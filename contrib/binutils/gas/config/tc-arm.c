begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* tc-arm.c -- Assemble for the ARM    Copyright (C) 1994, 95, 96, 97, 98, 1999, 2000 Free Software Foundation, Inc.    Contributed by Richard Earnshaw (rwe@pegasus.esprit.ec.org) 	Modified by David Taylor (dtaylor@armltd.co.uk)     This file is part of GAS, the GNU Assembler.     GAS is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     GAS is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with GAS; see the file COPYING.  If not, write to the Free    Software Foundation, 59 Temple Place - Suite 330, Boston, MA    02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_define
define|#
directive|define
name|NO_RELOC
value|0
end_define

begin_include
include|#
directive|include
file|"as.h"
end_include

begin_comment
comment|/* need TARGET_CPU */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"subsegs.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_include
include|#
directive|include
file|"symbols.h"
end_include

begin_include
include|#
directive|include
file|"listing.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|OBJ_ELF
end_ifdef

begin_include
include|#
directive|include
file|"elf/arm.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Types of processor to assemble for.  */
end_comment

begin_define
define|#
directive|define
name|ARM_1
value|0x00000001
end_define

begin_define
define|#
directive|define
name|ARM_2
value|0x00000002
end_define

begin_define
define|#
directive|define
name|ARM_3
value|0x00000004
end_define

begin_define
define|#
directive|define
name|ARM_250
value|ARM_3
end_define

begin_define
define|#
directive|define
name|ARM_6
value|0x00000008
end_define

begin_define
define|#
directive|define
name|ARM_7
value|ARM_6
end_define

begin_comment
comment|/* same core instruction set */
end_comment

begin_define
define|#
directive|define
name|ARM_8
value|ARM_6
end_define

begin_comment
comment|/* same core instruction set */
end_comment

begin_define
define|#
directive|define
name|ARM_9
value|ARM_6
end_define

begin_comment
comment|/* same core instruction set */
end_comment

begin_define
define|#
directive|define
name|ARM_CPU_MASK
value|0x0000000f
end_define

begin_comment
comment|/* The following bitmasks control CPU extensions (ARM7 onwards): */
end_comment

begin_define
define|#
directive|define
name|ARM_LONGMUL
value|0x00000010
end_define

begin_comment
comment|/* allow long multiplies */
end_comment

begin_define
define|#
directive|define
name|ARM_HALFWORD
value|0x00000020
end_define

begin_comment
comment|/* allow half word loads */
end_comment

begin_define
define|#
directive|define
name|ARM_THUMB
value|0x00000040
end_define

begin_comment
comment|/* allow BX instruction  */
end_comment

begin_define
define|#
directive|define
name|ARM_EXT_V5
value|0x00000080
end_define

begin_comment
comment|/* allow CLZ etc	 */
end_comment

begin_define
define|#
directive|define
name|ARM_EXT_V5E
value|0x00000200
end_define

begin_comment
comment|/* "El Segundo" 	 */
end_comment

begin_comment
comment|/* Architectures are the sum of the base and extensions.  */
end_comment

begin_define
define|#
directive|define
name|ARM_ARCH_V4
value|(ARM_7 | ARM_LONGMUL | ARM_HALFWORD)
end_define

begin_define
define|#
directive|define
name|ARM_ARCH_V4T
value|(ARM_ARCH_V4 | ARM_THUMB)
end_define

begin_define
define|#
directive|define
name|ARM_ARCH_V5
value|(ARM_ARCH_V4 | ARM_EXT_V5)
end_define

begin_define
define|#
directive|define
name|ARM_ARCH_V5T
value|(ARM_ARCH_V5 | ARM_THUMB)
end_define

begin_comment
comment|/* Some useful combinations:  */
end_comment

begin_define
define|#
directive|define
name|ARM_ANY
value|0x00ffffff
end_define

begin_define
define|#
directive|define
name|ARM_2UP
value|(ARM_ANY - ARM_1)
end_define

begin_define
define|#
directive|define
name|ARM_ALL
value|ARM_2UP
end_define

begin_comment
comment|/* Not arm1 only */
end_comment

begin_define
define|#
directive|define
name|ARM_3UP
value|0x00fffffc
end_define

begin_define
define|#
directive|define
name|ARM_6UP
value|0x00fffff8
end_define

begin_comment
comment|/* Includes ARM7 */
end_comment

begin_define
define|#
directive|define
name|FPU_CORE
value|0x80000000
end_define

begin_define
define|#
directive|define
name|FPU_FPA10
value|0x40000000
end_define

begin_define
define|#
directive|define
name|FPU_FPA11
value|0x40000000
end_define

begin_define
define|#
directive|define
name|FPU_NONE
value|0
end_define

begin_comment
comment|/* Some useful combinations  */
end_comment

begin_define
define|#
directive|define
name|FPU_ALL
value|0xff000000
end_define

begin_comment
comment|/* Note this is ~ARM_ANY */
end_comment

begin_define
define|#
directive|define
name|FPU_MEMMULTI
value|0x7f000000
end_define

begin_comment
comment|/* Not fpu_core */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|CPU_DEFAULT
end_ifndef

begin_if
if|#
directive|if
name|defined
name|__thumb__
end_if

begin_define
define|#
directive|define
name|CPU_DEFAULT
value|(ARM_ARCH_V4 | ARM_THUMB)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CPU_DEFAULT
value|ARM_ALL
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|FPU_DEFAULT
end_ifndef

begin_define
define|#
directive|define
name|FPU_DEFAULT
value|FPU_ALL
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|streq
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|(strcmp (a, b) == 0)
end_define

begin_define
define|#
directive|define
name|skip_whitespace
parameter_list|(
name|str
parameter_list|)
value|while (* (str) == ' ') ++ (str)
end_define

begin_decl_stmt
specifier|static
name|unsigned
name|long
name|cpu_variant
init|=
name|CPU_DEFAULT
operator||
name|FPU_DEFAULT
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|target_oabi
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|defined
name|OBJ_COFF
operator|||
name|defined
name|OBJ_ELF
end_if

begin_comment
comment|/* Flags stored in private area of BFD structure */
end_comment

begin_decl_stmt
specifier|static
name|boolean
name|uses_apcs_26
init|=
name|false
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|support_interwork
init|=
name|false
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|uses_apcs_float
init|=
name|false
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|pic_code
init|=
name|false
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* This array holds the chars that always start a comment.  If the    pre-processor is disabled, these aren't very useful.  */
end_comment

begin_decl_stmt
name|CONST
name|char
name|comment_chars
index|[]
init|=
literal|"@"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This array holds the chars that only start a comment at the beginning of    a line.  If the line seems to have the form '# 123 filename'    .line and .file directives will appear in the pre-processed output.  */
end_comment

begin_comment
comment|/* Note that input_file.c hand checks for '#' at the beginning of the    first line of the input file.  This is because the compiler outputs    #NO_APP at the beginning of its output.  */
end_comment

begin_comment
comment|/* Also note that comments like this one will always work.  */
end_comment

begin_decl_stmt
name|CONST
name|char
name|line_comment_chars
index|[]
init|=
literal|"#"
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|TE_LINUX
end_ifdef

begin_decl_stmt
name|CONST
name|char
name|line_separator_chars
index|[]
init|=
literal|";"
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
name|CONST
name|char
name|line_separator_chars
index|[]
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Chars that can be used to separate mant    from exp in floating point numbers.  */
end_comment

begin_decl_stmt
name|CONST
name|char
name|EXP_CHARS
index|[]
init|=
literal|"eE"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Chars that mean this number is a floating point constant */
end_comment

begin_comment
comment|/* As in 0f12.456 */
end_comment

begin_comment
comment|/* or    0d1.2345e12 */
end_comment

begin_decl_stmt
name|CONST
name|char
name|FLT_CHARS
index|[]
init|=
literal|"rRsSfFdDxXeEpP"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Prefix characters that indicate the start of an immediate    value.  */
end_comment

begin_define
define|#
directive|define
name|is_immediate_prefix
parameter_list|(
name|C
parameter_list|)
value|((C) == '#' || (C) == '$')
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|OBJ_ELF
end_ifdef

begin_decl_stmt
name|symbolS
modifier|*
name|GOT_symbol
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pre-defined "_GLOBAL_OFFSET_TABLE_" */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|CONST
name|int
name|md_reloc_size
init|=
literal|8
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Size of relocation record */
end_comment

begin_decl_stmt
specifier|static
name|int
name|thumb_mode
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 0: assemble for ARM, 1: assemble for Thumb, 				   2: assemble for Thumb even though target cpu 				   does not support thumb instructions.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|arm_fix
block|{
name|int
name|thumb_mode
decl_stmt|;
block|}
name|arm_fix_data
typedef|;
end_typedef

begin_struct
struct|struct
name|arm_it
block|{
name|CONST
name|char
modifier|*
name|error
decl_stmt|;
name|unsigned
name|long
name|instruction
decl_stmt|;
name|int
name|suffix
decl_stmt|;
name|int
name|size
decl_stmt|;
struct|struct
block|{
name|bfd_reloc_code_real_type
name|type
decl_stmt|;
name|expressionS
name|exp
decl_stmt|;
name|int
name|pc_rel
decl_stmt|;
block|}
name|reloc
struct|;
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|arm_it
name|inst
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|asm_shift
block|{
name|CONST
name|char
modifier|*
name|template
decl_stmt|;
name|unsigned
name|long
name|value
decl_stmt|;
block|}
struct|;
end_struct

begin_expr_stmt
specifier|static
name|CONST
expr|struct
name|asm_shift
name|shift
index|[]
operator|=
block|{
block|{
literal|"asl"
block|,
literal|0
block|}
block|,
block|{
literal|"lsl"
block|,
literal|0
block|}
block|,
block|{
literal|"lsr"
block|,
literal|0x00000020
block|}
block|,
block|{
literal|"asr"
block|,
literal|0x00000040
block|}
block|,
block|{
literal|"ror"
block|,
literal|0x00000060
block|}
block|,
block|{
literal|"rrx"
block|,
literal|0x00000060
block|}
block|,
block|{
literal|"ASL"
block|,
literal|0
block|}
block|,
block|{
literal|"LSL"
block|,
literal|0
block|}
block|,
block|{
literal|"LSR"
block|,
literal|0x00000020
block|}
block|,
block|{
literal|"ASR"
block|,
literal|0x00000040
block|}
block|,
block|{
literal|"ROR"
block|,
literal|0x00000060
block|}
block|,
block|{
literal|"RRX"
block|,
literal|0x00000060
block|}
block|}
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|NO_SHIFT_RESTRICT
value|1
end_define

begin_define
define|#
directive|define
name|SHIFT_RESTRICT
value|0
end_define

begin_define
define|#
directive|define
name|NUM_FLOAT_VALS
value|8
end_define

begin_decl_stmt
name|CONST
name|char
modifier|*
name|fp_const
index|[]
init|=
block|{
literal|"0.0"
block|,
literal|"1.0"
block|,
literal|"2.0"
block|,
literal|"3.0"
block|,
literal|"4.0"
block|,
literal|"5.0"
block|,
literal|"0.5"
block|,
literal|"10.0"
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of littlenums required to hold an extended precision number.  */
end_comment

begin_define
define|#
directive|define
name|MAX_LITTLENUMS
value|6
end_define

begin_decl_stmt
name|LITTLENUM_TYPE
name|fp_values
index|[
name|NUM_FLOAT_VALS
index|]
index|[
name|MAX_LITTLENUMS
index|]
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|FAIL
value|(-1)
end_define

begin_define
define|#
directive|define
name|SUCCESS
value|(0)
end_define

begin_define
define|#
directive|define
name|SUFF_S
value|1
end_define

begin_define
define|#
directive|define
name|SUFF_D
value|2
end_define

begin_define
define|#
directive|define
name|SUFF_E
value|3
end_define

begin_define
define|#
directive|define
name|SUFF_P
value|4
end_define

begin_define
define|#
directive|define
name|CP_T_X
value|0x00008000
end_define

begin_define
define|#
directive|define
name|CP_T_Y
value|0x00400000
end_define

begin_define
define|#
directive|define
name|CP_T_Pre
value|0x01000000
end_define

begin_define
define|#
directive|define
name|CP_T_UD
value|0x00800000
end_define

begin_define
define|#
directive|define
name|CP_T_WB
value|0x00200000
end_define

begin_define
define|#
directive|define
name|CONDS_BIT
value|(0x00100000)
end_define

begin_define
define|#
directive|define
name|LOAD_BIT
value|(0x00100000)
end_define

begin_define
define|#
directive|define
name|TRANS_BIT
value|(0x00200000)
end_define

begin_struct
struct|struct
name|asm_cond
block|{
name|CONST
name|char
modifier|*
name|template
decl_stmt|;
name|unsigned
name|long
name|value
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* This is to save a hash look-up in the common case.  */
end_comment

begin_define
define|#
directive|define
name|COND_ALWAYS
value|0xe0000000
end_define

begin_expr_stmt
specifier|static
name|CONST
expr|struct
name|asm_cond
name|conds
index|[]
operator|=
block|{
block|{
literal|"eq"
block|,
literal|0x00000000
block|}
block|,
block|{
literal|"ne"
block|,
literal|0x10000000
block|}
block|,
block|{
literal|"cs"
block|,
literal|0x20000000
block|}
block|,
block|{
literal|"hs"
block|,
literal|0x20000000
block|}
block|,
block|{
literal|"cc"
block|,
literal|0x30000000
block|}
block|,
block|{
literal|"ul"
block|,
literal|0x30000000
block|}
block|,
block|{
literal|"lo"
block|,
literal|0x30000000
block|}
block|,
block|{
literal|"mi"
block|,
literal|0x40000000
block|}
block|,
block|{
literal|"pl"
block|,
literal|0x50000000
block|}
block|,
block|{
literal|"vs"
block|,
literal|0x60000000
block|}
block|,
block|{
literal|"vc"
block|,
literal|0x70000000
block|}
block|,
block|{
literal|"hi"
block|,
literal|0x80000000
block|}
block|,
block|{
literal|"ls"
block|,
literal|0x90000000
block|}
block|,
block|{
literal|"ge"
block|,
literal|0xa0000000
block|}
block|,
block|{
literal|"lt"
block|,
literal|0xb0000000
block|}
block|,
block|{
literal|"gt"
block|,
literal|0xc0000000
block|}
block|,
block|{
literal|"le"
block|,
literal|0xd0000000
block|}
block|,
block|{
literal|"al"
block|,
literal|0xe0000000
block|}
block|,
block|{
literal|"nv"
block|,
literal|0xf0000000
block|}
block|}
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Warning: If the top bit of the set_bits is set, then the standard    instruction bitmask is ignored, and the new bitmask is taken from    the set_bits:  */
end_comment

begin_struct
struct|struct
name|asm_flg
block|{
name|CONST
name|char
modifier|*
name|template
decl_stmt|;
comment|/* Basic flag string */
name|unsigned
name|long
name|set_bits
decl_stmt|;
comment|/* Bits to set */
block|}
struct|;
end_struct

begin_expr_stmt
specifier|static
name|CONST
expr|struct
name|asm_flg
name|s_flag
index|[]
operator|=
block|{
block|{
literal|"s"
block|,
name|CONDS_BIT
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|}
block|}
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|CONST
expr|struct
name|asm_flg
name|ldr_flags
index|[]
operator|=
block|{
block|{
literal|"b"
block|,
literal|0x00400000
block|}
block|,
block|{
literal|"t"
block|,
name|TRANS_BIT
block|}
block|,
block|{
literal|"bt"
block|,
literal|0x00400000
operator||
name|TRANS_BIT
block|}
block|,
block|{
literal|"h"
block|,
literal|0x801000b0
block|}
block|,
block|{
literal|"sh"
block|,
literal|0x801000f0
block|}
block|,
block|{
literal|"sb"
block|,
literal|0x801000d0
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|}
block|}
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|CONST
expr|struct
name|asm_flg
name|str_flags
index|[]
operator|=
block|{
block|{
literal|"b"
block|,
literal|0x00400000
block|}
block|,
block|{
literal|"t"
block|,
name|TRANS_BIT
block|}
block|,
block|{
literal|"bt"
block|,
literal|0x00400000
operator||
name|TRANS_BIT
block|}
block|,
block|{
literal|"h"
block|,
literal|0x800000b0
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|}
block|}
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|CONST
expr|struct
name|asm_flg
name|byte_flag
index|[]
operator|=
block|{
block|{
literal|"b"
block|,
literal|0x00400000
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|}
block|}
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|CONST
expr|struct
name|asm_flg
name|cmp_flags
index|[]
operator|=
block|{
block|{
literal|"s"
block|,
name|CONDS_BIT
block|}
block|,
block|{
literal|"p"
block|,
literal|0x0010f000
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|}
block|}
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|CONST
expr|struct
name|asm_flg
name|ldm_flags
index|[]
operator|=
block|{
block|{
literal|"ed"
block|,
literal|0x01800000
block|}
block|,
block|{
literal|"fd"
block|,
literal|0x00800000
block|}
block|,
block|{
literal|"ea"
block|,
literal|0x01000000
block|}
block|,
block|{
literal|"fa"
block|,
literal|0x08000000
block|}
block|,
block|{
literal|"ib"
block|,
literal|0x01800000
block|}
block|,
block|{
literal|"ia"
block|,
literal|0x00800000
block|}
block|,
block|{
literal|"db"
block|,
literal|0x01000000
block|}
block|,
block|{
literal|"da"
block|,
literal|0x08000000
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|}
block|}
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|CONST
expr|struct
name|asm_flg
name|stm_flags
index|[]
operator|=
block|{
block|{
literal|"ed"
block|,
literal|0x08000000
block|}
block|,
block|{
literal|"fd"
block|,
literal|0x01000000
block|}
block|,
block|{
literal|"ea"
block|,
literal|0x00800000
block|}
block|,
block|{
literal|"fa"
block|,
literal|0x01800000
block|}
block|,
block|{
literal|"ib"
block|,
literal|0x01800000
block|}
block|,
block|{
literal|"ia"
block|,
literal|0x00800000
block|}
block|,
block|{
literal|"db"
block|,
literal|0x01000000
block|}
block|,
block|{
literal|"da"
block|,
literal|0x08000000
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|}
block|}
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|CONST
expr|struct
name|asm_flg
name|lfm_flags
index|[]
operator|=
block|{
block|{
literal|"fd"
block|,
literal|0x00800000
block|}
block|,
block|{
literal|"ea"
block|,
literal|0x01000000
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|}
block|}
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|CONST
expr|struct
name|asm_flg
name|sfm_flags
index|[]
operator|=
block|{
block|{
literal|"fd"
block|,
literal|0x01000000
block|}
block|,
block|{
literal|"ea"
block|,
literal|0x00800000
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|}
block|}
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|CONST
expr|struct
name|asm_flg
name|round_flags
index|[]
operator|=
block|{
block|{
literal|"p"
block|,
literal|0x00000020
block|}
block|,
block|{
literal|"m"
block|,
literal|0x00000040
block|}
block|,
block|{
literal|"z"
block|,
literal|0x00000060
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|}
block|}
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* The implementation of the FIX instruction is broken on some assemblers,    in that it accepts a precision specifier as well as a rounding specifier,    despite the fact that this is meaningless.  To be more compatible, we    accept it as well, though of course it does not set any bits.  */
end_comment

begin_expr_stmt
specifier|static
name|CONST
expr|struct
name|asm_flg
name|fix_flags
index|[]
operator|=
block|{
block|{
literal|"p"
block|,
literal|0x00000020
block|}
block|,
block|{
literal|"m"
block|,
literal|0x00000040
block|}
block|,
block|{
literal|"z"
block|,
literal|0x00000060
block|}
block|,
block|{
literal|"sp"
block|,
literal|0x00000020
block|}
block|,
block|{
literal|"sm"
block|,
literal|0x00000040
block|}
block|,
block|{
literal|"sz"
block|,
literal|0x00000060
block|}
block|,
block|{
literal|"dp"
block|,
literal|0x00000020
block|}
block|,
block|{
literal|"dm"
block|,
literal|0x00000040
block|}
block|,
block|{
literal|"dz"
block|,
literal|0x00000060
block|}
block|,
block|{
literal|"ep"
block|,
literal|0x00000020
block|}
block|,
block|{
literal|"em"
block|,
literal|0x00000040
block|}
block|,
block|{
literal|"ez"
block|,
literal|0x00000060
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|}
block|}
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|CONST
expr|struct
name|asm_flg
name|except_flag
index|[]
operator|=
block|{
block|{
literal|"e"
block|,
literal|0x00400000
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|}
block|}
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|CONST
expr|struct
name|asm_flg
name|cplong_flag
index|[]
operator|=
block|{
block|{
literal|"l"
block|,
literal|0x00400000
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|}
block|}
expr_stmt|;
end_expr_stmt

begin_struct
struct|struct
name|asm_psr
block|{
name|CONST
name|char
modifier|*
name|template
decl_stmt|;
name|boolean
name|cpsr
decl_stmt|;
name|unsigned
name|long
name|field
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|SPSR_BIT
value|(1<< 22)
end_define

begin_comment
comment|/* The bit that distnguishes CPSR and SPSR.  */
end_comment

begin_define
define|#
directive|define
name|PSR_SHIFT
value|16
end_define

begin_comment
comment|/* How many bits to shift the PSR_xxx bits up by.  */
end_comment

begin_define
define|#
directive|define
name|PSR_c
value|(1<< 0)
end_define

begin_define
define|#
directive|define
name|PSR_x
value|(1<< 1)
end_define

begin_define
define|#
directive|define
name|PSR_s
value|(1<< 2)
end_define

begin_define
define|#
directive|define
name|PSR_f
value|(1<< 3)
end_define

begin_expr_stmt
specifier|static
name|CONST
expr|struct
name|asm_psr
name|psrs
index|[]
operator|=
block|{
block|{
literal|"CPSR"
block|,
name|true
block|,
name|PSR_c
operator||
name|PSR_f
block|}
block|,
block|{
literal|"CPSR_all"
block|,
name|true
block|,
name|PSR_c
operator||
name|PSR_f
block|}
block|,
block|{
literal|"SPSR"
block|,
name|false
block|,
name|PSR_c
operator||
name|PSR_f
block|}
block|,
block|{
literal|"SPSR_all"
block|,
name|false
block|,
name|PSR_c
operator||
name|PSR_f
block|}
block|,
block|{
literal|"CPSR_flg"
block|,
name|true
block|,
name|PSR_f
block|}
block|,
block|{
literal|"CPSR_f"
block|,
name|true
block|,
name|PSR_f
block|}
block|,
block|{
literal|"SPSR_flg"
block|,
name|false
block|,
name|PSR_f
block|}
block|,
block|{
literal|"SPSR_f"
block|,
name|false
block|,
name|PSR_f
block|}
block|,
block|{
literal|"CPSR_c"
block|,
name|true
block|,
name|PSR_c
block|}
block|,
block|{
literal|"CPSR_ctl"
block|,
name|true
block|,
name|PSR_c
block|}
block|,
block|{
literal|"SPSR_c"
block|,
name|false
block|,
name|PSR_c
block|}
block|,
block|{
literal|"SPSR_ctl"
block|,
name|false
block|,
name|PSR_c
block|}
block|,
block|{
literal|"CPSR_x"
block|,
name|true
block|,
name|PSR_x
block|}
block|,
block|{
literal|"CPSR_s"
block|,
name|true
block|,
name|PSR_s
block|}
block|,
block|{
literal|"SPSR_x"
block|,
name|false
block|,
name|PSR_x
block|}
block|,
block|{
literal|"SPSR_s"
block|,
name|false
block|,
name|PSR_s
block|}
block|,
comment|/* For backwards compatability with older toolchain we also      support lower case versions of some of these flags.  */
block|{
literal|"cpsr"
block|,
name|true
block|,
name|PSR_c
operator||
name|PSR_f
block|}
block|,
block|{
literal|"cpsr_all"
block|,
name|true
block|,
name|PSR_c
operator||
name|PSR_f
block|}
block|,
block|{
literal|"spsr"
block|,
name|false
block|,
name|PSR_c
operator||
name|PSR_f
block|}
block|,
block|{
literal|"spsr_all"
block|,
name|false
block|,
name|PSR_c
operator||
name|PSR_f
block|}
block|,
block|{
literal|"cpsr_flg"
block|,
name|true
block|,
name|PSR_f
block|}
block|,
block|{
literal|"cpsr_f"
block|,
name|true
block|,
name|PSR_f
block|}
block|,
block|{
literal|"spsr_flg"
block|,
name|false
block|,
name|PSR_f
block|}
block|,
block|{
literal|"spsr_f"
block|,
name|false
block|,
name|PSR_f
block|}
block|,
block|{
literal|"cpsr_c"
block|,
name|true
block|,
name|PSR_c
block|}
block|,
block|{
literal|"cpsr_ctl"
block|,
name|true
block|,
name|PSR_c
block|}
block|,
block|{
literal|"spsr_c"
block|,
name|false
block|,
name|PSR_c
block|}
block|,
block|{
literal|"spsr_ctl"
block|,
name|false
block|,
name|PSR_c
block|}
block|}
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Functions called by parser.  */
end_comment

begin_comment
comment|/* ARM instructions */
end_comment

begin_decl_stmt
specifier|static
name|void
name|do_arit
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|unsigned
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_cmp
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|unsigned
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_mov
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|unsigned
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_ldst
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|unsigned
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_ldmstm
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|unsigned
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_branch
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|unsigned
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_swi
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|unsigned
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pseudo Op codes */
end_comment

begin_decl_stmt
specifier|static
name|void
name|do_adr
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|unsigned
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_adrl
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|unsigned
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_nop
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|unsigned
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ARM 2 */
end_comment

begin_decl_stmt
specifier|static
name|void
name|do_mul
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|unsigned
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_mla
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|unsigned
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ARM 3 */
end_comment

begin_decl_stmt
specifier|static
name|void
name|do_swap
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|unsigned
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ARM 6 */
end_comment

begin_decl_stmt
specifier|static
name|void
name|do_msr
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|unsigned
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_mrs
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|unsigned
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ARM 7M */
end_comment

begin_decl_stmt
specifier|static
name|void
name|do_mull
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|unsigned
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ARM THUMB */
end_comment

begin_decl_stmt
specifier|static
name|void
name|do_bx
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|unsigned
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Coprocessor Instructions */
end_comment

begin_decl_stmt
specifier|static
name|void
name|do_cdp
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|unsigned
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_lstc
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|unsigned
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_co_reg
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|unsigned
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_fp_ctrl
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|unsigned
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_fp_ldst
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|unsigned
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_fp_ldmstm
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|unsigned
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_fp_dyadic
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|unsigned
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_fp_monadic
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|unsigned
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_fp_cmp
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|unsigned
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_fp_from_reg
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|unsigned
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_fp_to_reg
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|unsigned
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|fix_new_arm
name|PARAMS
argument_list|(
operator|(
name|fragS
operator|*
operator|,
name|int
operator|,
name|short
operator|,
name|expressionS
operator|*
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|arm_reg_parse
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|static
name|CONST
expr|struct
name|asm_psr
operator|*
name|arm_psr_parse
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|void
name|symbol_locate
name|PARAMS
argument_list|(
operator|(
name|symbolS
operator|*
operator|,
name|CONST
name|char
operator|*
operator|,
name|segT
operator|,
name|valueT
operator|,
name|fragS
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|add_to_lit_pool
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|validate_immediate
name|PARAMS
argument_list|(
operator|(
name|unsigned
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|validate_immediate_twopart
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|int
operator|,
name|unsigned
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|validate_offset_imm
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|opcode_select
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|end_of_line
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|reg_required_here
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|psr_required_here
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|co_proc_number
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|cp_opc_expr
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|cp_reg_required_here
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|fp_reg_required_here
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|cp_address_offset
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|cp_address_required_here
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|my_get_float_expression
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|skip_past_comma
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|walk_no_bignums
name|PARAMS
argument_list|(
operator|(
name|symbolS
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|negate_data_op
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|long
operator|*
operator|,
name|unsigned
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|data_op2
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|fp_op2
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|reg_list
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|thumb_load_store
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|decode_shift
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ldst_extend
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|thumb_add_sub
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|insert_reg
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|thumb_shift
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|thumb_mov_compare
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|set_constant_flonums
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|valueT
name|md_chars_to_number
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|insert_reg_alias
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_inst
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|OBJ_ELF
end_ifdef

begin_decl_stmt
specifier|static
name|bfd_reloc_code_real_type
name|arm_parse_reloc
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ARM instructions take 4bytes in the object file, Thumb instructions    take 2:  */
end_comment

begin_define
define|#
directive|define
name|INSN_SIZE
value|4
end_define

begin_comment
comment|/* LONGEST_INST is the longest basic instruction name without conditions or     flags.  ARM7M has 4 of length 5.  */
end_comment

begin_define
define|#
directive|define
name|LONGEST_INST
value|5
end_define

begin_struct
struct|struct
name|asm_opcode
block|{
name|CONST
name|char
modifier|*
name|template
decl_stmt|;
comment|/* Basic string to match */
name|unsigned
name|long
name|value
decl_stmt|;
comment|/* Basic instruction code */
comment|/* Compulsory suffix that must follow conds. If "", then the      instruction is not conditional and must have no suffix. */
name|CONST
name|char
modifier|*
name|comp_suffix
decl_stmt|;
name|CONST
name|struct
name|asm_flg
modifier|*
name|flags
decl_stmt|;
comment|/* Bits to toggle if flag 'n' set */
name|unsigned
name|long
name|variants
decl_stmt|;
comment|/* Which CPU variants this exists for */
comment|/* Function to call to parse args */
name|void
argument_list|(
argument|*                parms
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|unsigned
name|long
operator|)
argument_list|)
expr_stmt|;
block|}
struct|;
end_struct

begin_expr_stmt
specifier|static
name|CONST
expr|struct
name|asm_opcode
name|insns
index|[]
operator|=
block|{
comment|/* ARM Instructions */
block|{
literal|"and"
block|,
literal|0x00000000
block|,
name|NULL
block|,
name|s_flag
block|,
name|ARM_ANY
block|,
name|do_arit
block|}
block|,
block|{
literal|"eor"
block|,
literal|0x00200000
block|,
name|NULL
block|,
name|s_flag
block|,
name|ARM_ANY
block|,
name|do_arit
block|}
block|,
block|{
literal|"sub"
block|,
literal|0x00400000
block|,
name|NULL
block|,
name|s_flag
block|,
name|ARM_ANY
block|,
name|do_arit
block|}
block|,
block|{
literal|"rsb"
block|,
literal|0x00600000
block|,
name|NULL
block|,
name|s_flag
block|,
name|ARM_ANY
block|,
name|do_arit
block|}
block|,
block|{
literal|"add"
block|,
literal|0x00800000
block|,
name|NULL
block|,
name|s_flag
block|,
name|ARM_ANY
block|,
name|do_arit
block|}
block|,
block|{
literal|"adc"
block|,
literal|0x00a00000
block|,
name|NULL
block|,
name|s_flag
block|,
name|ARM_ANY
block|,
name|do_arit
block|}
block|,
block|{
literal|"sbc"
block|,
literal|0x00c00000
block|,
name|NULL
block|,
name|s_flag
block|,
name|ARM_ANY
block|,
name|do_arit
block|}
block|,
block|{
literal|"rsc"
block|,
literal|0x00e00000
block|,
name|NULL
block|,
name|s_flag
block|,
name|ARM_ANY
block|,
name|do_arit
block|}
block|,
block|{
literal|"orr"
block|,
literal|0x01800000
block|,
name|NULL
block|,
name|s_flag
block|,
name|ARM_ANY
block|,
name|do_arit
block|}
block|,
block|{
literal|"bic"
block|,
literal|0x01c00000
block|,
name|NULL
block|,
name|s_flag
block|,
name|ARM_ANY
block|,
name|do_arit
block|}
block|,
block|{
literal|"tst"
block|,
literal|0x01000000
block|,
name|NULL
block|,
name|cmp_flags
block|,
name|ARM_ANY
block|,
name|do_cmp
block|}
block|,
block|{
literal|"teq"
block|,
literal|0x01200000
block|,
name|NULL
block|,
name|cmp_flags
block|,
name|ARM_ANY
block|,
name|do_cmp
block|}
block|,
block|{
literal|"cmp"
block|,
literal|0x01400000
block|,
name|NULL
block|,
name|cmp_flags
block|,
name|ARM_ANY
block|,
name|do_cmp
block|}
block|,
block|{
literal|"cmn"
block|,
literal|0x01600000
block|,
name|NULL
block|,
name|cmp_flags
block|,
name|ARM_ANY
block|,
name|do_cmp
block|}
block|,
block|{
literal|"mov"
block|,
literal|0x01a00000
block|,
name|NULL
block|,
name|s_flag
block|,
name|ARM_ANY
block|,
name|do_mov
block|}
block|,
block|{
literal|"mvn"
block|,
literal|0x01e00000
block|,
name|NULL
block|,
name|s_flag
block|,
name|ARM_ANY
block|,
name|do_mov
block|}
block|,
block|{
literal|"str"
block|,
literal|0x04000000
block|,
name|NULL
block|,
name|str_flags
block|,
name|ARM_ANY
block|,
name|do_ldst
block|}
block|,
block|{
literal|"ldr"
block|,
literal|0x04100000
block|,
name|NULL
block|,
name|ldr_flags
block|,
name|ARM_ANY
block|,
name|do_ldst
block|}
block|,
block|{
literal|"stm"
block|,
literal|0x08000000
block|,
name|NULL
block|,
name|stm_flags
block|,
name|ARM_ANY
block|,
name|do_ldmstm
block|}
block|,
block|{
literal|"ldm"
block|,
literal|0x08100000
block|,
name|NULL
block|,
name|ldm_flags
block|,
name|ARM_ANY
block|,
name|do_ldmstm
block|}
block|,
block|{
literal|"swi"
block|,
literal|0x0f000000
block|,
name|NULL
block|,
name|NULL
block|,
name|ARM_ANY
block|,
name|do_swi
block|}
block|,
ifdef|#
directive|ifdef
name|TE_WINCE
block|{
literal|"bl"
block|,
literal|0x0b000000
block|,
name|NULL
block|,
name|NULL
block|,
name|ARM_ANY
block|,
name|do_branch
block|}
block|,
block|{
literal|"b"
block|,
literal|0x0a000000
block|,
name|NULL
block|,
name|NULL
block|,
name|ARM_ANY
block|,
name|do_branch
block|}
block|,
else|#
directive|else
block|{
literal|"bl"
block|,
literal|0x0bfffffe
block|,
name|NULL
block|,
name|NULL
block|,
name|ARM_ANY
block|,
name|do_branch
block|}
block|,
block|{
literal|"b"
block|,
literal|0x0afffffe
block|,
name|NULL
block|,
name|NULL
block|,
name|ARM_ANY
block|,
name|do_branch
block|}
block|,
endif|#
directive|endif
comment|/* Pseudo ops */
block|{
literal|"adr"
block|,
literal|0x028f0000
block|,
name|NULL
block|,
name|NULL
block|,
name|ARM_ANY
block|,
name|do_adr
block|}
block|,
block|{
literal|"adrl"
block|,
literal|0x028f0000
block|,
name|NULL
block|,
name|NULL
block|,
name|ARM_ANY
block|,
name|do_adrl
block|}
block|,
block|{
literal|"nop"
block|,
literal|0x01a00000
block|,
name|NULL
block|,
name|NULL
block|,
name|ARM_ANY
block|,
name|do_nop
block|}
block|,
comment|/* ARM 2 multiplies */
block|{
literal|"mul"
block|,
literal|0x00000090
block|,
name|NULL
block|,
name|s_flag
block|,
name|ARM_2UP
block|,
name|do_mul
block|}
block|,
block|{
literal|"mla"
block|,
literal|0x00200090
block|,
name|NULL
block|,
name|s_flag
block|,
name|ARM_2UP
block|,
name|do_mla
block|}
block|,
comment|/* ARM 3 - swp instructions */
block|{
literal|"swp"
block|,
literal|0x01000090
block|,
name|NULL
block|,
name|byte_flag
block|,
name|ARM_3UP
block|,
name|do_swap
block|}
block|,
comment|/* ARM 6 Coprocessor instructions */
block|{
literal|"mrs"
block|,
literal|0x010f0000
block|,
name|NULL
block|,
name|NULL
block|,
name|ARM_6UP
block|,
name|do_mrs
block|}
block|,
block|{
literal|"msr"
block|,
literal|0x0120f000
block|,
name|NULL
block|,
name|NULL
block|,
name|ARM_6UP
block|,
name|do_msr
block|}
block|,
comment|/* ScottB: our code uses 0x0128f000 for msr.    NickC:  but this is wrong because the bits 16 through 19 are            handled by the PSR_xxx defines above.  */
comment|/* ARM 7M long multiplies - need signed/unsigned flags! */
block|{
literal|"smull"
block|,
literal|0x00c00090
block|,
name|NULL
block|,
name|s_flag
block|,
name|ARM_LONGMUL
block|,
name|do_mull
block|}
block|,
block|{
literal|"umull"
block|,
literal|0x00800090
block|,
name|NULL
block|,
name|s_flag
block|,
name|ARM_LONGMUL
block|,
name|do_mull
block|}
block|,
block|{
literal|"smlal"
block|,
literal|0x00e00090
block|,
name|NULL
block|,
name|s_flag
block|,
name|ARM_LONGMUL
block|,
name|do_mull
block|}
block|,
block|{
literal|"umlal"
block|,
literal|0x00a00090
block|,
name|NULL
block|,
name|s_flag
block|,
name|ARM_LONGMUL
block|,
name|do_mull
block|}
block|,
comment|/* ARM THUMB interworking */
block|{
literal|"bx"
block|,
literal|0x012fff10
block|,
name|NULL
block|,
name|NULL
block|,
name|ARM_THUMB
block|,
name|do_bx
block|}
block|,
comment|/* Floating point instructions */
block|{
literal|"wfs"
block|,
literal|0x0e200110
block|,
name|NULL
block|,
name|NULL
block|,
name|FPU_ALL
block|,
name|do_fp_ctrl
block|}
block|,
block|{
literal|"rfs"
block|,
literal|0x0e300110
block|,
name|NULL
block|,
name|NULL
block|,
name|FPU_ALL
block|,
name|do_fp_ctrl
block|}
block|,
block|{
literal|"wfc"
block|,
literal|0x0e400110
block|,
name|NULL
block|,
name|NULL
block|,
name|FPU_ALL
block|,
name|do_fp_ctrl
block|}
block|,
block|{
literal|"rfc"
block|,
literal|0x0e500110
block|,
name|NULL
block|,
name|NULL
block|,
name|FPU_ALL
block|,
name|do_fp_ctrl
block|}
block|,
block|{
literal|"ldf"
block|,
literal|0x0c100100
block|,
literal|"sdep"
block|,
name|NULL
block|,
name|FPU_ALL
block|,
name|do_fp_ldst
block|}
block|,
block|{
literal|"stf"
block|,
literal|0x0c000100
block|,
literal|"sdep"
block|,
name|NULL
block|,
name|FPU_ALL
block|,
name|do_fp_ldst
block|}
block|,
block|{
literal|"lfm"
block|,
literal|0x0c100200
block|,
name|NULL
block|,
name|lfm_flags
block|,
name|FPU_MEMMULTI
block|,
name|do_fp_ldmstm
block|}
block|,
block|{
literal|"sfm"
block|,
literal|0x0c000200
block|,
name|NULL
block|,
name|sfm_flags
block|,
name|FPU_MEMMULTI
block|,
name|do_fp_ldmstm
block|}
block|,
block|{
literal|"mvf"
block|,
literal|0x0e008100
block|,
literal|"sde"
block|,
name|round_flags
block|,
name|FPU_ALL
block|,
name|do_fp_monadic
block|}
block|,
block|{
literal|"mnf"
block|,
literal|0x0e108100
block|,
literal|"sde"
block|,
name|round_flags
block|,
name|FPU_ALL
block|,
name|do_fp_monadic
block|}
block|,
block|{
literal|"abs"
block|,
literal|0x0e208100
block|,
literal|"sde"
block|,
name|round_flags
block|,
name|FPU_ALL
block|,
name|do_fp_monadic
block|}
block|,
block|{
literal|"rnd"
block|,
literal|0x0e308100
block|,
literal|"sde"
block|,
name|round_flags
block|,
name|FPU_ALL
block|,
name|do_fp_monadic
block|}
block|,
block|{
literal|"sqt"
block|,
literal|0x0e408100
block|,
literal|"sde"
block|,
name|round_flags
block|,
name|FPU_ALL
block|,
name|do_fp_monadic
block|}
block|,
block|{
literal|"log"
block|,
literal|0x0e508100
block|,
literal|"sde"
block|,
name|round_flags
block|,
name|FPU_ALL
block|,
name|do_fp_monadic
block|}
block|,
block|{
literal|"lgn"
block|,
literal|0x0e608100
block|,
literal|"sde"
block|,
name|round_flags
block|,
name|FPU_ALL
block|,
name|do_fp_monadic
block|}
block|,
block|{
literal|"exp"
block|,
literal|0x0e708100
block|,
literal|"sde"
block|,
name|round_flags
block|,
name|FPU_ALL
block|,
name|do_fp_monadic
block|}
block|,
block|{
literal|"sin"
block|,
literal|0x0e808100
block|,
literal|"sde"
block|,
name|round_flags
block|,
name|FPU_ALL
block|,
name|do_fp_monadic
block|}
block|,
block|{
literal|"cos"
block|,
literal|0x0e908100
block|,
literal|"sde"
block|,
name|round_flags
block|,
name|FPU_ALL
block|,
name|do_fp_monadic
block|}
block|,
block|{
literal|"tan"
block|,
literal|0x0ea08100
block|,
literal|"sde"
block|,
name|round_flags
block|,
name|FPU_ALL
block|,
name|do_fp_monadic
block|}
block|,
block|{
literal|"asn"
block|,
literal|0x0eb08100
block|,
literal|"sde"
block|,
name|round_flags
block|,
name|FPU_ALL
block|,
name|do_fp_monadic
block|}
block|,
block|{
literal|"acs"
block|,
literal|0x0ec08100
block|,
literal|"sde"
block|,
name|round_flags
block|,
name|FPU_ALL
block|,
name|do_fp_monadic
block|}
block|,
block|{
literal|"atn"
block|,
literal|0x0ed08100
block|,
literal|"sde"
block|,
name|round_flags
block|,
name|FPU_ALL
block|,
name|do_fp_monadic
block|}
block|,
block|{
literal|"urd"
block|,
literal|0x0ee08100
block|,
literal|"sde"
block|,
name|round_flags
block|,
name|FPU_ALL
block|,
name|do_fp_monadic
block|}
block|,
block|{
literal|"nrm"
block|,
literal|0x0ef08100
block|,
literal|"sde"
block|,
name|round_flags
block|,
name|FPU_ALL
block|,
name|do_fp_monadic
block|}
block|,
block|{
literal|"adf"
block|,
literal|0x0e000100
block|,
literal|"sde"
block|,
name|round_flags
block|,
name|FPU_ALL
block|,
name|do_fp_dyadic
block|}
block|,
block|{
literal|"suf"
block|,
literal|0x0e200100
block|,
literal|"sde"
block|,
name|round_flags
block|,
name|FPU_ALL
block|,
name|do_fp_dyadic
block|}
block|,
block|{
literal|"rsf"
block|,
literal|0x0e300100
block|,
literal|"sde"
block|,
name|round_flags
block|,
name|FPU_ALL
block|,
name|do_fp_dyadic
block|}
block|,
block|{
literal|"muf"
block|,
literal|0x0e100100
block|,
literal|"sde"
block|,
name|round_flags
block|,
name|FPU_ALL
block|,
name|do_fp_dyadic
block|}
block|,
block|{
literal|"dvf"
block|,
literal|0x0e400100
block|,
literal|"sde"
block|,
name|round_flags
block|,
name|FPU_ALL
block|,
name|do_fp_dyadic
block|}
block|,
block|{
literal|"rdf"
block|,
literal|0x0e500100
block|,
literal|"sde"
block|,
name|round_flags
block|,
name|FPU_ALL
block|,
name|do_fp_dyadic
block|}
block|,
block|{
literal|"pow"
block|,
literal|0x0e600100
block|,
literal|"sde"
block|,
name|round_flags
block|,
name|FPU_ALL
block|,
name|do_fp_dyadic
block|}
block|,
block|{
literal|"rpw"
block|,
literal|0x0e700100
block|,
literal|"sde"
block|,
name|round_flags
block|,
name|FPU_ALL
block|,
name|do_fp_dyadic
block|}
block|,
block|{
literal|"rmf"
block|,
literal|0x0e800100
block|,
literal|"sde"
block|,
name|round_flags
block|,
name|FPU_ALL
block|,
name|do_fp_dyadic
block|}
block|,
block|{
literal|"fml"
block|,
literal|0x0e900100
block|,
literal|"sde"
block|,
name|round_flags
block|,
name|FPU_ALL
block|,
name|do_fp_dyadic
block|}
block|,
block|{
literal|"fdv"
block|,
literal|0x0ea00100
block|,
literal|"sde"
block|,
name|round_flags
block|,
name|FPU_ALL
block|,
name|do_fp_dyadic
block|}
block|,
block|{
literal|"frd"
block|,
literal|0x0eb00100
block|,
literal|"sde"
block|,
name|round_flags
block|,
name|FPU_ALL
block|,
name|do_fp_dyadic
block|}
block|,
block|{
literal|"pol"
block|,
literal|0x0ec00100
block|,
literal|"sde"
block|,
name|round_flags
block|,
name|FPU_ALL
block|,
name|do_fp_dyadic
block|}
block|,
block|{
literal|"cmf"
block|,
literal|0x0e90f110
block|,
name|NULL
block|,
name|except_flag
block|,
name|FPU_ALL
block|,
name|do_fp_cmp
block|}
block|,
block|{
literal|"cnf"
block|,
literal|0x0eb0f110
block|,
name|NULL
block|,
name|except_flag
block|,
name|FPU_ALL
block|,
name|do_fp_cmp
block|}
block|,
comment|/* The FPA10 data sheet suggests that the 'E' of cmfe/cnfe should not    be an optional suffix, but part of the instruction.  To be compatible,    we accept either.  */
block|{
literal|"cmfe"
block|,
literal|0x0ed0f110
block|,
name|NULL
block|,
name|NULL
block|,
name|FPU_ALL
block|,
name|do_fp_cmp
block|}
block|,
block|{
literal|"cnfe"
block|,
literal|0x0ef0f110
block|,
name|NULL
block|,
name|NULL
block|,
name|FPU_ALL
block|,
name|do_fp_cmp
block|}
block|,
block|{
literal|"flt"
block|,
literal|0x0e000110
block|,
literal|"sde"
block|,
name|round_flags
block|,
name|FPU_ALL
block|,
name|do_fp_from_reg
block|}
block|,
block|{
literal|"fix"
block|,
literal|0x0e100110
block|,
name|NULL
block|,
name|fix_flags
block|,
name|FPU_ALL
block|,
name|do_fp_to_reg
block|}
block|,
comment|/* Generic copressor instructions.  */
block|{
literal|"cdp"
block|,
literal|0x0e000000
block|,
name|NULL
block|,
name|NULL
block|,
name|ARM_2UP
block|,
name|do_cdp
block|}
block|,
block|{
literal|"ldc"
block|,
literal|0x0c100000
block|,
name|NULL
block|,
name|cplong_flag
block|,
name|ARM_2UP
block|,
name|do_lstc
block|}
block|,
block|{
literal|"stc"
block|,
literal|0x0c000000
block|,
name|NULL
block|,
name|cplong_flag
block|,
name|ARM_2UP
block|,
name|do_lstc
block|}
block|,
block|{
literal|"mcr"
block|,
literal|0x0e000010
block|,
name|NULL
block|,
name|NULL
block|,
name|ARM_2UP
block|,
name|do_co_reg
block|}
block|,
block|{
literal|"mrc"
block|,
literal|0x0e100010
block|,
name|NULL
block|,
name|NULL
block|,
name|ARM_2UP
block|,
name|do_co_reg
block|}
block|, }
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Defines for various bits that we will want to toggle.  */
end_comment

begin_define
define|#
directive|define
name|INST_IMMEDIATE
value|0x02000000
end_define

begin_define
define|#
directive|define
name|OFFSET_REG
value|0x02000000
end_define

begin_define
define|#
directive|define
name|HWOFFSET_IMM
value|0x00400000
end_define

begin_define
define|#
directive|define
name|SHIFT_BY_REG
value|0x00000010
end_define

begin_define
define|#
directive|define
name|PRE_INDEX
value|0x01000000
end_define

begin_define
define|#
directive|define
name|INDEX_UP
value|0x00800000
end_define

begin_define
define|#
directive|define
name|WRITE_BACK
value|0x00200000
end_define

begin_define
define|#
directive|define
name|LDM_TYPE_2_OR_3
value|0x00400000
end_define

begin_define
define|#
directive|define
name|LITERAL_MASK
value|0xf000f000
end_define

begin_define
define|#
directive|define
name|COND_MASK
value|0xf0000000
end_define

begin_define
define|#
directive|define
name|OPCODE_MASK
value|0xfe1fffff
end_define

begin_define
define|#
directive|define
name|DATA_OP_SHIFT
value|21
end_define

begin_comment
comment|/* Codes to distinguish the arithmetic instructions.  */
end_comment

begin_define
define|#
directive|define
name|OPCODE_AND
value|0
end_define

begin_define
define|#
directive|define
name|OPCODE_EOR
value|1
end_define

begin_define
define|#
directive|define
name|OPCODE_SUB
value|2
end_define

begin_define
define|#
directive|define
name|OPCODE_RSB
value|3
end_define

begin_define
define|#
directive|define
name|OPCODE_ADD
value|4
end_define

begin_define
define|#
directive|define
name|OPCODE_ADC
value|5
end_define

begin_define
define|#
directive|define
name|OPCODE_SBC
value|6
end_define

begin_define
define|#
directive|define
name|OPCODE_RSC
value|7
end_define

begin_define
define|#
directive|define
name|OPCODE_TST
value|8
end_define

begin_define
define|#
directive|define
name|OPCODE_TEQ
value|9
end_define

begin_define
define|#
directive|define
name|OPCODE_CMP
value|10
end_define

begin_define
define|#
directive|define
name|OPCODE_CMN
value|11
end_define

begin_define
define|#
directive|define
name|OPCODE_ORR
value|12
end_define

begin_define
define|#
directive|define
name|OPCODE_MOV
value|13
end_define

begin_define
define|#
directive|define
name|OPCODE_BIC
value|14
end_define

begin_define
define|#
directive|define
name|OPCODE_MVN
value|15
end_define

begin_decl_stmt
specifier|static
name|void
name|do_t_nop
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_t_arit
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_t_add
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_t_asr
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_t_branch9
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_t_branch12
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_t_branch23
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_t_bx
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_t_compare
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_t_ldmstm
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_t_ldr
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_t_ldrb
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_t_ldrh
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_t_lds
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_t_lsl
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_t_lsr
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_t_mov
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_t_push_pop
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_t_str
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_t_strb
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_t_strh
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_t_sub
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_t_swi
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_t_adr
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|T_OPCODE_MUL
value|0x4340
end_define

begin_define
define|#
directive|define
name|T_OPCODE_TST
value|0x4200
end_define

begin_define
define|#
directive|define
name|T_OPCODE_CMN
value|0x42c0
end_define

begin_define
define|#
directive|define
name|T_OPCODE_NEG
value|0x4240
end_define

begin_define
define|#
directive|define
name|T_OPCODE_MVN
value|0x43c0
end_define

begin_define
define|#
directive|define
name|T_OPCODE_ADD_R3
value|0x1800
end_define

begin_define
define|#
directive|define
name|T_OPCODE_SUB_R3
value|0x1a00
end_define

begin_define
define|#
directive|define
name|T_OPCODE_ADD_HI
value|0x4400
end_define

begin_define
define|#
directive|define
name|T_OPCODE_ADD_ST
value|0xb000
end_define

begin_define
define|#
directive|define
name|T_OPCODE_SUB_ST
value|0xb080
end_define

begin_define
define|#
directive|define
name|T_OPCODE_ADD_SP
value|0xa800
end_define

begin_define
define|#
directive|define
name|T_OPCODE_ADD_PC
value|0xa000
end_define

begin_define
define|#
directive|define
name|T_OPCODE_ADD_I8
value|0x3000
end_define

begin_define
define|#
directive|define
name|T_OPCODE_SUB_I8
value|0x3800
end_define

begin_define
define|#
directive|define
name|T_OPCODE_ADD_I3
value|0x1c00
end_define

begin_define
define|#
directive|define
name|T_OPCODE_SUB_I3
value|0x1e00
end_define

begin_define
define|#
directive|define
name|T_OPCODE_ASR_R
value|0x4100
end_define

begin_define
define|#
directive|define
name|T_OPCODE_LSL_R
value|0x4080
end_define

begin_define
define|#
directive|define
name|T_OPCODE_LSR_R
value|0x40c0
end_define

begin_define
define|#
directive|define
name|T_OPCODE_ASR_I
value|0x1000
end_define

begin_define
define|#
directive|define
name|T_OPCODE_LSL_I
value|0x0000
end_define

begin_define
define|#
directive|define
name|T_OPCODE_LSR_I
value|0x0800
end_define

begin_define
define|#
directive|define
name|T_OPCODE_MOV_I8
value|0x2000
end_define

begin_define
define|#
directive|define
name|T_OPCODE_CMP_I8
value|0x2800
end_define

begin_define
define|#
directive|define
name|T_OPCODE_CMP_LR
value|0x4280
end_define

begin_define
define|#
directive|define
name|T_OPCODE_MOV_HR
value|0x4600
end_define

begin_define
define|#
directive|define
name|T_OPCODE_CMP_HR
value|0x4500
end_define

begin_define
define|#
directive|define
name|T_OPCODE_LDR_PC
value|0x4800
end_define

begin_define
define|#
directive|define
name|T_OPCODE_LDR_SP
value|0x9800
end_define

begin_define
define|#
directive|define
name|T_OPCODE_STR_SP
value|0x9000
end_define

begin_define
define|#
directive|define
name|T_OPCODE_LDR_IW
value|0x6800
end_define

begin_define
define|#
directive|define
name|T_OPCODE_STR_IW
value|0x6000
end_define

begin_define
define|#
directive|define
name|T_OPCODE_LDR_IH
value|0x8800
end_define

begin_define
define|#
directive|define
name|T_OPCODE_STR_IH
value|0x8000
end_define

begin_define
define|#
directive|define
name|T_OPCODE_LDR_IB
value|0x7800
end_define

begin_define
define|#
directive|define
name|T_OPCODE_STR_IB
value|0x7000
end_define

begin_define
define|#
directive|define
name|T_OPCODE_LDR_RW
value|0x5800
end_define

begin_define
define|#
directive|define
name|T_OPCODE_STR_RW
value|0x5000
end_define

begin_define
define|#
directive|define
name|T_OPCODE_LDR_RH
value|0x5a00
end_define

begin_define
define|#
directive|define
name|T_OPCODE_STR_RH
value|0x5200
end_define

begin_define
define|#
directive|define
name|T_OPCODE_LDR_RB
value|0x5c00
end_define

begin_define
define|#
directive|define
name|T_OPCODE_STR_RB
value|0x5400
end_define

begin_define
define|#
directive|define
name|T_OPCODE_PUSH
value|0xb400
end_define

begin_define
define|#
directive|define
name|T_OPCODE_POP
value|0xbc00
end_define

begin_define
define|#
directive|define
name|T_OPCODE_BRANCH
value|0xe7fe
end_define

begin_decl_stmt
specifier|static
name|int
name|thumb_reg
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|*
name|str
operator|,
name|int
name|hi_lo
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|THUMB_SIZE
value|2
end_define

begin_comment
comment|/* Size of thumb instruction.  */
end_comment

begin_define
define|#
directive|define
name|THUMB_REG_LO
value|0x1
end_define

begin_define
define|#
directive|define
name|THUMB_REG_HI
value|0x2
end_define

begin_define
define|#
directive|define
name|THUMB_REG_ANY
value|0x3
end_define

begin_define
define|#
directive|define
name|THUMB_H1
value|0x0080
end_define

begin_define
define|#
directive|define
name|THUMB_H2
value|0x0040
end_define

begin_define
define|#
directive|define
name|THUMB_ASR
value|0
end_define

begin_define
define|#
directive|define
name|THUMB_LSL
value|1
end_define

begin_define
define|#
directive|define
name|THUMB_LSR
value|2
end_define

begin_define
define|#
directive|define
name|THUMB_MOVE
value|0
end_define

begin_define
define|#
directive|define
name|THUMB_COMPARE
value|1
end_define

begin_define
define|#
directive|define
name|THUMB_LOAD
value|0
end_define

begin_define
define|#
directive|define
name|THUMB_STORE
value|1
end_define

begin_define
define|#
directive|define
name|THUMB_PP_PC_LR
value|0x0100
end_define

begin_comment
comment|/* These three are used for immediate shifts, do not alter.  */
end_comment

begin_define
define|#
directive|define
name|THUMB_WORD
value|2
end_define

begin_define
define|#
directive|define
name|THUMB_HALFWORD
value|1
end_define

begin_define
define|#
directive|define
name|THUMB_BYTE
value|0
end_define

begin_struct
struct|struct
name|thumb_opcode
block|{
name|CONST
name|char
modifier|*
name|template
decl_stmt|;
comment|/* Basic string to match */
name|unsigned
name|long
name|value
decl_stmt|;
comment|/* Basic instruction code */
name|int
name|size
decl_stmt|;
name|unsigned
name|long
name|variants
decl_stmt|;
comment|/* Which CPU variants this exists for */
name|void
argument_list|(
argument|*       parms
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
expr_stmt|;
comment|/* Function to call to parse args */
block|}
struct|;
end_struct

begin_expr_stmt
specifier|static
name|CONST
expr|struct
name|thumb_opcode
name|tinsns
index|[]
operator|=
block|{
block|{
literal|"adc"
block|,
literal|0x4140
block|,
literal|2
block|,
name|ARM_THUMB
block|,
name|do_t_arit
block|}
block|,
block|{
literal|"add"
block|,
literal|0x0000
block|,
literal|2
block|,
name|ARM_THUMB
block|,
name|do_t_add
block|}
block|,
block|{
literal|"and"
block|,
literal|0x4000
block|,
literal|2
block|,
name|ARM_THUMB
block|,
name|do_t_arit
block|}
block|,
block|{
literal|"asr"
block|,
literal|0x0000
block|,
literal|2
block|,
name|ARM_THUMB
block|,
name|do_t_asr
block|}
block|,
block|{
literal|"b"
block|,
name|T_OPCODE_BRANCH
block|,
literal|2
block|,
name|ARM_THUMB
block|,
name|do_t_branch12
block|}
block|,
block|{
literal|"beq"
block|,
literal|0xd0fe
block|,
literal|2
block|,
name|ARM_THUMB
block|,
name|do_t_branch9
block|}
block|,
block|{
literal|"bne"
block|,
literal|0xd1fe
block|,
literal|2
block|,
name|ARM_THUMB
block|,
name|do_t_branch9
block|}
block|,
block|{
literal|"bcs"
block|,
literal|0xd2fe
block|,
literal|2
block|,
name|ARM_THUMB
block|,
name|do_t_branch9
block|}
block|,
block|{
literal|"bhs"
block|,
literal|0xd2fe
block|,
literal|2
block|,
name|ARM_THUMB
block|,
name|do_t_branch9
block|}
block|,
block|{
literal|"bcc"
block|,
literal|0xd3fe
block|,
literal|2
block|,
name|ARM_THUMB
block|,
name|do_t_branch9
block|}
block|,
block|{
literal|"bul"
block|,
literal|0xd3fe
block|,
literal|2
block|,
name|ARM_THUMB
block|,
name|do_t_branch9
block|}
block|,
block|{
literal|"blo"
block|,
literal|0xd3fe
block|,
literal|2
block|,
name|ARM_THUMB
block|,
name|do_t_branch9
block|}
block|,
block|{
literal|"bmi"
block|,
literal|0xd4fe
block|,
literal|2
block|,
name|ARM_THUMB
block|,
name|do_t_branch9
block|}
block|,
block|{
literal|"bpl"
block|,
literal|0xd5fe
block|,
literal|2
block|,
name|ARM_THUMB
block|,
name|do_t_branch9
block|}
block|,
block|{
literal|"bvs"
block|,
literal|0xd6fe
block|,
literal|2
block|,
name|ARM_THUMB
block|,
name|do_t_branch9
block|}
block|,
block|{
literal|"bvc"
block|,
literal|0xd7fe
block|,
literal|2
block|,
name|ARM_THUMB
block|,
name|do_t_branch9
block|}
block|,
block|{
literal|"bhi"
block|,
literal|0xd8fe
block|,
literal|2
block|,
name|ARM_THUMB
block|,
name|do_t_branch9
block|}
block|,
block|{
literal|"bls"
block|,
literal|0xd9fe
block|,
literal|2
block|,
name|ARM_THUMB
block|,
name|do_t_branch9
block|}
block|,
block|{
literal|"bge"
block|,
literal|0xdafe
block|,
literal|2
block|,
name|ARM_THUMB
block|,
name|do_t_branch9
block|}
block|,
block|{
literal|"blt"
block|,
literal|0xdbfe
block|,
literal|2
block|,
name|ARM_THUMB
block|,
name|do_t_branch9
block|}
block|,
block|{
literal|"bgt"
block|,
literal|0xdcfe
block|,
literal|2
block|,
name|ARM_THUMB
block|,
name|do_t_branch9
block|}
block|,
block|{
literal|"ble"
block|,
literal|0xddfe
block|,
literal|2
block|,
name|ARM_THUMB
block|,
name|do_t_branch9
block|}
block|,
block|{
literal|"bal"
block|,
literal|0xdefe
block|,
literal|2
block|,
name|ARM_THUMB
block|,
name|do_t_branch9
block|}
block|,
block|{
literal|"bic"
block|,
literal|0x4380
block|,
literal|2
block|,
name|ARM_THUMB
block|,
name|do_t_arit
block|}
block|,
block|{
literal|"bl"
block|,
literal|0xf7fffffe
block|,
literal|4
block|,
name|ARM_THUMB
block|,
name|do_t_branch23
block|}
block|,
block|{
literal|"bx"
block|,
literal|0x4700
block|,
literal|2
block|,
name|ARM_THUMB
block|,
name|do_t_bx
block|}
block|,
block|{
literal|"cmn"
block|,
name|T_OPCODE_CMN
block|,
literal|2
block|,
name|ARM_THUMB
block|,
name|do_t_arit
block|}
block|,
block|{
literal|"cmp"
block|,
literal|0x0000
block|,
literal|2
block|,
name|ARM_THUMB
block|,
name|do_t_compare
block|}
block|,
block|{
literal|"eor"
block|,
literal|0x4040
block|,
literal|2
block|,
name|ARM_THUMB
block|,
name|do_t_arit
block|}
block|,
block|{
literal|"ldmia"
block|,
literal|0xc800
block|,
literal|2
block|,
name|ARM_THUMB
block|,
name|do_t_ldmstm
block|}
block|,
block|{
literal|"ldr"
block|,
literal|0x0000
block|,
literal|2
block|,
name|ARM_THUMB
block|,
name|do_t_ldr
block|}
block|,
block|{
literal|"ldrb"
block|,
literal|0x0000
block|,
literal|2
block|,
name|ARM_THUMB
block|,
name|do_t_ldrb
block|}
block|,
block|{
literal|"ldrh"
block|,
literal|0x0000
block|,
literal|2
block|,
name|ARM_THUMB
block|,
name|do_t_ldrh
block|}
block|,
block|{
literal|"ldrsb"
block|,
literal|0x5600
block|,
literal|2
block|,
name|ARM_THUMB
block|,
name|do_t_lds
block|}
block|,
block|{
literal|"ldrsh"
block|,
literal|0x5e00
block|,
literal|2
block|,
name|ARM_THUMB
block|,
name|do_t_lds
block|}
block|,
block|{
literal|"ldsb"
block|,
literal|0x5600
block|,
literal|2
block|,
name|ARM_THUMB
block|,
name|do_t_lds
block|}
block|,
block|{
literal|"ldsh"
block|,
literal|0x5e00
block|,
literal|2
block|,
name|ARM_THUMB
block|,
name|do_t_lds
block|}
block|,
block|{
literal|"lsl"
block|,
literal|0x0000
block|,
literal|2
block|,
name|ARM_THUMB
block|,
name|do_t_lsl
block|}
block|,
block|{
literal|"lsr"
block|,
literal|0x0000
block|,
literal|2
block|,
name|ARM_THUMB
block|,
name|do_t_lsr
block|}
block|,
block|{
literal|"mov"
block|,
literal|0x0000
block|,
literal|2
block|,
name|ARM_THUMB
block|,
name|do_t_mov
block|}
block|,
block|{
literal|"mul"
block|,
name|T_OPCODE_MUL
block|,
literal|2
block|,
name|ARM_THUMB
block|,
name|do_t_arit
block|}
block|,
block|{
literal|"mvn"
block|,
name|T_OPCODE_MVN
block|,
literal|2
block|,
name|ARM_THUMB
block|,
name|do_t_arit
block|}
block|,
block|{
literal|"neg"
block|,
name|T_OPCODE_NEG
block|,
literal|2
block|,
name|ARM_THUMB
block|,
name|do_t_arit
block|}
block|,
block|{
literal|"orr"
block|,
literal|0x4300
block|,
literal|2
block|,
name|ARM_THUMB
block|,
name|do_t_arit
block|}
block|,
block|{
literal|"pop"
block|,
literal|0xbc00
block|,
literal|2
block|,
name|ARM_THUMB
block|,
name|do_t_push_pop
block|}
block|,
block|{
literal|"push"
block|,
literal|0xb400
block|,
literal|2
block|,
name|ARM_THUMB
block|,
name|do_t_push_pop
block|}
block|,
block|{
literal|"ror"
block|,
literal|0x41c0
block|,
literal|2
block|,
name|ARM_THUMB
block|,
name|do_t_arit
block|}
block|,
block|{
literal|"sbc"
block|,
literal|0x4180
block|,
literal|2
block|,
name|ARM_THUMB
block|,
name|do_t_arit
block|}
block|,
block|{
literal|"stmia"
block|,
literal|0xc000
block|,
literal|2
block|,
name|ARM_THUMB
block|,
name|do_t_ldmstm
block|}
block|,
block|{
literal|"str"
block|,
literal|0x0000
block|,
literal|2
block|,
name|ARM_THUMB
block|,
name|do_t_str
block|}
block|,
block|{
literal|"strb"
block|,
literal|0x0000
block|,
literal|2
block|,
name|ARM_THUMB
block|,
name|do_t_strb
block|}
block|,
block|{
literal|"strh"
block|,
literal|0x0000
block|,
literal|2
block|,
name|ARM_THUMB
block|,
name|do_t_strh
block|}
block|,
block|{
literal|"swi"
block|,
literal|0xdf00
block|,
literal|2
block|,
name|ARM_THUMB
block|,
name|do_t_swi
block|}
block|,
block|{
literal|"sub"
block|,
literal|0x0000
block|,
literal|2
block|,
name|ARM_THUMB
block|,
name|do_t_sub
block|}
block|,
block|{
literal|"tst"
block|,
name|T_OPCODE_TST
block|,
literal|2
block|,
name|ARM_THUMB
block|,
name|do_t_arit
block|}
block|,
comment|/* Pseudo ops: */
block|{
literal|"adr"
block|,
literal|0x0000
block|,
literal|2
block|,
name|ARM_THUMB
block|,
name|do_t_adr
block|}
block|,
block|{
literal|"nop"
block|,
literal|0x46C0
block|,
literal|2
block|,
name|ARM_THUMB
block|,
name|do_t_nop
block|}
block|,
comment|/* mov r8,r8 */
block|}
expr_stmt|;
end_expr_stmt

begin_struct
struct|struct
name|reg_entry
block|{
name|CONST
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|number
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|int_register
parameter_list|(
name|reg
parameter_list|)
value|((reg)>= 0&& (reg)<= 15)
end_define

begin_define
define|#
directive|define
name|cp_register
parameter_list|(
name|reg
parameter_list|)
value|((reg)>= 32&& (reg)<= 47)
end_define

begin_define
define|#
directive|define
name|fp_register
parameter_list|(
name|reg
parameter_list|)
value|((reg)>= 16&& (reg)<= 23)
end_define

begin_define
define|#
directive|define
name|REG_PC
value|15
end_define

begin_define
define|#
directive|define
name|REG_LR
value|14
end_define

begin_define
define|#
directive|define
name|REG_SP
value|13
end_define

begin_comment
comment|/* These are the standard names.  Users can add aliases with .req  */
end_comment

begin_expr_stmt
specifier|static
name|CONST
expr|struct
name|reg_entry
name|reg_table
index|[]
operator|=
block|{
comment|/* Processor Register Numbers.  */
block|{
literal|"r0"
block|,
literal|0
block|}
block|,
block|{
literal|"r1"
block|,
literal|1
block|}
block|,
block|{
literal|"r2"
block|,
literal|2
block|}
block|,
block|{
literal|"r3"
block|,
literal|3
block|}
block|,
block|{
literal|"r4"
block|,
literal|4
block|}
block|,
block|{
literal|"r5"
block|,
literal|5
block|}
block|,
block|{
literal|"r6"
block|,
literal|6
block|}
block|,
block|{
literal|"r7"
block|,
literal|7
block|}
block|,
block|{
literal|"r8"
block|,
literal|8
block|}
block|,
block|{
literal|"r9"
block|,
literal|9
block|}
block|,
block|{
literal|"r10"
block|,
literal|10
block|}
block|,
block|{
literal|"r11"
block|,
literal|11
block|}
block|,
block|{
literal|"r12"
block|,
literal|12
block|}
block|,
block|{
literal|"r13"
block|,
name|REG_SP
block|}
block|,
block|{
literal|"r14"
block|,
name|REG_LR
block|}
block|,
block|{
literal|"r15"
block|,
name|REG_PC
block|}
block|,
comment|/* APCS conventions.  */
block|{
literal|"a1"
block|,
literal|0
block|}
block|,
block|{
literal|"a2"
block|,
literal|1
block|}
block|,
block|{
literal|"a3"
block|,
literal|2
block|}
block|,
block|{
literal|"a4"
block|,
literal|3
block|}
block|,
block|{
literal|"v1"
block|,
literal|4
block|}
block|,
block|{
literal|"v2"
block|,
literal|5
block|}
block|,
block|{
literal|"v3"
block|,
literal|6
block|}
block|,
block|{
literal|"v4"
block|,
literal|7
block|}
block|,
block|{
literal|"v5"
block|,
literal|8
block|}
block|,
block|{
literal|"v6"
block|,
literal|9
block|}
block|,
block|{
literal|"sb"
block|,
literal|9
block|}
block|,
block|{
literal|"v7"
block|,
literal|10
block|}
block|,
block|{
literal|"sl"
block|,
literal|10
block|}
block|,
block|{
literal|"fp"
block|,
literal|11
block|}
block|,
block|{
literal|"ip"
block|,
literal|12
block|}
block|,
block|{
literal|"sp"
block|,
name|REG_SP
block|}
block|,
block|{
literal|"lr"
block|,
name|REG_LR
block|}
block|,
block|{
literal|"pc"
block|,
name|REG_PC
block|}
block|,
comment|/* ATPCS additions to APCS conventions.  */
block|{
literal|"wr"
block|,
literal|7
block|}
block|,
block|{
literal|"v8"
block|,
literal|11
block|}
block|,
comment|/* FP Registers.  */
block|{
literal|"f0"
block|,
literal|16
block|}
block|,
block|{
literal|"f1"
block|,
literal|17
block|}
block|,
block|{
literal|"f2"
block|,
literal|18
block|}
block|,
block|{
literal|"f3"
block|,
literal|19
block|}
block|,
block|{
literal|"f4"
block|,
literal|20
block|}
block|,
block|{
literal|"f5"
block|,
literal|21
block|}
block|,
block|{
literal|"f6"
block|,
literal|22
block|}
block|,
block|{
literal|"f7"
block|,
literal|23
block|}
block|,
block|{
literal|"c0"
block|,
literal|32
block|}
block|,
block|{
literal|"c1"
block|,
literal|33
block|}
block|,
block|{
literal|"c2"
block|,
literal|34
block|}
block|,
block|{
literal|"c3"
block|,
literal|35
block|}
block|,
block|{
literal|"c4"
block|,
literal|36
block|}
block|,
block|{
literal|"c5"
block|,
literal|37
block|}
block|,
block|{
literal|"c6"
block|,
literal|38
block|}
block|,
block|{
literal|"c7"
block|,
literal|39
block|}
block|,
block|{
literal|"c8"
block|,
literal|40
block|}
block|,
block|{
literal|"c9"
block|,
literal|41
block|}
block|,
block|{
literal|"c10"
block|,
literal|42
block|}
block|,
block|{
literal|"c11"
block|,
literal|43
block|}
block|,
block|{
literal|"c12"
block|,
literal|44
block|}
block|,
block|{
literal|"c13"
block|,
literal|45
block|}
block|,
block|{
literal|"c14"
block|,
literal|46
block|}
block|,
block|{
literal|"c15"
block|,
literal|47
block|}
block|,
block|{
literal|"cr0"
block|,
literal|32
block|}
block|,
block|{
literal|"cr1"
block|,
literal|33
block|}
block|,
block|{
literal|"cr2"
block|,
literal|34
block|}
block|,
block|{
literal|"cr3"
block|,
literal|35
block|}
block|,
block|{
literal|"cr4"
block|,
literal|36
block|}
block|,
block|{
literal|"cr5"
block|,
literal|37
block|}
block|,
block|{
literal|"cr6"
block|,
literal|38
block|}
block|,
block|{
literal|"cr7"
block|,
literal|39
block|}
block|,
block|{
literal|"cr8"
block|,
literal|40
block|}
block|,
block|{
literal|"cr9"
block|,
literal|41
block|}
block|,
block|{
literal|"cr10"
block|,
literal|42
block|}
block|,
block|{
literal|"cr11"
block|,
literal|43
block|}
block|,
block|{
literal|"cr12"
block|,
literal|44
block|}
block|,
block|{
literal|"cr13"
block|,
literal|45
block|}
block|,
block|{
literal|"cr14"
block|,
literal|46
block|}
block|,
block|{
literal|"cr15"
block|,
literal|47
block|}
block|,
comment|/* ATPCS additions to float register names.  */
block|{
literal|"s0"
block|,
literal|16
block|}
block|,
block|{
literal|"s1"
block|,
literal|17
block|}
block|,
block|{
literal|"s2"
block|,
literal|18
block|}
block|,
block|{
literal|"s3"
block|,
literal|19
block|}
block|,
block|{
literal|"s4"
block|,
literal|20
block|}
block|,
block|{
literal|"s5"
block|,
literal|21
block|}
block|,
block|{
literal|"s6"
block|,
literal|22
block|}
block|,
block|{
literal|"s7"
block|,
literal|23
block|}
block|,
block|{
literal|"d0"
block|,
literal|16
block|}
block|,
block|{
literal|"d1"
block|,
literal|17
block|}
block|,
block|{
literal|"d2"
block|,
literal|18
block|}
block|,
block|{
literal|"d3"
block|,
literal|19
block|}
block|,
block|{
literal|"d4"
block|,
literal|20
block|}
block|,
block|{
literal|"d5"
block|,
literal|21
block|}
block|,
block|{
literal|"d6"
block|,
literal|22
block|}
block|,
block|{
literal|"d7"
block|,
literal|23
block|}
block|,
comment|/* FIXME: At some point we need to add VFP register names.  */
comment|/* Array terminator.  */
block|{
name|NULL
block|,
literal|0
block|}
block|}
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|BAD_ARGS
value|_("Bad arguments to instruction")
end_define

begin_define
define|#
directive|define
name|BAD_PC
value|_("r15 not allowed here")
end_define

begin_define
define|#
directive|define
name|BAD_FLAGS
value|_("Instruction should not have flags")
end_define

begin_define
define|#
directive|define
name|BAD_COND
value|_("Instruction is not conditional")
end_define

begin_decl_stmt
specifier|static
name|struct
name|hash_control
modifier|*
name|arm_ops_hsh
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|hash_control
modifier|*
name|arm_tops_hsh
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|hash_control
modifier|*
name|arm_cond_hsh
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|hash_control
modifier|*
name|arm_shift_hsh
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|hash_control
modifier|*
name|arm_reg_hsh
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|hash_control
modifier|*
name|arm_psr_hsh
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This table describes all the machine specific pseudo-ops the assembler    has to support.  The fields are:      pseudo-op name without dot      function to call to execute this pseudo-op      Integer arg to pass to the function.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|s_req
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|s_align
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|s_bss
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|s_even
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|s_ltorg
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|s_arm
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|s_thumb
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|s_code
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|s_force_thumb
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|s_thumb_func
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|s_thumb_set
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|arm_s_text
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|arm_s_data
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|OBJ_ELF
end_ifdef

begin_decl_stmt
specifier|static
name|void
name|arm_s_section
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|s_arm_elf_cons
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|int
name|my_get_expression
name|PARAMS
argument_list|(
operator|(
name|expressionS
operator|*
operator|,
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|CONST
name|pseudo_typeS
name|md_pseudo_table
index|[]
init|=
block|{
block|{
literal|"req"
block|,
name|s_req
block|,
literal|0
block|}
block|,
comment|/* Never called becasue '.req' does not start line */
block|{
literal|"bss"
block|,
name|s_bss
block|,
literal|0
block|}
block|,
block|{
literal|"align"
block|,
name|s_align
block|,
literal|0
block|}
block|,
block|{
literal|"arm"
block|,
name|s_arm
block|,
literal|0
block|}
block|,
block|{
literal|"thumb"
block|,
name|s_thumb
block|,
literal|0
block|}
block|,
block|{
literal|"code"
block|,
name|s_code
block|,
literal|0
block|}
block|,
block|{
literal|"force_thumb"
block|,
name|s_force_thumb
block|,
literal|0
block|}
block|,
block|{
literal|"thumb_func"
block|,
name|s_thumb_func
block|,
literal|0
block|}
block|,
block|{
literal|"thumb_set"
block|,
name|s_thumb_set
block|,
literal|0
block|}
block|,
block|{
literal|"even"
block|,
name|s_even
block|,
literal|0
block|}
block|,
block|{
literal|"ltorg"
block|,
name|s_ltorg
block|,
literal|0
block|}
block|,
block|{
literal|"pool"
block|,
name|s_ltorg
block|,
literal|0
block|}
block|,
comment|/* Allow for the effect of section changes.  */
block|{
literal|"text"
block|,
name|arm_s_text
block|,
literal|0
block|}
block|,
block|{
literal|"data"
block|,
name|arm_s_data
block|,
literal|0
block|}
block|,
ifdef|#
directive|ifdef
name|OBJ_ELF
block|{
literal|"section"
block|,
name|arm_s_section
block|,
literal|0
block|}
block|,
block|{
literal|"section.s"
block|,
name|arm_s_section
block|,
literal|0
block|}
block|,
block|{
literal|"sect"
block|,
name|arm_s_section
block|,
literal|0
block|}
block|,
block|{
literal|"sect.s"
block|,
name|arm_s_section
block|,
literal|0
block|}
block|,
block|{
literal|"word"
block|,
name|s_arm_elf_cons
block|,
literal|4
block|}
block|,
block|{
literal|"long"
block|,
name|s_arm_elf_cons
block|,
literal|4
block|}
block|,
else|#
directive|else
block|{
literal|"word"
block|,
name|cons
block|,
literal|4
block|}
block|,
endif|#
directive|endif
block|{
literal|"extend"
block|,
name|float_cons
block|,
literal|'x'
block|}
block|,
block|{
literal|"ldouble"
block|,
name|float_cons
block|,
literal|'x'
block|}
block|,
block|{
literal|"packed"
block|,
name|float_cons
block|,
literal|'p'
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Stuff needed to resolve the label ambiguity    As:      ...      label:<insn>    may differ from:      ...      label:<insn> */
end_comment

begin_decl_stmt
name|symbolS
modifier|*
name|last_label_seen
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|label_is_thumb_function_name
init|=
name|false
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Literal stuff */
end_comment

begin_define
define|#
directive|define
name|MAX_LITERAL_POOL_SIZE
value|1024
end_define

begin_typedef
typedef|typedef
struct|struct
name|literalS
block|{
name|struct
name|expressionS
name|exp
decl_stmt|;
name|struct
name|arm_it
modifier|*
name|inst
decl_stmt|;
block|}
name|literalT
typedef|;
end_typedef

begin_decl_stmt
name|literalT
name|literals
index|[
name|MAX_LITERAL_POOL_SIZE
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|next_literal_pool_place
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Next free entry in the pool */
end_comment

begin_decl_stmt
name|int
name|lit_pool_num
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Next literal pool number */
end_comment

begin_decl_stmt
name|symbolS
modifier|*
name|current_poolP
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|add_to_lit_pool
parameter_list|()
block|{
name|int
name|lit_count
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|current_poolP
operator|==
name|NULL
condition|)
name|current_poolP
operator|=
name|symbol_create
argument_list|(
name|FAKE_LABEL_NAME
argument_list|,
name|undefined_section
argument_list|,
operator|(
name|valueT
operator|)
literal|0
argument_list|,
operator|&
name|zero_address_frag
argument_list|)
expr_stmt|;
comment|/* Check if this literal value is already in the pool:  */
while|while
condition|(
name|lit_count
operator|<
name|next_literal_pool_place
condition|)
block|{
if|if
condition|(
name|literals
index|[
name|lit_count
index|]
operator|.
name|exp
operator|.
name|X_op
operator|==
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_op
operator|&&
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_op
operator|==
name|O_constant
operator|&&
name|literals
index|[
name|lit_count
index|]
operator|.
name|exp
operator|.
name|X_add_number
operator|==
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_add_number
operator|&&
name|literals
index|[
name|lit_count
index|]
operator|.
name|exp
operator|.
name|X_unsigned
operator|==
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_unsigned
condition|)
break|break;
name|lit_count
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|lit_count
operator|==
name|next_literal_pool_place
condition|)
comment|/* new entry */
block|{
if|if
condition|(
name|next_literal_pool_place
operator|>
name|MAX_LITERAL_POOL_SIZE
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"Literal Pool Overflow"
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
block|}
name|literals
index|[
name|next_literal_pool_place
index|]
operator|.
name|exp
operator|=
name|inst
operator|.
name|reloc
operator|.
name|exp
expr_stmt|;
name|lit_count
operator|=
name|next_literal_pool_place
operator|++
expr_stmt|;
block|}
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_op
operator|=
name|O_symbol
expr_stmt|;
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_add_number
operator|=
operator|(
name|lit_count
operator|)
operator|*
literal|4
operator|-
literal|8
expr_stmt|;
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_add_symbol
operator|=
name|current_poolP
expr_stmt|;
return|return
name|SUCCESS
return|;
block|}
end_function

begin_comment
comment|/* Can't use symbol_new here, so have to create a symbol and then at    a later date assign it a value. Thats what these functions do.  */
end_comment

begin_function
specifier|static
name|void
name|symbol_locate
parameter_list|(
name|symbolP
parameter_list|,
name|name
parameter_list|,
name|segment
parameter_list|,
name|valu
parameter_list|,
name|frag
parameter_list|)
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
name|CONST
name|char
modifier|*
name|name
decl_stmt|;
comment|/* It is copied, the caller can modify */
name|segT
name|segment
decl_stmt|;
comment|/* Segment identifier (SEG_<something>) */
name|valueT
name|valu
decl_stmt|;
comment|/* Symbol value */
name|fragS
modifier|*
name|frag
decl_stmt|;
comment|/* Associated fragment */
block|{
name|unsigned
name|int
name|name_length
decl_stmt|;
name|char
modifier|*
name|preserved_copy_of_name
decl_stmt|;
name|name_length
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
expr_stmt|;
comment|/* +1 for \0 */
name|obstack_grow
argument_list|(
operator|&
name|notes
argument_list|,
name|name
argument_list|,
name|name_length
argument_list|)
expr_stmt|;
name|preserved_copy_of_name
operator|=
name|obstack_finish
argument_list|(
operator|&
name|notes
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|STRIP_UNDERSCORE
if|if
condition|(
name|preserved_copy_of_name
index|[
literal|0
index|]
operator|==
literal|'_'
condition|)
name|preserved_copy_of_name
operator|++
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|tc_canonicalize_symbol_name
name|preserved_copy_of_name
operator|=
name|tc_canonicalize_symbol_name
argument_list|(
name|preserved_copy_of_name
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|S_SET_NAME
argument_list|(
name|symbolP
argument_list|,
name|preserved_copy_of_name
argument_list|)
expr_stmt|;
name|S_SET_SEGMENT
argument_list|(
name|symbolP
argument_list|,
name|segment
argument_list|)
expr_stmt|;
name|S_SET_VALUE
argument_list|(
name|symbolP
argument_list|,
name|valu
argument_list|)
expr_stmt|;
name|symbol_clear_list_pointers
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
name|symbol_set_frag
argument_list|(
name|symbolP
argument_list|,
name|frag
argument_list|)
expr_stmt|;
comment|/* Link to end of symbol chain.  */
block|{
specifier|extern
name|int
name|symbol_table_frozen
decl_stmt|;
if|if
condition|(
name|symbol_table_frozen
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
name|symbol_append
argument_list|(
name|symbolP
argument_list|,
name|symbol_lastP
argument_list|,
operator|&
name|symbol_rootP
argument_list|,
operator|&
name|symbol_lastP
argument_list|)
expr_stmt|;
name|obj_symbol_new_hook
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|tc_symbol_new_hook
name|tc_symbol_new_hook
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DEBUG_SYMS
name|verify_symbol_chain
argument_list|(
name|symbol_rootP
argument_list|,
name|symbol_lastP
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG_SYMS */
block|}
end_function

begin_comment
comment|/* Check that an immediate is valid, and if so,    convert it to the right format.  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|validate_immediate
parameter_list|(
name|val
parameter_list|)
name|unsigned
name|int
name|val
decl_stmt|;
block|{
name|unsigned
name|int
name|a
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
define|#
directive|define
name|rotate_left
parameter_list|(
name|v
parameter_list|,
name|n
parameter_list|)
value|(v<< n | v>> (32 - n))
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|+=
literal|2
control|)
if|if
condition|(
operator|(
name|a
operator|=
name|rotate_left
argument_list|(
name|val
argument_list|,
name|i
argument_list|)
operator|)
operator|<=
literal|0xff
condition|)
return|return
name|a
operator||
operator|(
name|i
operator|<<
literal|7
operator|)
return|;
comment|/* 12-bit pack: [shift-cnt,const] */
return|return
name|FAIL
return|;
block|}
end_function

begin_comment
comment|/* Check to see if an immediate can be computed as two seperate immediate    values, added together.  We already know that this value cannot be    computed by just one ARM instruction.  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|validate_immediate_twopart
parameter_list|(
name|val
parameter_list|,
name|highpart
parameter_list|)
name|unsigned
name|int
name|val
decl_stmt|;
name|unsigned
name|int
modifier|*
name|highpart
decl_stmt|;
block|{
name|unsigned
name|int
name|a
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|+=
literal|2
control|)
if|if
condition|(
operator|(
operator|(
name|a
operator|=
name|rotate_left
argument_list|(
name|val
argument_list|,
name|i
argument_list|)
operator|)
operator|&
literal|0xff
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|a
operator|&
literal|0xff00
condition|)
block|{
if|if
condition|(
name|a
operator|&
operator|~
literal|0xffff
condition|)
continue|continue;
operator|*
name|highpart
operator|=
operator|(
name|a
operator|>>
literal|8
operator|)
operator||
operator|(
operator|(
name|i
operator|+
literal|24
operator|)
operator|<<
literal|7
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|a
operator|&
literal|0xff0000
condition|)
block|{
if|if
condition|(
name|a
operator|&
literal|0xff000000
condition|)
continue|continue;
operator|*
name|highpart
operator|=
operator|(
name|a
operator|>>
literal|16
operator|)
operator||
operator|(
operator|(
name|i
operator|+
literal|16
operator|)
operator|<<
literal|7
operator|)
expr_stmt|;
block|}
else|else
block|{
name|assert
argument_list|(
name|a
operator|&
literal|0xff000000
argument_list|)
expr_stmt|;
operator|*
name|highpart
operator|=
operator|(
name|a
operator|>>
literal|24
operator|)
operator||
operator|(
operator|(
name|i
operator|+
literal|8
operator|)
operator|<<
literal|7
operator|)
expr_stmt|;
block|}
return|return
operator|(
name|a
operator|&
literal|0xff
operator|)
operator||
operator|(
name|i
operator|<<
literal|7
operator|)
return|;
block|}
return|return
name|FAIL
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|validate_offset_imm
parameter_list|(
name|val
parameter_list|,
name|hwse
parameter_list|)
name|unsigned
name|int
name|val
decl_stmt|;
name|int
name|hwse
decl_stmt|;
block|{
if|if
condition|(
operator|(
name|hwse
operator|&&
name|val
operator|>
literal|255
operator|)
operator|||
name|val
operator|>
literal|4095
condition|)
return|return
name|FAIL
return|;
return|return
name|val
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|s_req
parameter_list|(
name|a
parameter_list|)
name|int
name|a
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Invalid syntax for .req directive."
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|s_bss
parameter_list|(
name|ignore
parameter_list|)
name|int
name|ignore
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
comment|/* We don't support putting frags in the BSS segment, we fake it by      marking in_bss, then looking at s_skip for clues?.. */
name|subseg_set
argument_list|(
name|bss_section
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|s_even
parameter_list|(
name|ignore
parameter_list|)
name|int
name|ignore
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|need_pass_2
condition|)
comment|/* Never make frag if expect extra pass. */
name|frag_align
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|record_alignment
argument_list|(
name|now_seg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|s_ltorg
parameter_list|(
name|ignored
parameter_list|)
name|int
name|ignored
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|int
name|lit_count
init|=
literal|0
decl_stmt|;
name|char
name|sym_name
index|[
literal|20
index|]
decl_stmt|;
if|if
condition|(
name|current_poolP
operator|==
name|NULL
condition|)
return|return;
comment|/* Align pool as you have word accesses */
comment|/* Only make a frag if we have to ... */
if|if
condition|(
operator|!
name|need_pass_2
condition|)
name|frag_align
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|record_alignment
argument_list|(
name|now_seg
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|sym_name
argument_list|,
literal|"$$lit_\002%x"
argument_list|,
name|lit_pool_num
operator|++
argument_list|)
expr_stmt|;
name|symbol_locate
argument_list|(
name|current_poolP
argument_list|,
name|sym_name
argument_list|,
name|now_seg
argument_list|,
operator|(
name|valueT
operator|)
name|frag_now_fix
argument_list|()
argument_list|,
name|frag_now
argument_list|)
expr_stmt|;
name|symbol_table_insert
argument_list|(
name|current_poolP
argument_list|)
expr_stmt|;
name|ARM_SET_THUMB
argument_list|(
name|current_poolP
argument_list|,
name|thumb_mode
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
name|OBJ_COFF
operator|||
name|defined
name|OBJ_ELF
name|ARM_SET_INTERWORK
argument_list|(
name|current_poolP
argument_list|,
name|support_interwork
argument_list|)
expr_stmt|;
endif|#
directive|endif
while|while
condition|(
name|lit_count
operator|<
name|next_literal_pool_place
condition|)
comment|/* First output the expression in the instruction to the pool.  */
name|emit_expr
argument_list|(
operator|&
operator|(
name|literals
index|[
name|lit_count
operator|++
index|]
operator|.
name|exp
operator|)
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* .word */
name|next_literal_pool_place
operator|=
literal|0
expr_stmt|;
name|current_poolP
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|s_align
parameter_list|(
name|unused
parameter_list|)
comment|/* Same as s_align_ptwo but align 0 => align 2 */
name|int
name|unused
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
specifier|register
name|int
name|temp
decl_stmt|;
specifier|register
name|long
name|temp_fill
decl_stmt|;
name|long
name|max_alignment
init|=
literal|15
decl_stmt|;
name|temp
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
if|if
condition|(
name|temp
operator|>
name|max_alignment
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Alignment too large: %d. assumed."
argument_list|)
argument_list|,
name|temp
operator|=
name|max_alignment
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|temp
operator|<
literal|0
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Alignment negative. 0 assumed."
argument_list|)
argument_list|)
expr_stmt|;
name|temp
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|','
condition|)
block|{
name|input_line_pointer
operator|++
expr_stmt|;
name|temp_fill
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
block|}
else|else
name|temp_fill
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|temp
condition|)
name|temp
operator|=
literal|2
expr_stmt|;
comment|/* Only make a frag if we HAVE to. . . */
if|if
condition|(
name|temp
operator|&&
operator|!
name|need_pass_2
condition|)
name|frag_align
argument_list|(
name|temp
argument_list|,
operator|(
name|int
operator|)
name|temp_fill
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
name|record_alignment
argument_list|(
name|now_seg
argument_list|,
name|temp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|s_force_thumb
parameter_list|(
name|ignore
parameter_list|)
name|int
name|ignore
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
comment|/* If we are not already in thumb mode go into it, EVEN if      the target processor does not support thumb instructions.      This is used by gcc/config/arm/lib1funcs.asm for example      to compile interworking support functions even if the      target processor should not support interworking.  */
if|if
condition|(
operator|!
name|thumb_mode
condition|)
block|{
name|thumb_mode
operator|=
literal|2
expr_stmt|;
name|record_alignment
argument_list|(
name|now_seg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|s_thumb_func
parameter_list|(
name|ignore
parameter_list|)
name|int
name|ignore
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
comment|/* The following label is the name/address of the start of a Thumb function.      We need to know this for the interworking support.  */
name|label_is_thumb_function_name
operator|=
name|true
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Perform a .set directive, but also mark the alias as    being a thumb function.  */
end_comment

begin_function
specifier|static
name|void
name|s_thumb_set
parameter_list|(
name|equiv
parameter_list|)
name|int
name|equiv
decl_stmt|;
block|{
comment|/* XXX the following is a duplicate of the code for s_set() in read.c      We cannot just call that code as we need to get at the symbol that      is created.  */
specifier|register
name|char
modifier|*
name|name
decl_stmt|;
specifier|register
name|char
name|delim
decl_stmt|;
specifier|register
name|char
modifier|*
name|end_name
decl_stmt|;
specifier|register
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
comment|/*    * Especial apologies for the random logic:    * this just grew, and could be parsed much more simply!    * Dean in haste.    */
name|name
operator|=
name|input_line_pointer
expr_stmt|;
name|delim
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
name|end_name
operator|=
name|input_line_pointer
expr_stmt|;
operator|*
name|end_name
operator|=
name|delim
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|!=
literal|','
condition|)
block|{
operator|*
name|end_name
operator|=
literal|0
expr_stmt|;
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Expected comma after name \"%s\""
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
operator|*
name|end_name
operator|=
name|delim
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
name|input_line_pointer
operator|++
expr_stmt|;
operator|*
name|end_name
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
name|name
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
block|{
comment|/* XXX - this should not happen to .thumb_set  */
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|symbolP
operator|=
name|symbol_find
argument_list|(
name|name
argument_list|)
operator|)
operator|==
name|NULL
operator|&&
operator|(
name|symbolP
operator|=
name|md_undefined_symbol
argument_list|(
name|name
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
ifndef|#
directive|ifndef
name|NO_LISTING
comment|/* When doing symbol listings, play games with dummy fragments living 	 outside the normal fragment chain to record the file and line info          for this symbol.  */
if|if
condition|(
name|listing
operator|&
name|LISTING_SYMBOLS
condition|)
block|{
specifier|extern
name|struct
name|list_info_struct
modifier|*
name|listing_tail
decl_stmt|;
name|fragS
modifier|*
name|dummy_frag
init|=
operator|(
name|fragS
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|fragS
argument_list|)
argument_list|)
decl_stmt|;
name|memset
argument_list|(
name|dummy_frag
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|fragS
argument_list|)
argument_list|)
expr_stmt|;
name|dummy_frag
operator|->
name|fr_type
operator|=
name|rs_fill
expr_stmt|;
name|dummy_frag
operator|->
name|line
operator|=
name|listing_tail
expr_stmt|;
name|symbolP
operator|=
name|symbol_new
argument_list|(
name|name
argument_list|,
name|undefined_section
argument_list|,
literal|0
argument_list|,
name|dummy_frag
argument_list|)
expr_stmt|;
name|dummy_frag
operator|->
name|fr_symbol
operator|=
name|symbolP
expr_stmt|;
block|}
else|else
endif|#
directive|endif
name|symbolP
operator|=
name|symbol_new
argument_list|(
name|name
argument_list|,
name|undefined_section
argument_list|,
literal|0
argument_list|,
operator|&
name|zero_address_frag
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|OBJ_COFF
comment|/* "set" symbols are local unless otherwise specified. */
name|SF_SET_LOCAL
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* OBJ_COFF */
block|}
comment|/* make a new symbol */
name|symbol_table_insert
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
operator|*
name|end_name
operator|=
name|delim
expr_stmt|;
if|if
condition|(
name|equiv
operator|&&
name|S_IS_DEFINED
argument_list|(
name|symbolP
argument_list|)
operator|&&
name|S_GET_SEGMENT
argument_list|(
name|symbolP
argument_list|)
operator|!=
name|reg_section
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"symbol `%s' already defined"
argument_list|)
argument_list|,
name|S_GET_NAME
argument_list|(
name|symbolP
argument_list|)
argument_list|)
expr_stmt|;
name|pseudo_set
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
comment|/* XXX Now we come to the Thumb specific bit of code.  */
name|THUMB_SET_FUNC
argument_list|(
name|symbolP
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ARM_SET_THUMB
argument_list|(
name|symbolP
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
name|OBJ_ELF
operator|||
name|defined
name|OBJ_COFF
name|ARM_SET_INTERWORK
argument_list|(
name|symbolP
argument_list|,
name|support_interwork
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* If we change section we must dump the literal pool first.  */
end_comment

begin_function
specifier|static
name|void
name|arm_s_text
parameter_list|(
name|ignore
parameter_list|)
name|int
name|ignore
decl_stmt|;
block|{
if|if
condition|(
name|now_seg
operator|!=
name|text_section
condition|)
name|s_ltorg
argument_list|(
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|OBJ_ELF
name|obj_elf_text
argument_list|(
name|ignore
argument_list|)
expr_stmt|;
else|#
directive|else
name|s_text
argument_list|(
name|ignore
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|arm_s_data
parameter_list|(
name|ignore
parameter_list|)
name|int
name|ignore
decl_stmt|;
block|{
if|if
condition|(
name|flag_readonly_data_in_text
condition|)
block|{
if|if
condition|(
name|now_seg
operator|!=
name|text_section
condition|)
name|s_ltorg
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|now_seg
operator|!=
name|data_section
condition|)
name|s_ltorg
argument_list|(
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|OBJ_ELF
name|obj_elf_data
argument_list|(
name|ignore
argument_list|)
expr_stmt|;
else|#
directive|else
name|s_data
argument_list|(
name|ignore
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|OBJ_ELF
end_ifdef

begin_function
specifier|static
name|void
name|arm_s_section
parameter_list|(
name|ignore
parameter_list|)
name|int
name|ignore
decl_stmt|;
block|{
name|s_ltorg
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|obj_elf_section
argument_list|(
name|ignore
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|opcode_select
parameter_list|(
name|width
parameter_list|)
name|int
name|width
decl_stmt|;
block|{
switch|switch
condition|(
name|width
condition|)
block|{
case|case
literal|16
case|:
if|if
condition|(
operator|!
name|thumb_mode
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|cpu_variant
operator|&
name|ARM_THUMB
operator|)
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"selected processor does not support THUMB opcodes"
argument_list|)
argument_list|)
expr_stmt|;
name|thumb_mode
operator|=
literal|1
expr_stmt|;
comment|/* No need to force the alignment, since we will have been              coming from ARM mode, which is word-aligned. */
name|record_alignment
argument_list|(
name|now_seg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|32
case|:
if|if
condition|(
name|thumb_mode
condition|)
block|{
if|if
condition|(
operator|(
name|cpu_variant
operator|&
name|ARM_ANY
operator|)
operator|==
name|ARM_THUMB
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"selected processor does not support ARM opcodes"
argument_list|)
argument_list|)
expr_stmt|;
name|thumb_mode
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|need_pass_2
condition|)
name|frag_align
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|record_alignment
argument_list|(
name|now_seg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"invalid instruction size selected (%d)"
argument_list|)
argument_list|,
name|width
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|s_arm
parameter_list|(
name|ignore
parameter_list|)
name|int
name|ignore
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|opcode_select
argument_list|(
literal|32
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|s_thumb
parameter_list|(
name|ignore
parameter_list|)
name|int
name|ignore
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|opcode_select
argument_list|(
literal|16
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|s_code
parameter_list|(
name|unused
parameter_list|)
name|int
name|unused
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
specifier|register
name|int
name|temp
decl_stmt|;
name|temp
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|temp
condition|)
block|{
case|case
literal|16
case|:
case|case
literal|32
case|:
name|opcode_select
argument_list|(
name|temp
argument_list|)
expr_stmt|;
break|break;
default|default:
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"invalid operand to .code directive (%d) (expecting 16 or 32)"
argument_list|)
argument_list|,
name|temp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|end_of_line
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|str
operator|!=
literal|'\0'
condition|)
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"Garbage following instruction"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|skip_past_comma
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
modifier|*
name|str
decl_stmt|;
block|{
name|char
modifier|*
name|p
init|=
operator|*
name|str
decl_stmt|,
name|c
decl_stmt|;
name|int
name|comma
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|p
operator|)
operator|==
literal|' '
operator|||
name|c
operator|==
literal|','
condition|)
block|{
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|','
operator|&&
name|comma
operator|++
condition|)
return|return
name|FAIL
return|;
block|}
if|if
condition|(
name|c
operator|==
literal|'\0'
condition|)
return|return
name|FAIL
return|;
operator|*
name|str
operator|=
name|p
expr_stmt|;
return|return
name|comma
condition|?
name|SUCCESS
else|:
name|FAIL
return|;
block|}
end_function

begin_comment
comment|/* A standard register must be given at this point.    Shift is the place to put it in inst.instruction.    Restores input start point on err.    Returns the reg#, or FAIL.  */
end_comment

begin_function
specifier|static
name|int
name|reg_required_here
parameter_list|(
name|str
parameter_list|,
name|shift
parameter_list|)
name|char
modifier|*
modifier|*
name|str
decl_stmt|;
name|int
name|shift
decl_stmt|;
block|{
specifier|static
name|char
name|buff
index|[
literal|128
index|]
decl_stmt|;
comment|/* XXX */
name|int
name|reg
decl_stmt|;
name|char
modifier|*
name|start
init|=
operator|*
name|str
decl_stmt|;
if|if
condition|(
operator|(
name|reg
operator|=
name|arm_reg_parse
argument_list|(
name|str
argument_list|)
operator|)
operator|!=
name|FAIL
operator|&&
name|int_register
argument_list|(
name|reg
argument_list|)
condition|)
block|{
if|if
condition|(
name|shift
operator|>=
literal|0
condition|)
name|inst
operator|.
name|instruction
operator||=
name|reg
operator|<<
name|shift
expr_stmt|;
return|return
name|reg
return|;
block|}
comment|/* Restore the start point, we may have got a reg of the wrong class.  */
operator|*
name|str
operator|=
name|start
expr_stmt|;
comment|/* In the few cases where we might be able to accept something else      this error can be overridden.  */
name|sprintf
argument_list|(
name|buff
argument_list|,
name|_
argument_list|(
literal|"Register expected, not '%.100s'"
argument_list|)
argument_list|,
name|start
argument_list|)
expr_stmt|;
name|inst
operator|.
name|error
operator|=
name|buff
expr_stmt|;
return|return
name|FAIL
return|;
block|}
end_function

begin_expr_stmt
specifier|static
name|CONST
expr|struct
name|asm_psr
operator|*
name|arm_psr_parse
argument_list|(
name|ccp
argument_list|)
specifier|register
name|char
operator|*
operator|*
name|ccp
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|char
modifier|*
name|start
init|=
operator|*
name|ccp
decl_stmt|;
name|char
name|c
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|CONST
name|struct
name|asm_psr
modifier|*
name|psr
decl_stmt|;
name|p
operator|=
name|start
expr_stmt|;
comment|/* Skip to the end of the next word in the input stream.  */
do|do
block|{
name|c
operator|=
operator|*
name|p
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|isalpha
argument_list|(
name|c
argument_list|)
operator|||
name|c
operator|==
literal|'_'
condition|)
do|;
comment|/* Terminate the word.  */
operator|*
operator|--
name|p
operator|=
literal|0
expr_stmt|;
comment|/* Now locate the word in the psr hash table.  */
name|psr
operator|=
operator|(
name|CONST
expr|struct
name|asm_psr
operator|*
operator|)
name|hash_find
argument_list|(
name|arm_psr_hsh
argument_list|,
name|start
argument_list|)
expr_stmt|;
comment|/* Restore the input stream.  */
operator|*
name|p
operator|=
name|c
expr_stmt|;
comment|/* If we found a valid match, advance the      stream pointer past the end of the word.  */
operator|*
name|ccp
operator|=
name|p
expr_stmt|;
return|return
name|psr
return|;
block|}
end_block

begin_comment
comment|/* Parse the input looking for a PSR flag.  */
end_comment

begin_function
specifier|static
name|int
name|psr_required_here
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
modifier|*
name|str
decl_stmt|;
block|{
name|char
modifier|*
name|start
init|=
operator|*
name|str
decl_stmt|;
name|CONST
name|struct
name|asm_psr
modifier|*
name|psr
decl_stmt|;
name|psr
operator|=
name|arm_psr_parse
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|psr
condition|)
block|{
comment|/* If this is the SPSR that is being modified, set the R bit.  */
if|if
condition|(
operator|!
name|psr
operator|->
name|cpsr
condition|)
name|inst
operator|.
name|instruction
operator||=
name|SPSR_BIT
expr_stmt|;
comment|/* Set the psr flags in the MSR instruction.  */
name|inst
operator|.
name|instruction
operator||=
name|psr
operator|->
name|field
operator|<<
name|PSR_SHIFT
expr_stmt|;
return|return
name|SUCCESS
return|;
block|}
comment|/* In the few cases where we might be able to accept      something else this error can be overridden.  */
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"flag for {c}psr instruction expected"
argument_list|)
expr_stmt|;
comment|/* Restore the start point.  */
operator|*
name|str
operator|=
name|start
expr_stmt|;
return|return
name|FAIL
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|co_proc_number
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
modifier|*
name|str
decl_stmt|;
block|{
name|int
name|processor
decl_stmt|,
name|pchar
decl_stmt|;
name|skip_whitespace
argument_list|(
operator|*
name|str
argument_list|)
expr_stmt|;
comment|/* The data sheet seems to imply that just a number on its own is valid      here, but the RISC iX assembler seems to accept a prefix 'p'.  We will      accept either.  */
if|if
condition|(
operator|*
operator|*
name|str
operator|==
literal|'p'
operator|||
operator|*
operator|*
name|str
operator|==
literal|'P'
condition|)
operator|(
operator|*
name|str
operator|)
operator|++
expr_stmt|;
name|pchar
operator|=
operator|*
operator|(
operator|*
name|str
operator|)
operator|++
expr_stmt|;
if|if
condition|(
name|pchar
operator|>=
literal|'0'
operator|&&
name|pchar
operator|<=
literal|'9'
condition|)
block|{
name|processor
operator|=
name|pchar
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
operator|*
operator|*
name|str
operator|>=
literal|'0'
operator|&&
operator|*
operator|*
name|str
operator|<=
literal|'9'
condition|)
block|{
name|processor
operator|=
name|processor
operator|*
literal|10
operator|+
operator|*
operator|(
operator|*
name|str
operator|)
operator|++
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
name|processor
operator|>
literal|15
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"Illegal co-processor number"
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
block|}
block|}
block|}
else|else
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"Bad or missing co-processor number"
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
block|}
name|inst
operator|.
name|instruction
operator||=
name|processor
operator|<<
literal|8
expr_stmt|;
return|return
name|SUCCESS
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cp_opc_expr
parameter_list|(
name|str
parameter_list|,
name|where
parameter_list|,
name|length
parameter_list|)
name|char
modifier|*
modifier|*
name|str
decl_stmt|;
name|int
name|where
decl_stmt|;
name|int
name|length
decl_stmt|;
block|{
name|expressionS
name|expr
decl_stmt|;
name|skip_whitespace
argument_list|(
operator|*
name|str
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|expr
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|my_get_expression
argument_list|(
operator|&
name|expr
argument_list|,
name|str
argument_list|)
condition|)
return|return
name|FAIL
return|;
if|if
condition|(
name|expr
operator|.
name|X_op
operator|!=
name|O_constant
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"bad or missing expression"
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
block|}
if|if
condition|(
operator|(
name|expr
operator|.
name|X_add_number
operator|&
operator|(
operator|(
literal|1
operator|<<
name|length
operator|)
operator|-
literal|1
operator|)
operator|)
operator|!=
name|expr
operator|.
name|X_add_number
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"immediate co-processor expression too large"
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
block|}
name|inst
operator|.
name|instruction
operator||=
name|expr
operator|.
name|X_add_number
operator|<<
name|where
expr_stmt|;
return|return
name|SUCCESS
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cp_reg_required_here
parameter_list|(
name|str
parameter_list|,
name|where
parameter_list|)
name|char
modifier|*
modifier|*
name|str
decl_stmt|;
name|int
name|where
decl_stmt|;
block|{
name|int
name|reg
decl_stmt|;
name|char
modifier|*
name|start
init|=
operator|*
name|str
decl_stmt|;
if|if
condition|(
operator|(
name|reg
operator|=
name|arm_reg_parse
argument_list|(
name|str
argument_list|)
operator|)
operator|!=
name|FAIL
operator|&&
name|cp_register
argument_list|(
name|reg
argument_list|)
condition|)
block|{
name|reg
operator|&=
literal|15
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|reg
operator|<<
name|where
expr_stmt|;
return|return
name|reg
return|;
block|}
comment|/* In the few cases where we might be able to accept something else      this error can be overridden.  */
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"Co-processor register expected"
argument_list|)
expr_stmt|;
comment|/* Restore the start point.  */
operator|*
name|str
operator|=
name|start
expr_stmt|;
return|return
name|FAIL
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|fp_reg_required_here
parameter_list|(
name|str
parameter_list|,
name|where
parameter_list|)
name|char
modifier|*
modifier|*
name|str
decl_stmt|;
name|int
name|where
decl_stmt|;
block|{
name|int
name|reg
decl_stmt|;
name|char
modifier|*
name|start
init|=
operator|*
name|str
decl_stmt|;
if|if
condition|(
operator|(
name|reg
operator|=
name|arm_reg_parse
argument_list|(
name|str
argument_list|)
operator|)
operator|!=
name|FAIL
operator|&&
name|fp_register
argument_list|(
name|reg
argument_list|)
condition|)
block|{
name|reg
operator|&=
literal|7
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|reg
operator|<<
name|where
expr_stmt|;
return|return
name|reg
return|;
block|}
comment|/* In the few cases where we might be able to accept something else      this error can be overridden.  */
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"Floating point register expected"
argument_list|)
expr_stmt|;
comment|/* Restore the start point.  */
operator|*
name|str
operator|=
name|start
expr_stmt|;
return|return
name|FAIL
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cp_address_offset
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
modifier|*
name|str
decl_stmt|;
block|{
name|int
name|offset
decl_stmt|;
name|skip_whitespace
argument_list|(
operator|*
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|is_immediate_prefix
argument_list|(
operator|*
operator|*
name|str
argument_list|)
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"immediate expression expected"
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
block|}
operator|(
operator|*
name|str
operator|)
operator|++
expr_stmt|;
if|if
condition|(
name|my_get_expression
argument_list|(
operator|&
name|inst
operator|.
name|reloc
operator|.
name|exp
argument_list|,
name|str
argument_list|)
condition|)
return|return
name|FAIL
return|;
if|if
condition|(
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_op
operator|==
name|O_constant
condition|)
block|{
name|offset
operator|=
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_add_number
expr_stmt|;
if|if
condition|(
name|offset
operator|&
literal|3
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"co-processor address must be word aligned"
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
block|}
if|if
condition|(
name|offset
operator|>
literal|1023
operator|||
name|offset
operator|<
operator|-
literal|1023
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"offset too large"
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
block|}
if|if
condition|(
name|offset
operator|>=
literal|0
condition|)
name|inst
operator|.
name|instruction
operator||=
name|INDEX_UP
expr_stmt|;
else|else
name|offset
operator|=
operator|-
name|offset
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|offset
operator|>>
literal|2
expr_stmt|;
block|}
else|else
name|inst
operator|.
name|reloc
operator|.
name|type
operator|=
name|BFD_RELOC_ARM_CP_OFF_IMM
expr_stmt|;
return|return
name|SUCCESS
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cp_address_required_here
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
modifier|*
name|str
decl_stmt|;
block|{
name|char
modifier|*
name|p
init|=
operator|*
name|str
decl_stmt|;
name|int
name|pre_inc
init|=
literal|0
decl_stmt|;
name|int
name|write_back
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'['
condition|)
block|{
name|int
name|reg
decl_stmt|;
name|p
operator|++
expr_stmt|;
name|skip_whitespace
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|reg
operator|=
name|reg_required_here
argument_list|(
operator|&
name|p
argument_list|,
literal|16
argument_list|)
operator|)
operator|==
name|FAIL
condition|)
return|return
name|FAIL
return|;
name|skip_whitespace
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|']'
condition|)
block|{
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|skip_past_comma
argument_list|(
operator|&
name|p
argument_list|)
operator|==
name|SUCCESS
condition|)
block|{
comment|/* [Rn], #expr */
name|write_back
operator|=
name|WRITE_BACK
expr_stmt|;
if|if
condition|(
name|reg
operator|==
name|REG_PC
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"pc may not be used in post-increment"
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
block|}
if|if
condition|(
name|cp_address_offset
argument_list|(
operator|&
name|p
argument_list|)
operator|==
name|FAIL
condition|)
return|return
name|FAIL
return|;
block|}
else|else
name|pre_inc
operator|=
name|PRE_INDEX
operator||
name|INDEX_UP
expr_stmt|;
block|}
else|else
block|{
comment|/* '['Rn, #expr']'[!] */
if|if
condition|(
name|skip_past_comma
argument_list|(
operator|&
name|p
argument_list|)
operator|==
name|FAIL
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"pre-indexed expression expected"
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
block|}
name|pre_inc
operator|=
name|PRE_INDEX
expr_stmt|;
if|if
condition|(
name|cp_address_offset
argument_list|(
operator|&
name|p
argument_list|)
operator|==
name|FAIL
condition|)
return|return
name|FAIL
return|;
name|skip_whitespace
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|++
operator|!=
literal|']'
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"missing ]"
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
block|}
name|skip_whitespace
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'!'
condition|)
block|{
if|if
condition|(
name|reg
operator|==
name|REG_PC
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"pc may not be used with write-back"
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
block|}
name|p
operator|++
expr_stmt|;
name|write_back
operator|=
name|WRITE_BACK
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
name|my_get_expression
argument_list|(
operator|&
name|inst
operator|.
name|reloc
operator|.
name|exp
argument_list|,
operator|&
name|p
argument_list|)
condition|)
return|return
name|FAIL
return|;
name|inst
operator|.
name|reloc
operator|.
name|type
operator|=
name|BFD_RELOC_ARM_CP_OFF_IMM
expr_stmt|;
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_add_number
operator|-=
literal|8
expr_stmt|;
comment|/* PC rel adjust */
name|inst
operator|.
name|reloc
operator|.
name|pc_rel
operator|=
literal|1
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
operator|(
name|REG_PC
operator|<<
literal|16
operator|)
expr_stmt|;
name|pre_inc
operator|=
name|PRE_INDEX
expr_stmt|;
block|}
name|inst
operator|.
name|instruction
operator||=
name|write_back
operator||
name|pre_inc
expr_stmt|;
operator|*
name|str
operator|=
name|p
expr_stmt|;
return|return
name|SUCCESS
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_nop
parameter_list|(
name|str
parameter_list|,
name|flags
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
name|unsigned
name|long
name|flags
decl_stmt|;
block|{
comment|/* Do nothing really.  */
name|inst
operator|.
name|instruction
operator||=
name|flags
expr_stmt|;
comment|/* This is pointless.  */
name|end_of_line
argument_list|(
name|str
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|do_mrs
parameter_list|(
name|str
parameter_list|,
name|flags
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
name|unsigned
name|long
name|flags
decl_stmt|;
block|{
name|int
name|skip
init|=
literal|0
decl_stmt|;
comment|/* Only one syntax.  */
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|12
argument_list|)
operator|==
name|FAIL
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|BAD_ARGS
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"comma expected after register name"
argument_list|)
expr_stmt|;
return|return;
block|}
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|str
argument_list|,
literal|"CPSR"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|str
argument_list|,
literal|"SPSR"
argument_list|)
operator|==
literal|0
comment|/* Lower case versions for backwards compatability.  */
operator|||
name|strcmp
argument_list|(
name|str
argument_list|,
literal|"cpsr"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|str
argument_list|,
literal|"spsr"
argument_list|)
operator|==
literal|0
condition|)
name|skip
operator|=
literal|4
expr_stmt|;
comment|/* This is for backwards compatability with older toolchains.  */
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|str
argument_list|,
literal|"cpsr_all"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|str
argument_list|,
literal|"spsr_all"
argument_list|)
operator|==
literal|0
condition|)
name|skip
operator|=
literal|8
expr_stmt|;
else|else
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"{C|S}PSR expected"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|*
name|str
operator|==
literal|'s'
operator|||
operator|*
name|str
operator|==
literal|'S'
condition|)
name|inst
operator|.
name|instruction
operator||=
name|SPSR_BIT
expr_stmt|;
name|str
operator|+=
name|skip
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|flags
expr_stmt|;
name|end_of_line
argument_list|(
name|str
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Two possible forms:       "{C|S}PSR_<field>, Rm",       "{C|S}PSR_f, #expression".  */
end_comment

begin_function
specifier|static
name|void
name|do_msr
parameter_list|(
name|str
parameter_list|,
name|flags
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
name|unsigned
name|long
name|flags
decl_stmt|;
block|{
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|psr_required_here
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
condition|)
return|return;
if|if
condition|(
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"comma missing after psr flags"
argument_list|)
expr_stmt|;
return|return;
block|}
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|0
argument_list|)
operator|!=
name|FAIL
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|NULL
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|flags
expr_stmt|;
name|end_of_line
argument_list|(
name|str
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|is_immediate_prefix
argument_list|(
operator|*
name|str
argument_list|)
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"only a register or immediate value can follow a psr flag"
argument_list|)
expr_stmt|;
return|return;
block|}
name|str
operator|++
expr_stmt|;
name|inst
operator|.
name|error
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|my_get_expression
argument_list|(
operator|&
name|inst
operator|.
name|reloc
operator|.
name|exp
argument_list|,
operator|&
name|str
argument_list|)
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"only a register or immediate value can follow a psr flag"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|inst
operator|.
name|instruction
operator|&
operator|(
operator|(
name|PSR_c
operator||
name|PSR_x
operator||
name|PSR_s
operator|)
operator|<<
name|PSR_SHIFT
operator|)
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"only flag field of psr can be set with immediate value"
argument_list|)
expr_stmt|;
return|return;
block|}
name|flags
operator||=
name|INST_IMMEDIATE
expr_stmt|;
if|if
condition|(
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_add_symbol
condition|)
block|{
name|inst
operator|.
name|reloc
operator|.
name|type
operator|=
name|BFD_RELOC_ARM_IMMEDIATE
expr_stmt|;
name|inst
operator|.
name|reloc
operator|.
name|pc_rel
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|unsigned
name|value
init|=
name|validate_immediate
argument_list|(
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_add_number
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|==
operator|(
name|unsigned
operator|)
name|FAIL
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"Invalid constant"
argument_list|)
expr_stmt|;
return|return;
block|}
name|inst
operator|.
name|instruction
operator||=
name|value
expr_stmt|;
block|}
name|inst
operator|.
name|error
operator|=
name|NULL
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|flags
expr_stmt|;
name|end_of_line
argument_list|(
name|str
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Long Multiply Parser    UMULL RdLo, RdHi, Rm, Rs    SMULL RdLo, RdHi, Rm, Rs    UMLAL RdLo, RdHi, Rm, Rs    SMLAL RdLo, RdHi, Rm, Rs */
end_comment

begin_function
specifier|static
name|void
name|do_mull
parameter_list|(
name|str
parameter_list|,
name|flags
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
name|unsigned
name|long
name|flags
decl_stmt|;
block|{
name|int
name|rdlo
decl_stmt|,
name|rdhi
decl_stmt|,
name|rm
decl_stmt|,
name|rs
decl_stmt|;
comment|/* Only one format "rdlo, rdhi, rm, rs" */
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|rdlo
operator|=
name|reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|12
argument_list|)
operator|)
operator|==
name|FAIL
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|BAD_ARGS
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
operator|||
operator|(
name|rdhi
operator|=
name|reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|16
argument_list|)
operator|)
operator|==
name|FAIL
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|BAD_ARGS
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
operator|||
operator|(
name|rm
operator|=
name|reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
name|FAIL
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|BAD_ARGS
expr_stmt|;
return|return;
block|}
comment|/* rdhi, rdlo and rm must all be different */
if|if
condition|(
name|rdlo
operator|==
name|rdhi
operator|||
name|rdlo
operator|==
name|rm
operator|||
name|rdhi
operator|==
name|rm
condition|)
name|as_tsktsk
argument_list|(
name|_
argument_list|(
literal|"rdhi, rdlo and rm must all be different"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
operator|||
operator|(
name|rs
operator|=
name|reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|8
argument_list|)
operator|)
operator|==
name|FAIL
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|BAD_ARGS
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|rdhi
operator|==
name|REG_PC
operator|||
name|rdhi
operator|==
name|REG_PC
operator|||
name|rdhi
operator|==
name|REG_PC
operator|||
name|rdhi
operator|==
name|REG_PC
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|BAD_PC
expr_stmt|;
return|return;
block|}
name|inst
operator|.
name|instruction
operator||=
name|flags
expr_stmt|;
name|end_of_line
argument_list|(
name|str
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|do_mul
parameter_list|(
name|str
parameter_list|,
name|flags
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
name|unsigned
name|long
name|flags
decl_stmt|;
block|{
name|int
name|rd
decl_stmt|,
name|rm
decl_stmt|;
comment|/* Only one format "rd, rm, rs" */
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|rd
operator|=
name|reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|16
argument_list|)
operator|)
operator|==
name|FAIL
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|BAD_ARGS
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|rd
operator|==
name|REG_PC
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|BAD_PC
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
operator|||
operator|(
name|rm
operator|=
name|reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
name|FAIL
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|BAD_ARGS
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|rm
operator|==
name|REG_PC
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|BAD_PC
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|rm
operator|==
name|rd
condition|)
name|as_tsktsk
argument_list|(
name|_
argument_list|(
literal|"rd and rm should be different in mul"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
operator|||
operator|(
name|rm
operator|=
name|reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|8
argument_list|)
operator|)
operator|==
name|FAIL
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|BAD_ARGS
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|rm
operator|==
name|REG_PC
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|BAD_PC
expr_stmt|;
return|return;
block|}
name|inst
operator|.
name|instruction
operator||=
name|flags
expr_stmt|;
name|end_of_line
argument_list|(
name|str
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|do_mla
parameter_list|(
name|str
parameter_list|,
name|flags
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
name|unsigned
name|long
name|flags
decl_stmt|;
block|{
name|int
name|rd
decl_stmt|,
name|rm
decl_stmt|;
comment|/* Only one format "rd, rm, rs, rn" */
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|rd
operator|=
name|reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|16
argument_list|)
operator|)
operator|==
name|FAIL
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|BAD_ARGS
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|rd
operator|==
name|REG_PC
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|BAD_PC
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
operator|||
operator|(
name|rm
operator|=
name|reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
name|FAIL
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|BAD_ARGS
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|rm
operator|==
name|REG_PC
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|BAD_PC
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|rm
operator|==
name|rd
condition|)
name|as_tsktsk
argument_list|(
name|_
argument_list|(
literal|"rd and rm should be different in mla"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
operator|||
operator|(
name|rd
operator|=
name|reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|8
argument_list|)
operator|)
operator|==
name|FAIL
operator|||
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
operator|||
operator|(
name|rm
operator|=
name|reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|12
argument_list|)
operator|)
operator|==
name|FAIL
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|BAD_ARGS
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|rd
operator|==
name|REG_PC
operator|||
name|rm
operator|==
name|REG_PC
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|BAD_PC
expr_stmt|;
return|return;
block|}
name|inst
operator|.
name|instruction
operator||=
name|flags
expr_stmt|;
name|end_of_line
argument_list|(
name|str
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* Returns the index into fp_values of a floating point number, or -1 if    not in the table.  */
end_comment

begin_function
specifier|static
name|int
name|my_get_float_expression
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
modifier|*
name|str
decl_stmt|;
block|{
name|LITTLENUM_TYPE
name|words
index|[
name|MAX_LITTLENUMS
index|]
decl_stmt|;
name|char
modifier|*
name|save_in
decl_stmt|;
name|expressionS
name|exp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|j
decl_stmt|;
name|memset
argument_list|(
name|words
argument_list|,
literal|0
argument_list|,
name|MAX_LITTLENUMS
operator|*
sizeof|sizeof
argument_list|(
name|LITTLENUM_TYPE
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Look for a raw floating point number */
if|if
condition|(
operator|(
name|save_in
operator|=
name|atof_ieee
argument_list|(
operator|*
name|str
argument_list|,
literal|'x'
argument_list|,
name|words
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
operator|(
name|is_end_of_line
index|[
call|(
name|int
call|)
argument_list|(
operator|*
name|save_in
argument_list|)
index|]
operator|||
operator|*
name|save_in
operator|==
literal|'\0'
operator|)
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_FLOAT_VALS
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|MAX_LITTLENUMS
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|words
index|[
name|j
index|]
operator|!=
name|fp_values
index|[
name|i
index|]
index|[
name|j
index|]
condition|)
break|break;
block|}
if|if
condition|(
name|j
operator|==
name|MAX_LITTLENUMS
condition|)
block|{
operator|*
name|str
operator|=
name|save_in
expr_stmt|;
return|return
name|i
return|;
block|}
block|}
block|}
comment|/* Try and parse a more complex expression, this will probably fail      unless the code uses a floating point prefix (eg "0f") */
name|save_in
operator|=
name|input_line_pointer
expr_stmt|;
name|input_line_pointer
operator|=
operator|*
name|str
expr_stmt|;
if|if
condition|(
name|expression
argument_list|(
operator|&
name|exp
argument_list|)
operator|==
name|absolute_section
operator|&&
name|exp
operator|.
name|X_op
operator|==
name|O_big
operator|&&
name|exp
operator|.
name|X_add_number
operator|<
literal|0
condition|)
block|{
comment|/* FIXME: 5 = X_PRECISION, should be #define'd where we can use it. 	 Ditto for 15.  */
if|if
condition|(
name|gen_to_words
argument_list|(
name|words
argument_list|,
literal|5
argument_list|,
operator|(
name|long
operator|)
literal|15
argument_list|)
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_FLOAT_VALS
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|MAX_LITTLENUMS
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|words
index|[
name|j
index|]
operator|!=
name|fp_values
index|[
name|i
index|]
index|[
name|j
index|]
condition|)
break|break;
block|}
if|if
condition|(
name|j
operator|==
name|MAX_LITTLENUMS
condition|)
block|{
operator|*
name|str
operator|=
name|input_line_pointer
expr_stmt|;
name|input_line_pointer
operator|=
name|save_in
expr_stmt|;
return|return
name|i
return|;
block|}
block|}
block|}
block|}
operator|*
name|str
operator|=
name|input_line_pointer
expr_stmt|;
name|input_line_pointer
operator|=
name|save_in
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Return true if anything in the expression is a bignum */
end_comment

begin_function
specifier|static
name|int
name|walk_no_bignums
parameter_list|(
name|sp
parameter_list|)
name|symbolS
modifier|*
name|sp
decl_stmt|;
block|{
if|if
condition|(
name|symbol_get_value_expression
argument_list|(
name|sp
argument_list|)
operator|->
name|X_op
operator|==
name|O_big
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|symbol_get_value_expression
argument_list|(
name|sp
argument_list|)
operator|->
name|X_add_symbol
condition|)
block|{
return|return
operator|(
name|walk_no_bignums
argument_list|(
name|symbol_get_value_expression
argument_list|(
name|sp
argument_list|)
operator|->
name|X_add_symbol
argument_list|)
operator|||
operator|(
name|symbol_get_value_expression
argument_list|(
name|sp
argument_list|)
operator|->
name|X_op_symbol
operator|&&
name|walk_no_bignums
argument_list|(
name|symbol_get_value_expression
argument_list|(
name|sp
argument_list|)
operator|->
name|X_op_symbol
argument_list|)
operator|)
operator|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|my_get_expression
parameter_list|(
name|ep
parameter_list|,
name|str
parameter_list|)
name|expressionS
modifier|*
name|ep
decl_stmt|;
name|char
modifier|*
modifier|*
name|str
decl_stmt|;
block|{
name|char
modifier|*
name|save_in
decl_stmt|;
name|segT
name|seg
decl_stmt|;
name|save_in
operator|=
name|input_line_pointer
expr_stmt|;
name|input_line_pointer
operator|=
operator|*
name|str
expr_stmt|;
name|seg
operator|=
name|expression
argument_list|(
name|ep
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|OBJ_AOUT
if|if
condition|(
name|seg
operator|!=
name|absolute_section
operator|&&
name|seg
operator|!=
name|text_section
operator|&&
name|seg
operator|!=
name|data_section
operator|&&
name|seg
operator|!=
name|bss_section
operator|&&
name|seg
operator|!=
name|undefined_section
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"bad_segment"
argument_list|)
expr_stmt|;
operator|*
name|str
operator|=
name|input_line_pointer
expr_stmt|;
name|input_line_pointer
operator|=
name|save_in
expr_stmt|;
return|return
literal|1
return|;
block|}
endif|#
directive|endif
comment|/* Get rid of any bignums now, so that we don't generate an error for which      we can't establish a line number later on.  Big numbers are never valid      in instructions, which is where this routine is always called.  */
if|if
condition|(
name|ep
operator|->
name|X_op
operator|==
name|O_big
operator|||
operator|(
name|ep
operator|->
name|X_add_symbol
operator|&&
operator|(
name|walk_no_bignums
argument_list|(
name|ep
operator|->
name|X_add_symbol
argument_list|)
operator|||
operator|(
name|ep
operator|->
name|X_op_symbol
operator|&&
name|walk_no_bignums
argument_list|(
name|ep
operator|->
name|X_op_symbol
argument_list|)
operator|)
operator|)
operator|)
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"Invalid constant"
argument_list|)
expr_stmt|;
operator|*
name|str
operator|=
name|input_line_pointer
expr_stmt|;
name|input_line_pointer
operator|=
name|save_in
expr_stmt|;
return|return
literal|1
return|;
block|}
operator|*
name|str
operator|=
name|input_line_pointer
expr_stmt|;
name|input_line_pointer
operator|=
name|save_in
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* unrestrict should be one if<shift><register> is permitted for this    instruction */
end_comment

begin_function
specifier|static
name|int
name|decode_shift
parameter_list|(
name|str
parameter_list|,
name|unrestrict
parameter_list|)
name|char
modifier|*
modifier|*
name|str
decl_stmt|;
name|int
name|unrestrict
decl_stmt|;
block|{
name|struct
name|asm_shift
modifier|*
name|shft
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|char
name|c
decl_stmt|;
name|skip_whitespace
argument_list|(
operator|*
name|str
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
operator|*
name|str
init|;
name|isalpha
argument_list|(
operator|*
name|p
argument_list|)
condition|;
name|p
operator|++
control|)
empty_stmt|;
if|if
condition|(
name|p
operator|==
operator|*
name|str
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"Shift expression expected"
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
block|}
name|c
operator|=
operator|*
name|p
expr_stmt|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
name|shft
operator|=
operator|(
expr|struct
name|asm_shift
operator|*
operator|)
name|hash_find
argument_list|(
name|arm_shift_hsh
argument_list|,
operator|*
name|str
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|shft
condition|)
block|{
if|if
condition|(
operator|!
name|strncmp
argument_list|(
operator|*
name|str
argument_list|,
literal|"rrx"
argument_list|,
literal|3
argument_list|)
operator|||
operator|!
name|strncmp
argument_list|(
operator|*
name|str
argument_list|,
literal|"RRX"
argument_list|,
literal|3
argument_list|)
condition|)
block|{
operator|*
name|str
operator|=
name|p
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|shft
operator|->
name|value
expr_stmt|;
return|return
name|SUCCESS
return|;
block|}
name|skip_whitespace
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|unrestrict
operator|&&
name|reg_required_here
argument_list|(
operator|&
name|p
argument_list|,
literal|8
argument_list|)
operator|!=
name|FAIL
condition|)
block|{
name|inst
operator|.
name|instruction
operator||=
name|shft
operator|->
name|value
operator||
name|SHIFT_BY_REG
expr_stmt|;
operator|*
name|str
operator|=
name|p
expr_stmt|;
return|return
name|SUCCESS
return|;
block|}
elseif|else
if|if
condition|(
name|is_immediate_prefix
argument_list|(
operator|*
name|p
argument_list|)
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|NULL
expr_stmt|;
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|my_get_expression
argument_list|(
operator|&
name|inst
operator|.
name|reloc
operator|.
name|exp
argument_list|,
operator|&
name|p
argument_list|)
condition|)
return|return
name|FAIL
return|;
comment|/* Validate some simple #expressions */
if|if
condition|(
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_op
operator|==
name|O_constant
condition|)
block|{
name|unsigned
name|num
init|=
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_add_number
decl_stmt|;
comment|/* Reject operations greater than 32, or lsl #32 */
if|if
condition|(
name|num
operator|>
literal|32
operator|||
operator|(
name|num
operator|==
literal|32
operator|&&
name|shft
operator|->
name|value
operator|==
literal|0
operator|)
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"Invalid immediate shift"
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
block|}
comment|/* Shifts of zero should be converted to lsl (which is zero)*/
if|if
condition|(
name|num
operator|==
literal|0
condition|)
block|{
operator|*
name|str
operator|=
name|p
expr_stmt|;
return|return
name|SUCCESS
return|;
block|}
comment|/* Shifts of 32 are encoded as 0, for those shifts that 		 support it.  */
if|if
condition|(
name|num
operator|==
literal|32
condition|)
name|num
operator|=
literal|0
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
operator|(
name|num
operator|<<
literal|7
operator|)
operator||
name|shft
operator|->
name|value
expr_stmt|;
operator|*
name|str
operator|=
name|p
expr_stmt|;
return|return
name|SUCCESS
return|;
block|}
name|inst
operator|.
name|reloc
operator|.
name|type
operator|=
name|BFD_RELOC_ARM_SHIFT_IMM
expr_stmt|;
name|inst
operator|.
name|reloc
operator|.
name|pc_rel
operator|=
literal|0
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|shft
operator|->
name|value
expr_stmt|;
operator|*
name|str
operator|=
name|p
expr_stmt|;
return|return
name|SUCCESS
return|;
block|}
else|else
block|{
name|inst
operator|.
name|error
operator|=
name|unrestrict
condition|?
name|_
argument_list|(
literal|"shift requires register or #expression"
argument_list|)
else|:
name|_
argument_list|(
literal|"shift requires #expression"
argument_list|)
expr_stmt|;
operator|*
name|str
operator|=
name|p
expr_stmt|;
return|return
name|FAIL
return|;
block|}
block|}
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"Shift expression expected"
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
block|}
end_function

begin_comment
comment|/* Do those data_ops which can take a negative immediate constant */
end_comment

begin_comment
comment|/* by altering the instuction. A bit of a hack really */
end_comment

begin_comment
comment|/*      MOV<-> MVN         AND<-> BIC         ADC<-> SBC         by inverting the second operand, and         ADD<-> SUB         CMP<-> CMN         by negating the second operand. */
end_comment

begin_function
specifier|static
name|int
name|negate_data_op
parameter_list|(
name|instruction
parameter_list|,
name|value
parameter_list|)
name|unsigned
name|long
modifier|*
name|instruction
decl_stmt|;
name|unsigned
name|long
name|value
decl_stmt|;
block|{
name|int
name|op
decl_stmt|,
name|new_inst
decl_stmt|;
name|unsigned
name|long
name|negated
decl_stmt|,
name|inverted
decl_stmt|;
name|negated
operator|=
name|validate_immediate
argument_list|(
operator|-
name|value
argument_list|)
expr_stmt|;
name|inverted
operator|=
name|validate_immediate
argument_list|(
operator|~
name|value
argument_list|)
expr_stmt|;
name|op
operator|=
operator|(
operator|*
name|instruction
operator|>>
name|DATA_OP_SHIFT
operator|)
operator|&
literal|0xf
expr_stmt|;
switch|switch
condition|(
name|op
condition|)
block|{
comment|/* First negates */
case|case
name|OPCODE_SUB
case|:
comment|/* ADD<-> SUB */
name|new_inst
operator|=
name|OPCODE_ADD
expr_stmt|;
name|value
operator|=
name|negated
expr_stmt|;
break|break;
case|case
name|OPCODE_ADD
case|:
name|new_inst
operator|=
name|OPCODE_SUB
expr_stmt|;
name|value
operator|=
name|negated
expr_stmt|;
break|break;
case|case
name|OPCODE_CMP
case|:
comment|/* CMP<-> CMN */
name|new_inst
operator|=
name|OPCODE_CMN
expr_stmt|;
name|value
operator|=
name|negated
expr_stmt|;
break|break;
case|case
name|OPCODE_CMN
case|:
name|new_inst
operator|=
name|OPCODE_CMP
expr_stmt|;
name|value
operator|=
name|negated
expr_stmt|;
break|break;
comment|/* Now Inverted ops */
case|case
name|OPCODE_MOV
case|:
comment|/* MOV<-> MVN */
name|new_inst
operator|=
name|OPCODE_MVN
expr_stmt|;
name|value
operator|=
name|inverted
expr_stmt|;
break|break;
case|case
name|OPCODE_MVN
case|:
name|new_inst
operator|=
name|OPCODE_MOV
expr_stmt|;
name|value
operator|=
name|inverted
expr_stmt|;
break|break;
case|case
name|OPCODE_AND
case|:
comment|/* AND<-> BIC */
name|new_inst
operator|=
name|OPCODE_BIC
expr_stmt|;
name|value
operator|=
name|inverted
expr_stmt|;
break|break;
case|case
name|OPCODE_BIC
case|:
name|new_inst
operator|=
name|OPCODE_AND
expr_stmt|;
name|value
operator|=
name|inverted
expr_stmt|;
break|break;
case|case
name|OPCODE_ADC
case|:
comment|/* ADC<-> SBC */
name|new_inst
operator|=
name|OPCODE_SBC
expr_stmt|;
name|value
operator|=
name|inverted
expr_stmt|;
break|break;
case|case
name|OPCODE_SBC
case|:
name|new_inst
operator|=
name|OPCODE_ADC
expr_stmt|;
name|value
operator|=
name|inverted
expr_stmt|;
break|break;
comment|/* We cannot do anything */
default|default:
return|return
name|FAIL
return|;
block|}
if|if
condition|(
name|value
operator|==
operator|(
name|unsigned
operator|)
name|FAIL
condition|)
return|return
name|FAIL
return|;
operator|*
name|instruction
operator|&=
name|OPCODE_MASK
expr_stmt|;
operator|*
name|instruction
operator||=
name|new_inst
operator|<<
name|DATA_OP_SHIFT
expr_stmt|;
return|return
name|value
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|data_op2
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
modifier|*
name|str
decl_stmt|;
block|{
name|int
name|value
decl_stmt|;
name|expressionS
name|expr
decl_stmt|;
name|skip_whitespace
argument_list|(
operator|*
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg_required_here
argument_list|(
name|str
argument_list|,
literal|0
argument_list|)
operator|!=
name|FAIL
condition|)
block|{
if|if
condition|(
name|skip_past_comma
argument_list|(
name|str
argument_list|)
operator|==
name|SUCCESS
condition|)
comment|/* Shift operation on register.  */
return|return
name|decode_shift
argument_list|(
name|str
argument_list|,
name|NO_SHIFT_RESTRICT
argument_list|)
return|;
return|return
name|SUCCESS
return|;
block|}
else|else
block|{
comment|/* Immediate expression */
if|if
condition|(
name|is_immediate_prefix
argument_list|(
operator|*
operator|*
name|str
argument_list|)
condition|)
block|{
operator|(
operator|*
name|str
operator|)
operator|++
expr_stmt|;
name|inst
operator|.
name|error
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|my_get_expression
argument_list|(
operator|&
name|inst
operator|.
name|reloc
operator|.
name|exp
argument_list|,
name|str
argument_list|)
condition|)
return|return
name|FAIL
return|;
if|if
condition|(
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_add_symbol
condition|)
block|{
name|inst
operator|.
name|reloc
operator|.
name|type
operator|=
name|BFD_RELOC_ARM_IMMEDIATE
expr_stmt|;
name|inst
operator|.
name|reloc
operator|.
name|pc_rel
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|skip_past_comma
argument_list|(
name|str
argument_list|)
operator|==
name|SUCCESS
condition|)
block|{
comment|/* #x, y -- ie explicit rotation by Y  */
if|if
condition|(
name|my_get_expression
argument_list|(
operator|&
name|expr
argument_list|,
name|str
argument_list|)
condition|)
return|return
name|FAIL
return|;
if|if
condition|(
name|expr
operator|.
name|X_op
operator|!=
name|O_constant
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"Constant expression expected"
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
block|}
comment|/* Rotate must be a multiple of 2 */
if|if
condition|(
operator|(
operator|(
name|unsigned
operator|)
name|expr
operator|.
name|X_add_number
operator|)
operator|>
literal|30
operator|||
operator|(
name|expr
operator|.
name|X_add_number
operator|&
literal|1
operator|)
operator|!=
literal|0
operator|||
operator|(
operator|(
name|unsigned
operator|)
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_add_number
operator|)
operator|>
literal|255
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"Invalid constant"
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
block|}
name|inst
operator|.
name|instruction
operator||=
name|INST_IMMEDIATE
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_add_number
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|expr
operator|.
name|X_add_number
operator|<<
literal|7
expr_stmt|;
return|return
name|SUCCESS
return|;
block|}
comment|/* Implicit rotation, select a suitable one  */
name|value
operator|=
name|validate_immediate
argument_list|(
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_add_number
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|==
name|FAIL
condition|)
block|{
comment|/* Can't be done, perhaps the code reads something like 		     "add Rd, Rn, #-n", where "sub Rd, Rn, #n" would be ok */
if|if
condition|(
operator|(
name|value
operator|=
name|negate_data_op
argument_list|(
operator|&
name|inst
operator|.
name|instruction
argument_list|,
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_add_number
argument_list|)
operator|)
operator|==
name|FAIL
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"Invalid constant"
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
block|}
block|}
name|inst
operator|.
name|instruction
operator||=
name|value
expr_stmt|;
block|}
name|inst
operator|.
name|instruction
operator||=
name|INST_IMMEDIATE
expr_stmt|;
return|return
name|SUCCESS
return|;
block|}
operator|(
operator|*
name|str
operator|)
operator|++
expr_stmt|;
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"Register or shift expression expected"
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|fp_op2
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
modifier|*
name|str
decl_stmt|;
block|{
name|skip_whitespace
argument_list|(
operator|*
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp_reg_required_here
argument_list|(
name|str
argument_list|,
literal|0
argument_list|)
operator|!=
name|FAIL
condition|)
return|return
name|SUCCESS
return|;
else|else
block|{
comment|/* Immediate expression */
if|if
condition|(
operator|*
operator|(
operator|(
operator|*
name|str
operator|)
operator|++
operator|)
operator|==
literal|'#'
condition|)
block|{
name|int
name|i
decl_stmt|;
name|inst
operator|.
name|error
operator|=
name|NULL
expr_stmt|;
name|skip_whitespace
argument_list|(
operator|*
name|str
argument_list|)
expr_stmt|;
comment|/* First try and match exact strings, this is to guarantee that 	     some formats will work even for cross assembly */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|fp_const
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
operator|*
name|str
argument_list|,
name|fp_const
index|[
name|i
index|]
argument_list|,
name|strlen
argument_list|(
name|fp_const
index|[
name|i
index|]
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|char
modifier|*
name|start
init|=
operator|*
name|str
decl_stmt|;
operator|*
name|str
operator|+=
name|strlen
argument_list|(
name|fp_const
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_end_of_line
index|[
operator|(
name|int
operator|)
operator|*
operator|*
name|str
index|]
operator|||
operator|*
operator|*
name|str
operator|==
literal|'\0'
condition|)
block|{
name|inst
operator|.
name|instruction
operator||=
name|i
operator|+
literal|8
expr_stmt|;
return|return
name|SUCCESS
return|;
block|}
operator|*
name|str
operator|=
name|start
expr_stmt|;
block|}
block|}
comment|/* Just because we didn't get a match doesn't mean that the 	     constant isn't valid, just that it is in a format that we 	     don't automatically recognize.  Try parsing it with 	     the standard expression routines.  */
if|if
condition|(
operator|(
name|i
operator|=
name|my_get_float_expression
argument_list|(
name|str
argument_list|)
operator|)
operator|>=
literal|0
condition|)
block|{
name|inst
operator|.
name|instruction
operator||=
name|i
operator|+
literal|8
expr_stmt|;
return|return
name|SUCCESS
return|;
block|}
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"Invalid floating point immediate expression"
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
block|}
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"Floating point register or immediate expression expected"
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|do_arit
parameter_list|(
name|str
parameter_list|,
name|flags
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
name|unsigned
name|long
name|flags
decl_stmt|;
block|{
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|12
argument_list|)
operator|==
name|FAIL
operator|||
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
operator|||
name|reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|16
argument_list|)
operator|==
name|FAIL
operator|||
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
operator|||
name|data_op2
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
condition|)
block|{
if|if
condition|(
operator|!
name|inst
operator|.
name|error
condition|)
name|inst
operator|.
name|error
operator|=
name|BAD_ARGS
expr_stmt|;
return|return;
block|}
name|inst
operator|.
name|instruction
operator||=
name|flags
expr_stmt|;
name|end_of_line
argument_list|(
name|str
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|do_adr
parameter_list|(
name|str
parameter_list|,
name|flags
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
name|unsigned
name|long
name|flags
decl_stmt|;
block|{
comment|/* This is a pseudo-op of the form "adr rd, label" to be converted      into a relative address of the form "add rd, pc, #label-.-8".  */
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|12
argument_list|)
operator|==
name|FAIL
operator|||
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
operator|||
name|my_get_expression
argument_list|(
operator|&
name|inst
operator|.
name|reloc
operator|.
name|exp
argument_list|,
operator|&
name|str
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|inst
operator|.
name|error
condition|)
name|inst
operator|.
name|error
operator|=
name|BAD_ARGS
expr_stmt|;
return|return;
block|}
comment|/* Frag hacking will turn this into a sub instruction if the offset turns      out to be negative.  */
name|inst
operator|.
name|reloc
operator|.
name|type
operator|=
name|BFD_RELOC_ARM_IMMEDIATE
expr_stmt|;
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_add_number
operator|-=
literal|8
expr_stmt|;
comment|/* PC relative adjust.  */
name|inst
operator|.
name|reloc
operator|.
name|pc_rel
operator|=
literal|1
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|flags
expr_stmt|;
name|end_of_line
argument_list|(
name|str
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|do_adrl
parameter_list|(
name|str
parameter_list|,
name|flags
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
name|unsigned
name|long
name|flags
decl_stmt|;
block|{
comment|/* This is a pseudo-op of the form "adrl rd, label" to be converted      into a relative address of the form:      	add rd, pc, #low(label-.-8)"      	add rd, rd, #high(label-.-8)"   */
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|12
argument_list|)
operator|==
name|FAIL
operator|||
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
operator|||
name|my_get_expression
argument_list|(
operator|&
name|inst
operator|.
name|reloc
operator|.
name|exp
argument_list|,
operator|&
name|str
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|inst
operator|.
name|error
condition|)
name|inst
operator|.
name|error
operator|=
name|BAD_ARGS
expr_stmt|;
return|return;
block|}
name|end_of_line
argument_list|(
name|str
argument_list|)
expr_stmt|;
comment|/* Frag hacking will turn this into a sub instruction if the offset turns      out to be negative.  */
name|inst
operator|.
name|reloc
operator|.
name|type
operator|=
name|BFD_RELOC_ARM_ADRL_IMMEDIATE
expr_stmt|;
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_add_number
operator|-=
literal|8
expr_stmt|;
comment|/* PC relative adjust */
name|inst
operator|.
name|reloc
operator|.
name|pc_rel
operator|=
literal|1
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|flags
expr_stmt|;
name|inst
operator|.
name|size
operator|=
name|INSN_SIZE
operator|*
literal|2
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|do_cmp
parameter_list|(
name|str
parameter_list|,
name|flags
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
name|unsigned
name|long
name|flags
decl_stmt|;
block|{
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|16
argument_list|)
operator|==
name|FAIL
condition|)
block|{
if|if
condition|(
operator|!
name|inst
operator|.
name|error
condition|)
name|inst
operator|.
name|error
operator|=
name|BAD_ARGS
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
operator|||
name|data_op2
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
condition|)
block|{
if|if
condition|(
operator|!
name|inst
operator|.
name|error
condition|)
name|inst
operator|.
name|error
operator|=
name|BAD_ARGS
expr_stmt|;
return|return;
block|}
name|inst
operator|.
name|instruction
operator||=
name|flags
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
literal|0x0000f000
operator|)
operator|==
literal|0
condition|)
name|inst
operator|.
name|instruction
operator||=
name|CONDS_BIT
expr_stmt|;
name|end_of_line
argument_list|(
name|str
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|do_mov
parameter_list|(
name|str
parameter_list|,
name|flags
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
name|unsigned
name|long
name|flags
decl_stmt|;
block|{
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|12
argument_list|)
operator|==
name|FAIL
condition|)
block|{
if|if
condition|(
operator|!
name|inst
operator|.
name|error
condition|)
name|inst
operator|.
name|error
operator|=
name|BAD_ARGS
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
operator|||
name|data_op2
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
condition|)
block|{
if|if
condition|(
operator|!
name|inst
operator|.
name|error
condition|)
name|inst
operator|.
name|error
operator|=
name|BAD_ARGS
expr_stmt|;
return|return;
block|}
name|inst
operator|.
name|instruction
operator||=
name|flags
expr_stmt|;
name|end_of_line
argument_list|(
name|str
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|int
name|ldst_extend
parameter_list|(
name|str
parameter_list|,
name|hwse
parameter_list|)
name|char
modifier|*
modifier|*
name|str
decl_stmt|;
name|int
name|hwse
decl_stmt|;
block|{
name|int
name|add
init|=
name|INDEX_UP
decl_stmt|;
switch|switch
condition|(
operator|*
operator|*
name|str
condition|)
block|{
case|case
literal|'#'
case|:
case|case
literal|'$'
case|:
operator|(
operator|*
name|str
operator|)
operator|++
expr_stmt|;
if|if
condition|(
name|my_get_expression
argument_list|(
operator|&
name|inst
operator|.
name|reloc
operator|.
name|exp
argument_list|,
name|str
argument_list|)
condition|)
return|return
name|FAIL
return|;
if|if
condition|(
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_op
operator|==
name|O_constant
condition|)
block|{
name|int
name|value
init|=
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_add_number
decl_stmt|;
if|if
condition|(
operator|(
name|hwse
operator|&&
operator|(
name|value
operator|<
operator|-
literal|255
operator|||
name|value
operator|>
literal|255
operator|)
operator|)
operator|||
operator|(
name|value
operator|<
operator|-
literal|4095
operator|||
name|value
operator|>
literal|4095
operator|)
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"address offset too large"
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
block|}
if|if
condition|(
name|value
operator|<
literal|0
condition|)
block|{
name|value
operator|=
operator|-
name|value
expr_stmt|;
name|add
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Halfword and signextension instructions have the              immediate value split across bits 11..8 and bits 3..0 */
if|if
condition|(
name|hwse
condition|)
name|inst
operator|.
name|instruction
operator||=
name|add
operator||
name|HWOFFSET_IMM
operator||
operator|(
operator|(
name|value
operator|>>
literal|4
operator|)
operator|<<
literal|8
operator|)
operator||
operator|(
name|value
operator|&
literal|0xF
operator|)
expr_stmt|;
else|else
name|inst
operator|.
name|instruction
operator||=
name|add
operator||
name|value
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|hwse
condition|)
block|{
name|inst
operator|.
name|instruction
operator||=
name|HWOFFSET_IMM
expr_stmt|;
name|inst
operator|.
name|reloc
operator|.
name|type
operator|=
name|BFD_RELOC_ARM_OFFSET_IMM8
expr_stmt|;
block|}
else|else
name|inst
operator|.
name|reloc
operator|.
name|type
operator|=
name|BFD_RELOC_ARM_OFFSET_IMM
expr_stmt|;
name|inst
operator|.
name|reloc
operator|.
name|pc_rel
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|SUCCESS
return|;
case|case
literal|'-'
case|:
name|add
operator|=
literal|0
expr_stmt|;
comment|/* and fall through */
case|case
literal|'+'
case|:
operator|(
operator|*
name|str
operator|)
operator|++
expr_stmt|;
comment|/* and fall through */
default|default:
if|if
condition|(
name|reg_required_here
argument_list|(
name|str
argument_list|,
literal|0
argument_list|)
operator|==
name|FAIL
condition|)
return|return
name|FAIL
return|;
if|if
condition|(
name|hwse
condition|)
name|inst
operator|.
name|instruction
operator||=
name|add
expr_stmt|;
else|else
block|{
name|inst
operator|.
name|instruction
operator||=
name|add
operator||
name|OFFSET_REG
expr_stmt|;
if|if
condition|(
name|skip_past_comma
argument_list|(
name|str
argument_list|)
operator|==
name|SUCCESS
condition|)
return|return
name|decode_shift
argument_list|(
name|str
argument_list|,
name|SHIFT_RESTRICT
argument_list|)
return|;
block|}
return|return
name|SUCCESS
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|do_ldst
parameter_list|(
name|str
parameter_list|,
name|flags
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
name|unsigned
name|long
name|flags
decl_stmt|;
block|{
name|int
name|halfword
init|=
literal|0
decl_stmt|;
name|int
name|pre_inc
init|=
literal|0
decl_stmt|;
name|int
name|conflict_reg
decl_stmt|;
name|int
name|value
decl_stmt|;
comment|/* This is not ideal, but it is the simplest way of dealing with the      ARM7T halfword instructions (since they use a different      encoding, but the same mnemonic): */
name|halfword
operator|=
operator|(
name|flags
operator|&
literal|0x80000000
operator|)
operator|!=
literal|0
expr_stmt|;
if|if
condition|(
name|halfword
condition|)
block|{
comment|/* This is actually a load/store of a halfword, or a          signed-extension load */
if|if
condition|(
operator|(
name|cpu_variant
operator|&
name|ARM_HALFWORD
operator|)
operator|==
literal|0
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"Processor does not support halfwords or signed bytes"
argument_list|)
expr_stmt|;
return|return;
block|}
name|inst
operator|.
name|instruction
operator|=
operator|(
name|inst
operator|.
name|instruction
operator|&
name|COND_MASK
operator|)
operator||
operator|(
name|flags
operator|&
operator|~
name|COND_MASK
operator|)
expr_stmt|;
name|flags
operator|=
literal|0
expr_stmt|;
block|}
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|conflict_reg
operator|=
name|reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|12
argument_list|)
operator|)
operator|==
name|FAIL
condition|)
block|{
if|if
condition|(
operator|!
name|inst
operator|.
name|error
condition|)
name|inst
operator|.
name|error
operator|=
name|BAD_ARGS
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"Address expected"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|*
name|str
operator|==
literal|'['
condition|)
block|{
name|int
name|reg
decl_stmt|;
name|str
operator|++
expr_stmt|;
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|reg
operator|=
name|reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|16
argument_list|)
operator|)
operator|==
name|FAIL
condition|)
return|return;
comment|/* Conflicts can occur on stores as well as loads.  */
name|conflict_reg
operator|=
operator|(
name|conflict_reg
operator|==
name|reg
operator|)
expr_stmt|;
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|str
operator|==
literal|']'
condition|)
block|{
name|str
operator|++
expr_stmt|;
if|if
condition|(
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|SUCCESS
condition|)
block|{
comment|/* [Rn],... (post inc) */
if|if
condition|(
name|ldst_extend
argument_list|(
operator|&
name|str
argument_list|,
name|halfword
argument_list|)
operator|==
name|FAIL
condition|)
return|return;
if|if
condition|(
name|conflict_reg
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"%s register same as write-back base"
argument_list|)
argument_list|,
operator|(
name|inst
operator|.
name|instruction
operator|&
name|LOAD_BIT
operator|)
condition|?
name|_
argument_list|(
literal|"destination"
argument_list|)
else|:
name|_
argument_list|(
literal|"source"
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* [Rn] */
if|if
condition|(
name|halfword
condition|)
name|inst
operator|.
name|instruction
operator||=
name|HWOFFSET_IMM
expr_stmt|;
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|str
operator|==
literal|'!'
condition|)
block|{
if|if
condition|(
name|conflict_reg
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"%s register same as write-back base"
argument_list|)
argument_list|,
operator|(
name|inst
operator|.
name|instruction
operator|&
name|LOAD_BIT
operator|)
condition|?
name|_
argument_list|(
literal|"destination"
argument_list|)
else|:
name|_
argument_list|(
literal|"source"
argument_list|)
argument_list|)
expr_stmt|;
name|str
operator|++
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|WRITE_BACK
expr_stmt|;
block|}
name|flags
operator||=
name|INDEX_UP
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|TRANS_BIT
operator|)
condition|)
name|pre_inc
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* [Rn,...] */
if|if
condition|(
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"pre-indexed expression expected"
argument_list|)
expr_stmt|;
return|return;
block|}
name|pre_inc
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|ldst_extend
argument_list|(
operator|&
name|str
argument_list|,
name|halfword
argument_list|)
operator|==
name|FAIL
condition|)
return|return;
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|str
operator|++
operator|!=
literal|']'
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"missing ]"
argument_list|)
expr_stmt|;
return|return;
block|}
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|str
operator|==
literal|'!'
condition|)
block|{
if|if
condition|(
name|conflict_reg
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"%s register same as write-back base"
argument_list|)
argument_list|,
operator|(
name|inst
operator|.
name|instruction
operator|&
name|LOAD_BIT
operator|)
condition|?
name|_
argument_list|(
literal|"destination"
argument_list|)
else|:
name|_
argument_list|(
literal|"source"
argument_list|)
argument_list|)
expr_stmt|;
name|str
operator|++
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|WRITE_BACK
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
operator|*
name|str
operator|==
literal|'='
condition|)
block|{
comment|/* Parse an "ldr Rd, =expr" instruction; this is another pseudo op */
name|str
operator|++
expr_stmt|;
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|my_get_expression
argument_list|(
operator|&
name|inst
operator|.
name|reloc
operator|.
name|exp
argument_list|,
operator|&
name|str
argument_list|)
condition|)
return|return;
if|if
condition|(
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_op
operator|!=
name|O_constant
operator|&&
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_op
operator|!=
name|O_symbol
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"Constant expression expected"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_op
operator|==
name|O_constant
operator|&&
operator|(
name|value
operator|=
name|validate_immediate
argument_list|(
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_add_number
argument_list|)
operator|)
operator|!=
name|FAIL
condition|)
block|{
comment|/* This can be done with a mov instruction */
name|inst
operator|.
name|instruction
operator|&=
name|LITERAL_MASK
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|INST_IMMEDIATE
operator||
operator|(
name|OPCODE_MOV
operator|<<
name|DATA_OP_SHIFT
operator|)
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
operator|(
name|flags
operator|&
name|COND_MASK
operator|)
operator||
operator|(
name|value
operator|&
literal|0xfff
operator|)
expr_stmt|;
name|end_of_line
argument_list|(
name|str
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
comment|/* Insert into literal pool */
if|if
condition|(
name|add_to_lit_pool
argument_list|()
operator|==
name|FAIL
condition|)
block|{
if|if
condition|(
operator|!
name|inst
operator|.
name|error
condition|)
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"literal pool insertion failed"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Change the instruction exp to point to the pool */
if|if
condition|(
name|halfword
condition|)
block|{
name|inst
operator|.
name|instruction
operator||=
name|HWOFFSET_IMM
expr_stmt|;
name|inst
operator|.
name|reloc
operator|.
name|type
operator|=
name|BFD_RELOC_ARM_HWLITERAL
expr_stmt|;
block|}
else|else
name|inst
operator|.
name|reloc
operator|.
name|type
operator|=
name|BFD_RELOC_ARM_LITERAL
expr_stmt|;
name|inst
operator|.
name|reloc
operator|.
name|pc_rel
operator|=
literal|1
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
operator|(
name|REG_PC
operator|<<
literal|16
operator|)
expr_stmt|;
name|pre_inc
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|my_get_expression
argument_list|(
operator|&
name|inst
operator|.
name|reloc
operator|.
name|exp
argument_list|,
operator|&
name|str
argument_list|)
condition|)
return|return;
if|if
condition|(
name|halfword
condition|)
block|{
name|inst
operator|.
name|instruction
operator||=
name|HWOFFSET_IMM
expr_stmt|;
name|inst
operator|.
name|reloc
operator|.
name|type
operator|=
name|BFD_RELOC_ARM_OFFSET_IMM8
expr_stmt|;
block|}
else|else
name|inst
operator|.
name|reloc
operator|.
name|type
operator|=
name|BFD_RELOC_ARM_OFFSET_IMM
expr_stmt|;
ifndef|#
directive|ifndef
name|TE_WINCE
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_add_number
operator|-=
literal|8
expr_stmt|;
comment|/* PC rel adjust */
endif|#
directive|endif
name|inst
operator|.
name|reloc
operator|.
name|pc_rel
operator|=
literal|1
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
operator|(
name|REG_PC
operator|<<
literal|16
operator|)
expr_stmt|;
name|pre_inc
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|pre_inc
operator|&&
operator|(
name|flags
operator|&
name|TRANS_BIT
operator|)
condition|)
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"Pre-increment instruction with translate"
argument_list|)
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|flags
operator||
operator|(
name|pre_inc
condition|?
name|PRE_INDEX
else|:
literal|0
operator|)
expr_stmt|;
name|end_of_line
argument_list|(
name|str
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|long
name|reg_list
parameter_list|(
name|strp
parameter_list|)
name|char
modifier|*
modifier|*
name|strp
decl_stmt|;
block|{
name|char
modifier|*
name|str
init|=
operator|*
name|strp
decl_stmt|;
name|long
name|range
init|=
literal|0
decl_stmt|;
name|int
name|another_range
decl_stmt|;
comment|/* We come back here if we get ranges concatenated by '+' or '|' */
do|do
block|{
name|another_range
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|*
name|str
operator|==
literal|'{'
condition|)
block|{
name|int
name|in_range
init|=
literal|0
decl_stmt|;
name|int
name|cur_reg
init|=
operator|-
literal|1
decl_stmt|;
name|str
operator|++
expr_stmt|;
do|do
block|{
name|int
name|reg
decl_stmt|;
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|reg
operator|=
name|reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
operator|-
literal|1
argument_list|)
operator|)
operator|==
name|FAIL
condition|)
return|return
name|FAIL
return|;
if|if
condition|(
name|in_range
condition|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|reg
operator|<=
name|cur_reg
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"Bad range in register list"
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
block|}
for|for
control|(
name|i
operator|=
name|cur_reg
operator|+
literal|1
init|;
name|i
operator|<
name|reg
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|range
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
condition|)
name|as_tsktsk
argument_list|(
name|_
argument_list|(
literal|"Warning: Duplicated register (r%d) in register list"
argument_list|)
argument_list|,
name|i
argument_list|)
expr_stmt|;
else|else
name|range
operator||=
literal|1
operator|<<
name|i
expr_stmt|;
block|}
name|in_range
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|range
operator|&
operator|(
literal|1
operator|<<
name|reg
operator|)
condition|)
name|as_tsktsk
argument_list|(
name|_
argument_list|(
literal|"Warning: Duplicated register (r%d) in register list"
argument_list|)
argument_list|,
name|reg
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|reg
operator|<=
name|cur_reg
condition|)
name|as_tsktsk
argument_list|(
name|_
argument_list|(
literal|"Warning: Register range not in ascending order"
argument_list|)
argument_list|)
expr_stmt|;
name|range
operator||=
literal|1
operator|<<
name|reg
expr_stmt|;
name|cur_reg
operator|=
name|reg
expr_stmt|;
block|}
do|while
condition|(
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|!=
name|FAIL
operator|||
operator|(
name|in_range
operator|=
literal|1
operator|,
operator|*
name|str
operator|++
operator|==
literal|'-'
operator|)
condition|)
do|;
name|str
operator|--
expr_stmt|;
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|str
operator|++
operator|!=
literal|'}'
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"Missing `}'"
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
block|}
block|}
else|else
block|{
name|expressionS
name|expr
decl_stmt|;
if|if
condition|(
name|my_get_expression
argument_list|(
operator|&
name|expr
argument_list|,
operator|&
name|str
argument_list|)
condition|)
return|return
name|FAIL
return|;
if|if
condition|(
name|expr
operator|.
name|X_op
operator|==
name|O_constant
condition|)
block|{
if|if
condition|(
name|expr
operator|.
name|X_add_number
operator|!=
operator|(
name|expr
operator|.
name|X_add_number
operator|&
literal|0x0000ffff
operator|)
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"invalid register mask"
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
block|}
if|if
condition|(
operator|(
name|range
operator|&
name|expr
operator|.
name|X_add_number
operator|)
operator|!=
literal|0
condition|)
block|{
name|int
name|regno
init|=
name|range
operator|&
name|expr
operator|.
name|X_add_number
decl_stmt|;
name|regno
operator|&=
operator|-
name|regno
expr_stmt|;
name|regno
operator|=
operator|(
literal|1
operator|<<
name|regno
operator|)
operator|-
literal|1
expr_stmt|;
name|as_tsktsk
argument_list|(
name|_
argument_list|(
literal|"Warning: Duplicated register (r%d) in register list"
argument_list|)
argument_list|,
name|regno
argument_list|)
expr_stmt|;
block|}
name|range
operator||=
name|expr
operator|.
name|X_add_number
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|inst
operator|.
name|reloc
operator|.
name|type
operator|!=
literal|0
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"expression too complex"
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
block|}
name|memcpy
argument_list|(
operator|&
name|inst
operator|.
name|reloc
operator|.
name|exp
argument_list|,
operator|&
name|expr
argument_list|,
sizeof|sizeof
argument_list|(
name|expressionS
argument_list|)
argument_list|)
expr_stmt|;
name|inst
operator|.
name|reloc
operator|.
name|type
operator|=
name|BFD_RELOC_ARM_MULTI
expr_stmt|;
name|inst
operator|.
name|reloc
operator|.
name|pc_rel
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|str
operator|==
literal|'|'
operator|||
operator|*
name|str
operator|==
literal|'+'
condition|)
block|{
name|str
operator|++
expr_stmt|;
name|another_range
operator|=
literal|1
expr_stmt|;
block|}
block|}
do|while
condition|(
name|another_range
condition|)
do|;
operator|*
name|strp
operator|=
name|str
expr_stmt|;
return|return
name|range
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_ldmstm
parameter_list|(
name|str
parameter_list|,
name|flags
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
name|unsigned
name|long
name|flags
decl_stmt|;
block|{
name|int
name|base_reg
decl_stmt|;
name|long
name|range
decl_stmt|;
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|base_reg
operator|=
name|reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|16
argument_list|)
operator|)
operator|==
name|FAIL
condition|)
return|return;
if|if
condition|(
name|base_reg
operator|==
name|REG_PC
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"r15 not allowed as base register"
argument_list|)
expr_stmt|;
return|return;
block|}
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|str
operator|==
literal|'!'
condition|)
block|{
name|flags
operator||=
name|WRITE_BACK
expr_stmt|;
name|str
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
operator|||
operator|(
name|range
operator|=
name|reg_list
argument_list|(
operator|&
name|str
argument_list|)
operator|)
operator|==
name|FAIL
condition|)
block|{
if|if
condition|(
operator|!
name|inst
operator|.
name|error
condition|)
name|inst
operator|.
name|error
operator|=
name|BAD_ARGS
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|*
name|str
operator|==
literal|'^'
condition|)
block|{
name|str
operator|++
expr_stmt|;
name|flags
operator||=
name|LDM_TYPE_2_OR_3
expr_stmt|;
block|}
name|inst
operator|.
name|instruction
operator||=
name|flags
operator||
name|range
expr_stmt|;
name|end_of_line
argument_list|(
name|str
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|do_swi
parameter_list|(
name|str
parameter_list|,
name|flags
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
name|unsigned
name|long
name|flags
decl_stmt|;
block|{
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
comment|/* Allow optional leading '#'.  */
if|if
condition|(
name|is_immediate_prefix
argument_list|(
operator|*
name|str
argument_list|)
condition|)
name|str
operator|++
expr_stmt|;
if|if
condition|(
name|my_get_expression
argument_list|(
operator|&
name|inst
operator|.
name|reloc
operator|.
name|exp
argument_list|,
operator|&
name|str
argument_list|)
condition|)
return|return;
name|inst
operator|.
name|reloc
operator|.
name|type
operator|=
name|BFD_RELOC_ARM_SWI
expr_stmt|;
name|inst
operator|.
name|reloc
operator|.
name|pc_rel
operator|=
literal|0
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|flags
expr_stmt|;
name|end_of_line
argument_list|(
name|str
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|do_swap
parameter_list|(
name|str
parameter_list|,
name|flags
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
name|unsigned
name|long
name|flags
decl_stmt|;
block|{
name|int
name|reg
decl_stmt|;
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|reg
operator|=
name|reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|12
argument_list|)
operator|)
operator|==
name|FAIL
condition|)
return|return;
if|if
condition|(
name|reg
operator|==
name|REG_PC
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"r15 not allowed in swap"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
operator|||
operator|(
name|reg
operator|=
name|reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
name|FAIL
condition|)
block|{
if|if
condition|(
operator|!
name|inst
operator|.
name|error
condition|)
name|inst
operator|.
name|error
operator|=
name|BAD_ARGS
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|reg
operator|==
name|REG_PC
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"r15 not allowed in swap"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
operator|||
operator|*
name|str
operator|++
operator|!=
literal|'['
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|BAD_ARGS
expr_stmt|;
return|return;
block|}
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|reg
operator|=
name|reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|16
argument_list|)
operator|)
operator|==
name|FAIL
condition|)
return|return;
if|if
condition|(
name|reg
operator|==
name|REG_PC
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|BAD_PC
expr_stmt|;
return|return;
block|}
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|str
operator|++
operator|!=
literal|']'
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"missing ]"
argument_list|)
expr_stmt|;
return|return;
block|}
name|inst
operator|.
name|instruction
operator||=
name|flags
expr_stmt|;
name|end_of_line
argument_list|(
name|str
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|do_branch
parameter_list|(
name|str
parameter_list|,
name|flags
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
name|unsigned
name|long
name|flags
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
if|if
condition|(
name|my_get_expression
argument_list|(
operator|&
name|inst
operator|.
name|reloc
operator|.
name|exp
argument_list|,
operator|&
name|str
argument_list|)
condition|)
return|return;
ifdef|#
directive|ifdef
name|OBJ_ELF
block|{
name|char
modifier|*
name|save_in
decl_stmt|;
comment|/* ScottB: February 5, 1998 */
comment|/* Check to see of PLT32 reloc required for the instruction.  */
comment|/* arm_parse_reloc() works on input_line_pointer.        We actually want to parse the operands to the branch instruction        passed in 'str'.  Save the input pointer and restore it later.  */
name|save_in
operator|=
name|input_line_pointer
expr_stmt|;
name|input_line_pointer
operator|=
name|str
expr_stmt|;
if|if
condition|(
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_op
operator|==
name|O_symbol
operator|&&
operator|*
name|str
operator|==
literal|'('
operator|&&
name|arm_parse_reloc
argument_list|()
operator|==
name|BFD_RELOC_ARM_PLT32
condition|)
block|{
name|inst
operator|.
name|reloc
operator|.
name|type
operator|=
name|BFD_RELOC_ARM_PLT32
expr_stmt|;
name|inst
operator|.
name|reloc
operator|.
name|pc_rel
operator|=
literal|0
expr_stmt|;
comment|/* Modify str to point to after parsed operands, otherwise 	   end_of_line() will complain about the (PLT) left in str.  */
name|str
operator|=
name|input_line_pointer
expr_stmt|;
block|}
else|else
block|{
name|inst
operator|.
name|reloc
operator|.
name|type
operator|=
name|BFD_RELOC_ARM_PCREL_BRANCH
expr_stmt|;
name|inst
operator|.
name|reloc
operator|.
name|pc_rel
operator|=
literal|1
expr_stmt|;
block|}
name|input_line_pointer
operator|=
name|save_in
expr_stmt|;
block|}
else|#
directive|else
name|inst
operator|.
name|reloc
operator|.
name|type
operator|=
name|BFD_RELOC_ARM_PCREL_BRANCH
expr_stmt|;
name|inst
operator|.
name|reloc
operator|.
name|pc_rel
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
comment|/* OBJ_ELF */
name|end_of_line
argument_list|(
name|str
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|do_bx
parameter_list|(
name|str
parameter_list|,
name|flags
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
name|unsigned
name|long
name|flags
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|int
name|reg
decl_stmt|;
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|reg
operator|=
name|reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
name|FAIL
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|BAD_ARGS
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|reg
operator|==
name|REG_PC
condition|)
name|inst
operator|.
name|error
operator|=
name|BAD_PC
expr_stmt|;
name|end_of_line
argument_list|(
name|str
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_cdp
parameter_list|(
name|str
parameter_list|,
name|flags
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
name|unsigned
name|long
name|flags
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
comment|/* Co-processor data operation.      Format: CDP{cond} CP#,<expr>,CRd,CRn,CRm{,<expr>}  */
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|co_proc_number
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
condition|)
block|{
if|if
condition|(
operator|!
name|inst
operator|.
name|error
condition|)
name|inst
operator|.
name|error
operator|=
name|BAD_ARGS
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
operator|||
name|cp_opc_expr
argument_list|(
operator|&
name|str
argument_list|,
literal|20
argument_list|,
literal|4
argument_list|)
operator|==
name|FAIL
condition|)
block|{
if|if
condition|(
operator|!
name|inst
operator|.
name|error
condition|)
name|inst
operator|.
name|error
operator|=
name|BAD_ARGS
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
operator|||
name|cp_reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|12
argument_list|)
operator|==
name|FAIL
condition|)
block|{
if|if
condition|(
operator|!
name|inst
operator|.
name|error
condition|)
name|inst
operator|.
name|error
operator|=
name|BAD_ARGS
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
operator|||
name|cp_reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|16
argument_list|)
operator|==
name|FAIL
condition|)
block|{
if|if
condition|(
operator|!
name|inst
operator|.
name|error
condition|)
name|inst
operator|.
name|error
operator|=
name|BAD_ARGS
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
operator|||
name|cp_reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|0
argument_list|)
operator|==
name|FAIL
condition|)
block|{
if|if
condition|(
operator|!
name|inst
operator|.
name|error
condition|)
name|inst
operator|.
name|error
operator|=
name|BAD_ARGS
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|SUCCESS
condition|)
block|{
if|if
condition|(
name|cp_opc_expr
argument_list|(
operator|&
name|str
argument_list|,
literal|5
argument_list|,
literal|3
argument_list|)
operator|==
name|FAIL
condition|)
block|{
if|if
condition|(
operator|!
name|inst
operator|.
name|error
condition|)
name|inst
operator|.
name|error
operator|=
name|BAD_ARGS
expr_stmt|;
return|return;
block|}
block|}
name|end_of_line
argument_list|(
name|str
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|do_lstc
parameter_list|(
name|str
parameter_list|,
name|flags
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
name|unsigned
name|long
name|flags
decl_stmt|;
block|{
comment|/* Co-processor register load/store.      Format:<LDC|STC{cond}[L] CP#,CRd,<address>  */
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|co_proc_number
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
condition|)
block|{
if|if
condition|(
operator|!
name|inst
operator|.
name|error
condition|)
name|inst
operator|.
name|error
operator|=
name|BAD_ARGS
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
operator|||
name|cp_reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|12
argument_list|)
operator|==
name|FAIL
condition|)
block|{
if|if
condition|(
operator|!
name|inst
operator|.
name|error
condition|)
name|inst
operator|.
name|error
operator|=
name|BAD_ARGS
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
operator|||
name|cp_address_required_here
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
condition|)
block|{
if|if
condition|(
operator|!
name|inst
operator|.
name|error
condition|)
name|inst
operator|.
name|error
operator|=
name|BAD_ARGS
expr_stmt|;
return|return;
block|}
name|inst
operator|.
name|instruction
operator||=
name|flags
expr_stmt|;
name|end_of_line
argument_list|(
name|str
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|do_co_reg
parameter_list|(
name|str
parameter_list|,
name|flags
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
name|unsigned
name|long
name|flags
decl_stmt|;
block|{
comment|/* Co-processor register transfer.      Format:<MCR|MRC>{cond} CP#,<expr1>,Rd,CRn,CRm{,<expr2>}  */
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|co_proc_number
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
condition|)
block|{
if|if
condition|(
operator|!
name|inst
operator|.
name|error
condition|)
name|inst
operator|.
name|error
operator|=
name|BAD_ARGS
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
operator|||
name|cp_opc_expr
argument_list|(
operator|&
name|str
argument_list|,
literal|21
argument_list|,
literal|3
argument_list|)
operator|==
name|FAIL
condition|)
block|{
if|if
condition|(
operator|!
name|inst
operator|.
name|error
condition|)
name|inst
operator|.
name|error
operator|=
name|BAD_ARGS
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
operator|||
name|reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|12
argument_list|)
operator|==
name|FAIL
condition|)
block|{
if|if
condition|(
operator|!
name|inst
operator|.
name|error
condition|)
name|inst
operator|.
name|error
operator|=
name|BAD_ARGS
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
operator|||
name|cp_reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|16
argument_list|)
operator|==
name|FAIL
condition|)
block|{
if|if
condition|(
operator|!
name|inst
operator|.
name|error
condition|)
name|inst
operator|.
name|error
operator|=
name|BAD_ARGS
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
operator|||
name|cp_reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|0
argument_list|)
operator|==
name|FAIL
condition|)
block|{
if|if
condition|(
operator|!
name|inst
operator|.
name|error
condition|)
name|inst
operator|.
name|error
operator|=
name|BAD_ARGS
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|SUCCESS
condition|)
block|{
if|if
condition|(
name|cp_opc_expr
argument_list|(
operator|&
name|str
argument_list|,
literal|5
argument_list|,
literal|3
argument_list|)
operator|==
name|FAIL
condition|)
block|{
if|if
condition|(
operator|!
name|inst
operator|.
name|error
condition|)
name|inst
operator|.
name|error
operator|=
name|BAD_ARGS
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
name|flags
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|BAD_COND
expr_stmt|;
block|}
name|end_of_line
argument_list|(
name|str
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|do_fp_ctrl
parameter_list|(
name|str
parameter_list|,
name|flags
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
name|unsigned
name|long
name|flags
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
comment|/* FP control registers.      Format:<WFS|RFS|WFC|RFC>{cond} Rn  */
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|12
argument_list|)
operator|==
name|FAIL
condition|)
block|{
if|if
condition|(
operator|!
name|inst
operator|.
name|error
condition|)
name|inst
operator|.
name|error
operator|=
name|BAD_ARGS
expr_stmt|;
return|return;
block|}
name|end_of_line
argument_list|(
name|str
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|do_fp_ldst
parameter_list|(
name|str
parameter_list|,
name|flags
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
name|unsigned
name|long
name|flags
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|inst
operator|.
name|suffix
condition|)
block|{
case|case
name|SUFF_S
case|:
break|break;
case|case
name|SUFF_D
case|:
name|inst
operator|.
name|instruction
operator||=
name|CP_T_X
expr_stmt|;
break|break;
case|case
name|SUFF_E
case|:
name|inst
operator|.
name|instruction
operator||=
name|CP_T_Y
expr_stmt|;
break|break;
case|case
name|SUFF_P
case|:
name|inst
operator|.
name|instruction
operator||=
name|CP_T_X
operator||
name|CP_T_Y
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|fp_reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|12
argument_list|)
operator|==
name|FAIL
condition|)
block|{
if|if
condition|(
operator|!
name|inst
operator|.
name|error
condition|)
name|inst
operator|.
name|error
operator|=
name|BAD_ARGS
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
operator|||
name|cp_address_required_here
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
condition|)
block|{
if|if
condition|(
operator|!
name|inst
operator|.
name|error
condition|)
name|inst
operator|.
name|error
operator|=
name|BAD_ARGS
expr_stmt|;
return|return;
block|}
name|end_of_line
argument_list|(
name|str
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_fp_ldmstm
parameter_list|(
name|str
parameter_list|,
name|flags
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
name|unsigned
name|long
name|flags
decl_stmt|;
block|{
name|int
name|num_regs
decl_stmt|;
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp_reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|12
argument_list|)
operator|==
name|FAIL
condition|)
block|{
if|if
condition|(
operator|!
name|inst
operator|.
name|error
condition|)
name|inst
operator|.
name|error
operator|=
name|BAD_ARGS
expr_stmt|;
return|return;
block|}
comment|/* Get Number of registers to transfer */
if|if
condition|(
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
operator|||
name|my_get_expression
argument_list|(
operator|&
name|inst
operator|.
name|reloc
operator|.
name|exp
argument_list|,
operator|&
name|str
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|inst
operator|.
name|error
condition|)
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"constant expression expected"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_op
operator|!=
name|O_constant
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"Constant value required for number of registers"
argument_list|)
expr_stmt|;
return|return;
block|}
name|num_regs
operator|=
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_add_number
expr_stmt|;
if|if
condition|(
name|num_regs
operator|<
literal|1
operator|||
name|num_regs
operator|>
literal|4
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"number of registers must be in the range [1:4]"
argument_list|)
expr_stmt|;
return|return;
block|}
switch|switch
condition|(
name|num_regs
condition|)
block|{
case|case
literal|1
case|:
name|inst
operator|.
name|instruction
operator||=
name|CP_T_X
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|inst
operator|.
name|instruction
operator||=
name|CP_T_Y
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|inst
operator|.
name|instruction
operator||=
name|CP_T_Y
operator||
name|CP_T_X
expr_stmt|;
break|break;
case|case
literal|4
case|:
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|flags
condition|)
block|{
name|int
name|reg
decl_stmt|;
name|int
name|write_back
decl_stmt|;
name|int
name|offset
decl_stmt|;
comment|/* The instruction specified "ea" or "fd", so we can only accept 	 [Rn]{!}.  The instruction does not really support stacking or 	 unstacking, so we have to emulate these by setting appropriate 	 bits and offsets.  */
if|if
condition|(
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
operator|||
operator|*
name|str
operator|!=
literal|'['
condition|)
block|{
if|if
condition|(
operator|!
name|inst
operator|.
name|error
condition|)
name|inst
operator|.
name|error
operator|=
name|BAD_ARGS
expr_stmt|;
return|return;
block|}
name|str
operator|++
expr_stmt|;
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|reg
operator|=
name|reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|16
argument_list|)
operator|)
operator|==
name|FAIL
condition|)
return|return;
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|str
operator|!=
literal|']'
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|BAD_ARGS
expr_stmt|;
return|return;
block|}
name|str
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|str
operator|==
literal|'!'
condition|)
block|{
name|write_back
operator|=
literal|1
expr_stmt|;
name|str
operator|++
expr_stmt|;
if|if
condition|(
name|reg
operator|==
name|REG_PC
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"R15 not allowed as base register with write-back"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
else|else
name|write_back
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|CP_T_Pre
condition|)
block|{
comment|/* Pre-decrement */
name|offset
operator|=
literal|3
operator|*
name|num_regs
expr_stmt|;
if|if
condition|(
name|write_back
condition|)
name|flags
operator||=
name|CP_T_WB
expr_stmt|;
block|}
else|else
block|{
comment|/* Post-increment */
if|if
condition|(
name|write_back
condition|)
block|{
name|flags
operator||=
name|CP_T_WB
expr_stmt|;
name|offset
operator|=
literal|3
operator|*
name|num_regs
expr_stmt|;
block|}
else|else
block|{
comment|/* No write-back, so convert this into a standard pre-increment 		 instruction -- aesthetically more pleasing.  */
name|flags
operator|=
name|CP_T_Pre
operator||
name|CP_T_UD
expr_stmt|;
name|offset
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|inst
operator|.
name|instruction
operator||=
name|flags
operator||
name|offset
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
operator|||
name|cp_address_required_here
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
condition|)
block|{
if|if
condition|(
operator|!
name|inst
operator|.
name|error
condition|)
name|inst
operator|.
name|error
operator|=
name|BAD_ARGS
expr_stmt|;
return|return;
block|}
name|end_of_line
argument_list|(
name|str
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_fp_dyadic
parameter_list|(
name|str
parameter_list|,
name|flags
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
name|unsigned
name|long
name|flags
decl_stmt|;
block|{
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|inst
operator|.
name|suffix
condition|)
block|{
case|case
name|SUFF_S
case|:
break|break;
case|case
name|SUFF_D
case|:
name|inst
operator|.
name|instruction
operator||=
literal|0x00000080
expr_stmt|;
break|break;
case|case
name|SUFF_E
case|:
name|inst
operator|.
name|instruction
operator||=
literal|0x00080000
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|fp_reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|12
argument_list|)
operator|==
name|FAIL
condition|)
block|{
if|if
condition|(
operator|!
name|inst
operator|.
name|error
condition|)
name|inst
operator|.
name|error
operator|=
name|BAD_ARGS
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
operator|||
name|fp_reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|16
argument_list|)
operator|==
name|FAIL
condition|)
block|{
if|if
condition|(
operator|!
name|inst
operator|.
name|error
condition|)
name|inst
operator|.
name|error
operator|=
name|BAD_ARGS
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
operator|||
name|fp_op2
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
condition|)
block|{
if|if
condition|(
operator|!
name|inst
operator|.
name|error
condition|)
name|inst
operator|.
name|error
operator|=
name|BAD_ARGS
expr_stmt|;
return|return;
block|}
name|inst
operator|.
name|instruction
operator||=
name|flags
expr_stmt|;
name|end_of_line
argument_list|(
name|str
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|do_fp_monadic
parameter_list|(
name|str
parameter_list|,
name|flags
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
name|unsigned
name|long
name|flags
decl_stmt|;
block|{
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|inst
operator|.
name|suffix
condition|)
block|{
case|case
name|SUFF_S
case|:
break|break;
case|case
name|SUFF_D
case|:
name|inst
operator|.
name|instruction
operator||=
literal|0x00000080
expr_stmt|;
break|break;
case|case
name|SUFF_E
case|:
name|inst
operator|.
name|instruction
operator||=
literal|0x00080000
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|fp_reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|12
argument_list|)
operator|==
name|FAIL
condition|)
block|{
if|if
condition|(
operator|!
name|inst
operator|.
name|error
condition|)
name|inst
operator|.
name|error
operator|=
name|BAD_ARGS
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
operator|||
name|fp_op2
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
condition|)
block|{
if|if
condition|(
operator|!
name|inst
operator|.
name|error
condition|)
name|inst
operator|.
name|error
operator|=
name|BAD_ARGS
expr_stmt|;
return|return;
block|}
name|inst
operator|.
name|instruction
operator||=
name|flags
expr_stmt|;
name|end_of_line
argument_list|(
name|str
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|do_fp_cmp
parameter_list|(
name|str
parameter_list|,
name|flags
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
name|unsigned
name|long
name|flags
decl_stmt|;
block|{
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp_reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|16
argument_list|)
operator|==
name|FAIL
condition|)
block|{
if|if
condition|(
operator|!
name|inst
operator|.
name|error
condition|)
name|inst
operator|.
name|error
operator|=
name|BAD_ARGS
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
operator|||
name|fp_op2
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
condition|)
block|{
if|if
condition|(
operator|!
name|inst
operator|.
name|error
condition|)
name|inst
operator|.
name|error
operator|=
name|BAD_ARGS
expr_stmt|;
return|return;
block|}
name|inst
operator|.
name|instruction
operator||=
name|flags
expr_stmt|;
name|end_of_line
argument_list|(
name|str
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|do_fp_from_reg
parameter_list|(
name|str
parameter_list|,
name|flags
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
name|unsigned
name|long
name|flags
decl_stmt|;
block|{
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|inst
operator|.
name|suffix
condition|)
block|{
case|case
name|SUFF_S
case|:
break|break;
case|case
name|SUFF_D
case|:
name|inst
operator|.
name|instruction
operator||=
literal|0x00000080
expr_stmt|;
break|break;
case|case
name|SUFF_E
case|:
name|inst
operator|.
name|instruction
operator||=
literal|0x00080000
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|fp_reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|16
argument_list|)
operator|==
name|FAIL
condition|)
block|{
if|if
condition|(
operator|!
name|inst
operator|.
name|error
condition|)
name|inst
operator|.
name|error
operator|=
name|BAD_ARGS
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
operator|||
name|reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|12
argument_list|)
operator|==
name|FAIL
condition|)
block|{
if|if
condition|(
operator|!
name|inst
operator|.
name|error
condition|)
name|inst
operator|.
name|error
operator|=
name|BAD_ARGS
expr_stmt|;
return|return;
block|}
name|inst
operator|.
name|instruction
operator||=
name|flags
expr_stmt|;
name|end_of_line
argument_list|(
name|str
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|do_fp_to_reg
parameter_list|(
name|str
parameter_list|,
name|flags
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
name|unsigned
name|long
name|flags
decl_stmt|;
block|{
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|12
argument_list|)
operator|==
name|FAIL
condition|)
return|return;
if|if
condition|(
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
operator|||
name|fp_reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|0
argument_list|)
operator|==
name|FAIL
condition|)
block|{
if|if
condition|(
operator|!
name|inst
operator|.
name|error
condition|)
name|inst
operator|.
name|error
operator|=
name|BAD_ARGS
expr_stmt|;
return|return;
block|}
name|inst
operator|.
name|instruction
operator||=
name|flags
expr_stmt|;
name|end_of_line
argument_list|(
name|str
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* Thumb specific routines */
end_comment

begin_comment
comment|/* Parse and validate that a register is of the right form, this saves    repeated checking of this information in many similar cases.     Unlike the 32-bit case we do not insert the register into the opcode     here, since the position is often unknown until the full instruction     has been parsed.  */
end_comment

begin_function
specifier|static
name|int
name|thumb_reg
parameter_list|(
name|strp
parameter_list|,
name|hi_lo
parameter_list|)
name|char
modifier|*
modifier|*
name|strp
decl_stmt|;
name|int
name|hi_lo
decl_stmt|;
block|{
name|int
name|reg
decl_stmt|;
if|if
condition|(
operator|(
name|reg
operator|=
name|reg_required_here
argument_list|(
name|strp
argument_list|,
operator|-
literal|1
argument_list|)
operator|)
operator|==
name|FAIL
condition|)
return|return
name|FAIL
return|;
switch|switch
condition|(
name|hi_lo
condition|)
block|{
case|case
name|THUMB_REG_LO
case|:
if|if
condition|(
name|reg
operator|>
literal|7
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"lo register required"
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
block|}
break|break;
case|case
name|THUMB_REG_HI
case|:
if|if
condition|(
name|reg
operator|<
literal|8
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"hi register required"
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
block|}
break|break;
default|default:
break|break;
block|}
return|return
name|reg
return|;
block|}
end_function

begin_comment
comment|/* Parse an add or subtract instruction, SUBTRACT is non-zero if the opcode    was SUB.  */
end_comment

begin_function
specifier|static
name|void
name|thumb_add_sub
parameter_list|(
name|str
parameter_list|,
name|subtract
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
name|int
name|subtract
decl_stmt|;
block|{
name|int
name|Rd
decl_stmt|,
name|Rs
decl_stmt|,
name|Rn
init|=
name|FAIL
decl_stmt|;
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|Rd
operator|=
name|thumb_reg
argument_list|(
operator|&
name|str
argument_list|,
name|THUMB_REG_ANY
argument_list|)
operator|)
operator|==
name|FAIL
operator|||
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
condition|)
block|{
if|if
condition|(
operator|!
name|inst
operator|.
name|error
condition|)
name|inst
operator|.
name|error
operator|=
name|BAD_ARGS
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|is_immediate_prefix
argument_list|(
operator|*
name|str
argument_list|)
condition|)
block|{
name|Rs
operator|=
name|Rd
expr_stmt|;
name|str
operator|++
expr_stmt|;
if|if
condition|(
name|my_get_expression
argument_list|(
operator|&
name|inst
operator|.
name|reloc
operator|.
name|exp
argument_list|,
operator|&
name|str
argument_list|)
condition|)
return|return;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|Rs
operator|=
name|thumb_reg
argument_list|(
operator|&
name|str
argument_list|,
name|THUMB_REG_ANY
argument_list|)
operator|)
operator|==
name|FAIL
condition|)
return|return;
if|if
condition|(
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
condition|)
block|{
comment|/* Two operand format, shuffle the registers and pretend there  	     are 3 */
name|Rn
operator|=
name|Rs
expr_stmt|;
name|Rs
operator|=
name|Rd
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|is_immediate_prefix
argument_list|(
operator|*
name|str
argument_list|)
condition|)
block|{
name|str
operator|++
expr_stmt|;
if|if
condition|(
name|my_get_expression
argument_list|(
operator|&
name|inst
operator|.
name|reloc
operator|.
name|exp
argument_list|,
operator|&
name|str
argument_list|)
condition|)
return|return;
block|}
elseif|else
if|if
condition|(
operator|(
name|Rn
operator|=
name|thumb_reg
argument_list|(
operator|&
name|str
argument_list|,
name|THUMB_REG_ANY
argument_list|)
operator|)
operator|==
name|FAIL
condition|)
return|return;
block|}
comment|/* We now have Rd and Rs set to registers, and Rn set to a register or FAIL;      for the latter case, EXPR contains the immediate that was found. */
if|if
condition|(
name|Rn
operator|!=
name|FAIL
condition|)
block|{
comment|/* All register format.  */
if|if
condition|(
name|Rd
operator|>
literal|7
operator|||
name|Rs
operator|>
literal|7
operator|||
name|Rn
operator|>
literal|7
condition|)
block|{
if|if
condition|(
name|Rs
operator|!=
name|Rd
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"dest and source1 must be the same register"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Can't do this for SUB */
if|if
condition|(
name|subtract
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"subtract valid only on lo regs"
argument_list|)
expr_stmt|;
return|return;
block|}
name|inst
operator|.
name|instruction
operator|=
operator|(
name|T_OPCODE_ADD_HI
operator||
operator|(
name|Rd
operator|>
literal|7
condition|?
name|THUMB_H1
else|:
literal|0
operator|)
operator||
operator|(
name|Rn
operator|>
literal|7
condition|?
name|THUMB_H2
else|:
literal|0
operator|)
operator|)
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
operator|(
name|Rd
operator|&
literal|7
operator|)
operator||
operator|(
operator|(
name|Rn
operator|&
literal|7
operator|)
operator|<<
literal|3
operator|)
expr_stmt|;
block|}
else|else
block|{
name|inst
operator|.
name|instruction
operator|=
name|subtract
condition|?
name|T_OPCODE_SUB_R3
else|:
name|T_OPCODE_ADD_R3
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|Rd
operator||
operator|(
name|Rs
operator|<<
literal|3
operator|)
operator||
operator|(
name|Rn
operator|<<
literal|6
operator|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Immediate expression, now things start to get nasty.  */
comment|/* First deal with HI regs, only very restricted cases allowed: 	 Adjusting SP, and using PC or SP to get an address.  */
if|if
condition|(
operator|(
name|Rd
operator|>
literal|7
operator|&&
operator|(
name|Rd
operator|!=
name|REG_SP
operator|||
name|Rs
operator|!=
name|REG_SP
operator|)
operator|)
operator|||
operator|(
name|Rs
operator|>
literal|7
operator|&&
name|Rs
operator|!=
name|REG_SP
operator|&&
name|Rs
operator|!=
name|REG_PC
operator|)
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"invalid Hi register with immediate"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_op
operator|!=
name|O_constant
condition|)
block|{
comment|/* Value isn't known yet, all we can do is store all the fragments 	     we know about in the instruction and let the reloc hacking  	     work it all out.  */
name|inst
operator|.
name|instruction
operator|=
operator|(
name|subtract
condition|?
literal|0x8000
else|:
literal|0
operator|)
operator||
operator|(
name|Rd
operator|<<
literal|4
operator|)
operator||
name|Rs
expr_stmt|;
name|inst
operator|.
name|reloc
operator|.
name|type
operator|=
name|BFD_RELOC_ARM_THUMB_ADD
expr_stmt|;
block|}
else|else
block|{
name|int
name|offset
init|=
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_add_number
decl_stmt|;
if|if
condition|(
name|subtract
condition|)
name|offset
operator|=
operator|-
name|offset
expr_stmt|;
if|if
condition|(
name|offset
operator|<
literal|0
condition|)
block|{
name|offset
operator|=
operator|-
name|offset
expr_stmt|;
name|subtract
operator|=
literal|1
expr_stmt|;
comment|/* Quick check, in case offset is MIN_INT */
if|if
condition|(
name|offset
operator|<
literal|0
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"immediate value out of range"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
else|else
name|subtract
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|Rd
operator|==
name|REG_SP
condition|)
block|{
if|if
condition|(
name|offset
operator|&
operator|~
literal|0x1fc
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"invalid immediate value for stack adjust"
argument_list|)
expr_stmt|;
return|return;
block|}
name|inst
operator|.
name|instruction
operator|=
name|subtract
condition|?
name|T_OPCODE_SUB_ST
else|:
name|T_OPCODE_ADD_ST
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|offset
operator|>>
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Rs
operator|==
name|REG_PC
operator|||
name|Rs
operator|==
name|REG_SP
condition|)
block|{
if|if
condition|(
name|subtract
operator|||
operator|(
name|offset
operator|&
operator|~
literal|0x3fc
operator|)
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"invalid immediate for address calculation"
argument_list|)
expr_stmt|;
return|return;
block|}
name|inst
operator|.
name|instruction
operator|=
operator|(
name|Rs
operator|==
name|REG_PC
condition|?
name|T_OPCODE_ADD_PC
else|:
name|T_OPCODE_ADD_SP
operator|)
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
operator|(
name|Rd
operator|<<
literal|8
operator|)
operator||
operator|(
name|offset
operator|>>
literal|2
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Rs
operator|==
name|Rd
condition|)
block|{
if|if
condition|(
name|offset
operator|&
operator|~
literal|0xff
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"immediate value out of range"
argument_list|)
expr_stmt|;
return|return;
block|}
name|inst
operator|.
name|instruction
operator|=
name|subtract
condition|?
name|T_OPCODE_SUB_I8
else|:
name|T_OPCODE_ADD_I8
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
operator|(
name|Rd
operator|<<
literal|8
operator|)
operator||
name|offset
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|offset
operator|&
operator|~
literal|0x7
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"immediate value out of range"
argument_list|)
expr_stmt|;
return|return;
block|}
name|inst
operator|.
name|instruction
operator|=
name|subtract
condition|?
name|T_OPCODE_SUB_I3
else|:
name|T_OPCODE_ADD_I3
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|Rd
operator||
operator|(
name|Rs
operator|<<
literal|3
operator|)
operator||
operator|(
name|offset
operator|<<
literal|6
operator|)
expr_stmt|;
block|}
block|}
block|}
name|end_of_line
argument_list|(
name|str
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|thumb_shift
parameter_list|(
name|str
parameter_list|,
name|shift
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
name|int
name|shift
decl_stmt|;
block|{
name|int
name|Rd
decl_stmt|,
name|Rs
decl_stmt|,
name|Rn
init|=
name|FAIL
decl_stmt|;
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|Rd
operator|=
name|thumb_reg
argument_list|(
operator|&
name|str
argument_list|,
name|THUMB_REG_LO
argument_list|)
operator|)
operator|==
name|FAIL
operator|||
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
condition|)
block|{
if|if
condition|(
operator|!
name|inst
operator|.
name|error
condition|)
name|inst
operator|.
name|error
operator|=
name|BAD_ARGS
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|is_immediate_prefix
argument_list|(
operator|*
name|str
argument_list|)
condition|)
block|{
comment|/* Two operand immediate format, set Rs to Rd.  */
name|Rs
operator|=
name|Rd
expr_stmt|;
name|str
operator|++
expr_stmt|;
if|if
condition|(
name|my_get_expression
argument_list|(
operator|&
name|inst
operator|.
name|reloc
operator|.
name|exp
argument_list|,
operator|&
name|str
argument_list|)
condition|)
return|return;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|Rs
operator|=
name|thumb_reg
argument_list|(
operator|&
name|str
argument_list|,
name|THUMB_REG_LO
argument_list|)
operator|)
operator|==
name|FAIL
condition|)
return|return;
if|if
condition|(
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
condition|)
block|{
comment|/* Two operand format, shuffle the registers and pretend there 	     are 3 */
name|Rn
operator|=
name|Rs
expr_stmt|;
name|Rs
operator|=
name|Rd
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|is_immediate_prefix
argument_list|(
operator|*
name|str
argument_list|)
condition|)
block|{
name|str
operator|++
expr_stmt|;
if|if
condition|(
name|my_get_expression
argument_list|(
operator|&
name|inst
operator|.
name|reloc
operator|.
name|exp
argument_list|,
operator|&
name|str
argument_list|)
condition|)
return|return;
block|}
elseif|else
if|if
condition|(
operator|(
name|Rn
operator|=
name|thumb_reg
argument_list|(
operator|&
name|str
argument_list|,
name|THUMB_REG_LO
argument_list|)
operator|)
operator|==
name|FAIL
condition|)
return|return;
block|}
comment|/* We now have Rd and Rs set to registers, and Rn set to a register or FAIL;      for the latter case, EXPR contains the immediate that was found. */
if|if
condition|(
name|Rn
operator|!=
name|FAIL
condition|)
block|{
if|if
condition|(
name|Rs
operator|!=
name|Rd
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"source1 and dest must be same register"
argument_list|)
expr_stmt|;
return|return;
block|}
switch|switch
condition|(
name|shift
condition|)
block|{
case|case
name|THUMB_ASR
case|:
name|inst
operator|.
name|instruction
operator|=
name|T_OPCODE_ASR_R
expr_stmt|;
break|break;
case|case
name|THUMB_LSL
case|:
name|inst
operator|.
name|instruction
operator|=
name|T_OPCODE_LSL_R
expr_stmt|;
break|break;
case|case
name|THUMB_LSR
case|:
name|inst
operator|.
name|instruction
operator|=
name|T_OPCODE_LSR_R
expr_stmt|;
break|break;
block|}
name|inst
operator|.
name|instruction
operator||=
name|Rd
operator||
operator|(
name|Rn
operator|<<
literal|3
operator|)
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
name|shift
condition|)
block|{
case|case
name|THUMB_ASR
case|:
name|inst
operator|.
name|instruction
operator|=
name|T_OPCODE_ASR_I
expr_stmt|;
break|break;
case|case
name|THUMB_LSL
case|:
name|inst
operator|.
name|instruction
operator|=
name|T_OPCODE_LSL_I
expr_stmt|;
break|break;
case|case
name|THUMB_LSR
case|:
name|inst
operator|.
name|instruction
operator|=
name|T_OPCODE_LSR_I
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_op
operator|!=
name|O_constant
condition|)
block|{
comment|/* Value isn't known yet, create a dummy reloc and let reloc 	     hacking fix it up */
name|inst
operator|.
name|reloc
operator|.
name|type
operator|=
name|BFD_RELOC_ARM_THUMB_SHIFT
expr_stmt|;
block|}
else|else
block|{
name|unsigned
name|shift_value
init|=
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_add_number
decl_stmt|;
if|if
condition|(
name|shift_value
operator|>
literal|32
operator|||
operator|(
name|shift_value
operator|==
literal|32
operator|&&
name|shift
operator|==
name|THUMB_LSL
operator|)
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"Invalid immediate for shift"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Shifts of zero are handled by converting to LSL */
if|if
condition|(
name|shift_value
operator|==
literal|0
condition|)
name|inst
operator|.
name|instruction
operator|=
name|T_OPCODE_LSL_I
expr_stmt|;
comment|/* Shifts of 32 are encoded as a shift of zero */
if|if
condition|(
name|shift_value
operator|==
literal|32
condition|)
name|shift_value
operator|=
literal|0
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|shift_value
operator|<<
literal|6
expr_stmt|;
block|}
name|inst
operator|.
name|instruction
operator||=
name|Rd
operator||
operator|(
name|Rs
operator|<<
literal|3
operator|)
expr_stmt|;
block|}
name|end_of_line
argument_list|(
name|str
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|thumb_mov_compare
parameter_list|(
name|str
parameter_list|,
name|move
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
name|int
name|move
decl_stmt|;
block|{
name|int
name|Rd
decl_stmt|,
name|Rs
init|=
name|FAIL
decl_stmt|;
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|Rd
operator|=
name|thumb_reg
argument_list|(
operator|&
name|str
argument_list|,
name|THUMB_REG_ANY
argument_list|)
operator|)
operator|==
name|FAIL
operator|||
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
condition|)
block|{
if|if
condition|(
operator|!
name|inst
operator|.
name|error
condition|)
name|inst
operator|.
name|error
operator|=
name|BAD_ARGS
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|is_immediate_prefix
argument_list|(
operator|*
name|str
argument_list|)
condition|)
block|{
name|str
operator|++
expr_stmt|;
if|if
condition|(
name|my_get_expression
argument_list|(
operator|&
name|inst
operator|.
name|reloc
operator|.
name|exp
argument_list|,
operator|&
name|str
argument_list|)
condition|)
return|return;
block|}
elseif|else
if|if
condition|(
operator|(
name|Rs
operator|=
name|thumb_reg
argument_list|(
operator|&
name|str
argument_list|,
name|THUMB_REG_ANY
argument_list|)
operator|)
operator|==
name|FAIL
condition|)
return|return;
if|if
condition|(
name|Rs
operator|!=
name|FAIL
condition|)
block|{
if|if
condition|(
name|Rs
operator|<
literal|8
operator|&&
name|Rd
operator|<
literal|8
condition|)
block|{
if|if
condition|(
name|move
operator|==
name|THUMB_MOVE
condition|)
comment|/* A move of two lowregs is encoded as ADD Rd, Rs, #0 	       since a MOV instruction produces unpredictable results */
name|inst
operator|.
name|instruction
operator|=
name|T_OPCODE_ADD_I3
expr_stmt|;
else|else
name|inst
operator|.
name|instruction
operator|=
name|T_OPCODE_CMP_LR
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|Rd
operator||
operator|(
name|Rs
operator|<<
literal|3
operator|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|move
operator|==
name|THUMB_MOVE
condition|)
name|inst
operator|.
name|instruction
operator|=
name|T_OPCODE_MOV_HR
expr_stmt|;
else|else
name|inst
operator|.
name|instruction
operator|=
name|T_OPCODE_CMP_HR
expr_stmt|;
if|if
condition|(
name|Rd
operator|>
literal|7
condition|)
name|inst
operator|.
name|instruction
operator||=
name|THUMB_H1
expr_stmt|;
if|if
condition|(
name|Rs
operator|>
literal|7
condition|)
name|inst
operator|.
name|instruction
operator||=
name|THUMB_H2
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
operator|(
name|Rd
operator|&
literal|7
operator|)
operator||
operator|(
operator|(
name|Rs
operator|&
literal|7
operator|)
operator|<<
literal|3
operator|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|Rd
operator|>
literal|7
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"only lo regs allowed with immediate"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|move
operator|==
name|THUMB_MOVE
condition|)
name|inst
operator|.
name|instruction
operator|=
name|T_OPCODE_MOV_I8
expr_stmt|;
else|else
name|inst
operator|.
name|instruction
operator|=
name|T_OPCODE_CMP_I8
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|Rd
operator|<<
literal|8
expr_stmt|;
if|if
condition|(
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_op
operator|!=
name|O_constant
condition|)
name|inst
operator|.
name|reloc
operator|.
name|type
operator|=
name|BFD_RELOC_ARM_THUMB_IMM
expr_stmt|;
else|else
block|{
name|unsigned
name|value
init|=
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_add_number
decl_stmt|;
if|if
condition|(
name|value
operator|>
literal|255
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"invalid immediate"
argument_list|)
expr_stmt|;
return|return;
block|}
name|inst
operator|.
name|instruction
operator||=
name|value
expr_stmt|;
block|}
block|}
name|end_of_line
argument_list|(
name|str
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|thumb_load_store
parameter_list|(
name|str
parameter_list|,
name|load_store
parameter_list|,
name|size
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
name|int
name|load_store
decl_stmt|;
name|int
name|size
decl_stmt|;
block|{
name|int
name|Rd
decl_stmt|,
name|Rb
decl_stmt|,
name|Ro
init|=
name|FAIL
decl_stmt|;
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|Rd
operator|=
name|thumb_reg
argument_list|(
operator|&
name|str
argument_list|,
name|THUMB_REG_LO
argument_list|)
operator|)
operator|==
name|FAIL
operator|||
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
condition|)
block|{
if|if
condition|(
operator|!
name|inst
operator|.
name|error
condition|)
name|inst
operator|.
name|error
operator|=
name|BAD_ARGS
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|*
name|str
operator|==
literal|'['
condition|)
block|{
name|str
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|Rb
operator|=
name|thumb_reg
argument_list|(
operator|&
name|str
argument_list|,
name|THUMB_REG_ANY
argument_list|)
operator|)
operator|==
name|FAIL
condition|)
return|return;
if|if
condition|(
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|!=
name|FAIL
condition|)
block|{
if|if
condition|(
name|is_immediate_prefix
argument_list|(
operator|*
name|str
argument_list|)
condition|)
block|{
name|str
operator|++
expr_stmt|;
if|if
condition|(
name|my_get_expression
argument_list|(
operator|&
name|inst
operator|.
name|reloc
operator|.
name|exp
argument_list|,
operator|&
name|str
argument_list|)
condition|)
return|return;
block|}
elseif|else
if|if
condition|(
operator|(
name|Ro
operator|=
name|thumb_reg
argument_list|(
operator|&
name|str
argument_list|,
name|THUMB_REG_LO
argument_list|)
operator|)
operator|==
name|FAIL
condition|)
return|return;
block|}
else|else
block|{
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_op
operator|=
name|O_constant
expr_stmt|;
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_add_number
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|str
operator|!=
literal|']'
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"expected ']'"
argument_list|)
expr_stmt|;
return|return;
block|}
name|str
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|str
operator|==
literal|'='
condition|)
block|{
comment|/* Parse an "ldr Rd, =expr" instruction; this is another pseudo op */
name|str
operator|++
expr_stmt|;
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|my_get_expression
argument_list|(
operator|&
name|inst
operator|.
name|reloc
operator|.
name|exp
argument_list|,
operator|&
name|str
argument_list|)
condition|)
return|return;
name|end_of_line
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_op
operator|!=
name|O_constant
operator|&&
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_op
operator|!=
name|O_symbol
condition|)
block|{
name|inst
operator|.
name|error
operator|=
literal|"Constant expression expected"
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_op
operator|==
name|O_constant
operator|&&
operator|(
operator|(
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_add_number
operator|&
operator|~
literal|0xFF
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* This can be done with a mov instruction */
name|inst
operator|.
name|instruction
operator|=
name|T_OPCODE_MOV_I8
operator||
operator|(
name|Rd
operator|<<
literal|8
operator|)
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_add_number
expr_stmt|;
return|return;
block|}
comment|/* Insert into literal pool */
if|if
condition|(
name|add_to_lit_pool
argument_list|()
operator|==
name|FAIL
condition|)
block|{
if|if
condition|(
operator|!
name|inst
operator|.
name|error
condition|)
name|inst
operator|.
name|error
operator|=
literal|"literal pool insertion failed"
expr_stmt|;
return|return;
block|}
name|inst
operator|.
name|reloc
operator|.
name|type
operator|=
name|BFD_RELOC_ARM_THUMB_OFFSET
expr_stmt|;
name|inst
operator|.
name|reloc
operator|.
name|pc_rel
operator|=
literal|1
expr_stmt|;
name|inst
operator|.
name|instruction
operator|=
name|T_OPCODE_LDR_PC
operator||
operator|(
name|Rd
operator|<<
literal|8
operator|)
expr_stmt|;
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_add_number
operator|+=
literal|4
expr_stmt|;
comment|/* Adjust ARM pipeline offset to Thumb */
return|return;
block|}
else|else
block|{
if|if
condition|(
name|my_get_expression
argument_list|(
operator|&
name|inst
operator|.
name|reloc
operator|.
name|exp
argument_list|,
operator|&
name|str
argument_list|)
condition|)
return|return;
name|inst
operator|.
name|instruction
operator|=
name|T_OPCODE_LDR_PC
operator||
operator|(
name|Rd
operator|<<
literal|8
operator|)
expr_stmt|;
name|inst
operator|.
name|reloc
operator|.
name|pc_rel
operator|=
literal|1
expr_stmt|;
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_add_number
operator|-=
literal|4
expr_stmt|;
comment|/* Pipeline offset */
name|inst
operator|.
name|reloc
operator|.
name|type
operator|=
name|BFD_RELOC_ARM_THUMB_OFFSET
expr_stmt|;
name|end_of_line
argument_list|(
name|str
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|Rb
operator|==
name|REG_PC
operator|||
name|Rb
operator|==
name|REG_SP
condition|)
block|{
if|if
condition|(
name|size
operator|!=
name|THUMB_WORD
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"byte or halfword not valid for base register"
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|Rb
operator|==
name|REG_PC
operator|&&
name|load_store
operator|!=
name|THUMB_LOAD
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"R15 based store not allowed"
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|Ro
operator|!=
name|FAIL
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"Invalid base register for register offset"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|Rb
operator|==
name|REG_PC
condition|)
name|inst
operator|.
name|instruction
operator|=
name|T_OPCODE_LDR_PC
expr_stmt|;
elseif|else
if|if
condition|(
name|load_store
operator|==
name|THUMB_LOAD
condition|)
name|inst
operator|.
name|instruction
operator|=
name|T_OPCODE_LDR_SP
expr_stmt|;
else|else
name|inst
operator|.
name|instruction
operator|=
name|T_OPCODE_STR_SP
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|Rd
operator|<<
literal|8
expr_stmt|;
if|if
condition|(
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_op
operator|==
name|O_constant
condition|)
block|{
name|unsigned
name|offset
init|=
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_add_number
decl_stmt|;
if|if
condition|(
name|offset
operator|&
operator|~
literal|0x3fc
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"invalid offset"
argument_list|)
expr_stmt|;
return|return;
block|}
name|inst
operator|.
name|instruction
operator||=
name|offset
operator|>>
literal|2
expr_stmt|;
block|}
else|else
name|inst
operator|.
name|reloc
operator|.
name|type
operator|=
name|BFD_RELOC_ARM_THUMB_OFFSET
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Rb
operator|>
literal|7
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"invalid base register in load/store"
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|Ro
operator|==
name|FAIL
condition|)
block|{
comment|/* Immediate offset */
if|if
condition|(
name|size
operator|==
name|THUMB_WORD
condition|)
name|inst
operator|.
name|instruction
operator|=
operator|(
name|load_store
operator|==
name|THUMB_LOAD
condition|?
name|T_OPCODE_LDR_IW
else|:
name|T_OPCODE_STR_IW
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|size
operator|==
name|THUMB_HALFWORD
condition|)
name|inst
operator|.
name|instruction
operator|=
operator|(
name|load_store
operator|==
name|THUMB_LOAD
condition|?
name|T_OPCODE_LDR_IH
else|:
name|T_OPCODE_STR_IH
operator|)
expr_stmt|;
else|else
name|inst
operator|.
name|instruction
operator|=
operator|(
name|load_store
operator|==
name|THUMB_LOAD
condition|?
name|T_OPCODE_LDR_IB
else|:
name|T_OPCODE_STR_IB
operator|)
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|Rd
operator||
operator|(
name|Rb
operator|<<
literal|3
operator|)
expr_stmt|;
if|if
condition|(
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_op
operator|==
name|O_constant
condition|)
block|{
name|unsigned
name|offset
init|=
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_add_number
decl_stmt|;
if|if
condition|(
name|offset
operator|&
operator|~
operator|(
literal|0x1f
operator|<<
name|size
operator|)
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"Invalid offset"
argument_list|)
expr_stmt|;
return|return;
block|}
name|inst
operator|.
name|instruction
operator||=
operator|(
name|offset
operator|>>
name|size
operator|)
operator|<<
literal|6
expr_stmt|;
block|}
else|else
name|inst
operator|.
name|reloc
operator|.
name|type
operator|=
name|BFD_RELOC_ARM_THUMB_OFFSET
expr_stmt|;
block|}
else|else
block|{
comment|/* Register offset */
if|if
condition|(
name|size
operator|==
name|THUMB_WORD
condition|)
name|inst
operator|.
name|instruction
operator|=
operator|(
name|load_store
operator|==
name|THUMB_LOAD
condition|?
name|T_OPCODE_LDR_RW
else|:
name|T_OPCODE_STR_RW
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|size
operator|==
name|THUMB_HALFWORD
condition|)
name|inst
operator|.
name|instruction
operator|=
operator|(
name|load_store
operator|==
name|THUMB_LOAD
condition|?
name|T_OPCODE_LDR_RH
else|:
name|T_OPCODE_STR_RH
operator|)
expr_stmt|;
else|else
name|inst
operator|.
name|instruction
operator|=
operator|(
name|load_store
operator|==
name|THUMB_LOAD
condition|?
name|T_OPCODE_LDR_RB
else|:
name|T_OPCODE_STR_RB
operator|)
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|Rd
operator||
operator|(
name|Rb
operator|<<
literal|3
operator|)
operator||
operator|(
name|Ro
operator|<<
literal|6
operator|)
expr_stmt|;
block|}
name|end_of_line
argument_list|(
name|str
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_t_nop
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
comment|/* Do nothing */
name|end_of_line
argument_list|(
name|str
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* Handle the Format 4 instructions that do not have equivalents in other     formats.  That is, ADC, AND, EOR, SBC, ROR, TST, NEG, CMN, ORR, MUL,    BIC and MVN.  */
end_comment

begin_function
specifier|static
name|void
name|do_t_arit
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|int
name|Rd
decl_stmt|,
name|Rs
decl_stmt|,
name|Rn
decl_stmt|;
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|Rd
operator|=
name|thumb_reg
argument_list|(
operator|&
name|str
argument_list|,
name|THUMB_REG_LO
argument_list|)
operator|)
operator|==
name|FAIL
operator|||
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
operator|||
operator|(
name|Rs
operator|=
name|thumb_reg
argument_list|(
operator|&
name|str
argument_list|,
name|THUMB_REG_LO
argument_list|)
operator|)
operator|==
name|FAIL
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|BAD_ARGS
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|!=
name|FAIL
condition|)
block|{
comment|/* Three operand format not allowed for TST, CMN, NEG and MVN. 	 (It isn't allowed for CMP either, but that isn't handled by this 	 function.)  */
if|if
condition|(
name|inst
operator|.
name|instruction
operator|==
name|T_OPCODE_TST
operator|||
name|inst
operator|.
name|instruction
operator|==
name|T_OPCODE_CMN
operator|||
name|inst
operator|.
name|instruction
operator|==
name|T_OPCODE_NEG
operator|||
name|inst
operator|.
name|instruction
operator|==
name|T_OPCODE_MVN
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|BAD_ARGS
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|Rn
operator|=
name|thumb_reg
argument_list|(
operator|&
name|str
argument_list|,
name|THUMB_REG_LO
argument_list|)
operator|)
operator|==
name|FAIL
condition|)
return|return;
if|if
condition|(
name|Rs
operator|!=
name|Rd
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"dest and source1 one must be the same register"
argument_list|)
expr_stmt|;
return|return;
block|}
name|Rs
operator|=
name|Rn
expr_stmt|;
block|}
if|if
condition|(
name|inst
operator|.
name|instruction
operator|==
name|T_OPCODE_MUL
operator|&&
name|Rs
operator|==
name|Rd
condition|)
name|as_tsktsk
argument_list|(
name|_
argument_list|(
literal|"Rs and Rd must be different in MUL"
argument_list|)
argument_list|)
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|Rd
operator||
operator|(
name|Rs
operator|<<
literal|3
operator|)
expr_stmt|;
name|end_of_line
argument_list|(
name|str
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_t_add
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|thumb_add_sub
argument_list|(
name|str
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_t_asr
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|thumb_shift
argument_list|(
name|str
argument_list|,
name|THUMB_ASR
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_t_branch9
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
if|if
condition|(
name|my_get_expression
argument_list|(
operator|&
name|inst
operator|.
name|reloc
operator|.
name|exp
argument_list|,
operator|&
name|str
argument_list|)
condition|)
return|return;
name|inst
operator|.
name|reloc
operator|.
name|type
operator|=
name|BFD_RELOC_THUMB_PCREL_BRANCH9
expr_stmt|;
name|inst
operator|.
name|reloc
operator|.
name|pc_rel
operator|=
literal|1
expr_stmt|;
name|end_of_line
argument_list|(
name|str
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_t_branch12
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
if|if
condition|(
name|my_get_expression
argument_list|(
operator|&
name|inst
operator|.
name|reloc
operator|.
name|exp
argument_list|,
operator|&
name|str
argument_list|)
condition|)
return|return;
name|inst
operator|.
name|reloc
operator|.
name|type
operator|=
name|BFD_RELOC_THUMB_PCREL_BRANCH12
expr_stmt|;
name|inst
operator|.
name|reloc
operator|.
name|pc_rel
operator|=
literal|1
expr_stmt|;
name|end_of_line
argument_list|(
name|str
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Find the real, Thumb encoded start of a Thumb function.  */
end_comment

begin_function
specifier|static
name|symbolS
modifier|*
name|find_real_start
parameter_list|(
name|symbolP
parameter_list|)
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
block|{
name|char
modifier|*
name|real_start
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
init|=
name|S_GET_NAME
argument_list|(
name|symbolP
argument_list|)
decl_stmt|;
name|symbolS
modifier|*
name|new_target
decl_stmt|;
comment|/* This definiton must agree with the one in gcc/config/arm/thumb.c */
define|#
directive|define
name|STUB_NAME
value|".real_start_of"
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Names that start with '.' are local labels, not function entry points.      The compiler may generate BL instructions to these labels because it      needs to perform a branch to a far away location.  */
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'.'
condition|)
return|return
name|symbolP
return|;
name|real_start
operator|=
name|malloc
argument_list|(
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
name|strlen
argument_list|(
name|STUB_NAME
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|real_start
argument_list|,
literal|"%s%s"
argument_list|,
name|STUB_NAME
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|new_target
operator|=
name|symbol_find
argument_list|(
name|real_start
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_target
operator|==
name|NULL
condition|)
block|{
name|as_warn
argument_list|(
literal|"Failed to find real start of function: %s\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|new_target
operator|=
name|symbolP
expr_stmt|;
block|}
name|free
argument_list|(
name|real_start
argument_list|)
expr_stmt|;
return|return
name|new_target
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_t_branch23
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
if|if
condition|(
name|my_get_expression
argument_list|(
operator|&
name|inst
operator|.
name|reloc
operator|.
name|exp
argument_list|,
operator|&
name|str
argument_list|)
condition|)
return|return;
name|inst
operator|.
name|reloc
operator|.
name|type
operator|=
name|BFD_RELOC_THUMB_PCREL_BRANCH23
expr_stmt|;
name|inst
operator|.
name|reloc
operator|.
name|pc_rel
operator|=
literal|1
expr_stmt|;
name|end_of_line
argument_list|(
name|str
argument_list|)
expr_stmt|;
comment|/* If the destination of the branch is a defined symbol which does not have      the THUMB_FUNC attribute, then we must be calling a function which has      the (interfacearm) attribute.  We look for the Thumb entry point to that      function and change the branch to refer to that function instead.  */
if|if
condition|(
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_op
operator|==
name|O_symbol
operator|&&
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_add_symbol
operator|!=
name|NULL
operator|&&
name|S_IS_DEFINED
argument_list|(
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_add_symbol
argument_list|)
operator|&&
operator|!
name|THUMB_IS_FUNC
argument_list|(
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_add_symbol
argument_list|)
condition|)
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_add_symbol
operator|=
name|find_real_start
argument_list|(
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_add_symbol
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_t_bx
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|int
name|reg
decl_stmt|;
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|reg
operator|=
name|thumb_reg
argument_list|(
operator|&
name|str
argument_list|,
name|THUMB_REG_ANY
argument_list|)
operator|)
operator|==
name|FAIL
condition|)
return|return;
comment|/* This sets THUMB_H2 from the top bit of reg.  */
name|inst
operator|.
name|instruction
operator||=
name|reg
operator|<<
literal|3
expr_stmt|;
comment|/* ??? FIXME: Should add a hacky reloc here if reg is REG_PC.  The reloc      should cause the alignment to be checked once it is known.  This is      because BX PC only works if the instruction is word aligned.  */
name|end_of_line
argument_list|(
name|str
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_t_compare
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|thumb_mov_compare
argument_list|(
name|str
argument_list|,
name|THUMB_COMPARE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_t_ldmstm
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|int
name|Rb
decl_stmt|;
name|long
name|range
decl_stmt|;
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|Rb
operator|=
name|thumb_reg
argument_list|(
operator|&
name|str
argument_list|,
name|THUMB_REG_LO
argument_list|)
operator|)
operator|==
name|FAIL
condition|)
return|return;
if|if
condition|(
operator|*
name|str
operator|!=
literal|'!'
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"Inserted missing '!': load/store multiple always writes back base register"
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|str
operator|++
expr_stmt|;
if|if
condition|(
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
operator|||
operator|(
name|range
operator|=
name|reg_list
argument_list|(
operator|&
name|str
argument_list|)
operator|)
operator|==
name|FAIL
condition|)
block|{
if|if
condition|(
operator|!
name|inst
operator|.
name|error
condition|)
name|inst
operator|.
name|error
operator|=
name|BAD_ARGS
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|inst
operator|.
name|reloc
operator|.
name|type
operator|!=
name|BFD_RELOC_NONE
condition|)
block|{
comment|/* This really doesn't seem worth it. */
name|inst
operator|.
name|reloc
operator|.
name|type
operator|=
name|BFD_RELOC_NONE
expr_stmt|;
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"Expression too complex"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|range
operator|&
operator|~
literal|0xff
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"only lo-regs valid in load/store multiple"
argument_list|)
expr_stmt|;
return|return;
block|}
name|inst
operator|.
name|instruction
operator||=
operator|(
name|Rb
operator|<<
literal|8
operator|)
operator||
name|range
expr_stmt|;
name|end_of_line
argument_list|(
name|str
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_t_ldr
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|thumb_load_store
argument_list|(
name|str
argument_list|,
name|THUMB_LOAD
argument_list|,
name|THUMB_WORD
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_t_ldrb
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|thumb_load_store
argument_list|(
name|str
argument_list|,
name|THUMB_LOAD
argument_list|,
name|THUMB_BYTE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_t_ldrh
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|thumb_load_store
argument_list|(
name|str
argument_list|,
name|THUMB_LOAD
argument_list|,
name|THUMB_HALFWORD
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_t_lds
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|int
name|Rd
decl_stmt|,
name|Rb
decl_stmt|,
name|Ro
decl_stmt|;
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|Rd
operator|=
name|thumb_reg
argument_list|(
operator|&
name|str
argument_list|,
name|THUMB_REG_LO
argument_list|)
operator|)
operator|==
name|FAIL
operator|||
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
operator|||
operator|*
name|str
operator|++
operator|!=
literal|'['
operator|||
operator|(
name|Rb
operator|=
name|thumb_reg
argument_list|(
operator|&
name|str
argument_list|,
name|THUMB_REG_LO
argument_list|)
operator|)
operator|==
name|FAIL
operator|||
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
operator|||
operator|(
name|Ro
operator|=
name|thumb_reg
argument_list|(
operator|&
name|str
argument_list|,
name|THUMB_REG_LO
argument_list|)
operator|)
operator|==
name|FAIL
operator|||
operator|*
name|str
operator|++
operator|!=
literal|']'
condition|)
block|{
if|if
condition|(
operator|!
name|inst
operator|.
name|error
condition|)
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"Syntax: ldrs[b] Rd, [Rb, Ro]"
argument_list|)
expr_stmt|;
return|return;
block|}
name|inst
operator|.
name|instruction
operator||=
name|Rd
operator||
operator|(
name|Rb
operator|<<
literal|3
operator|)
operator||
operator|(
name|Ro
operator|<<
literal|6
operator|)
expr_stmt|;
name|end_of_line
argument_list|(
name|str
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_t_lsl
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|thumb_shift
argument_list|(
name|str
argument_list|,
name|THUMB_LSL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_t_lsr
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|thumb_shift
argument_list|(
name|str
argument_list|,
name|THUMB_LSR
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_t_mov
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|thumb_mov_compare
argument_list|(
name|str
argument_list|,
name|THUMB_MOVE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_t_push_pop
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|long
name|range
decl_stmt|;
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|range
operator|=
name|reg_list
argument_list|(
operator|&
name|str
argument_list|)
operator|)
operator|==
name|FAIL
condition|)
block|{
if|if
condition|(
operator|!
name|inst
operator|.
name|error
condition|)
name|inst
operator|.
name|error
operator|=
name|BAD_ARGS
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|inst
operator|.
name|reloc
operator|.
name|type
operator|!=
name|BFD_RELOC_NONE
condition|)
block|{
comment|/* This really doesn't seem worth it. */
name|inst
operator|.
name|reloc
operator|.
name|type
operator|=
name|BFD_RELOC_NONE
expr_stmt|;
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"Expression too complex"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|range
operator|&
operator|~
literal|0xff
condition|)
block|{
if|if
condition|(
operator|(
name|inst
operator|.
name|instruction
operator|==
name|T_OPCODE_PUSH
operator|&&
operator|(
name|range
operator|&
operator|~
literal|0xff
operator|)
operator|==
literal|1
operator|<<
name|REG_LR
operator|)
operator|||
operator|(
name|inst
operator|.
name|instruction
operator|==
name|T_OPCODE_POP
operator|&&
operator|(
name|range
operator|&
operator|~
literal|0xff
operator|)
operator|==
literal|1
operator|<<
name|REG_PC
operator|)
condition|)
block|{
name|inst
operator|.
name|instruction
operator||=
name|THUMB_PP_PC_LR
expr_stmt|;
name|range
operator|&=
literal|0xff
expr_stmt|;
block|}
else|else
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"invalid register list to push/pop instruction"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|inst
operator|.
name|instruction
operator||=
name|range
expr_stmt|;
name|end_of_line
argument_list|(
name|str
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_t_str
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|thumb_load_store
argument_list|(
name|str
argument_list|,
name|THUMB_STORE
argument_list|,
name|THUMB_WORD
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_t_strb
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|thumb_load_store
argument_list|(
name|str
argument_list|,
name|THUMB_STORE
argument_list|,
name|THUMB_BYTE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_t_strh
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|thumb_load_store
argument_list|(
name|str
argument_list|,
name|THUMB_STORE
argument_list|,
name|THUMB_HALFWORD
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_t_sub
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|thumb_add_sub
argument_list|(
name|str
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_t_swi
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|my_get_expression
argument_list|(
operator|&
name|inst
operator|.
name|reloc
operator|.
name|exp
argument_list|,
operator|&
name|str
argument_list|)
condition|)
return|return;
name|inst
operator|.
name|reloc
operator|.
name|type
operator|=
name|BFD_RELOC_ARM_SWI
expr_stmt|;
name|end_of_line
argument_list|(
name|str
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|do_t_adr
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|int
name|reg
decl_stmt|;
comment|/* This is a pseudo-op of the form "adr rd, label" to be converted      into a relative address of the form "add rd, pc, #label-.-4".  */
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
comment|/* Store Rd in temporary location inside instruction.  */
if|if
condition|(
operator|(
name|reg
operator|=
name|reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|4
argument_list|)
operator|)
operator|==
name|FAIL
operator|||
operator|(
name|reg
operator|>
literal|7
operator|)
comment|/* For Thumb reg must be r0..r7.  */
operator|||
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
operator|||
name|my_get_expression
argument_list|(
operator|&
name|inst
operator|.
name|reloc
operator|.
name|exp
argument_list|,
operator|&
name|str
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|inst
operator|.
name|error
condition|)
name|inst
operator|.
name|error
operator|=
name|BAD_ARGS
expr_stmt|;
return|return;
block|}
name|inst
operator|.
name|reloc
operator|.
name|type
operator|=
name|BFD_RELOC_ARM_THUMB_ADD
expr_stmt|;
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_add_number
operator|-=
literal|4
expr_stmt|;
comment|/* PC relative adjust.  */
name|inst
operator|.
name|reloc
operator|.
name|pc_rel
operator|=
literal|1
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|REG_PC
expr_stmt|;
comment|/* Rd is already placed into the instruction.  */
name|end_of_line
argument_list|(
name|str
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|insert_reg
parameter_list|(
name|entry
parameter_list|)
name|int
name|entry
decl_stmt|;
block|{
name|int
name|len
init|=
name|strlen
argument_list|(
name|reg_table
index|[
name|entry
index|]
operator|.
name|name
argument_list|)
operator|+
literal|2
decl_stmt|;
name|char
modifier|*
name|buf
init|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|len
argument_list|)
decl_stmt|;
name|char
modifier|*
name|buf2
init|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|len
argument_list|)
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|REGISTER_PREFIX
name|buf
index|[
name|i
operator|++
index|]
operator|=
name|REGISTER_PREFIX
expr_stmt|;
endif|#
directive|endif
name|strcpy
argument_list|(
name|buf
operator|+
name|i
argument_list|,
name|reg_table
index|[
name|entry
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|buf
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
name|buf2
index|[
name|i
index|]
operator|=
name|islower
argument_list|(
name|buf
index|[
name|i
index|]
argument_list|)
condition|?
name|toupper
argument_list|(
name|buf
index|[
name|i
index|]
argument_list|)
else|:
name|buf
index|[
name|i
index|]
expr_stmt|;
name|buf2
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
name|hash_insert
argument_list|(
name|arm_reg_hsh
argument_list|,
name|buf
argument_list|,
operator|(
name|PTR
operator|)
operator|&
name|reg_table
index|[
name|entry
index|]
argument_list|)
expr_stmt|;
name|hash_insert
argument_list|(
name|arm_reg_hsh
argument_list|,
name|buf2
argument_list|,
operator|(
name|PTR
operator|)
operator|&
name|reg_table
index|[
name|entry
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|insert_reg_alias
parameter_list|(
name|str
parameter_list|,
name|regnum
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
name|int
name|regnum
decl_stmt|;
block|{
name|struct
name|reg_entry
modifier|*
name|new
init|=
operator|(
expr|struct
name|reg_entry
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|reg_entry
argument_list|)
argument_list|)
decl_stmt|;
name|char
modifier|*
name|name
init|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|str
argument_list|)
operator|+
literal|1
argument_list|)
decl_stmt|;
name|strcpy
argument_list|(
name|name
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|new
operator|->
name|name
operator|=
name|name
expr_stmt|;
name|new
operator|->
name|number
operator|=
name|regnum
expr_stmt|;
name|hash_insert
argument_list|(
name|arm_reg_hsh
argument_list|,
name|name
argument_list|,
operator|(
name|PTR
operator|)
name|new
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|set_constant_flonums
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_FLOAT_VALS
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|atof_ieee
argument_list|(
operator|(
name|char
operator|*
operator|)
name|fp_const
index|[
name|i
index|]
argument_list|,
literal|'x'
argument_list|,
name|fp_values
index|[
name|i
index|]
argument_list|)
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|md_begin
parameter_list|()
block|{
name|unsigned
name|mach
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|(
name|arm_ops_hsh
operator|=
name|hash_new
argument_list|()
operator|)
operator|==
name|NULL
operator|||
operator|(
name|arm_tops_hsh
operator|=
name|hash_new
argument_list|()
operator|)
operator|==
name|NULL
operator|||
operator|(
name|arm_cond_hsh
operator|=
name|hash_new
argument_list|()
operator|)
operator|==
name|NULL
operator|||
operator|(
name|arm_shift_hsh
operator|=
name|hash_new
argument_list|()
operator|)
operator|==
name|NULL
operator|||
operator|(
name|arm_reg_hsh
operator|=
name|hash_new
argument_list|()
operator|)
operator|==
name|NULL
operator|||
operator|(
name|arm_psr_hsh
operator|=
name|hash_new
argument_list|()
operator|)
operator|==
name|NULL
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"Virtual memory exhausted"
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|insns
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|asm_opcode
argument_list|)
condition|;
name|i
operator|++
control|)
name|hash_insert
argument_list|(
name|arm_ops_hsh
argument_list|,
name|insns
index|[
name|i
index|]
operator|.
name|template
argument_list|,
call|(
name|PTR
call|)
argument_list|(
name|insns
operator|+
name|i
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|tinsns
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|thumb_opcode
argument_list|)
condition|;
name|i
operator|++
control|)
name|hash_insert
argument_list|(
name|arm_tops_hsh
argument_list|,
name|tinsns
index|[
name|i
index|]
operator|.
name|template
argument_list|,
call|(
name|PTR
call|)
argument_list|(
name|tinsns
operator|+
name|i
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|conds
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|asm_cond
argument_list|)
condition|;
name|i
operator|++
control|)
name|hash_insert
argument_list|(
name|arm_cond_hsh
argument_list|,
name|conds
index|[
name|i
index|]
operator|.
name|template
argument_list|,
call|(
name|PTR
call|)
argument_list|(
name|conds
operator|+
name|i
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|shift
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|asm_shift
argument_list|)
condition|;
name|i
operator|++
control|)
name|hash_insert
argument_list|(
name|arm_shift_hsh
argument_list|,
name|shift
index|[
name|i
index|]
operator|.
name|template
argument_list|,
call|(
name|PTR
call|)
argument_list|(
name|shift
operator|+
name|i
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|psrs
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|asm_psr
argument_list|)
condition|;
name|i
operator|++
control|)
name|hash_insert
argument_list|(
name|arm_psr_hsh
argument_list|,
name|psrs
index|[
name|i
index|]
operator|.
name|template
argument_list|,
call|(
name|PTR
call|)
argument_list|(
name|psrs
operator|+
name|i
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|reg_table
index|[
name|i
index|]
operator|.
name|name
condition|;
name|i
operator|++
control|)
name|insert_reg
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|set_constant_flonums
argument_list|()
expr_stmt|;
if|#
directive|if
name|defined
name|OBJ_COFF
operator|||
name|defined
name|OBJ_ELF
block|{
name|unsigned
name|int
name|flags
init|=
literal|0
decl_stmt|;
comment|/* Set the flags in the private structure.  */
if|if
condition|(
name|uses_apcs_26
condition|)
name|flags
operator||=
name|F_APCS26
expr_stmt|;
if|if
condition|(
name|support_interwork
condition|)
name|flags
operator||=
name|F_INTERWORK
expr_stmt|;
if|if
condition|(
name|uses_apcs_float
condition|)
name|flags
operator||=
name|F_APCS_FLOAT
expr_stmt|;
if|if
condition|(
name|pic_code
condition|)
name|flags
operator||=
name|F_PIC
expr_stmt|;
if|if
condition|(
operator|(
name|cpu_variant
operator|&
name|FPU_ALL
operator|)
operator|==
name|FPU_NONE
condition|)
name|flags
operator||=
name|F_SOFT_FLOAT
expr_stmt|;
name|bfd_set_private_flags
argument_list|(
name|stdoutput
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Record the CPU type as well.  */
switch|switch
condition|(
name|cpu_variant
operator|&
name|ARM_CPU_MASK
condition|)
block|{
case|case
name|ARM_2
case|:
name|mach
operator|=
name|bfd_mach_arm_2
expr_stmt|;
break|break;
case|case
name|ARM_3
case|:
comment|/* Also ARM_250.  */
name|mach
operator|=
name|bfd_mach_arm_2a
expr_stmt|;
break|break;
default|default:
case|case
name|ARM_6
operator||
name|ARM_3
operator||
name|ARM_2
case|:
comment|/* Actually no CPU type defined.  */
name|mach
operator|=
name|bfd_mach_arm_4
expr_stmt|;
break|break;
case|case
name|ARM_7
case|:
comment|/* Also ARM_6.  */
name|mach
operator|=
name|bfd_mach_arm_3
expr_stmt|;
break|break;
block|}
comment|/* Catch special cases.  */
if|if
condition|(
name|cpu_variant
operator|!=
operator|(
name|FPU_DEFAULT
operator||
name|CPU_DEFAULT
operator|)
condition|)
block|{
if|if
condition|(
name|cpu_variant
operator|&
operator|(
name|ARM_EXT_V5
operator|&
name|ARM_THUMB
operator|)
condition|)
name|mach
operator|=
name|bfd_mach_arm_5T
expr_stmt|;
elseif|else
if|if
condition|(
name|cpu_variant
operator|&
name|ARM_EXT_V5
condition|)
name|mach
operator|=
name|bfd_mach_arm_5
expr_stmt|;
elseif|else
if|if
condition|(
name|cpu_variant
operator|&
name|ARM_THUMB
condition|)
name|mach
operator|=
name|bfd_mach_arm_4T
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|cpu_variant
operator|&
name|ARM_ARCH_V4
operator|)
operator|==
name|ARM_ARCH_V4
condition|)
name|mach
operator|=
name|bfd_mach_arm_4
expr_stmt|;
elseif|else
if|if
condition|(
name|cpu_variant
operator|&
name|ARM_LONGMUL
condition|)
name|mach
operator|=
name|bfd_mach_arm_3M
expr_stmt|;
block|}
name|bfd_set_arch_mach
argument_list|(
name|stdoutput
argument_list|,
name|TARGET_ARCH
argument_list|,
name|mach
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Turn an integer of n bytes (in val) into a stream of bytes appropriate    for use in the a.out file, and stores them in the array pointed to by buf.    This knows about the endian-ness of the target machine and does    THE RIGHT THING, whatever it is.  Possible values for n are 1 (byte)    2 (short) and 4 (long)  Floating numbers are put out as a series of    LITTLENUMS (shorts, here at least).  */
end_comment

begin_function
name|void
name|md_number_to_chars
parameter_list|(
name|buf
parameter_list|,
name|val
parameter_list|,
name|n
parameter_list|)
name|char
modifier|*
name|buf
decl_stmt|;
name|valueT
name|val
decl_stmt|;
name|int
name|n
decl_stmt|;
block|{
if|if
condition|(
name|target_big_endian
condition|)
name|number_to_chars_bigendian
argument_list|(
name|buf
argument_list|,
name|val
argument_list|,
name|n
argument_list|)
expr_stmt|;
else|else
name|number_to_chars_littleendian
argument_list|(
name|buf
argument_list|,
name|val
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|valueT
name|md_chars_to_number
parameter_list|(
name|buf
parameter_list|,
name|n
parameter_list|)
name|char
modifier|*
name|buf
decl_stmt|;
name|int
name|n
decl_stmt|;
block|{
name|valueT
name|result
init|=
literal|0
decl_stmt|;
name|unsigned
name|char
modifier|*
name|where
init|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|buf
decl_stmt|;
if|if
condition|(
name|target_big_endian
condition|)
block|{
while|while
condition|(
name|n
operator|--
condition|)
block|{
name|result
operator|<<=
literal|8
expr_stmt|;
name|result
operator||=
operator|(
operator|*
name|where
operator|++
operator|&
literal|255
operator|)
expr_stmt|;
block|}
block|}
else|else
block|{
while|while
condition|(
name|n
operator|--
condition|)
block|{
name|result
operator|<<=
literal|8
expr_stmt|;
name|result
operator||=
operator|(
name|where
index|[
name|n
index|]
operator|&
literal|255
operator|)
expr_stmt|;
block|}
block|}
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Turn a string in input_line_pointer into a floating point constant    of type TYPE, and store the appropriate bytes in *litP.  The number    of LITTLENUMS emitted is stored in *sizeP .  An error message is    returned, or NULL on OK.     Note that fp constants aren't represent in the normal way on the ARM.    In big endian mode, things are as expected.  However, in little endian    mode fp constants are big-endian word-wise, and little-endian byte-wise    within the words.  For example, (double) 1.1 in big endian mode is    the byte sequence 3f f1 99 99 99 99 99 9a, and in little endian mode is    the byte sequence 99 99 f1 3f 9a 99 99 99.     ??? The format of 12 byte floats is uncertain according to gcc's arm.h.  */
end_comment

begin_function
name|char
modifier|*
name|md_atof
parameter_list|(
name|type
parameter_list|,
name|litP
parameter_list|,
name|sizeP
parameter_list|)
name|char
name|type
decl_stmt|;
name|char
modifier|*
name|litP
decl_stmt|;
name|int
modifier|*
name|sizeP
decl_stmt|;
block|{
name|int
name|prec
decl_stmt|;
name|LITTLENUM_TYPE
name|words
index|[
name|MAX_LITTLENUMS
index|]
decl_stmt|;
name|char
modifier|*
name|t
decl_stmt|;
name|int
name|i
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
literal|'f'
case|:
case|case
literal|'F'
case|:
case|case
literal|'s'
case|:
case|case
literal|'S'
case|:
name|prec
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
case|case
literal|'D'
case|:
case|case
literal|'r'
case|:
case|case
literal|'R'
case|:
name|prec
operator|=
literal|4
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
case|case
literal|'X'
case|:
name|prec
operator|=
literal|6
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
case|case
literal|'P'
case|:
name|prec
operator|=
literal|6
expr_stmt|;
break|break;
default|default:
operator|*
name|sizeP
operator|=
literal|0
expr_stmt|;
return|return
name|_
argument_list|(
literal|"Bad call to MD_ATOF()"
argument_list|)
return|;
block|}
name|t
operator|=
name|atof_ieee
argument_list|(
name|input_line_pointer
argument_list|,
name|type
argument_list|,
name|words
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
condition|)
name|input_line_pointer
operator|=
name|t
expr_stmt|;
operator|*
name|sizeP
operator|=
name|prec
operator|*
literal|2
expr_stmt|;
if|if
condition|(
name|target_big_endian
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|prec
condition|;
name|i
operator|++
control|)
block|{
name|md_number_to_chars
argument_list|(
name|litP
argument_list|,
operator|(
name|valueT
operator|)
name|words
index|[
name|i
index|]
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|litP
operator|+=
literal|2
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* For a 4 byte float the order of elements in `words' is 1 0.  For an 	 8 byte float the order is 1 0 3 2.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|prec
condition|;
name|i
operator|+=
literal|2
control|)
block|{
name|md_number_to_chars
argument_list|(
name|litP
argument_list|,
operator|(
name|valueT
operator|)
name|words
index|[
name|i
operator|+
literal|1
index|]
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|litP
operator|+
literal|2
argument_list|,
operator|(
name|valueT
operator|)
name|words
index|[
name|i
index|]
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|litP
operator|+=
literal|4
expr_stmt|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* The knowledge of the PC's pipeline offset is built into the insns themselves.  */
end_comment

begin_function
name|long
name|md_pcrel_from
parameter_list|(
name|fixP
parameter_list|)
name|fixS
modifier|*
name|fixP
decl_stmt|;
block|{
if|if
condition|(
name|fixP
operator|->
name|fx_addsy
operator|&&
name|S_GET_SEGMENT
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
operator|==
name|undefined_section
operator|&&
name|fixP
operator|->
name|fx_subsy
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|fixP
operator|->
name|fx_pcrel
operator|&&
operator|(
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_ARM_THUMB_ADD
operator|)
condition|)
block|{
comment|/* PC relative addressing on the Thumb is slightly odd 	 as the bottom two bits of the PC are forced to zero 	 for the calculation.  */
return|return
operator|(
name|fixP
operator|->
name|fx_where
operator|+
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_address
operator|)
operator|&
operator|~
literal|3
return|;
block|}
ifdef|#
directive|ifdef
name|TE_WINCE
comment|/* The pattern was adjusted to accomodate CE's off-by-one fixups,      so we un-adjust here to compensate for the accomodation.  */
return|return
name|fixP
operator|->
name|fx_where
operator|+
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_address
operator|+
literal|8
return|;
else|#
directive|else
return|return
name|fixP
operator|->
name|fx_where
operator|+
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_address
return|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Round up a section size to the appropriate boundary. */
end_comment

begin_function
name|valueT
name|md_section_align
parameter_list|(
name|segment
parameter_list|,
name|size
parameter_list|)
name|segT
name|segment
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|valueT
name|size
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|OBJ_ELF
return|return
name|size
return|;
else|#
directive|else
comment|/* Round all sects to multiple of 4 */
return|return
operator|(
name|size
operator|+
literal|3
operator|)
operator|&
operator|~
literal|3
return|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Under ELF we need to default _GLOBAL_OFFSET_TABLE.  Otherwise     we have no need to default values of symbols.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|symbolS
modifier|*
name|md_undefined_symbol
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|OBJ_ELF
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'_'
operator|&&
name|name
index|[
literal|1
index|]
operator|==
literal|'G'
operator|&&
name|streq
argument_list|(
name|name
argument_list|,
name|GLOBAL_OFFSET_TABLE_NAME
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|GOT_symbol
condition|)
block|{
if|if
condition|(
name|symbol_find
argument_list|(
name|name
argument_list|)
condition|)
name|as_bad
argument_list|(
literal|"GOT already in the symbol table"
argument_list|)
expr_stmt|;
name|GOT_symbol
operator|=
name|symbol_new
argument_list|(
name|name
argument_list|,
name|undefined_section
argument_list|,
operator|(
name|valueT
operator|)
literal|0
argument_list|,
operator|&
name|zero_address_frag
argument_list|)
expr_stmt|;
block|}
return|return
name|GOT_symbol
return|;
block|}
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* arm_reg_parse () := if it looks like a register, return its token and     advance the pointer. */
end_comment

begin_function
specifier|static
name|int
name|arm_reg_parse
parameter_list|(
name|ccp
parameter_list|)
specifier|register
name|char
modifier|*
modifier|*
name|ccp
decl_stmt|;
block|{
name|char
modifier|*
name|start
init|=
operator|*
name|ccp
decl_stmt|;
name|char
name|c
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|struct
name|reg_entry
modifier|*
name|reg
decl_stmt|;
ifdef|#
directive|ifdef
name|REGISTER_PREFIX
if|if
condition|(
operator|*
name|start
operator|!=
name|REGISTER_PREFIX
condition|)
return|return
name|FAIL
return|;
name|p
operator|=
name|start
operator|+
literal|1
expr_stmt|;
else|#
directive|else
name|p
operator|=
name|start
expr_stmt|;
ifdef|#
directive|ifdef
name|OPTIONAL_REGISTER_PREFIX
if|if
condition|(
operator|*
name|p
operator|==
name|OPTIONAL_REGISTER_PREFIX
condition|)
name|p
operator|++
operator|,
name|start
operator|++
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
if|if
condition|(
operator|!
name|isalpha
argument_list|(
operator|*
name|p
argument_list|)
operator|||
operator|!
name|is_name_beginner
argument_list|(
operator|*
name|p
argument_list|)
condition|)
return|return
name|FAIL
return|;
name|c
operator|=
operator|*
name|p
operator|++
expr_stmt|;
while|while
condition|(
name|isalpha
argument_list|(
name|c
argument_list|)
operator|||
name|isdigit
argument_list|(
name|c
argument_list|)
operator|||
name|c
operator|==
literal|'_'
condition|)
name|c
operator|=
operator|*
name|p
operator|++
expr_stmt|;
operator|*
operator|--
name|p
operator|=
literal|0
expr_stmt|;
name|reg
operator|=
operator|(
expr|struct
name|reg_entry
operator|*
operator|)
name|hash_find
argument_list|(
name|arm_reg_hsh
argument_list|,
name|start
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|reg
condition|)
block|{
operator|*
name|ccp
operator|=
name|p
expr_stmt|;
return|return
name|reg
operator|->
name|number
return|;
block|}
return|return
name|FAIL
return|;
block|}
end_function

begin_function
name|int
name|md_apply_fix3
parameter_list|(
name|fixP
parameter_list|,
name|val
parameter_list|,
name|seg
parameter_list|)
name|fixS
modifier|*
name|fixP
decl_stmt|;
name|valueT
modifier|*
name|val
decl_stmt|;
name|segT
name|seg
decl_stmt|;
block|{
name|offsetT
name|value
init|=
operator|*
name|val
decl_stmt|;
name|offsetT
name|newval
decl_stmt|;
name|unsigned
name|int
name|newimm
decl_stmt|;
name|unsigned
name|long
name|temp
decl_stmt|;
name|int
name|sign
decl_stmt|;
name|char
modifier|*
name|buf
init|=
name|fixP
operator|->
name|fx_where
operator|+
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_literal
decl_stmt|;
name|arm_fix_data
modifier|*
name|arm_data
init|=
operator|(
name|arm_fix_data
operator|*
operator|)
name|fixP
operator|->
name|tc_fix_data
decl_stmt|;
name|assert
argument_list|(
name|fixP
operator|->
name|fx_r_type
operator|<
name|BFD_RELOC_UNUSED
argument_list|)
expr_stmt|;
comment|/* Note whether this will delete the relocation.  */
if|#
directive|if
literal|0
comment|/* patch from REarnshaw to JDavis (disabled for the moment, since it doesn't work fully) */
block|if ((fixP->fx_addsy == 0 || symbol_constant_p (fixP->fx_addsy))&& !fixP->fx_pcrel)
else|#
directive|else
if|if
condition|(
name|fixP
operator|->
name|fx_addsy
operator|==
literal|0
operator|&&
operator|!
name|fixP
operator|->
name|fx_pcrel
condition|)
endif|#
directive|endif
name|fixP
operator|->
name|fx_done
operator|=
literal|1
expr_stmt|;
comment|/* If this symbol is in a different section then we need to leave it for      the linker to deal with.  Unfortunately, md_pcrel_from can't tell,      so we have to undo it's effects here.  */
if|if
condition|(
name|fixP
operator|->
name|fx_pcrel
condition|)
block|{
if|if
condition|(
name|fixP
operator|->
name|fx_addsy
operator|!=
name|NULL
operator|&&
name|S_IS_DEFINED
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
operator|&&
name|S_GET_SEGMENT
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
operator|!=
name|seg
condition|)
block|{
if|if
condition|(
name|target_oabi
operator|&&
operator|(
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_ARM_PCREL_BRANCH
operator|)
condition|)
name|value
operator|=
literal|0
expr_stmt|;
else|else
name|value
operator|+=
name|md_pcrel_from
argument_list|(
name|fixP
argument_list|)
expr_stmt|;
block|}
block|}
name|fixP
operator|->
name|fx_addnumber
operator|=
name|value
expr_stmt|;
comment|/* Remember value for emit_reloc.  */
switch|switch
condition|(
name|fixP
operator|->
name|fx_r_type
condition|)
block|{
case|case
name|BFD_RELOC_ARM_IMMEDIATE
case|:
name|newimm
operator|=
name|validate_immediate
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|temp
operator|=
name|md_chars_to_number
argument_list|(
name|buf
argument_list|,
name|INSN_SIZE
argument_list|)
expr_stmt|;
comment|/* If the instruction will fail, see if we can fix things up by 	 changing the opcode.  */
if|if
condition|(
name|newimm
operator|==
operator|(
name|unsigned
name|int
operator|)
name|FAIL
operator|&&
operator|(
name|newimm
operator|=
name|negate_data_op
argument_list|(
operator|&
name|temp
argument_list|,
name|value
argument_list|)
operator|)
operator|==
operator|(
name|unsigned
name|int
operator|)
name|FAIL
condition|)
block|{
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"invalid constant (%lx) after fixup"
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|value
argument_list|)
expr_stmt|;
break|break;
block|}
name|newimm
operator||=
operator|(
name|temp
operator|&
literal|0xfffff000
operator|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|buf
argument_list|,
operator|(
name|valueT
operator|)
name|newimm
argument_list|,
name|INSN_SIZE
argument_list|)
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_ARM_ADRL_IMMEDIATE
case|:
block|{
name|unsigned
name|int
name|highpart
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|newinsn
init|=
literal|0xe1a00000
decl_stmt|;
comment|/* nop */
name|newimm
operator|=
name|validate_immediate
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|temp
operator|=
name|md_chars_to_number
argument_list|(
name|buf
argument_list|,
name|INSN_SIZE
argument_list|)
expr_stmt|;
comment|/* If the instruction will fail, see if we can fix things up by 	   changing the opcode.  */
if|if
condition|(
name|newimm
operator|==
operator|(
name|unsigned
name|int
operator|)
name|FAIL
operator|&&
operator|(
name|newimm
operator|=
name|negate_data_op
argument_list|(
operator|&
name|temp
argument_list|,
name|value
argument_list|)
operator|)
operator|==
operator|(
name|unsigned
name|int
operator|)
name|FAIL
condition|)
block|{
comment|/* No ?  OK - try using two ADD instructions to generate the value.  */
name|newimm
operator|=
name|validate_immediate_twopart
argument_list|(
name|value
argument_list|,
operator|&
name|highpart
argument_list|)
expr_stmt|;
comment|/* Yes - then make sure that the second instruction is also an add.  */
if|if
condition|(
name|newimm
operator|!=
operator|(
name|unsigned
name|int
operator|)
name|FAIL
condition|)
name|newinsn
operator|=
name|temp
expr_stmt|;
comment|/* Still No ?  Try using a negated value.  */
elseif|else
if|if
condition|(
operator|(
name|newimm
operator|=
name|validate_immediate_twopart
argument_list|(
operator|-
name|value
argument_list|,
operator|&
name|highpart
argument_list|)
operator|)
operator|!=
operator|(
name|unsigned
name|int
operator|)
name|FAIL
condition|)
name|temp
operator|=
name|newinsn
operator|=
operator|(
name|temp
operator|&
name|OPCODE_MASK
operator|)
operator||
name|OPCODE_SUB
operator|<<
name|DATA_OP_SHIFT
expr_stmt|;
comment|/* Otherwise - give up.  */
else|else
block|{
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"Unable to compute ADRL instructions for PC offset of 0x%x"
argument_list|)
argument_list|,
name|value
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Replace the first operand in the 2nd instruction (which is the PC) 	       with the destination register.  We have already added in the PC in the 	       first instruction and we do not want to do it again.  */
name|newinsn
operator|&=
operator|~
literal|0xf0000
expr_stmt|;
name|newinsn
operator||=
operator|(
operator|(
name|newinsn
operator|&
literal|0x0f000
operator|)
operator|<<
literal|4
operator|)
expr_stmt|;
block|}
name|newimm
operator||=
operator|(
name|temp
operator|&
literal|0xfffff000
operator|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|buf
argument_list|,
operator|(
name|valueT
operator|)
name|newimm
argument_list|,
name|INSN_SIZE
argument_list|)
expr_stmt|;
name|highpart
operator||=
operator|(
name|newinsn
operator|&
literal|0xfffff000
operator|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|buf
operator|+
name|INSN_SIZE
argument_list|,
operator|(
name|valueT
operator|)
name|highpart
argument_list|,
name|INSN_SIZE
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|BFD_RELOC_ARM_OFFSET_IMM
case|:
name|sign
operator|=
name|value
operator|>=
literal|0
expr_stmt|;
if|if
condition|(
name|value
operator|<
literal|0
condition|)
name|value
operator|=
operator|-
name|value
expr_stmt|;
if|if
condition|(
name|validate_offset_imm
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
operator|==
name|FAIL
condition|)
block|{
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"bad immediate value for offset (%ld)"
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|value
argument_list|)
expr_stmt|;
break|break;
block|}
name|newval
operator|=
name|md_chars_to_number
argument_list|(
name|buf
argument_list|,
name|INSN_SIZE
argument_list|)
expr_stmt|;
name|newval
operator|&=
literal|0xff7ff000
expr_stmt|;
name|newval
operator||=
name|value
operator||
operator|(
name|sign
condition|?
name|INDEX_UP
else|:
literal|0
operator|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|buf
argument_list|,
name|newval
argument_list|,
name|INSN_SIZE
argument_list|)
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_ARM_OFFSET_IMM8
case|:
case|case
name|BFD_RELOC_ARM_HWLITERAL
case|:
name|sign
operator|=
name|value
operator|>=
literal|0
expr_stmt|;
if|if
condition|(
name|value
operator|<
literal|0
condition|)
name|value
operator|=
operator|-
name|value
expr_stmt|;
if|if
condition|(
name|validate_offset_imm
argument_list|(
name|value
argument_list|,
literal|1
argument_list|)
operator|==
name|FAIL
condition|)
block|{
if|if
condition|(
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_ARM_HWLITERAL
condition|)
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"invalid literal constant: pool needs to be closer"
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"bad immediate value for half-word offset (%ld)"
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|value
argument_list|)
expr_stmt|;
break|break;
block|}
name|newval
operator|=
name|md_chars_to_number
argument_list|(
name|buf
argument_list|,
name|INSN_SIZE
argument_list|)
expr_stmt|;
name|newval
operator|&=
literal|0xff7ff0f0
expr_stmt|;
name|newval
operator||=
operator|(
operator|(
name|value
operator|>>
literal|4
operator|)
operator|<<
literal|8
operator|)
operator||
operator|(
name|value
operator|&
literal|0xf
operator|)
operator||
operator|(
name|sign
condition|?
name|INDEX_UP
else|:
literal|0
operator|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|buf
argument_list|,
name|newval
argument_list|,
name|INSN_SIZE
argument_list|)
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_ARM_LITERAL
case|:
name|sign
operator|=
name|value
operator|>=
literal|0
expr_stmt|;
if|if
condition|(
name|value
operator|<
literal|0
condition|)
name|value
operator|=
operator|-
name|value
expr_stmt|;
if|if
condition|(
name|validate_offset_imm
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
operator|==
name|FAIL
condition|)
block|{
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"invalid literal constant: pool needs to be closer"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|newval
operator|=
name|md_chars_to_number
argument_list|(
name|buf
argument_list|,
name|INSN_SIZE
argument_list|)
expr_stmt|;
name|newval
operator|&=
literal|0xff7ff000
expr_stmt|;
name|newval
operator||=
name|value
operator||
operator|(
name|sign
condition|?
name|INDEX_UP
else|:
literal|0
operator|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|buf
argument_list|,
name|newval
argument_list|,
name|INSN_SIZE
argument_list|)
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_ARM_SHIFT_IMM
case|:
name|newval
operator|=
name|md_chars_to_number
argument_list|(
name|buf
argument_list|,
name|INSN_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|unsigned
name|long
operator|)
name|value
operator|)
operator|>
literal|32
operator|||
operator|(
name|value
operator|==
literal|32
operator|&&
operator|(
operator|(
operator|(
name|newval
operator|&
literal|0x60
operator|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|newval
operator|&
literal|0x60
operator|)
operator|==
literal|0x60
operator|)
operator|)
condition|)
block|{
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"shift expression is too large"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|value
operator|==
literal|0
condition|)
name|newval
operator|&=
operator|~
literal|0x60
expr_stmt|;
comment|/* Shifts of zero must be done as lsl */
elseif|else
if|if
condition|(
name|value
operator|==
literal|32
condition|)
name|value
operator|=
literal|0
expr_stmt|;
name|newval
operator|&=
literal|0xfffff07f
expr_stmt|;
name|newval
operator||=
operator|(
name|value
operator|&
literal|0x1f
operator|)
operator|<<
literal|7
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|buf
argument_list|,
name|newval
argument_list|,
name|INSN_SIZE
argument_list|)
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_ARM_SWI
case|:
if|if
condition|(
name|arm_data
operator|->
name|thumb_mode
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|unsigned
name|long
operator|)
name|value
operator|)
operator|>
literal|0xff
condition|)
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"Invalid swi expression"
argument_list|)
argument_list|)
expr_stmt|;
name|newval
operator|=
name|md_chars_to_number
argument_list|(
name|buf
argument_list|,
name|THUMB_SIZE
argument_list|)
operator|&
literal|0xff00
expr_stmt|;
name|newval
operator||=
name|value
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|buf
argument_list|,
name|newval
argument_list|,
name|THUMB_SIZE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
operator|(
name|unsigned
name|long
operator|)
name|value
operator|)
operator|>
literal|0x00ffffff
condition|)
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"Invalid swi expression"
argument_list|)
argument_list|)
expr_stmt|;
name|newval
operator|=
name|md_chars_to_number
argument_list|(
name|buf
argument_list|,
name|INSN_SIZE
argument_list|)
operator|&
literal|0xff000000
expr_stmt|;
name|newval
operator||=
name|value
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|buf
argument_list|,
name|newval
argument_list|,
name|INSN_SIZE
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|BFD_RELOC_ARM_MULTI
case|:
if|if
condition|(
operator|(
operator|(
name|unsigned
name|long
operator|)
name|value
operator|)
operator|>
literal|0xffff
condition|)
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"Invalid expression in load/store multiple"
argument_list|)
argument_list|)
expr_stmt|;
name|newval
operator|=
name|value
operator||
name|md_chars_to_number
argument_list|(
name|buf
argument_list|,
name|INSN_SIZE
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|buf
argument_list|,
name|newval
argument_list|,
name|INSN_SIZE
argument_list|)
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_ARM_PCREL_BRANCH
case|:
name|newval
operator|=
name|md_chars_to_number
argument_list|(
name|buf
argument_list|,
name|INSN_SIZE
argument_list|)
expr_stmt|;
comment|/* Sign-extend a 24-bit number.  */
define|#
directive|define
name|SEXT24
parameter_list|(
name|x
parameter_list|)
value|((((x)& 0xffffff) ^ (~ 0x7fffff)) + 0x800000)
ifdef|#
directive|ifdef
name|OBJ_ELF
if|if
condition|(
operator|!
name|target_oabi
condition|)
name|value
operator|=
name|fixP
operator|->
name|fx_offset
expr_stmt|;
endif|#
directive|endif
comment|/* We are going to store value (shifted right by two) in the 	 instruction, in a 24 bit, signed field.  Thus we need to check 	 that none of the top 8 bits of the shifted value (top 7 bits of          the unshifted, unsigned value) are set, or that they are all set.  */
if|if
condition|(
operator|(
name|value
operator|&
literal|0xfe000000UL
operator|)
operator|!=
literal|0
operator|&&
operator|(
operator|(
name|value
operator|&
literal|0xfe000000UL
operator|)
operator|!=
literal|0xfe000000UL
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|OBJ_ELF
comment|/* Normally we would be stuck at this point, since we cannot store 	     the absolute address that is the destination of the branch in the 	     24 bits of the branch instruction.  If however, we happen to know 	     that the destination of the branch is in the same section as the 	     branch instruciton itself, then we can compute the relocation for 	     ourselves and not have to bother the linker with it. 	      	     FIXME: The tests for OBJ_ELF and ! target_oabi are only here 	     because I have not worked out how to do this for OBJ_COFF or 	     target_oabi.  */
if|if
condition|(
operator|!
name|target_oabi
operator|&&
name|fixP
operator|->
name|fx_addsy
operator|!=
name|NULL
operator|&&
name|S_IS_DEFINED
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
operator|&&
name|S_GET_SEGMENT
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
operator|==
name|seg
condition|)
block|{
comment|/* Get pc relative value to go into the branch.  */
name|value
operator|=
operator|*
name|val
expr_stmt|;
comment|/* Permit a backward branch provided that enough bits are set. 		 Allow a forwards branch, provided that enough bits are clear.  */
if|if
condition|(
operator|(
name|value
operator|&
literal|0xfe000000UL
operator|)
operator|==
literal|0xfe000000UL
operator|||
operator|(
name|value
operator|&
literal|0xfe000000UL
operator|)
operator|==
literal|0
condition|)
name|fixP
operator|->
name|fx_done
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|fixP
operator|->
name|fx_done
condition|)
endif|#
directive|endif
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"gas can't handle same-section branch dest>= 0x04000000"
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|value
operator|>>=
literal|2
expr_stmt|;
name|value
operator|+=
name|SEXT24
argument_list|(
name|newval
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|value
operator|&
literal|0xff000000UL
operator|)
operator|!=
literal|0
operator|&&
operator|(
operator|(
name|value
operator|&
literal|0xff000000UL
operator|)
operator|!=
literal|0xff000000UL
operator|)
condition|)
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"out of range branch"
argument_list|)
argument_list|)
expr_stmt|;
name|newval
operator|=
operator|(
name|value
operator|&
literal|0x00ffffff
operator|)
operator||
operator|(
name|newval
operator|&
literal|0xff000000
operator|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|buf
argument_list|,
name|newval
argument_list|,
name|INSN_SIZE
argument_list|)
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_THUMB_PCREL_BRANCH9
case|:
comment|/* conditional branch */
name|newval
operator|=
name|md_chars_to_number
argument_list|(
name|buf
argument_list|,
name|THUMB_SIZE
argument_list|)
expr_stmt|;
block|{
name|addressT
name|diff
init|=
operator|(
name|newval
operator|&
literal|0xff
operator|)
operator|<<
literal|1
decl_stmt|;
if|if
condition|(
name|diff
operator|&
literal|0x100
condition|)
name|diff
operator||=
operator|~
literal|0xff
expr_stmt|;
name|value
operator|+=
name|diff
expr_stmt|;
if|if
condition|(
operator|(
name|value
operator|&
operator|~
literal|0xff
operator|)
operator|&&
operator|(
operator|(
name|value
operator|&
operator|~
literal|0xff
operator|)
operator|!=
operator|~
literal|0xff
operator|)
condition|)
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"Branch out of range"
argument_list|)
argument_list|)
expr_stmt|;
name|newval
operator|=
operator|(
name|newval
operator|&
literal|0xff00
operator|)
operator||
operator|(
operator|(
name|value
operator|&
literal|0x1ff
operator|)
operator|>>
literal|1
operator|)
expr_stmt|;
block|}
name|md_number_to_chars
argument_list|(
name|buf
argument_list|,
name|newval
argument_list|,
name|THUMB_SIZE
argument_list|)
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_THUMB_PCREL_BRANCH12
case|:
comment|/* unconditional branch */
name|newval
operator|=
name|md_chars_to_number
argument_list|(
name|buf
argument_list|,
name|THUMB_SIZE
argument_list|)
expr_stmt|;
block|{
name|addressT
name|diff
init|=
operator|(
name|newval
operator|&
literal|0x7ff
operator|)
operator|<<
literal|1
decl_stmt|;
if|if
condition|(
name|diff
operator|&
literal|0x800
condition|)
name|diff
operator||=
operator|~
literal|0x7ff
expr_stmt|;
name|value
operator|+=
name|diff
expr_stmt|;
if|if
condition|(
operator|(
name|value
operator|&
operator|~
literal|0x7ff
operator|)
operator|&&
operator|(
operator|(
name|value
operator|&
operator|~
literal|0x7ff
operator|)
operator|!=
operator|~
literal|0x7ff
operator|)
condition|)
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"Branch out of range"
argument_list|)
argument_list|)
expr_stmt|;
name|newval
operator|=
operator|(
name|newval
operator|&
literal|0xf800
operator|)
operator||
operator|(
operator|(
name|value
operator|&
literal|0xfff
operator|)
operator|>>
literal|1
operator|)
expr_stmt|;
block|}
name|md_number_to_chars
argument_list|(
name|buf
argument_list|,
name|newval
argument_list|,
name|THUMB_SIZE
argument_list|)
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_THUMB_PCREL_BRANCH23
case|:
block|{
name|offsetT
name|newval2
decl_stmt|;
name|addressT
name|diff
decl_stmt|;
name|newval
operator|=
name|md_chars_to_number
argument_list|(
name|buf
argument_list|,
name|THUMB_SIZE
argument_list|)
expr_stmt|;
name|newval2
operator|=
name|md_chars_to_number
argument_list|(
name|buf
operator|+
name|THUMB_SIZE
argument_list|,
name|THUMB_SIZE
argument_list|)
expr_stmt|;
name|diff
operator|=
operator|(
operator|(
name|newval
operator|&
literal|0x7ff
operator|)
operator|<<
literal|12
operator|)
operator||
operator|(
operator|(
name|newval2
operator|&
literal|0x7ff
operator|)
operator|<<
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|diff
operator|&
literal|0x400000
condition|)
name|diff
operator||=
operator|~
literal|0x3fffff
expr_stmt|;
ifdef|#
directive|ifdef
name|OBJ_ELF
name|value
operator|=
name|fixP
operator|->
name|fx_offset
expr_stmt|;
endif|#
directive|endif
name|value
operator|+=
name|diff
expr_stmt|;
if|if
condition|(
operator|(
name|value
operator|&
operator|~
literal|0x3fffff
operator|)
operator|&&
operator|(
operator|(
name|value
operator|&
operator|~
literal|0x3fffff
operator|)
operator|!=
operator|~
literal|0x3fffff
operator|)
condition|)
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"Branch with link out of range"
argument_list|)
argument_list|)
expr_stmt|;
name|newval
operator|=
operator|(
name|newval
operator|&
literal|0xf800
operator|)
operator||
operator|(
operator|(
name|value
operator|&
literal|0x7fffff
operator|)
operator|>>
literal|12
operator|)
expr_stmt|;
name|newval2
operator|=
operator|(
name|newval2
operator|&
literal|0xf800
operator|)
operator||
operator|(
operator|(
name|value
operator|&
literal|0xfff
operator|)
operator|>>
literal|1
operator|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|buf
argument_list|,
name|newval
argument_list|,
name|THUMB_SIZE
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|buf
operator|+
name|THUMB_SIZE
argument_list|,
name|newval2
argument_list|,
name|THUMB_SIZE
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|BFD_RELOC_8
case|:
if|if
condition|(
name|fixP
operator|->
name|fx_done
operator|||
name|fixP
operator|->
name|fx_pcrel
condition|)
name|md_number_to_chars
argument_list|(
name|buf
argument_list|,
name|value
argument_list|,
literal|1
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|OBJ_ELF
elseif|else
if|if
condition|(
operator|!
name|target_oabi
condition|)
block|{
name|value
operator|=
name|fixP
operator|->
name|fx_offset
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|buf
argument_list|,
name|value
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
break|break;
case|case
name|BFD_RELOC_16
case|:
if|if
condition|(
name|fixP
operator|->
name|fx_done
operator|||
name|fixP
operator|->
name|fx_pcrel
condition|)
name|md_number_to_chars
argument_list|(
name|buf
argument_list|,
name|value
argument_list|,
literal|2
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|OBJ_ELF
elseif|else
if|if
condition|(
operator|!
name|target_oabi
condition|)
block|{
name|value
operator|=
name|fixP
operator|->
name|fx_offset
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|buf
argument_list|,
name|value
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
break|break;
ifdef|#
directive|ifdef
name|OBJ_ELF
case|case
name|BFD_RELOC_ARM_GOT32
case|:
case|case
name|BFD_RELOC_ARM_GOTOFF
case|:
name|md_number_to_chars
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|,
literal|4
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|BFD_RELOC_RVA
case|:
case|case
name|BFD_RELOC_32
case|:
if|if
condition|(
name|fixP
operator|->
name|fx_done
operator|||
name|fixP
operator|->
name|fx_pcrel
condition|)
name|md_number_to_chars
argument_list|(
name|buf
argument_list|,
name|value
argument_list|,
literal|4
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|OBJ_ELF
elseif|else
if|if
condition|(
operator|!
name|target_oabi
condition|)
block|{
name|value
operator|=
name|fixP
operator|->
name|fx_offset
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|buf
argument_list|,
name|value
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
break|break;
ifdef|#
directive|ifdef
name|OBJ_ELF
case|case
name|BFD_RELOC_ARM_PLT32
case|:
comment|/* It appears the instruction is fully prepared at this point. */
break|break;
endif|#
directive|endif
case|case
name|BFD_RELOC_ARM_GOTPC
case|:
name|md_number_to_chars
argument_list|(
name|buf
argument_list|,
name|value
argument_list|,
literal|4
argument_list|)
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_ARM_CP_OFF_IMM
case|:
name|sign
operator|=
name|value
operator|>=
literal|0
expr_stmt|;
if|if
condition|(
name|value
operator|<
operator|-
literal|1023
operator|||
name|value
operator|>
literal|1023
operator|||
operator|(
name|value
operator|&
literal|3
operator|)
condition|)
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"Illegal value for co-processor offset"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|<
literal|0
condition|)
name|value
operator|=
operator|-
name|value
expr_stmt|;
name|newval
operator|=
name|md_chars_to_number
argument_list|(
name|buf
argument_list|,
name|INSN_SIZE
argument_list|)
operator|&
literal|0xff7fff00
expr_stmt|;
name|newval
operator||=
operator|(
name|value
operator|>>
literal|2
operator|)
operator||
operator|(
name|sign
condition|?
name|INDEX_UP
else|:
literal|0
operator|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|buf
argument_list|,
name|newval
argument_list|,
name|INSN_SIZE
argument_list|)
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_ARM_THUMB_OFFSET
case|:
name|newval
operator|=
name|md_chars_to_number
argument_list|(
name|buf
argument_list|,
name|THUMB_SIZE
argument_list|)
expr_stmt|;
comment|/* Exactly what ranges, and where the offset is inserted depends on 	 the type of instruction, we can establish this from the top 4 bits */
switch|switch
condition|(
name|newval
operator|>>
literal|12
condition|)
block|{
case|case
literal|4
case|:
comment|/* PC load */
comment|/* Thumb PC loads are somewhat odd, bit 1 of the PC is 	     forced to zero for these loads, so we will need to round 	     up the offset if the instruction address is not word 	     aligned (since the final address produced must be, and 	     we can only describe word-aligned immediate offsets).  */
if|if
condition|(
operator|(
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_address
operator|+
name|fixP
operator|->
name|fx_where
operator|+
name|value
operator|)
operator|&
literal|3
condition|)
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"Invalid offset, target not word aligned (0x%08X)"
argument_list|)
argument_list|,
call|(
name|unsigned
name|int
call|)
argument_list|(
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_address
operator|+
name|fixP
operator|->
name|fx_where
operator|+
name|value
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|value
operator|+
literal|2
operator|)
operator|&
operator|~
literal|0x3fe
condition|)
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"Invalid offset, value too big (0x%08X)"
argument_list|)
argument_list|,
name|value
argument_list|)
expr_stmt|;
comment|/* Round up, since pc will be rounded down.  */
name|newval
operator||=
operator|(
name|value
operator|+
literal|2
operator|)
operator|>>
literal|2
expr_stmt|;
break|break;
case|case
literal|9
case|:
comment|/* SP load/store */
if|if
condition|(
name|value
operator|&
operator|~
literal|0x3fc
condition|)
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"Invalid offset, value too big (0x%08X)"
argument_list|)
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|newval
operator||=
name|value
operator|>>
literal|2
expr_stmt|;
break|break;
case|case
literal|6
case|:
comment|/* Word load/store */
if|if
condition|(
name|value
operator|&
operator|~
literal|0x7c
condition|)
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"Invalid offset, value too big (0x%08X)"
argument_list|)
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|newval
operator||=
name|value
operator|<<
literal|4
expr_stmt|;
comment|/* 6 - 2 */
break|break;
case|case
literal|7
case|:
comment|/* Byte load/store */
if|if
condition|(
name|value
operator|&
operator|~
literal|0x1f
condition|)
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"Invalid offset, value too big (0x%08X)"
argument_list|)
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|newval
operator||=
name|value
operator|<<
literal|6
expr_stmt|;
break|break;
case|case
literal|8
case|:
comment|/* Halfword load/store */
if|if
condition|(
name|value
operator|&
operator|~
literal|0x3e
condition|)
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"Invalid offset, value too big (0x%08X)"
argument_list|)
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|newval
operator||=
name|value
operator|<<
literal|5
expr_stmt|;
comment|/* 6 - 1 */
break|break;
default|default:
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
literal|"Unable to process relocation for thumb opcode: %lx"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|newval
argument_list|)
expr_stmt|;
break|break;
block|}
name|md_number_to_chars
argument_list|(
name|buf
argument_list|,
name|newval
argument_list|,
name|THUMB_SIZE
argument_list|)
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_ARM_THUMB_ADD
case|:
comment|/* This is a complicated relocation, since we use it for all of          the following immediate relocations:             3bit ADD/SUB             8bit ADD/SUB             9bit ADD/SUB SP word-aligned            10bit ADD PC/SP word-aligned           The type of instruction being processed is encoded in the          instruction field:            0x8000  SUB            0x00F0  Rd            0x000F  Rs       */
name|newval
operator|=
name|md_chars_to_number
argument_list|(
name|buf
argument_list|,
name|THUMB_SIZE
argument_list|)
expr_stmt|;
block|{
name|int
name|rd
init|=
operator|(
name|newval
operator|>>
literal|4
operator|)
operator|&
literal|0xf
decl_stmt|;
name|int
name|rs
init|=
name|newval
operator|&
literal|0xf
decl_stmt|;
name|int
name|subtract
init|=
name|newval
operator|&
literal|0x8000
decl_stmt|;
if|if
condition|(
name|rd
operator|==
name|REG_SP
condition|)
block|{
if|if
condition|(
name|value
operator|&
operator|~
literal|0x1fc
condition|)
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"Invalid immediate for stack address calculation"
argument_list|)
argument_list|)
expr_stmt|;
name|newval
operator|=
name|subtract
condition|?
name|T_OPCODE_SUB_ST
else|:
name|T_OPCODE_ADD_ST
expr_stmt|;
name|newval
operator||=
name|value
operator|>>
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rs
operator|==
name|REG_PC
operator|||
name|rs
operator|==
name|REG_SP
condition|)
block|{
if|if
condition|(
name|subtract
operator|||
name|value
operator|&
operator|~
literal|0x3fc
condition|)
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"Invalid immediate for address calculation (value = 0x%08lX)"
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|value
argument_list|)
expr_stmt|;
name|newval
operator|=
operator|(
name|rs
operator|==
name|REG_PC
condition|?
name|T_OPCODE_ADD_PC
else|:
name|T_OPCODE_ADD_SP
operator|)
expr_stmt|;
name|newval
operator||=
name|rd
operator|<<
literal|8
expr_stmt|;
name|newval
operator||=
name|value
operator|>>
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rs
operator|==
name|rd
condition|)
block|{
if|if
condition|(
name|value
operator|&
operator|~
literal|0xff
condition|)
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"Invalid 8bit immediate"
argument_list|)
argument_list|)
expr_stmt|;
name|newval
operator|=
name|subtract
condition|?
name|T_OPCODE_SUB_I8
else|:
name|T_OPCODE_ADD_I8
expr_stmt|;
name|newval
operator||=
operator|(
name|rd
operator|<<
literal|8
operator|)
operator||
name|value
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|value
operator|&
operator|~
literal|0x7
condition|)
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"Invalid 3bit immediate"
argument_list|)
argument_list|)
expr_stmt|;
name|newval
operator|=
name|subtract
condition|?
name|T_OPCODE_SUB_I3
else|:
name|T_OPCODE_ADD_I3
expr_stmt|;
name|newval
operator||=
name|rd
operator||
operator|(
name|rs
operator|<<
literal|3
operator|)
operator||
operator|(
name|value
operator|<<
literal|6
operator|)
expr_stmt|;
block|}
block|}
name|md_number_to_chars
argument_list|(
name|buf
argument_list|,
name|newval
argument_list|,
name|THUMB_SIZE
argument_list|)
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_ARM_THUMB_IMM
case|:
name|newval
operator|=
name|md_chars_to_number
argument_list|(
name|buf
argument_list|,
name|THUMB_SIZE
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|newval
operator|>>
literal|11
condition|)
block|{
case|case
literal|0x04
case|:
comment|/* 8bit immediate MOV */
case|case
literal|0x05
case|:
comment|/* 8bit immediate CMP */
if|if
condition|(
name|value
operator|<
literal|0
operator|||
name|value
operator|>
literal|255
condition|)
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"Invalid immediate: %ld is too large"
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|value
argument_list|)
expr_stmt|;
name|newval
operator||=
name|value
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|md_number_to_chars
argument_list|(
name|buf
argument_list|,
name|newval
argument_list|,
name|THUMB_SIZE
argument_list|)
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_ARM_THUMB_SHIFT
case|:
comment|/* 5bit shift value (0..31) */
if|if
condition|(
name|value
operator|<
literal|0
operator|||
name|value
operator|>
literal|31
condition|)
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"Illegal Thumb shift value: %ld"
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|value
argument_list|)
expr_stmt|;
name|newval
operator|=
name|md_chars_to_number
argument_list|(
name|buf
argument_list|,
name|THUMB_SIZE
argument_list|)
operator|&
literal|0xf03f
expr_stmt|;
name|newval
operator||=
name|value
operator|<<
literal|6
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|buf
argument_list|,
name|newval
argument_list|,
name|THUMB_SIZE
argument_list|)
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_VTABLE_INHERIT
case|:
case|case
name|BFD_RELOC_VTABLE_ENTRY
case|:
name|fixP
operator|->
name|fx_done
operator|=
literal|0
expr_stmt|;
return|return
literal|1
return|;
case|case
name|BFD_RELOC_NONE
case|:
default|default:
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"Bad relocation fixup type (%d)"
argument_list|)
argument_list|,
name|fixP
operator|->
name|fx_r_type
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Translate internal representation of relocation info to BFD target    format.  */
end_comment

begin_function
name|arelent
modifier|*
name|tc_gen_reloc
parameter_list|(
name|section
parameter_list|,
name|fixp
parameter_list|)
name|asection
modifier|*
name|section
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|fixS
modifier|*
name|fixp
decl_stmt|;
block|{
name|arelent
modifier|*
name|reloc
decl_stmt|;
name|bfd_reloc_code_real_type
name|code
decl_stmt|;
name|reloc
operator|=
operator|(
name|arelent
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|arelent
argument_list|)
argument_list|)
expr_stmt|;
name|reloc
operator|->
name|sym_ptr_ptr
operator|=
operator|(
name|asymbol
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|asymbol
operator|*
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|reloc
operator|->
name|sym_ptr_ptr
operator|=
name|symbol_get_bfdsym
argument_list|(
name|fixp
operator|->
name|fx_addsy
argument_list|)
expr_stmt|;
name|reloc
operator|->
name|address
operator|=
name|fixp
operator|->
name|fx_frag
operator|->
name|fr_address
operator|+
name|fixp
operator|->
name|fx_where
expr_stmt|;
comment|/* @@ Why fx_addnumber sometimes and fx_offset other times?  */
ifndef|#
directive|ifndef
name|OBJ_ELF
if|if
condition|(
name|fixp
operator|->
name|fx_pcrel
operator|==
literal|0
condition|)
name|reloc
operator|->
name|addend
operator|=
name|fixp
operator|->
name|fx_offset
expr_stmt|;
else|else
name|reloc
operator|->
name|addend
operator|=
name|fixp
operator|->
name|fx_offset
operator|=
name|reloc
operator|->
name|address
expr_stmt|;
else|#
directive|else
comment|/* OBJ_ELF */
name|reloc
operator|->
name|addend
operator|=
name|fixp
operator|->
name|fx_offset
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|fixp
operator|->
name|fx_r_type
condition|)
block|{
case|case
name|BFD_RELOC_8
case|:
if|if
condition|(
name|fixp
operator|->
name|fx_pcrel
condition|)
block|{
name|code
operator|=
name|BFD_RELOC_8_PCREL
expr_stmt|;
break|break;
block|}
case|case
name|BFD_RELOC_16
case|:
if|if
condition|(
name|fixp
operator|->
name|fx_pcrel
condition|)
block|{
name|code
operator|=
name|BFD_RELOC_16_PCREL
expr_stmt|;
break|break;
block|}
case|case
name|BFD_RELOC_32
case|:
if|if
condition|(
name|fixp
operator|->
name|fx_pcrel
condition|)
block|{
name|code
operator|=
name|BFD_RELOC_32_PCREL
expr_stmt|;
break|break;
block|}
case|case
name|BFD_RELOC_ARM_PCREL_BRANCH
case|:
case|case
name|BFD_RELOC_RVA
case|:
case|case
name|BFD_RELOC_THUMB_PCREL_BRANCH9
case|:
case|case
name|BFD_RELOC_THUMB_PCREL_BRANCH12
case|:
case|case
name|BFD_RELOC_THUMB_PCREL_BRANCH23
case|:
case|case
name|BFD_RELOC_VTABLE_ENTRY
case|:
case|case
name|BFD_RELOC_VTABLE_INHERIT
case|:
name|code
operator|=
name|fixp
operator|->
name|fx_r_type
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_ARM_LITERAL
case|:
case|case
name|BFD_RELOC_ARM_HWLITERAL
case|:
comment|/* If this is called then the a literal has been referenced across 	 a section boundary - possibly due to an implicit dump */
name|as_bad_where
argument_list|(
name|fixp
operator|->
name|fx_file
argument_list|,
name|fixp
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"Literal referenced across section boundary (Implicit dump?)"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
ifdef|#
directive|ifdef
name|OBJ_ELF
case|case
name|BFD_RELOC_ARM_GOT32
case|:
case|case
name|BFD_RELOC_ARM_GOTOFF
case|:
case|case
name|BFD_RELOC_ARM_PLT32
case|:
name|code
operator|=
name|fixp
operator|->
name|fx_r_type
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|BFD_RELOC_ARM_IMMEDIATE
case|:
name|as_bad_where
argument_list|(
name|fixp
operator|->
name|fx_file
argument_list|,
name|fixp
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"Internal_relocation (type %d) not fixed up (IMMEDIATE)"
argument_list|)
argument_list|,
name|fixp
operator|->
name|fx_r_type
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
case|case
name|BFD_RELOC_ARM_ADRL_IMMEDIATE
case|:
name|as_bad_where
argument_list|(
name|fixp
operator|->
name|fx_file
argument_list|,
name|fixp
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"ADRL used for a symbol not defined in the same file"
argument_list|)
argument_list|,
name|fixp
operator|->
name|fx_r_type
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
case|case
name|BFD_RELOC_ARM_OFFSET_IMM
case|:
name|as_bad_where
argument_list|(
name|fixp
operator|->
name|fx_file
argument_list|,
name|fixp
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"Internal_relocation (type %d) not fixed up (OFFSET_IMM)"
argument_list|)
argument_list|,
name|fixp
operator|->
name|fx_r_type
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
default|default:
block|{
name|char
modifier|*
name|type
decl_stmt|;
switch|switch
condition|(
name|fixp
operator|->
name|fx_r_type
condition|)
block|{
case|case
name|BFD_RELOC_ARM_IMMEDIATE
case|:
name|type
operator|=
literal|"IMMEDIATE"
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_ARM_OFFSET_IMM
case|:
name|type
operator|=
literal|"OFFSET_IMM"
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_ARM_OFFSET_IMM8
case|:
name|type
operator|=
literal|"OFFSET_IMM8"
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_ARM_SHIFT_IMM
case|:
name|type
operator|=
literal|"SHIFT_IMM"
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_ARM_SWI
case|:
name|type
operator|=
literal|"SWI"
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_ARM_MULTI
case|:
name|type
operator|=
literal|"MULTI"
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_ARM_CP_OFF_IMM
case|:
name|type
operator|=
literal|"CP_OFF_IMM"
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_ARM_THUMB_ADD
case|:
name|type
operator|=
literal|"THUMB_ADD"
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_ARM_THUMB_SHIFT
case|:
name|type
operator|=
literal|"THUMB_SHIFT"
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_ARM_THUMB_IMM
case|:
name|type
operator|=
literal|"THUMB_IMM"
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_ARM_THUMB_OFFSET
case|:
name|type
operator|=
literal|"THUMB_OFFSET"
expr_stmt|;
break|break;
default|default:
name|type
operator|=
name|_
argument_list|(
literal|"<unknown>"
argument_list|)
expr_stmt|;
break|break;
block|}
name|as_bad_where
argument_list|(
name|fixp
operator|->
name|fx_file
argument_list|,
name|fixp
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"Can not represent %s relocation in this object file format (%d)"
argument_list|)
argument_list|,
name|type
argument_list|,
name|fixp
operator|->
name|fx_pcrel
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
ifdef|#
directive|ifdef
name|OBJ_ELF
if|if
condition|(
name|code
operator|==
name|BFD_RELOC_32_PCREL
operator|&&
name|GOT_symbol
operator|&&
name|fixp
operator|->
name|fx_addsy
operator|==
name|GOT_symbol
condition|)
block|{
name|code
operator|=
name|BFD_RELOC_ARM_GOTPC
expr_stmt|;
name|reloc
operator|->
name|addend
operator|=
name|fixp
operator|->
name|fx_offset
operator|=
name|reloc
operator|->
name|address
expr_stmt|;
block|}
endif|#
directive|endif
name|reloc
operator|->
name|howto
operator|=
name|bfd_reloc_type_lookup
argument_list|(
name|stdoutput
argument_list|,
name|code
argument_list|)
expr_stmt|;
if|if
condition|(
name|reloc
operator|->
name|howto
operator|==
name|NULL
condition|)
block|{
name|as_bad_where
argument_list|(
name|fixp
operator|->
name|fx_file
argument_list|,
name|fixp
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"Can not represent %s relocation in this object file format"
argument_list|)
argument_list|,
name|bfd_get_reloc_code_name
argument_list|(
name|code
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* HACK: Since arm ELF uses Rel instead of Rela, encode the       vtable entry to be used in the relocation's section offset.  */
if|if
condition|(
name|fixp
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_VTABLE_ENTRY
condition|)
name|reloc
operator|->
name|address
operator|=
name|fixp
operator|->
name|fx_offset
expr_stmt|;
return|return
name|reloc
return|;
block|}
end_function

begin_function
name|int
name|md_estimate_size_before_relax
parameter_list|(
name|fragP
parameter_list|,
name|segtype
parameter_list|)
name|fragS
modifier|*
name|fragP
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|segT
name|segtype
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"md_estimate_size_before_relax\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|void
name|output_inst
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
block|{
name|char
modifier|*
name|to
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|inst
operator|.
name|error
condition|)
block|{
name|as_bad
argument_list|(
name|inst
operator|.
name|error
argument_list|)
expr_stmt|;
return|return;
block|}
name|to
operator|=
name|frag_more
argument_list|(
name|inst
operator|.
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|thumb_mode
operator|&&
operator|(
name|inst
operator|.
name|size
operator|>
name|THUMB_SIZE
operator|)
condition|)
block|{
name|assert
argument_list|(
name|inst
operator|.
name|size
operator|==
operator|(
literal|2
operator|*
name|THUMB_SIZE
operator|)
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|to
argument_list|,
name|inst
operator|.
name|instruction
operator|>>
literal|16
argument_list|,
name|THUMB_SIZE
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|to
operator|+
name|THUMB_SIZE
argument_list|,
name|inst
operator|.
name|instruction
argument_list|,
name|THUMB_SIZE
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|inst
operator|.
name|size
operator|>
name|INSN_SIZE
condition|)
block|{
name|assert
argument_list|(
name|inst
operator|.
name|size
operator|==
operator|(
literal|2
operator|*
name|INSN_SIZE
operator|)
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|to
argument_list|,
name|inst
operator|.
name|instruction
argument_list|,
name|INSN_SIZE
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|to
operator|+
name|INSN_SIZE
argument_list|,
name|inst
operator|.
name|instruction
argument_list|,
name|INSN_SIZE
argument_list|)
expr_stmt|;
block|}
else|else
name|md_number_to_chars
argument_list|(
name|to
argument_list|,
name|inst
operator|.
name|instruction
argument_list|,
name|inst
operator|.
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|inst
operator|.
name|reloc
operator|.
name|type
operator|!=
name|BFD_RELOC_NONE
condition|)
name|fix_new_arm
argument_list|(
name|frag_now
argument_list|,
name|to
operator|-
name|frag_now
operator|->
name|fr_literal
argument_list|,
name|inst
operator|.
name|size
argument_list|,
operator|&
name|inst
operator|.
name|reloc
operator|.
name|exp
argument_list|,
name|inst
operator|.
name|reloc
operator|.
name|pc_rel
argument_list|,
name|inst
operator|.
name|reloc
operator|.
name|type
argument_list|)
expr_stmt|;
return|return;
block|}
end_decl_stmt

begin_function
name|void
name|md_assemble
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|char
name|c
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|q
decl_stmt|;
name|char
modifier|*
name|start
decl_stmt|;
comment|/* Align the instruction.      This may not be the right thing to do but ... */
comment|/* arm_align (2, 0); */
name|listing_prev_line
argument_list|()
expr_stmt|;
comment|/* Defined in listing.h */
comment|/* Align the previous label if needed.  */
if|if
condition|(
name|last_label_seen
operator|!=
name|NULL
condition|)
block|{
name|symbol_set_frag
argument_list|(
name|last_label_seen
argument_list|,
name|frag_now
argument_list|)
expr_stmt|;
name|S_SET_VALUE
argument_list|(
name|last_label_seen
argument_list|,
operator|(
name|valueT
operator|)
name|frag_now_fix
argument_list|()
argument_list|)
expr_stmt|;
name|S_SET_SEGMENT
argument_list|(
name|last_label_seen
argument_list|,
name|now_seg
argument_list|)
expr_stmt|;
block|}
name|memset
argument_list|(
operator|&
name|inst
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
name|inst
argument_list|)
argument_list|)
expr_stmt|;
name|inst
operator|.
name|reloc
operator|.
name|type
operator|=
name|BFD_RELOC_NONE
expr_stmt|;
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
comment|/* Scan up to the end of the op-code, which must end in white space or      end of string.  */
for|for
control|(
name|start
operator|=
name|p
operator|=
name|str
init|;
operator|*
name|p
operator|!=
literal|'\0'
condition|;
name|p
operator|++
control|)
if|if
condition|(
operator|*
name|p
operator|==
literal|' '
condition|)
break|break;
if|if
condition|(
name|p
operator|==
name|str
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"No operator -- statement `%s'\n"
argument_list|)
argument_list|,
name|str
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|thumb_mode
condition|)
block|{
name|CONST
name|struct
name|thumb_opcode
modifier|*
name|opcode
decl_stmt|;
name|c
operator|=
operator|*
name|p
expr_stmt|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
name|opcode
operator|=
operator|(
name|CONST
expr|struct
name|thumb_opcode
operator|*
operator|)
name|hash_find
argument_list|(
name|arm_tops_hsh
argument_list|,
name|str
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|opcode
condition|)
block|{
comment|/* Check that this instruction is supported for this CPU.  */
if|if
condition|(
name|thumb_mode
operator|==
literal|1
operator|&&
operator|(
name|opcode
operator|->
name|variants
operator|&
name|cpu_variant
operator|)
operator|==
literal|0
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"selected processor does not support this opcode"
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|inst
operator|.
name|instruction
operator|=
name|opcode
operator|->
name|value
expr_stmt|;
name|inst
operator|.
name|size
operator|=
name|opcode
operator|->
name|size
expr_stmt|;
call|(
modifier|*
name|opcode
operator|->
name|parms
call|)
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|output_inst
argument_list|()
expr_stmt|;
return|return;
block|}
block|}
else|else
block|{
name|CONST
name|struct
name|asm_opcode
modifier|*
name|opcode
decl_stmt|;
name|unsigned
name|long
name|cond_code
decl_stmt|;
name|inst
operator|.
name|size
operator|=
name|INSN_SIZE
expr_stmt|;
comment|/* p now points to the end of the opcode, probably white space, but we 	 have to break the opcode up in case it contains condionals and flags; 	 keep trying with progressively smaller basic instructions until one 	 matches, or we run out of opcode.  */
name|q
operator|=
operator|(
name|p
operator|-
name|str
operator|>
name|LONGEST_INST
operator|)
condition|?
name|str
operator|+
name|LONGEST_INST
else|:
name|p
expr_stmt|;
for|for
control|(
init|;
name|q
operator|!=
name|str
condition|;
name|q
operator|--
control|)
block|{
name|c
operator|=
operator|*
name|q
expr_stmt|;
operator|*
name|q
operator|=
literal|'\0'
expr_stmt|;
name|opcode
operator|=
operator|(
name|CONST
expr|struct
name|asm_opcode
operator|*
operator|)
name|hash_find
argument_list|(
name|arm_ops_hsh
argument_list|,
name|str
argument_list|)
expr_stmt|;
operator|*
name|q
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|opcode
operator|&&
name|opcode
operator|->
name|template
condition|)
block|{
name|unsigned
name|long
name|flag_bits
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|r
decl_stmt|;
comment|/* Check that this instruction is supported for this CPU.  */
if|if
condition|(
operator|(
name|opcode
operator|->
name|variants
operator|&
name|cpu_variant
operator|)
operator|==
literal|0
condition|)
goto|goto
name|try_shorter
goto|;
name|inst
operator|.
name|instruction
operator|=
name|opcode
operator|->
name|value
expr_stmt|;
if|if
condition|(
name|q
operator|==
name|p
condition|)
comment|/* Just a simple opcode.  */
block|{
if|if
condition|(
name|opcode
operator|->
name|comp_suffix
condition|)
block|{
if|if
condition|(
operator|*
name|opcode
operator|->
name|comp_suffix
operator|!=
literal|'\0'
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Opcode `%s' must have suffix from list:<%s>"
argument_list|)
argument_list|,
name|str
argument_list|,
name|opcode
operator|->
name|comp_suffix
argument_list|)
expr_stmt|;
else|else
comment|/* Not a conditional instruction. */
call|(
modifier|*
name|opcode
operator|->
name|parms
call|)
argument_list|(
name|q
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* A conditional instruction with default condition. */
name|inst
operator|.
name|instruction
operator||=
name|COND_ALWAYS
expr_stmt|;
call|(
modifier|*
name|opcode
operator|->
name|parms
call|)
argument_list|(
name|q
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|output_inst
argument_list|()
expr_stmt|;
return|return;
block|}
comment|/* Not just a simple opcode.  Check if extra is a conditional. */
name|r
operator|=
name|q
expr_stmt|;
if|if
condition|(
name|p
operator|-
name|r
operator|>=
literal|2
condition|)
block|{
name|CONST
name|struct
name|asm_cond
modifier|*
name|cond
decl_stmt|;
name|char
name|d
init|=
operator|*
operator|(
name|r
operator|+
literal|2
operator|)
decl_stmt|;
operator|*
operator|(
name|r
operator|+
literal|2
operator|)
operator|=
literal|'\0'
expr_stmt|;
name|cond
operator|=
operator|(
name|CONST
expr|struct
name|asm_cond
operator|*
operator|)
name|hash_find
argument_list|(
name|arm_cond_hsh
argument_list|,
name|r
argument_list|)
expr_stmt|;
operator|*
operator|(
name|r
operator|+
literal|2
operator|)
operator|=
name|d
expr_stmt|;
if|if
condition|(
name|cond
condition|)
block|{
if|if
condition|(
name|cond
operator|->
name|value
operator|==
literal|0xf0000000
condition|)
name|as_tsktsk
argument_list|(
name|_
argument_list|(
literal|"Warning: Use of the 'nv' conditional is deprecated\n"
argument_list|)
argument_list|)
expr_stmt|;
name|cond_code
operator|=
name|cond
operator|->
name|value
expr_stmt|;
name|r
operator|+=
literal|2
expr_stmt|;
block|}
else|else
name|cond_code
operator|=
name|COND_ALWAYS
expr_stmt|;
block|}
else|else
name|cond_code
operator|=
name|COND_ALWAYS
expr_stmt|;
comment|/* Apply the conditional, or complain it's not allowed. */
if|if
condition|(
name|opcode
operator|->
name|comp_suffix
operator|&&
operator|*
name|opcode
operator|->
name|comp_suffix
operator|==
literal|'\0'
condition|)
block|{
comment|/* Instruction isn't conditional */
if|if
condition|(
name|cond_code
operator|!=
name|COND_ALWAYS
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Opcode `%s' is unconditional\n"
argument_list|)
argument_list|,
name|str
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
else|else
comment|/* Instruction is conditional: set the condition into it. */
name|inst
operator|.
name|instruction
operator||=
name|cond_code
expr_stmt|;
comment|/* If there is a compulsory suffix, it should come here, before 		 any optional flags.  */
if|if
condition|(
name|opcode
operator|->
name|comp_suffix
operator|&&
operator|*
name|opcode
operator|->
name|comp_suffix
operator|!=
literal|'\0'
condition|)
block|{
name|CONST
name|char
modifier|*
name|s
init|=
name|opcode
operator|->
name|comp_suffix
decl_stmt|;
while|while
condition|(
operator|*
name|s
condition|)
block|{
name|inst
operator|.
name|suffix
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|r
operator|==
operator|*
name|s
condition|)
break|break;
name|s
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|s
operator|==
literal|'\0'
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Opcode `%s' must have suffix from<%s>\n"
argument_list|)
argument_list|,
name|str
argument_list|,
name|opcode
operator|->
name|comp_suffix
argument_list|)
expr_stmt|;
return|return;
block|}
name|r
operator|++
expr_stmt|;
block|}
comment|/* The remainder, if any should now be flags for the instruction; 		 Scan these checking each one found with the opcode.  */
if|if
condition|(
name|r
operator|!=
name|p
condition|)
block|{
name|char
name|d
decl_stmt|;
name|CONST
name|struct
name|asm_flg
modifier|*
name|flag
init|=
name|opcode
operator|->
name|flags
decl_stmt|;
if|if
condition|(
name|flag
condition|)
block|{
name|int
name|flagno
decl_stmt|;
name|d
operator|=
operator|*
name|p
expr_stmt|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
name|flagno
operator|=
literal|0
init|;
name|flag
index|[
name|flagno
index|]
operator|.
name|template
condition|;
name|flagno
operator|++
control|)
block|{
if|if
condition|(
name|streq
argument_list|(
name|r
argument_list|,
name|flag
index|[
name|flagno
index|]
operator|.
name|template
argument_list|)
condition|)
block|{
name|flag_bits
operator||=
name|flag
index|[
name|flagno
index|]
operator|.
name|set_bits
expr_stmt|;
break|break;
block|}
block|}
operator|*
name|p
operator|=
name|d
expr_stmt|;
if|if
condition|(
operator|!
name|flag
index|[
name|flagno
index|]
operator|.
name|template
condition|)
goto|goto
name|try_shorter
goto|;
block|}
else|else
goto|goto
name|try_shorter
goto|;
block|}
call|(
modifier|*
name|opcode
operator|->
name|parms
call|)
argument_list|(
name|p
argument_list|,
name|flag_bits
argument_list|)
expr_stmt|;
name|output_inst
argument_list|()
expr_stmt|;
return|return;
block|}
name|try_shorter
label|:
empty_stmt|;
block|}
block|}
comment|/* It wasn't an instruction, but it might be a register alias of the form      alias .req reg */
name|q
operator|=
name|p
expr_stmt|;
name|skip_whitespace
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|c
operator|=
operator|*
name|p
expr_stmt|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|*
name|q
operator|&&
operator|!
name|strncmp
argument_list|(
name|q
argument_list|,
literal|".req "
argument_list|,
literal|4
argument_list|)
condition|)
block|{
name|int
name|reg
decl_stmt|;
name|char
modifier|*
name|copy_of_str
init|=
name|str
decl_stmt|;
name|char
modifier|*
name|r
decl_stmt|;
name|q
operator|+=
literal|4
expr_stmt|;
name|skip_whitespace
argument_list|(
name|q
argument_list|)
expr_stmt|;
for|for
control|(
name|r
operator|=
name|q
init|;
operator|*
name|r
operator|!=
literal|'\0'
condition|;
name|r
operator|++
control|)
if|if
condition|(
operator|*
name|r
operator|==
literal|' '
condition|)
break|break;
if|if
condition|(
name|r
operator|!=
name|q
condition|)
block|{
name|int
name|regnum
decl_stmt|;
name|char
name|d
init|=
operator|*
name|r
decl_stmt|;
operator|*
name|r
operator|=
literal|'\0'
expr_stmt|;
name|regnum
operator|=
name|arm_reg_parse
argument_list|(
operator|&
name|q
argument_list|)
expr_stmt|;
operator|*
name|r
operator|=
name|d
expr_stmt|;
name|reg
operator|=
name|arm_reg_parse
argument_list|(
operator|&
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
operator|==
name|FAIL
condition|)
block|{
if|if
condition|(
name|regnum
operator|!=
name|FAIL
condition|)
name|insert_reg_alias
argument_list|(
name|str
argument_list|,
name|regnum
argument_list|)
expr_stmt|;
else|else
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"register '%s' does not exist\n"
argument_list|)
argument_list|,
name|q
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|regnum
operator|!=
name|FAIL
condition|)
block|{
if|if
condition|(
name|reg
operator|!=
name|regnum
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"ignoring redefinition of register alias '%s'"
argument_list|)
argument_list|,
name|copy_of_str
argument_list|)
expr_stmt|;
comment|/* Do not warn about redefinitions to the same alias.  */
block|}
else|else
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"ignoring redefinition of register alias '%s' to non-existant register '%s'"
argument_list|)
argument_list|,
name|copy_of_str
argument_list|,
name|q
argument_list|)
expr_stmt|;
block|}
else|else
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"ignoring incomplete .req pseuso op"
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
name|c
expr_stmt|;
return|return;
block|}
operator|*
name|p
operator|=
name|c
expr_stmt|;
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"bad instruction `%s'"
argument_list|)
argument_list|,
name|start
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * md_parse_option  *    Invocation line includes a switch not recognized by the base assembler.  *    See if it's a processor-specific option.  These are:  *    Cpu variants, the arm part is optional:  *            -m[arm]1                Currently not supported.  *            -m[arm]2, -m[arm]250    Arm 2 and Arm 250 processor  *            -m[arm]3                Arm 3 processor  *            -m[arm]6[xx],           Arm 6 processors  *            -m[arm]7[xx][t][[d]m]   Arm 7 processors  *            -m[arm]8[10]            Arm 8 processors  *            -m[arm]9[20][tdmi]      Arm 9 processors  *            -mstrongarm[110[0]]     StrongARM processors  *            -m[arm]v[2345[t]]       Arm architectures  *            -mall                   All (except the ARM1)  *    FP variants:  *            -mfpa10, -mfpa11        FPA10 and 11 co-processor instructions  *            -mfpe-old               (No float load/store multiples)  *            -mno-fpu                Disable all floating point instructions  *    Run-time endian selection:  *            -EB                     big endian cpu  *            -EL                     little endian cpu  *    ARM Procedure Calling Standard:  *	      -mapcs-32		      32 bit APCS  *	      -mapcs-26		      26 bit APCS  *	      -mapcs-float	      Pass floats in float regs  *	      -mapcs-reentrant        Position independent code  *            -mthumb-interwork       Code supports Arm/Thumb interworking  *            -moabi                  Old ELF ABI  */
end_comment

begin_decl_stmt
name|CONST
name|char
modifier|*
name|md_shortopts
init|=
literal|"m:k"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|option
name|md_longopts
index|[]
init|=
block|{
ifdef|#
directive|ifdef
name|ARM_BI_ENDIAN
define|#
directive|define
name|OPTION_EB
value|(OPTION_MD_BASE + 0)
block|{
literal|"EB"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_EB
block|}
block|,
define|#
directive|define
name|OPTION_EL
value|(OPTION_MD_BASE + 1)
block|{
literal|"EL"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_EL
block|}
block|,
ifdef|#
directive|ifdef
name|OBJ_ELF
define|#
directive|define
name|OPTION_OABI
value|(OPTION_MD_BASE +2)
block|{
literal|"oabi"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_OABI
block|}
block|,
endif|#
directive|endif
endif|#
directive|endif
block|{
name|NULL
block|,
name|no_argument
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|size_t
name|md_longopts_size
init|=
sizeof|sizeof
argument_list|(
name|md_longopts
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|md_parse_option
parameter_list|(
name|c
parameter_list|,
name|arg
parameter_list|)
name|int
name|c
decl_stmt|;
name|char
modifier|*
name|arg
decl_stmt|;
block|{
name|char
modifier|*
name|str
init|=
name|arg
decl_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
ifdef|#
directive|ifdef
name|ARM_BI_ENDIAN
case|case
name|OPTION_EB
case|:
name|target_big_endian
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|OPTION_EL
case|:
name|target_big_endian
operator|=
literal|0
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
literal|'m'
case|:
switch|switch
condition|(
operator|*
name|str
condition|)
block|{
case|case
literal|'f'
case|:
if|if
condition|(
name|streq
argument_list|(
name|str
argument_list|,
literal|"fpa10"
argument_list|)
condition|)
name|cpu_variant
operator|=
operator|(
name|cpu_variant
operator|&
operator|~
name|FPU_ALL
operator|)
operator||
name|FPU_FPA10
expr_stmt|;
elseif|else
if|if
condition|(
name|streq
argument_list|(
name|str
argument_list|,
literal|"fpa11"
argument_list|)
condition|)
name|cpu_variant
operator|=
operator|(
name|cpu_variant
operator|&
operator|~
name|FPU_ALL
operator|)
operator||
name|FPU_FPA11
expr_stmt|;
elseif|else
if|if
condition|(
name|streq
argument_list|(
name|str
argument_list|,
literal|"fpe-old"
argument_list|)
condition|)
name|cpu_variant
operator|=
operator|(
name|cpu_variant
operator|&
operator|~
name|FPU_ALL
operator|)
operator||
name|FPU_CORE
expr_stmt|;
else|else
goto|goto
name|bad
goto|;
break|break;
case|case
literal|'n'
case|:
if|if
condition|(
name|streq
argument_list|(
name|str
argument_list|,
literal|"no-fpu"
argument_list|)
condition|)
name|cpu_variant
operator|&=
operator|~
name|FPU_ALL
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|OBJ_ELF
case|case
literal|'o'
case|:
if|if
condition|(
name|streq
argument_list|(
name|str
argument_list|,
literal|"oabi"
argument_list|)
condition|)
name|target_oabi
operator|=
name|true
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
literal|'t'
case|:
comment|/* Limit assembler to generating only Thumb instructions: */
if|if
condition|(
name|streq
argument_list|(
name|str
argument_list|,
literal|"thumb"
argument_list|)
condition|)
block|{
name|cpu_variant
operator|=
operator|(
name|cpu_variant
operator|&
operator|~
name|ARM_ANY
operator|)
operator||
name|ARM_THUMB
expr_stmt|;
name|cpu_variant
operator|=
operator|(
name|cpu_variant
operator|&
operator|~
name|FPU_ALL
operator|)
operator||
name|FPU_NONE
expr_stmt|;
name|thumb_mode
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|streq
argument_list|(
name|str
argument_list|,
literal|"thumb-interwork"
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|cpu_variant
operator|&
name|ARM_THUMB
operator|)
operator|==
literal|0
condition|)
name|cpu_variant
operator|=
operator|(
name|cpu_variant
operator|&
operator|~
name|ARM_ANY
operator|)
operator||
name|ARM_ARCH_V4T
expr_stmt|;
if|#
directive|if
name|defined
name|OBJ_COFF
operator|||
name|defined
name|OBJ_ELF
name|support_interwork
operator|=
name|true
expr_stmt|;
endif|#
directive|endif
block|}
else|else
goto|goto
name|bad
goto|;
break|break;
default|default:
if|if
condition|(
name|streq
argument_list|(
name|str
argument_list|,
literal|"all"
argument_list|)
condition|)
block|{
name|cpu_variant
operator|=
name|ARM_ALL
operator||
name|FPU_ALL
expr_stmt|;
return|return
literal|1
return|;
block|}
if|#
directive|if
name|defined
name|OBJ_COFF
operator|||
name|defined
name|OBJ_ELF
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|str
argument_list|,
literal|"apcs-"
argument_list|,
literal|5
argument_list|)
condition|)
block|{
comment|/* GCC passes on all command line options starting "-mapcs-..." 		 to us, so we must parse them here.  */
name|str
operator|+=
literal|5
expr_stmt|;
if|if
condition|(
name|streq
argument_list|(
name|str
argument_list|,
literal|"32"
argument_list|)
condition|)
block|{
name|uses_apcs_26
operator|=
name|false
expr_stmt|;
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|streq
argument_list|(
name|str
argument_list|,
literal|"26"
argument_list|)
condition|)
block|{
name|uses_apcs_26
operator|=
name|true
expr_stmt|;
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|streq
argument_list|(
name|str
argument_list|,
literal|"frame"
argument_list|)
condition|)
block|{
comment|/* Stack frames are being generated - does not affect 		     linkage of code.  */
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|streq
argument_list|(
name|str
argument_list|,
literal|"stack-check"
argument_list|)
condition|)
block|{
comment|/* Stack checking is being performed - does not affect 		     linkage, but does require that the functions 		     __rt_stkovf_split_small and __rt_stkovf_split_big be 		     present in the final link.  */
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|streq
argument_list|(
name|str
argument_list|,
literal|"float"
argument_list|)
condition|)
block|{
comment|/* Floating point arguments are being passed in the floating 		     point registers.  This does affect linking, since this 		     version of the APCS is incompatible with the version that 		     passes floating points in the integer registers.  */
name|uses_apcs_float
operator|=
name|true
expr_stmt|;
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|streq
argument_list|(
name|str
argument_list|,
literal|"reentrant"
argument_list|)
condition|)
block|{
comment|/* Reentrant code has been generated.  This does affect 		     linking, since there is no point in linking reentrant/ 		     position independent code with absolute position code. */
name|pic_code
operator|=
name|true
expr_stmt|;
return|return
literal|1
return|;
block|}
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Unrecognised APCS switch -m%s"
argument_list|)
argument_list|,
name|arg
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
endif|#
directive|endif
comment|/* Strip off optional "arm" */
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|str
argument_list|,
literal|"arm"
argument_list|,
literal|3
argument_list|)
condition|)
name|str
operator|+=
literal|3
expr_stmt|;
switch|switch
condition|(
operator|*
name|str
condition|)
block|{
case|case
literal|'1'
case|:
if|if
condition|(
name|streq
argument_list|(
name|str
argument_list|,
literal|"1"
argument_list|)
condition|)
name|cpu_variant
operator|=
operator|(
name|cpu_variant
operator|&
operator|~
name|ARM_ANY
operator|)
operator||
name|ARM_1
expr_stmt|;
else|else
goto|goto
name|bad
goto|;
break|break;
case|case
literal|'2'
case|:
if|if
condition|(
name|streq
argument_list|(
name|str
argument_list|,
literal|"2"
argument_list|)
condition|)
name|cpu_variant
operator|=
operator|(
name|cpu_variant
operator|&
operator|~
name|ARM_ANY
operator|)
operator||
name|ARM_2
expr_stmt|;
elseif|else
if|if
condition|(
name|streq
argument_list|(
name|str
argument_list|,
literal|"250"
argument_list|)
condition|)
name|cpu_variant
operator|=
operator|(
name|cpu_variant
operator|&
operator|~
name|ARM_ANY
operator|)
operator||
name|ARM_250
expr_stmt|;
else|else
goto|goto
name|bad
goto|;
break|break;
case|case
literal|'3'
case|:
if|if
condition|(
name|streq
argument_list|(
name|str
argument_list|,
literal|"3"
argument_list|)
condition|)
name|cpu_variant
operator|=
operator|(
name|cpu_variant
operator|&
operator|~
name|ARM_ANY
operator|)
operator||
name|ARM_3
expr_stmt|;
else|else
goto|goto
name|bad
goto|;
break|break;
case|case
literal|'6'
case|:
switch|switch
condition|(
name|strtol
argument_list|(
name|str
argument_list|,
name|NULL
argument_list|,
literal|10
argument_list|)
condition|)
block|{
case|case
literal|6
case|:
case|case
literal|60
case|:
case|case
literal|600
case|:
case|case
literal|610
case|:
case|case
literal|620
case|:
name|cpu_variant
operator|=
operator|(
name|cpu_variant
operator|&
operator|~
name|ARM_ANY
operator|)
operator||
name|ARM_6
expr_stmt|;
break|break;
default|default:
goto|goto
name|bad
goto|;
block|}
break|break;
case|case
literal|'7'
case|:
switch|switch
condition|(
name|strtol
argument_list|(
name|str
argument_list|,
operator|&
name|str
argument_list|,
literal|10
argument_list|)
condition|)
comment|/* Eat the processor name */
block|{
case|case
literal|7
case|:
case|case
literal|70
case|:
case|case
literal|700
case|:
case|case
literal|710
case|:
case|case
literal|720
case|:
case|case
literal|7100
case|:
case|case
literal|7500
case|:
break|break;
default|default:
goto|goto
name|bad
goto|;
block|}
name|cpu_variant
operator|=
operator|(
name|cpu_variant
operator|&
operator|~
name|ARM_ANY
operator|)
operator||
name|ARM_7
expr_stmt|;
for|for
control|(
init|;
operator|*
name|str
condition|;
name|str
operator|++
control|)
block|{
switch|switch
condition|(
operator|*
name|str
condition|)
block|{
case|case
literal|'t'
case|:
name|cpu_variant
operator||=
operator|(
name|ARM_THUMB
operator||
name|ARM_ARCH_V4
operator|)
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
name|cpu_variant
operator||=
name|ARM_LONGMUL
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
comment|/* fe => fp enabled cpu.  */
if|if
condition|(
name|str
index|[
literal|1
index|]
operator|==
literal|'e'
condition|)
operator|++
name|str
expr_stmt|;
else|else
goto|goto
name|bad
goto|;
case|case
literal|'c'
case|:
comment|/* Left over from 710c processor name.  */
case|case
literal|'d'
case|:
comment|/* Debug */
case|case
literal|'i'
case|:
comment|/* Embedded ICE */
comment|/* Included for completeness in ARM processor naming. */
break|break;
default|default:
goto|goto
name|bad
goto|;
block|}
block|}
break|break;
case|case
literal|'8'
case|:
if|if
condition|(
name|streq
argument_list|(
name|str
argument_list|,
literal|"8"
argument_list|)
operator|||
name|streq
argument_list|(
name|str
argument_list|,
literal|"810"
argument_list|)
condition|)
name|cpu_variant
operator|=
operator|(
name|cpu_variant
operator|&
operator|~
name|ARM_ANY
operator|)
operator||
name|ARM_8
operator||
name|ARM_ARCH_V4
operator||
name|ARM_LONGMUL
expr_stmt|;
else|else
goto|goto
name|bad
goto|;
break|break;
case|case
literal|'9'
case|:
if|if
condition|(
name|streq
argument_list|(
name|str
argument_list|,
literal|"9"
argument_list|)
condition|)
name|cpu_variant
operator|=
operator|(
name|cpu_variant
operator|&
operator|~
name|ARM_ANY
operator|)
operator||
name|ARM_9
operator||
name|ARM_ARCH_V4
operator||
name|ARM_LONGMUL
operator||
name|ARM_THUMB
expr_stmt|;
elseif|else
if|if
condition|(
name|streq
argument_list|(
name|str
argument_list|,
literal|"920"
argument_list|)
condition|)
name|cpu_variant
operator|=
operator|(
name|cpu_variant
operator|&
operator|~
name|ARM_ANY
operator|)
operator||
name|ARM_9
operator||
name|ARM_ARCH_V4
operator||
name|ARM_LONGMUL
expr_stmt|;
elseif|else
if|if
condition|(
name|streq
argument_list|(
name|str
argument_list|,
literal|"920t"
argument_list|)
condition|)
name|cpu_variant
operator|=
operator|(
name|cpu_variant
operator|&
operator|~
name|ARM_ANY
operator|)
operator||
name|ARM_9
operator||
name|ARM_ARCH_V4
operator||
name|ARM_LONGMUL
operator||
name|ARM_THUMB
expr_stmt|;
elseif|else
if|if
condition|(
name|streq
argument_list|(
name|str
argument_list|,
literal|"9tdmi"
argument_list|)
condition|)
name|cpu_variant
operator|=
operator|(
name|cpu_variant
operator|&
operator|~
name|ARM_ANY
operator|)
operator||
name|ARM_9
operator||
name|ARM_ARCH_V4
operator||
name|ARM_LONGMUL
operator||
name|ARM_THUMB
expr_stmt|;
else|else
goto|goto
name|bad
goto|;
break|break;
case|case
literal|'s'
case|:
if|if
condition|(
name|streq
argument_list|(
name|str
argument_list|,
literal|"strongarm"
argument_list|)
operator|||
name|streq
argument_list|(
name|str
argument_list|,
literal|"strongarm110"
argument_list|)
operator|||
name|streq
argument_list|(
name|str
argument_list|,
literal|"strongarm1100"
argument_list|)
condition|)
name|cpu_variant
operator|=
operator|(
name|cpu_variant
operator|&
operator|~
name|ARM_ANY
operator|)
operator||
name|ARM_8
operator||
name|ARM_ARCH_V4
operator||
name|ARM_LONGMUL
expr_stmt|;
else|else
goto|goto
name|bad
goto|;
break|break;
case|case
literal|'v'
case|:
comment|/* Select variant based on architecture rather than processor.  */
switch|switch
condition|(
operator|*
operator|++
name|str
condition|)
block|{
case|case
literal|'2'
case|:
switch|switch
condition|(
operator|*
operator|++
name|str
condition|)
block|{
case|case
literal|'a'
case|:
name|cpu_variant
operator|=
operator|(
name|cpu_variant
operator|&
operator|~
name|ARM_ANY
operator|)
operator||
name|ARM_3
expr_stmt|;
break|break;
case|case
literal|0
case|:
name|cpu_variant
operator|=
operator|(
name|cpu_variant
operator|&
operator|~
name|ARM_ANY
operator|)
operator||
name|ARM_2
expr_stmt|;
break|break;
default|default:
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Invalid architecture variant -m%s"
argument_list|)
argument_list|,
name|arg
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
literal|'3'
case|:
name|cpu_variant
operator|=
operator|(
name|cpu_variant
operator|&
operator|~
name|ARM_ANY
operator|)
operator||
name|ARM_7
expr_stmt|;
switch|switch
condition|(
operator|*
operator|++
name|str
condition|)
block|{
case|case
literal|'m'
case|:
name|cpu_variant
operator||=
name|ARM_LONGMUL
expr_stmt|;
break|break;
case|case
literal|0
case|:
break|break;
default|default:
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Invalid architecture variant -m%s"
argument_list|)
argument_list|,
name|arg
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
literal|'4'
case|:
name|cpu_variant
operator|=
operator|(
name|cpu_variant
operator|&
operator|~
name|ARM_ANY
operator|)
operator||
name|ARM_ARCH_V4
expr_stmt|;
switch|switch
condition|(
operator|*
operator|++
name|str
condition|)
block|{
case|case
literal|'t'
case|:
name|cpu_variant
operator||=
name|ARM_THUMB
expr_stmt|;
break|break;
case|case
literal|0
case|:
break|break;
default|default:
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Invalid architecture variant -m%s"
argument_list|)
argument_list|,
name|arg
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
literal|'5'
case|:
name|cpu_variant
operator|=
operator|(
name|cpu_variant
operator|&
operator|~
name|ARM_ANY
operator|)
operator||
name|ARM_ARCH_V5
expr_stmt|;
switch|switch
condition|(
operator|*
operator|++
name|str
condition|)
block|{
case|case
literal|'t'
case|:
name|cpu_variant
operator||=
name|ARM_THUMB
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
name|cpu_variant
operator||=
name|ARM_EXT_V5E
expr_stmt|;
break|break;
case|case
literal|0
case|:
break|break;
default|default:
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Invalid architecture variant -m%s"
argument_list|)
argument_list|,
name|arg
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
default|default:
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Invalid architecture variant -m%s"
argument_list|)
argument_list|,
name|arg
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
default|default:
name|bad
label|:
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Invalid processor variant -m%s"
argument_list|)
argument_list|,
name|arg
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
break|break;
if|#
directive|if
name|defined
name|OBJ_ELF
operator|||
name|defined
name|OBJ_COFF
case|case
literal|'k'
case|:
name|pic_code
operator|=
literal|1
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
name|void
name|md_show_usage
parameter_list|(
name|fp
parameter_list|)
name|FILE
modifier|*
name|fp
decl_stmt|;
block|{
name|fprintf
argument_list|(
name|fp
argument_list|,
name|_
argument_list|(
literal|"\  ARM Specific Assembler Options:\n\   -m[arm][<processor name>] select processor variant\n\   -m[arm]v[2|2a|3|3m|4|4t|5[t][e]] select architecture variant\n\   -mthumb                   only allow Thumb instructions\n\   -mthumb-interwork         mark the assembled code as supporting interworking\n\   -mall                     allow any instruction\n\   -mfpa10, -mfpa11          select floating point architecture\n\   -mfpe-old                 don't allow floating-point multiple instructions\n\   -mno-fpu                  don't allow any floating-point instructions.\n\   -k                        generate PIC code.\n"
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
name|OBJ_COFF
operator|||
name|defined
name|OBJ_ELF
name|fprintf
argument_list|(
name|fp
argument_list|,
name|_
argument_list|(
literal|"\   -mapcs-32, -mapcs-26      specify which ARM Procedure Calling Standard to use\n\   -mapcs-float              floating point args are passed in FP regs\n\   -mapcs-reentrant          the code is position independent/reentrant\n"
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|OBJ_ELF
name|fprintf
argument_list|(
name|fp
argument_list|,
name|_
argument_list|(
literal|"\   -moabi                    support the old ELF ABI\n"
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ARM_BI_ENDIAN
name|fprintf
argument_list|(
name|fp
argument_list|,
name|_
argument_list|(
literal|"\   -EB                       assemble code for a big endian cpu\n\   -EL                       assemble code for a little endian cpu\n"
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* We need to be able to fix up arbitrary expressions in some statements.    This is so that we can handle symbols that are an arbitrary distance from    the pc.  The most common cases are of the form ((+/-sym -/+ . - 8)& mask),    which returns part of an address in a form which will be valid for    a data instruction.  We do this by pushing the expression into a symbol    in the expr_section, and creating a fix for that.  */
end_comment

begin_function
specifier|static
name|void
name|fix_new_arm
parameter_list|(
name|frag
parameter_list|,
name|where
parameter_list|,
name|size
parameter_list|,
name|exp
parameter_list|,
name|pc_rel
parameter_list|,
name|reloc
parameter_list|)
name|fragS
modifier|*
name|frag
decl_stmt|;
name|int
name|where
decl_stmt|;
name|short
name|int
name|size
decl_stmt|;
name|expressionS
modifier|*
name|exp
decl_stmt|;
name|int
name|pc_rel
decl_stmt|;
name|int
name|reloc
decl_stmt|;
block|{
name|fixS
modifier|*
name|new_fix
decl_stmt|;
name|arm_fix_data
modifier|*
name|arm_data
decl_stmt|;
switch|switch
condition|(
name|exp
operator|->
name|X_op
condition|)
block|{
case|case
name|O_constant
case|:
case|case
name|O_symbol
case|:
case|case
name|O_add
case|:
case|case
name|O_subtract
case|:
name|new_fix
operator|=
name|fix_new_exp
argument_list|(
name|frag
argument_list|,
name|where
argument_list|,
name|size
argument_list|,
name|exp
argument_list|,
name|pc_rel
argument_list|,
name|reloc
argument_list|)
expr_stmt|;
break|break;
default|default:
name|new_fix
operator|=
name|fix_new
argument_list|(
name|frag
argument_list|,
name|where
argument_list|,
name|size
argument_list|,
name|make_expr_symbol
argument_list|(
name|exp
argument_list|)
argument_list|,
literal|0
argument_list|,
name|pc_rel
argument_list|,
name|reloc
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Mark whether the fix is to a THUMB instruction, or an ARM instruction */
name|arm_data
operator|=
operator|(
name|arm_fix_data
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|notes
argument_list|,
sizeof|sizeof
argument_list|(
name|arm_fix_data
argument_list|)
argument_list|)
expr_stmt|;
name|new_fix
operator|->
name|tc_fix_data
operator|=
operator|(
name|PTR
operator|)
name|arm_data
expr_stmt|;
name|arm_data
operator|->
name|thumb_mode
operator|=
name|thumb_mode
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* This fix_new is called by cons via TC_CONS_FIX_NEW.  */
end_comment

begin_function
name|void
name|cons_fix_new_arm
parameter_list|(
name|frag
parameter_list|,
name|where
parameter_list|,
name|size
parameter_list|,
name|exp
parameter_list|)
name|fragS
modifier|*
name|frag
decl_stmt|;
name|int
name|where
decl_stmt|;
name|int
name|size
decl_stmt|;
name|expressionS
modifier|*
name|exp
decl_stmt|;
block|{
name|bfd_reloc_code_real_type
name|type
decl_stmt|;
name|int
name|pcrel
init|=
literal|0
decl_stmt|;
comment|/* Pick a reloc.      FIXME: @@ Should look at CPU word size.  */
switch|switch
condition|(
name|size
condition|)
block|{
case|case
literal|1
case|:
name|type
operator|=
name|BFD_RELOC_8
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|type
operator|=
name|BFD_RELOC_16
expr_stmt|;
break|break;
case|case
literal|4
case|:
default|default:
name|type
operator|=
name|BFD_RELOC_32
expr_stmt|;
break|break;
case|case
literal|8
case|:
name|type
operator|=
name|BFD_RELOC_64
expr_stmt|;
break|break;
block|}
name|fix_new_exp
argument_list|(
name|frag
argument_list|,
name|where
argument_list|,
operator|(
name|int
operator|)
name|size
argument_list|,
name|exp
argument_list|,
name|pcrel
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* A good place to do this, although this was probably not intended    for this kind of use.  We need to dump the literal pool before    references are made to a null symbol pointer.  */
end_comment

begin_function
name|void
name|arm_cleanup
parameter_list|()
block|{
if|if
condition|(
name|current_poolP
operator|==
name|NULL
condition|)
return|return;
name|subseg_set
argument_list|(
name|text_section
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Put it at the end of text section.  */
name|s_ltorg
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|listing_prev_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|arm_start_line_hook
parameter_list|()
block|{
name|last_label_seen
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
name|void
name|arm_frob_label
parameter_list|(
name|sym
parameter_list|)
name|symbolS
modifier|*
name|sym
decl_stmt|;
block|{
name|last_label_seen
operator|=
name|sym
expr_stmt|;
name|ARM_SET_THUMB
argument_list|(
name|sym
argument_list|,
name|thumb_mode
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
name|OBJ_COFF
operator|||
name|defined
name|OBJ_ELF
name|ARM_SET_INTERWORK
argument_list|(
name|sym
argument_list|,
name|support_interwork
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|label_is_thumb_function_name
condition|)
block|{
comment|/* When the address of a Thumb function is taken the bottom 	 bit of that address should be set.  This will allow 	 interworking between Arm and Thumb functions to work 	 correctly.  */
name|THUMB_SET_FUNC
argument_list|(
name|sym
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|label_is_thumb_function_name
operator|=
name|false
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Adjust the symbol table.  This marks Thumb symbols as distinct from    ARM ones.  */
end_comment

begin_function
name|void
name|arm_adjust_symtab
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|OBJ_COFF
name|symbolS
modifier|*
name|sym
decl_stmt|;
for|for
control|(
name|sym
operator|=
name|symbol_rootP
init|;
name|sym
operator|!=
name|NULL
condition|;
name|sym
operator|=
name|symbol_next
argument_list|(
name|sym
argument_list|)
control|)
block|{
if|if
condition|(
name|ARM_IS_THUMB
argument_list|(
name|sym
argument_list|)
condition|)
block|{
if|if
condition|(
name|THUMB_IS_FUNC
argument_list|(
name|sym
argument_list|)
condition|)
block|{
comment|/* Mark the symbol as a Thumb function.  */
if|if
condition|(
name|S_GET_STORAGE_CLASS
argument_list|(
name|sym
argument_list|)
operator|==
name|C_STAT
operator|||
name|S_GET_STORAGE_CLASS
argument_list|(
name|sym
argument_list|)
operator|==
name|C_LABEL
condition|)
comment|/* This can happen! */
name|S_SET_STORAGE_CLASS
argument_list|(
name|sym
argument_list|,
name|C_THUMBSTATFUNC
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|S_GET_STORAGE_CLASS
argument_list|(
name|sym
argument_list|)
operator|==
name|C_EXT
condition|)
name|S_SET_STORAGE_CLASS
argument_list|(
name|sym
argument_list|,
name|C_THUMBEXTFUNC
argument_list|)
expr_stmt|;
else|else
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"%s: unexpected function type: %d"
argument_list|)
argument_list|,
name|S_GET_NAME
argument_list|(
name|sym
argument_list|)
argument_list|,
name|S_GET_STORAGE_CLASS
argument_list|(
name|sym
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
switch|switch
condition|(
name|S_GET_STORAGE_CLASS
argument_list|(
name|sym
argument_list|)
condition|)
block|{
case|case
name|C_EXT
case|:
name|S_SET_STORAGE_CLASS
argument_list|(
name|sym
argument_list|,
name|C_THUMBEXT
argument_list|)
expr_stmt|;
break|break;
case|case
name|C_STAT
case|:
name|S_SET_STORAGE_CLASS
argument_list|(
name|sym
argument_list|,
name|C_THUMBSTAT
argument_list|)
expr_stmt|;
break|break;
case|case
name|C_LABEL
case|:
name|S_SET_STORAGE_CLASS
argument_list|(
name|sym
argument_list|,
name|C_THUMBLABEL
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* do nothing */
break|break;
block|}
block|}
if|if
condition|(
name|ARM_IS_INTERWORK
argument_list|(
name|sym
argument_list|)
condition|)
name|coffsymbol
argument_list|(
name|symbol_get_bfdsym
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|->
name|native
operator|->
name|u
operator|.
name|syment
operator|.
name|n_flags
operator|=
literal|0xFF
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|OBJ_ELF
name|symbolS
modifier|*
name|sym
decl_stmt|;
name|char
name|bind
decl_stmt|;
for|for
control|(
name|sym
operator|=
name|symbol_rootP
init|;
name|sym
operator|!=
name|NULL
condition|;
name|sym
operator|=
name|symbol_next
argument_list|(
name|sym
argument_list|)
control|)
block|{
if|if
condition|(
name|ARM_IS_THUMB
argument_list|(
name|sym
argument_list|)
condition|)
block|{
name|elf_symbol_type
modifier|*
name|elf_sym
decl_stmt|;
name|elf_sym
operator|=
name|elf_symbol
argument_list|(
name|symbol_get_bfdsym
argument_list|(
name|sym
argument_list|)
argument_list|)
expr_stmt|;
name|bind
operator|=
name|ELF_ST_BIND
argument_list|(
name|elf_sym
argument_list|)
expr_stmt|;
comment|/* If it's a .thumb_func, declare it as so, 	     otherwise tag label as .code 16.  */
if|if
condition|(
name|THUMB_IS_FUNC
argument_list|(
name|sym
argument_list|)
condition|)
name|elf_sym
operator|->
name|internal_elf_sym
operator|.
name|st_info
operator|=
name|ELF_ST_INFO
argument_list|(
name|bind
argument_list|,
name|STT_ARM_TFUNC
argument_list|)
expr_stmt|;
else|else
name|elf_sym
operator|->
name|internal_elf_sym
operator|.
name|st_info
operator|=
name|ELF_ST_INFO
argument_list|(
name|bind
argument_list|,
name|STT_ARM_16BIT
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
block|}
end_function

begin_function
name|int
name|arm_data_in_code
parameter_list|()
block|{
if|if
condition|(
name|thumb_mode
operator|&&
operator|!
name|strncmp
argument_list|(
name|input_line_pointer
operator|+
literal|1
argument_list|,
literal|"data:"
argument_list|,
literal|5
argument_list|)
condition|)
block|{
operator|*
name|input_line_pointer
operator|=
literal|'/'
expr_stmt|;
name|input_line_pointer
operator|+=
literal|5
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
literal|0
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|arm_canonicalize_symbol_name
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|int
name|len
decl_stmt|;
if|if
condition|(
name|thumb_mode
operator|&&
operator|(
name|len
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
operator|)
operator|>
literal|5
operator|&&
name|streq
argument_list|(
name|name
operator|+
name|len
operator|-
literal|5
argument_list|,
literal|"/data"
argument_list|)
condition|)
operator|*
operator|(
name|name
operator|+
name|len
operator|-
literal|5
operator|)
operator|=
literal|0
expr_stmt|;
return|return
name|name
return|;
block|}
end_function

begin_function
name|boolean
name|arm_validate_fix
parameter_list|(
name|fixP
parameter_list|)
name|fixS
modifier|*
name|fixP
decl_stmt|;
block|{
comment|/* If the destination of the branch is a defined symbol which does not have      the THUMB_FUNC attribute, then we must be calling a function which has      the (interfacearm) attribute.  We look for the Thumb entry point to that      function and change the branch to refer to that function instead.  */
if|if
condition|(
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_THUMB_PCREL_BRANCH23
operator|&&
name|fixP
operator|->
name|fx_addsy
operator|!=
name|NULL
operator|&&
name|S_IS_DEFINED
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
operator|&&
operator|!
name|THUMB_IS_FUNC
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
condition|)
block|{
name|fixP
operator|->
name|fx_addsy
operator|=
name|find_real_start
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|OBJ_ELF
end_ifdef

begin_comment
comment|/* Relocations against Thumb function names must be left unadjusted,    so that the linker can use this information to correctly set the    bottom bit of their addresses.  The MIPS version of this function    also prevents relocations that are mips-16 specific, but I do not    know why it does this.     FIXME:    There is one other problem that ought to be addressed here, but    which currently is not:  Taking the address of a label (rather    than a function) and then later jumping to that address.  Such    addresses also ought to have their bottom bit set (assuming that    they reside in Thumb code), but at the moment they will not.  */
end_comment

begin_function
name|boolean
name|arm_fix_adjustable
parameter_list|(
name|fixP
parameter_list|)
name|fixS
modifier|*
name|fixP
decl_stmt|;
block|{
if|if
condition|(
name|fixP
operator|->
name|fx_addsy
operator|==
name|NULL
condition|)
return|return
literal|1
return|;
comment|/* Prevent all adjustments to global symbols. */
if|if
condition|(
name|S_IS_EXTERN
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|S_IS_WEAK
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|THUMB_IS_FUNC
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
operator|&&
name|fixP
operator|->
name|fx_subsy
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
comment|/* We need the symbol name for the VTABLE entries */
if|if
condition|(
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_VTABLE_INHERIT
operator|||
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_VTABLE_ENTRY
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|elf32_arm_target_format
parameter_list|()
block|{
if|if
condition|(
name|target_big_endian
condition|)
if|if
condition|(
name|target_oabi
condition|)
return|return
literal|"elf32-bigarm-oabi"
return|;
else|else
return|return
literal|"elf32-bigarm"
return|;
elseif|else
if|if
condition|(
name|target_oabi
condition|)
return|return
literal|"elf32-littlearm-oabi"
return|;
else|else
return|return
literal|"elf32-littlearm"
return|;
block|}
end_function

begin_function
name|void
name|armelf_frob_symbol
parameter_list|(
name|symp
parameter_list|,
name|puntp
parameter_list|)
name|symbolS
modifier|*
name|symp
decl_stmt|;
name|int
modifier|*
name|puntp
decl_stmt|;
block|{
name|elf_frob_symbol
argument_list|(
name|symp
argument_list|,
name|puntp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|arm_force_relocation
parameter_list|(
name|fixp
parameter_list|)
name|struct
name|fix
modifier|*
name|fixp
decl_stmt|;
block|{
if|if
condition|(
name|fixp
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_VTABLE_INHERIT
operator|||
name|fixp
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_VTABLE_ENTRY
operator|||
name|fixp
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_ARM_PCREL_BRANCH
operator|||
name|fixp
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_THUMB_PCREL_BRANCH23
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_reloc_code_real_type
name|arm_parse_reloc
parameter_list|()
block|{
name|char
name|id
index|[
literal|16
index|]
decl_stmt|;
name|char
modifier|*
name|ip
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
specifier|static
struct|struct
block|{
name|char
modifier|*
name|str
decl_stmt|;
name|int
name|len
decl_stmt|;
name|bfd_reloc_code_real_type
name|reloc
decl_stmt|;
block|}
name|reloc_map
index|[]
init|=
block|{
define|#
directive|define
name|MAP
parameter_list|(
name|str
parameter_list|,
name|reloc
parameter_list|)
value|{ str, sizeof (str)-1, reloc }
name|MAP
argument_list|(
literal|"(got)"
argument_list|,
name|BFD_RELOC_ARM_GOT32
argument_list|)
block|,
name|MAP
argument_list|(
literal|"(gotoff)"
argument_list|,
name|BFD_RELOC_ARM_GOTOFF
argument_list|)
block|,
comment|/* ScottB: Jan 30, 1998 */
comment|/* Added support for parsing "var(PLT)" branch instructions */
comment|/* generated by GCC for PLT relocs */
name|MAP
argument_list|(
literal|"(plt)"
argument_list|,
name|BFD_RELOC_ARM_PLT32
argument_list|)
block|,
block|{
name|NULL
block|,
literal|0
block|,
name|BFD_RELOC_UNUSED
block|}
undef|#
directive|undef
name|MAP
block|}
struct|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|ip
operator|=
name|input_line_pointer
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|id
argument_list|)
operator|&&
operator|(
name|isalnum
argument_list|(
operator|*
name|ip
argument_list|)
operator|||
name|ispunct
argument_list|(
operator|*
name|ip
argument_list|)
operator|)
condition|;
name|i
operator|++
operator|,
name|ip
operator|++
control|)
name|id
index|[
name|i
index|]
operator|=
name|tolower
argument_list|(
operator|*
name|ip
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|reloc_map
index|[
name|i
index|]
operator|.
name|str
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|strncmp
argument_list|(
name|id
argument_list|,
name|reloc_map
index|[
name|i
index|]
operator|.
name|str
argument_list|,
name|reloc_map
index|[
name|i
index|]
operator|.
name|len
argument_list|)
operator|==
literal|0
condition|)
break|break;
name|input_line_pointer
operator|+=
name|reloc_map
index|[
name|i
index|]
operator|.
name|len
expr_stmt|;
return|return
name|reloc_map
index|[
name|i
index|]
operator|.
name|reloc
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|s_arm_elf_cons
parameter_list|(
name|nbytes
parameter_list|)
name|int
name|nbytes
decl_stmt|;
block|{
name|expressionS
name|exp
decl_stmt|;
ifdef|#
directive|ifdef
name|md_flush_pending_output
name|md_flush_pending_output
argument_list|()
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|is_it_end_of_statement
argument_list|()
condition|)
block|{
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
ifdef|#
directive|ifdef
name|md_cons_align
name|md_cons_align
argument_list|(
name|nbytes
argument_list|)
expr_stmt|;
endif|#
directive|endif
do|do
block|{
name|bfd_reloc_code_real_type
name|reloc
decl_stmt|;
name|expression
argument_list|(
operator|&
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
name|exp
operator|.
name|X_op
operator|==
name|O_symbol
operator|&&
operator|*
name|input_line_pointer
operator|==
literal|'('
operator|&&
operator|(
name|reloc
operator|=
name|arm_parse_reloc
argument_list|()
operator|)
operator|!=
name|BFD_RELOC_UNUSED
condition|)
block|{
name|reloc_howto_type
modifier|*
name|howto
init|=
name|bfd_reloc_type_lookup
argument_list|(
name|stdoutput
argument_list|,
name|reloc
argument_list|)
decl_stmt|;
name|int
name|size
init|=
name|bfd_get_reloc_size
argument_list|(
name|howto
argument_list|)
decl_stmt|;
if|if
condition|(
name|size
operator|>
name|nbytes
condition|)
name|as_bad
argument_list|(
literal|"%s relocations do not fit in %d bytes"
argument_list|,
name|howto
operator|->
name|name
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
else|else
block|{
specifier|register
name|char
modifier|*
name|p
init|=
name|frag_more
argument_list|(
operator|(
name|int
operator|)
name|nbytes
argument_list|)
decl_stmt|;
name|int
name|offset
init|=
name|nbytes
operator|-
name|size
decl_stmt|;
name|fix_new_exp
argument_list|(
name|frag_now
argument_list|,
name|p
operator|-
name|frag_now
operator|->
name|fr_literal
operator|+
name|offset
argument_list|,
name|size
argument_list|,
operator|&
name|exp
argument_list|,
literal|0
argument_list|,
name|reloc
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|emit_expr
argument_list|(
operator|&
name|exp
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|nbytes
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|*
name|input_line_pointer
operator|++
operator|==
literal|','
condition|)
do|;
name|input_line_pointer
operator|--
expr_stmt|;
comment|/* Put terminator back into stream.  */
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* OBJ_ELF */
end_comment

end_unit

