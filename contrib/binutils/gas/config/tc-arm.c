begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* tc-arm.c -- Assemble for the ARM    Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002    Free Software Foundation, Inc.    Contributed by Richard Earnshaw (rwe@pegasus.esprit.ec.org) 	Modified by David Taylor (dtaylor@armltd.co.uk) 	Cirrus coprocessor mods by Aldy Hernandez (aldyh@redhat.com)     This file is part of GAS, the GNU Assembler.     GAS is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     GAS is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with GAS; see the file COPYING.  If not, write to the Free    Software Foundation, 59 Temple Place - Suite 330, Boston, MA    02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_define
define|#
directive|define
name|NO_RELOC
value|0
end_define

begin_include
include|#
directive|include
file|"as.h"
end_include

begin_include
include|#
directive|include
file|"safe-ctype.h"
end_include

begin_comment
comment|/* Need TARGET_CPU.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"subsegs.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_include
include|#
directive|include
file|"symbols.h"
end_include

begin_include
include|#
directive|include
file|"listing.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|OBJ_ELF
end_ifdef

begin_include
include|#
directive|include
file|"elf/arm.h"
end_include

begin_include
include|#
directive|include
file|"dwarf2dbg.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* XXX Set this to 1 after the next binutils release */
end_comment

begin_define
define|#
directive|define
name|WARN_DEPRECATED
value|0
end_define

begin_comment
comment|/* The following bitmasks control CPU extensions:  */
end_comment

begin_define
define|#
directive|define
name|ARM_EXT_V1
value|0x00000001
end_define

begin_comment
comment|/* All processors (core set).  */
end_comment

begin_define
define|#
directive|define
name|ARM_EXT_V2
value|0x00000002
end_define

begin_comment
comment|/* Multiply instructions.  */
end_comment

begin_define
define|#
directive|define
name|ARM_EXT_V2S
value|0x00000004
end_define

begin_comment
comment|/* SWP instructions.       */
end_comment

begin_define
define|#
directive|define
name|ARM_EXT_V3
value|0x00000008
end_define

begin_comment
comment|/* MSR MRS.                */
end_comment

begin_define
define|#
directive|define
name|ARM_EXT_V3M
value|0x00000010
end_define

begin_comment
comment|/* Allow long multiplies.  */
end_comment

begin_define
define|#
directive|define
name|ARM_EXT_V4
value|0x00000020
end_define

begin_comment
comment|/* Allow half word loads.  */
end_comment

begin_define
define|#
directive|define
name|ARM_EXT_V4T
value|0x00000040
end_define

begin_comment
comment|/* Thumb v1.               */
end_comment

begin_define
define|#
directive|define
name|ARM_EXT_V5
value|0x00000080
end_define

begin_comment
comment|/* Allow CLZ, etc.         */
end_comment

begin_define
define|#
directive|define
name|ARM_EXT_V5T
value|0x00000100
end_define

begin_comment
comment|/* Thumb v2.               */
end_comment

begin_define
define|#
directive|define
name|ARM_EXT_V5ExP
value|0x00000200
end_define

begin_comment
comment|/* DSP core set.           */
end_comment

begin_define
define|#
directive|define
name|ARM_EXT_V5E
value|0x00000400
end_define

begin_comment
comment|/* DSP Double transfers.   */
end_comment

begin_define
define|#
directive|define
name|ARM_EXT_V5J
value|0x00000800
end_define

begin_comment
comment|/* Jazelle extension.	   */
end_comment

begin_comment
comment|/* Co-processor space extensions.  */
end_comment

begin_define
define|#
directive|define
name|ARM_CEXT_XSCALE
value|0x00800000
end_define

begin_comment
comment|/* Allow MIA etc.          */
end_comment

begin_define
define|#
directive|define
name|ARM_CEXT_MAVERICK
value|0x00400000
end_define

begin_comment
comment|/* Use Cirrus/DSP coprocessor.  */
end_comment

begin_comment
comment|/* Architectures are the sum of the base and extensions.  The ARM ARM (rev E)    defines the following: ARMv3, ARMv3M, ARMv4xM, ARMv4, ARMv4TxM, ARMv4T,    ARMv5xM, ARMv5, ARMv5TxM, ARMv5T, ARMv5TExP, ARMv5TE.  To these we add    three more to cover cores prior to ARM6.  Finally, there are cores which    implement further extensions in the co-processor space.  */
end_comment

begin_define
define|#
directive|define
name|ARM_ARCH_V1
value|ARM_EXT_V1
end_define

begin_define
define|#
directive|define
name|ARM_ARCH_V2
value|(ARM_ARCH_V1	| ARM_EXT_V2)
end_define

begin_define
define|#
directive|define
name|ARM_ARCH_V2S
value|(ARM_ARCH_V2	| ARM_EXT_V2S)
end_define

begin_define
define|#
directive|define
name|ARM_ARCH_V3
value|(ARM_ARCH_V2S	| ARM_EXT_V3)
end_define

begin_define
define|#
directive|define
name|ARM_ARCH_V3M
value|(ARM_ARCH_V3	| ARM_EXT_V3M)
end_define

begin_define
define|#
directive|define
name|ARM_ARCH_V4xM
value|(ARM_ARCH_V3	| ARM_EXT_V4)
end_define

begin_define
define|#
directive|define
name|ARM_ARCH_V4
value|(ARM_ARCH_V3M	| ARM_EXT_V4)
end_define

begin_define
define|#
directive|define
name|ARM_ARCH_V4TxM
value|(ARM_ARCH_V4xM	| ARM_EXT_V4T)
end_define

begin_define
define|#
directive|define
name|ARM_ARCH_V4T
value|(ARM_ARCH_V4	| ARM_EXT_V4T)
end_define

begin_define
define|#
directive|define
name|ARM_ARCH_V5xM
value|(ARM_ARCH_V4xM	| ARM_EXT_V5)
end_define

begin_define
define|#
directive|define
name|ARM_ARCH_V5
value|(ARM_ARCH_V4	| ARM_EXT_V5)
end_define

begin_define
define|#
directive|define
name|ARM_ARCH_V5TxM
value|(ARM_ARCH_V5xM	| ARM_EXT_V4T | ARM_EXT_V5T)
end_define

begin_define
define|#
directive|define
name|ARM_ARCH_V5T
value|(ARM_ARCH_V5	| ARM_EXT_V4T | ARM_EXT_V5T)
end_define

begin_define
define|#
directive|define
name|ARM_ARCH_V5TExP
value|(ARM_ARCH_V5T	| ARM_EXT_V5ExP)
end_define

begin_define
define|#
directive|define
name|ARM_ARCH_V5TE
value|(ARM_ARCH_V5TExP | ARM_EXT_V5E)
end_define

begin_define
define|#
directive|define
name|ARM_ARCH_V5TEJ
value|(ARM_ARCH_V5TE	| ARM_EXT_V5J)
end_define

begin_comment
comment|/* Processors with specific extensions in the co-processor space.  */
end_comment

begin_define
define|#
directive|define
name|ARM_ARCH_XSCALE
value|(ARM_ARCH_V5TE	| ARM_CEXT_XSCALE)
end_define

begin_comment
comment|/* Some useful combinations:  */
end_comment

begin_define
define|#
directive|define
name|ARM_ANY
value|0x0000ffff
end_define

begin_comment
comment|/* Any basic core.  */
end_comment

begin_define
define|#
directive|define
name|ARM_ALL
value|0x00ffffff
end_define

begin_comment
comment|/* Any core + co-processor */
end_comment

begin_define
define|#
directive|define
name|CPROC_ANY
value|0x00ff0000
end_define

begin_comment
comment|/* Any co-processor */
end_comment

begin_define
define|#
directive|define
name|FPU_ANY
value|0xff000000
end_define

begin_comment
comment|/* Note this is ~ARM_ALL.  */
end_comment

begin_define
define|#
directive|define
name|FPU_FPA_EXT_V1
value|0x80000000
end_define

begin_comment
comment|/* Base FPA instruction set.  */
end_comment

begin_define
define|#
directive|define
name|FPU_FPA_EXT_V2
value|0x40000000
end_define

begin_comment
comment|/* LFM/SFM.		      */
end_comment

begin_define
define|#
directive|define
name|FPU_VFP_EXT_NONE
value|0x20000000
end_define

begin_comment
comment|/* Use VFP word-ordering.     */
end_comment

begin_define
define|#
directive|define
name|FPU_VFP_EXT_V1xD
value|0x10000000
end_define

begin_comment
comment|/* Base VFP instruction set.  */
end_comment

begin_define
define|#
directive|define
name|FPU_VFP_EXT_V1
value|0x08000000
end_define

begin_comment
comment|/* Double-precision insns.    */
end_comment

begin_define
define|#
directive|define
name|FPU_VFP_EXT_V2
value|0x04000000
end_define

begin_comment
comment|/* ARM10E VFPr1.	      */
end_comment

begin_define
define|#
directive|define
name|FPU_NONE
value|0
end_define

begin_define
define|#
directive|define
name|FPU_ARCH_FPE
value|FPU_FPA_EXT_V1
end_define

begin_define
define|#
directive|define
name|FPU_ARCH_FPA
value|(FPU_ARCH_FPE | FPU_FPA_EXT_V2)
end_define

begin_define
define|#
directive|define
name|FPU_ARCH_VFP
value|FPU_VFP_EXT_NONE
end_define

begin_define
define|#
directive|define
name|FPU_ARCH_VFP_V1xD
value|(FPU_VFP_EXT_V1xD | FPU_VFP_EXT_NONE)
end_define

begin_define
define|#
directive|define
name|FPU_ARCH_VFP_V1
value|(FPU_ARCH_VFP_V1xD | FPU_VFP_EXT_V1)
end_define

begin_define
define|#
directive|define
name|FPU_ARCH_VFP_V2
value|(FPU_ARCH_VFP_V1 | FPU_VFP_EXT_V2)
end_define

begin_comment
comment|/* Types of processor to assemble for.  */
end_comment

begin_define
define|#
directive|define
name|ARM_1
value|ARM_ARCH_V1
end_define

begin_define
define|#
directive|define
name|ARM_2
value|ARM_ARCH_V2
end_define

begin_define
define|#
directive|define
name|ARM_3
value|ARM_ARCH_V2S
end_define

begin_define
define|#
directive|define
name|ARM_250
value|ARM_ARCH_V2S
end_define

begin_define
define|#
directive|define
name|ARM_6
value|ARM_ARCH_V3
end_define

begin_define
define|#
directive|define
name|ARM_7
value|ARM_ARCH_V3
end_define

begin_define
define|#
directive|define
name|ARM_8
value|ARM_ARCH_V4
end_define

begin_define
define|#
directive|define
name|ARM_9
value|ARM_ARCH_V4T
end_define

begin_define
define|#
directive|define
name|ARM_STRONG
value|ARM_ARCH_V4
end_define

begin_define
define|#
directive|define
name|ARM_CPU_MASK
value|0x0000000f
end_define

begin_comment
comment|/* XXX? */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|CPU_DEFAULT
end_ifndef

begin_if
if|#
directive|if
name|defined
name|__XSCALE__
end_if

begin_define
define|#
directive|define
name|CPU_DEFAULT
value|(ARM_ARCH_XSCALE)
end_define

begin_else
else|#
directive|else
end_else

begin_if
if|#
directive|if
name|defined
name|__thumb__
end_if

begin_define
define|#
directive|define
name|CPU_DEFAULT
value|(ARM_ARCH_V5T)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CPU_DEFAULT
value|ARM_ANY
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* For backwards compatibility we default to the FPA.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|FPU_DEFAULT
end_ifndef

begin_define
define|#
directive|define
name|FPU_DEFAULT
value|FPU_ARCH_FPA
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|streq
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|(strcmp (a, b) == 0)
end_define

begin_define
define|#
directive|define
name|skip_whitespace
parameter_list|(
name|str
parameter_list|)
value|while (*(str) == ' ') ++(str)
end_define

begin_decl_stmt
specifier|static
name|unsigned
name|long
name|cpu_variant
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|target_oabi
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Flags stored in private area of BFD structure.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|uses_apcs_26
init|=
name|false
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|atpcs
init|=
name|false
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|support_interwork
init|=
name|false
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|uses_apcs_float
init|=
name|false
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|pic_code
init|=
name|false
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Variables that we set while parsing command-line options.  Once all    options have been read we re-process these values to set the real    assembly flags.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|legacy_cpu
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|legacy_fpu
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|mcpu_cpu_opt
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|mcpu_fpu_opt
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|march_cpu_opt
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|march_fpu_opt
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|mfpu_opt
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This array holds the chars that always start a comment.  If the    pre-processor is disabled, these aren't very useful.  */
end_comment

begin_decl_stmt
specifier|const
name|char
name|comment_chars
index|[]
init|=
literal|"@"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This array holds the chars that only start a comment at the beginning of    a line.  If the line seems to have the form '# 123 filename'    .line and .file directives will appear in the pre-processed output.  */
end_comment

begin_comment
comment|/* Note that input_file.c hand checks for '#' at the beginning of the    first line of the input file.  This is because the compiler outputs    #NO_APP at the beginning of its output.  */
end_comment

begin_comment
comment|/* Also note that comments like this one will always work.  */
end_comment

begin_decl_stmt
specifier|const
name|char
name|line_comment_chars
index|[]
init|=
literal|"#"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
name|line_separator_chars
index|[]
init|=
literal|";"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Chars that can be used to separate mant    from exp in floating point numbers.  */
end_comment

begin_decl_stmt
specifier|const
name|char
name|EXP_CHARS
index|[]
init|=
literal|"eE"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Chars that mean this number is a floating point constant.  */
end_comment

begin_comment
comment|/* As in 0f12.456  */
end_comment

begin_comment
comment|/* or    0d1.2345e12  */
end_comment

begin_decl_stmt
specifier|const
name|char
name|FLT_CHARS
index|[]
init|=
literal|"rRsSfFdDxXeEpP"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Prefix characters that indicate the start of an immediate    value.  */
end_comment

begin_define
define|#
directive|define
name|is_immediate_prefix
parameter_list|(
name|C
parameter_list|)
value|((C) == '#' || (C) == '$')
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|OBJ_ELF
end_ifdef

begin_comment
comment|/* Pre-defined "_GLOBAL_OFFSET_TABLE_"  */
end_comment

begin_decl_stmt
name|symbolS
modifier|*
name|GOT_symbol
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Size of relocation record.  */
end_comment

begin_decl_stmt
specifier|const
name|int
name|md_reloc_size
init|=
literal|8
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 0: assemble for ARM,    1: assemble for Thumb,    2: assemble for Thumb even though target CPU does not support thumb       instructions.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|thumb_mode
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
struct|struct
name|arm_fix
block|{
name|int
name|thumb_mode
decl_stmt|;
block|}
name|arm_fix_data
typedef|;
end_typedef

begin_struct
struct|struct
name|arm_it
block|{
specifier|const
name|char
modifier|*
name|error
decl_stmt|;
name|unsigned
name|long
name|instruction
decl_stmt|;
name|int
name|size
decl_stmt|;
struct|struct
block|{
name|bfd_reloc_code_real_type
name|type
decl_stmt|;
name|expressionS
name|exp
decl_stmt|;
name|int
name|pc_rel
decl_stmt|;
block|}
name|reloc
struct|;
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|arm_it
name|inst
decl_stmt|;
end_decl_stmt

begin_enum
enum|enum
name|asm_shift_index
block|{
name|SHIFT_LSL
init|=
literal|0
block|,
name|SHIFT_LSR
block|,
name|SHIFT_ASR
block|,
name|SHIFT_ROR
block|,
name|SHIFT_RRX
block|}
enum|;
end_enum

begin_struct
struct|struct
name|asm_shift_properties
block|{
name|enum
name|asm_shift_index
name|index
decl_stmt|;
name|unsigned
name|long
name|bit_field
decl_stmt|;
name|unsigned
name|int
name|allows_0
range|:
literal|1
decl_stmt|;
name|unsigned
name|int
name|allows_32
range|:
literal|1
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|asm_shift_properties
name|shift_properties
index|[]
init|=
block|{
block|{
name|SHIFT_LSL
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|}
block|,
block|{
name|SHIFT_LSR
block|,
literal|0x20
block|,
literal|0
block|,
literal|1
block|}
block|,
block|{
name|SHIFT_ASR
block|,
literal|0x40
block|,
literal|0
block|,
literal|1
block|}
block|,
block|{
name|SHIFT_ROR
block|,
literal|0x60
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|SHIFT_RRX
block|,
literal|0x60
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|asm_shift_name
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
specifier|const
name|struct
name|asm_shift_properties
modifier|*
name|properties
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|asm_shift_name
name|shift_names
index|[]
init|=
block|{
block|{
literal|"asl"
block|,
name|shift_properties
operator|+
name|SHIFT_LSL
block|}
block|,
block|{
literal|"lsl"
block|,
name|shift_properties
operator|+
name|SHIFT_LSL
block|}
block|,
block|{
literal|"lsr"
block|,
name|shift_properties
operator|+
name|SHIFT_LSR
block|}
block|,
block|{
literal|"asr"
block|,
name|shift_properties
operator|+
name|SHIFT_ASR
block|}
block|,
block|{
literal|"ror"
block|,
name|shift_properties
operator|+
name|SHIFT_ROR
block|}
block|,
block|{
literal|"rrx"
block|,
name|shift_properties
operator|+
name|SHIFT_RRX
block|}
block|,
block|{
literal|"ASL"
block|,
name|shift_properties
operator|+
name|SHIFT_LSL
block|}
block|,
block|{
literal|"LSL"
block|,
name|shift_properties
operator|+
name|SHIFT_LSL
block|}
block|,
block|{
literal|"LSR"
block|,
name|shift_properties
operator|+
name|SHIFT_LSR
block|}
block|,
block|{
literal|"ASR"
block|,
name|shift_properties
operator|+
name|SHIFT_ASR
block|}
block|,
block|{
literal|"ROR"
block|,
name|shift_properties
operator|+
name|SHIFT_ROR
block|}
block|,
block|{
literal|"RRX"
block|,
name|shift_properties
operator|+
name|SHIFT_RRX
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|NO_SHIFT_RESTRICT
value|1
end_define

begin_define
define|#
directive|define
name|SHIFT_RESTRICT
value|0
end_define

begin_define
define|#
directive|define
name|NUM_FLOAT_VALS
value|8
end_define

begin_decl_stmt
specifier|const
name|char
modifier|*
name|fp_const
index|[]
init|=
block|{
literal|"0.0"
block|,
literal|"1.0"
block|,
literal|"2.0"
block|,
literal|"3.0"
block|,
literal|"4.0"
block|,
literal|"5.0"
block|,
literal|"0.5"
block|,
literal|"10.0"
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of littlenums required to hold an extended precision number.  */
end_comment

begin_define
define|#
directive|define
name|MAX_LITTLENUMS
value|6
end_define

begin_decl_stmt
name|LITTLENUM_TYPE
name|fp_values
index|[
name|NUM_FLOAT_VALS
index|]
index|[
name|MAX_LITTLENUMS
index|]
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|FAIL
value|(-1)
end_define

begin_define
define|#
directive|define
name|SUCCESS
value|(0)
end_define

begin_comment
comment|/* Whether a Co-processor load/store operation accepts write-back forms.  */
end_comment

begin_define
define|#
directive|define
name|CP_WB_OK
value|1
end_define

begin_define
define|#
directive|define
name|CP_NO_WB
value|0
end_define

begin_define
define|#
directive|define
name|SUFF_S
value|1
end_define

begin_define
define|#
directive|define
name|SUFF_D
value|2
end_define

begin_define
define|#
directive|define
name|SUFF_E
value|3
end_define

begin_define
define|#
directive|define
name|SUFF_P
value|4
end_define

begin_define
define|#
directive|define
name|CP_T_X
value|0x00008000
end_define

begin_define
define|#
directive|define
name|CP_T_Y
value|0x00400000
end_define

begin_define
define|#
directive|define
name|CP_T_Pre
value|0x01000000
end_define

begin_define
define|#
directive|define
name|CP_T_UD
value|0x00800000
end_define

begin_define
define|#
directive|define
name|CP_T_WB
value|0x00200000
end_define

begin_define
define|#
directive|define
name|CONDS_BIT
value|0x00100000
end_define

begin_define
define|#
directive|define
name|LOAD_BIT
value|0x00100000
end_define

begin_define
define|#
directive|define
name|DOUBLE_LOAD_FLAG
value|0x00000001
end_define

begin_struct
struct|struct
name|asm_cond
block|{
specifier|const
name|char
modifier|*
name|template
decl_stmt|;
name|unsigned
name|long
name|value
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|COND_ALWAYS
value|0xe0000000
end_define

begin_define
define|#
directive|define
name|COND_MASK
value|0xf0000000
end_define

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|asm_cond
name|conds
index|[]
init|=
block|{
block|{
literal|"eq"
block|,
literal|0x00000000
block|}
block|,
block|{
literal|"ne"
block|,
literal|0x10000000
block|}
block|,
block|{
literal|"cs"
block|,
literal|0x20000000
block|}
block|,
block|{
literal|"hs"
block|,
literal|0x20000000
block|}
block|,
block|{
literal|"cc"
block|,
literal|0x30000000
block|}
block|,
block|{
literal|"ul"
block|,
literal|0x30000000
block|}
block|,
block|{
literal|"lo"
block|,
literal|0x30000000
block|}
block|,
block|{
literal|"mi"
block|,
literal|0x40000000
block|}
block|,
block|{
literal|"pl"
block|,
literal|0x50000000
block|}
block|,
block|{
literal|"vs"
block|,
literal|0x60000000
block|}
block|,
block|{
literal|"vc"
block|,
literal|0x70000000
block|}
block|,
block|{
literal|"hi"
block|,
literal|0x80000000
block|}
block|,
block|{
literal|"ls"
block|,
literal|0x90000000
block|}
block|,
block|{
literal|"ge"
block|,
literal|0xa0000000
block|}
block|,
block|{
literal|"lt"
block|,
literal|0xb0000000
block|}
block|,
block|{
literal|"gt"
block|,
literal|0xc0000000
block|}
block|,
block|{
literal|"le"
block|,
literal|0xd0000000
block|}
block|,
block|{
literal|"al"
block|,
literal|0xe0000000
block|}
block|,
block|{
literal|"nv"
block|,
literal|0xf0000000
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|asm_psr
block|{
specifier|const
name|char
modifier|*
name|template
decl_stmt|;
name|boolean
name|cpsr
decl_stmt|;
name|unsigned
name|long
name|field
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* The bit that distnguishes CPSR and SPSR.  */
end_comment

begin_define
define|#
directive|define
name|SPSR_BIT
value|(1<< 22)
end_define

begin_comment
comment|/* How many bits to shift the PSR_xxx bits up by.  */
end_comment

begin_define
define|#
directive|define
name|PSR_SHIFT
value|16
end_define

begin_define
define|#
directive|define
name|PSR_c
value|(1<< 0)
end_define

begin_define
define|#
directive|define
name|PSR_x
value|(1<< 1)
end_define

begin_define
define|#
directive|define
name|PSR_s
value|(1<< 2)
end_define

begin_define
define|#
directive|define
name|PSR_f
value|(1<< 3)
end_define

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|asm_psr
name|psrs
index|[]
init|=
block|{
block|{
literal|"CPSR"
block|,
name|true
block|,
name|PSR_c
operator||
name|PSR_f
block|}
block|,
block|{
literal|"CPSR_all"
block|,
name|true
block|,
name|PSR_c
operator||
name|PSR_f
block|}
block|,
block|{
literal|"SPSR"
block|,
name|false
block|,
name|PSR_c
operator||
name|PSR_f
block|}
block|,
block|{
literal|"SPSR_all"
block|,
name|false
block|,
name|PSR_c
operator||
name|PSR_f
block|}
block|,
block|{
literal|"CPSR_flg"
block|,
name|true
block|,
name|PSR_f
block|}
block|,
block|{
literal|"CPSR_f"
block|,
name|true
block|,
name|PSR_f
block|}
block|,
block|{
literal|"SPSR_flg"
block|,
name|false
block|,
name|PSR_f
block|}
block|,
block|{
literal|"SPSR_f"
block|,
name|false
block|,
name|PSR_f
block|}
block|,
block|{
literal|"CPSR_c"
block|,
name|true
block|,
name|PSR_c
block|}
block|,
block|{
literal|"CPSR_ctl"
block|,
name|true
block|,
name|PSR_c
block|}
block|,
block|{
literal|"SPSR_c"
block|,
name|false
block|,
name|PSR_c
block|}
block|,
block|{
literal|"SPSR_ctl"
block|,
name|false
block|,
name|PSR_c
block|}
block|,
block|{
literal|"CPSR_x"
block|,
name|true
block|,
name|PSR_x
block|}
block|,
block|{
literal|"CPSR_s"
block|,
name|true
block|,
name|PSR_s
block|}
block|,
block|{
literal|"SPSR_x"
block|,
name|false
block|,
name|PSR_x
block|}
block|,
block|{
literal|"SPSR_s"
block|,
name|false
block|,
name|PSR_s
block|}
block|,
comment|/* Combinations of flags.  */
block|{
literal|"CPSR_fs"
block|,
name|true
block|,
name|PSR_f
operator||
name|PSR_s
block|}
block|,
block|{
literal|"CPSR_fx"
block|,
name|true
block|,
name|PSR_f
operator||
name|PSR_x
block|}
block|,
block|{
literal|"CPSR_fc"
block|,
name|true
block|,
name|PSR_f
operator||
name|PSR_c
block|}
block|,
block|{
literal|"CPSR_sf"
block|,
name|true
block|,
name|PSR_s
operator||
name|PSR_f
block|}
block|,
block|{
literal|"CPSR_sx"
block|,
name|true
block|,
name|PSR_s
operator||
name|PSR_x
block|}
block|,
block|{
literal|"CPSR_sc"
block|,
name|true
block|,
name|PSR_s
operator||
name|PSR_c
block|}
block|,
block|{
literal|"CPSR_xf"
block|,
name|true
block|,
name|PSR_x
operator||
name|PSR_f
block|}
block|,
block|{
literal|"CPSR_xs"
block|,
name|true
block|,
name|PSR_x
operator||
name|PSR_s
block|}
block|,
block|{
literal|"CPSR_xc"
block|,
name|true
block|,
name|PSR_x
operator||
name|PSR_c
block|}
block|,
block|{
literal|"CPSR_cf"
block|,
name|true
block|,
name|PSR_c
operator||
name|PSR_f
block|}
block|,
block|{
literal|"CPSR_cs"
block|,
name|true
block|,
name|PSR_c
operator||
name|PSR_s
block|}
block|,
block|{
literal|"CPSR_cx"
block|,
name|true
block|,
name|PSR_c
operator||
name|PSR_x
block|}
block|,
block|{
literal|"CPSR_fsx"
block|,
name|true
block|,
name|PSR_f
operator||
name|PSR_s
operator||
name|PSR_x
block|}
block|,
block|{
literal|"CPSR_fsc"
block|,
name|true
block|,
name|PSR_f
operator||
name|PSR_s
operator||
name|PSR_c
block|}
block|,
block|{
literal|"CPSR_fxs"
block|,
name|true
block|,
name|PSR_f
operator||
name|PSR_x
operator||
name|PSR_s
block|}
block|,
block|{
literal|"CPSR_fxc"
block|,
name|true
block|,
name|PSR_f
operator||
name|PSR_x
operator||
name|PSR_c
block|}
block|,
block|{
literal|"CPSR_fcs"
block|,
name|true
block|,
name|PSR_f
operator||
name|PSR_c
operator||
name|PSR_s
block|}
block|,
block|{
literal|"CPSR_fcx"
block|,
name|true
block|,
name|PSR_f
operator||
name|PSR_c
operator||
name|PSR_x
block|}
block|,
block|{
literal|"CPSR_sfx"
block|,
name|true
block|,
name|PSR_s
operator||
name|PSR_f
operator||
name|PSR_x
block|}
block|,
block|{
literal|"CPSR_sfc"
block|,
name|true
block|,
name|PSR_s
operator||
name|PSR_f
operator||
name|PSR_c
block|}
block|,
block|{
literal|"CPSR_sxf"
block|,
name|true
block|,
name|PSR_s
operator||
name|PSR_x
operator||
name|PSR_f
block|}
block|,
block|{
literal|"CPSR_sxc"
block|,
name|true
block|,
name|PSR_s
operator||
name|PSR_x
operator||
name|PSR_c
block|}
block|,
block|{
literal|"CPSR_scf"
block|,
name|true
block|,
name|PSR_s
operator||
name|PSR_c
operator||
name|PSR_f
block|}
block|,
block|{
literal|"CPSR_scx"
block|,
name|true
block|,
name|PSR_s
operator||
name|PSR_c
operator||
name|PSR_x
block|}
block|,
block|{
literal|"CPSR_xfs"
block|,
name|true
block|,
name|PSR_x
operator||
name|PSR_f
operator||
name|PSR_s
block|}
block|,
block|{
literal|"CPSR_xfc"
block|,
name|true
block|,
name|PSR_x
operator||
name|PSR_f
operator||
name|PSR_c
block|}
block|,
block|{
literal|"CPSR_xsf"
block|,
name|true
block|,
name|PSR_x
operator||
name|PSR_s
operator||
name|PSR_f
block|}
block|,
block|{
literal|"CPSR_xsc"
block|,
name|true
block|,
name|PSR_x
operator||
name|PSR_s
operator||
name|PSR_c
block|}
block|,
block|{
literal|"CPSR_xcf"
block|,
name|true
block|,
name|PSR_x
operator||
name|PSR_c
operator||
name|PSR_f
block|}
block|,
block|{
literal|"CPSR_xcs"
block|,
name|true
block|,
name|PSR_x
operator||
name|PSR_c
operator||
name|PSR_s
block|}
block|,
block|{
literal|"CPSR_cfs"
block|,
name|true
block|,
name|PSR_c
operator||
name|PSR_f
operator||
name|PSR_s
block|}
block|,
block|{
literal|"CPSR_cfx"
block|,
name|true
block|,
name|PSR_c
operator||
name|PSR_f
operator||
name|PSR_x
block|}
block|,
block|{
literal|"CPSR_csf"
block|,
name|true
block|,
name|PSR_c
operator||
name|PSR_s
operator||
name|PSR_f
block|}
block|,
block|{
literal|"CPSR_csx"
block|,
name|true
block|,
name|PSR_c
operator||
name|PSR_s
operator||
name|PSR_x
block|}
block|,
block|{
literal|"CPSR_cxf"
block|,
name|true
block|,
name|PSR_c
operator||
name|PSR_x
operator||
name|PSR_f
block|}
block|,
block|{
literal|"CPSR_cxs"
block|,
name|true
block|,
name|PSR_c
operator||
name|PSR_x
operator||
name|PSR_s
block|}
block|,
block|{
literal|"CPSR_fsxc"
block|,
name|true
block|,
name|PSR_f
operator||
name|PSR_s
operator||
name|PSR_x
operator||
name|PSR_c
block|}
block|,
block|{
literal|"CPSR_fscx"
block|,
name|true
block|,
name|PSR_f
operator||
name|PSR_s
operator||
name|PSR_c
operator||
name|PSR_x
block|}
block|,
block|{
literal|"CPSR_fxsc"
block|,
name|true
block|,
name|PSR_f
operator||
name|PSR_x
operator||
name|PSR_s
operator||
name|PSR_c
block|}
block|,
block|{
literal|"CPSR_fxcs"
block|,
name|true
block|,
name|PSR_f
operator||
name|PSR_x
operator||
name|PSR_c
operator||
name|PSR_s
block|}
block|,
block|{
literal|"CPSR_fcsx"
block|,
name|true
block|,
name|PSR_f
operator||
name|PSR_c
operator||
name|PSR_s
operator||
name|PSR_x
block|}
block|,
block|{
literal|"CPSR_fcxs"
block|,
name|true
block|,
name|PSR_f
operator||
name|PSR_c
operator||
name|PSR_x
operator||
name|PSR_s
block|}
block|,
block|{
literal|"CPSR_sfxc"
block|,
name|true
block|,
name|PSR_s
operator||
name|PSR_f
operator||
name|PSR_x
operator||
name|PSR_c
block|}
block|,
block|{
literal|"CPSR_sfcx"
block|,
name|true
block|,
name|PSR_s
operator||
name|PSR_f
operator||
name|PSR_c
operator||
name|PSR_x
block|}
block|,
block|{
literal|"CPSR_sxfc"
block|,
name|true
block|,
name|PSR_s
operator||
name|PSR_x
operator||
name|PSR_f
operator||
name|PSR_c
block|}
block|,
block|{
literal|"CPSR_sxcf"
block|,
name|true
block|,
name|PSR_s
operator||
name|PSR_x
operator||
name|PSR_c
operator||
name|PSR_f
block|}
block|,
block|{
literal|"CPSR_scfx"
block|,
name|true
block|,
name|PSR_s
operator||
name|PSR_c
operator||
name|PSR_f
operator||
name|PSR_x
block|}
block|,
block|{
literal|"CPSR_scxf"
block|,
name|true
block|,
name|PSR_s
operator||
name|PSR_c
operator||
name|PSR_x
operator||
name|PSR_f
block|}
block|,
block|{
literal|"CPSR_xfsc"
block|,
name|true
block|,
name|PSR_x
operator||
name|PSR_f
operator||
name|PSR_s
operator||
name|PSR_c
block|}
block|,
block|{
literal|"CPSR_xfcs"
block|,
name|true
block|,
name|PSR_x
operator||
name|PSR_f
operator||
name|PSR_c
operator||
name|PSR_s
block|}
block|,
block|{
literal|"CPSR_xsfc"
block|,
name|true
block|,
name|PSR_x
operator||
name|PSR_s
operator||
name|PSR_f
operator||
name|PSR_c
block|}
block|,
block|{
literal|"CPSR_xscf"
block|,
name|true
block|,
name|PSR_x
operator||
name|PSR_s
operator||
name|PSR_c
operator||
name|PSR_f
block|}
block|,
block|{
literal|"CPSR_xcfs"
block|,
name|true
block|,
name|PSR_x
operator||
name|PSR_c
operator||
name|PSR_f
operator||
name|PSR_s
block|}
block|,
block|{
literal|"CPSR_xcsf"
block|,
name|true
block|,
name|PSR_x
operator||
name|PSR_c
operator||
name|PSR_s
operator||
name|PSR_f
block|}
block|,
block|{
literal|"CPSR_cfsx"
block|,
name|true
block|,
name|PSR_c
operator||
name|PSR_f
operator||
name|PSR_s
operator||
name|PSR_x
block|}
block|,
block|{
literal|"CPSR_cfxs"
block|,
name|true
block|,
name|PSR_c
operator||
name|PSR_f
operator||
name|PSR_x
operator||
name|PSR_s
block|}
block|,
block|{
literal|"CPSR_csfx"
block|,
name|true
block|,
name|PSR_c
operator||
name|PSR_s
operator||
name|PSR_f
operator||
name|PSR_x
block|}
block|,
block|{
literal|"CPSR_csxf"
block|,
name|true
block|,
name|PSR_c
operator||
name|PSR_s
operator||
name|PSR_x
operator||
name|PSR_f
block|}
block|,
block|{
literal|"CPSR_cxfs"
block|,
name|true
block|,
name|PSR_c
operator||
name|PSR_x
operator||
name|PSR_f
operator||
name|PSR_s
block|}
block|,
block|{
literal|"CPSR_cxsf"
block|,
name|true
block|,
name|PSR_c
operator||
name|PSR_x
operator||
name|PSR_s
operator||
name|PSR_f
block|}
block|,
block|{
literal|"SPSR_fs"
block|,
name|false
block|,
name|PSR_f
operator||
name|PSR_s
block|}
block|,
block|{
literal|"SPSR_fx"
block|,
name|false
block|,
name|PSR_f
operator||
name|PSR_x
block|}
block|,
block|{
literal|"SPSR_fc"
block|,
name|false
block|,
name|PSR_f
operator||
name|PSR_c
block|}
block|,
block|{
literal|"SPSR_sf"
block|,
name|false
block|,
name|PSR_s
operator||
name|PSR_f
block|}
block|,
block|{
literal|"SPSR_sx"
block|,
name|false
block|,
name|PSR_s
operator||
name|PSR_x
block|}
block|,
block|{
literal|"SPSR_sc"
block|,
name|false
block|,
name|PSR_s
operator||
name|PSR_c
block|}
block|,
block|{
literal|"SPSR_xf"
block|,
name|false
block|,
name|PSR_x
operator||
name|PSR_f
block|}
block|,
block|{
literal|"SPSR_xs"
block|,
name|false
block|,
name|PSR_x
operator||
name|PSR_s
block|}
block|,
block|{
literal|"SPSR_xc"
block|,
name|false
block|,
name|PSR_x
operator||
name|PSR_c
block|}
block|,
block|{
literal|"SPSR_cf"
block|,
name|false
block|,
name|PSR_c
operator||
name|PSR_f
block|}
block|,
block|{
literal|"SPSR_cs"
block|,
name|false
block|,
name|PSR_c
operator||
name|PSR_s
block|}
block|,
block|{
literal|"SPSR_cx"
block|,
name|false
block|,
name|PSR_c
operator||
name|PSR_x
block|}
block|,
block|{
literal|"SPSR_fsx"
block|,
name|false
block|,
name|PSR_f
operator||
name|PSR_s
operator||
name|PSR_x
block|}
block|,
block|{
literal|"SPSR_fsc"
block|,
name|false
block|,
name|PSR_f
operator||
name|PSR_s
operator||
name|PSR_c
block|}
block|,
block|{
literal|"SPSR_fxs"
block|,
name|false
block|,
name|PSR_f
operator||
name|PSR_x
operator||
name|PSR_s
block|}
block|,
block|{
literal|"SPSR_fxc"
block|,
name|false
block|,
name|PSR_f
operator||
name|PSR_x
operator||
name|PSR_c
block|}
block|,
block|{
literal|"SPSR_fcs"
block|,
name|false
block|,
name|PSR_f
operator||
name|PSR_c
operator||
name|PSR_s
block|}
block|,
block|{
literal|"SPSR_fcx"
block|,
name|false
block|,
name|PSR_f
operator||
name|PSR_c
operator||
name|PSR_x
block|}
block|,
block|{
literal|"SPSR_sfx"
block|,
name|false
block|,
name|PSR_s
operator||
name|PSR_f
operator||
name|PSR_x
block|}
block|,
block|{
literal|"SPSR_sfc"
block|,
name|false
block|,
name|PSR_s
operator||
name|PSR_f
operator||
name|PSR_c
block|}
block|,
block|{
literal|"SPSR_sxf"
block|,
name|false
block|,
name|PSR_s
operator||
name|PSR_x
operator||
name|PSR_f
block|}
block|,
block|{
literal|"SPSR_sxc"
block|,
name|false
block|,
name|PSR_s
operator||
name|PSR_x
operator||
name|PSR_c
block|}
block|,
block|{
literal|"SPSR_scf"
block|,
name|false
block|,
name|PSR_s
operator||
name|PSR_c
operator||
name|PSR_f
block|}
block|,
block|{
literal|"SPSR_scx"
block|,
name|false
block|,
name|PSR_s
operator||
name|PSR_c
operator||
name|PSR_x
block|}
block|,
block|{
literal|"SPSR_xfs"
block|,
name|false
block|,
name|PSR_x
operator||
name|PSR_f
operator||
name|PSR_s
block|}
block|,
block|{
literal|"SPSR_xfc"
block|,
name|false
block|,
name|PSR_x
operator||
name|PSR_f
operator||
name|PSR_c
block|}
block|,
block|{
literal|"SPSR_xsf"
block|,
name|false
block|,
name|PSR_x
operator||
name|PSR_s
operator||
name|PSR_f
block|}
block|,
block|{
literal|"SPSR_xsc"
block|,
name|false
block|,
name|PSR_x
operator||
name|PSR_s
operator||
name|PSR_c
block|}
block|,
block|{
literal|"SPSR_xcf"
block|,
name|false
block|,
name|PSR_x
operator||
name|PSR_c
operator||
name|PSR_f
block|}
block|,
block|{
literal|"SPSR_xcs"
block|,
name|false
block|,
name|PSR_x
operator||
name|PSR_c
operator||
name|PSR_s
block|}
block|,
block|{
literal|"SPSR_cfs"
block|,
name|false
block|,
name|PSR_c
operator||
name|PSR_f
operator||
name|PSR_s
block|}
block|,
block|{
literal|"SPSR_cfx"
block|,
name|false
block|,
name|PSR_c
operator||
name|PSR_f
operator||
name|PSR_x
block|}
block|,
block|{
literal|"SPSR_csf"
block|,
name|false
block|,
name|PSR_c
operator||
name|PSR_s
operator||
name|PSR_f
block|}
block|,
block|{
literal|"SPSR_csx"
block|,
name|false
block|,
name|PSR_c
operator||
name|PSR_s
operator||
name|PSR_x
block|}
block|,
block|{
literal|"SPSR_cxf"
block|,
name|false
block|,
name|PSR_c
operator||
name|PSR_x
operator||
name|PSR_f
block|}
block|,
block|{
literal|"SPSR_cxs"
block|,
name|false
block|,
name|PSR_c
operator||
name|PSR_x
operator||
name|PSR_s
block|}
block|,
block|{
literal|"SPSR_fsxc"
block|,
name|false
block|,
name|PSR_f
operator||
name|PSR_s
operator||
name|PSR_x
operator||
name|PSR_c
block|}
block|,
block|{
literal|"SPSR_fscx"
block|,
name|false
block|,
name|PSR_f
operator||
name|PSR_s
operator||
name|PSR_c
operator||
name|PSR_x
block|}
block|,
block|{
literal|"SPSR_fxsc"
block|,
name|false
block|,
name|PSR_f
operator||
name|PSR_x
operator||
name|PSR_s
operator||
name|PSR_c
block|}
block|,
block|{
literal|"SPSR_fxcs"
block|,
name|false
block|,
name|PSR_f
operator||
name|PSR_x
operator||
name|PSR_c
operator||
name|PSR_s
block|}
block|,
block|{
literal|"SPSR_fcsx"
block|,
name|false
block|,
name|PSR_f
operator||
name|PSR_c
operator||
name|PSR_s
operator||
name|PSR_x
block|}
block|,
block|{
literal|"SPSR_fcxs"
block|,
name|false
block|,
name|PSR_f
operator||
name|PSR_c
operator||
name|PSR_x
operator||
name|PSR_s
block|}
block|,
block|{
literal|"SPSR_sfxc"
block|,
name|false
block|,
name|PSR_s
operator||
name|PSR_f
operator||
name|PSR_x
operator||
name|PSR_c
block|}
block|,
block|{
literal|"SPSR_sfcx"
block|,
name|false
block|,
name|PSR_s
operator||
name|PSR_f
operator||
name|PSR_c
operator||
name|PSR_x
block|}
block|,
block|{
literal|"SPSR_sxfc"
block|,
name|false
block|,
name|PSR_s
operator||
name|PSR_x
operator||
name|PSR_f
operator||
name|PSR_c
block|}
block|,
block|{
literal|"SPSR_sxcf"
block|,
name|false
block|,
name|PSR_s
operator||
name|PSR_x
operator||
name|PSR_c
operator||
name|PSR_f
block|}
block|,
block|{
literal|"SPSR_scfx"
block|,
name|false
block|,
name|PSR_s
operator||
name|PSR_c
operator||
name|PSR_f
operator||
name|PSR_x
block|}
block|,
block|{
literal|"SPSR_scxf"
block|,
name|false
block|,
name|PSR_s
operator||
name|PSR_c
operator||
name|PSR_x
operator||
name|PSR_f
block|}
block|,
block|{
literal|"SPSR_xfsc"
block|,
name|false
block|,
name|PSR_x
operator||
name|PSR_f
operator||
name|PSR_s
operator||
name|PSR_c
block|}
block|,
block|{
literal|"SPSR_xfcs"
block|,
name|false
block|,
name|PSR_x
operator||
name|PSR_f
operator||
name|PSR_c
operator||
name|PSR_s
block|}
block|,
block|{
literal|"SPSR_xsfc"
block|,
name|false
block|,
name|PSR_x
operator||
name|PSR_s
operator||
name|PSR_f
operator||
name|PSR_c
block|}
block|,
block|{
literal|"SPSR_xscf"
block|,
name|false
block|,
name|PSR_x
operator||
name|PSR_s
operator||
name|PSR_c
operator||
name|PSR_f
block|}
block|,
block|{
literal|"SPSR_xcfs"
block|,
name|false
block|,
name|PSR_x
operator||
name|PSR_c
operator||
name|PSR_f
operator||
name|PSR_s
block|}
block|,
block|{
literal|"SPSR_xcsf"
block|,
name|false
block|,
name|PSR_x
operator||
name|PSR_c
operator||
name|PSR_s
operator||
name|PSR_f
block|}
block|,
block|{
literal|"SPSR_cfsx"
block|,
name|false
block|,
name|PSR_c
operator||
name|PSR_f
operator||
name|PSR_s
operator||
name|PSR_x
block|}
block|,
block|{
literal|"SPSR_cfxs"
block|,
name|false
block|,
name|PSR_c
operator||
name|PSR_f
operator||
name|PSR_x
operator||
name|PSR_s
block|}
block|,
block|{
literal|"SPSR_csfx"
block|,
name|false
block|,
name|PSR_c
operator||
name|PSR_s
operator||
name|PSR_f
operator||
name|PSR_x
block|}
block|,
block|{
literal|"SPSR_csxf"
block|,
name|false
block|,
name|PSR_c
operator||
name|PSR_s
operator||
name|PSR_x
operator||
name|PSR_f
block|}
block|,
block|{
literal|"SPSR_cxfs"
block|,
name|false
block|,
name|PSR_c
operator||
name|PSR_x
operator||
name|PSR_f
operator||
name|PSR_s
block|}
block|,
block|{
literal|"SPSR_cxsf"
block|,
name|false
block|,
name|PSR_c
operator||
name|PSR_x
operator||
name|PSR_s
operator||
name|PSR_f
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_enum
enum|enum
name|vfp_dp_reg_pos
block|{
name|VFP_REG_Dd
block|,
name|VFP_REG_Dm
block|,
name|VFP_REG_Dn
block|}
enum|;
end_enum

begin_enum
enum|enum
name|vfp_sp_reg_pos
block|{
name|VFP_REG_Sd
block|,
name|VFP_REG_Sm
block|,
name|VFP_REG_Sn
block|}
enum|;
end_enum

begin_enum
enum|enum
name|vfp_ldstm_type
block|{
name|VFP_LDSTMIA
block|,
name|VFP_LDSTMDB
block|,
name|VFP_LDSTMIAX
block|,
name|VFP_LDSTMDBX
block|}
enum|;
end_enum

begin_comment
comment|/* VFP system registers.  */
end_comment

begin_struct
struct|struct
name|vfp_reg
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|unsigned
name|long
name|regno
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|vfp_reg
name|vfp_regs
index|[]
init|=
block|{
block|{
literal|"fpsid"
block|,
literal|0x00000000
block|}
block|,
block|{
literal|"FPSID"
block|,
literal|0x00000000
block|}
block|,
block|{
literal|"fpscr"
block|,
literal|0x00010000
block|}
block|,
block|{
literal|"FPSCR"
block|,
literal|0x00010000
block|}
block|,
block|{
literal|"fpexc"
block|,
literal|0x00080000
block|}
block|,
block|{
literal|"FPEXC"
block|,
literal|0x00080000
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Structure for a hash table entry for a register.  */
end_comment

begin_struct
struct|struct
name|reg_entry
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|number
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Some well known registers that we refer to directly elsewhere.  */
end_comment

begin_define
define|#
directive|define
name|REG_SP
value|13
end_define

begin_define
define|#
directive|define
name|REG_LR
value|14
end_define

begin_define
define|#
directive|define
name|REG_PC
value|15
end_define

begin_comment
comment|/* These are the standard names.  Users can add aliases with .req.  */
end_comment

begin_comment
comment|/* Integer Register Numbers.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|reg_entry
name|rn_table
index|[]
init|=
block|{
block|{
literal|"r0"
block|,
literal|0
block|}
block|,
block|{
literal|"r1"
block|,
literal|1
block|}
block|,
block|{
literal|"r2"
block|,
literal|2
block|}
block|,
block|{
literal|"r3"
block|,
literal|3
block|}
block|,
block|{
literal|"r4"
block|,
literal|4
block|}
block|,
block|{
literal|"r5"
block|,
literal|5
block|}
block|,
block|{
literal|"r6"
block|,
literal|6
block|}
block|,
block|{
literal|"r7"
block|,
literal|7
block|}
block|,
block|{
literal|"r8"
block|,
literal|8
block|}
block|,
block|{
literal|"r9"
block|,
literal|9
block|}
block|,
block|{
literal|"r10"
block|,
literal|10
block|}
block|,
block|{
literal|"r11"
block|,
literal|11
block|}
block|,
block|{
literal|"r12"
block|,
literal|12
block|}
block|,
block|{
literal|"r13"
block|,
name|REG_SP
block|}
block|,
block|{
literal|"r14"
block|,
name|REG_LR
block|}
block|,
block|{
literal|"r15"
block|,
name|REG_PC
block|}
block|,
comment|/* ATPCS Synonyms.  */
block|{
literal|"a1"
block|,
literal|0
block|}
block|,
block|{
literal|"a2"
block|,
literal|1
block|}
block|,
block|{
literal|"a3"
block|,
literal|2
block|}
block|,
block|{
literal|"a4"
block|,
literal|3
block|}
block|,
block|{
literal|"v1"
block|,
literal|4
block|}
block|,
block|{
literal|"v2"
block|,
literal|5
block|}
block|,
block|{
literal|"v3"
block|,
literal|6
block|}
block|,
block|{
literal|"v4"
block|,
literal|7
block|}
block|,
block|{
literal|"v5"
block|,
literal|8
block|}
block|,
block|{
literal|"v6"
block|,
literal|9
block|}
block|,
block|{
literal|"v7"
block|,
literal|10
block|}
block|,
block|{
literal|"v8"
block|,
literal|11
block|}
block|,
comment|/* Well-known aliases.  */
block|{
literal|"wr"
block|,
literal|7
block|}
block|,
block|{
literal|"sb"
block|,
literal|9
block|}
block|,
block|{
literal|"sl"
block|,
literal|10
block|}
block|,
block|{
literal|"fp"
block|,
literal|11
block|}
block|,
block|{
literal|"ip"
block|,
literal|12
block|}
block|,
block|{
literal|"sp"
block|,
name|REG_SP
block|}
block|,
block|{
literal|"lr"
block|,
name|REG_LR
block|}
block|,
block|{
literal|"pc"
block|,
name|REG_PC
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Co-processor Numbers.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|reg_entry
name|cp_table
index|[]
init|=
block|{
block|{
literal|"p0"
block|,
literal|0
block|}
block|,
block|{
literal|"p1"
block|,
literal|1
block|}
block|,
block|{
literal|"p2"
block|,
literal|2
block|}
block|,
block|{
literal|"p3"
block|,
literal|3
block|}
block|,
block|{
literal|"p4"
block|,
literal|4
block|}
block|,
block|{
literal|"p5"
block|,
literal|5
block|}
block|,
block|{
literal|"p6"
block|,
literal|6
block|}
block|,
block|{
literal|"p7"
block|,
literal|7
block|}
block|,
block|{
literal|"p8"
block|,
literal|8
block|}
block|,
block|{
literal|"p9"
block|,
literal|9
block|}
block|,
block|{
literal|"p10"
block|,
literal|10
block|}
block|,
block|{
literal|"p11"
block|,
literal|11
block|}
block|,
block|{
literal|"p12"
block|,
literal|12
block|}
block|,
block|{
literal|"p13"
block|,
literal|13
block|}
block|,
block|{
literal|"p14"
block|,
literal|14
block|}
block|,
block|{
literal|"p15"
block|,
literal|15
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Co-processor Register Numbers.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|reg_entry
name|cn_table
index|[]
init|=
block|{
block|{
literal|"c0"
block|,
literal|0
block|}
block|,
block|{
literal|"c1"
block|,
literal|1
block|}
block|,
block|{
literal|"c2"
block|,
literal|2
block|}
block|,
block|{
literal|"c3"
block|,
literal|3
block|}
block|,
block|{
literal|"c4"
block|,
literal|4
block|}
block|,
block|{
literal|"c5"
block|,
literal|5
block|}
block|,
block|{
literal|"c6"
block|,
literal|6
block|}
block|,
block|{
literal|"c7"
block|,
literal|7
block|}
block|,
block|{
literal|"c8"
block|,
literal|8
block|}
block|,
block|{
literal|"c9"
block|,
literal|9
block|}
block|,
block|{
literal|"c10"
block|,
literal|10
block|}
block|,
block|{
literal|"c11"
block|,
literal|11
block|}
block|,
block|{
literal|"c12"
block|,
literal|12
block|}
block|,
block|{
literal|"c13"
block|,
literal|13
block|}
block|,
block|{
literal|"c14"
block|,
literal|14
block|}
block|,
block|{
literal|"c15"
block|,
literal|15
block|}
block|,
comment|/* Not really valid, but kept for back-wards compatibility.  */
block|{
literal|"cr0"
block|,
literal|0
block|}
block|,
block|{
literal|"cr1"
block|,
literal|1
block|}
block|,
block|{
literal|"cr2"
block|,
literal|2
block|}
block|,
block|{
literal|"cr3"
block|,
literal|3
block|}
block|,
block|{
literal|"cr4"
block|,
literal|4
block|}
block|,
block|{
literal|"cr5"
block|,
literal|5
block|}
block|,
block|{
literal|"cr6"
block|,
literal|6
block|}
block|,
block|{
literal|"cr7"
block|,
literal|7
block|}
block|,
block|{
literal|"cr8"
block|,
literal|8
block|}
block|,
block|{
literal|"cr9"
block|,
literal|9
block|}
block|,
block|{
literal|"cr10"
block|,
literal|10
block|}
block|,
block|{
literal|"cr11"
block|,
literal|11
block|}
block|,
block|{
literal|"cr12"
block|,
literal|12
block|}
block|,
block|{
literal|"cr13"
block|,
literal|13
block|}
block|,
block|{
literal|"cr14"
block|,
literal|14
block|}
block|,
block|{
literal|"cr15"
block|,
literal|15
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* FPA Registers.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|reg_entry
name|fn_table
index|[]
init|=
block|{
block|{
literal|"f0"
block|,
literal|0
block|}
block|,
block|{
literal|"f1"
block|,
literal|1
block|}
block|,
block|{
literal|"f2"
block|,
literal|2
block|}
block|,
block|{
literal|"f3"
block|,
literal|3
block|}
block|,
block|{
literal|"f4"
block|,
literal|4
block|}
block|,
block|{
literal|"f5"
block|,
literal|5
block|}
block|,
block|{
literal|"f6"
block|,
literal|6
block|}
block|,
block|{
literal|"f7"
block|,
literal|7
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* VFP SP Registers.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|reg_entry
name|sn_table
index|[]
init|=
block|{
block|{
literal|"s0"
block|,
literal|0
block|}
block|,
block|{
literal|"s1"
block|,
literal|1
block|}
block|,
block|{
literal|"s2"
block|,
literal|2
block|}
block|,
block|{
literal|"s3"
block|,
literal|3
block|}
block|,
block|{
literal|"s4"
block|,
literal|4
block|}
block|,
block|{
literal|"s5"
block|,
literal|5
block|}
block|,
block|{
literal|"s6"
block|,
literal|6
block|}
block|,
block|{
literal|"s7"
block|,
literal|7
block|}
block|,
block|{
literal|"s8"
block|,
literal|8
block|}
block|,
block|{
literal|"s9"
block|,
literal|9
block|}
block|,
block|{
literal|"s10"
block|,
literal|10
block|}
block|,
block|{
literal|"s11"
block|,
literal|11
block|}
block|,
block|{
literal|"s12"
block|,
literal|12
block|}
block|,
block|{
literal|"s13"
block|,
literal|13
block|}
block|,
block|{
literal|"s14"
block|,
literal|14
block|}
block|,
block|{
literal|"s15"
block|,
literal|15
block|}
block|,
block|{
literal|"s16"
block|,
literal|16
block|}
block|,
block|{
literal|"s17"
block|,
literal|17
block|}
block|,
block|{
literal|"s18"
block|,
literal|18
block|}
block|,
block|{
literal|"s19"
block|,
literal|19
block|}
block|,
block|{
literal|"s20"
block|,
literal|20
block|}
block|,
block|{
literal|"s21"
block|,
literal|21
block|}
block|,
block|{
literal|"s22"
block|,
literal|22
block|}
block|,
block|{
literal|"s23"
block|,
literal|23
block|}
block|,
block|{
literal|"s24"
block|,
literal|24
block|}
block|,
block|{
literal|"s25"
block|,
literal|25
block|}
block|,
block|{
literal|"s26"
block|,
literal|26
block|}
block|,
block|{
literal|"s27"
block|,
literal|27
block|}
block|,
block|{
literal|"s28"
block|,
literal|28
block|}
block|,
block|{
literal|"s29"
block|,
literal|29
block|}
block|,
block|{
literal|"s30"
block|,
literal|30
block|}
block|,
block|{
literal|"s31"
block|,
literal|31
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* VFP DP Registers.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|reg_entry
name|dn_table
index|[]
init|=
block|{
block|{
literal|"d0"
block|,
literal|0
block|}
block|,
block|{
literal|"d1"
block|,
literal|1
block|}
block|,
block|{
literal|"d2"
block|,
literal|2
block|}
block|,
block|{
literal|"d3"
block|,
literal|3
block|}
block|,
block|{
literal|"d4"
block|,
literal|4
block|}
block|,
block|{
literal|"d5"
block|,
literal|5
block|}
block|,
block|{
literal|"d6"
block|,
literal|6
block|}
block|,
block|{
literal|"d7"
block|,
literal|7
block|}
block|,
block|{
literal|"d8"
block|,
literal|8
block|}
block|,
block|{
literal|"d9"
block|,
literal|9
block|}
block|,
block|{
literal|"d10"
block|,
literal|10
block|}
block|,
block|{
literal|"d11"
block|,
literal|11
block|}
block|,
block|{
literal|"d12"
block|,
literal|12
block|}
block|,
block|{
literal|"d13"
block|,
literal|13
block|}
block|,
block|{
literal|"d14"
block|,
literal|14
block|}
block|,
block|{
literal|"d15"
block|,
literal|15
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Maverick DSP coprocessor registers.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|reg_entry
name|mav_mvf_table
index|[]
init|=
block|{
block|{
literal|"mvf0"
block|,
literal|0
block|}
block|,
block|{
literal|"mvf1"
block|,
literal|1
block|}
block|,
block|{
literal|"mvf2"
block|,
literal|2
block|}
block|,
block|{
literal|"mvf3"
block|,
literal|3
block|}
block|,
block|{
literal|"mvf4"
block|,
literal|4
block|}
block|,
block|{
literal|"mvf5"
block|,
literal|5
block|}
block|,
block|{
literal|"mvf6"
block|,
literal|6
block|}
block|,
block|{
literal|"mvf7"
block|,
literal|7
block|}
block|,
block|{
literal|"mvf8"
block|,
literal|8
block|}
block|,
block|{
literal|"mvf9"
block|,
literal|9
block|}
block|,
block|{
literal|"mvf10"
block|,
literal|10
block|}
block|,
block|{
literal|"mvf11"
block|,
literal|11
block|}
block|,
block|{
literal|"mvf12"
block|,
literal|12
block|}
block|,
block|{
literal|"mvf13"
block|,
literal|13
block|}
block|,
block|{
literal|"mvf14"
block|,
literal|14
block|}
block|,
block|{
literal|"mvf15"
block|,
literal|15
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|reg_entry
name|mav_mvd_table
index|[]
init|=
block|{
block|{
literal|"mvd0"
block|,
literal|0
block|}
block|,
block|{
literal|"mvd1"
block|,
literal|1
block|}
block|,
block|{
literal|"mvd2"
block|,
literal|2
block|}
block|,
block|{
literal|"mvd3"
block|,
literal|3
block|}
block|,
block|{
literal|"mvd4"
block|,
literal|4
block|}
block|,
block|{
literal|"mvd5"
block|,
literal|5
block|}
block|,
block|{
literal|"mvd6"
block|,
literal|6
block|}
block|,
block|{
literal|"mvd7"
block|,
literal|7
block|}
block|,
block|{
literal|"mvd8"
block|,
literal|8
block|}
block|,
block|{
literal|"mvd9"
block|,
literal|9
block|}
block|,
block|{
literal|"mvd10"
block|,
literal|10
block|}
block|,
block|{
literal|"mvd11"
block|,
literal|11
block|}
block|,
block|{
literal|"mvd12"
block|,
literal|12
block|}
block|,
block|{
literal|"mvd13"
block|,
literal|13
block|}
block|,
block|{
literal|"mvd14"
block|,
literal|14
block|}
block|,
block|{
literal|"mvd15"
block|,
literal|15
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|reg_entry
name|mav_mvfx_table
index|[]
init|=
block|{
block|{
literal|"mvfx0"
block|,
literal|0
block|}
block|,
block|{
literal|"mvfx1"
block|,
literal|1
block|}
block|,
block|{
literal|"mvfx2"
block|,
literal|2
block|}
block|,
block|{
literal|"mvfx3"
block|,
literal|3
block|}
block|,
block|{
literal|"mvfx4"
block|,
literal|4
block|}
block|,
block|{
literal|"mvfx5"
block|,
literal|5
block|}
block|,
block|{
literal|"mvfx6"
block|,
literal|6
block|}
block|,
block|{
literal|"mvfx7"
block|,
literal|7
block|}
block|,
block|{
literal|"mvfx8"
block|,
literal|8
block|}
block|,
block|{
literal|"mvfx9"
block|,
literal|9
block|}
block|,
block|{
literal|"mvfx10"
block|,
literal|10
block|}
block|,
block|{
literal|"mvfx11"
block|,
literal|11
block|}
block|,
block|{
literal|"mvfx12"
block|,
literal|12
block|}
block|,
block|{
literal|"mvfx13"
block|,
literal|13
block|}
block|,
block|{
literal|"mvfx14"
block|,
literal|14
block|}
block|,
block|{
literal|"mvfx15"
block|,
literal|15
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|reg_entry
name|mav_mvdx_table
index|[]
init|=
block|{
block|{
literal|"mvdx0"
block|,
literal|0
block|}
block|,
block|{
literal|"mvdx1"
block|,
literal|1
block|}
block|,
block|{
literal|"mvdx2"
block|,
literal|2
block|}
block|,
block|{
literal|"mvdx3"
block|,
literal|3
block|}
block|,
block|{
literal|"mvdx4"
block|,
literal|4
block|}
block|,
block|{
literal|"mvdx5"
block|,
literal|5
block|}
block|,
block|{
literal|"mvdx6"
block|,
literal|6
block|}
block|,
block|{
literal|"mvdx7"
block|,
literal|7
block|}
block|,
block|{
literal|"mvdx8"
block|,
literal|8
block|}
block|,
block|{
literal|"mvdx9"
block|,
literal|9
block|}
block|,
block|{
literal|"mvdx10"
block|,
literal|10
block|}
block|,
block|{
literal|"mvdx11"
block|,
literal|11
block|}
block|,
block|{
literal|"mvdx12"
block|,
literal|12
block|}
block|,
block|{
literal|"mvdx13"
block|,
literal|13
block|}
block|,
block|{
literal|"mvdx14"
block|,
literal|14
block|}
block|,
block|{
literal|"mvdx15"
block|,
literal|15
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|reg_entry
name|mav_mvax_table
index|[]
init|=
block|{
block|{
literal|"mvax0"
block|,
literal|0
block|}
block|,
block|{
literal|"mvax1"
block|,
literal|1
block|}
block|,
block|{
literal|"mvax2"
block|,
literal|2
block|}
block|,
block|{
literal|"mvax3"
block|,
literal|3
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|reg_entry
name|mav_dspsc_table
index|[]
init|=
block|{
block|{
literal|"dspsc"
block|,
literal|0
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|reg_map
block|{
specifier|const
name|struct
name|reg_entry
modifier|*
name|names
decl_stmt|;
name|int
name|max_regno
decl_stmt|;
name|struct
name|hash_control
modifier|*
name|htab
decl_stmt|;
specifier|const
name|char
modifier|*
name|expected
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|reg_map
name|all_reg_maps
index|[]
init|=
block|{
block|{
name|rn_table
block|,
literal|15
block|,
name|NULL
block|,
name|N_
argument_list|(
literal|"ARM register expected"
argument_list|)
block|}
block|,
block|{
name|cp_table
block|,
literal|15
block|,
name|NULL
block|,
name|N_
argument_list|(
literal|"bad or missing co-processor number"
argument_list|)
block|}
block|,
block|{
name|cn_table
block|,
literal|15
block|,
name|NULL
block|,
name|N_
argument_list|(
literal|"co-processor register expected"
argument_list|)
block|}
block|,
block|{
name|fn_table
block|,
literal|7
block|,
name|NULL
block|,
name|N_
argument_list|(
literal|"FPA register expected"
argument_list|)
block|}
block|,
block|{
name|sn_table
block|,
literal|31
block|,
name|NULL
block|,
name|N_
argument_list|(
literal|"VFP single precision register expected"
argument_list|)
block|}
block|,
block|{
name|dn_table
block|,
literal|15
block|,
name|NULL
block|,
name|N_
argument_list|(
literal|"VFP double precision register expected"
argument_list|)
block|}
block|,
block|{
name|mav_mvf_table
block|,
literal|15
block|,
name|NULL
block|,
name|N_
argument_list|(
literal|"Maverick MVF register expected"
argument_list|)
block|}
block|,
block|{
name|mav_mvd_table
block|,
literal|15
block|,
name|NULL
block|,
name|N_
argument_list|(
literal|"Maverick MVD register expected"
argument_list|)
block|}
block|,
block|{
name|mav_mvfx_table
block|,
literal|15
block|,
name|NULL
block|,
name|N_
argument_list|(
literal|"Maverick MVFX register expected"
argument_list|)
block|}
block|,
block|{
name|mav_mvdx_table
block|,
literal|15
block|,
name|NULL
block|,
name|N_
argument_list|(
literal|"Maverick MVFX register expected"
argument_list|)
block|}
block|,
block|{
name|mav_mvax_table
block|,
literal|3
block|,
name|NULL
block|,
name|N_
argument_list|(
literal|"Maverick MVAX register expected"
argument_list|)
block|}
block|,
block|{
name|mav_dspsc_table
block|,
literal|0
block|,
name|NULL
block|,
name|N_
argument_list|(
literal|"Maverick DSPSC register expected"
argument_list|)
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Enumeration matching entries in table above.  */
end_comment

begin_enum
enum|enum
name|arm_reg_type
block|{
name|REG_TYPE_RN
init|=
literal|0
block|,
define|#
directive|define
name|REG_TYPE_FIRST
value|REG_TYPE_RN
name|REG_TYPE_CP
init|=
literal|1
block|,
name|REG_TYPE_CN
init|=
literal|2
block|,
name|REG_TYPE_FN
init|=
literal|3
block|,
name|REG_TYPE_SN
init|=
literal|4
block|,
name|REG_TYPE_DN
init|=
literal|5
block|,
name|REG_TYPE_MVF
init|=
literal|6
block|,
name|REG_TYPE_MVD
init|=
literal|7
block|,
name|REG_TYPE_MVFX
init|=
literal|8
block|,
name|REG_TYPE_MVDX
init|=
literal|9
block|,
name|REG_TYPE_MVAX
init|=
literal|10
block|,
name|REG_TYPE_DSPSC
init|=
literal|11
block|,
name|REG_TYPE_MAX
init|=
literal|12
block|}
enum|;
end_enum

begin_comment
comment|/* Functions called by parser.  */
end_comment

begin_comment
comment|/* ARM instructions.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|do_arit
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_cmp
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_mov
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_ldst
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_ldstt
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_ldmstm
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_branch
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_swi
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pseudo Op codes.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|do_adr
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_adrl
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_empty
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ARM v2.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|do_mul
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_mla
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ARM v2S.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|do_swap
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ARM v3.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|do_msr
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_mrs
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ARM v3M.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|do_mull
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ARM v4.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|do_ldstv4
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ARM v4T.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|do_bx
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ARM v5T.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|do_blx
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_bkpt
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_clz
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_lstc2
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_cdp2
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_co_reg2
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ARM v5TExP.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|do_smla
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_smlal
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_smul
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_qadd
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ARM v5TE.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|do_pld
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_ldrd
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_co_reg2c
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ARM v5TEJ.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|do_bxj
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Coprocessor Instructions.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|do_cdp
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_lstc
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_co_reg
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* FPA instructions.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|do_fpa_ctrl
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_fpa_ldst
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_fpa_ldmstm
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_fpa_dyadic
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_fpa_monadic
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_fpa_cmp
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_fpa_from_reg
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_fpa_to_reg
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* VFP instructions.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|do_vfp_sp_monadic
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_vfp_dp_monadic
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_vfp_sp_dyadic
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_vfp_dp_dyadic
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_vfp_reg_from_sp
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_vfp_sp_from_reg
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_vfp_sp_reg2
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_vfp_reg_from_dp
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_vfp_reg2_from_dp
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_vfp_dp_from_reg
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_vfp_dp_from_reg2
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_vfp_reg_from_ctrl
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_vfp_ctrl_from_reg
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_vfp_sp_ldst
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_vfp_dp_ldst
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_vfp_sp_ldstmia
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_vfp_sp_ldstmdb
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_vfp_dp_ldstmia
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_vfp_dp_ldstmdb
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_vfp_xp_ldstmia
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_vfp_xp_ldstmdb
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_vfp_sp_compare_z
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_vfp_dp_compare_z
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_vfp_dp_sp_cvt
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_vfp_sp_dp_cvt
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* XScale.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|do_xsc_mia
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_xsc_mar
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_xsc_mra
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Maverick.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|do_mav_binops
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|,
expr|enum
name|arm_reg_type
operator|,
expr|enum
name|arm_reg_type
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_mav_binops_1a
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_mav_binops_1b
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_mav_binops_1c
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_mav_binops_1d
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_mav_binops_1e
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_mav_binops_1f
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_mav_binops_1g
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_mav_binops_1h
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_mav_binops_1i
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_mav_binops_1j
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_mav_binops_1k
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_mav_binops_1l
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_mav_binops_1m
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_mav_binops_1n
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_mav_binops_1o
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_mav_binops_2a
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_mav_binops_2b
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_mav_binops_2c
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_mav_binops_3a
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_mav_binops_3b
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_mav_binops_3c
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_mav_binops_3d
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_mav_triple
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|,
expr|enum
name|arm_reg_type
operator|,
expr|enum
name|arm_reg_type
operator|,
expr|enum
name|arm_reg_type
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_mav_triple_4a
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_mav_triple_4b
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_mav_triple_5a
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_mav_triple_5b
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_mav_triple_5c
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_mav_triple_5d
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_mav_triple_5e
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_mav_triple_5f
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_mav_triple_5g
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_mav_triple_5h
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_mav_quad
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|,
expr|enum
name|arm_reg_type
operator|,
expr|enum
name|arm_reg_type
operator|,
expr|enum
name|arm_reg_type
operator|,
expr|enum
name|arm_reg_type
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_mav_quad_6a
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_mav_quad_6b
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_mav_dspsc_1
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_mav_dspsc_2
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_mav_shift
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
expr|enum
name|arm_reg_type
operator|,
expr|enum
name|arm_reg_type
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_mav_shift_1
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_mav_shift_2
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_mav_ldst
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
expr|enum
name|arm_reg_type
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_mav_ldst_1
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_mav_ldst_2
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_mav_ldst_3
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_mav_ldst_4
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|mav_reg_required_here
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|,
name|int
operator|,
expr|enum
name|arm_reg_type
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|mav_parse_offset
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|fix_new_arm
name|PARAMS
argument_list|(
operator|(
name|fragS
operator|*
operator|,
name|int
operator|,
name|short
operator|,
name|expressionS
operator|*
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|arm_reg_parse
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|,
expr|struct
name|hash_control
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|enum
name|arm_reg_type
name|arm_reg_parse_any
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|asm_psr
modifier|*
name|arm_psr_parse
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|symbol_locate
name|PARAMS
argument_list|(
operator|(
name|symbolS
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
name|segT
operator|,
name|valueT
operator|,
name|fragS
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|add_to_lit_pool
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|validate_immediate
name|PARAMS
argument_list|(
operator|(
name|unsigned
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|validate_immediate_twopart
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|int
operator|,
name|unsigned
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|validate_offset_imm
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|opcode_select
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|end_of_line
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|reg_required_here
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|psr_required_here
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|co_proc_number
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|cp_opc_expr
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|cp_reg_required_here
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|fp_reg_required_here
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|vfp_sp_reg_required_here
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|,
expr|enum
name|vfp_sp_reg_pos
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|vfp_dp_reg_required_here
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|,
expr|enum
name|vfp_dp_reg_pos
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|vfp_sp_ldstm
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
expr|enum
name|vfp_ldstm_type
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|vfp_dp_ldstm
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
expr|enum
name|vfp_ldstm_type
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|vfp_sp_reg_list
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|,
expr|enum
name|vfp_sp_reg_pos
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|vfp_dp_reg_list
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|vfp_psr_required_here
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|*
name|str
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|vfp_reg
modifier|*
name|vfp_psr_parse
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|*
name|str
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|cp_address_offset
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|cp_address_required_here
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|my_get_float_expression
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|skip_past_comma
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|walk_no_bignums
name|PARAMS
argument_list|(
operator|(
name|symbolS
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|negate_data_op
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|long
operator|*
operator|,
name|unsigned
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|data_op2
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|fp_op2
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|reg_list
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|thumb_load_store
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|decode_shift
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ldst_extend
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ldst_extend_v4
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|thumb_add_sub
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|insert_reg
name|PARAMS
argument_list|(
operator|(
specifier|const
expr|struct
name|reg_entry
operator|*
operator|,
expr|struct
name|hash_control
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|thumb_shift
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|thumb_mov_compare
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|build_arm_ops_hsh
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|set_constant_flonums
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|valueT
name|md_chars_to_number
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|build_reg_hsh
name|PARAMS
argument_list|(
operator|(
expr|struct
name|reg_map
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|insert_reg_alias
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|,
expr|struct
name|hash_control
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|create_register_alias
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_inst
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|accum0_required_here
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ld_mode_required_here
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_branch25
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|symbolS
modifier|*
name|find_real_start
name|PARAMS
argument_list|(
operator|(
name|symbolS
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|OBJ_ELF
end_ifdef

begin_decl_stmt
specifier|static
name|bfd_reloc_code_real_type
name|arm_parse_reloc
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ARM instructions take 4bytes in the object file, Thumb instructions    take 2:  */
end_comment

begin_define
define|#
directive|define
name|INSN_SIZE
value|4
end_define

begin_comment
comment|/* "INSN<cond> X,Y" where X:bit12, Y:bit16.  */
end_comment

begin_define
define|#
directive|define
name|MAV_MODE1
value|0x100c
end_define

begin_comment
comment|/* "INSN<cond> X,Y" where X:bit16, Y:bit12.  */
end_comment

begin_define
define|#
directive|define
name|MAV_MODE2
value|0x0c10
end_define

begin_comment
comment|/* "INSN<cond> X,Y" where X:0, Y:bit16.  */
end_comment

begin_define
define|#
directive|define
name|MAV_MODE3
value|0x1000
end_define

begin_comment
comment|/* "INSN<cond> X,Y,Z" where X:16, Y:0, Z:12.  */
end_comment

begin_define
define|#
directive|define
name|MAV_MODE4
value|0x0c0010
end_define

begin_comment
comment|/* "INSN<cond> X,Y,Z" where X:12, Y:16, Z:0.  */
end_comment

begin_define
define|#
directive|define
name|MAV_MODE5
value|0x00100c
end_define

begin_comment
comment|/* "INSN<cond> W,X,Y,Z" where W:5, X:12, Y:16, Z:0.  */
end_comment

begin_define
define|#
directive|define
name|MAV_MODE6
value|0x00100c05
end_define

begin_struct
struct|struct
name|asm_opcode
block|{
comment|/* Basic string to match.  */
specifier|const
name|char
modifier|*
name|template
decl_stmt|;
comment|/* Basic instruction code.  */
name|unsigned
name|long
name|value
decl_stmt|;
comment|/* Offset into the template where the condition code (if any) will be.      If zero, then the instruction is never conditional.  */
name|unsigned
name|cond_offset
decl_stmt|;
comment|/* Which architecture variant provides this instruction.  */
name|unsigned
name|long
name|variant
decl_stmt|;
comment|/* Function to call to parse args.  */
name|void
argument_list|(
argument|* parms
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
expr_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|asm_opcode
name|insns
index|[]
init|=
block|{
comment|/* Core ARM Instructions.  */
block|{
literal|"and"
block|,
literal|0xe0000000
block|,
literal|3
block|,
name|ARM_EXT_V1
block|,
name|do_arit
block|}
block|,
block|{
literal|"ands"
block|,
literal|0xe0100000
block|,
literal|3
block|,
name|ARM_EXT_V1
block|,
name|do_arit
block|}
block|,
block|{
literal|"eor"
block|,
literal|0xe0200000
block|,
literal|3
block|,
name|ARM_EXT_V1
block|,
name|do_arit
block|}
block|,
block|{
literal|"eors"
block|,
literal|0xe0300000
block|,
literal|3
block|,
name|ARM_EXT_V1
block|,
name|do_arit
block|}
block|,
block|{
literal|"sub"
block|,
literal|0xe0400000
block|,
literal|3
block|,
name|ARM_EXT_V1
block|,
name|do_arit
block|}
block|,
block|{
literal|"subs"
block|,
literal|0xe0500000
block|,
literal|3
block|,
name|ARM_EXT_V1
block|,
name|do_arit
block|}
block|,
block|{
literal|"rsb"
block|,
literal|0xe0600000
block|,
literal|3
block|,
name|ARM_EXT_V1
block|,
name|do_arit
block|}
block|,
block|{
literal|"rsbs"
block|,
literal|0xe0700000
block|,
literal|3
block|,
name|ARM_EXT_V1
block|,
name|do_arit
block|}
block|,
block|{
literal|"add"
block|,
literal|0xe0800000
block|,
literal|3
block|,
name|ARM_EXT_V1
block|,
name|do_arit
block|}
block|,
block|{
literal|"adds"
block|,
literal|0xe0900000
block|,
literal|3
block|,
name|ARM_EXT_V1
block|,
name|do_arit
block|}
block|,
block|{
literal|"adc"
block|,
literal|0xe0a00000
block|,
literal|3
block|,
name|ARM_EXT_V1
block|,
name|do_arit
block|}
block|,
block|{
literal|"adcs"
block|,
literal|0xe0b00000
block|,
literal|3
block|,
name|ARM_EXT_V1
block|,
name|do_arit
block|}
block|,
block|{
literal|"sbc"
block|,
literal|0xe0c00000
block|,
literal|3
block|,
name|ARM_EXT_V1
block|,
name|do_arit
block|}
block|,
block|{
literal|"sbcs"
block|,
literal|0xe0d00000
block|,
literal|3
block|,
name|ARM_EXT_V1
block|,
name|do_arit
block|}
block|,
block|{
literal|"rsc"
block|,
literal|0xe0e00000
block|,
literal|3
block|,
name|ARM_EXT_V1
block|,
name|do_arit
block|}
block|,
block|{
literal|"rscs"
block|,
literal|0xe0f00000
block|,
literal|3
block|,
name|ARM_EXT_V1
block|,
name|do_arit
block|}
block|,
block|{
literal|"orr"
block|,
literal|0xe1800000
block|,
literal|3
block|,
name|ARM_EXT_V1
block|,
name|do_arit
block|}
block|,
block|{
literal|"orrs"
block|,
literal|0xe1900000
block|,
literal|3
block|,
name|ARM_EXT_V1
block|,
name|do_arit
block|}
block|,
block|{
literal|"bic"
block|,
literal|0xe1c00000
block|,
literal|3
block|,
name|ARM_EXT_V1
block|,
name|do_arit
block|}
block|,
block|{
literal|"bics"
block|,
literal|0xe1d00000
block|,
literal|3
block|,
name|ARM_EXT_V1
block|,
name|do_arit
block|}
block|,
block|{
literal|"tst"
block|,
literal|0xe1100000
block|,
literal|3
block|,
name|ARM_EXT_V1
block|,
name|do_cmp
block|}
block|,
block|{
literal|"tsts"
block|,
literal|0xe1100000
block|,
literal|3
block|,
name|ARM_EXT_V1
block|,
name|do_cmp
block|}
block|,
block|{
literal|"tstp"
block|,
literal|0xe110f000
block|,
literal|3
block|,
name|ARM_EXT_V1
block|,
name|do_cmp
block|}
block|,
block|{
literal|"teq"
block|,
literal|0xe1300000
block|,
literal|3
block|,
name|ARM_EXT_V1
block|,
name|do_cmp
block|}
block|,
block|{
literal|"teqs"
block|,
literal|0xe1300000
block|,
literal|3
block|,
name|ARM_EXT_V1
block|,
name|do_cmp
block|}
block|,
block|{
literal|"teqp"
block|,
literal|0xe130f000
block|,
literal|3
block|,
name|ARM_EXT_V1
block|,
name|do_cmp
block|}
block|,
block|{
literal|"cmp"
block|,
literal|0xe1500000
block|,
literal|3
block|,
name|ARM_EXT_V1
block|,
name|do_cmp
block|}
block|,
block|{
literal|"cmps"
block|,
literal|0xe1500000
block|,
literal|3
block|,
name|ARM_EXT_V1
block|,
name|do_cmp
block|}
block|,
block|{
literal|"cmpp"
block|,
literal|0xe150f000
block|,
literal|3
block|,
name|ARM_EXT_V1
block|,
name|do_cmp
block|}
block|,
block|{
literal|"cmn"
block|,
literal|0xe1700000
block|,
literal|3
block|,
name|ARM_EXT_V1
block|,
name|do_cmp
block|}
block|,
block|{
literal|"cmns"
block|,
literal|0xe1700000
block|,
literal|3
block|,
name|ARM_EXT_V1
block|,
name|do_cmp
block|}
block|,
block|{
literal|"cmnp"
block|,
literal|0xe170f000
block|,
literal|3
block|,
name|ARM_EXT_V1
block|,
name|do_cmp
block|}
block|,
block|{
literal|"mov"
block|,
literal|0xe1a00000
block|,
literal|3
block|,
name|ARM_EXT_V1
block|,
name|do_mov
block|}
block|,
block|{
literal|"movs"
block|,
literal|0xe1b00000
block|,
literal|3
block|,
name|ARM_EXT_V1
block|,
name|do_mov
block|}
block|,
block|{
literal|"mvn"
block|,
literal|0xe1e00000
block|,
literal|3
block|,
name|ARM_EXT_V1
block|,
name|do_mov
block|}
block|,
block|{
literal|"mvns"
block|,
literal|0xe1f00000
block|,
literal|3
block|,
name|ARM_EXT_V1
block|,
name|do_mov
block|}
block|,
block|{
literal|"ldr"
block|,
literal|0xe4100000
block|,
literal|3
block|,
name|ARM_EXT_V1
block|,
name|do_ldst
block|}
block|,
block|{
literal|"ldrb"
block|,
literal|0xe4500000
block|,
literal|3
block|,
name|ARM_EXT_V1
block|,
name|do_ldst
block|}
block|,
block|{
literal|"ldrt"
block|,
literal|0xe4300000
block|,
literal|3
block|,
name|ARM_EXT_V1
block|,
name|do_ldstt
block|}
block|,
block|{
literal|"ldrbt"
block|,
literal|0xe4700000
block|,
literal|3
block|,
name|ARM_EXT_V1
block|,
name|do_ldstt
block|}
block|,
block|{
literal|"str"
block|,
literal|0xe4000000
block|,
literal|3
block|,
name|ARM_EXT_V1
block|,
name|do_ldst
block|}
block|,
block|{
literal|"strb"
block|,
literal|0xe4400000
block|,
literal|3
block|,
name|ARM_EXT_V1
block|,
name|do_ldst
block|}
block|,
block|{
literal|"strt"
block|,
literal|0xe4200000
block|,
literal|3
block|,
name|ARM_EXT_V1
block|,
name|do_ldstt
block|}
block|,
block|{
literal|"strbt"
block|,
literal|0xe4600000
block|,
literal|3
block|,
name|ARM_EXT_V1
block|,
name|do_ldstt
block|}
block|,
block|{
literal|"stmia"
block|,
literal|0xe8800000
block|,
literal|3
block|,
name|ARM_EXT_V1
block|,
name|do_ldmstm
block|}
block|,
block|{
literal|"stmib"
block|,
literal|0xe9800000
block|,
literal|3
block|,
name|ARM_EXT_V1
block|,
name|do_ldmstm
block|}
block|,
block|{
literal|"stmda"
block|,
literal|0xe8000000
block|,
literal|3
block|,
name|ARM_EXT_V1
block|,
name|do_ldmstm
block|}
block|,
block|{
literal|"stmdb"
block|,
literal|0xe9000000
block|,
literal|3
block|,
name|ARM_EXT_V1
block|,
name|do_ldmstm
block|}
block|,
block|{
literal|"stmfd"
block|,
literal|0xe9000000
block|,
literal|3
block|,
name|ARM_EXT_V1
block|,
name|do_ldmstm
block|}
block|,
block|{
literal|"stmfa"
block|,
literal|0xe9800000
block|,
literal|3
block|,
name|ARM_EXT_V1
block|,
name|do_ldmstm
block|}
block|,
block|{
literal|"stmea"
block|,
literal|0xe8800000
block|,
literal|3
block|,
name|ARM_EXT_V1
block|,
name|do_ldmstm
block|}
block|,
block|{
literal|"stmed"
block|,
literal|0xe8000000
block|,
literal|3
block|,
name|ARM_EXT_V1
block|,
name|do_ldmstm
block|}
block|,
block|{
literal|"ldmia"
block|,
literal|0xe8900000
block|,
literal|3
block|,
name|ARM_EXT_V1
block|,
name|do_ldmstm
block|}
block|,
block|{
literal|"ldmib"
block|,
literal|0xe9900000
block|,
literal|3
block|,
name|ARM_EXT_V1
block|,
name|do_ldmstm
block|}
block|,
block|{
literal|"ldmda"
block|,
literal|0xe8100000
block|,
literal|3
block|,
name|ARM_EXT_V1
block|,
name|do_ldmstm
block|}
block|,
block|{
literal|"ldmdb"
block|,
literal|0xe9100000
block|,
literal|3
block|,
name|ARM_EXT_V1
block|,
name|do_ldmstm
block|}
block|,
block|{
literal|"ldmfd"
block|,
literal|0xe8900000
block|,
literal|3
block|,
name|ARM_EXT_V1
block|,
name|do_ldmstm
block|}
block|,
block|{
literal|"ldmfa"
block|,
literal|0xe8100000
block|,
literal|3
block|,
name|ARM_EXT_V1
block|,
name|do_ldmstm
block|}
block|,
block|{
literal|"ldmea"
block|,
literal|0xe9100000
block|,
literal|3
block|,
name|ARM_EXT_V1
block|,
name|do_ldmstm
block|}
block|,
block|{
literal|"ldmed"
block|,
literal|0xe9900000
block|,
literal|3
block|,
name|ARM_EXT_V1
block|,
name|do_ldmstm
block|}
block|,
block|{
literal|"swi"
block|,
literal|0xef000000
block|,
literal|3
block|,
name|ARM_EXT_V1
block|,
name|do_swi
block|}
block|,
ifdef|#
directive|ifdef
name|TE_WINCE
comment|/* XXX This is the wrong place to do this.  Think multi-arch.  */
block|{
literal|"bl"
block|,
literal|0xeb000000
block|,
literal|2
block|,
name|ARM_EXT_V1
block|,
name|do_branch
block|}
block|,
block|{
literal|"b"
block|,
literal|0xea000000
block|,
literal|1
block|,
name|ARM_EXT_V1
block|,
name|do_branch
block|}
block|,
else|#
directive|else
block|{
literal|"bl"
block|,
literal|0xebfffffe
block|,
literal|2
block|,
name|ARM_EXT_V1
block|,
name|do_branch
block|}
block|,
block|{
literal|"b"
block|,
literal|0xeafffffe
block|,
literal|1
block|,
name|ARM_EXT_V1
block|,
name|do_branch
block|}
block|,
endif|#
directive|endif
comment|/* Pseudo ops.  */
block|{
literal|"adr"
block|,
literal|0xe28f0000
block|,
literal|3
block|,
name|ARM_EXT_V1
block|,
name|do_adr
block|}
block|,
block|{
literal|"adrl"
block|,
literal|0xe28f0000
block|,
literal|3
block|,
name|ARM_EXT_V1
block|,
name|do_adrl
block|}
block|,
block|{
literal|"nop"
block|,
literal|0xe1a00000
block|,
literal|3
block|,
name|ARM_EXT_V1
block|,
name|do_empty
block|}
block|,
comment|/* ARM 2 multiplies.  */
block|{
literal|"mul"
block|,
literal|0xe0000090
block|,
literal|3
block|,
name|ARM_EXT_V2
block|,
name|do_mul
block|}
block|,
block|{
literal|"muls"
block|,
literal|0xe0100090
block|,
literal|3
block|,
name|ARM_EXT_V2
block|,
name|do_mul
block|}
block|,
block|{
literal|"mla"
block|,
literal|0xe0200090
block|,
literal|3
block|,
name|ARM_EXT_V2
block|,
name|do_mla
block|}
block|,
block|{
literal|"mlas"
block|,
literal|0xe0300090
block|,
literal|3
block|,
name|ARM_EXT_V2
block|,
name|do_mla
block|}
block|,
comment|/* Generic copressor instructions.  */
block|{
literal|"cdp"
block|,
literal|0xee000000
block|,
literal|3
block|,
name|ARM_EXT_V2
block|,
name|do_cdp
block|}
block|,
block|{
literal|"ldc"
block|,
literal|0xec100000
block|,
literal|3
block|,
name|ARM_EXT_V2
block|,
name|do_lstc
block|}
block|,
block|{
literal|"ldcl"
block|,
literal|0xec500000
block|,
literal|3
block|,
name|ARM_EXT_V2
block|,
name|do_lstc
block|}
block|,
block|{
literal|"stc"
block|,
literal|0xec000000
block|,
literal|3
block|,
name|ARM_EXT_V2
block|,
name|do_lstc
block|}
block|,
block|{
literal|"stcl"
block|,
literal|0xec400000
block|,
literal|3
block|,
name|ARM_EXT_V2
block|,
name|do_lstc
block|}
block|,
block|{
literal|"mcr"
block|,
literal|0xee000010
block|,
literal|3
block|,
name|ARM_EXT_V2
block|,
name|do_co_reg
block|}
block|,
block|{
literal|"mrc"
block|,
literal|0xee100010
block|,
literal|3
block|,
name|ARM_EXT_V2
block|,
name|do_co_reg
block|}
block|,
comment|/* ARM 3 - swp instructions.  */
block|{
literal|"swp"
block|,
literal|0xe1000090
block|,
literal|3
block|,
name|ARM_EXT_V2S
block|,
name|do_swap
block|}
block|,
block|{
literal|"swpb"
block|,
literal|0xe1400090
block|,
literal|3
block|,
name|ARM_EXT_V2S
block|,
name|do_swap
block|}
block|,
comment|/* ARM 6 Status register instructions.  */
block|{
literal|"mrs"
block|,
literal|0xe10f0000
block|,
literal|3
block|,
name|ARM_EXT_V3
block|,
name|do_mrs
block|}
block|,
block|{
literal|"msr"
block|,
literal|0xe120f000
block|,
literal|3
block|,
name|ARM_EXT_V3
block|,
name|do_msr
block|}
block|,
comment|/* ScottB: our code uses     0xe128f000 for msr.      NickC:  but this is wrong because the bits 16 through 19 are              handled by the PSR_xxx defines above.  */
comment|/* ARM 7M long multiplies.  */
block|{
literal|"smull"
block|,
literal|0xe0c00090
block|,
literal|5
block|,
name|ARM_EXT_V3M
block|,
name|do_mull
block|}
block|,
block|{
literal|"smulls"
block|,
literal|0xe0d00090
block|,
literal|5
block|,
name|ARM_EXT_V3M
block|,
name|do_mull
block|}
block|,
block|{
literal|"umull"
block|,
literal|0xe0800090
block|,
literal|5
block|,
name|ARM_EXT_V3M
block|,
name|do_mull
block|}
block|,
block|{
literal|"umulls"
block|,
literal|0xe0900090
block|,
literal|5
block|,
name|ARM_EXT_V3M
block|,
name|do_mull
block|}
block|,
block|{
literal|"smlal"
block|,
literal|0xe0e00090
block|,
literal|5
block|,
name|ARM_EXT_V3M
block|,
name|do_mull
block|}
block|,
block|{
literal|"smlals"
block|,
literal|0xe0f00090
block|,
literal|5
block|,
name|ARM_EXT_V3M
block|,
name|do_mull
block|}
block|,
block|{
literal|"umlal"
block|,
literal|0xe0a00090
block|,
literal|5
block|,
name|ARM_EXT_V3M
block|,
name|do_mull
block|}
block|,
block|{
literal|"umlals"
block|,
literal|0xe0b00090
block|,
literal|5
block|,
name|ARM_EXT_V3M
block|,
name|do_mull
block|}
block|,
comment|/* ARM Architecture 4.  */
block|{
literal|"ldrh"
block|,
literal|0xe01000b0
block|,
literal|3
block|,
name|ARM_EXT_V4
block|,
name|do_ldstv4
block|}
block|,
block|{
literal|"ldrsh"
block|,
literal|0xe01000f0
block|,
literal|3
block|,
name|ARM_EXT_V4
block|,
name|do_ldstv4
block|}
block|,
block|{
literal|"ldrsb"
block|,
literal|0xe01000d0
block|,
literal|3
block|,
name|ARM_EXT_V4
block|,
name|do_ldstv4
block|}
block|,
block|{
literal|"strh"
block|,
literal|0xe00000b0
block|,
literal|3
block|,
name|ARM_EXT_V4
block|,
name|do_ldstv4
block|}
block|,
comment|/* ARM Architecture 4T.  */
comment|/* Note: bx (and blx) are required on V5, even if the processor does       not support Thumb.  */
block|{
literal|"bx"
block|,
literal|0xe12fff10
block|,
literal|2
block|,
name|ARM_EXT_V4T
operator||
name|ARM_EXT_V5
block|,
name|do_bx
block|}
block|,
comment|/*  ARM Architecture 5T.  */
comment|/* Note: blx has 2 variants, so the .value is set dynamically.      Only one of the variants has conditional execution.  */
block|{
literal|"blx"
block|,
literal|0xe0000000
block|,
literal|3
block|,
name|ARM_EXT_V5
block|,
name|do_blx
block|}
block|,
block|{
literal|"clz"
block|,
literal|0xe16f0f10
block|,
literal|3
block|,
name|ARM_EXT_V5
block|,
name|do_clz
block|}
block|,
block|{
literal|"bkpt"
block|,
literal|0xe1200070
block|,
literal|0
block|,
name|ARM_EXT_V5
block|,
name|do_bkpt
block|}
block|,
block|{
literal|"ldc2"
block|,
literal|0xfc100000
block|,
literal|0
block|,
name|ARM_EXT_V5
block|,
name|do_lstc2
block|}
block|,
block|{
literal|"ldc2l"
block|,
literal|0xfc500000
block|,
literal|0
block|,
name|ARM_EXT_V5
block|,
name|do_lstc2
block|}
block|,
block|{
literal|"stc2"
block|,
literal|0xfc000000
block|,
literal|0
block|,
name|ARM_EXT_V5
block|,
name|do_lstc2
block|}
block|,
block|{
literal|"stc2l"
block|,
literal|0xfc400000
block|,
literal|0
block|,
name|ARM_EXT_V5
block|,
name|do_lstc2
block|}
block|,
block|{
literal|"cdp2"
block|,
literal|0xfe000000
block|,
literal|0
block|,
name|ARM_EXT_V5
block|,
name|do_cdp2
block|}
block|,
block|{
literal|"mcr2"
block|,
literal|0xfe000010
block|,
literal|0
block|,
name|ARM_EXT_V5
block|,
name|do_co_reg2
block|}
block|,
block|{
literal|"mrc2"
block|,
literal|0xfe100010
block|,
literal|0
block|,
name|ARM_EXT_V5
block|,
name|do_co_reg2
block|}
block|,
comment|/*  ARM Architecture 5TExP.  */
block|{
literal|"smlabb"
block|,
literal|0xe1000080
block|,
literal|6
block|,
name|ARM_EXT_V5ExP
block|,
name|do_smla
block|}
block|,
block|{
literal|"smlatb"
block|,
literal|0xe10000a0
block|,
literal|6
block|,
name|ARM_EXT_V5ExP
block|,
name|do_smla
block|}
block|,
block|{
literal|"smlabt"
block|,
literal|0xe10000c0
block|,
literal|6
block|,
name|ARM_EXT_V5ExP
block|,
name|do_smla
block|}
block|,
block|{
literal|"smlatt"
block|,
literal|0xe10000e0
block|,
literal|6
block|,
name|ARM_EXT_V5ExP
block|,
name|do_smla
block|}
block|,
block|{
literal|"smlawb"
block|,
literal|0xe1200080
block|,
literal|6
block|,
name|ARM_EXT_V5ExP
block|,
name|do_smla
block|}
block|,
block|{
literal|"smlawt"
block|,
literal|0xe12000c0
block|,
literal|6
block|,
name|ARM_EXT_V5ExP
block|,
name|do_smla
block|}
block|,
block|{
literal|"smlalbb"
block|,
literal|0xe1400080
block|,
literal|7
block|,
name|ARM_EXT_V5ExP
block|,
name|do_smlal
block|}
block|,
block|{
literal|"smlaltb"
block|,
literal|0xe14000a0
block|,
literal|7
block|,
name|ARM_EXT_V5ExP
block|,
name|do_smlal
block|}
block|,
block|{
literal|"smlalbt"
block|,
literal|0xe14000c0
block|,
literal|7
block|,
name|ARM_EXT_V5ExP
block|,
name|do_smlal
block|}
block|,
block|{
literal|"smlaltt"
block|,
literal|0xe14000e0
block|,
literal|7
block|,
name|ARM_EXT_V5ExP
block|,
name|do_smlal
block|}
block|,
block|{
literal|"smulbb"
block|,
literal|0xe1600080
block|,
literal|6
block|,
name|ARM_EXT_V5ExP
block|,
name|do_smul
block|}
block|,
block|{
literal|"smultb"
block|,
literal|0xe16000a0
block|,
literal|6
block|,
name|ARM_EXT_V5ExP
block|,
name|do_smul
block|}
block|,
block|{
literal|"smulbt"
block|,
literal|0xe16000c0
block|,
literal|6
block|,
name|ARM_EXT_V5ExP
block|,
name|do_smul
block|}
block|,
block|{
literal|"smultt"
block|,
literal|0xe16000e0
block|,
literal|6
block|,
name|ARM_EXT_V5ExP
block|,
name|do_smul
block|}
block|,
block|{
literal|"smulwb"
block|,
literal|0xe12000a0
block|,
literal|6
block|,
name|ARM_EXT_V5ExP
block|,
name|do_smul
block|}
block|,
block|{
literal|"smulwt"
block|,
literal|0xe12000e0
block|,
literal|6
block|,
name|ARM_EXT_V5ExP
block|,
name|do_smul
block|}
block|,
block|{
literal|"qadd"
block|,
literal|0xe1000050
block|,
literal|4
block|,
name|ARM_EXT_V5ExP
block|,
name|do_qadd
block|}
block|,
block|{
literal|"qdadd"
block|,
literal|0xe1400050
block|,
literal|5
block|,
name|ARM_EXT_V5ExP
block|,
name|do_qadd
block|}
block|,
block|{
literal|"qsub"
block|,
literal|0xe1200050
block|,
literal|4
block|,
name|ARM_EXT_V5ExP
block|,
name|do_qadd
block|}
block|,
block|{
literal|"qdsub"
block|,
literal|0xe1600050
block|,
literal|5
block|,
name|ARM_EXT_V5ExP
block|,
name|do_qadd
block|}
block|,
comment|/*  ARM Architecture 5TE.  */
block|{
literal|"pld"
block|,
literal|0xf450f000
block|,
literal|0
block|,
name|ARM_EXT_V5E
block|,
name|do_pld
block|}
block|,
block|{
literal|"ldrd"
block|,
literal|0xe00000d0
block|,
literal|3
block|,
name|ARM_EXT_V5E
block|,
name|do_ldrd
block|}
block|,
block|{
literal|"strd"
block|,
literal|0xe00000f0
block|,
literal|3
block|,
name|ARM_EXT_V5E
block|,
name|do_ldrd
block|}
block|,
block|{
literal|"mcrr"
block|,
literal|0xec400000
block|,
literal|4
block|,
name|ARM_EXT_V5E
block|,
name|do_co_reg2c
block|}
block|,
block|{
literal|"mrrc"
block|,
literal|0xec500000
block|,
literal|4
block|,
name|ARM_EXT_V5E
block|,
name|do_co_reg2c
block|}
block|,
comment|/*  ARM Architecture 5TEJ.  */
block|{
literal|"bxj"
block|,
literal|0xe12fff20
block|,
literal|3
block|,
name|ARM_EXT_V5J
block|,
name|do_bxj
block|}
block|,
comment|/* Core FPA instruction set (V1).  */
block|{
literal|"wfs"
block|,
literal|0xee200110
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_ctrl
block|}
block|,
block|{
literal|"rfs"
block|,
literal|0xee300110
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_ctrl
block|}
block|,
block|{
literal|"wfc"
block|,
literal|0xee400110
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_ctrl
block|}
block|,
block|{
literal|"rfc"
block|,
literal|0xee500110
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_ctrl
block|}
block|,
block|{
literal|"ldfs"
block|,
literal|0xec100100
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_ldst
block|}
block|,
block|{
literal|"ldfd"
block|,
literal|0xec108100
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_ldst
block|}
block|,
block|{
literal|"ldfe"
block|,
literal|0xec500100
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_ldst
block|}
block|,
block|{
literal|"ldfp"
block|,
literal|0xec508100
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_ldst
block|}
block|,
block|{
literal|"stfs"
block|,
literal|0xec000100
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_ldst
block|}
block|,
block|{
literal|"stfd"
block|,
literal|0xec008100
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_ldst
block|}
block|,
block|{
literal|"stfe"
block|,
literal|0xec400100
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_ldst
block|}
block|,
block|{
literal|"stfp"
block|,
literal|0xec408100
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_ldst
block|}
block|,
block|{
literal|"mvfs"
block|,
literal|0xee008100
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_monadic
block|}
block|,
block|{
literal|"mvfsp"
block|,
literal|0xee008120
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_monadic
block|}
block|,
block|{
literal|"mvfsm"
block|,
literal|0xee008140
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_monadic
block|}
block|,
block|{
literal|"mvfsz"
block|,
literal|0xee008160
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_monadic
block|}
block|,
block|{
literal|"mvfd"
block|,
literal|0xee008180
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_monadic
block|}
block|,
block|{
literal|"mvfdp"
block|,
literal|0xee0081a0
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_monadic
block|}
block|,
block|{
literal|"mvfdm"
block|,
literal|0xee0081c0
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_monadic
block|}
block|,
block|{
literal|"mvfdz"
block|,
literal|0xee0081e0
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_monadic
block|}
block|,
block|{
literal|"mvfe"
block|,
literal|0xee088100
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_monadic
block|}
block|,
block|{
literal|"mvfep"
block|,
literal|0xee088120
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_monadic
block|}
block|,
block|{
literal|"mvfem"
block|,
literal|0xee088140
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_monadic
block|}
block|,
block|{
literal|"mvfez"
block|,
literal|0xee088160
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_monadic
block|}
block|,
block|{
literal|"mnfs"
block|,
literal|0xee108100
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_monadic
block|}
block|,
block|{
literal|"mnfsp"
block|,
literal|0xee108120
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_monadic
block|}
block|,
block|{
literal|"mnfsm"
block|,
literal|0xee108140
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_monadic
block|}
block|,
block|{
literal|"mnfsz"
block|,
literal|0xee108160
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_monadic
block|}
block|,
block|{
literal|"mnfd"
block|,
literal|0xee108180
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_monadic
block|}
block|,
block|{
literal|"mnfdp"
block|,
literal|0xee1081a0
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_monadic
block|}
block|,
block|{
literal|"mnfdm"
block|,
literal|0xee1081c0
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_monadic
block|}
block|,
block|{
literal|"mnfdz"
block|,
literal|0xee1081e0
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_monadic
block|}
block|,
block|{
literal|"mnfe"
block|,
literal|0xee188100
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_monadic
block|}
block|,
block|{
literal|"mnfep"
block|,
literal|0xee188120
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_monadic
block|}
block|,
block|{
literal|"mnfem"
block|,
literal|0xee188140
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_monadic
block|}
block|,
block|{
literal|"mnfez"
block|,
literal|0xee188160
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_monadic
block|}
block|,
block|{
literal|"abss"
block|,
literal|0xee208100
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_monadic
block|}
block|,
block|{
literal|"abssp"
block|,
literal|0xee208120
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_monadic
block|}
block|,
block|{
literal|"abssm"
block|,
literal|0xee208140
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_monadic
block|}
block|,
block|{
literal|"abssz"
block|,
literal|0xee208160
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_monadic
block|}
block|,
block|{
literal|"absd"
block|,
literal|0xee208180
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_monadic
block|}
block|,
block|{
literal|"absdp"
block|,
literal|0xee2081a0
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_monadic
block|}
block|,
block|{
literal|"absdm"
block|,
literal|0xee2081c0
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_monadic
block|}
block|,
block|{
literal|"absdz"
block|,
literal|0xee2081e0
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_monadic
block|}
block|,
block|{
literal|"abse"
block|,
literal|0xee288100
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_monadic
block|}
block|,
block|{
literal|"absep"
block|,
literal|0xee288120
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_monadic
block|}
block|,
block|{
literal|"absem"
block|,
literal|0xee288140
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_monadic
block|}
block|,
block|{
literal|"absez"
block|,
literal|0xee288160
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_monadic
block|}
block|,
block|{
literal|"rnds"
block|,
literal|0xee308100
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_monadic
block|}
block|,
block|{
literal|"rndsp"
block|,
literal|0xee308120
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_monadic
block|}
block|,
block|{
literal|"rndsm"
block|,
literal|0xee308140
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_monadic
block|}
block|,
block|{
literal|"rndsz"
block|,
literal|0xee308160
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_monadic
block|}
block|,
block|{
literal|"rndd"
block|,
literal|0xee308180
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_monadic
block|}
block|,
block|{
literal|"rnddp"
block|,
literal|0xee3081a0
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_monadic
block|}
block|,
block|{
literal|"rnddm"
block|,
literal|0xee3081c0
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_monadic
block|}
block|,
block|{
literal|"rnddz"
block|,
literal|0xee3081e0
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_monadic
block|}
block|,
block|{
literal|"rnde"
block|,
literal|0xee388100
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_monadic
block|}
block|,
block|{
literal|"rndep"
block|,
literal|0xee388120
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_monadic
block|}
block|,
block|{
literal|"rndem"
block|,
literal|0xee388140
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_monadic
block|}
block|,
block|{
literal|"rndez"
block|,
literal|0xee388160
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_monadic
block|}
block|,
block|{
literal|"sqts"
block|,
literal|0xee408100
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_monadic
block|}
block|,
block|{
literal|"sqtsp"
block|,
literal|0xee408120
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_monadic
block|}
block|,
block|{
literal|"sqtsm"
block|,
literal|0xee408140
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_monadic
block|}
block|,
block|{
literal|"sqtsz"
block|,
literal|0xee408160
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_monadic
block|}
block|,
block|{
literal|"sqtd"
block|,
literal|0xee408180
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_monadic
block|}
block|,
block|{
literal|"sqtdp"
block|,
literal|0xee4081a0
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_monadic
block|}
block|,
block|{
literal|"sqtdm"
block|,
literal|0xee4081c0
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_monadic
block|}
block|,
block|{
literal|"sqtdz"
block|,
literal|0xee4081e0
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_monadic
block|}
block|,
block|{
literal|"sqte"
block|,
literal|0xee488100
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_monadic
block|}
block|,
block|{
literal|"sqtep"
block|,
literal|0xee488120
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_monadic
block|}
block|,
block|{
literal|"sqtem"
block|,
literal|0xee488140
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_monadic
block|}
block|,
block|{
literal|"sqtez"
block|,
literal|0xee488160
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_monadic
block|}
block|,
block|{
literal|"logs"
block|,
literal|0xee508100
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_monadic
block|}
block|,
block|{
literal|"logsp"
block|,
literal|0xee508120
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_monadic
block|}
block|,
block|{
literal|"logsm"
block|,
literal|0xee508140
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_monadic
block|}
block|,
block|{
literal|"logsz"
block|,
literal|0xee508160
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_monadic
block|}
block|,
block|{
literal|"logd"
block|,
literal|0xee508180
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_monadic
block|}
block|,
block|{
literal|"logdp"
block|,
literal|0xee5081a0
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_monadic
block|}
block|,
block|{
literal|"logdm"
block|,
literal|0xee5081c0
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_monadic
block|}
block|,
block|{
literal|"logdz"
block|,
literal|0xee5081e0
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_monadic
block|}
block|,
block|{
literal|"loge"
block|,
literal|0xee588100
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_monadic
block|}
block|,
block|{
literal|"logep"
block|,
literal|0xee588120
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_monadic
block|}
block|,
block|{
literal|"logem"
block|,
literal|0xee588140
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_monadic
block|}
block|,
block|{
literal|"logez"
block|,
literal|0xee588160
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_monadic
block|}
block|,
block|{
literal|"lgns"
block|,
literal|0xee608100
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_monadic
block|}
block|,
block|{
literal|"lgnsp"
block|,
literal|0xee608120
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_monadic
block|}
block|,
block|{
literal|"lgnsm"
block|,
literal|0xee608140
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_monadic
block|}
block|,
block|{
literal|"lgnsz"
block|,
literal|0xee608160
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_monadic
block|}
block|,
block|{
literal|"lgnd"
block|,
literal|0xee608180
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_monadic
block|}
block|,
block|{
literal|"lgndp"
block|,
literal|0xee6081a0
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_monadic
block|}
block|,
block|{
literal|"lgndm"
block|,
literal|0xee6081c0
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_monadic
block|}
block|,
block|{
literal|"lgndz"
block|,
literal|0xee6081e0
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_monadic
block|}
block|,
block|{
literal|"lgne"
block|,
literal|0xee688100
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_monadic
block|}
block|,
block|{
literal|"lgnep"
block|,
literal|0xee688120
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_monadic
block|}
block|,
block|{
literal|"lgnem"
block|,
literal|0xee688140
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_monadic
block|}
block|,
block|{
literal|"lgnez"
block|,
literal|0xee688160
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_monadic
block|}
block|,
block|{
literal|"exps"
block|,
literal|0xee708100
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_monadic
block|}
block|,
block|{
literal|"expsp"
block|,
literal|0xee708120
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_monadic
block|}
block|,
block|{
literal|"expsm"
block|,
literal|0xee708140
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_monadic
block|}
block|,
block|{
literal|"expsz"
block|,
literal|0xee708160
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_monadic
block|}
block|,
block|{
literal|"expd"
block|,
literal|0xee708180
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_monadic
block|}
block|,
block|{
literal|"expdp"
block|,
literal|0xee7081a0
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_monadic
block|}
block|,
block|{
literal|"expdm"
block|,
literal|0xee7081c0
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_monadic
block|}
block|,
block|{
literal|"expdz"
block|,
literal|0xee7081e0
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_monadic
block|}
block|,
block|{
literal|"expe"
block|,
literal|0xee788100
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_monadic
block|}
block|,
block|{
literal|"expep"
block|,
literal|0xee788120
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_monadic
block|}
block|,
block|{
literal|"expem"
block|,
literal|0xee788140
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_monadic
block|}
block|,
block|{
literal|"expdz"
block|,
literal|0xee788160
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_monadic
block|}
block|,
block|{
literal|"sins"
block|,
literal|0xee808100
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_monadic
block|}
block|,
block|{
literal|"sinsp"
block|,
literal|0xee808120
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_monadic
block|}
block|,
block|{
literal|"sinsm"
block|,
literal|0xee808140
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_monadic
block|}
block|,
block|{
literal|"sinsz"
block|,
literal|0xee808160
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_monadic
block|}
block|,
block|{
literal|"sind"
block|,
literal|0xee808180
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_monadic
block|}
block|,
block|{
literal|"sindp"
block|,
literal|0xee8081a0
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_monadic
block|}
block|,
block|{
literal|"sindm"
block|,
literal|0xee8081c0
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_monadic
block|}
block|,
block|{
literal|"sindz"
block|,
literal|0xee8081e0
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_monadic
block|}
block|,
block|{
literal|"sine"
block|,
literal|0xee888100
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_monadic
block|}
block|,
block|{
literal|"sinep"
block|,
literal|0xee888120
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_monadic
block|}
block|,
block|{
literal|"sinem"
block|,
literal|0xee888140
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_monadic
block|}
block|,
block|{
literal|"sinez"
block|,
literal|0xee888160
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_monadic
block|}
block|,
block|{
literal|"coss"
block|,
literal|0xee908100
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_monadic
block|}
block|,
block|{
literal|"cossp"
block|,
literal|0xee908120
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_monadic
block|}
block|,
block|{
literal|"cossm"
block|,
literal|0xee908140
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_monadic
block|}
block|,
block|{
literal|"cossz"
block|,
literal|0xee908160
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_monadic
block|}
block|,
block|{
literal|"cosd"
block|,
literal|0xee908180
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_monadic
block|}
block|,
block|{
literal|"cosdp"
block|,
literal|0xee9081a0
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_monadic
block|}
block|,
block|{
literal|"cosdm"
block|,
literal|0xee9081c0
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_monadic
block|}
block|,
block|{
literal|"cosdz"
block|,
literal|0xee9081e0
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_monadic
block|}
block|,
block|{
literal|"cose"
block|,
literal|0xee988100
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_monadic
block|}
block|,
block|{
literal|"cosep"
block|,
literal|0xee988120
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_monadic
block|}
block|,
block|{
literal|"cosem"
block|,
literal|0xee988140
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_monadic
block|}
block|,
block|{
literal|"cosez"
block|,
literal|0xee988160
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_monadic
block|}
block|,
block|{
literal|"tans"
block|,
literal|0xeea08100
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_monadic
block|}
block|,
block|{
literal|"tansp"
block|,
literal|0xeea08120
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_monadic
block|}
block|,
block|{
literal|"tansm"
block|,
literal|0xeea08140
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_monadic
block|}
block|,
block|{
literal|"tansz"
block|,
literal|0xeea08160
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_monadic
block|}
block|,
block|{
literal|"tand"
block|,
literal|0xeea08180
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_monadic
block|}
block|,
block|{
literal|"tandp"
block|,
literal|0xeea081a0
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_monadic
block|}
block|,
block|{
literal|"tandm"
block|,
literal|0xeea081c0
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_monadic
block|}
block|,
block|{
literal|"tandz"
block|,
literal|0xeea081e0
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_monadic
block|}
block|,
block|{
literal|"tane"
block|,
literal|0xeea88100
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_monadic
block|}
block|,
block|{
literal|"tanep"
block|,
literal|0xeea88120
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_monadic
block|}
block|,
block|{
literal|"tanem"
block|,
literal|0xeea88140
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_monadic
block|}
block|,
block|{
literal|"tanez"
block|,
literal|0xeea88160
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_monadic
block|}
block|,
block|{
literal|"asns"
block|,
literal|0xeeb08100
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_monadic
block|}
block|,
block|{
literal|"asnsp"
block|,
literal|0xeeb08120
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_monadic
block|}
block|,
block|{
literal|"asnsm"
block|,
literal|0xeeb08140
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_monadic
block|}
block|,
block|{
literal|"asnsz"
block|,
literal|0xeeb08160
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_monadic
block|}
block|,
block|{
literal|"asnd"
block|,
literal|0xeeb08180
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_monadic
block|}
block|,
block|{
literal|"asndp"
block|,
literal|0xeeb081a0
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_monadic
block|}
block|,
block|{
literal|"asndm"
block|,
literal|0xeeb081c0
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_monadic
block|}
block|,
block|{
literal|"asndz"
block|,
literal|0xeeb081e0
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_monadic
block|}
block|,
block|{
literal|"asne"
block|,
literal|0xeeb88100
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_monadic
block|}
block|,
block|{
literal|"asnep"
block|,
literal|0xeeb88120
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_monadic
block|}
block|,
block|{
literal|"asnem"
block|,
literal|0xeeb88140
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_monadic
block|}
block|,
block|{
literal|"asnez"
block|,
literal|0xeeb88160
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_monadic
block|}
block|,
block|{
literal|"acss"
block|,
literal|0xeec08100
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_monadic
block|}
block|,
block|{
literal|"acssp"
block|,
literal|0xeec08120
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_monadic
block|}
block|,
block|{
literal|"acssm"
block|,
literal|0xeec08140
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_monadic
block|}
block|,
block|{
literal|"acssz"
block|,
literal|0xeec08160
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_monadic
block|}
block|,
block|{
literal|"acsd"
block|,
literal|0xeec08180
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_monadic
block|}
block|,
block|{
literal|"acsdp"
block|,
literal|0xeec081a0
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_monadic
block|}
block|,
block|{
literal|"acsdm"
block|,
literal|0xeec081c0
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_monadic
block|}
block|,
block|{
literal|"acsdz"
block|,
literal|0xeec081e0
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_monadic
block|}
block|,
block|{
literal|"acse"
block|,
literal|0xeec88100
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_monadic
block|}
block|,
block|{
literal|"acsep"
block|,
literal|0xeec88120
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_monadic
block|}
block|,
block|{
literal|"acsem"
block|,
literal|0xeec88140
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_monadic
block|}
block|,
block|{
literal|"acsez"
block|,
literal|0xeec88160
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_monadic
block|}
block|,
block|{
literal|"atns"
block|,
literal|0xeed08100
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_monadic
block|}
block|,
block|{
literal|"atnsp"
block|,
literal|0xeed08120
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_monadic
block|}
block|,
block|{
literal|"atnsm"
block|,
literal|0xeed08140
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_monadic
block|}
block|,
block|{
literal|"atnsz"
block|,
literal|0xeed08160
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_monadic
block|}
block|,
block|{
literal|"atnd"
block|,
literal|0xeed08180
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_monadic
block|}
block|,
block|{
literal|"atndp"
block|,
literal|0xeed081a0
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_monadic
block|}
block|,
block|{
literal|"atndm"
block|,
literal|0xeed081c0
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_monadic
block|}
block|,
block|{
literal|"atndz"
block|,
literal|0xeed081e0
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_monadic
block|}
block|,
block|{
literal|"atne"
block|,
literal|0xeed88100
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_monadic
block|}
block|,
block|{
literal|"atnep"
block|,
literal|0xeed88120
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_monadic
block|}
block|,
block|{
literal|"atnem"
block|,
literal|0xeed88140
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_monadic
block|}
block|,
block|{
literal|"atnez"
block|,
literal|0xeed88160
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_monadic
block|}
block|,
block|{
literal|"urds"
block|,
literal|0xeee08100
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_monadic
block|}
block|,
block|{
literal|"urdsp"
block|,
literal|0xeee08120
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_monadic
block|}
block|,
block|{
literal|"urdsm"
block|,
literal|0xeee08140
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_monadic
block|}
block|,
block|{
literal|"urdsz"
block|,
literal|0xeee08160
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_monadic
block|}
block|,
block|{
literal|"urdd"
block|,
literal|0xeee08180
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_monadic
block|}
block|,
block|{
literal|"urddp"
block|,
literal|0xeee081a0
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_monadic
block|}
block|,
block|{
literal|"urddm"
block|,
literal|0xeee081c0
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_monadic
block|}
block|,
block|{
literal|"urddz"
block|,
literal|0xeee081e0
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_monadic
block|}
block|,
block|{
literal|"urde"
block|,
literal|0xeee88100
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_monadic
block|}
block|,
block|{
literal|"urdep"
block|,
literal|0xeee88120
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_monadic
block|}
block|,
block|{
literal|"urdem"
block|,
literal|0xeee88140
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_monadic
block|}
block|,
block|{
literal|"urdez"
block|,
literal|0xeee88160
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_monadic
block|}
block|,
block|{
literal|"nrms"
block|,
literal|0xeef08100
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_monadic
block|}
block|,
block|{
literal|"nrmsp"
block|,
literal|0xeef08120
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_monadic
block|}
block|,
block|{
literal|"nrmsm"
block|,
literal|0xeef08140
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_monadic
block|}
block|,
block|{
literal|"nrmsz"
block|,
literal|0xeef08160
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_monadic
block|}
block|,
block|{
literal|"nrmd"
block|,
literal|0xeef08180
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_monadic
block|}
block|,
block|{
literal|"nrmdp"
block|,
literal|0xeef081a0
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_monadic
block|}
block|,
block|{
literal|"nrmdm"
block|,
literal|0xeef081c0
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_monadic
block|}
block|,
block|{
literal|"nrmdz"
block|,
literal|0xeef081e0
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_monadic
block|}
block|,
block|{
literal|"nrme"
block|,
literal|0xeef88100
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_monadic
block|}
block|,
block|{
literal|"nrmep"
block|,
literal|0xeef88120
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_monadic
block|}
block|,
block|{
literal|"nrmem"
block|,
literal|0xeef88140
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_monadic
block|}
block|,
block|{
literal|"nrmez"
block|,
literal|0xeef88160
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_monadic
block|}
block|,
block|{
literal|"adfs"
block|,
literal|0xee000100
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_dyadic
block|}
block|,
block|{
literal|"adfsp"
block|,
literal|0xee000120
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_dyadic
block|}
block|,
block|{
literal|"adfsm"
block|,
literal|0xee000140
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_dyadic
block|}
block|,
block|{
literal|"adfsz"
block|,
literal|0xee000160
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_dyadic
block|}
block|,
block|{
literal|"adfd"
block|,
literal|0xee000180
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_dyadic
block|}
block|,
block|{
literal|"adfdp"
block|,
literal|0xee0001a0
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_dyadic
block|}
block|,
block|{
literal|"adfdm"
block|,
literal|0xee0001c0
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_dyadic
block|}
block|,
block|{
literal|"adfdz"
block|,
literal|0xee0001e0
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_dyadic
block|}
block|,
block|{
literal|"adfe"
block|,
literal|0xee080100
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_dyadic
block|}
block|,
block|{
literal|"adfep"
block|,
literal|0xee080120
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_dyadic
block|}
block|,
block|{
literal|"adfem"
block|,
literal|0xee080140
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_dyadic
block|}
block|,
block|{
literal|"adfez"
block|,
literal|0xee080160
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_dyadic
block|}
block|,
block|{
literal|"sufs"
block|,
literal|0xee200100
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_dyadic
block|}
block|,
block|{
literal|"sufsp"
block|,
literal|0xee200120
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_dyadic
block|}
block|,
block|{
literal|"sufsm"
block|,
literal|0xee200140
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_dyadic
block|}
block|,
block|{
literal|"sufsz"
block|,
literal|0xee200160
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_dyadic
block|}
block|,
block|{
literal|"sufd"
block|,
literal|0xee200180
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_dyadic
block|}
block|,
block|{
literal|"sufdp"
block|,
literal|0xee2001a0
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_dyadic
block|}
block|,
block|{
literal|"sufdm"
block|,
literal|0xee2001c0
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_dyadic
block|}
block|,
block|{
literal|"sufdz"
block|,
literal|0xee2001e0
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_dyadic
block|}
block|,
block|{
literal|"sufe"
block|,
literal|0xee280100
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_dyadic
block|}
block|,
block|{
literal|"sufep"
block|,
literal|0xee280120
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_dyadic
block|}
block|,
block|{
literal|"sufem"
block|,
literal|0xee280140
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_dyadic
block|}
block|,
block|{
literal|"sufez"
block|,
literal|0xee280160
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_dyadic
block|}
block|,
block|{
literal|"rsfs"
block|,
literal|0xee300100
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_dyadic
block|}
block|,
block|{
literal|"rsfsp"
block|,
literal|0xee300120
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_dyadic
block|}
block|,
block|{
literal|"rsfsm"
block|,
literal|0xee300140
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_dyadic
block|}
block|,
block|{
literal|"rsfsz"
block|,
literal|0xee300160
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_dyadic
block|}
block|,
block|{
literal|"rsfd"
block|,
literal|0xee300180
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_dyadic
block|}
block|,
block|{
literal|"rsfdp"
block|,
literal|0xee3001a0
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_dyadic
block|}
block|,
block|{
literal|"rsfdm"
block|,
literal|0xee3001c0
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_dyadic
block|}
block|,
block|{
literal|"rsfdz"
block|,
literal|0xee3001e0
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_dyadic
block|}
block|,
block|{
literal|"rsfe"
block|,
literal|0xee380100
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_dyadic
block|}
block|,
block|{
literal|"rsfep"
block|,
literal|0xee380120
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_dyadic
block|}
block|,
block|{
literal|"rsfem"
block|,
literal|0xee380140
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_dyadic
block|}
block|,
block|{
literal|"rsfez"
block|,
literal|0xee380160
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_dyadic
block|}
block|,
block|{
literal|"mufs"
block|,
literal|0xee100100
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_dyadic
block|}
block|,
block|{
literal|"mufsp"
block|,
literal|0xee100120
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_dyadic
block|}
block|,
block|{
literal|"mufsm"
block|,
literal|0xee100140
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_dyadic
block|}
block|,
block|{
literal|"mufsz"
block|,
literal|0xee100160
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_dyadic
block|}
block|,
block|{
literal|"mufd"
block|,
literal|0xee100180
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_dyadic
block|}
block|,
block|{
literal|"mufdp"
block|,
literal|0xee1001a0
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_dyadic
block|}
block|,
block|{
literal|"mufdm"
block|,
literal|0xee1001c0
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_dyadic
block|}
block|,
block|{
literal|"mufdz"
block|,
literal|0xee1001e0
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_dyadic
block|}
block|,
block|{
literal|"mufe"
block|,
literal|0xee180100
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_dyadic
block|}
block|,
block|{
literal|"mufep"
block|,
literal|0xee180120
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_dyadic
block|}
block|,
block|{
literal|"mufem"
block|,
literal|0xee180140
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_dyadic
block|}
block|,
block|{
literal|"mufez"
block|,
literal|0xee180160
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_dyadic
block|}
block|,
block|{
literal|"dvfs"
block|,
literal|0xee400100
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_dyadic
block|}
block|,
block|{
literal|"dvfsp"
block|,
literal|0xee400120
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_dyadic
block|}
block|,
block|{
literal|"dvfsm"
block|,
literal|0xee400140
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_dyadic
block|}
block|,
block|{
literal|"dvfsz"
block|,
literal|0xee400160
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_dyadic
block|}
block|,
block|{
literal|"dvfd"
block|,
literal|0xee400180
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_dyadic
block|}
block|,
block|{
literal|"dvfdp"
block|,
literal|0xee4001a0
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_dyadic
block|}
block|,
block|{
literal|"dvfdm"
block|,
literal|0xee4001c0
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_dyadic
block|}
block|,
block|{
literal|"dvfdz"
block|,
literal|0xee4001e0
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_dyadic
block|}
block|,
block|{
literal|"dvfe"
block|,
literal|0xee480100
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_dyadic
block|}
block|,
block|{
literal|"dvfep"
block|,
literal|0xee480120
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_dyadic
block|}
block|,
block|{
literal|"dvfem"
block|,
literal|0xee480140
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_dyadic
block|}
block|,
block|{
literal|"dvfez"
block|,
literal|0xee480160
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_dyadic
block|}
block|,
block|{
literal|"rdfs"
block|,
literal|0xee500100
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_dyadic
block|}
block|,
block|{
literal|"rdfsp"
block|,
literal|0xee500120
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_dyadic
block|}
block|,
block|{
literal|"rdfsm"
block|,
literal|0xee500140
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_dyadic
block|}
block|,
block|{
literal|"rdfsz"
block|,
literal|0xee500160
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_dyadic
block|}
block|,
block|{
literal|"rdfd"
block|,
literal|0xee500180
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_dyadic
block|}
block|,
block|{
literal|"rdfdp"
block|,
literal|0xee5001a0
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_dyadic
block|}
block|,
block|{
literal|"rdfdm"
block|,
literal|0xee5001c0
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_dyadic
block|}
block|,
block|{
literal|"rdfdz"
block|,
literal|0xee5001e0
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_dyadic
block|}
block|,
block|{
literal|"rdfe"
block|,
literal|0xee580100
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_dyadic
block|}
block|,
block|{
literal|"rdfep"
block|,
literal|0xee580120
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_dyadic
block|}
block|,
block|{
literal|"rdfem"
block|,
literal|0xee580140
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_dyadic
block|}
block|,
block|{
literal|"rdfez"
block|,
literal|0xee580160
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_dyadic
block|}
block|,
block|{
literal|"pows"
block|,
literal|0xee600100
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_dyadic
block|}
block|,
block|{
literal|"powsp"
block|,
literal|0xee600120
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_dyadic
block|}
block|,
block|{
literal|"powsm"
block|,
literal|0xee600140
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_dyadic
block|}
block|,
block|{
literal|"powsz"
block|,
literal|0xee600160
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_dyadic
block|}
block|,
block|{
literal|"powd"
block|,
literal|0xee600180
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_dyadic
block|}
block|,
block|{
literal|"powdp"
block|,
literal|0xee6001a0
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_dyadic
block|}
block|,
block|{
literal|"powdm"
block|,
literal|0xee6001c0
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_dyadic
block|}
block|,
block|{
literal|"powdz"
block|,
literal|0xee6001e0
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_dyadic
block|}
block|,
block|{
literal|"powe"
block|,
literal|0xee680100
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_dyadic
block|}
block|,
block|{
literal|"powep"
block|,
literal|0xee680120
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_dyadic
block|}
block|,
block|{
literal|"powem"
block|,
literal|0xee680140
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_dyadic
block|}
block|,
block|{
literal|"powez"
block|,
literal|0xee680160
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_dyadic
block|}
block|,
block|{
literal|"rpws"
block|,
literal|0xee700100
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_dyadic
block|}
block|,
block|{
literal|"rpwsp"
block|,
literal|0xee700120
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_dyadic
block|}
block|,
block|{
literal|"rpwsm"
block|,
literal|0xee700140
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_dyadic
block|}
block|,
block|{
literal|"rpwsz"
block|,
literal|0xee700160
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_dyadic
block|}
block|,
block|{
literal|"rpwd"
block|,
literal|0xee700180
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_dyadic
block|}
block|,
block|{
literal|"rpwdp"
block|,
literal|0xee7001a0
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_dyadic
block|}
block|,
block|{
literal|"rpwdm"
block|,
literal|0xee7001c0
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_dyadic
block|}
block|,
block|{
literal|"rpwdz"
block|,
literal|0xee7001e0
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_dyadic
block|}
block|,
block|{
literal|"rpwe"
block|,
literal|0xee780100
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_dyadic
block|}
block|,
block|{
literal|"rpwep"
block|,
literal|0xee780120
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_dyadic
block|}
block|,
block|{
literal|"rpwem"
block|,
literal|0xee780140
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_dyadic
block|}
block|,
block|{
literal|"rpwez"
block|,
literal|0xee780160
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_dyadic
block|}
block|,
block|{
literal|"rmfs"
block|,
literal|0xee800100
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_dyadic
block|}
block|,
block|{
literal|"rmfsp"
block|,
literal|0xee800120
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_dyadic
block|}
block|,
block|{
literal|"rmfsm"
block|,
literal|0xee800140
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_dyadic
block|}
block|,
block|{
literal|"rmfsz"
block|,
literal|0xee800160
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_dyadic
block|}
block|,
block|{
literal|"rmfd"
block|,
literal|0xee800180
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_dyadic
block|}
block|,
block|{
literal|"rmfdp"
block|,
literal|0xee8001a0
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_dyadic
block|}
block|,
block|{
literal|"rmfdm"
block|,
literal|0xee8001c0
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_dyadic
block|}
block|,
block|{
literal|"rmfdz"
block|,
literal|0xee8001e0
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_dyadic
block|}
block|,
block|{
literal|"rmfe"
block|,
literal|0xee880100
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_dyadic
block|}
block|,
block|{
literal|"rmfep"
block|,
literal|0xee880120
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_dyadic
block|}
block|,
block|{
literal|"rmfem"
block|,
literal|0xee880140
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_dyadic
block|}
block|,
block|{
literal|"rmfez"
block|,
literal|0xee880160
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_dyadic
block|}
block|,
block|{
literal|"fmls"
block|,
literal|0xee900100
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_dyadic
block|}
block|,
block|{
literal|"fmlsp"
block|,
literal|0xee900120
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_dyadic
block|}
block|,
block|{
literal|"fmlsm"
block|,
literal|0xee900140
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_dyadic
block|}
block|,
block|{
literal|"fmlsz"
block|,
literal|0xee900160
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_dyadic
block|}
block|,
block|{
literal|"fmld"
block|,
literal|0xee900180
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_dyadic
block|}
block|,
block|{
literal|"fmldp"
block|,
literal|0xee9001a0
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_dyadic
block|}
block|,
block|{
literal|"fmldm"
block|,
literal|0xee9001c0
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_dyadic
block|}
block|,
block|{
literal|"fmldz"
block|,
literal|0xee9001e0
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_dyadic
block|}
block|,
block|{
literal|"fmle"
block|,
literal|0xee980100
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_dyadic
block|}
block|,
block|{
literal|"fmlep"
block|,
literal|0xee980120
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_dyadic
block|}
block|,
block|{
literal|"fmlem"
block|,
literal|0xee980140
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_dyadic
block|}
block|,
block|{
literal|"fmlez"
block|,
literal|0xee980160
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_dyadic
block|}
block|,
block|{
literal|"fdvs"
block|,
literal|0xeea00100
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_dyadic
block|}
block|,
block|{
literal|"fdvsp"
block|,
literal|0xeea00120
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_dyadic
block|}
block|,
block|{
literal|"fdvsm"
block|,
literal|0xeea00140
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_dyadic
block|}
block|,
block|{
literal|"fdvsz"
block|,
literal|0xeea00160
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_dyadic
block|}
block|,
block|{
literal|"fdvd"
block|,
literal|0xeea00180
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_dyadic
block|}
block|,
block|{
literal|"fdvdp"
block|,
literal|0xeea001a0
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_dyadic
block|}
block|,
block|{
literal|"fdvdm"
block|,
literal|0xeea001c0
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_dyadic
block|}
block|,
block|{
literal|"fdvdz"
block|,
literal|0xeea001e0
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_dyadic
block|}
block|,
block|{
literal|"fdve"
block|,
literal|0xeea80100
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_dyadic
block|}
block|,
block|{
literal|"fdvep"
block|,
literal|0xeea80120
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_dyadic
block|}
block|,
block|{
literal|"fdvem"
block|,
literal|0xeea80140
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_dyadic
block|}
block|,
block|{
literal|"fdvez"
block|,
literal|0xeea80160
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_dyadic
block|}
block|,
block|{
literal|"frds"
block|,
literal|0xeeb00100
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_dyadic
block|}
block|,
block|{
literal|"frdsp"
block|,
literal|0xeeb00120
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_dyadic
block|}
block|,
block|{
literal|"frdsm"
block|,
literal|0xeeb00140
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_dyadic
block|}
block|,
block|{
literal|"frdsz"
block|,
literal|0xeeb00160
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_dyadic
block|}
block|,
block|{
literal|"frdd"
block|,
literal|0xeeb00180
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_dyadic
block|}
block|,
block|{
literal|"frddp"
block|,
literal|0xeeb001a0
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_dyadic
block|}
block|,
block|{
literal|"frddm"
block|,
literal|0xeeb001c0
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_dyadic
block|}
block|,
block|{
literal|"frddz"
block|,
literal|0xeeb001e0
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_dyadic
block|}
block|,
block|{
literal|"frde"
block|,
literal|0xeeb80100
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_dyadic
block|}
block|,
block|{
literal|"frdep"
block|,
literal|0xeeb80120
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_dyadic
block|}
block|,
block|{
literal|"frdem"
block|,
literal|0xeeb80140
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_dyadic
block|}
block|,
block|{
literal|"frdez"
block|,
literal|0xeeb80160
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_dyadic
block|}
block|,
block|{
literal|"pols"
block|,
literal|0xeec00100
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_dyadic
block|}
block|,
block|{
literal|"polsp"
block|,
literal|0xeec00120
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_dyadic
block|}
block|,
block|{
literal|"polsm"
block|,
literal|0xeec00140
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_dyadic
block|}
block|,
block|{
literal|"polsz"
block|,
literal|0xeec00160
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_dyadic
block|}
block|,
block|{
literal|"pold"
block|,
literal|0xeec00180
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_dyadic
block|}
block|,
block|{
literal|"poldp"
block|,
literal|0xeec001a0
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_dyadic
block|}
block|,
block|{
literal|"poldm"
block|,
literal|0xeec001c0
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_dyadic
block|}
block|,
block|{
literal|"poldz"
block|,
literal|0xeec001e0
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_dyadic
block|}
block|,
block|{
literal|"pole"
block|,
literal|0xeec80100
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_dyadic
block|}
block|,
block|{
literal|"polep"
block|,
literal|0xeec80120
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_dyadic
block|}
block|,
block|{
literal|"polem"
block|,
literal|0xeec80140
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_dyadic
block|}
block|,
block|{
literal|"polez"
block|,
literal|0xeec80160
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_dyadic
block|}
block|,
block|{
literal|"cmf"
block|,
literal|0xee90f110
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_cmp
block|}
block|,
block|{
literal|"cmfe"
block|,
literal|0xeed0f110
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_cmp
block|}
block|,
block|{
literal|"cnf"
block|,
literal|0xeeb0f110
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_cmp
block|}
block|,
block|{
literal|"cnfe"
block|,
literal|0xeef0f110
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_cmp
block|}
block|,
comment|/* The FPA10 data sheet suggests that the 'E' of cmfe/cnfe should      not be an optional suffix, but part of the instruction.  To be      compatible, we accept either.  */
block|{
literal|"cmfe"
block|,
literal|0xeed0f110
block|,
literal|4
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_cmp
block|}
block|,
block|{
literal|"cnfe"
block|,
literal|0xeef0f110
block|,
literal|4
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_cmp
block|}
block|,
block|{
literal|"flts"
block|,
literal|0xee000110
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_from_reg
block|}
block|,
block|{
literal|"fltsp"
block|,
literal|0xee000130
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_from_reg
block|}
block|,
block|{
literal|"fltsm"
block|,
literal|0xee000150
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_from_reg
block|}
block|,
block|{
literal|"fltsz"
block|,
literal|0xee000170
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_from_reg
block|}
block|,
block|{
literal|"fltd"
block|,
literal|0xee000190
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_from_reg
block|}
block|,
block|{
literal|"fltdp"
block|,
literal|0xee0001b0
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_from_reg
block|}
block|,
block|{
literal|"fltdm"
block|,
literal|0xee0001d0
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_from_reg
block|}
block|,
block|{
literal|"fltdz"
block|,
literal|0xee0001f0
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_from_reg
block|}
block|,
block|{
literal|"flte"
block|,
literal|0xee080110
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_from_reg
block|}
block|,
block|{
literal|"fltep"
block|,
literal|0xee080130
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_from_reg
block|}
block|,
block|{
literal|"fltem"
block|,
literal|0xee080150
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_from_reg
block|}
block|,
block|{
literal|"fltez"
block|,
literal|0xee080170
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_from_reg
block|}
block|,
comment|/* The implementation of the FIX instruction is broken on some      assemblers, in that it accepts a precision specifier as well as a      rounding specifier, despite the fact that this is meaningless.      To be more compatible, we accept it as well, though of course it      does not set any bits.  */
block|{
literal|"fix"
block|,
literal|0xee100110
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_to_reg
block|}
block|,
block|{
literal|"fixp"
block|,
literal|0xee100130
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_to_reg
block|}
block|,
block|{
literal|"fixm"
block|,
literal|0xee100150
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_to_reg
block|}
block|,
block|{
literal|"fixz"
block|,
literal|0xee100170
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_to_reg
block|}
block|,
block|{
literal|"fixsp"
block|,
literal|0xee100130
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_to_reg
block|}
block|,
block|{
literal|"fixsm"
block|,
literal|0xee100150
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_to_reg
block|}
block|,
block|{
literal|"fixsz"
block|,
literal|0xee100170
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_to_reg
block|}
block|,
block|{
literal|"fixdp"
block|,
literal|0xee100130
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_to_reg
block|}
block|,
block|{
literal|"fixdm"
block|,
literal|0xee100150
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_to_reg
block|}
block|,
block|{
literal|"fixdz"
block|,
literal|0xee100170
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_to_reg
block|}
block|,
block|{
literal|"fixep"
block|,
literal|0xee100130
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_to_reg
block|}
block|,
block|{
literal|"fixem"
block|,
literal|0xee100150
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_to_reg
block|}
block|,
block|{
literal|"fixez"
block|,
literal|0xee100170
block|,
literal|3
block|,
name|FPU_FPA_EXT_V1
block|,
name|do_fpa_to_reg
block|}
block|,
comment|/* Instructions that were new with the real FPA, call them V2.  */
block|{
literal|"lfm"
block|,
literal|0xec100200
block|,
literal|3
block|,
name|FPU_FPA_EXT_V2
block|,
name|do_fpa_ldmstm
block|}
block|,
block|{
literal|"lfmfd"
block|,
literal|0xec900200
block|,
literal|3
block|,
name|FPU_FPA_EXT_V2
block|,
name|do_fpa_ldmstm
block|}
block|,
block|{
literal|"lfmea"
block|,
literal|0xed100200
block|,
literal|3
block|,
name|FPU_FPA_EXT_V2
block|,
name|do_fpa_ldmstm
block|}
block|,
block|{
literal|"sfm"
block|,
literal|0xec000200
block|,
literal|3
block|,
name|FPU_FPA_EXT_V2
block|,
name|do_fpa_ldmstm
block|}
block|,
block|{
literal|"sfmfd"
block|,
literal|0xed000200
block|,
literal|3
block|,
name|FPU_FPA_EXT_V2
block|,
name|do_fpa_ldmstm
block|}
block|,
block|{
literal|"sfmea"
block|,
literal|0xec800200
block|,
literal|3
block|,
name|FPU_FPA_EXT_V2
block|,
name|do_fpa_ldmstm
block|}
block|,
comment|/* VFP V1xD (single precision).  */
comment|/* Moves and type conversions.  */
block|{
literal|"fcpys"
block|,
literal|0xeeb00a40
block|,
literal|5
block|,
name|FPU_VFP_EXT_V1xD
block|,
name|do_vfp_sp_monadic
block|}
block|,
block|{
literal|"fmrs"
block|,
literal|0xee100a10
block|,
literal|4
block|,
name|FPU_VFP_EXT_V1xD
block|,
name|do_vfp_reg_from_sp
block|}
block|,
block|{
literal|"fmsr"
block|,
literal|0xee000a10
block|,
literal|4
block|,
name|FPU_VFP_EXT_V1xD
block|,
name|do_vfp_sp_from_reg
block|}
block|,
block|{
literal|"fmstat"
block|,
literal|0xeef1fa10
block|,
literal|6
block|,
name|FPU_VFP_EXT_V1xD
block|,
name|do_empty
block|}
block|,
block|{
literal|"fsitos"
block|,
literal|0xeeb80ac0
block|,
literal|6
block|,
name|FPU_VFP_EXT_V1xD
block|,
name|do_vfp_sp_monadic
block|}
block|,
block|{
literal|"fuitos"
block|,
literal|0xeeb80a40
block|,
literal|6
block|,
name|FPU_VFP_EXT_V1xD
block|,
name|do_vfp_sp_monadic
block|}
block|,
block|{
literal|"ftosis"
block|,
literal|0xeebd0a40
block|,
literal|6
block|,
name|FPU_VFP_EXT_V1xD
block|,
name|do_vfp_sp_monadic
block|}
block|,
block|{
literal|"ftosizs"
block|,
literal|0xeebd0ac0
block|,
literal|7
block|,
name|FPU_VFP_EXT_V1xD
block|,
name|do_vfp_sp_monadic
block|}
block|,
block|{
literal|"ftouis"
block|,
literal|0xeebc0a40
block|,
literal|6
block|,
name|FPU_VFP_EXT_V1xD
block|,
name|do_vfp_sp_monadic
block|}
block|,
block|{
literal|"ftouizs"
block|,
literal|0xeebc0ac0
block|,
literal|7
block|,
name|FPU_VFP_EXT_V1xD
block|,
name|do_vfp_sp_monadic
block|}
block|,
block|{
literal|"fmrx"
block|,
literal|0xeef00a10
block|,
literal|4
block|,
name|FPU_VFP_EXT_V1xD
block|,
name|do_vfp_reg_from_ctrl
block|}
block|,
block|{
literal|"fmxr"
block|,
literal|0xeee00a10
block|,
literal|4
block|,
name|FPU_VFP_EXT_V1xD
block|,
name|do_vfp_ctrl_from_reg
block|}
block|,
comment|/* Memory operations.  */
block|{
literal|"flds"
block|,
literal|0xed100a00
block|,
literal|4
block|,
name|FPU_VFP_EXT_V1xD
block|,
name|do_vfp_sp_ldst
block|}
block|,
block|{
literal|"fsts"
block|,
literal|0xed000a00
block|,
literal|4
block|,
name|FPU_VFP_EXT_V1xD
block|,
name|do_vfp_sp_ldst
block|}
block|,
block|{
literal|"fldmias"
block|,
literal|0xec900a00
block|,
literal|7
block|,
name|FPU_VFP_EXT_V1xD
block|,
name|do_vfp_sp_ldstmia
block|}
block|,
block|{
literal|"fldmfds"
block|,
literal|0xec900a00
block|,
literal|7
block|,
name|FPU_VFP_EXT_V1xD
block|,
name|do_vfp_sp_ldstmia
block|}
block|,
block|{
literal|"fldmdbs"
block|,
literal|0xed300a00
block|,
literal|7
block|,
name|FPU_VFP_EXT_V1xD
block|,
name|do_vfp_sp_ldstmdb
block|}
block|,
block|{
literal|"fldmeas"
block|,
literal|0xed300a00
block|,
literal|7
block|,
name|FPU_VFP_EXT_V1xD
block|,
name|do_vfp_sp_ldstmdb
block|}
block|,
block|{
literal|"fldmiax"
block|,
literal|0xec900b00
block|,
literal|7
block|,
name|FPU_VFP_EXT_V1xD
block|,
name|do_vfp_xp_ldstmia
block|}
block|,
block|{
literal|"fldmfdx"
block|,
literal|0xec900b00
block|,
literal|7
block|,
name|FPU_VFP_EXT_V1xD
block|,
name|do_vfp_xp_ldstmia
block|}
block|,
block|{
literal|"fldmdbx"
block|,
literal|0xed300b00
block|,
literal|7
block|,
name|FPU_VFP_EXT_V1xD
block|,
name|do_vfp_xp_ldstmdb
block|}
block|,
block|{
literal|"fldmeax"
block|,
literal|0xed300b00
block|,
literal|7
block|,
name|FPU_VFP_EXT_V1xD
block|,
name|do_vfp_xp_ldstmdb
block|}
block|,
block|{
literal|"fstmias"
block|,
literal|0xec800a00
block|,
literal|7
block|,
name|FPU_VFP_EXT_V1xD
block|,
name|do_vfp_sp_ldstmia
block|}
block|,
block|{
literal|"fstmeas"
block|,
literal|0xec800a00
block|,
literal|7
block|,
name|FPU_VFP_EXT_V1xD
block|,
name|do_vfp_sp_ldstmia
block|}
block|,
block|{
literal|"fstmdbs"
block|,
literal|0xed200a00
block|,
literal|7
block|,
name|FPU_VFP_EXT_V1xD
block|,
name|do_vfp_sp_ldstmdb
block|}
block|,
block|{
literal|"fstmfds"
block|,
literal|0xed200a00
block|,
literal|7
block|,
name|FPU_VFP_EXT_V1xD
block|,
name|do_vfp_sp_ldstmdb
block|}
block|,
block|{
literal|"fstmiax"
block|,
literal|0xec800b00
block|,
literal|7
block|,
name|FPU_VFP_EXT_V1xD
block|,
name|do_vfp_xp_ldstmia
block|}
block|,
block|{
literal|"fstmeax"
block|,
literal|0xec800b00
block|,
literal|7
block|,
name|FPU_VFP_EXT_V1xD
block|,
name|do_vfp_xp_ldstmia
block|}
block|,
block|{
literal|"fstmdbx"
block|,
literal|0xed200b00
block|,
literal|7
block|,
name|FPU_VFP_EXT_V1xD
block|,
name|do_vfp_xp_ldstmdb
block|}
block|,
block|{
literal|"fstmfdx"
block|,
literal|0xed200b00
block|,
literal|7
block|,
name|FPU_VFP_EXT_V1xD
block|,
name|do_vfp_xp_ldstmdb
block|}
block|,
comment|/* Monadic operations.  */
block|{
literal|"fabss"
block|,
literal|0xeeb00ac0
block|,
literal|5
block|,
name|FPU_VFP_EXT_V1xD
block|,
name|do_vfp_sp_monadic
block|}
block|,
block|{
literal|"fnegs"
block|,
literal|0xeeb10a40
block|,
literal|5
block|,
name|FPU_VFP_EXT_V1xD
block|,
name|do_vfp_sp_monadic
block|}
block|,
block|{
literal|"fsqrts"
block|,
literal|0xeeb10ac0
block|,
literal|6
block|,
name|FPU_VFP_EXT_V1xD
block|,
name|do_vfp_sp_monadic
block|}
block|,
comment|/* Dyadic operations.  */
block|{
literal|"fadds"
block|,
literal|0xee300a00
block|,
literal|5
block|,
name|FPU_VFP_EXT_V1xD
block|,
name|do_vfp_sp_dyadic
block|}
block|,
block|{
literal|"fsubs"
block|,
literal|0xee300a40
block|,
literal|5
block|,
name|FPU_VFP_EXT_V1xD
block|,
name|do_vfp_sp_dyadic
block|}
block|,
block|{
literal|"fmuls"
block|,
literal|0xee200a00
block|,
literal|5
block|,
name|FPU_VFP_EXT_V1xD
block|,
name|do_vfp_sp_dyadic
block|}
block|,
block|{
literal|"fdivs"
block|,
literal|0xee800a00
block|,
literal|5
block|,
name|FPU_VFP_EXT_V1xD
block|,
name|do_vfp_sp_dyadic
block|}
block|,
block|{
literal|"fmacs"
block|,
literal|0xee000a00
block|,
literal|5
block|,
name|FPU_VFP_EXT_V1xD
block|,
name|do_vfp_sp_dyadic
block|}
block|,
block|{
literal|"fmscs"
block|,
literal|0xee100a00
block|,
literal|5
block|,
name|FPU_VFP_EXT_V1xD
block|,
name|do_vfp_sp_dyadic
block|}
block|,
block|{
literal|"fnmuls"
block|,
literal|0xee200a40
block|,
literal|6
block|,
name|FPU_VFP_EXT_V1xD
block|,
name|do_vfp_sp_dyadic
block|}
block|,
block|{
literal|"fnmacs"
block|,
literal|0xee000a40
block|,
literal|6
block|,
name|FPU_VFP_EXT_V1xD
block|,
name|do_vfp_sp_dyadic
block|}
block|,
block|{
literal|"fnmscs"
block|,
literal|0xee100a40
block|,
literal|6
block|,
name|FPU_VFP_EXT_V1xD
block|,
name|do_vfp_sp_dyadic
block|}
block|,
comment|/* Comparisons.  */
block|{
literal|"fcmps"
block|,
literal|0xeeb40a40
block|,
literal|5
block|,
name|FPU_VFP_EXT_V1xD
block|,
name|do_vfp_sp_monadic
block|}
block|,
block|{
literal|"fcmpzs"
block|,
literal|0xeeb50a40
block|,
literal|6
block|,
name|FPU_VFP_EXT_V1xD
block|,
name|do_vfp_sp_compare_z
block|}
block|,
block|{
literal|"fcmpes"
block|,
literal|0xeeb40ac0
block|,
literal|6
block|,
name|FPU_VFP_EXT_V1xD
block|,
name|do_vfp_sp_monadic
block|}
block|,
block|{
literal|"fcmpezs"
block|,
literal|0xeeb50ac0
block|,
literal|7
block|,
name|FPU_VFP_EXT_V1xD
block|,
name|do_vfp_sp_compare_z
block|}
block|,
comment|/* VFP V1 (Double precision).  */
comment|/* Moves and type conversions.  */
block|{
literal|"fcpyd"
block|,
literal|0xeeb00b40
block|,
literal|5
block|,
name|FPU_VFP_EXT_V1
block|,
name|do_vfp_dp_monadic
block|}
block|,
block|{
literal|"fcvtds"
block|,
literal|0xeeb70ac0
block|,
literal|6
block|,
name|FPU_VFP_EXT_V1
block|,
name|do_vfp_dp_sp_cvt
block|}
block|,
block|{
literal|"fcvtsd"
block|,
literal|0xeeb70bc0
block|,
literal|6
block|,
name|FPU_VFP_EXT_V1
block|,
name|do_vfp_sp_dp_cvt
block|}
block|,
block|{
literal|"fmdhr"
block|,
literal|0xee200b10
block|,
literal|5
block|,
name|FPU_VFP_EXT_V1
block|,
name|do_vfp_dp_from_reg
block|}
block|,
block|{
literal|"fmdlr"
block|,
literal|0xee000b10
block|,
literal|5
block|,
name|FPU_VFP_EXT_V1
block|,
name|do_vfp_dp_from_reg
block|}
block|,
block|{
literal|"fmrdh"
block|,
literal|0xee300b10
block|,
literal|5
block|,
name|FPU_VFP_EXT_V1
block|,
name|do_vfp_reg_from_dp
block|}
block|,
block|{
literal|"fmrdl"
block|,
literal|0xee100b10
block|,
literal|5
block|,
name|FPU_VFP_EXT_V1
block|,
name|do_vfp_reg_from_dp
block|}
block|,
block|{
literal|"fsitod"
block|,
literal|0xeeb80bc0
block|,
literal|6
block|,
name|FPU_VFP_EXT_V1
block|,
name|do_vfp_dp_sp_cvt
block|}
block|,
block|{
literal|"fuitod"
block|,
literal|0xeeb80b40
block|,
literal|6
block|,
name|FPU_VFP_EXT_V1
block|,
name|do_vfp_dp_sp_cvt
block|}
block|,
block|{
literal|"ftosid"
block|,
literal|0xeebd0b40
block|,
literal|6
block|,
name|FPU_VFP_EXT_V1
block|,
name|do_vfp_sp_dp_cvt
block|}
block|,
block|{
literal|"ftosizd"
block|,
literal|0xeebd0bc0
block|,
literal|7
block|,
name|FPU_VFP_EXT_V1
block|,
name|do_vfp_sp_dp_cvt
block|}
block|,
block|{
literal|"ftouid"
block|,
literal|0xeebc0b40
block|,
literal|6
block|,
name|FPU_VFP_EXT_V1
block|,
name|do_vfp_sp_dp_cvt
block|}
block|,
block|{
literal|"ftouizd"
block|,
literal|0xeebc0bc0
block|,
literal|7
block|,
name|FPU_VFP_EXT_V1
block|,
name|do_vfp_sp_dp_cvt
block|}
block|,
comment|/* Memory operations.  */
block|{
literal|"fldd"
block|,
literal|0xed100b00
block|,
literal|4
block|,
name|FPU_VFP_EXT_V1
block|,
name|do_vfp_dp_ldst
block|}
block|,
block|{
literal|"fstd"
block|,
literal|0xed000b00
block|,
literal|4
block|,
name|FPU_VFP_EXT_V1
block|,
name|do_vfp_dp_ldst
block|}
block|,
block|{
literal|"fldmiad"
block|,
literal|0xec900b00
block|,
literal|7
block|,
name|FPU_VFP_EXT_V1
block|,
name|do_vfp_dp_ldstmia
block|}
block|,
block|{
literal|"fldmfdd"
block|,
literal|0xec900b00
block|,
literal|7
block|,
name|FPU_VFP_EXT_V1
block|,
name|do_vfp_dp_ldstmia
block|}
block|,
block|{
literal|"fldmdbd"
block|,
literal|0xed300b00
block|,
literal|7
block|,
name|FPU_VFP_EXT_V1
block|,
name|do_vfp_dp_ldstmdb
block|}
block|,
block|{
literal|"fldmead"
block|,
literal|0xed300b00
block|,
literal|7
block|,
name|FPU_VFP_EXT_V1
block|,
name|do_vfp_dp_ldstmdb
block|}
block|,
block|{
literal|"fstmiad"
block|,
literal|0xec800b00
block|,
literal|7
block|,
name|FPU_VFP_EXT_V1
block|,
name|do_vfp_dp_ldstmia
block|}
block|,
block|{
literal|"fstmead"
block|,
literal|0xec800b00
block|,
literal|7
block|,
name|FPU_VFP_EXT_V1
block|,
name|do_vfp_dp_ldstmia
block|}
block|,
block|{
literal|"fstmdbd"
block|,
literal|0xed200b00
block|,
literal|7
block|,
name|FPU_VFP_EXT_V1
block|,
name|do_vfp_dp_ldstmdb
block|}
block|,
block|{
literal|"fstmfdd"
block|,
literal|0xed200b00
block|,
literal|7
block|,
name|FPU_VFP_EXT_V1
block|,
name|do_vfp_dp_ldstmdb
block|}
block|,
comment|/* Monadic operations.  */
block|{
literal|"fabsd"
block|,
literal|0xeeb00bc0
block|,
literal|5
block|,
name|FPU_VFP_EXT_V1
block|,
name|do_vfp_dp_monadic
block|}
block|,
block|{
literal|"fnegd"
block|,
literal|0xeeb10b40
block|,
literal|5
block|,
name|FPU_VFP_EXT_V1
block|,
name|do_vfp_dp_monadic
block|}
block|,
block|{
literal|"fsqrtd"
block|,
literal|0xeeb10bc0
block|,
literal|6
block|,
name|FPU_VFP_EXT_V1
block|,
name|do_vfp_dp_monadic
block|}
block|,
comment|/* Dyadic operations.  */
block|{
literal|"faddd"
block|,
literal|0xee300b00
block|,
literal|5
block|,
name|FPU_VFP_EXT_V1
block|,
name|do_vfp_dp_dyadic
block|}
block|,
block|{
literal|"fsubd"
block|,
literal|0xee300b40
block|,
literal|5
block|,
name|FPU_VFP_EXT_V1
block|,
name|do_vfp_dp_dyadic
block|}
block|,
block|{
literal|"fmuld"
block|,
literal|0xee200b00
block|,
literal|5
block|,
name|FPU_VFP_EXT_V1
block|,
name|do_vfp_dp_dyadic
block|}
block|,
block|{
literal|"fdivd"
block|,
literal|0xee800b00
block|,
literal|5
block|,
name|FPU_VFP_EXT_V1
block|,
name|do_vfp_dp_dyadic
block|}
block|,
block|{
literal|"fmacd"
block|,
literal|0xee000b00
block|,
literal|5
block|,
name|FPU_VFP_EXT_V1
block|,
name|do_vfp_dp_dyadic
block|}
block|,
block|{
literal|"fmscd"
block|,
literal|0xee100b00
block|,
literal|5
block|,
name|FPU_VFP_EXT_V1
block|,
name|do_vfp_dp_dyadic
block|}
block|,
block|{
literal|"fnmuld"
block|,
literal|0xee200b40
block|,
literal|6
block|,
name|FPU_VFP_EXT_V1
block|,
name|do_vfp_dp_dyadic
block|}
block|,
block|{
literal|"fnmacd"
block|,
literal|0xee000b40
block|,
literal|6
block|,
name|FPU_VFP_EXT_V1
block|,
name|do_vfp_dp_dyadic
block|}
block|,
block|{
literal|"fnmscd"
block|,
literal|0xee100b40
block|,
literal|6
block|,
name|FPU_VFP_EXT_V1
block|,
name|do_vfp_dp_dyadic
block|}
block|,
comment|/* Comparisons.  */
block|{
literal|"fcmpd"
block|,
literal|0xeeb40b40
block|,
literal|5
block|,
name|FPU_VFP_EXT_V1
block|,
name|do_vfp_dp_monadic
block|}
block|,
block|{
literal|"fcmpzd"
block|,
literal|0xeeb50b40
block|,
literal|6
block|,
name|FPU_VFP_EXT_V1
block|,
name|do_vfp_dp_compare_z
block|}
block|,
block|{
literal|"fcmped"
block|,
literal|0xeeb40bc0
block|,
literal|6
block|,
name|FPU_VFP_EXT_V1
block|,
name|do_vfp_dp_monadic
block|}
block|,
block|{
literal|"fcmpezd"
block|,
literal|0xeeb50bc0
block|,
literal|7
block|,
name|FPU_VFP_EXT_V1
block|,
name|do_vfp_dp_compare_z
block|}
block|,
comment|/* VFP V2.  */
block|{
literal|"fmsrr"
block|,
literal|0xec400a10
block|,
literal|5
block|,
name|FPU_VFP_EXT_V2
block|,
name|do_vfp_sp_reg2
block|}
block|,
block|{
literal|"fmrrs"
block|,
literal|0xec500a10
block|,
literal|5
block|,
name|FPU_VFP_EXT_V2
block|,
name|do_vfp_sp_reg2
block|}
block|,
block|{
literal|"fmdrr"
block|,
literal|0xec400b10
block|,
literal|5
block|,
name|FPU_VFP_EXT_V2
block|,
name|do_vfp_dp_from_reg2
block|}
block|,
block|{
literal|"fmrrd"
block|,
literal|0xec500b10
block|,
literal|5
block|,
name|FPU_VFP_EXT_V2
block|,
name|do_vfp_reg2_from_dp
block|}
block|,
comment|/* Intel XScale extensions to ARM V5 ISA.  (All use CP0).  */
block|{
literal|"mia"
block|,
literal|0xee200010
block|,
literal|3
block|,
name|ARM_CEXT_XSCALE
block|,
name|do_xsc_mia
block|}
block|,
block|{
literal|"miaph"
block|,
literal|0xee280010
block|,
literal|5
block|,
name|ARM_CEXT_XSCALE
block|,
name|do_xsc_mia
block|}
block|,
block|{
literal|"miabb"
block|,
literal|0xee2c0010
block|,
literal|5
block|,
name|ARM_CEXT_XSCALE
block|,
name|do_xsc_mia
block|}
block|,
block|{
literal|"miabt"
block|,
literal|0xee2d0010
block|,
literal|5
block|,
name|ARM_CEXT_XSCALE
block|,
name|do_xsc_mia
block|}
block|,
block|{
literal|"miatb"
block|,
literal|0xee2e0010
block|,
literal|5
block|,
name|ARM_CEXT_XSCALE
block|,
name|do_xsc_mia
block|}
block|,
block|{
literal|"miatt"
block|,
literal|0xee2f0010
block|,
literal|5
block|,
name|ARM_CEXT_XSCALE
block|,
name|do_xsc_mia
block|}
block|,
block|{
literal|"mar"
block|,
literal|0xec400000
block|,
literal|3
block|,
name|ARM_CEXT_XSCALE
block|,
name|do_xsc_mar
block|}
block|,
block|{
literal|"mra"
block|,
literal|0xec500000
block|,
literal|3
block|,
name|ARM_CEXT_XSCALE
block|,
name|do_xsc_mra
block|}
block|,
comment|/* Cirrus Maverick instructions.  */
block|{
literal|"cfldrs"
block|,
literal|0xec100400
block|,
literal|6
block|,
name|ARM_CEXT_MAVERICK
block|,
name|do_mav_ldst_1
block|}
block|,
block|{
literal|"cfldrd"
block|,
literal|0xec500400
block|,
literal|6
block|,
name|ARM_CEXT_MAVERICK
block|,
name|do_mav_ldst_2
block|}
block|,
block|{
literal|"cfldr32"
block|,
literal|0xec100500
block|,
literal|7
block|,
name|ARM_CEXT_MAVERICK
block|,
name|do_mav_ldst_3
block|}
block|,
block|{
literal|"cfldr64"
block|,
literal|0xec500500
block|,
literal|7
block|,
name|ARM_CEXT_MAVERICK
block|,
name|do_mav_ldst_4
block|}
block|,
block|{
literal|"cfstrs"
block|,
literal|0xec000400
block|,
literal|6
block|,
name|ARM_CEXT_MAVERICK
block|,
name|do_mav_ldst_1
block|}
block|,
block|{
literal|"cfstrd"
block|,
literal|0xec400400
block|,
literal|6
block|,
name|ARM_CEXT_MAVERICK
block|,
name|do_mav_ldst_2
block|}
block|,
block|{
literal|"cfstr32"
block|,
literal|0xec000500
block|,
literal|7
block|,
name|ARM_CEXT_MAVERICK
block|,
name|do_mav_ldst_3
block|}
block|,
block|{
literal|"cfstr64"
block|,
literal|0xec400500
block|,
literal|7
block|,
name|ARM_CEXT_MAVERICK
block|,
name|do_mav_ldst_4
block|}
block|,
block|{
literal|"cfmvsr"
block|,
literal|0xee000450
block|,
literal|6
block|,
name|ARM_CEXT_MAVERICK
block|,
name|do_mav_binops_2a
block|}
block|,
block|{
literal|"cfmvrs"
block|,
literal|0xee100450
block|,
literal|6
block|,
name|ARM_CEXT_MAVERICK
block|,
name|do_mav_binops_1a
block|}
block|,
block|{
literal|"cfmvdlr"
block|,
literal|0xee000410
block|,
literal|7
block|,
name|ARM_CEXT_MAVERICK
block|,
name|do_mav_binops_2b
block|}
block|,
block|{
literal|"cfmvrdl"
block|,
literal|0xee100410
block|,
literal|7
block|,
name|ARM_CEXT_MAVERICK
block|,
name|do_mav_binops_1b
block|}
block|,
block|{
literal|"cfmvdhr"
block|,
literal|0xee000430
block|,
literal|7
block|,
name|ARM_CEXT_MAVERICK
block|,
name|do_mav_binops_2b
block|}
block|,
block|{
literal|"cfmvrdh"
block|,
literal|0xee100430
block|,
literal|7
block|,
name|ARM_CEXT_MAVERICK
block|,
name|do_mav_binops_1b
block|}
block|,
block|{
literal|"cfmv64lr"
block|,
literal|0xee000510
block|,
literal|8
block|,
name|ARM_CEXT_MAVERICK
block|,
name|do_mav_binops_2c
block|}
block|,
block|{
literal|"cfmvr64l"
block|,
literal|0xee100510
block|,
literal|8
block|,
name|ARM_CEXT_MAVERICK
block|,
name|do_mav_binops_1c
block|}
block|,
block|{
literal|"cfmv64hr"
block|,
literal|0xee000530
block|,
literal|8
block|,
name|ARM_CEXT_MAVERICK
block|,
name|do_mav_binops_2c
block|}
block|,
block|{
literal|"cfmvr64h"
block|,
literal|0xee100530
block|,
literal|8
block|,
name|ARM_CEXT_MAVERICK
block|,
name|do_mav_binops_1c
block|}
block|,
block|{
literal|"cfmval32"
block|,
literal|0xee100610
block|,
literal|8
block|,
name|ARM_CEXT_MAVERICK
block|,
name|do_mav_binops_3a
block|}
block|,
block|{
literal|"cfmv32al"
block|,
literal|0xee000610
block|,
literal|8
block|,
name|ARM_CEXT_MAVERICK
block|,
name|do_mav_binops_3b
block|}
block|,
block|{
literal|"cfmvam32"
block|,
literal|0xee100630
block|,
literal|8
block|,
name|ARM_CEXT_MAVERICK
block|,
name|do_mav_binops_3a
block|}
block|,
block|{
literal|"cfmv32am"
block|,
literal|0xee000630
block|,
literal|8
block|,
name|ARM_CEXT_MAVERICK
block|,
name|do_mav_binops_3b
block|}
block|,
block|{
literal|"cfmvah32"
block|,
literal|0xee100650
block|,
literal|8
block|,
name|ARM_CEXT_MAVERICK
block|,
name|do_mav_binops_3a
block|}
block|,
block|{
literal|"cfmv32ah"
block|,
literal|0xee000650
block|,
literal|8
block|,
name|ARM_CEXT_MAVERICK
block|,
name|do_mav_binops_3b
block|}
block|,
block|{
literal|"cfmva32"
block|,
literal|0xee100670
block|,
literal|7
block|,
name|ARM_CEXT_MAVERICK
block|,
name|do_mav_binops_3a
block|}
block|,
block|{
literal|"cfmv32a"
block|,
literal|0xee000670
block|,
literal|7
block|,
name|ARM_CEXT_MAVERICK
block|,
name|do_mav_binops_3b
block|}
block|,
block|{
literal|"cfmva64"
block|,
literal|0xee100690
block|,
literal|7
block|,
name|ARM_CEXT_MAVERICK
block|,
name|do_mav_binops_3c
block|}
block|,
block|{
literal|"cfmv64a"
block|,
literal|0xee000690
block|,
literal|7
block|,
name|ARM_CEXT_MAVERICK
block|,
name|do_mav_binops_3d
block|}
block|,
block|{
literal|"cfmvsc32"
block|,
literal|0xee1006b0
block|,
literal|8
block|,
name|ARM_CEXT_MAVERICK
block|,
name|do_mav_dspsc_1
block|}
block|,
block|{
literal|"cfmv32sc"
block|,
literal|0xee0006b0
block|,
literal|8
block|,
name|ARM_CEXT_MAVERICK
block|,
name|do_mav_dspsc_2
block|}
block|,
block|{
literal|"cfcpys"
block|,
literal|0xee000400
block|,
literal|6
block|,
name|ARM_CEXT_MAVERICK
block|,
name|do_mav_binops_1d
block|}
block|,
block|{
literal|"cfcpyd"
block|,
literal|0xee000420
block|,
literal|6
block|,
name|ARM_CEXT_MAVERICK
block|,
name|do_mav_binops_1e
block|}
block|,
block|{
literal|"cfcvtsd"
block|,
literal|0xee000460
block|,
literal|7
block|,
name|ARM_CEXT_MAVERICK
block|,
name|do_mav_binops_1f
block|}
block|,
block|{
literal|"cfcvtds"
block|,
literal|0xee000440
block|,
literal|7
block|,
name|ARM_CEXT_MAVERICK
block|,
name|do_mav_binops_1g
block|}
block|,
block|{
literal|"cfcvt32s"
block|,
literal|0xee000480
block|,
literal|8
block|,
name|ARM_CEXT_MAVERICK
block|,
name|do_mav_binops_1h
block|}
block|,
block|{
literal|"cfcvt32d"
block|,
literal|0xee0004a0
block|,
literal|8
block|,
name|ARM_CEXT_MAVERICK
block|,
name|do_mav_binops_1i
block|}
block|,
block|{
literal|"cfcvt64s"
block|,
literal|0xee0004c0
block|,
literal|8
block|,
name|ARM_CEXT_MAVERICK
block|,
name|do_mav_binops_1j
block|}
block|,
block|{
literal|"cfcvt64d"
block|,
literal|0xee0004e0
block|,
literal|8
block|,
name|ARM_CEXT_MAVERICK
block|,
name|do_mav_binops_1k
block|}
block|,
block|{
literal|"cfcvts32"
block|,
literal|0xee100580
block|,
literal|8
block|,
name|ARM_CEXT_MAVERICK
block|,
name|do_mav_binops_1l
block|}
block|,
block|{
literal|"cfcvtd32"
block|,
literal|0xee1005a0
block|,
literal|8
block|,
name|ARM_CEXT_MAVERICK
block|,
name|do_mav_binops_1m
block|}
block|,
block|{
literal|"cftruncs32"
block|,
literal|0xee1005c0
block|,
literal|10
block|,
name|ARM_CEXT_MAVERICK
block|,
name|do_mav_binops_1l
block|}
block|,
block|{
literal|"cftruncd32"
block|,
literal|0xee1005e0
block|,
literal|10
block|,
name|ARM_CEXT_MAVERICK
block|,
name|do_mav_binops_1m
block|}
block|,
block|{
literal|"cfrshl32"
block|,
literal|0xee000550
block|,
literal|8
block|,
name|ARM_CEXT_MAVERICK
block|,
name|do_mav_triple_4a
block|}
block|,
block|{
literal|"cfrshl64"
block|,
literal|0xee000570
block|,
literal|8
block|,
name|ARM_CEXT_MAVERICK
block|,
name|do_mav_triple_4b
block|}
block|,
block|{
literal|"cfsh32"
block|,
literal|0xee000500
block|,
literal|6
block|,
name|ARM_CEXT_MAVERICK
block|,
name|do_mav_shift_1
block|}
block|,
block|{
literal|"cfsh64"
block|,
literal|0xee200500
block|,
literal|6
block|,
name|ARM_CEXT_MAVERICK
block|,
name|do_mav_shift_2
block|}
block|,
block|{
literal|"cfcmps"
block|,
literal|0xee100490
block|,
literal|6
block|,
name|ARM_CEXT_MAVERICK
block|,
name|do_mav_triple_5a
block|}
block|,
block|{
literal|"cfcmpd"
block|,
literal|0xee1004b0
block|,
literal|6
block|,
name|ARM_CEXT_MAVERICK
block|,
name|do_mav_triple_5b
block|}
block|,
block|{
literal|"cfcmp32"
block|,
literal|0xee100590
block|,
literal|7
block|,
name|ARM_CEXT_MAVERICK
block|,
name|do_mav_triple_5c
block|}
block|,
block|{
literal|"cfcmp64"
block|,
literal|0xee1005b0
block|,
literal|7
block|,
name|ARM_CEXT_MAVERICK
block|,
name|do_mav_triple_5d
block|}
block|,
block|{
literal|"cfabss"
block|,
literal|0xee300400
block|,
literal|6
block|,
name|ARM_CEXT_MAVERICK
block|,
name|do_mav_binops_1d
block|}
block|,
block|{
literal|"cfabsd"
block|,
literal|0xee300420
block|,
literal|6
block|,
name|ARM_CEXT_MAVERICK
block|,
name|do_mav_binops_1e
block|}
block|,
block|{
literal|"cfnegs"
block|,
literal|0xee300440
block|,
literal|6
block|,
name|ARM_CEXT_MAVERICK
block|,
name|do_mav_binops_1d
block|}
block|,
block|{
literal|"cfnegd"
block|,
literal|0xee300460
block|,
literal|6
block|,
name|ARM_CEXT_MAVERICK
block|,
name|do_mav_binops_1e
block|}
block|,
block|{
literal|"cfadds"
block|,
literal|0xee300480
block|,
literal|6
block|,
name|ARM_CEXT_MAVERICK
block|,
name|do_mav_triple_5e
block|}
block|,
block|{
literal|"cfaddd"
block|,
literal|0xee3004a0
block|,
literal|6
block|,
name|ARM_CEXT_MAVERICK
block|,
name|do_mav_triple_5f
block|}
block|,
block|{
literal|"cfsubs"
block|,
literal|0xee3004c0
block|,
literal|6
block|,
name|ARM_CEXT_MAVERICK
block|,
name|do_mav_triple_5e
block|}
block|,
block|{
literal|"cfsubd"
block|,
literal|0xee3004e0
block|,
literal|6
block|,
name|ARM_CEXT_MAVERICK
block|,
name|do_mav_triple_5f
block|}
block|,
block|{
literal|"cfmuls"
block|,
literal|0xee100400
block|,
literal|6
block|,
name|ARM_CEXT_MAVERICK
block|,
name|do_mav_triple_5e
block|}
block|,
block|{
literal|"cfmuld"
block|,
literal|0xee100420
block|,
literal|6
block|,
name|ARM_CEXT_MAVERICK
block|,
name|do_mav_triple_5f
block|}
block|,
block|{
literal|"cfabs32"
block|,
literal|0xee300500
block|,
literal|7
block|,
name|ARM_CEXT_MAVERICK
block|,
name|do_mav_binops_1n
block|}
block|,
block|{
literal|"cfabs64"
block|,
literal|0xee300520
block|,
literal|7
block|,
name|ARM_CEXT_MAVERICK
block|,
name|do_mav_binops_1o
block|}
block|,
block|{
literal|"cfneg32"
block|,
literal|0xee300540
block|,
literal|7
block|,
name|ARM_CEXT_MAVERICK
block|,
name|do_mav_binops_1n
block|}
block|,
block|{
literal|"cfneg64"
block|,
literal|0xee300560
block|,
literal|7
block|,
name|ARM_CEXT_MAVERICK
block|,
name|do_mav_binops_1o
block|}
block|,
block|{
literal|"cfadd32"
block|,
literal|0xee300580
block|,
literal|7
block|,
name|ARM_CEXT_MAVERICK
block|,
name|do_mav_triple_5g
block|}
block|,
block|{
literal|"cfadd64"
block|,
literal|0xee3005a0
block|,
literal|7
block|,
name|ARM_CEXT_MAVERICK
block|,
name|do_mav_triple_5h
block|}
block|,
block|{
literal|"cfsub32"
block|,
literal|0xee3005c0
block|,
literal|7
block|,
name|ARM_CEXT_MAVERICK
block|,
name|do_mav_triple_5g
block|}
block|,
block|{
literal|"cfsub64"
block|,
literal|0xee3005e0
block|,
literal|7
block|,
name|ARM_CEXT_MAVERICK
block|,
name|do_mav_triple_5h
block|}
block|,
block|{
literal|"cfmul32"
block|,
literal|0xee100500
block|,
literal|7
block|,
name|ARM_CEXT_MAVERICK
block|,
name|do_mav_triple_5g
block|}
block|,
block|{
literal|"cfmul64"
block|,
literal|0xee100520
block|,
literal|7
block|,
name|ARM_CEXT_MAVERICK
block|,
name|do_mav_triple_5h
block|}
block|,
block|{
literal|"cfmac32"
block|,
literal|0xee100540
block|,
literal|7
block|,
name|ARM_CEXT_MAVERICK
block|,
name|do_mav_triple_5g
block|}
block|,
block|{
literal|"cfmsc32"
block|,
literal|0xee100560
block|,
literal|7
block|,
name|ARM_CEXT_MAVERICK
block|,
name|do_mav_triple_5g
block|}
block|,
block|{
literal|"cfmadd32"
block|,
literal|0xee000600
block|,
literal|8
block|,
name|ARM_CEXT_MAVERICK
block|,
name|do_mav_quad_6a
block|}
block|,
block|{
literal|"cfmsub32"
block|,
literal|0xee100600
block|,
literal|8
block|,
name|ARM_CEXT_MAVERICK
block|,
name|do_mav_quad_6a
block|}
block|,
block|{
literal|"cfmadda32"
block|,
literal|0xee200600
block|,
literal|9
block|,
name|ARM_CEXT_MAVERICK
block|,
name|do_mav_quad_6b
block|}
block|,
block|{
literal|"cfmsuba32"
block|,
literal|0xee300600
block|,
literal|9
block|,
name|ARM_CEXT_MAVERICK
block|,
name|do_mav_quad_6b
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Defines for various bits that we will want to toggle.  */
end_comment

begin_define
define|#
directive|define
name|INST_IMMEDIATE
value|0x02000000
end_define

begin_define
define|#
directive|define
name|OFFSET_REG
value|0x02000000
end_define

begin_define
define|#
directive|define
name|HWOFFSET_IMM
value|0x00400000
end_define

begin_define
define|#
directive|define
name|SHIFT_BY_REG
value|0x00000010
end_define

begin_define
define|#
directive|define
name|PRE_INDEX
value|0x01000000
end_define

begin_define
define|#
directive|define
name|INDEX_UP
value|0x00800000
end_define

begin_define
define|#
directive|define
name|WRITE_BACK
value|0x00200000
end_define

begin_define
define|#
directive|define
name|LDM_TYPE_2_OR_3
value|0x00400000
end_define

begin_define
define|#
directive|define
name|LITERAL_MASK
value|0xf000f000
end_define

begin_define
define|#
directive|define
name|OPCODE_MASK
value|0xfe1fffff
end_define

begin_define
define|#
directive|define
name|V4_STR_BIT
value|0x00000020
end_define

begin_define
define|#
directive|define
name|DATA_OP_SHIFT
value|21
end_define

begin_comment
comment|/* Codes to distinguish the arithmetic instructions.  */
end_comment

begin_define
define|#
directive|define
name|OPCODE_AND
value|0
end_define

begin_define
define|#
directive|define
name|OPCODE_EOR
value|1
end_define

begin_define
define|#
directive|define
name|OPCODE_SUB
value|2
end_define

begin_define
define|#
directive|define
name|OPCODE_RSB
value|3
end_define

begin_define
define|#
directive|define
name|OPCODE_ADD
value|4
end_define

begin_define
define|#
directive|define
name|OPCODE_ADC
value|5
end_define

begin_define
define|#
directive|define
name|OPCODE_SBC
value|6
end_define

begin_define
define|#
directive|define
name|OPCODE_RSC
value|7
end_define

begin_define
define|#
directive|define
name|OPCODE_TST
value|8
end_define

begin_define
define|#
directive|define
name|OPCODE_TEQ
value|9
end_define

begin_define
define|#
directive|define
name|OPCODE_CMP
value|10
end_define

begin_define
define|#
directive|define
name|OPCODE_CMN
value|11
end_define

begin_define
define|#
directive|define
name|OPCODE_ORR
value|12
end_define

begin_define
define|#
directive|define
name|OPCODE_MOV
value|13
end_define

begin_define
define|#
directive|define
name|OPCODE_BIC
value|14
end_define

begin_define
define|#
directive|define
name|OPCODE_MVN
value|15
end_define

begin_comment
comment|/* Thumb v1 (ARMv4T).  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|do_t_nop
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_t_arit
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_t_add
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_t_asr
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_t_branch9
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_t_branch12
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_t_branch23
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_t_bx
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_t_compare
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_t_ldmstm
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_t_ldr
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_t_ldrb
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_t_ldrh
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_t_lds
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_t_lsl
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_t_lsr
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_t_mov
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_t_push_pop
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_t_str
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_t_strb
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_t_strh
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_t_sub
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_t_swi
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_t_adr
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Thumb v2 (ARMv5T).  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|do_t_blx
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_t_bkpt
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|T_OPCODE_MUL
value|0x4340
end_define

begin_define
define|#
directive|define
name|T_OPCODE_TST
value|0x4200
end_define

begin_define
define|#
directive|define
name|T_OPCODE_CMN
value|0x42c0
end_define

begin_define
define|#
directive|define
name|T_OPCODE_NEG
value|0x4240
end_define

begin_define
define|#
directive|define
name|T_OPCODE_MVN
value|0x43c0
end_define

begin_define
define|#
directive|define
name|T_OPCODE_ADD_R3
value|0x1800
end_define

begin_define
define|#
directive|define
name|T_OPCODE_SUB_R3
value|0x1a00
end_define

begin_define
define|#
directive|define
name|T_OPCODE_ADD_HI
value|0x4400
end_define

begin_define
define|#
directive|define
name|T_OPCODE_ADD_ST
value|0xb000
end_define

begin_define
define|#
directive|define
name|T_OPCODE_SUB_ST
value|0xb080
end_define

begin_define
define|#
directive|define
name|T_OPCODE_ADD_SP
value|0xa800
end_define

begin_define
define|#
directive|define
name|T_OPCODE_ADD_PC
value|0xa000
end_define

begin_define
define|#
directive|define
name|T_OPCODE_ADD_I8
value|0x3000
end_define

begin_define
define|#
directive|define
name|T_OPCODE_SUB_I8
value|0x3800
end_define

begin_define
define|#
directive|define
name|T_OPCODE_ADD_I3
value|0x1c00
end_define

begin_define
define|#
directive|define
name|T_OPCODE_SUB_I3
value|0x1e00
end_define

begin_define
define|#
directive|define
name|T_OPCODE_ASR_R
value|0x4100
end_define

begin_define
define|#
directive|define
name|T_OPCODE_LSL_R
value|0x4080
end_define

begin_define
define|#
directive|define
name|T_OPCODE_LSR_R
value|0x40c0
end_define

begin_define
define|#
directive|define
name|T_OPCODE_ASR_I
value|0x1000
end_define

begin_define
define|#
directive|define
name|T_OPCODE_LSL_I
value|0x0000
end_define

begin_define
define|#
directive|define
name|T_OPCODE_LSR_I
value|0x0800
end_define

begin_define
define|#
directive|define
name|T_OPCODE_MOV_I8
value|0x2000
end_define

begin_define
define|#
directive|define
name|T_OPCODE_CMP_I8
value|0x2800
end_define

begin_define
define|#
directive|define
name|T_OPCODE_CMP_LR
value|0x4280
end_define

begin_define
define|#
directive|define
name|T_OPCODE_MOV_HR
value|0x4600
end_define

begin_define
define|#
directive|define
name|T_OPCODE_CMP_HR
value|0x4500
end_define

begin_define
define|#
directive|define
name|T_OPCODE_LDR_PC
value|0x4800
end_define

begin_define
define|#
directive|define
name|T_OPCODE_LDR_SP
value|0x9800
end_define

begin_define
define|#
directive|define
name|T_OPCODE_STR_SP
value|0x9000
end_define

begin_define
define|#
directive|define
name|T_OPCODE_LDR_IW
value|0x6800
end_define

begin_define
define|#
directive|define
name|T_OPCODE_STR_IW
value|0x6000
end_define

begin_define
define|#
directive|define
name|T_OPCODE_LDR_IH
value|0x8800
end_define

begin_define
define|#
directive|define
name|T_OPCODE_STR_IH
value|0x8000
end_define

begin_define
define|#
directive|define
name|T_OPCODE_LDR_IB
value|0x7800
end_define

begin_define
define|#
directive|define
name|T_OPCODE_STR_IB
value|0x7000
end_define

begin_define
define|#
directive|define
name|T_OPCODE_LDR_RW
value|0x5800
end_define

begin_define
define|#
directive|define
name|T_OPCODE_STR_RW
value|0x5000
end_define

begin_define
define|#
directive|define
name|T_OPCODE_LDR_RH
value|0x5a00
end_define

begin_define
define|#
directive|define
name|T_OPCODE_STR_RH
value|0x5200
end_define

begin_define
define|#
directive|define
name|T_OPCODE_LDR_RB
value|0x5c00
end_define

begin_define
define|#
directive|define
name|T_OPCODE_STR_RB
value|0x5400
end_define

begin_define
define|#
directive|define
name|T_OPCODE_PUSH
value|0xb400
end_define

begin_define
define|#
directive|define
name|T_OPCODE_POP
value|0xbc00
end_define

begin_define
define|#
directive|define
name|T_OPCODE_BRANCH
value|0xe7fe
end_define

begin_decl_stmt
specifier|static
name|int
name|thumb_reg
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|*
name|str
operator|,
name|int
name|hi_lo
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|THUMB_SIZE
value|2
end_define

begin_comment
comment|/* Size of thumb instruction.  */
end_comment

begin_define
define|#
directive|define
name|THUMB_REG_LO
value|0x1
end_define

begin_define
define|#
directive|define
name|THUMB_REG_HI
value|0x2
end_define

begin_define
define|#
directive|define
name|THUMB_REG_ANY
value|0x3
end_define

begin_define
define|#
directive|define
name|THUMB_H1
value|0x0080
end_define

begin_define
define|#
directive|define
name|THUMB_H2
value|0x0040
end_define

begin_define
define|#
directive|define
name|THUMB_ASR
value|0
end_define

begin_define
define|#
directive|define
name|THUMB_LSL
value|1
end_define

begin_define
define|#
directive|define
name|THUMB_LSR
value|2
end_define

begin_define
define|#
directive|define
name|THUMB_MOVE
value|0
end_define

begin_define
define|#
directive|define
name|THUMB_COMPARE
value|1
end_define

begin_define
define|#
directive|define
name|THUMB_LOAD
value|0
end_define

begin_define
define|#
directive|define
name|THUMB_STORE
value|1
end_define

begin_define
define|#
directive|define
name|THUMB_PP_PC_LR
value|0x0100
end_define

begin_comment
comment|/* These three are used for immediate shifts, do not alter.  */
end_comment

begin_define
define|#
directive|define
name|THUMB_WORD
value|2
end_define

begin_define
define|#
directive|define
name|THUMB_HALFWORD
value|1
end_define

begin_define
define|#
directive|define
name|THUMB_BYTE
value|0
end_define

begin_struct
struct|struct
name|thumb_opcode
block|{
comment|/* Basic string to match.  */
specifier|const
name|char
modifier|*
name|template
decl_stmt|;
comment|/* Basic instruction code.  */
name|unsigned
name|long
name|value
decl_stmt|;
name|int
name|size
decl_stmt|;
comment|/* Which CPU variants this exists for.  */
name|unsigned
name|long
name|variant
decl_stmt|;
comment|/* Function to call to parse args.  */
name|void
argument_list|(
argument|* parms
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
expr_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|thumb_opcode
name|tinsns
index|[]
init|=
block|{
comment|/* Thumb v1 (ARMv4T).  */
block|{
literal|"adc"
block|,
literal|0x4140
block|,
literal|2
block|,
name|ARM_EXT_V4T
block|,
name|do_t_arit
block|}
block|,
block|{
literal|"add"
block|,
literal|0x0000
block|,
literal|2
block|,
name|ARM_EXT_V4T
block|,
name|do_t_add
block|}
block|,
block|{
literal|"and"
block|,
literal|0x4000
block|,
literal|2
block|,
name|ARM_EXT_V4T
block|,
name|do_t_arit
block|}
block|,
block|{
literal|"asr"
block|,
literal|0x0000
block|,
literal|2
block|,
name|ARM_EXT_V4T
block|,
name|do_t_asr
block|}
block|,
block|{
literal|"b"
block|,
name|T_OPCODE_BRANCH
block|,
literal|2
block|,
name|ARM_EXT_V4T
block|,
name|do_t_branch12
block|}
block|,
block|{
literal|"beq"
block|,
literal|0xd0fe
block|,
literal|2
block|,
name|ARM_EXT_V4T
block|,
name|do_t_branch9
block|}
block|,
block|{
literal|"bne"
block|,
literal|0xd1fe
block|,
literal|2
block|,
name|ARM_EXT_V4T
block|,
name|do_t_branch9
block|}
block|,
block|{
literal|"bcs"
block|,
literal|0xd2fe
block|,
literal|2
block|,
name|ARM_EXT_V4T
block|,
name|do_t_branch9
block|}
block|,
block|{
literal|"bhs"
block|,
literal|0xd2fe
block|,
literal|2
block|,
name|ARM_EXT_V4T
block|,
name|do_t_branch9
block|}
block|,
block|{
literal|"bcc"
block|,
literal|0xd3fe
block|,
literal|2
block|,
name|ARM_EXT_V4T
block|,
name|do_t_branch9
block|}
block|,
block|{
literal|"bul"
block|,
literal|0xd3fe
block|,
literal|2
block|,
name|ARM_EXT_V4T
block|,
name|do_t_branch9
block|}
block|,
block|{
literal|"blo"
block|,
literal|0xd3fe
block|,
literal|2
block|,
name|ARM_EXT_V4T
block|,
name|do_t_branch9
block|}
block|,
block|{
literal|"bmi"
block|,
literal|0xd4fe
block|,
literal|2
block|,
name|ARM_EXT_V4T
block|,
name|do_t_branch9
block|}
block|,
block|{
literal|"bpl"
block|,
literal|0xd5fe
block|,
literal|2
block|,
name|ARM_EXT_V4T
block|,
name|do_t_branch9
block|}
block|,
block|{
literal|"bvs"
block|,
literal|0xd6fe
block|,
literal|2
block|,
name|ARM_EXT_V4T
block|,
name|do_t_branch9
block|}
block|,
block|{
literal|"bvc"
block|,
literal|0xd7fe
block|,
literal|2
block|,
name|ARM_EXT_V4T
block|,
name|do_t_branch9
block|}
block|,
block|{
literal|"bhi"
block|,
literal|0xd8fe
block|,
literal|2
block|,
name|ARM_EXT_V4T
block|,
name|do_t_branch9
block|}
block|,
block|{
literal|"bls"
block|,
literal|0xd9fe
block|,
literal|2
block|,
name|ARM_EXT_V4T
block|,
name|do_t_branch9
block|}
block|,
block|{
literal|"bge"
block|,
literal|0xdafe
block|,
literal|2
block|,
name|ARM_EXT_V4T
block|,
name|do_t_branch9
block|}
block|,
block|{
literal|"blt"
block|,
literal|0xdbfe
block|,
literal|2
block|,
name|ARM_EXT_V4T
block|,
name|do_t_branch9
block|}
block|,
block|{
literal|"bgt"
block|,
literal|0xdcfe
block|,
literal|2
block|,
name|ARM_EXT_V4T
block|,
name|do_t_branch9
block|}
block|,
block|{
literal|"ble"
block|,
literal|0xddfe
block|,
literal|2
block|,
name|ARM_EXT_V4T
block|,
name|do_t_branch9
block|}
block|,
block|{
literal|"bal"
block|,
literal|0xdefe
block|,
literal|2
block|,
name|ARM_EXT_V4T
block|,
name|do_t_branch9
block|}
block|,
block|{
literal|"bic"
block|,
literal|0x4380
block|,
literal|2
block|,
name|ARM_EXT_V4T
block|,
name|do_t_arit
block|}
block|,
block|{
literal|"bl"
block|,
literal|0xf7fffffe
block|,
literal|4
block|,
name|ARM_EXT_V4T
block|,
name|do_t_branch23
block|}
block|,
block|{
literal|"bx"
block|,
literal|0x4700
block|,
literal|2
block|,
name|ARM_EXT_V4T
block|,
name|do_t_bx
block|}
block|,
block|{
literal|"cmn"
block|,
name|T_OPCODE_CMN
block|,
literal|2
block|,
name|ARM_EXT_V4T
block|,
name|do_t_arit
block|}
block|,
block|{
literal|"cmp"
block|,
literal|0x0000
block|,
literal|2
block|,
name|ARM_EXT_V4T
block|,
name|do_t_compare
block|}
block|,
block|{
literal|"eor"
block|,
literal|0x4040
block|,
literal|2
block|,
name|ARM_EXT_V4T
block|,
name|do_t_arit
block|}
block|,
block|{
literal|"ldmia"
block|,
literal|0xc800
block|,
literal|2
block|,
name|ARM_EXT_V4T
block|,
name|do_t_ldmstm
block|}
block|,
block|{
literal|"ldr"
block|,
literal|0x0000
block|,
literal|2
block|,
name|ARM_EXT_V4T
block|,
name|do_t_ldr
block|}
block|,
block|{
literal|"ldrb"
block|,
literal|0x0000
block|,
literal|2
block|,
name|ARM_EXT_V4T
block|,
name|do_t_ldrb
block|}
block|,
block|{
literal|"ldrh"
block|,
literal|0x0000
block|,
literal|2
block|,
name|ARM_EXT_V4T
block|,
name|do_t_ldrh
block|}
block|,
block|{
literal|"ldrsb"
block|,
literal|0x5600
block|,
literal|2
block|,
name|ARM_EXT_V4T
block|,
name|do_t_lds
block|}
block|,
block|{
literal|"ldrsh"
block|,
literal|0x5e00
block|,
literal|2
block|,
name|ARM_EXT_V4T
block|,
name|do_t_lds
block|}
block|,
block|{
literal|"ldsb"
block|,
literal|0x5600
block|,
literal|2
block|,
name|ARM_EXT_V4T
block|,
name|do_t_lds
block|}
block|,
block|{
literal|"ldsh"
block|,
literal|0x5e00
block|,
literal|2
block|,
name|ARM_EXT_V4T
block|,
name|do_t_lds
block|}
block|,
block|{
literal|"lsl"
block|,
literal|0x0000
block|,
literal|2
block|,
name|ARM_EXT_V4T
block|,
name|do_t_lsl
block|}
block|,
block|{
literal|"lsr"
block|,
literal|0x0000
block|,
literal|2
block|,
name|ARM_EXT_V4T
block|,
name|do_t_lsr
block|}
block|,
block|{
literal|"mov"
block|,
literal|0x0000
block|,
literal|2
block|,
name|ARM_EXT_V4T
block|,
name|do_t_mov
block|}
block|,
block|{
literal|"mul"
block|,
name|T_OPCODE_MUL
block|,
literal|2
block|,
name|ARM_EXT_V4T
block|,
name|do_t_arit
block|}
block|,
block|{
literal|"mvn"
block|,
name|T_OPCODE_MVN
block|,
literal|2
block|,
name|ARM_EXT_V4T
block|,
name|do_t_arit
block|}
block|,
block|{
literal|"neg"
block|,
name|T_OPCODE_NEG
block|,
literal|2
block|,
name|ARM_EXT_V4T
block|,
name|do_t_arit
block|}
block|,
block|{
literal|"orr"
block|,
literal|0x4300
block|,
literal|2
block|,
name|ARM_EXT_V4T
block|,
name|do_t_arit
block|}
block|,
block|{
literal|"pop"
block|,
literal|0xbc00
block|,
literal|2
block|,
name|ARM_EXT_V4T
block|,
name|do_t_push_pop
block|}
block|,
block|{
literal|"push"
block|,
literal|0xb400
block|,
literal|2
block|,
name|ARM_EXT_V4T
block|,
name|do_t_push_pop
block|}
block|,
block|{
literal|"ror"
block|,
literal|0x41c0
block|,
literal|2
block|,
name|ARM_EXT_V4T
block|,
name|do_t_arit
block|}
block|,
block|{
literal|"sbc"
block|,
literal|0x4180
block|,
literal|2
block|,
name|ARM_EXT_V4T
block|,
name|do_t_arit
block|}
block|,
block|{
literal|"stmia"
block|,
literal|0xc000
block|,
literal|2
block|,
name|ARM_EXT_V4T
block|,
name|do_t_ldmstm
block|}
block|,
block|{
literal|"str"
block|,
literal|0x0000
block|,
literal|2
block|,
name|ARM_EXT_V4T
block|,
name|do_t_str
block|}
block|,
block|{
literal|"strb"
block|,
literal|0x0000
block|,
literal|2
block|,
name|ARM_EXT_V4T
block|,
name|do_t_strb
block|}
block|,
block|{
literal|"strh"
block|,
literal|0x0000
block|,
literal|2
block|,
name|ARM_EXT_V4T
block|,
name|do_t_strh
block|}
block|,
block|{
literal|"swi"
block|,
literal|0xdf00
block|,
literal|2
block|,
name|ARM_EXT_V4T
block|,
name|do_t_swi
block|}
block|,
block|{
literal|"sub"
block|,
literal|0x0000
block|,
literal|2
block|,
name|ARM_EXT_V4T
block|,
name|do_t_sub
block|}
block|,
block|{
literal|"tst"
block|,
name|T_OPCODE_TST
block|,
literal|2
block|,
name|ARM_EXT_V4T
block|,
name|do_t_arit
block|}
block|,
comment|/* Pseudo ops:  */
block|{
literal|"adr"
block|,
literal|0x0000
block|,
literal|2
block|,
name|ARM_EXT_V4T
block|,
name|do_t_adr
block|}
block|,
block|{
literal|"nop"
block|,
literal|0x46C0
block|,
literal|2
block|,
name|ARM_EXT_V4T
block|,
name|do_t_nop
block|}
block|,
comment|/* mov r8,r8  */
comment|/* Thumb v2 (ARMv5T).  */
block|{
literal|"blx"
block|,
literal|0
block|,
literal|0
block|,
name|ARM_EXT_V5T
block|,
name|do_t_blx
block|}
block|,
block|{
literal|"bkpt"
block|,
literal|0xbe00
block|,
literal|2
block|,
name|ARM_EXT_V5T
block|,
name|do_t_bkpt
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|BAD_ARGS
value|_("bad arguments to instruction")
end_define

begin_define
define|#
directive|define
name|BAD_PC
value|_("r15 not allowed here")
end_define

begin_define
define|#
directive|define
name|BAD_COND
value|_("instruction is not conditional")
end_define

begin_define
define|#
directive|define
name|ERR_NO_ACCUM
value|_("acc0 expected")
end_define

begin_decl_stmt
specifier|static
name|struct
name|hash_control
modifier|*
name|arm_ops_hsh
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|hash_control
modifier|*
name|arm_tops_hsh
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|hash_control
modifier|*
name|arm_cond_hsh
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|hash_control
modifier|*
name|arm_shift_hsh
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|hash_control
modifier|*
name|arm_psr_hsh
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This table describes all the machine specific pseudo-ops the assembler    has to support.  The fields are:      pseudo-op name without dot      function to call to execute this pseudo-op      Integer arg to pass to the function.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|s_req
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|s_align
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|s_bss
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|s_even
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|s_ltorg
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|s_arm
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|s_thumb
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|s_code
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|s_force_thumb
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|s_thumb_func
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|s_thumb_set
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|arm_s_text
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|arm_s_data
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|OBJ_ELF
end_ifdef

begin_decl_stmt
specifier|static
name|void
name|arm_s_section
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|s_arm_elf_cons
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|int
name|my_get_expression
name|PARAMS
argument_list|(
operator|(
name|expressionS
operator|*
operator|,
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|pseudo_typeS
name|md_pseudo_table
index|[]
init|=
block|{
comment|/* Never called becasue '.req' does not start line.  */
block|{
literal|"req"
block|,
name|s_req
block|,
literal|0
block|}
block|,
block|{
literal|"bss"
block|,
name|s_bss
block|,
literal|0
block|}
block|,
block|{
literal|"align"
block|,
name|s_align
block|,
literal|0
block|}
block|,
block|{
literal|"arm"
block|,
name|s_arm
block|,
literal|0
block|}
block|,
block|{
literal|"thumb"
block|,
name|s_thumb
block|,
literal|0
block|}
block|,
block|{
literal|"code"
block|,
name|s_code
block|,
literal|0
block|}
block|,
block|{
literal|"force_thumb"
block|,
name|s_force_thumb
block|,
literal|0
block|}
block|,
block|{
literal|"thumb_func"
block|,
name|s_thumb_func
block|,
literal|0
block|}
block|,
block|{
literal|"thumb_set"
block|,
name|s_thumb_set
block|,
literal|0
block|}
block|,
block|{
literal|"even"
block|,
name|s_even
block|,
literal|0
block|}
block|,
block|{
literal|"ltorg"
block|,
name|s_ltorg
block|,
literal|0
block|}
block|,
block|{
literal|"pool"
block|,
name|s_ltorg
block|,
literal|0
block|}
block|,
comment|/* Allow for the effect of section changes.  */
block|{
literal|"text"
block|,
name|arm_s_text
block|,
literal|0
block|}
block|,
block|{
literal|"data"
block|,
name|arm_s_data
block|,
literal|0
block|}
block|,
ifdef|#
directive|ifdef
name|OBJ_ELF
block|{
literal|"section"
block|,
name|arm_s_section
block|,
literal|0
block|}
block|,
block|{
literal|"section.s"
block|,
name|arm_s_section
block|,
literal|0
block|}
block|,
block|{
literal|"sect"
block|,
name|arm_s_section
block|,
literal|0
block|}
block|,
block|{
literal|"sect.s"
block|,
name|arm_s_section
block|,
literal|0
block|}
block|,
block|{
literal|"word"
block|,
name|s_arm_elf_cons
block|,
literal|4
block|}
block|,
block|{
literal|"long"
block|,
name|s_arm_elf_cons
block|,
literal|4
block|}
block|,
block|{
literal|"file"
block|,
name|dwarf2_directive_file
block|,
literal|0
block|}
block|,
block|{
literal|"loc"
block|,
name|dwarf2_directive_loc
block|,
literal|0
block|}
block|,
else|#
directive|else
block|{
literal|"word"
block|,
name|cons
block|,
literal|4
block|}
block|,
endif|#
directive|endif
block|{
literal|"extend"
block|,
name|float_cons
block|,
literal|'x'
block|}
block|,
block|{
literal|"ldouble"
block|,
name|float_cons
block|,
literal|'x'
block|}
block|,
block|{
literal|"packed"
block|,
name|float_cons
block|,
literal|'p'
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Other internal functions.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|arm_parse_extension
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|arm_parse_cpu
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|arm_parse_arch
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|arm_parse_fpu
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Stuff needed to resolve the label ambiguity    As:      ...      label:<insn>    may differ from:      ...      label:<insn> */
end_comment

begin_decl_stmt
name|symbolS
modifier|*
name|last_label_seen
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|label_is_thumb_function_name
init|=
name|false
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Literal stuff.  */
end_comment

begin_define
define|#
directive|define
name|MAX_LITERAL_POOL_SIZE
value|1024
end_define

begin_typedef
typedef|typedef
struct|struct
name|literalS
block|{
name|struct
name|expressionS
name|exp
decl_stmt|;
name|struct
name|arm_it
modifier|*
name|inst
decl_stmt|;
block|}
name|literalT
typedef|;
end_typedef

begin_decl_stmt
name|literalT
name|literals
index|[
name|MAX_LITERAL_POOL_SIZE
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Next free entry in the pool.  */
end_comment

begin_decl_stmt
name|int
name|next_literal_pool_place
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Next literal pool number.  */
end_comment

begin_decl_stmt
name|int
name|lit_pool_num
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|symbolS
modifier|*
name|current_poolP
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|add_to_lit_pool
parameter_list|()
block|{
name|int
name|lit_count
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|current_poolP
operator|==
name|NULL
condition|)
name|current_poolP
operator|=
name|symbol_create
argument_list|(
name|FAKE_LABEL_NAME
argument_list|,
name|undefined_section
argument_list|,
operator|(
name|valueT
operator|)
literal|0
argument_list|,
operator|&
name|zero_address_frag
argument_list|)
expr_stmt|;
comment|/* Check if this literal value is already in the pool:  */
while|while
condition|(
name|lit_count
operator|<
name|next_literal_pool_place
condition|)
block|{
if|if
condition|(
name|literals
index|[
name|lit_count
index|]
operator|.
name|exp
operator|.
name|X_op
operator|==
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_op
operator|&&
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_op
operator|==
name|O_constant
operator|&&
operator|(
name|literals
index|[
name|lit_count
index|]
operator|.
name|exp
operator|.
name|X_add_number
operator|==
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_add_number
operator|)
operator|&&
name|literals
index|[
name|lit_count
index|]
operator|.
name|exp
operator|.
name|X_unsigned
operator|==
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_unsigned
condition|)
break|break;
if|if
condition|(
name|literals
index|[
name|lit_count
index|]
operator|.
name|exp
operator|.
name|X_op
operator|==
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_op
operator|&&
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_op
operator|==
name|O_symbol
operator|&&
operator|(
name|literals
index|[
name|lit_count
index|]
operator|.
name|exp
operator|.
name|X_add_number
operator|==
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_add_number
operator|)
operator|&&
operator|(
name|literals
index|[
name|lit_count
index|]
operator|.
name|exp
operator|.
name|X_add_symbol
operator|==
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_add_symbol
operator|)
operator|&&
operator|(
name|literals
index|[
name|lit_count
index|]
operator|.
name|exp
operator|.
name|X_op_symbol
operator|==
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_op_symbol
operator|)
condition|)
break|break;
name|lit_count
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|lit_count
operator|==
name|next_literal_pool_place
condition|)
comment|/* New entry.  */
block|{
if|if
condition|(
name|next_literal_pool_place
operator|>=
name|MAX_LITERAL_POOL_SIZE
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"literal pool overflow"
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
block|}
name|literals
index|[
name|next_literal_pool_place
index|]
operator|.
name|exp
operator|=
name|inst
operator|.
name|reloc
operator|.
name|exp
expr_stmt|;
name|lit_count
operator|=
name|next_literal_pool_place
operator|++
expr_stmt|;
block|}
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_op
operator|=
name|O_symbol
expr_stmt|;
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_add_number
operator|=
operator|(
name|lit_count
operator|)
operator|*
literal|4
operator|-
literal|8
expr_stmt|;
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_add_symbol
operator|=
name|current_poolP
expr_stmt|;
return|return
name|SUCCESS
return|;
block|}
end_function

begin_comment
comment|/* Can't use symbol_new here, so have to create a symbol and then at    a later date assign it a value. Thats what these functions do.  */
end_comment

begin_function
specifier|static
name|void
name|symbol_locate
parameter_list|(
name|symbolP
parameter_list|,
name|name
parameter_list|,
name|segment
parameter_list|,
name|valu
parameter_list|,
name|frag
parameter_list|)
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
comment|/* It is copied, the caller can modify.  */
name|segT
name|segment
decl_stmt|;
comment|/* Segment identifier (SEG_<something>).  */
name|valueT
name|valu
decl_stmt|;
comment|/* Symbol value.  */
name|fragS
modifier|*
name|frag
decl_stmt|;
comment|/* Associated fragment.  */
block|{
name|unsigned
name|int
name|name_length
decl_stmt|;
name|char
modifier|*
name|preserved_copy_of_name
decl_stmt|;
name|name_length
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
expr_stmt|;
comment|/* +1 for \0.  */
name|obstack_grow
argument_list|(
operator|&
name|notes
argument_list|,
name|name
argument_list|,
name|name_length
argument_list|)
expr_stmt|;
name|preserved_copy_of_name
operator|=
name|obstack_finish
argument_list|(
operator|&
name|notes
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|STRIP_UNDERSCORE
if|if
condition|(
name|preserved_copy_of_name
index|[
literal|0
index|]
operator|==
literal|'_'
condition|)
name|preserved_copy_of_name
operator|++
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|tc_canonicalize_symbol_name
name|preserved_copy_of_name
operator|=
name|tc_canonicalize_symbol_name
argument_list|(
name|preserved_copy_of_name
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|S_SET_NAME
argument_list|(
name|symbolP
argument_list|,
name|preserved_copy_of_name
argument_list|)
expr_stmt|;
name|S_SET_SEGMENT
argument_list|(
name|symbolP
argument_list|,
name|segment
argument_list|)
expr_stmt|;
name|S_SET_VALUE
argument_list|(
name|symbolP
argument_list|,
name|valu
argument_list|)
expr_stmt|;
name|symbol_clear_list_pointers
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
name|symbol_set_frag
argument_list|(
name|symbolP
argument_list|,
name|frag
argument_list|)
expr_stmt|;
comment|/* Link to end of symbol chain.  */
block|{
specifier|extern
name|int
name|symbol_table_frozen
decl_stmt|;
if|if
condition|(
name|symbol_table_frozen
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
name|symbol_append
argument_list|(
name|symbolP
argument_list|,
name|symbol_lastP
argument_list|,
operator|&
name|symbol_rootP
argument_list|,
operator|&
name|symbol_lastP
argument_list|)
expr_stmt|;
name|obj_symbol_new_hook
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|tc_symbol_new_hook
name|tc_symbol_new_hook
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DEBUG_SYMS
name|verify_symbol_chain
argument_list|(
name|symbol_rootP
argument_list|,
name|symbol_lastP
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG_SYMS  */
block|}
end_function

begin_comment
comment|/* Check that an immediate is valid.    If so, convert it to the right format.  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|validate_immediate
parameter_list|(
name|val
parameter_list|)
name|unsigned
name|int
name|val
decl_stmt|;
block|{
name|unsigned
name|int
name|a
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
define|#
directive|define
name|rotate_left
parameter_list|(
name|v
parameter_list|,
name|n
parameter_list|)
value|(v<< n | v>> (32 - n))
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|+=
literal|2
control|)
if|if
condition|(
operator|(
name|a
operator|=
name|rotate_left
argument_list|(
name|val
argument_list|,
name|i
argument_list|)
operator|)
operator|<=
literal|0xff
condition|)
return|return
name|a
operator||
operator|(
name|i
operator|<<
literal|7
operator|)
return|;
comment|/* 12-bit pack: [shift-cnt,const].  */
return|return
name|FAIL
return|;
block|}
end_function

begin_comment
comment|/* Check to see if an immediate can be computed as two seperate immediate    values, added together.  We already know that this value cannot be    computed by just one ARM instruction.  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|validate_immediate_twopart
parameter_list|(
name|val
parameter_list|,
name|highpart
parameter_list|)
name|unsigned
name|int
name|val
decl_stmt|;
name|unsigned
name|int
modifier|*
name|highpart
decl_stmt|;
block|{
name|unsigned
name|int
name|a
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|+=
literal|2
control|)
if|if
condition|(
operator|(
operator|(
name|a
operator|=
name|rotate_left
argument_list|(
name|val
argument_list|,
name|i
argument_list|)
operator|)
operator|&
literal|0xff
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|a
operator|&
literal|0xff00
condition|)
block|{
if|if
condition|(
name|a
operator|&
operator|~
literal|0xffff
condition|)
continue|continue;
operator|*
name|highpart
operator|=
operator|(
name|a
operator|>>
literal|8
operator|)
operator||
operator|(
operator|(
name|i
operator|+
literal|24
operator|)
operator|<<
literal|7
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|a
operator|&
literal|0xff0000
condition|)
block|{
if|if
condition|(
name|a
operator|&
literal|0xff000000
condition|)
continue|continue;
operator|*
name|highpart
operator|=
operator|(
name|a
operator|>>
literal|16
operator|)
operator||
operator|(
operator|(
name|i
operator|+
literal|16
operator|)
operator|<<
literal|7
operator|)
expr_stmt|;
block|}
else|else
block|{
name|assert
argument_list|(
name|a
operator|&
literal|0xff000000
argument_list|)
expr_stmt|;
operator|*
name|highpart
operator|=
operator|(
name|a
operator|>>
literal|24
operator|)
operator||
operator|(
operator|(
name|i
operator|+
literal|8
operator|)
operator|<<
literal|7
operator|)
expr_stmt|;
block|}
return|return
operator|(
name|a
operator|&
literal|0xff
operator|)
operator||
operator|(
name|i
operator|<<
literal|7
operator|)
return|;
block|}
return|return
name|FAIL
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|validate_offset_imm
parameter_list|(
name|val
parameter_list|,
name|hwse
parameter_list|)
name|unsigned
name|int
name|val
decl_stmt|;
name|int
name|hwse
decl_stmt|;
block|{
if|if
condition|(
operator|(
name|hwse
operator|&&
name|val
operator|>
literal|255
operator|)
operator|||
name|val
operator|>
literal|4095
condition|)
return|return
name|FAIL
return|;
return|return
name|val
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|s_req
parameter_list|(
name|a
parameter_list|)
name|int
name|a
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"invalid syntax for .req directive"
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|s_bss
parameter_list|(
name|ignore
parameter_list|)
name|int
name|ignore
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
comment|/* We don't support putting frags in the BSS segment, we fake it by      marking in_bss, then looking at s_skip for clues.  */
name|subseg_set
argument_list|(
name|bss_section
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|s_even
parameter_list|(
name|ignore
parameter_list|)
name|int
name|ignore
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
comment|/* Never make frag if expect extra pass.  */
if|if
condition|(
operator|!
name|need_pass_2
condition|)
name|frag_align
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|record_alignment
argument_list|(
name|now_seg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|s_ltorg
parameter_list|(
name|ignored
parameter_list|)
name|int
name|ignored
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|int
name|lit_count
init|=
literal|0
decl_stmt|;
name|char
name|sym_name
index|[
literal|20
index|]
decl_stmt|;
if|if
condition|(
name|current_poolP
operator|==
name|NULL
condition|)
return|return;
comment|/* Align pool as you have word accesses.      Only make a frag if we have to.  */
if|if
condition|(
operator|!
name|need_pass_2
condition|)
name|frag_align
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|record_alignment
argument_list|(
name|now_seg
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|sym_name
argument_list|,
literal|"$$lit_\002%x"
argument_list|,
name|lit_pool_num
operator|++
argument_list|)
expr_stmt|;
name|symbol_locate
argument_list|(
name|current_poolP
argument_list|,
name|sym_name
argument_list|,
name|now_seg
argument_list|,
operator|(
name|valueT
operator|)
name|frag_now_fix
argument_list|()
argument_list|,
name|frag_now
argument_list|)
expr_stmt|;
name|symbol_table_insert
argument_list|(
name|current_poolP
argument_list|)
expr_stmt|;
name|ARM_SET_THUMB
argument_list|(
name|current_poolP
argument_list|,
name|thumb_mode
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
name|OBJ_COFF
operator|||
name|defined
name|OBJ_ELF
name|ARM_SET_INTERWORK
argument_list|(
name|current_poolP
argument_list|,
name|support_interwork
argument_list|)
expr_stmt|;
endif|#
directive|endif
while|while
condition|(
name|lit_count
operator|<
name|next_literal_pool_place
condition|)
comment|/* First output the expression in the instruction to the pool.  */
name|emit_expr
argument_list|(
operator|&
operator|(
name|literals
index|[
name|lit_count
operator|++
index|]
operator|.
name|exp
operator|)
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* .word  */
name|next_literal_pool_place
operator|=
literal|0
expr_stmt|;
name|current_poolP
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Same as s_align_ptwo but align 0 => align 2.  */
end_comment

begin_function
specifier|static
name|void
name|s_align
parameter_list|(
name|unused
parameter_list|)
name|int
name|unused
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
specifier|register
name|int
name|temp
decl_stmt|;
specifier|register
name|long
name|temp_fill
decl_stmt|;
name|long
name|max_alignment
init|=
literal|15
decl_stmt|;
name|temp
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
if|if
condition|(
name|temp
operator|>
name|max_alignment
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"alignment too large: %d assumed"
argument_list|)
argument_list|,
name|temp
operator|=
name|max_alignment
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|temp
operator|<
literal|0
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"alignment negative. 0 assumed."
argument_list|)
argument_list|)
expr_stmt|;
name|temp
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|','
condition|)
block|{
name|input_line_pointer
operator|++
expr_stmt|;
name|temp_fill
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
block|}
else|else
name|temp_fill
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|temp
condition|)
name|temp
operator|=
literal|2
expr_stmt|;
comment|/* Only make a frag if we HAVE to.  */
if|if
condition|(
name|temp
operator|&&
operator|!
name|need_pass_2
condition|)
name|frag_align
argument_list|(
name|temp
argument_list|,
operator|(
name|int
operator|)
name|temp_fill
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
name|record_alignment
argument_list|(
name|now_seg
argument_list|,
name|temp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|s_force_thumb
parameter_list|(
name|ignore
parameter_list|)
name|int
name|ignore
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
comment|/* If we are not already in thumb mode go into it, EVEN if      the target processor does not support thumb instructions.      This is used by gcc/config/arm/lib1funcs.asm for example      to compile interworking support functions even if the      target processor should not support interworking.  */
if|if
condition|(
operator|!
name|thumb_mode
condition|)
block|{
name|thumb_mode
operator|=
literal|2
expr_stmt|;
name|record_alignment
argument_list|(
name|now_seg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|s_thumb_func
parameter_list|(
name|ignore
parameter_list|)
name|int
name|ignore
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|thumb_mode
condition|)
name|opcode_select
argument_list|(
literal|16
argument_list|)
expr_stmt|;
comment|/* The following label is the name/address of the start of a Thumb function.      We need to know this for the interworking support.  */
name|label_is_thumb_function_name
operator|=
name|true
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Perform a .set directive, but also mark the alias as    being a thumb function.  */
end_comment

begin_function
specifier|static
name|void
name|s_thumb_set
parameter_list|(
name|equiv
parameter_list|)
name|int
name|equiv
decl_stmt|;
block|{
comment|/* XXX the following is a duplicate of the code for s_set() in read.c      We cannot just call that code as we need to get at the symbol that      is created.  */
specifier|register
name|char
modifier|*
name|name
decl_stmt|;
specifier|register
name|char
name|delim
decl_stmt|;
specifier|register
name|char
modifier|*
name|end_name
decl_stmt|;
specifier|register
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
comment|/* Especial apologies for the random logic:      This just grew, and could be parsed much more simply!      Dean - in haste.  */
name|name
operator|=
name|input_line_pointer
expr_stmt|;
name|delim
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
name|end_name
operator|=
name|input_line_pointer
expr_stmt|;
operator|*
name|end_name
operator|=
name|delim
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|!=
literal|','
condition|)
block|{
operator|*
name|end_name
operator|=
literal|0
expr_stmt|;
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"expected comma after name \"%s\""
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
operator|*
name|end_name
operator|=
name|delim
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
name|input_line_pointer
operator|++
expr_stmt|;
operator|*
name|end_name
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
name|name
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
block|{
comment|/* XXX - this should not happen to .thumb_set.  */
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|symbolP
operator|=
name|symbol_find
argument_list|(
name|name
argument_list|)
operator|)
operator|==
name|NULL
operator|&&
operator|(
name|symbolP
operator|=
name|md_undefined_symbol
argument_list|(
name|name
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
ifndef|#
directive|ifndef
name|NO_LISTING
comment|/* When doing symbol listings, play games with dummy fragments living 	 outside the normal fragment chain to record the file and line info          for this symbol.  */
if|if
condition|(
name|listing
operator|&
name|LISTING_SYMBOLS
condition|)
block|{
specifier|extern
name|struct
name|list_info_struct
modifier|*
name|listing_tail
decl_stmt|;
name|fragS
modifier|*
name|dummy_frag
init|=
operator|(
name|fragS
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|fragS
argument_list|)
argument_list|)
decl_stmt|;
name|memset
argument_list|(
name|dummy_frag
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|fragS
argument_list|)
argument_list|)
expr_stmt|;
name|dummy_frag
operator|->
name|fr_type
operator|=
name|rs_fill
expr_stmt|;
name|dummy_frag
operator|->
name|line
operator|=
name|listing_tail
expr_stmt|;
name|symbolP
operator|=
name|symbol_new
argument_list|(
name|name
argument_list|,
name|undefined_section
argument_list|,
literal|0
argument_list|,
name|dummy_frag
argument_list|)
expr_stmt|;
name|dummy_frag
operator|->
name|fr_symbol
operator|=
name|symbolP
expr_stmt|;
block|}
else|else
endif|#
directive|endif
name|symbolP
operator|=
name|symbol_new
argument_list|(
name|name
argument_list|,
name|undefined_section
argument_list|,
literal|0
argument_list|,
operator|&
name|zero_address_frag
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|OBJ_COFF
comment|/* "set" symbols are local unless otherwise specified.  */
name|SF_SET_LOCAL
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* OBJ_COFF  */
block|}
comment|/* Make a new symbol.  */
name|symbol_table_insert
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
operator|*
name|end_name
operator|=
name|delim
expr_stmt|;
if|if
condition|(
name|equiv
operator|&&
name|S_IS_DEFINED
argument_list|(
name|symbolP
argument_list|)
operator|&&
name|S_GET_SEGMENT
argument_list|(
name|symbolP
argument_list|)
operator|!=
name|reg_section
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"symbol `%s' already defined"
argument_list|)
argument_list|,
name|S_GET_NAME
argument_list|(
name|symbolP
argument_list|)
argument_list|)
expr_stmt|;
name|pseudo_set
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
comment|/* XXX Now we come to the Thumb specific bit of code.  */
name|THUMB_SET_FUNC
argument_list|(
name|symbolP
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ARM_SET_THUMB
argument_list|(
name|symbolP
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
name|OBJ_ELF
operator|||
name|defined
name|OBJ_COFF
name|ARM_SET_INTERWORK
argument_list|(
name|symbolP
argument_list|,
name|support_interwork
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* If we change section we must dump the literal pool first.  */
end_comment

begin_function
specifier|static
name|void
name|arm_s_text
parameter_list|(
name|ignore
parameter_list|)
name|int
name|ignore
decl_stmt|;
block|{
if|if
condition|(
name|now_seg
operator|!=
name|text_section
condition|)
name|s_ltorg
argument_list|(
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|OBJ_ELF
name|obj_elf_text
argument_list|(
name|ignore
argument_list|)
expr_stmt|;
else|#
directive|else
name|s_text
argument_list|(
name|ignore
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|arm_s_data
parameter_list|(
name|ignore
parameter_list|)
name|int
name|ignore
decl_stmt|;
block|{
if|if
condition|(
name|flag_readonly_data_in_text
condition|)
block|{
if|if
condition|(
name|now_seg
operator|!=
name|text_section
condition|)
name|s_ltorg
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|now_seg
operator|!=
name|data_section
condition|)
name|s_ltorg
argument_list|(
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|OBJ_ELF
name|obj_elf_data
argument_list|(
name|ignore
argument_list|)
expr_stmt|;
else|#
directive|else
name|s_data
argument_list|(
name|ignore
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|OBJ_ELF
end_ifdef

begin_function
specifier|static
name|void
name|arm_s_section
parameter_list|(
name|ignore
parameter_list|)
name|int
name|ignore
decl_stmt|;
block|{
name|s_ltorg
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|obj_elf_section
argument_list|(
name|ignore
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|opcode_select
parameter_list|(
name|width
parameter_list|)
name|int
name|width
decl_stmt|;
block|{
switch|switch
condition|(
name|width
condition|)
block|{
case|case
literal|16
case|:
if|if
condition|(
operator|!
name|thumb_mode
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|cpu_variant
operator|&
name|ARM_EXT_V4T
operator|)
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"selected processor does not support THUMB opcodes"
argument_list|)
argument_list|)
expr_stmt|;
name|thumb_mode
operator|=
literal|1
expr_stmt|;
comment|/* No need to force the alignment, since we will have been              coming from ARM mode, which is word-aligned.  */
name|record_alignment
argument_list|(
name|now_seg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|32
case|:
if|if
condition|(
name|thumb_mode
condition|)
block|{
if|if
condition|(
operator|(
name|cpu_variant
operator|&
name|ARM_ALL
operator|)
operator|==
name|ARM_EXT_V4T
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"selected processor does not support ARM opcodes"
argument_list|)
argument_list|)
expr_stmt|;
name|thumb_mode
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|need_pass_2
condition|)
name|frag_align
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|record_alignment
argument_list|(
name|now_seg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"invalid instruction size selected (%d)"
argument_list|)
argument_list|,
name|width
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|s_arm
parameter_list|(
name|ignore
parameter_list|)
name|int
name|ignore
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|opcode_select
argument_list|(
literal|32
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|s_thumb
parameter_list|(
name|ignore
parameter_list|)
name|int
name|ignore
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|opcode_select
argument_list|(
literal|16
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|s_code
parameter_list|(
name|unused
parameter_list|)
name|int
name|unused
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
specifier|register
name|int
name|temp
decl_stmt|;
name|temp
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|temp
condition|)
block|{
case|case
literal|16
case|:
case|case
literal|32
case|:
name|opcode_select
argument_list|(
name|temp
argument_list|)
expr_stmt|;
break|break;
default|default:
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"invalid operand to .code directive (%d) (expecting 16 or 32)"
argument_list|)
argument_list|,
name|temp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|end_of_line
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|str
operator|!=
literal|'\0'
operator|&&
operator|!
name|inst
operator|.
name|error
condition|)
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"garbage following instruction"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|skip_past_comma
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
modifier|*
name|str
decl_stmt|;
block|{
name|char
modifier|*
name|p
init|=
operator|*
name|str
decl_stmt|,
name|c
decl_stmt|;
name|int
name|comma
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|p
operator|)
operator|==
literal|' '
operator|||
name|c
operator|==
literal|','
condition|)
block|{
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|','
operator|&&
name|comma
operator|++
condition|)
return|return
name|FAIL
return|;
block|}
if|if
condition|(
name|c
operator|==
literal|'\0'
condition|)
return|return
name|FAIL
return|;
operator|*
name|str
operator|=
name|p
expr_stmt|;
return|return
name|comma
condition|?
name|SUCCESS
else|:
name|FAIL
return|;
block|}
end_function

begin_comment
comment|/* A standard register must be given at this point.    SHIFT is the place to put it in inst.instruction.    Restores input start point on error.    Returns the reg#, or FAIL.  */
end_comment

begin_function
specifier|static
name|int
name|reg_required_here
parameter_list|(
name|str
parameter_list|,
name|shift
parameter_list|)
name|char
modifier|*
modifier|*
name|str
decl_stmt|;
name|int
name|shift
decl_stmt|;
block|{
specifier|static
name|char
name|buff
index|[
literal|128
index|]
decl_stmt|;
comment|/* XXX  */
name|int
name|reg
decl_stmt|;
name|char
modifier|*
name|start
init|=
operator|*
name|str
decl_stmt|;
if|if
condition|(
operator|(
name|reg
operator|=
name|arm_reg_parse
argument_list|(
name|str
argument_list|,
name|all_reg_maps
index|[
name|REG_TYPE_RN
index|]
operator|.
name|htab
argument_list|)
operator|)
operator|!=
name|FAIL
condition|)
block|{
if|if
condition|(
name|shift
operator|>=
literal|0
condition|)
name|inst
operator|.
name|instruction
operator||=
name|reg
operator|<<
name|shift
expr_stmt|;
return|return
name|reg
return|;
block|}
comment|/* Restore the start point, we may have got a reg of the wrong class.  */
operator|*
name|str
operator|=
name|start
expr_stmt|;
comment|/* In the few cases where we might be able to accept something else      this error can be overridden.  */
name|sprintf
argument_list|(
name|buff
argument_list|,
name|_
argument_list|(
literal|"register expected, not '%.100s'"
argument_list|)
argument_list|,
name|start
argument_list|)
expr_stmt|;
name|inst
operator|.
name|error
operator|=
name|buff
expr_stmt|;
return|return
name|FAIL
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|struct
name|asm_psr
modifier|*
name|arm_psr_parse
parameter_list|(
name|ccp
parameter_list|)
specifier|register
name|char
modifier|*
modifier|*
name|ccp
decl_stmt|;
block|{
name|char
modifier|*
name|start
init|=
operator|*
name|ccp
decl_stmt|;
name|char
name|c
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
specifier|const
name|struct
name|asm_psr
modifier|*
name|psr
decl_stmt|;
name|p
operator|=
name|start
expr_stmt|;
comment|/* Skip to the end of the next word in the input stream.  */
do|do
block|{
name|c
operator|=
operator|*
name|p
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|ISALPHA
argument_list|(
name|c
argument_list|)
operator|||
name|c
operator|==
literal|'_'
condition|)
do|;
comment|/* Terminate the word.  */
operator|*
operator|--
name|p
operator|=
literal|0
expr_stmt|;
comment|/* CPSR's and SPSR's can now be lowercase.  This is just a convenience      feature for ease of use and backwards compatibility.  */
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|start
argument_list|,
literal|"cpsr"
argument_list|,
literal|4
argument_list|)
condition|)
name|strncpy
argument_list|(
name|start
argument_list|,
literal|"CPSR"
argument_list|,
literal|4
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|start
argument_list|,
literal|"spsr"
argument_list|,
literal|4
argument_list|)
condition|)
name|strncpy
argument_list|(
name|start
argument_list|,
literal|"SPSR"
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* Now locate the word in the psr hash table.  */
name|psr
operator|=
operator|(
specifier|const
expr|struct
name|asm_psr
operator|*
operator|)
name|hash_find
argument_list|(
name|arm_psr_hsh
argument_list|,
name|start
argument_list|)
expr_stmt|;
comment|/* Restore the input stream.  */
operator|*
name|p
operator|=
name|c
expr_stmt|;
comment|/* If we found a valid match, advance the      stream pointer past the end of the word.  */
operator|*
name|ccp
operator|=
name|p
expr_stmt|;
return|return
name|psr
return|;
block|}
end_function

begin_comment
comment|/* Parse the input looking for a PSR flag.  */
end_comment

begin_function
specifier|static
name|int
name|psr_required_here
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
modifier|*
name|str
decl_stmt|;
block|{
name|char
modifier|*
name|start
init|=
operator|*
name|str
decl_stmt|;
specifier|const
name|struct
name|asm_psr
modifier|*
name|psr
decl_stmt|;
name|psr
operator|=
name|arm_psr_parse
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|psr
condition|)
block|{
comment|/* If this is the SPSR that is being modified, set the R bit.  */
if|if
condition|(
operator|!
name|psr
operator|->
name|cpsr
condition|)
name|inst
operator|.
name|instruction
operator||=
name|SPSR_BIT
expr_stmt|;
comment|/* Set the psr flags in the MSR instruction.  */
name|inst
operator|.
name|instruction
operator||=
name|psr
operator|->
name|field
operator|<<
name|PSR_SHIFT
expr_stmt|;
return|return
name|SUCCESS
return|;
block|}
comment|/* In the few cases where we might be able to accept      something else this error can be overridden.  */
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"flag for {c}psr instruction expected"
argument_list|)
expr_stmt|;
comment|/* Restore the start point.  */
operator|*
name|str
operator|=
name|start
expr_stmt|;
return|return
name|FAIL
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|co_proc_number
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
modifier|*
name|str
decl_stmt|;
block|{
name|int
name|processor
decl_stmt|,
name|pchar
decl_stmt|;
name|char
modifier|*
name|start
decl_stmt|;
name|skip_whitespace
argument_list|(
operator|*
name|str
argument_list|)
expr_stmt|;
name|start
operator|=
operator|*
name|str
expr_stmt|;
comment|/* The data sheet seems to imply that just a number on its own is valid      here, but the RISC iX assembler seems to accept a prefix 'p'.  We will      accept either.  */
if|if
condition|(
operator|(
name|processor
operator|=
name|arm_reg_parse
argument_list|(
name|str
argument_list|,
name|all_reg_maps
index|[
name|REG_TYPE_CP
index|]
operator|.
name|htab
argument_list|)
operator|)
operator|==
name|FAIL
condition|)
block|{
operator|*
name|str
operator|=
name|start
expr_stmt|;
name|pchar
operator|=
operator|*
operator|(
operator|*
name|str
operator|)
operator|++
expr_stmt|;
if|if
condition|(
name|pchar
operator|>=
literal|'0'
operator|&&
name|pchar
operator|<=
literal|'9'
condition|)
block|{
name|processor
operator|=
name|pchar
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
operator|*
operator|*
name|str
operator|>=
literal|'0'
operator|&&
operator|*
operator|*
name|str
operator|<=
literal|'9'
condition|)
block|{
name|processor
operator|=
name|processor
operator|*
literal|10
operator|+
operator|*
operator|(
operator|*
name|str
operator|)
operator|++
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
name|processor
operator|>
literal|15
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"illegal co-processor number"
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
block|}
block|}
block|}
else|else
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"bad or missing co-processor number"
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
block|}
block|}
name|inst
operator|.
name|instruction
operator||=
name|processor
operator|<<
literal|8
expr_stmt|;
return|return
name|SUCCESS
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cp_opc_expr
parameter_list|(
name|str
parameter_list|,
name|where
parameter_list|,
name|length
parameter_list|)
name|char
modifier|*
modifier|*
name|str
decl_stmt|;
name|int
name|where
decl_stmt|;
name|int
name|length
decl_stmt|;
block|{
name|expressionS
name|expr
decl_stmt|;
name|skip_whitespace
argument_list|(
operator|*
name|str
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|expr
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|my_get_expression
argument_list|(
operator|&
name|expr
argument_list|,
name|str
argument_list|)
condition|)
return|return
name|FAIL
return|;
if|if
condition|(
name|expr
operator|.
name|X_op
operator|!=
name|O_constant
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"bad or missing expression"
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
block|}
if|if
condition|(
operator|(
name|expr
operator|.
name|X_add_number
operator|&
operator|(
operator|(
literal|1
operator|<<
name|length
operator|)
operator|-
literal|1
operator|)
operator|)
operator|!=
name|expr
operator|.
name|X_add_number
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"immediate co-processor expression too large"
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
block|}
name|inst
operator|.
name|instruction
operator||=
name|expr
operator|.
name|X_add_number
operator|<<
name|where
expr_stmt|;
return|return
name|SUCCESS
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cp_reg_required_here
parameter_list|(
name|str
parameter_list|,
name|where
parameter_list|)
name|char
modifier|*
modifier|*
name|str
decl_stmt|;
name|int
name|where
decl_stmt|;
block|{
name|int
name|reg
decl_stmt|;
name|char
modifier|*
name|start
init|=
operator|*
name|str
decl_stmt|;
if|if
condition|(
operator|(
name|reg
operator|=
name|arm_reg_parse
argument_list|(
name|str
argument_list|,
name|all_reg_maps
index|[
name|REG_TYPE_CN
index|]
operator|.
name|htab
argument_list|)
operator|)
operator|!=
name|FAIL
condition|)
block|{
name|inst
operator|.
name|instruction
operator||=
name|reg
operator|<<
name|where
expr_stmt|;
return|return
name|reg
return|;
block|}
comment|/* In the few cases where we might be able to accept something else      this error can be overridden.  */
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"co-processor register expected"
argument_list|)
expr_stmt|;
comment|/* Restore the start point.  */
operator|*
name|str
operator|=
name|start
expr_stmt|;
return|return
name|FAIL
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|fp_reg_required_here
parameter_list|(
name|str
parameter_list|,
name|where
parameter_list|)
name|char
modifier|*
modifier|*
name|str
decl_stmt|;
name|int
name|where
decl_stmt|;
block|{
name|int
name|reg
decl_stmt|;
name|char
modifier|*
name|start
init|=
operator|*
name|str
decl_stmt|;
if|if
condition|(
operator|(
name|reg
operator|=
name|arm_reg_parse
argument_list|(
name|str
argument_list|,
name|all_reg_maps
index|[
name|REG_TYPE_FN
index|]
operator|.
name|htab
argument_list|)
operator|)
operator|!=
name|FAIL
condition|)
block|{
name|inst
operator|.
name|instruction
operator||=
name|reg
operator|<<
name|where
expr_stmt|;
return|return
name|reg
return|;
block|}
comment|/* In the few cases where we might be able to accept something else      this error can be overridden.  */
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"floating point register expected"
argument_list|)
expr_stmt|;
comment|/* Restore the start point.  */
operator|*
name|str
operator|=
name|start
expr_stmt|;
return|return
name|FAIL
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cp_address_offset
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
modifier|*
name|str
decl_stmt|;
block|{
name|int
name|offset
decl_stmt|;
name|skip_whitespace
argument_list|(
operator|*
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|is_immediate_prefix
argument_list|(
operator|*
operator|*
name|str
argument_list|)
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"immediate expression expected"
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
block|}
operator|(
operator|*
name|str
operator|)
operator|++
expr_stmt|;
if|if
condition|(
name|my_get_expression
argument_list|(
operator|&
name|inst
operator|.
name|reloc
operator|.
name|exp
argument_list|,
name|str
argument_list|)
condition|)
return|return
name|FAIL
return|;
if|if
condition|(
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_op
operator|==
name|O_constant
condition|)
block|{
name|offset
operator|=
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_add_number
expr_stmt|;
if|if
condition|(
name|offset
operator|&
literal|3
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"co-processor address must be word aligned"
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
block|}
if|if
condition|(
name|offset
operator|>
literal|1023
operator|||
name|offset
operator|<
operator|-
literal|1023
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"offset too large"
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
block|}
if|if
condition|(
name|offset
operator|>=
literal|0
condition|)
name|inst
operator|.
name|instruction
operator||=
name|INDEX_UP
expr_stmt|;
else|else
name|offset
operator|=
operator|-
name|offset
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|offset
operator|>>
literal|2
expr_stmt|;
block|}
else|else
name|inst
operator|.
name|reloc
operator|.
name|type
operator|=
name|BFD_RELOC_ARM_CP_OFF_IMM
expr_stmt|;
return|return
name|SUCCESS
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cp_address_required_here
parameter_list|(
name|str
parameter_list|,
name|wb_ok
parameter_list|)
name|char
modifier|*
modifier|*
name|str
decl_stmt|;
name|int
name|wb_ok
decl_stmt|;
block|{
name|char
modifier|*
name|p
init|=
operator|*
name|str
decl_stmt|;
name|int
name|pre_inc
init|=
literal|0
decl_stmt|;
name|int
name|write_back
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'['
condition|)
block|{
name|int
name|reg
decl_stmt|;
name|p
operator|++
expr_stmt|;
name|skip_whitespace
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|reg
operator|=
name|reg_required_here
argument_list|(
operator|&
name|p
argument_list|,
literal|16
argument_list|)
operator|)
operator|==
name|FAIL
condition|)
return|return
name|FAIL
return|;
name|skip_whitespace
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|']'
condition|)
block|{
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|wb_ok
operator|&&
name|skip_past_comma
argument_list|(
operator|&
name|p
argument_list|)
operator|==
name|SUCCESS
condition|)
block|{
comment|/* [Rn], #expr  */
name|write_back
operator|=
name|WRITE_BACK
expr_stmt|;
if|if
condition|(
name|reg
operator|==
name|REG_PC
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"pc may not be used in post-increment"
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
block|}
if|if
condition|(
name|cp_address_offset
argument_list|(
operator|&
name|p
argument_list|)
operator|==
name|FAIL
condition|)
return|return
name|FAIL
return|;
block|}
else|else
name|pre_inc
operator|=
name|PRE_INDEX
operator||
name|INDEX_UP
expr_stmt|;
block|}
else|else
block|{
comment|/* '['Rn, #expr']'[!]  */
if|if
condition|(
name|skip_past_comma
argument_list|(
operator|&
name|p
argument_list|)
operator|==
name|FAIL
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"pre-indexed expression expected"
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
block|}
name|pre_inc
operator|=
name|PRE_INDEX
expr_stmt|;
if|if
condition|(
name|cp_address_offset
argument_list|(
operator|&
name|p
argument_list|)
operator|==
name|FAIL
condition|)
return|return
name|FAIL
return|;
name|skip_whitespace
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|++
operator|!=
literal|']'
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"missing ]"
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
block|}
name|skip_whitespace
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|wb_ok
operator|&&
operator|*
name|p
operator|==
literal|'!'
condition|)
block|{
if|if
condition|(
name|reg
operator|==
name|REG_PC
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"pc may not be used with write-back"
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
block|}
name|p
operator|++
expr_stmt|;
name|write_back
operator|=
name|WRITE_BACK
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
name|my_get_expression
argument_list|(
operator|&
name|inst
operator|.
name|reloc
operator|.
name|exp
argument_list|,
operator|&
name|p
argument_list|)
condition|)
return|return
name|FAIL
return|;
name|inst
operator|.
name|reloc
operator|.
name|type
operator|=
name|BFD_RELOC_ARM_CP_OFF_IMM
expr_stmt|;
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_add_number
operator|-=
literal|8
expr_stmt|;
comment|/* PC rel adjust.  */
name|inst
operator|.
name|reloc
operator|.
name|pc_rel
operator|=
literal|1
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
operator|(
name|REG_PC
operator|<<
literal|16
operator|)
expr_stmt|;
name|pre_inc
operator|=
name|PRE_INDEX
expr_stmt|;
block|}
name|inst
operator|.
name|instruction
operator||=
name|write_back
operator||
name|pre_inc
expr_stmt|;
operator|*
name|str
operator|=
name|p
expr_stmt|;
return|return
name|SUCCESS
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_empty
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
comment|/* Do nothing really.  */
name|end_of_line
argument_list|(
name|str
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|do_mrs
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|int
name|skip
init|=
literal|0
decl_stmt|;
comment|/* Only one syntax.  */
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|12
argument_list|)
operator|==
name|FAIL
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|BAD_ARGS
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"comma expected after register name"
argument_list|)
expr_stmt|;
return|return;
block|}
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|str
argument_list|,
literal|"CPSR"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|str
argument_list|,
literal|"SPSR"
argument_list|)
operator|==
literal|0
comment|/* Lower case versions for backwards compatability.  */
operator|||
name|strcmp
argument_list|(
name|str
argument_list|,
literal|"cpsr"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|str
argument_list|,
literal|"spsr"
argument_list|)
operator|==
literal|0
condition|)
name|skip
operator|=
literal|4
expr_stmt|;
comment|/* This is for backwards compatability with older toolchains.  */
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|str
argument_list|,
literal|"cpsr_all"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|str
argument_list|,
literal|"spsr_all"
argument_list|)
operator|==
literal|0
condition|)
name|skip
operator|=
literal|8
expr_stmt|;
else|else
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"CPSR or SPSR expected"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|*
name|str
operator|==
literal|'s'
operator|||
operator|*
name|str
operator|==
literal|'S'
condition|)
name|inst
operator|.
name|instruction
operator||=
name|SPSR_BIT
expr_stmt|;
name|str
operator|+=
name|skip
expr_stmt|;
name|end_of_line
argument_list|(
name|str
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Two possible forms:       "{C|S}PSR_<field>, Rm",       "{C|S}PSR_f, #expression".  */
end_comment

begin_function
specifier|static
name|void
name|do_msr
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|psr_required_here
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
condition|)
return|return;
if|if
condition|(
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"comma missing after psr flags"
argument_list|)
expr_stmt|;
return|return;
block|}
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|0
argument_list|)
operator|!=
name|FAIL
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|NULL
expr_stmt|;
name|end_of_line
argument_list|(
name|str
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|is_immediate_prefix
argument_list|(
operator|*
name|str
argument_list|)
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"only a register or immediate value can follow a psr flag"
argument_list|)
expr_stmt|;
return|return;
block|}
name|str
operator|++
expr_stmt|;
name|inst
operator|.
name|error
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|my_get_expression
argument_list|(
operator|&
name|inst
operator|.
name|reloc
operator|.
name|exp
argument_list|,
operator|&
name|str
argument_list|)
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"only a register or immediate value can follow a psr flag"
argument_list|)
expr_stmt|;
return|return;
block|}
if|#
directive|if
literal|0
comment|/* The first edition of the ARM architecture manual stated that 	  writing anything other than the flags with an immediate operation 	  had UNPREDICTABLE effects.  This constraint was removed in the 	  second edition of the specification.  */
block|if ((cpu_variant& ARM_EXT_V5) != ARM_EXT_V5&& inst.instruction& ((PSR_c | PSR_x | PSR_s)<< PSR_SHIFT))     {       inst.error = _("immediate value cannot be used to set this field");       return;     }
endif|#
directive|endif
name|inst
operator|.
name|instruction
operator||=
name|INST_IMMEDIATE
expr_stmt|;
if|if
condition|(
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_add_symbol
condition|)
block|{
name|inst
operator|.
name|reloc
operator|.
name|type
operator|=
name|BFD_RELOC_ARM_IMMEDIATE
expr_stmt|;
name|inst
operator|.
name|reloc
operator|.
name|pc_rel
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|unsigned
name|value
init|=
name|validate_immediate
argument_list|(
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_add_number
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|==
operator|(
name|unsigned
operator|)
name|FAIL
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"invalid constant"
argument_list|)
expr_stmt|;
return|return;
block|}
name|inst
operator|.
name|instruction
operator||=
name|value
expr_stmt|;
block|}
name|inst
operator|.
name|error
operator|=
name|NULL
expr_stmt|;
name|end_of_line
argument_list|(
name|str
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Long Multiply Parser    UMULL RdLo, RdHi, Rm, Rs    SMULL RdLo, RdHi, Rm, Rs    UMLAL RdLo, RdHi, Rm, Rs    SMLAL RdLo, RdHi, Rm, Rs.  */
end_comment

begin_function
specifier|static
name|void
name|do_mull
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|int
name|rdlo
decl_stmt|,
name|rdhi
decl_stmt|,
name|rm
decl_stmt|,
name|rs
decl_stmt|;
comment|/* Only one format "rdlo, rdhi, rm, rs".  */
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|rdlo
operator|=
name|reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|12
argument_list|)
operator|)
operator|==
name|FAIL
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|BAD_ARGS
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
operator|||
operator|(
name|rdhi
operator|=
name|reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|16
argument_list|)
operator|)
operator|==
name|FAIL
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|BAD_ARGS
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
operator|||
operator|(
name|rm
operator|=
name|reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
name|FAIL
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|BAD_ARGS
expr_stmt|;
return|return;
block|}
comment|/* rdhi, rdlo and rm must all be different.  */
if|if
condition|(
name|rdlo
operator|==
name|rdhi
operator|||
name|rdlo
operator|==
name|rm
operator|||
name|rdhi
operator|==
name|rm
condition|)
name|as_tsktsk
argument_list|(
name|_
argument_list|(
literal|"rdhi, rdlo and rm must all be different"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
operator|||
operator|(
name|rs
operator|=
name|reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|8
argument_list|)
operator|)
operator|==
name|FAIL
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|BAD_ARGS
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|rdhi
operator|==
name|REG_PC
operator|||
name|rdhi
operator|==
name|REG_PC
operator|||
name|rdhi
operator|==
name|REG_PC
operator|||
name|rdhi
operator|==
name|REG_PC
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|BAD_PC
expr_stmt|;
return|return;
block|}
name|end_of_line
argument_list|(
name|str
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|do_mul
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|int
name|rd
decl_stmt|,
name|rm
decl_stmt|;
comment|/* Only one format "rd, rm, rs".  */
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|rd
operator|=
name|reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|16
argument_list|)
operator|)
operator|==
name|FAIL
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|BAD_ARGS
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|rd
operator|==
name|REG_PC
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|BAD_PC
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
operator|||
operator|(
name|rm
operator|=
name|reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
name|FAIL
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|BAD_ARGS
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|rm
operator|==
name|REG_PC
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|BAD_PC
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|rm
operator|==
name|rd
condition|)
name|as_tsktsk
argument_list|(
name|_
argument_list|(
literal|"rd and rm should be different in mul"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
operator|||
operator|(
name|rm
operator|=
name|reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|8
argument_list|)
operator|)
operator|==
name|FAIL
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|BAD_ARGS
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|rm
operator|==
name|REG_PC
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|BAD_PC
expr_stmt|;
return|return;
block|}
name|end_of_line
argument_list|(
name|str
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|do_mla
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|int
name|rd
decl_stmt|,
name|rm
decl_stmt|;
comment|/* Only one format "rd, rm, rs, rn".  */
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|rd
operator|=
name|reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|16
argument_list|)
operator|)
operator|==
name|FAIL
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|BAD_ARGS
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|rd
operator|==
name|REG_PC
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|BAD_PC
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
operator|||
operator|(
name|rm
operator|=
name|reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
name|FAIL
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|BAD_ARGS
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|rm
operator|==
name|REG_PC
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|BAD_PC
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|rm
operator|==
name|rd
condition|)
name|as_tsktsk
argument_list|(
name|_
argument_list|(
literal|"rd and rm should be different in mla"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
operator|||
operator|(
name|rd
operator|=
name|reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|8
argument_list|)
operator|)
operator|==
name|FAIL
operator|||
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
operator|||
operator|(
name|rm
operator|=
name|reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|12
argument_list|)
operator|)
operator|==
name|FAIL
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|BAD_ARGS
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|rd
operator|==
name|REG_PC
operator|||
name|rm
operator|==
name|REG_PC
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|BAD_PC
expr_stmt|;
return|return;
block|}
name|end_of_line
argument_list|(
name|str
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* Expects *str -> the characters "acc0", possibly with leading blanks.    Advances *str to the next non-alphanumeric.    Returns 0, or else FAIL (in which case sets inst.error).    (In a future XScale, there may be accumulators other than zero.   At that time this routine and its callers can be upgraded to suit.)  */
end_comment

begin_function
specifier|static
name|int
name|accum0_required_here
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
modifier|*
name|str
decl_stmt|;
block|{
specifier|static
name|char
name|buff
index|[
literal|128
index|]
decl_stmt|;
comment|/* Note the address is taken.  Hence, static.  */
name|char
modifier|*
name|p
init|=
operator|*
name|str
decl_stmt|;
name|char
name|c
decl_stmt|;
name|int
name|result
init|=
literal|0
decl_stmt|;
comment|/* The accum number.  */
name|skip_whitespace
argument_list|(
name|p
argument_list|)
expr_stmt|;
operator|*
name|str
operator|=
name|p
expr_stmt|;
comment|/* Advance caller's string pointer too.  */
name|c
operator|=
operator|*
name|p
operator|++
expr_stmt|;
while|while
condition|(
name|ISALNUM
argument_list|(
name|c
argument_list|)
condition|)
name|c
operator|=
operator|*
name|p
operator|++
expr_stmt|;
operator|*
operator|--
name|p
operator|=
literal|0
expr_stmt|;
comment|/* Aap nul into input buffer at non-alnum.  */
if|if
condition|(
operator|!
operator|(
name|streq
argument_list|(
operator|*
name|str
argument_list|,
literal|"acc0"
argument_list|)
operator|||
name|streq
argument_list|(
operator|*
name|str
argument_list|,
literal|"ACC0"
argument_list|)
operator|)
condition|)
block|{
name|sprintf
argument_list|(
name|buff
argument_list|,
name|_
argument_list|(
literal|"acc0 expected, not '%.100s'"
argument_list|)
argument_list|,
operator|*
name|str
argument_list|)
expr_stmt|;
name|inst
operator|.
name|error
operator|=
name|buff
expr_stmt|;
name|result
operator|=
name|FAIL
expr_stmt|;
block|}
operator|*
name|p
operator|=
name|c
expr_stmt|;
comment|/* Unzap.  */
operator|*
name|str
operator|=
name|p
expr_stmt|;
comment|/* Caller's string pointer to after match.  */
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Expects **str -> after a comma. May be leading blanks.    Advances *str, recognizing a load  mode, and setting inst.instruction.    Returns rn, or else FAIL (in which case may set inst.error    and not advance str)     Note: doesn't know Rd, so no err checks that require such knowledge.  */
end_comment

begin_function
specifier|static
name|int
name|ld_mode_required_here
parameter_list|(
name|string
parameter_list|)
name|char
modifier|*
modifier|*
name|string
decl_stmt|;
block|{
name|char
modifier|*
name|str
init|=
operator|*
name|string
decl_stmt|;
name|int
name|rn
decl_stmt|;
name|int
name|pre_inc
init|=
literal|0
decl_stmt|;
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|str
operator|==
literal|'['
condition|)
block|{
name|str
operator|++
expr_stmt|;
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|rn
operator|=
name|reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|16
argument_list|)
operator|)
operator|==
name|FAIL
condition|)
return|return
name|FAIL
return|;
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|str
operator|==
literal|']'
condition|)
block|{
name|str
operator|++
expr_stmt|;
if|if
condition|(
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|SUCCESS
condition|)
block|{
comment|/* [Rn],... (post inc) */
if|if
condition|(
name|ldst_extend_v4
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
condition|)
return|return
name|FAIL
return|;
block|}
else|else
comment|/* [Rn] */
block|{
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|str
operator|==
literal|'!'
condition|)
block|{
name|str
operator|++
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|WRITE_BACK
expr_stmt|;
block|}
name|inst
operator|.
name|instruction
operator||=
name|INDEX_UP
operator||
name|HWOFFSET_IMM
expr_stmt|;
name|pre_inc
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
comment|/* [Rn,...] */
block|{
if|if
condition|(
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"pre-indexed expression expected"
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
block|}
name|pre_inc
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|ldst_extend_v4
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
condition|)
return|return
name|FAIL
return|;
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|str
operator|++
operator|!=
literal|']'
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"missing ]"
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
block|}
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|str
operator|==
literal|'!'
condition|)
block|{
name|str
operator|++
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|WRITE_BACK
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
operator|*
name|str
operator|==
literal|'='
condition|)
comment|/* ldr's "r,=label" syntax */
comment|/* We should never reach here, because<text> =<expression> is        caught gas/read.c read_a_source_file() as a .set operation.  */
return|return
name|FAIL
return|;
else|else
comment|/* PC +- 8 bit immediate offset.  */
block|{
if|if
condition|(
name|my_get_expression
argument_list|(
operator|&
name|inst
operator|.
name|reloc
operator|.
name|exp
argument_list|,
operator|&
name|str
argument_list|)
condition|)
return|return
name|FAIL
return|;
name|inst
operator|.
name|instruction
operator||=
name|HWOFFSET_IMM
expr_stmt|;
comment|/* The I bit.  */
name|inst
operator|.
name|reloc
operator|.
name|type
operator|=
name|BFD_RELOC_ARM_OFFSET_IMM8
expr_stmt|;
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_add_number
operator|-=
literal|8
expr_stmt|;
comment|/* PC rel adjust.  */
name|inst
operator|.
name|reloc
operator|.
name|pc_rel
operator|=
literal|1
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
operator|(
name|REG_PC
operator|<<
literal|16
operator|)
expr_stmt|;
name|rn
operator|=
name|REG_PC
expr_stmt|;
name|pre_inc
operator|=
literal|1
expr_stmt|;
block|}
name|inst
operator|.
name|instruction
operator||=
operator|(
name|pre_inc
condition|?
name|PRE_INDEX
else|:
literal|0
operator|)
expr_stmt|;
operator|*
name|string
operator|=
name|str
expr_stmt|;
return|return
name|rn
return|;
block|}
end_function

begin_comment
comment|/* ARM V5E (El Segundo) signed-multiply-accumulate (argument parse)    SMLAxy{cond} Rd,Rm,Rs,Rn    SMLAWy{cond} Rd,Rm,Rs,Rn    Error if any register is R15.  */
end_comment

begin_function
specifier|static
name|void
name|do_smla
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|int
name|rd
decl_stmt|,
name|rm
decl_stmt|,
name|rs
decl_stmt|,
name|rn
decl_stmt|;
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|rd
operator|=
name|reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|16
argument_list|)
operator|)
operator|==
name|FAIL
operator|||
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
operator|||
operator|(
name|rm
operator|=
name|reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
name|FAIL
operator|||
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
operator|||
operator|(
name|rs
operator|=
name|reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|8
argument_list|)
operator|)
operator|==
name|FAIL
operator|||
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
operator|||
operator|(
name|rn
operator|=
name|reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|12
argument_list|)
operator|)
operator|==
name|FAIL
condition|)
name|inst
operator|.
name|error
operator|=
name|BAD_ARGS
expr_stmt|;
elseif|else
if|if
condition|(
name|rd
operator|==
name|REG_PC
operator|||
name|rm
operator|==
name|REG_PC
operator|||
name|rs
operator|==
name|REG_PC
operator|||
name|rn
operator|==
name|REG_PC
condition|)
name|inst
operator|.
name|error
operator|=
name|BAD_PC
expr_stmt|;
else|else
name|end_of_line
argument_list|(
name|str
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ARM V5E (El Segundo) signed-multiply-accumulate-long (argument parse)    SMLALxy{cond} Rdlo,Rdhi,Rm,Rs    Error if any register is R15.    Warning if Rdlo == Rdhi.  */
end_comment

begin_function
specifier|static
name|void
name|do_smlal
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|int
name|rdlo
decl_stmt|,
name|rdhi
decl_stmt|,
name|rm
decl_stmt|,
name|rs
decl_stmt|;
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|rdlo
operator|=
name|reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|12
argument_list|)
operator|)
operator|==
name|FAIL
operator|||
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
operator|||
operator|(
name|rdhi
operator|=
name|reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|16
argument_list|)
operator|)
operator|==
name|FAIL
operator|||
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
operator|||
operator|(
name|rm
operator|=
name|reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
name|FAIL
operator|||
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
operator|||
operator|(
name|rs
operator|=
name|reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|8
argument_list|)
operator|)
operator|==
name|FAIL
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|BAD_ARGS
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|rdlo
operator|==
name|REG_PC
operator|||
name|rdhi
operator|==
name|REG_PC
operator|||
name|rm
operator|==
name|REG_PC
operator|||
name|rs
operator|==
name|REG_PC
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|BAD_PC
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|rdlo
operator|==
name|rdhi
condition|)
name|as_tsktsk
argument_list|(
name|_
argument_list|(
literal|"rdhi and rdlo must be different"
argument_list|)
argument_list|)
expr_stmt|;
name|end_of_line
argument_list|(
name|str
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ARM V5E (El Segundo) signed-multiply (argument parse)    SMULxy{cond} Rd,Rm,Rs    Error if any register is R15.  */
end_comment

begin_function
specifier|static
name|void
name|do_smul
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|int
name|rd
decl_stmt|,
name|rm
decl_stmt|,
name|rs
decl_stmt|;
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|rd
operator|=
name|reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|16
argument_list|)
operator|)
operator|==
name|FAIL
operator|||
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
operator|||
operator|(
name|rm
operator|=
name|reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
name|FAIL
operator|||
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
operator|||
operator|(
name|rs
operator|=
name|reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|8
argument_list|)
operator|)
operator|==
name|FAIL
condition|)
name|inst
operator|.
name|error
operator|=
name|BAD_ARGS
expr_stmt|;
elseif|else
if|if
condition|(
name|rd
operator|==
name|REG_PC
operator|||
name|rm
operator|==
name|REG_PC
operator|||
name|rs
operator|==
name|REG_PC
condition|)
name|inst
operator|.
name|error
operator|=
name|BAD_PC
expr_stmt|;
else|else
name|end_of_line
argument_list|(
name|str
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ARM V5E (El Segundo) saturating-add/subtract (argument parse)    Q[D]{ADD,SUB}{cond} Rd,Rm,Rn    Error if any register is R15.  */
end_comment

begin_function
specifier|static
name|void
name|do_qadd
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|int
name|rd
decl_stmt|,
name|rm
decl_stmt|,
name|rn
decl_stmt|;
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|rd
operator|=
name|reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|12
argument_list|)
operator|)
operator|==
name|FAIL
operator|||
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
operator|||
operator|(
name|rm
operator|=
name|reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
name|FAIL
operator|||
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
operator|||
operator|(
name|rn
operator|=
name|reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|16
argument_list|)
operator|)
operator|==
name|FAIL
condition|)
name|inst
operator|.
name|error
operator|=
name|BAD_ARGS
expr_stmt|;
elseif|else
if|if
condition|(
name|rd
operator|==
name|REG_PC
operator|||
name|rm
operator|==
name|REG_PC
operator|||
name|rn
operator|==
name|REG_PC
condition|)
name|inst
operator|.
name|error
operator|=
name|BAD_PC
expr_stmt|;
else|else
name|end_of_line
argument_list|(
name|str
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ARM V5E (el Segundo)    MCRRcc<coproc>,<opcode>,<Rd>,<Rn>,<CRm>.    MRRCcc<coproc>,<opcode>,<Rd>,<Rn>,<CRm>.     These are equivalent to the XScale instructions MAR and MRA,    respectively, when coproc == 0, opcode == 0, and CRm == 0.     Result unpredicatable if Rd or Rn is R15.  */
end_comment

begin_function
specifier|static
name|void
name|do_co_reg2c
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|int
name|rd
decl_stmt|,
name|rn
decl_stmt|;
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|co_proc_number
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
condition|)
block|{
if|if
condition|(
operator|!
name|inst
operator|.
name|error
condition|)
name|inst
operator|.
name|error
operator|=
name|BAD_ARGS
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
operator|||
name|cp_opc_expr
argument_list|(
operator|&
name|str
argument_list|,
literal|4
argument_list|,
literal|4
argument_list|)
operator|==
name|FAIL
condition|)
block|{
if|if
condition|(
operator|!
name|inst
operator|.
name|error
condition|)
name|inst
operator|.
name|error
operator|=
name|BAD_ARGS
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
operator|||
operator|(
name|rd
operator|=
name|reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|12
argument_list|)
operator|)
operator|==
name|FAIL
condition|)
block|{
if|if
condition|(
operator|!
name|inst
operator|.
name|error
condition|)
name|inst
operator|.
name|error
operator|=
name|BAD_ARGS
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
operator|||
operator|(
name|rn
operator|=
name|reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|16
argument_list|)
operator|)
operator|==
name|FAIL
condition|)
block|{
if|if
condition|(
operator|!
name|inst
operator|.
name|error
condition|)
name|inst
operator|.
name|error
operator|=
name|BAD_ARGS
expr_stmt|;
return|return;
block|}
comment|/* Unpredictable result if rd or rn is R15.  */
if|if
condition|(
name|rd
operator|==
name|REG_PC
operator|||
name|rn
operator|==
name|REG_PC
condition|)
name|as_tsktsk
argument_list|(
name|_
argument_list|(
literal|"Warning: instruction unpredictable when using r15"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
operator|||
name|cp_reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|0
argument_list|)
operator|==
name|FAIL
condition|)
block|{
if|if
condition|(
operator|!
name|inst
operator|.
name|error
condition|)
name|inst
operator|.
name|error
operator|=
name|BAD_ARGS
expr_stmt|;
return|return;
block|}
name|end_of_line
argument_list|(
name|str
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ARM V5 count-leading-zeroes instruction (argument parse)      CLZ{<cond>}<Rd>,<Rm>      Condition defaults to COND_ALWAYS.      Error if Rd or Rm are R15.  */
end_comment

begin_function
specifier|static
name|void
name|do_clz
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|int
name|rd
decl_stmt|,
name|rm
decl_stmt|;
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|rd
operator|=
name|reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|12
argument_list|)
operator|)
operator|==
name|FAIL
operator|)
operator|||
operator|(
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
operator|)
operator|||
operator|(
operator|(
name|rm
operator|=
name|reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
name|FAIL
operator|)
condition|)
name|inst
operator|.
name|error
operator|=
name|BAD_ARGS
expr_stmt|;
elseif|else
if|if
condition|(
name|rd
operator|==
name|REG_PC
operator|||
name|rm
operator|==
name|REG_PC
condition|)
name|inst
operator|.
name|error
operator|=
name|BAD_PC
expr_stmt|;
else|else
name|end_of_line
argument_list|(
name|str
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ARM V5 (argument parse)      LDC2{L}<coproc>,<CRd>,<addressing mode>      STC2{L}<coproc>,<CRd>,<addressing mode>      Instruction is not conditional, and has 0xf in the codition field.      Otherwise, it's the same as LDC/STC.  */
end_comment

begin_function
specifier|static
name|void
name|do_lstc2
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|co_proc_number
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
condition|)
block|{
if|if
condition|(
operator|!
name|inst
operator|.
name|error
condition|)
name|inst
operator|.
name|error
operator|=
name|BAD_ARGS
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
operator|||
name|cp_reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|12
argument_list|)
operator|==
name|FAIL
condition|)
block|{
if|if
condition|(
operator|!
name|inst
operator|.
name|error
condition|)
name|inst
operator|.
name|error
operator|=
name|BAD_ARGS
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
operator|||
name|cp_address_required_here
argument_list|(
operator|&
name|str
argument_list|,
name|CP_WB_OK
argument_list|)
operator|==
name|FAIL
condition|)
block|{
if|if
condition|(
operator|!
name|inst
operator|.
name|error
condition|)
name|inst
operator|.
name|error
operator|=
name|BAD_ARGS
expr_stmt|;
block|}
else|else
name|end_of_line
argument_list|(
name|str
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ARM V5 (argument parse)      CDP2<coproc>,<opcode_1>,<CRd>,<CRn>,<CRm>,<opcode_2>      Instruction is not conditional, and has 0xf in the condition field.      Otherwise, it's the same as CDP.  */
end_comment

begin_function
specifier|static
name|void
name|do_cdp2
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|co_proc_number
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
condition|)
block|{
if|if
condition|(
operator|!
name|inst
operator|.
name|error
condition|)
name|inst
operator|.
name|error
operator|=
name|BAD_ARGS
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
operator|||
name|cp_opc_expr
argument_list|(
operator|&
name|str
argument_list|,
literal|20
argument_list|,
literal|4
argument_list|)
operator|==
name|FAIL
condition|)
block|{
if|if
condition|(
operator|!
name|inst
operator|.
name|error
condition|)
name|inst
operator|.
name|error
operator|=
name|BAD_ARGS
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
operator|||
name|cp_reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|12
argument_list|)
operator|==
name|FAIL
condition|)
block|{
if|if
condition|(
operator|!
name|inst
operator|.
name|error
condition|)
name|inst
operator|.
name|error
operator|=
name|BAD_ARGS
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
operator|||
name|cp_reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|16
argument_list|)
operator|==
name|FAIL
condition|)
block|{
if|if
condition|(
operator|!
name|inst
operator|.
name|error
condition|)
name|inst
operator|.
name|error
operator|=
name|BAD_ARGS
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
operator|||
name|cp_reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|0
argument_list|)
operator|==
name|FAIL
condition|)
block|{
if|if
condition|(
operator|!
name|inst
operator|.
name|error
condition|)
name|inst
operator|.
name|error
operator|=
name|BAD_ARGS
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|SUCCESS
condition|)
block|{
if|if
condition|(
name|cp_opc_expr
argument_list|(
operator|&
name|str
argument_list|,
literal|5
argument_list|,
literal|3
argument_list|)
operator|==
name|FAIL
condition|)
block|{
if|if
condition|(
operator|!
name|inst
operator|.
name|error
condition|)
name|inst
operator|.
name|error
operator|=
name|BAD_ARGS
expr_stmt|;
return|return;
block|}
block|}
name|end_of_line
argument_list|(
name|str
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ARM V5 (argument parse)      MCR2<coproc>,<opcode_1>,<Rd>,<CRn>,<CRm>,<opcode_2>      MRC2<coproc>,<opcode_1>,<Rd>,<CRn>,<CRm>,<opcode_2>      Instruction is not conditional, and has 0xf in the condition field.      Otherwise, it's the same as MCR/MRC.  */
end_comment

begin_function
specifier|static
name|void
name|do_co_reg2
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|co_proc_number
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
condition|)
block|{
if|if
condition|(
operator|!
name|inst
operator|.
name|error
condition|)
name|inst
operator|.
name|error
operator|=
name|BAD_ARGS
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
operator|||
name|cp_opc_expr
argument_list|(
operator|&
name|str
argument_list|,
literal|21
argument_list|,
literal|3
argument_list|)
operator|==
name|FAIL
condition|)
block|{
if|if
condition|(
operator|!
name|inst
operator|.
name|error
condition|)
name|inst
operator|.
name|error
operator|=
name|BAD_ARGS
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
operator|||
name|reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|12
argument_list|)
operator|==
name|FAIL
condition|)
block|{
if|if
condition|(
operator|!
name|inst
operator|.
name|error
condition|)
name|inst
operator|.
name|error
operator|=
name|BAD_ARGS
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
operator|||
name|cp_reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|16
argument_list|)
operator|==
name|FAIL
condition|)
block|{
if|if
condition|(
operator|!
name|inst
operator|.
name|error
condition|)
name|inst
operator|.
name|error
operator|=
name|BAD_ARGS
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
operator|||
name|cp_reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|0
argument_list|)
operator|==
name|FAIL
condition|)
block|{
if|if
condition|(
operator|!
name|inst
operator|.
name|error
condition|)
name|inst
operator|.
name|error
operator|=
name|BAD_ARGS
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|SUCCESS
condition|)
block|{
if|if
condition|(
name|cp_opc_expr
argument_list|(
operator|&
name|str
argument_list|,
literal|5
argument_list|,
literal|3
argument_list|)
operator|==
name|FAIL
condition|)
block|{
if|if
condition|(
operator|!
name|inst
operator|.
name|error
condition|)
name|inst
operator|.
name|error
operator|=
name|BAD_ARGS
expr_stmt|;
return|return;
block|}
block|}
name|end_of_line
argument_list|(
name|str
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ARM v5TEJ.  Jump to Jazelle code.  */
end_comment

begin_function
specifier|static
name|void
name|do_bxj
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|int
name|reg
decl_stmt|;
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|reg
operator|=
name|reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
name|FAIL
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|BAD_ARGS
expr_stmt|;
return|return;
block|}
comment|/* Note - it is not illegal to do a "bxj pc".  Useless, but not illegal.  */
if|if
condition|(
name|reg
operator|==
name|REG_PC
condition|)
name|as_tsktsk
argument_list|(
name|_
argument_list|(
literal|"use of r15 in bxj is not really useful"
argument_list|)
argument_list|)
expr_stmt|;
name|end_of_line
argument_list|(
name|str
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* THUMB V5 breakpoint instruction (argument parse) 	BKPT<immed_8>.  */
end_comment

begin_function
specifier|static
name|void
name|do_t_bkpt
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|expressionS
name|expr
decl_stmt|;
name|unsigned
name|long
name|number
decl_stmt|;
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
comment|/* Allow optional leading '#'.  */
if|if
condition|(
name|is_immediate_prefix
argument_list|(
operator|*
name|str
argument_list|)
condition|)
name|str
operator|++
expr_stmt|;
name|memset
argument_list|(
operator|&
name|expr
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|my_get_expression
argument_list|(
operator|&
name|expr
argument_list|,
operator|&
name|str
argument_list|)
operator|||
operator|(
name|expr
operator|.
name|X_op
operator|!=
name|O_constant
operator|)
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"bad or missing expression"
argument_list|)
expr_stmt|;
return|return;
block|}
name|number
operator|=
name|expr
operator|.
name|X_add_number
expr_stmt|;
comment|/* Check it fits an 8 bit unsigned.  */
if|if
condition|(
name|number
operator|!=
operator|(
name|number
operator|&
literal|0xff
operator|)
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"immediate value out of range"
argument_list|)
expr_stmt|;
return|return;
block|}
name|inst
operator|.
name|instruction
operator||=
name|number
expr_stmt|;
name|end_of_line
argument_list|(
name|str
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ARM V5 branch-link-exchange (argument parse) for BLX(1) only.    Expects inst.instruction is set for BLX(1).    Note: this is cloned from do_branch, and the reloc changed to be a 	new one that can cope with setting one extra bit (the H bit).  */
end_comment

begin_function
specifier|static
name|void
name|do_branch25
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
if|if
condition|(
name|my_get_expression
argument_list|(
operator|&
name|inst
operator|.
name|reloc
operator|.
name|exp
argument_list|,
operator|&
name|str
argument_list|)
condition|)
return|return;
ifdef|#
directive|ifdef
name|OBJ_ELF
block|{
name|char
modifier|*
name|save_in
decl_stmt|;
comment|/* ScottB: February 5, 1998 */
comment|/* Check to see of PLT32 reloc required for the instruction.  */
comment|/* arm_parse_reloc() works on input_line_pointer.        We actually want to parse the operands to the branch instruction        passed in 'str'.  Save the input pointer and restore it later.  */
name|save_in
operator|=
name|input_line_pointer
expr_stmt|;
name|input_line_pointer
operator|=
name|str
expr_stmt|;
if|if
condition|(
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_op
operator|==
name|O_symbol
operator|&&
operator|*
name|str
operator|==
literal|'('
operator|&&
name|arm_parse_reloc
argument_list|()
operator|==
name|BFD_RELOC_ARM_PLT32
condition|)
block|{
name|inst
operator|.
name|reloc
operator|.
name|type
operator|=
name|BFD_RELOC_ARM_PLT32
expr_stmt|;
name|inst
operator|.
name|reloc
operator|.
name|pc_rel
operator|=
literal|0
expr_stmt|;
comment|/* Modify str to point to after parsed operands, otherwise 	   end_of_line() will complain about the (PLT) left in str.  */
name|str
operator|=
name|input_line_pointer
expr_stmt|;
block|}
else|else
block|{
name|inst
operator|.
name|reloc
operator|.
name|type
operator|=
name|BFD_RELOC_ARM_PCREL_BLX
expr_stmt|;
name|inst
operator|.
name|reloc
operator|.
name|pc_rel
operator|=
literal|1
expr_stmt|;
block|}
name|input_line_pointer
operator|=
name|save_in
expr_stmt|;
block|}
else|#
directive|else
name|inst
operator|.
name|reloc
operator|.
name|type
operator|=
name|BFD_RELOC_ARM_PCREL_BLX
expr_stmt|;
name|inst
operator|.
name|reloc
operator|.
name|pc_rel
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
comment|/* OBJ_ELF */
name|end_of_line
argument_list|(
name|str
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ARM V5 branch-link-exchange instruction (argument parse)      BLX<target_addr>		ie BLX(1)      BLX{<condition>}<Rm>	ie BLX(2)    Unfortunately, there are two different opcodes for this mnemonic.    So, the insns[].value is not used, and the code here zaps values 	into inst.instruction.    Also, the<target_addr> can be 25 bits, hence has its own reloc.  */
end_comment

begin_function
specifier|static
name|void
name|do_blx
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|char
modifier|*
name|mystr
init|=
name|str
decl_stmt|;
name|int
name|rm
decl_stmt|;
name|skip_whitespace
argument_list|(
name|mystr
argument_list|)
expr_stmt|;
name|rm
operator|=
name|reg_required_here
argument_list|(
operator|&
name|mystr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* The above may set inst.error.  Ignore his opinion.  */
name|inst
operator|.
name|error
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|rm
operator|!=
name|FAIL
condition|)
block|{
comment|/* Arg is a register. 	 Use the condition code our caller put in inst.instruction. 	 Pass ourselves off as a BX with a funny opcode.  */
name|inst
operator|.
name|instruction
operator||=
literal|0x012fff30
expr_stmt|;
name|do_bx
argument_list|(
name|str
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* This must be is BLX<target address>, no condition allowed.  */
if|if
condition|(
name|inst
operator|.
name|instruction
operator|!=
name|COND_ALWAYS
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|BAD_COND
expr_stmt|;
return|return;
block|}
name|inst
operator|.
name|instruction
operator|=
literal|0xfafffffe
expr_stmt|;
comment|/* Process like a B/BL, but with a different reloc. 	 Note that B/BL expecte fffffe, not 0, offset in the opcode table.  */
name|do_branch25
argument_list|(
name|str
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ARM V5 Thumb BLX (argument parse) 	BLX<target_addr>	which is BLX(1) 	BLX<Rm>		which is BLX(2)    Unfortunately, there are two different opcodes for this mnemonic.    So, the tinsns[].value is not used, and the code here zaps values 	into inst.instruction.	*/
end_comment

begin_function
specifier|static
name|void
name|do_t_blx
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|char
modifier|*
name|mystr
init|=
name|str
decl_stmt|;
name|int
name|rm
decl_stmt|;
name|skip_whitespace
argument_list|(
name|mystr
argument_list|)
expr_stmt|;
name|inst
operator|.
name|instruction
operator|=
literal|0x4780
expr_stmt|;
comment|/* Note that this call is to the ARM register recognizer.  BLX(2)      uses the ARM register space, not the Thumb one, so a call to      thumb_reg() would be wrong.  */
name|rm
operator|=
name|reg_required_here
argument_list|(
operator|&
name|mystr
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|inst
operator|.
name|error
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|rm
operator|!=
name|FAIL
condition|)
block|{
comment|/* It's BLX(2).  The .instruction was zapped with rm& is final.  */
name|inst
operator|.
name|size
operator|=
literal|2
expr_stmt|;
block|}
else|else
block|{
comment|/* No ARM register.  This must be BLX(1).  Change the .instruction.  */
name|inst
operator|.
name|instruction
operator|=
literal|0xf7ffeffe
expr_stmt|;
name|inst
operator|.
name|size
operator|=
literal|4
expr_stmt|;
if|if
condition|(
name|my_get_expression
argument_list|(
operator|&
name|inst
operator|.
name|reloc
operator|.
name|exp
argument_list|,
operator|&
name|mystr
argument_list|)
condition|)
return|return;
name|inst
operator|.
name|reloc
operator|.
name|type
operator|=
name|BFD_RELOC_THUMB_PCREL_BLX
expr_stmt|;
name|inst
operator|.
name|reloc
operator|.
name|pc_rel
operator|=
literal|1
expr_stmt|;
block|}
name|end_of_line
argument_list|(
name|mystr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ARM V5 breakpoint instruction (argument parse)      BKPT<16 bit unsigned immediate>      Instruction is not conditional. 	The bit pattern given in insns[] has the COND_ALWAYS condition, 	and it is an error if the caller tried to override that. */
end_comment

begin_function
specifier|static
name|void
name|do_bkpt
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|expressionS
name|expr
decl_stmt|;
name|unsigned
name|long
name|number
decl_stmt|;
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
comment|/* Allow optional leading '#'.  */
if|if
condition|(
name|is_immediate_prefix
argument_list|(
operator|*
name|str
argument_list|)
condition|)
name|str
operator|++
expr_stmt|;
name|memset
argument_list|(
operator|&
name|expr
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|my_get_expression
argument_list|(
operator|&
name|expr
argument_list|,
operator|&
name|str
argument_list|)
operator|||
operator|(
name|expr
operator|.
name|X_op
operator|!=
name|O_constant
operator|)
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"bad or missing expression"
argument_list|)
expr_stmt|;
return|return;
block|}
name|number
operator|=
name|expr
operator|.
name|X_add_number
expr_stmt|;
comment|/* Check it fits a 16 bit unsigned.  */
if|if
condition|(
name|number
operator|!=
operator|(
name|number
operator|&
literal|0xffff
operator|)
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"immediate value out of range"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Top 12 of 16 bits to bits 19:8.  */
name|inst
operator|.
name|instruction
operator||=
operator|(
name|number
operator|&
literal|0xfff0
operator|)
operator|<<
literal|4
expr_stmt|;
comment|/* Bottom 4 of 16 bits to bits 3:0.  */
name|inst
operator|.
name|instruction
operator||=
name|number
operator|&
literal|0xf
expr_stmt|;
name|end_of_line
argument_list|(
name|str
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Xscale multiply-accumulate (argument parse)      MIAcc   acc0,Rm,Rs      MIAPHcc acc0,Rm,Rs      MIAxycc acc0,Rm,Rs.  */
end_comment

begin_function
specifier|static
name|void
name|do_xsc_mia
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|int
name|rs
decl_stmt|;
name|int
name|rm
decl_stmt|;
if|if
condition|(
name|accum0_required_here
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
condition|)
name|inst
operator|.
name|error
operator|=
name|ERR_NO_ACCUM
expr_stmt|;
elseif|else
if|if
condition|(
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
operator|||
operator|(
name|rm
operator|=
name|reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
name|FAIL
condition|)
name|inst
operator|.
name|error
operator|=
name|BAD_ARGS
expr_stmt|;
elseif|else
if|if
condition|(
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
operator|||
operator|(
name|rs
operator|=
name|reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|12
argument_list|)
operator|)
operator|==
name|FAIL
condition|)
name|inst
operator|.
name|error
operator|=
name|BAD_ARGS
expr_stmt|;
comment|/* inst.instruction has now been zapped with both rm and rs.  */
elseif|else
if|if
condition|(
name|rm
operator|==
name|REG_PC
operator|||
name|rs
operator|==
name|REG_PC
condition|)
name|inst
operator|.
name|error
operator|=
name|BAD_PC
expr_stmt|;
comment|/* Undefined result if rm or rs is R15.  */
else|else
name|end_of_line
argument_list|(
name|str
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Xscale move-accumulator-register (argument parse)       MARcc   acc0,RdLo,RdHi.  */
end_comment

begin_function
specifier|static
name|void
name|do_xsc_mar
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|int
name|rdlo
decl_stmt|,
name|rdhi
decl_stmt|;
if|if
condition|(
name|accum0_required_here
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
condition|)
name|inst
operator|.
name|error
operator|=
name|ERR_NO_ACCUM
expr_stmt|;
elseif|else
if|if
condition|(
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
operator|||
operator|(
name|rdlo
operator|=
name|reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|12
argument_list|)
operator|)
operator|==
name|FAIL
condition|)
name|inst
operator|.
name|error
operator|=
name|BAD_ARGS
expr_stmt|;
elseif|else
if|if
condition|(
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
operator|||
operator|(
name|rdhi
operator|=
name|reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|16
argument_list|)
operator|)
operator|==
name|FAIL
condition|)
name|inst
operator|.
name|error
operator|=
name|BAD_ARGS
expr_stmt|;
comment|/* inst.instruction has now been zapped with both rdlo and rdhi.  */
elseif|else
if|if
condition|(
name|rdlo
operator|==
name|REG_PC
operator|||
name|rdhi
operator|==
name|REG_PC
condition|)
name|inst
operator|.
name|error
operator|=
name|BAD_PC
expr_stmt|;
comment|/* Undefined result if rdlo or rdhi is R15.  */
else|else
name|end_of_line
argument_list|(
name|str
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Xscale move-register-accumulator (argument parse)       MRAcc   RdLo,RdHi,acc0.  */
end_comment

begin_function
specifier|static
name|void
name|do_xsc_mra
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|int
name|rdlo
decl_stmt|;
name|int
name|rdhi
decl_stmt|;
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|rdlo
operator|=
name|reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|12
argument_list|)
operator|)
operator|==
name|FAIL
condition|)
name|inst
operator|.
name|error
operator|=
name|BAD_ARGS
expr_stmt|;
elseif|else
if|if
condition|(
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
operator|||
operator|(
name|rdhi
operator|=
name|reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|16
argument_list|)
operator|)
operator|==
name|FAIL
condition|)
name|inst
operator|.
name|error
operator|=
name|BAD_ARGS
expr_stmt|;
elseif|else
if|if
condition|(
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
operator|||
name|accum0_required_here
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
condition|)
name|inst
operator|.
name|error
operator|=
name|ERR_NO_ACCUM
expr_stmt|;
comment|/* inst.instruction has now been zapped with both rdlo and rdhi.  */
elseif|else
if|if
condition|(
name|rdlo
operator|==
name|rdhi
condition|)
name|inst
operator|.
name|error
operator|=
name|BAD_ARGS
expr_stmt|;
comment|/* Undefined result if 2 writes to same reg.  */
elseif|else
if|if
condition|(
name|rdlo
operator|==
name|REG_PC
operator|||
name|rdhi
operator|==
name|REG_PC
condition|)
name|inst
operator|.
name|error
operator|=
name|BAD_PC
expr_stmt|;
comment|/* Undefined result if rdlo or rdhi is R15.  */
else|else
name|end_of_line
argument_list|(
name|str
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ARMv5TE: Preload-Cache      PLD<addr_mode>    Syntactically, like LDR with B=1, W=0, L=1.  */
end_comment

begin_function
specifier|static
name|void
name|do_pld
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|int
name|rd
decl_stmt|;
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|str
operator|!=
literal|'['
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"'[' expected after PLD mnemonic"
argument_list|)
expr_stmt|;
return|return;
block|}
operator|++
name|str
expr_stmt|;
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|rd
operator|=
name|reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|16
argument_list|)
operator|)
operator|==
name|FAIL
condition|)
return|return;
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|str
operator|==
literal|']'
condition|)
block|{
comment|/* [Rn], ... ?  */
operator|++
name|str
expr_stmt|;
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
comment|/* Post-indexed addressing is not allowed with PLD.  */
if|if
condition|(
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|SUCCESS
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"post-indexed expression used in preload instruction"
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
operator|*
name|str
operator|==
literal|'!'
condition|)
comment|/* [Rn]! */
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"writeback used in preload instruction"
argument_list|)
expr_stmt|;
operator|++
name|str
expr_stmt|;
block|}
else|else
comment|/* [Rn] */
name|inst
operator|.
name|instruction
operator||=
name|INDEX_UP
operator||
name|PRE_INDEX
expr_stmt|;
block|}
else|else
comment|/* [Rn, ...] */
block|{
if|if
condition|(
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"pre-indexed expression expected"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|ldst_extend
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
condition|)
return|return;
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|str
operator|!=
literal|']'
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"missing ]"
argument_list|)
expr_stmt|;
return|return;
block|}
operator|++
name|str
expr_stmt|;
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|str
operator|==
literal|'!'
condition|)
comment|/* [Rn]! */
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"writeback used in preload instruction"
argument_list|)
expr_stmt|;
operator|++
name|str
expr_stmt|;
block|}
name|inst
operator|.
name|instruction
operator||=
name|PRE_INDEX
expr_stmt|;
block|}
name|end_of_line
argument_list|(
name|str
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ARMv5TE load-consecutive (argument parse)    Mode is like LDRH.       LDRccD R, mode      STRccD R, mode.  */
end_comment

begin_function
specifier|static
name|void
name|do_ldrd
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|int
name|rd
decl_stmt|;
name|int
name|rn
decl_stmt|;
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|rd
operator|=
name|reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|12
argument_list|)
operator|)
operator|==
name|FAIL
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|BAD_ARGS
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
operator|||
operator|(
name|rn
operator|=
name|ld_mode_required_here
argument_list|(
operator|&
name|str
argument_list|)
operator|)
operator|==
name|FAIL
condition|)
block|{
if|if
condition|(
operator|!
name|inst
operator|.
name|error
condition|)
name|inst
operator|.
name|error
operator|=
name|BAD_ARGS
expr_stmt|;
return|return;
block|}
comment|/* inst.instruction has now been zapped with Rd and the addressing mode.  */
if|if
condition|(
name|rd
operator|&
literal|1
condition|)
comment|/* Unpredictable result if Rd is odd.  */
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"destination register must be even"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|rd
operator|==
name|REG_LR
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"r14 not allowed here"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
operator|(
name|rd
operator|==
name|rn
operator|)
operator|||
operator|(
name|rd
operator|+
literal|1
operator|==
name|rn
operator|)
operator|)
operator|&&
operator|(
operator|(
name|inst
operator|.
name|instruction
operator|&
name|WRITE_BACK
operator|)
operator|||
operator|(
operator|!
operator|(
name|inst
operator|.
name|instruction
operator|&
name|PRE_INDEX
operator|)
operator|)
operator|)
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"pre/post-indexing used when modified address register is destination"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* For an index-register load, the index register must not overlap the      destination (even if not write-back).  */
if|if
condition|(
operator|(
name|inst
operator|.
name|instruction
operator|&
name|V4_STR_BIT
operator|)
operator|==
literal|0
operator|&&
operator|(
name|inst
operator|.
name|instruction
operator|&
name|HWOFFSET_IMM
operator|)
operator|==
literal|0
condition|)
block|{
name|int
name|rm
init|=
name|inst
operator|.
name|instruction
operator|&
literal|0x0000000f
decl_stmt|;
if|if
condition|(
name|rm
operator|==
name|rd
operator|||
operator|(
name|rm
operator|==
name|rd
operator|+
literal|1
operator|)
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"ldrd destination registers must not overlap index register"
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|end_of_line
argument_list|(
name|str
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Returns the index into fp_values of a floating point number,    or -1 if not in the table.  */
end_comment

begin_function
specifier|static
name|int
name|my_get_float_expression
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
modifier|*
name|str
decl_stmt|;
block|{
name|LITTLENUM_TYPE
name|words
index|[
name|MAX_LITTLENUMS
index|]
decl_stmt|;
name|char
modifier|*
name|save_in
decl_stmt|;
name|expressionS
name|exp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|j
decl_stmt|;
name|memset
argument_list|(
name|words
argument_list|,
literal|0
argument_list|,
name|MAX_LITTLENUMS
operator|*
sizeof|sizeof
argument_list|(
name|LITTLENUM_TYPE
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Look for a raw floating point number.  */
if|if
condition|(
operator|(
name|save_in
operator|=
name|atof_ieee
argument_list|(
operator|*
name|str
argument_list|,
literal|'x'
argument_list|,
name|words
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
name|is_end_of_line
index|[
operator|(
name|unsigned
name|char
operator|)
operator|*
name|save_in
index|]
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_FLOAT_VALS
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|MAX_LITTLENUMS
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|words
index|[
name|j
index|]
operator|!=
name|fp_values
index|[
name|i
index|]
index|[
name|j
index|]
condition|)
break|break;
block|}
if|if
condition|(
name|j
operator|==
name|MAX_LITTLENUMS
condition|)
block|{
operator|*
name|str
operator|=
name|save_in
expr_stmt|;
return|return
name|i
return|;
block|}
block|}
block|}
comment|/* Try and parse a more complex expression, this will probably fail      unless the code uses a floating point prefix (eg "0f").  */
name|save_in
operator|=
name|input_line_pointer
expr_stmt|;
name|input_line_pointer
operator|=
operator|*
name|str
expr_stmt|;
if|if
condition|(
name|expression
argument_list|(
operator|&
name|exp
argument_list|)
operator|==
name|absolute_section
operator|&&
name|exp
operator|.
name|X_op
operator|==
name|O_big
operator|&&
name|exp
operator|.
name|X_add_number
operator|<
literal|0
condition|)
block|{
comment|/* FIXME: 5 = X_PRECISION, should be #define'd where we can use it. 	 Ditto for 15.  */
if|if
condition|(
name|gen_to_words
argument_list|(
name|words
argument_list|,
literal|5
argument_list|,
operator|(
name|long
operator|)
literal|15
argument_list|)
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_FLOAT_VALS
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|MAX_LITTLENUMS
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|words
index|[
name|j
index|]
operator|!=
name|fp_values
index|[
name|i
index|]
index|[
name|j
index|]
condition|)
break|break;
block|}
if|if
condition|(
name|j
operator|==
name|MAX_LITTLENUMS
condition|)
block|{
operator|*
name|str
operator|=
name|input_line_pointer
expr_stmt|;
name|input_line_pointer
operator|=
name|save_in
expr_stmt|;
return|return
name|i
return|;
block|}
block|}
block|}
block|}
operator|*
name|str
operator|=
name|input_line_pointer
expr_stmt|;
name|input_line_pointer
operator|=
name|save_in
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Return true if anything in the expression is a bignum.  */
end_comment

begin_function
specifier|static
name|int
name|walk_no_bignums
parameter_list|(
name|sp
parameter_list|)
name|symbolS
modifier|*
name|sp
decl_stmt|;
block|{
if|if
condition|(
name|symbol_get_value_expression
argument_list|(
name|sp
argument_list|)
operator|->
name|X_op
operator|==
name|O_big
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|symbol_get_value_expression
argument_list|(
name|sp
argument_list|)
operator|->
name|X_add_symbol
condition|)
block|{
return|return
operator|(
name|walk_no_bignums
argument_list|(
name|symbol_get_value_expression
argument_list|(
name|sp
argument_list|)
operator|->
name|X_add_symbol
argument_list|)
operator|||
operator|(
name|symbol_get_value_expression
argument_list|(
name|sp
argument_list|)
operator|->
name|X_op_symbol
operator|&&
name|walk_no_bignums
argument_list|(
name|symbol_get_value_expression
argument_list|(
name|sp
argument_list|)
operator|->
name|X_op_symbol
argument_list|)
operator|)
operator|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|int
name|in_my_get_expression
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|my_get_expression
parameter_list|(
name|ep
parameter_list|,
name|str
parameter_list|)
name|expressionS
modifier|*
name|ep
decl_stmt|;
name|char
modifier|*
modifier|*
name|str
decl_stmt|;
block|{
name|char
modifier|*
name|save_in
decl_stmt|;
name|segT
name|seg
decl_stmt|;
name|save_in
operator|=
name|input_line_pointer
expr_stmt|;
name|input_line_pointer
operator|=
operator|*
name|str
expr_stmt|;
name|in_my_get_expression
operator|=
literal|1
expr_stmt|;
name|seg
operator|=
name|expression
argument_list|(
name|ep
argument_list|)
expr_stmt|;
name|in_my_get_expression
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ep
operator|->
name|X_op
operator|==
name|O_illegal
condition|)
block|{
comment|/* We found a bad expression in md_operand().  */
operator|*
name|str
operator|=
name|input_line_pointer
expr_stmt|;
name|input_line_pointer
operator|=
name|save_in
expr_stmt|;
return|return
literal|1
return|;
block|}
ifdef|#
directive|ifdef
name|OBJ_AOUT
if|if
condition|(
name|seg
operator|!=
name|absolute_section
operator|&&
name|seg
operator|!=
name|text_section
operator|&&
name|seg
operator|!=
name|data_section
operator|&&
name|seg
operator|!=
name|bss_section
operator|&&
name|seg
operator|!=
name|undefined_section
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"bad_segment"
argument_list|)
expr_stmt|;
operator|*
name|str
operator|=
name|input_line_pointer
expr_stmt|;
name|input_line_pointer
operator|=
name|save_in
expr_stmt|;
return|return
literal|1
return|;
block|}
endif|#
directive|endif
comment|/* Get rid of any bignums now, so that we don't generate an error for which      we can't establish a line number later on.  Big numbers are never valid      in instructions, which is where this routine is always called.  */
if|if
condition|(
name|ep
operator|->
name|X_op
operator|==
name|O_big
operator|||
operator|(
name|ep
operator|->
name|X_add_symbol
operator|&&
operator|(
name|walk_no_bignums
argument_list|(
name|ep
operator|->
name|X_add_symbol
argument_list|)
operator|||
operator|(
name|ep
operator|->
name|X_op_symbol
operator|&&
name|walk_no_bignums
argument_list|(
name|ep
operator|->
name|X_op_symbol
argument_list|)
operator|)
operator|)
operator|)
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"invalid constant"
argument_list|)
expr_stmt|;
operator|*
name|str
operator|=
name|input_line_pointer
expr_stmt|;
name|input_line_pointer
operator|=
name|save_in
expr_stmt|;
return|return
literal|1
return|;
block|}
operator|*
name|str
operator|=
name|input_line_pointer
expr_stmt|;
name|input_line_pointer
operator|=
name|save_in
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* We handle all bad expressions here, so that we can report the faulty     instruction in the error message.  */
end_comment

begin_function
name|void
name|md_operand
parameter_list|(
name|expr
parameter_list|)
name|expressionS
modifier|*
name|expr
decl_stmt|;
block|{
if|if
condition|(
name|in_my_get_expression
condition|)
block|{
name|expr
operator|->
name|X_op
operator|=
name|O_illegal
expr_stmt|;
if|if
condition|(
name|inst
operator|.
name|error
operator|==
name|NULL
condition|)
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"bad expression"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* UNRESTRICT should be one if<shift><register> is permitted for this    instruction.  */
end_comment

begin_function
specifier|static
name|int
name|decode_shift
parameter_list|(
name|str
parameter_list|,
name|unrestrict
parameter_list|)
name|char
modifier|*
modifier|*
name|str
decl_stmt|;
name|int
name|unrestrict
decl_stmt|;
block|{
specifier|const
name|struct
name|asm_shift_name
modifier|*
name|shift
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|char
name|c
decl_stmt|;
name|skip_whitespace
argument_list|(
operator|*
name|str
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
operator|*
name|str
init|;
name|ISALPHA
argument_list|(
operator|*
name|p
argument_list|)
condition|;
name|p
operator|++
control|)
empty_stmt|;
if|if
condition|(
name|p
operator|==
operator|*
name|str
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"shift expression expected"
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
block|}
name|c
operator|=
operator|*
name|p
expr_stmt|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
name|shift
operator|=
operator|(
specifier|const
expr|struct
name|asm_shift_name
operator|*
operator|)
name|hash_find
argument_list|(
name|arm_shift_hsh
argument_list|,
operator|*
name|str
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|shift
operator|==
name|NULL
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"shift expression expected"
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
block|}
name|assert
argument_list|(
name|shift
operator|->
name|properties
operator|->
name|index
operator|==
name|shift_properties
index|[
name|shift
operator|->
name|properties
operator|->
name|index
index|]
operator|.
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|shift
operator|->
name|properties
operator|->
name|index
operator|==
name|SHIFT_RRX
condition|)
block|{
operator|*
name|str
operator|=
name|p
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|shift
operator|->
name|properties
operator|->
name|bit_field
expr_stmt|;
return|return
name|SUCCESS
return|;
block|}
name|skip_whitespace
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|unrestrict
operator|&&
name|reg_required_here
argument_list|(
operator|&
name|p
argument_list|,
literal|8
argument_list|)
operator|!=
name|FAIL
condition|)
block|{
name|inst
operator|.
name|instruction
operator||=
name|shift
operator|->
name|properties
operator|->
name|bit_field
operator||
name|SHIFT_BY_REG
expr_stmt|;
operator|*
name|str
operator|=
name|p
expr_stmt|;
return|return
name|SUCCESS
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|is_immediate_prefix
argument_list|(
operator|*
name|p
argument_list|)
condition|)
block|{
name|inst
operator|.
name|error
operator|=
operator|(
name|unrestrict
condition|?
name|_
argument_list|(
literal|"shift requires register or #expression"
argument_list|)
else|:
name|_
argument_list|(
literal|"shift requires #expression"
argument_list|)
operator|)
expr_stmt|;
operator|*
name|str
operator|=
name|p
expr_stmt|;
return|return
name|FAIL
return|;
block|}
name|inst
operator|.
name|error
operator|=
name|NULL
expr_stmt|;
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|my_get_expression
argument_list|(
operator|&
name|inst
operator|.
name|reloc
operator|.
name|exp
argument_list|,
operator|&
name|p
argument_list|)
condition|)
return|return
name|FAIL
return|;
comment|/* Validate some simple #expressions.  */
if|if
condition|(
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_op
operator|==
name|O_constant
condition|)
block|{
name|unsigned
name|num
init|=
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_add_number
decl_stmt|;
comment|/* Reject operations greater than 32.  */
if|if
condition|(
name|num
operator|>
literal|32
comment|/* Reject a shift of 0 unless the mode allows it.  */
operator|||
operator|(
name|num
operator|==
literal|0
operator|&&
name|shift
operator|->
name|properties
operator|->
name|allows_0
operator|==
literal|0
operator|)
comment|/* Reject a shift of 32 unless the mode allows it.  */
operator|||
operator|(
name|num
operator|==
literal|32
operator|&&
name|shift
operator|->
name|properties
operator|->
name|allows_32
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* As a special case we allow a shift of zero for 	     modes that do not support it to be recoded as an 	     logical shift left of zero (ie nothing).  We warn 	     about this though.  */
if|if
condition|(
name|num
operator|==
literal|0
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"shift of 0 ignored."
argument_list|)
argument_list|)
expr_stmt|;
name|shift
operator|=
operator|&
name|shift_names
index|[
literal|0
index|]
expr_stmt|;
name|assert
argument_list|(
name|shift
operator|->
name|properties
operator|->
name|index
operator|==
name|SHIFT_LSL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"invalid immediate shift"
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
block|}
block|}
comment|/* Shifts of 32 are encoded as 0, for those shifts that 	 support it.  */
if|if
condition|(
name|num
operator|==
literal|32
condition|)
name|num
operator|=
literal|0
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
operator|(
name|num
operator|<<
literal|7
operator|)
operator||
name|shift
operator|->
name|properties
operator|->
name|bit_field
expr_stmt|;
block|}
else|else
block|{
name|inst
operator|.
name|reloc
operator|.
name|type
operator|=
name|BFD_RELOC_ARM_SHIFT_IMM
expr_stmt|;
name|inst
operator|.
name|reloc
operator|.
name|pc_rel
operator|=
literal|0
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|shift
operator|->
name|properties
operator|->
name|bit_field
expr_stmt|;
block|}
operator|*
name|str
operator|=
name|p
expr_stmt|;
return|return
name|SUCCESS
return|;
block|}
end_function

begin_comment
comment|/* Do those data_ops which can take a negative immediate constant    by altering the instuction.  A bit of a hack really.         MOV<-> MVN         AND<-> BIC         ADC<-> SBC         by inverting the second operand, and         ADD<-> SUB         CMP<-> CMN         by negating the second operand.  */
end_comment

begin_function
specifier|static
name|int
name|negate_data_op
parameter_list|(
name|instruction
parameter_list|,
name|value
parameter_list|)
name|unsigned
name|long
modifier|*
name|instruction
decl_stmt|;
name|unsigned
name|long
name|value
decl_stmt|;
block|{
name|int
name|op
decl_stmt|,
name|new_inst
decl_stmt|;
name|unsigned
name|long
name|negated
decl_stmt|,
name|inverted
decl_stmt|;
name|negated
operator|=
name|validate_immediate
argument_list|(
operator|-
name|value
argument_list|)
expr_stmt|;
name|inverted
operator|=
name|validate_immediate
argument_list|(
operator|~
name|value
argument_list|)
expr_stmt|;
name|op
operator|=
operator|(
operator|*
name|instruction
operator|>>
name|DATA_OP_SHIFT
operator|)
operator|&
literal|0xf
expr_stmt|;
switch|switch
condition|(
name|op
condition|)
block|{
comment|/* First negates.  */
case|case
name|OPCODE_SUB
case|:
comment|/* ADD<-> SUB  */
name|new_inst
operator|=
name|OPCODE_ADD
expr_stmt|;
name|value
operator|=
name|negated
expr_stmt|;
break|break;
case|case
name|OPCODE_ADD
case|:
name|new_inst
operator|=
name|OPCODE_SUB
expr_stmt|;
name|value
operator|=
name|negated
expr_stmt|;
break|break;
case|case
name|OPCODE_CMP
case|:
comment|/* CMP<-> CMN  */
name|new_inst
operator|=
name|OPCODE_CMN
expr_stmt|;
name|value
operator|=
name|negated
expr_stmt|;
break|break;
case|case
name|OPCODE_CMN
case|:
name|new_inst
operator|=
name|OPCODE_CMP
expr_stmt|;
name|value
operator|=
name|negated
expr_stmt|;
break|break;
comment|/* Now Inverted ops.  */
case|case
name|OPCODE_MOV
case|:
comment|/* MOV<-> MVN  */
name|new_inst
operator|=
name|OPCODE_MVN
expr_stmt|;
name|value
operator|=
name|inverted
expr_stmt|;
break|break;
case|case
name|OPCODE_MVN
case|:
name|new_inst
operator|=
name|OPCODE_MOV
expr_stmt|;
name|value
operator|=
name|inverted
expr_stmt|;
break|break;
case|case
name|OPCODE_AND
case|:
comment|/* AND<-> BIC  */
name|new_inst
operator|=
name|OPCODE_BIC
expr_stmt|;
name|value
operator|=
name|inverted
expr_stmt|;
break|break;
case|case
name|OPCODE_BIC
case|:
name|new_inst
operator|=
name|OPCODE_AND
expr_stmt|;
name|value
operator|=
name|inverted
expr_stmt|;
break|break;
case|case
name|OPCODE_ADC
case|:
comment|/* ADC<-> SBC  */
name|new_inst
operator|=
name|OPCODE_SBC
expr_stmt|;
name|value
operator|=
name|inverted
expr_stmt|;
break|break;
case|case
name|OPCODE_SBC
case|:
name|new_inst
operator|=
name|OPCODE_ADC
expr_stmt|;
name|value
operator|=
name|inverted
expr_stmt|;
break|break;
comment|/* We cannot do anything.  */
default|default:
return|return
name|FAIL
return|;
block|}
if|if
condition|(
name|value
operator|==
operator|(
name|unsigned
operator|)
name|FAIL
condition|)
return|return
name|FAIL
return|;
operator|*
name|instruction
operator|&=
name|OPCODE_MASK
expr_stmt|;
operator|*
name|instruction
operator||=
name|new_inst
operator|<<
name|DATA_OP_SHIFT
expr_stmt|;
return|return
name|value
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|data_op2
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
modifier|*
name|str
decl_stmt|;
block|{
name|int
name|value
decl_stmt|;
name|expressionS
name|expr
decl_stmt|;
name|skip_whitespace
argument_list|(
operator|*
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg_required_here
argument_list|(
name|str
argument_list|,
literal|0
argument_list|)
operator|!=
name|FAIL
condition|)
block|{
if|if
condition|(
name|skip_past_comma
argument_list|(
name|str
argument_list|)
operator|==
name|SUCCESS
condition|)
comment|/* Shift operation on register.  */
return|return
name|decode_shift
argument_list|(
name|str
argument_list|,
name|NO_SHIFT_RESTRICT
argument_list|)
return|;
return|return
name|SUCCESS
return|;
block|}
else|else
block|{
comment|/* Immediate expression.  */
if|if
condition|(
name|is_immediate_prefix
argument_list|(
operator|*
operator|*
name|str
argument_list|)
condition|)
block|{
operator|(
operator|*
name|str
operator|)
operator|++
expr_stmt|;
name|inst
operator|.
name|error
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|my_get_expression
argument_list|(
operator|&
name|inst
operator|.
name|reloc
operator|.
name|exp
argument_list|,
name|str
argument_list|)
condition|)
return|return
name|FAIL
return|;
if|if
condition|(
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_add_symbol
condition|)
block|{
name|inst
operator|.
name|reloc
operator|.
name|type
operator|=
name|BFD_RELOC_ARM_IMMEDIATE
expr_stmt|;
name|inst
operator|.
name|reloc
operator|.
name|pc_rel
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|skip_past_comma
argument_list|(
name|str
argument_list|)
operator|==
name|SUCCESS
condition|)
block|{
comment|/* #x, y -- ie explicit rotation by Y.  */
if|if
condition|(
name|my_get_expression
argument_list|(
operator|&
name|expr
argument_list|,
name|str
argument_list|)
condition|)
return|return
name|FAIL
return|;
if|if
condition|(
name|expr
operator|.
name|X_op
operator|!=
name|O_constant
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"constant expression expected"
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
block|}
comment|/* Rotate must be a multiple of 2.  */
if|if
condition|(
operator|(
operator|(
name|unsigned
operator|)
name|expr
operator|.
name|X_add_number
operator|)
operator|>
literal|30
operator|||
operator|(
name|expr
operator|.
name|X_add_number
operator|&
literal|1
operator|)
operator|!=
literal|0
operator|||
operator|(
operator|(
name|unsigned
operator|)
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_add_number
operator|)
operator|>
literal|255
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"invalid constant"
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
block|}
name|inst
operator|.
name|instruction
operator||=
name|INST_IMMEDIATE
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_add_number
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|expr
operator|.
name|X_add_number
operator|<<
literal|7
expr_stmt|;
return|return
name|SUCCESS
return|;
block|}
comment|/* Implicit rotation, select a suitable one.  */
name|value
operator|=
name|validate_immediate
argument_list|(
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_add_number
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|==
name|FAIL
condition|)
block|{
comment|/* Can't be done.  Perhaps the code reads something like 		     "add Rd, Rn, #-n", where "sub Rd, Rn, #n" would be OK.  */
if|if
condition|(
operator|(
name|value
operator|=
name|negate_data_op
argument_list|(
operator|&
name|inst
operator|.
name|instruction
argument_list|,
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_add_number
argument_list|)
operator|)
operator|==
name|FAIL
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"invalid constant"
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
block|}
block|}
name|inst
operator|.
name|instruction
operator||=
name|value
expr_stmt|;
block|}
name|inst
operator|.
name|instruction
operator||=
name|INST_IMMEDIATE
expr_stmt|;
return|return
name|SUCCESS
return|;
block|}
operator|(
operator|*
name|str
operator|)
operator|++
expr_stmt|;
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"register or shift expression expected"
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|fp_op2
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
modifier|*
name|str
decl_stmt|;
block|{
name|skip_whitespace
argument_list|(
operator|*
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp_reg_required_here
argument_list|(
name|str
argument_list|,
literal|0
argument_list|)
operator|!=
name|FAIL
condition|)
return|return
name|SUCCESS
return|;
else|else
block|{
comment|/* Immediate expression.  */
if|if
condition|(
operator|*
operator|(
operator|(
operator|*
name|str
operator|)
operator|++
operator|)
operator|==
literal|'#'
condition|)
block|{
name|int
name|i
decl_stmt|;
name|inst
operator|.
name|error
operator|=
name|NULL
expr_stmt|;
name|skip_whitespace
argument_list|(
operator|*
name|str
argument_list|)
expr_stmt|;
comment|/* First try and match exact strings, this is to guarantee 	     that some formats will work even for cross assembly.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|fp_const
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
operator|*
name|str
argument_list|,
name|fp_const
index|[
name|i
index|]
argument_list|,
name|strlen
argument_list|(
name|fp_const
index|[
name|i
index|]
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|char
modifier|*
name|start
init|=
operator|*
name|str
decl_stmt|;
operator|*
name|str
operator|+=
name|strlen
argument_list|(
name|fp_const
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_end_of_line
index|[
operator|(
name|unsigned
name|char
operator|)
operator|*
operator|*
name|str
index|]
condition|)
block|{
name|inst
operator|.
name|instruction
operator||=
name|i
operator|+
literal|8
expr_stmt|;
return|return
name|SUCCESS
return|;
block|}
operator|*
name|str
operator|=
name|start
expr_stmt|;
block|}
block|}
comment|/* Just because we didn't get a match doesn't mean that the 	     constant isn't valid, just that it is in a format that we 	     don't automatically recognize.  Try parsing it with 	     the standard expression routines.  */
if|if
condition|(
operator|(
name|i
operator|=
name|my_get_float_expression
argument_list|(
name|str
argument_list|)
operator|)
operator|>=
literal|0
condition|)
block|{
name|inst
operator|.
name|instruction
operator||=
name|i
operator|+
literal|8
expr_stmt|;
return|return
name|SUCCESS
return|;
block|}
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"invalid floating point immediate expression"
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
block|}
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"floating point register or immediate expression expected"
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|do_arit
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|12
argument_list|)
operator|==
name|FAIL
operator|||
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
operator|||
name|reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|16
argument_list|)
operator|==
name|FAIL
operator|||
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
operator|||
name|data_op2
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
condition|)
block|{
if|if
condition|(
operator|!
name|inst
operator|.
name|error
condition|)
name|inst
operator|.
name|error
operator|=
name|BAD_ARGS
expr_stmt|;
return|return;
block|}
name|end_of_line
argument_list|(
name|str
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|do_adr
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
comment|/* This is a pseudo-op of the form "adr rd, label" to be converted      into a relative address of the form "add rd, pc, #label-.-8".  */
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|12
argument_list|)
operator|==
name|FAIL
operator|||
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
operator|||
name|my_get_expression
argument_list|(
operator|&
name|inst
operator|.
name|reloc
operator|.
name|exp
argument_list|,
operator|&
name|str
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|inst
operator|.
name|error
condition|)
name|inst
operator|.
name|error
operator|=
name|BAD_ARGS
expr_stmt|;
return|return;
block|}
comment|/* Frag hacking will turn this into a sub instruction if the offset turns      out to be negative.  */
name|inst
operator|.
name|reloc
operator|.
name|type
operator|=
name|BFD_RELOC_ARM_IMMEDIATE
expr_stmt|;
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_add_number
operator|-=
literal|8
expr_stmt|;
comment|/* PC relative adjust.  */
name|inst
operator|.
name|reloc
operator|.
name|pc_rel
operator|=
literal|1
expr_stmt|;
name|end_of_line
argument_list|(
name|str
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_adrl
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
comment|/* This is a pseudo-op of the form "adrl rd, label" to be converted      into a relative address of the form:      add rd, pc, #low(label-.-8)"      add rd, rd, #high(label-.-8)"  */
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|12
argument_list|)
operator|==
name|FAIL
operator|||
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
operator|||
name|my_get_expression
argument_list|(
operator|&
name|inst
operator|.
name|reloc
operator|.
name|exp
argument_list|,
operator|&
name|str
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|inst
operator|.
name|error
condition|)
name|inst
operator|.
name|error
operator|=
name|BAD_ARGS
expr_stmt|;
return|return;
block|}
name|end_of_line
argument_list|(
name|str
argument_list|)
expr_stmt|;
comment|/* Frag hacking will turn this into a sub instruction if the offset turns      out to be negative.  */
name|inst
operator|.
name|reloc
operator|.
name|type
operator|=
name|BFD_RELOC_ARM_ADRL_IMMEDIATE
expr_stmt|;
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_add_number
operator|-=
literal|8
expr_stmt|;
comment|/* PC relative adjust  */
name|inst
operator|.
name|reloc
operator|.
name|pc_rel
operator|=
literal|1
expr_stmt|;
name|inst
operator|.
name|size
operator|=
name|INSN_SIZE
operator|*
literal|2
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|do_cmp
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|16
argument_list|)
operator|==
name|FAIL
condition|)
block|{
if|if
condition|(
operator|!
name|inst
operator|.
name|error
condition|)
name|inst
operator|.
name|error
operator|=
name|BAD_ARGS
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
operator|||
name|data_op2
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
condition|)
block|{
if|if
condition|(
operator|!
name|inst
operator|.
name|error
condition|)
name|inst
operator|.
name|error
operator|=
name|BAD_ARGS
expr_stmt|;
return|return;
block|}
name|end_of_line
argument_list|(
name|str
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|do_mov
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|12
argument_list|)
operator|==
name|FAIL
condition|)
block|{
if|if
condition|(
operator|!
name|inst
operator|.
name|error
condition|)
name|inst
operator|.
name|error
operator|=
name|BAD_ARGS
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
operator|||
name|data_op2
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
condition|)
block|{
if|if
condition|(
operator|!
name|inst
operator|.
name|error
condition|)
name|inst
operator|.
name|error
operator|=
name|BAD_ARGS
expr_stmt|;
return|return;
block|}
name|end_of_line
argument_list|(
name|str
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|int
name|ldst_extend
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
modifier|*
name|str
decl_stmt|;
block|{
name|int
name|add
init|=
name|INDEX_UP
decl_stmt|;
switch|switch
condition|(
operator|*
operator|*
name|str
condition|)
block|{
case|case
literal|'#'
case|:
case|case
literal|'$'
case|:
operator|(
operator|*
name|str
operator|)
operator|++
expr_stmt|;
if|if
condition|(
name|my_get_expression
argument_list|(
operator|&
name|inst
operator|.
name|reloc
operator|.
name|exp
argument_list|,
name|str
argument_list|)
condition|)
return|return
name|FAIL
return|;
if|if
condition|(
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_op
operator|==
name|O_constant
condition|)
block|{
name|int
name|value
init|=
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_add_number
decl_stmt|;
if|if
condition|(
name|value
operator|<
operator|-
literal|4095
operator|||
name|value
operator|>
literal|4095
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"address offset too large"
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
block|}
if|if
condition|(
name|value
operator|<
literal|0
condition|)
block|{
name|value
operator|=
operator|-
name|value
expr_stmt|;
name|add
operator|=
literal|0
expr_stmt|;
block|}
name|inst
operator|.
name|instruction
operator||=
name|add
operator||
name|value
expr_stmt|;
block|}
else|else
block|{
name|inst
operator|.
name|reloc
operator|.
name|type
operator|=
name|BFD_RELOC_ARM_OFFSET_IMM
expr_stmt|;
name|inst
operator|.
name|reloc
operator|.
name|pc_rel
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|SUCCESS
return|;
case|case
literal|'-'
case|:
name|add
operator|=
literal|0
expr_stmt|;
comment|/* Fall through.  */
case|case
literal|'+'
case|:
operator|(
operator|*
name|str
operator|)
operator|++
expr_stmt|;
comment|/* Fall through.  */
default|default:
if|if
condition|(
name|reg_required_here
argument_list|(
name|str
argument_list|,
literal|0
argument_list|)
operator|==
name|FAIL
condition|)
return|return
name|FAIL
return|;
name|inst
operator|.
name|instruction
operator||=
name|add
operator||
name|OFFSET_REG
expr_stmt|;
if|if
condition|(
name|skip_past_comma
argument_list|(
name|str
argument_list|)
operator|==
name|SUCCESS
condition|)
return|return
name|decode_shift
argument_list|(
name|str
argument_list|,
name|SHIFT_RESTRICT
argument_list|)
return|;
return|return
name|SUCCESS
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|do_ldst
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|int
name|pre_inc
init|=
literal|0
decl_stmt|;
name|int
name|conflict_reg
decl_stmt|;
name|int
name|value
decl_stmt|;
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|conflict_reg
operator|=
name|reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|12
argument_list|)
operator|)
operator|==
name|FAIL
condition|)
block|{
if|if
condition|(
operator|!
name|inst
operator|.
name|error
condition|)
name|inst
operator|.
name|error
operator|=
name|BAD_ARGS
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"address expected"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|*
name|str
operator|==
literal|'['
condition|)
block|{
name|int
name|reg
decl_stmt|;
name|str
operator|++
expr_stmt|;
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|reg
operator|=
name|reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|16
argument_list|)
operator|)
operator|==
name|FAIL
condition|)
return|return;
comment|/* Conflicts can occur on stores as well as loads.  */
name|conflict_reg
operator|=
operator|(
name|conflict_reg
operator|==
name|reg
operator|)
expr_stmt|;
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|str
operator|==
literal|']'
condition|)
block|{
name|str
operator|++
expr_stmt|;
if|if
condition|(
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|SUCCESS
condition|)
block|{
comment|/* [Rn],... (post inc)  */
if|if
condition|(
name|ldst_extend
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
condition|)
return|return;
if|if
condition|(
name|conflict_reg
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"%s register same as write-back base"
argument_list|)
argument_list|,
operator|(
operator|(
name|inst
operator|.
name|instruction
operator|&
name|LOAD_BIT
operator|)
condition|?
name|_
argument_list|(
literal|"destination"
argument_list|)
else|:
name|_
argument_list|(
literal|"source"
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* [Rn]  */
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|str
operator|==
literal|'!'
condition|)
block|{
if|if
condition|(
name|conflict_reg
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"%s register same as write-back base"
argument_list|)
argument_list|,
operator|(
operator|(
name|inst
operator|.
name|instruction
operator|&
name|LOAD_BIT
operator|)
condition|?
name|_
argument_list|(
literal|"destination"
argument_list|)
else|:
name|_
argument_list|(
literal|"source"
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|str
operator|++
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|WRITE_BACK
expr_stmt|;
block|}
name|inst
operator|.
name|instruction
operator||=
name|INDEX_UP
expr_stmt|;
name|pre_inc
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* [Rn,...]  */
if|if
condition|(
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"pre-indexed expression expected"
argument_list|)
expr_stmt|;
return|return;
block|}
name|pre_inc
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|ldst_extend
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
condition|)
return|return;
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|str
operator|++
operator|!=
literal|']'
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"missing ]"
argument_list|)
expr_stmt|;
return|return;
block|}
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|str
operator|==
literal|'!'
condition|)
block|{
if|if
condition|(
name|conflict_reg
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"%s register same as write-back base"
argument_list|)
argument_list|,
operator|(
operator|(
name|inst
operator|.
name|instruction
operator|&
name|LOAD_BIT
operator|)
condition|?
name|_
argument_list|(
literal|"destination"
argument_list|)
else|:
name|_
argument_list|(
literal|"source"
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|str
operator|++
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|WRITE_BACK
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
operator|*
name|str
operator|==
literal|'='
condition|)
block|{
if|if
condition|(
operator|(
name|inst
operator|.
name|instruction
operator|&
name|LOAD_BIT
operator|)
operator|==
literal|0
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"invalid pseudo operation"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Parse an "ldr Rd, =expr" instruction; this is another pseudo op.  */
name|str
operator|++
expr_stmt|;
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|my_get_expression
argument_list|(
operator|&
name|inst
operator|.
name|reloc
operator|.
name|exp
argument_list|,
operator|&
name|str
argument_list|)
condition|)
return|return;
if|if
condition|(
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_op
operator|!=
name|O_constant
operator|&&
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_op
operator|!=
name|O_symbol
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"constant expression expected"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_op
operator|==
name|O_constant
condition|)
block|{
name|value
operator|=
name|validate_immediate
argument_list|(
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_add_number
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|!=
name|FAIL
condition|)
block|{
comment|/* This can be done with a mov instruction.  */
name|inst
operator|.
name|instruction
operator|&=
name|LITERAL_MASK
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
operator|(
name|INST_IMMEDIATE
operator||
operator|(
name|OPCODE_MOV
operator|<<
name|DATA_OP_SHIFT
operator|)
operator|)
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|value
operator|&
literal|0xfff
expr_stmt|;
name|end_of_line
argument_list|(
name|str
argument_list|)
expr_stmt|;
return|return;
block|}
name|value
operator|=
name|validate_immediate
argument_list|(
operator|~
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_add_number
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|!=
name|FAIL
condition|)
block|{
comment|/* This can be done with a mvn instruction.  */
name|inst
operator|.
name|instruction
operator|&=
name|LITERAL_MASK
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
operator|(
name|INST_IMMEDIATE
operator||
operator|(
name|OPCODE_MVN
operator|<<
name|DATA_OP_SHIFT
operator|)
operator|)
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|value
operator|&
literal|0xfff
expr_stmt|;
name|end_of_line
argument_list|(
name|str
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* Insert into literal pool.  */
if|if
condition|(
name|add_to_lit_pool
argument_list|()
operator|==
name|FAIL
condition|)
block|{
if|if
condition|(
operator|!
name|inst
operator|.
name|error
condition|)
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"literal pool insertion failed"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Change the instruction exp to point to the pool.  */
name|inst
operator|.
name|reloc
operator|.
name|type
operator|=
name|BFD_RELOC_ARM_LITERAL
expr_stmt|;
name|inst
operator|.
name|reloc
operator|.
name|pc_rel
operator|=
literal|1
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
operator|(
name|REG_PC
operator|<<
literal|16
operator|)
expr_stmt|;
name|pre_inc
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|my_get_expression
argument_list|(
operator|&
name|inst
operator|.
name|reloc
operator|.
name|exp
argument_list|,
operator|&
name|str
argument_list|)
condition|)
return|return;
name|inst
operator|.
name|reloc
operator|.
name|type
operator|=
name|BFD_RELOC_ARM_OFFSET_IMM
expr_stmt|;
ifndef|#
directive|ifndef
name|TE_WINCE
comment|/* PC rel adjust.  */
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_add_number
operator|-=
literal|8
expr_stmt|;
endif|#
directive|endif
name|inst
operator|.
name|reloc
operator|.
name|pc_rel
operator|=
literal|1
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
operator|(
name|REG_PC
operator|<<
literal|16
operator|)
expr_stmt|;
name|pre_inc
operator|=
literal|1
expr_stmt|;
block|}
name|inst
operator|.
name|instruction
operator||=
operator|(
name|pre_inc
condition|?
name|PRE_INDEX
else|:
literal|0
operator|)
expr_stmt|;
name|end_of_line
argument_list|(
name|str
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|do_ldstt
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|int
name|conflict_reg
decl_stmt|;
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|conflict_reg
operator|=
name|reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|12
argument_list|)
operator|)
operator|==
name|FAIL
condition|)
block|{
if|if
condition|(
operator|!
name|inst
operator|.
name|error
condition|)
name|inst
operator|.
name|error
operator|=
name|BAD_ARGS
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"address expected"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|*
name|str
operator|==
literal|'['
condition|)
block|{
name|int
name|reg
decl_stmt|;
name|str
operator|++
expr_stmt|;
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|reg
operator|=
name|reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|16
argument_list|)
operator|)
operator|==
name|FAIL
condition|)
return|return;
comment|/* ldrt/strt always use post-indexed addressing, so if the base is 	 the same as Rd, we warn.  */
if|if
condition|(
name|conflict_reg
operator|==
name|reg
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"%s register same as write-back base"
argument_list|)
argument_list|,
operator|(
operator|(
name|inst
operator|.
name|instruction
operator|&
name|LOAD_BIT
operator|)
condition|?
name|_
argument_list|(
literal|"destination"
argument_list|)
else|:
name|_
argument_list|(
literal|"source"
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|str
operator|==
literal|']'
condition|)
block|{
name|str
operator|++
expr_stmt|;
if|if
condition|(
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|SUCCESS
condition|)
block|{
comment|/* [Rn],... (post inc)  */
if|if
condition|(
name|ldst_extend
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
condition|)
return|return;
block|}
else|else
block|{
comment|/* [Rn]  */
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
comment|/* Skip a write-back '!'.  */
if|if
condition|(
operator|*
name|str
operator|==
literal|'!'
condition|)
name|str
operator|++
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|INDEX_UP
expr_stmt|;
block|}
block|}
else|else
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"post-indexed expression expected"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
else|else
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"post-indexed expression expected"
argument_list|)
expr_stmt|;
return|return;
block|}
name|end_of_line
argument_list|(
name|str
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|int
name|ldst_extend_v4
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
modifier|*
name|str
decl_stmt|;
block|{
name|int
name|add
init|=
name|INDEX_UP
decl_stmt|;
switch|switch
condition|(
operator|*
operator|*
name|str
condition|)
block|{
case|case
literal|'#'
case|:
case|case
literal|'$'
case|:
operator|(
operator|*
name|str
operator|)
operator|++
expr_stmt|;
if|if
condition|(
name|my_get_expression
argument_list|(
operator|&
name|inst
operator|.
name|reloc
operator|.
name|exp
argument_list|,
name|str
argument_list|)
condition|)
return|return
name|FAIL
return|;
if|if
condition|(
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_op
operator|==
name|O_constant
condition|)
block|{
name|int
name|value
init|=
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_add_number
decl_stmt|;
if|if
condition|(
name|value
operator|<
operator|-
literal|255
operator|||
name|value
operator|>
literal|255
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"address offset too large"
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
block|}
if|if
condition|(
name|value
operator|<
literal|0
condition|)
block|{
name|value
operator|=
operator|-
name|value
expr_stmt|;
name|add
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Halfword and signextension instructions have the              immediate value split across bits 11..8 and bits 3..0.  */
name|inst
operator|.
name|instruction
operator||=
operator|(
name|add
operator||
name|HWOFFSET_IMM
operator||
operator|(
operator|(
name|value
operator|>>
literal|4
operator|)
operator|<<
literal|8
operator|)
operator||
operator|(
name|value
operator|&
literal|0xF
operator|)
operator|)
expr_stmt|;
block|}
else|else
block|{
name|inst
operator|.
name|instruction
operator||=
name|HWOFFSET_IMM
expr_stmt|;
name|inst
operator|.
name|reloc
operator|.
name|type
operator|=
name|BFD_RELOC_ARM_OFFSET_IMM8
expr_stmt|;
name|inst
operator|.
name|reloc
operator|.
name|pc_rel
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|SUCCESS
return|;
case|case
literal|'-'
case|:
name|add
operator|=
literal|0
expr_stmt|;
comment|/* Fall through.  */
case|case
literal|'+'
case|:
operator|(
operator|*
name|str
operator|)
operator|++
expr_stmt|;
comment|/* Fall through.  */
default|default:
if|if
condition|(
name|reg_required_here
argument_list|(
name|str
argument_list|,
literal|0
argument_list|)
operator|==
name|FAIL
condition|)
return|return
name|FAIL
return|;
name|inst
operator|.
name|instruction
operator||=
name|add
expr_stmt|;
return|return
name|SUCCESS
return|;
block|}
block|}
end_function

begin_comment
comment|/* Halfword and signed-byte load/store operations.  */
end_comment

begin_function
specifier|static
name|void
name|do_ldstv4
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|int
name|pre_inc
init|=
literal|0
decl_stmt|;
name|int
name|conflict_reg
decl_stmt|;
name|int
name|value
decl_stmt|;
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|conflict_reg
operator|=
name|reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|12
argument_list|)
operator|)
operator|==
name|FAIL
condition|)
block|{
if|if
condition|(
operator|!
name|inst
operator|.
name|error
condition|)
name|inst
operator|.
name|error
operator|=
name|BAD_ARGS
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"address expected"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|*
name|str
operator|==
literal|'['
condition|)
block|{
name|int
name|reg
decl_stmt|;
name|str
operator|++
expr_stmt|;
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|reg
operator|=
name|reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|16
argument_list|)
operator|)
operator|==
name|FAIL
condition|)
return|return;
comment|/* Conflicts can occur on stores as well as loads.  */
name|conflict_reg
operator|=
operator|(
name|conflict_reg
operator|==
name|reg
operator|)
expr_stmt|;
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|str
operator|==
literal|']'
condition|)
block|{
name|str
operator|++
expr_stmt|;
if|if
condition|(
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|SUCCESS
condition|)
block|{
comment|/* [Rn],... (post inc)  */
if|if
condition|(
name|ldst_extend_v4
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
condition|)
return|return;
if|if
condition|(
name|conflict_reg
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"%s register same as write-back base"
argument_list|)
argument_list|,
operator|(
operator|(
name|inst
operator|.
name|instruction
operator|&
name|LOAD_BIT
operator|)
condition|?
name|_
argument_list|(
literal|"destination"
argument_list|)
else|:
name|_
argument_list|(
literal|"source"
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* [Rn]  */
name|inst
operator|.
name|instruction
operator||=
name|HWOFFSET_IMM
expr_stmt|;
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|str
operator|==
literal|'!'
condition|)
block|{
if|if
condition|(
name|conflict_reg
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"%s register same as write-back base"
argument_list|)
argument_list|,
operator|(
operator|(
name|inst
operator|.
name|instruction
operator|&
name|LOAD_BIT
operator|)
condition|?
name|_
argument_list|(
literal|"destination"
argument_list|)
else|:
name|_
argument_list|(
literal|"source"
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|str
operator|++
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|WRITE_BACK
expr_stmt|;
block|}
name|inst
operator|.
name|instruction
operator||=
name|INDEX_UP
expr_stmt|;
name|pre_inc
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* [Rn,...]  */
if|if
condition|(
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"pre-indexed expression expected"
argument_list|)
expr_stmt|;
return|return;
block|}
name|pre_inc
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|ldst_extend_v4
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
condition|)
return|return;
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|str
operator|++
operator|!=
literal|']'
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"missing ]"
argument_list|)
expr_stmt|;
return|return;
block|}
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|str
operator|==
literal|'!'
condition|)
block|{
if|if
condition|(
name|conflict_reg
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"%s register same as write-back base"
argument_list|)
argument_list|,
operator|(
operator|(
name|inst
operator|.
name|instruction
operator|&
name|LOAD_BIT
operator|)
condition|?
name|_
argument_list|(
literal|"destination"
argument_list|)
else|:
name|_
argument_list|(
literal|"source"
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|str
operator|++
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|WRITE_BACK
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
operator|*
name|str
operator|==
literal|'='
condition|)
block|{
if|if
condition|(
operator|(
name|inst
operator|.
name|instruction
operator|&
name|LOAD_BIT
operator|)
operator|==
literal|0
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"invalid pseudo operation"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* XXX Does this work correctly for half-word/byte ops?  */
comment|/* Parse an "ldr Rd, =expr" instruction; this is another pseudo op.  */
name|str
operator|++
expr_stmt|;
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|my_get_expression
argument_list|(
operator|&
name|inst
operator|.
name|reloc
operator|.
name|exp
argument_list|,
operator|&
name|str
argument_list|)
condition|)
return|return;
if|if
condition|(
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_op
operator|!=
name|O_constant
operator|&&
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_op
operator|!=
name|O_symbol
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"constant expression expected"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_op
operator|==
name|O_constant
condition|)
block|{
name|value
operator|=
name|validate_immediate
argument_list|(
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_add_number
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|!=
name|FAIL
condition|)
block|{
comment|/* This can be done with a mov instruction.  */
name|inst
operator|.
name|instruction
operator|&=
name|LITERAL_MASK
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|INST_IMMEDIATE
operator||
operator|(
name|OPCODE_MOV
operator|<<
name|DATA_OP_SHIFT
operator|)
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|value
operator|&
literal|0xfff
expr_stmt|;
name|end_of_line
argument_list|(
name|str
argument_list|)
expr_stmt|;
return|return;
block|}
name|value
operator|=
name|validate_immediate
argument_list|(
operator|~
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_add_number
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|!=
name|FAIL
condition|)
block|{
comment|/* This can be done with a mvn instruction.  */
name|inst
operator|.
name|instruction
operator|&=
name|LITERAL_MASK
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|INST_IMMEDIATE
operator||
operator|(
name|OPCODE_MVN
operator|<<
name|DATA_OP_SHIFT
operator|)
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|value
operator|&
literal|0xfff
expr_stmt|;
name|end_of_line
argument_list|(
name|str
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* Insert into literal pool.  */
if|if
condition|(
name|add_to_lit_pool
argument_list|()
operator|==
name|FAIL
condition|)
block|{
if|if
condition|(
operator|!
name|inst
operator|.
name|error
condition|)
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"literal pool insertion failed"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Change the instruction exp to point to the pool.  */
name|inst
operator|.
name|instruction
operator||=
name|HWOFFSET_IMM
expr_stmt|;
name|inst
operator|.
name|reloc
operator|.
name|type
operator|=
name|BFD_RELOC_ARM_HWLITERAL
expr_stmt|;
name|inst
operator|.
name|reloc
operator|.
name|pc_rel
operator|=
literal|1
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
operator|(
name|REG_PC
operator|<<
literal|16
operator|)
expr_stmt|;
name|pre_inc
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|my_get_expression
argument_list|(
operator|&
name|inst
operator|.
name|reloc
operator|.
name|exp
argument_list|,
operator|&
name|str
argument_list|)
condition|)
return|return;
name|inst
operator|.
name|instruction
operator||=
name|HWOFFSET_IMM
expr_stmt|;
name|inst
operator|.
name|reloc
operator|.
name|type
operator|=
name|BFD_RELOC_ARM_OFFSET_IMM8
expr_stmt|;
ifndef|#
directive|ifndef
name|TE_WINCE
comment|/* PC rel adjust.  */
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_add_number
operator|-=
literal|8
expr_stmt|;
endif|#
directive|endif
name|inst
operator|.
name|reloc
operator|.
name|pc_rel
operator|=
literal|1
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
operator|(
name|REG_PC
operator|<<
literal|16
operator|)
expr_stmt|;
name|pre_inc
operator|=
literal|1
expr_stmt|;
block|}
name|inst
operator|.
name|instruction
operator||=
operator|(
name|pre_inc
condition|?
name|PRE_INDEX
else|:
literal|0
operator|)
expr_stmt|;
name|end_of_line
argument_list|(
name|str
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|long
name|reg_list
parameter_list|(
name|strp
parameter_list|)
name|char
modifier|*
modifier|*
name|strp
decl_stmt|;
block|{
name|char
modifier|*
name|str
init|=
operator|*
name|strp
decl_stmt|;
name|long
name|range
init|=
literal|0
decl_stmt|;
name|int
name|another_range
decl_stmt|;
comment|/* We come back here if we get ranges concatenated by '+' or '|'.  */
do|do
block|{
name|another_range
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|*
name|str
operator|==
literal|'{'
condition|)
block|{
name|int
name|in_range
init|=
literal|0
decl_stmt|;
name|int
name|cur_reg
init|=
operator|-
literal|1
decl_stmt|;
name|str
operator|++
expr_stmt|;
do|do
block|{
name|int
name|reg
decl_stmt|;
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|reg
operator|=
name|reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
operator|-
literal|1
argument_list|)
operator|)
operator|==
name|FAIL
condition|)
return|return
name|FAIL
return|;
if|if
condition|(
name|in_range
condition|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|reg
operator|<=
name|cur_reg
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"bad range in register list"
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
block|}
for|for
control|(
name|i
operator|=
name|cur_reg
operator|+
literal|1
init|;
name|i
operator|<
name|reg
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|range
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
condition|)
name|as_tsktsk
argument_list|(
name|_
argument_list|(
literal|"Warning: duplicated register (r%d) in register list"
argument_list|)
argument_list|,
name|i
argument_list|)
expr_stmt|;
else|else
name|range
operator||=
literal|1
operator|<<
name|i
expr_stmt|;
block|}
name|in_range
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|range
operator|&
operator|(
literal|1
operator|<<
name|reg
operator|)
condition|)
name|as_tsktsk
argument_list|(
name|_
argument_list|(
literal|"Warning: duplicated register (r%d) in register list"
argument_list|)
argument_list|,
name|reg
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|reg
operator|<=
name|cur_reg
condition|)
name|as_tsktsk
argument_list|(
name|_
argument_list|(
literal|"Warning: register range not in ascending order"
argument_list|)
argument_list|)
expr_stmt|;
name|range
operator||=
literal|1
operator|<<
name|reg
expr_stmt|;
name|cur_reg
operator|=
name|reg
expr_stmt|;
block|}
do|while
condition|(
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|!=
name|FAIL
operator|||
operator|(
name|in_range
operator|=
literal|1
operator|,
operator|*
name|str
operator|++
operator|==
literal|'-'
operator|)
condition|)
do|;
name|str
operator|--
expr_stmt|;
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|str
operator|++
operator|!=
literal|'}'
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"missing `}'"
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
block|}
block|}
else|else
block|{
name|expressionS
name|expr
decl_stmt|;
if|if
condition|(
name|my_get_expression
argument_list|(
operator|&
name|expr
argument_list|,
operator|&
name|str
argument_list|)
condition|)
return|return
name|FAIL
return|;
if|if
condition|(
name|expr
operator|.
name|X_op
operator|==
name|O_constant
condition|)
block|{
if|if
condition|(
name|expr
operator|.
name|X_add_number
operator|!=
operator|(
name|expr
operator|.
name|X_add_number
operator|&
literal|0x0000ffff
operator|)
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"invalid register mask"
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
block|}
if|if
condition|(
operator|(
name|range
operator|&
name|expr
operator|.
name|X_add_number
operator|)
operator|!=
literal|0
condition|)
block|{
name|int
name|regno
init|=
name|range
operator|&
name|expr
operator|.
name|X_add_number
decl_stmt|;
name|regno
operator|&=
operator|-
name|regno
expr_stmt|;
name|regno
operator|=
operator|(
literal|1
operator|<<
name|regno
operator|)
operator|-
literal|1
expr_stmt|;
name|as_tsktsk
argument_list|(
name|_
argument_list|(
literal|"Warning: duplicated register (r%d) in register list"
argument_list|)
argument_list|,
name|regno
argument_list|)
expr_stmt|;
block|}
name|range
operator||=
name|expr
operator|.
name|X_add_number
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|inst
operator|.
name|reloc
operator|.
name|type
operator|!=
literal|0
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"expression too complex"
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
block|}
name|memcpy
argument_list|(
operator|&
name|inst
operator|.
name|reloc
operator|.
name|exp
argument_list|,
operator|&
name|expr
argument_list|,
sizeof|sizeof
argument_list|(
name|expressionS
argument_list|)
argument_list|)
expr_stmt|;
name|inst
operator|.
name|reloc
operator|.
name|type
operator|=
name|BFD_RELOC_ARM_MULTI
expr_stmt|;
name|inst
operator|.
name|reloc
operator|.
name|pc_rel
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|str
operator|==
literal|'|'
operator|||
operator|*
name|str
operator|==
literal|'+'
condition|)
block|{
name|str
operator|++
expr_stmt|;
name|another_range
operator|=
literal|1
expr_stmt|;
block|}
block|}
do|while
condition|(
name|another_range
condition|)
do|;
operator|*
name|strp
operator|=
name|str
expr_stmt|;
return|return
name|range
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_ldmstm
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|int
name|base_reg
decl_stmt|;
name|long
name|range
decl_stmt|;
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|base_reg
operator|=
name|reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|16
argument_list|)
operator|)
operator|==
name|FAIL
condition|)
return|return;
if|if
condition|(
name|base_reg
operator|==
name|REG_PC
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"r15 not allowed as base register"
argument_list|)
expr_stmt|;
return|return;
block|}
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|str
operator|==
literal|'!'
condition|)
block|{
name|inst
operator|.
name|instruction
operator||=
name|WRITE_BACK
expr_stmt|;
name|str
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
operator|||
operator|(
name|range
operator|=
name|reg_list
argument_list|(
operator|&
name|str
argument_list|)
operator|)
operator|==
name|FAIL
condition|)
block|{
if|if
condition|(
operator|!
name|inst
operator|.
name|error
condition|)
name|inst
operator|.
name|error
operator|=
name|BAD_ARGS
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|*
name|str
operator|==
literal|'^'
condition|)
block|{
name|str
operator|++
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|LDM_TYPE_2_OR_3
expr_stmt|;
block|}
name|inst
operator|.
name|instruction
operator||=
name|range
expr_stmt|;
name|end_of_line
argument_list|(
name|str
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|do_swi
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
comment|/* Allow optional leading '#'.  */
if|if
condition|(
name|is_immediate_prefix
argument_list|(
operator|*
name|str
argument_list|)
condition|)
name|str
operator|++
expr_stmt|;
if|if
condition|(
name|my_get_expression
argument_list|(
operator|&
name|inst
operator|.
name|reloc
operator|.
name|exp
argument_list|,
operator|&
name|str
argument_list|)
condition|)
return|return;
name|inst
operator|.
name|reloc
operator|.
name|type
operator|=
name|BFD_RELOC_ARM_SWI
expr_stmt|;
name|inst
operator|.
name|reloc
operator|.
name|pc_rel
operator|=
literal|0
expr_stmt|;
name|end_of_line
argument_list|(
name|str
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|do_swap
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|int
name|reg
decl_stmt|;
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|reg
operator|=
name|reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|12
argument_list|)
operator|)
operator|==
name|FAIL
condition|)
return|return;
if|if
condition|(
name|reg
operator|==
name|REG_PC
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"r15 not allowed in swap"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
operator|||
operator|(
name|reg
operator|=
name|reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
name|FAIL
condition|)
block|{
if|if
condition|(
operator|!
name|inst
operator|.
name|error
condition|)
name|inst
operator|.
name|error
operator|=
name|BAD_ARGS
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|reg
operator|==
name|REG_PC
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"r15 not allowed in swap"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
operator|||
operator|*
name|str
operator|++
operator|!=
literal|'['
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|BAD_ARGS
expr_stmt|;
return|return;
block|}
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|reg
operator|=
name|reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|16
argument_list|)
operator|)
operator|==
name|FAIL
condition|)
return|return;
if|if
condition|(
name|reg
operator|==
name|REG_PC
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|BAD_PC
expr_stmt|;
return|return;
block|}
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|str
operator|++
operator|!=
literal|']'
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"missing ]"
argument_list|)
expr_stmt|;
return|return;
block|}
name|end_of_line
argument_list|(
name|str
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|do_branch
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
if|if
condition|(
name|my_get_expression
argument_list|(
operator|&
name|inst
operator|.
name|reloc
operator|.
name|exp
argument_list|,
operator|&
name|str
argument_list|)
condition|)
return|return;
ifdef|#
directive|ifdef
name|OBJ_ELF
block|{
name|char
modifier|*
name|save_in
decl_stmt|;
comment|/* ScottB: February 5, 1998 - Check to see of PLT32 reloc        required for the instruction.  */
comment|/* arm_parse_reloc () works on input_line_pointer.        We actually want to parse the operands to the branch instruction        passed in 'str'.  Save the input pointer and restore it later.  */
name|save_in
operator|=
name|input_line_pointer
expr_stmt|;
name|input_line_pointer
operator|=
name|str
expr_stmt|;
if|if
condition|(
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_op
operator|==
name|O_symbol
operator|&&
operator|*
name|str
operator|==
literal|'('
operator|&&
name|arm_parse_reloc
argument_list|()
operator|==
name|BFD_RELOC_ARM_PLT32
condition|)
block|{
name|inst
operator|.
name|reloc
operator|.
name|type
operator|=
name|BFD_RELOC_ARM_PLT32
expr_stmt|;
name|inst
operator|.
name|reloc
operator|.
name|pc_rel
operator|=
literal|0
expr_stmt|;
comment|/* Modify str to point to after parsed operands, otherwise 	   end_of_line() will complain about the (PLT) left in str.  */
name|str
operator|=
name|input_line_pointer
expr_stmt|;
block|}
else|else
block|{
name|inst
operator|.
name|reloc
operator|.
name|type
operator|=
name|BFD_RELOC_ARM_PCREL_BRANCH
expr_stmt|;
name|inst
operator|.
name|reloc
operator|.
name|pc_rel
operator|=
literal|1
expr_stmt|;
block|}
name|input_line_pointer
operator|=
name|save_in
expr_stmt|;
block|}
else|#
directive|else
name|inst
operator|.
name|reloc
operator|.
name|type
operator|=
name|BFD_RELOC_ARM_PCREL_BRANCH
expr_stmt|;
name|inst
operator|.
name|reloc
operator|.
name|pc_rel
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
comment|/* OBJ_ELF  */
name|end_of_line
argument_list|(
name|str
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|do_bx
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|int
name|reg
decl_stmt|;
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|reg
operator|=
name|reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
name|FAIL
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|BAD_ARGS
expr_stmt|;
return|return;
block|}
comment|/* Note - it is not illegal to do a "bx pc".  Useless, but not illegal.  */
if|if
condition|(
name|reg
operator|==
name|REG_PC
condition|)
name|as_tsktsk
argument_list|(
name|_
argument_list|(
literal|"use of r15 in bx in ARM mode is not really useful"
argument_list|)
argument_list|)
expr_stmt|;
name|end_of_line
argument_list|(
name|str
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_cdp
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
comment|/* Co-processor data operation.      Format: CDP{cond} CP#,<expr>,CRd,CRn,CRm{,<expr>}  */
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|co_proc_number
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
condition|)
block|{
if|if
condition|(
operator|!
name|inst
operator|.
name|error
condition|)
name|inst
operator|.
name|error
operator|=
name|BAD_ARGS
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
operator|||
name|cp_opc_expr
argument_list|(
operator|&
name|str
argument_list|,
literal|20
argument_list|,
literal|4
argument_list|)
operator|==
name|FAIL
condition|)
block|{
if|if
condition|(
operator|!
name|inst
operator|.
name|error
condition|)
name|inst
operator|.
name|error
operator|=
name|BAD_ARGS
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
operator|||
name|cp_reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|12
argument_list|)
operator|==
name|FAIL
condition|)
block|{
if|if
condition|(
operator|!
name|inst
operator|.
name|error
condition|)
name|inst
operator|.
name|error
operator|=
name|BAD_ARGS
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
operator|||
name|cp_reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|16
argument_list|)
operator|==
name|FAIL
condition|)
block|{
if|if
condition|(
operator|!
name|inst
operator|.
name|error
condition|)
name|inst
operator|.
name|error
operator|=
name|BAD_ARGS
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
operator|||
name|cp_reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|0
argument_list|)
operator|==
name|FAIL
condition|)
block|{
if|if
condition|(
operator|!
name|inst
operator|.
name|error
condition|)
name|inst
operator|.
name|error
operator|=
name|BAD_ARGS
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|SUCCESS
condition|)
block|{
if|if
condition|(
name|cp_opc_expr
argument_list|(
operator|&
name|str
argument_list|,
literal|5
argument_list|,
literal|3
argument_list|)
operator|==
name|FAIL
condition|)
block|{
if|if
condition|(
operator|!
name|inst
operator|.
name|error
condition|)
name|inst
operator|.
name|error
operator|=
name|BAD_ARGS
expr_stmt|;
return|return;
block|}
block|}
name|end_of_line
argument_list|(
name|str
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|do_lstc
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
comment|/* Co-processor register load/store.      Format:<LDC|STC{cond}[L] CP#,CRd,<address>  */
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|co_proc_number
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
condition|)
block|{
if|if
condition|(
operator|!
name|inst
operator|.
name|error
condition|)
name|inst
operator|.
name|error
operator|=
name|BAD_ARGS
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
operator|||
name|cp_reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|12
argument_list|)
operator|==
name|FAIL
condition|)
block|{
if|if
condition|(
operator|!
name|inst
operator|.
name|error
condition|)
name|inst
operator|.
name|error
operator|=
name|BAD_ARGS
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
operator|||
name|cp_address_required_here
argument_list|(
operator|&
name|str
argument_list|,
name|CP_WB_OK
argument_list|)
operator|==
name|FAIL
condition|)
block|{
if|if
condition|(
operator|!
name|inst
operator|.
name|error
condition|)
name|inst
operator|.
name|error
operator|=
name|BAD_ARGS
expr_stmt|;
return|return;
block|}
name|end_of_line
argument_list|(
name|str
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|do_co_reg
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
comment|/* Co-processor register transfer.      Format:<MCR|MRC>{cond} CP#,<expr1>,Rd,CRn,CRm{,<expr2>}  */
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|co_proc_number
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
condition|)
block|{
if|if
condition|(
operator|!
name|inst
operator|.
name|error
condition|)
name|inst
operator|.
name|error
operator|=
name|BAD_ARGS
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
operator|||
name|cp_opc_expr
argument_list|(
operator|&
name|str
argument_list|,
literal|21
argument_list|,
literal|3
argument_list|)
operator|==
name|FAIL
condition|)
block|{
if|if
condition|(
operator|!
name|inst
operator|.
name|error
condition|)
name|inst
operator|.
name|error
operator|=
name|BAD_ARGS
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
operator|||
name|reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|12
argument_list|)
operator|==
name|FAIL
condition|)
block|{
if|if
condition|(
operator|!
name|inst
operator|.
name|error
condition|)
name|inst
operator|.
name|error
operator|=
name|BAD_ARGS
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
operator|||
name|cp_reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|16
argument_list|)
operator|==
name|FAIL
condition|)
block|{
if|if
condition|(
operator|!
name|inst
operator|.
name|error
condition|)
name|inst
operator|.
name|error
operator|=
name|BAD_ARGS
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
operator|||
name|cp_reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|0
argument_list|)
operator|==
name|FAIL
condition|)
block|{
if|if
condition|(
operator|!
name|inst
operator|.
name|error
condition|)
name|inst
operator|.
name|error
operator|=
name|BAD_ARGS
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|SUCCESS
condition|)
block|{
if|if
condition|(
name|cp_opc_expr
argument_list|(
operator|&
name|str
argument_list|,
literal|5
argument_list|,
literal|3
argument_list|)
operator|==
name|FAIL
condition|)
block|{
if|if
condition|(
operator|!
name|inst
operator|.
name|error
condition|)
name|inst
operator|.
name|error
operator|=
name|BAD_ARGS
expr_stmt|;
return|return;
block|}
block|}
name|end_of_line
argument_list|(
name|str
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|do_fpa_ctrl
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
comment|/* FP control registers.      Format:<WFS|RFS|WFC|RFC>{cond} Rn  */
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|12
argument_list|)
operator|==
name|FAIL
condition|)
block|{
if|if
condition|(
operator|!
name|inst
operator|.
name|error
condition|)
name|inst
operator|.
name|error
operator|=
name|BAD_ARGS
expr_stmt|;
return|return;
block|}
name|end_of_line
argument_list|(
name|str
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|do_fpa_ldst
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp_reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|12
argument_list|)
operator|==
name|FAIL
condition|)
block|{
if|if
condition|(
operator|!
name|inst
operator|.
name|error
condition|)
name|inst
operator|.
name|error
operator|=
name|BAD_ARGS
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
operator|||
name|cp_address_required_here
argument_list|(
operator|&
name|str
argument_list|,
name|CP_WB_OK
argument_list|)
operator|==
name|FAIL
condition|)
block|{
if|if
condition|(
operator|!
name|inst
operator|.
name|error
condition|)
name|inst
operator|.
name|error
operator|=
name|BAD_ARGS
expr_stmt|;
return|return;
block|}
name|end_of_line
argument_list|(
name|str
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_fpa_ldmstm
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|int
name|num_regs
decl_stmt|;
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp_reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|12
argument_list|)
operator|==
name|FAIL
condition|)
block|{
if|if
condition|(
operator|!
name|inst
operator|.
name|error
condition|)
name|inst
operator|.
name|error
operator|=
name|BAD_ARGS
expr_stmt|;
return|return;
block|}
comment|/* Get Number of registers to transfer.  */
if|if
condition|(
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
operator|||
name|my_get_expression
argument_list|(
operator|&
name|inst
operator|.
name|reloc
operator|.
name|exp
argument_list|,
operator|&
name|str
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|inst
operator|.
name|error
condition|)
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"constant expression expected"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_op
operator|!=
name|O_constant
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"constant value required for number of registers"
argument_list|)
expr_stmt|;
return|return;
block|}
name|num_regs
operator|=
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_add_number
expr_stmt|;
if|if
condition|(
name|num_regs
operator|<
literal|1
operator|||
name|num_regs
operator|>
literal|4
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"number of registers must be in the range [1:4]"
argument_list|)
expr_stmt|;
return|return;
block|}
switch|switch
condition|(
name|num_regs
condition|)
block|{
case|case
literal|1
case|:
name|inst
operator|.
name|instruction
operator||=
name|CP_T_X
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|inst
operator|.
name|instruction
operator||=
name|CP_T_Y
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|inst
operator|.
name|instruction
operator||=
name|CP_T_Y
operator||
name|CP_T_X
expr_stmt|;
break|break;
case|case
literal|4
case|:
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|inst
operator|.
name|instruction
operator|&
operator|(
name|CP_T_Pre
operator||
name|CP_T_UD
operator|)
condition|)
comment|/* ea/fd format.  */
block|{
name|int
name|reg
decl_stmt|;
name|int
name|write_back
decl_stmt|;
name|int
name|offset
decl_stmt|;
comment|/* The instruction specified "ea" or "fd", so we can only accept 	 [Rn]{!}.  The instruction does not really support stacking or 	 unstacking, so we have to emulate these by setting appropriate 	 bits and offsets.  */
if|if
condition|(
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
operator|||
operator|*
name|str
operator|!=
literal|'['
condition|)
block|{
if|if
condition|(
operator|!
name|inst
operator|.
name|error
condition|)
name|inst
operator|.
name|error
operator|=
name|BAD_ARGS
expr_stmt|;
return|return;
block|}
name|str
operator|++
expr_stmt|;
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|reg
operator|=
name|reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|16
argument_list|)
operator|)
operator|==
name|FAIL
condition|)
return|return;
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|str
operator|!=
literal|']'
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|BAD_ARGS
expr_stmt|;
return|return;
block|}
name|str
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|str
operator|==
literal|'!'
condition|)
block|{
name|write_back
operator|=
literal|1
expr_stmt|;
name|str
operator|++
expr_stmt|;
if|if
condition|(
name|reg
operator|==
name|REG_PC
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"r15 not allowed as base register with write-back"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
else|else
name|write_back
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|inst
operator|.
name|instruction
operator|&
name|CP_T_Pre
condition|)
block|{
comment|/* Pre-decrement.  */
name|offset
operator|=
literal|3
operator|*
name|num_regs
expr_stmt|;
if|if
condition|(
name|write_back
condition|)
name|inst
operator|.
name|instruction
operator||=
name|CP_T_WB
expr_stmt|;
block|}
else|else
block|{
comment|/* Post-increment.  */
if|if
condition|(
name|write_back
condition|)
block|{
name|inst
operator|.
name|instruction
operator||=
name|CP_T_WB
expr_stmt|;
name|offset
operator|=
literal|3
operator|*
name|num_regs
expr_stmt|;
block|}
else|else
block|{
comment|/* No write-back, so convert this into a standard pre-increment 		 instruction -- aesthetically more pleasing.  */
name|inst
operator|.
name|instruction
operator||=
name|CP_T_Pre
operator||
name|CP_T_UD
expr_stmt|;
name|offset
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|inst
operator|.
name|instruction
operator||=
name|offset
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
operator|||
name|cp_address_required_here
argument_list|(
operator|&
name|str
argument_list|,
name|CP_WB_OK
argument_list|)
operator|==
name|FAIL
condition|)
block|{
if|if
condition|(
operator|!
name|inst
operator|.
name|error
condition|)
name|inst
operator|.
name|error
operator|=
name|BAD_ARGS
expr_stmt|;
return|return;
block|}
name|end_of_line
argument_list|(
name|str
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_fpa_dyadic
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp_reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|12
argument_list|)
operator|==
name|FAIL
condition|)
block|{
if|if
condition|(
operator|!
name|inst
operator|.
name|error
condition|)
name|inst
operator|.
name|error
operator|=
name|BAD_ARGS
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
operator|||
name|fp_reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|16
argument_list|)
operator|==
name|FAIL
condition|)
block|{
if|if
condition|(
operator|!
name|inst
operator|.
name|error
condition|)
name|inst
operator|.
name|error
operator|=
name|BAD_ARGS
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
operator|||
name|fp_op2
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
condition|)
block|{
if|if
condition|(
operator|!
name|inst
operator|.
name|error
condition|)
name|inst
operator|.
name|error
operator|=
name|BAD_ARGS
expr_stmt|;
return|return;
block|}
name|end_of_line
argument_list|(
name|str
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|do_fpa_monadic
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp_reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|12
argument_list|)
operator|==
name|FAIL
condition|)
block|{
if|if
condition|(
operator|!
name|inst
operator|.
name|error
condition|)
name|inst
operator|.
name|error
operator|=
name|BAD_ARGS
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
operator|||
name|fp_op2
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
condition|)
block|{
if|if
condition|(
operator|!
name|inst
operator|.
name|error
condition|)
name|inst
operator|.
name|error
operator|=
name|BAD_ARGS
expr_stmt|;
return|return;
block|}
name|end_of_line
argument_list|(
name|str
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|do_fpa_cmp
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp_reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|16
argument_list|)
operator|==
name|FAIL
condition|)
block|{
if|if
condition|(
operator|!
name|inst
operator|.
name|error
condition|)
name|inst
operator|.
name|error
operator|=
name|BAD_ARGS
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
operator|||
name|fp_op2
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
condition|)
block|{
if|if
condition|(
operator|!
name|inst
operator|.
name|error
condition|)
name|inst
operator|.
name|error
operator|=
name|BAD_ARGS
expr_stmt|;
return|return;
block|}
name|end_of_line
argument_list|(
name|str
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|do_fpa_from_reg
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp_reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|16
argument_list|)
operator|==
name|FAIL
condition|)
block|{
if|if
condition|(
operator|!
name|inst
operator|.
name|error
condition|)
name|inst
operator|.
name|error
operator|=
name|BAD_ARGS
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
operator|||
name|reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|12
argument_list|)
operator|==
name|FAIL
condition|)
block|{
if|if
condition|(
operator|!
name|inst
operator|.
name|error
condition|)
name|inst
operator|.
name|error
operator|=
name|BAD_ARGS
expr_stmt|;
return|return;
block|}
name|end_of_line
argument_list|(
name|str
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|do_fpa_to_reg
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|12
argument_list|)
operator|==
name|FAIL
condition|)
return|return;
if|if
condition|(
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
operator|||
name|fp_reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|0
argument_list|)
operator|==
name|FAIL
condition|)
block|{
if|if
condition|(
operator|!
name|inst
operator|.
name|error
condition|)
name|inst
operator|.
name|error
operator|=
name|BAD_ARGS
expr_stmt|;
return|return;
block|}
name|end_of_line
argument_list|(
name|str
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|int
name|vfp_sp_reg_required_here
parameter_list|(
name|str
parameter_list|,
name|pos
parameter_list|)
name|char
modifier|*
modifier|*
name|str
decl_stmt|;
name|enum
name|vfp_sp_reg_pos
name|pos
decl_stmt|;
block|{
name|int
name|reg
decl_stmt|;
name|char
modifier|*
name|start
init|=
operator|*
name|str
decl_stmt|;
if|if
condition|(
operator|(
name|reg
operator|=
name|arm_reg_parse
argument_list|(
name|str
argument_list|,
name|all_reg_maps
index|[
name|REG_TYPE_SN
index|]
operator|.
name|htab
argument_list|)
operator|)
operator|!=
name|FAIL
condition|)
block|{
switch|switch
condition|(
name|pos
condition|)
block|{
case|case
name|VFP_REG_Sd
case|:
name|inst
operator|.
name|instruction
operator||=
operator|(
operator|(
name|reg
operator|>>
literal|1
operator|)
operator|<<
literal|12
operator|)
operator||
operator|(
operator|(
name|reg
operator|&
literal|1
operator|)
operator|<<
literal|22
operator|)
expr_stmt|;
break|break;
case|case
name|VFP_REG_Sn
case|:
name|inst
operator|.
name|instruction
operator||=
operator|(
operator|(
name|reg
operator|>>
literal|1
operator|)
operator|<<
literal|16
operator|)
operator||
operator|(
operator|(
name|reg
operator|&
literal|1
operator|)
operator|<<
literal|7
operator|)
expr_stmt|;
break|break;
case|case
name|VFP_REG_Sm
case|:
name|inst
operator|.
name|instruction
operator||=
operator|(
operator|(
name|reg
operator|>>
literal|1
operator|)
operator|<<
literal|0
operator|)
operator||
operator|(
operator|(
name|reg
operator|&
literal|1
operator|)
operator|<<
literal|5
operator|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
return|return
name|reg
return|;
block|}
comment|/* In the few cases where we might be able to accept something else      this error can be overridden.  */
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
name|all_reg_maps
index|[
name|REG_TYPE_SN
index|]
operator|.
name|expected
argument_list|)
expr_stmt|;
comment|/* Restore the start point.  */
operator|*
name|str
operator|=
name|start
expr_stmt|;
return|return
name|FAIL
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vfp_dp_reg_required_here
parameter_list|(
name|str
parameter_list|,
name|pos
parameter_list|)
name|char
modifier|*
modifier|*
name|str
decl_stmt|;
name|enum
name|vfp_dp_reg_pos
name|pos
decl_stmt|;
block|{
name|int
name|reg
decl_stmt|;
name|char
modifier|*
name|start
init|=
operator|*
name|str
decl_stmt|;
if|if
condition|(
operator|(
name|reg
operator|=
name|arm_reg_parse
argument_list|(
name|str
argument_list|,
name|all_reg_maps
index|[
name|REG_TYPE_DN
index|]
operator|.
name|htab
argument_list|)
operator|)
operator|!=
name|FAIL
condition|)
block|{
switch|switch
condition|(
name|pos
condition|)
block|{
case|case
name|VFP_REG_Dd
case|:
name|inst
operator|.
name|instruction
operator||=
name|reg
operator|<<
literal|12
expr_stmt|;
break|break;
case|case
name|VFP_REG_Dn
case|:
name|inst
operator|.
name|instruction
operator||=
name|reg
operator|<<
literal|16
expr_stmt|;
break|break;
case|case
name|VFP_REG_Dm
case|:
name|inst
operator|.
name|instruction
operator||=
name|reg
operator|<<
literal|0
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
return|return
name|reg
return|;
block|}
comment|/* In the few cases where we might be able to accept something else      this error can be overridden.  */
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
name|all_reg_maps
index|[
name|REG_TYPE_DN
index|]
operator|.
name|expected
argument_list|)
expr_stmt|;
comment|/* Restore the start point.  */
operator|*
name|str
operator|=
name|start
expr_stmt|;
return|return
name|FAIL
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_vfp_sp_monadic
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|vfp_sp_reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
name|VFP_REG_Sd
argument_list|)
operator|==
name|FAIL
condition|)
return|return;
if|if
condition|(
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
operator|||
name|vfp_sp_reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
name|VFP_REG_Sm
argument_list|)
operator|==
name|FAIL
condition|)
block|{
if|if
condition|(
operator|!
name|inst
operator|.
name|error
condition|)
name|inst
operator|.
name|error
operator|=
name|BAD_ARGS
expr_stmt|;
return|return;
block|}
name|end_of_line
argument_list|(
name|str
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|do_vfp_dp_monadic
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|vfp_dp_reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
name|VFP_REG_Dd
argument_list|)
operator|==
name|FAIL
condition|)
return|return;
if|if
condition|(
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
operator|||
name|vfp_dp_reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
name|VFP_REG_Dm
argument_list|)
operator|==
name|FAIL
condition|)
block|{
if|if
condition|(
operator|!
name|inst
operator|.
name|error
condition|)
name|inst
operator|.
name|error
operator|=
name|BAD_ARGS
expr_stmt|;
return|return;
block|}
name|end_of_line
argument_list|(
name|str
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|do_vfp_sp_dyadic
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|vfp_sp_reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
name|VFP_REG_Sd
argument_list|)
operator|==
name|FAIL
condition|)
return|return;
if|if
condition|(
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
operator|||
name|vfp_sp_reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
name|VFP_REG_Sn
argument_list|)
operator|==
name|FAIL
operator|||
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
operator|||
name|vfp_sp_reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
name|VFP_REG_Sm
argument_list|)
operator|==
name|FAIL
condition|)
block|{
if|if
condition|(
operator|!
name|inst
operator|.
name|error
condition|)
name|inst
operator|.
name|error
operator|=
name|BAD_ARGS
expr_stmt|;
return|return;
block|}
name|end_of_line
argument_list|(
name|str
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|do_vfp_dp_dyadic
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|vfp_dp_reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
name|VFP_REG_Dd
argument_list|)
operator|==
name|FAIL
condition|)
return|return;
if|if
condition|(
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
operator|||
name|vfp_dp_reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
name|VFP_REG_Dn
argument_list|)
operator|==
name|FAIL
operator|||
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
operator|||
name|vfp_dp_reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
name|VFP_REG_Dm
argument_list|)
operator|==
name|FAIL
condition|)
block|{
if|if
condition|(
operator|!
name|inst
operator|.
name|error
condition|)
name|inst
operator|.
name|error
operator|=
name|BAD_ARGS
expr_stmt|;
return|return;
block|}
name|end_of_line
argument_list|(
name|str
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|do_vfp_reg_from_sp
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|12
argument_list|)
operator|==
name|FAIL
condition|)
return|return;
if|if
condition|(
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
operator|||
name|vfp_sp_reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
name|VFP_REG_Sn
argument_list|)
operator|==
name|FAIL
condition|)
block|{
if|if
condition|(
operator|!
name|inst
operator|.
name|error
condition|)
name|inst
operator|.
name|error
operator|=
name|BAD_ARGS
expr_stmt|;
return|return;
block|}
name|end_of_line
argument_list|(
name|str
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|do_vfp_sp_reg2
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|12
argument_list|)
operator|==
name|FAIL
condition|)
return|return;
if|if
condition|(
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
operator|||
name|reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|16
argument_list|)
operator|==
name|FAIL
operator|||
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
condition|)
block|{
if|if
condition|(
operator|!
name|inst
operator|.
name|error
condition|)
name|inst
operator|.
name|error
operator|=
name|BAD_ARGS
expr_stmt|;
return|return;
block|}
comment|/* We require exactly two consecutive SP registers.  */
if|if
condition|(
name|vfp_sp_reg_list
argument_list|(
operator|&
name|str
argument_list|,
name|VFP_REG_Sm
argument_list|)
operator|!=
literal|2
condition|)
block|{
if|if
condition|(
operator|!
name|inst
operator|.
name|error
condition|)
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"only two consecutive VFP SP registers allowed here"
argument_list|)
expr_stmt|;
block|}
name|end_of_line
argument_list|(
name|str
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|do_vfp_sp_from_reg
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|vfp_sp_reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
name|VFP_REG_Sn
argument_list|)
operator|==
name|FAIL
condition|)
return|return;
if|if
condition|(
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
operator|||
name|reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|12
argument_list|)
operator|==
name|FAIL
condition|)
block|{
if|if
condition|(
operator|!
name|inst
operator|.
name|error
condition|)
name|inst
operator|.
name|error
operator|=
name|BAD_ARGS
expr_stmt|;
return|return;
block|}
name|end_of_line
argument_list|(
name|str
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|do_vfp_reg_from_dp
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|12
argument_list|)
operator|==
name|FAIL
condition|)
return|return;
if|if
condition|(
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
operator|||
name|vfp_dp_reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
name|VFP_REG_Dn
argument_list|)
operator|==
name|FAIL
condition|)
block|{
if|if
condition|(
operator|!
name|inst
operator|.
name|error
condition|)
name|inst
operator|.
name|error
operator|=
name|BAD_ARGS
expr_stmt|;
return|return;
block|}
name|end_of_line
argument_list|(
name|str
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|do_vfp_reg2_from_dp
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|12
argument_list|)
operator|==
name|FAIL
condition|)
return|return;
if|if
condition|(
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
operator|||
name|reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|16
argument_list|)
operator|==
name|FAIL
operator|||
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
operator|||
name|vfp_dp_reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
name|VFP_REG_Dm
argument_list|)
operator|==
name|FAIL
condition|)
block|{
if|if
condition|(
operator|!
name|inst
operator|.
name|error
condition|)
name|inst
operator|.
name|error
operator|=
name|BAD_ARGS
expr_stmt|;
return|return;
block|}
name|end_of_line
argument_list|(
name|str
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|do_vfp_dp_from_reg
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|vfp_dp_reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
name|VFP_REG_Dn
argument_list|)
operator|==
name|FAIL
condition|)
return|return;
if|if
condition|(
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
operator|||
name|reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|12
argument_list|)
operator|==
name|FAIL
condition|)
block|{
if|if
condition|(
operator|!
name|inst
operator|.
name|error
condition|)
name|inst
operator|.
name|error
operator|=
name|BAD_ARGS
expr_stmt|;
return|return;
block|}
name|end_of_line
argument_list|(
name|str
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|do_vfp_dp_from_reg2
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|vfp_dp_reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
name|VFP_REG_Dm
argument_list|)
operator|==
name|FAIL
condition|)
return|return;
if|if
condition|(
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
operator|||
name|reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|12
argument_list|)
operator|==
name|FAIL
operator|||
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
operator|||
name|reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|16
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|inst
operator|.
name|error
condition|)
name|inst
operator|.
name|error
operator|=
name|BAD_ARGS
expr_stmt|;
return|return;
block|}
name|end_of_line
argument_list|(
name|str
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
specifier|const
name|struct
name|vfp_reg
modifier|*
name|vfp_psr_parse
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
modifier|*
name|str
decl_stmt|;
block|{
name|char
modifier|*
name|start
init|=
operator|*
name|str
decl_stmt|;
name|char
name|c
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
specifier|const
name|struct
name|vfp_reg
modifier|*
name|vreg
decl_stmt|;
name|p
operator|=
name|start
expr_stmt|;
comment|/* Find the end of the current token.  */
do|do
block|{
name|c
operator|=
operator|*
name|p
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|ISALPHA
argument_list|(
name|c
argument_list|)
condition|)
do|;
comment|/* Mark it.  */
operator|*
operator|--
name|p
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|vreg
operator|=
name|vfp_regs
operator|+
literal|0
init|;
name|vreg
operator|<
name|vfp_regs
operator|+
sizeof|sizeof
argument_list|(
name|vfp_regs
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|vfp_reg
argument_list|)
condition|;
name|vreg
operator|++
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|start
argument_list|,
name|vreg
operator|->
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|p
operator|=
name|c
expr_stmt|;
operator|*
name|str
operator|=
name|p
expr_stmt|;
return|return
name|vreg
return|;
block|}
block|}
operator|*
name|p
operator|=
name|c
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vfp_psr_required_here
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
modifier|*
name|str
decl_stmt|;
block|{
name|char
modifier|*
name|start
init|=
operator|*
name|str
decl_stmt|;
specifier|const
name|struct
name|vfp_reg
modifier|*
name|vreg
decl_stmt|;
name|vreg
operator|=
name|vfp_psr_parse
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|vreg
condition|)
block|{
name|inst
operator|.
name|instruction
operator||=
name|vreg
operator|->
name|regno
expr_stmt|;
return|return
name|SUCCESS
return|;
block|}
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"VFP system register expected"
argument_list|)
expr_stmt|;
operator|*
name|str
operator|=
name|start
expr_stmt|;
return|return
name|FAIL
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_vfp_reg_from_ctrl
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|12
argument_list|)
operator|==
name|FAIL
condition|)
return|return;
if|if
condition|(
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
operator|||
name|vfp_psr_required_here
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
condition|)
block|{
if|if
condition|(
operator|!
name|inst
operator|.
name|error
condition|)
name|inst
operator|.
name|error
operator|=
name|BAD_ARGS
expr_stmt|;
return|return;
block|}
name|end_of_line
argument_list|(
name|str
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|do_vfp_ctrl_from_reg
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|vfp_psr_required_here
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
condition|)
return|return;
if|if
condition|(
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
operator|||
name|reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|12
argument_list|)
operator|==
name|FAIL
condition|)
block|{
if|if
condition|(
operator|!
name|inst
operator|.
name|error
condition|)
name|inst
operator|.
name|error
operator|=
name|BAD_ARGS
expr_stmt|;
return|return;
block|}
name|end_of_line
argument_list|(
name|str
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|do_vfp_sp_ldst
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|vfp_sp_reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
name|VFP_REG_Sd
argument_list|)
operator|==
name|FAIL
condition|)
block|{
if|if
condition|(
operator|!
name|inst
operator|.
name|error
condition|)
name|inst
operator|.
name|error
operator|=
name|BAD_ARGS
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
operator|||
name|cp_address_required_here
argument_list|(
operator|&
name|str
argument_list|,
name|CP_NO_WB
argument_list|)
operator|==
name|FAIL
condition|)
block|{
if|if
condition|(
operator|!
name|inst
operator|.
name|error
condition|)
name|inst
operator|.
name|error
operator|=
name|BAD_ARGS
expr_stmt|;
return|return;
block|}
name|end_of_line
argument_list|(
name|str
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|do_vfp_dp_ldst
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|vfp_dp_reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
name|VFP_REG_Dd
argument_list|)
operator|==
name|FAIL
condition|)
block|{
if|if
condition|(
operator|!
name|inst
operator|.
name|error
condition|)
name|inst
operator|.
name|error
operator|=
name|BAD_ARGS
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
operator|||
name|cp_address_required_here
argument_list|(
operator|&
name|str
argument_list|,
name|CP_NO_WB
argument_list|)
operator|==
name|FAIL
condition|)
block|{
if|if
condition|(
operator|!
name|inst
operator|.
name|error
condition|)
name|inst
operator|.
name|error
operator|=
name|BAD_ARGS
expr_stmt|;
return|return;
block|}
name|end_of_line
argument_list|(
name|str
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* Parse and encode a VFP SP register list, storing the initial    register in position POS and returning the range as the result.  If    the string is invalid return FAIL (an invalid range).  */
end_comment

begin_function
specifier|static
name|long
name|vfp_sp_reg_list
parameter_list|(
name|str
parameter_list|,
name|pos
parameter_list|)
name|char
modifier|*
modifier|*
name|str
decl_stmt|;
name|enum
name|vfp_sp_reg_pos
name|pos
decl_stmt|;
block|{
name|long
name|range
init|=
literal|0
decl_stmt|;
name|int
name|base_reg
init|=
literal|0
decl_stmt|;
name|int
name|new_base
decl_stmt|;
name|long
name|base_bits
init|=
literal|0
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
name|long
name|tempinst
decl_stmt|;
name|unsigned
name|long
name|mask
init|=
literal|0
decl_stmt|;
name|int
name|warned
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|*
operator|*
name|str
operator|!=
literal|'{'
condition|)
return|return
name|FAIL
return|;
operator|(
operator|*
name|str
operator|)
operator|++
expr_stmt|;
name|skip_whitespace
argument_list|(
operator|*
name|str
argument_list|)
expr_stmt|;
name|tempinst
operator|=
name|inst
operator|.
name|instruction
expr_stmt|;
do|do
block|{
name|inst
operator|.
name|instruction
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|new_base
operator|=
name|vfp_sp_reg_required_here
argument_list|(
name|str
argument_list|,
name|pos
argument_list|)
operator|)
operator|==
name|FAIL
condition|)
return|return
name|FAIL
return|;
if|if
condition|(
name|count
operator|==
literal|0
operator|||
name|base_reg
operator|>
name|new_base
condition|)
block|{
name|base_reg
operator|=
name|new_base
expr_stmt|;
name|base_bits
operator|=
name|inst
operator|.
name|instruction
expr_stmt|;
block|}
if|if
condition|(
name|mask
operator|&
operator|(
literal|1
operator|<<
name|new_base
operator|)
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"invalid register list"
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
block|}
if|if
condition|(
operator|(
name|mask
operator|>>
name|new_base
operator|)
operator|!=
literal|0
operator|&&
operator|!
name|warned
condition|)
block|{
name|as_tsktsk
argument_list|(
name|_
argument_list|(
literal|"register list not in ascending order"
argument_list|)
argument_list|)
expr_stmt|;
name|warned
operator|=
literal|1
expr_stmt|;
block|}
name|mask
operator||=
literal|1
operator|<<
name|new_base
expr_stmt|;
name|count
operator|++
expr_stmt|;
name|skip_whitespace
argument_list|(
operator|*
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|*
name|str
operator|==
literal|'-'
condition|)
comment|/* We have the start of a range expression */
block|{
name|int
name|high_range
decl_stmt|;
operator|(
operator|*
name|str
operator|)
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|high_range
operator|=
name|arm_reg_parse
argument_list|(
name|str
argument_list|,
name|all_reg_maps
index|[
name|REG_TYPE_SN
index|]
operator|.
name|htab
argument_list|)
operator|)
operator|==
name|FAIL
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
name|all_reg_maps
index|[
name|REG_TYPE_SN
index|]
operator|.
name|expected
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
block|}
if|if
condition|(
name|high_range
operator|<=
name|new_base
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"register range not in ascending order"
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
block|}
for|for
control|(
name|new_base
operator|++
init|;
name|new_base
operator|<=
name|high_range
condition|;
name|new_base
operator|++
control|)
block|{
if|if
condition|(
name|mask
operator|&
operator|(
literal|1
operator|<<
name|new_base
operator|)
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"invalid register list"
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
block|}
name|mask
operator||=
literal|1
operator|<<
name|new_base
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
block|}
block|}
do|while
condition|(
name|skip_past_comma
argument_list|(
name|str
argument_list|)
operator|!=
name|FAIL
condition|)
do|;
if|if
condition|(
operator|*
operator|*
name|str
operator|!=
literal|'}'
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"invalid register list"
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
block|}
operator|(
operator|*
name|str
operator|)
operator|++
expr_stmt|;
name|range
operator|=
name|count
expr_stmt|;
comment|/* Sanity check -- should have raised a parse error above.  */
if|if
condition|(
name|count
operator|==
literal|0
operator|||
name|count
operator|>
literal|32
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Final test -- the registers must be consecutive.  */
while|while
condition|(
name|count
operator|--
condition|)
block|{
if|if
condition|(
operator|(
name|mask
operator|&
operator|(
literal|1
operator|<<
name|base_reg
operator|++
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"non-contiguous register range"
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
block|}
block|}
name|inst
operator|.
name|instruction
operator|=
name|tempinst
operator||
name|base_bits
expr_stmt|;
return|return
name|range
return|;
block|}
end_function

begin_function
specifier|static
name|long
name|vfp_dp_reg_list
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
modifier|*
name|str
decl_stmt|;
block|{
name|long
name|range
init|=
literal|0
decl_stmt|;
name|int
name|base_reg
init|=
literal|0
decl_stmt|;
name|int
name|new_base
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
name|long
name|tempinst
decl_stmt|;
name|unsigned
name|long
name|mask
init|=
literal|0
decl_stmt|;
name|int
name|warned
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|*
operator|*
name|str
operator|!=
literal|'{'
condition|)
return|return
name|FAIL
return|;
operator|(
operator|*
name|str
operator|)
operator|++
expr_stmt|;
name|skip_whitespace
argument_list|(
operator|*
name|str
argument_list|)
expr_stmt|;
name|tempinst
operator|=
name|inst
operator|.
name|instruction
expr_stmt|;
do|do
block|{
name|inst
operator|.
name|instruction
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|new_base
operator|=
name|vfp_dp_reg_required_here
argument_list|(
name|str
argument_list|,
name|VFP_REG_Dd
argument_list|)
operator|)
operator|==
name|FAIL
condition|)
return|return
name|FAIL
return|;
if|if
condition|(
name|count
operator|==
literal|0
operator|||
name|base_reg
operator|>
name|new_base
condition|)
block|{
name|base_reg
operator|=
name|new_base
expr_stmt|;
name|range
operator|=
name|inst
operator|.
name|instruction
expr_stmt|;
block|}
if|if
condition|(
name|mask
operator|&
operator|(
literal|1
operator|<<
name|new_base
operator|)
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"invalid register list"
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
block|}
if|if
condition|(
operator|(
name|mask
operator|>>
name|new_base
operator|)
operator|!=
literal|0
operator|&&
operator|!
name|warned
condition|)
block|{
name|as_tsktsk
argument_list|(
name|_
argument_list|(
literal|"register list not in ascending order"
argument_list|)
argument_list|)
expr_stmt|;
name|warned
operator|=
literal|1
expr_stmt|;
block|}
name|mask
operator||=
literal|1
operator|<<
name|new_base
expr_stmt|;
name|count
operator|++
expr_stmt|;
name|skip_whitespace
argument_list|(
operator|*
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|*
name|str
operator|==
literal|'-'
condition|)
comment|/* We have the start of a range expression */
block|{
name|int
name|high_range
decl_stmt|;
operator|(
operator|*
name|str
operator|)
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|high_range
operator|=
name|arm_reg_parse
argument_list|(
name|str
argument_list|,
name|all_reg_maps
index|[
name|REG_TYPE_DN
index|]
operator|.
name|htab
argument_list|)
operator|)
operator|==
name|FAIL
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
name|all_reg_maps
index|[
name|REG_TYPE_DN
index|]
operator|.
name|expected
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
block|}
if|if
condition|(
name|high_range
operator|<=
name|new_base
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"register range not in ascending order"
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
block|}
for|for
control|(
name|new_base
operator|++
init|;
name|new_base
operator|<=
name|high_range
condition|;
name|new_base
operator|++
control|)
block|{
if|if
condition|(
name|mask
operator|&
operator|(
literal|1
operator|<<
name|new_base
operator|)
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"invalid register list"
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
block|}
name|mask
operator||=
literal|1
operator|<<
name|new_base
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
block|}
block|}
do|while
condition|(
name|skip_past_comma
argument_list|(
name|str
argument_list|)
operator|!=
name|FAIL
condition|)
do|;
if|if
condition|(
operator|*
operator|*
name|str
operator|!=
literal|'}'
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"invalid register list"
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
block|}
operator|(
operator|*
name|str
operator|)
operator|++
expr_stmt|;
name|range
operator||=
literal|2
operator|*
name|count
expr_stmt|;
comment|/* Sanity check -- should have raised a parse error above.  */
if|if
condition|(
name|count
operator|==
literal|0
operator|||
name|count
operator|>
literal|16
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Final test -- the registers must be consecutive.  */
while|while
condition|(
name|count
operator|--
condition|)
block|{
if|if
condition|(
operator|(
name|mask
operator|&
operator|(
literal|1
operator|<<
name|base_reg
operator|++
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"non-contiguous register range"
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
block|}
block|}
name|inst
operator|.
name|instruction
operator|=
name|tempinst
expr_stmt|;
return|return
name|range
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|vfp_sp_ldstm
parameter_list|(
name|str
parameter_list|,
name|ldstm_type
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
name|enum
name|vfp_ldstm_type
name|ldstm_type
decl_stmt|;
block|{
name|long
name|range
decl_stmt|;
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|16
argument_list|)
operator|==
name|FAIL
condition|)
return|return;
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|str
operator|==
literal|'!'
condition|)
block|{
name|inst
operator|.
name|instruction
operator||=
name|WRITE_BACK
expr_stmt|;
name|str
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ldstm_type
operator|!=
name|VFP_LDSTMIA
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"this addressing mode requires base-register writeback"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
operator|||
operator|(
name|range
operator|=
name|vfp_sp_reg_list
argument_list|(
operator|&
name|str
argument_list|,
name|VFP_REG_Sd
argument_list|)
operator|)
operator|==
name|FAIL
condition|)
block|{
if|if
condition|(
operator|!
name|inst
operator|.
name|error
condition|)
name|inst
operator|.
name|error
operator|=
name|BAD_ARGS
expr_stmt|;
return|return;
block|}
name|inst
operator|.
name|instruction
operator||=
name|range
expr_stmt|;
name|end_of_line
argument_list|(
name|str
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|vfp_dp_ldstm
parameter_list|(
name|str
parameter_list|,
name|ldstm_type
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
name|enum
name|vfp_ldstm_type
name|ldstm_type
decl_stmt|;
block|{
name|long
name|range
decl_stmt|;
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|16
argument_list|)
operator|==
name|FAIL
condition|)
return|return;
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|str
operator|==
literal|'!'
condition|)
block|{
name|inst
operator|.
name|instruction
operator||=
name|WRITE_BACK
expr_stmt|;
name|str
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ldstm_type
operator|!=
name|VFP_LDSTMIA
operator|&&
name|ldstm_type
operator|!=
name|VFP_LDSTMIAX
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"this addressing mode requires base-register writeback"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
operator|||
operator|(
name|range
operator|=
name|vfp_dp_reg_list
argument_list|(
operator|&
name|str
argument_list|)
operator|)
operator|==
name|FAIL
condition|)
block|{
if|if
condition|(
operator|!
name|inst
operator|.
name|error
condition|)
name|inst
operator|.
name|error
operator|=
name|BAD_ARGS
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|ldstm_type
operator|==
name|VFP_LDSTMIAX
operator|||
name|ldstm_type
operator|==
name|VFP_LDSTMDBX
condition|)
name|range
operator|+=
literal|1
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|range
expr_stmt|;
name|end_of_line
argument_list|(
name|str
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_vfp_sp_ldstmia
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|vfp_sp_ldstm
argument_list|(
name|str
argument_list|,
name|VFP_LDSTMIA
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_vfp_sp_ldstmdb
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|vfp_sp_ldstm
argument_list|(
name|str
argument_list|,
name|VFP_LDSTMDB
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_vfp_dp_ldstmia
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|vfp_dp_ldstm
argument_list|(
name|str
argument_list|,
name|VFP_LDSTMIA
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_vfp_dp_ldstmdb
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|vfp_dp_ldstm
argument_list|(
name|str
argument_list|,
name|VFP_LDSTMDB
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_vfp_xp_ldstmia
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|vfp_dp_ldstm
argument_list|(
name|str
argument_list|,
name|VFP_LDSTMIAX
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_vfp_xp_ldstmdb
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|vfp_dp_ldstm
argument_list|(
name|str
argument_list|,
name|VFP_LDSTMDBX
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_vfp_sp_compare_z
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|vfp_sp_reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
name|VFP_REG_Sd
argument_list|)
operator|==
name|FAIL
condition|)
block|{
if|if
condition|(
operator|!
name|inst
operator|.
name|error
condition|)
name|inst
operator|.
name|error
operator|=
name|BAD_ARGS
expr_stmt|;
return|return;
block|}
name|end_of_line
argument_list|(
name|str
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|do_vfp_dp_compare_z
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|vfp_dp_reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
name|VFP_REG_Dd
argument_list|)
operator|==
name|FAIL
condition|)
block|{
if|if
condition|(
operator|!
name|inst
operator|.
name|error
condition|)
name|inst
operator|.
name|error
operator|=
name|BAD_ARGS
expr_stmt|;
return|return;
block|}
name|end_of_line
argument_list|(
name|str
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|do_vfp_dp_sp_cvt
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|vfp_dp_reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
name|VFP_REG_Dd
argument_list|)
operator|==
name|FAIL
condition|)
return|return;
if|if
condition|(
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
operator|||
name|vfp_sp_reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
name|VFP_REG_Sm
argument_list|)
operator|==
name|FAIL
condition|)
block|{
if|if
condition|(
operator|!
name|inst
operator|.
name|error
condition|)
name|inst
operator|.
name|error
operator|=
name|BAD_ARGS
expr_stmt|;
return|return;
block|}
name|end_of_line
argument_list|(
name|str
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|do_vfp_sp_dp_cvt
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|vfp_sp_reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
name|VFP_REG_Sd
argument_list|)
operator|==
name|FAIL
condition|)
return|return;
if|if
condition|(
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
operator|||
name|vfp_dp_reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
name|VFP_REG_Dm
argument_list|)
operator|==
name|FAIL
condition|)
block|{
if|if
condition|(
operator|!
name|inst
operator|.
name|error
condition|)
name|inst
operator|.
name|error
operator|=
name|BAD_ARGS
expr_stmt|;
return|return;
block|}
name|end_of_line
argument_list|(
name|str
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* Thumb specific routines.  */
end_comment

begin_comment
comment|/* Parse and validate that a register is of the right form, this saves    repeated checking of this information in many similar cases.    Unlike the 32-bit case we do not insert the register into the opcode    here, since the position is often unknown until the full instruction    has been parsed.  */
end_comment

begin_function
specifier|static
name|int
name|thumb_reg
parameter_list|(
name|strp
parameter_list|,
name|hi_lo
parameter_list|)
name|char
modifier|*
modifier|*
name|strp
decl_stmt|;
name|int
name|hi_lo
decl_stmt|;
block|{
name|int
name|reg
decl_stmt|;
if|if
condition|(
operator|(
name|reg
operator|=
name|reg_required_here
argument_list|(
name|strp
argument_list|,
operator|-
literal|1
argument_list|)
operator|)
operator|==
name|FAIL
condition|)
return|return
name|FAIL
return|;
switch|switch
condition|(
name|hi_lo
condition|)
block|{
case|case
name|THUMB_REG_LO
case|:
if|if
condition|(
name|reg
operator|>
literal|7
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"lo register required"
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
block|}
break|break;
case|case
name|THUMB_REG_HI
case|:
if|if
condition|(
name|reg
operator|<
literal|8
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"hi register required"
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
block|}
break|break;
default|default:
break|break;
block|}
return|return
name|reg
return|;
block|}
end_function

begin_comment
comment|/* Parse an add or subtract instruction, SUBTRACT is non-zero if the opcode    was SUB.  */
end_comment

begin_function
specifier|static
name|void
name|thumb_add_sub
parameter_list|(
name|str
parameter_list|,
name|subtract
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
name|int
name|subtract
decl_stmt|;
block|{
name|int
name|Rd
decl_stmt|,
name|Rs
decl_stmt|,
name|Rn
init|=
name|FAIL
decl_stmt|;
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|Rd
operator|=
name|thumb_reg
argument_list|(
operator|&
name|str
argument_list|,
name|THUMB_REG_ANY
argument_list|)
operator|)
operator|==
name|FAIL
operator|||
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
condition|)
block|{
if|if
condition|(
operator|!
name|inst
operator|.
name|error
condition|)
name|inst
operator|.
name|error
operator|=
name|BAD_ARGS
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|is_immediate_prefix
argument_list|(
operator|*
name|str
argument_list|)
condition|)
block|{
name|Rs
operator|=
name|Rd
expr_stmt|;
name|str
operator|++
expr_stmt|;
if|if
condition|(
name|my_get_expression
argument_list|(
operator|&
name|inst
operator|.
name|reloc
operator|.
name|exp
argument_list|,
operator|&
name|str
argument_list|)
condition|)
return|return;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|Rs
operator|=
name|thumb_reg
argument_list|(
operator|&
name|str
argument_list|,
name|THUMB_REG_ANY
argument_list|)
operator|)
operator|==
name|FAIL
condition|)
return|return;
if|if
condition|(
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
condition|)
block|{
comment|/* Two operand format, shuffle the registers 	     and pretend there are 3.  */
name|Rn
operator|=
name|Rs
expr_stmt|;
name|Rs
operator|=
name|Rd
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|is_immediate_prefix
argument_list|(
operator|*
name|str
argument_list|)
condition|)
block|{
name|str
operator|++
expr_stmt|;
if|if
condition|(
name|my_get_expression
argument_list|(
operator|&
name|inst
operator|.
name|reloc
operator|.
name|exp
argument_list|,
operator|&
name|str
argument_list|)
condition|)
return|return;
block|}
elseif|else
if|if
condition|(
operator|(
name|Rn
operator|=
name|thumb_reg
argument_list|(
operator|&
name|str
argument_list|,
name|THUMB_REG_ANY
argument_list|)
operator|)
operator|==
name|FAIL
condition|)
return|return;
block|}
comment|/* We now have Rd and Rs set to registers, and Rn set to a register or FAIL;      for the latter case, EXPR contains the immediate that was found.  */
if|if
condition|(
name|Rn
operator|!=
name|FAIL
condition|)
block|{
comment|/* All register format.  */
if|if
condition|(
name|Rd
operator|>
literal|7
operator|||
name|Rs
operator|>
literal|7
operator|||
name|Rn
operator|>
literal|7
condition|)
block|{
if|if
condition|(
name|Rs
operator|!=
name|Rd
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"dest and source1 must be the same register"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Can't do this for SUB.  */
if|if
condition|(
name|subtract
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"subtract valid only on lo regs"
argument_list|)
expr_stmt|;
return|return;
block|}
name|inst
operator|.
name|instruction
operator|=
operator|(
name|T_OPCODE_ADD_HI
operator||
operator|(
name|Rd
operator|>
literal|7
condition|?
name|THUMB_H1
else|:
literal|0
operator|)
operator||
operator|(
name|Rn
operator|>
literal|7
condition|?
name|THUMB_H2
else|:
literal|0
operator|)
operator|)
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
operator|(
name|Rd
operator|&
literal|7
operator|)
operator||
operator|(
operator|(
name|Rn
operator|&
literal|7
operator|)
operator|<<
literal|3
operator|)
expr_stmt|;
block|}
else|else
block|{
name|inst
operator|.
name|instruction
operator|=
name|subtract
condition|?
name|T_OPCODE_SUB_R3
else|:
name|T_OPCODE_ADD_R3
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|Rd
operator||
operator|(
name|Rs
operator|<<
literal|3
operator|)
operator||
operator|(
name|Rn
operator|<<
literal|6
operator|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Immediate expression, now things start to get nasty.  */
comment|/* First deal with HI regs, only very restricted cases allowed: 	 Adjusting SP, and using PC or SP to get an address.  */
if|if
condition|(
operator|(
name|Rd
operator|>
literal|7
operator|&&
operator|(
name|Rd
operator|!=
name|REG_SP
operator|||
name|Rs
operator|!=
name|REG_SP
operator|)
operator|)
operator|||
operator|(
name|Rs
operator|>
literal|7
operator|&&
name|Rs
operator|!=
name|REG_SP
operator|&&
name|Rs
operator|!=
name|REG_PC
operator|)
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"invalid Hi register with immediate"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_op
operator|!=
name|O_constant
condition|)
block|{
comment|/* Value isn't known yet, all we can do is store all the fragments 	     we know about in the instruction and let the reloc hacking 	     work it all out.  */
name|inst
operator|.
name|instruction
operator|=
operator|(
name|subtract
condition|?
literal|0x8000
else|:
literal|0
operator|)
operator||
operator|(
name|Rd
operator|<<
literal|4
operator|)
operator||
name|Rs
expr_stmt|;
name|inst
operator|.
name|reloc
operator|.
name|type
operator|=
name|BFD_RELOC_ARM_THUMB_ADD
expr_stmt|;
block|}
else|else
block|{
name|int
name|offset
init|=
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_add_number
decl_stmt|;
if|if
condition|(
name|subtract
condition|)
name|offset
operator|=
operator|-
name|offset
expr_stmt|;
if|if
condition|(
name|offset
operator|<
literal|0
condition|)
block|{
name|offset
operator|=
operator|-
name|offset
expr_stmt|;
name|subtract
operator|=
literal|1
expr_stmt|;
comment|/* Quick check, in case offset is MIN_INT.  */
if|if
condition|(
name|offset
operator|<
literal|0
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"immediate value out of range"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
else|else
name|subtract
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|Rd
operator|==
name|REG_SP
condition|)
block|{
if|if
condition|(
name|offset
operator|&
operator|~
literal|0x1fc
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"invalid immediate value for stack adjust"
argument_list|)
expr_stmt|;
return|return;
block|}
name|inst
operator|.
name|instruction
operator|=
name|subtract
condition|?
name|T_OPCODE_SUB_ST
else|:
name|T_OPCODE_ADD_ST
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|offset
operator|>>
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Rs
operator|==
name|REG_PC
operator|||
name|Rs
operator|==
name|REG_SP
condition|)
block|{
if|if
condition|(
name|subtract
operator|||
operator|(
name|offset
operator|&
operator|~
literal|0x3fc
operator|)
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"invalid immediate for address calculation"
argument_list|)
expr_stmt|;
return|return;
block|}
name|inst
operator|.
name|instruction
operator|=
operator|(
name|Rs
operator|==
name|REG_PC
condition|?
name|T_OPCODE_ADD_PC
else|:
name|T_OPCODE_ADD_SP
operator|)
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
operator|(
name|Rd
operator|<<
literal|8
operator|)
operator||
operator|(
name|offset
operator|>>
literal|2
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Rs
operator|==
name|Rd
condition|)
block|{
if|if
condition|(
name|offset
operator|&
operator|~
literal|0xff
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"immediate value out of range"
argument_list|)
expr_stmt|;
return|return;
block|}
name|inst
operator|.
name|instruction
operator|=
name|subtract
condition|?
name|T_OPCODE_SUB_I8
else|:
name|T_OPCODE_ADD_I8
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
operator|(
name|Rd
operator|<<
literal|8
operator|)
operator||
name|offset
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|offset
operator|&
operator|~
literal|0x7
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"immediate value out of range"
argument_list|)
expr_stmt|;
return|return;
block|}
name|inst
operator|.
name|instruction
operator|=
name|subtract
condition|?
name|T_OPCODE_SUB_I3
else|:
name|T_OPCODE_ADD_I3
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|Rd
operator||
operator|(
name|Rs
operator|<<
literal|3
operator|)
operator||
operator|(
name|offset
operator|<<
literal|6
operator|)
expr_stmt|;
block|}
block|}
block|}
name|end_of_line
argument_list|(
name|str
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|thumb_shift
parameter_list|(
name|str
parameter_list|,
name|shift
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
name|int
name|shift
decl_stmt|;
block|{
name|int
name|Rd
decl_stmt|,
name|Rs
decl_stmt|,
name|Rn
init|=
name|FAIL
decl_stmt|;
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|Rd
operator|=
name|thumb_reg
argument_list|(
operator|&
name|str
argument_list|,
name|THUMB_REG_LO
argument_list|)
operator|)
operator|==
name|FAIL
operator|||
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
condition|)
block|{
if|if
condition|(
operator|!
name|inst
operator|.
name|error
condition|)
name|inst
operator|.
name|error
operator|=
name|BAD_ARGS
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|is_immediate_prefix
argument_list|(
operator|*
name|str
argument_list|)
condition|)
block|{
comment|/* Two operand immediate format, set Rs to Rd.  */
name|Rs
operator|=
name|Rd
expr_stmt|;
name|str
operator|++
expr_stmt|;
if|if
condition|(
name|my_get_expression
argument_list|(
operator|&
name|inst
operator|.
name|reloc
operator|.
name|exp
argument_list|,
operator|&
name|str
argument_list|)
condition|)
return|return;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|Rs
operator|=
name|thumb_reg
argument_list|(
operator|&
name|str
argument_list|,
name|THUMB_REG_LO
argument_list|)
operator|)
operator|==
name|FAIL
condition|)
return|return;
if|if
condition|(
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
condition|)
block|{
comment|/* Two operand format, shuffle the registers 	     and pretend there are 3.  */
name|Rn
operator|=
name|Rs
expr_stmt|;
name|Rs
operator|=
name|Rd
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|is_immediate_prefix
argument_list|(
operator|*
name|str
argument_list|)
condition|)
block|{
name|str
operator|++
expr_stmt|;
if|if
condition|(
name|my_get_expression
argument_list|(
operator|&
name|inst
operator|.
name|reloc
operator|.
name|exp
argument_list|,
operator|&
name|str
argument_list|)
condition|)
return|return;
block|}
elseif|else
if|if
condition|(
operator|(
name|Rn
operator|=
name|thumb_reg
argument_list|(
operator|&
name|str
argument_list|,
name|THUMB_REG_LO
argument_list|)
operator|)
operator|==
name|FAIL
condition|)
return|return;
block|}
comment|/* We now have Rd and Rs set to registers, and Rn set to a register or FAIL;      for the latter case, EXPR contains the immediate that was found.  */
if|if
condition|(
name|Rn
operator|!=
name|FAIL
condition|)
block|{
if|if
condition|(
name|Rs
operator|!=
name|Rd
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"source1 and dest must be same register"
argument_list|)
expr_stmt|;
return|return;
block|}
switch|switch
condition|(
name|shift
condition|)
block|{
case|case
name|THUMB_ASR
case|:
name|inst
operator|.
name|instruction
operator|=
name|T_OPCODE_ASR_R
expr_stmt|;
break|break;
case|case
name|THUMB_LSL
case|:
name|inst
operator|.
name|instruction
operator|=
name|T_OPCODE_LSL_R
expr_stmt|;
break|break;
case|case
name|THUMB_LSR
case|:
name|inst
operator|.
name|instruction
operator|=
name|T_OPCODE_LSR_R
expr_stmt|;
break|break;
block|}
name|inst
operator|.
name|instruction
operator||=
name|Rd
operator||
operator|(
name|Rn
operator|<<
literal|3
operator|)
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
name|shift
condition|)
block|{
case|case
name|THUMB_ASR
case|:
name|inst
operator|.
name|instruction
operator|=
name|T_OPCODE_ASR_I
expr_stmt|;
break|break;
case|case
name|THUMB_LSL
case|:
name|inst
operator|.
name|instruction
operator|=
name|T_OPCODE_LSL_I
expr_stmt|;
break|break;
case|case
name|THUMB_LSR
case|:
name|inst
operator|.
name|instruction
operator|=
name|T_OPCODE_LSR_I
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_op
operator|!=
name|O_constant
condition|)
block|{
comment|/* Value isn't known yet, create a dummy reloc and let reloc 	     hacking fix it up.  */
name|inst
operator|.
name|reloc
operator|.
name|type
operator|=
name|BFD_RELOC_ARM_THUMB_SHIFT
expr_stmt|;
block|}
else|else
block|{
name|unsigned
name|shift_value
init|=
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_add_number
decl_stmt|;
if|if
condition|(
name|shift_value
operator|>
literal|32
operator|||
operator|(
name|shift_value
operator|==
literal|32
operator|&&
name|shift
operator|==
name|THUMB_LSL
operator|)
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"invalid immediate for shift"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Shifts of zero are handled by converting to LSL.  */
if|if
condition|(
name|shift_value
operator|==
literal|0
condition|)
name|inst
operator|.
name|instruction
operator|=
name|T_OPCODE_LSL_I
expr_stmt|;
comment|/* Shifts of 32 are encoded as a shift of zero.  */
if|if
condition|(
name|shift_value
operator|==
literal|32
condition|)
name|shift_value
operator|=
literal|0
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|shift_value
operator|<<
literal|6
expr_stmt|;
block|}
name|inst
operator|.
name|instruction
operator||=
name|Rd
operator||
operator|(
name|Rs
operator|<<
literal|3
operator|)
expr_stmt|;
block|}
name|end_of_line
argument_list|(
name|str
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|thumb_mov_compare
parameter_list|(
name|str
parameter_list|,
name|move
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
name|int
name|move
decl_stmt|;
block|{
name|int
name|Rd
decl_stmt|,
name|Rs
init|=
name|FAIL
decl_stmt|;
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|Rd
operator|=
name|thumb_reg
argument_list|(
operator|&
name|str
argument_list|,
name|THUMB_REG_ANY
argument_list|)
operator|)
operator|==
name|FAIL
operator|||
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
condition|)
block|{
if|if
condition|(
operator|!
name|inst
operator|.
name|error
condition|)
name|inst
operator|.
name|error
operator|=
name|BAD_ARGS
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|is_immediate_prefix
argument_list|(
operator|*
name|str
argument_list|)
condition|)
block|{
name|str
operator|++
expr_stmt|;
if|if
condition|(
name|my_get_expression
argument_list|(
operator|&
name|inst
operator|.
name|reloc
operator|.
name|exp
argument_list|,
operator|&
name|str
argument_list|)
condition|)
return|return;
block|}
elseif|else
if|if
condition|(
operator|(
name|Rs
operator|=
name|thumb_reg
argument_list|(
operator|&
name|str
argument_list|,
name|THUMB_REG_ANY
argument_list|)
operator|)
operator|==
name|FAIL
condition|)
return|return;
if|if
condition|(
name|Rs
operator|!=
name|FAIL
condition|)
block|{
if|if
condition|(
name|Rs
operator|<
literal|8
operator|&&
name|Rd
operator|<
literal|8
condition|)
block|{
if|if
condition|(
name|move
operator|==
name|THUMB_MOVE
condition|)
comment|/* A move of two lowregs is encoded as ADD Rd, Rs, #0 	       since a MOV instruction produces unpredictable results.  */
name|inst
operator|.
name|instruction
operator|=
name|T_OPCODE_ADD_I3
expr_stmt|;
else|else
name|inst
operator|.
name|instruction
operator|=
name|T_OPCODE_CMP_LR
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|Rd
operator||
operator|(
name|Rs
operator|<<
literal|3
operator|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|move
operator|==
name|THUMB_MOVE
condition|)
name|inst
operator|.
name|instruction
operator|=
name|T_OPCODE_MOV_HR
expr_stmt|;
else|else
name|inst
operator|.
name|instruction
operator|=
name|T_OPCODE_CMP_HR
expr_stmt|;
if|if
condition|(
name|Rd
operator|>
literal|7
condition|)
name|inst
operator|.
name|instruction
operator||=
name|THUMB_H1
expr_stmt|;
if|if
condition|(
name|Rs
operator|>
literal|7
condition|)
name|inst
operator|.
name|instruction
operator||=
name|THUMB_H2
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
operator|(
name|Rd
operator|&
literal|7
operator|)
operator||
operator|(
operator|(
name|Rs
operator|&
literal|7
operator|)
operator|<<
literal|3
operator|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|Rd
operator|>
literal|7
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"only lo regs allowed with immediate"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|move
operator|==
name|THUMB_MOVE
condition|)
name|inst
operator|.
name|instruction
operator|=
name|T_OPCODE_MOV_I8
expr_stmt|;
else|else
name|inst
operator|.
name|instruction
operator|=
name|T_OPCODE_CMP_I8
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|Rd
operator|<<
literal|8
expr_stmt|;
if|if
condition|(
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_op
operator|!=
name|O_constant
condition|)
name|inst
operator|.
name|reloc
operator|.
name|type
operator|=
name|BFD_RELOC_ARM_THUMB_IMM
expr_stmt|;
else|else
block|{
name|unsigned
name|value
init|=
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_add_number
decl_stmt|;
if|if
condition|(
name|value
operator|>
literal|255
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"invalid immediate"
argument_list|)
expr_stmt|;
return|return;
block|}
name|inst
operator|.
name|instruction
operator||=
name|value
expr_stmt|;
block|}
block|}
name|end_of_line
argument_list|(
name|str
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|thumb_load_store
parameter_list|(
name|str
parameter_list|,
name|load_store
parameter_list|,
name|size
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
name|int
name|load_store
decl_stmt|;
name|int
name|size
decl_stmt|;
block|{
name|int
name|Rd
decl_stmt|,
name|Rb
decl_stmt|,
name|Ro
init|=
name|FAIL
decl_stmt|;
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|Rd
operator|=
name|thumb_reg
argument_list|(
operator|&
name|str
argument_list|,
name|THUMB_REG_LO
argument_list|)
operator|)
operator|==
name|FAIL
operator|||
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
condition|)
block|{
if|if
condition|(
operator|!
name|inst
operator|.
name|error
condition|)
name|inst
operator|.
name|error
operator|=
name|BAD_ARGS
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|*
name|str
operator|==
literal|'['
condition|)
block|{
name|str
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|Rb
operator|=
name|thumb_reg
argument_list|(
operator|&
name|str
argument_list|,
name|THUMB_REG_ANY
argument_list|)
operator|)
operator|==
name|FAIL
condition|)
return|return;
if|if
condition|(
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|!=
name|FAIL
condition|)
block|{
if|if
condition|(
name|is_immediate_prefix
argument_list|(
operator|*
name|str
argument_list|)
condition|)
block|{
name|str
operator|++
expr_stmt|;
if|if
condition|(
name|my_get_expression
argument_list|(
operator|&
name|inst
operator|.
name|reloc
operator|.
name|exp
argument_list|,
operator|&
name|str
argument_list|)
condition|)
return|return;
block|}
elseif|else
if|if
condition|(
operator|(
name|Ro
operator|=
name|thumb_reg
argument_list|(
operator|&
name|str
argument_list|,
name|THUMB_REG_LO
argument_list|)
operator|)
operator|==
name|FAIL
condition|)
return|return;
block|}
else|else
block|{
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_op
operator|=
name|O_constant
expr_stmt|;
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_add_number
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|str
operator|!=
literal|']'
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"expected ']'"
argument_list|)
expr_stmt|;
return|return;
block|}
name|str
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|str
operator|==
literal|'='
condition|)
block|{
if|if
condition|(
name|load_store
operator|!=
name|THUMB_LOAD
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"invalid pseudo operation"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Parse an "ldr Rd, =expr" instruction; this is another pseudo op.  */
name|str
operator|++
expr_stmt|;
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|my_get_expression
argument_list|(
operator|&
name|inst
operator|.
name|reloc
operator|.
name|exp
argument_list|,
operator|&
name|str
argument_list|)
condition|)
return|return;
name|end_of_line
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_op
operator|!=
name|O_constant
operator|&&
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_op
operator|!=
name|O_symbol
condition|)
block|{
name|inst
operator|.
name|error
operator|=
literal|"Constant expression expected"
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_op
operator|==
name|O_constant
operator|&&
operator|(
operator|(
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_add_number
operator|&
operator|~
literal|0xFF
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* This can be done with a mov instruction.  */
name|inst
operator|.
name|instruction
operator|=
name|T_OPCODE_MOV_I8
operator||
operator|(
name|Rd
operator|<<
literal|8
operator|)
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_add_number
expr_stmt|;
return|return;
block|}
comment|/* Insert into literal pool.  */
if|if
condition|(
name|add_to_lit_pool
argument_list|()
operator|==
name|FAIL
condition|)
block|{
if|if
condition|(
operator|!
name|inst
operator|.
name|error
condition|)
name|inst
operator|.
name|error
operator|=
literal|"literal pool insertion failed"
expr_stmt|;
return|return;
block|}
name|inst
operator|.
name|reloc
operator|.
name|type
operator|=
name|BFD_RELOC_ARM_THUMB_OFFSET
expr_stmt|;
name|inst
operator|.
name|reloc
operator|.
name|pc_rel
operator|=
literal|1
expr_stmt|;
name|inst
operator|.
name|instruction
operator|=
name|T_OPCODE_LDR_PC
operator||
operator|(
name|Rd
operator|<<
literal|8
operator|)
expr_stmt|;
comment|/* Adjust ARM pipeline offset to Thumb.  */
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_add_number
operator|+=
literal|4
expr_stmt|;
return|return;
block|}
else|else
block|{
if|if
condition|(
name|my_get_expression
argument_list|(
operator|&
name|inst
operator|.
name|reloc
operator|.
name|exp
argument_list|,
operator|&
name|str
argument_list|)
condition|)
return|return;
name|inst
operator|.
name|instruction
operator|=
name|T_OPCODE_LDR_PC
operator||
operator|(
name|Rd
operator|<<
literal|8
operator|)
expr_stmt|;
name|inst
operator|.
name|reloc
operator|.
name|pc_rel
operator|=
literal|1
expr_stmt|;
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_add_number
operator|-=
literal|4
expr_stmt|;
comment|/* Pipeline offset.  */
name|inst
operator|.
name|reloc
operator|.
name|type
operator|=
name|BFD_RELOC_ARM_THUMB_OFFSET
expr_stmt|;
name|end_of_line
argument_list|(
name|str
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|Rb
operator|==
name|REG_PC
operator|||
name|Rb
operator|==
name|REG_SP
condition|)
block|{
if|if
condition|(
name|size
operator|!=
name|THUMB_WORD
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"byte or halfword not valid for base register"
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|Rb
operator|==
name|REG_PC
operator|&&
name|load_store
operator|!=
name|THUMB_LOAD
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"r15 based store not allowed"
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|Ro
operator|!=
name|FAIL
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"invalid base register for register offset"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|Rb
operator|==
name|REG_PC
condition|)
name|inst
operator|.
name|instruction
operator|=
name|T_OPCODE_LDR_PC
expr_stmt|;
elseif|else
if|if
condition|(
name|load_store
operator|==
name|THUMB_LOAD
condition|)
name|inst
operator|.
name|instruction
operator|=
name|T_OPCODE_LDR_SP
expr_stmt|;
else|else
name|inst
operator|.
name|instruction
operator|=
name|T_OPCODE_STR_SP
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|Rd
operator|<<
literal|8
expr_stmt|;
if|if
condition|(
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_op
operator|==
name|O_constant
condition|)
block|{
name|unsigned
name|offset
init|=
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_add_number
decl_stmt|;
if|if
condition|(
name|offset
operator|&
operator|~
literal|0x3fc
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"invalid offset"
argument_list|)
expr_stmt|;
return|return;
block|}
name|inst
operator|.
name|instruction
operator||=
name|offset
operator|>>
literal|2
expr_stmt|;
block|}
else|else
name|inst
operator|.
name|reloc
operator|.
name|type
operator|=
name|BFD_RELOC_ARM_THUMB_OFFSET
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Rb
operator|>
literal|7
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"invalid base register in load/store"
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|Ro
operator|==
name|FAIL
condition|)
block|{
comment|/* Immediate offset.  */
if|if
condition|(
name|size
operator|==
name|THUMB_WORD
condition|)
name|inst
operator|.
name|instruction
operator|=
operator|(
name|load_store
operator|==
name|THUMB_LOAD
condition|?
name|T_OPCODE_LDR_IW
else|:
name|T_OPCODE_STR_IW
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|size
operator|==
name|THUMB_HALFWORD
condition|)
name|inst
operator|.
name|instruction
operator|=
operator|(
name|load_store
operator|==
name|THUMB_LOAD
condition|?
name|T_OPCODE_LDR_IH
else|:
name|T_OPCODE_STR_IH
operator|)
expr_stmt|;
else|else
name|inst
operator|.
name|instruction
operator|=
operator|(
name|load_store
operator|==
name|THUMB_LOAD
condition|?
name|T_OPCODE_LDR_IB
else|:
name|T_OPCODE_STR_IB
operator|)
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|Rd
operator||
operator|(
name|Rb
operator|<<
literal|3
operator|)
expr_stmt|;
if|if
condition|(
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_op
operator|==
name|O_constant
condition|)
block|{
name|unsigned
name|offset
init|=
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_add_number
decl_stmt|;
if|if
condition|(
name|offset
operator|&
operator|~
operator|(
literal|0x1f
operator|<<
name|size
operator|)
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"invalid offset"
argument_list|)
expr_stmt|;
return|return;
block|}
name|inst
operator|.
name|instruction
operator||=
operator|(
name|offset
operator|>>
name|size
operator|)
operator|<<
literal|6
expr_stmt|;
block|}
else|else
name|inst
operator|.
name|reloc
operator|.
name|type
operator|=
name|BFD_RELOC_ARM_THUMB_OFFSET
expr_stmt|;
block|}
else|else
block|{
comment|/* Register offset.  */
if|if
condition|(
name|size
operator|==
name|THUMB_WORD
condition|)
name|inst
operator|.
name|instruction
operator|=
operator|(
name|load_store
operator|==
name|THUMB_LOAD
condition|?
name|T_OPCODE_LDR_RW
else|:
name|T_OPCODE_STR_RW
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|size
operator|==
name|THUMB_HALFWORD
condition|)
name|inst
operator|.
name|instruction
operator|=
operator|(
name|load_store
operator|==
name|THUMB_LOAD
condition|?
name|T_OPCODE_LDR_RH
else|:
name|T_OPCODE_STR_RH
operator|)
expr_stmt|;
else|else
name|inst
operator|.
name|instruction
operator|=
operator|(
name|load_store
operator|==
name|THUMB_LOAD
condition|?
name|T_OPCODE_LDR_RB
else|:
name|T_OPCODE_STR_RB
operator|)
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|Rd
operator||
operator|(
name|Rb
operator|<<
literal|3
operator|)
operator||
operator|(
name|Ro
operator|<<
literal|6
operator|)
expr_stmt|;
block|}
name|end_of_line
argument_list|(
name|str
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* A register must be given at this point.     Shift is the place to put it in inst.instruction.     Restores input start point on err.    Returns the reg#, or FAIL.  */
end_comment

begin_function
specifier|static
name|int
name|mav_reg_required_here
parameter_list|(
name|str
parameter_list|,
name|shift
parameter_list|,
name|regtype
parameter_list|)
name|char
modifier|*
modifier|*
name|str
decl_stmt|;
name|int
name|shift
decl_stmt|;
name|enum
name|arm_reg_type
name|regtype
decl_stmt|;
block|{
name|int
name|reg
decl_stmt|;
name|char
modifier|*
name|start
init|=
operator|*
name|str
decl_stmt|;
if|if
condition|(
operator|(
name|reg
operator|=
name|arm_reg_parse
argument_list|(
name|str
argument_list|,
name|all_reg_maps
index|[
name|regtype
index|]
operator|.
name|htab
argument_list|)
operator|)
operator|!=
name|FAIL
condition|)
block|{
if|if
condition|(
name|shift
operator|>=
literal|0
condition|)
name|inst
operator|.
name|instruction
operator||=
name|reg
operator|<<
name|shift
expr_stmt|;
return|return
name|reg
return|;
block|}
comment|/* Restore the start point.  */
operator|*
name|str
operator|=
name|start
expr_stmt|;
comment|/* In the few cases where we might be able to accept something else      this error can be overridden.  */
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
name|all_reg_maps
index|[
name|regtype
index|]
operator|.
name|expected
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
block|}
end_function

begin_comment
comment|/* Cirrus Maverick Instructions.  */
end_comment

begin_comment
comment|/* Wrapper functions.  */
end_comment

begin_function
specifier|static
name|void
name|do_mav_binops_1a
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|do_mav_binops
argument_list|(
name|str
argument_list|,
name|MAV_MODE1
argument_list|,
name|REG_TYPE_RN
argument_list|,
name|REG_TYPE_MVF
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_mav_binops_1b
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|do_mav_binops
argument_list|(
name|str
argument_list|,
name|MAV_MODE1
argument_list|,
name|REG_TYPE_RN
argument_list|,
name|REG_TYPE_MVD
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_mav_binops_1c
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|do_mav_binops
argument_list|(
name|str
argument_list|,
name|MAV_MODE1
argument_list|,
name|REG_TYPE_RN
argument_list|,
name|REG_TYPE_MVDX
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_mav_binops_1d
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|do_mav_binops
argument_list|(
name|str
argument_list|,
name|MAV_MODE1
argument_list|,
name|REG_TYPE_MVF
argument_list|,
name|REG_TYPE_MVF
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_mav_binops_1e
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|do_mav_binops
argument_list|(
name|str
argument_list|,
name|MAV_MODE1
argument_list|,
name|REG_TYPE_MVD
argument_list|,
name|REG_TYPE_MVD
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_mav_binops_1f
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|do_mav_binops
argument_list|(
name|str
argument_list|,
name|MAV_MODE1
argument_list|,
name|REG_TYPE_MVD
argument_list|,
name|REG_TYPE_MVF
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_mav_binops_1g
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|do_mav_binops
argument_list|(
name|str
argument_list|,
name|MAV_MODE1
argument_list|,
name|REG_TYPE_MVF
argument_list|,
name|REG_TYPE_MVD
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_mav_binops_1h
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|do_mav_binops
argument_list|(
name|str
argument_list|,
name|MAV_MODE1
argument_list|,
name|REG_TYPE_MVF
argument_list|,
name|REG_TYPE_MVFX
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_mav_binops_1i
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|do_mav_binops
argument_list|(
name|str
argument_list|,
name|MAV_MODE1
argument_list|,
name|REG_TYPE_MVD
argument_list|,
name|REG_TYPE_MVFX
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_mav_binops_1j
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|do_mav_binops
argument_list|(
name|str
argument_list|,
name|MAV_MODE1
argument_list|,
name|REG_TYPE_MVF
argument_list|,
name|REG_TYPE_MVDX
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_mav_binops_1k
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|do_mav_binops
argument_list|(
name|str
argument_list|,
name|MAV_MODE1
argument_list|,
name|REG_TYPE_MVD
argument_list|,
name|REG_TYPE_MVDX
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_mav_binops_1l
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|do_mav_binops
argument_list|(
name|str
argument_list|,
name|MAV_MODE1
argument_list|,
name|REG_TYPE_MVFX
argument_list|,
name|REG_TYPE_MVF
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_mav_binops_1m
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|do_mav_binops
argument_list|(
name|str
argument_list|,
name|MAV_MODE1
argument_list|,
name|REG_TYPE_MVFX
argument_list|,
name|REG_TYPE_MVD
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_mav_binops_1n
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|do_mav_binops
argument_list|(
name|str
argument_list|,
name|MAV_MODE1
argument_list|,
name|REG_TYPE_MVFX
argument_list|,
name|REG_TYPE_MVFX
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_mav_binops_1o
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|do_mav_binops
argument_list|(
name|str
argument_list|,
name|MAV_MODE1
argument_list|,
name|REG_TYPE_MVDX
argument_list|,
name|REG_TYPE_MVDX
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_mav_binops_2a
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|do_mav_binops
argument_list|(
name|str
argument_list|,
name|MAV_MODE2
argument_list|,
name|REG_TYPE_MVF
argument_list|,
name|REG_TYPE_RN
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_mav_binops_2b
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|do_mav_binops
argument_list|(
name|str
argument_list|,
name|MAV_MODE2
argument_list|,
name|REG_TYPE_MVD
argument_list|,
name|REG_TYPE_RN
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_mav_binops_2c
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|do_mav_binops
argument_list|(
name|str
argument_list|,
name|MAV_MODE2
argument_list|,
name|REG_TYPE_MVDX
argument_list|,
name|REG_TYPE_RN
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_mav_binops_3a
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|do_mav_binops
argument_list|(
name|str
argument_list|,
name|MAV_MODE3
argument_list|,
name|REG_TYPE_MVAX
argument_list|,
name|REG_TYPE_MVFX
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_mav_binops_3b
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|do_mav_binops
argument_list|(
name|str
argument_list|,
name|MAV_MODE3
argument_list|,
name|REG_TYPE_MVFX
argument_list|,
name|REG_TYPE_MVAX
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_mav_binops_3c
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|do_mav_binops
argument_list|(
name|str
argument_list|,
name|MAV_MODE3
argument_list|,
name|REG_TYPE_MVAX
argument_list|,
name|REG_TYPE_MVDX
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_mav_binops_3d
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|do_mav_binops
argument_list|(
name|str
argument_list|,
name|MAV_MODE3
argument_list|,
name|REG_TYPE_MVDX
argument_list|,
name|REG_TYPE_MVAX
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_mav_triple_4a
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|do_mav_triple
argument_list|(
name|str
argument_list|,
name|MAV_MODE4
argument_list|,
name|REG_TYPE_MVFX
argument_list|,
name|REG_TYPE_MVFX
argument_list|,
name|REG_TYPE_RN
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_mav_triple_4b
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|do_mav_triple
argument_list|(
name|str
argument_list|,
name|MAV_MODE4
argument_list|,
name|REG_TYPE_MVDX
argument_list|,
name|REG_TYPE_MVDX
argument_list|,
name|REG_TYPE_RN
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_mav_triple_5a
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|do_mav_triple
argument_list|(
name|str
argument_list|,
name|MAV_MODE5
argument_list|,
name|REG_TYPE_RN
argument_list|,
name|REG_TYPE_MVF
argument_list|,
name|REG_TYPE_MVF
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_mav_triple_5b
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|do_mav_triple
argument_list|(
name|str
argument_list|,
name|MAV_MODE5
argument_list|,
name|REG_TYPE_RN
argument_list|,
name|REG_TYPE_MVD
argument_list|,
name|REG_TYPE_MVD
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_mav_triple_5c
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|do_mav_triple
argument_list|(
name|str
argument_list|,
name|MAV_MODE5
argument_list|,
name|REG_TYPE_RN
argument_list|,
name|REG_TYPE_MVFX
argument_list|,
name|REG_TYPE_MVFX
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_mav_triple_5d
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|do_mav_triple
argument_list|(
name|str
argument_list|,
name|MAV_MODE5
argument_list|,
name|REG_TYPE_RN
argument_list|,
name|REG_TYPE_MVDX
argument_list|,
name|REG_TYPE_MVDX
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_mav_triple_5e
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|do_mav_triple
argument_list|(
name|str
argument_list|,
name|MAV_MODE5
argument_list|,
name|REG_TYPE_MVF
argument_list|,
name|REG_TYPE_MVF
argument_list|,
name|REG_TYPE_MVF
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_mav_triple_5f
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|do_mav_triple
argument_list|(
name|str
argument_list|,
name|MAV_MODE5
argument_list|,
name|REG_TYPE_MVD
argument_list|,
name|REG_TYPE_MVD
argument_list|,
name|REG_TYPE_MVD
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_mav_triple_5g
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|do_mav_triple
argument_list|(
name|str
argument_list|,
name|MAV_MODE5
argument_list|,
name|REG_TYPE_MVFX
argument_list|,
name|REG_TYPE_MVFX
argument_list|,
name|REG_TYPE_MVFX
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_mav_triple_5h
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|do_mav_triple
argument_list|(
name|str
argument_list|,
name|MAV_MODE5
argument_list|,
name|REG_TYPE_MVDX
argument_list|,
name|REG_TYPE_MVDX
argument_list|,
name|REG_TYPE_MVDX
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_mav_quad_6a
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|do_mav_quad
argument_list|(
name|str
argument_list|,
name|MAV_MODE6
argument_list|,
name|REG_TYPE_MVAX
argument_list|,
name|REG_TYPE_MVFX
argument_list|,
name|REG_TYPE_MVFX
argument_list|,
name|REG_TYPE_MVFX
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_mav_quad_6b
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|do_mav_quad
argument_list|(
name|str
argument_list|,
name|MAV_MODE6
argument_list|,
name|REG_TYPE_MVAX
argument_list|,
name|REG_TYPE_MVAX
argument_list|,
name|REG_TYPE_MVFX
argument_list|,
name|REG_TYPE_MVFX
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* cfmvsc32<cond> DSPSC,MVFX[15:0]. */
end_comment

begin_function
specifier|static
name|void
name|do_mav_dspsc_1
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
comment|/* cfmvsc32.  */
if|if
condition|(
name|mav_reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
operator|-
literal|1
argument_list|,
name|REG_TYPE_DSPSC
argument_list|)
operator|==
name|FAIL
operator|||
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
operator|||
name|mav_reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|16
argument_list|,
name|REG_TYPE_MVFX
argument_list|)
operator|==
name|FAIL
condition|)
block|{
if|if
condition|(
operator|!
name|inst
operator|.
name|error
condition|)
name|inst
operator|.
name|error
operator|=
name|BAD_ARGS
expr_stmt|;
return|return;
block|}
name|end_of_line
argument_list|(
name|str
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* cfmv32sc<cond> MVFX[15:0],DSPSC.  */
end_comment

begin_function
specifier|static
name|void
name|do_mav_dspsc_2
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
comment|/* cfmv32sc.  */
if|if
condition|(
name|mav_reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|0
argument_list|,
name|REG_TYPE_MVFX
argument_list|)
operator|==
name|FAIL
operator|||
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
operator|||
name|mav_reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
operator|-
literal|1
argument_list|,
name|REG_TYPE_DSPSC
argument_list|)
operator|==
name|FAIL
condition|)
block|{
if|if
condition|(
operator|!
name|inst
operator|.
name|error
condition|)
name|inst
operator|.
name|error
operator|=
name|BAD_ARGS
expr_stmt|;
return|return;
block|}
name|end_of_line
argument_list|(
name|str
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_mav_shift_1
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|do_mav_shift
argument_list|(
name|str
argument_list|,
name|REG_TYPE_MVFX
argument_list|,
name|REG_TYPE_MVFX
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_mav_shift_2
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|do_mav_shift
argument_list|(
name|str
argument_list|,
name|REG_TYPE_MVDX
argument_list|,
name|REG_TYPE_MVDX
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_mav_ldst_1
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|do_mav_ldst
argument_list|(
name|str
argument_list|,
name|REG_TYPE_MVF
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_mav_ldst_2
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|do_mav_ldst
argument_list|(
name|str
argument_list|,
name|REG_TYPE_MVD
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_mav_ldst_3
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|do_mav_ldst
argument_list|(
name|str
argument_list|,
name|REG_TYPE_MVFX
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_mav_ldst_4
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|do_mav_ldst
argument_list|(
name|str
argument_list|,
name|REG_TYPE_MVDX
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Isnsn like "foo X,Y".  */
end_comment

begin_function
specifier|static
name|void
name|do_mav_binops
parameter_list|(
name|str
parameter_list|,
name|mode
parameter_list|,
name|reg0
parameter_list|,
name|reg1
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
name|int
name|mode
decl_stmt|;
name|enum
name|arm_reg_type
name|reg0
decl_stmt|;
name|enum
name|arm_reg_type
name|reg1
decl_stmt|;
block|{
name|int
name|shift0
decl_stmt|,
name|shift1
decl_stmt|;
name|shift0
operator|=
name|mode
operator|&
literal|0xff
expr_stmt|;
name|shift1
operator|=
operator|(
name|mode
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|mav_reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
name|shift0
argument_list|,
name|reg0
argument_list|)
operator|==
name|FAIL
operator|||
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
operator|||
name|mav_reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
name|shift1
argument_list|,
name|reg1
argument_list|)
operator|==
name|FAIL
condition|)
block|{
if|if
condition|(
operator|!
name|inst
operator|.
name|error
condition|)
name|inst
operator|.
name|error
operator|=
name|BAD_ARGS
expr_stmt|;
block|}
else|else
name|end_of_line
argument_list|(
name|str
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Isnsn like "foo X,Y,Z".  */
end_comment

begin_function
specifier|static
name|void
name|do_mav_triple
parameter_list|(
name|str
parameter_list|,
name|mode
parameter_list|,
name|reg0
parameter_list|,
name|reg1
parameter_list|,
name|reg2
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
name|int
name|mode
decl_stmt|;
name|enum
name|arm_reg_type
name|reg0
decl_stmt|;
name|enum
name|arm_reg_type
name|reg1
decl_stmt|;
name|enum
name|arm_reg_type
name|reg2
decl_stmt|;
block|{
name|int
name|shift0
decl_stmt|,
name|shift1
decl_stmt|,
name|shift2
decl_stmt|;
name|shift0
operator|=
name|mode
operator|&
literal|0xff
expr_stmt|;
name|shift1
operator|=
operator|(
name|mode
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
name|shift2
operator|=
operator|(
name|mode
operator|>>
literal|16
operator|)
operator|&
literal|0xff
expr_stmt|;
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|mav_reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
name|shift0
argument_list|,
name|reg0
argument_list|)
operator|==
name|FAIL
operator|||
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
operator|||
name|mav_reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
name|shift1
argument_list|,
name|reg1
argument_list|)
operator|==
name|FAIL
operator|||
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
operator|||
name|mav_reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
name|shift2
argument_list|,
name|reg2
argument_list|)
operator|==
name|FAIL
condition|)
block|{
if|if
condition|(
operator|!
name|inst
operator|.
name|error
condition|)
name|inst
operator|.
name|error
operator|=
name|BAD_ARGS
expr_stmt|;
block|}
else|else
name|end_of_line
argument_list|(
name|str
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Isnsn like "foo W,X,Y,Z".     where W=MVAX[0:3] and X,Y,Z=MVFX[0:15].  */
end_comment

begin_function
specifier|static
name|void
name|do_mav_quad
parameter_list|(
name|str
parameter_list|,
name|mode
parameter_list|,
name|reg0
parameter_list|,
name|reg1
parameter_list|,
name|reg2
parameter_list|,
name|reg3
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
name|int
name|mode
decl_stmt|;
name|enum
name|arm_reg_type
name|reg0
decl_stmt|;
name|enum
name|arm_reg_type
name|reg1
decl_stmt|;
name|enum
name|arm_reg_type
name|reg2
decl_stmt|;
name|enum
name|arm_reg_type
name|reg3
decl_stmt|;
block|{
name|int
name|shift0
decl_stmt|,
name|shift1
decl_stmt|,
name|shift2
decl_stmt|,
name|shift3
decl_stmt|;
name|shift0
operator|=
name|mode
operator|&
literal|0xff
expr_stmt|;
name|shift1
operator|=
operator|(
name|mode
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
name|shift2
operator|=
operator|(
name|mode
operator|>>
literal|16
operator|)
operator|&
literal|0xff
expr_stmt|;
name|shift3
operator|=
operator|(
name|mode
operator|>>
literal|24
operator|)
operator|&
literal|0xff
expr_stmt|;
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|mav_reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
name|shift0
argument_list|,
name|reg0
argument_list|)
operator|==
name|FAIL
operator|||
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
operator|||
name|mav_reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
name|shift1
argument_list|,
name|reg1
argument_list|)
operator|==
name|FAIL
operator|||
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
operator|||
name|mav_reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
name|shift2
argument_list|,
name|reg2
argument_list|)
operator|==
name|FAIL
operator|||
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
operator|||
name|mav_reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
name|shift3
argument_list|,
name|reg3
argument_list|)
operator|==
name|FAIL
condition|)
block|{
if|if
condition|(
operator|!
name|inst
operator|.
name|error
condition|)
name|inst
operator|.
name|error
operator|=
name|BAD_ARGS
expr_stmt|;
block|}
else|else
name|end_of_line
argument_list|(
name|str
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Maverick shift immediate instructions.    cfsh32<cond> MVFX[15:0],MVFX[15:0],Shift[6:0].    cfsh64<cond> MVDX[15:0],MVDX[15:0],Shift[6:0].  */
end_comment

begin_function
specifier|static
name|void
name|do_mav_shift
parameter_list|(
name|str
parameter_list|,
name|reg0
parameter_list|,
name|reg1
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
name|enum
name|arm_reg_type
name|reg0
decl_stmt|;
name|enum
name|arm_reg_type
name|reg1
decl_stmt|;
block|{
name|int
name|error
decl_stmt|;
name|int
name|imm
decl_stmt|,
name|neg
init|=
literal|0
decl_stmt|;
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|mav_reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|12
argument_list|,
name|reg0
argument_list|)
operator|==
name|FAIL
operator|||
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
operator|||
name|mav_reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|16
argument_list|,
name|reg1
argument_list|)
operator|==
name|FAIL
operator|||
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
condition|)
block|{
if|if
condition|(
operator|!
name|inst
operator|.
name|error
condition|)
name|inst
operator|.
name|error
operator|=
name|BAD_ARGS
expr_stmt|;
return|return;
block|}
comment|/* Calculate the immediate operand.      The operand is a 7bit signed number.  */
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|str
operator|==
literal|'#'
condition|)
operator|++
name|str
expr_stmt|;
if|if
condition|(
operator|!
name|ISDIGIT
argument_list|(
operator|*
name|str
argument_list|)
operator|&&
operator|*
name|str
operator|!=
literal|'-'
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"expecting immediate, 7bit operand"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|*
name|str
operator|==
literal|'-'
condition|)
block|{
name|neg
operator|=
literal|1
expr_stmt|;
operator|++
name|str
expr_stmt|;
block|}
for|for
control|(
name|imm
operator|=
literal|0
init|;
operator|*
name|str
operator|&&
name|ISDIGIT
argument_list|(
operator|*
name|str
argument_list|)
condition|;
operator|++
name|str
control|)
name|imm
operator|=
name|imm
operator|*
literal|10
operator|+
operator|*
name|str
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
name|imm
operator|>
literal|64
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"immediate out of range"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Make negative imm's into 7bit signed numbers.  */
if|if
condition|(
name|neg
condition|)
block|{
name|imm
operator|=
operator|-
name|imm
expr_stmt|;
name|imm
operator|&=
literal|0x0000007f
expr_stmt|;
block|}
comment|/* Bits 0-3 of the insn should have bits 0-3 of the immediate.      Bits 5-7 of the insn should have bits 4-6 of the immediate.      Bit 4 should be 0.  */
name|imm
operator|=
operator|(
name|imm
operator|&
literal|0xf
operator|)
operator||
operator|(
operator|(
name|imm
operator|&
literal|0x70
operator|)
operator|<<
literal|1
operator|)
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|imm
expr_stmt|;
name|end_of_line
argument_list|(
name|str
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|mav_parse_offset
parameter_list|(
name|str
parameter_list|,
name|negative
parameter_list|)
name|char
modifier|*
modifier|*
name|str
decl_stmt|;
name|int
modifier|*
name|negative
decl_stmt|;
block|{
name|char
modifier|*
name|p
init|=
operator|*
name|str
decl_stmt|;
name|int
name|offset
decl_stmt|;
operator|*
name|negative
operator|=
literal|0
expr_stmt|;
name|skip_whitespace
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'#'
condition|)
operator|++
name|p
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'-'
condition|)
block|{
operator|*
name|negative
operator|=
literal|1
expr_stmt|;
operator|++
name|p
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|ISDIGIT
argument_list|(
operator|*
name|p
argument_list|)
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"offset expected"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
for|for
control|(
name|offset
operator|=
literal|0
init|;
operator|*
name|p
operator|&&
name|ISDIGIT
argument_list|(
operator|*
name|p
argument_list|)
condition|;
operator|++
name|p
control|)
name|offset
operator|=
name|offset
operator|*
literal|10
operator|+
operator|*
name|p
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
name|offset
operator|>
literal|0xff
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"offset out of range"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
operator|*
name|str
operator|=
name|p
expr_stmt|;
return|return
operator|*
name|negative
condition|?
operator|-
name|offset
else|:
name|offset
return|;
block|}
end_function

begin_comment
comment|/* Maverick load/store instructions.<insn><cond> CRd,[Rn,<offset>]{!}.<insn><cond> CRd,[Rn],<offset>.  */
end_comment

begin_function
specifier|static
name|void
name|do_mav_ldst
parameter_list|(
name|str
parameter_list|,
name|reg0
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
name|enum
name|arm_reg_type
name|reg0
decl_stmt|;
block|{
name|int
name|offset
decl_stmt|,
name|negative
decl_stmt|;
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|mav_reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|12
argument_list|,
name|reg0
argument_list|)
operator|==
name|FAIL
operator|||
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
operator|||
operator|*
name|str
operator|++
operator|!=
literal|'['
operator|||
name|reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|16
argument_list|)
operator|==
name|FAIL
condition|)
goto|goto
name|fail_ldst
goto|;
if|if
condition|(
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|SUCCESS
condition|)
block|{
comment|/* You are here: "<offset>]{!}".  */
name|inst
operator|.
name|instruction
operator||=
name|PRE_INDEX
expr_stmt|;
name|offset
operator|=
name|mav_parse_offset
argument_list|(
operator|&
name|str
argument_list|,
operator|&
name|negative
argument_list|)
expr_stmt|;
if|if
condition|(
name|inst
operator|.
name|error
condition|)
return|return;
if|if
condition|(
operator|*
name|str
operator|++
operator|!=
literal|']'
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"missing ]"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|*
name|str
operator|==
literal|'!'
condition|)
block|{
name|inst
operator|.
name|instruction
operator||=
name|WRITE_BACK
expr_stmt|;
operator|++
name|str
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* You are here: "],<offset>".  */
if|if
condition|(
operator|*
name|str
operator|++
operator|!=
literal|']'
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"missing ]"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
operator|||
operator|(
name|offset
operator|=
name|mav_parse_offset
argument_list|(
operator|&
name|str
argument_list|,
operator|&
name|negative
argument_list|)
operator|,
name|inst
operator|.
name|error
operator|)
condition|)
goto|goto
name|fail_ldst
goto|;
name|inst
operator|.
name|instruction
operator||=
name|CP_T_WB
expr_stmt|;
comment|/* Post indexed, set bit W.  */
block|}
if|if
condition|(
name|negative
condition|)
name|offset
operator|=
operator|-
name|offset
expr_stmt|;
else|else
name|inst
operator|.
name|instruction
operator||=
name|CP_T_UD
expr_stmt|;
comment|/* Postive, so set bit U.  */
name|inst
operator|.
name|instruction
operator||=
name|offset
operator|>>
literal|2
expr_stmt|;
name|end_of_line
argument_list|(
name|str
argument_list|)
expr_stmt|;
return|return;
name|fail_ldst
label|:
if|if
condition|(
operator|!
name|inst
operator|.
name|error
condition|)
name|inst
operator|.
name|error
operator|=
name|BAD_ARGS
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|do_t_nop
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
comment|/* Do nothing.  */
name|end_of_line
argument_list|(
name|str
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* Handle the Format 4 instructions that do not have equivalents in other    formats.  That is, ADC, AND, EOR, SBC, ROR, TST, NEG, CMN, ORR, MUL,    BIC and MVN.  */
end_comment

begin_function
specifier|static
name|void
name|do_t_arit
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|int
name|Rd
decl_stmt|,
name|Rs
decl_stmt|,
name|Rn
decl_stmt|;
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|Rd
operator|=
name|thumb_reg
argument_list|(
operator|&
name|str
argument_list|,
name|THUMB_REG_LO
argument_list|)
operator|)
operator|==
name|FAIL
operator|||
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
operator|||
operator|(
name|Rs
operator|=
name|thumb_reg
argument_list|(
operator|&
name|str
argument_list|,
name|THUMB_REG_LO
argument_list|)
operator|)
operator|==
name|FAIL
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|BAD_ARGS
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|!=
name|FAIL
condition|)
block|{
comment|/* Three operand format not allowed for TST, CMN, NEG and MVN. 	 (It isn't allowed for CMP either, but that isn't handled by this 	 function.)  */
if|if
condition|(
name|inst
operator|.
name|instruction
operator|==
name|T_OPCODE_TST
operator|||
name|inst
operator|.
name|instruction
operator|==
name|T_OPCODE_CMN
operator|||
name|inst
operator|.
name|instruction
operator|==
name|T_OPCODE_NEG
operator|||
name|inst
operator|.
name|instruction
operator|==
name|T_OPCODE_MVN
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|BAD_ARGS
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|Rn
operator|=
name|thumb_reg
argument_list|(
operator|&
name|str
argument_list|,
name|THUMB_REG_LO
argument_list|)
operator|)
operator|==
name|FAIL
condition|)
return|return;
if|if
condition|(
name|Rs
operator|!=
name|Rd
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"dest and source1 must be the same register"
argument_list|)
expr_stmt|;
return|return;
block|}
name|Rs
operator|=
name|Rn
expr_stmt|;
block|}
if|if
condition|(
name|inst
operator|.
name|instruction
operator|==
name|T_OPCODE_MUL
operator|&&
name|Rs
operator|==
name|Rd
condition|)
name|as_tsktsk
argument_list|(
name|_
argument_list|(
literal|"Rs and Rd must be different in MUL"
argument_list|)
argument_list|)
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|Rd
operator||
operator|(
name|Rs
operator|<<
literal|3
operator|)
expr_stmt|;
name|end_of_line
argument_list|(
name|str
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_t_add
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|thumb_add_sub
argument_list|(
name|str
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_t_asr
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|thumb_shift
argument_list|(
name|str
argument_list|,
name|THUMB_ASR
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_t_branch9
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
if|if
condition|(
name|my_get_expression
argument_list|(
operator|&
name|inst
operator|.
name|reloc
operator|.
name|exp
argument_list|,
operator|&
name|str
argument_list|)
condition|)
return|return;
name|inst
operator|.
name|reloc
operator|.
name|type
operator|=
name|BFD_RELOC_THUMB_PCREL_BRANCH9
expr_stmt|;
name|inst
operator|.
name|reloc
operator|.
name|pc_rel
operator|=
literal|1
expr_stmt|;
name|end_of_line
argument_list|(
name|str
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_t_branch12
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
if|if
condition|(
name|my_get_expression
argument_list|(
operator|&
name|inst
operator|.
name|reloc
operator|.
name|exp
argument_list|,
operator|&
name|str
argument_list|)
condition|)
return|return;
name|inst
operator|.
name|reloc
operator|.
name|type
operator|=
name|BFD_RELOC_THUMB_PCREL_BRANCH12
expr_stmt|;
name|inst
operator|.
name|reloc
operator|.
name|pc_rel
operator|=
literal|1
expr_stmt|;
name|end_of_line
argument_list|(
name|str
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Find the real, Thumb encoded start of a Thumb function.  */
end_comment

begin_function
specifier|static
name|symbolS
modifier|*
name|find_real_start
parameter_list|(
name|symbolP
parameter_list|)
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
block|{
name|char
modifier|*
name|real_start
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
init|=
name|S_GET_NAME
argument_list|(
name|symbolP
argument_list|)
decl_stmt|;
name|symbolS
modifier|*
name|new_target
decl_stmt|;
comment|/* This definiton must agree with the one in gcc/config/arm/thumb.c.  */
define|#
directive|define
name|STUB_NAME
value|".real_start_of"
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Names that start with '.' are local labels, not function entry points.      The compiler may generate BL instructions to these labels because it      needs to perform a branch to a far away location.  */
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'.'
condition|)
return|return
name|symbolP
return|;
name|real_start
operator|=
name|malloc
argument_list|(
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
name|strlen
argument_list|(
name|STUB_NAME
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|real_start
argument_list|,
literal|"%s%s"
argument_list|,
name|STUB_NAME
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|new_target
operator|=
name|symbol_find
argument_list|(
name|real_start
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_target
operator|==
name|NULL
condition|)
block|{
name|as_warn
argument_list|(
literal|"Failed to find real start of function: %s\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|new_target
operator|=
name|symbolP
expr_stmt|;
block|}
name|free
argument_list|(
name|real_start
argument_list|)
expr_stmt|;
return|return
name|new_target
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_t_branch23
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
if|if
condition|(
name|my_get_expression
argument_list|(
operator|&
name|inst
operator|.
name|reloc
operator|.
name|exp
argument_list|,
operator|&
name|str
argument_list|)
condition|)
return|return;
name|inst
operator|.
name|reloc
operator|.
name|type
operator|=
name|BFD_RELOC_THUMB_PCREL_BRANCH23
expr_stmt|;
name|inst
operator|.
name|reloc
operator|.
name|pc_rel
operator|=
literal|1
expr_stmt|;
name|end_of_line
argument_list|(
name|str
argument_list|)
expr_stmt|;
comment|/* If the destination of the branch is a defined symbol which does not have      the THUMB_FUNC attribute, then we must be calling a function which has      the (interfacearm) attribute.  We look for the Thumb entry point to that      function and change the branch to refer to that function instead.  */
if|if
condition|(
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_op
operator|==
name|O_symbol
operator|&&
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_add_symbol
operator|!=
name|NULL
operator|&&
name|S_IS_DEFINED
argument_list|(
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_add_symbol
argument_list|)
operator|&&
operator|!
name|THUMB_IS_FUNC
argument_list|(
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_add_symbol
argument_list|)
condition|)
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_add_symbol
operator|=
name|find_real_start
argument_list|(
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_add_symbol
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_t_bx
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|int
name|reg
decl_stmt|;
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|reg
operator|=
name|thumb_reg
argument_list|(
operator|&
name|str
argument_list|,
name|THUMB_REG_ANY
argument_list|)
operator|)
operator|==
name|FAIL
condition|)
return|return;
comment|/* This sets THUMB_H2 from the top bit of reg.  */
name|inst
operator|.
name|instruction
operator||=
name|reg
operator|<<
literal|3
expr_stmt|;
comment|/* ??? FIXME: Should add a hacky reloc here if reg is REG_PC.  The reloc      should cause the alignment to be checked once it is known.  This is      because BX PC only works if the instruction is word aligned.  */
name|end_of_line
argument_list|(
name|str
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_t_compare
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|thumb_mov_compare
argument_list|(
name|str
argument_list|,
name|THUMB_COMPARE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_t_ldmstm
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|int
name|Rb
decl_stmt|;
name|long
name|range
decl_stmt|;
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|Rb
operator|=
name|thumb_reg
argument_list|(
operator|&
name|str
argument_list|,
name|THUMB_REG_LO
argument_list|)
operator|)
operator|==
name|FAIL
condition|)
return|return;
if|if
condition|(
operator|*
name|str
operator|!=
literal|'!'
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"inserted missing '!': load/store multiple always writes back base register"
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|str
operator|++
expr_stmt|;
if|if
condition|(
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
operator|||
operator|(
name|range
operator|=
name|reg_list
argument_list|(
operator|&
name|str
argument_list|)
operator|)
operator|==
name|FAIL
condition|)
block|{
if|if
condition|(
operator|!
name|inst
operator|.
name|error
condition|)
name|inst
operator|.
name|error
operator|=
name|BAD_ARGS
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|inst
operator|.
name|reloc
operator|.
name|type
operator|!=
name|BFD_RELOC_NONE
condition|)
block|{
comment|/* This really doesn't seem worth it.  */
name|inst
operator|.
name|reloc
operator|.
name|type
operator|=
name|BFD_RELOC_NONE
expr_stmt|;
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"expression too complex"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|range
operator|&
operator|~
literal|0xff
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"only lo-regs valid in load/store multiple"
argument_list|)
expr_stmt|;
return|return;
block|}
name|inst
operator|.
name|instruction
operator||=
operator|(
name|Rb
operator|<<
literal|8
operator|)
operator||
name|range
expr_stmt|;
name|end_of_line
argument_list|(
name|str
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_t_ldr
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|thumb_load_store
argument_list|(
name|str
argument_list|,
name|THUMB_LOAD
argument_list|,
name|THUMB_WORD
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_t_ldrb
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|thumb_load_store
argument_list|(
name|str
argument_list|,
name|THUMB_LOAD
argument_list|,
name|THUMB_BYTE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_t_ldrh
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|thumb_load_store
argument_list|(
name|str
argument_list|,
name|THUMB_LOAD
argument_list|,
name|THUMB_HALFWORD
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_t_lds
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|int
name|Rd
decl_stmt|,
name|Rb
decl_stmt|,
name|Ro
decl_stmt|;
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|Rd
operator|=
name|thumb_reg
argument_list|(
operator|&
name|str
argument_list|,
name|THUMB_REG_LO
argument_list|)
operator|)
operator|==
name|FAIL
operator|||
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
operator|||
operator|*
name|str
operator|++
operator|!=
literal|'['
operator|||
operator|(
name|Rb
operator|=
name|thumb_reg
argument_list|(
operator|&
name|str
argument_list|,
name|THUMB_REG_LO
argument_list|)
operator|)
operator|==
name|FAIL
operator|||
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
operator|||
operator|(
name|Ro
operator|=
name|thumb_reg
argument_list|(
operator|&
name|str
argument_list|,
name|THUMB_REG_LO
argument_list|)
operator|)
operator|==
name|FAIL
operator|||
operator|*
name|str
operator|++
operator|!=
literal|']'
condition|)
block|{
if|if
condition|(
operator|!
name|inst
operator|.
name|error
condition|)
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"syntax: ldrs[b] Rd, [Rb, Ro]"
argument_list|)
expr_stmt|;
return|return;
block|}
name|inst
operator|.
name|instruction
operator||=
name|Rd
operator||
operator|(
name|Rb
operator|<<
literal|3
operator|)
operator||
operator|(
name|Ro
operator|<<
literal|6
operator|)
expr_stmt|;
name|end_of_line
argument_list|(
name|str
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_t_lsl
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|thumb_shift
argument_list|(
name|str
argument_list|,
name|THUMB_LSL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_t_lsr
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|thumb_shift
argument_list|(
name|str
argument_list|,
name|THUMB_LSR
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_t_mov
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|thumb_mov_compare
argument_list|(
name|str
argument_list|,
name|THUMB_MOVE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_t_push_pop
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|long
name|range
decl_stmt|;
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|range
operator|=
name|reg_list
argument_list|(
operator|&
name|str
argument_list|)
operator|)
operator|==
name|FAIL
condition|)
block|{
if|if
condition|(
operator|!
name|inst
operator|.
name|error
condition|)
name|inst
operator|.
name|error
operator|=
name|BAD_ARGS
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|inst
operator|.
name|reloc
operator|.
name|type
operator|!=
name|BFD_RELOC_NONE
condition|)
block|{
comment|/* This really doesn't seem worth it.  */
name|inst
operator|.
name|reloc
operator|.
name|type
operator|=
name|BFD_RELOC_NONE
expr_stmt|;
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"expression too complex"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|range
operator|&
operator|~
literal|0xff
condition|)
block|{
if|if
condition|(
operator|(
name|inst
operator|.
name|instruction
operator|==
name|T_OPCODE_PUSH
operator|&&
operator|(
name|range
operator|&
operator|~
literal|0xff
operator|)
operator|==
literal|1
operator|<<
name|REG_LR
operator|)
operator|||
operator|(
name|inst
operator|.
name|instruction
operator|==
name|T_OPCODE_POP
operator|&&
operator|(
name|range
operator|&
operator|~
literal|0xff
operator|)
operator|==
literal|1
operator|<<
name|REG_PC
operator|)
condition|)
block|{
name|inst
operator|.
name|instruction
operator||=
name|THUMB_PP_PC_LR
expr_stmt|;
name|range
operator|&=
literal|0xff
expr_stmt|;
block|}
else|else
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"invalid register list to push/pop instruction"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|inst
operator|.
name|instruction
operator||=
name|range
expr_stmt|;
name|end_of_line
argument_list|(
name|str
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_t_str
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|thumb_load_store
argument_list|(
name|str
argument_list|,
name|THUMB_STORE
argument_list|,
name|THUMB_WORD
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_t_strb
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|thumb_load_store
argument_list|(
name|str
argument_list|,
name|THUMB_STORE
argument_list|,
name|THUMB_BYTE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_t_strh
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|thumb_load_store
argument_list|(
name|str
argument_list|,
name|THUMB_STORE
argument_list|,
name|THUMB_HALFWORD
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_t_sub
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|thumb_add_sub
argument_list|(
name|str
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_t_swi
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|my_get_expression
argument_list|(
operator|&
name|inst
operator|.
name|reloc
operator|.
name|exp
argument_list|,
operator|&
name|str
argument_list|)
condition|)
return|return;
name|inst
operator|.
name|reloc
operator|.
name|type
operator|=
name|BFD_RELOC_ARM_SWI
expr_stmt|;
name|end_of_line
argument_list|(
name|str
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|do_t_adr
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|int
name|reg
decl_stmt|;
comment|/* This is a pseudo-op of the form "adr rd, label" to be converted      into a relative address of the form "add rd, pc, #label-.-4".  */
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
comment|/* Store Rd in temporary location inside instruction.  */
if|if
condition|(
operator|(
name|reg
operator|=
name|reg_required_here
argument_list|(
operator|&
name|str
argument_list|,
literal|4
argument_list|)
operator|)
operator|==
name|FAIL
operator|||
operator|(
name|reg
operator|>
literal|7
operator|)
comment|/* For Thumb reg must be r0..r7.  */
operator|||
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|==
name|FAIL
operator|||
name|my_get_expression
argument_list|(
operator|&
name|inst
operator|.
name|reloc
operator|.
name|exp
argument_list|,
operator|&
name|str
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|inst
operator|.
name|error
condition|)
name|inst
operator|.
name|error
operator|=
name|BAD_ARGS
expr_stmt|;
return|return;
block|}
name|inst
operator|.
name|reloc
operator|.
name|type
operator|=
name|BFD_RELOC_ARM_THUMB_ADD
expr_stmt|;
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_add_number
operator|-=
literal|4
expr_stmt|;
comment|/* PC relative adjust.  */
name|inst
operator|.
name|reloc
operator|.
name|pc_rel
operator|=
literal|1
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|REG_PC
expr_stmt|;
comment|/* Rd is already placed into the instruction.  */
name|end_of_line
argument_list|(
name|str
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|insert_reg
parameter_list|(
name|r
parameter_list|,
name|htab
parameter_list|)
specifier|const
name|struct
name|reg_entry
modifier|*
name|r
decl_stmt|;
name|struct
name|hash_control
modifier|*
name|htab
decl_stmt|;
block|{
name|int
name|len
init|=
name|strlen
argument_list|(
name|r
operator|->
name|name
argument_list|)
operator|+
literal|2
decl_stmt|;
name|char
modifier|*
name|buf
init|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|len
argument_list|)
decl_stmt|;
name|char
modifier|*
name|buf2
init|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|len
argument_list|)
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|REGISTER_PREFIX
name|buf
index|[
name|i
operator|++
index|]
operator|=
name|REGISTER_PREFIX
expr_stmt|;
endif|#
directive|endif
name|strcpy
argument_list|(
name|buf
operator|+
name|i
argument_list|,
name|r
operator|->
name|name
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|buf
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
name|buf2
index|[
name|i
index|]
operator|=
name|TOUPPER
argument_list|(
name|buf
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|buf2
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
name|hash_insert
argument_list|(
name|htab
argument_list|,
name|buf
argument_list|,
operator|(
name|PTR
operator|)
name|r
argument_list|)
expr_stmt|;
name|hash_insert
argument_list|(
name|htab
argument_list|,
name|buf2
argument_list|,
operator|(
name|PTR
operator|)
name|r
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|build_reg_hsh
parameter_list|(
name|map
parameter_list|)
name|struct
name|reg_map
modifier|*
name|map
decl_stmt|;
block|{
specifier|const
name|struct
name|reg_entry
modifier|*
name|r
decl_stmt|;
if|if
condition|(
operator|(
name|map
operator|->
name|htab
operator|=
name|hash_new
argument_list|()
operator|)
operator|==
name|NULL
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"virtual memory exhausted"
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|r
operator|=
name|map
operator|->
name|names
init|;
name|r
operator|->
name|name
operator|!=
name|NULL
condition|;
name|r
operator|++
control|)
name|insert_reg
argument_list|(
name|r
argument_list|,
name|map
operator|->
name|htab
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|insert_reg_alias
parameter_list|(
name|str
parameter_list|,
name|regnum
parameter_list|,
name|htab
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
name|int
name|regnum
decl_stmt|;
name|struct
name|hash_control
modifier|*
name|htab
decl_stmt|;
block|{
name|struct
name|reg_entry
modifier|*
name|new
init|=
operator|(
expr|struct
name|reg_entry
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|reg_entry
argument_list|)
argument_list|)
decl_stmt|;
name|char
modifier|*
name|name
init|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|str
argument_list|)
operator|+
literal|1
argument_list|)
decl_stmt|;
name|strcpy
argument_list|(
name|name
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|new
operator|->
name|name
operator|=
name|name
expr_stmt|;
name|new
operator|->
name|number
operator|=
name|regnum
expr_stmt|;
name|hash_insert
argument_list|(
name|htab
argument_list|,
name|name
argument_list|,
operator|(
name|PTR
operator|)
name|new
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Look for the .req directive.  This is of the form:     	newname .req existing_name     If we find one, or if it looks sufficiently like one that we want to    handle any error here, return non-zero.  Otherwise return zero.  */
end_comment

begin_function
specifier|static
name|int
name|create_register_alias
parameter_list|(
name|newname
parameter_list|,
name|p
parameter_list|)
name|char
modifier|*
name|newname
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
block|{
name|char
modifier|*
name|q
decl_stmt|;
name|char
name|c
decl_stmt|;
name|q
operator|=
name|p
expr_stmt|;
name|skip_whitespace
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|c
operator|=
operator|*
name|p
expr_stmt|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|*
name|q
operator|&&
operator|!
name|strncmp
argument_list|(
name|q
argument_list|,
literal|".req "
argument_list|,
literal|5
argument_list|)
condition|)
block|{
name|char
modifier|*
name|copy_of_str
decl_stmt|;
name|char
modifier|*
name|r
decl_stmt|;
ifdef|#
directive|ifdef
name|IGNORE_OPCODE_CASE
name|newname
operator|=
name|original_case_string
expr_stmt|;
endif|#
directive|endif
name|copy_of_str
operator|=
name|newname
expr_stmt|;
name|q
operator|+=
literal|4
expr_stmt|;
name|skip_whitespace
argument_list|(
name|q
argument_list|)
expr_stmt|;
for|for
control|(
name|r
operator|=
name|q
init|;
operator|*
name|r
operator|!=
literal|'\0'
condition|;
name|r
operator|++
control|)
if|if
condition|(
operator|*
name|r
operator|==
literal|' '
condition|)
break|break;
if|if
condition|(
name|r
operator|!=
name|q
condition|)
block|{
name|enum
name|arm_reg_type
name|new_type
decl_stmt|,
name|old_type
decl_stmt|;
name|int
name|old_regno
decl_stmt|;
name|char
name|d
init|=
operator|*
name|r
decl_stmt|;
operator|*
name|r
operator|=
literal|'\0'
expr_stmt|;
name|old_type
operator|=
name|arm_reg_parse_any
argument_list|(
name|q
argument_list|)
expr_stmt|;
operator|*
name|r
operator|=
name|d
expr_stmt|;
name|new_type
operator|=
name|arm_reg_parse_any
argument_list|(
name|newname
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_type
operator|==
name|REG_TYPE_MAX
condition|)
block|{
if|if
condition|(
name|old_type
operator|!=
name|REG_TYPE_MAX
condition|)
block|{
name|old_regno
operator|=
name|arm_reg_parse
argument_list|(
operator|&
name|q
argument_list|,
name|all_reg_maps
index|[
name|old_type
index|]
operator|.
name|htab
argument_list|)
expr_stmt|;
name|insert_reg_alias
argument_list|(
name|newname
argument_list|,
name|old_regno
argument_list|,
name|all_reg_maps
index|[
name|old_type
index|]
operator|.
name|htab
argument_list|)
expr_stmt|;
block|}
else|else
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"register '%s' does not exist\n"
argument_list|)
argument_list|,
name|q
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|old_type
operator|==
name|REG_TYPE_MAX
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"ignoring redefinition of register alias '%s' to non-existant register '%s'"
argument_list|)
argument_list|,
name|copy_of_str
argument_list|,
name|q
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Do not warn about redefinitions to the same alias.  */
if|if
condition|(
name|new_type
operator|!=
name|old_type
operator|||
operator|(
name|arm_reg_parse
argument_list|(
operator|&
name|q
argument_list|,
name|all_reg_maps
index|[
name|old_type
index|]
operator|.
name|htab
argument_list|)
operator|!=
name|arm_reg_parse
argument_list|(
operator|&
name|q
argument_list|,
name|all_reg_maps
index|[
name|new_type
index|]
operator|.
name|htab
argument_list|)
operator|)
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"ignoring redefinition of register alias '%s'"
argument_list|)
argument_list|,
name|copy_of_str
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"ignoring incomplete .req pseuso op"
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
name|c
expr_stmt|;
return|return
literal|1
return|;
block|}
operator|*
name|p
operator|=
name|c
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|set_constant_flonums
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_FLOAT_VALS
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|atof_ieee
argument_list|(
operator|(
name|char
operator|*
operator|)
name|fp_const
index|[
name|i
index|]
argument_list|,
literal|'x'
argument_list|,
name|fp_values
index|[
name|i
index|]
argument_list|)
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Iterate over the base tables to create the instruction patterns.  */
end_comment

begin_function
specifier|static
name|void
name|build_arm_ops_hsh
parameter_list|()
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|unsigned
name|int
name|j
decl_stmt|;
specifier|static
name|struct
name|obstack
name|insn_obstack
decl_stmt|;
name|obstack_begin
argument_list|(
operator|&
name|insn_obstack
argument_list|,
literal|4000
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|insns
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|asm_opcode
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|struct
name|asm_opcode
modifier|*
name|insn
init|=
name|insns
operator|+
name|i
decl_stmt|;
if|if
condition|(
name|insn
operator|->
name|cond_offset
operator|!=
literal|0
condition|)
block|{
comment|/* Insn supports conditional execution.  Build the varaints 	     and insert them in the hash table.  */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
sizeof|sizeof
argument_list|(
name|conds
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|asm_cond
argument_list|)
condition|;
name|j
operator|++
control|)
block|{
name|unsigned
name|len
init|=
name|strlen
argument_list|(
name|insn
operator|->
name|template
argument_list|)
decl_stmt|;
name|struct
name|asm_opcode
modifier|*
name|new
decl_stmt|;
name|char
modifier|*
name|template
decl_stmt|;
name|new
operator|=
name|obstack_alloc
argument_list|(
operator|&
name|insn_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|asm_opcode
argument_list|)
argument_list|)
expr_stmt|;
comment|/* All condition codes are two characters.  */
name|template
operator|=
name|obstack_alloc
argument_list|(
operator|&
name|insn_obstack
argument_list|,
name|len
operator|+
literal|3
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|template
argument_list|,
name|insn
operator|->
name|template
argument_list|,
name|insn
operator|->
name|cond_offset
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|template
operator|+
name|insn
operator|->
name|cond_offset
argument_list|,
name|conds
index|[
name|j
index|]
operator|.
name|template
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|insn
operator|->
name|cond_offset
condition|)
name|strcpy
argument_list|(
name|template
operator|+
name|insn
operator|->
name|cond_offset
operator|+
literal|2
argument_list|,
name|insn
operator|->
name|template
operator|+
name|insn
operator|->
name|cond_offset
argument_list|)
expr_stmt|;
name|new
operator|->
name|template
operator|=
name|template
expr_stmt|;
name|new
operator|->
name|cond_offset
operator|=
literal|0
expr_stmt|;
name|new
operator|->
name|variant
operator|=
name|insn
operator|->
name|variant
expr_stmt|;
name|new
operator|->
name|parms
operator|=
name|insn
operator|->
name|parms
expr_stmt|;
name|new
operator|->
name|value
operator|=
operator|(
name|insn
operator|->
name|value
operator|&
operator|~
name|COND_MASK
operator|)
operator||
name|conds
index|[
name|j
index|]
operator|.
name|value
expr_stmt|;
name|hash_insert
argument_list|(
name|arm_ops_hsh
argument_list|,
name|new
operator|->
name|template
argument_list|,
operator|(
name|PTR
operator|)
name|new
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Finally, insert the unconditional insn in the table directly; 	 no need to build a copy.  */
name|hash_insert
argument_list|(
name|arm_ops_hsh
argument_list|,
name|insn
operator|->
name|template
argument_list|,
operator|(
name|PTR
operator|)
name|insn
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|md_begin
parameter_list|()
block|{
name|unsigned
name|mach
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|(
name|arm_ops_hsh
operator|=
name|hash_new
argument_list|()
operator|)
operator|==
name|NULL
operator|||
operator|(
name|arm_tops_hsh
operator|=
name|hash_new
argument_list|()
operator|)
operator|==
name|NULL
operator|||
operator|(
name|arm_cond_hsh
operator|=
name|hash_new
argument_list|()
operator|)
operator|==
name|NULL
operator|||
operator|(
name|arm_shift_hsh
operator|=
name|hash_new
argument_list|()
operator|)
operator|==
name|NULL
operator|||
operator|(
name|arm_psr_hsh
operator|=
name|hash_new
argument_list|()
operator|)
operator|==
name|NULL
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"virtual memory exhausted"
argument_list|)
argument_list|)
expr_stmt|;
name|build_arm_ops_hsh
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|tinsns
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|thumb_opcode
argument_list|)
condition|;
name|i
operator|++
control|)
name|hash_insert
argument_list|(
name|arm_tops_hsh
argument_list|,
name|tinsns
index|[
name|i
index|]
operator|.
name|template
argument_list|,
call|(
name|PTR
call|)
argument_list|(
name|tinsns
operator|+
name|i
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|conds
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|asm_cond
argument_list|)
condition|;
name|i
operator|++
control|)
name|hash_insert
argument_list|(
name|arm_cond_hsh
argument_list|,
name|conds
index|[
name|i
index|]
operator|.
name|template
argument_list|,
call|(
name|PTR
call|)
argument_list|(
name|conds
operator|+
name|i
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|shift_names
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|asm_shift_name
argument_list|)
condition|;
name|i
operator|++
control|)
name|hash_insert
argument_list|(
name|arm_shift_hsh
argument_list|,
name|shift_names
index|[
name|i
index|]
operator|.
name|name
argument_list|,
call|(
name|PTR
call|)
argument_list|(
name|shift_names
operator|+
name|i
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|psrs
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|asm_psr
argument_list|)
condition|;
name|i
operator|++
control|)
name|hash_insert
argument_list|(
name|arm_psr_hsh
argument_list|,
name|psrs
index|[
name|i
index|]
operator|.
name|template
argument_list|,
call|(
name|PTR
call|)
argument_list|(
name|psrs
operator|+
name|i
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
operator|(
name|int
operator|)
name|REG_TYPE_FIRST
init|;
name|i
operator|<
operator|(
name|int
operator|)
name|REG_TYPE_MAX
condition|;
name|i
operator|++
control|)
name|build_reg_hsh
argument_list|(
name|all_reg_maps
operator|+
name|i
argument_list|)
expr_stmt|;
name|set_constant_flonums
argument_list|()
expr_stmt|;
comment|/* Set the cpu variant based on the command-line options.  We prefer      -mcpu= over -march= if both are set (as for GCC); and we prefer      -mfpu= over any other way of setting the floating point unit.      Use of legacy options with new options are faulted.  */
if|if
condition|(
name|legacy_cpu
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|mcpu_cpu_opt
operator|!=
operator|-
literal|1
operator|||
name|march_cpu_opt
operator|!=
operator|-
literal|1
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"use of old and new-style options to set CPU type"
argument_list|)
argument_list|)
expr_stmt|;
name|mcpu_cpu_opt
operator|=
name|legacy_cpu
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mcpu_cpu_opt
operator|==
operator|-
literal|1
condition|)
name|mcpu_cpu_opt
operator|=
name|march_cpu_opt
expr_stmt|;
if|if
condition|(
name|legacy_fpu
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|mfpu_opt
operator|!=
operator|-
literal|1
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"use of old and new-style options to set FPU type"
argument_list|)
argument_list|)
expr_stmt|;
name|mfpu_opt
operator|=
name|legacy_fpu
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mfpu_opt
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|mcpu_fpu_opt
operator|!=
operator|-
literal|1
condition|)
name|mfpu_opt
operator|=
name|mcpu_fpu_opt
expr_stmt|;
else|else
name|mfpu_opt
operator|=
name|march_fpu_opt
expr_stmt|;
block|}
if|if
condition|(
name|mfpu_opt
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|mcpu_cpu_opt
operator|==
operator|-
literal|1
condition|)
name|mfpu_opt
operator|=
name|FPU_DEFAULT
expr_stmt|;
elseif|else
if|if
condition|(
name|mcpu_cpu_opt
operator|&
name|ARM_EXT_V5
condition|)
name|mfpu_opt
operator|=
name|FPU_ARCH_VFP_V2
expr_stmt|;
else|else
name|mfpu_opt
operator|=
name|FPU_ARCH_FPA
expr_stmt|;
block|}
if|if
condition|(
name|mcpu_cpu_opt
operator|==
operator|-
literal|1
condition|)
name|mcpu_cpu_opt
operator|=
name|CPU_DEFAULT
expr_stmt|;
name|cpu_variant
operator|=
name|mcpu_cpu_opt
operator||
name|mfpu_opt
expr_stmt|;
if|#
directive|if
name|defined
name|OBJ_COFF
operator|||
name|defined
name|OBJ_ELF
block|{
name|unsigned
name|int
name|flags
init|=
literal|0
decl_stmt|;
comment|/* Set the flags in the private structure.  */
if|if
condition|(
name|uses_apcs_26
condition|)
name|flags
operator||=
name|F_APCS26
expr_stmt|;
if|if
condition|(
name|support_interwork
condition|)
name|flags
operator||=
name|F_INTERWORK
expr_stmt|;
if|if
condition|(
name|uses_apcs_float
condition|)
name|flags
operator||=
name|F_APCS_FLOAT
expr_stmt|;
if|if
condition|(
name|pic_code
condition|)
name|flags
operator||=
name|F_PIC
expr_stmt|;
if|if
condition|(
operator|(
name|cpu_variant
operator|&
name|FPU_ANY
operator|)
operator|==
name|FPU_NONE
operator|||
operator|(
name|cpu_variant
operator|&
name|FPU_ANY
operator|)
operator|==
name|FPU_ARCH_VFP
condition|)
comment|/* VFP layout only.  */
name|flags
operator||=
name|F_SOFT_FLOAT
expr_stmt|;
comment|/* Using VFP conventions (even if soft-float).  */
if|if
condition|(
name|cpu_variant
operator|&
name|FPU_VFP_EXT_NONE
condition|)
name|flags
operator||=
name|F_VFP_FLOAT
expr_stmt|;
name|bfd_set_private_flags
argument_list|(
name|stdoutput
argument_list|,
name|flags
argument_list|)
expr_stmt|;
comment|/* We have run out flags in the COFF header to encode the        status of ATPCS support, so instead we create a dummy,        empty, debug section called .arm.atpcs.  */
if|if
condition|(
name|atpcs
condition|)
block|{
name|asection
modifier|*
name|sec
decl_stmt|;
name|sec
operator|=
name|bfd_make_section
argument_list|(
name|stdoutput
argument_list|,
literal|".arm.atpcs"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sec
operator|!=
name|NULL
condition|)
block|{
name|bfd_set_section_flags
argument_list|(
name|stdoutput
argument_list|,
name|sec
argument_list|,
name|SEC_READONLY
operator||
name|SEC_DEBUGGING
comment|/* | SEC_HAS_CONTENTS */
argument_list|)
expr_stmt|;
name|bfd_set_section_size
argument_list|(
name|stdoutput
argument_list|,
name|sec
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bfd_set_section_contents
argument_list|(
name|stdoutput
argument_list|,
name|sec
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
endif|#
directive|endif
comment|/* Record the CPU type as well.  */
switch|switch
condition|(
name|cpu_variant
operator|&
name|ARM_CPU_MASK
condition|)
block|{
case|case
name|ARM_2
case|:
name|mach
operator|=
name|bfd_mach_arm_2
expr_stmt|;
break|break;
case|case
name|ARM_3
case|:
comment|/* Also ARM_250.  */
name|mach
operator|=
name|bfd_mach_arm_2a
expr_stmt|;
break|break;
case|case
name|ARM_6
case|:
comment|/* Also ARM_7.  */
name|mach
operator|=
name|bfd_mach_arm_3
expr_stmt|;
break|break;
default|default:
name|mach
operator|=
name|bfd_mach_arm_4
expr_stmt|;
break|break;
block|}
comment|/* Catch special cases.  */
if|if
condition|(
name|cpu_variant
operator|&
name|ARM_CEXT_XSCALE
condition|)
name|mach
operator|=
name|bfd_mach_arm_XScale
expr_stmt|;
elseif|else
if|if
condition|(
name|cpu_variant
operator|&
name|ARM_EXT_V5E
condition|)
name|mach
operator|=
name|bfd_mach_arm_5TE
expr_stmt|;
elseif|else
if|if
condition|(
name|cpu_variant
operator|&
name|ARM_EXT_V5
condition|)
block|{
if|if
condition|(
name|cpu_variant
operator|&
name|ARM_EXT_V4T
condition|)
name|mach
operator|=
name|bfd_mach_arm_5T
expr_stmt|;
else|else
name|mach
operator|=
name|bfd_mach_arm_5
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cpu_variant
operator|&
name|ARM_EXT_V4
condition|)
block|{
if|if
condition|(
name|cpu_variant
operator|&
name|ARM_EXT_V4T
condition|)
name|mach
operator|=
name|bfd_mach_arm_4T
expr_stmt|;
else|else
name|mach
operator|=
name|bfd_mach_arm_4
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cpu_variant
operator|&
name|ARM_EXT_V3M
condition|)
name|mach
operator|=
name|bfd_mach_arm_3M
expr_stmt|;
name|bfd_set_arch_mach
argument_list|(
name|stdoutput
argument_list|,
name|TARGET_ARCH
argument_list|,
name|mach
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Turn an integer of n bytes (in val) into a stream of bytes appropriate    for use in the a.out file, and stores them in the array pointed to by buf.    This knows about the endian-ness of the target machine and does    THE RIGHT THING, whatever it is.  Possible values for n are 1 (byte)    2 (short) and 4 (long)  Floating numbers are put out as a series of    LITTLENUMS (shorts, here at least).  */
end_comment

begin_function
name|void
name|md_number_to_chars
parameter_list|(
name|buf
parameter_list|,
name|val
parameter_list|,
name|n
parameter_list|)
name|char
modifier|*
name|buf
decl_stmt|;
name|valueT
name|val
decl_stmt|;
name|int
name|n
decl_stmt|;
block|{
if|if
condition|(
name|target_big_endian
condition|)
name|number_to_chars_bigendian
argument_list|(
name|buf
argument_list|,
name|val
argument_list|,
name|n
argument_list|)
expr_stmt|;
else|else
name|number_to_chars_littleendian
argument_list|(
name|buf
argument_list|,
name|val
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|valueT
name|md_chars_to_number
parameter_list|(
name|buf
parameter_list|,
name|n
parameter_list|)
name|char
modifier|*
name|buf
decl_stmt|;
name|int
name|n
decl_stmt|;
block|{
name|valueT
name|result
init|=
literal|0
decl_stmt|;
name|unsigned
name|char
modifier|*
name|where
init|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|buf
decl_stmt|;
if|if
condition|(
name|target_big_endian
condition|)
block|{
while|while
condition|(
name|n
operator|--
condition|)
block|{
name|result
operator|<<=
literal|8
expr_stmt|;
name|result
operator||=
operator|(
operator|*
name|where
operator|++
operator|&
literal|255
operator|)
expr_stmt|;
block|}
block|}
else|else
block|{
while|while
condition|(
name|n
operator|--
condition|)
block|{
name|result
operator|<<=
literal|8
expr_stmt|;
name|result
operator||=
operator|(
name|where
index|[
name|n
index|]
operator|&
literal|255
operator|)
expr_stmt|;
block|}
block|}
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Turn a string in input_line_pointer into a floating point constant    of type TYPE, and store the appropriate bytes in *LITP.  The number    of LITTLENUMS emitted is stored in *SIZEP.  An error message is    returned, or NULL on OK.     Note that fp constants aren't represent in the normal way on the ARM.    In big endian mode, things are as expected.  However, in little endian    mode fp constants are big-endian word-wise, and little-endian byte-wise    within the words.  For example, (double) 1.1 in big endian mode is    the byte sequence 3f f1 99 99 99 99 99 9a, and in little endian mode is    the byte sequence 99 99 f1 3f 9a 99 99 99.     ??? The format of 12 byte floats is uncertain according to gcc's arm.h.  */
end_comment

begin_function
name|char
modifier|*
name|md_atof
parameter_list|(
name|type
parameter_list|,
name|litP
parameter_list|,
name|sizeP
parameter_list|)
name|char
name|type
decl_stmt|;
name|char
modifier|*
name|litP
decl_stmt|;
name|int
modifier|*
name|sizeP
decl_stmt|;
block|{
name|int
name|prec
decl_stmt|;
name|LITTLENUM_TYPE
name|words
index|[
name|MAX_LITTLENUMS
index|]
decl_stmt|;
name|char
modifier|*
name|t
decl_stmt|;
name|int
name|i
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
literal|'f'
case|:
case|case
literal|'F'
case|:
case|case
literal|'s'
case|:
case|case
literal|'S'
case|:
name|prec
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
case|case
literal|'D'
case|:
case|case
literal|'r'
case|:
case|case
literal|'R'
case|:
name|prec
operator|=
literal|4
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
case|case
literal|'X'
case|:
name|prec
operator|=
literal|6
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
case|case
literal|'P'
case|:
name|prec
operator|=
literal|6
expr_stmt|;
break|break;
default|default:
operator|*
name|sizeP
operator|=
literal|0
expr_stmt|;
return|return
name|_
argument_list|(
literal|"bad call to MD_ATOF()"
argument_list|)
return|;
block|}
name|t
operator|=
name|atof_ieee
argument_list|(
name|input_line_pointer
argument_list|,
name|type
argument_list|,
name|words
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
condition|)
name|input_line_pointer
operator|=
name|t
expr_stmt|;
operator|*
name|sizeP
operator|=
name|prec
operator|*
literal|2
expr_stmt|;
if|if
condition|(
name|target_big_endian
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|prec
condition|;
name|i
operator|++
control|)
block|{
name|md_number_to_chars
argument_list|(
name|litP
argument_list|,
operator|(
name|valueT
operator|)
name|words
index|[
name|i
index|]
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|litP
operator|+=
literal|2
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|cpu_variant
operator|&
name|FPU_ARCH_VFP
condition|)
for|for
control|(
name|i
operator|=
name|prec
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|md_number_to_chars
argument_list|(
name|litP
argument_list|,
operator|(
name|valueT
operator|)
name|words
index|[
name|i
index|]
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|litP
operator|+=
literal|2
expr_stmt|;
block|}
else|else
comment|/* For a 4 byte float the order of elements in `words' is 1 0. 	   For an 8 byte float the order is 1 0 3 2.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|prec
condition|;
name|i
operator|+=
literal|2
control|)
block|{
name|md_number_to_chars
argument_list|(
name|litP
argument_list|,
operator|(
name|valueT
operator|)
name|words
index|[
name|i
operator|+
literal|1
index|]
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|litP
operator|+
literal|2
argument_list|,
operator|(
name|valueT
operator|)
name|words
index|[
name|i
index|]
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|litP
operator|+=
literal|4
expr_stmt|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* The knowledge of the PC's pipeline offset is built into the insns    themselves.  */
end_comment

begin_function
name|long
name|md_pcrel_from
parameter_list|(
name|fixP
parameter_list|)
name|fixS
modifier|*
name|fixP
decl_stmt|;
block|{
if|if
condition|(
name|fixP
operator|->
name|fx_addsy
operator|&&
name|S_GET_SEGMENT
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
operator|==
name|undefined_section
operator|&&
name|fixP
operator|->
name|fx_subsy
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|fixP
operator|->
name|fx_pcrel
operator|&&
operator|(
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_ARM_THUMB_ADD
operator|)
condition|)
block|{
comment|/* PC relative addressing on the Thumb is slightly odd 	 as the bottom two bits of the PC are forced to zero 	 for the calculation.  */
return|return
operator|(
name|fixP
operator|->
name|fx_where
operator|+
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_address
operator|)
operator|&
operator|~
literal|3
return|;
block|}
ifdef|#
directive|ifdef
name|TE_WINCE
comment|/* The pattern was adjusted to accomodate CE's off-by-one fixups,      so we un-adjust here to compensate for the accomodation.  */
return|return
name|fixP
operator|->
name|fx_where
operator|+
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_address
operator|+
literal|8
return|;
else|#
directive|else
return|return
name|fixP
operator|->
name|fx_where
operator|+
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_address
return|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Round up a section size to the appropriate boundary.  */
end_comment

begin_function
name|valueT
name|md_section_align
parameter_list|(
name|segment
parameter_list|,
name|size
parameter_list|)
name|segT
name|segment
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|valueT
name|size
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|OBJ_ELF
return|return
name|size
return|;
else|#
directive|else
comment|/* Round all sects to multiple of 4.  */
return|return
operator|(
name|size
operator|+
literal|3
operator|)
operator|&
operator|~
literal|3
return|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Under ELF we need to default _GLOBAL_OFFSET_TABLE.    Otherwise we have no need to default values of symbols.  */
end_comment

begin_function
name|symbolS
modifier|*
name|md_undefined_symbol
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|OBJ_ELF
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'_'
operator|&&
name|name
index|[
literal|1
index|]
operator|==
literal|'G'
operator|&&
name|streq
argument_list|(
name|name
argument_list|,
name|GLOBAL_OFFSET_TABLE_NAME
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|GOT_symbol
condition|)
block|{
if|if
condition|(
name|symbol_find
argument_list|(
name|name
argument_list|)
condition|)
name|as_bad
argument_list|(
literal|"GOT already in the symbol table"
argument_list|)
expr_stmt|;
name|GOT_symbol
operator|=
name|symbol_new
argument_list|(
name|name
argument_list|,
name|undefined_section
argument_list|,
operator|(
name|valueT
operator|)
literal|0
argument_list|,
operator|&
name|zero_address_frag
argument_list|)
expr_stmt|;
block|}
return|return
name|GOT_symbol
return|;
block|}
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* arm_reg_parse () := if it looks like a register, return its token and    advance the pointer.  */
end_comment

begin_function
specifier|static
name|int
name|arm_reg_parse
parameter_list|(
name|ccp
parameter_list|,
name|htab
parameter_list|)
specifier|register
name|char
modifier|*
modifier|*
name|ccp
decl_stmt|;
name|struct
name|hash_control
modifier|*
name|htab
decl_stmt|;
block|{
name|char
modifier|*
name|start
init|=
operator|*
name|ccp
decl_stmt|;
name|char
name|c
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|struct
name|reg_entry
modifier|*
name|reg
decl_stmt|;
ifdef|#
directive|ifdef
name|REGISTER_PREFIX
if|if
condition|(
operator|*
name|start
operator|!=
name|REGISTER_PREFIX
condition|)
return|return
name|FAIL
return|;
name|p
operator|=
name|start
operator|+
literal|1
expr_stmt|;
else|#
directive|else
name|p
operator|=
name|start
expr_stmt|;
ifdef|#
directive|ifdef
name|OPTIONAL_REGISTER_PREFIX
if|if
condition|(
operator|*
name|p
operator|==
name|OPTIONAL_REGISTER_PREFIX
condition|)
name|p
operator|++
operator|,
name|start
operator|++
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
if|if
condition|(
operator|!
name|ISALPHA
argument_list|(
operator|*
name|p
argument_list|)
operator|||
operator|!
name|is_name_beginner
argument_list|(
operator|*
name|p
argument_list|)
condition|)
return|return
name|FAIL
return|;
name|c
operator|=
operator|*
name|p
operator|++
expr_stmt|;
while|while
condition|(
name|ISALPHA
argument_list|(
name|c
argument_list|)
operator|||
name|ISDIGIT
argument_list|(
name|c
argument_list|)
operator|||
name|c
operator|==
literal|'_'
condition|)
name|c
operator|=
operator|*
name|p
operator|++
expr_stmt|;
operator|*
operator|--
name|p
operator|=
literal|0
expr_stmt|;
name|reg
operator|=
operator|(
expr|struct
name|reg_entry
operator|*
operator|)
name|hash_find
argument_list|(
name|htab
argument_list|,
name|start
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|reg
condition|)
block|{
operator|*
name|ccp
operator|=
name|p
expr_stmt|;
return|return
name|reg
operator|->
name|number
return|;
block|}
return|return
name|FAIL
return|;
block|}
end_function

begin_comment
comment|/* Search for the following register name in each of the possible reg name    tables.  Return the classification if found, or REG_TYPE_MAX if not    present.  */
end_comment

begin_function
specifier|static
name|enum
name|arm_reg_type
name|arm_reg_parse_any
parameter_list|(
name|cp
parameter_list|)
name|char
modifier|*
name|cp
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
operator|(
name|int
operator|)
name|REG_TYPE_FIRST
init|;
name|i
operator|<
operator|(
name|int
operator|)
name|REG_TYPE_MAX
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|arm_reg_parse
argument_list|(
operator|&
name|cp
argument_list|,
name|all_reg_maps
index|[
name|i
index|]
operator|.
name|htab
argument_list|)
operator|!=
name|FAIL
condition|)
return|return
operator|(
expr|enum
name|arm_reg_type
operator|)
name|i
return|;
return|return
name|REG_TYPE_MAX
return|;
block|}
end_function

begin_function
name|void
name|md_apply_fix3
parameter_list|(
name|fixP
parameter_list|,
name|valP
parameter_list|,
name|seg
parameter_list|)
name|fixS
modifier|*
name|fixP
decl_stmt|;
name|valueT
modifier|*
name|valP
decl_stmt|;
name|segT
name|seg
decl_stmt|;
block|{
name|offsetT
name|value
init|=
operator|*
name|valP
decl_stmt|;
name|offsetT
name|newval
decl_stmt|;
name|unsigned
name|int
name|newimm
decl_stmt|;
name|unsigned
name|long
name|temp
decl_stmt|;
name|int
name|sign
decl_stmt|;
name|char
modifier|*
name|buf
init|=
name|fixP
operator|->
name|fx_where
operator|+
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_literal
decl_stmt|;
name|arm_fix_data
modifier|*
name|arm_data
init|=
operator|(
name|arm_fix_data
operator|*
operator|)
name|fixP
operator|->
name|tc_fix_data
decl_stmt|;
name|assert
argument_list|(
name|fixP
operator|->
name|fx_r_type
operator|<
name|BFD_RELOC_UNUSED
argument_list|)
expr_stmt|;
comment|/* Note whether this will delete the relocation.  */
if|#
directive|if
literal|0
comment|/* Patch from REarnshaw to JDavis (disabled for the moment, since it      doesn't work fully.)  */
block|if ((fixP->fx_addsy == 0 || symbol_constant_p (fixP->fx_addsy))&& !fixP->fx_pcrel)
else|#
directive|else
if|if
condition|(
name|fixP
operator|->
name|fx_addsy
operator|==
literal|0
operator|&&
operator|!
name|fixP
operator|->
name|fx_pcrel
condition|)
endif|#
directive|endif
name|fixP
operator|->
name|fx_done
operator|=
literal|1
expr_stmt|;
comment|/* If this symbol is in a different section then we need to leave it for      the linker to deal with.  Unfortunately, md_pcrel_from can't tell,      so we have to undo it's effects here.  */
if|if
condition|(
name|fixP
operator|->
name|fx_pcrel
condition|)
block|{
if|if
condition|(
name|fixP
operator|->
name|fx_addsy
operator|!=
name|NULL
operator|&&
name|S_IS_DEFINED
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
operator|&&
name|S_GET_SEGMENT
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
operator|!=
name|seg
condition|)
block|{
if|if
condition|(
name|target_oabi
operator|&&
operator|(
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_ARM_PCREL_BRANCH
operator|||
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_ARM_PCREL_BLX
operator|)
condition|)
name|value
operator|=
literal|0
expr_stmt|;
else|else
name|value
operator|+=
name|md_pcrel_from
argument_list|(
name|fixP
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Remember value for emit_reloc.  */
name|fixP
operator|->
name|fx_addnumber
operator|=
name|value
expr_stmt|;
switch|switch
condition|(
name|fixP
operator|->
name|fx_r_type
condition|)
block|{
case|case
name|BFD_RELOC_ARM_IMMEDIATE
case|:
name|newimm
operator|=
name|validate_immediate
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|temp
operator|=
name|md_chars_to_number
argument_list|(
name|buf
argument_list|,
name|INSN_SIZE
argument_list|)
expr_stmt|;
comment|/* If the instruction will fail, see if we can fix things up by 	 changing the opcode.  */
if|if
condition|(
name|newimm
operator|==
operator|(
name|unsigned
name|int
operator|)
name|FAIL
operator|&&
operator|(
name|newimm
operator|=
name|negate_data_op
argument_list|(
operator|&
name|temp
argument_list|,
name|value
argument_list|)
operator|)
operator|==
operator|(
name|unsigned
name|int
operator|)
name|FAIL
condition|)
block|{
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"invalid constant (%lx) after fixup"
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|value
argument_list|)
expr_stmt|;
break|break;
block|}
name|newimm
operator||=
operator|(
name|temp
operator|&
literal|0xfffff000
operator|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|buf
argument_list|,
operator|(
name|valueT
operator|)
name|newimm
argument_list|,
name|INSN_SIZE
argument_list|)
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_ARM_ADRL_IMMEDIATE
case|:
block|{
name|unsigned
name|int
name|highpart
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|newinsn
init|=
literal|0xe1a00000
decl_stmt|;
comment|/* nop.  */
name|newimm
operator|=
name|validate_immediate
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|temp
operator|=
name|md_chars_to_number
argument_list|(
name|buf
argument_list|,
name|INSN_SIZE
argument_list|)
expr_stmt|;
comment|/* If the instruction will fail, see if we can fix things up by 	   changing the opcode.  */
if|if
condition|(
name|newimm
operator|==
operator|(
name|unsigned
name|int
operator|)
name|FAIL
operator|&&
operator|(
name|newimm
operator|=
name|negate_data_op
argument_list|(
operator|&
name|temp
argument_list|,
name|value
argument_list|)
operator|)
operator|==
operator|(
name|unsigned
name|int
operator|)
name|FAIL
condition|)
block|{
comment|/* No ?  OK - try using two ADD instructions to generate                the value.  */
name|newimm
operator|=
name|validate_immediate_twopart
argument_list|(
name|value
argument_list|,
operator|&
name|highpart
argument_list|)
expr_stmt|;
comment|/* Yes - then make sure that the second instruction is                also an add.  */
if|if
condition|(
name|newimm
operator|!=
operator|(
name|unsigned
name|int
operator|)
name|FAIL
condition|)
name|newinsn
operator|=
name|temp
expr_stmt|;
comment|/* Still No ?  Try using a negated value.  */
elseif|else
if|if
condition|(
operator|(
name|newimm
operator|=
name|validate_immediate_twopart
argument_list|(
operator|-
name|value
argument_list|,
operator|&
name|highpart
argument_list|)
operator|)
operator|!=
operator|(
name|unsigned
name|int
operator|)
name|FAIL
condition|)
name|temp
operator|=
name|newinsn
operator|=
operator|(
name|temp
operator|&
name|OPCODE_MASK
operator|)
operator||
name|OPCODE_SUB
operator|<<
name|DATA_OP_SHIFT
expr_stmt|;
comment|/* Otherwise - give up.  */
else|else
block|{
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"unable to compute ADRL instructions for PC offset of 0x%lx"
argument_list|)
argument_list|,
name|value
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Replace the first operand in the 2nd instruction (which 	       is the PC) with the destination register.  We have 	       already added in the PC in the first instruction and we 	       do not want to do it again.  */
name|newinsn
operator|&=
operator|~
literal|0xf0000
expr_stmt|;
name|newinsn
operator||=
operator|(
operator|(
name|newinsn
operator|&
literal|0x0f000
operator|)
operator|<<
literal|4
operator|)
expr_stmt|;
block|}
name|newimm
operator||=
operator|(
name|temp
operator|&
literal|0xfffff000
operator|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|buf
argument_list|,
operator|(
name|valueT
operator|)
name|newimm
argument_list|,
name|INSN_SIZE
argument_list|)
expr_stmt|;
name|highpart
operator||=
operator|(
name|newinsn
operator|&
literal|0xfffff000
operator|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|buf
operator|+
name|INSN_SIZE
argument_list|,
operator|(
name|valueT
operator|)
name|highpart
argument_list|,
name|INSN_SIZE
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|BFD_RELOC_ARM_OFFSET_IMM
case|:
name|sign
operator|=
name|value
operator|>=
literal|0
expr_stmt|;
if|if
condition|(
name|value
operator|<
literal|0
condition|)
name|value
operator|=
operator|-
name|value
expr_stmt|;
if|if
condition|(
name|validate_offset_imm
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
operator|==
name|FAIL
condition|)
block|{
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"bad immediate value for offset (%ld)"
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|value
argument_list|)
expr_stmt|;
break|break;
block|}
name|newval
operator|=
name|md_chars_to_number
argument_list|(
name|buf
argument_list|,
name|INSN_SIZE
argument_list|)
expr_stmt|;
name|newval
operator|&=
literal|0xff7ff000
expr_stmt|;
name|newval
operator||=
name|value
operator||
operator|(
name|sign
condition|?
name|INDEX_UP
else|:
literal|0
operator|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|buf
argument_list|,
name|newval
argument_list|,
name|INSN_SIZE
argument_list|)
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_ARM_OFFSET_IMM8
case|:
case|case
name|BFD_RELOC_ARM_HWLITERAL
case|:
name|sign
operator|=
name|value
operator|>=
literal|0
expr_stmt|;
if|if
condition|(
name|value
operator|<
literal|0
condition|)
name|value
operator|=
operator|-
name|value
expr_stmt|;
if|if
condition|(
name|validate_offset_imm
argument_list|(
name|value
argument_list|,
literal|1
argument_list|)
operator|==
name|FAIL
condition|)
block|{
if|if
condition|(
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_ARM_HWLITERAL
condition|)
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"invalid literal constant: pool needs to be closer"
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"bad immediate value for half-word offset (%ld)"
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|value
argument_list|)
expr_stmt|;
break|break;
block|}
name|newval
operator|=
name|md_chars_to_number
argument_list|(
name|buf
argument_list|,
name|INSN_SIZE
argument_list|)
expr_stmt|;
name|newval
operator|&=
literal|0xff7ff0f0
expr_stmt|;
name|newval
operator||=
operator|(
operator|(
name|value
operator|>>
literal|4
operator|)
operator|<<
literal|8
operator|)
operator||
operator|(
name|value
operator|&
literal|0xf
operator|)
operator||
operator|(
name|sign
condition|?
name|INDEX_UP
else|:
literal|0
operator|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|buf
argument_list|,
name|newval
argument_list|,
name|INSN_SIZE
argument_list|)
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_ARM_LITERAL
case|:
name|sign
operator|=
name|value
operator|>=
literal|0
expr_stmt|;
if|if
condition|(
name|value
operator|<
literal|0
condition|)
name|value
operator|=
operator|-
name|value
expr_stmt|;
if|if
condition|(
name|validate_offset_imm
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
operator|==
name|FAIL
condition|)
block|{
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"invalid literal constant: pool needs to be closer"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|newval
operator|=
name|md_chars_to_number
argument_list|(
name|buf
argument_list|,
name|INSN_SIZE
argument_list|)
expr_stmt|;
name|newval
operator|&=
literal|0xff7ff000
expr_stmt|;
name|newval
operator||=
name|value
operator||
operator|(
name|sign
condition|?
name|INDEX_UP
else|:
literal|0
operator|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|buf
argument_list|,
name|newval
argument_list|,
name|INSN_SIZE
argument_list|)
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_ARM_SHIFT_IMM
case|:
name|newval
operator|=
name|md_chars_to_number
argument_list|(
name|buf
argument_list|,
name|INSN_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|unsigned
name|long
operator|)
name|value
operator|)
operator|>
literal|32
operator|||
operator|(
name|value
operator|==
literal|32
operator|&&
operator|(
operator|(
operator|(
name|newval
operator|&
literal|0x60
operator|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|newval
operator|&
literal|0x60
operator|)
operator|==
literal|0x60
operator|)
operator|)
condition|)
block|{
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"shift expression is too large"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|value
operator|==
literal|0
condition|)
comment|/* Shifts of zero must be done as lsl.  */
name|newval
operator|&=
operator|~
literal|0x60
expr_stmt|;
elseif|else
if|if
condition|(
name|value
operator|==
literal|32
condition|)
name|value
operator|=
literal|0
expr_stmt|;
name|newval
operator|&=
literal|0xfffff07f
expr_stmt|;
name|newval
operator||=
operator|(
name|value
operator|&
literal|0x1f
operator|)
operator|<<
literal|7
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|buf
argument_list|,
name|newval
argument_list|,
name|INSN_SIZE
argument_list|)
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_ARM_SWI
case|:
if|if
condition|(
name|arm_data
operator|->
name|thumb_mode
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|unsigned
name|long
operator|)
name|value
operator|)
operator|>
literal|0xff
condition|)
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"invalid swi expression"
argument_list|)
argument_list|)
expr_stmt|;
name|newval
operator|=
name|md_chars_to_number
argument_list|(
name|buf
argument_list|,
name|THUMB_SIZE
argument_list|)
operator|&
literal|0xff00
expr_stmt|;
name|newval
operator||=
name|value
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|buf
argument_list|,
name|newval
argument_list|,
name|THUMB_SIZE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
operator|(
name|unsigned
name|long
operator|)
name|value
operator|)
operator|>
literal|0x00ffffff
condition|)
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"invalid swi expression"
argument_list|)
argument_list|)
expr_stmt|;
name|newval
operator|=
name|md_chars_to_number
argument_list|(
name|buf
argument_list|,
name|INSN_SIZE
argument_list|)
operator|&
literal|0xff000000
expr_stmt|;
name|newval
operator||=
name|value
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|buf
argument_list|,
name|newval
argument_list|,
name|INSN_SIZE
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|BFD_RELOC_ARM_MULTI
case|:
if|if
condition|(
operator|(
operator|(
name|unsigned
name|long
operator|)
name|value
operator|)
operator|>
literal|0xffff
condition|)
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"invalid expression in load/store multiple"
argument_list|)
argument_list|)
expr_stmt|;
name|newval
operator|=
name|value
operator||
name|md_chars_to_number
argument_list|(
name|buf
argument_list|,
name|INSN_SIZE
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|buf
argument_list|,
name|newval
argument_list|,
name|INSN_SIZE
argument_list|)
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_ARM_PCREL_BRANCH
case|:
name|newval
operator|=
name|md_chars_to_number
argument_list|(
name|buf
argument_list|,
name|INSN_SIZE
argument_list|)
expr_stmt|;
comment|/* Sign-extend a 24-bit number.  */
define|#
directive|define
name|SEXT24
parameter_list|(
name|x
parameter_list|)
value|((((x)& 0xffffff) ^ (~ 0x7fffff)) + 0x800000)
ifdef|#
directive|ifdef
name|OBJ_ELF
if|if
condition|(
operator|!
name|target_oabi
condition|)
name|value
operator|=
name|fixP
operator|->
name|fx_offset
expr_stmt|;
endif|#
directive|endif
comment|/* We are going to store value (shifted right by two) in the 	 instruction, in a 24 bit, signed field.  Thus we need to check 	 that none of the top 8 bits of the shifted value (top 7 bits of          the unshifted, unsigned value) are set, or that they are all set.  */
if|if
condition|(
operator|(
name|value
operator|&
operator|~
operator|(
operator|(
name|offsetT
operator|)
literal|0x1ffffff
operator|)
operator|)
operator|!=
literal|0
operator|&&
operator|(
operator|(
name|value
operator|&
operator|~
operator|(
operator|(
name|offsetT
operator|)
literal|0x1ffffff
operator|)
operator|)
operator|!=
operator|~
operator|(
operator|(
name|offsetT
operator|)
literal|0x1ffffff
operator|)
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|OBJ_ELF
comment|/* Normally we would be stuck at this point, since we cannot store 	     the absolute address that is the destination of the branch in the 	     24 bits of the branch instruction.  If however, we happen to know 	     that the destination of the branch is in the same section as the 	     branch instruciton itself, then we can compute the relocation for 	     ourselves and not have to bother the linker with it.  	     FIXME: The tests for OBJ_ELF and ! target_oabi are only here 	     because I have not worked out how to do this for OBJ_COFF or 	     target_oabi.  */
if|if
condition|(
operator|!
name|target_oabi
operator|&&
name|fixP
operator|->
name|fx_addsy
operator|!=
name|NULL
operator|&&
name|S_IS_DEFINED
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
operator|&&
name|S_GET_SEGMENT
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
operator|==
name|seg
condition|)
block|{
comment|/* Get pc relative value to go into the branch.  */
name|value
operator|=
operator|*
name|valP
expr_stmt|;
comment|/* Permit a backward branch provided that enough bits 		 are set.  Allow a forwards branch, provided that 		 enough bits are clear.  */
if|if
condition|(
operator|(
name|value
operator|&
operator|~
operator|(
operator|(
name|offsetT
operator|)
literal|0x1ffffff
operator|)
operator|)
operator|==
operator|~
operator|(
operator|(
name|offsetT
operator|)
literal|0x1ffffff
operator|)
operator|||
operator|(
name|value
operator|&
operator|~
operator|(
operator|(
name|offsetT
operator|)
literal|0x1ffffff
operator|)
operator|)
operator|==
literal|0
condition|)
name|fixP
operator|->
name|fx_done
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|fixP
operator|->
name|fx_done
condition|)
endif|#
directive|endif
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"GAS can't handle same-section branch dest>= 0x04000000"
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|value
operator|>>=
literal|2
expr_stmt|;
name|value
operator|+=
name|SEXT24
argument_list|(
name|newval
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|value
operator|&
operator|~
operator|(
operator|(
name|offsetT
operator|)
literal|0xffffff
operator|)
operator|)
operator|!=
literal|0
operator|&&
operator|(
operator|(
name|value
operator|&
operator|~
operator|(
operator|(
name|offsetT
operator|)
literal|0xffffff
operator|)
operator|)
operator|!=
operator|~
operator|(
operator|(
name|offsetT
operator|)
literal|0xffffff
operator|)
operator|)
condition|)
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"out of range branch"
argument_list|)
argument_list|)
expr_stmt|;
name|newval
operator|=
operator|(
name|value
operator|&
literal|0x00ffffff
operator|)
operator||
operator|(
name|newval
operator|&
literal|0xff000000
operator|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|buf
argument_list|,
name|newval
argument_list|,
name|INSN_SIZE
argument_list|)
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_ARM_PCREL_BLX
case|:
block|{
name|offsetT
name|hbit
decl_stmt|;
name|newval
operator|=
name|md_chars_to_number
argument_list|(
name|buf
argument_list|,
name|INSN_SIZE
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|OBJ_ELF
if|if
condition|(
operator|!
name|target_oabi
condition|)
name|value
operator|=
name|fixP
operator|->
name|fx_offset
expr_stmt|;
endif|#
directive|endif
name|hbit
operator|=
operator|(
name|value
operator|>>
literal|1
operator|)
operator|&
literal|1
expr_stmt|;
name|value
operator|=
operator|(
name|value
operator|>>
literal|2
operator|)
operator|&
literal|0x00ffffff
expr_stmt|;
name|value
operator|=
operator|(
name|value
operator|+
operator|(
name|newval
operator|&
literal|0x00ffffff
operator|)
operator|)
operator|&
literal|0x00ffffff
expr_stmt|;
name|newval
operator|=
name|value
operator||
operator|(
name|newval
operator|&
literal|0xfe000000
operator|)
operator||
operator|(
name|hbit
operator|<<
literal|24
operator|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|buf
argument_list|,
name|newval
argument_list|,
name|INSN_SIZE
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|BFD_RELOC_THUMB_PCREL_BRANCH9
case|:
comment|/* Conditional branch.  */
name|newval
operator|=
name|md_chars_to_number
argument_list|(
name|buf
argument_list|,
name|THUMB_SIZE
argument_list|)
expr_stmt|;
block|{
name|addressT
name|diff
init|=
operator|(
name|newval
operator|&
literal|0xff
operator|)
operator|<<
literal|1
decl_stmt|;
if|if
condition|(
name|diff
operator|&
literal|0x100
condition|)
name|diff
operator||=
operator|~
literal|0xff
expr_stmt|;
name|value
operator|+=
name|diff
expr_stmt|;
if|if
condition|(
operator|(
name|value
operator|&
operator|~
literal|0xff
operator|)
operator|&&
operator|(
operator|(
name|value
operator|&
operator|~
literal|0xff
operator|)
operator|!=
operator|~
literal|0xff
operator|)
condition|)
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"branch out of range"
argument_list|)
argument_list|)
expr_stmt|;
name|newval
operator|=
operator|(
name|newval
operator|&
literal|0xff00
operator|)
operator||
operator|(
operator|(
name|value
operator|&
literal|0x1ff
operator|)
operator|>>
literal|1
operator|)
expr_stmt|;
block|}
name|md_number_to_chars
argument_list|(
name|buf
argument_list|,
name|newval
argument_list|,
name|THUMB_SIZE
argument_list|)
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_THUMB_PCREL_BRANCH12
case|:
comment|/* Unconditional branch.  */
name|newval
operator|=
name|md_chars_to_number
argument_list|(
name|buf
argument_list|,
name|THUMB_SIZE
argument_list|)
expr_stmt|;
block|{
name|addressT
name|diff
init|=
operator|(
name|newval
operator|&
literal|0x7ff
operator|)
operator|<<
literal|1
decl_stmt|;
if|if
condition|(
name|diff
operator|&
literal|0x800
condition|)
name|diff
operator||=
operator|~
literal|0x7ff
expr_stmt|;
name|value
operator|+=
name|diff
expr_stmt|;
if|if
condition|(
operator|(
name|value
operator|&
operator|~
literal|0x7ff
operator|)
operator|&&
operator|(
operator|(
name|value
operator|&
operator|~
literal|0x7ff
operator|)
operator|!=
operator|~
literal|0x7ff
operator|)
condition|)
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"branch out of range"
argument_list|)
argument_list|)
expr_stmt|;
name|newval
operator|=
operator|(
name|newval
operator|&
literal|0xf800
operator|)
operator||
operator|(
operator|(
name|value
operator|&
literal|0xfff
operator|)
operator|>>
literal|1
operator|)
expr_stmt|;
block|}
name|md_number_to_chars
argument_list|(
name|buf
argument_list|,
name|newval
argument_list|,
name|THUMB_SIZE
argument_list|)
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_THUMB_PCREL_BLX
case|:
case|case
name|BFD_RELOC_THUMB_PCREL_BRANCH23
case|:
block|{
name|offsetT
name|newval2
decl_stmt|;
name|addressT
name|diff
decl_stmt|;
name|newval
operator|=
name|md_chars_to_number
argument_list|(
name|buf
argument_list|,
name|THUMB_SIZE
argument_list|)
expr_stmt|;
name|newval2
operator|=
name|md_chars_to_number
argument_list|(
name|buf
operator|+
name|THUMB_SIZE
argument_list|,
name|THUMB_SIZE
argument_list|)
expr_stmt|;
name|diff
operator|=
operator|(
operator|(
name|newval
operator|&
literal|0x7ff
operator|)
operator|<<
literal|12
operator|)
operator||
operator|(
operator|(
name|newval2
operator|&
literal|0x7ff
operator|)
operator|<<
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|diff
operator|&
literal|0x400000
condition|)
name|diff
operator||=
operator|~
literal|0x3fffff
expr_stmt|;
ifdef|#
directive|ifdef
name|OBJ_ELF
name|value
operator|=
name|fixP
operator|->
name|fx_offset
expr_stmt|;
endif|#
directive|endif
name|value
operator|+=
name|diff
expr_stmt|;
if|if
condition|(
operator|(
name|value
operator|&
operator|~
literal|0x3fffff
operator|)
operator|&&
operator|(
operator|(
name|value
operator|&
operator|~
literal|0x3fffff
operator|)
operator|!=
operator|~
literal|0x3fffff
operator|)
condition|)
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"branch with link out of range"
argument_list|)
argument_list|)
expr_stmt|;
name|newval
operator|=
operator|(
name|newval
operator|&
literal|0xf800
operator|)
operator||
operator|(
operator|(
name|value
operator|&
literal|0x7fffff
operator|)
operator|>>
literal|12
operator|)
expr_stmt|;
name|newval2
operator|=
operator|(
name|newval2
operator|&
literal|0xf800
operator|)
operator||
operator|(
operator|(
name|value
operator|&
literal|0xfff
operator|)
operator|>>
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_THUMB_PCREL_BLX
condition|)
comment|/* Remove bit zero of the adjusted offset.  Bit zero can only be 	     set if the upper insn is at a half-word boundary, since the 	     destination address, an ARM instruction, must always be on a 	     word boundary.  The semantics of the BLX (1) instruction, however, 	     are that bit zero in the offset must always be zero, and the 	     corresponding bit one in the target address will be set from bit 	     one of the source address.  */
name|newval2
operator|&=
operator|~
literal|1
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|buf
argument_list|,
name|newval
argument_list|,
name|THUMB_SIZE
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|buf
operator|+
name|THUMB_SIZE
argument_list|,
name|newval2
argument_list|,
name|THUMB_SIZE
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|BFD_RELOC_8
case|:
if|if
condition|(
name|fixP
operator|->
name|fx_done
operator|||
name|fixP
operator|->
name|fx_pcrel
condition|)
name|md_number_to_chars
argument_list|(
name|buf
argument_list|,
name|value
argument_list|,
literal|1
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|OBJ_ELF
elseif|else
if|if
condition|(
operator|!
name|target_oabi
condition|)
block|{
name|value
operator|=
name|fixP
operator|->
name|fx_offset
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|buf
argument_list|,
name|value
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
break|break;
case|case
name|BFD_RELOC_16
case|:
if|if
condition|(
name|fixP
operator|->
name|fx_done
operator|||
name|fixP
operator|->
name|fx_pcrel
condition|)
name|md_number_to_chars
argument_list|(
name|buf
argument_list|,
name|value
argument_list|,
literal|2
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|OBJ_ELF
elseif|else
if|if
condition|(
operator|!
name|target_oabi
condition|)
block|{
name|value
operator|=
name|fixP
operator|->
name|fx_offset
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|buf
argument_list|,
name|value
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
break|break;
ifdef|#
directive|ifdef
name|OBJ_ELF
case|case
name|BFD_RELOC_ARM_GOT32
case|:
case|case
name|BFD_RELOC_ARM_GOTOFF
case|:
name|md_number_to_chars
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|,
literal|4
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|BFD_RELOC_RVA
case|:
case|case
name|BFD_RELOC_32
case|:
if|if
condition|(
name|fixP
operator|->
name|fx_done
operator|||
name|fixP
operator|->
name|fx_pcrel
condition|)
name|md_number_to_chars
argument_list|(
name|buf
argument_list|,
name|value
argument_list|,
literal|4
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|OBJ_ELF
elseif|else
if|if
condition|(
operator|!
name|target_oabi
condition|)
block|{
name|value
operator|=
name|fixP
operator|->
name|fx_offset
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|buf
argument_list|,
name|value
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
break|break;
ifdef|#
directive|ifdef
name|OBJ_ELF
case|case
name|BFD_RELOC_ARM_PLT32
case|:
comment|/* It appears the instruction is fully prepared at this point.  */
break|break;
endif|#
directive|endif
case|case
name|BFD_RELOC_ARM_GOTPC
case|:
name|md_number_to_chars
argument_list|(
name|buf
argument_list|,
name|value
argument_list|,
literal|4
argument_list|)
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_ARM_CP_OFF_IMM
case|:
name|sign
operator|=
name|value
operator|>=
literal|0
expr_stmt|;
if|if
condition|(
name|value
operator|<
operator|-
literal|1023
operator|||
name|value
operator|>
literal|1023
operator|||
operator|(
name|value
operator|&
literal|3
operator|)
condition|)
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"illegal value for co-processor offset"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|<
literal|0
condition|)
name|value
operator|=
operator|-
name|value
expr_stmt|;
name|newval
operator|=
name|md_chars_to_number
argument_list|(
name|buf
argument_list|,
name|INSN_SIZE
argument_list|)
operator|&
literal|0xff7fff00
expr_stmt|;
name|newval
operator||=
operator|(
name|value
operator|>>
literal|2
operator|)
operator||
operator|(
name|sign
condition|?
name|INDEX_UP
else|:
literal|0
operator|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|buf
argument_list|,
name|newval
argument_list|,
name|INSN_SIZE
argument_list|)
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_ARM_THUMB_OFFSET
case|:
name|newval
operator|=
name|md_chars_to_number
argument_list|(
name|buf
argument_list|,
name|THUMB_SIZE
argument_list|)
expr_stmt|;
comment|/* Exactly what ranges, and where the offset is inserted depends 	 on the type of instruction, we can establish this from the 	 top 4 bits.  */
switch|switch
condition|(
name|newval
operator|>>
literal|12
condition|)
block|{
case|case
literal|4
case|:
comment|/* PC load.  */
comment|/* Thumb PC loads are somewhat odd, bit 1 of the PC is 	     forced to zero for these loads, so we will need to round 	     up the offset if the instruction address is not word 	     aligned (since the final address produced must be, and 	     we can only describe word-aligned immediate offsets).  */
if|if
condition|(
operator|(
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_address
operator|+
name|fixP
operator|->
name|fx_where
operator|+
name|value
operator|)
operator|&
literal|3
condition|)
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"invalid offset, target not word aligned (0x%08X)"
argument_list|)
argument_list|,
call|(
name|unsigned
name|int
call|)
argument_list|(
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_address
operator|+
name|fixP
operator|->
name|fx_where
operator|+
name|value
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|value
operator|+
literal|2
operator|)
operator|&
operator|~
literal|0x3fe
condition|)
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"invalid offset, value too big (0x%08lX)"
argument_list|)
argument_list|,
name|value
argument_list|)
expr_stmt|;
comment|/* Round up, since pc will be rounded down.  */
name|newval
operator||=
operator|(
name|value
operator|+
literal|2
operator|)
operator|>>
literal|2
expr_stmt|;
break|break;
case|case
literal|9
case|:
comment|/* SP load/store.  */
if|if
condition|(
name|value
operator|&
operator|~
literal|0x3fc
condition|)
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"invalid offset, value too big (0x%08lX)"
argument_list|)
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|newval
operator||=
name|value
operator|>>
literal|2
expr_stmt|;
break|break;
case|case
literal|6
case|:
comment|/* Word load/store.  */
if|if
condition|(
name|value
operator|&
operator|~
literal|0x7c
condition|)
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"invalid offset, value too big (0x%08lX)"
argument_list|)
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|newval
operator||=
name|value
operator|<<
literal|4
expr_stmt|;
comment|/* 6 - 2.  */
break|break;
case|case
literal|7
case|:
comment|/* Byte load/store.  */
if|if
condition|(
name|value
operator|&
operator|~
literal|0x1f
condition|)
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"invalid offset, value too big (0x%08lX)"
argument_list|)
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|newval
operator||=
name|value
operator|<<
literal|6
expr_stmt|;
break|break;
case|case
literal|8
case|:
comment|/* Halfword load/store.  */
if|if
condition|(
name|value
operator|&
operator|~
literal|0x3e
condition|)
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"invalid offset, value too big (0x%08lX)"
argument_list|)
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|newval
operator||=
name|value
operator|<<
literal|5
expr_stmt|;
comment|/* 6 - 1.  */
break|break;
default|default:
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
literal|"Unable to process relocation for thumb opcode: %lx"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|newval
argument_list|)
expr_stmt|;
break|break;
block|}
name|md_number_to_chars
argument_list|(
name|buf
argument_list|,
name|newval
argument_list|,
name|THUMB_SIZE
argument_list|)
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_ARM_THUMB_ADD
case|:
comment|/* This is a complicated relocation, since we use it for all of          the following immediate relocations:  	    3bit ADD/SUB 	    8bit ADD/SUB 	    9bit ADD/SUB SP word-aligned 	   10bit ADD PC/SP word-aligned           The type of instruction being processed is encoded in the          instruction field:  	   0x8000  SUB 	   0x00F0  Rd 	   0x000F  Rs       */
name|newval
operator|=
name|md_chars_to_number
argument_list|(
name|buf
argument_list|,
name|THUMB_SIZE
argument_list|)
expr_stmt|;
block|{
name|int
name|rd
init|=
operator|(
name|newval
operator|>>
literal|4
operator|)
operator|&
literal|0xf
decl_stmt|;
name|int
name|rs
init|=
name|newval
operator|&
literal|0xf
decl_stmt|;
name|int
name|subtract
init|=
name|newval
operator|&
literal|0x8000
decl_stmt|;
if|if
condition|(
name|rd
operator|==
name|REG_SP
condition|)
block|{
if|if
condition|(
name|value
operator|&
operator|~
literal|0x1fc
condition|)
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"invalid immediate for stack address calculation"
argument_list|)
argument_list|)
expr_stmt|;
name|newval
operator|=
name|subtract
condition|?
name|T_OPCODE_SUB_ST
else|:
name|T_OPCODE_ADD_ST
expr_stmt|;
name|newval
operator||=
name|value
operator|>>
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rs
operator|==
name|REG_PC
operator|||
name|rs
operator|==
name|REG_SP
condition|)
block|{
if|if
condition|(
name|subtract
operator|||
name|value
operator|&
operator|~
literal|0x3fc
condition|)
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"invalid immediate for address calculation (value = 0x%08lX)"
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|value
argument_list|)
expr_stmt|;
name|newval
operator|=
operator|(
name|rs
operator|==
name|REG_PC
condition|?
name|T_OPCODE_ADD_PC
else|:
name|T_OPCODE_ADD_SP
operator|)
expr_stmt|;
name|newval
operator||=
name|rd
operator|<<
literal|8
expr_stmt|;
name|newval
operator||=
name|value
operator|>>
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rs
operator|==
name|rd
condition|)
block|{
if|if
condition|(
name|value
operator|&
operator|~
literal|0xff
condition|)
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"invalid 8bit immediate"
argument_list|)
argument_list|)
expr_stmt|;
name|newval
operator|=
name|subtract
condition|?
name|T_OPCODE_SUB_I8
else|:
name|T_OPCODE_ADD_I8
expr_stmt|;
name|newval
operator||=
operator|(
name|rd
operator|<<
literal|8
operator|)
operator||
name|value
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|value
operator|&
operator|~
literal|0x7
condition|)
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"invalid 3bit immediate"
argument_list|)
argument_list|)
expr_stmt|;
name|newval
operator|=
name|subtract
condition|?
name|T_OPCODE_SUB_I3
else|:
name|T_OPCODE_ADD_I3
expr_stmt|;
name|newval
operator||=
name|rd
operator||
operator|(
name|rs
operator|<<
literal|3
operator|)
operator||
operator|(
name|value
operator|<<
literal|6
operator|)
expr_stmt|;
block|}
block|}
name|md_number_to_chars
argument_list|(
name|buf
argument_list|,
name|newval
argument_list|,
name|THUMB_SIZE
argument_list|)
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_ARM_THUMB_IMM
case|:
name|newval
operator|=
name|md_chars_to_number
argument_list|(
name|buf
argument_list|,
name|THUMB_SIZE
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|newval
operator|>>
literal|11
condition|)
block|{
case|case
literal|0x04
case|:
comment|/* 8bit immediate MOV.  */
case|case
literal|0x05
case|:
comment|/* 8bit immediate CMP.  */
if|if
condition|(
name|value
operator|<
literal|0
operator|||
name|value
operator|>
literal|255
condition|)
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"invalid immediate: %ld is too large"
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|value
argument_list|)
expr_stmt|;
name|newval
operator||=
name|value
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|md_number_to_chars
argument_list|(
name|buf
argument_list|,
name|newval
argument_list|,
name|THUMB_SIZE
argument_list|)
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_ARM_THUMB_SHIFT
case|:
comment|/* 5bit shift value (0..31).  */
if|if
condition|(
name|value
operator|<
literal|0
operator|||
name|value
operator|>
literal|31
condition|)
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"illegal Thumb shift value: %ld"
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|value
argument_list|)
expr_stmt|;
name|newval
operator|=
name|md_chars_to_number
argument_list|(
name|buf
argument_list|,
name|THUMB_SIZE
argument_list|)
operator|&
literal|0xf03f
expr_stmt|;
name|newval
operator||=
name|value
operator|<<
literal|6
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|buf
argument_list|,
name|newval
argument_list|,
name|THUMB_SIZE
argument_list|)
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_VTABLE_INHERIT
case|:
case|case
name|BFD_RELOC_VTABLE_ENTRY
case|:
name|fixP
operator|->
name|fx_done
operator|=
literal|0
expr_stmt|;
return|return;
case|case
name|BFD_RELOC_NONE
case|:
default|default:
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"bad relocation fixup type (%d)"
argument_list|)
argument_list|,
name|fixP
operator|->
name|fx_r_type
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Translate internal representation of relocation info to BFD target    format.  */
end_comment

begin_function
name|arelent
modifier|*
name|tc_gen_reloc
parameter_list|(
name|section
parameter_list|,
name|fixp
parameter_list|)
name|asection
modifier|*
name|section
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|fixS
modifier|*
name|fixp
decl_stmt|;
block|{
name|arelent
modifier|*
name|reloc
decl_stmt|;
name|bfd_reloc_code_real_type
name|code
decl_stmt|;
name|reloc
operator|=
operator|(
name|arelent
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|arelent
argument_list|)
argument_list|)
expr_stmt|;
name|reloc
operator|->
name|sym_ptr_ptr
operator|=
operator|(
name|asymbol
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|asymbol
operator|*
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|reloc
operator|->
name|sym_ptr_ptr
operator|=
name|symbol_get_bfdsym
argument_list|(
name|fixp
operator|->
name|fx_addsy
argument_list|)
expr_stmt|;
name|reloc
operator|->
name|address
operator|=
name|fixp
operator|->
name|fx_frag
operator|->
name|fr_address
operator|+
name|fixp
operator|->
name|fx_where
expr_stmt|;
comment|/* @@ Why fx_addnumber sometimes and fx_offset other times?  */
ifndef|#
directive|ifndef
name|OBJ_ELF
if|if
condition|(
name|fixp
operator|->
name|fx_pcrel
operator|==
literal|0
condition|)
name|reloc
operator|->
name|addend
operator|=
name|fixp
operator|->
name|fx_offset
expr_stmt|;
else|else
name|reloc
operator|->
name|addend
operator|=
name|fixp
operator|->
name|fx_offset
operator|=
name|reloc
operator|->
name|address
expr_stmt|;
else|#
directive|else
comment|/* OBJ_ELF */
name|reloc
operator|->
name|addend
operator|=
name|fixp
operator|->
name|fx_offset
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|fixp
operator|->
name|fx_r_type
condition|)
block|{
case|case
name|BFD_RELOC_8
case|:
if|if
condition|(
name|fixp
operator|->
name|fx_pcrel
condition|)
block|{
name|code
operator|=
name|BFD_RELOC_8_PCREL
expr_stmt|;
break|break;
block|}
case|case
name|BFD_RELOC_16
case|:
if|if
condition|(
name|fixp
operator|->
name|fx_pcrel
condition|)
block|{
name|code
operator|=
name|BFD_RELOC_16_PCREL
expr_stmt|;
break|break;
block|}
case|case
name|BFD_RELOC_32
case|:
if|if
condition|(
name|fixp
operator|->
name|fx_pcrel
condition|)
block|{
name|code
operator|=
name|BFD_RELOC_32_PCREL
expr_stmt|;
break|break;
block|}
case|case
name|BFD_RELOC_ARM_PCREL_BRANCH
case|:
case|case
name|BFD_RELOC_ARM_PCREL_BLX
case|:
case|case
name|BFD_RELOC_RVA
case|:
case|case
name|BFD_RELOC_THUMB_PCREL_BRANCH9
case|:
case|case
name|BFD_RELOC_THUMB_PCREL_BRANCH12
case|:
case|case
name|BFD_RELOC_THUMB_PCREL_BRANCH23
case|:
case|case
name|BFD_RELOC_THUMB_PCREL_BLX
case|:
case|case
name|BFD_RELOC_VTABLE_ENTRY
case|:
case|case
name|BFD_RELOC_VTABLE_INHERIT
case|:
name|code
operator|=
name|fixp
operator|->
name|fx_r_type
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_ARM_LITERAL
case|:
case|case
name|BFD_RELOC_ARM_HWLITERAL
case|:
comment|/* If this is called then the a literal has been referenced across 	 a section boundary - possibly due to an implicit dump.  */
name|as_bad_where
argument_list|(
name|fixp
operator|->
name|fx_file
argument_list|,
name|fixp
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"literal referenced across section boundary (Implicit dump?)"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
ifdef|#
directive|ifdef
name|OBJ_ELF
case|case
name|BFD_RELOC_ARM_GOT32
case|:
case|case
name|BFD_RELOC_ARM_GOTOFF
case|:
case|case
name|BFD_RELOC_ARM_PLT32
case|:
name|code
operator|=
name|fixp
operator|->
name|fx_r_type
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|BFD_RELOC_ARM_IMMEDIATE
case|:
name|as_bad_where
argument_list|(
name|fixp
operator|->
name|fx_file
argument_list|,
name|fixp
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"internal relocation (type %d) not fixed up (IMMEDIATE)"
argument_list|)
argument_list|,
name|fixp
operator|->
name|fx_r_type
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
case|case
name|BFD_RELOC_ARM_ADRL_IMMEDIATE
case|:
name|as_bad_where
argument_list|(
name|fixp
operator|->
name|fx_file
argument_list|,
name|fixp
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"ADRL used for a symbol not defined in the same file"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
case|case
name|BFD_RELOC_ARM_OFFSET_IMM
case|:
name|as_bad_where
argument_list|(
name|fixp
operator|->
name|fx_file
argument_list|,
name|fixp
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"internal_relocation (type %d) not fixed up (OFFSET_IMM)"
argument_list|)
argument_list|,
name|fixp
operator|->
name|fx_r_type
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
default|default:
block|{
name|char
modifier|*
name|type
decl_stmt|;
switch|switch
condition|(
name|fixp
operator|->
name|fx_r_type
condition|)
block|{
case|case
name|BFD_RELOC_ARM_IMMEDIATE
case|:
name|type
operator|=
literal|"IMMEDIATE"
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_ARM_OFFSET_IMM
case|:
name|type
operator|=
literal|"OFFSET_IMM"
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_ARM_OFFSET_IMM8
case|:
name|type
operator|=
literal|"OFFSET_IMM8"
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_ARM_SHIFT_IMM
case|:
name|type
operator|=
literal|"SHIFT_IMM"
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_ARM_SWI
case|:
name|type
operator|=
literal|"SWI"
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_ARM_MULTI
case|:
name|type
operator|=
literal|"MULTI"
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_ARM_CP_OFF_IMM
case|:
name|type
operator|=
literal|"CP_OFF_IMM"
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_ARM_THUMB_ADD
case|:
name|type
operator|=
literal|"THUMB_ADD"
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_ARM_THUMB_SHIFT
case|:
name|type
operator|=
literal|"THUMB_SHIFT"
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_ARM_THUMB_IMM
case|:
name|type
operator|=
literal|"THUMB_IMM"
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_ARM_THUMB_OFFSET
case|:
name|type
operator|=
literal|"THUMB_OFFSET"
expr_stmt|;
break|break;
default|default:
name|type
operator|=
name|_
argument_list|(
literal|"<unknown>"
argument_list|)
expr_stmt|;
break|break;
block|}
name|as_bad_where
argument_list|(
name|fixp
operator|->
name|fx_file
argument_list|,
name|fixp
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"cannot represent %s relocation in this object file format"
argument_list|)
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
ifdef|#
directive|ifdef
name|OBJ_ELF
if|if
condition|(
name|code
operator|==
name|BFD_RELOC_32_PCREL
operator|&&
name|GOT_symbol
operator|&&
name|fixp
operator|->
name|fx_addsy
operator|==
name|GOT_symbol
condition|)
block|{
name|code
operator|=
name|BFD_RELOC_ARM_GOTPC
expr_stmt|;
name|reloc
operator|->
name|addend
operator|=
name|fixp
operator|->
name|fx_offset
operator|=
name|reloc
operator|->
name|address
expr_stmt|;
block|}
endif|#
directive|endif
name|reloc
operator|->
name|howto
operator|=
name|bfd_reloc_type_lookup
argument_list|(
name|stdoutput
argument_list|,
name|code
argument_list|)
expr_stmt|;
if|if
condition|(
name|reloc
operator|->
name|howto
operator|==
name|NULL
condition|)
block|{
name|as_bad_where
argument_list|(
name|fixp
operator|->
name|fx_file
argument_list|,
name|fixp
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"cannot represent %s relocation in this object file format"
argument_list|)
argument_list|,
name|bfd_get_reloc_code_name
argument_list|(
name|code
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* HACK: Since arm ELF uses Rel instead of Rela, encode the      vtable entry to be used in the relocation's section offset.  */
if|if
condition|(
name|fixp
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_VTABLE_ENTRY
condition|)
name|reloc
operator|->
name|address
operator|=
name|fixp
operator|->
name|fx_offset
expr_stmt|;
return|return
name|reloc
return|;
block|}
end_function

begin_function
name|int
name|md_estimate_size_before_relax
parameter_list|(
name|fragP
parameter_list|,
name|segtype
parameter_list|)
name|fragS
modifier|*
name|fragP
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|segT
name|segtype
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"md_estimate_size_before_relax\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|output_inst
parameter_list|(
name|str
parameter_list|)
specifier|const
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|char
modifier|*
name|to
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|inst
operator|.
name|error
condition|)
block|{
name|as_bad
argument_list|(
literal|"%s -- `%s'"
argument_list|,
name|inst
operator|.
name|error
argument_list|,
name|str
argument_list|)
expr_stmt|;
return|return;
block|}
name|to
operator|=
name|frag_more
argument_list|(
name|inst
operator|.
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|thumb_mode
operator|&&
operator|(
name|inst
operator|.
name|size
operator|>
name|THUMB_SIZE
operator|)
condition|)
block|{
name|assert
argument_list|(
name|inst
operator|.
name|size
operator|==
operator|(
literal|2
operator|*
name|THUMB_SIZE
operator|)
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|to
argument_list|,
name|inst
operator|.
name|instruction
operator|>>
literal|16
argument_list|,
name|THUMB_SIZE
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|to
operator|+
name|THUMB_SIZE
argument_list|,
name|inst
operator|.
name|instruction
argument_list|,
name|THUMB_SIZE
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|inst
operator|.
name|size
operator|>
name|INSN_SIZE
condition|)
block|{
name|assert
argument_list|(
name|inst
operator|.
name|size
operator|==
operator|(
literal|2
operator|*
name|INSN_SIZE
operator|)
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|to
argument_list|,
name|inst
operator|.
name|instruction
argument_list|,
name|INSN_SIZE
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|to
operator|+
name|INSN_SIZE
argument_list|,
name|inst
operator|.
name|instruction
argument_list|,
name|INSN_SIZE
argument_list|)
expr_stmt|;
block|}
else|else
name|md_number_to_chars
argument_list|(
name|to
argument_list|,
name|inst
operator|.
name|instruction
argument_list|,
name|inst
operator|.
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|inst
operator|.
name|reloc
operator|.
name|type
operator|!=
name|BFD_RELOC_NONE
condition|)
name|fix_new_arm
argument_list|(
name|frag_now
argument_list|,
name|to
operator|-
name|frag_now
operator|->
name|fr_literal
argument_list|,
name|inst
operator|.
name|size
argument_list|,
operator|&
name|inst
operator|.
name|reloc
operator|.
name|exp
argument_list|,
name|inst
operator|.
name|reloc
operator|.
name|pc_rel
argument_list|,
name|inst
operator|.
name|reloc
operator|.
name|type
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|OBJ_ELF
name|dwarf2_emit_insn
argument_list|(
name|inst
operator|.
name|size
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|md_assemble
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|char
name|c
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|start
decl_stmt|;
comment|/* Align the instruction.      This may not be the right thing to do but ...  */
if|#
directive|if
literal|0
block|arm_align (2, 0);
endif|#
directive|endif
name|listing_prev_line
argument_list|()
expr_stmt|;
comment|/* Defined in listing.h.  */
comment|/* Align the previous label if needed.  */
if|if
condition|(
name|last_label_seen
operator|!=
name|NULL
condition|)
block|{
name|symbol_set_frag
argument_list|(
name|last_label_seen
argument_list|,
name|frag_now
argument_list|)
expr_stmt|;
name|S_SET_VALUE
argument_list|(
name|last_label_seen
argument_list|,
operator|(
name|valueT
operator|)
name|frag_now_fix
argument_list|()
argument_list|)
expr_stmt|;
name|S_SET_SEGMENT
argument_list|(
name|last_label_seen
argument_list|,
name|now_seg
argument_list|)
expr_stmt|;
block|}
name|memset
argument_list|(
operator|&
name|inst
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
name|inst
argument_list|)
argument_list|)
expr_stmt|;
name|inst
operator|.
name|reloc
operator|.
name|type
operator|=
name|BFD_RELOC_NONE
expr_stmt|;
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
comment|/* Scan up to the end of the op-code, which must end in white space or      end of string.  */
for|for
control|(
name|start
operator|=
name|p
operator|=
name|str
init|;
operator|*
name|p
operator|!=
literal|'\0'
condition|;
name|p
operator|++
control|)
if|if
condition|(
operator|*
name|p
operator|==
literal|' '
condition|)
break|break;
if|if
condition|(
name|p
operator|==
name|str
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"no operator -- statement `%s'\n"
argument_list|)
argument_list|,
name|str
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|thumb_mode
condition|)
block|{
specifier|const
name|struct
name|thumb_opcode
modifier|*
name|opcode
decl_stmt|;
name|c
operator|=
operator|*
name|p
expr_stmt|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
name|opcode
operator|=
operator|(
specifier|const
expr|struct
name|thumb_opcode
operator|*
operator|)
name|hash_find
argument_list|(
name|arm_tops_hsh
argument_list|,
name|str
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|opcode
condition|)
block|{
comment|/* Check that this instruction is supported for this CPU.  */
if|if
condition|(
name|thumb_mode
operator|==
literal|1
operator|&&
operator|(
name|opcode
operator|->
name|variant
operator|&
name|cpu_variant
operator|)
operator|==
literal|0
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"selected processor does not support `%s'"
argument_list|)
argument_list|,
name|str
argument_list|)
expr_stmt|;
return|return;
block|}
name|inst
operator|.
name|instruction
operator|=
name|opcode
operator|->
name|value
expr_stmt|;
name|inst
operator|.
name|size
operator|=
name|opcode
operator|->
name|size
expr_stmt|;
call|(
modifier|*
name|opcode
operator|->
name|parms
call|)
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|output_inst
argument_list|(
name|str
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
else|else
block|{
specifier|const
name|struct
name|asm_opcode
modifier|*
name|opcode
decl_stmt|;
name|c
operator|=
operator|*
name|p
expr_stmt|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
name|opcode
operator|=
operator|(
specifier|const
expr|struct
name|asm_opcode
operator|*
operator|)
name|hash_find
argument_list|(
name|arm_ops_hsh
argument_list|,
name|str
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|opcode
condition|)
block|{
comment|/* Check that this instruction is supported for this CPU.  */
if|if
condition|(
operator|(
name|opcode
operator|->
name|variant
operator|&
name|cpu_variant
operator|)
operator|==
literal|0
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"selected processor does not support `%s'"
argument_list|)
argument_list|,
name|str
argument_list|)
expr_stmt|;
return|return;
block|}
name|inst
operator|.
name|instruction
operator|=
name|opcode
operator|->
name|value
expr_stmt|;
name|inst
operator|.
name|size
operator|=
name|INSN_SIZE
expr_stmt|;
call|(
modifier|*
name|opcode
operator|->
name|parms
call|)
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|output_inst
argument_list|(
name|str
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* It wasn't an instruction, but it might be a register alias of the form      alias .req reg.  */
if|if
condition|(
name|create_register_alias
argument_list|(
name|str
argument_list|,
name|p
argument_list|)
condition|)
return|return;
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"bad instruction `%s'"
argument_list|)
argument_list|,
name|start
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* md_parse_option       Invocation line includes a switch not recognized by the base assembler.       See if it's a processor-specific option.          This routine is somewhat complicated by the need for backwards       compatibility (since older releases of gcc can't be changed).       The new options try to make the interface as compatible as       possible with GCC.        New options (supported) are:  	      -mcpu=<cpu name>		 Assemble for selected processor 	      -march=<architecture name> Assemble for selected architecture 	      -mfpu=<fpu architecture>	 Assemble for selected FPU. 	      -EB/-mbig-endian		 Big-endian 	      -EL/-mlittle-endian	 Little-endian 	      -k			 Generate PIC code 	      -mthumb			 Start in Thumb mode 	      -mthumb-interwork		 Code supports ARM/Thumb interworking        For now we will also provide support for   	      -mapcs-32			 32-bit Program counter 	      -mapcs-26			 26-bit Program counter 	      -macps-float		 Floats passed in FP registers 	      -mapcs-reentrant		 Reentrant code 	      -matpcs       (sometime these will probably be replaced with -mapcs=<list of options>       and -matpcs=<list of options>)        The remaining options are only supported for back-wards compatibility.       Cpu variants, the arm part is optional:               -m[arm]1                Currently not supported.               -m[arm]2, -m[arm]250    Arm 2 and Arm 250 processor               -m[arm]3                Arm 3 processor               -m[arm]6[xx],           Arm 6 processors               -m[arm]7[xx][t][[d]m]   Arm 7 processors               -m[arm]8[10]            Arm 8 processors               -m[arm]9[20][tdmi]      Arm 9 processors               -mstrongarm[110[0]]     StrongARM processors               -mxscale                XScale processors               -m[arm]v[2345[t[e]]]    Arm architectures               -mall                   All (except the ARM1)       FP variants:               -mfpa10, -mfpa11        FPA10 and 11 co-processor instructions               -mfpe-old               (No float load/store multiples) 	      -mvfpxd		      VFP Single precision 	      -mvfp		      All VFP               -mno-fpu                Disable all floating point instructions        The following CPU names are recognized: 	      arm1, arm2, arm250, arm3, arm6, arm600, arm610, arm620, 	      arm7, arm7m, arm7d, arm7dm, arm7di, arm7dmi, arm70, arm700, 	      arm700i, arm710 arm710t, arm720, arm720t, arm740t, arm710c, 	      arm7100, arm7500, arm7500fe, arm7tdmi, arm8, arm810, arm9, 	      arm920, arm920t, arm940t, arm946, arm966, arm9tdmi, arm9e, 	      arm10t arm10e, arm1020t, arm1020e, arm10200e, 	      strongarm, strongarm110, strongarm1100, strongarm1110, xscale.        */
end_comment

begin_decl_stmt
name|CONST
name|char
modifier|*
name|md_shortopts
init|=
literal|"m:k"
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|ARM_BI_ENDIAN
end_ifdef

begin_define
define|#
directive|define
name|OPTION_EB
value|(OPTION_MD_BASE + 0)
end_define

begin_define
define|#
directive|define
name|OPTION_EL
value|(OPTION_MD_BASE + 1)
end_define

begin_else
else|#
directive|else
end_else

begin_if
if|#
directive|if
name|TARGET_BYTES_BIG_ENDIAN
end_if

begin_define
define|#
directive|define
name|OPTION_EB
value|(OPTION_MD_BASE + 0)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|OPTION_EL
value|(OPTION_MD_BASE + 1)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|struct
name|option
name|md_longopts
index|[]
init|=
block|{
ifdef|#
directive|ifdef
name|OPTION_EB
block|{
literal|"EB"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_EB
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|OPTION_EL
block|{
literal|"EL"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_EL
block|}
block|,
endif|#
directive|endif
block|{
name|NULL
block|,
name|no_argument
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|size_t
name|md_longopts_size
init|=
sizeof|sizeof
argument_list|(
name|md_longopts
argument_list|)
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|arm_option_table
block|{
name|char
modifier|*
name|option
decl_stmt|;
comment|/* Option name to match.  */
name|char
modifier|*
name|help
decl_stmt|;
comment|/* Help information.  */
name|int
modifier|*
name|var
decl_stmt|;
comment|/* Variable to change.  */
name|int
name|value
decl_stmt|;
comment|/* What to change it to.  */
name|char
modifier|*
name|deprecated
decl_stmt|;
comment|/* If non-null, print this message.  */
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|arm_option_table
name|arm_opts
index|[]
init|=
block|{
block|{
literal|"k"
block|,
name|N_
argument_list|(
literal|"generate PIC code"
argument_list|)
block|,
operator|&
name|pic_code
block|,
literal|1
block|,
name|NULL
block|}
block|,
block|{
literal|"mthumb"
block|,
name|N_
argument_list|(
literal|"assemble Thumb code"
argument_list|)
block|,
operator|&
name|thumb_mode
block|,
literal|1
block|,
name|NULL
block|}
block|,
block|{
literal|"mthumb-interwork"
block|,
name|N_
argument_list|(
literal|"support ARM/Thumb interworking"
argument_list|)
block|,
operator|&
name|support_interwork
block|,
literal|1
block|,
name|NULL
block|}
block|,
block|{
literal|"moabi"
block|,
name|N_
argument_list|(
literal|"use old ABI (ELF only)"
argument_list|)
block|,
operator|&
name|target_oabi
block|,
literal|1
block|,
name|NULL
block|}
block|,
block|{
literal|"mapcs-32"
block|,
name|N_
argument_list|(
literal|"code uses 32-bit program counter"
argument_list|)
block|,
operator|&
name|uses_apcs_26
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"mapcs-26"
block|,
name|N_
argument_list|(
literal|"code uses 26-bit program counter"
argument_list|)
block|,
operator|&
name|uses_apcs_26
block|,
literal|1
block|,
name|NULL
block|}
block|,
block|{
literal|"mapcs-float"
block|,
name|N_
argument_list|(
literal|"floating point args are in fp regs"
argument_list|)
block|,
operator|&
name|uses_apcs_float
block|,
literal|1
block|,
name|NULL
block|}
block|,
block|{
literal|"mapcs-reentrant"
block|,
name|N_
argument_list|(
literal|"re-entrant code"
argument_list|)
block|,
operator|&
name|pic_code
block|,
literal|1
block|,
name|NULL
block|}
block|,
block|{
literal|"matpcs"
block|,
name|N_
argument_list|(
literal|"code is ATPCS conformant"
argument_list|)
block|,
operator|&
name|atpcs
block|,
literal|1
block|,
name|NULL
block|}
block|,
block|{
literal|"mbig-endian"
block|,
name|N_
argument_list|(
literal|"assemble for big-endian"
argument_list|)
block|,
operator|&
name|target_big_endian
block|,
literal|1
block|,
name|NULL
block|}
block|,
block|{
literal|"mlittle-endian"
block|,
name|N_
argument_list|(
literal|"assemble for little-endian"
argument_list|)
block|,
operator|&
name|target_big_endian
block|,
literal|1
block|,
name|NULL
block|}
block|,
comment|/* These are recognized by the assembler, but have no affect on code.  */
block|{
literal|"mapcs-frame"
block|,
name|N_
argument_list|(
literal|"use frame pointer"
argument_list|)
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"mapcs-stack-check"
block|,
name|N_
argument_list|(
literal|"use stack size checking"
argument_list|)
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
comment|/* DON'T add any new processors to this list -- we want the whole list      to go away...  Add them to the processors table instead.  */
block|{
literal|"marm1"
block|,
name|NULL
block|,
operator|&
name|legacy_cpu
block|,
name|ARM_ARCH_V1
block|,
name|N_
argument_list|(
literal|"use -mcpu=arm1"
argument_list|)
block|}
block|,
block|{
literal|"m1"
block|,
name|NULL
block|,
operator|&
name|legacy_cpu
block|,
name|ARM_ARCH_V1
block|,
name|N_
argument_list|(
literal|"use -mcpu=arm1"
argument_list|)
block|}
block|,
block|{
literal|"marm2"
block|,
name|NULL
block|,
operator|&
name|legacy_cpu
block|,
name|ARM_ARCH_V2
block|,
name|N_
argument_list|(
literal|"use -mcpu=arm2"
argument_list|)
block|}
block|,
block|{
literal|"m2"
block|,
name|NULL
block|,
operator|&
name|legacy_cpu
block|,
name|ARM_ARCH_V2
block|,
name|N_
argument_list|(
literal|"use -mcpu=arm2"
argument_list|)
block|}
block|,
block|{
literal|"marm250"
block|,
name|NULL
block|,
operator|&
name|legacy_cpu
block|,
name|ARM_ARCH_V2S
block|,
name|N_
argument_list|(
literal|"use -mcpu=arm250"
argument_list|)
block|}
block|,
block|{
literal|"m250"
block|,
name|NULL
block|,
operator|&
name|legacy_cpu
block|,
name|ARM_ARCH_V2S
block|,
name|N_
argument_list|(
literal|"use -mcpu=arm250"
argument_list|)
block|}
block|,
block|{
literal|"marm3"
block|,
name|NULL
block|,
operator|&
name|legacy_cpu
block|,
name|ARM_ARCH_V2S
block|,
name|N_
argument_list|(
literal|"use -mcpu=arm3"
argument_list|)
block|}
block|,
block|{
literal|"m3"
block|,
name|NULL
block|,
operator|&
name|legacy_cpu
block|,
name|ARM_ARCH_V2S
block|,
name|N_
argument_list|(
literal|"use -mcpu=arm3"
argument_list|)
block|}
block|,
block|{
literal|"marm6"
block|,
name|NULL
block|,
operator|&
name|legacy_cpu
block|,
name|ARM_ARCH_V3
block|,
name|N_
argument_list|(
literal|"use -mcpu=arm6"
argument_list|)
block|}
block|,
block|{
literal|"m6"
block|,
name|NULL
block|,
operator|&
name|legacy_cpu
block|,
name|ARM_ARCH_V3
block|,
name|N_
argument_list|(
literal|"use -mcpu=arm6"
argument_list|)
block|}
block|,
block|{
literal|"marm600"
block|,
name|NULL
block|,
operator|&
name|legacy_cpu
block|,
name|ARM_ARCH_V3
block|,
name|N_
argument_list|(
literal|"use -mcpu=arm600"
argument_list|)
block|}
block|,
block|{
literal|"m600"
block|,
name|NULL
block|,
operator|&
name|legacy_cpu
block|,
name|ARM_ARCH_V3
block|,
name|N_
argument_list|(
literal|"use -mcpu=arm600"
argument_list|)
block|}
block|,
block|{
literal|"marm610"
block|,
name|NULL
block|,
operator|&
name|legacy_cpu
block|,
name|ARM_ARCH_V3
block|,
name|N_
argument_list|(
literal|"use -mcpu=arm610"
argument_list|)
block|}
block|,
block|{
literal|"m610"
block|,
name|NULL
block|,
operator|&
name|legacy_cpu
block|,
name|ARM_ARCH_V3
block|,
name|N_
argument_list|(
literal|"use -mcpu=arm610"
argument_list|)
block|}
block|,
block|{
literal|"marm620"
block|,
name|NULL
block|,
operator|&
name|legacy_cpu
block|,
name|ARM_ARCH_V3
block|,
name|N_
argument_list|(
literal|"use -mcpu=arm620"
argument_list|)
block|}
block|,
block|{
literal|"m620"
block|,
name|NULL
block|,
operator|&
name|legacy_cpu
block|,
name|ARM_ARCH_V3
block|,
name|N_
argument_list|(
literal|"use -mcpu=arm620"
argument_list|)
block|}
block|,
block|{
literal|"marm7"
block|,
name|NULL
block|,
operator|&
name|legacy_cpu
block|,
name|ARM_ARCH_V3
block|,
name|N_
argument_list|(
literal|"use -mcpu=arm7"
argument_list|)
block|}
block|,
block|{
literal|"m7"
block|,
name|NULL
block|,
operator|&
name|legacy_cpu
block|,
name|ARM_ARCH_V3
block|,
name|N_
argument_list|(
literal|"use -mcpu=arm7"
argument_list|)
block|}
block|,
block|{
literal|"marm70"
block|,
name|NULL
block|,
operator|&
name|legacy_cpu
block|,
name|ARM_ARCH_V3
block|,
name|N_
argument_list|(
literal|"use -mcpu=arm70"
argument_list|)
block|}
block|,
block|{
literal|"m70"
block|,
name|NULL
block|,
operator|&
name|legacy_cpu
block|,
name|ARM_ARCH_V3
block|,
name|N_
argument_list|(
literal|"use -mcpu=arm70"
argument_list|)
block|}
block|,
block|{
literal|"marm700"
block|,
name|NULL
block|,
operator|&
name|legacy_cpu
block|,
name|ARM_ARCH_V3
block|,
name|N_
argument_list|(
literal|"use -mcpu=arm700"
argument_list|)
block|}
block|,
block|{
literal|"m700"
block|,
name|NULL
block|,
operator|&
name|legacy_cpu
block|,
name|ARM_ARCH_V3
block|,
name|N_
argument_list|(
literal|"use -mcpu=arm700"
argument_list|)
block|}
block|,
block|{
literal|"marm700i"
block|,
name|NULL
block|,
operator|&
name|legacy_cpu
block|,
name|ARM_ARCH_V3
block|,
name|N_
argument_list|(
literal|"use -mcpu=arm700i"
argument_list|)
block|}
block|,
block|{
literal|"m700i"
block|,
name|NULL
block|,
operator|&
name|legacy_cpu
block|,
name|ARM_ARCH_V3
block|,
name|N_
argument_list|(
literal|"use -mcpu=arm700i"
argument_list|)
block|}
block|,
block|{
literal|"marm710"
block|,
name|NULL
block|,
operator|&
name|legacy_cpu
block|,
name|ARM_ARCH_V3
block|,
name|N_
argument_list|(
literal|"use -mcpu=arm710"
argument_list|)
block|}
block|,
block|{
literal|"m710"
block|,
name|NULL
block|,
operator|&
name|legacy_cpu
block|,
name|ARM_ARCH_V3
block|,
name|N_
argument_list|(
literal|"use -mcpu=arm710"
argument_list|)
block|}
block|,
block|{
literal|"marm710c"
block|,
name|NULL
block|,
operator|&
name|legacy_cpu
block|,
name|ARM_ARCH_V3
block|,
name|N_
argument_list|(
literal|"use -mcpu=arm710c"
argument_list|)
block|}
block|,
block|{
literal|"m710c"
block|,
name|NULL
block|,
operator|&
name|legacy_cpu
block|,
name|ARM_ARCH_V3
block|,
name|N_
argument_list|(
literal|"use -mcpu=arm710c"
argument_list|)
block|}
block|,
block|{
literal|"marm720"
block|,
name|NULL
block|,
operator|&
name|legacy_cpu
block|,
name|ARM_ARCH_V3
block|,
name|N_
argument_list|(
literal|"use -mcpu=arm720"
argument_list|)
block|}
block|,
block|{
literal|"m720"
block|,
name|NULL
block|,
operator|&
name|legacy_cpu
block|,
name|ARM_ARCH_V3
block|,
name|N_
argument_list|(
literal|"use -mcpu=arm720"
argument_list|)
block|}
block|,
block|{
literal|"marm7d"
block|,
name|NULL
block|,
operator|&
name|legacy_cpu
block|,
name|ARM_ARCH_V3
block|,
name|N_
argument_list|(
literal|"use -mcpu=arm7d"
argument_list|)
block|}
block|,
block|{
literal|"m7d"
block|,
name|NULL
block|,
operator|&
name|legacy_cpu
block|,
name|ARM_ARCH_V3
block|,
name|N_
argument_list|(
literal|"use -mcpu=arm7d"
argument_list|)
block|}
block|,
block|{
literal|"marm7di"
block|,
name|NULL
block|,
operator|&
name|legacy_cpu
block|,
name|ARM_ARCH_V3
block|,
name|N_
argument_list|(
literal|"use -mcpu=arm7di"
argument_list|)
block|}
block|,
block|{
literal|"m7di"
block|,
name|NULL
block|,
operator|&
name|legacy_cpu
block|,
name|ARM_ARCH_V3
block|,
name|N_
argument_list|(
literal|"use -mcpu=arm7di"
argument_list|)
block|}
block|,
block|{
literal|"marm7m"
block|,
name|NULL
block|,
operator|&
name|legacy_cpu
block|,
name|ARM_ARCH_V3M
block|,
name|N_
argument_list|(
literal|"use -mcpu=arm7m"
argument_list|)
block|}
block|,
block|{
literal|"m7m"
block|,
name|NULL
block|,
operator|&
name|legacy_cpu
block|,
name|ARM_ARCH_V3M
block|,
name|N_
argument_list|(
literal|"use -mcpu=arm7m"
argument_list|)
block|}
block|,
block|{
literal|"marm7dm"
block|,
name|NULL
block|,
operator|&
name|legacy_cpu
block|,
name|ARM_ARCH_V3M
block|,
name|N_
argument_list|(
literal|"use -mcpu=arm7dm"
argument_list|)
block|}
block|,
block|{
literal|"m7dm"
block|,
name|NULL
block|,
operator|&
name|legacy_cpu
block|,
name|ARM_ARCH_V3M
block|,
name|N_
argument_list|(
literal|"use -mcpu=arm7dm"
argument_list|)
block|}
block|,
block|{
literal|"marm7dmi"
block|,
name|NULL
block|,
operator|&
name|legacy_cpu
block|,
name|ARM_ARCH_V3M
block|,
name|N_
argument_list|(
literal|"use -mcpu=arm7dmi"
argument_list|)
block|}
block|,
block|{
literal|"m7dmi"
block|,
name|NULL
block|,
operator|&
name|legacy_cpu
block|,
name|ARM_ARCH_V3M
block|,
name|N_
argument_list|(
literal|"use -mcpu=arm7dmi"
argument_list|)
block|}
block|,
block|{
literal|"marm7100"
block|,
name|NULL
block|,
operator|&
name|legacy_cpu
block|,
name|ARM_ARCH_V3
block|,
name|N_
argument_list|(
literal|"use -mcpu=arm7100"
argument_list|)
block|}
block|,
block|{
literal|"m7100"
block|,
name|NULL
block|,
operator|&
name|legacy_cpu
block|,
name|ARM_ARCH_V3
block|,
name|N_
argument_list|(
literal|"use -mcpu=arm7100"
argument_list|)
block|}
block|,
block|{
literal|"marm7500"
block|,
name|NULL
block|,
operator|&
name|legacy_cpu
block|,
name|ARM_ARCH_V3
block|,
name|N_
argument_list|(
literal|"use -mcpu=arm7500"
argument_list|)
block|}
block|,
block|{
literal|"m7500"
block|,
name|NULL
block|,
operator|&
name|legacy_cpu
block|,
name|ARM_ARCH_V3
block|,
name|N_
argument_list|(
literal|"use -mcpu=arm7500"
argument_list|)
block|}
block|,
block|{
literal|"marm7500fe"
block|,
name|NULL
block|,
operator|&
name|legacy_cpu
block|,
name|ARM_ARCH_V3
block|,
name|N_
argument_list|(
literal|"use -mcpu=arm7500fe"
argument_list|)
block|}
block|,
block|{
literal|"m7500fe"
block|,
name|NULL
block|,
operator|&
name|legacy_cpu
block|,
name|ARM_ARCH_V3
block|,
name|N_
argument_list|(
literal|"use -mcpu=arm7500fe"
argument_list|)
block|}
block|,
block|{
literal|"marm7t"
block|,
name|NULL
block|,
operator|&
name|legacy_cpu
block|,
name|ARM_ARCH_V4T
block|,
name|N_
argument_list|(
literal|"use -mcpu=arm7tdmi"
argument_list|)
block|}
block|,
block|{
literal|"m7t"
block|,
name|NULL
block|,
operator|&
name|legacy_cpu
block|,
name|ARM_ARCH_V4T
block|,
name|N_
argument_list|(
literal|"use -mcpu=arm7tdmi"
argument_list|)
block|}
block|,
block|{
literal|"marm7tdmi"
block|,
name|NULL
block|,
operator|&
name|legacy_cpu
block|,
name|ARM_ARCH_V4T
block|,
name|N_
argument_list|(
literal|"use -mcpu=arm7tdmi"
argument_list|)
block|}
block|,
block|{
literal|"m7tdmi"
block|,
name|NULL
block|,
operator|&
name|legacy_cpu
block|,
name|ARM_ARCH_V4T
block|,
name|N_
argument_list|(
literal|"use -mcpu=arm7tdmi"
argument_list|)
block|}
block|,
block|{
literal|"marm710t"
block|,
name|NULL
block|,
operator|&
name|legacy_cpu
block|,
name|ARM_ARCH_V4T
block|,
name|N_
argument_list|(
literal|"use -mcpu=arm710t"
argument_list|)
block|}
block|,
block|{
literal|"m710t"
block|,
name|NULL
block|,
operator|&
name|legacy_cpu
block|,
name|ARM_ARCH_V4T
block|,
name|N_
argument_list|(
literal|"use -mcpu=arm710t"
argument_list|)
block|}
block|,
block|{
literal|"marm720t"
block|,
name|NULL
block|,
operator|&
name|legacy_cpu
block|,
name|ARM_ARCH_V4T
block|,
name|N_
argument_list|(
literal|"use -mcpu=arm720t"
argument_list|)
block|}
block|,
block|{
literal|"m720t"
block|,
name|NULL
block|,
operator|&
name|legacy_cpu
block|,
name|ARM_ARCH_V4T
block|,
name|N_
argument_list|(
literal|"use -mcpu=arm720t"
argument_list|)
block|}
block|,
block|{
literal|"marm740t"
block|,
name|NULL
block|,
operator|&
name|legacy_cpu
block|,
name|ARM_ARCH_V4T
block|,
name|N_
argument_list|(
literal|"use -mcpu=arm740t"
argument_list|)
block|}
block|,
block|{
literal|"m740t"
block|,
name|NULL
block|,
operator|&
name|legacy_cpu
block|,
name|ARM_ARCH_V4T
block|,
name|N_
argument_list|(
literal|"use -mcpu=arm740t"
argument_list|)
block|}
block|,
block|{
literal|"marm8"
block|,
name|NULL
block|,
operator|&
name|legacy_cpu
block|,
name|ARM_ARCH_V4
block|,
name|N_
argument_list|(
literal|"use -mcpu=arm8"
argument_list|)
block|}
block|,
block|{
literal|"m8"
block|,
name|NULL
block|,
operator|&
name|legacy_cpu
block|,
name|ARM_ARCH_V4
block|,
name|N_
argument_list|(
literal|"use -mcpu=arm8"
argument_list|)
block|}
block|,
block|{
literal|"marm810"
block|,
name|NULL
block|,
operator|&
name|legacy_cpu
block|,
name|ARM_ARCH_V4
block|,
name|N_
argument_list|(
literal|"use -mcpu=arm810"
argument_list|)
block|}
block|,
block|{
literal|"m810"
block|,
name|NULL
block|,
operator|&
name|legacy_cpu
block|,
name|ARM_ARCH_V4
block|,
name|N_
argument_list|(
literal|"use -mcpu=arm810"
argument_list|)
block|}
block|,
block|{
literal|"marm9"
block|,
name|NULL
block|,
operator|&
name|legacy_cpu
block|,
name|ARM_ARCH_V4T
block|,
name|N_
argument_list|(
literal|"use -mcpu=arm9"
argument_list|)
block|}
block|,
block|{
literal|"m9"
block|,
name|NULL
block|,
operator|&
name|legacy_cpu
block|,
name|ARM_ARCH_V4T
block|,
name|N_
argument_list|(
literal|"use -mcpu=arm9"
argument_list|)
block|}
block|,
block|{
literal|"marm9tdmi"
block|,
name|NULL
block|,
operator|&
name|legacy_cpu
block|,
name|ARM_ARCH_V4T
block|,
name|N_
argument_list|(
literal|"use -mcpu=arm9tdmi"
argument_list|)
block|}
block|,
block|{
literal|"m9tdmi"
block|,
name|NULL
block|,
operator|&
name|legacy_cpu
block|,
name|ARM_ARCH_V4T
block|,
name|N_
argument_list|(
literal|"use -mcpu=arm9tdmi"
argument_list|)
block|}
block|,
block|{
literal|"marm920"
block|,
name|NULL
block|,
operator|&
name|legacy_cpu
block|,
name|ARM_ARCH_V4T
block|,
name|N_
argument_list|(
literal|"use -mcpu=arm920"
argument_list|)
block|}
block|,
block|{
literal|"m920"
block|,
name|NULL
block|,
operator|&
name|legacy_cpu
block|,
name|ARM_ARCH_V4T
block|,
name|N_
argument_list|(
literal|"use -mcpu=arm920"
argument_list|)
block|}
block|,
block|{
literal|"marm940"
block|,
name|NULL
block|,
operator|&
name|legacy_cpu
block|,
name|ARM_ARCH_V4T
block|,
name|N_
argument_list|(
literal|"use -mcpu=arm940"
argument_list|)
block|}
block|,
block|{
literal|"m940"
block|,
name|NULL
block|,
operator|&
name|legacy_cpu
block|,
name|ARM_ARCH_V4T
block|,
name|N_
argument_list|(
literal|"use -mcpu=arm940"
argument_list|)
block|}
block|,
block|{
literal|"mstrongarm"
block|,
name|NULL
block|,
operator|&
name|legacy_cpu
block|,
name|ARM_ARCH_V4
block|,
name|N_
argument_list|(
literal|"use -mcpu=strongarm"
argument_list|)
block|}
block|,
block|{
literal|"mstrongarm110"
block|,
name|NULL
block|,
operator|&
name|legacy_cpu
block|,
name|ARM_ARCH_V4
block|,
name|N_
argument_list|(
literal|"use -mcpu=strongarm110"
argument_list|)
block|}
block|,
block|{
literal|"mstrongarm1100"
block|,
name|NULL
block|,
operator|&
name|legacy_cpu
block|,
name|ARM_ARCH_V4
block|,
name|N_
argument_list|(
literal|"use -mcpu=strongarm1100"
argument_list|)
block|}
block|,
block|{
literal|"mstrongarm1110"
block|,
name|NULL
block|,
operator|&
name|legacy_cpu
block|,
name|ARM_ARCH_V4
block|,
name|N_
argument_list|(
literal|"use -mcpu=strongarm1110"
argument_list|)
block|}
block|,
block|{
literal|"mxscale"
block|,
name|NULL
block|,
operator|&
name|legacy_cpu
block|,
name|ARM_ARCH_XSCALE
block|,
name|N_
argument_list|(
literal|"use -mcpu=xscale"
argument_list|)
block|}
block|,
block|{
literal|"mall"
block|,
name|NULL
block|,
operator|&
name|legacy_cpu
block|,
name|ARM_ANY
block|,
name|N_
argument_list|(
literal|"use -mcpu=all"
argument_list|)
block|}
block|,
comment|/* Architecture variants -- don't add any more to this list either.  */
block|{
literal|"mv2"
block|,
name|NULL
block|,
operator|&
name|legacy_cpu
block|,
name|ARM_ARCH_V2
block|,
name|N_
argument_list|(
literal|"use -march=armv2"
argument_list|)
block|}
block|,
block|{
literal|"marmv2"
block|,
name|NULL
block|,
operator|&
name|legacy_cpu
block|,
name|ARM_ARCH_V2
block|,
name|N_
argument_list|(
literal|"use -march=armv2"
argument_list|)
block|}
block|,
block|{
literal|"mv2a"
block|,
name|NULL
block|,
operator|&
name|legacy_cpu
block|,
name|ARM_ARCH_V2S
block|,
name|N_
argument_list|(
literal|"use -march=armv2a"
argument_list|)
block|}
block|,
block|{
literal|"marmv2a"
block|,
name|NULL
block|,
operator|&
name|legacy_cpu
block|,
name|ARM_ARCH_V2S
block|,
name|N_
argument_list|(
literal|"use -march=armv2a"
argument_list|)
block|}
block|,
block|{
literal|"mv3"
block|,
name|NULL
block|,
operator|&
name|legacy_cpu
block|,
name|ARM_ARCH_V3
block|,
name|N_
argument_list|(
literal|"use -march=armv3"
argument_list|)
block|}
block|,
block|{
literal|"marmv3"
block|,
name|NULL
block|,
operator|&
name|legacy_cpu
block|,
name|ARM_ARCH_V3
block|,
name|N_
argument_list|(
literal|"use -march=armv3"
argument_list|)
block|}
block|,
block|{
literal|"mv3m"
block|,
name|NULL
block|,
operator|&
name|legacy_cpu
block|,
name|ARM_ARCH_V3M
block|,
name|N_
argument_list|(
literal|"use -march=armv3m"
argument_list|)
block|}
block|,
block|{
literal|"marmv3m"
block|,
name|NULL
block|,
operator|&
name|legacy_cpu
block|,
name|ARM_ARCH_V3M
block|,
name|N_
argument_list|(
literal|"use -march=armv3m"
argument_list|)
block|}
block|,
block|{
literal|"mv4"
block|,
name|NULL
block|,
operator|&
name|legacy_cpu
block|,
name|ARM_ARCH_V4
block|,
name|N_
argument_list|(
literal|"use -march=armv4"
argument_list|)
block|}
block|,
block|{
literal|"marmv4"
block|,
name|NULL
block|,
operator|&
name|legacy_cpu
block|,
name|ARM_ARCH_V4
block|,
name|N_
argument_list|(
literal|"use -march=armv4"
argument_list|)
block|}
block|,
block|{
literal|"mv4t"
block|,
name|NULL
block|,
operator|&
name|legacy_cpu
block|,
name|ARM_ARCH_V4T
block|,
name|N_
argument_list|(
literal|"use -march=armv4t"
argument_list|)
block|}
block|,
block|{
literal|"marmv4t"
block|,
name|NULL
block|,
operator|&
name|legacy_cpu
block|,
name|ARM_ARCH_V4T
block|,
name|N_
argument_list|(
literal|"use -march=armv4t"
argument_list|)
block|}
block|,
block|{
literal|"mv5"
block|,
name|NULL
block|,
operator|&
name|legacy_cpu
block|,
name|ARM_ARCH_V5
block|,
name|N_
argument_list|(
literal|"use -march=armv5"
argument_list|)
block|}
block|,
block|{
literal|"marmv5"
block|,
name|NULL
block|,
operator|&
name|legacy_cpu
block|,
name|ARM_ARCH_V5
block|,
name|N_
argument_list|(
literal|"use -march=armv5"
argument_list|)
block|}
block|,
block|{
literal|"mv5t"
block|,
name|NULL
block|,
operator|&
name|legacy_cpu
block|,
name|ARM_ARCH_V5T
block|,
name|N_
argument_list|(
literal|"use -march=armv5t"
argument_list|)
block|}
block|,
block|{
literal|"marmv5t"
block|,
name|NULL
block|,
operator|&
name|legacy_cpu
block|,
name|ARM_ARCH_V5T
block|,
name|N_
argument_list|(
literal|"use -march=armv5t"
argument_list|)
block|}
block|,
block|{
literal|"mv5e"
block|,
name|NULL
block|,
operator|&
name|legacy_cpu
block|,
name|ARM_ARCH_V5TE
block|,
name|N_
argument_list|(
literal|"use -march=armv5te"
argument_list|)
block|}
block|,
block|{
literal|"marmv5e"
block|,
name|NULL
block|,
operator|&
name|legacy_cpu
block|,
name|ARM_ARCH_V5TE
block|,
name|N_
argument_list|(
literal|"use -march=armv5te"
argument_list|)
block|}
block|,
comment|/* Floating point variants -- don't add any more to this list either.  */
block|{
literal|"mfpe-old"
block|,
name|NULL
block|,
operator|&
name|legacy_fpu
block|,
name|FPU_ARCH_FPE
block|,
name|N_
argument_list|(
literal|"use -mfpu=fpe"
argument_list|)
block|}
block|,
block|{
literal|"mfpa10"
block|,
name|NULL
block|,
operator|&
name|legacy_fpu
block|,
name|FPU_ARCH_FPA
block|,
name|N_
argument_list|(
literal|"use -mfpu=fpa10"
argument_list|)
block|}
block|,
block|{
literal|"mfpa11"
block|,
name|NULL
block|,
operator|&
name|legacy_fpu
block|,
name|FPU_ARCH_FPA
block|,
name|N_
argument_list|(
literal|"use -mfpu=fpa11"
argument_list|)
block|}
block|,
block|{
literal|"mno-fpu"
block|,
name|NULL
block|,
operator|&
name|legacy_fpu
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"use either -mfpu=softfpa or -mfpu=softvfp"
argument_list|)
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|arm_cpu_option_table
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|value
decl_stmt|;
comment|/* For some CPUs we assume an FPU unless the user explicitly sets      -mfpu=...  */
name|int
name|default_fpu
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* This list should, at a minimum, contain all the cpu names    recognized by GCC.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|arm_cpu_option_table
name|arm_cpus
index|[]
init|=
block|{
block|{
literal|"all"
block|,
name|ARM_ANY
block|,
name|FPU_ARCH_FPA
block|}
block|,
block|{
literal|"arm1"
block|,
name|ARM_ARCH_V1
block|,
name|FPU_ARCH_FPA
block|}
block|,
block|{
literal|"arm2"
block|,
name|ARM_ARCH_V2
block|,
name|FPU_ARCH_FPA
block|}
block|,
block|{
literal|"arm250"
block|,
name|ARM_ARCH_V2S
block|,
name|FPU_ARCH_FPA
block|}
block|,
block|{
literal|"arm3"
block|,
name|ARM_ARCH_V2S
block|,
name|FPU_ARCH_FPA
block|}
block|,
block|{
literal|"arm6"
block|,
name|ARM_ARCH_V3
block|,
name|FPU_ARCH_FPA
block|}
block|,
block|{
literal|"arm60"
block|,
name|ARM_ARCH_V3
block|,
name|FPU_ARCH_FPA
block|}
block|,
block|{
literal|"arm600"
block|,
name|ARM_ARCH_V3
block|,
name|FPU_ARCH_FPA
block|}
block|,
block|{
literal|"arm610"
block|,
name|ARM_ARCH_V3
block|,
name|FPU_ARCH_FPA
block|}
block|,
block|{
literal|"arm620"
block|,
name|ARM_ARCH_V3
block|,
name|FPU_ARCH_FPA
block|}
block|,
block|{
literal|"arm7"
block|,
name|ARM_ARCH_V3
block|,
name|FPU_ARCH_FPA
block|}
block|,
block|{
literal|"arm7m"
block|,
name|ARM_ARCH_V3M
block|,
name|FPU_ARCH_FPA
block|}
block|,
block|{
literal|"arm7d"
block|,
name|ARM_ARCH_V3
block|,
name|FPU_ARCH_FPA
block|}
block|,
block|{
literal|"arm7dm"
block|,
name|ARM_ARCH_V3M
block|,
name|FPU_ARCH_FPA
block|}
block|,
block|{
literal|"arm7di"
block|,
name|ARM_ARCH_V3
block|,
name|FPU_ARCH_FPA
block|}
block|,
block|{
literal|"arm7dmi"
block|,
name|ARM_ARCH_V3M
block|,
name|FPU_ARCH_FPA
block|}
block|,
block|{
literal|"arm70"
block|,
name|ARM_ARCH_V3
block|,
name|FPU_ARCH_FPA
block|}
block|,
block|{
literal|"arm700"
block|,
name|ARM_ARCH_V3
block|,
name|FPU_ARCH_FPA
block|}
block|,
block|{
literal|"arm700i"
block|,
name|ARM_ARCH_V3
block|,
name|FPU_ARCH_FPA
block|}
block|,
block|{
literal|"arm710"
block|,
name|ARM_ARCH_V3
block|,
name|FPU_ARCH_FPA
block|}
block|,
block|{
literal|"arm710t"
block|,
name|ARM_ARCH_V4T
block|,
name|FPU_ARCH_FPA
block|}
block|,
block|{
literal|"arm720"
block|,
name|ARM_ARCH_V3
block|,
name|FPU_ARCH_FPA
block|}
block|,
block|{
literal|"arm720t"
block|,
name|ARM_ARCH_V4T
block|,
name|FPU_ARCH_FPA
block|}
block|,
block|{
literal|"arm740t"
block|,
name|ARM_ARCH_V4T
block|,
name|FPU_ARCH_FPA
block|}
block|,
block|{
literal|"arm710c"
block|,
name|ARM_ARCH_V3
block|,
name|FPU_ARCH_FPA
block|}
block|,
block|{
literal|"arm7100"
block|,
name|ARM_ARCH_V3
block|,
name|FPU_ARCH_FPA
block|}
block|,
block|{
literal|"arm7500"
block|,
name|ARM_ARCH_V3
block|,
name|FPU_ARCH_FPA
block|}
block|,
block|{
literal|"arm7500fe"
block|,
name|ARM_ARCH_V3
block|,
name|FPU_ARCH_FPA
block|}
block|,
block|{
literal|"arm7t"
block|,
name|ARM_ARCH_V4T
block|,
name|FPU_ARCH_FPA
block|}
block|,
block|{
literal|"arm7tdmi"
block|,
name|ARM_ARCH_V4T
block|,
name|FPU_ARCH_FPA
block|}
block|,
block|{
literal|"arm8"
block|,
name|ARM_ARCH_V4
block|,
name|FPU_ARCH_FPA
block|}
block|,
block|{
literal|"arm810"
block|,
name|ARM_ARCH_V4
block|,
name|FPU_ARCH_FPA
block|}
block|,
block|{
literal|"strongarm"
block|,
name|ARM_ARCH_V4
block|,
name|FPU_ARCH_FPA
block|}
block|,
block|{
literal|"strongarm1"
block|,
name|ARM_ARCH_V4
block|,
name|FPU_ARCH_FPA
block|}
block|,
block|{
literal|"strongarm110"
block|,
name|ARM_ARCH_V4
block|,
name|FPU_ARCH_FPA
block|}
block|,
block|{
literal|"strongarm1100"
block|,
name|ARM_ARCH_V4
block|,
name|FPU_ARCH_FPA
block|}
block|,
block|{
literal|"strongarm1110"
block|,
name|ARM_ARCH_V4
block|,
name|FPU_ARCH_FPA
block|}
block|,
block|{
literal|"arm9"
block|,
name|ARM_ARCH_V4T
block|,
name|FPU_ARCH_FPA
block|}
block|,
block|{
literal|"arm920"
block|,
name|ARM_ARCH_V4T
block|,
name|FPU_ARCH_FPA
block|}
block|,
block|{
literal|"arm920t"
block|,
name|ARM_ARCH_V4T
block|,
name|FPU_ARCH_FPA
block|}
block|,
block|{
literal|"arm922t"
block|,
name|ARM_ARCH_V4T
block|,
name|FPU_ARCH_FPA
block|}
block|,
block|{
literal|"arm940t"
block|,
name|ARM_ARCH_V4T
block|,
name|FPU_ARCH_FPA
block|}
block|,
block|{
literal|"arm9tdmi"
block|,
name|ARM_ARCH_V4T
block|,
name|FPU_ARCH_FPA
block|}
block|,
comment|/* For V5 or later processors we default to using VFP; but the user      should really set the FPU type explicitly.  */
block|{
literal|"arm9e-r0"
block|,
name|ARM_ARCH_V5TExP
block|,
name|FPU_ARCH_VFP_V2
block|}
block|,
block|{
literal|"arm9e"
block|,
name|ARM_ARCH_V5TE
block|,
name|FPU_ARCH_VFP_V2
block|}
block|,
block|{
literal|"arm926ej"
block|,
name|ARM_ARCH_V5TEJ
block|,
name|FPU_ARCH_VFP_V2
block|}
block|,
block|{
literal|"arm946e-r0"
block|,
name|ARM_ARCH_V5TExP
block|,
name|FPU_ARCH_VFP_V2
block|}
block|,
block|{
literal|"arm946e"
block|,
name|ARM_ARCH_V5TE
block|,
name|FPU_ARCH_VFP_V2
block|}
block|,
block|{
literal|"arm966e-r0"
block|,
name|ARM_ARCH_V5TExP
block|,
name|FPU_ARCH_VFP_V2
block|}
block|,
block|{
literal|"arm966e"
block|,
name|ARM_ARCH_V5TE
block|,
name|FPU_ARCH_VFP_V2
block|}
block|,
block|{
literal|"arm10t"
block|,
name|ARM_ARCH_V5T
block|,
name|FPU_ARCH_VFP_V1
block|}
block|,
block|{
literal|"arm10e"
block|,
name|ARM_ARCH_V5TE
block|,
name|FPU_ARCH_VFP_V2
block|}
block|,
block|{
literal|"arm1020"
block|,
name|ARM_ARCH_V5TE
block|,
name|FPU_ARCH_VFP_V2
block|}
block|,
block|{
literal|"arm1020t"
block|,
name|ARM_ARCH_V5T
block|,
name|FPU_ARCH_VFP_V1
block|}
block|,
block|{
literal|"arm1020e"
block|,
name|ARM_ARCH_V5TE
block|,
name|FPU_ARCH_VFP_V2
block|}
block|,
comment|/* ??? XSCALE is really an architecture.  */
block|{
literal|"xscale"
block|,
name|ARM_ARCH_XSCALE
block|,
name|FPU_ARCH_VFP_V2
block|}
block|,
block|{
literal|"i80200"
block|,
name|ARM_ARCH_XSCALE
block|,
name|FPU_ARCH_VFP_V2
block|}
block|,
comment|/* Maverick */
block|{
literal|"ep9312"
block|,
name|ARM_ARCH_V4T
operator||
name|ARM_CEXT_MAVERICK
block|,
name|FPU_NONE
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|arm_arch_option_table
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|value
decl_stmt|;
name|int
name|default_fpu
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* This list should, at a minimum, contain all the architecture names    recognized by GCC.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|arm_arch_option_table
name|arm_archs
index|[]
init|=
block|{
block|{
literal|"all"
block|,
name|ARM_ANY
block|,
name|FPU_ARCH_FPA
block|}
block|,
block|{
literal|"armv1"
block|,
name|ARM_ARCH_V1
block|,
name|FPU_ARCH_FPA
block|}
block|,
block|{
literal|"armv2"
block|,
name|ARM_ARCH_V2
block|,
name|FPU_ARCH_FPA
block|}
block|,
block|{
literal|"armv2a"
block|,
name|ARM_ARCH_V2S
block|,
name|FPU_ARCH_FPA
block|}
block|,
block|{
literal|"armv2s"
block|,
name|ARM_ARCH_V2S
block|,
name|FPU_ARCH_FPA
block|}
block|,
block|{
literal|"armv3"
block|,
name|ARM_ARCH_V3
block|,
name|FPU_ARCH_FPA
block|}
block|,
block|{
literal|"armv3m"
block|,
name|ARM_ARCH_V3M
block|,
name|FPU_ARCH_FPA
block|}
block|,
block|{
literal|"armv4"
block|,
name|ARM_ARCH_V4
block|,
name|FPU_ARCH_FPA
block|}
block|,
block|{
literal|"armv4xm"
block|,
name|ARM_ARCH_V4xM
block|,
name|FPU_ARCH_FPA
block|}
block|,
block|{
literal|"armv4t"
block|,
name|ARM_ARCH_V4T
block|,
name|FPU_ARCH_FPA
block|}
block|,
block|{
literal|"armv4txm"
block|,
name|ARM_ARCH_V4TxM
block|,
name|FPU_ARCH_FPA
block|}
block|,
block|{
literal|"armv5"
block|,
name|ARM_ARCH_V5
block|,
name|FPU_ARCH_VFP
block|}
block|,
block|{
literal|"armv5t"
block|,
name|ARM_ARCH_V5T
block|,
name|FPU_ARCH_VFP
block|}
block|,
block|{
literal|"armv5txm"
block|,
name|ARM_ARCH_V5TxM
block|,
name|FPU_ARCH_VFP
block|}
block|,
block|{
literal|"armv5te"
block|,
name|ARM_ARCH_V5TE
block|,
name|FPU_ARCH_VFP
block|}
block|,
block|{
literal|"armv5texp"
block|,
name|ARM_ARCH_V5TExP
block|,
name|FPU_ARCH_VFP
block|}
block|,
block|{
literal|"armv5tej"
block|,
name|ARM_ARCH_V5TEJ
block|,
name|FPU_ARCH_VFP
block|}
block|,
block|{
literal|"xscale"
block|,
name|ARM_ARCH_XSCALE
block|,
name|FPU_ARCH_VFP
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ISA extensions in the co-processor space.  */
end_comment

begin_struct
struct|struct
name|arm_arch_extension_table
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|value
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|arm_arch_extension_table
name|arm_extensions
index|[]
init|=
block|{
block|{
literal|"maverick"
block|,
name|ARM_CEXT_MAVERICK
block|}
block|,
block|{
literal|"xscale"
block|,
name|ARM_CEXT_XSCALE
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|arm_fpu_option_table
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|value
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* This list should, at a minimum, contain all the fpu names    recognized by GCC.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|arm_fpu_option_table
name|arm_fpus
index|[]
init|=
block|{
block|{
literal|"softfpa"
block|,
name|FPU_NONE
block|}
block|,
block|{
literal|"fpe"
block|,
name|FPU_ARCH_FPE
block|}
block|,
block|{
literal|"fpe2"
block|,
name|FPU_ARCH_FPE
block|}
block|,
block|{
literal|"fpe3"
block|,
name|FPU_ARCH_FPA
block|}
block|,
comment|/* Third release supports LFM/SFM.  */
block|{
literal|"fpa"
block|,
name|FPU_ARCH_FPA
block|}
block|,
block|{
literal|"fpa10"
block|,
name|FPU_ARCH_FPA
block|}
block|,
block|{
literal|"fpa11"
block|,
name|FPU_ARCH_FPA
block|}
block|,
block|{
literal|"arm7500fe"
block|,
name|FPU_ARCH_FPA
block|}
block|,
block|{
literal|"softvfp"
block|,
name|FPU_ARCH_VFP
block|}
block|,
block|{
literal|"softvfp+vfp"
block|,
name|FPU_ARCH_VFP_V2
block|}
block|,
block|{
literal|"vfp"
block|,
name|FPU_ARCH_VFP_V2
block|}
block|,
block|{
literal|"vfp9"
block|,
name|FPU_ARCH_VFP_V2
block|}
block|,
block|{
literal|"vfp10"
block|,
name|FPU_ARCH_VFP_V2
block|}
block|,
block|{
literal|"vfp10-r0"
block|,
name|FPU_ARCH_VFP_V1
block|}
block|,
block|{
literal|"vfpxd"
block|,
name|FPU_ARCH_VFP_V1xD
block|}
block|,
block|{
literal|"arm1020t"
block|,
name|FPU_ARCH_VFP_V1
block|}
block|,
block|{
literal|"arm1020e"
block|,
name|FPU_ARCH_VFP_V2
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|arm_long_option_table
block|{
name|char
modifier|*
name|option
decl_stmt|;
comment|/* Substring to match.  */
name|char
modifier|*
name|help
decl_stmt|;
comment|/* Help information.  */
name|int
argument_list|(
argument|*func
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
name|subopt
operator|)
argument_list|)
expr_stmt|;
comment|/* Function to decode sub-option.  */
name|char
modifier|*
name|deprecated
decl_stmt|;
comment|/* If non-null, print this message.  */
block|}
struct|;
end_struct

begin_function
specifier|static
name|int
name|arm_parse_extension
parameter_list|(
name|str
parameter_list|,
name|opt_p
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
name|int
modifier|*
name|opt_p
decl_stmt|;
block|{
while|while
condition|(
name|str
operator|!=
name|NULL
operator|&&
operator|*
name|str
operator|!=
literal|0
condition|)
block|{
name|struct
name|arm_arch_extension_table
modifier|*
name|opt
decl_stmt|;
name|char
modifier|*
name|ext
decl_stmt|;
name|int
name|optlen
decl_stmt|;
if|if
condition|(
operator|*
name|str
operator|!=
literal|'+'
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"invalid architectural extension"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|str
operator|++
expr_stmt|;
name|ext
operator|=
name|strchr
argument_list|(
name|str
argument_list|,
literal|'+'
argument_list|)
expr_stmt|;
if|if
condition|(
name|ext
operator|!=
name|NULL
condition|)
name|optlen
operator|=
name|ext
operator|-
name|str
expr_stmt|;
else|else
name|optlen
operator|=
name|strlen
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|optlen
operator|==
literal|0
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"missing architectural extension"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
for|for
control|(
name|opt
operator|=
name|arm_extensions
init|;
name|opt
operator|->
name|name
operator|!=
name|NULL
condition|;
name|opt
operator|++
control|)
if|if
condition|(
name|strncmp
argument_list|(
name|opt
operator|->
name|name
argument_list|,
name|str
argument_list|,
name|optlen
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|opt_p
operator||=
name|opt
operator|->
name|value
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|opt
operator|->
name|name
operator|==
name|NULL
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"unknown architectural extnsion `%s'"
argument_list|)
argument_list|,
name|str
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|str
operator|=
name|ext
expr_stmt|;
block|}
empty_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|arm_parse_cpu
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|struct
name|arm_cpu_option_table
modifier|*
name|opt
decl_stmt|;
name|char
modifier|*
name|ext
init|=
name|strchr
argument_list|(
name|str
argument_list|,
literal|'+'
argument_list|)
decl_stmt|;
name|int
name|optlen
decl_stmt|;
if|if
condition|(
name|ext
operator|!=
name|NULL
condition|)
name|optlen
operator|=
name|ext
operator|-
name|str
expr_stmt|;
else|else
name|optlen
operator|=
name|strlen
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|optlen
operator|==
literal|0
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"missing cpu name `%s'"
argument_list|)
argument_list|,
name|str
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
for|for
control|(
name|opt
operator|=
name|arm_cpus
init|;
name|opt
operator|->
name|name
operator|!=
name|NULL
condition|;
name|opt
operator|++
control|)
if|if
condition|(
name|strncmp
argument_list|(
name|opt
operator|->
name|name
argument_list|,
name|str
argument_list|,
name|optlen
argument_list|)
operator|==
literal|0
condition|)
block|{
name|mcpu_cpu_opt
operator|=
name|opt
operator|->
name|value
expr_stmt|;
name|mcpu_fpu_opt
operator|=
name|opt
operator|->
name|default_fpu
expr_stmt|;
if|if
condition|(
name|ext
operator|!=
name|NULL
condition|)
return|return
name|arm_parse_extension
argument_list|(
name|ext
argument_list|,
operator|&
name|mcpu_cpu_opt
argument_list|)
return|;
return|return
literal|1
return|;
block|}
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"unknown cpu `%s'"
argument_list|)
argument_list|,
name|str
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|arm_parse_arch
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|struct
name|arm_arch_option_table
modifier|*
name|opt
decl_stmt|;
name|char
modifier|*
name|ext
init|=
name|strchr
argument_list|(
name|str
argument_list|,
literal|'+'
argument_list|)
decl_stmt|;
name|int
name|optlen
decl_stmt|;
if|if
condition|(
name|ext
operator|!=
name|NULL
condition|)
name|optlen
operator|=
name|ext
operator|-
name|str
expr_stmt|;
else|else
name|optlen
operator|=
name|strlen
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|optlen
operator|==
literal|0
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"missing architecture name `%s'"
argument_list|)
argument_list|,
name|str
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
for|for
control|(
name|opt
operator|=
name|arm_archs
init|;
name|opt
operator|->
name|name
operator|!=
name|NULL
condition|;
name|opt
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|opt
operator|->
name|name
argument_list|,
name|str
argument_list|)
operator|==
literal|0
condition|)
block|{
name|march_cpu_opt
operator|=
name|opt
operator|->
name|value
expr_stmt|;
name|march_fpu_opt
operator|=
name|opt
operator|->
name|default_fpu
expr_stmt|;
if|if
condition|(
name|ext
operator|!=
name|NULL
condition|)
return|return
name|arm_parse_extension
argument_list|(
name|ext
argument_list|,
operator|&
name|march_cpu_opt
argument_list|)
return|;
return|return
literal|1
return|;
block|}
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"unknown architecture `%s'\n"
argument_list|)
argument_list|,
name|str
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|arm_parse_fpu
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|struct
name|arm_fpu_option_table
modifier|*
name|opt
decl_stmt|;
for|for
control|(
name|opt
operator|=
name|arm_fpus
init|;
name|opt
operator|->
name|name
operator|!=
name|NULL
condition|;
name|opt
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|opt
operator|->
name|name
argument_list|,
name|str
argument_list|)
operator|==
literal|0
condition|)
block|{
name|mfpu_opt
operator|=
name|opt
operator|->
name|value
expr_stmt|;
return|return
literal|1
return|;
block|}
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"unknown floating point format `%s'\n"
argument_list|)
argument_list|,
name|str
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_decl_stmt
name|struct
name|arm_long_option_table
name|arm_long_opts
index|[]
init|=
block|{
block|{
literal|"mcpu="
block|,
name|N_
argument_list|(
literal|"<cpu name>\t  assemble for CPU<cpu name>"
argument_list|)
block|,
name|arm_parse_cpu
block|,
name|NULL
block|}
block|,
block|{
literal|"march="
block|,
name|N_
argument_list|(
literal|"<arch name>\t  assemble for architecture<arch name>"
argument_list|)
block|,
name|arm_parse_arch
block|,
name|NULL
block|}
block|,
block|{
literal|"mfpu="
block|,
name|N_
argument_list|(
literal|"<fpu name>\t  assemble for FPU architecture<fpu name>"
argument_list|)
block|,
name|arm_parse_fpu
block|,
name|NULL
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|md_parse_option
parameter_list|(
name|c
parameter_list|,
name|arg
parameter_list|)
name|int
name|c
decl_stmt|;
name|char
modifier|*
name|arg
decl_stmt|;
block|{
name|struct
name|arm_option_table
modifier|*
name|opt
decl_stmt|;
name|struct
name|arm_long_option_table
modifier|*
name|lopt
decl_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
ifdef|#
directive|ifdef
name|OPTION_EB
case|case
name|OPTION_EB
case|:
name|target_big_endian
operator|=
literal|1
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|OPTION_EL
case|case
name|OPTION_EL
case|:
name|target_big_endian
operator|=
literal|0
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
literal|'a'
case|:
comment|/* Listing option.  Just ignore these, we don't support additional  	 ones.  */
return|return
literal|0
return|;
default|default:
for|for
control|(
name|opt
operator|=
name|arm_opts
init|;
name|opt
operator|->
name|option
operator|!=
name|NULL
condition|;
name|opt
operator|++
control|)
block|{
if|if
condition|(
name|c
operator|==
name|opt
operator|->
name|option
index|[
literal|0
index|]
operator|&&
operator|(
operator|(
name|arg
operator|==
name|NULL
operator|&&
name|opt
operator|->
name|option
index|[
literal|1
index|]
operator|==
literal|0
operator|)
operator|||
name|strcmp
argument_list|(
name|arg
argument_list|,
name|opt
operator|->
name|option
operator|+
literal|1
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
if|#
directive|if
name|WARN_DEPRECATED
comment|/* If the option is deprecated, tell the user.  */
if|if
condition|(
name|opt
operator|->
name|deprecated
operator|!=
name|NULL
condition|)
name|as_tsktsk
argument_list|(
name|_
argument_list|(
literal|"option `-%c%s' is deprecated: %s"
argument_list|)
argument_list|,
name|c
argument_list|,
name|arg
condition|?
name|arg
else|:
literal|""
argument_list|,
name|_
argument_list|(
name|opt
operator|->
name|deprecated
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|opt
operator|->
name|var
operator|!=
name|NULL
condition|)
operator|*
name|opt
operator|->
name|var
operator|=
name|opt
operator|->
name|value
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
for|for
control|(
name|lopt
operator|=
name|arm_long_opts
init|;
name|lopt
operator|->
name|option
operator|!=
name|NULL
condition|;
name|lopt
operator|++
control|)
block|{
comment|/* These options are expected to have an argument.  */
if|if
condition|(
name|c
operator|==
name|lopt
operator|->
name|option
index|[
literal|0
index|]
operator|&&
name|arg
operator|!=
name|NULL
operator|&&
name|strncmp
argument_list|(
name|arg
argument_list|,
name|lopt
operator|->
name|option
operator|+
literal|1
argument_list|,
name|strlen
argument_list|(
name|lopt
operator|->
name|option
operator|+
literal|1
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
if|#
directive|if
name|WARN_DEPRECATED
comment|/* If the option is deprecated, tell the user.  */
if|if
condition|(
name|lopt
operator|->
name|deprecated
operator|!=
name|NULL
condition|)
name|as_tsktsk
argument_list|(
name|_
argument_list|(
literal|"option `-%c%s' is deprecated: %s"
argument_list|)
argument_list|,
name|c
argument_list|,
name|arg
argument_list|,
name|_
argument_list|(
name|lopt
operator|->
name|deprecated
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Call the sup-option parser.  */
return|return
call|(
modifier|*
name|lopt
operator|->
name|func
call|)
argument_list|(
name|arg
operator|+
name|strlen
argument_list|(
name|lopt
operator|->
name|option
argument_list|)
operator|-
literal|1
argument_list|)
return|;
block|}
block|}
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"unrecognized option `-%c%s'"
argument_list|)
argument_list|,
name|c
argument_list|,
name|arg
condition|?
name|arg
else|:
literal|""
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
name|void
name|md_show_usage
parameter_list|(
name|fp
parameter_list|)
name|FILE
modifier|*
name|fp
decl_stmt|;
block|{
name|struct
name|arm_option_table
modifier|*
name|opt
decl_stmt|;
name|struct
name|arm_long_option_table
modifier|*
name|lopt
decl_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
name|_
argument_list|(
literal|" ARM-specific assembler options:\n"
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|opt
operator|=
name|arm_opts
init|;
name|opt
operator|->
name|option
operator|!=
name|NULL
condition|;
name|opt
operator|++
control|)
if|if
condition|(
name|opt
operator|->
name|help
operator|!=
name|NULL
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"  -%-23s%s\n"
argument_list|,
name|opt
operator|->
name|option
argument_list|,
name|_
argument_list|(
name|opt
operator|->
name|help
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|lopt
operator|=
name|arm_long_opts
init|;
name|lopt
operator|->
name|option
operator|!=
name|NULL
condition|;
name|lopt
operator|++
control|)
if|if
condition|(
name|lopt
operator|->
name|help
operator|!=
name|NULL
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"  -%s%s\n"
argument_list|,
name|lopt
operator|->
name|option
argument_list|,
name|_
argument_list|(
name|lopt
operator|->
name|help
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|OPTION_EB
name|fprintf
argument_list|(
name|fp
argument_list|,
name|_
argument_list|(
literal|"\   -EB                     assemble code for a big-endian cpu\n"
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|OPTION_EL
name|fprintf
argument_list|(
name|fp
argument_list|,
name|_
argument_list|(
literal|"\   -EL                     assemble code for a little-endian cpu\n"
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* We need to be able to fix up arbitrary expressions in some statements.    This is so that we can handle symbols that are an arbitrary distance from    the pc.  The most common cases are of the form ((+/-sym -/+ . - 8)& mask),    which returns part of an address in a form which will be valid for    a data instruction.  We do this by pushing the expression into a symbol    in the expr_section, and creating a fix for that.  */
end_comment

begin_function
specifier|static
name|void
name|fix_new_arm
parameter_list|(
name|frag
parameter_list|,
name|where
parameter_list|,
name|size
parameter_list|,
name|exp
parameter_list|,
name|pc_rel
parameter_list|,
name|reloc
parameter_list|)
name|fragS
modifier|*
name|frag
decl_stmt|;
name|int
name|where
decl_stmt|;
name|short
name|int
name|size
decl_stmt|;
name|expressionS
modifier|*
name|exp
decl_stmt|;
name|int
name|pc_rel
decl_stmt|;
name|int
name|reloc
decl_stmt|;
block|{
name|fixS
modifier|*
name|new_fix
decl_stmt|;
name|arm_fix_data
modifier|*
name|arm_data
decl_stmt|;
switch|switch
condition|(
name|exp
operator|->
name|X_op
condition|)
block|{
case|case
name|O_constant
case|:
case|case
name|O_symbol
case|:
case|case
name|O_add
case|:
case|case
name|O_subtract
case|:
name|new_fix
operator|=
name|fix_new_exp
argument_list|(
name|frag
argument_list|,
name|where
argument_list|,
name|size
argument_list|,
name|exp
argument_list|,
name|pc_rel
argument_list|,
name|reloc
argument_list|)
expr_stmt|;
break|break;
default|default:
name|new_fix
operator|=
name|fix_new
argument_list|(
name|frag
argument_list|,
name|where
argument_list|,
name|size
argument_list|,
name|make_expr_symbol
argument_list|(
name|exp
argument_list|)
argument_list|,
literal|0
argument_list|,
name|pc_rel
argument_list|,
name|reloc
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Mark whether the fix is to a THUMB instruction, or an ARM      instruction.  */
name|arm_data
operator|=
operator|(
name|arm_fix_data
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|notes
argument_list|,
sizeof|sizeof
argument_list|(
name|arm_fix_data
argument_list|)
argument_list|)
expr_stmt|;
name|new_fix
operator|->
name|tc_fix_data
operator|=
operator|(
name|PTR
operator|)
name|arm_data
expr_stmt|;
name|arm_data
operator|->
name|thumb_mode
operator|=
name|thumb_mode
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* This fix_new is called by cons via TC_CONS_FIX_NEW.  */
end_comment

begin_function
name|void
name|cons_fix_new_arm
parameter_list|(
name|frag
parameter_list|,
name|where
parameter_list|,
name|size
parameter_list|,
name|exp
parameter_list|)
name|fragS
modifier|*
name|frag
decl_stmt|;
name|int
name|where
decl_stmt|;
name|int
name|size
decl_stmt|;
name|expressionS
modifier|*
name|exp
decl_stmt|;
block|{
name|bfd_reloc_code_real_type
name|type
decl_stmt|;
name|int
name|pcrel
init|=
literal|0
decl_stmt|;
comment|/* Pick a reloc.      FIXME: @@ Should look at CPU word size.  */
switch|switch
condition|(
name|size
condition|)
block|{
case|case
literal|1
case|:
name|type
operator|=
name|BFD_RELOC_8
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|type
operator|=
name|BFD_RELOC_16
expr_stmt|;
break|break;
case|case
literal|4
case|:
default|default:
name|type
operator|=
name|BFD_RELOC_32
expr_stmt|;
break|break;
case|case
literal|8
case|:
name|type
operator|=
name|BFD_RELOC_64
expr_stmt|;
break|break;
block|}
name|fix_new_exp
argument_list|(
name|frag
argument_list|,
name|where
argument_list|,
operator|(
name|int
operator|)
name|size
argument_list|,
name|exp
argument_list|,
name|pcrel
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* A good place to do this, although this was probably not intended    for this kind of use.  We need to dump the literal pool before    references are made to a null symbol pointer.  */
end_comment

begin_function
name|void
name|arm_cleanup
parameter_list|()
block|{
if|if
condition|(
name|current_poolP
operator|==
name|NULL
condition|)
return|return;
comment|/* Put it at the end of text section.  */
name|subseg_set
argument_list|(
name|text_section
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|s_ltorg
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|listing_prev_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|arm_start_line_hook
parameter_list|()
block|{
name|last_label_seen
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
name|void
name|arm_frob_label
parameter_list|(
name|sym
parameter_list|)
name|symbolS
modifier|*
name|sym
decl_stmt|;
block|{
name|last_label_seen
operator|=
name|sym
expr_stmt|;
name|ARM_SET_THUMB
argument_list|(
name|sym
argument_list|,
name|thumb_mode
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
name|OBJ_COFF
operator|||
name|defined
name|OBJ_ELF
name|ARM_SET_INTERWORK
argument_list|(
name|sym
argument_list|,
name|support_interwork
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Note - do not allow local symbols (.Lxxx) to be labeled      as Thumb functions.  This is because these labels, whilst      they exist inside Thumb code, are not the entry points for      possible ARM->Thumb calls.  Also, these labels can be used      as part of a computed goto or switch statement.  eg gcc      can generate code that looks like this:                  ldr  r2, [pc, .Laaa]                 lsl  r3, r3, #2                 ldr  r2, [r3, r2]                 mov  pc, r2 		        .Lbbb:  .word .Lxxx        .Lccc:  .word .Lyyy        ..etc...        .Laaa:   .word Lbbb       The first instruction loads the address of the jump table.      The second instruction converts a table index into a byte offset.      The third instruction gets the jump address out of the table.      The fourth instruction performs the jump.            If the address stored at .Laaa is that of a symbol which has the      Thumb_Func bit set, then the linker will arrange for this address      to have the bottom bit set, which in turn would mean that the      address computation performed by the third instruction would end      up with the bottom bit set.  Since the ARM is capable of unaligned      word loads, the instruction would then load the incorrect address      out of the jump table, and chaos would ensue.  */
if|if
condition|(
name|label_is_thumb_function_name
operator|&&
operator|(
name|S_GET_NAME
argument_list|(
name|sym
argument_list|)
index|[
literal|0
index|]
operator|!=
literal|'.'
operator|||
name|S_GET_NAME
argument_list|(
name|sym
argument_list|)
index|[
literal|1
index|]
operator|!=
literal|'L'
operator|)
operator|&&
operator|(
name|bfd_get_section_flags
argument_list|(
name|stdoutput
argument_list|,
name|now_seg
argument_list|)
operator|&
name|SEC_CODE
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* When the address of a Thumb function is taken the bottom 	 bit of that address should be set.  This will allow 	 interworking between Arm and Thumb functions to work 	 correctly.  */
name|THUMB_SET_FUNC
argument_list|(
name|sym
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|label_is_thumb_function_name
operator|=
name|false
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Adjust the symbol table.  This marks Thumb symbols as distinct from    ARM ones.  */
end_comment

begin_function
name|void
name|arm_adjust_symtab
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|OBJ_COFF
name|symbolS
modifier|*
name|sym
decl_stmt|;
for|for
control|(
name|sym
operator|=
name|symbol_rootP
init|;
name|sym
operator|!=
name|NULL
condition|;
name|sym
operator|=
name|symbol_next
argument_list|(
name|sym
argument_list|)
control|)
block|{
if|if
condition|(
name|ARM_IS_THUMB
argument_list|(
name|sym
argument_list|)
condition|)
block|{
if|if
condition|(
name|THUMB_IS_FUNC
argument_list|(
name|sym
argument_list|)
condition|)
block|{
comment|/* Mark the symbol as a Thumb function.  */
if|if
condition|(
name|S_GET_STORAGE_CLASS
argument_list|(
name|sym
argument_list|)
operator|==
name|C_STAT
operator|||
name|S_GET_STORAGE_CLASS
argument_list|(
name|sym
argument_list|)
operator|==
name|C_LABEL
condition|)
comment|/* This can happen!  */
name|S_SET_STORAGE_CLASS
argument_list|(
name|sym
argument_list|,
name|C_THUMBSTATFUNC
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|S_GET_STORAGE_CLASS
argument_list|(
name|sym
argument_list|)
operator|==
name|C_EXT
condition|)
name|S_SET_STORAGE_CLASS
argument_list|(
name|sym
argument_list|,
name|C_THUMBEXTFUNC
argument_list|)
expr_stmt|;
else|else
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"%s: unexpected function type: %d"
argument_list|)
argument_list|,
name|S_GET_NAME
argument_list|(
name|sym
argument_list|)
argument_list|,
name|S_GET_STORAGE_CLASS
argument_list|(
name|sym
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
switch|switch
condition|(
name|S_GET_STORAGE_CLASS
argument_list|(
name|sym
argument_list|)
condition|)
block|{
case|case
name|C_EXT
case|:
name|S_SET_STORAGE_CLASS
argument_list|(
name|sym
argument_list|,
name|C_THUMBEXT
argument_list|)
expr_stmt|;
break|break;
case|case
name|C_STAT
case|:
name|S_SET_STORAGE_CLASS
argument_list|(
name|sym
argument_list|,
name|C_THUMBSTAT
argument_list|)
expr_stmt|;
break|break;
case|case
name|C_LABEL
case|:
name|S_SET_STORAGE_CLASS
argument_list|(
name|sym
argument_list|,
name|C_THUMBLABEL
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* Do nothing.  */
break|break;
block|}
block|}
if|if
condition|(
name|ARM_IS_INTERWORK
argument_list|(
name|sym
argument_list|)
condition|)
name|coffsymbol
argument_list|(
name|symbol_get_bfdsym
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|->
name|native
operator|->
name|u
operator|.
name|syment
operator|.
name|n_flags
operator|=
literal|0xFF
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|OBJ_ELF
name|symbolS
modifier|*
name|sym
decl_stmt|;
name|char
name|bind
decl_stmt|;
for|for
control|(
name|sym
operator|=
name|symbol_rootP
init|;
name|sym
operator|!=
name|NULL
condition|;
name|sym
operator|=
name|symbol_next
argument_list|(
name|sym
argument_list|)
control|)
block|{
if|if
condition|(
name|ARM_IS_THUMB
argument_list|(
name|sym
argument_list|)
condition|)
block|{
name|elf_symbol_type
modifier|*
name|elf_sym
decl_stmt|;
name|elf_sym
operator|=
name|elf_symbol
argument_list|(
name|symbol_get_bfdsym
argument_list|(
name|sym
argument_list|)
argument_list|)
expr_stmt|;
name|bind
operator|=
name|ELF_ST_BIND
argument_list|(
name|elf_sym
argument_list|)
expr_stmt|;
comment|/* If it's a .thumb_func, declare it as so, 	     otherwise tag label as .code 16.  */
if|if
condition|(
name|THUMB_IS_FUNC
argument_list|(
name|sym
argument_list|)
condition|)
name|elf_sym
operator|->
name|internal_elf_sym
operator|.
name|st_info
operator|=
name|ELF_ST_INFO
argument_list|(
name|bind
argument_list|,
name|STT_ARM_TFUNC
argument_list|)
expr_stmt|;
else|else
name|elf_sym
operator|->
name|internal_elf_sym
operator|.
name|st_info
operator|=
name|ELF_ST_INFO
argument_list|(
name|bind
argument_list|,
name|STT_ARM_16BIT
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
block|}
end_function

begin_function
name|int
name|arm_data_in_code
parameter_list|()
block|{
if|if
condition|(
name|thumb_mode
operator|&&
operator|!
name|strncmp
argument_list|(
name|input_line_pointer
operator|+
literal|1
argument_list|,
literal|"data:"
argument_list|,
literal|5
argument_list|)
condition|)
block|{
operator|*
name|input_line_pointer
operator|=
literal|'/'
expr_stmt|;
name|input_line_pointer
operator|+=
literal|5
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
literal|0
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|arm_canonicalize_symbol_name
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|int
name|len
decl_stmt|;
if|if
condition|(
name|thumb_mode
operator|&&
operator|(
name|len
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
operator|)
operator|>
literal|5
operator|&&
name|streq
argument_list|(
name|name
operator|+
name|len
operator|-
literal|5
argument_list|,
literal|"/data"
argument_list|)
condition|)
operator|*
operator|(
name|name
operator|+
name|len
operator|-
literal|5
operator|)
operator|=
literal|0
expr_stmt|;
return|return
name|name
return|;
block|}
end_function

begin_function
name|boolean
name|arm_validate_fix
parameter_list|(
name|fixP
parameter_list|)
name|fixS
modifier|*
name|fixP
decl_stmt|;
block|{
comment|/* If the destination of the branch is a defined symbol which does not have      the THUMB_FUNC attribute, then we must be calling a function which has      the (interfacearm) attribute.  We look for the Thumb entry point to that      function and change the branch to refer to that function instead.  */
if|if
condition|(
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_THUMB_PCREL_BRANCH23
operator|&&
name|fixP
operator|->
name|fx_addsy
operator|!=
name|NULL
operator|&&
name|S_IS_DEFINED
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
operator|&&
operator|!
name|THUMB_IS_FUNC
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
condition|)
block|{
name|fixP
operator|->
name|fx_addsy
operator|=
name|find_real_start
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|OBJ_COFF
end_ifdef

begin_comment
comment|/* This is a little hack to help the gas/arm/adrl.s test.  It prevents    local labels from being added to the output symbol table when they    are used with the ADRL pseudo op.  The ADRL relocation should always    be resolved before the binbary is emitted, so it is safe to say that    it is adjustable.  */
end_comment

begin_function
name|boolean
name|arm_fix_adjustable
parameter_list|(
name|fixP
parameter_list|)
name|fixS
modifier|*
name|fixP
decl_stmt|;
block|{
if|if
condition|(
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_ARM_ADRL_IMMEDIATE
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|OBJ_ELF
end_ifdef

begin_comment
comment|/* Relocations against Thumb function names must be left unadjusted,    so that the linker can use this information to correctly set the    bottom bit of their addresses.  The MIPS version of this function    also prevents relocations that are mips-16 specific, but I do not    know why it does this.     FIXME:    There is one other problem that ought to be addressed here, but    which currently is not:  Taking the address of a label (rather    than a function) and then later jumping to that address.  Such    addresses also ought to have their bottom bit set (assuming that    they reside in Thumb code), but at the moment they will not.  */
end_comment

begin_function
name|boolean
name|arm_fix_adjustable
parameter_list|(
name|fixP
parameter_list|)
name|fixS
modifier|*
name|fixP
decl_stmt|;
block|{
if|if
condition|(
name|fixP
operator|->
name|fx_addsy
operator|==
name|NULL
condition|)
return|return
literal|1
return|;
comment|/* Prevent all adjustments to global symbols.  */
if|if
condition|(
name|S_IS_EXTERN
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|S_IS_WEAK
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|THUMB_IS_FUNC
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
operator|&&
name|fixP
operator|->
name|fx_subsy
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
comment|/* We need the symbol name for the VTABLE entries.  */
if|if
condition|(
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_VTABLE_INHERIT
operator|||
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_VTABLE_ENTRY
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|elf32_arm_target_format
parameter_list|()
block|{
if|if
condition|(
name|target_big_endian
condition|)
block|{
if|if
condition|(
name|target_oabi
condition|)
return|return
literal|"elf32-bigarm-oabi"
return|;
else|else
return|return
literal|"elf32-bigarm"
return|;
block|}
else|else
block|{
if|if
condition|(
name|target_oabi
condition|)
return|return
literal|"elf32-littlearm-oabi"
return|;
else|else
return|return
literal|"elf32-littlearm"
return|;
block|}
block|}
end_function

begin_function
name|void
name|armelf_frob_symbol
parameter_list|(
name|symp
parameter_list|,
name|puntp
parameter_list|)
name|symbolS
modifier|*
name|symp
decl_stmt|;
name|int
modifier|*
name|puntp
decl_stmt|;
block|{
name|elf_frob_symbol
argument_list|(
name|symp
argument_list|,
name|puntp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|arm_force_relocation
parameter_list|(
name|fixp
parameter_list|)
name|struct
name|fix
modifier|*
name|fixp
decl_stmt|;
block|{
if|if
condition|(
name|fixp
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_VTABLE_INHERIT
operator|||
name|fixp
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_VTABLE_ENTRY
operator|||
name|fixp
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_ARM_PCREL_BRANCH
operator|||
name|fixp
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_ARM_PCREL_BLX
operator|||
name|fixp
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_THUMB_PCREL_BLX
operator|||
name|fixp
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_THUMB_PCREL_BRANCH23
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_reloc_code_real_type
name|arm_parse_reloc
parameter_list|()
block|{
name|char
name|id
index|[
literal|16
index|]
decl_stmt|;
name|char
modifier|*
name|ip
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
specifier|static
struct|struct
block|{
name|char
modifier|*
name|str
decl_stmt|;
name|int
name|len
decl_stmt|;
name|bfd_reloc_code_real_type
name|reloc
decl_stmt|;
block|}
name|reloc_map
index|[]
init|=
block|{
define|#
directive|define
name|MAP
parameter_list|(
name|str
parameter_list|,
name|reloc
parameter_list|)
value|{ str, sizeof (str) - 1, reloc }
name|MAP
argument_list|(
literal|"(got)"
argument_list|,
name|BFD_RELOC_ARM_GOT32
argument_list|)
block|,
name|MAP
argument_list|(
literal|"(gotoff)"
argument_list|,
name|BFD_RELOC_ARM_GOTOFF
argument_list|)
block|,
comment|/* ScottB: Jan 30, 1998 - Added support for parsing "var(PLT)"        branch instructions generated by GCC for PLT relocs.  */
name|MAP
argument_list|(
literal|"(plt)"
argument_list|,
name|BFD_RELOC_ARM_PLT32
argument_list|)
block|,
block|{
name|NULL
block|,
literal|0
block|,
name|BFD_RELOC_UNUSED
block|}
undef|#
directive|undef
name|MAP
block|}
struct|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|ip
operator|=
name|input_line_pointer
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|id
argument_list|)
operator|&&
operator|(
name|ISALNUM
argument_list|(
operator|*
name|ip
argument_list|)
operator|||
name|ISPUNCT
argument_list|(
operator|*
name|ip
argument_list|)
operator|)
condition|;
name|i
operator|++
operator|,
name|ip
operator|++
control|)
name|id
index|[
name|i
index|]
operator|=
name|TOLOWER
argument_list|(
operator|*
name|ip
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|reloc_map
index|[
name|i
index|]
operator|.
name|str
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|strncmp
argument_list|(
name|id
argument_list|,
name|reloc_map
index|[
name|i
index|]
operator|.
name|str
argument_list|,
name|reloc_map
index|[
name|i
index|]
operator|.
name|len
argument_list|)
operator|==
literal|0
condition|)
break|break;
name|input_line_pointer
operator|+=
name|reloc_map
index|[
name|i
index|]
operator|.
name|len
expr_stmt|;
return|return
name|reloc_map
index|[
name|i
index|]
operator|.
name|reloc
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|s_arm_elf_cons
parameter_list|(
name|nbytes
parameter_list|)
name|int
name|nbytes
decl_stmt|;
block|{
name|expressionS
name|exp
decl_stmt|;
ifdef|#
directive|ifdef
name|md_flush_pending_output
name|md_flush_pending_output
argument_list|()
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|is_it_end_of_statement
argument_list|()
condition|)
block|{
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
ifdef|#
directive|ifdef
name|md_cons_align
name|md_cons_align
argument_list|(
name|nbytes
argument_list|)
expr_stmt|;
endif|#
directive|endif
do|do
block|{
name|bfd_reloc_code_real_type
name|reloc
decl_stmt|;
name|expression
argument_list|(
operator|&
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
name|exp
operator|.
name|X_op
operator|==
name|O_symbol
operator|&&
operator|*
name|input_line_pointer
operator|==
literal|'('
operator|&&
operator|(
name|reloc
operator|=
name|arm_parse_reloc
argument_list|()
operator|)
operator|!=
name|BFD_RELOC_UNUSED
condition|)
block|{
name|reloc_howto_type
modifier|*
name|howto
init|=
name|bfd_reloc_type_lookup
argument_list|(
name|stdoutput
argument_list|,
name|reloc
argument_list|)
decl_stmt|;
name|int
name|size
init|=
name|bfd_get_reloc_size
argument_list|(
name|howto
argument_list|)
decl_stmt|;
if|if
condition|(
name|size
operator|>
name|nbytes
condition|)
name|as_bad
argument_list|(
literal|"%s relocations do not fit in %d bytes"
argument_list|,
name|howto
operator|->
name|name
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
else|else
block|{
specifier|register
name|char
modifier|*
name|p
init|=
name|frag_more
argument_list|(
operator|(
name|int
operator|)
name|nbytes
argument_list|)
decl_stmt|;
name|int
name|offset
init|=
name|nbytes
operator|-
name|size
decl_stmt|;
name|fix_new_exp
argument_list|(
name|frag_now
argument_list|,
name|p
operator|-
name|frag_now
operator|->
name|fr_literal
operator|+
name|offset
argument_list|,
name|size
argument_list|,
operator|&
name|exp
argument_list|,
literal|0
argument_list|,
name|reloc
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|emit_expr
argument_list|(
operator|&
name|exp
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|nbytes
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|*
name|input_line_pointer
operator|++
operator|==
literal|','
condition|)
do|;
comment|/* Put terminator back into stream.  */
name|input_line_pointer
operator|--
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* OBJ_ELF */
end_comment

begin_comment
comment|/* This is called from HANDLE_ALIGN in write.c.  Fill in the contents    of an rs_align_code fragment.  */
end_comment

begin_function
name|void
name|arm_handle_align
parameter_list|(
name|fragP
parameter_list|)
name|fragS
modifier|*
name|fragP
decl_stmt|;
block|{
specifier|static
name|char
specifier|const
name|arm_noop
index|[
literal|4
index|]
init|=
block|{
literal|0x00
block|,
literal|0x00
block|,
literal|0xa0
block|,
literal|0xe1
block|}
decl_stmt|;
specifier|static
name|char
specifier|const
name|thumb_noop
index|[
literal|2
index|]
init|=
block|{
literal|0xc0
block|,
literal|0x46
block|}
decl_stmt|;
specifier|static
name|char
specifier|const
name|arm_bigend_noop
index|[
literal|4
index|]
init|=
block|{
literal|0xe1
block|,
literal|0xa0
block|,
literal|0x00
block|,
literal|0x00
block|}
decl_stmt|;
specifier|static
name|char
specifier|const
name|thumb_bigend_noop
index|[
literal|2
index|]
init|=
block|{
literal|0x46
block|,
literal|0xc0
block|}
decl_stmt|;
name|int
name|bytes
decl_stmt|,
name|fix
decl_stmt|,
name|noop_size
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
specifier|const
name|char
modifier|*
name|noop
decl_stmt|;
if|if
condition|(
name|fragP
operator|->
name|fr_type
operator|!=
name|rs_align_code
condition|)
return|return;
name|bytes
operator|=
name|fragP
operator|->
name|fr_next
operator|->
name|fr_address
operator|-
name|fragP
operator|->
name|fr_address
operator|-
name|fragP
operator|->
name|fr_fix
expr_stmt|;
name|p
operator|=
name|fragP
operator|->
name|fr_literal
operator|+
name|fragP
operator|->
name|fr_fix
expr_stmt|;
name|fix
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|bytes
operator|>
name|MAX_MEM_FOR_RS_ALIGN_CODE
condition|)
name|bytes
operator|&=
name|MAX_MEM_FOR_RS_ALIGN_CODE
expr_stmt|;
if|if
condition|(
name|fragP
operator|->
name|tc_frag_data
condition|)
block|{
if|if
condition|(
name|target_big_endian
condition|)
name|noop
operator|=
name|thumb_bigend_noop
expr_stmt|;
else|else
name|noop
operator|=
name|thumb_noop
expr_stmt|;
name|noop_size
operator|=
sizeof|sizeof
argument_list|(
name|thumb_noop
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|target_big_endian
condition|)
name|noop
operator|=
name|arm_bigend_noop
expr_stmt|;
else|else
name|noop
operator|=
name|arm_noop
expr_stmt|;
name|noop_size
operator|=
sizeof|sizeof
argument_list|(
name|arm_noop
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bytes
operator|&
operator|(
name|noop_size
operator|-
literal|1
operator|)
condition|)
block|{
name|fix
operator|=
name|bytes
operator|&
operator|(
name|noop_size
operator|-
literal|1
operator|)
expr_stmt|;
name|memset
argument_list|(
name|p
argument_list|,
literal|0
argument_list|,
name|fix
argument_list|)
expr_stmt|;
name|p
operator|+=
name|fix
expr_stmt|;
name|bytes
operator|-=
name|fix
expr_stmt|;
block|}
while|while
condition|(
name|bytes
operator|>=
name|noop_size
condition|)
block|{
name|memcpy
argument_list|(
name|p
argument_list|,
name|noop
argument_list|,
name|noop_size
argument_list|)
expr_stmt|;
name|p
operator|+=
name|noop_size
expr_stmt|;
name|bytes
operator|-=
name|noop_size
expr_stmt|;
name|fix
operator|+=
name|noop_size
expr_stmt|;
block|}
name|fragP
operator|->
name|fr_fix
operator|+=
name|fix
expr_stmt|;
name|fragP
operator|->
name|fr_var
operator|=
name|noop_size
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Called from md_do_align.  Used to create an alignment    frag in a code section.  */
end_comment

begin_function
name|void
name|arm_frag_align_code
parameter_list|(
name|n
parameter_list|,
name|max
parameter_list|)
name|int
name|n
decl_stmt|;
name|int
name|max
decl_stmt|;
block|{
name|char
modifier|*
name|p
decl_stmt|;
comment|/* We assume that there will never be a requirment      to support alignments greater than 32 bytes.  */
if|if
condition|(
name|max
operator|>
name|MAX_MEM_FOR_RS_ALIGN_CODE
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"alignments greater than 32 bytes not supported in .text sections."
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|=
name|frag_var
argument_list|(
name|rs_align_code
argument_list|,
name|MAX_MEM_FOR_RS_ALIGN_CODE
argument_list|,
literal|1
argument_list|,
operator|(
name|relax_substateT
operator|)
name|max
argument_list|,
operator|(
name|symbolS
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|offsetT
operator|)
name|n
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Perform target specific initialisation of a frag.  */
end_comment

begin_function
name|void
name|arm_init_frag
parameter_list|(
name|fragP
parameter_list|)
name|fragS
modifier|*
name|fragP
decl_stmt|;
block|{
comment|/* Record whether this frag is in an ARM or a THUMB area.  */
name|fragP
operator|->
name|tc_frag_data
operator|=
name|thumb_mode
expr_stmt|;
block|}
end_function

end_unit

