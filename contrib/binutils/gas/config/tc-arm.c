begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* tc-arm.c -- Assemble for the ARM    Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003,    2004, 2005, 2006    Free Software Foundation, Inc.    Contributed by Richard Earnshaw (rwe@pegasus.esprit.ec.org) 	Modified by David Taylor (dtaylor@armltd.co.uk) 	Cirrus coprocessor mods by Aldy Hernandez (aldyh@redhat.com) 	Cirrus coprocessor fixes by Petko Manolov (petkan@nucleusys.com) 	Cirrus coprocessor fixes by Vladimir Ivanov (vladitx@nucleusys.com)     This file is part of GAS, the GNU Assembler.     GAS is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     GAS is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with GAS; see the file COPYING.  If not, write to the Free    Software Foundation, 51 Franklin Street - Fifth Floor, Boston, MA    02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_define
define|#
directive|define
name|NO_RELOC
value|0
end_define

begin_include
include|#
directive|include
file|"as.h"
end_include

begin_include
include|#
directive|include
file|"safe-ctype.h"
end_include

begin_include
include|#
directive|include
file|"subsegs.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_include
include|#
directive|include
file|"opcode/arm.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|OBJ_ELF
end_ifdef

begin_include
include|#
directive|include
file|"elf/arm.h"
end_include

begin_include
include|#
directive|include
file|"dw2gencfi.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"dwarf2dbg.h"
end_include

begin_define
define|#
directive|define
name|WARN_DEPRECATED
value|1
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|OBJ_ELF
end_ifdef

begin_comment
comment|/* Must be at least the size of the largest unwind opcode (currently two).  */
end_comment

begin_define
define|#
directive|define
name|ARM_OPCODE_CHUNK_SIZE
value|8
end_define

begin_comment
comment|/* This structure holds the unwinding state.  */
end_comment

begin_struct
specifier|static
struct|struct
block|{
name|symbolS
modifier|*
name|proc_start
decl_stmt|;
name|symbolS
modifier|*
name|table_entry
decl_stmt|;
name|symbolS
modifier|*
name|personality_routine
decl_stmt|;
name|int
name|personality_index
decl_stmt|;
comment|/* The segment containing the function.  */
name|segT
name|saved_seg
decl_stmt|;
name|subsegT
name|saved_subseg
decl_stmt|;
comment|/* Opcodes generated from this function.  */
name|unsigned
name|char
modifier|*
name|opcodes
decl_stmt|;
name|int
name|opcode_count
decl_stmt|;
name|int
name|opcode_alloc
decl_stmt|;
comment|/* The number of bytes pushed to the stack.  */
name|offsetT
name|frame_size
decl_stmt|;
comment|/* We don't add stack adjustment opcodes immediately so that we can merge      multiple adjustments.  We can also omit the final adjustment      when using a frame pointer.  */
name|offsetT
name|pending_offset
decl_stmt|;
comment|/* These two fields are set by both unwind_movsp and unwind_setfp.  They      hold the reg+offset to use when restoring sp from a frame pointer.	 */
name|offsetT
name|fp_offset
decl_stmt|;
name|int
name|fp_reg
decl_stmt|;
comment|/* Nonzero if an unwind_setfp directive has been seen.  */
name|unsigned
name|fp_used
range|:
literal|1
decl_stmt|;
comment|/* Nonzero if the last opcode restores sp from fp_reg.  */
name|unsigned
name|sp_restored
range|:
literal|1
decl_stmt|;
block|}
name|unwind
struct|;
end_struct

begin_comment
comment|/* Bit N indicates that an R_ARM_NONE relocation has been output for    __aeabi_unwind_cpp_prN already if set. This enables dependencies to be    emitted only once per section, to save unnecessary bloat.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|marked_pr_dependency
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* OBJ_ELF */
end_comment

begin_comment
comment|/* Results from operand parsing worker functions.  */
end_comment

begin_typedef
typedef|typedef
enum|enum
block|{
name|PARSE_OPERAND_SUCCESS
block|,
name|PARSE_OPERAND_FAIL
block|,
name|PARSE_OPERAND_FAIL_NO_BACKTRACK
block|}
name|parse_operand_result
typedef|;
end_typedef

begin_enum
enum|enum
name|arm_float_abi
block|{
name|ARM_FLOAT_ABI_HARD
block|,
name|ARM_FLOAT_ABI_SOFTFP
block|,
name|ARM_FLOAT_ABI_SOFT
block|}
enum|;
end_enum

begin_comment
comment|/* Types of processor to assemble for.	*/
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|CPU_DEFAULT
end_ifndef

begin_if
if|#
directive|if
name|defined
name|__XSCALE__
end_if

begin_define
define|#
directive|define
name|CPU_DEFAULT
value|ARM_ARCH_XSCALE
end_define

begin_else
else|#
directive|else
end_else

begin_if
if|#
directive|if
name|defined
name|__thumb__
end_if

begin_define
define|#
directive|define
name|CPU_DEFAULT
value|ARM_ARCH_V5T
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|FPU_DEFAULT
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|TE_LINUX
end_ifdef

begin_define
define|#
directive|define
name|FPU_DEFAULT
value|FPU_ARCH_FPA
end_define

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|TE_NetBSD
argument_list|)
end_elif

begin_ifdef
ifdef|#
directive|ifdef
name|OBJ_ELF
end_ifdef

begin_define
define|#
directive|define
name|FPU_DEFAULT
value|FPU_ARCH_VFP
end_define

begin_comment
comment|/* Soft-float, but VFP order.  */
end_comment

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* Legacy a.out format.  */
end_comment

begin_define
define|#
directive|define
name|FPU_DEFAULT
value|FPU_ARCH_FPA
end_define

begin_comment
comment|/* Soft-float, but FPA order.  */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|TE_VXWORKS
argument_list|)
end_elif

begin_define
define|#
directive|define
name|FPU_DEFAULT
value|FPU_ARCH_VFP
end_define

begin_comment
comment|/* Soft-float, VFP order.  */
end_comment

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* For backwards compatibility, default to FPA.  */
end_comment

begin_define
define|#
directive|define
name|FPU_DEFAULT
value|FPU_ARCH_FPA
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ifndef FPU_DEFAULT */
end_comment

begin_define
define|#
directive|define
name|streq
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|(strcmp (a, b) == 0)
end_define

begin_decl_stmt
specifier|static
name|arm_feature_set
name|cpu_variant
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|arm_feature_set
name|arm_arch_used
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|arm_feature_set
name|thumb_arch_used
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Flags stored in private area of BFD structure.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|uses_apcs_26
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|atpcs
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|support_interwork
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|uses_apcs_float
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|pic_code
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Variables that we set while parsing command-line options.  Once all    options have been read we re-process these values to set the real    assembly flags.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|arm_feature_set
modifier|*
name|legacy_cpu
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|arm_feature_set
modifier|*
name|legacy_fpu
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|arm_feature_set
modifier|*
name|mcpu_cpu_opt
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|arm_feature_set
modifier|*
name|mcpu_fpu_opt
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|arm_feature_set
modifier|*
name|march_cpu_opt
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|arm_feature_set
modifier|*
name|march_fpu_opt
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|arm_feature_set
modifier|*
name|mfpu_opt
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|arm_feature_set
modifier|*
name|object_arch
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Constants for known architecture features.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|arm_feature_set
name|fpu_default
init|=
name|FPU_DEFAULT
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|arm_feature_set
name|fpu_arch_vfp_v1
init|=
name|FPU_ARCH_VFP_V1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|arm_feature_set
name|fpu_arch_vfp_v2
init|=
name|FPU_ARCH_VFP_V2
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|arm_feature_set
name|fpu_arch_vfp_v3
init|=
name|FPU_ARCH_VFP_V3
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|arm_feature_set
name|fpu_arch_neon_v1
init|=
name|FPU_ARCH_NEON_V1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|arm_feature_set
name|fpu_arch_fpa
init|=
name|FPU_ARCH_FPA
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|arm_feature_set
name|fpu_any_hard
init|=
name|FPU_ANY_HARD
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|arm_feature_set
name|fpu_arch_maverick
init|=
name|FPU_ARCH_MAVERICK
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|arm_feature_set
name|fpu_endian_pure
init|=
name|FPU_ARCH_ENDIAN_PURE
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|CPU_DEFAULT
end_ifdef

begin_decl_stmt
specifier|static
specifier|const
name|arm_feature_set
name|cpu_default
init|=
name|CPU_DEFAULT
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
specifier|const
name|arm_feature_set
name|arm_ext_v1
init|=
name|ARM_FEATURE
argument_list|(
name|ARM_EXT_V1
argument_list|,
literal|0
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|arm_feature_set
name|arm_ext_v2
init|=
name|ARM_FEATURE
argument_list|(
name|ARM_EXT_V1
argument_list|,
literal|0
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|arm_feature_set
name|arm_ext_v2s
init|=
name|ARM_FEATURE
argument_list|(
name|ARM_EXT_V2S
argument_list|,
literal|0
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|arm_feature_set
name|arm_ext_v3
init|=
name|ARM_FEATURE
argument_list|(
name|ARM_EXT_V3
argument_list|,
literal|0
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|arm_feature_set
name|arm_ext_v3m
init|=
name|ARM_FEATURE
argument_list|(
name|ARM_EXT_V3M
argument_list|,
literal|0
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|arm_feature_set
name|arm_ext_v4
init|=
name|ARM_FEATURE
argument_list|(
name|ARM_EXT_V4
argument_list|,
literal|0
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|arm_feature_set
name|arm_ext_v4t
init|=
name|ARM_FEATURE
argument_list|(
name|ARM_EXT_V4T
argument_list|,
literal|0
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|arm_feature_set
name|arm_ext_v5
init|=
name|ARM_FEATURE
argument_list|(
name|ARM_EXT_V5
argument_list|,
literal|0
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|arm_feature_set
name|arm_ext_v4t_5
init|=
name|ARM_FEATURE
argument_list|(
name|ARM_EXT_V4T
operator||
name|ARM_EXT_V5
argument_list|,
literal|0
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|arm_feature_set
name|arm_ext_v5t
init|=
name|ARM_FEATURE
argument_list|(
name|ARM_EXT_V5T
argument_list|,
literal|0
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|arm_feature_set
name|arm_ext_v5e
init|=
name|ARM_FEATURE
argument_list|(
name|ARM_EXT_V5E
argument_list|,
literal|0
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|arm_feature_set
name|arm_ext_v5exp
init|=
name|ARM_FEATURE
argument_list|(
name|ARM_EXT_V5ExP
argument_list|,
literal|0
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|arm_feature_set
name|arm_ext_v5j
init|=
name|ARM_FEATURE
argument_list|(
name|ARM_EXT_V5J
argument_list|,
literal|0
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|arm_feature_set
name|arm_ext_v6
init|=
name|ARM_FEATURE
argument_list|(
name|ARM_EXT_V6
argument_list|,
literal|0
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|arm_feature_set
name|arm_ext_v6k
init|=
name|ARM_FEATURE
argument_list|(
name|ARM_EXT_V6K
argument_list|,
literal|0
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|arm_feature_set
name|arm_ext_v6z
init|=
name|ARM_FEATURE
argument_list|(
name|ARM_EXT_V6Z
argument_list|,
literal|0
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|arm_feature_set
name|arm_ext_v6t2
init|=
name|ARM_FEATURE
argument_list|(
name|ARM_EXT_V6T2
argument_list|,
literal|0
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|arm_feature_set
name|arm_ext_v6_notm
init|=
name|ARM_FEATURE
argument_list|(
name|ARM_EXT_V6_NOTM
argument_list|,
literal|0
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|arm_feature_set
name|arm_ext_div
init|=
name|ARM_FEATURE
argument_list|(
name|ARM_EXT_DIV
argument_list|,
literal|0
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|arm_feature_set
name|arm_ext_v7
init|=
name|ARM_FEATURE
argument_list|(
name|ARM_EXT_V7
argument_list|,
literal|0
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|arm_feature_set
name|arm_ext_v7a
init|=
name|ARM_FEATURE
argument_list|(
name|ARM_EXT_V7A
argument_list|,
literal|0
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|arm_feature_set
name|arm_ext_v7r
init|=
name|ARM_FEATURE
argument_list|(
name|ARM_EXT_V7R
argument_list|,
literal|0
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|arm_feature_set
name|arm_ext_v7m
init|=
name|ARM_FEATURE
argument_list|(
name|ARM_EXT_V7M
argument_list|,
literal|0
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|arm_feature_set
name|arm_arch_any
init|=
name|ARM_ANY
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|arm_feature_set
name|arm_arch_full
init|=
name|ARM_FEATURE
argument_list|(
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|arm_feature_set
name|arm_arch_t2
init|=
name|ARM_ARCH_THUMB2
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|arm_feature_set
name|arm_arch_none
init|=
name|ARM_ARCH_NONE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|arm_feature_set
name|arm_cext_iwmmxt2
init|=
name|ARM_FEATURE
argument_list|(
literal|0
argument_list|,
name|ARM_CEXT_IWMMXT2
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|arm_feature_set
name|arm_cext_iwmmxt
init|=
name|ARM_FEATURE
argument_list|(
literal|0
argument_list|,
name|ARM_CEXT_IWMMXT
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|arm_feature_set
name|arm_cext_xscale
init|=
name|ARM_FEATURE
argument_list|(
literal|0
argument_list|,
name|ARM_CEXT_XSCALE
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|arm_feature_set
name|arm_cext_maverick
init|=
name|ARM_FEATURE
argument_list|(
literal|0
argument_list|,
name|ARM_CEXT_MAVERICK
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|arm_feature_set
name|fpu_fpa_ext_v1
init|=
name|ARM_FEATURE
argument_list|(
literal|0
argument_list|,
name|FPU_FPA_EXT_V1
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|arm_feature_set
name|fpu_fpa_ext_v2
init|=
name|ARM_FEATURE
argument_list|(
literal|0
argument_list|,
name|FPU_FPA_EXT_V2
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|arm_feature_set
name|fpu_vfp_ext_v1xd
init|=
name|ARM_FEATURE
argument_list|(
literal|0
argument_list|,
name|FPU_VFP_EXT_V1xD
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|arm_feature_set
name|fpu_vfp_ext_v1
init|=
name|ARM_FEATURE
argument_list|(
literal|0
argument_list|,
name|FPU_VFP_EXT_V1
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|arm_feature_set
name|fpu_vfp_ext_v2
init|=
name|ARM_FEATURE
argument_list|(
literal|0
argument_list|,
name|FPU_VFP_EXT_V2
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|arm_feature_set
name|fpu_vfp_ext_v3
init|=
name|ARM_FEATURE
argument_list|(
literal|0
argument_list|,
name|FPU_VFP_EXT_V3
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|arm_feature_set
name|fpu_neon_ext_v1
init|=
name|ARM_FEATURE
argument_list|(
literal|0
argument_list|,
name|FPU_NEON_EXT_V1
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|arm_feature_set
name|fpu_vfp_v3_or_neon_ext
init|=
name|ARM_FEATURE
argument_list|(
literal|0
argument_list|,
name|FPU_NEON_EXT_V1
operator||
name|FPU_VFP_EXT_V3
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|mfloat_abi_opt
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Record user cpu selection for object attributes.  */
end_comment

begin_decl_stmt
specifier|static
name|arm_feature_set
name|selected_cpu
init|=
name|ARM_ARCH_NONE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Must be long enough to hold any of the names in arm_cpus.  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|selected_cpu_name
index|[
literal|16
index|]
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|OBJ_ELF
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|EABI_DEFAULT
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|meabi_flags
init|=
name|EABI_DEFAULT
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|static
name|int
name|meabi_flags
init|=
name|EF_ARM_EABI_UNKNOWN
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|bfd_boolean
name|arm_is_eabi
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
name|EF_ARM_EABI_VERSION
argument_list|(
name|meabi_flags
argument_list|)
operator|>=
name|EF_ARM_EABI_VER4
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|OBJ_ELF
end_ifdef

begin_comment
comment|/* Pre-defined "_GLOBAL_OFFSET_TABLE_"	*/
end_comment

begin_decl_stmt
name|symbolS
modifier|*
name|GOT_symbol
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* 0: assemble for ARM,    1: assemble for Thumb,    2: assemble for Thumb even though target CPU does not support thumb       instructions.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|thumb_mode
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If unified_syntax is true, we are processing the new unified    ARM/Thumb syntax.  Important differences from the old ARM mode:       - Immediate operands do not require a # prefix.      - Conditional affixes always appear at the end of the        instruction.  (For backward compatibility, those instructions        that formerly had them in the middle, continue to accept them        there.)      - The IT instruction may appear, and if it does is validated        against subsequent conditional affixes.  It does not generate        machine code.     Important differences from the old Thumb mode:       - Immediate operands do not require a # prefix.      - Most of the V6T2 instructions are only available in unified mode.      - The .N and .W suffixes are recognized and honored (it is an error        if they cannot be honored).      - All instructions set the flags if and only if they have an 's' affix.      - Conditional affixes may be used.  They are validated against        preceding IT instructions.  Unlike ARM mode, you cannot use a        conditional affix except in the scope of an IT instruction.  */
end_comment

begin_decl_stmt
specifier|static
name|bfd_boolean
name|unified_syntax
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_enum
enum|enum
name|neon_el_type
block|{
name|NT_invtype
block|,
name|NT_untyped
block|,
name|NT_integer
block|,
name|NT_float
block|,
name|NT_poly
block|,
name|NT_signed
block|,
name|NT_unsigned
block|}
enum|;
end_enum

begin_struct
struct|struct
name|neon_type_el
block|{
name|enum
name|neon_el_type
name|type
decl_stmt|;
name|unsigned
name|size
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|NEON_MAX_TYPE_ELS
value|4
end_define

begin_struct
struct|struct
name|neon_type
block|{
name|struct
name|neon_type_el
name|el
index|[
name|NEON_MAX_TYPE_ELS
index|]
decl_stmt|;
name|unsigned
name|elems
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|arm_it
block|{
specifier|const
name|char
modifier|*
name|error
decl_stmt|;
name|unsigned
name|long
name|instruction
decl_stmt|;
name|int
name|size
decl_stmt|;
name|int
name|size_req
decl_stmt|;
name|int
name|cond
decl_stmt|;
comment|/* "uncond_value" is set to the value in place of the conditional field in      unconditional versions of the instruction, or -1 if nothing is      appropriate.  */
name|int
name|uncond_value
decl_stmt|;
name|struct
name|neon_type
name|vectype
decl_stmt|;
comment|/* Set to the opcode if the instruction needs relaxation.      Zero if the instruction is not relaxed.  */
name|unsigned
name|long
name|relax
decl_stmt|;
struct|struct
block|{
name|bfd_reloc_code_real_type
name|type
decl_stmt|;
name|expressionS
name|exp
decl_stmt|;
name|int
name|pc_rel
decl_stmt|;
block|}
name|reloc
struct|;
struct|struct
block|{
name|unsigned
name|reg
decl_stmt|;
name|signed
name|int
name|imm
decl_stmt|;
name|struct
name|neon_type_el
name|vectype
decl_stmt|;
name|unsigned
name|present
range|:
literal|1
decl_stmt|;
comment|/* Operand present.  */
name|unsigned
name|isreg
range|:
literal|1
decl_stmt|;
comment|/* Operand was a register.  */
name|unsigned
name|immisreg
range|:
literal|1
decl_stmt|;
comment|/* .imm field is a second register.  */
name|unsigned
name|isscalar
range|:
literal|1
decl_stmt|;
comment|/* Operand is a (Neon) scalar.  */
name|unsigned
name|immisalign
range|:
literal|1
decl_stmt|;
comment|/* Immediate is an alignment specifier.  */
name|unsigned
name|immisfloat
range|:
literal|1
decl_stmt|;
comment|/* Immediate was parsed as a float.  */
comment|/* Note: we abuse "regisimm" to mean "is Neon register" in VMOV        instructions. This allows us to disambiguate ARM<-> vector insns.  */
name|unsigned
name|regisimm
range|:
literal|1
decl_stmt|;
comment|/* 64-bit immediate, reg forms high 32 bits.  */
name|unsigned
name|isvec
range|:
literal|1
decl_stmt|;
comment|/* Is a single, double or quad VFP/Neon reg.  */
name|unsigned
name|isquad
range|:
literal|1
decl_stmt|;
comment|/* Operand is Neon quad-precision register.  */
name|unsigned
name|issingle
range|:
literal|1
decl_stmt|;
comment|/* Operand is VFP single-precision register.  */
name|unsigned
name|hasreloc
range|:
literal|1
decl_stmt|;
comment|/* Operand has relocation suffix.  */
name|unsigned
name|writeback
range|:
literal|1
decl_stmt|;
comment|/* Operand has trailing !  */
name|unsigned
name|preind
range|:
literal|1
decl_stmt|;
comment|/* Preindexed address.  */
name|unsigned
name|postind
range|:
literal|1
decl_stmt|;
comment|/* Postindexed address.  */
name|unsigned
name|negative
range|:
literal|1
decl_stmt|;
comment|/* Index register was negated.  */
name|unsigned
name|shifted
range|:
literal|1
decl_stmt|;
comment|/* Shift applied to operation.  */
name|unsigned
name|shift_kind
range|:
literal|3
decl_stmt|;
comment|/* Shift operation (enum shift_kind).  */
block|}
name|operands
index|[
literal|6
index|]
struct|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|arm_it
name|inst
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|NUM_FLOAT_VALS
value|8
end_define

begin_decl_stmt
specifier|const
name|char
modifier|*
name|fp_const
index|[]
init|=
block|{
literal|"0.0"
block|,
literal|"1.0"
block|,
literal|"2.0"
block|,
literal|"3.0"
block|,
literal|"4.0"
block|,
literal|"5.0"
block|,
literal|"0.5"
block|,
literal|"10.0"
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of littlenums required to hold an extended precision number.	*/
end_comment

begin_define
define|#
directive|define
name|MAX_LITTLENUMS
value|6
end_define

begin_decl_stmt
name|LITTLENUM_TYPE
name|fp_values
index|[
name|NUM_FLOAT_VALS
index|]
index|[
name|MAX_LITTLENUMS
index|]
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|FAIL
value|(-1)
end_define

begin_define
define|#
directive|define
name|SUCCESS
value|(0)
end_define

begin_define
define|#
directive|define
name|SUFF_S
value|1
end_define

begin_define
define|#
directive|define
name|SUFF_D
value|2
end_define

begin_define
define|#
directive|define
name|SUFF_E
value|3
end_define

begin_define
define|#
directive|define
name|SUFF_P
value|4
end_define

begin_define
define|#
directive|define
name|CP_T_X
value|0x00008000
end_define

begin_define
define|#
directive|define
name|CP_T_Y
value|0x00400000
end_define

begin_define
define|#
directive|define
name|CONDS_BIT
value|0x00100000
end_define

begin_define
define|#
directive|define
name|LOAD_BIT
value|0x00100000
end_define

begin_define
define|#
directive|define
name|DOUBLE_LOAD_FLAG
value|0x00000001
end_define

begin_struct
struct|struct
name|asm_cond
block|{
specifier|const
name|char
modifier|*
name|template
decl_stmt|;
name|unsigned
name|long
name|value
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|COND_ALWAYS
value|0xE
end_define

begin_struct
struct|struct
name|asm_psr
block|{
specifier|const
name|char
modifier|*
name|template
decl_stmt|;
name|unsigned
name|long
name|field
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|asm_barrier_opt
block|{
specifier|const
name|char
modifier|*
name|template
decl_stmt|;
name|unsigned
name|long
name|value
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* The bit that distinguishes CPSR and SPSR.  */
end_comment

begin_define
define|#
directive|define
name|SPSR_BIT
value|(1<< 22)
end_define

begin_comment
comment|/* The individual PSR flag bits.  */
end_comment

begin_define
define|#
directive|define
name|PSR_c
value|(1<< 16)
end_define

begin_define
define|#
directive|define
name|PSR_x
value|(1<< 17)
end_define

begin_define
define|#
directive|define
name|PSR_s
value|(1<< 18)
end_define

begin_define
define|#
directive|define
name|PSR_f
value|(1<< 19)
end_define

begin_struct
struct|struct
name|reloc_entry
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|bfd_reloc_code_real_type
name|reloc
decl_stmt|;
block|}
struct|;
end_struct

begin_enum
enum|enum
name|vfp_reg_pos
block|{
name|VFP_REG_Sd
block|,
name|VFP_REG_Sm
block|,
name|VFP_REG_Sn
block|,
name|VFP_REG_Dd
block|,
name|VFP_REG_Dm
block|,
name|VFP_REG_Dn
block|}
enum|;
end_enum

begin_enum
enum|enum
name|vfp_ldstm_type
block|{
name|VFP_LDSTMIA
block|,
name|VFP_LDSTMDB
block|,
name|VFP_LDSTMIAX
block|,
name|VFP_LDSTMDBX
block|}
enum|;
end_enum

begin_comment
comment|/* Bits for DEFINED field in neon_typed_alias.  */
end_comment

begin_define
define|#
directive|define
name|NTA_HASTYPE
value|1
end_define

begin_define
define|#
directive|define
name|NTA_HASINDEX
value|2
end_define

begin_struct
struct|struct
name|neon_typed_alias
block|{
name|unsigned
name|char
name|defined
decl_stmt|;
name|unsigned
name|char
name|index
decl_stmt|;
name|struct
name|neon_type_el
name|eltype
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* ARM register categories.  This includes coprocessor numbers and various    architecture extensions' registers.	*/
end_comment

begin_enum
enum|enum
name|arm_reg_type
block|{
name|REG_TYPE_RN
block|,
name|REG_TYPE_CP
block|,
name|REG_TYPE_CN
block|,
name|REG_TYPE_FN
block|,
name|REG_TYPE_VFS
block|,
name|REG_TYPE_VFD
block|,
name|REG_TYPE_NQ
block|,
name|REG_TYPE_VFSD
block|,
name|REG_TYPE_NDQ
block|,
name|REG_TYPE_NSDQ
block|,
name|REG_TYPE_VFC
block|,
name|REG_TYPE_MVF
block|,
name|REG_TYPE_MVD
block|,
name|REG_TYPE_MVFX
block|,
name|REG_TYPE_MVDX
block|,
name|REG_TYPE_MVAX
block|,
name|REG_TYPE_DSPSC
block|,
name|REG_TYPE_MMXWR
block|,
name|REG_TYPE_MMXWC
block|,
name|REG_TYPE_MMXWCG
block|,
name|REG_TYPE_XSCALE
block|, }
enum|;
end_enum

begin_comment
comment|/* Structure for a hash table entry for a register.    If TYPE is REG_TYPE_VFD or REG_TYPE_NQ, the NEON field can point to extra    information which states whether a vector type or index is specified (for a    register alias created with .dn or .qn). Otherwise NEON should be NULL.  */
end_comment

begin_struct
struct|struct
name|reg_entry
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|unsigned
name|char
name|number
decl_stmt|;
name|unsigned
name|char
name|type
decl_stmt|;
name|unsigned
name|char
name|builtin
decl_stmt|;
name|struct
name|neon_typed_alias
modifier|*
name|neon
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Diagnostics used when we don't get a register of the expected type.	*/
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
specifier|const
name|reg_expected_msgs
index|[]
init|=
block|{
name|N_
argument_list|(
literal|"ARM register expected"
argument_list|)
block|,
name|N_
argument_list|(
literal|"bad or missing co-processor number"
argument_list|)
block|,
name|N_
argument_list|(
literal|"co-processor register expected"
argument_list|)
block|,
name|N_
argument_list|(
literal|"FPA register expected"
argument_list|)
block|,
name|N_
argument_list|(
literal|"VFP single precision register expected"
argument_list|)
block|,
name|N_
argument_list|(
literal|"VFP/Neon double precision register expected"
argument_list|)
block|,
name|N_
argument_list|(
literal|"Neon quad precision register expected"
argument_list|)
block|,
name|N_
argument_list|(
literal|"VFP single or double precision register expected"
argument_list|)
block|,
name|N_
argument_list|(
literal|"Neon double or quad precision register expected"
argument_list|)
block|,
name|N_
argument_list|(
literal|"VFP single, double or Neon quad precision register expected"
argument_list|)
block|,
name|N_
argument_list|(
literal|"VFP system register expected"
argument_list|)
block|,
name|N_
argument_list|(
literal|"Maverick MVF register expected"
argument_list|)
block|,
name|N_
argument_list|(
literal|"Maverick MVD register expected"
argument_list|)
block|,
name|N_
argument_list|(
literal|"Maverick MVFX register expected"
argument_list|)
block|,
name|N_
argument_list|(
literal|"Maverick MVDX register expected"
argument_list|)
block|,
name|N_
argument_list|(
literal|"Maverick MVAX register expected"
argument_list|)
block|,
name|N_
argument_list|(
literal|"Maverick DSPSC register expected"
argument_list|)
block|,
name|N_
argument_list|(
literal|"iWMMXt data register expected"
argument_list|)
block|,
name|N_
argument_list|(
literal|"iWMMXt control register expected"
argument_list|)
block|,
name|N_
argument_list|(
literal|"iWMMXt scalar register expected"
argument_list|)
block|,
name|N_
argument_list|(
literal|"XScale accumulator register expected"
argument_list|)
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Some well known registers that we refer to directly elsewhere.  */
end_comment

begin_define
define|#
directive|define
name|REG_SP
value|13
end_define

begin_define
define|#
directive|define
name|REG_LR
value|14
end_define

begin_define
define|#
directive|define
name|REG_PC
value|15
end_define

begin_comment
comment|/* ARM instructions take 4bytes in the object file, Thumb instructions    take 2:  */
end_comment

begin_define
define|#
directive|define
name|INSN_SIZE
value|4
end_define

begin_struct
struct|struct
name|asm_opcode
block|{
comment|/* Basic string to match.  */
specifier|const
name|char
modifier|*
name|template
decl_stmt|;
comment|/* Parameters to instruction.	 */
name|unsigned
name|char
name|operands
index|[
literal|8
index|]
decl_stmt|;
comment|/* Conditional tag - see opcode_lookup.  */
name|unsigned
name|int
name|tag
range|:
literal|4
decl_stmt|;
comment|/* Basic instruction code.  */
name|unsigned
name|int
name|avalue
range|:
literal|28
decl_stmt|;
comment|/* Thumb-format instruction code.  */
name|unsigned
name|int
name|tvalue
decl_stmt|;
comment|/* Which architecture variant provides this instruction.  */
specifier|const
name|arm_feature_set
modifier|*
name|avariant
decl_stmt|;
specifier|const
name|arm_feature_set
modifier|*
name|tvariant
decl_stmt|;
comment|/* Function to call to encode instruction in ARM format.  */
name|void
function_decl|(
modifier|*
name|aencode
function_decl|)
parameter_list|(
name|void
parameter_list|)
function_decl|;
comment|/* Function to call to encode instruction in Thumb format.  */
name|void
function_decl|(
modifier|*
name|tencode
function_decl|)
parameter_list|(
name|void
parameter_list|)
function_decl|;
block|}
struct|;
end_struct

begin_comment
comment|/* Defines for various bits that we will want to toggle.  */
end_comment

begin_define
define|#
directive|define
name|INST_IMMEDIATE
value|0x02000000
end_define

begin_define
define|#
directive|define
name|OFFSET_REG
value|0x02000000
end_define

begin_define
define|#
directive|define
name|HWOFFSET_IMM
value|0x00400000
end_define

begin_define
define|#
directive|define
name|SHIFT_BY_REG
value|0x00000010
end_define

begin_define
define|#
directive|define
name|PRE_INDEX
value|0x01000000
end_define

begin_define
define|#
directive|define
name|INDEX_UP
value|0x00800000
end_define

begin_define
define|#
directive|define
name|WRITE_BACK
value|0x00200000
end_define

begin_define
define|#
directive|define
name|LDM_TYPE_2_OR_3
value|0x00400000
end_define

begin_define
define|#
directive|define
name|CPSI_MMOD
value|0x00020000
end_define

begin_define
define|#
directive|define
name|LITERAL_MASK
value|0xf000f000
end_define

begin_define
define|#
directive|define
name|OPCODE_MASK
value|0xfe1fffff
end_define

begin_define
define|#
directive|define
name|V4_STR_BIT
value|0x00000020
end_define

begin_define
define|#
directive|define
name|T2_SUBS_PC_LR
value|0xf3de8f00
end_define

begin_define
define|#
directive|define
name|DATA_OP_SHIFT
value|21
end_define

begin_define
define|#
directive|define
name|T2_OPCODE_MASK
value|0xfe1fffff
end_define

begin_define
define|#
directive|define
name|T2_DATA_OP_SHIFT
value|21
end_define

begin_comment
comment|/* Codes to distinguish the arithmetic instructions.  */
end_comment

begin_define
define|#
directive|define
name|OPCODE_AND
value|0
end_define

begin_define
define|#
directive|define
name|OPCODE_EOR
value|1
end_define

begin_define
define|#
directive|define
name|OPCODE_SUB
value|2
end_define

begin_define
define|#
directive|define
name|OPCODE_RSB
value|3
end_define

begin_define
define|#
directive|define
name|OPCODE_ADD
value|4
end_define

begin_define
define|#
directive|define
name|OPCODE_ADC
value|5
end_define

begin_define
define|#
directive|define
name|OPCODE_SBC
value|6
end_define

begin_define
define|#
directive|define
name|OPCODE_RSC
value|7
end_define

begin_define
define|#
directive|define
name|OPCODE_TST
value|8
end_define

begin_define
define|#
directive|define
name|OPCODE_TEQ
value|9
end_define

begin_define
define|#
directive|define
name|OPCODE_CMP
value|10
end_define

begin_define
define|#
directive|define
name|OPCODE_CMN
value|11
end_define

begin_define
define|#
directive|define
name|OPCODE_ORR
value|12
end_define

begin_define
define|#
directive|define
name|OPCODE_MOV
value|13
end_define

begin_define
define|#
directive|define
name|OPCODE_BIC
value|14
end_define

begin_define
define|#
directive|define
name|OPCODE_MVN
value|15
end_define

begin_define
define|#
directive|define
name|T2_OPCODE_AND
value|0
end_define

begin_define
define|#
directive|define
name|T2_OPCODE_BIC
value|1
end_define

begin_define
define|#
directive|define
name|T2_OPCODE_ORR
value|2
end_define

begin_define
define|#
directive|define
name|T2_OPCODE_ORN
value|3
end_define

begin_define
define|#
directive|define
name|T2_OPCODE_EOR
value|4
end_define

begin_define
define|#
directive|define
name|T2_OPCODE_ADD
value|8
end_define

begin_define
define|#
directive|define
name|T2_OPCODE_ADC
value|10
end_define

begin_define
define|#
directive|define
name|T2_OPCODE_SBC
value|11
end_define

begin_define
define|#
directive|define
name|T2_OPCODE_SUB
value|13
end_define

begin_define
define|#
directive|define
name|T2_OPCODE_RSB
value|14
end_define

begin_define
define|#
directive|define
name|T_OPCODE_MUL
value|0x4340
end_define

begin_define
define|#
directive|define
name|T_OPCODE_TST
value|0x4200
end_define

begin_define
define|#
directive|define
name|T_OPCODE_CMN
value|0x42c0
end_define

begin_define
define|#
directive|define
name|T_OPCODE_NEG
value|0x4240
end_define

begin_define
define|#
directive|define
name|T_OPCODE_MVN
value|0x43c0
end_define

begin_define
define|#
directive|define
name|T_OPCODE_ADD_R3
value|0x1800
end_define

begin_define
define|#
directive|define
name|T_OPCODE_SUB_R3
value|0x1a00
end_define

begin_define
define|#
directive|define
name|T_OPCODE_ADD_HI
value|0x4400
end_define

begin_define
define|#
directive|define
name|T_OPCODE_ADD_ST
value|0xb000
end_define

begin_define
define|#
directive|define
name|T_OPCODE_SUB_ST
value|0xb080
end_define

begin_define
define|#
directive|define
name|T_OPCODE_ADD_SP
value|0xa800
end_define

begin_define
define|#
directive|define
name|T_OPCODE_ADD_PC
value|0xa000
end_define

begin_define
define|#
directive|define
name|T_OPCODE_ADD_I8
value|0x3000
end_define

begin_define
define|#
directive|define
name|T_OPCODE_SUB_I8
value|0x3800
end_define

begin_define
define|#
directive|define
name|T_OPCODE_ADD_I3
value|0x1c00
end_define

begin_define
define|#
directive|define
name|T_OPCODE_SUB_I3
value|0x1e00
end_define

begin_define
define|#
directive|define
name|T_OPCODE_ASR_R
value|0x4100
end_define

begin_define
define|#
directive|define
name|T_OPCODE_LSL_R
value|0x4080
end_define

begin_define
define|#
directive|define
name|T_OPCODE_LSR_R
value|0x40c0
end_define

begin_define
define|#
directive|define
name|T_OPCODE_ROR_R
value|0x41c0
end_define

begin_define
define|#
directive|define
name|T_OPCODE_ASR_I
value|0x1000
end_define

begin_define
define|#
directive|define
name|T_OPCODE_LSL_I
value|0x0000
end_define

begin_define
define|#
directive|define
name|T_OPCODE_LSR_I
value|0x0800
end_define

begin_define
define|#
directive|define
name|T_OPCODE_MOV_I8
value|0x2000
end_define

begin_define
define|#
directive|define
name|T_OPCODE_CMP_I8
value|0x2800
end_define

begin_define
define|#
directive|define
name|T_OPCODE_CMP_LR
value|0x4280
end_define

begin_define
define|#
directive|define
name|T_OPCODE_MOV_HR
value|0x4600
end_define

begin_define
define|#
directive|define
name|T_OPCODE_CMP_HR
value|0x4500
end_define

begin_define
define|#
directive|define
name|T_OPCODE_LDR_PC
value|0x4800
end_define

begin_define
define|#
directive|define
name|T_OPCODE_LDR_SP
value|0x9800
end_define

begin_define
define|#
directive|define
name|T_OPCODE_STR_SP
value|0x9000
end_define

begin_define
define|#
directive|define
name|T_OPCODE_LDR_IW
value|0x6800
end_define

begin_define
define|#
directive|define
name|T_OPCODE_STR_IW
value|0x6000
end_define

begin_define
define|#
directive|define
name|T_OPCODE_LDR_IH
value|0x8800
end_define

begin_define
define|#
directive|define
name|T_OPCODE_STR_IH
value|0x8000
end_define

begin_define
define|#
directive|define
name|T_OPCODE_LDR_IB
value|0x7800
end_define

begin_define
define|#
directive|define
name|T_OPCODE_STR_IB
value|0x7000
end_define

begin_define
define|#
directive|define
name|T_OPCODE_LDR_RW
value|0x5800
end_define

begin_define
define|#
directive|define
name|T_OPCODE_STR_RW
value|0x5000
end_define

begin_define
define|#
directive|define
name|T_OPCODE_LDR_RH
value|0x5a00
end_define

begin_define
define|#
directive|define
name|T_OPCODE_STR_RH
value|0x5200
end_define

begin_define
define|#
directive|define
name|T_OPCODE_LDR_RB
value|0x5c00
end_define

begin_define
define|#
directive|define
name|T_OPCODE_STR_RB
value|0x5400
end_define

begin_define
define|#
directive|define
name|T_OPCODE_PUSH
value|0xb400
end_define

begin_define
define|#
directive|define
name|T_OPCODE_POP
value|0xbc00
end_define

begin_define
define|#
directive|define
name|T_OPCODE_BRANCH
value|0xe000
end_define

begin_define
define|#
directive|define
name|THUMB_SIZE
value|2
end_define

begin_comment
comment|/* Size of thumb instruction.  */
end_comment

begin_define
define|#
directive|define
name|THUMB_PP_PC_LR
value|0x0100
end_define

begin_define
define|#
directive|define
name|THUMB_LOAD_BIT
value|0x0800
end_define

begin_define
define|#
directive|define
name|THUMB2_LOAD_BIT
value|0x00100000
end_define

begin_define
define|#
directive|define
name|BAD_ARGS
value|_("bad arguments to instruction")
end_define

begin_define
define|#
directive|define
name|BAD_PC
value|_("r15 not allowed here")
end_define

begin_define
define|#
directive|define
name|BAD_SP
value|_("r13 not allowed here")
end_define

begin_define
define|#
directive|define
name|BAD_COND
value|_("instruction cannot be conditional")
end_define

begin_define
define|#
directive|define
name|BAD_OVERLAP
value|_("registers may not be the same")
end_define

begin_define
define|#
directive|define
name|BAD_HIREG
value|_("lo register required")
end_define

begin_define
define|#
directive|define
name|BAD_THUMB32
value|_("instruction not supported in Thumb16 mode")
end_define

begin_define
define|#
directive|define
name|BAD_ADDR_MODE
value|_("instruction does not accept this addressing mode");
end_define

begin_define
define|#
directive|define
name|BAD_BRANCH
value|_("branch must be last instruction in IT block")
end_define

begin_define
define|#
directive|define
name|BAD_NOT_IT
value|_("instruction not allowed in IT block")
end_define

begin_define
define|#
directive|define
name|BAD_FPU
value|_("selected FPU does not support instruction")
end_define

begin_define
define|#
directive|define
name|BAD_VMRS
value|_("APSR_nzcv may only be used with fpscr")
end_define

begin_decl_stmt
specifier|static
name|struct
name|hash_control
modifier|*
name|arm_ops_hsh
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|hash_control
modifier|*
name|arm_cond_hsh
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|hash_control
modifier|*
name|arm_shift_hsh
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|hash_control
modifier|*
name|arm_psr_hsh
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|hash_control
modifier|*
name|arm_v7m_psr_hsh
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|hash_control
modifier|*
name|arm_reg_hsh
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|hash_control
modifier|*
name|arm_reloc_hsh
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|hash_control
modifier|*
name|arm_barrier_opt_hsh
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Stuff needed to resolve the label ambiguity    As:      ...      label:<insn>    may differ from:      ...      label:<insn> */
end_comment

begin_decl_stmt
name|symbolS
modifier|*
name|last_label_seen
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|label_is_thumb_function_name
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Literal pool structure.  Held on a per-section    and per-sub-section basis.  */
end_comment

begin_define
define|#
directive|define
name|MAX_LITERAL_POOL_SIZE
value|1024
end_define

begin_typedef
typedef|typedef
struct|struct
name|literal_pool
block|{
name|expressionS
name|literals
index|[
name|MAX_LITERAL_POOL_SIZE
index|]
decl_stmt|;
name|unsigned
name|int
name|next_free_entry
decl_stmt|;
name|unsigned
name|int
name|id
decl_stmt|;
name|symbolS
modifier|*
name|symbol
decl_stmt|;
name|segT
name|section
decl_stmt|;
name|subsegT
name|sub_section
decl_stmt|;
name|struct
name|literal_pool
modifier|*
name|next
decl_stmt|;
block|}
name|literal_pool
typedef|;
end_typedef

begin_comment
comment|/* Pointer to a linked list of literal pools.  */
end_comment

begin_decl_stmt
name|literal_pool
modifier|*
name|list_of_pools
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* State variables for IT block handling.  */
end_comment

begin_decl_stmt
specifier|static
name|bfd_boolean
name|current_it_mask
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|current_cc
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Pure syntax.	 */
end_comment

begin_comment
comment|/* This array holds the chars that always start a comment.  If the    pre-processor is disabled, these aren't very useful.	 */
end_comment

begin_decl_stmt
specifier|const
name|char
name|comment_chars
index|[]
init|=
literal|"@"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This array holds the chars that only start a comment at the beginning of    a line.  If the line seems to have the form '# 123 filename'    .line and .file directives will appear in the pre-processed output.	*/
end_comment

begin_comment
comment|/* Note that input_file.c hand checks for '#' at the beginning of the    first line of the input file.  This is because the compiler outputs    #NO_APP at the beginning of its output.  */
end_comment

begin_comment
comment|/* Also note that comments like this one will always work.  */
end_comment

begin_decl_stmt
specifier|const
name|char
name|line_comment_chars
index|[]
init|=
literal|"#"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
name|line_separator_chars
index|[]
init|=
literal|";"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Chars that can be used to separate mant    from exp in floating point numbers.	*/
end_comment

begin_decl_stmt
specifier|const
name|char
name|EXP_CHARS
index|[]
init|=
literal|"eE"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Chars that mean this number is a floating point constant.  */
end_comment

begin_comment
comment|/* As in 0f12.456  */
end_comment

begin_comment
comment|/* or	 0d1.2345e12  */
end_comment

begin_decl_stmt
specifier|const
name|char
name|FLT_CHARS
index|[]
init|=
literal|"rRsSfFdDxXeEpP"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Prefix characters that indicate the start of an immediate    value.  */
end_comment

begin_define
define|#
directive|define
name|is_immediate_prefix
parameter_list|(
name|C
parameter_list|)
value|((C) == '#' || (C) == '$')
end_define

begin_comment
comment|/* Separator character handling.  */
end_comment

begin_define
define|#
directive|define
name|skip_whitespace
parameter_list|(
name|str
parameter_list|)
value|do { if (*(str) == ' ') ++(str); } while (0)
end_define

begin_function
specifier|static
specifier|inline
name|int
name|skip_past_char
parameter_list|(
name|char
modifier|*
modifier|*
name|str
parameter_list|,
name|char
name|c
parameter_list|)
block|{
if|if
condition|(
operator|*
operator|*
name|str
operator|==
name|c
condition|)
block|{
operator|(
operator|*
name|str
operator|)
operator|++
expr_stmt|;
return|return
name|SUCCESS
return|;
block|}
else|else
return|return
name|FAIL
return|;
block|}
end_function

begin_define
define|#
directive|define
name|skip_past_comma
parameter_list|(
name|str
parameter_list|)
value|skip_past_char (str, ',')
end_define

begin_comment
comment|/* Arithmetic expressions (possibly involving symbols).	 */
end_comment

begin_comment
comment|/* Return TRUE if anything in the expression is a bignum.  */
end_comment

begin_function
specifier|static
name|int
name|walk_no_bignums
parameter_list|(
name|symbolS
modifier|*
name|sp
parameter_list|)
block|{
if|if
condition|(
name|symbol_get_value_expression
argument_list|(
name|sp
argument_list|)
operator|->
name|X_op
operator|==
name|O_big
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|symbol_get_value_expression
argument_list|(
name|sp
argument_list|)
operator|->
name|X_add_symbol
condition|)
block|{
return|return
operator|(
name|walk_no_bignums
argument_list|(
name|symbol_get_value_expression
argument_list|(
name|sp
argument_list|)
operator|->
name|X_add_symbol
argument_list|)
operator|||
operator|(
name|symbol_get_value_expression
argument_list|(
name|sp
argument_list|)
operator|->
name|X_op_symbol
operator|&&
name|walk_no_bignums
argument_list|(
name|symbol_get_value_expression
argument_list|(
name|sp
argument_list|)
operator|->
name|X_op_symbol
argument_list|)
operator|)
operator|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|int
name|in_my_get_expression
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Third argument to my_get_expression.	 */
end_comment

begin_define
define|#
directive|define
name|GE_NO_PREFIX
value|0
end_define

begin_define
define|#
directive|define
name|GE_IMM_PREFIX
value|1
end_define

begin_define
define|#
directive|define
name|GE_OPT_PREFIX
value|2
end_define

begin_comment
comment|/* This is a bit of a hack. Use an optional prefix, and also allow big (64-bit)    immediates, as can be used in Neon VMVN and VMOV immediate instructions.  */
end_comment

begin_define
define|#
directive|define
name|GE_OPT_PREFIX_BIG
value|3
end_define

begin_function
specifier|static
name|int
name|my_get_expression
parameter_list|(
name|expressionS
modifier|*
name|ep
parameter_list|,
name|char
modifier|*
modifier|*
name|str
parameter_list|,
name|int
name|prefix_mode
parameter_list|)
block|{
name|char
modifier|*
name|save_in
decl_stmt|;
name|segT
name|seg
decl_stmt|;
comment|/* In unified syntax, all prefixes are optional.  */
if|if
condition|(
name|unified_syntax
condition|)
name|prefix_mode
operator|=
operator|(
name|prefix_mode
operator|==
name|GE_OPT_PREFIX_BIG
operator|)
condition|?
name|prefix_mode
else|:
name|GE_OPT_PREFIX
expr_stmt|;
switch|switch
condition|(
name|prefix_mode
condition|)
block|{
case|case
name|GE_NO_PREFIX
case|:
break|break;
case|case
name|GE_IMM_PREFIX
case|:
if|if
condition|(
operator|!
name|is_immediate_prefix
argument_list|(
operator|*
operator|*
name|str
argument_list|)
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"immediate expression requires a # prefix"
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
block|}
operator|(
operator|*
name|str
operator|)
operator|++
expr_stmt|;
break|break;
case|case
name|GE_OPT_PREFIX
case|:
case|case
name|GE_OPT_PREFIX_BIG
case|:
if|if
condition|(
name|is_immediate_prefix
argument_list|(
operator|*
operator|*
name|str
argument_list|)
condition|)
operator|(
operator|*
name|str
operator|)
operator|++
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|memset
argument_list|(
name|ep
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|expressionS
argument_list|)
argument_list|)
expr_stmt|;
name|save_in
operator|=
name|input_line_pointer
expr_stmt|;
name|input_line_pointer
operator|=
operator|*
name|str
expr_stmt|;
name|in_my_get_expression
operator|=
literal|1
expr_stmt|;
name|seg
operator|=
name|expression
argument_list|(
name|ep
argument_list|)
expr_stmt|;
name|in_my_get_expression
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ep
operator|->
name|X_op
operator|==
name|O_illegal
condition|)
block|{
comment|/* We found a bad expression in md_operand().  */
operator|*
name|str
operator|=
name|input_line_pointer
expr_stmt|;
name|input_line_pointer
operator|=
name|save_in
expr_stmt|;
if|if
condition|(
name|inst
operator|.
name|error
operator|==
name|NULL
condition|)
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"bad expression"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
ifdef|#
directive|ifdef
name|OBJ_AOUT
if|if
condition|(
name|seg
operator|!=
name|absolute_section
operator|&&
name|seg
operator|!=
name|text_section
operator|&&
name|seg
operator|!=
name|data_section
operator|&&
name|seg
operator|!=
name|bss_section
operator|&&
name|seg
operator|!=
name|undefined_section
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"bad segment"
argument_list|)
expr_stmt|;
operator|*
name|str
operator|=
name|input_line_pointer
expr_stmt|;
name|input_line_pointer
operator|=
name|save_in
expr_stmt|;
return|return
literal|1
return|;
block|}
endif|#
directive|endif
comment|/* Get rid of any bignums now, so that we don't generate an error for which      we can't establish a line number later on.	 Big numbers are never valid      in instructions, which is where this routine is always called.  */
if|if
condition|(
name|prefix_mode
operator|!=
name|GE_OPT_PREFIX_BIG
operator|&&
operator|(
name|ep
operator|->
name|X_op
operator|==
name|O_big
operator|||
operator|(
name|ep
operator|->
name|X_add_symbol
operator|&&
operator|(
name|walk_no_bignums
argument_list|(
name|ep
operator|->
name|X_add_symbol
argument_list|)
operator|||
operator|(
name|ep
operator|->
name|X_op_symbol
operator|&&
name|walk_no_bignums
argument_list|(
name|ep
operator|->
name|X_op_symbol
argument_list|)
operator|)
operator|)
operator|)
operator|)
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"invalid constant"
argument_list|)
expr_stmt|;
operator|*
name|str
operator|=
name|input_line_pointer
expr_stmt|;
name|input_line_pointer
operator|=
name|save_in
expr_stmt|;
return|return
literal|1
return|;
block|}
operator|*
name|str
operator|=
name|input_line_pointer
expr_stmt|;
name|input_line_pointer
operator|=
name|save_in
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Turn a string in input_line_pointer into a floating point constant    of type TYPE, and store the appropriate bytes in *LITP.  The number    of LITTLENUMS emitted is stored in *SIZEP.  An error message is    returned, or NULL on OK.     Note that fp constants aren't represent in the normal way on the ARM.    In big endian mode, things are as expected.	However, in little endian    mode fp constants are big-endian word-wise, and little-endian byte-wise    within the words.  For example, (double) 1.1 in big endian mode is    the byte sequence 3f f1 99 99 99 99 99 9a, and in little endian mode is    the byte sequence 99 99 f1 3f 9a 99 99 99.     ??? The format of 12 byte floats is uncertain according to gcc's arm.h.  */
end_comment

begin_function
name|char
modifier|*
name|md_atof
parameter_list|(
name|int
name|type
parameter_list|,
name|char
modifier|*
name|litP
parameter_list|,
name|int
modifier|*
name|sizeP
parameter_list|)
block|{
name|int
name|prec
decl_stmt|;
name|LITTLENUM_TYPE
name|words
index|[
name|MAX_LITTLENUMS
index|]
decl_stmt|;
name|char
modifier|*
name|t
decl_stmt|;
name|int
name|i
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
literal|'f'
case|:
case|case
literal|'F'
case|:
case|case
literal|'s'
case|:
case|case
literal|'S'
case|:
name|prec
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
case|case
literal|'D'
case|:
case|case
literal|'r'
case|:
case|case
literal|'R'
case|:
name|prec
operator|=
literal|4
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
case|case
literal|'X'
case|:
name|prec
operator|=
literal|6
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
case|case
literal|'P'
case|:
name|prec
operator|=
literal|6
expr_stmt|;
break|break;
default|default:
operator|*
name|sizeP
operator|=
literal|0
expr_stmt|;
return|return
name|_
argument_list|(
literal|"bad call to MD_ATOF()"
argument_list|)
return|;
block|}
name|t
operator|=
name|atof_ieee
argument_list|(
name|input_line_pointer
argument_list|,
name|type
argument_list|,
name|words
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
condition|)
name|input_line_pointer
operator|=
name|t
expr_stmt|;
operator|*
name|sizeP
operator|=
name|prec
operator|*
literal|2
expr_stmt|;
if|if
condition|(
name|target_big_endian
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|prec
condition|;
name|i
operator|++
control|)
block|{
name|md_number_to_chars
argument_list|(
name|litP
argument_list|,
operator|(
name|valueT
operator|)
name|words
index|[
name|i
index|]
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|litP
operator|+=
literal|2
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|ARM_CPU_HAS_FEATURE
argument_list|(
name|cpu_variant
argument_list|,
name|fpu_endian_pure
argument_list|)
condition|)
for|for
control|(
name|i
operator|=
name|prec
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|md_number_to_chars
argument_list|(
name|litP
argument_list|,
operator|(
name|valueT
operator|)
name|words
index|[
name|i
index|]
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|litP
operator|+=
literal|2
expr_stmt|;
block|}
else|else
comment|/* For a 4 byte float the order of elements in `words' is 1 0. 	   For an 8 byte float the order is 1 0 3 2.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|prec
condition|;
name|i
operator|+=
literal|2
control|)
block|{
name|md_number_to_chars
argument_list|(
name|litP
argument_list|,
operator|(
name|valueT
operator|)
name|words
index|[
name|i
operator|+
literal|1
index|]
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|litP
operator|+
literal|2
argument_list|,
operator|(
name|valueT
operator|)
name|words
index|[
name|i
index|]
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|litP
operator|+=
literal|4
expr_stmt|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* We handle all bad expressions here, so that we can report the faulty    instruction in the error message.  */
end_comment

begin_function
name|void
name|md_operand
parameter_list|(
name|expressionS
modifier|*
name|expr
parameter_list|)
block|{
if|if
condition|(
name|in_my_get_expression
condition|)
name|expr
operator|->
name|X_op
operator|=
name|O_illegal
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Immediate values.  */
end_comment

begin_comment
comment|/* Generic immediate-value read function for use in directives.    Accepts anything that 'expression' can fold to a constant.    *val receives the number.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|OBJ_ELF
end_ifdef

begin_function
specifier|static
name|int
name|immediate_for_directive
parameter_list|(
name|int
modifier|*
name|val
parameter_list|)
block|{
name|expressionS
name|exp
decl_stmt|;
name|exp
operator|.
name|X_op
operator|=
name|O_illegal
expr_stmt|;
if|if
condition|(
name|is_immediate_prefix
argument_list|(
operator|*
name|input_line_pointer
argument_list|)
condition|)
block|{
name|input_line_pointer
operator|++
expr_stmt|;
name|expression
argument_list|(
operator|&
name|exp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|exp
operator|.
name|X_op
operator|!=
name|O_constant
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"expected #constant"
argument_list|)
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return
name|FAIL
return|;
block|}
operator|*
name|val
operator|=
name|exp
operator|.
name|X_add_number
expr_stmt|;
return|return
name|SUCCESS
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Register parsing.  */
end_comment

begin_comment
comment|/* Generic register parser.  CCP points to what should be the    beginning of a register name.  If it is indeed a valid register    name, advance CCP over it and return the reg_entry structure;    otherwise return NULL.  Does not issue diagnostics.	*/
end_comment

begin_function
specifier|static
name|struct
name|reg_entry
modifier|*
name|arm_reg_parse_multi
parameter_list|(
name|char
modifier|*
modifier|*
name|ccp
parameter_list|)
block|{
name|char
modifier|*
name|start
init|=
operator|*
name|ccp
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|struct
name|reg_entry
modifier|*
name|reg
decl_stmt|;
ifdef|#
directive|ifdef
name|REGISTER_PREFIX
if|if
condition|(
operator|*
name|start
operator|!=
name|REGISTER_PREFIX
condition|)
return|return
name|NULL
return|;
name|start
operator|++
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|OPTIONAL_REGISTER_PREFIX
if|if
condition|(
operator|*
name|start
operator|==
name|OPTIONAL_REGISTER_PREFIX
condition|)
name|start
operator|++
expr_stmt|;
endif|#
directive|endif
name|p
operator|=
name|start
expr_stmt|;
if|if
condition|(
operator|!
name|ISALPHA
argument_list|(
operator|*
name|p
argument_list|)
operator|||
operator|!
name|is_name_beginner
argument_list|(
operator|*
name|p
argument_list|)
condition|)
return|return
name|NULL
return|;
do|do
name|p
operator|++
expr_stmt|;
do|while
condition|(
name|ISALPHA
argument_list|(
operator|*
name|p
argument_list|)
operator|||
name|ISDIGIT
argument_list|(
operator|*
name|p
argument_list|)
operator|||
operator|*
name|p
operator|==
literal|'_'
condition|)
do|;
name|reg
operator|=
operator|(
expr|struct
name|reg_entry
operator|*
operator|)
name|hash_find_n
argument_list|(
name|arm_reg_hsh
argument_list|,
name|start
argument_list|,
name|p
operator|-
name|start
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|reg
condition|)
return|return
name|NULL
return|;
operator|*
name|ccp
operator|=
name|p
expr_stmt|;
return|return
name|reg
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|arm_reg_alt_syntax
parameter_list|(
name|char
modifier|*
modifier|*
name|ccp
parameter_list|,
name|char
modifier|*
name|start
parameter_list|,
name|struct
name|reg_entry
modifier|*
name|reg
parameter_list|,
name|enum
name|arm_reg_type
name|type
parameter_list|)
block|{
comment|/* Alternative syntaxes are accepted for a few register classes.  */
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|REG_TYPE_MVF
case|:
case|case
name|REG_TYPE_MVD
case|:
case|case
name|REG_TYPE_MVFX
case|:
case|case
name|REG_TYPE_MVDX
case|:
comment|/* Generic coprocessor register names are allowed for these.  */
if|if
condition|(
name|reg
operator|&&
name|reg
operator|->
name|type
operator|==
name|REG_TYPE_CN
condition|)
return|return
name|reg
operator|->
name|number
return|;
break|break;
case|case
name|REG_TYPE_CP
case|:
comment|/* For backward compatibility, a bare number is valid here.  */
block|{
name|unsigned
name|long
name|processor
init|=
name|strtoul
argument_list|(
name|start
argument_list|,
name|ccp
argument_list|,
literal|10
argument_list|)
decl_stmt|;
if|if
condition|(
operator|*
name|ccp
operator|!=
name|start
operator|&&
name|processor
operator|<=
literal|15
condition|)
return|return
name|processor
return|;
block|}
case|case
name|REG_TYPE_MMXWC
case|:
comment|/* WC includes WCG.  ??? I'm not sure this is true for all 	 instructions that take WC registers.  */
if|if
condition|(
name|reg
operator|&&
name|reg
operator|->
name|type
operator|==
name|REG_TYPE_MMXWCG
condition|)
return|return
name|reg
operator|->
name|number
return|;
break|break;
default|default:
break|break;
block|}
return|return
name|FAIL
return|;
block|}
end_function

begin_comment
comment|/* As arm_reg_parse_multi, but the register must be of type TYPE, and the    return value is the register number or FAIL.  */
end_comment

begin_function
specifier|static
name|int
name|arm_reg_parse
parameter_list|(
name|char
modifier|*
modifier|*
name|ccp
parameter_list|,
name|enum
name|arm_reg_type
name|type
parameter_list|)
block|{
name|char
modifier|*
name|start
init|=
operator|*
name|ccp
decl_stmt|;
name|struct
name|reg_entry
modifier|*
name|reg
init|=
name|arm_reg_parse_multi
argument_list|(
name|ccp
argument_list|)
decl_stmt|;
name|int
name|ret
decl_stmt|;
comment|/* Do not allow a scalar (reg+index) to parse as a register.  */
if|if
condition|(
name|reg
operator|&&
name|reg
operator|->
name|neon
operator|&&
operator|(
name|reg
operator|->
name|neon
operator|->
name|defined
operator|&
name|NTA_HASINDEX
operator|)
condition|)
return|return
name|FAIL
return|;
if|if
condition|(
name|reg
operator|&&
name|reg
operator|->
name|type
operator|==
name|type
condition|)
return|return
name|reg
operator|->
name|number
return|;
if|if
condition|(
operator|(
name|ret
operator|=
name|arm_reg_alt_syntax
argument_list|(
name|ccp
argument_list|,
name|start
argument_list|,
name|reg
argument_list|,
name|type
argument_list|)
operator|)
operator|!=
name|FAIL
condition|)
return|return
name|ret
return|;
operator|*
name|ccp
operator|=
name|start
expr_stmt|;
return|return
name|FAIL
return|;
block|}
end_function

begin_comment
comment|/* Parse a Neon type specifier. *STR should point at the leading '.'    character. Does no verification at this stage that the type fits the opcode    properly. E.g.,       .i32.i32.s16      .s32.f32      .u16     Can all be legally parsed by this function.     Fills in neon_type struct pointer with parsed information, and updates STR    to point after the parsed type specifier. Returns SUCCESS if this was a legal    type, FAIL if not.  */
end_comment

begin_function
specifier|static
name|int
name|parse_neon_type
parameter_list|(
name|struct
name|neon_type
modifier|*
name|type
parameter_list|,
name|char
modifier|*
modifier|*
name|str
parameter_list|)
block|{
name|char
modifier|*
name|ptr
init|=
operator|*
name|str
decl_stmt|;
if|if
condition|(
name|type
condition|)
name|type
operator|->
name|elems
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|type
operator|->
name|elems
operator|<
name|NEON_MAX_TYPE_ELS
condition|)
block|{
name|enum
name|neon_el_type
name|thistype
init|=
name|NT_untyped
decl_stmt|;
name|unsigned
name|thissize
init|=
operator|-
literal|1u
decl_stmt|;
if|if
condition|(
operator|*
name|ptr
operator|!=
literal|'.'
condition|)
break|break;
name|ptr
operator|++
expr_stmt|;
comment|/* Just a size without an explicit type.  */
if|if
condition|(
name|ISDIGIT
argument_list|(
operator|*
name|ptr
argument_list|)
condition|)
goto|goto
name|parsesize
goto|;
switch|switch
condition|(
name|TOLOWER
argument_list|(
operator|*
name|ptr
argument_list|)
condition|)
block|{
case|case
literal|'i'
case|:
name|thistype
operator|=
name|NT_integer
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|thistype
operator|=
name|NT_float
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|thistype
operator|=
name|NT_poly
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|thistype
operator|=
name|NT_signed
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
name|thistype
operator|=
name|NT_unsigned
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|thistype
operator|=
name|NT_float
expr_stmt|;
name|thissize
operator|=
literal|64
expr_stmt|;
name|ptr
operator|++
expr_stmt|;
goto|goto
name|done
goto|;
default|default:
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"unexpected character `%c' in type specifier"
argument_list|)
argument_list|,
operator|*
name|ptr
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
block|}
name|ptr
operator|++
expr_stmt|;
comment|/* .f is an abbreviation for .f32.  */
if|if
condition|(
name|thistype
operator|==
name|NT_float
operator|&&
operator|!
name|ISDIGIT
argument_list|(
operator|*
name|ptr
argument_list|)
condition|)
name|thissize
operator|=
literal|32
expr_stmt|;
else|else
block|{
name|parsesize
label|:
name|thissize
operator|=
name|strtoul
argument_list|(
name|ptr
argument_list|,
operator|&
name|ptr
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|thissize
operator|!=
literal|8
operator|&&
name|thissize
operator|!=
literal|16
operator|&&
name|thissize
operator|!=
literal|32
operator|&&
name|thissize
operator|!=
literal|64
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"bad size %d in type specifier"
argument_list|)
argument_list|,
name|thissize
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
block|}
block|}
name|done
label|:
if|if
condition|(
name|type
condition|)
block|{
name|type
operator|->
name|el
index|[
name|type
operator|->
name|elems
index|]
operator|.
name|type
operator|=
name|thistype
expr_stmt|;
name|type
operator|->
name|el
index|[
name|type
operator|->
name|elems
index|]
operator|.
name|size
operator|=
name|thissize
expr_stmt|;
name|type
operator|->
name|elems
operator|++
expr_stmt|;
block|}
block|}
comment|/* Empty/missing type is not a successful parse.  */
if|if
condition|(
name|type
operator|->
name|elems
operator|==
literal|0
condition|)
return|return
name|FAIL
return|;
operator|*
name|str
operator|=
name|ptr
expr_stmt|;
return|return
name|SUCCESS
return|;
block|}
end_function

begin_comment
comment|/* Errors may be set multiple times during parsing or bit encoding    (particularly in the Neon bits), but usually the earliest error which is set    will be the most meaningful. Avoid overwriting it with later (cascading)    errors by calling this function.  */
end_comment

begin_function
specifier|static
name|void
name|first_error
parameter_list|(
specifier|const
name|char
modifier|*
name|err
parameter_list|)
block|{
if|if
condition|(
operator|!
name|inst
operator|.
name|error
condition|)
name|inst
operator|.
name|error
operator|=
name|err
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Parse a single type, e.g. ".s32", leading period included.  */
end_comment

begin_function
specifier|static
name|int
name|parse_neon_operand_type
parameter_list|(
name|struct
name|neon_type_el
modifier|*
name|vectype
parameter_list|,
name|char
modifier|*
modifier|*
name|ccp
parameter_list|)
block|{
name|char
modifier|*
name|str
init|=
operator|*
name|ccp
decl_stmt|;
name|struct
name|neon_type
name|optype
decl_stmt|;
if|if
condition|(
operator|*
name|str
operator|==
literal|'.'
condition|)
block|{
if|if
condition|(
name|parse_neon_type
argument_list|(
operator|&
name|optype
argument_list|,
operator|&
name|str
argument_list|)
operator|==
name|SUCCESS
condition|)
block|{
if|if
condition|(
name|optype
operator|.
name|elems
operator|==
literal|1
condition|)
operator|*
name|vectype
operator|=
name|optype
operator|.
name|el
index|[
literal|0
index|]
expr_stmt|;
else|else
block|{
name|first_error
argument_list|(
name|_
argument_list|(
literal|"only one type should be specified for operand"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
block|}
block|}
else|else
block|{
name|first_error
argument_list|(
name|_
argument_list|(
literal|"vector type expected"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
block|}
block|}
else|else
return|return
name|FAIL
return|;
operator|*
name|ccp
operator|=
name|str
expr_stmt|;
return|return
name|SUCCESS
return|;
block|}
end_function

begin_comment
comment|/* Special meanings for indices (which have a range of 0-7), which will fit into    a 4-bit integer.  */
end_comment

begin_define
define|#
directive|define
name|NEON_ALL_LANES
value|15
end_define

begin_define
define|#
directive|define
name|NEON_INTERLEAVE_LANES
value|14
end_define

begin_comment
comment|/* Parse either a register or a scalar, with an optional type. Return the    register number, and optionally fill in the actual type of the register    when multiple alternatives were given (NEON_TYPE_NDQ) in *RTYPE, and    type/index information in *TYPEINFO.  */
end_comment

begin_function
specifier|static
name|int
name|parse_typed_reg_or_scalar
parameter_list|(
name|char
modifier|*
modifier|*
name|ccp
parameter_list|,
name|enum
name|arm_reg_type
name|type
parameter_list|,
name|enum
name|arm_reg_type
modifier|*
name|rtype
parameter_list|,
name|struct
name|neon_typed_alias
modifier|*
name|typeinfo
parameter_list|)
block|{
name|char
modifier|*
name|str
init|=
operator|*
name|ccp
decl_stmt|;
name|struct
name|reg_entry
modifier|*
name|reg
init|=
name|arm_reg_parse_multi
argument_list|(
operator|&
name|str
argument_list|)
decl_stmt|;
name|struct
name|neon_typed_alias
name|atype
decl_stmt|;
name|struct
name|neon_type_el
name|parsetype
decl_stmt|;
name|atype
operator|.
name|defined
operator|=
literal|0
expr_stmt|;
name|atype
operator|.
name|index
operator|=
operator|-
literal|1
expr_stmt|;
name|atype
operator|.
name|eltype
operator|.
name|type
operator|=
name|NT_invtype
expr_stmt|;
name|atype
operator|.
name|eltype
operator|.
name|size
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* Try alternate syntax for some types of register. Note these are mutually      exclusive with the Neon syntax extensions.  */
if|if
condition|(
name|reg
operator|==
name|NULL
condition|)
block|{
name|int
name|altreg
init|=
name|arm_reg_alt_syntax
argument_list|(
operator|&
name|str
argument_list|,
operator|*
name|ccp
argument_list|,
name|reg
argument_list|,
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|altreg
operator|!=
name|FAIL
condition|)
operator|*
name|ccp
operator|=
name|str
expr_stmt|;
if|if
condition|(
name|typeinfo
condition|)
operator|*
name|typeinfo
operator|=
name|atype
expr_stmt|;
return|return
name|altreg
return|;
block|}
comment|/* Undo polymorphism when a set of register types may be accepted.  */
if|if
condition|(
operator|(
name|type
operator|==
name|REG_TYPE_NDQ
operator|&&
operator|(
name|reg
operator|->
name|type
operator|==
name|REG_TYPE_NQ
operator|||
name|reg
operator|->
name|type
operator|==
name|REG_TYPE_VFD
operator|)
operator|)
operator|||
operator|(
name|type
operator|==
name|REG_TYPE_VFSD
operator|&&
operator|(
name|reg
operator|->
name|type
operator|==
name|REG_TYPE_VFS
operator|||
name|reg
operator|->
name|type
operator|==
name|REG_TYPE_VFD
operator|)
operator|)
operator|||
operator|(
name|type
operator|==
name|REG_TYPE_NSDQ
operator|&&
operator|(
name|reg
operator|->
name|type
operator|==
name|REG_TYPE_VFS
operator|||
name|reg
operator|->
name|type
operator|==
name|REG_TYPE_VFD
operator|||
name|reg
operator|->
name|type
operator|==
name|REG_TYPE_NQ
operator|)
operator|)
operator|||
operator|(
name|type
operator|==
name|REG_TYPE_MMXWC
operator|&&
operator|(
name|reg
operator|->
name|type
operator|==
name|REG_TYPE_MMXWCG
operator|)
operator|)
condition|)
name|type
operator|=
name|reg
operator|->
name|type
expr_stmt|;
if|if
condition|(
name|type
operator|!=
name|reg
operator|->
name|type
condition|)
return|return
name|FAIL
return|;
if|if
condition|(
name|reg
operator|->
name|neon
condition|)
name|atype
operator|=
operator|*
name|reg
operator|->
name|neon
expr_stmt|;
if|if
condition|(
name|parse_neon_operand_type
argument_list|(
operator|&
name|parsetype
argument_list|,
operator|&
name|str
argument_list|)
operator|==
name|SUCCESS
condition|)
block|{
if|if
condition|(
operator|(
name|atype
operator|.
name|defined
operator|&
name|NTA_HASTYPE
operator|)
operator|!=
literal|0
condition|)
block|{
name|first_error
argument_list|(
name|_
argument_list|(
literal|"can't redefine type for operand"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
block|}
name|atype
operator|.
name|defined
operator||=
name|NTA_HASTYPE
expr_stmt|;
name|atype
operator|.
name|eltype
operator|=
name|parsetype
expr_stmt|;
block|}
if|if
condition|(
name|skip_past_char
argument_list|(
operator|&
name|str
argument_list|,
literal|'['
argument_list|)
operator|==
name|SUCCESS
condition|)
block|{
if|if
condition|(
name|type
operator|!=
name|REG_TYPE_VFD
condition|)
block|{
name|first_error
argument_list|(
name|_
argument_list|(
literal|"only D registers may be indexed"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
block|}
if|if
condition|(
operator|(
name|atype
operator|.
name|defined
operator|&
name|NTA_HASINDEX
operator|)
operator|!=
literal|0
condition|)
block|{
name|first_error
argument_list|(
name|_
argument_list|(
literal|"can't change index for operand"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
block|}
name|atype
operator|.
name|defined
operator||=
name|NTA_HASINDEX
expr_stmt|;
if|if
condition|(
name|skip_past_char
argument_list|(
operator|&
name|str
argument_list|,
literal|']'
argument_list|)
operator|==
name|SUCCESS
condition|)
name|atype
operator|.
name|index
operator|=
name|NEON_ALL_LANES
expr_stmt|;
else|else
block|{
name|expressionS
name|exp
decl_stmt|;
name|my_get_expression
argument_list|(
operator|&
name|exp
argument_list|,
operator|&
name|str
argument_list|,
name|GE_NO_PREFIX
argument_list|)
expr_stmt|;
if|if
condition|(
name|exp
operator|.
name|X_op
operator|!=
name|O_constant
condition|)
block|{
name|first_error
argument_list|(
name|_
argument_list|(
literal|"constant expression required"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
block|}
if|if
condition|(
name|skip_past_char
argument_list|(
operator|&
name|str
argument_list|,
literal|']'
argument_list|)
operator|==
name|FAIL
condition|)
return|return
name|FAIL
return|;
name|atype
operator|.
name|index
operator|=
name|exp
operator|.
name|X_add_number
expr_stmt|;
block|}
block|}
if|if
condition|(
name|typeinfo
condition|)
operator|*
name|typeinfo
operator|=
name|atype
expr_stmt|;
if|if
condition|(
name|rtype
condition|)
operator|*
name|rtype
operator|=
name|type
expr_stmt|;
operator|*
name|ccp
operator|=
name|str
expr_stmt|;
return|return
name|reg
operator|->
name|number
return|;
block|}
end_function

begin_comment
comment|/* Like arm_reg_parse, but allow allow the following extra features:     - If RTYPE is non-zero, return the (possibly restricted) type of the       register (e.g. Neon double or quad reg when either has been requested).     - If this is a Neon vector type with additional type information, fill       in the struct pointed to by VECTYPE (if non-NULL).    This function will fault on encountering a scalar. */
end_comment

begin_function
specifier|static
name|int
name|arm_typed_reg_parse
parameter_list|(
name|char
modifier|*
modifier|*
name|ccp
parameter_list|,
name|enum
name|arm_reg_type
name|type
parameter_list|,
name|enum
name|arm_reg_type
modifier|*
name|rtype
parameter_list|,
name|struct
name|neon_type_el
modifier|*
name|vectype
parameter_list|)
block|{
name|struct
name|neon_typed_alias
name|atype
decl_stmt|;
name|char
modifier|*
name|str
init|=
operator|*
name|ccp
decl_stmt|;
name|int
name|reg
init|=
name|parse_typed_reg_or_scalar
argument_list|(
operator|&
name|str
argument_list|,
name|type
argument_list|,
name|rtype
argument_list|,
operator|&
name|atype
argument_list|)
decl_stmt|;
if|if
condition|(
name|reg
operator|==
name|FAIL
condition|)
return|return
name|FAIL
return|;
comment|/* Do not allow a scalar (reg+index) to parse as a register.  */
if|if
condition|(
operator|(
name|atype
operator|.
name|defined
operator|&
name|NTA_HASINDEX
operator|)
operator|!=
literal|0
condition|)
block|{
name|first_error
argument_list|(
name|_
argument_list|(
literal|"register operand expected, but got scalar"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
block|}
if|if
condition|(
name|vectype
condition|)
operator|*
name|vectype
operator|=
name|atype
operator|.
name|eltype
expr_stmt|;
operator|*
name|ccp
operator|=
name|str
expr_stmt|;
return|return
name|reg
return|;
block|}
end_function

begin_define
define|#
directive|define
name|NEON_SCALAR_REG
parameter_list|(
name|X
parameter_list|)
value|((X)>> 4)
end_define

begin_define
define|#
directive|define
name|NEON_SCALAR_INDEX
parameter_list|(
name|X
parameter_list|)
value|((X)& 15)
end_define

begin_comment
comment|/* Parse a Neon scalar. Most of the time when we're parsing a scalar, we don't    have enough information to be able to do a good job bounds-checking. So, we    just do easy checks here, and do further checks later.  */
end_comment

begin_function
specifier|static
name|int
name|parse_scalar
parameter_list|(
name|char
modifier|*
modifier|*
name|ccp
parameter_list|,
name|int
name|elsize
parameter_list|,
name|struct
name|neon_type_el
modifier|*
name|type
parameter_list|)
block|{
name|int
name|reg
decl_stmt|;
name|char
modifier|*
name|str
init|=
operator|*
name|ccp
decl_stmt|;
name|struct
name|neon_typed_alias
name|atype
decl_stmt|;
name|reg
operator|=
name|parse_typed_reg_or_scalar
argument_list|(
operator|&
name|str
argument_list|,
name|REG_TYPE_VFD
argument_list|,
name|NULL
argument_list|,
operator|&
name|atype
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
operator|==
name|FAIL
operator|||
operator|(
name|atype
operator|.
name|defined
operator|&
name|NTA_HASINDEX
operator|)
operator|==
literal|0
condition|)
return|return
name|FAIL
return|;
if|if
condition|(
name|atype
operator|.
name|index
operator|==
name|NEON_ALL_LANES
condition|)
block|{
name|first_error
argument_list|(
name|_
argument_list|(
literal|"scalar must have an index"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
block|}
elseif|else
if|if
condition|(
name|atype
operator|.
name|index
operator|>=
literal|64
operator|/
name|elsize
condition|)
block|{
name|first_error
argument_list|(
name|_
argument_list|(
literal|"scalar index out of range"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
block|}
if|if
condition|(
name|type
condition|)
operator|*
name|type
operator|=
name|atype
operator|.
name|eltype
expr_stmt|;
operator|*
name|ccp
operator|=
name|str
expr_stmt|;
return|return
name|reg
operator|*
literal|16
operator|+
name|atype
operator|.
name|index
return|;
block|}
end_function

begin_comment
comment|/* Parse an ARM register list.  Returns the bitmask, or FAIL.  */
end_comment

begin_function
specifier|static
name|long
name|parse_reg_list
parameter_list|(
name|char
modifier|*
modifier|*
name|strp
parameter_list|)
block|{
name|char
modifier|*
name|str
init|=
operator|*
name|strp
decl_stmt|;
name|long
name|range
init|=
literal|0
decl_stmt|;
name|int
name|another_range
decl_stmt|;
comment|/* We come back here if we get ranges concatenated by '+' or '|'.  */
do|do
block|{
name|another_range
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|*
name|str
operator|==
literal|'{'
condition|)
block|{
name|int
name|in_range
init|=
literal|0
decl_stmt|;
name|int
name|cur_reg
init|=
operator|-
literal|1
decl_stmt|;
name|str
operator|++
expr_stmt|;
do|do
block|{
name|int
name|reg
decl_stmt|;
if|if
condition|(
operator|(
name|reg
operator|=
name|arm_reg_parse
argument_list|(
operator|&
name|str
argument_list|,
name|REG_TYPE_RN
argument_list|)
operator|)
operator|==
name|FAIL
condition|)
block|{
name|first_error
argument_list|(
name|_
argument_list|(
name|reg_expected_msgs
index|[
name|REG_TYPE_RN
index|]
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
block|}
if|if
condition|(
name|in_range
condition|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|reg
operator|<=
name|cur_reg
condition|)
block|{
name|first_error
argument_list|(
name|_
argument_list|(
literal|"bad range in register list"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
block|}
for|for
control|(
name|i
operator|=
name|cur_reg
operator|+
literal|1
init|;
name|i
operator|<
name|reg
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|range
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
condition|)
name|as_tsktsk
argument_list|(
name|_
argument_list|(
literal|"Warning: duplicated register (r%d) in register list"
argument_list|)
argument_list|,
name|i
argument_list|)
expr_stmt|;
else|else
name|range
operator||=
literal|1
operator|<<
name|i
expr_stmt|;
block|}
name|in_range
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|range
operator|&
operator|(
literal|1
operator|<<
name|reg
operator|)
condition|)
name|as_tsktsk
argument_list|(
name|_
argument_list|(
literal|"Warning: duplicated register (r%d) in register list"
argument_list|)
argument_list|,
name|reg
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|reg
operator|<=
name|cur_reg
condition|)
name|as_tsktsk
argument_list|(
name|_
argument_list|(
literal|"Warning: register range not in ascending order"
argument_list|)
argument_list|)
expr_stmt|;
name|range
operator||=
literal|1
operator|<<
name|reg
expr_stmt|;
name|cur_reg
operator|=
name|reg
expr_stmt|;
block|}
do|while
condition|(
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|!=
name|FAIL
operator|||
operator|(
name|in_range
operator|=
literal|1
operator|,
operator|*
name|str
operator|++
operator|==
literal|'-'
operator|)
condition|)
do|;
name|str
operator|--
expr_stmt|;
if|if
condition|(
operator|*
name|str
operator|++
operator|!=
literal|'}'
condition|)
block|{
name|first_error
argument_list|(
name|_
argument_list|(
literal|"missing `}'"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
block|}
block|}
else|else
block|{
name|expressionS
name|expr
decl_stmt|;
if|if
condition|(
name|my_get_expression
argument_list|(
operator|&
name|expr
argument_list|,
operator|&
name|str
argument_list|,
name|GE_NO_PREFIX
argument_list|)
condition|)
return|return
name|FAIL
return|;
if|if
condition|(
name|expr
operator|.
name|X_op
operator|==
name|O_constant
condition|)
block|{
if|if
condition|(
name|expr
operator|.
name|X_add_number
operator|!=
operator|(
name|expr
operator|.
name|X_add_number
operator|&
literal|0x0000ffff
operator|)
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"invalid register mask"
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
block|}
if|if
condition|(
operator|(
name|range
operator|&
name|expr
operator|.
name|X_add_number
operator|)
operator|!=
literal|0
condition|)
block|{
name|int
name|regno
init|=
name|range
operator|&
name|expr
operator|.
name|X_add_number
decl_stmt|;
name|regno
operator|&=
operator|-
name|regno
expr_stmt|;
name|regno
operator|=
operator|(
literal|1
operator|<<
name|regno
operator|)
operator|-
literal|1
expr_stmt|;
name|as_tsktsk
argument_list|(
name|_
argument_list|(
literal|"Warning: duplicated register (r%d) in register list"
argument_list|)
argument_list|,
name|regno
argument_list|)
expr_stmt|;
block|}
name|range
operator||=
name|expr
operator|.
name|X_add_number
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|inst
operator|.
name|reloc
operator|.
name|type
operator|!=
literal|0
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"expression too complex"
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
block|}
name|memcpy
argument_list|(
operator|&
name|inst
operator|.
name|reloc
operator|.
name|exp
argument_list|,
operator|&
name|expr
argument_list|,
sizeof|sizeof
argument_list|(
name|expressionS
argument_list|)
argument_list|)
expr_stmt|;
name|inst
operator|.
name|reloc
operator|.
name|type
operator|=
name|BFD_RELOC_ARM_MULTI
expr_stmt|;
name|inst
operator|.
name|reloc
operator|.
name|pc_rel
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|*
name|str
operator|==
literal|'|'
operator|||
operator|*
name|str
operator|==
literal|'+'
condition|)
block|{
name|str
operator|++
expr_stmt|;
name|another_range
operator|=
literal|1
expr_stmt|;
block|}
block|}
do|while
condition|(
name|another_range
condition|)
do|;
operator|*
name|strp
operator|=
name|str
expr_stmt|;
return|return
name|range
return|;
block|}
end_function

begin_comment
comment|/* Types of registers in a list.  */
end_comment

begin_enum
enum|enum
name|reg_list_els
block|{
name|REGLIST_VFP_S
block|,
name|REGLIST_VFP_D
block|,
name|REGLIST_NEON_D
block|}
enum|;
end_enum

begin_comment
comment|/* Parse a VFP register list.  If the string is invalid return FAIL.    Otherwise return the number of registers, and set PBASE to the first    register.  Parses registers of type ETYPE.    If REGLIST_NEON_D is used, several syntax enhancements are enabled:      - Q registers can be used to specify pairs of D registers      - { } can be omitted from around a singleton register list          FIXME: This is not implemented, as it would require backtracking in          some cases, e.g.:            vtbl.8 d3,d4,d5          This could be done (the meaning isn't really ambiguous), but doesn't          fit in well with the current parsing framework.      - 32 D registers may be used (also true for VFPv3).    FIXME: Types are ignored in these register lists, which is probably a    bug.  */
end_comment

begin_function
specifier|static
name|int
name|parse_vfp_reg_list
parameter_list|(
name|char
modifier|*
modifier|*
name|ccp
parameter_list|,
name|unsigned
name|int
modifier|*
name|pbase
parameter_list|,
name|enum
name|reg_list_els
name|etype
parameter_list|)
block|{
name|char
modifier|*
name|str
init|=
operator|*
name|ccp
decl_stmt|;
name|int
name|base_reg
decl_stmt|;
name|int
name|new_base
decl_stmt|;
name|enum
name|arm_reg_type
name|regtype
init|=
literal|0
decl_stmt|;
name|int
name|max_regs
init|=
literal|0
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
name|int
name|warned
init|=
literal|0
decl_stmt|;
name|unsigned
name|long
name|mask
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|*
name|str
operator|!=
literal|'{'
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"expecting {"
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
block|}
name|str
operator|++
expr_stmt|;
switch|switch
condition|(
name|etype
condition|)
block|{
case|case
name|REGLIST_VFP_S
case|:
name|regtype
operator|=
name|REG_TYPE_VFS
expr_stmt|;
name|max_regs
operator|=
literal|32
expr_stmt|;
break|break;
case|case
name|REGLIST_VFP_D
case|:
name|regtype
operator|=
name|REG_TYPE_VFD
expr_stmt|;
break|break;
case|case
name|REGLIST_NEON_D
case|:
name|regtype
operator|=
name|REG_TYPE_NDQ
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|etype
operator|!=
name|REGLIST_VFP_S
condition|)
block|{
comment|/* VFPv3 allows 32 D registers.  */
if|if
condition|(
name|ARM_CPU_HAS_FEATURE
argument_list|(
name|cpu_variant
argument_list|,
name|fpu_vfp_ext_v3
argument_list|)
condition|)
block|{
name|max_regs
operator|=
literal|32
expr_stmt|;
if|if
condition|(
name|thumb_mode
condition|)
name|ARM_MERGE_FEATURE_SETS
argument_list|(
name|thumb_arch_used
argument_list|,
name|thumb_arch_used
argument_list|,
name|fpu_vfp_ext_v3
argument_list|)
expr_stmt|;
else|else
name|ARM_MERGE_FEATURE_SETS
argument_list|(
name|arm_arch_used
argument_list|,
name|arm_arch_used
argument_list|,
name|fpu_vfp_ext_v3
argument_list|)
expr_stmt|;
block|}
else|else
name|max_regs
operator|=
literal|16
expr_stmt|;
block|}
name|base_reg
operator|=
name|max_regs
expr_stmt|;
do|do
block|{
name|int
name|setmask
init|=
literal|1
decl_stmt|,
name|addregs
init|=
literal|1
decl_stmt|;
name|new_base
operator|=
name|arm_typed_reg_parse
argument_list|(
operator|&
name|str
argument_list|,
name|regtype
argument_list|,
operator|&
name|regtype
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_base
operator|==
name|FAIL
condition|)
block|{
name|first_error
argument_list|(
name|_
argument_list|(
name|reg_expected_msgs
index|[
name|regtype
index|]
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
block|}
if|if
condition|(
name|new_base
operator|>=
name|max_regs
condition|)
block|{
name|first_error
argument_list|(
name|_
argument_list|(
literal|"register out of range in list"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
block|}
comment|/* Note: a value of 2 * n is returned for the register Q<n>.  */
if|if
condition|(
name|regtype
operator|==
name|REG_TYPE_NQ
condition|)
block|{
name|setmask
operator|=
literal|3
expr_stmt|;
name|addregs
operator|=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|new_base
operator|<
name|base_reg
condition|)
name|base_reg
operator|=
name|new_base
expr_stmt|;
if|if
condition|(
name|mask
operator|&
operator|(
name|setmask
operator|<<
name|new_base
operator|)
condition|)
block|{
name|first_error
argument_list|(
name|_
argument_list|(
literal|"invalid register list"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
block|}
if|if
condition|(
operator|(
name|mask
operator|>>
name|new_base
operator|)
operator|!=
literal|0
operator|&&
operator|!
name|warned
condition|)
block|{
name|as_tsktsk
argument_list|(
name|_
argument_list|(
literal|"register list not in ascending order"
argument_list|)
argument_list|)
expr_stmt|;
name|warned
operator|=
literal|1
expr_stmt|;
block|}
name|mask
operator||=
name|setmask
operator|<<
name|new_base
expr_stmt|;
name|count
operator|+=
name|addregs
expr_stmt|;
if|if
condition|(
operator|*
name|str
operator|==
literal|'-'
condition|)
comment|/* We have the start of a range expression */
block|{
name|int
name|high_range
decl_stmt|;
name|str
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|high_range
operator|=
name|arm_typed_reg_parse
argument_list|(
operator|&
name|str
argument_list|,
name|regtype
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
name|FAIL
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|gettext
argument_list|(
name|reg_expected_msgs
index|[
name|regtype
index|]
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
block|}
if|if
condition|(
name|high_range
operator|>=
name|max_regs
condition|)
block|{
name|first_error
argument_list|(
name|_
argument_list|(
literal|"register out of range in list"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
block|}
if|if
condition|(
name|regtype
operator|==
name|REG_TYPE_NQ
condition|)
name|high_range
operator|=
name|high_range
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|high_range
operator|<=
name|new_base
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"register range not in ascending order"
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
block|}
for|for
control|(
name|new_base
operator|+=
name|addregs
init|;
name|new_base
operator|<=
name|high_range
condition|;
name|new_base
operator|+=
name|addregs
control|)
block|{
if|if
condition|(
name|mask
operator|&
operator|(
name|setmask
operator|<<
name|new_base
operator|)
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"invalid register list"
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
block|}
name|mask
operator||=
name|setmask
operator|<<
name|new_base
expr_stmt|;
name|count
operator|+=
name|addregs
expr_stmt|;
block|}
block|}
block|}
do|while
condition|(
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
operator|!=
name|FAIL
condition|)
do|;
name|str
operator|++
expr_stmt|;
comment|/* Sanity check -- should have raised a parse error above.  */
if|if
condition|(
name|count
operator|==
literal|0
operator|||
name|count
operator|>
name|max_regs
condition|)
name|abort
argument_list|()
expr_stmt|;
operator|*
name|pbase
operator|=
name|base_reg
expr_stmt|;
comment|/* Final test -- the registers must be consecutive.  */
name|mask
operator|>>=
name|base_reg
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|mask
operator|&
operator|(
literal|1u
operator|<<
name|i
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"non-contiguous register range"
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
block|}
block|}
operator|*
name|ccp
operator|=
name|str
expr_stmt|;
return|return
name|count
return|;
block|}
end_function

begin_comment
comment|/* True if two alias types are the same.  */
end_comment

begin_function
specifier|static
name|int
name|neon_alias_types_same
parameter_list|(
name|struct
name|neon_typed_alias
modifier|*
name|a
parameter_list|,
name|struct
name|neon_typed_alias
modifier|*
name|b
parameter_list|)
block|{
if|if
condition|(
operator|!
name|a
operator|&&
operator|!
name|b
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|!
name|a
operator|||
operator|!
name|b
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|a
operator|->
name|defined
operator|!=
name|b
operator|->
name|defined
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|(
name|a
operator|->
name|defined
operator|&
name|NTA_HASTYPE
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|a
operator|->
name|eltype
operator|.
name|type
operator|!=
name|b
operator|->
name|eltype
operator|.
name|type
operator|||
name|a
operator|->
name|eltype
operator|.
name|size
operator|!=
name|b
operator|->
name|eltype
operator|.
name|size
operator|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|(
name|a
operator|->
name|defined
operator|&
name|NTA_HASINDEX
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|a
operator|->
name|index
operator|!=
name|b
operator|->
name|index
operator|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Parse element/structure lists for Neon VLD<n> and VST<n> instructions.    The base register is put in *PBASE.    The lane (or one of the NEON_*_LANES constants) is placed in bits [3:0] of    the return value.    The register stride (minus one) is put in bit 4 of the return value.    Bits [6:5] encode the list length (minus one).    The type of the list elements is put in *ELTYPE, if non-NULL.  */
end_comment

begin_define
define|#
directive|define
name|NEON_LANE
parameter_list|(
name|X
parameter_list|)
value|((X)& 0xf)
end_define

begin_define
define|#
directive|define
name|NEON_REG_STRIDE
parameter_list|(
name|X
parameter_list|)
value|((((X)>> 4)& 1) + 1)
end_define

begin_define
define|#
directive|define
name|NEON_REGLIST_LENGTH
parameter_list|(
name|X
parameter_list|)
value|((((X)>> 5)& 3) + 1)
end_define

begin_function
specifier|static
name|int
name|parse_neon_el_struct_list
parameter_list|(
name|char
modifier|*
modifier|*
name|str
parameter_list|,
name|unsigned
modifier|*
name|pbase
parameter_list|,
name|struct
name|neon_type_el
modifier|*
name|eltype
parameter_list|)
block|{
name|char
modifier|*
name|ptr
init|=
operator|*
name|str
decl_stmt|;
name|int
name|base_reg
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|reg_incr
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
name|int
name|lane
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|leading_brace
init|=
literal|0
decl_stmt|;
name|enum
name|arm_reg_type
name|rtype
init|=
name|REG_TYPE_NDQ
decl_stmt|;
name|int
name|addregs
init|=
literal|1
decl_stmt|;
specifier|const
name|char
modifier|*
specifier|const
name|incr_error
init|=
literal|"register stride must be 1 or 2"
decl_stmt|;
specifier|const
name|char
modifier|*
specifier|const
name|type_error
init|=
literal|"mismatched element/structure types in list"
decl_stmt|;
name|struct
name|neon_typed_alias
name|firsttype
decl_stmt|;
if|if
condition|(
name|skip_past_char
argument_list|(
operator|&
name|ptr
argument_list|,
literal|'{'
argument_list|)
operator|==
name|SUCCESS
condition|)
name|leading_brace
operator|=
literal|1
expr_stmt|;
do|do
block|{
name|struct
name|neon_typed_alias
name|atype
decl_stmt|;
name|int
name|getreg
init|=
name|parse_typed_reg_or_scalar
argument_list|(
operator|&
name|ptr
argument_list|,
name|rtype
argument_list|,
operator|&
name|rtype
argument_list|,
operator|&
name|atype
argument_list|)
decl_stmt|;
if|if
condition|(
name|getreg
operator|==
name|FAIL
condition|)
block|{
name|first_error
argument_list|(
name|_
argument_list|(
name|reg_expected_msgs
index|[
name|rtype
index|]
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
block|}
if|if
condition|(
name|base_reg
operator|==
operator|-
literal|1
condition|)
block|{
name|base_reg
operator|=
name|getreg
expr_stmt|;
if|if
condition|(
name|rtype
operator|==
name|REG_TYPE_NQ
condition|)
block|{
name|reg_incr
operator|=
literal|1
expr_stmt|;
name|addregs
operator|=
literal|2
expr_stmt|;
block|}
name|firsttype
operator|=
name|atype
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|reg_incr
operator|==
operator|-
literal|1
condition|)
block|{
name|reg_incr
operator|=
name|getreg
operator|-
name|base_reg
expr_stmt|;
if|if
condition|(
name|reg_incr
operator|<
literal|1
operator|||
name|reg_incr
operator|>
literal|2
condition|)
block|{
name|first_error
argument_list|(
name|_
argument_list|(
name|incr_error
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|getreg
operator|!=
name|base_reg
operator|+
name|reg_incr
operator|*
name|count
condition|)
block|{
name|first_error
argument_list|(
name|_
argument_list|(
name|incr_error
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
block|}
if|if
condition|(
operator|!
name|neon_alias_types_same
argument_list|(
operator|&
name|atype
argument_list|,
operator|&
name|firsttype
argument_list|)
condition|)
block|{
name|first_error
argument_list|(
name|_
argument_list|(
name|type_error
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
block|}
comment|/* Handle Dn-Dm or Qn-Qm syntax. Can only be used with non-indexed list          modes.  */
if|if
condition|(
name|ptr
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
block|{
name|struct
name|neon_typed_alias
name|htype
decl_stmt|;
name|int
name|hireg
decl_stmt|,
name|dregs
init|=
operator|(
name|rtype
operator|==
name|REG_TYPE_NQ
operator|)
condition|?
literal|2
else|:
literal|1
decl_stmt|;
if|if
condition|(
name|lane
operator|==
operator|-
literal|1
condition|)
name|lane
operator|=
name|NEON_INTERLEAVE_LANES
expr_stmt|;
elseif|else
if|if
condition|(
name|lane
operator|!=
name|NEON_INTERLEAVE_LANES
condition|)
block|{
name|first_error
argument_list|(
name|_
argument_list|(
name|type_error
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
block|}
if|if
condition|(
name|reg_incr
operator|==
operator|-
literal|1
condition|)
name|reg_incr
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|reg_incr
operator|!=
literal|1
condition|)
block|{
name|first_error
argument_list|(
name|_
argument_list|(
literal|"don't use Rn-Rm syntax with non-unit stride"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
block|}
name|ptr
operator|++
expr_stmt|;
name|hireg
operator|=
name|parse_typed_reg_or_scalar
argument_list|(
operator|&
name|ptr
argument_list|,
name|rtype
argument_list|,
name|NULL
argument_list|,
operator|&
name|htype
argument_list|)
expr_stmt|;
if|if
condition|(
name|hireg
operator|==
name|FAIL
condition|)
block|{
name|first_error
argument_list|(
name|_
argument_list|(
name|reg_expected_msgs
index|[
name|rtype
index|]
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
block|}
if|if
condition|(
operator|!
name|neon_alias_types_same
argument_list|(
operator|&
name|htype
argument_list|,
operator|&
name|firsttype
argument_list|)
condition|)
block|{
name|first_error
argument_list|(
name|_
argument_list|(
name|type_error
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
block|}
name|count
operator|+=
name|hireg
operator|+
name|dregs
operator|-
name|getreg
expr_stmt|;
continue|continue;
block|}
comment|/* If we're using Q registers, we can't use [] or [n] syntax.  */
if|if
condition|(
name|rtype
operator|==
name|REG_TYPE_NQ
condition|)
block|{
name|count
operator|+=
literal|2
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|(
name|atype
operator|.
name|defined
operator|&
name|NTA_HASINDEX
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|lane
operator|==
operator|-
literal|1
condition|)
name|lane
operator|=
name|atype
operator|.
name|index
expr_stmt|;
elseif|else
if|if
condition|(
name|lane
operator|!=
name|atype
operator|.
name|index
condition|)
block|{
name|first_error
argument_list|(
name|_
argument_list|(
name|type_error
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|lane
operator|==
operator|-
literal|1
condition|)
name|lane
operator|=
name|NEON_INTERLEAVE_LANES
expr_stmt|;
elseif|else
if|if
condition|(
name|lane
operator|!=
name|NEON_INTERLEAVE_LANES
condition|)
block|{
name|first_error
argument_list|(
name|_
argument_list|(
name|type_error
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
block|}
name|count
operator|++
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|count
operator|!=
literal|1
operator|||
name|leading_brace
operator|)
operator|&&
name|skip_past_comma
argument_list|(
operator|&
name|ptr
argument_list|)
operator|!=
name|FAIL
condition|)
do|;
comment|/* No lane set by [x]. We must be interleaving structures.  */
if|if
condition|(
name|lane
operator|==
operator|-
literal|1
condition|)
name|lane
operator|=
name|NEON_INTERLEAVE_LANES
expr_stmt|;
comment|/* Sanity check.  */
if|if
condition|(
name|lane
operator|==
operator|-
literal|1
operator|||
name|base_reg
operator|==
operator|-
literal|1
operator|||
name|count
operator|<
literal|1
operator|||
name|count
operator|>
literal|4
operator|||
operator|(
name|count
operator|>
literal|1
operator|&&
name|reg_incr
operator|==
operator|-
literal|1
operator|)
condition|)
block|{
name|first_error
argument_list|(
name|_
argument_list|(
literal|"error parsing element/structure list"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
block|}
if|if
condition|(
operator|(
name|count
operator|>
literal|1
operator|||
name|leading_brace
operator|)
operator|&&
name|skip_past_char
argument_list|(
operator|&
name|ptr
argument_list|,
literal|'}'
argument_list|)
operator|==
name|FAIL
condition|)
block|{
name|first_error
argument_list|(
name|_
argument_list|(
literal|"expected }"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
block|}
if|if
condition|(
name|reg_incr
operator|==
operator|-
literal|1
condition|)
name|reg_incr
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|eltype
condition|)
operator|*
name|eltype
operator|=
name|firsttype
operator|.
name|eltype
expr_stmt|;
operator|*
name|pbase
operator|=
name|base_reg
expr_stmt|;
operator|*
name|str
operator|=
name|ptr
expr_stmt|;
return|return
name|lane
operator||
operator|(
operator|(
name|reg_incr
operator|-
literal|1
operator|)
operator|<<
literal|4
operator|)
operator||
operator|(
operator|(
name|count
operator|-
literal|1
operator|)
operator|<<
literal|5
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Parse an explicit relocation suffix on an expression.  This is    either nothing, or a word in parentheses.  Note that if !OBJ_ELF,    arm_reloc_hsh contains no entries, so this function can only    succeed if there is no () after the word.  Returns -1 on error,    BFD_RELOC_UNUSED if there wasn't any suffix.	 */
end_comment

begin_function
specifier|static
name|int
name|parse_reloc
parameter_list|(
name|char
modifier|*
modifier|*
name|str
parameter_list|)
block|{
name|struct
name|reloc_entry
modifier|*
name|r
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
if|if
condition|(
operator|*
operator|*
name|str
operator|!=
literal|'('
condition|)
return|return
name|BFD_RELOC_UNUSED
return|;
name|p
operator|=
operator|*
name|str
operator|+
literal|1
expr_stmt|;
name|q
operator|=
name|p
expr_stmt|;
while|while
condition|(
operator|*
name|q
operator|&&
operator|*
name|q
operator|!=
literal|')'
operator|&&
operator|*
name|q
operator|!=
literal|','
condition|)
name|q
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|q
operator|!=
literal|')'
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
operator|(
name|r
operator|=
name|hash_find_n
argument_list|(
name|arm_reloc_hsh
argument_list|,
name|p
argument_list|,
name|q
operator|-
name|p
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
operator|*
name|str
operator|=
name|q
operator|+
literal|1
expr_stmt|;
return|return
name|r
operator|->
name|reloc
return|;
block|}
end_function

begin_comment
comment|/* Directives: register aliases.  */
end_comment

begin_function
specifier|static
name|struct
name|reg_entry
modifier|*
name|insert_reg_alias
parameter_list|(
name|char
modifier|*
name|str
parameter_list|,
name|int
name|number
parameter_list|,
name|int
name|type
parameter_list|)
block|{
name|struct
name|reg_entry
modifier|*
name|new
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
if|if
condition|(
operator|(
name|new
operator|=
name|hash_find
argument_list|(
name|arm_reg_hsh
argument_list|,
name|str
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|new
operator|->
name|builtin
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"ignoring attempt to redefine built-in register '%s'"
argument_list|)
argument_list|,
name|str
argument_list|)
expr_stmt|;
comment|/* Only warn about a redefinition if it's not defined as the 	 same register.	 */
elseif|else
if|if
condition|(
name|new
operator|->
name|number
operator|!=
name|number
operator|||
name|new
operator|->
name|type
operator|!=
name|type
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"ignoring redefinition of register alias '%s'"
argument_list|)
argument_list|,
name|str
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|name
operator|=
name|xstrdup
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|new
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|reg_entry
argument_list|)
argument_list|)
expr_stmt|;
name|new
operator|->
name|name
operator|=
name|name
expr_stmt|;
name|new
operator|->
name|number
operator|=
name|number
expr_stmt|;
name|new
operator|->
name|type
operator|=
name|type
expr_stmt|;
name|new
operator|->
name|builtin
operator|=
name|FALSE
expr_stmt|;
name|new
operator|->
name|neon
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|hash_insert
argument_list|(
name|arm_reg_hsh
argument_list|,
name|name
argument_list|,
operator|(
name|PTR
operator|)
name|new
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
name|new
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|insert_neon_reg_alias
parameter_list|(
name|char
modifier|*
name|str
parameter_list|,
name|int
name|number
parameter_list|,
name|int
name|type
parameter_list|,
name|struct
name|neon_typed_alias
modifier|*
name|atype
parameter_list|)
block|{
name|struct
name|reg_entry
modifier|*
name|reg
init|=
name|insert_reg_alias
argument_list|(
name|str
argument_list|,
name|number
argument_list|,
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|reg
condition|)
block|{
name|first_error
argument_list|(
name|_
argument_list|(
literal|"attempt to redefine typed alias"
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|atype
condition|)
block|{
name|reg
operator|->
name|neon
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|neon_typed_alias
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|reg
operator|->
name|neon
operator|=
operator|*
name|atype
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Look for the .req directive.	 This is of the form:  	new_register_name .req existing_register_name     If we find one, or if it looks sufficiently like one that we want to    handle any error here, return non-zero.  Otherwise return zero.  */
end_comment

begin_function
specifier|static
name|int
name|create_register_alias
parameter_list|(
name|char
modifier|*
name|newname
parameter_list|,
name|char
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|reg_entry
modifier|*
name|old
decl_stmt|;
name|char
modifier|*
name|oldname
decl_stmt|,
modifier|*
name|nbuf
decl_stmt|;
name|size_t
name|nlen
decl_stmt|;
comment|/* The input scrubber ensures that whitespace after the mnemonic is      collapsed to single spaces.  */
name|oldname
operator|=
name|p
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|oldname
argument_list|,
literal|" .req "
argument_list|,
literal|6
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
name|oldname
operator|+=
literal|6
expr_stmt|;
if|if
condition|(
operator|*
name|oldname
operator|==
literal|'\0'
condition|)
return|return
literal|0
return|;
name|old
operator|=
name|hash_find
argument_list|(
name|arm_reg_hsh
argument_list|,
name|oldname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|old
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"unknown register '%s' -- .req ignored"
argument_list|)
argument_list|,
name|oldname
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* If TC_CASE_SENSITIVE is defined, then newname already points to      the desired alias name, and p points to its end.  If not, then      the desired alias name is in the global original_case_string.  */
ifdef|#
directive|ifdef
name|TC_CASE_SENSITIVE
name|nlen
operator|=
name|p
operator|-
name|newname
expr_stmt|;
else|#
directive|else
name|newname
operator|=
name|original_case_string
expr_stmt|;
name|nlen
operator|=
name|strlen
argument_list|(
name|newname
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|nbuf
operator|=
name|alloca
argument_list|(
name|nlen
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|nbuf
argument_list|,
name|newname
argument_list|,
name|nlen
argument_list|)
expr_stmt|;
name|nbuf
index|[
name|nlen
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Create aliases under the new name as stated; an all-lowercase      version of the new name; and an all-uppercase version of the new      name.  */
name|insert_reg_alias
argument_list|(
name|nbuf
argument_list|,
name|old
operator|->
name|number
argument_list|,
name|old
operator|->
name|type
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|nbuf
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
operator|*
name|p
operator|=
name|TOUPPER
argument_list|(
operator|*
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|nbuf
argument_list|,
name|newname
argument_list|,
name|nlen
argument_list|)
condition|)
name|insert_reg_alias
argument_list|(
name|nbuf
argument_list|,
name|old
operator|->
name|number
argument_list|,
name|old
operator|->
name|type
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|nbuf
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
operator|*
name|p
operator|=
name|TOLOWER
argument_list|(
operator|*
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|nbuf
argument_list|,
name|newname
argument_list|,
name|nlen
argument_list|)
condition|)
name|insert_reg_alias
argument_list|(
name|nbuf
argument_list|,
name|old
operator|->
name|number
argument_list|,
name|old
operator|->
name|type
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Create a Neon typed/indexed register alias using directives, e.g.:      X .dn d5.s32[1]      Y .qn 6.s16      Z .dn d7      T .dn Z[0]    These typed registers can be used instead of the types specified after the    Neon mnemonic, so long as all operands given have types. Types can also be    specified directly, e.g.:      vadd d0.s32, d1.s32, d2.s32 */
end_comment

begin_function
specifier|static
name|int
name|create_neon_reg_alias
parameter_list|(
name|char
modifier|*
name|newname
parameter_list|,
name|char
modifier|*
name|p
parameter_list|)
block|{
name|enum
name|arm_reg_type
name|basetype
decl_stmt|;
name|struct
name|reg_entry
modifier|*
name|basereg
decl_stmt|;
name|struct
name|reg_entry
name|mybasereg
decl_stmt|;
name|struct
name|neon_type
name|ntype
decl_stmt|;
name|struct
name|neon_typed_alias
name|typeinfo
decl_stmt|;
name|char
modifier|*
name|namebuf
decl_stmt|,
modifier|*
name|nameend
decl_stmt|;
name|int
name|namelen
decl_stmt|;
name|typeinfo
operator|.
name|defined
operator|=
literal|0
expr_stmt|;
name|typeinfo
operator|.
name|eltype
operator|.
name|type
operator|=
name|NT_invtype
expr_stmt|;
name|typeinfo
operator|.
name|eltype
operator|.
name|size
operator|=
operator|-
literal|1
expr_stmt|;
name|typeinfo
operator|.
name|index
operator|=
operator|-
literal|1
expr_stmt|;
name|nameend
operator|=
name|p
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|p
argument_list|,
literal|" .dn "
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
name|basetype
operator|=
name|REG_TYPE_VFD
expr_stmt|;
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|p
argument_list|,
literal|" .qn "
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
name|basetype
operator|=
name|REG_TYPE_NQ
expr_stmt|;
else|else
return|return
literal|0
return|;
name|p
operator|+=
literal|5
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
return|return
literal|0
return|;
name|basereg
operator|=
name|arm_reg_parse_multi
argument_list|(
operator|&
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|basereg
operator|&&
name|basereg
operator|->
name|type
operator|!=
name|basetype
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"bad type for register"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|basereg
operator|==
name|NULL
condition|)
block|{
name|expressionS
name|exp
decl_stmt|;
comment|/* Try parsing as an integer.  */
name|my_get_expression
argument_list|(
operator|&
name|exp
argument_list|,
operator|&
name|p
argument_list|,
name|GE_NO_PREFIX
argument_list|)
expr_stmt|;
if|if
condition|(
name|exp
operator|.
name|X_op
operator|!=
name|O_constant
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"expression must be constant"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|basereg
operator|=
operator|&
name|mybasereg
expr_stmt|;
name|basereg
operator|->
name|number
operator|=
operator|(
name|basetype
operator|==
name|REG_TYPE_NQ
operator|)
condition|?
name|exp
operator|.
name|X_add_number
operator|*
literal|2
else|:
name|exp
operator|.
name|X_add_number
expr_stmt|;
name|basereg
operator|->
name|neon
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|basereg
operator|->
name|neon
condition|)
name|typeinfo
operator|=
operator|*
name|basereg
operator|->
name|neon
expr_stmt|;
if|if
condition|(
name|parse_neon_type
argument_list|(
operator|&
name|ntype
argument_list|,
operator|&
name|p
argument_list|)
operator|==
name|SUCCESS
condition|)
block|{
comment|/* We got a type.  */
if|if
condition|(
name|typeinfo
operator|.
name|defined
operator|&
name|NTA_HASTYPE
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"can't redefine the type of a register alias"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|typeinfo
operator|.
name|defined
operator||=
name|NTA_HASTYPE
expr_stmt|;
if|if
condition|(
name|ntype
operator|.
name|elems
operator|!=
literal|1
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"you must specify a single type only"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|typeinfo
operator|.
name|eltype
operator|=
name|ntype
operator|.
name|el
index|[
literal|0
index|]
expr_stmt|;
block|}
if|if
condition|(
name|skip_past_char
argument_list|(
operator|&
name|p
argument_list|,
literal|'['
argument_list|)
operator|==
name|SUCCESS
condition|)
block|{
name|expressionS
name|exp
decl_stmt|;
comment|/* We got a scalar index.  */
if|if
condition|(
name|typeinfo
operator|.
name|defined
operator|&
name|NTA_HASINDEX
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"can't redefine the index of a scalar alias"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|my_get_expression
argument_list|(
operator|&
name|exp
argument_list|,
operator|&
name|p
argument_list|,
name|GE_NO_PREFIX
argument_list|)
expr_stmt|;
if|if
condition|(
name|exp
operator|.
name|X_op
operator|!=
name|O_constant
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"scalar index must be constant"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|typeinfo
operator|.
name|defined
operator||=
name|NTA_HASINDEX
expr_stmt|;
name|typeinfo
operator|.
name|index
operator|=
name|exp
operator|.
name|X_add_number
expr_stmt|;
if|if
condition|(
name|skip_past_char
argument_list|(
operator|&
name|p
argument_list|,
literal|']'
argument_list|)
operator|==
name|FAIL
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"expecting ]"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
name|namelen
operator|=
name|nameend
operator|-
name|newname
expr_stmt|;
name|namebuf
operator|=
name|alloca
argument_list|(
name|namelen
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|namebuf
argument_list|,
name|newname
argument_list|,
name|namelen
argument_list|)
expr_stmt|;
name|namebuf
index|[
name|namelen
index|]
operator|=
literal|'\0'
expr_stmt|;
name|insert_neon_reg_alias
argument_list|(
name|namebuf
argument_list|,
name|basereg
operator|->
name|number
argument_list|,
name|basetype
argument_list|,
name|typeinfo
operator|.
name|defined
operator|!=
literal|0
condition|?
operator|&
name|typeinfo
else|:
name|NULL
argument_list|)
expr_stmt|;
comment|/* Insert name in all uppercase.  */
for|for
control|(
name|p
operator|=
name|namebuf
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
operator|*
name|p
operator|=
name|TOUPPER
argument_list|(
operator|*
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|namebuf
argument_list|,
name|newname
argument_list|,
name|namelen
argument_list|)
condition|)
name|insert_neon_reg_alias
argument_list|(
name|namebuf
argument_list|,
name|basereg
operator|->
name|number
argument_list|,
name|basetype
argument_list|,
name|typeinfo
operator|.
name|defined
operator|!=
literal|0
condition|?
operator|&
name|typeinfo
else|:
name|NULL
argument_list|)
expr_stmt|;
comment|/* Insert name in all lowercase.  */
for|for
control|(
name|p
operator|=
name|namebuf
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
operator|*
name|p
operator|=
name|TOLOWER
argument_list|(
operator|*
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|namebuf
argument_list|,
name|newname
argument_list|,
name|namelen
argument_list|)
condition|)
name|insert_neon_reg_alias
argument_list|(
name|namebuf
argument_list|,
name|basereg
operator|->
name|number
argument_list|,
name|basetype
argument_list|,
name|typeinfo
operator|.
name|defined
operator|!=
literal|0
condition|?
operator|&
name|typeinfo
else|:
name|NULL
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Should never be called, as .req goes between the alias and the    register name, not at the beginning of the line.  */
end_comment

begin_function
specifier|static
name|void
name|s_req
parameter_list|(
name|int
name|a
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"invalid syntax for .req directive"
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|s_dn
parameter_list|(
name|int
name|a
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"invalid syntax for .dn directive"
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|s_qn
parameter_list|(
name|int
name|a
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"invalid syntax for .qn directive"
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The .unreq directive deletes an alias which was previously defined    by .req.  For example:         my_alias .req r11        .unreq my_alias	  */
end_comment

begin_function
specifier|static
name|void
name|s_unreq
parameter_list|(
name|int
name|a
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|char
name|saved_char
decl_stmt|;
name|name
operator|=
name|input_line_pointer
expr_stmt|;
while|while
condition|(
operator|*
name|input_line_pointer
operator|!=
literal|0
operator|&&
operator|*
name|input_line_pointer
operator|!=
literal|' '
operator|&&
operator|*
name|input_line_pointer
operator|!=
literal|'\n'
condition|)
operator|++
name|input_line_pointer
expr_stmt|;
name|saved_char
operator|=
operator|*
name|input_line_pointer
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|name
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"invalid syntax for .unreq directive"
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|struct
name|reg_entry
modifier|*
name|reg
init|=
name|hash_find
argument_list|(
name|arm_reg_hsh
argument_list|,
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|reg
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"unknown register alias '%s'"
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|reg
operator|->
name|builtin
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"ignoring attempt to undefine built-in register '%s'"
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|else
block|{
name|hash_delete
argument_list|(
name|arm_reg_hsh
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|reg
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
operator|->
name|neon
condition|)
name|free
argument_list|(
name|reg
operator|->
name|neon
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|reg
argument_list|)
expr_stmt|;
block|}
block|}
operator|*
name|input_line_pointer
operator|=
name|saved_char
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|s_inst
parameter_list|(
name|int
name|unused
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|expressionS
name|exp
decl_stmt|;
if|if
condition|(
name|thumb_mode
condition|)
block|{
name|as_bad
argument_list|(
literal|".inst not implemented for Thumb mode"
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|is_it_end_of_statement
argument_list|()
condition|)
block|{
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
do|do
block|{
name|expression
argument_list|(
operator|&
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
name|exp
operator|.
name|X_op
operator|!=
name|O_constant
condition|)
name|as_bad
argument_list|(
literal|"constant expression required"
argument_list|)
expr_stmt|;
else|else
name|emit_expr
argument_list|(
operator|&
name|exp
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|*
name|input_line_pointer
operator|++
operator|==
literal|','
condition|)
do|;
comment|/* Put terminator back into stream. */
name|input_line_pointer
operator|--
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Directives: Instruction set selection.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|OBJ_ELF
end_ifdef

begin_comment
comment|/* This code is to handle mapping symbols as defined in the ARM ELF spec.    (See "Mapping symbols", section 4.5.5, ARM AAELF version 1.0).    Note that previously, $a and $t has type STT_FUNC (BSF_OBJECT flag),    and $d has type STT_OBJECT (BSF_OBJECT flag). Now all three are untyped.  */
end_comment

begin_decl_stmt
specifier|static
name|enum
name|mstate
name|mapstate
init|=
name|MAP_UNDEFINED
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|mapping_state
parameter_list|(
name|enum
name|mstate
name|state
parameter_list|)
block|{
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
specifier|const
name|char
modifier|*
name|symname
decl_stmt|;
name|int
name|type
decl_stmt|;
if|if
condition|(
name|mapstate
operator|==
name|state
condition|)
comment|/* The mapping symbol has already been emitted.        There is nothing else to do.  */
return|return;
name|mapstate
operator|=
name|state
expr_stmt|;
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|MAP_DATA
case|:
name|symname
operator|=
literal|"$d"
expr_stmt|;
name|type
operator|=
name|BSF_NO_FLAGS
expr_stmt|;
break|break;
case|case
name|MAP_ARM
case|:
name|symname
operator|=
literal|"$a"
expr_stmt|;
name|type
operator|=
name|BSF_NO_FLAGS
expr_stmt|;
break|break;
case|case
name|MAP_THUMB
case|:
name|symname
operator|=
literal|"$t"
expr_stmt|;
name|type
operator|=
name|BSF_NO_FLAGS
expr_stmt|;
break|break;
case|case
name|MAP_UNDEFINED
case|:
return|return;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|seg_info
argument_list|(
name|now_seg
argument_list|)
operator|->
name|tc_segment_info_data
operator|.
name|mapstate
operator|=
name|state
expr_stmt|;
name|symbolP
operator|=
name|symbol_new
argument_list|(
name|symname
argument_list|,
name|now_seg
argument_list|,
operator|(
name|valueT
operator|)
name|frag_now_fix
argument_list|()
argument_list|,
name|frag_now
argument_list|)
expr_stmt|;
name|symbol_table_insert
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
name|symbol_get_bfdsym
argument_list|(
name|symbolP
argument_list|)
operator|->
name|flags
operator||=
name|type
operator||
name|BSF_LOCAL
expr_stmt|;
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|MAP_ARM
case|:
name|THUMB_SET_FUNC
argument_list|(
name|symbolP
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ARM_SET_THUMB
argument_list|(
name|symbolP
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ARM_SET_INTERWORK
argument_list|(
name|symbolP
argument_list|,
name|support_interwork
argument_list|)
expr_stmt|;
break|break;
case|case
name|MAP_THUMB
case|:
name|THUMB_SET_FUNC
argument_list|(
name|symbolP
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ARM_SET_THUMB
argument_list|(
name|symbolP
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ARM_SET_INTERWORK
argument_list|(
name|symbolP
argument_list|,
name|support_interwork
argument_list|)
expr_stmt|;
break|break;
case|case
name|MAP_DATA
case|:
default|default:
return|return;
block|}
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|mapping_state
parameter_list|(
name|x
parameter_list|)
end_define

begin_comment
comment|/* nothing */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Find the real, Thumb encoded start of a Thumb function.  */
end_comment

begin_function
specifier|static
name|symbolS
modifier|*
name|find_real_start
parameter_list|(
name|symbolS
modifier|*
name|symbolP
parameter_list|)
block|{
name|char
modifier|*
name|real_start
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
init|=
name|S_GET_NAME
argument_list|(
name|symbolP
argument_list|)
decl_stmt|;
name|symbolS
modifier|*
name|new_target
decl_stmt|;
comment|/* This definition must agree with the one in gcc/config/arm/thumb.c.	 */
define|#
directive|define
name|STUB_NAME
value|".real_start_of"
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* The compiler may generate BL instructions to local labels because      it needs to perform a branch to a far away location. These labels      do not have a corresponding ".real_start_of" label.  We check      both for S_IS_LOCAL and for a leading dot, to give a way to bypass      the ".real_start_of" convention for nonlocal branches.  */
if|if
condition|(
name|S_IS_LOCAL
argument_list|(
name|symbolP
argument_list|)
operator|||
name|name
index|[
literal|0
index|]
operator|==
literal|'.'
condition|)
return|return
name|symbolP
return|;
name|real_start
operator|=
name|ACONCAT
argument_list|(
operator|(
name|STUB_NAME
operator|,
name|name
operator|,
name|NULL
operator|)
argument_list|)
expr_stmt|;
name|new_target
operator|=
name|symbol_find
argument_list|(
name|real_start
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_target
operator|==
name|NULL
condition|)
block|{
name|as_warn
argument_list|(
literal|"Failed to find real start of function: %s\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|new_target
operator|=
name|symbolP
expr_stmt|;
block|}
return|return
name|new_target
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|opcode_select
parameter_list|(
name|int
name|width
parameter_list|)
block|{
switch|switch
condition|(
name|width
condition|)
block|{
case|case
literal|16
case|:
if|if
condition|(
operator|!
name|thumb_mode
condition|)
block|{
if|if
condition|(
operator|!
name|ARM_CPU_HAS_FEATURE
argument_list|(
name|cpu_variant
argument_list|,
name|arm_ext_v4t
argument_list|)
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"selected processor does not support THUMB opcodes"
argument_list|)
argument_list|)
expr_stmt|;
name|thumb_mode
operator|=
literal|1
expr_stmt|;
comment|/* No need to force the alignment, since we will have been 	     coming from ARM mode, which is word-aligned.  */
name|record_alignment
argument_list|(
name|now_seg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|mapping_state
argument_list|(
name|MAP_THUMB
argument_list|)
expr_stmt|;
break|break;
case|case
literal|32
case|:
if|if
condition|(
name|thumb_mode
condition|)
block|{
if|if
condition|(
operator|!
name|ARM_CPU_HAS_FEATURE
argument_list|(
name|cpu_variant
argument_list|,
name|arm_ext_v1
argument_list|)
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"selected processor does not support ARM opcodes"
argument_list|)
argument_list|)
expr_stmt|;
name|thumb_mode
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|need_pass_2
condition|)
name|frag_align
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|record_alignment
argument_list|(
name|now_seg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|mapping_state
argument_list|(
name|MAP_ARM
argument_list|)
expr_stmt|;
break|break;
default|default:
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"invalid instruction size selected (%d)"
argument_list|)
argument_list|,
name|width
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|s_arm
parameter_list|(
name|int
name|ignore
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|opcode_select
argument_list|(
literal|32
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|s_thumb
parameter_list|(
name|int
name|ignore
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|opcode_select
argument_list|(
literal|16
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|s_code
parameter_list|(
name|int
name|unused
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|int
name|temp
decl_stmt|;
name|temp
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|temp
condition|)
block|{
case|case
literal|16
case|:
case|case
literal|32
case|:
name|opcode_select
argument_list|(
name|temp
argument_list|)
expr_stmt|;
break|break;
default|default:
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"invalid operand to .code directive (%d) (expecting 16 or 32)"
argument_list|)
argument_list|,
name|temp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|s_force_thumb
parameter_list|(
name|int
name|ignore
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
comment|/* If we are not already in thumb mode go into it, EVEN if      the target processor does not support thumb instructions.      This is used by gcc/config/arm/lib1funcs.asm for example      to compile interworking support functions even if the      target processor should not support interworking.	*/
if|if
condition|(
operator|!
name|thumb_mode
condition|)
block|{
name|thumb_mode
operator|=
literal|2
expr_stmt|;
name|record_alignment
argument_list|(
name|now_seg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|s_thumb_func
parameter_list|(
name|int
name|ignore
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|s_thumb
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* The following label is the name/address of the start of a Thumb function.      We need to know this for the interworking support.	 */
name|label_is_thumb_function_name
operator|=
name|TRUE
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Perform a .set directive, but also mark the alias as    being a thumb function.  */
end_comment

begin_function
specifier|static
name|void
name|s_thumb_set
parameter_list|(
name|int
name|equiv
parameter_list|)
block|{
comment|/* XXX the following is a duplicate of the code for s_set() in read.c      We cannot just call that code as we need to get at the symbol that      is created.  */
name|char
modifier|*
name|name
decl_stmt|;
name|char
name|delim
decl_stmt|;
name|char
modifier|*
name|end_name
decl_stmt|;
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
comment|/* Especial apologies for the random logic:      This just grew, and could be parsed much more simply!      Dean - in haste.  */
name|name
operator|=
name|input_line_pointer
expr_stmt|;
name|delim
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
name|end_name
operator|=
name|input_line_pointer
expr_stmt|;
operator|*
name|end_name
operator|=
name|delim
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|!=
literal|','
condition|)
block|{
operator|*
name|end_name
operator|=
literal|0
expr_stmt|;
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"expected comma after name \"%s\""
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
operator|*
name|end_name
operator|=
name|delim
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
name|input_line_pointer
operator|++
expr_stmt|;
operator|*
name|end_name
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
name|name
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
block|{
comment|/* XXX - this should not happen to .thumb_set.  */
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|symbolP
operator|=
name|symbol_find
argument_list|(
name|name
argument_list|)
operator|)
operator|==
name|NULL
operator|&&
operator|(
name|symbolP
operator|=
name|md_undefined_symbol
argument_list|(
name|name
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
ifndef|#
directive|ifndef
name|NO_LISTING
comment|/* When doing symbol listings, play games with dummy fragments living 	 outside the normal fragment chain to record the file and line info 	 for this symbol.  */
if|if
condition|(
name|listing
operator|&
name|LISTING_SYMBOLS
condition|)
block|{
specifier|extern
name|struct
name|list_info_struct
modifier|*
name|listing_tail
decl_stmt|;
name|fragS
modifier|*
name|dummy_frag
init|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|fragS
argument_list|)
argument_list|)
decl_stmt|;
name|memset
argument_list|(
name|dummy_frag
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|fragS
argument_list|)
argument_list|)
expr_stmt|;
name|dummy_frag
operator|->
name|fr_type
operator|=
name|rs_fill
expr_stmt|;
name|dummy_frag
operator|->
name|line
operator|=
name|listing_tail
expr_stmt|;
name|symbolP
operator|=
name|symbol_new
argument_list|(
name|name
argument_list|,
name|undefined_section
argument_list|,
literal|0
argument_list|,
name|dummy_frag
argument_list|)
expr_stmt|;
name|dummy_frag
operator|->
name|fr_symbol
operator|=
name|symbolP
expr_stmt|;
block|}
else|else
endif|#
directive|endif
name|symbolP
operator|=
name|symbol_new
argument_list|(
name|name
argument_list|,
name|undefined_section
argument_list|,
literal|0
argument_list|,
operator|&
name|zero_address_frag
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|OBJ_COFF
comment|/* "set" symbols are local unless otherwise specified.  */
name|SF_SET_LOCAL
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* OBJ_COFF  */
block|}
comment|/* Make a new symbol.  */
name|symbol_table_insert
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
operator|*
name|end_name
operator|=
name|delim
expr_stmt|;
if|if
condition|(
name|equiv
operator|&&
name|S_IS_DEFINED
argument_list|(
name|symbolP
argument_list|)
operator|&&
name|S_GET_SEGMENT
argument_list|(
name|symbolP
argument_list|)
operator|!=
name|reg_section
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"symbol `%s' already defined"
argument_list|)
argument_list|,
name|S_GET_NAME
argument_list|(
name|symbolP
argument_list|)
argument_list|)
expr_stmt|;
name|pseudo_set
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
comment|/* XXX Now we come to the Thumb specific bit of code.	 */
name|THUMB_SET_FUNC
argument_list|(
name|symbolP
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ARM_SET_THUMB
argument_list|(
name|symbolP
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
name|OBJ_ELF
operator|||
name|defined
name|OBJ_COFF
name|ARM_SET_INTERWORK
argument_list|(
name|symbolP
argument_list|,
name|support_interwork
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Directives: Mode selection.  */
end_comment

begin_comment
comment|/* .syntax [unified|divided] - choose the new unified syntax    (same for Arm and Thumb encoding, modulo slight differences in what    can be represented) or the old divergent syntax for each mode.  */
end_comment

begin_function
specifier|static
name|void
name|s_syntax
parameter_list|(
name|int
name|unused
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|char
modifier|*
name|name
decl_stmt|,
name|delim
decl_stmt|;
name|name
operator|=
name|input_line_pointer
expr_stmt|;
name|delim
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
name|name
argument_list|,
literal|"unified"
argument_list|)
condition|)
name|unified_syntax
operator|=
name|TRUE
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
name|name
argument_list|,
literal|"divided"
argument_list|)
condition|)
name|unified_syntax
operator|=
name|FALSE
expr_stmt|;
else|else
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"unrecognized syntax mode \"%s\""
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return;
block|}
operator|*
name|input_line_pointer
operator|=
name|delim
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Directives: sectioning and alignment.  */
end_comment

begin_comment
comment|/* Same as s_align_ptwo but align 0 => align 2.	 */
end_comment

begin_function
specifier|static
name|void
name|s_align
parameter_list|(
name|int
name|unused
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|int
name|temp
decl_stmt|;
name|bfd_boolean
name|fill_p
decl_stmt|;
name|long
name|temp_fill
decl_stmt|;
name|long
name|max_alignment
init|=
literal|15
decl_stmt|;
name|temp
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
if|if
condition|(
name|temp
operator|>
name|max_alignment
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"alignment too large: %d assumed"
argument_list|)
argument_list|,
name|temp
operator|=
name|max_alignment
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|temp
operator|<
literal|0
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"alignment negative. 0 assumed."
argument_list|)
argument_list|)
expr_stmt|;
name|temp
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|','
condition|)
block|{
name|input_line_pointer
operator|++
expr_stmt|;
name|temp_fill
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
name|fill_p
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
name|fill_p
operator|=
name|FALSE
expr_stmt|;
name|temp_fill
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|temp
condition|)
name|temp
operator|=
literal|2
expr_stmt|;
comment|/* Only make a frag if we HAVE to.  */
if|if
condition|(
name|temp
operator|&&
operator|!
name|need_pass_2
condition|)
block|{
if|if
condition|(
operator|!
name|fill_p
operator|&&
name|subseg_text_p
argument_list|(
name|now_seg
argument_list|)
condition|)
name|frag_align_code
argument_list|(
name|temp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|frag_align
argument_list|(
name|temp
argument_list|,
operator|(
name|int
operator|)
name|temp_fill
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
name|record_alignment
argument_list|(
name|now_seg
argument_list|,
name|temp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|s_bss
parameter_list|(
name|int
name|ignore
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
comment|/* We don't support putting frags in the BSS segment, we fake it by      marking in_bss, then looking at s_skip for clues.	*/
name|subseg_set
argument_list|(
name|bss_section
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
name|mapping_state
argument_list|(
name|MAP_DATA
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|s_even
parameter_list|(
name|int
name|ignore
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
comment|/* Never make frag if expect extra pass.  */
if|if
condition|(
operator|!
name|need_pass_2
condition|)
name|frag_align
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|record_alignment
argument_list|(
name|now_seg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Directives: Literal pools.  */
end_comment

begin_function
specifier|static
name|literal_pool
modifier|*
name|find_literal_pool
parameter_list|(
name|void
parameter_list|)
block|{
name|literal_pool
modifier|*
name|pool
decl_stmt|;
for|for
control|(
name|pool
operator|=
name|list_of_pools
init|;
name|pool
operator|!=
name|NULL
condition|;
name|pool
operator|=
name|pool
operator|->
name|next
control|)
block|{
if|if
condition|(
name|pool
operator|->
name|section
operator|==
name|now_seg
operator|&&
name|pool
operator|->
name|sub_section
operator|==
name|now_subseg
condition|)
break|break;
block|}
return|return
name|pool
return|;
block|}
end_function

begin_function
specifier|static
name|literal_pool
modifier|*
name|find_or_make_literal_pool
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* Next literal pool ID number.  */
specifier|static
name|unsigned
name|int
name|latest_pool_num
init|=
literal|1
decl_stmt|;
name|literal_pool
modifier|*
name|pool
decl_stmt|;
name|pool
operator|=
name|find_literal_pool
argument_list|()
expr_stmt|;
if|if
condition|(
name|pool
operator|==
name|NULL
condition|)
block|{
comment|/* Create a new pool.  */
name|pool
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pool
condition|)
return|return
name|NULL
return|;
name|pool
operator|->
name|next_free_entry
operator|=
literal|0
expr_stmt|;
name|pool
operator|->
name|section
operator|=
name|now_seg
expr_stmt|;
name|pool
operator|->
name|sub_section
operator|=
name|now_subseg
expr_stmt|;
name|pool
operator|->
name|next
operator|=
name|list_of_pools
expr_stmt|;
name|pool
operator|->
name|symbol
operator|=
name|NULL
expr_stmt|;
comment|/* Add it to the list.  */
name|list_of_pools
operator|=
name|pool
expr_stmt|;
block|}
comment|/* New pools, and emptied pools, will have a NULL symbol.  */
if|if
condition|(
name|pool
operator|->
name|symbol
operator|==
name|NULL
condition|)
block|{
name|pool
operator|->
name|symbol
operator|=
name|symbol_create
argument_list|(
name|FAKE_LABEL_NAME
argument_list|,
name|undefined_section
argument_list|,
operator|(
name|valueT
operator|)
literal|0
argument_list|,
operator|&
name|zero_address_frag
argument_list|)
expr_stmt|;
name|pool
operator|->
name|id
operator|=
name|latest_pool_num
operator|++
expr_stmt|;
block|}
comment|/* Done.  */
return|return
name|pool
return|;
block|}
end_function

begin_comment
comment|/* Add the literal in the global 'inst'    structure to the relevent literal pool.  */
end_comment

begin_function
specifier|static
name|int
name|add_to_lit_pool
parameter_list|(
name|void
parameter_list|)
block|{
name|literal_pool
modifier|*
name|pool
decl_stmt|;
name|unsigned
name|int
name|entry
decl_stmt|;
name|pool
operator|=
name|find_or_make_literal_pool
argument_list|()
expr_stmt|;
comment|/* Check if this literal value is already in the pool.  */
for|for
control|(
name|entry
operator|=
literal|0
init|;
name|entry
operator|<
name|pool
operator|->
name|next_free_entry
condition|;
name|entry
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|pool
operator|->
name|literals
index|[
name|entry
index|]
operator|.
name|X_op
operator|==
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_op
operator|)
operator|&&
operator|(
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_op
operator|==
name|O_constant
operator|)
operator|&&
operator|(
name|pool
operator|->
name|literals
index|[
name|entry
index|]
operator|.
name|X_add_number
operator|==
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_add_number
operator|)
operator|&&
operator|(
name|pool
operator|->
name|literals
index|[
name|entry
index|]
operator|.
name|X_unsigned
operator|==
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_unsigned
operator|)
condition|)
break|break;
if|if
condition|(
operator|(
name|pool
operator|->
name|literals
index|[
name|entry
index|]
operator|.
name|X_op
operator|==
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_op
operator|)
operator|&&
operator|(
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_op
operator|==
name|O_symbol
operator|)
operator|&&
operator|(
name|pool
operator|->
name|literals
index|[
name|entry
index|]
operator|.
name|X_add_number
operator|==
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_add_number
operator|)
operator|&&
operator|(
name|pool
operator|->
name|literals
index|[
name|entry
index|]
operator|.
name|X_add_symbol
operator|==
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_add_symbol
operator|)
operator|&&
operator|(
name|pool
operator|->
name|literals
index|[
name|entry
index|]
operator|.
name|X_op_symbol
operator|==
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_op_symbol
operator|)
condition|)
break|break;
block|}
comment|/* Do we need to create a new entry?	*/
if|if
condition|(
name|entry
operator|==
name|pool
operator|->
name|next_free_entry
condition|)
block|{
if|if
condition|(
name|entry
operator|>=
name|MAX_LITERAL_POOL_SIZE
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"literal pool overflow"
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
block|}
name|pool
operator|->
name|literals
index|[
name|entry
index|]
operator|=
name|inst
operator|.
name|reloc
operator|.
name|exp
expr_stmt|;
name|pool
operator|->
name|next_free_entry
operator|+=
literal|1
expr_stmt|;
block|}
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_op
operator|=
name|O_symbol
expr_stmt|;
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_add_number
operator|=
operator|(
operator|(
name|int
operator|)
name|entry
operator|)
operator|*
literal|4
expr_stmt|;
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_add_symbol
operator|=
name|pool
operator|->
name|symbol
expr_stmt|;
return|return
name|SUCCESS
return|;
block|}
end_function

begin_comment
comment|/* Can't use symbol_new here, so have to create a symbol and then at    a later date assign it a value. Thats what these functions do.  */
end_comment

begin_function
specifier|static
name|void
name|symbol_locate
parameter_list|(
name|symbolS
modifier|*
name|symbolP
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
comment|/* It is copied, the caller can modify.	 */
name|segT
name|segment
parameter_list|,
comment|/* Segment identifier (SEG_<something>).  */
name|valueT
name|valu
parameter_list|,
comment|/* Symbol value.  */
name|fragS
modifier|*
name|frag
parameter_list|)
comment|/* Associated fragment.	 */
block|{
name|unsigned
name|int
name|name_length
decl_stmt|;
name|char
modifier|*
name|preserved_copy_of_name
decl_stmt|;
name|name_length
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
expr_stmt|;
comment|/* +1 for \0.  */
name|obstack_grow
argument_list|(
operator|&
name|notes
argument_list|,
name|name
argument_list|,
name|name_length
argument_list|)
expr_stmt|;
name|preserved_copy_of_name
operator|=
name|obstack_finish
argument_list|(
operator|&
name|notes
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|tc_canonicalize_symbol_name
name|preserved_copy_of_name
operator|=
name|tc_canonicalize_symbol_name
argument_list|(
name|preserved_copy_of_name
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|S_SET_NAME
argument_list|(
name|symbolP
argument_list|,
name|preserved_copy_of_name
argument_list|)
expr_stmt|;
name|S_SET_SEGMENT
argument_list|(
name|symbolP
argument_list|,
name|segment
argument_list|)
expr_stmt|;
name|S_SET_VALUE
argument_list|(
name|symbolP
argument_list|,
name|valu
argument_list|)
expr_stmt|;
name|symbol_clear_list_pointers
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
name|symbol_set_frag
argument_list|(
name|symbolP
argument_list|,
name|frag
argument_list|)
expr_stmt|;
comment|/* Link to end of symbol chain.  */
block|{
specifier|extern
name|int
name|symbol_table_frozen
decl_stmt|;
if|if
condition|(
name|symbol_table_frozen
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
name|symbol_append
argument_list|(
name|symbolP
argument_list|,
name|symbol_lastP
argument_list|,
operator|&
name|symbol_rootP
argument_list|,
operator|&
name|symbol_lastP
argument_list|)
expr_stmt|;
name|obj_symbol_new_hook
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|tc_symbol_new_hook
name|tc_symbol_new_hook
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DEBUG_SYMS
name|verify_symbol_chain
argument_list|(
name|symbol_rootP
argument_list|,
name|symbol_lastP
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG_SYMS  */
block|}
end_function

begin_function
specifier|static
name|void
name|s_ltorg
parameter_list|(
name|int
name|ignored
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|unsigned
name|int
name|entry
decl_stmt|;
name|literal_pool
modifier|*
name|pool
decl_stmt|;
name|char
name|sym_name
index|[
literal|20
index|]
decl_stmt|;
name|pool
operator|=
name|find_literal_pool
argument_list|()
expr_stmt|;
if|if
condition|(
name|pool
operator|==
name|NULL
operator|||
name|pool
operator|->
name|symbol
operator|==
name|NULL
operator|||
name|pool
operator|->
name|next_free_entry
operator|==
literal|0
condition|)
return|return;
name|mapping_state
argument_list|(
name|MAP_DATA
argument_list|)
expr_stmt|;
comment|/* Align pool as you have word accesses.      Only make a frag if we have to.  */
if|if
condition|(
operator|!
name|need_pass_2
condition|)
name|frag_align
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|record_alignment
argument_list|(
name|now_seg
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|sym_name
argument_list|,
literal|"$$lit_\002%x"
argument_list|,
name|pool
operator|->
name|id
argument_list|)
expr_stmt|;
name|symbol_locate
argument_list|(
name|pool
operator|->
name|symbol
argument_list|,
name|sym_name
argument_list|,
name|now_seg
argument_list|,
operator|(
name|valueT
operator|)
name|frag_now_fix
argument_list|()
argument_list|,
name|frag_now
argument_list|)
expr_stmt|;
name|symbol_table_insert
argument_list|(
name|pool
operator|->
name|symbol
argument_list|)
expr_stmt|;
name|ARM_SET_THUMB
argument_list|(
name|pool
operator|->
name|symbol
argument_list|,
name|thumb_mode
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
name|OBJ_COFF
operator|||
name|defined
name|OBJ_ELF
name|ARM_SET_INTERWORK
argument_list|(
name|pool
operator|->
name|symbol
argument_list|,
name|support_interwork
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|entry
operator|=
literal|0
init|;
name|entry
operator|<
name|pool
operator|->
name|next_free_entry
condition|;
name|entry
operator|++
control|)
comment|/* First output the expression in the instruction to the pool.  */
name|emit_expr
argument_list|(
operator|&
operator|(
name|pool
operator|->
name|literals
index|[
name|entry
index|]
operator|)
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* .word  */
comment|/* Mark the pool as empty.  */
name|pool
operator|->
name|next_free_entry
operator|=
literal|0
expr_stmt|;
name|pool
operator|->
name|symbol
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|OBJ_ELF
end_ifdef

begin_comment
comment|/* Forward declarations for functions below, in the MD interface    section.  */
end_comment

begin_function_decl
specifier|static
name|void
name|fix_new_arm
parameter_list|(
name|fragS
modifier|*
parameter_list|,
name|int
parameter_list|,
name|short
parameter_list|,
name|expressionS
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|valueT
name|create_unwind_entry
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|start_unwind_section
parameter_list|(
specifier|const
name|segT
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|add_unwind_opcode
parameter_list|(
name|valueT
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|flush_pending_unwind
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Directives: Data.  */
end_comment

begin_function
specifier|static
name|void
name|s_arm_elf_cons
parameter_list|(
name|int
name|nbytes
parameter_list|)
block|{
name|expressionS
name|exp
decl_stmt|;
ifdef|#
directive|ifdef
name|md_flush_pending_output
name|md_flush_pending_output
argument_list|()
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|is_it_end_of_statement
argument_list|()
condition|)
block|{
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
ifdef|#
directive|ifdef
name|md_cons_align
name|md_cons_align
argument_list|(
name|nbytes
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|mapping_state
argument_list|(
name|MAP_DATA
argument_list|)
expr_stmt|;
do|do
block|{
name|int
name|reloc
decl_stmt|;
name|char
modifier|*
name|base
init|=
name|input_line_pointer
decl_stmt|;
name|expression
argument_list|(
operator|&
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
name|exp
operator|.
name|X_op
operator|!=
name|O_symbol
condition|)
name|emit_expr
argument_list|(
operator|&
name|exp
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|nbytes
argument_list|)
expr_stmt|;
else|else
block|{
name|char
modifier|*
name|before_reloc
init|=
name|input_line_pointer
decl_stmt|;
name|reloc
operator|=
name|parse_reloc
argument_list|(
operator|&
name|input_line_pointer
argument_list|)
expr_stmt|;
if|if
condition|(
name|reloc
operator|==
operator|-
literal|1
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"unrecognized relocation suffix"
argument_list|)
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|reloc
operator|==
name|BFD_RELOC_UNUSED
condition|)
name|emit_expr
argument_list|(
operator|&
name|exp
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|nbytes
argument_list|)
expr_stmt|;
else|else
block|{
name|reloc_howto_type
modifier|*
name|howto
init|=
name|bfd_reloc_type_lookup
argument_list|(
name|stdoutput
argument_list|,
name|reloc
argument_list|)
decl_stmt|;
name|int
name|size
init|=
name|bfd_get_reloc_size
argument_list|(
name|howto
argument_list|)
decl_stmt|;
if|if
condition|(
name|reloc
operator|==
name|BFD_RELOC_ARM_PLT32
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"(plt) is only valid on branch targets"
argument_list|)
argument_list|)
expr_stmt|;
name|reloc
operator|=
name|BFD_RELOC_UNUSED
expr_stmt|;
name|size
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|size
operator|>
name|nbytes
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"%s relocations do not fit in %d bytes"
argument_list|)
argument_list|,
name|howto
operator|->
name|name
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* We've parsed an expression stopping at O_symbol. 		     But there may be more expression left now that we 		     have parsed the relocation marker.  Parse it again. 		     XXX Surely there is a cleaner way to do this.  */
name|char
modifier|*
name|p
init|=
name|input_line_pointer
decl_stmt|;
name|int
name|offset
decl_stmt|;
name|char
modifier|*
name|save_buf
init|=
name|alloca
argument_list|(
name|input_line_pointer
operator|-
name|base
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
name|save_buf
argument_list|,
name|base
argument_list|,
name|input_line_pointer
operator|-
name|base
argument_list|)
expr_stmt|;
name|memmove
argument_list|(
name|base
operator|+
operator|(
name|input_line_pointer
operator|-
name|before_reloc
operator|)
argument_list|,
name|base
argument_list|,
name|before_reloc
operator|-
name|base
argument_list|)
expr_stmt|;
name|input_line_pointer
operator|=
name|base
operator|+
operator|(
name|input_line_pointer
operator|-
name|before_reloc
operator|)
expr_stmt|;
name|expression
argument_list|(
operator|&
name|exp
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|base
argument_list|,
name|save_buf
argument_list|,
name|p
operator|-
name|base
argument_list|)
expr_stmt|;
name|offset
operator|=
name|nbytes
operator|-
name|size
expr_stmt|;
name|p
operator|=
name|frag_more
argument_list|(
operator|(
name|int
operator|)
name|nbytes
argument_list|)
expr_stmt|;
name|fix_new_exp
argument_list|(
name|frag_now
argument_list|,
name|p
operator|-
name|frag_now
operator|->
name|fr_literal
operator|+
name|offset
argument_list|,
name|size
argument_list|,
operator|&
name|exp
argument_list|,
literal|0
argument_list|,
name|reloc
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
do|while
condition|(
operator|*
name|input_line_pointer
operator|++
operator|==
literal|','
condition|)
do|;
comment|/* Put terminator back into stream.  */
name|input_line_pointer
operator|--
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Parse a .rel31 directive.  */
end_comment

begin_function
specifier|static
name|void
name|s_arm_rel31
parameter_list|(
name|int
name|ignored
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|expressionS
name|exp
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|valueT
name|highbit
decl_stmt|;
name|highbit
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|'1'
condition|)
name|highbit
operator|=
literal|0x80000000
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|input_line_pointer
operator|!=
literal|'0'
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"expected 0 or 1"
argument_list|)
argument_list|)
expr_stmt|;
name|input_line_pointer
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|!=
literal|','
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"missing comma"
argument_list|)
argument_list|)
expr_stmt|;
name|input_line_pointer
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|md_flush_pending_output
name|md_flush_pending_output
argument_list|()
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|md_cons_align
name|md_cons_align
argument_list|(
literal|4
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|mapping_state
argument_list|(
name|MAP_DATA
argument_list|)
expr_stmt|;
name|expression
argument_list|(
operator|&
name|exp
argument_list|)
expr_stmt|;
name|p
operator|=
name|frag_more
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|p
argument_list|,
name|highbit
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|fix_new_arm
argument_list|(
name|frag_now
argument_list|,
name|p
operator|-
name|frag_now
operator|->
name|fr_literal
argument_list|,
literal|4
argument_list|,
operator|&
name|exp
argument_list|,
literal|1
argument_list|,
name|BFD_RELOC_ARM_PREL31
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Directives: AEABI stack-unwind tables.  */
end_comment

begin_comment
comment|/* Parse an unwind_fnstart directive.  Simply records the current location.  */
end_comment

begin_function
specifier|static
name|void
name|s_arm_unwind_fnstart
parameter_list|(
name|int
name|ignored
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
comment|/* Mark the start of the function.  */
name|unwind
operator|.
name|proc_start
operator|=
name|expr_build_dot
argument_list|()
expr_stmt|;
comment|/* Reset the rest of the unwind info.	 */
name|unwind
operator|.
name|opcode_count
operator|=
literal|0
expr_stmt|;
name|unwind
operator|.
name|table_entry
operator|=
name|NULL
expr_stmt|;
name|unwind
operator|.
name|personality_routine
operator|=
name|NULL
expr_stmt|;
name|unwind
operator|.
name|personality_index
operator|=
operator|-
literal|1
expr_stmt|;
name|unwind
operator|.
name|frame_size
operator|=
literal|0
expr_stmt|;
name|unwind
operator|.
name|fp_offset
operator|=
literal|0
expr_stmt|;
name|unwind
operator|.
name|fp_reg
operator|=
literal|13
expr_stmt|;
name|unwind
operator|.
name|fp_used
operator|=
literal|0
expr_stmt|;
name|unwind
operator|.
name|sp_restored
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Parse a handlerdata directive.  Creates the exception handling table entry    for the function.  */
end_comment

begin_function
specifier|static
name|void
name|s_arm_unwind_handlerdata
parameter_list|(
name|int
name|ignored
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
if|if
condition|(
name|unwind
operator|.
name|table_entry
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"dupicate .handlerdata directive"
argument_list|)
argument_list|)
expr_stmt|;
name|create_unwind_entry
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Parse an unwind_fnend directive.  Generates the index table entry.  */
end_comment

begin_function
specifier|static
name|void
name|s_arm_unwind_fnend
parameter_list|(
name|int
name|ignored
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|long
name|where
decl_stmt|;
name|char
modifier|*
name|ptr
decl_stmt|;
name|valueT
name|val
decl_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
comment|/* Add eh table entry.  */
if|if
condition|(
name|unwind
operator|.
name|table_entry
operator|==
name|NULL
condition|)
name|val
operator|=
name|create_unwind_entry
argument_list|(
literal|0
argument_list|)
expr_stmt|;
else|else
name|val
operator|=
literal|0
expr_stmt|;
comment|/* Add index table entry.  This is two words.	 */
name|start_unwind_section
argument_list|(
name|unwind
operator|.
name|saved_seg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|frag_align
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|record_alignment
argument_list|(
name|now_seg
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|frag_more
argument_list|(
literal|8
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|ptr
argument_list|,
literal|0
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|where
operator|=
name|frag_now_fix
argument_list|()
operator|-
literal|8
expr_stmt|;
comment|/* Self relative offset of the function start.  */
name|fix_new
argument_list|(
name|frag_now
argument_list|,
name|where
argument_list|,
literal|4
argument_list|,
name|unwind
operator|.
name|proc_start
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
name|BFD_RELOC_ARM_PREL31
argument_list|)
expr_stmt|;
comment|/* Indicate dependency on EHABI-defined personality routines to the      linker, if it hasn't been done already.  */
if|if
condition|(
name|unwind
operator|.
name|personality_index
operator|>=
literal|0
operator|&&
name|unwind
operator|.
name|personality_index
operator|<
literal|3
operator|&&
operator|!
operator|(
name|marked_pr_dependency
operator|&
operator|(
literal|1
operator|<<
name|unwind
operator|.
name|personality_index
operator|)
operator|)
condition|)
block|{
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|name
index|[]
init|=
block|{
literal|"__aeabi_unwind_cpp_pr0"
block|,
literal|"__aeabi_unwind_cpp_pr1"
block|,
literal|"__aeabi_unwind_cpp_pr2"
block|}
decl_stmt|;
name|symbolS
modifier|*
name|pr
init|=
name|symbol_find_or_make
argument_list|(
name|name
index|[
name|unwind
operator|.
name|personality_index
index|]
argument_list|)
decl_stmt|;
name|fix_new
argument_list|(
name|frag_now
argument_list|,
name|where
argument_list|,
literal|0
argument_list|,
name|pr
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
name|BFD_RELOC_NONE
argument_list|)
expr_stmt|;
name|marked_pr_dependency
operator||=
literal|1
operator|<<
name|unwind
operator|.
name|personality_index
expr_stmt|;
name|seg_info
argument_list|(
name|now_seg
argument_list|)
operator|->
name|tc_segment_info_data
operator|.
name|marked_pr_dependency
operator|=
name|marked_pr_dependency
expr_stmt|;
block|}
if|if
condition|(
name|val
condition|)
comment|/* Inline exception table entry.  */
name|md_number_to_chars
argument_list|(
name|ptr
operator|+
literal|4
argument_list|,
name|val
argument_list|,
literal|4
argument_list|)
expr_stmt|;
else|else
comment|/* Self relative offset of the table entry.	 */
name|fix_new
argument_list|(
name|frag_now
argument_list|,
name|where
operator|+
literal|4
argument_list|,
literal|4
argument_list|,
name|unwind
operator|.
name|table_entry
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
name|BFD_RELOC_ARM_PREL31
argument_list|)
expr_stmt|;
comment|/* Restore the original section.  */
name|subseg_set
argument_list|(
name|unwind
operator|.
name|saved_seg
argument_list|,
name|unwind
operator|.
name|saved_subseg
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Parse an unwind_cantunwind directive.  */
end_comment

begin_function
specifier|static
name|void
name|s_arm_unwind_cantunwind
parameter_list|(
name|int
name|ignored
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
if|if
condition|(
name|unwind
operator|.
name|personality_routine
operator|||
name|unwind
operator|.
name|personality_index
operator|!=
operator|-
literal|1
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"personality routine specified for cantunwind frame"
argument_list|)
argument_list|)
expr_stmt|;
name|unwind
operator|.
name|personality_index
operator|=
operator|-
literal|2
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Parse a personalityindex directive.	*/
end_comment

begin_function
specifier|static
name|void
name|s_arm_unwind_personalityindex
parameter_list|(
name|int
name|ignored
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|expressionS
name|exp
decl_stmt|;
if|if
condition|(
name|unwind
operator|.
name|personality_routine
operator|||
name|unwind
operator|.
name|personality_index
operator|!=
operator|-
literal|1
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"duplicate .personalityindex directive"
argument_list|)
argument_list|)
expr_stmt|;
name|expression
argument_list|(
operator|&
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
name|exp
operator|.
name|X_op
operator|!=
name|O_constant
operator|||
name|exp
operator|.
name|X_add_number
operator|<
literal|0
operator|||
name|exp
operator|.
name|X_add_number
operator|>
literal|15
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"bad personality routine number"
argument_list|)
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
name|unwind
operator|.
name|personality_index
operator|=
name|exp
operator|.
name|X_add_number
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Parse a personality directive.  */
end_comment

begin_function
specifier|static
name|void
name|s_arm_unwind_personality
parameter_list|(
name|int
name|ignored
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|char
modifier|*
name|name
decl_stmt|,
modifier|*
name|p
decl_stmt|,
name|c
decl_stmt|;
if|if
condition|(
name|unwind
operator|.
name|personality_routine
operator|||
name|unwind
operator|.
name|personality_index
operator|!=
operator|-
literal|1
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"duplicate .personality directive"
argument_list|)
argument_list|)
expr_stmt|;
name|name
operator|=
name|input_line_pointer
expr_stmt|;
name|c
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
name|p
operator|=
name|input_line_pointer
expr_stmt|;
name|unwind
operator|.
name|personality_routine
operator|=
name|symbol_find_or_make
argument_list|(
name|name
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
name|c
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Parse a directive saving core registers.  */
end_comment

begin_function
specifier|static
name|void
name|s_arm_unwind_save_core
parameter_list|(
name|void
parameter_list|)
block|{
name|valueT
name|op
decl_stmt|;
name|long
name|range
decl_stmt|;
name|int
name|n
decl_stmt|;
name|range
operator|=
name|parse_reg_list
argument_list|(
operator|&
name|input_line_pointer
argument_list|)
expr_stmt|;
if|if
condition|(
name|range
operator|==
name|FAIL
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"expected register list"
argument_list|)
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
comment|/* Turn .unwind_movsp ip followed by .unwind_save {..., ip, ...}      into .unwind_save {..., sp...}.  We aren't bothered about the value of      ip because it is clobbered by calls.  */
if|if
condition|(
name|unwind
operator|.
name|sp_restored
operator|&&
name|unwind
operator|.
name|fp_reg
operator|==
literal|12
operator|&&
operator|(
name|range
operator|&
literal|0x3000
operator|)
operator|==
literal|0x1000
condition|)
block|{
name|unwind
operator|.
name|opcode_count
operator|--
expr_stmt|;
name|unwind
operator|.
name|sp_restored
operator|=
literal|0
expr_stmt|;
name|range
operator|=
operator|(
name|range
operator||
literal|0x2000
operator|)
operator|&
operator|~
literal|0x1000
expr_stmt|;
name|unwind
operator|.
name|pending_offset
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Pop r4-r15.  */
if|if
condition|(
name|range
operator|&
literal|0xfff0
condition|)
block|{
comment|/* See if we can use the short opcodes.  These pop a block of up to 8 	 registers starting with r4, plus maybe r14.  */
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
literal|8
condition|;
name|n
operator|++
control|)
block|{
comment|/* Break at the first non-saved register.	 */
if|if
condition|(
operator|(
name|range
operator|&
operator|(
literal|1
operator|<<
operator|(
name|n
operator|+
literal|4
operator|)
operator|)
operator|)
operator|==
literal|0
condition|)
break|break;
block|}
comment|/* See if there are any other bits set.  */
if|if
condition|(
name|n
operator|==
literal|0
operator|||
operator|(
name|range
operator|&
operator|(
literal|0xfff0
operator|<<
name|n
operator|)
operator|&
literal|0xbff0
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* Use the long form.  */
name|op
operator|=
literal|0x8000
operator||
operator|(
operator|(
name|range
operator|>>
literal|4
operator|)
operator|&
literal|0xfff
operator|)
expr_stmt|;
name|add_unwind_opcode
argument_list|(
name|op
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Use the short form.  */
if|if
condition|(
name|range
operator|&
literal|0x4000
condition|)
name|op
operator|=
literal|0xa8
expr_stmt|;
comment|/* Pop r14.	*/
else|else
name|op
operator|=
literal|0xa0
expr_stmt|;
comment|/* Do not pop r14.  */
name|op
operator||=
operator|(
name|n
operator|-
literal|1
operator|)
expr_stmt|;
name|add_unwind_opcode
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Pop r0-r3.	 */
if|if
condition|(
name|range
operator|&
literal|0xf
condition|)
block|{
name|op
operator|=
literal|0xb100
operator||
operator|(
name|range
operator|&
literal|0xf
operator|)
expr_stmt|;
name|add_unwind_opcode
argument_list|(
name|op
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
comment|/* Record the number of bytes pushed.	 */
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
literal|16
condition|;
name|n
operator|++
control|)
block|{
if|if
condition|(
name|range
operator|&
operator|(
literal|1
operator|<<
name|n
operator|)
condition|)
name|unwind
operator|.
name|frame_size
operator|+=
literal|4
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Parse a directive saving FPA registers.  */
end_comment

begin_function
specifier|static
name|void
name|s_arm_unwind_save_fpa
parameter_list|(
name|int
name|reg
parameter_list|)
block|{
name|expressionS
name|exp
decl_stmt|;
name|int
name|num_regs
decl_stmt|;
name|valueT
name|op
decl_stmt|;
comment|/* Get Number of registers to transfer.  */
if|if
condition|(
name|skip_past_comma
argument_list|(
operator|&
name|input_line_pointer
argument_list|)
operator|!=
name|FAIL
condition|)
name|expression
argument_list|(
operator|&
name|exp
argument_list|)
expr_stmt|;
else|else
name|exp
operator|.
name|X_op
operator|=
name|O_illegal
expr_stmt|;
if|if
condition|(
name|exp
operator|.
name|X_op
operator|!=
name|O_constant
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"expected ,<constant>"
argument_list|)
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
name|num_regs
operator|=
name|exp
operator|.
name|X_add_number
expr_stmt|;
if|if
condition|(
name|num_regs
operator|<
literal|1
operator|||
name|num_regs
operator|>
literal|4
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"number of registers must be in the range [1:4]"
argument_list|)
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
if|if
condition|(
name|reg
operator|==
literal|4
condition|)
block|{
comment|/* Short form.  */
name|op
operator|=
literal|0xb4
operator||
operator|(
name|num_regs
operator|-
literal|1
operator|)
expr_stmt|;
name|add_unwind_opcode
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Long form.  */
name|op
operator|=
literal|0xc800
operator||
operator|(
name|reg
operator|<<
literal|4
operator|)
operator||
operator|(
name|num_regs
operator|-
literal|1
operator|)
expr_stmt|;
name|add_unwind_opcode
argument_list|(
name|op
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
name|unwind
operator|.
name|frame_size
operator|+=
name|num_regs
operator|*
literal|12
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Parse a directive saving VFP registers for ARMv6 and above.  */
end_comment

begin_function
specifier|static
name|void
name|s_arm_unwind_save_vfp_armv6
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|count
decl_stmt|;
name|unsigned
name|int
name|start
decl_stmt|;
name|valueT
name|op
decl_stmt|;
name|int
name|num_vfpv3_regs
init|=
literal|0
decl_stmt|;
name|int
name|num_regs_below_16
decl_stmt|;
name|count
operator|=
name|parse_vfp_reg_list
argument_list|(
operator|&
name|input_line_pointer
argument_list|,
operator|&
name|start
argument_list|,
name|REGLIST_VFP_D
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|==
name|FAIL
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"expected register list"
argument_list|)
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
comment|/* We always generate FSTMD/FLDMD-style unwinding opcodes (rather      than FSTMX/FLDMX-style ones).  */
comment|/* Generate opcode for (VFPv3) registers numbered in the range 16 .. 31.  */
if|if
condition|(
name|start
operator|>=
literal|16
condition|)
name|num_vfpv3_regs
operator|=
name|count
expr_stmt|;
elseif|else
if|if
condition|(
name|start
operator|+
name|count
operator|>
literal|16
condition|)
name|num_vfpv3_regs
operator|=
name|start
operator|+
name|count
operator|-
literal|16
expr_stmt|;
if|if
condition|(
name|num_vfpv3_regs
operator|>
literal|0
condition|)
block|{
name|int
name|start_offset
init|=
name|start
operator|>
literal|16
condition|?
name|start
operator|-
literal|16
else|:
literal|0
decl_stmt|;
name|op
operator|=
literal|0xc800
operator||
operator|(
name|start_offset
operator|<<
literal|4
operator|)
operator||
operator|(
name|num_vfpv3_regs
operator|-
literal|1
operator|)
expr_stmt|;
name|add_unwind_opcode
argument_list|(
name|op
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
comment|/* Generate opcode for registers numbered in the range 0 .. 15.  */
name|num_regs_below_16
operator|=
name|num_vfpv3_regs
operator|>
literal|0
condition|?
literal|16
operator|-
operator|(
name|int
operator|)
name|start
else|:
name|count
expr_stmt|;
name|assert
argument_list|(
name|num_regs_below_16
operator|+
name|num_vfpv3_regs
operator|==
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|num_regs_below_16
operator|>
literal|0
condition|)
block|{
name|op
operator|=
literal|0xc900
operator||
operator|(
name|start
operator|<<
literal|4
operator|)
operator||
operator|(
name|num_regs_below_16
operator|-
literal|1
operator|)
expr_stmt|;
name|add_unwind_opcode
argument_list|(
name|op
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
name|unwind
operator|.
name|frame_size
operator|+=
name|count
operator|*
literal|8
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Parse a directive saving VFP registers for pre-ARMv6.  */
end_comment

begin_function
specifier|static
name|void
name|s_arm_unwind_save_vfp
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|count
decl_stmt|;
name|unsigned
name|int
name|reg
decl_stmt|;
name|valueT
name|op
decl_stmt|;
name|count
operator|=
name|parse_vfp_reg_list
argument_list|(
operator|&
name|input_line_pointer
argument_list|,
operator|&
name|reg
argument_list|,
name|REGLIST_VFP_D
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|==
name|FAIL
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"expected register list"
argument_list|)
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
if|if
condition|(
name|reg
operator|==
literal|8
condition|)
block|{
comment|/* Short form.  */
name|op
operator|=
literal|0xb8
operator||
operator|(
name|count
operator|-
literal|1
operator|)
expr_stmt|;
name|add_unwind_opcode
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Long form.  */
name|op
operator|=
literal|0xb300
operator||
operator|(
name|reg
operator|<<
literal|4
operator|)
operator||
operator|(
name|count
operator|-
literal|1
operator|)
expr_stmt|;
name|add_unwind_opcode
argument_list|(
name|op
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
name|unwind
operator|.
name|frame_size
operator|+=
name|count
operator|*
literal|8
operator|+
literal|4
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Parse a directive saving iWMMXt data registers.  */
end_comment

begin_function
specifier|static
name|void
name|s_arm_unwind_save_mmxwr
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|reg
decl_stmt|;
name|int
name|hi_reg
decl_stmt|;
name|int
name|i
decl_stmt|;
name|unsigned
name|mask
init|=
literal|0
decl_stmt|;
name|valueT
name|op
decl_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|'{'
condition|)
name|input_line_pointer
operator|++
expr_stmt|;
do|do
block|{
name|reg
operator|=
name|arm_reg_parse
argument_list|(
operator|&
name|input_line_pointer
argument_list|,
name|REG_TYPE_MMXWR
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
operator|==
name|FAIL
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
name|reg_expected_msgs
index|[
name|REG_TYPE_MMXWR
index|]
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
if|if
condition|(
name|mask
operator|>>
name|reg
condition|)
name|as_tsktsk
argument_list|(
name|_
argument_list|(
literal|"register list not in ascending order"
argument_list|)
argument_list|)
expr_stmt|;
name|mask
operator||=
literal|1
operator|<<
name|reg
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|'-'
condition|)
block|{
name|input_line_pointer
operator|++
expr_stmt|;
name|hi_reg
operator|=
name|arm_reg_parse
argument_list|(
operator|&
name|input_line_pointer
argument_list|,
name|REG_TYPE_MMXWR
argument_list|)
expr_stmt|;
if|if
condition|(
name|hi_reg
operator|==
name|FAIL
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
name|reg_expected_msgs
index|[
name|REG_TYPE_MMXWR
index|]
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
elseif|else
if|if
condition|(
name|reg
operator|>=
name|hi_reg
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"bad register range"
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
for|for
control|(
init|;
name|reg
operator|<
name|hi_reg
condition|;
name|reg
operator|++
control|)
name|mask
operator||=
literal|1
operator|<<
name|reg
expr_stmt|;
block|}
block|}
do|while
condition|(
name|skip_past_comma
argument_list|(
operator|&
name|input_line_pointer
argument_list|)
operator|!=
name|FAIL
condition|)
do|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|'}'
condition|)
name|input_line_pointer
operator|++
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
comment|/* Generate any deferred opcodes because we're going to be looking at      the list.	*/
name|flush_pending_unwind
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|mask
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
condition|)
name|unwind
operator|.
name|frame_size
operator|+=
literal|8
expr_stmt|;
block|}
comment|/* Attempt to combine with a previous opcode.	 We do this because gcc      likes to output separate unwind directives for a single block of      registers.	 */
if|if
condition|(
name|unwind
operator|.
name|opcode_count
operator|>
literal|0
condition|)
block|{
name|i
operator|=
name|unwind
operator|.
name|opcodes
index|[
name|unwind
operator|.
name|opcode_count
operator|-
literal|1
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|&
literal|0xf8
operator|)
operator|==
literal|0xc0
condition|)
block|{
name|i
operator|&=
literal|7
expr_stmt|;
comment|/* Only merge if the blocks are contiguous.  */
if|if
condition|(
name|i
operator|<
literal|6
condition|)
block|{
if|if
condition|(
operator|(
name|mask
operator|&
literal|0xfe00
operator|)
operator|==
operator|(
literal|1
operator|<<
literal|9
operator|)
condition|)
block|{
name|mask
operator||=
operator|(
operator|(
literal|1
operator|<<
operator|(
name|i
operator|+
literal|11
operator|)
operator|)
operator|-
literal|1
operator|)
operator|&
literal|0xfc00
expr_stmt|;
name|unwind
operator|.
name|opcode_count
operator|--
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|i
operator|==
literal|6
operator|&&
name|unwind
operator|.
name|opcode_count
operator|>=
literal|2
condition|)
block|{
name|i
operator|=
name|unwind
operator|.
name|opcodes
index|[
name|unwind
operator|.
name|opcode_count
operator|-
literal|2
index|]
expr_stmt|;
name|reg
operator|=
name|i
operator|>>
literal|4
expr_stmt|;
name|i
operator|&=
literal|0xf
expr_stmt|;
name|op
operator|=
literal|0xffff
operator|<<
operator|(
name|reg
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|reg
operator|>
literal|0
operator|&&
operator|(
operator|(
name|mask
operator|&
name|op
operator|)
operator|==
operator|(
literal|1u
operator|<<
operator|(
name|reg
operator|-
literal|1
operator|)
operator|)
operator|)
condition|)
block|{
name|op
operator|=
operator|(
literal|1
operator|<<
operator|(
name|reg
operator|+
name|i
operator|+
literal|1
operator|)
operator|)
operator|-
literal|1
expr_stmt|;
name|op
operator|&=
operator|~
operator|(
operator|(
literal|1
operator|<<
name|reg
operator|)
operator|-
literal|1
operator|)
expr_stmt|;
name|mask
operator||=
name|op
expr_stmt|;
name|unwind
operator|.
name|opcode_count
operator|-=
literal|2
expr_stmt|;
block|}
block|}
block|}
block|}
name|hi_reg
operator|=
literal|15
expr_stmt|;
comment|/* We want to generate opcodes in the order the registers have been      saved, ie. descending order.  */
for|for
control|(
name|reg
operator|=
literal|15
init|;
name|reg
operator|>=
operator|-
literal|1
condition|;
name|reg
operator|--
control|)
block|{
comment|/* Save registers in blocks.  */
if|if
condition|(
name|reg
operator|<
literal|0
operator|||
operator|!
operator|(
name|mask
operator|&
operator|(
literal|1
operator|<<
name|reg
operator|)
operator|)
condition|)
block|{
comment|/* We found an unsaved reg.  Generate opcodes to save the 	     preceeding block.	*/
if|if
condition|(
name|reg
operator|!=
name|hi_reg
condition|)
block|{
if|if
condition|(
name|reg
operator|==
literal|9
condition|)
block|{
comment|/* Short form.  */
name|op
operator|=
literal|0xc0
operator||
operator|(
name|hi_reg
operator|-
literal|10
operator|)
expr_stmt|;
name|add_unwind_opcode
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Long form.	 */
name|op
operator|=
literal|0xc600
operator||
operator|(
operator|(
name|reg
operator|+
literal|1
operator|)
operator|<<
literal|4
operator|)
operator||
operator|(
operator|(
name|hi_reg
operator|-
name|reg
operator|)
operator|-
literal|1
operator|)
expr_stmt|;
name|add_unwind_opcode
argument_list|(
name|op
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
block|}
name|hi_reg
operator|=
name|reg
operator|-
literal|1
expr_stmt|;
block|}
block|}
return|return;
name|error
label|:
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|s_arm_unwind_save_mmxwcg
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|reg
decl_stmt|;
name|int
name|hi_reg
decl_stmt|;
name|unsigned
name|mask
init|=
literal|0
decl_stmt|;
name|valueT
name|op
decl_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|'{'
condition|)
name|input_line_pointer
operator|++
expr_stmt|;
do|do
block|{
name|reg
operator|=
name|arm_reg_parse
argument_list|(
operator|&
name|input_line_pointer
argument_list|,
name|REG_TYPE_MMXWCG
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
operator|==
name|FAIL
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
name|reg_expected_msgs
index|[
name|REG_TYPE_MMXWCG
index|]
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|reg
operator|-=
literal|8
expr_stmt|;
if|if
condition|(
name|mask
operator|>>
name|reg
condition|)
name|as_tsktsk
argument_list|(
name|_
argument_list|(
literal|"register list not in ascending order"
argument_list|)
argument_list|)
expr_stmt|;
name|mask
operator||=
literal|1
operator|<<
name|reg
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|'-'
condition|)
block|{
name|input_line_pointer
operator|++
expr_stmt|;
name|hi_reg
operator|=
name|arm_reg_parse
argument_list|(
operator|&
name|input_line_pointer
argument_list|,
name|REG_TYPE_MMXWCG
argument_list|)
expr_stmt|;
if|if
condition|(
name|hi_reg
operator|==
name|FAIL
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
name|reg_expected_msgs
index|[
name|REG_TYPE_MMXWCG
index|]
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
elseif|else
if|if
condition|(
name|reg
operator|>=
name|hi_reg
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"bad register range"
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
for|for
control|(
init|;
name|reg
operator|<
name|hi_reg
condition|;
name|reg
operator|++
control|)
name|mask
operator||=
literal|1
operator|<<
name|reg
expr_stmt|;
block|}
block|}
do|while
condition|(
name|skip_past_comma
argument_list|(
operator|&
name|input_line_pointer
argument_list|)
operator|!=
name|FAIL
condition|)
do|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|'}'
condition|)
name|input_line_pointer
operator|++
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
comment|/* Generate any deferred opcodes because we're going to be looking at      the list.	*/
name|flush_pending_unwind
argument_list|()
expr_stmt|;
for|for
control|(
name|reg
operator|=
literal|0
init|;
name|reg
operator|<
literal|16
condition|;
name|reg
operator|++
control|)
block|{
if|if
condition|(
name|mask
operator|&
operator|(
literal|1
operator|<<
name|reg
operator|)
condition|)
name|unwind
operator|.
name|frame_size
operator|+=
literal|4
expr_stmt|;
block|}
name|op
operator|=
literal|0xc700
operator||
name|mask
expr_stmt|;
name|add_unwind_opcode
argument_list|(
name|op
argument_list|,
literal|2
argument_list|)
expr_stmt|;
return|return;
name|error
label|:
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Parse an unwind_save directive.    If the argument is non-zero, this is a .vsave directive.  */
end_comment

begin_function
specifier|static
name|void
name|s_arm_unwind_save
parameter_list|(
name|int
name|arch_v6
parameter_list|)
block|{
name|char
modifier|*
name|peek
decl_stmt|;
name|struct
name|reg_entry
modifier|*
name|reg
decl_stmt|;
name|bfd_boolean
name|had_brace
init|=
name|FALSE
decl_stmt|;
comment|/* Figure out what sort of save we have.  */
name|peek
operator|=
name|input_line_pointer
expr_stmt|;
if|if
condition|(
operator|*
name|peek
operator|==
literal|'{'
condition|)
block|{
name|had_brace
operator|=
name|TRUE
expr_stmt|;
name|peek
operator|++
expr_stmt|;
block|}
name|reg
operator|=
name|arm_reg_parse_multi
argument_list|(
operator|&
name|peek
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|reg
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"register expected"
argument_list|)
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
switch|switch
condition|(
name|reg
operator|->
name|type
condition|)
block|{
case|case
name|REG_TYPE_FN
case|:
if|if
condition|(
name|had_brace
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"FPA .unwind_save does not take a register list"
argument_list|)
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
name|s_arm_unwind_save_fpa
argument_list|(
name|reg
operator|->
name|number
argument_list|)
expr_stmt|;
return|return;
case|case
name|REG_TYPE_RN
case|:
name|s_arm_unwind_save_core
argument_list|()
expr_stmt|;
return|return;
case|case
name|REG_TYPE_VFD
case|:
if|if
condition|(
name|arch_v6
condition|)
name|s_arm_unwind_save_vfp_armv6
argument_list|()
expr_stmt|;
else|else
name|s_arm_unwind_save_vfp
argument_list|()
expr_stmt|;
return|return;
case|case
name|REG_TYPE_MMXWR
case|:
name|s_arm_unwind_save_mmxwr
argument_list|()
expr_stmt|;
return|return;
case|case
name|REG_TYPE_MMXWCG
case|:
name|s_arm_unwind_save_mmxwcg
argument_list|()
expr_stmt|;
return|return;
default|default:
name|as_bad
argument_list|(
name|_
argument_list|(
literal|".unwind_save does not support this kind of register"
argument_list|)
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Parse an unwind_movsp directive.  */
end_comment

begin_function
specifier|static
name|void
name|s_arm_unwind_movsp
parameter_list|(
name|int
name|ignored
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|int
name|reg
decl_stmt|;
name|valueT
name|op
decl_stmt|;
name|int
name|offset
decl_stmt|;
name|reg
operator|=
name|arm_reg_parse
argument_list|(
operator|&
name|input_line_pointer
argument_list|,
name|REG_TYPE_RN
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
operator|==
name|FAIL
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
name|reg_expected_msgs
index|[
name|REG_TYPE_RN
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
comment|/* Optional constant.	 */
if|if
condition|(
name|skip_past_comma
argument_list|(
operator|&
name|input_line_pointer
argument_list|)
operator|!=
name|FAIL
condition|)
block|{
if|if
condition|(
name|immediate_for_directive
argument_list|(
operator|&
name|offset
argument_list|)
operator|==
name|FAIL
condition|)
return|return;
block|}
else|else
name|offset
operator|=
literal|0
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
if|if
condition|(
name|reg
operator|==
name|REG_SP
operator|||
name|reg
operator|==
name|REG_PC
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"SP and PC not permitted in .unwind_movsp directive"
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|unwind
operator|.
name|fp_reg
operator|!=
name|REG_SP
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"unexpected .unwind_movsp directive"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Generate opcode to restore the value.  */
name|op
operator|=
literal|0x90
operator||
name|reg
expr_stmt|;
name|add_unwind_opcode
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Record the information for later.	*/
name|unwind
operator|.
name|fp_reg
operator|=
name|reg
expr_stmt|;
name|unwind
operator|.
name|fp_offset
operator|=
name|unwind
operator|.
name|frame_size
operator|-
name|offset
expr_stmt|;
name|unwind
operator|.
name|sp_restored
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Parse an unwind_pad directive.  */
end_comment

begin_function
specifier|static
name|void
name|s_arm_unwind_pad
parameter_list|(
name|int
name|ignored
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|int
name|offset
decl_stmt|;
if|if
condition|(
name|immediate_for_directive
argument_list|(
operator|&
name|offset
argument_list|)
operator|==
name|FAIL
condition|)
return|return;
if|if
condition|(
name|offset
operator|&
literal|3
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"stack increment must be multiple of 4"
argument_list|)
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
comment|/* Don't generate any opcodes, just record the details for later.  */
name|unwind
operator|.
name|frame_size
operator|+=
name|offset
expr_stmt|;
name|unwind
operator|.
name|pending_offset
operator|+=
name|offset
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Parse an unwind_setfp directive.  */
end_comment

begin_function
specifier|static
name|void
name|s_arm_unwind_setfp
parameter_list|(
name|int
name|ignored
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|int
name|sp_reg
decl_stmt|;
name|int
name|fp_reg
decl_stmt|;
name|int
name|offset
decl_stmt|;
name|fp_reg
operator|=
name|arm_reg_parse
argument_list|(
operator|&
name|input_line_pointer
argument_list|,
name|REG_TYPE_RN
argument_list|)
expr_stmt|;
if|if
condition|(
name|skip_past_comma
argument_list|(
operator|&
name|input_line_pointer
argument_list|)
operator|==
name|FAIL
condition|)
name|sp_reg
operator|=
name|FAIL
expr_stmt|;
else|else
name|sp_reg
operator|=
name|arm_reg_parse
argument_list|(
operator|&
name|input_line_pointer
argument_list|,
name|REG_TYPE_RN
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp_reg
operator|==
name|FAIL
operator|||
name|sp_reg
operator|==
name|FAIL
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"expected<reg>,<reg>"
argument_list|)
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
comment|/* Optional constant.	 */
if|if
condition|(
name|skip_past_comma
argument_list|(
operator|&
name|input_line_pointer
argument_list|)
operator|!=
name|FAIL
condition|)
block|{
if|if
condition|(
name|immediate_for_directive
argument_list|(
operator|&
name|offset
argument_list|)
operator|==
name|FAIL
condition|)
return|return;
block|}
else|else
name|offset
operator|=
literal|0
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
if|if
condition|(
name|sp_reg
operator|!=
literal|13
operator|&&
name|sp_reg
operator|!=
name|unwind
operator|.
name|fp_reg
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"register must be either sp or set by a previous"
literal|"unwind_movsp directive"
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Don't generate any opcodes, just record the information for later.	 */
name|unwind
operator|.
name|fp_reg
operator|=
name|fp_reg
expr_stmt|;
name|unwind
operator|.
name|fp_used
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|sp_reg
operator|==
literal|13
condition|)
name|unwind
operator|.
name|fp_offset
operator|=
name|unwind
operator|.
name|frame_size
operator|-
name|offset
expr_stmt|;
else|else
name|unwind
operator|.
name|fp_offset
operator|-=
name|offset
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Parse an unwind_raw directive.  */
end_comment

begin_function
specifier|static
name|void
name|s_arm_unwind_raw
parameter_list|(
name|int
name|ignored
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|expressionS
name|exp
decl_stmt|;
comment|/* This is an arbitrary limit.	 */
name|unsigned
name|char
name|op
index|[
literal|16
index|]
decl_stmt|;
name|int
name|count
decl_stmt|;
name|expression
argument_list|(
operator|&
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
name|exp
operator|.
name|X_op
operator|==
name|O_constant
operator|&&
name|skip_past_comma
argument_list|(
operator|&
name|input_line_pointer
argument_list|)
operator|!=
name|FAIL
condition|)
block|{
name|unwind
operator|.
name|frame_size
operator|+=
name|exp
operator|.
name|X_add_number
expr_stmt|;
name|expression
argument_list|(
operator|&
name|exp
argument_list|)
expr_stmt|;
block|}
else|else
name|exp
operator|.
name|X_op
operator|=
name|O_illegal
expr_stmt|;
if|if
condition|(
name|exp
operator|.
name|X_op
operator|!=
name|O_constant
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"expected<offset>,<opcode>"
argument_list|)
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
name|count
operator|=
literal|0
expr_stmt|;
comment|/* Parse the opcode.	*/
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|count
operator|>=
literal|16
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"unwind opcode too long"
argument_list|)
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|exp
operator|.
name|X_op
operator|!=
name|O_constant
operator|||
name|exp
operator|.
name|X_add_number
operator|&
operator|~
literal|0xff
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"invalid unwind opcode"
argument_list|)
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
name|op
index|[
name|count
operator|++
index|]
operator|=
name|exp
operator|.
name|X_add_number
expr_stmt|;
comment|/* Parse the next byte.  */
if|if
condition|(
name|skip_past_comma
argument_list|(
operator|&
name|input_line_pointer
argument_list|)
operator|==
name|FAIL
condition|)
break|break;
name|expression
argument_list|(
operator|&
name|exp
argument_list|)
expr_stmt|;
block|}
comment|/* Add the opcode bytes in reverse order.  */
while|while
condition|(
name|count
operator|--
condition|)
name|add_unwind_opcode
argument_list|(
name|op
index|[
name|count
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Parse a .eabi_attribute directive.  */
end_comment

begin_function
specifier|static
name|void
name|s_arm_eabi_attribute
parameter_list|(
name|int
name|ignored
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|s_vendor_attribute
argument_list|(
name|OBJ_ATTR_PROC
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* OBJ_ELF */
end_comment

begin_function_decl
specifier|static
name|void
name|s_arm_arch
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|s_arm_object_arch
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|s_arm_cpu
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|s_arm_fpu
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|s_arm_arch_extension
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|TE_PE
end_ifdef

begin_function
specifier|static
name|void
name|pe_directive_secrel
parameter_list|(
name|int
name|dummy
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|expressionS
name|exp
decl_stmt|;
do|do
block|{
name|expression
argument_list|(
operator|&
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
name|exp
operator|.
name|X_op
operator|==
name|O_symbol
condition|)
name|exp
operator|.
name|X_op
operator|=
name|O_secrel
expr_stmt|;
name|emit_expr
argument_list|(
operator|&
name|exp
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|*
name|input_line_pointer
operator|++
operator|==
literal|','
condition|)
do|;
name|input_line_pointer
operator|--
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* TE_PE */
end_comment

begin_comment
comment|/* This table describes all the machine specific pseudo-ops the assembler    has to support.  The fields are:      pseudo-op name without dot      function to call to execute this pseudo-op      Integer arg to pass to the function.  */
end_comment

begin_decl_stmt
specifier|const
name|pseudo_typeS
name|md_pseudo_table
index|[]
init|=
block|{
comment|/* Never called because '.req' does not start a line.	 */
block|{
literal|"req"
block|,
name|s_req
block|,
literal|0
block|}
block|,
comment|/* Following two are likewise never called.  */
block|{
literal|"dn"
block|,
name|s_dn
block|,
literal|0
block|}
block|,
block|{
literal|"qn"
block|,
name|s_qn
block|,
literal|0
block|}
block|,
block|{
literal|"unreq"
block|,
name|s_unreq
block|,
literal|0
block|}
block|,
block|{
literal|"bss"
block|,
name|s_bss
block|,
literal|0
block|}
block|,
block|{
literal|"align"
block|,
name|s_align
block|,
literal|0
block|}
block|,
block|{
literal|"arm"
block|,
name|s_arm
block|,
literal|0
block|}
block|,
block|{
literal|"thumb"
block|,
name|s_thumb
block|,
literal|0
block|}
block|,
block|{
literal|"code"
block|,
name|s_code
block|,
literal|0
block|}
block|,
block|{
literal|"force_thumb"
block|,
name|s_force_thumb
block|,
literal|0
block|}
block|,
block|{
literal|"thumb_func"
block|,
name|s_thumb_func
block|,
literal|0
block|}
block|,
block|{
literal|"thumb_set"
block|,
name|s_thumb_set
block|,
literal|0
block|}
block|,
block|{
literal|"even"
block|,
name|s_even
block|,
literal|0
block|}
block|,
block|{
literal|"ltorg"
block|,
name|s_ltorg
block|,
literal|0
block|}
block|,
block|{
literal|"pool"
block|,
name|s_ltorg
block|,
literal|0
block|}
block|,
block|{
literal|"syntax"
block|,
name|s_syntax
block|,
literal|0
block|}
block|,
block|{
literal|"cpu"
block|,
name|s_arm_cpu
block|,
literal|0
block|}
block|,
block|{
literal|"arch"
block|,
name|s_arm_arch
block|,
literal|0
block|}
block|,
block|{
literal|"object_arch"
block|,
name|s_arm_object_arch
block|,
literal|0
block|}
block|,
block|{
literal|"fpu"
block|,
name|s_arm_fpu
block|,
literal|0
block|}
block|,
block|{
literal|"arch_extension"
block|,
name|s_arm_arch_extension
block|,
literal|0
block|}
block|,
block|{
literal|"inst"
block|,
name|s_inst
block|,
literal|0
block|}
block|,
ifdef|#
directive|ifdef
name|OBJ_ELF
block|{
literal|"word"
block|,
name|s_arm_elf_cons
block|,
literal|4
block|}
block|,
block|{
literal|"long"
block|,
name|s_arm_elf_cons
block|,
literal|4
block|}
block|,
block|{
literal|"rel31"
block|,
name|s_arm_rel31
block|,
literal|0
block|}
block|,
block|{
literal|"fnstart"
block|,
name|s_arm_unwind_fnstart
block|,
literal|0
block|}
block|,
block|{
literal|"fnend"
block|,
name|s_arm_unwind_fnend
block|,
literal|0
block|}
block|,
block|{
literal|"cantunwind"
block|,
name|s_arm_unwind_cantunwind
block|,
literal|0
block|}
block|,
block|{
literal|"personality"
block|,
name|s_arm_unwind_personality
block|,
literal|0
block|}
block|,
block|{
literal|"personalityindex"
block|,
name|s_arm_unwind_personalityindex
block|,
literal|0
block|}
block|,
block|{
literal|"handlerdata"
block|,
name|s_arm_unwind_handlerdata
block|,
literal|0
block|}
block|,
block|{
literal|"save"
block|,
name|s_arm_unwind_save
block|,
literal|0
block|}
block|,
block|{
literal|"vsave"
block|,
name|s_arm_unwind_save
block|,
literal|1
block|}
block|,
block|{
literal|"movsp"
block|,
name|s_arm_unwind_movsp
block|,
literal|0
block|}
block|,
block|{
literal|"pad"
block|,
name|s_arm_unwind_pad
block|,
literal|0
block|}
block|,
block|{
literal|"setfp"
block|,
name|s_arm_unwind_setfp
block|,
literal|0
block|}
block|,
block|{
literal|"unwind_raw"
block|,
name|s_arm_unwind_raw
block|,
literal|0
block|}
block|,
block|{
literal|"eabi_attribute"
block|,
name|s_arm_eabi_attribute
block|,
literal|0
block|}
block|,
else|#
directive|else
block|{
literal|"word"
block|,
name|cons
block|,
literal|4
block|}
block|,
comment|/* These are used for dwarf.  */
block|{
literal|"2byte"
block|,
name|cons
block|,
literal|2
block|}
block|,
block|{
literal|"4byte"
block|,
name|cons
block|,
literal|4
block|}
block|,
block|{
literal|"8byte"
block|,
name|cons
block|,
literal|8
block|}
block|,
comment|/* These are used for dwarf2.  */
block|{
literal|"file"
block|,
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|int
argument_list|)
operator|)
name|dwarf2_directive_file
block|,
literal|0
block|}
block|,
block|{
literal|"loc"
block|,
name|dwarf2_directive_loc
block|,
literal|0
block|}
block|,
block|{
literal|"loc_mark_labels"
block|,
name|dwarf2_directive_loc_mark_labels
block|,
literal|0
block|}
block|,
endif|#
directive|endif
block|{
literal|"extend"
block|,
name|float_cons
block|,
literal|'x'
block|}
block|,
block|{
literal|"ldouble"
block|,
name|float_cons
block|,
literal|'x'
block|}
block|,
block|{
literal|"packed"
block|,
name|float_cons
block|,
literal|'p'
block|}
block|,
ifdef|#
directive|ifdef
name|TE_PE
block|{
literal|"secrel32"
block|,
name|pe_directive_secrel
block|,
literal|0
block|}
block|,
endif|#
directive|endif
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Parser functions used exclusively in instruction operands.  */
end_comment

begin_comment
comment|/* Generic immediate-value read function for use in insn parsing.    STR points to the beginning of the immediate (the leading #);    VAL receives the value; if the value is outside [MIN, MAX]    issue an error.  PREFIX_OPT is true if the immediate prefix is    optional.  */
end_comment

begin_function
specifier|static
name|int
name|parse_immediate
parameter_list|(
name|char
modifier|*
modifier|*
name|str
parameter_list|,
name|int
modifier|*
name|val
parameter_list|,
name|int
name|min
parameter_list|,
name|int
name|max
parameter_list|,
name|bfd_boolean
name|prefix_opt
parameter_list|)
block|{
name|expressionS
name|exp
decl_stmt|;
name|my_get_expression
argument_list|(
operator|&
name|exp
argument_list|,
name|str
argument_list|,
name|prefix_opt
condition|?
name|GE_OPT_PREFIX
else|:
name|GE_IMM_PREFIX
argument_list|)
expr_stmt|;
if|if
condition|(
name|exp
operator|.
name|X_op
operator|!=
name|O_constant
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"constant expression required"
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
block|}
if|if
condition|(
name|exp
operator|.
name|X_add_number
operator|<
name|min
operator|||
name|exp
operator|.
name|X_add_number
operator|>
name|max
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"immediate value out of range"
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
block|}
operator|*
name|val
operator|=
name|exp
operator|.
name|X_add_number
expr_stmt|;
return|return
name|SUCCESS
return|;
block|}
end_function

begin_comment
comment|/* Less-generic immediate-value read function with the possibility of loading a    big (64-bit) immediate, as required by Neon VMOV, VMVN and logic immediate    instructions. Puts the result directly in inst.operands[i].  */
end_comment

begin_function
specifier|static
name|int
name|parse_big_immediate
parameter_list|(
name|char
modifier|*
modifier|*
name|str
parameter_list|,
name|int
name|i
parameter_list|)
block|{
name|expressionS
name|exp
decl_stmt|;
name|char
modifier|*
name|ptr
init|=
operator|*
name|str
decl_stmt|;
name|my_get_expression
argument_list|(
operator|&
name|exp
argument_list|,
operator|&
name|ptr
argument_list|,
name|GE_OPT_PREFIX_BIG
argument_list|)
expr_stmt|;
if|if
condition|(
name|exp
operator|.
name|X_op
operator|==
name|O_constant
condition|)
block|{
name|inst
operator|.
name|operands
index|[
name|i
index|]
operator|.
name|imm
operator|=
name|exp
operator|.
name|X_add_number
operator|&
literal|0xffffffff
expr_stmt|;
comment|/* If we're on a 64-bit host, then a 64-bit number can be returned using 	 O_constant.  We have to be careful not to break compilation for 	 32-bit X_add_number, though.  */
if|if
condition|(
operator|(
name|exp
operator|.
name|X_add_number
operator|&
operator|~
literal|0xffffffffl
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* X>> 32 is illegal if sizeof (exp.X_add_number) == 4.  */
name|inst
operator|.
name|operands
index|[
name|i
index|]
operator|.
name|reg
operator|=
operator|(
operator|(
name|exp
operator|.
name|X_add_number
operator|>>
literal|16
operator|)
operator|>>
literal|16
operator|)
operator|&
literal|0xffffffff
expr_stmt|;
name|inst
operator|.
name|operands
index|[
name|i
index|]
operator|.
name|regisimm
operator|=
literal|1
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|exp
operator|.
name|X_op
operator|==
name|O_big
operator|&&
name|LITTLENUM_NUMBER_OF_BITS
operator|*
name|exp
operator|.
name|X_add_number
operator|>
literal|32
operator|&&
name|LITTLENUM_NUMBER_OF_BITS
operator|*
name|exp
operator|.
name|X_add_number
operator|<=
literal|64
condition|)
block|{
name|unsigned
name|parts
init|=
literal|32
operator|/
name|LITTLENUM_NUMBER_OF_BITS
decl_stmt|,
name|j
decl_stmt|,
name|idx
init|=
literal|0
decl_stmt|;
comment|/* Bignums have their least significant bits in          generic_bignum[0]. Make sure we put 32 bits in imm and          32 bits in reg,  in a (hopefully) portable way.  */
name|assert
argument_list|(
name|parts
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|inst
operator|.
name|operands
index|[
name|i
index|]
operator|.
name|imm
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|parts
condition|;
name|j
operator|++
operator|,
name|idx
operator|++
control|)
name|inst
operator|.
name|operands
index|[
name|i
index|]
operator|.
name|imm
operator||=
name|generic_bignum
index|[
name|idx
index|]
operator|<<
operator|(
name|LITTLENUM_NUMBER_OF_BITS
operator|*
name|j
operator|)
expr_stmt|;
name|inst
operator|.
name|operands
index|[
name|i
index|]
operator|.
name|reg
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|parts
condition|;
name|j
operator|++
operator|,
name|idx
operator|++
control|)
name|inst
operator|.
name|operands
index|[
name|i
index|]
operator|.
name|reg
operator||=
name|generic_bignum
index|[
name|idx
index|]
operator|<<
operator|(
name|LITTLENUM_NUMBER_OF_BITS
operator|*
name|j
operator|)
expr_stmt|;
name|inst
operator|.
name|operands
index|[
name|i
index|]
operator|.
name|regisimm
operator|=
literal|1
expr_stmt|;
block|}
else|else
return|return
name|FAIL
return|;
operator|*
name|str
operator|=
name|ptr
expr_stmt|;
return|return
name|SUCCESS
return|;
block|}
end_function

begin_comment
comment|/* Returns the pseudo-register number of an FPA immediate constant,    or FAIL if there isn't a valid constant here.  */
end_comment

begin_function
specifier|static
name|int
name|parse_fpa_immediate
parameter_list|(
name|char
modifier|*
modifier|*
name|str
parameter_list|)
block|{
name|LITTLENUM_TYPE
name|words
index|[
name|MAX_LITTLENUMS
index|]
decl_stmt|;
name|char
modifier|*
name|save_in
decl_stmt|;
name|expressionS
name|exp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|j
decl_stmt|;
comment|/* First try and match exact strings, this is to guarantee      that some formats will work even for cross assembly.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|fp_const
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
operator|*
name|str
argument_list|,
name|fp_const
index|[
name|i
index|]
argument_list|,
name|strlen
argument_list|(
name|fp_const
index|[
name|i
index|]
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|char
modifier|*
name|start
init|=
operator|*
name|str
decl_stmt|;
operator|*
name|str
operator|+=
name|strlen
argument_list|(
name|fp_const
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_end_of_line
index|[
operator|(
name|unsigned
name|char
operator|)
operator|*
operator|*
name|str
index|]
condition|)
return|return
name|i
operator|+
literal|8
return|;
operator|*
name|str
operator|=
name|start
expr_stmt|;
block|}
block|}
comment|/* Just because we didn't get a match doesn't mean that the constant      isn't valid, just that it is in a format that we don't      automatically recognize.  Try parsing it with the standard      expression routines.  */
name|memset
argument_list|(
name|words
argument_list|,
literal|0
argument_list|,
name|MAX_LITTLENUMS
operator|*
sizeof|sizeof
argument_list|(
name|LITTLENUM_TYPE
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Look for a raw floating point number.  */
if|if
condition|(
operator|(
name|save_in
operator|=
name|atof_ieee
argument_list|(
operator|*
name|str
argument_list|,
literal|'x'
argument_list|,
name|words
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
name|is_end_of_line
index|[
operator|(
name|unsigned
name|char
operator|)
operator|*
name|save_in
index|]
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_FLOAT_VALS
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|MAX_LITTLENUMS
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|words
index|[
name|j
index|]
operator|!=
name|fp_values
index|[
name|i
index|]
index|[
name|j
index|]
condition|)
break|break;
block|}
if|if
condition|(
name|j
operator|==
name|MAX_LITTLENUMS
condition|)
block|{
operator|*
name|str
operator|=
name|save_in
expr_stmt|;
return|return
name|i
operator|+
literal|8
return|;
block|}
block|}
block|}
comment|/* Try and parse a more complex expression, this will probably fail      unless the code uses a floating point prefix (eg "0f").  */
name|save_in
operator|=
name|input_line_pointer
expr_stmt|;
name|input_line_pointer
operator|=
operator|*
name|str
expr_stmt|;
if|if
condition|(
name|expression
argument_list|(
operator|&
name|exp
argument_list|)
operator|==
name|absolute_section
operator|&&
name|exp
operator|.
name|X_op
operator|==
name|O_big
operator|&&
name|exp
operator|.
name|X_add_number
operator|<
literal|0
condition|)
block|{
comment|/* FIXME: 5 = X_PRECISION, should be #define'd where we can use it. 	 Ditto for 15.	*/
if|if
condition|(
name|gen_to_words
argument_list|(
name|words
argument_list|,
literal|5
argument_list|,
operator|(
name|long
operator|)
literal|15
argument_list|)
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_FLOAT_VALS
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|MAX_LITTLENUMS
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|words
index|[
name|j
index|]
operator|!=
name|fp_values
index|[
name|i
index|]
index|[
name|j
index|]
condition|)
break|break;
block|}
if|if
condition|(
name|j
operator|==
name|MAX_LITTLENUMS
condition|)
block|{
operator|*
name|str
operator|=
name|input_line_pointer
expr_stmt|;
name|input_line_pointer
operator|=
name|save_in
expr_stmt|;
return|return
name|i
operator|+
literal|8
return|;
block|}
block|}
block|}
block|}
operator|*
name|str
operator|=
name|input_line_pointer
expr_stmt|;
name|input_line_pointer
operator|=
name|save_in
expr_stmt|;
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"invalid FPA immediate expression"
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
block|}
end_function

begin_comment
comment|/* Returns 1 if a number has "quarter-precision" float format    0baBbbbbbc defgh000 00000000 00000000.  */
end_comment

begin_function
specifier|static
name|int
name|is_quarter_float
parameter_list|(
name|unsigned
name|imm
parameter_list|)
block|{
name|int
name|bs
init|=
operator|(
name|imm
operator|&
literal|0x20000000
operator|)
condition|?
literal|0x3e000000
else|:
literal|0x40000000
decl_stmt|;
return|return
operator|(
name|imm
operator|&
literal|0x7ffff
operator|)
operator|==
literal|0
operator|&&
operator|(
operator|(
name|imm
operator|&
literal|0x7e000000
operator|)
operator|^
name|bs
operator|)
operator|==
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Parse an 8-bit "quarter-precision" floating point number of the form:    0baBbbbbbc defgh000 00000000 00000000.    The zero and minus-zero cases need special handling, since they can't be    encoded in the "quarter-precision" float format, but can nonetheless be    loaded as integer constants.  */
end_comment

begin_function
specifier|static
name|unsigned
name|parse_qfloat_immediate
parameter_list|(
name|char
modifier|*
modifier|*
name|ccp
parameter_list|,
name|int
modifier|*
name|immed
parameter_list|)
block|{
name|char
modifier|*
name|str
init|=
operator|*
name|ccp
decl_stmt|;
name|char
modifier|*
name|fpnum
decl_stmt|;
name|LITTLENUM_TYPE
name|words
index|[
name|MAX_LITTLENUMS
index|]
decl_stmt|;
name|int
name|found_fpchar
init|=
literal|0
decl_stmt|;
name|skip_past_char
argument_list|(
operator|&
name|str
argument_list|,
literal|'#'
argument_list|)
expr_stmt|;
comment|/* We must not accidentally parse an integer as a floating-point number. Make      sure that the value we parse is not an integer by checking for special      characters '.' or 'e'.      FIXME: This is a horrible hack, but doing better is tricky because type      information isn't in a very usable state at parse time.  */
name|fpnum
operator|=
name|str
expr_stmt|;
name|skip_whitespace
argument_list|(
name|fpnum
argument_list|)
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|fpnum
argument_list|,
literal|"0x"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
return|return
name|FAIL
return|;
else|else
block|{
for|for
control|(
init|;
operator|*
name|fpnum
operator|!=
literal|'\0'
operator|&&
operator|*
name|fpnum
operator|!=
literal|' '
operator|&&
operator|*
name|fpnum
operator|!=
literal|'\n'
condition|;
name|fpnum
operator|++
control|)
if|if
condition|(
operator|*
name|fpnum
operator|==
literal|'.'
operator|||
operator|*
name|fpnum
operator|==
literal|'e'
operator|||
operator|*
name|fpnum
operator|==
literal|'E'
condition|)
block|{
name|found_fpchar
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|found_fpchar
condition|)
return|return
name|FAIL
return|;
block|}
if|if
condition|(
operator|(
name|str
operator|=
name|atof_ieee
argument_list|(
name|str
argument_list|,
literal|'s'
argument_list|,
name|words
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|unsigned
name|fpword
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Our FP word must be 32 bits (single-precision FP).  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
operator|/
name|LITTLENUM_NUMBER_OF_BITS
condition|;
name|i
operator|++
control|)
block|{
name|fpword
operator|<<=
name|LITTLENUM_NUMBER_OF_BITS
expr_stmt|;
name|fpword
operator||=
name|words
index|[
name|i
index|]
expr_stmt|;
block|}
if|if
condition|(
name|is_quarter_float
argument_list|(
name|fpword
argument_list|)
operator|||
operator|(
name|fpword
operator|&
literal|0x7fffffff
operator|)
operator|==
literal|0
condition|)
operator|*
name|immed
operator|=
name|fpword
expr_stmt|;
else|else
return|return
name|FAIL
return|;
operator|*
name|ccp
operator|=
name|str
expr_stmt|;
return|return
name|SUCCESS
return|;
block|}
return|return
name|FAIL
return|;
block|}
end_function

begin_comment
comment|/* Shift operands.  */
end_comment

begin_enum
enum|enum
name|shift_kind
block|{
name|SHIFT_LSL
block|,
name|SHIFT_LSR
block|,
name|SHIFT_ASR
block|,
name|SHIFT_ROR
block|,
name|SHIFT_RRX
block|}
enum|;
end_enum

begin_struct
struct|struct
name|asm_shift_name
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|enum
name|shift_kind
name|kind
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Third argument to parse_shift.  */
end_comment

begin_enum
enum|enum
name|parse_shift_mode
block|{
name|NO_SHIFT_RESTRICT
block|,
comment|/* Any kind of shift is accepted.  */
name|SHIFT_IMMEDIATE
block|,
comment|/* Shift operand must be an immediate.	*/
name|SHIFT_LSL_OR_ASR_IMMEDIATE
block|,
comment|/* Shift must be LSL or ASR immediate.	*/
name|SHIFT_ASR_IMMEDIATE
block|,
comment|/* Shift must be ASR immediate.	 */
name|SHIFT_LSL_IMMEDIATE
block|,
comment|/* Shift must be LSL immediate.	 */
block|}
enum|;
end_enum

begin_comment
comment|/* Parse a<shift> specifier on an ARM data processing instruction.    This has three forms:       (LSL|LSR|ASL|ASR|ROR) Rs      (LSL|LSR|ASL|ASR|ROR) #imm      RRX     Note that ASL is assimilated to LSL in the instruction encoding, and    RRX to ROR #0 (which cannot be written as such).  */
end_comment

begin_function
specifier|static
name|int
name|parse_shift
parameter_list|(
name|char
modifier|*
modifier|*
name|str
parameter_list|,
name|int
name|i
parameter_list|,
name|enum
name|parse_shift_mode
name|mode
parameter_list|)
block|{
specifier|const
name|struct
name|asm_shift_name
modifier|*
name|shift_name
decl_stmt|;
name|enum
name|shift_kind
name|shift
decl_stmt|;
name|char
modifier|*
name|s
init|=
operator|*
name|str
decl_stmt|;
name|char
modifier|*
name|p
init|=
name|s
decl_stmt|;
name|int
name|reg
decl_stmt|;
for|for
control|(
name|p
operator|=
operator|*
name|str
init|;
name|ISALPHA
argument_list|(
operator|*
name|p
argument_list|)
condition|;
name|p
operator|++
control|)
empty_stmt|;
if|if
condition|(
name|p
operator|==
operator|*
name|str
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"shift expression expected"
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
block|}
name|shift_name
operator|=
name|hash_find_n
argument_list|(
name|arm_shift_hsh
argument_list|,
operator|*
name|str
argument_list|,
name|p
operator|-
operator|*
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|shift_name
operator|==
name|NULL
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"shift expression expected"
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
block|}
name|shift
operator|=
name|shift_name
operator|->
name|kind
expr_stmt|;
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|NO_SHIFT_RESTRICT
case|:
case|case
name|SHIFT_IMMEDIATE
case|:
break|break;
case|case
name|SHIFT_LSL_OR_ASR_IMMEDIATE
case|:
if|if
condition|(
name|shift
operator|!=
name|SHIFT_LSL
operator|&&
name|shift
operator|!=
name|SHIFT_ASR
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"'LSL' or 'ASR' required"
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
block|}
break|break;
case|case
name|SHIFT_LSL_IMMEDIATE
case|:
if|if
condition|(
name|shift
operator|!=
name|SHIFT_LSL
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"'LSL' required"
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
block|}
break|break;
case|case
name|SHIFT_ASR_IMMEDIATE
case|:
if|if
condition|(
name|shift
operator|!=
name|SHIFT_ASR
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"'ASR' required"
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
block|}
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|shift
operator|!=
name|SHIFT_RRX
condition|)
block|{
comment|/* Whitespace can appear here if the next thing is a bare digit.	*/
name|skip_whitespace
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|NO_SHIFT_RESTRICT
operator|&&
operator|(
name|reg
operator|=
name|arm_reg_parse
argument_list|(
operator|&
name|p
argument_list|,
name|REG_TYPE_RN
argument_list|)
operator|)
operator|!=
name|FAIL
condition|)
block|{
name|inst
operator|.
name|operands
index|[
name|i
index|]
operator|.
name|imm
operator|=
name|reg
expr_stmt|;
name|inst
operator|.
name|operands
index|[
name|i
index|]
operator|.
name|immisreg
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|my_get_expression
argument_list|(
operator|&
name|inst
operator|.
name|reloc
operator|.
name|exp
argument_list|,
operator|&
name|p
argument_list|,
name|GE_IMM_PREFIX
argument_list|)
condition|)
return|return
name|FAIL
return|;
block|}
name|inst
operator|.
name|operands
index|[
name|i
index|]
operator|.
name|shift_kind
operator|=
name|shift
expr_stmt|;
name|inst
operator|.
name|operands
index|[
name|i
index|]
operator|.
name|shifted
operator|=
literal|1
expr_stmt|;
operator|*
name|str
operator|=
name|p
expr_stmt|;
return|return
name|SUCCESS
return|;
block|}
end_function

begin_comment
comment|/* Parse a<shifter_operand> for an ARM data processing instruction:        #<immediate>       #<immediate>,<rotate><Rm><Rm>,<shift>     where<shift> is defined by parse_shift above, and<rotate> is a    multiple of 2 between 0 and 30.  Validation of immediate operands    is deferred to md_apply_fix.  */
end_comment

begin_function
specifier|static
name|int
name|parse_shifter_operand
parameter_list|(
name|char
modifier|*
modifier|*
name|str
parameter_list|,
name|int
name|i
parameter_list|)
block|{
name|int
name|value
decl_stmt|;
name|expressionS
name|expr
decl_stmt|;
if|if
condition|(
operator|(
name|value
operator|=
name|arm_reg_parse
argument_list|(
name|str
argument_list|,
name|REG_TYPE_RN
argument_list|)
operator|)
operator|!=
name|FAIL
condition|)
block|{
name|inst
operator|.
name|operands
index|[
name|i
index|]
operator|.
name|reg
operator|=
name|value
expr_stmt|;
name|inst
operator|.
name|operands
index|[
name|i
index|]
operator|.
name|isreg
operator|=
literal|1
expr_stmt|;
comment|/* parse_shift will override this if appropriate */
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_op
operator|=
name|O_constant
expr_stmt|;
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_add_number
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|skip_past_comma
argument_list|(
name|str
argument_list|)
operator|==
name|FAIL
condition|)
return|return
name|SUCCESS
return|;
comment|/* Shift operation on register.  */
return|return
name|parse_shift
argument_list|(
name|str
argument_list|,
name|i
argument_list|,
name|NO_SHIFT_RESTRICT
argument_list|)
return|;
block|}
if|if
condition|(
name|my_get_expression
argument_list|(
operator|&
name|inst
operator|.
name|reloc
operator|.
name|exp
argument_list|,
name|str
argument_list|,
name|GE_IMM_PREFIX
argument_list|)
condition|)
return|return
name|FAIL
return|;
if|if
condition|(
name|skip_past_comma
argument_list|(
name|str
argument_list|)
operator|==
name|SUCCESS
condition|)
block|{
comment|/* #x, y -- ie explicit rotation by Y.  */
if|if
condition|(
name|my_get_expression
argument_list|(
operator|&
name|expr
argument_list|,
name|str
argument_list|,
name|GE_NO_PREFIX
argument_list|)
condition|)
return|return
name|FAIL
return|;
if|if
condition|(
name|expr
operator|.
name|X_op
operator|!=
name|O_constant
operator|||
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_op
operator|!=
name|O_constant
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"constant expression expected"
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
block|}
name|value
operator|=
name|expr
operator|.
name|X_add_number
expr_stmt|;
if|if
condition|(
name|value
operator|<
literal|0
operator|||
name|value
operator|>
literal|30
operator|||
name|value
operator|%
literal|2
operator|!=
literal|0
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"invalid rotation"
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
block|}
if|if
condition|(
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_add_number
operator|<
literal|0
operator|||
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_add_number
operator|>
literal|255
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"invalid constant"
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
block|}
comment|/* Convert to decoded value.  md_apply_fix will put it back.  */
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_add_number
operator|=
operator|(
operator|(
operator|(
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_add_number
operator|<<
operator|(
literal|32
operator|-
name|value
operator|)
operator|)
operator||
operator|(
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_add_number
operator|>>
name|value
operator|)
operator|)
operator|&
literal|0xffffffff
operator|)
expr_stmt|;
block|}
name|inst
operator|.
name|reloc
operator|.
name|type
operator|=
name|BFD_RELOC_ARM_IMMEDIATE
expr_stmt|;
name|inst
operator|.
name|reloc
operator|.
name|pc_rel
operator|=
literal|0
expr_stmt|;
return|return
name|SUCCESS
return|;
block|}
end_function

begin_comment
comment|/* Group relocation information.  Each entry in the table contains the    textual name of the relocation as may appear in assembler source    and must end with a colon.    Along with this textual name are the relocation codes to be used if    the corresponding instruction is an ALU instruction (ADD or SUB only),    an LDR, an LDRS, or an LDC.  */
end_comment

begin_struct
struct|struct
name|group_reloc_table_entry
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|alu_code
decl_stmt|;
name|int
name|ldr_code
decl_stmt|;
name|int
name|ldrs_code
decl_stmt|;
name|int
name|ldc_code
decl_stmt|;
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
enum|enum
block|{
comment|/* Varieties of non-ALU group relocation.  */
name|GROUP_LDR
block|,
name|GROUP_LDRS
block|,
name|GROUP_LDC
block|}
name|group_reloc_type
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|struct
name|group_reloc_table_entry
name|group_reloc_table
index|[]
init|=
block|{
comment|/* Program counter relative: */
block|{
literal|"pc_g0_nc"
block|,
name|BFD_RELOC_ARM_ALU_PC_G0_NC
block|,
comment|/* ALU */
literal|0
block|,
comment|/* LDR */
literal|0
block|,
comment|/* LDRS */
literal|0
block|}
block|,
comment|/* LDC */
block|{
literal|"pc_g0"
block|,
name|BFD_RELOC_ARM_ALU_PC_G0
block|,
comment|/* ALU */
name|BFD_RELOC_ARM_LDR_PC_G0
block|,
comment|/* LDR */
name|BFD_RELOC_ARM_LDRS_PC_G0
block|,
comment|/* LDRS */
name|BFD_RELOC_ARM_LDC_PC_G0
block|}
block|,
comment|/* LDC */
block|{
literal|"pc_g1_nc"
block|,
name|BFD_RELOC_ARM_ALU_PC_G1_NC
block|,
comment|/* ALU */
literal|0
block|,
comment|/* LDR */
literal|0
block|,
comment|/* LDRS */
literal|0
block|}
block|,
comment|/* LDC */
block|{
literal|"pc_g1"
block|,
name|BFD_RELOC_ARM_ALU_PC_G1
block|,
comment|/* ALU */
name|BFD_RELOC_ARM_LDR_PC_G1
block|,
comment|/* LDR */
name|BFD_RELOC_ARM_LDRS_PC_G1
block|,
comment|/* LDRS */
name|BFD_RELOC_ARM_LDC_PC_G1
block|}
block|,
comment|/* LDC */
block|{
literal|"pc_g2"
block|,
name|BFD_RELOC_ARM_ALU_PC_G2
block|,
comment|/* ALU */
name|BFD_RELOC_ARM_LDR_PC_G2
block|,
comment|/* LDR */
name|BFD_RELOC_ARM_LDRS_PC_G2
block|,
comment|/* LDRS */
name|BFD_RELOC_ARM_LDC_PC_G2
block|}
block|,
comment|/* LDC */
comment|/* Section base relative */
block|{
literal|"sb_g0_nc"
block|,
name|BFD_RELOC_ARM_ALU_SB_G0_NC
block|,
comment|/* ALU */
literal|0
block|,
comment|/* LDR */
literal|0
block|,
comment|/* LDRS */
literal|0
block|}
block|,
comment|/* LDC */
block|{
literal|"sb_g0"
block|,
name|BFD_RELOC_ARM_ALU_SB_G0
block|,
comment|/* ALU */
name|BFD_RELOC_ARM_LDR_SB_G0
block|,
comment|/* LDR */
name|BFD_RELOC_ARM_LDRS_SB_G0
block|,
comment|/* LDRS */
name|BFD_RELOC_ARM_LDC_SB_G0
block|}
block|,
comment|/* LDC */
block|{
literal|"sb_g1_nc"
block|,
name|BFD_RELOC_ARM_ALU_SB_G1_NC
block|,
comment|/* ALU */
literal|0
block|,
comment|/* LDR */
literal|0
block|,
comment|/* LDRS */
literal|0
block|}
block|,
comment|/* LDC */
block|{
literal|"sb_g1"
block|,
name|BFD_RELOC_ARM_ALU_SB_G1
block|,
comment|/* ALU */
name|BFD_RELOC_ARM_LDR_SB_G1
block|,
comment|/* LDR */
name|BFD_RELOC_ARM_LDRS_SB_G1
block|,
comment|/* LDRS */
name|BFD_RELOC_ARM_LDC_SB_G1
block|}
block|,
comment|/* LDC */
block|{
literal|"sb_g2"
block|,
name|BFD_RELOC_ARM_ALU_SB_G2
block|,
comment|/* ALU */
name|BFD_RELOC_ARM_LDR_SB_G2
block|,
comment|/* LDR */
name|BFD_RELOC_ARM_LDRS_SB_G2
block|,
comment|/* LDRS */
name|BFD_RELOC_ARM_LDC_SB_G2
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* LDC */
end_comment

begin_comment
comment|/* Given the address of a pointer pointing to the textual name of a group    relocation as may appear in assembler source, attempt to find its details    in group_reloc_table.  The pointer will be updated to the character after    the trailing colon.  On failure, FAIL will be returned; SUCCESS    otherwise.  On success, *entry will be updated to point at the relevant    group_reloc_table entry. */
end_comment

begin_function
specifier|static
name|int
name|find_group_reloc_table_entry
parameter_list|(
name|char
modifier|*
modifier|*
name|str
parameter_list|,
name|struct
name|group_reloc_table_entry
modifier|*
modifier|*
name|out
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|group_reloc_table
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|int
name|length
init|=
name|strlen
argument_list|(
name|group_reloc_table
index|[
name|i
index|]
operator|.
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|strncasecmp
argument_list|(
name|group_reloc_table
index|[
name|i
index|]
operator|.
name|name
argument_list|,
operator|*
name|str
argument_list|,
name|length
argument_list|)
operator|==
literal|0
operator|&&
operator|(
operator|*
name|str
operator|)
index|[
name|length
index|]
operator|==
literal|':'
condition|)
block|{
operator|*
name|out
operator|=
operator|&
name|group_reloc_table
index|[
name|i
index|]
expr_stmt|;
operator|*
name|str
operator|+=
operator|(
name|length
operator|+
literal|1
operator|)
expr_stmt|;
return|return
name|SUCCESS
return|;
block|}
block|}
return|return
name|FAIL
return|;
block|}
end_function

begin_comment
comment|/* Parse a<shifter_operand> for an ARM data processing instruction    (as for parse_shifter_operand) where group relocations are allowed:        #<immediate>       #<immediate>,<rotate>       #:<group_reloc>:<expression><Rm><Rm>,<shift>     where<group_reloc> is one of the strings defined in group_reloc_table.    The hashes are optional.     Everything else is as for parse_shifter_operand.  */
end_comment

begin_function
specifier|static
name|parse_operand_result
name|parse_shifter_operand_group_reloc
parameter_list|(
name|char
modifier|*
modifier|*
name|str
parameter_list|,
name|int
name|i
parameter_list|)
block|{
comment|/* Determine if we have the sequence of characters #: or just :      coming next.  If we do, then we check for a group relocation.      If we don't, punt the whole lot to parse_shifter_operand.  */
if|if
condition|(
operator|(
operator|(
operator|*
name|str
operator|)
index|[
literal|0
index|]
operator|==
literal|'#'
operator|&&
operator|(
operator|*
name|str
operator|)
index|[
literal|1
index|]
operator|==
literal|':'
operator|)
operator|||
operator|(
operator|*
name|str
operator|)
index|[
literal|0
index|]
operator|==
literal|':'
condition|)
block|{
name|struct
name|group_reloc_table_entry
modifier|*
name|entry
decl_stmt|;
if|if
condition|(
operator|(
operator|*
name|str
operator|)
index|[
literal|0
index|]
operator|==
literal|'#'
condition|)
operator|(
operator|*
name|str
operator|)
operator|+=
literal|2
expr_stmt|;
else|else
operator|(
operator|*
name|str
operator|)
operator|++
expr_stmt|;
comment|/* Try to parse a group relocation.  Anything else is an error.  */
if|if
condition|(
name|find_group_reloc_table_entry
argument_list|(
name|str
argument_list|,
operator|&
name|entry
argument_list|)
operator|==
name|FAIL
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"unknown group relocation"
argument_list|)
expr_stmt|;
return|return
name|PARSE_OPERAND_FAIL_NO_BACKTRACK
return|;
block|}
comment|/* We now have the group relocation table entry corresponding to          the name in the assembler source.  Next, we parse the expression.  */
if|if
condition|(
name|my_get_expression
argument_list|(
operator|&
name|inst
operator|.
name|reloc
operator|.
name|exp
argument_list|,
name|str
argument_list|,
name|GE_NO_PREFIX
argument_list|)
condition|)
return|return
name|PARSE_OPERAND_FAIL_NO_BACKTRACK
return|;
comment|/* Record the relocation type (always the ALU variant here).  */
name|inst
operator|.
name|reloc
operator|.
name|type
operator|=
name|entry
operator|->
name|alu_code
expr_stmt|;
name|assert
argument_list|(
name|inst
operator|.
name|reloc
operator|.
name|type
operator|!=
literal|0
argument_list|)
expr_stmt|;
return|return
name|PARSE_OPERAND_SUCCESS
return|;
block|}
else|else
return|return
name|parse_shifter_operand
argument_list|(
name|str
argument_list|,
name|i
argument_list|)
operator|==
name|SUCCESS
condition|?
name|PARSE_OPERAND_SUCCESS
else|:
name|PARSE_OPERAND_FAIL
return|;
comment|/* Never reached.  */
block|}
end_function

begin_comment
comment|/* Parse all forms of an ARM address expression.  Information is written    to inst.operands[i] and/or inst.reloc.     Preindexed addressing (.preind=1):     [Rn, #offset]       .reg=Rn .reloc.exp=offset    [Rn, +/-Rm]	       .reg=Rn .imm=Rm .immisreg=1 .negative=0/1    [Rn, +/-Rm, shift]  .reg=Rn .imm=Rm .immisreg=1 .negative=0/1 		       .shift_kind=shift .reloc.exp=shift_imm     These three may have a trailing ! which causes .writeback to be set also.     Postindexed addressing (.postind=1, .writeback=1):     [Rn], #offset       .reg=Rn .reloc.exp=offset    [Rn], +/-Rm	       .reg=Rn .imm=Rm .immisreg=1 .negative=0/1    [Rn], +/-Rm, shift  .reg=Rn .imm=Rm .immisreg=1 .negative=0/1 		       .shift_kind=shift .reloc.exp=shift_imm     Unindexed addressing (.preind=0, .postind=0):     [Rn], {option}      .reg=Rn .imm=option .immisreg=0     Other:     [Rn]{!}	       shorthand for [Rn,#0]{!}    =immediate	       .isreg=0 .reloc.exp=immediate    label	       .reg=PC .reloc.pc_rel=1 .reloc.exp=label    It is the caller's responsibility to check for addressing modes not   supported by the instruction, and to set inst.reloc.type.  */
end_comment

begin_function
specifier|static
name|parse_operand_result
name|parse_address_main
parameter_list|(
name|char
modifier|*
modifier|*
name|str
parameter_list|,
name|int
name|i
parameter_list|,
name|int
name|group_relocations
parameter_list|,
name|group_reloc_type
name|group_type
parameter_list|)
block|{
name|char
modifier|*
name|p
init|=
operator|*
name|str
decl_stmt|;
name|int
name|reg
decl_stmt|;
if|if
condition|(
name|skip_past_char
argument_list|(
operator|&
name|p
argument_list|,
literal|'['
argument_list|)
operator|==
name|FAIL
condition|)
block|{
if|if
condition|(
name|skip_past_char
argument_list|(
operator|&
name|p
argument_list|,
literal|'='
argument_list|)
operator|==
name|FAIL
condition|)
block|{
comment|/* bare address - translate to PC-relative offset */
name|inst
operator|.
name|reloc
operator|.
name|pc_rel
operator|=
literal|1
expr_stmt|;
name|inst
operator|.
name|operands
index|[
name|i
index|]
operator|.
name|reg
operator|=
name|REG_PC
expr_stmt|;
name|inst
operator|.
name|operands
index|[
name|i
index|]
operator|.
name|isreg
operator|=
literal|1
expr_stmt|;
name|inst
operator|.
name|operands
index|[
name|i
index|]
operator|.
name|preind
operator|=
literal|1
expr_stmt|;
block|}
comment|/* else a load-constant pseudo op, no special treatment needed here */
if|if
condition|(
name|my_get_expression
argument_list|(
operator|&
name|inst
operator|.
name|reloc
operator|.
name|exp
argument_list|,
operator|&
name|p
argument_list|,
name|GE_NO_PREFIX
argument_list|)
condition|)
return|return
name|PARSE_OPERAND_FAIL
return|;
operator|*
name|str
operator|=
name|p
expr_stmt|;
return|return
name|PARSE_OPERAND_SUCCESS
return|;
block|}
if|if
condition|(
operator|(
name|reg
operator|=
name|arm_reg_parse
argument_list|(
operator|&
name|p
argument_list|,
name|REG_TYPE_RN
argument_list|)
operator|)
operator|==
name|FAIL
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
name|reg_expected_msgs
index|[
name|REG_TYPE_RN
index|]
argument_list|)
expr_stmt|;
return|return
name|PARSE_OPERAND_FAIL
return|;
block|}
name|inst
operator|.
name|operands
index|[
name|i
index|]
operator|.
name|reg
operator|=
name|reg
expr_stmt|;
name|inst
operator|.
name|operands
index|[
name|i
index|]
operator|.
name|isreg
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|skip_past_comma
argument_list|(
operator|&
name|p
argument_list|)
operator|==
name|SUCCESS
condition|)
block|{
name|inst
operator|.
name|operands
index|[
name|i
index|]
operator|.
name|preind
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'+'
condition|)
name|p
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'-'
condition|)
name|p
operator|++
operator|,
name|inst
operator|.
name|operands
index|[
name|i
index|]
operator|.
name|negative
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|reg
operator|=
name|arm_reg_parse
argument_list|(
operator|&
name|p
argument_list|,
name|REG_TYPE_RN
argument_list|)
operator|)
operator|!=
name|FAIL
condition|)
block|{
name|inst
operator|.
name|operands
index|[
name|i
index|]
operator|.
name|imm
operator|=
name|reg
expr_stmt|;
name|inst
operator|.
name|operands
index|[
name|i
index|]
operator|.
name|immisreg
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|skip_past_comma
argument_list|(
operator|&
name|p
argument_list|)
operator|==
name|SUCCESS
condition|)
if|if
condition|(
name|parse_shift
argument_list|(
operator|&
name|p
argument_list|,
name|i
argument_list|,
name|SHIFT_IMMEDIATE
argument_list|)
operator|==
name|FAIL
condition|)
return|return
name|PARSE_OPERAND_FAIL
return|;
block|}
elseif|else
if|if
condition|(
name|skip_past_char
argument_list|(
operator|&
name|p
argument_list|,
literal|':'
argument_list|)
operator|==
name|SUCCESS
condition|)
block|{
comment|/* FIXME: '@' should be used here, but it's filtered out by generic              code before we get to see it here. This may be subject to              change.  */
name|expressionS
name|exp
decl_stmt|;
name|my_get_expression
argument_list|(
operator|&
name|exp
argument_list|,
operator|&
name|p
argument_list|,
name|GE_NO_PREFIX
argument_list|)
expr_stmt|;
if|if
condition|(
name|exp
operator|.
name|X_op
operator|!=
name|O_constant
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"alignment must be constant"
argument_list|)
expr_stmt|;
return|return
name|PARSE_OPERAND_FAIL
return|;
block|}
name|inst
operator|.
name|operands
index|[
name|i
index|]
operator|.
name|imm
operator|=
name|exp
operator|.
name|X_add_number
operator|<<
literal|8
expr_stmt|;
name|inst
operator|.
name|operands
index|[
name|i
index|]
operator|.
name|immisalign
operator|=
literal|1
expr_stmt|;
comment|/* Alignments are not pre-indexes.  */
name|inst
operator|.
name|operands
index|[
name|i
index|]
operator|.
name|preind
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|inst
operator|.
name|operands
index|[
name|i
index|]
operator|.
name|negative
condition|)
block|{
name|inst
operator|.
name|operands
index|[
name|i
index|]
operator|.
name|negative
operator|=
literal|0
expr_stmt|;
name|p
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|group_relocations
operator|&&
operator|(
operator|(
operator|*
name|p
operator|==
literal|'#'
operator|&&
operator|*
operator|(
name|p
operator|+
literal|1
operator|)
operator|==
literal|':'
operator|)
operator|||
operator|*
name|p
operator|==
literal|':'
operator|)
condition|)
block|{
name|struct
name|group_reloc_table_entry
modifier|*
name|entry
decl_stmt|;
comment|/* Skip over the #: or : sequence.  */
if|if
condition|(
operator|*
name|p
operator|==
literal|'#'
condition|)
name|p
operator|+=
literal|2
expr_stmt|;
else|else
name|p
operator|++
expr_stmt|;
comment|/* Try to parse a group relocation.  Anything else is an                  error.  */
if|if
condition|(
name|find_group_reloc_table_entry
argument_list|(
operator|&
name|p
argument_list|,
operator|&
name|entry
argument_list|)
operator|==
name|FAIL
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"unknown group relocation"
argument_list|)
expr_stmt|;
return|return
name|PARSE_OPERAND_FAIL_NO_BACKTRACK
return|;
block|}
comment|/* We now have the group relocation table entry corresponding to 		 the name in the assembler source.  Next, we parse the                  expression.  */
if|if
condition|(
name|my_get_expression
argument_list|(
operator|&
name|inst
operator|.
name|reloc
operator|.
name|exp
argument_list|,
operator|&
name|p
argument_list|,
name|GE_NO_PREFIX
argument_list|)
condition|)
return|return
name|PARSE_OPERAND_FAIL_NO_BACKTRACK
return|;
comment|/* Record the relocation type.  */
switch|switch
condition|(
name|group_type
condition|)
block|{
case|case
name|GROUP_LDR
case|:
name|inst
operator|.
name|reloc
operator|.
name|type
operator|=
name|entry
operator|->
name|ldr_code
expr_stmt|;
break|break;
case|case
name|GROUP_LDRS
case|:
name|inst
operator|.
name|reloc
operator|.
name|type
operator|=
name|entry
operator|->
name|ldrs_code
expr_stmt|;
break|break;
case|case
name|GROUP_LDC
case|:
name|inst
operator|.
name|reloc
operator|.
name|type
operator|=
name|entry
operator|->
name|ldc_code
expr_stmt|;
break|break;
default|default:
name|assert
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|inst
operator|.
name|reloc
operator|.
name|type
operator|==
literal|0
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"this group relocation is not allowed on this instruction"
argument_list|)
expr_stmt|;
return|return
name|PARSE_OPERAND_FAIL_NO_BACKTRACK
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|my_get_expression
argument_list|(
operator|&
name|inst
operator|.
name|reloc
operator|.
name|exp
argument_list|,
operator|&
name|p
argument_list|,
name|GE_IMM_PREFIX
argument_list|)
condition|)
return|return
name|PARSE_OPERAND_FAIL
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|skip_past_char
argument_list|(
operator|&
name|p
argument_list|,
literal|':'
argument_list|)
operator|==
name|SUCCESS
condition|)
block|{
comment|/* FIXME: '@' should be used here, but it's filtered out by generic          code before we get to see it here. This may be subject to          change.  */
name|expressionS
name|exp
decl_stmt|;
name|my_get_expression
argument_list|(
operator|&
name|exp
argument_list|,
operator|&
name|p
argument_list|,
name|GE_NO_PREFIX
argument_list|)
expr_stmt|;
if|if
condition|(
name|exp
operator|.
name|X_op
operator|!=
name|O_constant
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"alignment must be constant"
argument_list|)
expr_stmt|;
return|return
name|PARSE_OPERAND_FAIL
return|;
block|}
name|inst
operator|.
name|operands
index|[
name|i
index|]
operator|.
name|imm
operator|=
name|exp
operator|.
name|X_add_number
operator|<<
literal|8
expr_stmt|;
name|inst
operator|.
name|operands
index|[
name|i
index|]
operator|.
name|immisalign
operator|=
literal|1
expr_stmt|;
comment|/* Alignments are not pre-indexes.  */
name|inst
operator|.
name|operands
index|[
name|i
index|]
operator|.
name|preind
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|skip_past_char
argument_list|(
operator|&
name|p
argument_list|,
literal|']'
argument_list|)
operator|==
name|FAIL
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"']' expected"
argument_list|)
expr_stmt|;
return|return
name|PARSE_OPERAND_FAIL
return|;
block|}
if|if
condition|(
name|skip_past_char
argument_list|(
operator|&
name|p
argument_list|,
literal|'!'
argument_list|)
operator|==
name|SUCCESS
condition|)
name|inst
operator|.
name|operands
index|[
name|i
index|]
operator|.
name|writeback
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|skip_past_comma
argument_list|(
operator|&
name|p
argument_list|)
operator|==
name|SUCCESS
condition|)
block|{
if|if
condition|(
name|skip_past_char
argument_list|(
operator|&
name|p
argument_list|,
literal|'{'
argument_list|)
operator|==
name|SUCCESS
condition|)
block|{
comment|/* [Rn], {expr} - unindexed, with option */
if|if
condition|(
name|parse_immediate
argument_list|(
operator|&
name|p
argument_list|,
operator|&
name|inst
operator|.
name|operands
index|[
name|i
index|]
operator|.
name|imm
argument_list|,
literal|0
argument_list|,
literal|255
argument_list|,
name|TRUE
argument_list|)
operator|==
name|FAIL
condition|)
return|return
name|PARSE_OPERAND_FAIL
return|;
if|if
condition|(
name|skip_past_char
argument_list|(
operator|&
name|p
argument_list|,
literal|'}'
argument_list|)
operator|==
name|FAIL
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"'}' expected at end of 'option' field"
argument_list|)
expr_stmt|;
return|return
name|PARSE_OPERAND_FAIL
return|;
block|}
if|if
condition|(
name|inst
operator|.
name|operands
index|[
name|i
index|]
operator|.
name|preind
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"cannot combine index with option"
argument_list|)
expr_stmt|;
return|return
name|PARSE_OPERAND_FAIL
return|;
block|}
operator|*
name|str
operator|=
name|p
expr_stmt|;
return|return
name|PARSE_OPERAND_SUCCESS
return|;
block|}
else|else
block|{
name|inst
operator|.
name|operands
index|[
name|i
index|]
operator|.
name|postind
operator|=
literal|1
expr_stmt|;
name|inst
operator|.
name|operands
index|[
name|i
index|]
operator|.
name|writeback
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|inst
operator|.
name|operands
index|[
name|i
index|]
operator|.
name|preind
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"cannot combine pre- and post-indexing"
argument_list|)
expr_stmt|;
return|return
name|PARSE_OPERAND_FAIL
return|;
block|}
if|if
condition|(
operator|*
name|p
operator|==
literal|'+'
condition|)
name|p
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'-'
condition|)
name|p
operator|++
operator|,
name|inst
operator|.
name|operands
index|[
name|i
index|]
operator|.
name|negative
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|reg
operator|=
name|arm_reg_parse
argument_list|(
operator|&
name|p
argument_list|,
name|REG_TYPE_RN
argument_list|)
operator|)
operator|!=
name|FAIL
condition|)
block|{
comment|/* We might be using the immediate for alignment already. If we                  are, OR the register number into the low-order bits.  */
if|if
condition|(
name|inst
operator|.
name|operands
index|[
name|i
index|]
operator|.
name|immisalign
condition|)
name|inst
operator|.
name|operands
index|[
name|i
index|]
operator|.
name|imm
operator||=
name|reg
expr_stmt|;
else|else
name|inst
operator|.
name|operands
index|[
name|i
index|]
operator|.
name|imm
operator|=
name|reg
expr_stmt|;
name|inst
operator|.
name|operands
index|[
name|i
index|]
operator|.
name|immisreg
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|skip_past_comma
argument_list|(
operator|&
name|p
argument_list|)
operator|==
name|SUCCESS
condition|)
if|if
condition|(
name|parse_shift
argument_list|(
operator|&
name|p
argument_list|,
name|i
argument_list|,
name|SHIFT_IMMEDIATE
argument_list|)
operator|==
name|FAIL
condition|)
return|return
name|PARSE_OPERAND_FAIL
return|;
block|}
else|else
block|{
if|if
condition|(
name|inst
operator|.
name|operands
index|[
name|i
index|]
operator|.
name|negative
condition|)
block|{
name|inst
operator|.
name|operands
index|[
name|i
index|]
operator|.
name|negative
operator|=
literal|0
expr_stmt|;
name|p
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|my_get_expression
argument_list|(
operator|&
name|inst
operator|.
name|reloc
operator|.
name|exp
argument_list|,
operator|&
name|p
argument_list|,
name|GE_IMM_PREFIX
argument_list|)
condition|)
return|return
name|PARSE_OPERAND_FAIL
return|;
block|}
block|}
block|}
comment|/* If at this point neither .preind nor .postind is set, we have a      bare [Rn]{!}, which is shorthand for [Rn,#0]{!}.  */
if|if
condition|(
name|inst
operator|.
name|operands
index|[
name|i
index|]
operator|.
name|preind
operator|==
literal|0
operator|&&
name|inst
operator|.
name|operands
index|[
name|i
index|]
operator|.
name|postind
operator|==
literal|0
condition|)
block|{
name|inst
operator|.
name|operands
index|[
name|i
index|]
operator|.
name|preind
operator|=
literal|1
expr_stmt|;
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_op
operator|=
name|O_constant
expr_stmt|;
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_add_number
operator|=
literal|0
expr_stmt|;
block|}
operator|*
name|str
operator|=
name|p
expr_stmt|;
return|return
name|PARSE_OPERAND_SUCCESS
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|parse_address
parameter_list|(
name|char
modifier|*
modifier|*
name|str
parameter_list|,
name|int
name|i
parameter_list|)
block|{
return|return
name|parse_address_main
argument_list|(
name|str
argument_list|,
name|i
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|==
name|PARSE_OPERAND_SUCCESS
condition|?
name|SUCCESS
else|:
name|FAIL
return|;
block|}
end_function

begin_function
specifier|static
name|parse_operand_result
name|parse_address_group_reloc
parameter_list|(
name|char
modifier|*
modifier|*
name|str
parameter_list|,
name|int
name|i
parameter_list|,
name|group_reloc_type
name|type
parameter_list|)
block|{
return|return
name|parse_address_main
argument_list|(
name|str
argument_list|,
name|i
argument_list|,
literal|1
argument_list|,
name|type
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Parse an operand for a MOVW or MOVT instruction.  */
end_comment

begin_function
specifier|static
name|int
name|parse_half
parameter_list|(
name|char
modifier|*
modifier|*
name|str
parameter_list|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|p
operator|=
operator|*
name|str
expr_stmt|;
name|skip_past_char
argument_list|(
operator|&
name|p
argument_list|,
literal|'#'
argument_list|)
expr_stmt|;
if|if
condition|(
name|strncasecmp
argument_list|(
name|p
argument_list|,
literal|":lower16:"
argument_list|,
literal|9
argument_list|)
operator|==
literal|0
condition|)
name|inst
operator|.
name|reloc
operator|.
name|type
operator|=
name|BFD_RELOC_ARM_MOVW
expr_stmt|;
elseif|else
if|if
condition|(
name|strncasecmp
argument_list|(
name|p
argument_list|,
literal|":upper16:"
argument_list|,
literal|9
argument_list|)
operator|==
literal|0
condition|)
name|inst
operator|.
name|reloc
operator|.
name|type
operator|=
name|BFD_RELOC_ARM_MOVT
expr_stmt|;
if|if
condition|(
name|inst
operator|.
name|reloc
operator|.
name|type
operator|!=
name|BFD_RELOC_UNUSED
condition|)
block|{
name|p
operator|+=
literal|9
expr_stmt|;
name|skip_whitespace
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|my_get_expression
argument_list|(
operator|&
name|inst
operator|.
name|reloc
operator|.
name|exp
argument_list|,
operator|&
name|p
argument_list|,
name|GE_NO_PREFIX
argument_list|)
condition|)
return|return
name|FAIL
return|;
if|if
condition|(
name|inst
operator|.
name|reloc
operator|.
name|type
operator|==
name|BFD_RELOC_UNUSED
condition|)
block|{
if|if
condition|(
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_op
operator|!=
name|O_constant
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"constant expression expected"
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
block|}
if|if
condition|(
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_add_number
operator|<
literal|0
operator|||
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_add_number
operator|>
literal|0xffff
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"immediate value out of range"
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
block|}
block|}
operator|*
name|str
operator|=
name|p
expr_stmt|;
return|return
name|SUCCESS
return|;
block|}
end_function

begin_comment
comment|/* Miscellaneous. */
end_comment

begin_comment
comment|/* Parse a PSR flag operand.  The value returned is FAIL on syntax error,    or a bitmask suitable to be or-ed into the ARM msr instruction.  */
end_comment

begin_function
specifier|static
name|int
name|parse_psr
parameter_list|(
name|char
modifier|*
modifier|*
name|str
parameter_list|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|unsigned
name|long
name|psr_field
decl_stmt|;
specifier|const
name|struct
name|asm_psr
modifier|*
name|psr
decl_stmt|;
name|char
modifier|*
name|start
decl_stmt|;
comment|/* CPSR's and SPSR's can now be lowercase.  This is just a convenience      feature for ease of use and backwards compatibility.  */
name|p
operator|=
operator|*
name|str
expr_stmt|;
if|if
condition|(
name|strncasecmp
argument_list|(
name|p
argument_list|,
literal|"SPSR"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
name|psr_field
operator|=
name|SPSR_BIT
expr_stmt|;
elseif|else
if|if
condition|(
name|strncasecmp
argument_list|(
name|p
argument_list|,
literal|"CPSR"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
name|psr_field
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|start
operator|=
name|p
expr_stmt|;
do|do
name|p
operator|++
expr_stmt|;
do|while
condition|(
name|ISALNUM
argument_list|(
operator|*
name|p
argument_list|)
operator|||
operator|*
name|p
operator|==
literal|'_'
condition|)
do|;
name|psr
operator|=
name|hash_find_n
argument_list|(
name|arm_v7m_psr_hsh
argument_list|,
name|start
argument_list|,
name|p
operator|-
name|start
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|psr
condition|)
return|return
name|FAIL
return|;
operator|*
name|str
operator|=
name|p
expr_stmt|;
return|return
name|psr
operator|->
name|field
return|;
block|}
name|p
operator|+=
literal|4
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'_'
condition|)
block|{
comment|/* A suffix follows.  */
name|p
operator|++
expr_stmt|;
name|start
operator|=
name|p
expr_stmt|;
do|do
name|p
operator|++
expr_stmt|;
do|while
condition|(
name|ISALNUM
argument_list|(
operator|*
name|p
argument_list|)
operator|||
operator|*
name|p
operator|==
literal|'_'
condition|)
do|;
name|psr
operator|=
name|hash_find_n
argument_list|(
name|arm_psr_hsh
argument_list|,
name|start
argument_list|,
name|p
operator|-
name|start
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|psr
condition|)
goto|goto
name|error
goto|;
name|psr_field
operator||=
name|psr
operator|->
name|field
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ISALNUM
argument_list|(
operator|*
name|p
argument_list|)
condition|)
goto|goto
name|error
goto|;
comment|/* Garbage after "[CS]PSR".  */
name|psr_field
operator||=
operator|(
name|PSR_c
operator||
name|PSR_f
operator|)
expr_stmt|;
block|}
operator|*
name|str
operator|=
name|p
expr_stmt|;
return|return
name|psr_field
return|;
name|error
label|:
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"flag for {c}psr instruction expected"
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
block|}
end_function

begin_comment
comment|/* Parse the flags argument to CPSI[ED].  Returns FAIL on error, or a    value suitable for splatting into the AIF field of the instruction.	*/
end_comment

begin_function
specifier|static
name|int
name|parse_cps_flags
parameter_list|(
name|char
modifier|*
modifier|*
name|str
parameter_list|)
block|{
name|int
name|val
init|=
literal|0
decl_stmt|;
name|int
name|saw_a_flag
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|s
init|=
operator|*
name|str
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
switch|switch
condition|(
operator|*
name|s
operator|++
condition|)
block|{
case|case
literal|'\0'
case|:
case|case
literal|','
case|:
goto|goto
name|done
goto|;
case|case
literal|'a'
case|:
case|case
literal|'A'
case|:
name|saw_a_flag
operator|=
literal|1
expr_stmt|;
name|val
operator||=
literal|0x4
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
case|case
literal|'I'
case|:
name|saw_a_flag
operator|=
literal|1
expr_stmt|;
name|val
operator||=
literal|0x2
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
case|case
literal|'F'
case|:
name|saw_a_flag
operator|=
literal|1
expr_stmt|;
name|val
operator||=
literal|0x1
expr_stmt|;
break|break;
default|default:
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"unrecognized CPS flag"
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
block|}
name|done
label|:
if|if
condition|(
name|saw_a_flag
operator|==
literal|0
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"missing CPS flags"
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
block|}
operator|*
name|str
operator|=
name|s
operator|-
literal|1
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_comment
comment|/* Parse an endian specifier ("BE" or "LE", case insensitive);    returns 0 for big-endian, 1 for little-endian, FAIL for an error.  */
end_comment

begin_function
specifier|static
name|int
name|parse_endian_specifier
parameter_list|(
name|char
modifier|*
modifier|*
name|str
parameter_list|)
block|{
name|int
name|little_endian
decl_stmt|;
name|char
modifier|*
name|s
init|=
operator|*
name|str
decl_stmt|;
if|if
condition|(
name|strncasecmp
argument_list|(
name|s
argument_list|,
literal|"BE"
argument_list|,
literal|2
argument_list|)
condition|)
name|little_endian
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|strncasecmp
argument_list|(
name|s
argument_list|,
literal|"LE"
argument_list|,
literal|2
argument_list|)
condition|)
name|little_endian
operator|=
literal|1
expr_stmt|;
else|else
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"valid endian specifiers are be or le"
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
block|}
if|if
condition|(
name|ISALNUM
argument_list|(
name|s
index|[
literal|2
index|]
argument_list|)
operator|||
name|s
index|[
literal|2
index|]
operator|==
literal|'_'
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"valid endian specifiers are be or le"
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
block|}
operator|*
name|str
operator|=
name|s
operator|+
literal|2
expr_stmt|;
return|return
name|little_endian
return|;
block|}
end_function

begin_comment
comment|/* Parse a rotation specifier: ROR #0, #8, #16, #24.  *val receives a    value suitable for poking into the rotate field of an sxt or sxta    instruction, or FAIL on error.  */
end_comment

begin_function
specifier|static
name|int
name|parse_ror
parameter_list|(
name|char
modifier|*
modifier|*
name|str
parameter_list|)
block|{
name|int
name|rot
decl_stmt|;
name|char
modifier|*
name|s
init|=
operator|*
name|str
decl_stmt|;
if|if
condition|(
name|strncasecmp
argument_list|(
name|s
argument_list|,
literal|"ROR"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
name|s
operator|+=
literal|3
expr_stmt|;
else|else
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"missing rotation field after comma"
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
block|}
if|if
condition|(
name|parse_immediate
argument_list|(
operator|&
name|s
argument_list|,
operator|&
name|rot
argument_list|,
literal|0
argument_list|,
literal|24
argument_list|,
name|FALSE
argument_list|)
operator|==
name|FAIL
condition|)
return|return
name|FAIL
return|;
switch|switch
condition|(
name|rot
condition|)
block|{
case|case
literal|0
case|:
operator|*
name|str
operator|=
name|s
expr_stmt|;
return|return
literal|0x0
return|;
case|case
literal|8
case|:
operator|*
name|str
operator|=
name|s
expr_stmt|;
return|return
literal|0x1
return|;
case|case
literal|16
case|:
operator|*
name|str
operator|=
name|s
expr_stmt|;
return|return
literal|0x2
return|;
case|case
literal|24
case|:
operator|*
name|str
operator|=
name|s
expr_stmt|;
return|return
literal|0x3
return|;
default|default:
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"rotation can only be 0, 8, 16, or 24"
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
block|}
block|}
end_function

begin_comment
comment|/* Parse a conditional code (from conds[] below).  The value returned is in the    range 0 .. 14, or FAIL.  */
end_comment

begin_function
specifier|static
name|int
name|parse_cond
parameter_list|(
name|char
modifier|*
modifier|*
name|str
parameter_list|)
block|{
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
specifier|const
name|struct
name|asm_cond
modifier|*
name|c
decl_stmt|;
name|p
operator|=
name|q
operator|=
operator|*
name|str
expr_stmt|;
while|while
condition|(
name|ISALPHA
argument_list|(
operator|*
name|q
argument_list|)
condition|)
name|q
operator|++
expr_stmt|;
name|c
operator|=
name|hash_find_n
argument_list|(
name|arm_cond_hsh
argument_list|,
name|p
argument_list|,
name|q
operator|-
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|c
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"condition required"
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
block|}
operator|*
name|str
operator|=
name|q
expr_stmt|;
return|return
name|c
operator|->
name|value
return|;
block|}
end_function

begin_comment
comment|/* Parse an option for a barrier instruction.  Returns the encoding for the    option, or FAIL.  */
end_comment

begin_function
specifier|static
name|int
name|parse_barrier
parameter_list|(
name|char
modifier|*
modifier|*
name|str
parameter_list|)
block|{
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
specifier|const
name|struct
name|asm_barrier_opt
modifier|*
name|o
decl_stmt|;
name|p
operator|=
name|q
operator|=
operator|*
name|str
expr_stmt|;
while|while
condition|(
name|ISALPHA
argument_list|(
operator|*
name|q
argument_list|)
condition|)
name|q
operator|++
expr_stmt|;
name|o
operator|=
name|hash_find_n
argument_list|(
name|arm_barrier_opt_hsh
argument_list|,
name|p
argument_list|,
name|q
operator|-
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|o
condition|)
return|return
name|FAIL
return|;
operator|*
name|str
operator|=
name|q
expr_stmt|;
return|return
name|o
operator|->
name|value
return|;
block|}
end_function

begin_comment
comment|/* Parse the operands of a table branch instruction.  Similar to a memory    operand.  */
end_comment

begin_function
specifier|static
name|int
name|parse_tb
parameter_list|(
name|char
modifier|*
modifier|*
name|str
parameter_list|)
block|{
name|char
modifier|*
name|p
init|=
operator|*
name|str
decl_stmt|;
name|int
name|reg
decl_stmt|;
if|if
condition|(
name|skip_past_char
argument_list|(
operator|&
name|p
argument_list|,
literal|'['
argument_list|)
operator|==
name|FAIL
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"'[' expected"
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
block|}
if|if
condition|(
operator|(
name|reg
operator|=
name|arm_reg_parse
argument_list|(
operator|&
name|p
argument_list|,
name|REG_TYPE_RN
argument_list|)
operator|)
operator|==
name|FAIL
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
name|reg_expected_msgs
index|[
name|REG_TYPE_RN
index|]
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
block|}
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
operator|=
name|reg
expr_stmt|;
if|if
condition|(
name|skip_past_comma
argument_list|(
operator|&
name|p
argument_list|)
operator|==
name|FAIL
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"',' expected"
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
block|}
if|if
condition|(
operator|(
name|reg
operator|=
name|arm_reg_parse
argument_list|(
operator|&
name|p
argument_list|,
name|REG_TYPE_RN
argument_list|)
operator|)
operator|==
name|FAIL
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
name|reg_expected_msgs
index|[
name|REG_TYPE_RN
index|]
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
block|}
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|imm
operator|=
name|reg
expr_stmt|;
if|if
condition|(
name|skip_past_comma
argument_list|(
operator|&
name|p
argument_list|)
operator|==
name|SUCCESS
condition|)
block|{
if|if
condition|(
name|parse_shift
argument_list|(
operator|&
name|p
argument_list|,
literal|0
argument_list|,
name|SHIFT_LSL_IMMEDIATE
argument_list|)
operator|==
name|FAIL
condition|)
return|return
name|FAIL
return|;
if|if
condition|(
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_add_number
operator|!=
literal|1
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"invalid shift"
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
block|}
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|shifted
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|skip_past_char
argument_list|(
operator|&
name|p
argument_list|,
literal|']'
argument_list|)
operator|==
name|FAIL
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"']' expected"
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
block|}
operator|*
name|str
operator|=
name|p
expr_stmt|;
return|return
name|SUCCESS
return|;
block|}
end_function

begin_comment
comment|/* Parse the operands of a Neon VMOV instruction. See do_neon_mov for more    information on the types the operands can take and how they are encoded.    Up to four operands may be read; this function handles setting the    ".present" field for each read operand itself.    Updates STR and WHICH_OPERAND if parsing is successful and returns SUCCESS,    else returns FAIL.  */
end_comment

begin_function
specifier|static
name|int
name|parse_neon_mov
parameter_list|(
name|char
modifier|*
modifier|*
name|str
parameter_list|,
name|int
modifier|*
name|which_operand
parameter_list|)
block|{
name|int
name|i
init|=
operator|*
name|which_operand
decl_stmt|,
name|val
decl_stmt|;
name|enum
name|arm_reg_type
name|rtype
decl_stmt|;
name|char
modifier|*
name|ptr
init|=
operator|*
name|str
decl_stmt|;
name|struct
name|neon_type_el
name|optype
decl_stmt|;
if|if
condition|(
operator|(
name|val
operator|=
name|parse_scalar
argument_list|(
operator|&
name|ptr
argument_list|,
literal|8
argument_list|,
operator|&
name|optype
argument_list|)
operator|)
operator|!=
name|FAIL
condition|)
block|{
comment|/* Case 4: VMOV<c><q>.<size><Dn[x]>,<Rd>.  */
name|inst
operator|.
name|operands
index|[
name|i
index|]
operator|.
name|reg
operator|=
name|val
expr_stmt|;
name|inst
operator|.
name|operands
index|[
name|i
index|]
operator|.
name|isscalar
operator|=
literal|1
expr_stmt|;
name|inst
operator|.
name|operands
index|[
name|i
index|]
operator|.
name|vectype
operator|=
name|optype
expr_stmt|;
name|inst
operator|.
name|operands
index|[
name|i
operator|++
index|]
operator|.
name|present
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|skip_past_comma
argument_list|(
operator|&
name|ptr
argument_list|)
operator|==
name|FAIL
condition|)
goto|goto
name|wanted_comma
goto|;
if|if
condition|(
operator|(
name|val
operator|=
name|arm_reg_parse
argument_list|(
operator|&
name|ptr
argument_list|,
name|REG_TYPE_RN
argument_list|)
operator|)
operator|==
name|FAIL
condition|)
goto|goto
name|wanted_arm
goto|;
name|inst
operator|.
name|operands
index|[
name|i
index|]
operator|.
name|reg
operator|=
name|val
expr_stmt|;
name|inst
operator|.
name|operands
index|[
name|i
index|]
operator|.
name|isreg
operator|=
literal|1
expr_stmt|;
name|inst
operator|.
name|operands
index|[
name|i
index|]
operator|.
name|present
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|val
operator|=
name|arm_typed_reg_parse
argument_list|(
operator|&
name|ptr
argument_list|,
name|REG_TYPE_NSDQ
argument_list|,
operator|&
name|rtype
argument_list|,
operator|&
name|optype
argument_list|)
operator|)
operator|!=
name|FAIL
condition|)
block|{
comment|/* Cases 0, 1, 2, 3, 5 (D only).  */
if|if
condition|(
name|skip_past_comma
argument_list|(
operator|&
name|ptr
argument_list|)
operator|==
name|FAIL
condition|)
goto|goto
name|wanted_comma
goto|;
name|inst
operator|.
name|operands
index|[
name|i
index|]
operator|.
name|reg
operator|=
name|val
expr_stmt|;
name|inst
operator|.
name|operands
index|[
name|i
index|]
operator|.
name|isreg
operator|=
literal|1
expr_stmt|;
name|inst
operator|.
name|operands
index|[
name|i
index|]
operator|.
name|isquad
operator|=
operator|(
name|rtype
operator|==
name|REG_TYPE_NQ
operator|)
expr_stmt|;
name|inst
operator|.
name|operands
index|[
name|i
index|]
operator|.
name|issingle
operator|=
operator|(
name|rtype
operator|==
name|REG_TYPE_VFS
operator|)
expr_stmt|;
name|inst
operator|.
name|operands
index|[
name|i
index|]
operator|.
name|isvec
operator|=
literal|1
expr_stmt|;
name|inst
operator|.
name|operands
index|[
name|i
index|]
operator|.
name|vectype
operator|=
name|optype
expr_stmt|;
name|inst
operator|.
name|operands
index|[
name|i
operator|++
index|]
operator|.
name|present
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|val
operator|=
name|arm_reg_parse
argument_list|(
operator|&
name|ptr
argument_list|,
name|REG_TYPE_RN
argument_list|)
operator|)
operator|!=
name|FAIL
condition|)
block|{
comment|/* Case 5: VMOV<c><q><Dm>,<Rd>,<Rn>.              Case 13: VMOV<Sd>,<Rm>  */
name|inst
operator|.
name|operands
index|[
name|i
index|]
operator|.
name|reg
operator|=
name|val
expr_stmt|;
name|inst
operator|.
name|operands
index|[
name|i
index|]
operator|.
name|isreg
operator|=
literal|1
expr_stmt|;
name|inst
operator|.
name|operands
index|[
name|i
index|]
operator|.
name|present
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|rtype
operator|==
name|REG_TYPE_NQ
condition|)
block|{
name|first_error
argument_list|(
name|_
argument_list|(
literal|"can't use Neon quad register here"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
block|}
elseif|else
if|if
condition|(
name|rtype
operator|!=
name|REG_TYPE_VFS
condition|)
block|{
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|skip_past_comma
argument_list|(
operator|&
name|ptr
argument_list|)
operator|==
name|FAIL
condition|)
goto|goto
name|wanted_comma
goto|;
if|if
condition|(
operator|(
name|val
operator|=
name|arm_reg_parse
argument_list|(
operator|&
name|ptr
argument_list|,
name|REG_TYPE_RN
argument_list|)
operator|)
operator|==
name|FAIL
condition|)
goto|goto
name|wanted_arm
goto|;
name|inst
operator|.
name|operands
index|[
name|i
index|]
operator|.
name|reg
operator|=
name|val
expr_stmt|;
name|inst
operator|.
name|operands
index|[
name|i
index|]
operator|.
name|isreg
operator|=
literal|1
expr_stmt|;
name|inst
operator|.
name|operands
index|[
name|i
index|]
operator|.
name|present
operator|=
literal|1
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|val
operator|=
name|arm_typed_reg_parse
argument_list|(
operator|&
name|ptr
argument_list|,
name|REG_TYPE_NSDQ
argument_list|,
operator|&
name|rtype
argument_list|,
operator|&
name|optype
argument_list|)
operator|)
operator|!=
name|FAIL
condition|)
block|{
comment|/* Case 0: VMOV<c><q><Qd>,<Qm>              Case 1: VMOV<c><q><Dd>,<Dm>              Case 8: VMOV.F32<Sd>,<Sm>              Case 15: VMOV<Sd>,<Se>,<Rn>,<Rm>  */
name|inst
operator|.
name|operands
index|[
name|i
index|]
operator|.
name|reg
operator|=
name|val
expr_stmt|;
name|inst
operator|.
name|operands
index|[
name|i
index|]
operator|.
name|isreg
operator|=
literal|1
expr_stmt|;
name|inst
operator|.
name|operands
index|[
name|i
index|]
operator|.
name|isquad
operator|=
operator|(
name|rtype
operator|==
name|REG_TYPE_NQ
operator|)
expr_stmt|;
name|inst
operator|.
name|operands
index|[
name|i
index|]
operator|.
name|issingle
operator|=
operator|(
name|rtype
operator|==
name|REG_TYPE_VFS
operator|)
expr_stmt|;
name|inst
operator|.
name|operands
index|[
name|i
index|]
operator|.
name|isvec
operator|=
literal|1
expr_stmt|;
name|inst
operator|.
name|operands
index|[
name|i
index|]
operator|.
name|vectype
operator|=
name|optype
expr_stmt|;
name|inst
operator|.
name|operands
index|[
name|i
index|]
operator|.
name|present
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|skip_past_comma
argument_list|(
operator|&
name|ptr
argument_list|)
operator|==
name|SUCCESS
condition|)
block|{
comment|/* Case 15.  */
name|i
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|val
operator|=
name|arm_reg_parse
argument_list|(
operator|&
name|ptr
argument_list|,
name|REG_TYPE_RN
argument_list|)
operator|)
operator|==
name|FAIL
condition|)
goto|goto
name|wanted_arm
goto|;
name|inst
operator|.
name|operands
index|[
name|i
index|]
operator|.
name|reg
operator|=
name|val
expr_stmt|;
name|inst
operator|.
name|operands
index|[
name|i
index|]
operator|.
name|isreg
operator|=
literal|1
expr_stmt|;
name|inst
operator|.
name|operands
index|[
name|i
operator|++
index|]
operator|.
name|present
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|skip_past_comma
argument_list|(
operator|&
name|ptr
argument_list|)
operator|==
name|FAIL
condition|)
goto|goto
name|wanted_comma
goto|;
if|if
condition|(
operator|(
name|val
operator|=
name|arm_reg_parse
argument_list|(
operator|&
name|ptr
argument_list|,
name|REG_TYPE_RN
argument_list|)
operator|)
operator|==
name|FAIL
condition|)
goto|goto
name|wanted_arm
goto|;
name|inst
operator|.
name|operands
index|[
name|i
index|]
operator|.
name|reg
operator|=
name|val
expr_stmt|;
name|inst
operator|.
name|operands
index|[
name|i
index|]
operator|.
name|isreg
operator|=
literal|1
expr_stmt|;
name|inst
operator|.
name|operands
index|[
name|i
index|]
operator|.
name|present
operator|=
literal|1
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|parse_qfloat_immediate
argument_list|(
operator|&
name|ptr
argument_list|,
operator|&
name|inst
operator|.
name|operands
index|[
name|i
index|]
operator|.
name|imm
argument_list|)
operator|==
name|SUCCESS
condition|)
comment|/* Case 2: VMOV<c><q>.<dt><Qd>, #<float-imm>              Case 3: VMOV<c><q>.<dt><Dd>, #<float-imm>              Case 10: VMOV.F32<Sd>, #<imm>              Case 11: VMOV.F64<Dd>, #<imm>  */
name|inst
operator|.
name|operands
index|[
name|i
index|]
operator|.
name|immisfloat
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|parse_big_immediate
argument_list|(
operator|&
name|ptr
argument_list|,
name|i
argument_list|)
operator|==
name|SUCCESS
condition|)
comment|/* Case 2: VMOV<c><q>.<dt><Qd>, #<imm>              Case 3: VMOV<c><q>.<dt><Dd>, #<imm>  */
empty_stmt|;
else|else
block|{
name|first_error
argument_list|(
name|_
argument_list|(
literal|"expected<Rm> or<Dm> or<Qm> operand"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|val
operator|=
name|arm_reg_parse
argument_list|(
operator|&
name|ptr
argument_list|,
name|REG_TYPE_RN
argument_list|)
operator|)
operator|!=
name|FAIL
condition|)
block|{
comment|/* Cases 6, 7.  */
name|inst
operator|.
name|operands
index|[
name|i
index|]
operator|.
name|reg
operator|=
name|val
expr_stmt|;
name|inst
operator|.
name|operands
index|[
name|i
index|]
operator|.
name|isreg
operator|=
literal|1
expr_stmt|;
name|inst
operator|.
name|operands
index|[
name|i
operator|++
index|]
operator|.
name|present
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|skip_past_comma
argument_list|(
operator|&
name|ptr
argument_list|)
operator|==
name|FAIL
condition|)
goto|goto
name|wanted_comma
goto|;
if|if
condition|(
operator|(
name|val
operator|=
name|parse_scalar
argument_list|(
operator|&
name|ptr
argument_list|,
literal|8
argument_list|,
operator|&
name|optype
argument_list|)
operator|)
operator|!=
name|FAIL
condition|)
block|{
comment|/* Case 6: VMOV<c><q>.<dt><Rd>,<Dn[x]>  */
name|inst
operator|.
name|operands
index|[
name|i
index|]
operator|.
name|reg
operator|=
name|val
expr_stmt|;
name|inst
operator|.
name|operands
index|[
name|i
index|]
operator|.
name|isscalar
operator|=
literal|1
expr_stmt|;
name|inst
operator|.
name|operands
index|[
name|i
index|]
operator|.
name|present
operator|=
literal|1
expr_stmt|;
name|inst
operator|.
name|operands
index|[
name|i
index|]
operator|.
name|vectype
operator|=
name|optype
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|val
operator|=
name|arm_reg_parse
argument_list|(
operator|&
name|ptr
argument_list|,
name|REG_TYPE_RN
argument_list|)
operator|)
operator|!=
name|FAIL
condition|)
block|{
comment|/* Case 7: VMOV<c><q><Rd>,<Rn>,<Dm>  */
name|inst
operator|.
name|operands
index|[
name|i
index|]
operator|.
name|reg
operator|=
name|val
expr_stmt|;
name|inst
operator|.
name|operands
index|[
name|i
index|]
operator|.
name|isreg
operator|=
literal|1
expr_stmt|;
name|inst
operator|.
name|operands
index|[
name|i
operator|++
index|]
operator|.
name|present
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|skip_past_comma
argument_list|(
operator|&
name|ptr
argument_list|)
operator|==
name|FAIL
condition|)
goto|goto
name|wanted_comma
goto|;
if|if
condition|(
operator|(
name|val
operator|=
name|arm_typed_reg_parse
argument_list|(
operator|&
name|ptr
argument_list|,
name|REG_TYPE_VFSD
argument_list|,
operator|&
name|rtype
argument_list|,
operator|&
name|optype
argument_list|)
operator|)
operator|==
name|FAIL
condition|)
block|{
name|first_error
argument_list|(
name|_
argument_list|(
name|reg_expected_msgs
index|[
name|REG_TYPE_VFSD
index|]
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
block|}
name|inst
operator|.
name|operands
index|[
name|i
index|]
operator|.
name|reg
operator|=
name|val
expr_stmt|;
name|inst
operator|.
name|operands
index|[
name|i
index|]
operator|.
name|isreg
operator|=
literal|1
expr_stmt|;
name|inst
operator|.
name|operands
index|[
name|i
index|]
operator|.
name|isvec
operator|=
literal|1
expr_stmt|;
name|inst
operator|.
name|operands
index|[
name|i
index|]
operator|.
name|issingle
operator|=
operator|(
name|rtype
operator|==
name|REG_TYPE_VFS
operator|)
expr_stmt|;
name|inst
operator|.
name|operands
index|[
name|i
index|]
operator|.
name|vectype
operator|=
name|optype
expr_stmt|;
name|inst
operator|.
name|operands
index|[
name|i
index|]
operator|.
name|present
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|rtype
operator|==
name|REG_TYPE_VFS
condition|)
block|{
comment|/* Case 14.  */
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|skip_past_comma
argument_list|(
operator|&
name|ptr
argument_list|)
operator|==
name|FAIL
condition|)
goto|goto
name|wanted_comma
goto|;
if|if
condition|(
operator|(
name|val
operator|=
name|arm_typed_reg_parse
argument_list|(
operator|&
name|ptr
argument_list|,
name|REG_TYPE_VFS
argument_list|,
name|NULL
argument_list|,
operator|&
name|optype
argument_list|)
operator|)
operator|==
name|FAIL
condition|)
block|{
name|first_error
argument_list|(
name|_
argument_list|(
name|reg_expected_msgs
index|[
name|REG_TYPE_VFS
index|]
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
block|}
name|inst
operator|.
name|operands
index|[
name|i
index|]
operator|.
name|reg
operator|=
name|val
expr_stmt|;
name|inst
operator|.
name|operands
index|[
name|i
index|]
operator|.
name|isreg
operator|=
literal|1
expr_stmt|;
name|inst
operator|.
name|operands
index|[
name|i
index|]
operator|.
name|isvec
operator|=
literal|1
expr_stmt|;
name|inst
operator|.
name|operands
index|[
name|i
index|]
operator|.
name|issingle
operator|=
literal|1
expr_stmt|;
name|inst
operator|.
name|operands
index|[
name|i
index|]
operator|.
name|vectype
operator|=
name|optype
expr_stmt|;
name|inst
operator|.
name|operands
index|[
name|i
index|]
operator|.
name|present
operator|=
literal|1
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|val
operator|=
name|arm_typed_reg_parse
argument_list|(
operator|&
name|ptr
argument_list|,
name|REG_TYPE_VFS
argument_list|,
name|NULL
argument_list|,
operator|&
name|optype
argument_list|)
operator|)
operator|!=
name|FAIL
condition|)
block|{
comment|/* Case 13.  */
name|inst
operator|.
name|operands
index|[
name|i
index|]
operator|.
name|reg
operator|=
name|val
expr_stmt|;
name|inst
operator|.
name|operands
index|[
name|i
index|]
operator|.
name|isreg
operator|=
literal|1
expr_stmt|;
name|inst
operator|.
name|operands
index|[
name|i
index|]
operator|.
name|isvec
operator|=
literal|1
expr_stmt|;
name|inst
operator|.
name|operands
index|[
name|i
index|]
operator|.
name|issingle
operator|=
literal|1
expr_stmt|;
name|inst
operator|.
name|operands
index|[
name|i
index|]
operator|.
name|vectype
operator|=
name|optype
expr_stmt|;
name|inst
operator|.
name|operands
index|[
name|i
index|]
operator|.
name|present
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
name|first_error
argument_list|(
name|_
argument_list|(
literal|"parse error"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
block|}
comment|/* Successfully parsed the operands. Update args.  */
operator|*
name|which_operand
operator|=
name|i
expr_stmt|;
operator|*
name|str
operator|=
name|ptr
expr_stmt|;
return|return
name|SUCCESS
return|;
name|wanted_comma
label|:
name|first_error
argument_list|(
name|_
argument_list|(
literal|"expected comma"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
name|wanted_arm
label|:
name|first_error
argument_list|(
name|_
argument_list|(
name|reg_expected_msgs
index|[
name|REG_TYPE_RN
index|]
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
block|}
end_function

begin_comment
comment|/* Matcher codes for parse_operands.  */
end_comment

begin_enum
enum|enum
name|operand_parse_code
block|{
name|OP_stop
block|,
comment|/* end of line */
name|OP_RR
block|,
comment|/* ARM register */
name|OP_RRnpc
block|,
comment|/* ARM register, not r15 */
name|OP_RRnpcb
block|,
comment|/* ARM register, not r15, in square brackets */
name|OP_RRw
block|,
comment|/* ARM register, not r15, optional trailing ! */
name|OP_RCP
block|,
comment|/* Coprocessor number */
name|OP_RCN
block|,
comment|/* Coprocessor register */
name|OP_RF
block|,
comment|/* FPA register */
name|OP_RVS
block|,
comment|/* VFP single precision register */
name|OP_RVD
block|,
comment|/* VFP double precision register (0..15) */
name|OP_RND
block|,
comment|/* Neon double precision register (0..31) */
name|OP_RNQ
block|,
comment|/* Neon quad precision register */
name|OP_RVSD
block|,
comment|/* VFP single or double precision register */
name|OP_RNDQ
block|,
comment|/* Neon double or quad precision register */
name|OP_RNSDQ
block|,
comment|/* Neon single, double or quad precision register */
name|OP_RNSC
block|,
comment|/* Neon scalar D[X] */
name|OP_RVC
block|,
comment|/* VFP control register */
name|OP_RMF
block|,
comment|/* Maverick F register */
name|OP_RMD
block|,
comment|/* Maverick D register */
name|OP_RMFX
block|,
comment|/* Maverick FX register */
name|OP_RMDX
block|,
comment|/* Maverick DX register */
name|OP_RMAX
block|,
comment|/* Maverick AX register */
name|OP_RMDS
block|,
comment|/* Maverick DSPSC register */
name|OP_RIWR
block|,
comment|/* iWMMXt wR register */
name|OP_RIWC
block|,
comment|/* iWMMXt wC register */
name|OP_RIWG
block|,
comment|/* iWMMXt wCG register */
name|OP_RXA
block|,
comment|/* XScale accumulator register */
name|OP_REGLST
block|,
comment|/* ARM register list */
name|OP_VRSLST
block|,
comment|/* VFP single-precision register list */
name|OP_VRDLST
block|,
comment|/* VFP double-precision register list */
name|OP_VRSDLST
block|,
comment|/* VFP single or double-precision register list (& quad) */
name|OP_NRDLST
block|,
comment|/* Neon double-precision register list (d0-d31, qN aliases) */
name|OP_NSTRLST
block|,
comment|/* Neon element/structure list */
name|OP_NILO
block|,
comment|/* Neon immediate/logic operands 2 or 2+3. (VBIC, VORR...)  */
name|OP_RNDQ_I0
block|,
comment|/* Neon D or Q reg, or immediate zero.  */
name|OP_RVSD_I0
block|,
comment|/* VFP S or D reg, or immediate zero.  */
name|OP_RR_RNSC
block|,
comment|/* ARM reg or Neon scalar.  */
name|OP_RNSDQ_RNSC
block|,
comment|/* Vector S, D or Q reg, or Neon scalar.  */
name|OP_RNDQ_RNSC
block|,
comment|/* Neon D or Q reg, or Neon scalar.  */
name|OP_RND_RNSC
block|,
comment|/* Neon D reg, or Neon scalar.  */
name|OP_VMOV
block|,
comment|/* Neon VMOV operands.  */
name|OP_RNDQ_IMVNb
block|,
comment|/* Neon D or Q reg, or immediate good for VMVN.  */
name|OP_RNDQ_I63b
block|,
comment|/* Neon D or Q reg, or immediate for shift.  */
name|OP_RIWR_I32z
block|,
comment|/* iWMMXt wR register, or immediate 0 .. 32 for iWMMXt2.  */
name|OP_I0
block|,
comment|/* immediate zero */
name|OP_I7
block|,
comment|/* immediate value 0 .. 7 */
name|OP_I15
block|,
comment|/*		   0 .. 15 */
name|OP_I16
block|,
comment|/*		   1 .. 16 */
name|OP_I16z
block|,
comment|/*                 0 .. 16 */
name|OP_I31
block|,
comment|/*		   0 .. 31 */
name|OP_I31w
block|,
comment|/*		   0 .. 31, optional trailing ! */
name|OP_I32
block|,
comment|/*		   1 .. 32 */
name|OP_I32z
block|,
comment|/*		   0 .. 32 */
name|OP_I63
block|,
comment|/*		   0 .. 63 */
name|OP_I63s
block|,
comment|/*		 -64 .. 63 */
name|OP_I64
block|,
comment|/*		   1 .. 64 */
name|OP_I64z
block|,
comment|/*		   0 .. 64 */
name|OP_I255
block|,
comment|/*		   0 .. 255 */
name|OP_I4b
block|,
comment|/* immediate, prefix optional, 1 .. 4 */
name|OP_I7b
block|,
comment|/*			       0 .. 7 */
name|OP_I15b
block|,
comment|/*			       0 .. 15 */
name|OP_I31b
block|,
comment|/*			       0 .. 31 */
name|OP_SH
block|,
comment|/* shifter operand */
name|OP_SHG
block|,
comment|/* shifter operand with possible group relocation */
name|OP_ADDR
block|,
comment|/* Memory address expression (any mode) */
name|OP_ADDRGLDR
block|,
comment|/* Mem addr expr (any mode) with possible LDR group reloc */
name|OP_ADDRGLDRS
block|,
comment|/* Mem addr expr (any mode) with possible LDRS group reloc */
name|OP_ADDRGLDC
block|,
comment|/* Mem addr expr (any mode) with possible LDC group reloc */
name|OP_EXP
block|,
comment|/* arbitrary expression */
name|OP_EXPi
block|,
comment|/* same, with optional immediate prefix */
name|OP_EXPr
block|,
comment|/* same, with optional relocation suffix */
name|OP_HALF
block|,
comment|/* 0 .. 65535 or low/high reloc.  */
name|OP_CPSF
block|,
comment|/* CPS flags */
name|OP_ENDI
block|,
comment|/* Endianness specifier */
name|OP_PSR
block|,
comment|/* CPSR/SPSR mask for msr */
name|OP_COND
block|,
comment|/* conditional code */
name|OP_TB
block|,
comment|/* Table branch.  */
name|OP_RVC_PSR
block|,
comment|/* CPSR/SPSR mask for msr, or VFP control register.  */
name|OP_APSR_RR
block|,
comment|/* ARM register or "APSR_nzcv".  */
name|OP_RRnpc_I0
block|,
comment|/* ARM register or literal 0 */
name|OP_RR_EXr
block|,
comment|/* ARM register or expression with opt. reloc suff. */
name|OP_RR_EXi
block|,
comment|/* ARM register or expression with imm prefix */
name|OP_RF_IF
block|,
comment|/* FPA register or immediate */
name|OP_RIWR_RIWC
block|,
comment|/* iWMMXt R or C reg */
name|OP_RIWC_RIWG
block|,
comment|/* iWMMXt wC or wCG reg */
comment|/* Optional operands.	 */
name|OP_oI7b
block|,
comment|/* immediate, prefix optional, 0 .. 7 */
name|OP_oI31b
block|,
comment|/*				0 .. 31 */
name|OP_oI32b
block|,
comment|/*                             1 .. 32 */
name|OP_oIffffb
block|,
comment|/*				0 .. 65535 */
name|OP_oI255c
block|,
comment|/*	  curly-brace enclosed, 0 .. 255 */
name|OP_oRR
block|,
comment|/* ARM register */
name|OP_oRRnpc
block|,
comment|/* ARM register, not the PC */
name|OP_oRRw
block|,
comment|/* ARM register, not r15, optional trailing ! */
name|OP_oRND
block|,
comment|/* Optional Neon double precision register */
name|OP_oRNQ
block|,
comment|/* Optional Neon quad precision register */
name|OP_oRNDQ
block|,
comment|/* Optional Neon double or quad precision register */
name|OP_oRNSDQ
block|,
comment|/* Optional single, double or quad precision vector register */
name|OP_oSHll
block|,
comment|/* LSL immediate */
name|OP_oSHar
block|,
comment|/* ASR immediate */
name|OP_oSHllar
block|,
comment|/* LSL or ASR immediate */
name|OP_oROR
block|,
comment|/* ROR 0/8/16/24 */
name|OP_oBARRIER
block|,
comment|/* Option argument for a barrier instruction.  */
name|OP_FIRST_OPTIONAL
init|=
name|OP_oI7b
block|}
enum|;
end_enum

begin_comment
comment|/* Generic instruction operand parser.	This does no encoding and no    semantic validation; it merely squirrels values away in the inst    structure.  Returns SUCCESS or FAIL depending on whether the    specified grammar matched.  */
end_comment

begin_function
specifier|static
name|int
name|parse_operands
parameter_list|(
name|char
modifier|*
name|str
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|pattern
parameter_list|)
block|{
name|unsigned
specifier|const
name|char
modifier|*
name|upat
init|=
name|pattern
decl_stmt|;
name|char
modifier|*
name|backtrack_pos
init|=
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
name|backtrack_error
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|,
name|val
decl_stmt|,
name|backtrack_index
init|=
literal|0
decl_stmt|;
name|enum
name|arm_reg_type
name|rtype
decl_stmt|;
name|parse_operand_result
name|result
decl_stmt|;
define|#
directive|define
name|po_char_or_fail
parameter_list|(
name|chr
parameter_list|)
value|do {		\   if (skip_past_char (&str, chr) == FAIL)	\     goto bad_args;				\ } while (0)
define|#
directive|define
name|po_reg_or_fail
parameter_list|(
name|regtype
parameter_list|)
value|do {				\   val = arm_typed_reg_parse (&str, regtype,&rtype,		\&inst.operands[i].vectype);	\   if (val == FAIL)						\     {								\       first_error (_(reg_expected_msgs[regtype]));		\       goto failure;						\     }								\   inst.operands[i].reg = val;					\   inst.operands[i].isreg = 1;					\   inst.operands[i].isquad = (rtype == REG_TYPE_NQ);		\   inst.operands[i].issingle = (rtype == REG_TYPE_VFS);		\   inst.operands[i].isvec = (rtype == REG_TYPE_VFS		\                             || rtype == REG_TYPE_VFD		\                             || rtype == REG_TYPE_NQ);		\ } while (0)
define|#
directive|define
name|po_reg_or_goto
parameter_list|(
name|regtype
parameter_list|,
name|label
parameter_list|)
value|do {			\   val = arm_typed_reg_parse (&str, regtype,&rtype,		\&inst.operands[i].vectype);	\   if (val == FAIL)						\     goto label;							\ 								\   inst.operands[i].reg = val;					\   inst.operands[i].isreg = 1;					\   inst.operands[i].isquad = (rtype == REG_TYPE_NQ);		\   inst.operands[i].issingle = (rtype == REG_TYPE_VFS);		\   inst.operands[i].isvec = (rtype == REG_TYPE_VFS		\                             || rtype == REG_TYPE_VFD		\                             || rtype == REG_TYPE_NQ);		\ } while (0)
define|#
directive|define
name|po_imm_or_fail
parameter_list|(
name|min
parameter_list|,
name|max
parameter_list|,
name|popt
parameter_list|)
value|do {			\   if (parse_immediate (&str,&val, min, max, popt) == FAIL)	\     goto failure;						\   inst.operands[i].imm = val;					\ } while (0)
define|#
directive|define
name|po_scalar_or_goto
parameter_list|(
name|elsz
parameter_list|,
name|label
parameter_list|)
value|do {			\   val = parse_scalar (&str, elsz,&inst.operands[i].vectype);	\   if (val == FAIL)						\     goto label;							\   inst.operands[i].reg = val;					\   inst.operands[i].isscalar = 1;				\ } while (0)
define|#
directive|define
name|po_misc_or_fail
parameter_list|(
name|expr
parameter_list|)
value|do {		\   if (expr)					\     goto failure;				\ } while (0)
define|#
directive|define
name|po_misc_or_fail_no_backtrack
parameter_list|(
name|expr
parameter_list|)
value|do {	\   result = expr;				\   if (result == PARSE_OPERAND_FAIL_NO_BACKTRACK)\     backtrack_pos = 0;				\   if (result != PARSE_OPERAND_SUCCESS)		\     goto failure;				\ } while (0)
name|skip_whitespace
argument_list|(
name|str
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|upat
index|[
name|i
index|]
operator|!=
name|OP_stop
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|upat
index|[
name|i
index|]
operator|>=
name|OP_FIRST_OPTIONAL
condition|)
block|{
comment|/* Remember where we are in case we need to backtrack.  */
name|assert
argument_list|(
operator|!
name|backtrack_pos
argument_list|)
expr_stmt|;
name|backtrack_pos
operator|=
name|str
expr_stmt|;
name|backtrack_error
operator|=
name|inst
operator|.
name|error
expr_stmt|;
name|backtrack_index
operator|=
name|i
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|>
literal|0
operator|&&
operator|(
name|i
operator|>
literal|1
operator|||
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|present
operator|)
condition|)
name|po_char_or_fail
argument_list|(
literal|','
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|upat
index|[
name|i
index|]
condition|)
block|{
comment|/* Registers */
case|case
name|OP_oRRnpc
case|:
case|case
name|OP_RRnpc
case|:
case|case
name|OP_oRR
case|:
case|case
name|OP_RR
case|:
name|po_reg_or_fail
argument_list|(
name|REG_TYPE_RN
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_RCP
case|:
name|po_reg_or_fail
argument_list|(
name|REG_TYPE_CP
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_RCN
case|:
name|po_reg_or_fail
argument_list|(
name|REG_TYPE_CN
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_RF
case|:
name|po_reg_or_fail
argument_list|(
name|REG_TYPE_FN
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_RVS
case|:
name|po_reg_or_fail
argument_list|(
name|REG_TYPE_VFS
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_RVD
case|:
name|po_reg_or_fail
argument_list|(
name|REG_TYPE_VFD
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_oRND
case|:
case|case
name|OP_RND
case|:
name|po_reg_or_fail
argument_list|(
name|REG_TYPE_VFD
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_RVC
case|:
name|po_reg_or_goto
argument_list|(
name|REG_TYPE_VFC
argument_list|,
name|coproc_reg
argument_list|)
expr_stmt|;
break|break;
comment|/* Also accept generic coprocessor regs for unknown registers.  */
name|coproc_reg
label|:
name|po_reg_or_fail
argument_list|(
name|REG_TYPE_CN
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_RMF
case|:
name|po_reg_or_fail
argument_list|(
name|REG_TYPE_MVF
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_RMD
case|:
name|po_reg_or_fail
argument_list|(
name|REG_TYPE_MVD
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_RMFX
case|:
name|po_reg_or_fail
argument_list|(
name|REG_TYPE_MVFX
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_RMDX
case|:
name|po_reg_or_fail
argument_list|(
name|REG_TYPE_MVDX
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_RMAX
case|:
name|po_reg_or_fail
argument_list|(
name|REG_TYPE_MVAX
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_RMDS
case|:
name|po_reg_or_fail
argument_list|(
name|REG_TYPE_DSPSC
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_RIWR
case|:
name|po_reg_or_fail
argument_list|(
name|REG_TYPE_MMXWR
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_RIWC
case|:
name|po_reg_or_fail
argument_list|(
name|REG_TYPE_MMXWC
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_RIWG
case|:
name|po_reg_or_fail
argument_list|(
name|REG_TYPE_MMXWCG
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_RXA
case|:
name|po_reg_or_fail
argument_list|(
name|REG_TYPE_XSCALE
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_oRNQ
case|:
case|case
name|OP_RNQ
case|:
name|po_reg_or_fail
argument_list|(
name|REG_TYPE_NQ
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_oRNDQ
case|:
case|case
name|OP_RNDQ
case|:
name|po_reg_or_fail
argument_list|(
name|REG_TYPE_NDQ
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_RVSD
case|:
name|po_reg_or_fail
argument_list|(
name|REG_TYPE_VFSD
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_oRNSDQ
case|:
case|case
name|OP_RNSDQ
case|:
name|po_reg_or_fail
argument_list|(
name|REG_TYPE_NSDQ
argument_list|)
expr_stmt|;
break|break;
comment|/* Neon scalar. Using an element size of 8 means that some invalid            scalars are accepted here, so deal with those in later code.  */
case|case
name|OP_RNSC
case|:
name|po_scalar_or_goto
argument_list|(
literal|8
argument_list|,
name|failure
argument_list|)
expr_stmt|;
break|break;
comment|/* WARNING: We can expand to two operands here. This has the potential            to totally confuse the backtracking mechanism! It will be OK at            least as long as we don't try to use optional args as well,            though.  */
case|case
name|OP_NILO
case|:
block|{
name|po_reg_or_goto
argument_list|(
name|REG_TYPE_NDQ
argument_list|,
name|try_imm
argument_list|)
expr_stmt|;
name|inst
operator|.
name|operands
index|[
name|i
index|]
operator|.
name|present
operator|=
literal|1
expr_stmt|;
name|i
operator|++
expr_stmt|;
name|skip_past_comma
argument_list|(
operator|&
name|str
argument_list|)
expr_stmt|;
name|po_reg_or_goto
argument_list|(
name|REG_TYPE_NDQ
argument_list|,
name|one_reg_only
argument_list|)
expr_stmt|;
break|break;
name|one_reg_only
label|:
comment|/* Optional register operand was omitted. Unfortunately, it's in                operands[i-1] and we need it to be in inst.operands[i]. Fix that                here (this is a bit grotty).  */
name|inst
operator|.
name|operands
index|[
name|i
index|]
operator|=
name|inst
operator|.
name|operands
index|[
name|i
operator|-
literal|1
index|]
expr_stmt|;
name|inst
operator|.
name|operands
index|[
name|i
operator|-
literal|1
index|]
operator|.
name|present
operator|=
literal|0
expr_stmt|;
break|break;
name|try_imm
label|:
comment|/* There's a possibility of getting a 64-bit immediate here, so 	       we need special handling.  */
if|if
condition|(
name|parse_big_immediate
argument_list|(
operator|&
name|str
argument_list|,
name|i
argument_list|)
operator|==
name|FAIL
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"immediate value is out of range"
argument_list|)
expr_stmt|;
goto|goto
name|failure
goto|;
block|}
block|}
break|break;
case|case
name|OP_RNDQ_I0
case|:
block|{
name|po_reg_or_goto
argument_list|(
name|REG_TYPE_NDQ
argument_list|,
name|try_imm0
argument_list|)
expr_stmt|;
break|break;
name|try_imm0
label|:
name|po_imm_or_fail
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|OP_RVSD_I0
case|:
name|po_reg_or_goto
argument_list|(
name|REG_TYPE_VFSD
argument_list|,
name|try_imm0
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_RR_RNSC
case|:
block|{
name|po_scalar_or_goto
argument_list|(
literal|8
argument_list|,
name|try_rr
argument_list|)
expr_stmt|;
break|break;
name|try_rr
label|:
name|po_reg_or_fail
argument_list|(
name|REG_TYPE_RN
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|OP_RNSDQ_RNSC
case|:
block|{
name|po_scalar_or_goto
argument_list|(
literal|8
argument_list|,
name|try_nsdq
argument_list|)
expr_stmt|;
break|break;
name|try_nsdq
label|:
name|po_reg_or_fail
argument_list|(
name|REG_TYPE_NSDQ
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|OP_RNDQ_RNSC
case|:
block|{
name|po_scalar_or_goto
argument_list|(
literal|8
argument_list|,
name|try_ndq
argument_list|)
expr_stmt|;
break|break;
name|try_ndq
label|:
name|po_reg_or_fail
argument_list|(
name|REG_TYPE_NDQ
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|OP_RND_RNSC
case|:
block|{
name|po_scalar_or_goto
argument_list|(
literal|8
argument_list|,
name|try_vfd
argument_list|)
expr_stmt|;
break|break;
name|try_vfd
label|:
name|po_reg_or_fail
argument_list|(
name|REG_TYPE_VFD
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|OP_VMOV
case|:
comment|/* WARNING: parse_neon_mov can move the operand counter, i. If we're              not careful then bad things might happen.  */
name|po_misc_or_fail
argument_list|(
name|parse_neon_mov
argument_list|(
operator|&
name|str
argument_list|,
operator|&
name|i
argument_list|)
operator|==
name|FAIL
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_RNDQ_IMVNb
case|:
block|{
name|po_reg_or_goto
argument_list|(
name|REG_TYPE_NDQ
argument_list|,
name|try_mvnimm
argument_list|)
expr_stmt|;
break|break;
name|try_mvnimm
label|:
comment|/* There's a possibility of getting a 64-bit immediate here, so                we need special handling.  */
if|if
condition|(
name|parse_big_immediate
argument_list|(
operator|&
name|str
argument_list|,
name|i
argument_list|)
operator|==
name|FAIL
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"immediate value is out of range"
argument_list|)
expr_stmt|;
goto|goto
name|failure
goto|;
block|}
block|}
break|break;
case|case
name|OP_RNDQ_I63b
case|:
block|{
name|po_reg_or_goto
argument_list|(
name|REG_TYPE_NDQ
argument_list|,
name|try_shimm
argument_list|)
expr_stmt|;
break|break;
name|try_shimm
label|:
name|po_imm_or_fail
argument_list|(
literal|0
argument_list|,
literal|63
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|OP_RRnpcb
case|:
name|po_char_or_fail
argument_list|(
literal|'['
argument_list|)
expr_stmt|;
name|po_reg_or_fail
argument_list|(
name|REG_TYPE_RN
argument_list|)
expr_stmt|;
name|po_char_or_fail
argument_list|(
literal|']'
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_RRw
case|:
case|case
name|OP_oRRw
case|:
name|po_reg_or_fail
argument_list|(
name|REG_TYPE_RN
argument_list|)
expr_stmt|;
if|if
condition|(
name|skip_past_char
argument_list|(
operator|&
name|str
argument_list|,
literal|'!'
argument_list|)
operator|==
name|SUCCESS
condition|)
name|inst
operator|.
name|operands
index|[
name|i
index|]
operator|.
name|writeback
operator|=
literal|1
expr_stmt|;
break|break;
comment|/* Immediates */
case|case
name|OP_I7
case|:
name|po_imm_or_fail
argument_list|(
literal|0
argument_list|,
literal|7
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_I15
case|:
name|po_imm_or_fail
argument_list|(
literal|0
argument_list|,
literal|15
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_I16
case|:
name|po_imm_or_fail
argument_list|(
literal|1
argument_list|,
literal|16
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_I16z
case|:
name|po_imm_or_fail
argument_list|(
literal|0
argument_list|,
literal|16
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_I31
case|:
name|po_imm_or_fail
argument_list|(
literal|0
argument_list|,
literal|31
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_I32
case|:
name|po_imm_or_fail
argument_list|(
literal|1
argument_list|,
literal|32
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_I32z
case|:
name|po_imm_or_fail
argument_list|(
literal|0
argument_list|,
literal|32
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_I63s
case|:
name|po_imm_or_fail
argument_list|(
operator|-
literal|64
argument_list|,
literal|63
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_I63
case|:
name|po_imm_or_fail
argument_list|(
literal|0
argument_list|,
literal|63
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_I64
case|:
name|po_imm_or_fail
argument_list|(
literal|1
argument_list|,
literal|64
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_I64z
case|:
name|po_imm_or_fail
argument_list|(
literal|0
argument_list|,
literal|64
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_I255
case|:
name|po_imm_or_fail
argument_list|(
literal|0
argument_list|,
literal|255
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_I4b
case|:
name|po_imm_or_fail
argument_list|(
literal|1
argument_list|,
literal|4
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_oI7b
case|:
case|case
name|OP_I7b
case|:
name|po_imm_or_fail
argument_list|(
literal|0
argument_list|,
literal|7
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_I15b
case|:
name|po_imm_or_fail
argument_list|(
literal|0
argument_list|,
literal|15
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_oI31b
case|:
case|case
name|OP_I31b
case|:
name|po_imm_or_fail
argument_list|(
literal|0
argument_list|,
literal|31
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_oI32b
case|:
name|po_imm_or_fail
argument_list|(
literal|1
argument_list|,
literal|32
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_oIffffb
case|:
name|po_imm_or_fail
argument_list|(
literal|0
argument_list|,
literal|0xffff
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
break|break;
comment|/* Immediate variants */
case|case
name|OP_oI255c
case|:
name|po_char_or_fail
argument_list|(
literal|'{'
argument_list|)
expr_stmt|;
name|po_imm_or_fail
argument_list|(
literal|0
argument_list|,
literal|255
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|po_char_or_fail
argument_list|(
literal|'}'
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_I31w
case|:
comment|/* The expression parser chokes on a trailing !, so we have 	     to find it first and zap it.  */
block|{
name|char
modifier|*
name|s
init|=
name|str
decl_stmt|;
while|while
condition|(
operator|*
name|s
operator|&&
operator|*
name|s
operator|!=
literal|','
condition|)
name|s
operator|++
expr_stmt|;
if|if
condition|(
name|s
index|[
operator|-
literal|1
index|]
operator|==
literal|'!'
condition|)
block|{
name|s
index|[
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|inst
operator|.
name|operands
index|[
name|i
index|]
operator|.
name|writeback
operator|=
literal|1
expr_stmt|;
block|}
name|po_imm_or_fail
argument_list|(
literal|0
argument_list|,
literal|31
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|str
operator|==
name|s
operator|-
literal|1
condition|)
name|str
operator|=
name|s
expr_stmt|;
block|}
break|break;
comment|/* Expressions */
case|case
name|OP_EXPi
case|:
name|EXPi
label|:
name|po_misc_or_fail
argument_list|(
name|my_get_expression
argument_list|(
operator|&
name|inst
operator|.
name|reloc
operator|.
name|exp
argument_list|,
operator|&
name|str
argument_list|,
name|GE_OPT_PREFIX
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_EXP
case|:
name|po_misc_or_fail
argument_list|(
name|my_get_expression
argument_list|(
operator|&
name|inst
operator|.
name|reloc
operator|.
name|exp
argument_list|,
operator|&
name|str
argument_list|,
name|GE_NO_PREFIX
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_EXPr
case|:
name|EXPr
label|:
name|po_misc_or_fail
argument_list|(
name|my_get_expression
argument_list|(
operator|&
name|inst
operator|.
name|reloc
operator|.
name|exp
argument_list|,
operator|&
name|str
argument_list|,
name|GE_NO_PREFIX
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_op
operator|==
name|O_symbol
condition|)
block|{
name|val
operator|=
name|parse_reloc
argument_list|(
operator|&
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|==
operator|-
literal|1
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"unrecognized relocation suffix"
argument_list|)
expr_stmt|;
goto|goto
name|failure
goto|;
block|}
elseif|else
if|if
condition|(
name|val
operator|!=
name|BFD_RELOC_UNUSED
condition|)
block|{
name|inst
operator|.
name|operands
index|[
name|i
index|]
operator|.
name|imm
operator|=
name|val
expr_stmt|;
name|inst
operator|.
name|operands
index|[
name|i
index|]
operator|.
name|hasreloc
operator|=
literal|1
expr_stmt|;
block|}
block|}
break|break;
comment|/* Operand for MOVW or MOVT.  */
case|case
name|OP_HALF
case|:
name|po_misc_or_fail
argument_list|(
name|parse_half
argument_list|(
operator|&
name|str
argument_list|)
argument_list|)
expr_stmt|;
break|break;
comment|/* Register or expression */
case|case
name|OP_RR_EXr
case|:
name|po_reg_or_goto
argument_list|(
name|REG_TYPE_RN
argument_list|,
name|EXPr
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_RR_EXi
case|:
name|po_reg_or_goto
argument_list|(
name|REG_TYPE_RN
argument_list|,
name|EXPi
argument_list|)
expr_stmt|;
break|break;
comment|/* Register or immediate */
case|case
name|OP_RRnpc_I0
case|:
name|po_reg_or_goto
argument_list|(
name|REG_TYPE_RN
argument_list|,
name|I0
argument_list|)
expr_stmt|;
break|break;
name|I0
label|:
name|po_imm_or_fail
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_RF_IF
case|:
name|po_reg_or_goto
argument_list|(
name|REG_TYPE_FN
argument_list|,
name|IF
argument_list|)
expr_stmt|;
break|break;
name|IF
label|:
if|if
condition|(
operator|!
name|is_immediate_prefix
argument_list|(
operator|*
name|str
argument_list|)
condition|)
goto|goto
name|bad_args
goto|;
name|str
operator|++
expr_stmt|;
name|val
operator|=
name|parse_fpa_immediate
argument_list|(
operator|&
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|==
name|FAIL
condition|)
goto|goto
name|failure
goto|;
comment|/* FPA immediates are encoded as registers 8-15. 	     parse_fpa_immediate has already applied the offset.  */
name|inst
operator|.
name|operands
index|[
name|i
index|]
operator|.
name|reg
operator|=
name|val
expr_stmt|;
name|inst
operator|.
name|operands
index|[
name|i
index|]
operator|.
name|isreg
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|OP_RIWR_I32z
case|:
name|po_reg_or_goto
argument_list|(
name|REG_TYPE_MMXWR
argument_list|,
name|I32z
argument_list|)
expr_stmt|;
break|break;
name|I32z
label|:
name|po_imm_or_fail
argument_list|(
literal|0
argument_list|,
literal|32
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
break|break;
comment|/* Two kinds of register */
case|case
name|OP_RIWR_RIWC
case|:
block|{
name|struct
name|reg_entry
modifier|*
name|rege
init|=
name|arm_reg_parse_multi
argument_list|(
operator|&
name|str
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|rege
operator|||
operator|(
name|rege
operator|->
name|type
operator|!=
name|REG_TYPE_MMXWR
operator|&&
name|rege
operator|->
name|type
operator|!=
name|REG_TYPE_MMXWC
operator|&&
name|rege
operator|->
name|type
operator|!=
name|REG_TYPE_MMXWCG
operator|)
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"iWMMXt data or control register expected"
argument_list|)
expr_stmt|;
goto|goto
name|failure
goto|;
block|}
name|inst
operator|.
name|operands
index|[
name|i
index|]
operator|.
name|reg
operator|=
name|rege
operator|->
name|number
expr_stmt|;
name|inst
operator|.
name|operands
index|[
name|i
index|]
operator|.
name|isreg
operator|=
operator|(
name|rege
operator|->
name|type
operator|==
name|REG_TYPE_MMXWR
operator|)
expr_stmt|;
block|}
break|break;
case|case
name|OP_RIWC_RIWG
case|:
block|{
name|struct
name|reg_entry
modifier|*
name|rege
init|=
name|arm_reg_parse_multi
argument_list|(
operator|&
name|str
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|rege
operator|||
operator|(
name|rege
operator|->
name|type
operator|!=
name|REG_TYPE_MMXWC
operator|&&
name|rege
operator|->
name|type
operator|!=
name|REG_TYPE_MMXWCG
operator|)
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"iWMMXt control register expected"
argument_list|)
expr_stmt|;
goto|goto
name|failure
goto|;
block|}
name|inst
operator|.
name|operands
index|[
name|i
index|]
operator|.
name|reg
operator|=
name|rege
operator|->
name|number
expr_stmt|;
name|inst
operator|.
name|operands
index|[
name|i
index|]
operator|.
name|isreg
operator|=
literal|1
expr_stmt|;
block|}
break|break;
comment|/* Misc */
case|case
name|OP_CPSF
case|:
name|val
operator|=
name|parse_cps_flags
argument_list|(
operator|&
name|str
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_ENDI
case|:
name|val
operator|=
name|parse_endian_specifier
argument_list|(
operator|&
name|str
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_oROR
case|:
name|val
operator|=
name|parse_ror
argument_list|(
operator|&
name|str
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_PSR
case|:
name|val
operator|=
name|parse_psr
argument_list|(
operator|&
name|str
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_COND
case|:
name|val
operator|=
name|parse_cond
argument_list|(
operator|&
name|str
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_oBARRIER
case|:
name|val
operator|=
name|parse_barrier
argument_list|(
operator|&
name|str
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_RVC_PSR
case|:
name|po_reg_or_goto
argument_list|(
name|REG_TYPE_VFC
argument_list|,
name|try_psr
argument_list|)
expr_stmt|;
name|inst
operator|.
name|operands
index|[
name|i
index|]
operator|.
name|isvec
operator|=
literal|1
expr_stmt|;
comment|/* Mark VFP control reg as vector.  */
break|break;
name|try_psr
label|:
name|val
operator|=
name|parse_psr
argument_list|(
operator|&
name|str
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_APSR_RR
case|:
name|po_reg_or_goto
argument_list|(
name|REG_TYPE_RN
argument_list|,
name|try_apsr
argument_list|)
expr_stmt|;
break|break;
name|try_apsr
label|:
comment|/* Parse "APSR_nvzc" operand (for FMSTAT-equivalent MRS              instruction).  */
if|if
condition|(
name|strncasecmp
argument_list|(
name|str
argument_list|,
literal|"APSR_"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
block|{
name|unsigned
name|found
init|=
literal|0
decl_stmt|;
name|str
operator|+=
literal|5
expr_stmt|;
while|while
condition|(
name|found
operator|<
literal|15
condition|)
switch|switch
condition|(
operator|*
name|str
operator|++
condition|)
block|{
case|case
literal|'c'
case|:
name|found
operator|=
operator|(
name|found
operator|&
literal|1
operator|)
condition|?
literal|16
else|:
name|found
operator||
literal|1
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
name|found
operator|=
operator|(
name|found
operator|&
literal|2
operator|)
condition|?
literal|16
else|:
name|found
operator||
literal|2
expr_stmt|;
break|break;
case|case
literal|'z'
case|:
name|found
operator|=
operator|(
name|found
operator|&
literal|4
operator|)
condition|?
literal|16
else|:
name|found
operator||
literal|4
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
name|found
operator|=
operator|(
name|found
operator|&
literal|8
operator|)
condition|?
literal|16
else|:
name|found
operator||
literal|8
expr_stmt|;
break|break;
default|default:
name|found
operator|=
literal|16
expr_stmt|;
block|}
if|if
condition|(
name|found
operator|!=
literal|15
condition|)
goto|goto
name|failure
goto|;
name|inst
operator|.
name|operands
index|[
name|i
index|]
operator|.
name|isvec
operator|=
literal|1
expr_stmt|;
block|}
else|else
goto|goto
name|failure
goto|;
break|break;
case|case
name|OP_TB
case|:
name|po_misc_or_fail
argument_list|(
name|parse_tb
argument_list|(
operator|&
name|str
argument_list|)
argument_list|)
expr_stmt|;
break|break;
comment|/* Register lists */
case|case
name|OP_REGLST
case|:
name|val
operator|=
name|parse_reg_list
argument_list|(
operator|&
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|str
operator|==
literal|'^'
condition|)
block|{
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|writeback
operator|=
literal|1
expr_stmt|;
name|str
operator|++
expr_stmt|;
block|}
break|break;
case|case
name|OP_VRSLST
case|:
name|val
operator|=
name|parse_vfp_reg_list
argument_list|(
operator|&
name|str
argument_list|,
operator|&
name|inst
operator|.
name|operands
index|[
name|i
index|]
operator|.
name|reg
argument_list|,
name|REGLIST_VFP_S
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_VRDLST
case|:
name|val
operator|=
name|parse_vfp_reg_list
argument_list|(
operator|&
name|str
argument_list|,
operator|&
name|inst
operator|.
name|operands
index|[
name|i
index|]
operator|.
name|reg
argument_list|,
name|REGLIST_VFP_D
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_VRSDLST
case|:
comment|/* Allow Q registers too.  */
name|val
operator|=
name|parse_vfp_reg_list
argument_list|(
operator|&
name|str
argument_list|,
operator|&
name|inst
operator|.
name|operands
index|[
name|i
index|]
operator|.
name|reg
argument_list|,
name|REGLIST_NEON_D
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|==
name|FAIL
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|NULL
expr_stmt|;
name|val
operator|=
name|parse_vfp_reg_list
argument_list|(
operator|&
name|str
argument_list|,
operator|&
name|inst
operator|.
name|operands
index|[
name|i
index|]
operator|.
name|reg
argument_list|,
name|REGLIST_VFP_S
argument_list|)
expr_stmt|;
name|inst
operator|.
name|operands
index|[
name|i
index|]
operator|.
name|issingle
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|OP_NRDLST
case|:
name|val
operator|=
name|parse_vfp_reg_list
argument_list|(
operator|&
name|str
argument_list|,
operator|&
name|inst
operator|.
name|operands
index|[
name|i
index|]
operator|.
name|reg
argument_list|,
name|REGLIST_NEON_D
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_NSTRLST
case|:
name|val
operator|=
name|parse_neon_el_struct_list
argument_list|(
operator|&
name|str
argument_list|,
operator|&
name|inst
operator|.
name|operands
index|[
name|i
index|]
operator|.
name|reg
argument_list|,
operator|&
name|inst
operator|.
name|operands
index|[
name|i
index|]
operator|.
name|vectype
argument_list|)
expr_stmt|;
break|break;
comment|/* Addressing modes */
case|case
name|OP_ADDR
case|:
name|po_misc_or_fail
argument_list|(
name|parse_address
argument_list|(
operator|&
name|str
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_ADDRGLDR
case|:
name|po_misc_or_fail_no_backtrack
argument_list|(
name|parse_address_group_reloc
argument_list|(
operator|&
name|str
argument_list|,
name|i
argument_list|,
name|GROUP_LDR
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_ADDRGLDRS
case|:
name|po_misc_or_fail_no_backtrack
argument_list|(
name|parse_address_group_reloc
argument_list|(
operator|&
name|str
argument_list|,
name|i
argument_list|,
name|GROUP_LDRS
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_ADDRGLDC
case|:
name|po_misc_or_fail_no_backtrack
argument_list|(
name|parse_address_group_reloc
argument_list|(
operator|&
name|str
argument_list|,
name|i
argument_list|,
name|GROUP_LDC
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_SH
case|:
name|po_misc_or_fail
argument_list|(
name|parse_shifter_operand
argument_list|(
operator|&
name|str
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_SHG
case|:
name|po_misc_or_fail_no_backtrack
argument_list|(
name|parse_shifter_operand_group_reloc
argument_list|(
operator|&
name|str
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_oSHll
case|:
name|po_misc_or_fail
argument_list|(
name|parse_shift
argument_list|(
operator|&
name|str
argument_list|,
name|i
argument_list|,
name|SHIFT_LSL_IMMEDIATE
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_oSHar
case|:
name|po_misc_or_fail
argument_list|(
name|parse_shift
argument_list|(
operator|&
name|str
argument_list|,
name|i
argument_list|,
name|SHIFT_ASR_IMMEDIATE
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_oSHllar
case|:
name|po_misc_or_fail
argument_list|(
name|parse_shift
argument_list|(
operator|&
name|str
argument_list|,
name|i
argument_list|,
name|SHIFT_LSL_OR_ASR_IMMEDIATE
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|as_fatal
argument_list|(
literal|"unhandled operand code %d"
argument_list|,
name|upat
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* Various value-based sanity checks and shared operations.  We 	 do not signal immediate failures for the register constraints; 	 this allows a syntax error to take precedence.	 */
switch|switch
condition|(
name|upat
index|[
name|i
index|]
condition|)
block|{
case|case
name|OP_oRRnpc
case|:
case|case
name|OP_RRnpc
case|:
case|case
name|OP_RRnpcb
case|:
case|case
name|OP_RRw
case|:
case|case
name|OP_oRRw
case|:
case|case
name|OP_RRnpc_I0
case|:
if|if
condition|(
name|inst
operator|.
name|operands
index|[
name|i
index|]
operator|.
name|isreg
operator|&&
name|inst
operator|.
name|operands
index|[
name|i
index|]
operator|.
name|reg
operator|==
name|REG_PC
condition|)
name|inst
operator|.
name|error
operator|=
name|BAD_PC
expr_stmt|;
break|break;
case|case
name|OP_CPSF
case|:
case|case
name|OP_ENDI
case|:
case|case
name|OP_oROR
case|:
case|case
name|OP_PSR
case|:
case|case
name|OP_RVC_PSR
case|:
case|case
name|OP_COND
case|:
case|case
name|OP_oBARRIER
case|:
case|case
name|OP_REGLST
case|:
case|case
name|OP_VRSLST
case|:
case|case
name|OP_VRDLST
case|:
case|case
name|OP_VRSDLST
case|:
case|case
name|OP_NRDLST
case|:
case|case
name|OP_NSTRLST
case|:
if|if
condition|(
name|val
operator|==
name|FAIL
condition|)
goto|goto
name|failure
goto|;
name|inst
operator|.
name|operands
index|[
name|i
index|]
operator|.
name|imm
operator|=
name|val
expr_stmt|;
break|break;
default|default:
break|break;
block|}
comment|/* If we get here, this operand was successfully parsed.	*/
name|inst
operator|.
name|operands
index|[
name|i
index|]
operator|.
name|present
operator|=
literal|1
expr_stmt|;
continue|continue;
name|bad_args
label|:
name|inst
operator|.
name|error
operator|=
name|BAD_ARGS
expr_stmt|;
name|failure
label|:
if|if
condition|(
operator|!
name|backtrack_pos
condition|)
block|{
comment|/* The parse routine should already have set inst.error, but set a 	     defaut here just in case.  */
if|if
condition|(
operator|!
name|inst
operator|.
name|error
condition|)
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"syntax error"
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
block|}
comment|/* Do not backtrack over a trailing optional argument that 	 absorbed some text.  We will only fail again, with the 	 'garbage following instruction' error message, which is 	 probably less helpful than the current one.  */
if|if
condition|(
name|backtrack_index
operator|==
name|i
operator|&&
name|backtrack_pos
operator|!=
name|str
operator|&&
name|upat
index|[
name|i
operator|+
literal|1
index|]
operator|==
name|OP_stop
condition|)
block|{
if|if
condition|(
operator|!
name|inst
operator|.
name|error
condition|)
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"syntax error"
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
block|}
comment|/* Try again, skipping the optional argument at backtrack_pos.  */
name|str
operator|=
name|backtrack_pos
expr_stmt|;
name|inst
operator|.
name|error
operator|=
name|backtrack_error
expr_stmt|;
name|inst
operator|.
name|operands
index|[
name|backtrack_index
index|]
operator|.
name|present
operator|=
literal|0
expr_stmt|;
name|i
operator|=
name|backtrack_index
expr_stmt|;
name|backtrack_pos
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Check that we have parsed all the arguments.  */
if|if
condition|(
operator|*
name|str
operator|!=
literal|'\0'
operator|&&
operator|!
name|inst
operator|.
name|error
condition|)
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"garbage following instruction"
argument_list|)
expr_stmt|;
return|return
name|inst
operator|.
name|error
condition|?
name|FAIL
else|:
name|SUCCESS
return|;
block|}
end_function

begin_undef
undef|#
directive|undef
name|po_char_or_fail
end_undef

begin_undef
undef|#
directive|undef
name|po_reg_or_fail
end_undef

begin_undef
undef|#
directive|undef
name|po_reg_or_goto
end_undef

begin_undef
undef|#
directive|undef
name|po_imm_or_fail
end_undef

begin_undef
undef|#
directive|undef
name|po_scalar_or_fail
end_undef

begin_escape
end_escape

begin_comment
comment|/* Shorthand macro for instruction encoding functions issuing errors.  */
end_comment

begin_define
define|#
directive|define
name|constraint
parameter_list|(
name|expr
parameter_list|,
name|err
parameter_list|)
value|do {		\   if (expr)					\     {						\       inst.error = err;				\       return;					\     }						\ } while (0)
end_define

begin_comment
comment|/* Functions for operand encoding.  ARM, then Thumb.  */
end_comment

begin_define
define|#
directive|define
name|rotate_left
parameter_list|(
name|v
parameter_list|,
name|n
parameter_list|)
value|(v<< (n % 32) | v>> ((32 - n) % 32))
end_define

begin_comment
comment|/* If VAL can be encoded in the immediate field of an ARM instruction,    return the encoded form.  Otherwise, return FAIL.  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|encode_arm_immediate
parameter_list|(
name|unsigned
name|int
name|val
parameter_list|)
block|{
name|unsigned
name|int
name|a
decl_stmt|,
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|+=
literal|2
control|)
if|if
condition|(
operator|(
name|a
operator|=
name|rotate_left
argument_list|(
name|val
argument_list|,
name|i
argument_list|)
operator|)
operator|<=
literal|0xff
condition|)
return|return
name|a
operator||
operator|(
name|i
operator|<<
literal|7
operator|)
return|;
comment|/* 12-bit pack: [shift-cnt,const].  */
return|return
name|FAIL
return|;
block|}
end_function

begin_comment
comment|/* If VAL can be encoded in the immediate field of a Thumb32 instruction,    return the encoded form.  Otherwise, return FAIL.  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|encode_thumb32_immediate
parameter_list|(
name|unsigned
name|int
name|val
parameter_list|)
block|{
name|unsigned
name|int
name|a
decl_stmt|,
name|i
decl_stmt|;
if|if
condition|(
name|val
operator|<=
literal|0xff
condition|)
return|return
name|val
return|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
literal|24
condition|;
name|i
operator|++
control|)
block|{
name|a
operator|=
name|val
operator|>>
name|i
expr_stmt|;
if|if
condition|(
operator|(
name|val
operator|&
operator|~
operator|(
literal|0xff
operator|<<
name|i
operator|)
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
operator|(
name|val
operator|>>
name|i
operator|)
operator|&
literal|0x7f
operator|)
operator||
operator|(
operator|(
literal|32
operator|-
name|i
operator|)
operator|<<
literal|7
operator|)
return|;
block|}
name|a
operator|=
name|val
operator|&
literal|0xff
expr_stmt|;
if|if
condition|(
name|val
operator|==
operator|(
operator|(
name|a
operator|<<
literal|16
operator|)
operator||
name|a
operator|)
condition|)
return|return
literal|0x100
operator||
name|a
return|;
if|if
condition|(
name|val
operator|==
operator|(
operator|(
name|a
operator|<<
literal|24
operator|)
operator||
operator|(
name|a
operator|<<
literal|16
operator|)
operator||
operator|(
name|a
operator|<<
literal|8
operator|)
operator||
name|a
operator|)
condition|)
return|return
literal|0x300
operator||
name|a
return|;
name|a
operator|=
name|val
operator|&
literal|0xff00
expr_stmt|;
if|if
condition|(
name|val
operator|==
operator|(
operator|(
name|a
operator|<<
literal|16
operator|)
operator||
name|a
operator|)
condition|)
return|return
literal|0x200
operator||
operator|(
name|a
operator|>>
literal|8
operator|)
return|;
return|return
name|FAIL
return|;
block|}
end_function

begin_comment
comment|/* Encode a VFP SP or DP register number into inst.instruction.  */
end_comment

begin_function
specifier|static
name|void
name|encode_arm_vfp_reg
parameter_list|(
name|int
name|reg
parameter_list|,
name|enum
name|vfp_reg_pos
name|pos
parameter_list|)
block|{
if|if
condition|(
operator|(
name|pos
operator|==
name|VFP_REG_Dd
operator|||
name|pos
operator|==
name|VFP_REG_Dn
operator|||
name|pos
operator|==
name|VFP_REG_Dm
operator|)
operator|&&
name|reg
operator|>
literal|15
condition|)
block|{
if|if
condition|(
name|ARM_CPU_HAS_FEATURE
argument_list|(
name|cpu_variant
argument_list|,
name|fpu_vfp_ext_v3
argument_list|)
condition|)
block|{
if|if
condition|(
name|thumb_mode
condition|)
name|ARM_MERGE_FEATURE_SETS
argument_list|(
name|thumb_arch_used
argument_list|,
name|thumb_arch_used
argument_list|,
name|fpu_vfp_ext_v3
argument_list|)
expr_stmt|;
else|else
name|ARM_MERGE_FEATURE_SETS
argument_list|(
name|arm_arch_used
argument_list|,
name|arm_arch_used
argument_list|,
name|fpu_vfp_ext_v3
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|first_error
argument_list|(
name|_
argument_list|(
literal|"D register out of range for selected VFP version"
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
switch|switch
condition|(
name|pos
condition|)
block|{
case|case
name|VFP_REG_Sd
case|:
name|inst
operator|.
name|instruction
operator||=
operator|(
operator|(
name|reg
operator|>>
literal|1
operator|)
operator|<<
literal|12
operator|)
operator||
operator|(
operator|(
name|reg
operator|&
literal|1
operator|)
operator|<<
literal|22
operator|)
expr_stmt|;
break|break;
case|case
name|VFP_REG_Sn
case|:
name|inst
operator|.
name|instruction
operator||=
operator|(
operator|(
name|reg
operator|>>
literal|1
operator|)
operator|<<
literal|16
operator|)
operator||
operator|(
operator|(
name|reg
operator|&
literal|1
operator|)
operator|<<
literal|7
operator|)
expr_stmt|;
break|break;
case|case
name|VFP_REG_Sm
case|:
name|inst
operator|.
name|instruction
operator||=
operator|(
operator|(
name|reg
operator|>>
literal|1
operator|)
operator|<<
literal|0
operator|)
operator||
operator|(
operator|(
name|reg
operator|&
literal|1
operator|)
operator|<<
literal|5
operator|)
expr_stmt|;
break|break;
case|case
name|VFP_REG_Dd
case|:
name|inst
operator|.
name|instruction
operator||=
operator|(
operator|(
name|reg
operator|&
literal|15
operator|)
operator|<<
literal|12
operator|)
operator||
operator|(
operator|(
name|reg
operator|>>
literal|4
operator|)
operator|<<
literal|22
operator|)
expr_stmt|;
break|break;
case|case
name|VFP_REG_Dn
case|:
name|inst
operator|.
name|instruction
operator||=
operator|(
operator|(
name|reg
operator|&
literal|15
operator|)
operator|<<
literal|16
operator|)
operator||
operator|(
operator|(
name|reg
operator|>>
literal|4
operator|)
operator|<<
literal|7
operator|)
expr_stmt|;
break|break;
case|case
name|VFP_REG_Dm
case|:
name|inst
operator|.
name|instruction
operator||=
operator|(
name|reg
operator|&
literal|15
operator|)
operator||
operator|(
operator|(
name|reg
operator|>>
literal|4
operator|)
operator|<<
literal|5
operator|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Encode a<shift> in an ARM-format instruction.  The immediate,    if any, is handled by md_apply_fix.	 */
end_comment

begin_function
specifier|static
name|void
name|encode_arm_shift
parameter_list|(
name|int
name|i
parameter_list|)
block|{
if|if
condition|(
name|inst
operator|.
name|operands
index|[
name|i
index|]
operator|.
name|shift_kind
operator|==
name|SHIFT_RRX
condition|)
name|inst
operator|.
name|instruction
operator||=
name|SHIFT_ROR
operator|<<
literal|5
expr_stmt|;
else|else
block|{
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
name|i
index|]
operator|.
name|shift_kind
operator|<<
literal|5
expr_stmt|;
if|if
condition|(
name|inst
operator|.
name|operands
index|[
name|i
index|]
operator|.
name|immisreg
condition|)
block|{
name|inst
operator|.
name|instruction
operator||=
name|SHIFT_BY_REG
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
name|i
index|]
operator|.
name|imm
operator|<<
literal|8
expr_stmt|;
block|}
else|else
name|inst
operator|.
name|reloc
operator|.
name|type
operator|=
name|BFD_RELOC_ARM_SHIFT_IMM
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|encode_arm_shifter_operand
parameter_list|(
name|int
name|i
parameter_list|)
block|{
if|if
condition|(
name|inst
operator|.
name|operands
index|[
name|i
index|]
operator|.
name|isreg
condition|)
block|{
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
name|i
index|]
operator|.
name|reg
expr_stmt|;
name|encode_arm_shift
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
else|else
name|inst
operator|.
name|instruction
operator||=
name|INST_IMMEDIATE
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Subroutine of encode_arm_addr_mode_2 and encode_arm_addr_mode_3.  */
end_comment

begin_function
specifier|static
name|void
name|encode_arm_addr_mode_common
parameter_list|(
name|int
name|i
parameter_list|,
name|bfd_boolean
name|is_t
parameter_list|)
block|{
name|assert
argument_list|(
name|inst
operator|.
name|operands
index|[
name|i
index|]
operator|.
name|isreg
argument_list|)
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
name|i
index|]
operator|.
name|reg
operator|<<
literal|16
expr_stmt|;
if|if
condition|(
name|inst
operator|.
name|operands
index|[
name|i
index|]
operator|.
name|preind
condition|)
block|{
if|if
condition|(
name|is_t
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"instruction does not accept preindexed addressing"
argument_list|)
expr_stmt|;
return|return;
block|}
name|inst
operator|.
name|instruction
operator||=
name|PRE_INDEX
expr_stmt|;
if|if
condition|(
name|inst
operator|.
name|operands
index|[
name|i
index|]
operator|.
name|writeback
condition|)
name|inst
operator|.
name|instruction
operator||=
name|WRITE_BACK
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|inst
operator|.
name|operands
index|[
name|i
index|]
operator|.
name|postind
condition|)
block|{
name|assert
argument_list|(
name|inst
operator|.
name|operands
index|[
name|i
index|]
operator|.
name|writeback
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_t
condition|)
name|inst
operator|.
name|instruction
operator||=
name|WRITE_BACK
expr_stmt|;
block|}
else|else
comment|/* unindexed - only for coprocessor */
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"instruction does not accept unindexed addressing"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
operator|(
name|inst
operator|.
name|instruction
operator|&
name|WRITE_BACK
operator|)
operator|||
operator|!
operator|(
name|inst
operator|.
name|instruction
operator|&
name|PRE_INDEX
operator|)
operator|)
operator|&&
operator|(
operator|(
operator|(
name|inst
operator|.
name|instruction
operator|&
literal|0x000f0000
operator|)
operator|>>
literal|16
operator|)
operator|==
operator|(
operator|(
name|inst
operator|.
name|instruction
operator|&
literal|0x0000f000
operator|)
operator|>>
literal|12
operator|)
operator|)
condition|)
name|as_warn
argument_list|(
operator|(
name|inst
operator|.
name|instruction
operator|&
name|LOAD_BIT
operator|)
condition|?
name|_
argument_list|(
literal|"destination register same as write-back base"
argument_list|)
else|:
name|_
argument_list|(
literal|"source register same as write-back base"
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* inst.operands[i] was set up by parse_address.  Encode it into an    ARM-format mode 2 load or store instruction.	 If is_t is true,    reject forms that cannot be used with a T instruction (i.e. not    post-indexed).  */
end_comment

begin_function
specifier|static
name|void
name|encode_arm_addr_mode_2
parameter_list|(
name|int
name|i
parameter_list|,
name|bfd_boolean
name|is_t
parameter_list|)
block|{
name|encode_arm_addr_mode_common
argument_list|(
name|i
argument_list|,
name|is_t
argument_list|)
expr_stmt|;
if|if
condition|(
name|inst
operator|.
name|operands
index|[
name|i
index|]
operator|.
name|immisreg
condition|)
block|{
name|inst
operator|.
name|instruction
operator||=
name|INST_IMMEDIATE
expr_stmt|;
comment|/* yes, this is backwards */
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
name|i
index|]
operator|.
name|imm
expr_stmt|;
if|if
condition|(
operator|!
name|inst
operator|.
name|operands
index|[
name|i
index|]
operator|.
name|negative
condition|)
name|inst
operator|.
name|instruction
operator||=
name|INDEX_UP
expr_stmt|;
if|if
condition|(
name|inst
operator|.
name|operands
index|[
name|i
index|]
operator|.
name|shifted
condition|)
block|{
if|if
condition|(
name|inst
operator|.
name|operands
index|[
name|i
index|]
operator|.
name|shift_kind
operator|==
name|SHIFT_RRX
condition|)
name|inst
operator|.
name|instruction
operator||=
name|SHIFT_ROR
operator|<<
literal|5
expr_stmt|;
else|else
block|{
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
name|i
index|]
operator|.
name|shift_kind
operator|<<
literal|5
expr_stmt|;
name|inst
operator|.
name|reloc
operator|.
name|type
operator|=
name|BFD_RELOC_ARM_SHIFT_IMM
expr_stmt|;
block|}
block|}
block|}
else|else
comment|/* immediate offset in inst.reloc */
block|{
if|if
condition|(
name|inst
operator|.
name|reloc
operator|.
name|type
operator|==
name|BFD_RELOC_UNUSED
condition|)
name|inst
operator|.
name|reloc
operator|.
name|type
operator|=
name|BFD_RELOC_ARM_OFFSET_IMM
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* inst.operands[i] was set up by parse_address.  Encode it into an    ARM-format mode 3 load or store instruction.	 Reject forms that    cannot be used with such instructions.  If is_t is true, reject    forms that cannot be used with a T instruction (i.e. not    post-indexed).  */
end_comment

begin_function
specifier|static
name|void
name|encode_arm_addr_mode_3
parameter_list|(
name|int
name|i
parameter_list|,
name|bfd_boolean
name|is_t
parameter_list|)
block|{
if|if
condition|(
name|inst
operator|.
name|operands
index|[
name|i
index|]
operator|.
name|immisreg
operator|&&
name|inst
operator|.
name|operands
index|[
name|i
index|]
operator|.
name|shifted
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"instruction does not accept scaled register index"
argument_list|)
expr_stmt|;
return|return;
block|}
name|encode_arm_addr_mode_common
argument_list|(
name|i
argument_list|,
name|is_t
argument_list|)
expr_stmt|;
if|if
condition|(
name|inst
operator|.
name|operands
index|[
name|i
index|]
operator|.
name|immisreg
condition|)
block|{
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
name|i
index|]
operator|.
name|imm
expr_stmt|;
if|if
condition|(
operator|!
name|inst
operator|.
name|operands
index|[
name|i
index|]
operator|.
name|negative
condition|)
name|inst
operator|.
name|instruction
operator||=
name|INDEX_UP
expr_stmt|;
block|}
else|else
comment|/* immediate offset in inst.reloc */
block|{
name|inst
operator|.
name|instruction
operator||=
name|HWOFFSET_IMM
expr_stmt|;
if|if
condition|(
name|inst
operator|.
name|reloc
operator|.
name|type
operator|==
name|BFD_RELOC_UNUSED
condition|)
name|inst
operator|.
name|reloc
operator|.
name|type
operator|=
name|BFD_RELOC_ARM_OFFSET_IMM8
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* inst.operands[i] was set up by parse_address.  Encode it into an    ARM-format instruction.  Reject all forms which cannot be encoded    into a coprocessor load/store instruction.  If wb_ok is false,    reject use of writeback; if unind_ok is false, reject use of    unindexed addressing.  If reloc_override is not 0, use it instead    of BFD_ARM_CP_OFF_IMM, unless the initial relocation is a group one    (in which case it is preserved).  */
end_comment

begin_function
specifier|static
name|int
name|encode_arm_cp_address
parameter_list|(
name|int
name|i
parameter_list|,
name|int
name|wb_ok
parameter_list|,
name|int
name|unind_ok
parameter_list|,
name|int
name|reloc_override
parameter_list|)
block|{
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
name|i
index|]
operator|.
name|reg
operator|<<
literal|16
expr_stmt|;
name|assert
argument_list|(
operator|!
operator|(
name|inst
operator|.
name|operands
index|[
name|i
index|]
operator|.
name|preind
operator|&&
name|inst
operator|.
name|operands
index|[
name|i
index|]
operator|.
name|postind
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|inst
operator|.
name|operands
index|[
name|i
index|]
operator|.
name|preind
operator|&&
operator|!
name|inst
operator|.
name|operands
index|[
name|i
index|]
operator|.
name|postind
condition|)
comment|/* unindexed */
block|{
name|assert
argument_list|(
operator|!
name|inst
operator|.
name|operands
index|[
name|i
index|]
operator|.
name|writeback
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|unind_ok
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"instruction does not support unindexed addressing"
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
block|}
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
name|i
index|]
operator|.
name|imm
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|INDEX_UP
expr_stmt|;
return|return
name|SUCCESS
return|;
block|}
if|if
condition|(
name|inst
operator|.
name|operands
index|[
name|i
index|]
operator|.
name|preind
condition|)
name|inst
operator|.
name|instruction
operator||=
name|PRE_INDEX
expr_stmt|;
if|if
condition|(
name|inst
operator|.
name|operands
index|[
name|i
index|]
operator|.
name|writeback
condition|)
block|{
if|if
condition|(
name|inst
operator|.
name|operands
index|[
name|i
index|]
operator|.
name|reg
operator|==
name|REG_PC
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"pc may not be used with write-back"
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
block|}
if|if
condition|(
operator|!
name|wb_ok
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"instruction does not support writeback"
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
block|}
name|inst
operator|.
name|instruction
operator||=
name|WRITE_BACK
expr_stmt|;
block|}
if|if
condition|(
name|reloc_override
condition|)
name|inst
operator|.
name|reloc
operator|.
name|type
operator|=
name|reloc_override
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|inst
operator|.
name|reloc
operator|.
name|type
operator|<
name|BFD_RELOC_ARM_ALU_PC_G0_NC
operator|||
name|inst
operator|.
name|reloc
operator|.
name|type
operator|>
name|BFD_RELOC_ARM_LDC_SB_G2
operator|)
operator|&&
name|inst
operator|.
name|reloc
operator|.
name|type
operator|!=
name|BFD_RELOC_ARM_LDR_PC_G0
condition|)
block|{
if|if
condition|(
name|thumb_mode
condition|)
name|inst
operator|.
name|reloc
operator|.
name|type
operator|=
name|BFD_RELOC_ARM_T32_CP_OFF_IMM
expr_stmt|;
else|else
name|inst
operator|.
name|reloc
operator|.
name|type
operator|=
name|BFD_RELOC_ARM_CP_OFF_IMM
expr_stmt|;
block|}
return|return
name|SUCCESS
return|;
block|}
end_function

begin_comment
comment|/* inst.reloc.exp describes an "=expr" load pseudo-operation.    Determine whether it can be performed with a move instruction; if    it can, convert inst.instruction to that move instruction and    return 1; if it can't, convert inst.instruction to a literal-pool    load and return 0.  If this is not a valid thing to do in the    current context, set inst.error and return 1.     inst.operands[i] describes the destination register.	 */
end_comment

begin_function
specifier|static
name|int
name|move_or_literal_pool
parameter_list|(
name|int
name|i
parameter_list|,
name|bfd_boolean
name|thumb_p
parameter_list|,
name|bfd_boolean
name|mode_3
parameter_list|)
block|{
name|unsigned
name|long
name|tbit
decl_stmt|;
if|if
condition|(
name|thumb_p
condition|)
name|tbit
operator|=
operator|(
name|inst
operator|.
name|instruction
operator|>
literal|0xffff
operator|)
condition|?
name|THUMB2_LOAD_BIT
else|:
name|THUMB_LOAD_BIT
expr_stmt|;
else|else
name|tbit
operator|=
name|LOAD_BIT
expr_stmt|;
if|if
condition|(
operator|(
name|inst
operator|.
name|instruction
operator|&
name|tbit
operator|)
operator|==
literal|0
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"invalid pseudo operation"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_op
operator|!=
name|O_constant
operator|&&
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_op
operator|!=
name|O_symbol
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"constant expression expected"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_op
operator|==
name|O_constant
condition|)
block|{
if|if
condition|(
name|thumb_p
condition|)
block|{
if|if
condition|(
operator|!
name|unified_syntax
operator|&&
operator|(
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_add_number
operator|&
operator|~
literal|0xFF
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* This can be done with a mov(1) instruction.  */
name|inst
operator|.
name|instruction
operator|=
name|T_OPCODE_MOV_I8
operator||
operator|(
name|inst
operator|.
name|operands
index|[
name|i
index|]
operator|.
name|reg
operator|<<
literal|8
operator|)
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_add_number
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
else|else
block|{
name|int
name|value
init|=
name|encode_arm_immediate
argument_list|(
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_add_number
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|!=
name|FAIL
condition|)
block|{
comment|/* This can be done with a mov instruction.  */
name|inst
operator|.
name|instruction
operator|&=
name|LITERAL_MASK
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|INST_IMMEDIATE
operator||
operator|(
name|OPCODE_MOV
operator|<<
name|DATA_OP_SHIFT
operator|)
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|value
operator|&
literal|0xfff
expr_stmt|;
return|return
literal|1
return|;
block|}
name|value
operator|=
name|encode_arm_immediate
argument_list|(
operator|~
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_add_number
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|!=
name|FAIL
condition|)
block|{
comment|/* This can be done with a mvn instruction.  */
name|inst
operator|.
name|instruction
operator|&=
name|LITERAL_MASK
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|INST_IMMEDIATE
operator||
operator|(
name|OPCODE_MVN
operator|<<
name|DATA_OP_SHIFT
operator|)
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|value
operator|&
literal|0xfff
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
block|}
if|if
condition|(
name|add_to_lit_pool
argument_list|()
operator|==
name|FAIL
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"literal pool insertion failed"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
operator|=
name|REG_PC
expr_stmt|;
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|isreg
operator|=
literal|1
expr_stmt|;
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|preind
operator|=
literal|1
expr_stmt|;
name|inst
operator|.
name|reloc
operator|.
name|pc_rel
operator|=
literal|1
expr_stmt|;
name|inst
operator|.
name|reloc
operator|.
name|type
operator|=
operator|(
name|thumb_p
condition|?
name|BFD_RELOC_ARM_THUMB_OFFSET
else|:
operator|(
name|mode_3
condition|?
name|BFD_RELOC_ARM_HWLITERAL
else|:
name|BFD_RELOC_ARM_LITERAL
operator|)
operator|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Functions for instruction encoding, sorted by subarchitecture.    First some generics; their names are taken from the conventional    bit positions for register arguments in ARM format instructions.  */
end_comment

begin_function
specifier|static
name|void
name|do_noargs
parameter_list|(
name|void
parameter_list|)
block|{ }
end_function

begin_function
specifier|static
name|void
name|do_rd
parameter_list|(
name|void
parameter_list|)
block|{
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
operator|<<
literal|12
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_rd_rm
parameter_list|(
name|void
parameter_list|)
block|{
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
operator|<<
literal|12
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_rd_rn
parameter_list|(
name|void
parameter_list|)
block|{
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
operator|<<
literal|12
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
operator|<<
literal|16
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_rn_rd
parameter_list|(
name|void
parameter_list|)
block|{
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
operator|<<
literal|16
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
operator|<<
literal|12
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_rd_rm_rn
parameter_list|(
name|void
parameter_list|)
block|{
name|unsigned
name|Rn
init|=
name|inst
operator|.
name|operands
index|[
literal|2
index|]
operator|.
name|reg
decl_stmt|;
comment|/* Enforce restrictions on SWP instruction.  */
if|if
condition|(
operator|(
name|inst
operator|.
name|instruction
operator|&
literal|0x0fbfffff
operator|)
operator|==
literal|0x01000090
condition|)
name|constraint
argument_list|(
name|Rn
operator|==
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
operator|||
name|Rn
operator|==
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
argument_list|,
name|_
argument_list|(
literal|"Rn must not overlap other operands"
argument_list|)
argument_list|)
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
operator|<<
literal|12
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|Rn
operator|<<
literal|16
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_rd_rn_rm
parameter_list|(
name|void
parameter_list|)
block|{
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
operator|<<
literal|12
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
operator|<<
literal|16
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|2
index|]
operator|.
name|reg
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_rm_rd_rn
parameter_list|(
name|void
parameter_list|)
block|{
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
operator|<<
literal|12
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|2
index|]
operator|.
name|reg
operator|<<
literal|16
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_imm0
parameter_list|(
name|void
parameter_list|)
block|{
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|imm
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_rd_cpaddr
parameter_list|(
name|void
parameter_list|)
block|{
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
operator|<<
literal|12
expr_stmt|;
name|encode_arm_cp_address
argument_list|(
literal|1
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ARM instructions, in alphabetical order by function name (except    that wrapper functions appear immediately after the function they    wrap).  */
end_comment

begin_comment
comment|/* This is a pseudo-op of the form "adr rd, label" to be converted    into a relative address of the form "add rd, pc, #label-.-8".  */
end_comment

begin_function
specifier|static
name|void
name|do_adr
parameter_list|(
name|void
parameter_list|)
block|{
name|inst
operator|.
name|instruction
operator||=
operator|(
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
operator|<<
literal|12
operator|)
expr_stmt|;
comment|/* Rd */
comment|/* Frag hacking will turn this into a sub instruction if the offset turns      out to be negative.  */
name|inst
operator|.
name|reloc
operator|.
name|type
operator|=
name|BFD_RELOC_ARM_IMMEDIATE
expr_stmt|;
name|inst
operator|.
name|reloc
operator|.
name|pc_rel
operator|=
literal|1
expr_stmt|;
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_add_number
operator|-=
literal|8
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This is a pseudo-op of the form "adrl rd, label" to be converted    into a relative address of the form:    add rd, pc, #low(label-.-8)"    add rd, rd, #high(label-.-8)"  */
end_comment

begin_function
specifier|static
name|void
name|do_adrl
parameter_list|(
name|void
parameter_list|)
block|{
name|inst
operator|.
name|instruction
operator||=
operator|(
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
operator|<<
literal|12
operator|)
expr_stmt|;
comment|/* Rd */
comment|/* Frag hacking will turn this into a sub instruction if the offset turns      out to be negative.  */
name|inst
operator|.
name|reloc
operator|.
name|type
operator|=
name|BFD_RELOC_ARM_ADRL_IMMEDIATE
expr_stmt|;
name|inst
operator|.
name|reloc
operator|.
name|pc_rel
operator|=
literal|1
expr_stmt|;
name|inst
operator|.
name|size
operator|=
name|INSN_SIZE
operator|*
literal|2
expr_stmt|;
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_add_number
operator|-=
literal|8
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_arit
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|present
condition|)
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
operator|=
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
operator|<<
literal|12
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
operator|<<
literal|16
expr_stmt|;
name|encode_arm_shifter_operand
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_barrier
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|present
condition|)
block|{
name|constraint
argument_list|(
operator|(
name|inst
operator|.
name|instruction
operator|&
literal|0xf0
operator|)
operator|!=
literal|0x40
operator|&&
operator|(
name|inst
operator|.
name|instruction
operator|&
literal|0xf0
operator|)
operator|!=
literal|0x50
operator|&&
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|imm
operator|!=
literal|0xf
argument_list|,
literal|"bad barrier type"
argument_list|)
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|imm
expr_stmt|;
block|}
else|else
name|inst
operator|.
name|instruction
operator||=
literal|0xf
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_bfc
parameter_list|(
name|void
parameter_list|)
block|{
name|unsigned
name|int
name|msb
init|=
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|imm
operator|+
name|inst
operator|.
name|operands
index|[
literal|2
index|]
operator|.
name|imm
decl_stmt|;
name|constraint
argument_list|(
name|msb
operator|>
literal|32
argument_list|,
name|_
argument_list|(
literal|"bit-field extends past end of register"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* The instruction encoding stores the LSB and MSB,      not the LSB and width.  */
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
operator|<<
literal|12
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|imm
operator|<<
literal|7
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
operator|(
name|msb
operator|-
literal|1
operator|)
operator|<<
literal|16
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_bfi
parameter_list|(
name|void
parameter_list|)
block|{
name|unsigned
name|int
name|msb
decl_stmt|;
comment|/* #0 in second position is alternative syntax for bfc, which is      the same instruction but with REG_PC in the Rm field.  */
if|if
condition|(
operator|!
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|isreg
condition|)
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
operator|=
name|REG_PC
expr_stmt|;
name|msb
operator|=
name|inst
operator|.
name|operands
index|[
literal|2
index|]
operator|.
name|imm
operator|+
name|inst
operator|.
name|operands
index|[
literal|3
index|]
operator|.
name|imm
expr_stmt|;
name|constraint
argument_list|(
name|msb
operator|>
literal|32
argument_list|,
name|_
argument_list|(
literal|"bit-field extends past end of register"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* The instruction encoding stores the LSB and MSB,      not the LSB and width.  */
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
operator|<<
literal|12
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|2
index|]
operator|.
name|imm
operator|<<
literal|7
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
operator|(
name|msb
operator|-
literal|1
operator|)
operator|<<
literal|16
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_bfx
parameter_list|(
name|void
parameter_list|)
block|{
name|constraint
argument_list|(
name|inst
operator|.
name|operands
index|[
literal|2
index|]
operator|.
name|imm
operator|+
name|inst
operator|.
name|operands
index|[
literal|3
index|]
operator|.
name|imm
operator|>
literal|32
argument_list|,
name|_
argument_list|(
literal|"bit-field extends past end of register"
argument_list|)
argument_list|)
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
operator|<<
literal|12
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|2
index|]
operator|.
name|imm
operator|<<
literal|7
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
operator|(
name|inst
operator|.
name|operands
index|[
literal|3
index|]
operator|.
name|imm
operator|-
literal|1
operator|)
operator|<<
literal|16
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ARM V5 breakpoint instruction (argument parse)      BKPT<16 bit unsigned immediate>      Instruction is not conditional. 	The bit pattern given in insns[] has the COND_ALWAYS condition, 	and it is an error if the caller tried to override that.  */
end_comment

begin_function
specifier|static
name|void
name|do_bkpt
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* Top 12 of 16 bits to bits 19:8.  */
name|inst
operator|.
name|instruction
operator||=
operator|(
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|imm
operator|&
literal|0xfff0
operator|)
operator|<<
literal|4
expr_stmt|;
comment|/* Bottom 4 of 16 bits to bits 3:0.  */
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|imm
operator|&
literal|0xf
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|encode_branch
parameter_list|(
name|int
name|default_reloc
parameter_list|)
block|{
if|if
condition|(
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|hasreloc
condition|)
block|{
name|constraint
argument_list|(
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|imm
operator|!=
name|BFD_RELOC_ARM_PLT32
argument_list|,
name|_
argument_list|(
literal|"the only suffix valid here is '(plt)'"
argument_list|)
argument_list|)
expr_stmt|;
name|inst
operator|.
name|reloc
operator|.
name|type
operator|=
name|BFD_RELOC_ARM_PLT32
expr_stmt|;
block|}
else|else
block|{
name|inst
operator|.
name|reloc
operator|.
name|type
operator|=
name|default_reloc
expr_stmt|;
block|}
name|inst
operator|.
name|reloc
operator|.
name|pc_rel
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_branch
parameter_list|(
name|void
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|OBJ_ELF
if|if
condition|(
name|EF_ARM_EABI_VERSION
argument_list|(
name|meabi_flags
argument_list|)
operator|>=
name|EF_ARM_EABI_VER4
condition|)
name|encode_branch
argument_list|(
name|BFD_RELOC_ARM_PCREL_JUMP
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|encode_branch
argument_list|(
name|BFD_RELOC_ARM_PCREL_BRANCH
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_bl
parameter_list|(
name|void
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|OBJ_ELF
if|if
condition|(
name|EF_ARM_EABI_VERSION
argument_list|(
name|meabi_flags
argument_list|)
operator|>=
name|EF_ARM_EABI_VER4
condition|)
block|{
if|if
condition|(
name|inst
operator|.
name|cond
operator|==
name|COND_ALWAYS
condition|)
name|encode_branch
argument_list|(
name|BFD_RELOC_ARM_PCREL_CALL
argument_list|)
expr_stmt|;
else|else
name|encode_branch
argument_list|(
name|BFD_RELOC_ARM_PCREL_JUMP
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
name|encode_branch
argument_list|(
name|BFD_RELOC_ARM_PCREL_BRANCH
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ARM V5 branch-link-exchange instruction (argument parse)      BLX<target_addr>		ie BLX(1)      BLX{<condition>}<Rm>	ie BLX(2)    Unfortunately, there are two different opcodes for this mnemonic.    So, the insns[].value is not used, and the code here zaps values 	into inst.instruction.    Also, the<target_addr> can be 25 bits, hence has its own reloc.  */
end_comment

begin_function
specifier|static
name|void
name|do_blx
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|isreg
condition|)
block|{
comment|/* Arg is a register; the opcode provided by insns[] is correct. 	 It is not illegal to do "blx pc", just useless.  */
if|if
condition|(
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
operator|==
name|REG_PC
condition|)
name|as_tsktsk
argument_list|(
name|_
argument_list|(
literal|"use of r15 in blx in ARM mode is not really useful"
argument_list|)
argument_list|)
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
expr_stmt|;
block|}
else|else
block|{
comment|/* Arg is an address; this instruction cannot be executed 	 conditionally, and the opcode must be adjusted.  */
name|constraint
argument_list|(
name|inst
operator|.
name|cond
operator|!=
name|COND_ALWAYS
argument_list|,
name|BAD_COND
argument_list|)
expr_stmt|;
name|inst
operator|.
name|instruction
operator|=
literal|0xfa000000
expr_stmt|;
ifdef|#
directive|ifdef
name|OBJ_ELF
if|if
condition|(
name|EF_ARM_EABI_VERSION
argument_list|(
name|meabi_flags
argument_list|)
operator|>=
name|EF_ARM_EABI_VER4
condition|)
name|encode_branch
argument_list|(
name|BFD_RELOC_ARM_PCREL_CALL
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|encode_branch
argument_list|(
name|BFD_RELOC_ARM_PCREL_BLX
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|do_bx
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
operator|==
name|REG_PC
condition|)
name|as_tsktsk
argument_list|(
name|_
argument_list|(
literal|"use of r15 in bx in ARM mode is not really useful"
argument_list|)
argument_list|)
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ARM v5TEJ.  Jump to Jazelle code.  */
end_comment

begin_function
specifier|static
name|void
name|do_bxj
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
operator|==
name|REG_PC
condition|)
name|as_tsktsk
argument_list|(
name|_
argument_list|(
literal|"use of r15 in bxj is not really useful"
argument_list|)
argument_list|)
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Co-processor data operation:       CDP{cond}<coproc>,<opcode_1>,<CRd>,<CRn>,<CRm>{,<opcode_2>}       CDP2<coproc>,<opcode_1>,<CRd>,<CRn>,<CRm>{,<opcode_2>}	 */
end_comment

begin_function
specifier|static
name|void
name|do_cdp
parameter_list|(
name|void
parameter_list|)
block|{
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
operator|<<
literal|8
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|imm
operator|<<
literal|20
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|2
index|]
operator|.
name|reg
operator|<<
literal|12
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|3
index|]
operator|.
name|reg
operator|<<
literal|16
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|4
index|]
operator|.
name|reg
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|5
index|]
operator|.
name|imm
operator|<<
literal|5
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_cmp
parameter_list|(
name|void
parameter_list|)
block|{
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
operator|<<
literal|16
expr_stmt|;
name|encode_arm_shifter_operand
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Transfer between coprocessor and ARM registers.    MRC{cond}<coproc>,<opcode_1>,<Rd>,<CRn>,<CRm>{,<opcode_2>}    MRC2    MCR{cond}    MCR2     No special properties.  */
end_comment

begin_function
specifier|static
name|void
name|do_co_reg
parameter_list|(
name|void
parameter_list|)
block|{
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
operator|<<
literal|8
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|imm
operator|<<
literal|21
expr_stmt|;
comment|/* If this is a vector we are using the APSR_nzcv syntax, encode as r15 */
if|if
condition|(
name|inst
operator|.
name|operands
index|[
literal|2
index|]
operator|.
name|isvec
operator|!=
literal|0
condition|)
name|inst
operator|.
name|instruction
operator||=
literal|15
operator|<<
literal|12
expr_stmt|;
else|else
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|2
index|]
operator|.
name|reg
operator|<<
literal|12
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|3
index|]
operator|.
name|reg
operator|<<
literal|16
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|4
index|]
operator|.
name|reg
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|5
index|]
operator|.
name|imm
operator|<<
literal|5
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Transfer between coprocessor register and pair of ARM registers.    MCRR{cond}<coproc>,<opcode>,<Rd>,<Rn>,<CRm>.    MCRR2    MRRC{cond}    MRRC2     Two XScale instructions are special cases of these:       MAR{cond} acc0,<RdLo>,<RdHi> == MCRR{cond} p0, #0,<RdLo>,<RdHi>, c0      MRA{cond} acc0,<RdLo>,<RdHi> == MRRC{cond} p0, #0,<RdLo>,<RdHi>, c0     Result unpredicatable if Rd or Rn is R15.  */
end_comment

begin_function
specifier|static
name|void
name|do_co_reg2c
parameter_list|(
name|void
parameter_list|)
block|{
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
operator|<<
literal|8
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|imm
operator|<<
literal|4
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|2
index|]
operator|.
name|reg
operator|<<
literal|12
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|3
index|]
operator|.
name|reg
operator|<<
literal|16
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|4
index|]
operator|.
name|reg
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_cpsi
parameter_list|(
name|void
parameter_list|)
block|{
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|imm
operator|<<
literal|6
expr_stmt|;
if|if
condition|(
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|present
condition|)
block|{
name|inst
operator|.
name|instruction
operator||=
name|CPSI_MMOD
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|imm
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|do_dbg
parameter_list|(
name|void
parameter_list|)
block|{
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|imm
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_it
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* There is no IT instruction in ARM mode.  We      process it but do not generate code for it.  */
name|inst
operator|.
name|size
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_ldmstm
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|base_reg
init|=
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
decl_stmt|;
name|int
name|range
init|=
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|imm
decl_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|base_reg
operator|<<
literal|16
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|range
expr_stmt|;
if|if
condition|(
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|writeback
condition|)
name|inst
operator|.
name|instruction
operator||=
name|LDM_TYPE_2_OR_3
expr_stmt|;
if|if
condition|(
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|writeback
condition|)
block|{
name|inst
operator|.
name|instruction
operator||=
name|WRITE_BACK
expr_stmt|;
comment|/* Check for unpredictable uses of writeback.  */
if|if
condition|(
name|inst
operator|.
name|instruction
operator|&
name|LOAD_BIT
condition|)
block|{
comment|/* Not allowed in LDM type 2.	 */
if|if
condition|(
operator|(
name|inst
operator|.
name|instruction
operator|&
name|LDM_TYPE_2_OR_3
operator|)
operator|&&
operator|(
operator|(
name|range
operator|&
operator|(
literal|1
operator|<<
name|REG_PC
operator|)
operator|)
operator|==
literal|0
operator|)
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"writeback of base register is UNPREDICTABLE"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Only allowed if base reg not in list for other types.  */
elseif|else
if|if
condition|(
name|range
operator|&
operator|(
literal|1
operator|<<
name|base_reg
operator|)
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"writeback of base register when in register list is UNPREDICTABLE"
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* STM.  */
block|{
comment|/* Not allowed for type 2.  */
if|if
condition|(
name|inst
operator|.
name|instruction
operator|&
name|LDM_TYPE_2_OR_3
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"writeback of base register is UNPREDICTABLE"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Only allowed if base reg not in list, or first in list.  */
elseif|else
if|if
condition|(
operator|(
name|range
operator|&
operator|(
literal|1
operator|<<
name|base_reg
operator|)
operator|)
operator|&&
operator|(
name|range
operator|&
operator|(
operator|(
literal|1
operator|<<
name|base_reg
operator|)
operator|-
literal|1
operator|)
operator|)
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"if writeback register is in list, it must be the lowest reg in the list"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* ARMv5TE load-consecutive (argument parse)    Mode is like LDRH.       LDRccD R, mode      STRccD R, mode.  */
end_comment

begin_function
specifier|static
name|void
name|do_ldrd
parameter_list|(
name|void
parameter_list|)
block|{
name|constraint
argument_list|(
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
operator|%
literal|2
operator|!=
literal|0
argument_list|,
name|_
argument_list|(
literal|"first destination register must be even"
argument_list|)
argument_list|)
expr_stmt|;
name|constraint
argument_list|(
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|present
operator|&&
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
operator|!=
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
operator|+
literal|1
argument_list|,
name|_
argument_list|(
literal|"can only load two consecutive registers"
argument_list|)
argument_list|)
expr_stmt|;
name|constraint
argument_list|(
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
operator|==
name|REG_LR
argument_list|,
name|_
argument_list|(
literal|"r14 not allowed here"
argument_list|)
argument_list|)
expr_stmt|;
name|constraint
argument_list|(
operator|!
name|inst
operator|.
name|operands
index|[
literal|2
index|]
operator|.
name|isreg
argument_list|,
name|_
argument_list|(
literal|"'[' expected"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|present
condition|)
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
operator|=
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|inst
operator|.
name|instruction
operator|&
name|LOAD_BIT
condition|)
block|{
comment|/* encode_arm_addr_mode_3 will diagnose overlap between the base 	 register and the first register written; we have to diagnose 	 overlap between the base and the second register written here.	 */
if|if
condition|(
name|inst
operator|.
name|operands
index|[
literal|2
index|]
operator|.
name|reg
operator|==
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
operator|&&
operator|(
name|inst
operator|.
name|operands
index|[
literal|2
index|]
operator|.
name|writeback
operator|||
name|inst
operator|.
name|operands
index|[
literal|2
index|]
operator|.
name|postind
operator|)
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"base register written back, and overlaps "
literal|"second destination register"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* For an index-register load, the index register must not overlap the 	 destination (even if not write-back).	*/
elseif|else
if|if
condition|(
name|inst
operator|.
name|operands
index|[
literal|2
index|]
operator|.
name|immisreg
operator|&&
operator|(
operator|(
name|unsigned
operator|)
name|inst
operator|.
name|operands
index|[
literal|2
index|]
operator|.
name|imm
operator|==
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
operator|||
operator|(
name|unsigned
operator|)
name|inst
operator|.
name|operands
index|[
literal|2
index|]
operator|.
name|imm
operator|==
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
operator|)
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"index register overlaps destination register"
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
operator|<<
literal|12
expr_stmt|;
name|encode_arm_addr_mode_3
argument_list|(
literal|2
argument_list|,
comment|/*is_t=*/
name|FALSE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_ldrex
parameter_list|(
name|void
parameter_list|)
block|{
name|constraint
argument_list|(
operator|!
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|isreg
operator|||
operator|!
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|preind
operator|||
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|postind
operator|||
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|writeback
operator|||
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|immisreg
operator|||
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|shifted
operator|||
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|negative
comment|/* This can arise if the programmer has written 		   strex rN, rM, foo 		 or if they have mistakenly used a register name as the last 		 operand,  eg: 		   strex rN, rM, rX 		 It is very difficult to distinguish between these two cases 		 because "rX" might actually be a label. ie the register 		 name has been occluded by a symbol of the same name. So we 		 just generate a general 'bad addressing mode' type error 		 message and leave it up to the programmer to discover the 		 true cause and fix their mistake.  */
operator|||
operator|(
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
operator|==
name|REG_PC
operator|)
argument_list|,
name|BAD_ADDR_MODE
argument_list|)
expr_stmt|;
name|constraint
argument_list|(
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_op
operator|!=
name|O_constant
operator|||
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_add_number
operator|!=
literal|0
argument_list|,
name|_
argument_list|(
literal|"offset must be zero in ARM encoding"
argument_list|)
argument_list|)
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
operator|<<
literal|12
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
operator|<<
literal|16
expr_stmt|;
name|inst
operator|.
name|reloc
operator|.
name|type
operator|=
name|BFD_RELOC_UNUSED
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_ldrexd
parameter_list|(
name|void
parameter_list|)
block|{
name|constraint
argument_list|(
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
operator|%
literal|2
operator|!=
literal|0
argument_list|,
name|_
argument_list|(
literal|"even register required"
argument_list|)
argument_list|)
expr_stmt|;
name|constraint
argument_list|(
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|present
operator|&&
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
operator|!=
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
operator|+
literal|1
argument_list|,
name|_
argument_list|(
literal|"can only load two consecutive registers"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If op 1 were present and equal to PC, this function wouldn't      have been called in the first place.  */
name|constraint
argument_list|(
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
operator|==
name|REG_LR
argument_list|,
name|_
argument_list|(
literal|"r14 not allowed here"
argument_list|)
argument_list|)
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
operator|<<
literal|12
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|2
index|]
operator|.
name|reg
operator|<<
literal|16
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_ldst
parameter_list|(
name|void
parameter_list|)
block|{
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
operator|<<
literal|12
expr_stmt|;
if|if
condition|(
operator|!
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|isreg
condition|)
if|if
condition|(
name|move_or_literal_pool
argument_list|(
literal|0
argument_list|,
comment|/*thumb_p=*/
name|FALSE
argument_list|,
comment|/*mode_3=*/
name|FALSE
argument_list|)
condition|)
return|return;
name|encode_arm_addr_mode_2
argument_list|(
literal|1
argument_list|,
comment|/*is_t=*/
name|FALSE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_ldstt
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* ldrt/strt always use post-indexed addressing.  Turn [Rn] into [Rn]! and      reject [Rn,...].  */
if|if
condition|(
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|preind
condition|)
block|{
name|constraint
argument_list|(
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_op
operator|!=
name|O_constant
operator|||
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_add_number
operator|!=
literal|0
argument_list|,
name|_
argument_list|(
literal|"this instruction requires a post-indexed address"
argument_list|)
argument_list|)
expr_stmt|;
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|preind
operator|=
literal|0
expr_stmt|;
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|postind
operator|=
literal|1
expr_stmt|;
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|writeback
operator|=
literal|1
expr_stmt|;
block|}
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
operator|<<
literal|12
expr_stmt|;
name|encode_arm_addr_mode_2
argument_list|(
literal|1
argument_list|,
comment|/*is_t=*/
name|TRUE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Halfword and signed-byte load/store operations.  */
end_comment

begin_function
specifier|static
name|void
name|do_ldstv4
parameter_list|(
name|void
parameter_list|)
block|{
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
operator|<<
literal|12
expr_stmt|;
if|if
condition|(
operator|!
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|isreg
condition|)
if|if
condition|(
name|move_or_literal_pool
argument_list|(
literal|0
argument_list|,
comment|/*thumb_p=*/
name|FALSE
argument_list|,
comment|/*mode_3=*/
name|TRUE
argument_list|)
condition|)
return|return;
name|encode_arm_addr_mode_3
argument_list|(
literal|1
argument_list|,
comment|/*is_t=*/
name|FALSE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_ldsttv4
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* ldrt/strt always use post-indexed addressing.  Turn [Rn] into [Rn]! and      reject [Rn,...].  */
if|if
condition|(
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|preind
condition|)
block|{
name|constraint
argument_list|(
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_op
operator|!=
name|O_constant
operator|||
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_add_number
operator|!=
literal|0
argument_list|,
name|_
argument_list|(
literal|"this instruction requires a post-indexed address"
argument_list|)
argument_list|)
expr_stmt|;
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|preind
operator|=
literal|0
expr_stmt|;
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|postind
operator|=
literal|1
expr_stmt|;
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|writeback
operator|=
literal|1
expr_stmt|;
block|}
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
operator|<<
literal|12
expr_stmt|;
name|encode_arm_addr_mode_3
argument_list|(
literal|1
argument_list|,
comment|/*is_t=*/
name|TRUE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Co-processor register load/store.    Format:<LDC|STC>{cond}[L] CP#,CRd,<address>	 */
end_comment

begin_function
specifier|static
name|void
name|do_lstc
parameter_list|(
name|void
parameter_list|)
block|{
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
operator|<<
literal|8
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
operator|<<
literal|12
expr_stmt|;
name|encode_arm_cp_address
argument_list|(
literal|2
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_mlas
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* This restriction does not apply to mls (nor to mla in v6 or later).  */
if|if
condition|(
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
operator|==
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
operator|&&
operator|!
name|ARM_CPU_HAS_FEATURE
argument_list|(
name|selected_cpu
argument_list|,
name|arm_ext_v6
argument_list|)
operator|&&
operator|!
operator|(
name|inst
operator|.
name|instruction
operator|&
literal|0x00400000
operator|)
condition|)
name|as_tsktsk
argument_list|(
name|_
argument_list|(
literal|"Rd and Rm should be different in mla"
argument_list|)
argument_list|)
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
operator|<<
literal|16
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|2
index|]
operator|.
name|reg
operator|<<
literal|8
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|3
index|]
operator|.
name|reg
operator|<<
literal|12
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_mov
parameter_list|(
name|void
parameter_list|)
block|{
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
operator|<<
literal|12
expr_stmt|;
name|encode_arm_shifter_operand
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ARM V6T2 16-bit immediate register load: MOV[WT]{cond} Rd, #<imm16>.	 */
end_comment

begin_function
specifier|static
name|void
name|do_mov16
parameter_list|(
name|void
parameter_list|)
block|{
name|bfd_vma
name|imm
decl_stmt|;
name|bfd_boolean
name|top
decl_stmt|;
name|top
operator|=
operator|(
name|inst
operator|.
name|instruction
operator|&
literal|0x00400000
operator|)
operator|!=
literal|0
expr_stmt|;
name|constraint
argument_list|(
name|top
operator|&&
name|inst
operator|.
name|reloc
operator|.
name|type
operator|==
name|BFD_RELOC_ARM_MOVW
argument_list|,
name|_
argument_list|(
literal|":lower16: not allowed this instruction"
argument_list|)
argument_list|)
expr_stmt|;
name|constraint
argument_list|(
operator|!
name|top
operator|&&
name|inst
operator|.
name|reloc
operator|.
name|type
operator|==
name|BFD_RELOC_ARM_MOVT
argument_list|,
name|_
argument_list|(
literal|":upper16: not allowed instruction"
argument_list|)
argument_list|)
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
operator|<<
literal|12
expr_stmt|;
if|if
condition|(
name|inst
operator|.
name|reloc
operator|.
name|type
operator|==
name|BFD_RELOC_UNUSED
condition|)
block|{
name|imm
operator|=
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_add_number
expr_stmt|;
comment|/* The value is in two pieces: 0:11, 16:19.  */
name|inst
operator|.
name|instruction
operator||=
operator|(
name|imm
operator|&
literal|0x00000fff
operator|)
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
operator|(
name|imm
operator|&
literal|0x0000f000
operator|)
operator|<<
literal|4
expr_stmt|;
block|}
block|}
end_function

begin_function_decl
specifier|static
name|void
name|do_vfp_nsyn_opcode
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|int
name|do_vfp_nsyn_mrs
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|isvec
condition|)
block|{
if|if
condition|(
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
operator|!=
literal|1
condition|)
name|first_error
argument_list|(
name|_
argument_list|(
literal|"operand 1 must be FPSCR"
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|inst
operator|.
name|operands
index|[
literal|0
index|]
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
name|inst
operator|.
name|operands
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|inst
operator|.
name|operands
index|[
literal|1
index|]
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
name|inst
operator|.
name|operands
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|do_vfp_nsyn_opcode
argument_list|(
literal|"fmstat"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|isvec
condition|)
name|do_vfp_nsyn_opcode
argument_list|(
literal|"fmrx"
argument_list|)
expr_stmt|;
else|else
return|return
name|FAIL
return|;
return|return
name|SUCCESS
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|do_vfp_nsyn_msr
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|isvec
condition|)
name|do_vfp_nsyn_opcode
argument_list|(
literal|"fmxr"
argument_list|)
expr_stmt|;
else|else
return|return
name|FAIL
return|;
return|return
name|SUCCESS
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_vfp_vmrs
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|rt
decl_stmt|;
comment|/* The destination register can be r0-r14 or APSR_nzcv */
if|if
condition|(
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
operator|>
literal|14
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|BAD_PC
expr_stmt|;
return|return;
block|}
comment|/* If the destination is r13 and not in ARM mode then unprefictable */
if|if
condition|(
name|thumb_mode
operator|&&
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
operator|==
name|REG_SP
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|BAD_SP
expr_stmt|;
return|return;
block|}
comment|/* If the destination is APSR_nzcv */
if|if
condition|(
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|isvec
operator|&&
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
operator|!=
literal|1
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|BAD_VMRS
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|isvec
condition|)
name|rt
operator|=
literal|15
expr_stmt|;
else|else
name|rt
operator|=
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
expr_stmt|;
comment|/* Or in the registers to use */
name|inst
operator|.
name|instruction
operator||=
name|rt
operator|<<
literal|12
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
operator|<<
literal|16
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_vfp_vmsr
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* The destination register can be r0-r14 or APSR_nzcv */
if|if
condition|(
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
operator|>
literal|14
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|BAD_PC
expr_stmt|;
return|return;
block|}
comment|/* If the destination is r13 and not in ARM mode then unprefictable */
if|if
condition|(
name|thumb_mode
operator|&&
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
operator|==
name|REG_SP
condition|)
block|{
name|inst
operator|.
name|error
operator|=
name|BAD_SP
expr_stmt|;
return|return;
block|}
comment|/* Or in the registers to use */
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
operator|<<
literal|12
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
operator|<<
literal|16
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_mrs
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|do_vfp_nsyn_mrs
argument_list|()
operator|==
name|SUCCESS
condition|)
return|return;
comment|/* mrs only accepts CPSR/SPSR/CPSR_all/SPSR_all.  */
name|constraint
argument_list|(
operator|(
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|imm
operator|&
operator|(
name|PSR_c
operator||
name|PSR_x
operator||
name|PSR_s
operator||
name|PSR_f
operator|)
operator|)
operator|!=
operator|(
name|PSR_c
operator||
name|PSR_f
operator|)
argument_list|,
name|_
argument_list|(
literal|"'CPSR' or 'SPSR' expected"
argument_list|)
argument_list|)
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
operator|<<
literal|12
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
operator|(
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|imm
operator|&
name|SPSR_BIT
operator|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Two possible forms:       "{C|S}PSR_<field>, Rm",       "{C|S}PSR_f, #expression".  */
end_comment

begin_function
specifier|static
name|void
name|do_msr
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|do_vfp_nsyn_msr
argument_list|()
operator|==
name|SUCCESS
condition|)
return|return;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|imm
expr_stmt|;
if|if
condition|(
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|isreg
condition|)
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
expr_stmt|;
else|else
block|{
name|inst
operator|.
name|instruction
operator||=
name|INST_IMMEDIATE
expr_stmt|;
name|inst
operator|.
name|reloc
operator|.
name|type
operator|=
name|BFD_RELOC_ARM_IMMEDIATE
expr_stmt|;
name|inst
operator|.
name|reloc
operator|.
name|pc_rel
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|do_mul
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
name|inst
operator|.
name|operands
index|[
literal|2
index|]
operator|.
name|present
condition|)
name|inst
operator|.
name|operands
index|[
literal|2
index|]
operator|.
name|reg
operator|=
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
operator|<<
literal|16
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|2
index|]
operator|.
name|reg
operator|<<
literal|8
expr_stmt|;
if|if
condition|(
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
operator|==
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
operator|&&
operator|!
name|ARM_CPU_HAS_FEATURE
argument_list|(
name|selected_cpu
argument_list|,
name|arm_ext_v6
argument_list|)
condition|)
name|as_tsktsk
argument_list|(
name|_
argument_list|(
literal|"Rd and Rm should be different in mul"
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Long Multiply Parser    UMULL RdLo, RdHi, Rm, Rs    SMULL RdLo, RdHi, Rm, Rs    UMLAL RdLo, RdHi, Rm, Rs    SMLAL RdLo, RdHi, Rm, Rs.  */
end_comment

begin_function
specifier|static
name|void
name|do_mull
parameter_list|(
name|void
parameter_list|)
block|{
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
operator|<<
literal|12
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
operator|<<
literal|16
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|2
index|]
operator|.
name|reg
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|3
index|]
operator|.
name|reg
operator|<<
literal|8
expr_stmt|;
comment|/* rdhi, rdlo and rm must all be different prior to ARMv6.  */
if|if
condition|(
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
operator|==
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
operator|||
operator|(
operator|(
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
operator|==
name|inst
operator|.
name|operands
index|[
literal|2
index|]
operator|.
name|reg
operator|||
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
operator|==
name|inst
operator|.
name|operands
index|[
literal|2
index|]
operator|.
name|reg
operator|)
operator|&&
operator|!
name|ARM_CPU_HAS_FEATURE
argument_list|(
name|selected_cpu
argument_list|,
name|arm_ext_v6
argument_list|)
operator|)
condition|)
name|as_tsktsk
argument_list|(
name|_
argument_list|(
literal|"rdhi, rdlo and rm must all be different"
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_nop
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|present
condition|)
block|{
comment|/* Architectural NOP hints are CPSR sets with no bits selected.  */
name|inst
operator|.
name|instruction
operator|&=
literal|0xf0000000
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
literal|0x0320f000
operator|+
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|imm
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ARM V6 Pack Halfword Bottom Top instruction (argument parse).    PKHBT {<cond>}<Rd>,<Rn>,<Rm> {, LSL #<shift_imm>}    Condition defaults to COND_ALWAYS.    Error if Rd, Rn or Rm are R15.  */
end_comment

begin_function
specifier|static
name|void
name|do_pkhbt
parameter_list|(
name|void
parameter_list|)
block|{
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
operator|<<
literal|12
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
operator|<<
literal|16
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|2
index|]
operator|.
name|reg
expr_stmt|;
if|if
condition|(
name|inst
operator|.
name|operands
index|[
literal|3
index|]
operator|.
name|present
condition|)
name|encode_arm_shift
argument_list|(
literal|3
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ARM V6 PKHTB (Argument Parse).  */
end_comment

begin_function
specifier|static
name|void
name|do_pkhtb
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
name|inst
operator|.
name|operands
index|[
literal|3
index|]
operator|.
name|present
condition|)
block|{
comment|/* If the shift specifier is omitted, turn the instruction 	 into pkhbt rd, rm, rn. */
name|inst
operator|.
name|instruction
operator|&=
literal|0xfff00010
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
operator|<<
literal|12
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|2
index|]
operator|.
name|reg
operator|<<
literal|16
expr_stmt|;
block|}
else|else
block|{
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
operator|<<
literal|12
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
operator|<<
literal|16
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|2
index|]
operator|.
name|reg
expr_stmt|;
name|encode_arm_shift
argument_list|(
literal|3
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ARMv5TE: Preload-Cache      PLD<addr_mode>    Syntactically, like LDR with B=1, W=0, L=1.  */
end_comment

begin_function
specifier|static
name|void
name|do_pld
parameter_list|(
name|void
parameter_list|)
block|{
name|constraint
argument_list|(
operator|!
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|isreg
argument_list|,
name|_
argument_list|(
literal|"'[' expected after PLD mnemonic"
argument_list|)
argument_list|)
expr_stmt|;
name|constraint
argument_list|(
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|postind
argument_list|,
name|_
argument_list|(
literal|"post-indexed expression used in preload instruction"
argument_list|)
argument_list|)
expr_stmt|;
name|constraint
argument_list|(
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|writeback
argument_list|,
name|_
argument_list|(
literal|"writeback used in preload instruction"
argument_list|)
argument_list|)
expr_stmt|;
name|constraint
argument_list|(
operator|!
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|preind
argument_list|,
name|_
argument_list|(
literal|"unindexed addressing used in preload instruction"
argument_list|)
argument_list|)
expr_stmt|;
name|encode_arm_addr_mode_2
argument_list|(
literal|0
argument_list|,
comment|/*is_t=*/
name|FALSE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ARMv7: PLI<addr_mode>  */
end_comment

begin_function
specifier|static
name|void
name|do_pli
parameter_list|(
name|void
parameter_list|)
block|{
name|constraint
argument_list|(
operator|!
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|isreg
argument_list|,
name|_
argument_list|(
literal|"'[' expected after PLI mnemonic"
argument_list|)
argument_list|)
expr_stmt|;
name|constraint
argument_list|(
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|postind
argument_list|,
name|_
argument_list|(
literal|"post-indexed expression used in preload instruction"
argument_list|)
argument_list|)
expr_stmt|;
name|constraint
argument_list|(
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|writeback
argument_list|,
name|_
argument_list|(
literal|"writeback used in preload instruction"
argument_list|)
argument_list|)
expr_stmt|;
name|constraint
argument_list|(
operator|!
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|preind
argument_list|,
name|_
argument_list|(
literal|"unindexed addressing used in preload instruction"
argument_list|)
argument_list|)
expr_stmt|;
name|encode_arm_addr_mode_2
argument_list|(
literal|0
argument_list|,
comment|/*is_t=*/
name|FALSE
argument_list|)
expr_stmt|;
name|inst
operator|.
name|instruction
operator|&=
operator|~
name|PRE_INDEX
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_push_pop
parameter_list|(
name|void
parameter_list|)
block|{
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|=
name|inst
operator|.
name|operands
index|[
literal|0
index|]
expr_stmt|;
name|memset
argument_list|(
operator|&
name|inst
operator|.
name|operands
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|inst
operator|.
name|operands
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|isreg
operator|=
literal|1
expr_stmt|;
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|writeback
operator|=
literal|1
expr_stmt|;
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
operator|=
name|REG_SP
expr_stmt|;
name|do_ldmstm
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ARM V6 RFE (Return from Exception) loads the PC and CPSR from the    word at the specified address and the following word    respectively.    Unconditionally executed.    Error if Rn is R15.	*/
end_comment

begin_function
specifier|static
name|void
name|do_rfe
parameter_list|(
name|void
parameter_list|)
block|{
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
operator|<<
literal|16
expr_stmt|;
if|if
condition|(
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|writeback
condition|)
name|inst
operator|.
name|instruction
operator||=
name|WRITE_BACK
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ARM V6 ssat (argument parse).  */
end_comment

begin_function
specifier|static
name|void
name|do_ssat
parameter_list|(
name|void
parameter_list|)
block|{
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
operator|<<
literal|12
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
operator|(
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|imm
operator|-
literal|1
operator|)
operator|<<
literal|16
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|2
index|]
operator|.
name|reg
expr_stmt|;
if|if
condition|(
name|inst
operator|.
name|operands
index|[
literal|3
index|]
operator|.
name|present
condition|)
name|encode_arm_shift
argument_list|(
literal|3
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ARM V6 usat (argument parse).  */
end_comment

begin_function
specifier|static
name|void
name|do_usat
parameter_list|(
name|void
parameter_list|)
block|{
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
operator|<<
literal|12
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|imm
operator|<<
literal|16
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|2
index|]
operator|.
name|reg
expr_stmt|;
if|if
condition|(
name|inst
operator|.
name|operands
index|[
literal|3
index|]
operator|.
name|present
condition|)
name|encode_arm_shift
argument_list|(
literal|3
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ARM V6 ssat16 (argument parse).  */
end_comment

begin_function
specifier|static
name|void
name|do_ssat16
parameter_list|(
name|void
parameter_list|)
block|{
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
operator|<<
literal|12
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
operator|(
operator|(
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|imm
operator|-
literal|1
operator|)
operator|<<
literal|16
operator|)
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|2
index|]
operator|.
name|reg
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_usat16
parameter_list|(
name|void
parameter_list|)
block|{
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
operator|<<
literal|12
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|imm
operator|<<
literal|16
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|2
index|]
operator|.
name|reg
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ARM V6 SETEND (argument parse).  Sets the E bit in the CPSR while    preserving the other bits.     setend<endian_specifier>, where<endian_specifier> is either    BE or LE.  */
end_comment

begin_function
specifier|static
name|void
name|do_setend
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|imm
condition|)
name|inst
operator|.
name|instruction
operator||=
literal|0x200
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_shift
parameter_list|(
name|void
parameter_list|)
block|{
name|unsigned
name|int
name|Rm
init|=
operator|(
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|present
condition|?
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
else|:
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
operator|)
decl_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
operator|<<
literal|12
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|Rm
expr_stmt|;
if|if
condition|(
name|inst
operator|.
name|operands
index|[
literal|2
index|]
operator|.
name|isreg
condition|)
comment|/* Rd, {Rm,} Rs */
block|{
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|2
index|]
operator|.
name|reg
operator|<<
literal|8
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|SHIFT_BY_REG
expr_stmt|;
block|}
else|else
name|inst
operator|.
name|reloc
operator|.
name|type
operator|=
name|BFD_RELOC_ARM_SHIFT_IMM
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_smc
parameter_list|(
name|void
parameter_list|)
block|{
name|inst
operator|.
name|reloc
operator|.
name|type
operator|=
name|BFD_RELOC_ARM_SMC
expr_stmt|;
name|inst
operator|.
name|reloc
operator|.
name|pc_rel
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_swi
parameter_list|(
name|void
parameter_list|)
block|{
name|inst
operator|.
name|reloc
operator|.
name|type
operator|=
name|BFD_RELOC_ARM_SWI
expr_stmt|;
name|inst
operator|.
name|reloc
operator|.
name|pc_rel
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ARM V5E (El Segundo) signed-multiply-accumulate (argument parse)    SMLAxy{cond} Rd,Rm,Rs,Rn    SMLAWy{cond} Rd,Rm,Rs,Rn    Error if any register is R15.  */
end_comment

begin_function
specifier|static
name|void
name|do_smla
parameter_list|(
name|void
parameter_list|)
block|{
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
operator|<<
literal|16
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|2
index|]
operator|.
name|reg
operator|<<
literal|8
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|3
index|]
operator|.
name|reg
operator|<<
literal|12
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ARM V5E (El Segundo) signed-multiply-accumulate-long (argument parse)    SMLALxy{cond} Rdlo,Rdhi,Rm,Rs    Error if any register is R15.    Warning if Rdlo == Rdhi.  */
end_comment

begin_function
specifier|static
name|void
name|do_smlal
parameter_list|(
name|void
parameter_list|)
block|{
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
operator|<<
literal|12
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
operator|<<
literal|16
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|2
index|]
operator|.
name|reg
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|3
index|]
operator|.
name|reg
operator|<<
literal|8
expr_stmt|;
if|if
condition|(
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
operator|==
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
condition|)
name|as_tsktsk
argument_list|(
name|_
argument_list|(
literal|"rdhi and rdlo must be different"
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ARM V5E (El Segundo) signed-multiply (argument parse)    SMULxy{cond} Rd,Rm,Rs    Error if any register is R15.  */
end_comment

begin_function
specifier|static
name|void
name|do_smul
parameter_list|(
name|void
parameter_list|)
block|{
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
operator|<<
literal|16
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|2
index|]
operator|.
name|reg
operator|<<
literal|8
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ARM V6 srs (argument parse).  The variable fields in the encoding are    the same for both ARM and Thumb-2.  */
end_comment

begin_function
specifier|static
name|void
name|do_srs
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|reg
decl_stmt|;
if|if
condition|(
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|present
condition|)
block|{
name|reg
operator|=
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
expr_stmt|;
name|constraint
argument_list|(
name|reg
operator|!=
literal|13
argument_list|,
name|_
argument_list|(
literal|"SRS base register must be r13"
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|reg
operator|=
literal|13
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|reg
operator|<<
literal|16
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|imm
expr_stmt|;
if|if
condition|(
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|writeback
operator|||
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|writeback
condition|)
name|inst
operator|.
name|instruction
operator||=
name|WRITE_BACK
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ARM V6 strex (argument parse).  */
end_comment

begin_function
specifier|static
name|void
name|do_strex
parameter_list|(
name|void
parameter_list|)
block|{
name|constraint
argument_list|(
operator|!
name|inst
operator|.
name|operands
index|[
literal|2
index|]
operator|.
name|isreg
operator|||
operator|!
name|inst
operator|.
name|operands
index|[
literal|2
index|]
operator|.
name|preind
operator|||
name|inst
operator|.
name|operands
index|[
literal|2
index|]
operator|.
name|postind
operator|||
name|inst
operator|.
name|operands
index|[
literal|2
index|]
operator|.
name|writeback
operator|||
name|inst
operator|.
name|operands
index|[
literal|2
index|]
operator|.
name|immisreg
operator|||
name|inst
operator|.
name|operands
index|[
literal|2
index|]
operator|.
name|shifted
operator|||
name|inst
operator|.
name|operands
index|[
literal|2
index|]
operator|.
name|negative
comment|/* See comment in do_ldrex().  */
operator|||
operator|(
name|inst
operator|.
name|operands
index|[
literal|2
index|]
operator|.
name|reg
operator|==
name|REG_PC
operator|)
argument_list|,
name|BAD_ADDR_MODE
argument_list|)
expr_stmt|;
name|constraint
argument_list|(
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
operator|==
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
operator|||
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
operator|==
name|inst
operator|.
name|operands
index|[
literal|2
index|]
operator|.
name|reg
argument_list|,
name|BAD_OVERLAP
argument_list|)
expr_stmt|;
name|constraint
argument_list|(
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_op
operator|!=
name|O_constant
operator|||
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_add_number
operator|!=
literal|0
argument_list|,
name|_
argument_list|(
literal|"offset must be zero in ARM encoding"
argument_list|)
argument_list|)
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
operator|<<
literal|12
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|2
index|]
operator|.
name|reg
operator|<<
literal|16
expr_stmt|;
name|inst
operator|.
name|reloc
operator|.
name|type
operator|=
name|BFD_RELOC_UNUSED
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_strexd
parameter_list|(
name|void
parameter_list|)
block|{
name|constraint
argument_list|(
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
operator|%
literal|2
operator|!=
literal|0
argument_list|,
name|_
argument_list|(
literal|"even register required"
argument_list|)
argument_list|)
expr_stmt|;
name|constraint
argument_list|(
name|inst
operator|.
name|operands
index|[
literal|2
index|]
operator|.
name|present
operator|&&
name|inst
operator|.
name|operands
index|[
literal|2
index|]
operator|.
name|reg
operator|!=
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
operator|+
literal|1
argument_list|,
name|_
argument_list|(
literal|"can only store two consecutive registers"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If op 2 were present and equal to PC, this function wouldn't      have been called in the first place.  */
name|constraint
argument_list|(
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
operator|==
name|REG_LR
argument_list|,
name|_
argument_list|(
literal|"r14 not allowed here"
argument_list|)
argument_list|)
expr_stmt|;
name|constraint
argument_list|(
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
operator|==
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
operator|||
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
operator|==
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
operator|+
literal|1
operator|||
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
operator|==
name|inst
operator|.
name|operands
index|[
literal|3
index|]
operator|.
name|reg
argument_list|,
name|BAD_OVERLAP
argument_list|)
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
operator|<<
literal|12
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|3
index|]
operator|.
name|reg
operator|<<
literal|16
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ARM V6 SXTAH extracts a 16-bit value from a register, sign    extends it to 32-bits, and adds the result to a value in another    register.  You can specify a rotation by 0, 8, 16, or 24 bits    before extracting the 16-bit value.    SXTAH{<cond>}<Rd>,<Rn>,<Rm>{,<rotation>}    Condition defaults to COND_ALWAYS.    Error if any register uses R15.  */
end_comment

begin_function
specifier|static
name|void
name|do_sxtah
parameter_list|(
name|void
parameter_list|)
block|{
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
operator|<<
literal|12
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
operator|<<
literal|16
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|2
index|]
operator|.
name|reg
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|3
index|]
operator|.
name|imm
operator|<<
literal|10
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ARM V6 SXTH.     SXTH {<cond>}<Rd>,<Rm>{,<rotation>}    Condition defaults to COND_ALWAYS.    Error if any register uses R15.  */
end_comment

begin_function
specifier|static
name|void
name|do_sxth
parameter_list|(
name|void
parameter_list|)
block|{
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
operator|<<
literal|12
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|2
index|]
operator|.
name|imm
operator|<<
literal|10
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* VFP instructions.  In a logical order: SP variant first, monad    before dyad, arithmetic then move then load/store.  */
end_comment

begin_function
specifier|static
name|void
name|do_vfp_sp_monadic
parameter_list|(
name|void
parameter_list|)
block|{
name|encode_arm_vfp_reg
argument_list|(
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
argument_list|,
name|VFP_REG_Sd
argument_list|)
expr_stmt|;
name|encode_arm_vfp_reg
argument_list|(
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
argument_list|,
name|VFP_REG_Sm
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_vfp_sp_dyadic
parameter_list|(
name|void
parameter_list|)
block|{
name|encode_arm_vfp_reg
argument_list|(
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
argument_list|,
name|VFP_REG_Sd
argument_list|)
expr_stmt|;
name|encode_arm_vfp_reg
argument_list|(
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
argument_list|,
name|VFP_REG_Sn
argument_list|)
expr_stmt|;
name|encode_arm_vfp_reg
argument_list|(
name|inst
operator|.
name|operands
index|[
literal|2
index|]
operator|.
name|reg
argument_list|,
name|VFP_REG_Sm
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_vfp_sp_compare_z
parameter_list|(
name|void
parameter_list|)
block|{
name|encode_arm_vfp_reg
argument_list|(
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
argument_list|,
name|VFP_REG_Sd
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_vfp_dp_sp_cvt
parameter_list|(
name|void
parameter_list|)
block|{
name|encode_arm_vfp_reg
argument_list|(
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
argument_list|,
name|VFP_REG_Dd
argument_list|)
expr_stmt|;
name|encode_arm_vfp_reg
argument_list|(
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
argument_list|,
name|VFP_REG_Sm
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_vfp_sp_dp_cvt
parameter_list|(
name|void
parameter_list|)
block|{
name|encode_arm_vfp_reg
argument_list|(
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
argument_list|,
name|VFP_REG_Sd
argument_list|)
expr_stmt|;
name|encode_arm_vfp_reg
argument_list|(
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
argument_list|,
name|VFP_REG_Dm
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_vfp_reg_from_sp
parameter_list|(
name|void
parameter_list|)
block|{
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
operator|<<
literal|12
expr_stmt|;
name|encode_arm_vfp_reg
argument_list|(
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
argument_list|,
name|VFP_REG_Sn
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_vfp_reg2_from_sp2
parameter_list|(
name|void
parameter_list|)
block|{
name|constraint
argument_list|(
name|inst
operator|.
name|operands
index|[
literal|2
index|]
operator|.
name|imm
operator|!=
literal|2
argument_list|,
name|_
argument_list|(
literal|"only two consecutive VFP SP registers allowed here"
argument_list|)
argument_list|)
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
operator|<<
literal|12
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
operator|<<
literal|16
expr_stmt|;
name|encode_arm_vfp_reg
argument_list|(
name|inst
operator|.
name|operands
index|[
literal|2
index|]
operator|.
name|reg
argument_list|,
name|VFP_REG_Sm
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_vfp_sp_from_reg
parameter_list|(
name|void
parameter_list|)
block|{
name|encode_arm_vfp_reg
argument_list|(
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
argument_list|,
name|VFP_REG_Sn
argument_list|)
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
operator|<<
literal|12
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_vfp_sp2_from_reg2
parameter_list|(
name|void
parameter_list|)
block|{
name|constraint
argument_list|(
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|imm
operator|!=
literal|2
argument_list|,
name|_
argument_list|(
literal|"only two consecutive VFP SP registers allowed here"
argument_list|)
argument_list|)
expr_stmt|;
name|encode_arm_vfp_reg
argument_list|(
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
argument_list|,
name|VFP_REG_Sm
argument_list|)
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
operator|<<
literal|12
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|2
index|]
operator|.
name|reg
operator|<<
literal|16
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_vfp_sp_ldst
parameter_list|(
name|void
parameter_list|)
block|{
name|encode_arm_vfp_reg
argument_list|(
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
argument_list|,
name|VFP_REG_Sd
argument_list|)
expr_stmt|;
name|encode_arm_cp_address
argument_list|(
literal|1
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_vfp_dp_ldst
parameter_list|(
name|void
parameter_list|)
block|{
name|encode_arm_vfp_reg
argument_list|(
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
argument_list|,
name|VFP_REG_Dd
argument_list|)
expr_stmt|;
name|encode_arm_cp_address
argument_list|(
literal|1
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|vfp_sp_ldstm
parameter_list|(
name|enum
name|vfp_ldstm_type
name|ldstm_type
parameter_list|)
block|{
if|if
condition|(
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|writeback
condition|)
name|inst
operator|.
name|instruction
operator||=
name|WRITE_BACK
expr_stmt|;
else|else
name|constraint
argument_list|(
name|ldstm_type
operator|!=
name|VFP_LDSTMIA
argument_list|,
name|_
argument_list|(
literal|"this addressing mode requires base-register writeback"
argument_list|)
argument_list|)
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
operator|<<
literal|16
expr_stmt|;
name|encode_arm_vfp_reg
argument_list|(
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
argument_list|,
name|VFP_REG_Sd
argument_list|)
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|imm
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|vfp_dp_ldstm
parameter_list|(
name|enum
name|vfp_ldstm_type
name|ldstm_type
parameter_list|)
block|{
name|int
name|count
decl_stmt|;
if|if
condition|(
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|writeback
condition|)
name|inst
operator|.
name|instruction
operator||=
name|WRITE_BACK
expr_stmt|;
else|else
name|constraint
argument_list|(
name|ldstm_type
operator|!=
name|VFP_LDSTMIA
operator|&&
name|ldstm_type
operator|!=
name|VFP_LDSTMIAX
argument_list|,
name|_
argument_list|(
literal|"this addressing mode requires base-register writeback"
argument_list|)
argument_list|)
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
operator|<<
literal|16
expr_stmt|;
name|encode_arm_vfp_reg
argument_list|(
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
argument_list|,
name|VFP_REG_Dd
argument_list|)
expr_stmt|;
name|count
operator|=
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|imm
operator|<<
literal|1
expr_stmt|;
if|if
condition|(
name|ldstm_type
operator|==
name|VFP_LDSTMIAX
operator|||
name|ldstm_type
operator|==
name|VFP_LDSTMDBX
condition|)
name|count
operator|+=
literal|1
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|count
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_vfp_sp_ldstmia
parameter_list|(
name|void
parameter_list|)
block|{
name|vfp_sp_ldstm
argument_list|(
name|VFP_LDSTMIA
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_vfp_sp_ldstmdb
parameter_list|(
name|void
parameter_list|)
block|{
name|vfp_sp_ldstm
argument_list|(
name|VFP_LDSTMDB
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_vfp_dp_ldstmia
parameter_list|(
name|void
parameter_list|)
block|{
name|vfp_dp_ldstm
argument_list|(
name|VFP_LDSTMIA
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_vfp_dp_ldstmdb
parameter_list|(
name|void
parameter_list|)
block|{
name|vfp_dp_ldstm
argument_list|(
name|VFP_LDSTMDB
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_vfp_xp_ldstmia
parameter_list|(
name|void
parameter_list|)
block|{
name|vfp_dp_ldstm
argument_list|(
name|VFP_LDSTMIAX
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_vfp_xp_ldstmdb
parameter_list|(
name|void
parameter_list|)
block|{
name|vfp_dp_ldstm
argument_list|(
name|VFP_LDSTMDBX
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_vfp_dp_rd_rm
parameter_list|(
name|void
parameter_list|)
block|{
name|encode_arm_vfp_reg
argument_list|(
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
argument_list|,
name|VFP_REG_Dd
argument_list|)
expr_stmt|;
name|encode_arm_vfp_reg
argument_list|(
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
argument_list|,
name|VFP_REG_Dm
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_vfp_dp_rn_rd
parameter_list|(
name|void
parameter_list|)
block|{
name|encode_arm_vfp_reg
argument_list|(
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
argument_list|,
name|VFP_REG_Dn
argument_list|)
expr_stmt|;
name|encode_arm_vfp_reg
argument_list|(
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
argument_list|,
name|VFP_REG_Dd
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_vfp_dp_rd_rn
parameter_list|(
name|void
parameter_list|)
block|{
name|encode_arm_vfp_reg
argument_list|(
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
argument_list|,
name|VFP_REG_Dd
argument_list|)
expr_stmt|;
name|encode_arm_vfp_reg
argument_list|(
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
argument_list|,
name|VFP_REG_Dn
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_vfp_dp_rd_rn_rm
parameter_list|(
name|void
parameter_list|)
block|{
name|encode_arm_vfp_reg
argument_list|(
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
argument_list|,
name|VFP_REG_Dd
argument_list|)
expr_stmt|;
name|encode_arm_vfp_reg
argument_list|(
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
argument_list|,
name|VFP_REG_Dn
argument_list|)
expr_stmt|;
name|encode_arm_vfp_reg
argument_list|(
name|inst
operator|.
name|operands
index|[
literal|2
index|]
operator|.
name|reg
argument_list|,
name|VFP_REG_Dm
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_vfp_dp_rd
parameter_list|(
name|void
parameter_list|)
block|{
name|encode_arm_vfp_reg
argument_list|(
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
argument_list|,
name|VFP_REG_Dd
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_vfp_dp_rm_rd_rn
parameter_list|(
name|void
parameter_list|)
block|{
name|encode_arm_vfp_reg
argument_list|(
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
argument_list|,
name|VFP_REG_Dm
argument_list|)
expr_stmt|;
name|encode_arm_vfp_reg
argument_list|(
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
argument_list|,
name|VFP_REG_Dd
argument_list|)
expr_stmt|;
name|encode_arm_vfp_reg
argument_list|(
name|inst
operator|.
name|operands
index|[
literal|2
index|]
operator|.
name|reg
argument_list|,
name|VFP_REG_Dn
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* VFPv3 instructions.  */
end_comment

begin_function
specifier|static
name|void
name|do_vfp_sp_const
parameter_list|(
name|void
parameter_list|)
block|{
name|encode_arm_vfp_reg
argument_list|(
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
argument_list|,
name|VFP_REG_Sd
argument_list|)
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
operator|(
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|imm
operator|&
literal|0xf0
operator|)
operator|<<
literal|12
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
operator|(
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|imm
operator|&
literal|0x0f
operator|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_vfp_dp_const
parameter_list|(
name|void
parameter_list|)
block|{
name|encode_arm_vfp_reg
argument_list|(
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
argument_list|,
name|VFP_REG_Dd
argument_list|)
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
operator|(
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|imm
operator|&
literal|0xf0
operator|)
operator|<<
literal|12
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
operator|(
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|imm
operator|&
literal|0x0f
operator|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|vfp_conv
parameter_list|(
name|int
name|srcsize
parameter_list|)
block|{
name|unsigned
name|immbits
init|=
name|srcsize
operator|-
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|imm
decl_stmt|;
name|inst
operator|.
name|instruction
operator||=
operator|(
name|immbits
operator|&
literal|1
operator|)
operator|<<
literal|5
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
operator|(
name|immbits
operator|>>
literal|1
operator|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_vfp_sp_conv_16
parameter_list|(
name|void
parameter_list|)
block|{
name|encode_arm_vfp_reg
argument_list|(
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
argument_list|,
name|VFP_REG_Sd
argument_list|)
expr_stmt|;
name|vfp_conv
argument_list|(
literal|16
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_vfp_dp_conv_16
parameter_list|(
name|void
parameter_list|)
block|{
name|encode_arm_vfp_reg
argument_list|(
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
argument_list|,
name|VFP_REG_Dd
argument_list|)
expr_stmt|;
name|vfp_conv
argument_list|(
literal|16
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_vfp_sp_conv_32
parameter_list|(
name|void
parameter_list|)
block|{
name|encode_arm_vfp_reg
argument_list|(
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
argument_list|,
name|VFP_REG_Sd
argument_list|)
expr_stmt|;
name|vfp_conv
argument_list|(
literal|32
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_vfp_dp_conv_32
parameter_list|(
name|void
parameter_list|)
block|{
name|encode_arm_vfp_reg
argument_list|(
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
argument_list|,
name|VFP_REG_Dd
argument_list|)
expr_stmt|;
name|vfp_conv
argument_list|(
literal|32
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* FPA instructions.  Also in a logical order.	*/
end_comment

begin_function
specifier|static
name|void
name|do_fpa_cmp
parameter_list|(
name|void
parameter_list|)
block|{
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
operator|<<
literal|16
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_fpa_ldmstm
parameter_list|(
name|void
parameter_list|)
block|{
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
operator|<<
literal|12
expr_stmt|;
switch|switch
condition|(
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|imm
condition|)
block|{
case|case
literal|1
case|:
name|inst
operator|.
name|instruction
operator||=
name|CP_T_X
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|inst
operator|.
name|instruction
operator||=
name|CP_T_Y
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|inst
operator|.
name|instruction
operator||=
name|CP_T_Y
operator||
name|CP_T_X
expr_stmt|;
break|break;
case|case
literal|4
case|:
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|inst
operator|.
name|instruction
operator|&
operator|(
name|PRE_INDEX
operator||
name|INDEX_UP
operator|)
condition|)
block|{
comment|/* The instruction specified "ea" or "fd", so we can only accept 	 [Rn]{!}.  The instruction does not really support stacking or 	 unstacking, so we have to emulate these by setting appropriate 	 bits and offsets.  */
name|constraint
argument_list|(
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_op
operator|!=
name|O_constant
operator|||
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_add_number
operator|!=
literal|0
argument_list|,
name|_
argument_list|(
literal|"this instruction does not support indexing"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|inst
operator|.
name|instruction
operator|&
name|PRE_INDEX
operator|)
operator|||
name|inst
operator|.
name|operands
index|[
literal|2
index|]
operator|.
name|writeback
condition|)
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_add_number
operator|=
literal|12
operator|*
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|imm
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|inst
operator|.
name|instruction
operator|&
name|INDEX_UP
operator|)
condition|)
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_add_number
operator|=
operator|-
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_add_number
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|inst
operator|.
name|instruction
operator|&
name|PRE_INDEX
operator|)
operator|&&
name|inst
operator|.
name|operands
index|[
literal|2
index|]
operator|.
name|writeback
condition|)
block|{
name|inst
operator|.
name|operands
index|[
literal|2
index|]
operator|.
name|preind
operator|=
literal|0
expr_stmt|;
name|inst
operator|.
name|operands
index|[
literal|2
index|]
operator|.
name|postind
operator|=
literal|1
expr_stmt|;
block|}
block|}
name|encode_arm_cp_address
argument_list|(
literal|2
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* iWMMXt instructions: strictly in alphabetical order.	 */
end_comment

begin_function
specifier|static
name|void
name|do_iwmmxt_tandorc
parameter_list|(
name|void
parameter_list|)
block|{
name|constraint
argument_list|(
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
operator|!=
name|REG_PC
argument_list|,
name|_
argument_list|(
literal|"only r15 allowed here"
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_iwmmxt_textrc
parameter_list|(
name|void
parameter_list|)
block|{
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
operator|<<
literal|12
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|imm
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_iwmmxt_textrm
parameter_list|(
name|void
parameter_list|)
block|{
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
operator|<<
literal|12
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
operator|<<
literal|16
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|2
index|]
operator|.
name|imm
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_iwmmxt_tinsr
parameter_list|(
name|void
parameter_list|)
block|{
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
operator|<<
literal|16
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
operator|<<
literal|12
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|2
index|]
operator|.
name|imm
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_iwmmxt_tmia
parameter_list|(
name|void
parameter_list|)
block|{
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
operator|<<
literal|5
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|2
index|]
operator|.
name|reg
operator|<<
literal|12
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_iwmmxt_waligni
parameter_list|(
name|void
parameter_list|)
block|{
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
operator|<<
literal|12
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
operator|<<
literal|16
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|2
index|]
operator|.
name|reg
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|3
index|]
operator|.
name|imm
operator|<<
literal|20
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_iwmmxt_wmerge
parameter_list|(
name|void
parameter_list|)
block|{
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
operator|<<
literal|12
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
operator|<<
literal|16
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|2
index|]
operator|.
name|reg
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|3
index|]
operator|.
name|imm
operator|<<
literal|21
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_iwmmxt_wmov
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* WMOV rD, rN is an alias for WOR rD, rN, rN.  */
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
operator|<<
literal|12
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
operator|<<
literal|16
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_iwmmxt_wldstbh
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|reloc
decl_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
operator|<<
literal|12
expr_stmt|;
if|if
condition|(
name|thumb_mode
condition|)
name|reloc
operator|=
name|BFD_RELOC_ARM_T32_CP_OFF_IMM_S2
expr_stmt|;
else|else
name|reloc
operator|=
name|BFD_RELOC_ARM_CP_OFF_IMM_S2
expr_stmt|;
name|encode_arm_cp_address
argument_list|(
literal|1
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|,
name|reloc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_iwmmxt_wldstw
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* RIWR_RIWC clears .isreg for a control register.  */
if|if
condition|(
operator|!
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|isreg
condition|)
block|{
name|constraint
argument_list|(
name|inst
operator|.
name|cond
operator|!=
name|COND_ALWAYS
argument_list|,
name|BAD_COND
argument_list|)
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
literal|0xf0000000
expr_stmt|;
block|}
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
operator|<<
literal|12
expr_stmt|;
name|encode_arm_cp_address
argument_list|(
literal|1
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_iwmmxt_wldstd
parameter_list|(
name|void
parameter_list|)
block|{
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
operator|<<
literal|12
expr_stmt|;
if|if
condition|(
name|ARM_CPU_HAS_FEATURE
argument_list|(
name|cpu_variant
argument_list|,
name|arm_cext_iwmmxt2
argument_list|)
operator|&&
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|immisreg
condition|)
block|{
name|inst
operator|.
name|instruction
operator|&=
operator|~
literal|0x1a000ff
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
operator|(
literal|0xf
operator|<<
literal|28
operator|)
expr_stmt|;
if|if
condition|(
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|preind
condition|)
name|inst
operator|.
name|instruction
operator||=
name|PRE_INDEX
expr_stmt|;
if|if
condition|(
operator|!
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|negative
condition|)
name|inst
operator|.
name|instruction
operator||=
name|INDEX_UP
expr_stmt|;
if|if
condition|(
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|writeback
condition|)
name|inst
operator|.
name|instruction
operator||=
name|WRITE_BACK
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
operator|<<
literal|16
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_add_number
operator|<<
literal|4
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|imm
expr_stmt|;
block|}
else|else
name|encode_arm_cp_address
argument_list|(
literal|1
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_iwmmxt_wshufh
parameter_list|(
name|void
parameter_list|)
block|{
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
operator|<<
literal|12
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
operator|<<
literal|16
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
operator|(
operator|(
name|inst
operator|.
name|operands
index|[
literal|2
index|]
operator|.
name|imm
operator|&
literal|0xf0
operator|)
operator|<<
literal|16
operator|)
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
operator|(
name|inst
operator|.
name|operands
index|[
literal|2
index|]
operator|.
name|imm
operator|&
literal|0x0f
operator|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_iwmmxt_wzero
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* WZERO reg is an alias for WANDN reg, reg, reg.  */
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
operator|<<
literal|12
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
operator|<<
literal|16
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_iwmmxt_wrwrwr_or_imm5
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|inst
operator|.
name|operands
index|[
literal|2
index|]
operator|.
name|isreg
condition|)
name|do_rd_rn_rm
argument_list|()
expr_stmt|;
else|else
block|{
name|constraint
argument_list|(
operator|!
name|ARM_CPU_HAS_FEATURE
argument_list|(
name|cpu_variant
argument_list|,
name|arm_cext_iwmmxt2
argument_list|)
argument_list|,
name|_
argument_list|(
literal|"immediate operand requires iWMMXt2"
argument_list|)
argument_list|)
expr_stmt|;
name|do_rd_rn
argument_list|()
expr_stmt|;
if|if
condition|(
name|inst
operator|.
name|operands
index|[
literal|2
index|]
operator|.
name|imm
operator|==
literal|0
condition|)
block|{
switch|switch
condition|(
operator|(
name|inst
operator|.
name|instruction
operator|>>
literal|20
operator|)
operator|&
literal|0xf
condition|)
block|{
case|case
literal|4
case|:
case|case
literal|5
case|:
case|case
literal|6
case|:
case|case
literal|7
case|:
comment|/* w...h wrd, wrn, #0 -> wrorh wrd, wrn, #16.  */
name|inst
operator|.
name|operands
index|[
literal|2
index|]
operator|.
name|imm
operator|=
literal|16
expr_stmt|;
name|inst
operator|.
name|instruction
operator|=
operator|(
name|inst
operator|.
name|instruction
operator|&
literal|0xff0fffff
operator|)
operator||
operator|(
literal|0x7
operator|<<
literal|20
operator|)
expr_stmt|;
break|break;
case|case
literal|8
case|:
case|case
literal|9
case|:
case|case
literal|10
case|:
case|case
literal|11
case|:
comment|/* w...w wrd, wrn, #0 -> wrorw wrd, wrn, #32.  */
name|inst
operator|.
name|operands
index|[
literal|2
index|]
operator|.
name|imm
operator|=
literal|32
expr_stmt|;
name|inst
operator|.
name|instruction
operator|=
operator|(
name|inst
operator|.
name|instruction
operator|&
literal|0xff0fffff
operator|)
operator||
operator|(
literal|0xb
operator|<<
literal|20
operator|)
expr_stmt|;
break|break;
case|case
literal|12
case|:
case|case
literal|13
case|:
case|case
literal|14
case|:
case|case
literal|15
case|:
block|{
comment|/* w...d wrd, wrn, #0 -> wor wrd, wrn, wrn.  */
name|unsigned
name|long
name|wrn
decl_stmt|;
name|wrn
operator|=
operator|(
name|inst
operator|.
name|instruction
operator|>>
literal|16
operator|)
operator|&
literal|0xf
expr_stmt|;
name|inst
operator|.
name|instruction
operator|&=
literal|0xff0fff0f
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|wrn
expr_stmt|;
comment|/* Bail out here; the instruction is now assembled.  */
return|return;
block|}
block|}
block|}
comment|/* Map 32 -> 0, etc.  */
name|inst
operator|.
name|operands
index|[
literal|2
index|]
operator|.
name|imm
operator|&=
literal|0x1f
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
operator|(
literal|0xf
operator|<<
literal|28
operator|)
operator||
operator|(
operator|(
name|inst
operator|.
name|operands
index|[
literal|2
index|]
operator|.
name|imm
operator|&
literal|0x10
operator|)
operator|<<
literal|4
operator|)
operator||
operator|(
name|inst
operator|.
name|operands
index|[
literal|2
index|]
operator|.
name|imm
operator|&
literal|0xf
operator|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Cirrus Maverick instructions.  Simple 2-, 3-, and 4-register    operations first, then control, shift, and load/store.  */
end_comment

begin_comment
comment|/* Insns like "foo X,Y,Z".  */
end_comment

begin_function
specifier|static
name|void
name|do_mav_triple
parameter_list|(
name|void
parameter_list|)
block|{
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
operator|<<
literal|16
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|2
index|]
operator|.
name|reg
operator|<<
literal|12
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Insns like "foo W,X,Y,Z".     where W=MVAX[0:3] and X,Y,Z=MVFX[0:15].  */
end_comment

begin_function
specifier|static
name|void
name|do_mav_quad
parameter_list|(
name|void
parameter_list|)
block|{
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
operator|<<
literal|5
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
operator|<<
literal|12
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|2
index|]
operator|.
name|reg
operator|<<
literal|16
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|3
index|]
operator|.
name|reg
expr_stmt|;
block|}
end_function

begin_comment
comment|/* cfmvsc32<cond> DSPSC,MVDX[15:0].  */
end_comment

begin_function
specifier|static
name|void
name|do_mav_dspsc
parameter_list|(
name|void
parameter_list|)
block|{
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
operator|<<
literal|12
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Maverick shift immediate instructions.    cfsh32<cond> MVFX[15:0],MVFX[15:0],Shift[6:0].    cfsh64<cond> MVDX[15:0],MVDX[15:0],Shift[6:0].  */
end_comment

begin_function
specifier|static
name|void
name|do_mav_shift
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|imm
init|=
name|inst
operator|.
name|operands
index|[
literal|2
index|]
operator|.
name|imm
decl_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
operator|<<
literal|12
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
operator|<<
literal|16
expr_stmt|;
comment|/* Bits 0-3 of the insn should have bits 0-3 of the immediate.      Bits 5-7 of the insn should have bits 4-6 of the immediate.      Bit 4 should be 0.	 */
name|imm
operator|=
operator|(
name|imm
operator|&
literal|0xf
operator|)
operator||
operator|(
operator|(
name|imm
operator|&
literal|0x70
operator|)
operator|<<
literal|1
operator|)
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|imm
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* XScale instructions.	 Also sorted arithmetic before move.  */
end_comment

begin_comment
comment|/* Xscale multiply-accumulate (argument parse)      MIAcc   acc0,Rm,Rs      MIAPHcc acc0,Rm,Rs      MIAxycc acc0,Rm,Rs.  */
end_comment

begin_function
specifier|static
name|void
name|do_xsc_mia
parameter_list|(
name|void
parameter_list|)
block|{
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|2
index|]
operator|.
name|reg
operator|<<
literal|12
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Xscale move-accumulator-register (argument parse)       MARcc   acc0,RdLo,RdHi.  */
end_comment

begin_function
specifier|static
name|void
name|do_xsc_mar
parameter_list|(
name|void
parameter_list|)
block|{
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
operator|<<
literal|12
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|2
index|]
operator|.
name|reg
operator|<<
literal|16
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Xscale move-register-accumulator (argument parse)       MRAcc   RdLo,RdHi,acc0.  */
end_comment

begin_function
specifier|static
name|void
name|do_xsc_mra
parameter_list|(
name|void
parameter_list|)
block|{
name|constraint
argument_list|(
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
operator|==
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
argument_list|,
name|BAD_OVERLAP
argument_list|)
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
operator|<<
literal|12
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
operator|<<
literal|16
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Encoding functions relevant only to Thumb.  */
end_comment

begin_comment
comment|/* inst.operands[i] is a shifted-register operand; encode    it into inst.instruction in the format used by Thumb32.  */
end_comment

begin_function
specifier|static
name|void
name|encode_thumb32_shifted_operand
parameter_list|(
name|int
name|i
parameter_list|)
block|{
name|unsigned
name|int
name|value
init|=
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_add_number
decl_stmt|;
name|unsigned
name|int
name|shift
init|=
name|inst
operator|.
name|operands
index|[
name|i
index|]
operator|.
name|shift_kind
decl_stmt|;
name|constraint
argument_list|(
name|inst
operator|.
name|operands
index|[
name|i
index|]
operator|.
name|immisreg
argument_list|,
name|_
argument_list|(
literal|"shift by register not allowed in thumb mode"
argument_list|)
argument_list|)
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
name|i
index|]
operator|.
name|reg
expr_stmt|;
if|if
condition|(
name|shift
operator|==
name|SHIFT_RRX
condition|)
name|inst
operator|.
name|instruction
operator||=
name|SHIFT_ROR
operator|<<
literal|4
expr_stmt|;
else|else
block|{
name|constraint
argument_list|(
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_op
operator|!=
name|O_constant
argument_list|,
name|_
argument_list|(
literal|"expression too complex"
argument_list|)
argument_list|)
expr_stmt|;
name|constraint
argument_list|(
name|value
operator|>
literal|32
operator|||
operator|(
name|value
operator|==
literal|32
operator|&&
operator|(
name|shift
operator|==
name|SHIFT_LSL
operator|||
name|shift
operator|==
name|SHIFT_ROR
operator|)
operator|)
argument_list|,
name|_
argument_list|(
literal|"shift expression is too large"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|==
literal|0
condition|)
name|shift
operator|=
name|SHIFT_LSL
expr_stmt|;
elseif|else
if|if
condition|(
name|value
operator|==
literal|32
condition|)
name|value
operator|=
literal|0
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|shift
operator|<<
literal|4
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
operator|(
name|value
operator|&
literal|0x1c
operator|)
operator|<<
literal|10
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
operator|(
name|value
operator|&
literal|0x03
operator|)
operator|<<
literal|6
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* inst.operands[i] was set up by parse_address.  Encode it into a    Thumb32 format load or store instruction.  Reject forms that cannot    be used with such instructions.  If is_t is true, reject forms that    cannot be used with a T instruction; if is_d is true, reject forms    that cannot be used with a D instruction.  */
end_comment

begin_function
specifier|static
name|void
name|encode_thumb32_addr_mode
parameter_list|(
name|int
name|i
parameter_list|,
name|bfd_boolean
name|is_t
parameter_list|,
name|bfd_boolean
name|is_d
parameter_list|)
block|{
name|bfd_boolean
name|is_pc
init|=
operator|(
name|inst
operator|.
name|operands
index|[
name|i
index|]
operator|.
name|reg
operator|==
name|REG_PC
operator|)
decl_stmt|;
name|constraint
argument_list|(
operator|!
name|inst
operator|.
name|operands
index|[
name|i
index|]
operator|.
name|isreg
argument_list|,
name|_
argument_list|(
literal|"Instruction does not support =N addresses"
argument_list|)
argument_list|)
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
name|i
index|]
operator|.
name|reg
operator|<<
literal|16
expr_stmt|;
if|if
condition|(
name|inst
operator|.
name|operands
index|[
name|i
index|]
operator|.
name|immisreg
condition|)
block|{
name|constraint
argument_list|(
name|is_pc
argument_list|,
name|_
argument_list|(
literal|"cannot use register index with PC-relative addressing"
argument_list|)
argument_list|)
expr_stmt|;
name|constraint
argument_list|(
name|is_t
operator|||
name|is_d
argument_list|,
name|_
argument_list|(
literal|"cannot use register index with this instruction"
argument_list|)
argument_list|)
expr_stmt|;
name|constraint
argument_list|(
name|inst
operator|.
name|operands
index|[
name|i
index|]
operator|.
name|negative
argument_list|,
name|_
argument_list|(
literal|"Thumb does not support negative register indexing"
argument_list|)
argument_list|)
expr_stmt|;
name|constraint
argument_list|(
name|inst
operator|.
name|operands
index|[
name|i
index|]
operator|.
name|postind
argument_list|,
name|_
argument_list|(
literal|"Thumb does not support register post-indexing"
argument_list|)
argument_list|)
expr_stmt|;
name|constraint
argument_list|(
name|inst
operator|.
name|operands
index|[
name|i
index|]
operator|.
name|writeback
argument_list|,
name|_
argument_list|(
literal|"Thumb does not support register indexing with writeback"
argument_list|)
argument_list|)
expr_stmt|;
name|constraint
argument_list|(
name|inst
operator|.
name|operands
index|[
name|i
index|]
operator|.
name|shifted
operator|&&
name|inst
operator|.
name|operands
index|[
name|i
index|]
operator|.
name|shift_kind
operator|!=
name|SHIFT_LSL
argument_list|,
name|_
argument_list|(
literal|"Thumb supports only LSL in shifted register indexing"
argument_list|)
argument_list|)
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
name|i
index|]
operator|.
name|imm
expr_stmt|;
if|if
condition|(
name|inst
operator|.
name|operands
index|[
name|i
index|]
operator|.
name|shifted
condition|)
block|{
name|constraint
argument_list|(
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_op
operator|!=
name|O_constant
argument_list|,
name|_
argument_list|(
literal|"expression too complex"
argument_list|)
argument_list|)
expr_stmt|;
name|constraint
argument_list|(
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_add_number
operator|<
literal|0
operator|||
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_add_number
operator|>
literal|3
argument_list|,
name|_
argument_list|(
literal|"shift out of range"
argument_list|)
argument_list|)
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_add_number
operator|<<
literal|4
expr_stmt|;
block|}
name|inst
operator|.
name|reloc
operator|.
name|type
operator|=
name|BFD_RELOC_UNUSED
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|inst
operator|.
name|operands
index|[
name|i
index|]
operator|.
name|preind
condition|)
block|{
name|constraint
argument_list|(
name|is_pc
operator|&&
name|inst
operator|.
name|operands
index|[
name|i
index|]
operator|.
name|writeback
argument_list|,
name|_
argument_list|(
literal|"cannot use writeback with PC-relative addressing"
argument_list|)
argument_list|)
expr_stmt|;
name|constraint
argument_list|(
name|is_t
operator|&&
name|inst
operator|.
name|operands
index|[
name|i
index|]
operator|.
name|writeback
argument_list|,
name|_
argument_list|(
literal|"cannot use writeback with this instruction"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_d
condition|)
block|{
name|inst
operator|.
name|instruction
operator||=
literal|0x01000000
expr_stmt|;
if|if
condition|(
name|inst
operator|.
name|operands
index|[
name|i
index|]
operator|.
name|writeback
condition|)
name|inst
operator|.
name|instruction
operator||=
literal|0x00200000
expr_stmt|;
block|}
else|else
block|{
name|inst
operator|.
name|instruction
operator||=
literal|0x00000c00
expr_stmt|;
if|if
condition|(
name|inst
operator|.
name|operands
index|[
name|i
index|]
operator|.
name|writeback
condition|)
name|inst
operator|.
name|instruction
operator||=
literal|0x00000100
expr_stmt|;
block|}
name|inst
operator|.
name|reloc
operator|.
name|type
operator|=
name|BFD_RELOC_ARM_T32_OFFSET_IMM
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|inst
operator|.
name|operands
index|[
name|i
index|]
operator|.
name|postind
condition|)
block|{
name|assert
argument_list|(
name|inst
operator|.
name|operands
index|[
name|i
index|]
operator|.
name|writeback
argument_list|)
expr_stmt|;
name|constraint
argument_list|(
name|is_pc
argument_list|,
name|_
argument_list|(
literal|"cannot use post-indexing with PC-relative addressing"
argument_list|)
argument_list|)
expr_stmt|;
name|constraint
argument_list|(
name|is_t
argument_list|,
name|_
argument_list|(
literal|"cannot use post-indexing with this instruction"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_d
condition|)
name|inst
operator|.
name|instruction
operator||=
literal|0x00200000
expr_stmt|;
else|else
name|inst
operator|.
name|instruction
operator||=
literal|0x00000900
expr_stmt|;
name|inst
operator|.
name|reloc
operator|.
name|type
operator|=
name|BFD_RELOC_ARM_T32_OFFSET_IMM
expr_stmt|;
block|}
else|else
comment|/* unindexed - only for coprocessor */
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"instruction does not accept unindexed addressing"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Table of Thumb instructions which exist in both 16- and 32-bit    encodings (the latter only in post-V6T2 cores).  The index is the    value used in the insns table below.  When there is more than one    possible 16-bit encoding for the instruction, this table always    holds variant (1).    Also contains several pseudo-instructions used during relaxation.  */
end_comment

begin_define
define|#
directive|define
name|T16_32_TAB
define|\
value|X(adc,   4140, eb400000),			\   X(adcs,  4140, eb500000),			\   X(add,   1c00, eb000000),			\   X(adds,  1c00, eb100000),			\   X(addi,  0000, f1000000),			\   X(addis, 0000, f1100000),			\   X(add_pc,000f, f20f0000),			\   X(add_sp,000d, f10d0000),			\   X(adr,   000f, f20f0000),			\   X(and,   4000, ea000000),			\   X(ands,  4000, ea100000),			\   X(asr,   1000, fa40f000),			\   X(asrs,  1000, fa50f000),			\   X(b,     e000, f000b000),			\   X(bcond, d000, f0008000),			\   X(bic,   4380, ea200000),			\   X(bics,  4380, ea300000),			\   X(cmn,   42c0, eb100f00),			\   X(cmp,   2800, ebb00f00),			\   X(cpsie, b660, f3af8400),			\   X(cpsid, b670, f3af8600),			\   X(cpy,   4600, ea4f0000),			\   X(dec_sp,80dd, f1ad0d00),			\   X(eor,   4040, ea800000),			\   X(eors,  4040, ea900000),			\   X(inc_sp,00dd, f10d0d00),			\   X(ldmia, c800, e8900000),			\   X(ldr,   6800, f8500000),			\   X(ldrb,  7800, f8100000),			\   X(ldrh,  8800, f8300000),			\   X(ldrsb, 5600, f9100000),			\   X(ldrsh, 5e00, f9300000),			\   X(ldr_pc,4800, f85f0000),			\   X(ldr_pc2,4800, f85f0000),			\   X(ldr_sp,9800, f85d0000),			\   X(lsl,   0000, fa00f000),			\   X(lsls,  0000, fa10f000),			\   X(lsr,   0800, fa20f000),			\   X(lsrs,  0800, fa30f000),			\   X(mov,   2000, ea4f0000),			\   X(movs,  2000, ea5f0000),			\   X(mul,   4340, fb00f000),                     \   X(muls,  4340, ffffffff),
comment|/* no 32b muls */
value|\   X(mvn,   43c0, ea6f0000),			\   X(mvns,  43c0, ea7f0000),			\   X(neg,   4240, f1c00000),
comment|/* rsb #0 */
value|\   X(negs,  4240, f1d00000),
comment|/* rsbs #0 */
value|\   X(orr,   4300, ea400000),			\   X(orrs,  4300, ea500000),			\   X(pop,   bc00, e8bd0000),
comment|/* ldmia sp!,... */
value|\   X(push,  b400, e92d0000),
comment|/* stmdb sp!,... */
value|\   X(rev,   ba00, fa90f080),			\   X(rev16, ba40, fa90f090),			\   X(revsh, bac0, fa90f0b0),			\   X(ror,   41c0, fa60f000),			\   X(rors,  41c0, fa70f000),			\   X(sbc,   4180, eb600000),			\   X(sbcs,  4180, eb700000),			\   X(stmia, c000, e8800000),			\   X(str,   6000, f8400000),			\   X(strb,  7000, f8000000),			\   X(strh,  8000, f8200000),			\   X(str_sp,9000, f84d0000),			\   X(sub,   1e00, eba00000),			\   X(subs,  1e00, ebb00000),			\   X(subi,  8000, f1a00000),			\   X(subis, 8000, f1b00000),			\   X(sxtb,  b240, fa4ff080),			\   X(sxth,  b200, fa0ff080),			\   X(tst,   4200, ea100f00),			\   X(uxtb,  b2c0, fa5ff080),			\   X(uxth,  b280, fa1ff080),			\   X(nop,   bf00, f3af8000),			\   X(yield, bf10, f3af8001),			\   X(wfe,   bf20, f3af8002),			\   X(wfi,   bf30, f3af8003),			\   X(sev,   bf40, f3af9004),
end_define

begin_comment
comment|/* typo, 8004? */
end_comment

begin_comment
comment|/* To catch errors in encoding functions, the codes are all offset by    0xF800, putting them in one of the 32-bit prefix ranges, ergo undefined    as 16-bit instructions.  */
end_comment

begin_define
define|#
directive|define
name|X
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|)
value|T_MNEM_##a
end_define

begin_enum
enum|enum
name|t16_32_codes
block|{
name|T16_32_OFFSET
init|=
literal|0xF7FF
block|,
name|T16_32_TAB
block|}
enum|;
end_enum

begin_undef
undef|#
directive|undef
name|X
end_undef

begin_define
define|#
directive|define
name|X
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|)
value|0x##b
end_define

begin_decl_stmt
specifier|static
specifier|const
name|unsigned
name|short
name|thumb_op16
index|[]
init|=
block|{
name|T16_32_TAB
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|THUMB_OP16
parameter_list|(
name|n
parameter_list|)
value|(thumb_op16[(n) - (T16_32_OFFSET + 1)])
end_define

begin_undef
undef|#
directive|undef
name|X
end_undef

begin_define
define|#
directive|define
name|X
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|)
value|0x##c
end_define

begin_decl_stmt
specifier|static
specifier|const
name|unsigned
name|int
name|thumb_op32
index|[]
init|=
block|{
name|T16_32_TAB
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|THUMB_OP32
parameter_list|(
name|n
parameter_list|)
value|(thumb_op32[(n) - (T16_32_OFFSET + 1)])
end_define

begin_define
define|#
directive|define
name|THUMB_SETS_FLAGS
parameter_list|(
name|n
parameter_list|)
value|(THUMB_OP32 (n)& 0x00100000)
end_define

begin_undef
undef|#
directive|undef
name|X
end_undef

begin_undef
undef|#
directive|undef
name|T16_32_TAB
end_undef

begin_comment
comment|/* Thumb instruction encoders, in alphabetical order.  */
end_comment

begin_comment
comment|/* ADDW or SUBW.  */
end_comment

begin_function
specifier|static
name|void
name|do_t_add_sub_w
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|Rd
decl_stmt|,
name|Rn
decl_stmt|;
name|Rd
operator|=
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
expr_stmt|;
name|Rn
operator|=
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
expr_stmt|;
name|constraint
argument_list|(
name|Rd
operator|==
literal|15
argument_list|,
name|_
argument_list|(
literal|"PC not allowed as destination"
argument_list|)
argument_list|)
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
operator|(
name|Rn
operator|<<
literal|16
operator|)
operator||
operator|(
name|Rd
operator|<<
literal|8
operator|)
expr_stmt|;
name|inst
operator|.
name|reloc
operator|.
name|type
operator|=
name|BFD_RELOC_ARM_T32_IMM12
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Parse an add or subtract instruction.  We get here with inst.instruction    equalling any of THUMB_OPCODE_add, adds, sub, or subs.  */
end_comment

begin_function
specifier|static
name|void
name|do_t_add_sub
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|Rd
decl_stmt|,
name|Rs
decl_stmt|,
name|Rn
decl_stmt|;
name|Rd
operator|=
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
expr_stmt|;
name|Rs
operator|=
operator|(
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|present
condition|?
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
comment|/* Rd, Rs, foo */
else|:
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
operator|)
expr_stmt|;
comment|/* Rd, foo -> Rd, Rd, foo */
if|if
condition|(
name|unified_syntax
condition|)
block|{
name|bfd_boolean
name|flags
decl_stmt|;
name|bfd_boolean
name|narrow
decl_stmt|;
name|int
name|opcode
decl_stmt|;
name|flags
operator|=
operator|(
name|inst
operator|.
name|instruction
operator|==
name|T_MNEM_adds
operator|||
name|inst
operator|.
name|instruction
operator|==
name|T_MNEM_subs
operator|)
expr_stmt|;
if|if
condition|(
name|flags
condition|)
name|narrow
operator|=
operator|(
name|current_it_mask
operator|==
literal|0
operator|)
expr_stmt|;
else|else
name|narrow
operator|=
operator|(
name|current_it_mask
operator|!=
literal|0
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|inst
operator|.
name|operands
index|[
literal|2
index|]
operator|.
name|isreg
condition|)
block|{
name|int
name|add
decl_stmt|;
name|add
operator|=
operator|(
name|inst
operator|.
name|instruction
operator|==
name|T_MNEM_add
operator|||
name|inst
operator|.
name|instruction
operator|==
name|T_MNEM_adds
operator|)
expr_stmt|;
name|opcode
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|inst
operator|.
name|size_req
operator|!=
literal|4
condition|)
block|{
comment|/* Attempt to use a narrow opcode, with relaxation if 	         appropriate.  */
if|if
condition|(
name|Rd
operator|==
name|REG_SP
operator|&&
name|Rs
operator|==
name|REG_SP
operator|&&
operator|!
name|flags
condition|)
name|opcode
operator|=
name|add
condition|?
name|T_MNEM_inc_sp
else|:
name|T_MNEM_dec_sp
expr_stmt|;
elseif|else
if|if
condition|(
name|Rd
operator|<=
literal|7
operator|&&
name|Rs
operator|==
name|REG_SP
operator|&&
name|add
operator|&&
operator|!
name|flags
condition|)
name|opcode
operator|=
name|T_MNEM_add_sp
expr_stmt|;
elseif|else
if|if
condition|(
name|Rd
operator|<=
literal|7
operator|&&
name|Rs
operator|==
name|REG_PC
operator|&&
name|add
operator|&&
operator|!
name|flags
condition|)
name|opcode
operator|=
name|T_MNEM_add_pc
expr_stmt|;
elseif|else
if|if
condition|(
name|Rd
operator|<=
literal|7
operator|&&
name|Rs
operator|<=
literal|7
operator|&&
name|narrow
condition|)
block|{
if|if
condition|(
name|flags
condition|)
name|opcode
operator|=
name|add
condition|?
name|T_MNEM_addis
else|:
name|T_MNEM_subis
expr_stmt|;
else|else
name|opcode
operator|=
name|add
condition|?
name|T_MNEM_addi
else|:
name|T_MNEM_subi
expr_stmt|;
block|}
if|if
condition|(
name|opcode
condition|)
block|{
name|inst
operator|.
name|instruction
operator|=
name|THUMB_OP16
argument_list|(
name|opcode
argument_list|)
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
operator|(
name|Rd
operator|<<
literal|4
operator|)
operator||
name|Rs
expr_stmt|;
name|inst
operator|.
name|reloc
operator|.
name|type
operator|=
name|BFD_RELOC_ARM_THUMB_ADD
expr_stmt|;
if|if
condition|(
name|inst
operator|.
name|size_req
operator|!=
literal|2
condition|)
name|inst
operator|.
name|relax
operator|=
name|opcode
expr_stmt|;
block|}
else|else
name|constraint
argument_list|(
name|inst
operator|.
name|size_req
operator|==
literal|2
argument_list|,
name|BAD_HIREG
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|inst
operator|.
name|size_req
operator|==
literal|4
operator|||
operator|(
name|inst
operator|.
name|size_req
operator|!=
literal|2
operator|&&
operator|!
name|opcode
operator|)
condition|)
block|{
if|if
condition|(
name|Rd
operator|==
name|REG_PC
condition|)
block|{
name|constraint
argument_list|(
name|Rs
operator|!=
name|REG_LR
operator|||
name|inst
operator|.
name|instruction
operator|!=
name|T_MNEM_subs
argument_list|,
name|_
argument_list|(
literal|"only SUBS PC, LR, #const allowed"
argument_list|)
argument_list|)
expr_stmt|;
name|constraint
argument_list|(
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_op
operator|!=
name|O_constant
argument_list|,
name|_
argument_list|(
literal|"expression too complex"
argument_list|)
argument_list|)
expr_stmt|;
name|constraint
argument_list|(
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_add_number
operator|<
literal|0
operator|||
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_add_number
operator|>
literal|0xff
argument_list|,
name|_
argument_list|(
literal|"immediate value out of range"
argument_list|)
argument_list|)
expr_stmt|;
name|inst
operator|.
name|instruction
operator|=
name|T2_SUBS_PC_LR
operator||
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_add_number
expr_stmt|;
name|inst
operator|.
name|reloc
operator|.
name|type
operator|=
name|BFD_RELOC_UNUSED
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|Rs
operator|==
name|REG_PC
condition|)
block|{
comment|/* Always use addw/subw.  */
name|inst
operator|.
name|instruction
operator|=
name|add
condition|?
literal|0xf20f0000
else|:
literal|0xf2af0000
expr_stmt|;
name|inst
operator|.
name|reloc
operator|.
name|type
operator|=
name|BFD_RELOC_ARM_T32_IMM12
expr_stmt|;
block|}
else|else
block|{
name|inst
operator|.
name|instruction
operator|=
name|THUMB_OP32
argument_list|(
name|inst
operator|.
name|instruction
argument_list|)
expr_stmt|;
name|inst
operator|.
name|instruction
operator|=
operator|(
name|inst
operator|.
name|instruction
operator|&
literal|0xe1ffffff
operator|)
operator||
literal|0x10000000
expr_stmt|;
if|if
condition|(
name|flags
condition|)
name|inst
operator|.
name|reloc
operator|.
name|type
operator|=
name|BFD_RELOC_ARM_T32_IMMEDIATE
expr_stmt|;
else|else
name|inst
operator|.
name|reloc
operator|.
name|type
operator|=
name|BFD_RELOC_ARM_T32_ADD_IMM
expr_stmt|;
block|}
name|inst
operator|.
name|instruction
operator||=
name|Rd
operator|<<
literal|8
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|Rs
operator|<<
literal|16
expr_stmt|;
block|}
block|}
else|else
block|{
name|Rn
operator|=
name|inst
operator|.
name|operands
index|[
literal|2
index|]
operator|.
name|reg
expr_stmt|;
comment|/* See if we can do this with a 16-bit instruction.  */
if|if
condition|(
operator|!
name|inst
operator|.
name|operands
index|[
literal|2
index|]
operator|.
name|shifted
operator|&&
name|inst
operator|.
name|size_req
operator|!=
literal|4
condition|)
block|{
if|if
condition|(
name|Rd
operator|>
literal|7
operator|||
name|Rs
operator|>
literal|7
operator|||
name|Rn
operator|>
literal|7
condition|)
name|narrow
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|narrow
condition|)
block|{
name|inst
operator|.
name|instruction
operator|=
operator|(
operator|(
name|inst
operator|.
name|instruction
operator|==
name|T_MNEM_adds
operator|||
name|inst
operator|.
name|instruction
operator|==
name|T_MNEM_add
operator|)
condition|?
name|T_OPCODE_ADD_R3
else|:
name|T_OPCODE_SUB_R3
operator|)
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|Rd
operator||
operator|(
name|Rs
operator|<<
literal|3
operator|)
operator||
operator|(
name|Rn
operator|<<
literal|6
operator|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|inst
operator|.
name|instruction
operator|==
name|T_MNEM_add
condition|)
block|{
if|if
condition|(
name|Rd
operator|==
name|Rs
condition|)
block|{
name|inst
operator|.
name|instruction
operator|=
name|T_OPCODE_ADD_HI
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
operator|(
name|Rd
operator|&
literal|8
operator|)
operator|<<
literal|4
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
operator|(
name|Rd
operator|&
literal|7
operator|)
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|Rn
operator|<<
literal|3
expr_stmt|;
return|return;
block|}
comment|/* ... because addition is commutative! */
elseif|else
if|if
condition|(
name|Rd
operator|==
name|Rn
condition|)
block|{
name|inst
operator|.
name|instruction
operator|=
name|T_OPCODE_ADD_HI
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
operator|(
name|Rd
operator|&
literal|8
operator|)
operator|<<
literal|4
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
operator|(
name|Rd
operator|&
literal|7
operator|)
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|Rs
operator|<<
literal|3
expr_stmt|;
return|return;
block|}
block|}
block|}
comment|/* If we get here, it can't be done in 16 bits.  */
name|constraint
argument_list|(
name|inst
operator|.
name|operands
index|[
literal|2
index|]
operator|.
name|shifted
operator|&&
name|inst
operator|.
name|operands
index|[
literal|2
index|]
operator|.
name|immisreg
argument_list|,
name|_
argument_list|(
literal|"shift must be constant"
argument_list|)
argument_list|)
expr_stmt|;
name|inst
operator|.
name|instruction
operator|=
name|THUMB_OP32
argument_list|(
name|inst
operator|.
name|instruction
argument_list|)
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|Rd
operator|<<
literal|8
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|Rs
operator|<<
literal|16
expr_stmt|;
name|encode_thumb32_shifted_operand
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|constraint
argument_list|(
name|inst
operator|.
name|instruction
operator|==
name|T_MNEM_adds
operator|||
name|inst
operator|.
name|instruction
operator|==
name|T_MNEM_subs
argument_list|,
name|BAD_THUMB32
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|inst
operator|.
name|operands
index|[
literal|2
index|]
operator|.
name|isreg
condition|)
comment|/* Rd, Rs, #imm */
block|{
name|constraint
argument_list|(
operator|(
name|Rd
operator|>
literal|7
operator|&&
operator|(
name|Rd
operator|!=
name|REG_SP
operator|||
name|Rs
operator|!=
name|REG_SP
operator|)
operator|)
operator|||
operator|(
name|Rs
operator|>
literal|7
operator|&&
name|Rs
operator|!=
name|REG_SP
operator|&&
name|Rs
operator|!=
name|REG_PC
operator|)
argument_list|,
name|BAD_HIREG
argument_list|)
expr_stmt|;
name|inst
operator|.
name|instruction
operator|=
operator|(
name|inst
operator|.
name|instruction
operator|==
name|T_MNEM_add
condition|?
literal|0x0000
else|:
literal|0x8000
operator|)
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
operator|(
name|Rd
operator|<<
literal|4
operator|)
operator||
name|Rs
expr_stmt|;
name|inst
operator|.
name|reloc
operator|.
name|type
operator|=
name|BFD_RELOC_ARM_THUMB_ADD
expr_stmt|;
return|return;
block|}
name|Rn
operator|=
name|inst
operator|.
name|operands
index|[
literal|2
index|]
operator|.
name|reg
expr_stmt|;
name|constraint
argument_list|(
name|inst
operator|.
name|operands
index|[
literal|2
index|]
operator|.
name|shifted
argument_list|,
name|_
argument_list|(
literal|"unshifted register required"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We now have Rd, Rs, and Rn set to registers.  */
if|if
condition|(
name|Rd
operator|>
literal|7
operator|||
name|Rs
operator|>
literal|7
operator|||
name|Rn
operator|>
literal|7
condition|)
block|{
comment|/* Can't do this for SUB.	 */
name|constraint
argument_list|(
name|inst
operator|.
name|instruction
operator|==
name|T_MNEM_sub
argument_list|,
name|BAD_HIREG
argument_list|)
expr_stmt|;
name|inst
operator|.
name|instruction
operator|=
name|T_OPCODE_ADD_HI
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
operator|(
name|Rd
operator|&
literal|8
operator|)
operator|<<
literal|4
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
operator|(
name|Rd
operator|&
literal|7
operator|)
expr_stmt|;
if|if
condition|(
name|Rs
operator|==
name|Rd
condition|)
name|inst
operator|.
name|instruction
operator||=
name|Rn
operator|<<
literal|3
expr_stmt|;
elseif|else
if|if
condition|(
name|Rn
operator|==
name|Rd
condition|)
name|inst
operator|.
name|instruction
operator||=
name|Rs
operator|<<
literal|3
expr_stmt|;
else|else
name|constraint
argument_list|(
literal|1
argument_list|,
name|_
argument_list|(
literal|"dest must overlap one source register"
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|inst
operator|.
name|instruction
operator|=
operator|(
name|inst
operator|.
name|instruction
operator|==
name|T_MNEM_add
condition|?
name|T_OPCODE_ADD_R3
else|:
name|T_OPCODE_SUB_R3
operator|)
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|Rd
operator||
operator|(
name|Rs
operator|<<
literal|3
operator|)
operator||
operator|(
name|Rn
operator|<<
literal|6
operator|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|do_t_adr
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|unified_syntax
operator|&&
name|inst
operator|.
name|size_req
operator|==
literal|0
operator|&&
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
operator|<=
literal|7
condition|)
block|{
comment|/* Defer to section relaxation.  */
name|inst
operator|.
name|relax
operator|=
name|inst
operator|.
name|instruction
expr_stmt|;
name|inst
operator|.
name|instruction
operator|=
name|THUMB_OP16
argument_list|(
name|inst
operator|.
name|instruction
argument_list|)
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
operator|<<
literal|4
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|unified_syntax
operator|&&
name|inst
operator|.
name|size_req
operator|!=
literal|2
condition|)
block|{
comment|/* Generate a 32-bit opcode.  */
name|inst
operator|.
name|instruction
operator|=
name|THUMB_OP32
argument_list|(
name|inst
operator|.
name|instruction
argument_list|)
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
operator|<<
literal|8
expr_stmt|;
name|inst
operator|.
name|reloc
operator|.
name|type
operator|=
name|BFD_RELOC_ARM_T32_ADD_PC12
expr_stmt|;
name|inst
operator|.
name|reloc
operator|.
name|pc_rel
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* Generate a 16-bit opcode.  */
name|inst
operator|.
name|instruction
operator|=
name|THUMB_OP16
argument_list|(
name|inst
operator|.
name|instruction
argument_list|)
expr_stmt|;
name|inst
operator|.
name|reloc
operator|.
name|type
operator|=
name|BFD_RELOC_ARM_THUMB_ADD
expr_stmt|;
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_add_number
operator|-=
literal|4
expr_stmt|;
comment|/* PC relative adjust.  */
name|inst
operator|.
name|reloc
operator|.
name|pc_rel
operator|=
literal|1
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
operator|<<
literal|4
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Arithmetic instructions for which there is just one 16-bit    instruction encoding, and it allows only two low registers.    For maximal compatibility with ARM syntax, we allow three register    operands even when Thumb-32 instructions are not available, as long    as the first two are identical.  For instance, both "sbc r0,r1" and    "sbc r0,r0,r1" are allowed.  */
end_comment

begin_function
specifier|static
name|void
name|do_t_arit3
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|Rd
decl_stmt|,
name|Rs
decl_stmt|,
name|Rn
decl_stmt|;
name|Rd
operator|=
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
expr_stmt|;
name|Rs
operator|=
operator|(
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|present
condition|?
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
comment|/* Rd, Rs, foo */
else|:
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
operator|)
expr_stmt|;
comment|/* Rd, foo -> Rd, Rd, foo */
name|Rn
operator|=
name|inst
operator|.
name|operands
index|[
literal|2
index|]
operator|.
name|reg
expr_stmt|;
if|if
condition|(
name|unified_syntax
condition|)
block|{
if|if
condition|(
operator|!
name|inst
operator|.
name|operands
index|[
literal|2
index|]
operator|.
name|isreg
condition|)
block|{
comment|/* For an immediate, we always generate a 32-bit opcode; 	     section relaxation will shrink it later if possible.  */
name|inst
operator|.
name|instruction
operator|=
name|THUMB_OP32
argument_list|(
name|inst
operator|.
name|instruction
argument_list|)
expr_stmt|;
name|inst
operator|.
name|instruction
operator|=
operator|(
name|inst
operator|.
name|instruction
operator|&
literal|0xe1ffffff
operator|)
operator||
literal|0x10000000
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|Rd
operator|<<
literal|8
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|Rs
operator|<<
literal|16
expr_stmt|;
name|inst
operator|.
name|reloc
operator|.
name|type
operator|=
name|BFD_RELOC_ARM_T32_IMMEDIATE
expr_stmt|;
block|}
else|else
block|{
name|bfd_boolean
name|narrow
decl_stmt|;
comment|/* See if we can do this with a 16-bit instruction.  */
if|if
condition|(
name|THUMB_SETS_FLAGS
argument_list|(
name|inst
operator|.
name|instruction
argument_list|)
condition|)
name|narrow
operator|=
name|current_it_mask
operator|==
literal|0
expr_stmt|;
else|else
name|narrow
operator|=
name|current_it_mask
operator|!=
literal|0
expr_stmt|;
if|if
condition|(
name|Rd
operator|>
literal|7
operator|||
name|Rn
operator|>
literal|7
operator|||
name|Rs
operator|>
literal|7
condition|)
name|narrow
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|inst
operator|.
name|operands
index|[
literal|2
index|]
operator|.
name|shifted
condition|)
name|narrow
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|inst
operator|.
name|size_req
operator|==
literal|4
condition|)
name|narrow
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|narrow
operator|&&
name|Rd
operator|==
name|Rs
condition|)
block|{
name|inst
operator|.
name|instruction
operator|=
name|THUMB_OP16
argument_list|(
name|inst
operator|.
name|instruction
argument_list|)
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|Rd
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|Rn
operator|<<
literal|3
expr_stmt|;
return|return;
block|}
comment|/* If we get here, it can't be done in 16 bits.  */
name|constraint
argument_list|(
name|inst
operator|.
name|operands
index|[
literal|2
index|]
operator|.
name|shifted
operator|&&
name|inst
operator|.
name|operands
index|[
literal|2
index|]
operator|.
name|immisreg
argument_list|,
name|_
argument_list|(
literal|"shift must be constant"
argument_list|)
argument_list|)
expr_stmt|;
name|inst
operator|.
name|instruction
operator|=
name|THUMB_OP32
argument_list|(
name|inst
operator|.
name|instruction
argument_list|)
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|Rd
operator|<<
literal|8
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|Rs
operator|<<
literal|16
expr_stmt|;
name|encode_thumb32_shifted_operand
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* On its face this is a lie - the instruction does set the 	 flags.  However, the only supported mnemonic in this mode 	 says it doesn't.  */
name|constraint
argument_list|(
name|THUMB_SETS_FLAGS
argument_list|(
name|inst
operator|.
name|instruction
argument_list|)
argument_list|,
name|BAD_THUMB32
argument_list|)
expr_stmt|;
name|constraint
argument_list|(
operator|!
name|inst
operator|.
name|operands
index|[
literal|2
index|]
operator|.
name|isreg
operator|||
name|inst
operator|.
name|operands
index|[
literal|2
index|]
operator|.
name|shifted
argument_list|,
name|_
argument_list|(
literal|"unshifted register required"
argument_list|)
argument_list|)
expr_stmt|;
name|constraint
argument_list|(
name|Rd
operator|>
literal|7
operator|||
name|Rs
operator|>
literal|7
operator|||
name|Rn
operator|>
literal|7
argument_list|,
name|BAD_HIREG
argument_list|)
expr_stmt|;
name|constraint
argument_list|(
name|Rd
operator|!=
name|Rs
argument_list|,
name|_
argument_list|(
literal|"dest and source1 must be the same register"
argument_list|)
argument_list|)
expr_stmt|;
name|inst
operator|.
name|instruction
operator|=
name|THUMB_OP16
argument_list|(
name|inst
operator|.
name|instruction
argument_list|)
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|Rd
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|Rn
operator|<<
literal|3
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Similarly, but for instructions where the arithmetic operation is    commutative, so we can allow either of them to be different from    the destination operand in a 16-bit instruction.  For instance, all    three of "adc r0,r1", "adc r0,r0,r1", and "adc r0,r1,r0" are    accepted.  */
end_comment

begin_function
specifier|static
name|void
name|do_t_arit3c
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|Rd
decl_stmt|,
name|Rs
decl_stmt|,
name|Rn
decl_stmt|;
name|Rd
operator|=
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
expr_stmt|;
name|Rs
operator|=
operator|(
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|present
condition|?
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
comment|/* Rd, Rs, foo */
else|:
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
operator|)
expr_stmt|;
comment|/* Rd, foo -> Rd, Rd, foo */
name|Rn
operator|=
name|inst
operator|.
name|operands
index|[
literal|2
index|]
operator|.
name|reg
expr_stmt|;
if|if
condition|(
name|unified_syntax
condition|)
block|{
if|if
condition|(
operator|!
name|inst
operator|.
name|operands
index|[
literal|2
index|]
operator|.
name|isreg
condition|)
block|{
comment|/* For an immediate, we always generate a 32-bit opcode; 	     section relaxation will shrink it later if possible.  */
name|inst
operator|.
name|instruction
operator|=
name|THUMB_OP32
argument_list|(
name|inst
operator|.
name|instruction
argument_list|)
expr_stmt|;
name|inst
operator|.
name|instruction
operator|=
operator|(
name|inst
operator|.
name|instruction
operator|&
literal|0xe1ffffff
operator|)
operator||
literal|0x10000000
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|Rd
operator|<<
literal|8
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|Rs
operator|<<
literal|16
expr_stmt|;
name|inst
operator|.
name|reloc
operator|.
name|type
operator|=
name|BFD_RELOC_ARM_T32_IMMEDIATE
expr_stmt|;
block|}
else|else
block|{
name|bfd_boolean
name|narrow
decl_stmt|;
comment|/* See if we can do this with a 16-bit instruction.  */
if|if
condition|(
name|THUMB_SETS_FLAGS
argument_list|(
name|inst
operator|.
name|instruction
argument_list|)
condition|)
name|narrow
operator|=
name|current_it_mask
operator|==
literal|0
expr_stmt|;
else|else
name|narrow
operator|=
name|current_it_mask
operator|!=
literal|0
expr_stmt|;
if|if
condition|(
name|Rd
operator|>
literal|7
operator|||
name|Rn
operator|>
literal|7
operator|||
name|Rs
operator|>
literal|7
condition|)
name|narrow
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|inst
operator|.
name|operands
index|[
literal|2
index|]
operator|.
name|shifted
condition|)
name|narrow
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|inst
operator|.
name|size_req
operator|==
literal|4
condition|)
name|narrow
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|narrow
condition|)
block|{
if|if
condition|(
name|Rd
operator|==
name|Rs
condition|)
block|{
name|inst
operator|.
name|instruction
operator|=
name|THUMB_OP16
argument_list|(
name|inst
operator|.
name|instruction
argument_list|)
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|Rd
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|Rn
operator|<<
literal|3
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|Rd
operator|==
name|Rn
condition|)
block|{
name|inst
operator|.
name|instruction
operator|=
name|THUMB_OP16
argument_list|(
name|inst
operator|.
name|instruction
argument_list|)
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|Rd
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|Rs
operator|<<
literal|3
expr_stmt|;
return|return;
block|}
block|}
comment|/* If we get here, it can't be done in 16 bits.  */
name|constraint
argument_list|(
name|inst
operator|.
name|operands
index|[
literal|2
index|]
operator|.
name|shifted
operator|&&
name|inst
operator|.
name|operands
index|[
literal|2
index|]
operator|.
name|immisreg
argument_list|,
name|_
argument_list|(
literal|"shift must be constant"
argument_list|)
argument_list|)
expr_stmt|;
name|inst
operator|.
name|instruction
operator|=
name|THUMB_OP32
argument_list|(
name|inst
operator|.
name|instruction
argument_list|)
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|Rd
operator|<<
literal|8
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|Rs
operator|<<
literal|16
expr_stmt|;
name|encode_thumb32_shifted_operand
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* On its face this is a lie - the instruction does set the 	 flags.  However, the only supported mnemonic in this mode 	 says it doesn't.  */
name|constraint
argument_list|(
name|THUMB_SETS_FLAGS
argument_list|(
name|inst
operator|.
name|instruction
argument_list|)
argument_list|,
name|BAD_THUMB32
argument_list|)
expr_stmt|;
name|constraint
argument_list|(
operator|!
name|inst
operator|.
name|operands
index|[
literal|2
index|]
operator|.
name|isreg
operator|||
name|inst
operator|.
name|operands
index|[
literal|2
index|]
operator|.
name|shifted
argument_list|,
name|_
argument_list|(
literal|"unshifted register required"
argument_list|)
argument_list|)
expr_stmt|;
name|constraint
argument_list|(
name|Rd
operator|>
literal|7
operator|||
name|Rs
operator|>
literal|7
operator|||
name|Rn
operator|>
literal|7
argument_list|,
name|BAD_HIREG
argument_list|)
expr_stmt|;
name|inst
operator|.
name|instruction
operator|=
name|THUMB_OP16
argument_list|(
name|inst
operator|.
name|instruction
argument_list|)
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|Rd
expr_stmt|;
if|if
condition|(
name|Rd
operator|==
name|Rs
condition|)
name|inst
operator|.
name|instruction
operator||=
name|Rn
operator|<<
literal|3
expr_stmt|;
elseif|else
if|if
condition|(
name|Rd
operator|==
name|Rn
condition|)
name|inst
operator|.
name|instruction
operator||=
name|Rs
operator|<<
literal|3
expr_stmt|;
else|else
name|constraint
argument_list|(
literal|1
argument_list|,
name|_
argument_list|(
literal|"dest must overlap one source register"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|do_t_barrier
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|present
condition|)
block|{
name|constraint
argument_list|(
operator|(
name|inst
operator|.
name|instruction
operator|&
literal|0xf0
operator|)
operator|!=
literal|0x40
operator|&&
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|imm
operator|!=
literal|0xf
argument_list|,
literal|"bad barrier type"
argument_list|)
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|imm
expr_stmt|;
block|}
else|else
name|inst
operator|.
name|instruction
operator||=
literal|0xf
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_t_bfc
parameter_list|(
name|void
parameter_list|)
block|{
name|unsigned
name|int
name|msb
init|=
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|imm
operator|+
name|inst
operator|.
name|operands
index|[
literal|2
index|]
operator|.
name|imm
decl_stmt|;
name|constraint
argument_list|(
name|msb
operator|>
literal|32
argument_list|,
name|_
argument_list|(
literal|"bit-field extends past end of register"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* The instruction encoding stores the LSB and MSB,      not the LSB and width.  */
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
operator|<<
literal|8
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
operator|(
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|imm
operator|&
literal|0x1c
operator|)
operator|<<
literal|10
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
operator|(
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|imm
operator|&
literal|0x03
operator|)
operator|<<
literal|6
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|msb
operator|-
literal|1
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_t_bfi
parameter_list|(
name|void
parameter_list|)
block|{
name|unsigned
name|int
name|msb
decl_stmt|;
comment|/* #0 in second position is alternative syntax for bfc, which is      the same instruction but with REG_PC in the Rm field.  */
if|if
condition|(
operator|!
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|isreg
condition|)
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
operator|=
name|REG_PC
expr_stmt|;
name|msb
operator|=
name|inst
operator|.
name|operands
index|[
literal|2
index|]
operator|.
name|imm
operator|+
name|inst
operator|.
name|operands
index|[
literal|3
index|]
operator|.
name|imm
expr_stmt|;
name|constraint
argument_list|(
name|msb
operator|>
literal|32
argument_list|,
name|_
argument_list|(
literal|"bit-field extends past end of register"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* The instruction encoding stores the LSB and MSB,      not the LSB and width.  */
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
operator|<<
literal|8
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
operator|<<
literal|16
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
operator|(
name|inst
operator|.
name|operands
index|[
literal|2
index|]
operator|.
name|imm
operator|&
literal|0x1c
operator|)
operator|<<
literal|10
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
operator|(
name|inst
operator|.
name|operands
index|[
literal|2
index|]
operator|.
name|imm
operator|&
literal|0x03
operator|)
operator|<<
literal|6
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|msb
operator|-
literal|1
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_t_bfx
parameter_list|(
name|void
parameter_list|)
block|{
name|constraint
argument_list|(
name|inst
operator|.
name|operands
index|[
literal|2
index|]
operator|.
name|imm
operator|+
name|inst
operator|.
name|operands
index|[
literal|3
index|]
operator|.
name|imm
operator|>
literal|32
argument_list|,
name|_
argument_list|(
literal|"bit-field extends past end of register"
argument_list|)
argument_list|)
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
operator|<<
literal|8
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
operator|<<
literal|16
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
operator|(
name|inst
operator|.
name|operands
index|[
literal|2
index|]
operator|.
name|imm
operator|&
literal|0x1c
operator|)
operator|<<
literal|10
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
operator|(
name|inst
operator|.
name|operands
index|[
literal|2
index|]
operator|.
name|imm
operator|&
literal|0x03
operator|)
operator|<<
literal|6
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|3
index|]
operator|.
name|imm
operator|-
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ARM V5 Thumb BLX (argument parse) 	BLX<target_addr>	which is BLX(1) 	BLX<Rm>		which is BLX(2)    Unfortunately, there are two different opcodes for this mnemonic.    So, the insns[].value is not used, and the code here zaps values 	into inst.instruction.     ??? How to take advantage of the additional two bits of displacement    available in Thumb32 mode?  Need new relocation?  */
end_comment

begin_function
specifier|static
name|void
name|do_t_blx
parameter_list|(
name|void
parameter_list|)
block|{
name|constraint
argument_list|(
name|current_it_mask
operator|&&
name|current_it_mask
operator|!=
literal|0x10
argument_list|,
name|BAD_BRANCH
argument_list|)
expr_stmt|;
if|if
condition|(
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|isreg
condition|)
comment|/* We have a register, so this is BLX(2).  */
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
operator|<<
literal|3
expr_stmt|;
else|else
block|{
comment|/* No register.  This must be BLX(1).  */
name|inst
operator|.
name|instruction
operator|=
literal|0xf000e800
expr_stmt|;
ifdef|#
directive|ifdef
name|OBJ_ELF
if|if
condition|(
name|EF_ARM_EABI_VERSION
argument_list|(
name|meabi_flags
argument_list|)
operator|>=
name|EF_ARM_EABI_VER4
condition|)
name|inst
operator|.
name|reloc
operator|.
name|type
operator|=
name|BFD_RELOC_THUMB_PCREL_BRANCH23
expr_stmt|;
else|else
endif|#
directive|endif
name|inst
operator|.
name|reloc
operator|.
name|type
operator|=
name|BFD_RELOC_THUMB_PCREL_BLX
expr_stmt|;
name|inst
operator|.
name|reloc
operator|.
name|pc_rel
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|do_t_branch
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|opcode
decl_stmt|;
name|int
name|cond
decl_stmt|;
if|if
condition|(
name|current_it_mask
condition|)
block|{
comment|/* Conditional branches inside IT blocks are encoded as unconditional          branches.  */
name|cond
operator|=
name|COND_ALWAYS
expr_stmt|;
comment|/* A branch must be the last instruction in an IT block.  */
name|constraint
argument_list|(
name|current_it_mask
operator|!=
literal|0x10
argument_list|,
name|BAD_BRANCH
argument_list|)
expr_stmt|;
block|}
else|else
name|cond
operator|=
name|inst
operator|.
name|cond
expr_stmt|;
if|if
condition|(
name|cond
operator|!=
name|COND_ALWAYS
condition|)
name|opcode
operator|=
name|T_MNEM_bcond
expr_stmt|;
else|else
name|opcode
operator|=
name|inst
operator|.
name|instruction
expr_stmt|;
if|if
condition|(
name|unified_syntax
operator|&&
name|inst
operator|.
name|size_req
operator|==
literal|4
condition|)
block|{
name|inst
operator|.
name|instruction
operator|=
name|THUMB_OP32
argument_list|(
name|opcode
argument_list|)
expr_stmt|;
if|if
condition|(
name|cond
operator|==
name|COND_ALWAYS
condition|)
name|inst
operator|.
name|reloc
operator|.
name|type
operator|=
name|BFD_RELOC_THUMB_PCREL_BRANCH25
expr_stmt|;
else|else
block|{
name|assert
argument_list|(
name|cond
operator|!=
literal|0xF
argument_list|)
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|cond
operator|<<
literal|22
expr_stmt|;
name|inst
operator|.
name|reloc
operator|.
name|type
operator|=
name|BFD_RELOC_THUMB_PCREL_BRANCH20
expr_stmt|;
block|}
block|}
else|else
block|{
name|inst
operator|.
name|instruction
operator|=
name|THUMB_OP16
argument_list|(
name|opcode
argument_list|)
expr_stmt|;
if|if
condition|(
name|cond
operator|==
name|COND_ALWAYS
condition|)
name|inst
operator|.
name|reloc
operator|.
name|type
operator|=
name|BFD_RELOC_THUMB_PCREL_BRANCH12
expr_stmt|;
else|else
block|{
name|inst
operator|.
name|instruction
operator||=
name|cond
operator|<<
literal|8
expr_stmt|;
name|inst
operator|.
name|reloc
operator|.
name|type
operator|=
name|BFD_RELOC_THUMB_PCREL_BRANCH9
expr_stmt|;
block|}
comment|/* Allow section relaxation.  */
if|if
condition|(
name|unified_syntax
operator|&&
name|inst
operator|.
name|size_req
operator|!=
literal|2
condition|)
name|inst
operator|.
name|relax
operator|=
name|opcode
expr_stmt|;
block|}
name|inst
operator|.
name|reloc
operator|.
name|pc_rel
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_t_bkpt
parameter_list|(
name|void
parameter_list|)
block|{
name|constraint
argument_list|(
name|inst
operator|.
name|cond
operator|!=
name|COND_ALWAYS
argument_list|,
name|_
argument_list|(
literal|"instruction is always unconditional"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|present
condition|)
block|{
name|constraint
argument_list|(
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|imm
operator|>
literal|255
argument_list|,
name|_
argument_list|(
literal|"immediate value out of range"
argument_list|)
argument_list|)
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|imm
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|do_t_branch23
parameter_list|(
name|void
parameter_list|)
block|{
name|constraint
argument_list|(
name|current_it_mask
operator|&&
name|current_it_mask
operator|!=
literal|0x10
argument_list|,
name|BAD_BRANCH
argument_list|)
expr_stmt|;
name|inst
operator|.
name|reloc
operator|.
name|type
operator|=
name|BFD_RELOC_THUMB_PCREL_BRANCH23
expr_stmt|;
name|inst
operator|.
name|reloc
operator|.
name|pc_rel
operator|=
literal|1
expr_stmt|;
comment|/* If the destination of the branch is a defined symbol which does not have      the THUMB_FUNC attribute, then we must be calling a function which has      the (interfacearm) attribute.  We look for the Thumb entry point to that      function and change the branch to refer to that function instead.	*/
if|if
condition|(
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_op
operator|==
name|O_symbol
operator|&&
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_add_symbol
operator|!=
name|NULL
operator|&&
name|S_IS_DEFINED
argument_list|(
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_add_symbol
argument_list|)
operator|&&
operator|!
name|THUMB_IS_FUNC
argument_list|(
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_add_symbol
argument_list|)
condition|)
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_add_symbol
operator|=
name|find_real_start
argument_list|(
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_add_symbol
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_t_bx
parameter_list|(
name|void
parameter_list|)
block|{
name|constraint
argument_list|(
name|current_it_mask
operator|&&
name|current_it_mask
operator|!=
literal|0x10
argument_list|,
name|BAD_BRANCH
argument_list|)
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
operator|<<
literal|3
expr_stmt|;
comment|/* ??? FIXME: Should add a hacky reloc here if reg is REG_PC.	 The reloc      should cause the alignment to be checked once it is known.	 This is      because BX PC only works if the instruction is word aligned.  */
block|}
end_function

begin_function
specifier|static
name|void
name|do_t_bxj
parameter_list|(
name|void
parameter_list|)
block|{
name|constraint
argument_list|(
name|current_it_mask
operator|&&
name|current_it_mask
operator|!=
literal|0x10
argument_list|,
name|BAD_BRANCH
argument_list|)
expr_stmt|;
if|if
condition|(
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
operator|==
name|REG_PC
condition|)
name|as_tsktsk
argument_list|(
name|_
argument_list|(
literal|"use of r15 in bxj is not really useful"
argument_list|)
argument_list|)
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
operator|<<
literal|16
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_t_clz
parameter_list|(
name|void
parameter_list|)
block|{
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
operator|<<
literal|8
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
operator|<<
literal|16
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_t_cps
parameter_list|(
name|void
parameter_list|)
block|{
name|constraint
argument_list|(
name|current_it_mask
argument_list|,
name|BAD_NOT_IT
argument_list|)
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|imm
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_t_cpsi
parameter_list|(
name|void
parameter_list|)
block|{
name|constraint
argument_list|(
name|current_it_mask
argument_list|,
name|BAD_NOT_IT
argument_list|)
expr_stmt|;
if|if
condition|(
name|unified_syntax
operator|&&
operator|(
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|present
operator|||
name|inst
operator|.
name|size_req
operator|==
literal|4
operator|)
operator|&&
name|ARM_CPU_HAS_FEATURE
argument_list|(
name|cpu_variant
argument_list|,
name|arm_ext_v6_notm
argument_list|)
condition|)
block|{
name|unsigned
name|int
name|imod
init|=
operator|(
name|inst
operator|.
name|instruction
operator|&
literal|0x0030
operator|)
operator|>>
literal|4
decl_stmt|;
name|inst
operator|.
name|instruction
operator|=
literal|0xf3af8000
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|imod
operator|<<
literal|9
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|imm
operator|<<
literal|5
expr_stmt|;
if|if
condition|(
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|present
condition|)
name|inst
operator|.
name|instruction
operator||=
literal|0x100
operator||
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|imm
expr_stmt|;
block|}
else|else
block|{
name|constraint
argument_list|(
operator|!
name|ARM_CPU_HAS_FEATURE
argument_list|(
name|cpu_variant
argument_list|,
name|arm_ext_v1
argument_list|)
operator|&&
operator|(
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|imm
operator|&
literal|4
operator|)
argument_list|,
name|_
argument_list|(
literal|"selected processor does not support 'A' form "
literal|"of this instruction"
argument_list|)
argument_list|)
expr_stmt|;
name|constraint
argument_list|(
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|present
operator|||
name|inst
operator|.
name|size_req
operator|==
literal|4
argument_list|,
name|_
argument_list|(
literal|"Thumb does not support the 2-argument "
literal|"form of this instruction"
argument_list|)
argument_list|)
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|imm
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* THUMB CPY instruction (argument parse).  */
end_comment

begin_function
specifier|static
name|void
name|do_t_cpy
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|inst
operator|.
name|size_req
operator|==
literal|4
condition|)
block|{
name|inst
operator|.
name|instruction
operator|=
name|THUMB_OP32
argument_list|(
name|T_MNEM_mov
argument_list|)
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
operator|<<
literal|8
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
expr_stmt|;
block|}
else|else
block|{
name|inst
operator|.
name|instruction
operator||=
operator|(
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
operator|&
literal|0x8
operator|)
operator|<<
literal|4
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
operator|(
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
operator|&
literal|0x7
operator|)
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
operator|<<
literal|3
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|do_t_cbz
parameter_list|(
name|void
parameter_list|)
block|{
name|constraint
argument_list|(
name|current_it_mask
argument_list|,
name|BAD_NOT_IT
argument_list|)
expr_stmt|;
name|constraint
argument_list|(
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
operator|>
literal|7
argument_list|,
name|BAD_HIREG
argument_list|)
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
expr_stmt|;
name|inst
operator|.
name|reloc
operator|.
name|pc_rel
operator|=
literal|1
expr_stmt|;
name|inst
operator|.
name|reloc
operator|.
name|type
operator|=
name|BFD_RELOC_THUMB_PCREL_BRANCH7
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_t_dbg
parameter_list|(
name|void
parameter_list|)
block|{
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|imm
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_t_div
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|present
condition|)
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
operator|=
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
operator|<<
literal|8
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
operator|<<
literal|16
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|2
index|]
operator|.
name|reg
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_t_hint
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|unified_syntax
operator|&&
name|inst
operator|.
name|size_req
operator|==
literal|4
condition|)
name|inst
operator|.
name|instruction
operator|=
name|THUMB_OP32
argument_list|(
name|inst
operator|.
name|instruction
argument_list|)
expr_stmt|;
else|else
name|inst
operator|.
name|instruction
operator|=
name|THUMB_OP16
argument_list|(
name|inst
operator|.
name|instruction
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_t_it
parameter_list|(
name|void
parameter_list|)
block|{
name|unsigned
name|int
name|cond
init|=
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|imm
decl_stmt|;
name|constraint
argument_list|(
name|current_it_mask
argument_list|,
name|BAD_NOT_IT
argument_list|)
expr_stmt|;
name|current_it_mask
operator|=
operator|(
name|inst
operator|.
name|instruction
operator|&
literal|0xf
operator|)
operator||
literal|0x10
expr_stmt|;
name|current_cc
operator|=
name|cond
expr_stmt|;
comment|/* If the condition is a negative condition, invert the mask.  */
if|if
condition|(
operator|(
name|cond
operator|&
literal|0x1
operator|)
operator|==
literal|0x0
condition|)
block|{
name|unsigned
name|int
name|mask
init|=
name|inst
operator|.
name|instruction
operator|&
literal|0x000f
decl_stmt|;
if|if
condition|(
operator|(
name|mask
operator|&
literal|0x7
operator|)
operator|==
literal|0
condition|)
comment|/* no conversion needed */
empty_stmt|;
elseif|else
if|if
condition|(
operator|(
name|mask
operator|&
literal|0x3
operator|)
operator|==
literal|0
condition|)
name|mask
operator|^=
literal|0x8
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|mask
operator|&
literal|0x1
operator|)
operator|==
literal|0
condition|)
name|mask
operator|^=
literal|0xC
expr_stmt|;
else|else
name|mask
operator|^=
literal|0xE
expr_stmt|;
name|inst
operator|.
name|instruction
operator|&=
literal|0xfff0
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|mask
expr_stmt|;
block|}
name|inst
operator|.
name|instruction
operator||=
name|cond
operator|<<
literal|4
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Helper function used for both push/pop and ldm/stm.  */
end_comment

begin_function
specifier|static
name|void
name|encode_thumb2_ldmstm
parameter_list|(
name|int
name|base
parameter_list|,
name|unsigned
name|mask
parameter_list|,
name|bfd_boolean
name|writeback
parameter_list|)
block|{
name|bfd_boolean
name|load
decl_stmt|;
name|load
operator|=
operator|(
name|inst
operator|.
name|instruction
operator|&
operator|(
literal|1
operator|<<
literal|20
operator|)
operator|)
operator|!=
literal|0
expr_stmt|;
if|if
condition|(
name|mask
operator|&
operator|(
literal|1
operator|<<
literal|13
operator|)
condition|)
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"SP not allowed in register list"
argument_list|)
expr_stmt|;
if|if
condition|(
name|load
condition|)
block|{
if|if
condition|(
name|mask
operator|&
operator|(
literal|1
operator|<<
literal|14
operator|)
operator|&&
name|mask
operator|&
operator|(
literal|1
operator|<<
literal|15
operator|)
condition|)
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"LR and PC should not both be in register list"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|mask
operator|&
operator|(
literal|1
operator|<<
name|base
operator|)
operator|)
operator|!=
literal|0
operator|&&
name|writeback
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"base register should not be in register list "
literal|"when written back"
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|mask
operator|&
operator|(
literal|1
operator|<<
literal|15
operator|)
condition|)
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"PC not allowed in register list"
argument_list|)
expr_stmt|;
if|if
condition|(
name|mask
operator|&
operator|(
literal|1
operator|<<
name|base
operator|)
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"value stored for r%d is UNPREDICTABLE"
argument_list|)
argument_list|,
name|base
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|mask
operator|&
operator|(
name|mask
operator|-
literal|1
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* Single register transfers implemented as str/ldr.  */
if|if
condition|(
name|writeback
condition|)
block|{
if|if
condition|(
name|inst
operator|.
name|instruction
operator|&
operator|(
literal|1
operator|<<
literal|23
operator|)
condition|)
name|inst
operator|.
name|instruction
operator|=
literal|0x00000b04
expr_stmt|;
comment|/* ia! -> [base], #4 */
else|else
name|inst
operator|.
name|instruction
operator|=
literal|0x00000d04
expr_stmt|;
comment|/* db! -> [base, #-4]! */
block|}
else|else
block|{
if|if
condition|(
name|inst
operator|.
name|instruction
operator|&
operator|(
literal|1
operator|<<
literal|23
operator|)
condition|)
name|inst
operator|.
name|instruction
operator|=
literal|0x00800000
expr_stmt|;
comment|/* ia -> [base] */
else|else
name|inst
operator|.
name|instruction
operator|=
literal|0x00000c04
expr_stmt|;
comment|/* db -> [base, #-4] */
block|}
name|inst
operator|.
name|instruction
operator||=
literal|0xf8400000
expr_stmt|;
if|if
condition|(
name|load
condition|)
name|inst
operator|.
name|instruction
operator||=
literal|0x00100000
expr_stmt|;
name|mask
operator|=
name|ffs
argument_list|(
name|mask
argument_list|)
operator|-
literal|1
expr_stmt|;
name|mask
operator|<<=
literal|12
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|writeback
condition|)
name|inst
operator|.
name|instruction
operator||=
name|WRITE_BACK
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|mask
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|base
operator|<<
literal|16
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_t_ldmstm
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* This really doesn't seem worth it.  */
name|constraint
argument_list|(
name|inst
operator|.
name|reloc
operator|.
name|type
operator|!=
name|BFD_RELOC_UNUSED
argument_list|,
name|_
argument_list|(
literal|"expression too complex"
argument_list|)
argument_list|)
expr_stmt|;
name|constraint
argument_list|(
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|writeback
argument_list|,
name|_
argument_list|(
literal|"Thumb load/store multiple does not support {reglist}^"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|unified_syntax
condition|)
block|{
name|bfd_boolean
name|narrow
decl_stmt|;
name|unsigned
name|mask
decl_stmt|;
name|narrow
operator|=
name|FALSE
expr_stmt|;
comment|/* See if we can use a 16-bit instruction.  */
if|if
condition|(
name|inst
operator|.
name|instruction
operator|<
literal|0xffff
comment|/* not ldmdb/stmdb */
operator|&&
name|inst
operator|.
name|size_req
operator|!=
literal|4
operator|&&
operator|!
operator|(
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|imm
operator|&
operator|~
literal|0xff
operator|)
condition|)
block|{
name|mask
operator|=
literal|1
operator|<<
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
expr_stmt|;
if|if
condition|(
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
operator|<=
literal|7
operator|&&
operator|(
name|inst
operator|.
name|instruction
operator|==
name|T_MNEM_stmia
condition|?
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|writeback
else|:
operator|(
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|writeback
operator|==
operator|!
operator|(
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|imm
operator|&
name|mask
operator|)
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|inst
operator|.
name|instruction
operator|==
name|T_MNEM_stmia
operator|&&
operator|(
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|imm
operator|&
name|mask
operator|)
operator|&&
operator|(
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|imm
operator|&
operator|(
name|mask
operator|-
literal|1
operator|)
operator|)
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"value stored for r%d is UNPREDICTABLE"
argument_list|)
argument_list|,
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
argument_list|)
expr_stmt|;
name|inst
operator|.
name|instruction
operator|=
name|THUMB_OP16
argument_list|(
name|inst
operator|.
name|instruction
argument_list|)
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
operator|<<
literal|8
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|imm
expr_stmt|;
name|narrow
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
operator|==
name|REG_SP
operator|&&
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|writeback
condition|)
block|{
name|inst
operator|.
name|instruction
operator|=
name|THUMB_OP16
argument_list|(
name|inst
operator|.
name|instruction
operator|==
name|T_MNEM_stmia
condition|?
name|T_MNEM_push
else|:
name|T_MNEM_pop
argument_list|)
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|imm
expr_stmt|;
name|narrow
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|narrow
condition|)
block|{
if|if
condition|(
name|inst
operator|.
name|instruction
operator|<
literal|0xffff
condition|)
name|inst
operator|.
name|instruction
operator|=
name|THUMB_OP32
argument_list|(
name|inst
operator|.
name|instruction
argument_list|)
expr_stmt|;
name|encode_thumb2_ldmstm
argument_list|(
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
argument_list|,
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|imm
argument_list|,
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|writeback
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|constraint
argument_list|(
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
operator|>
literal|7
operator|||
operator|(
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|imm
operator|&
operator|~
literal|0xff
operator|)
argument_list|,
name|BAD_HIREG
argument_list|)
expr_stmt|;
name|constraint
argument_list|(
name|inst
operator|.
name|instruction
operator|!=
name|T_MNEM_ldmia
operator|&&
name|inst
operator|.
name|instruction
operator|!=
name|T_MNEM_stmia
argument_list|,
name|_
argument_list|(
literal|"Thumb-2 instruction only valid in unified syntax"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|inst
operator|.
name|instruction
operator|==
name|T_MNEM_stmia
condition|)
block|{
if|if
condition|(
operator|!
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|writeback
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"this instruction will write back the base register"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|imm
operator|&
operator|(
literal|1
operator|<<
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
operator|)
operator|)
operator|&&
operator|(
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|imm
operator|&
operator|(
operator|(
literal|1
operator|<<
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
operator|)
operator|-
literal|1
operator|)
operator|)
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"value stored for r%d is UNPREDICTABLE"
argument_list|)
argument_list|,
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|writeback
operator|&&
operator|!
operator|(
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|imm
operator|&
operator|(
literal|1
operator|<<
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
operator|)
operator|)
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"this instruction will write back the base register"
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|writeback
operator|&&
operator|(
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|imm
operator|&
operator|(
literal|1
operator|<<
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
operator|)
operator|)
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"this instruction will not write back the base register"
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|inst
operator|.
name|instruction
operator|=
name|THUMB_OP16
argument_list|(
name|inst
operator|.
name|instruction
argument_list|)
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
operator|<<
literal|8
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|imm
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|do_t_ldrex
parameter_list|(
name|void
parameter_list|)
block|{
name|constraint
argument_list|(
operator|!
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|isreg
operator|||
operator|!
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|preind
operator|||
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|postind
operator|||
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|writeback
operator|||
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|immisreg
operator|||
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|shifted
operator|||
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|negative
argument_list|,
name|BAD_ADDR_MODE
argument_list|)
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
operator|<<
literal|12
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
operator|<<
literal|16
expr_stmt|;
name|inst
operator|.
name|reloc
operator|.
name|type
operator|=
name|BFD_RELOC_ARM_T32_OFFSET_U8
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_t_ldrexd
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|present
condition|)
block|{
name|constraint
argument_list|(
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
operator|==
name|REG_LR
argument_list|,
name|_
argument_list|(
literal|"r14 not allowed as first register "
literal|"when second register is omitted"
argument_list|)
argument_list|)
expr_stmt|;
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
operator|=
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
operator|+
literal|1
expr_stmt|;
block|}
name|constraint
argument_list|(
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
operator|==
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
argument_list|,
name|BAD_OVERLAP
argument_list|)
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
operator|<<
literal|12
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
operator|<<
literal|8
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|2
index|]
operator|.
name|reg
operator|<<
literal|16
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_t_ldst
parameter_list|(
name|void
parameter_list|)
block|{
name|unsigned
name|long
name|opcode
decl_stmt|;
name|int
name|Rn
decl_stmt|;
name|opcode
operator|=
name|inst
operator|.
name|instruction
expr_stmt|;
if|if
condition|(
name|unified_syntax
condition|)
block|{
if|if
condition|(
operator|!
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|isreg
condition|)
block|{
if|if
condition|(
name|opcode
operator|<=
literal|0xffff
condition|)
name|inst
operator|.
name|instruction
operator|=
name|THUMB_OP32
argument_list|(
name|opcode
argument_list|)
expr_stmt|;
if|if
condition|(
name|move_or_literal_pool
argument_list|(
literal|0
argument_list|,
comment|/*thumb_p=*/
name|TRUE
argument_list|,
comment|/*mode_3=*/
name|FALSE
argument_list|)
condition|)
return|return;
block|}
if|if
condition|(
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|isreg
operator|&&
operator|!
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|writeback
operator|&&
operator|!
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|shifted
operator|&&
operator|!
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|postind
operator|&&
operator|!
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|negative
operator|&&
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
operator|<=
literal|7
operator|&&
name|opcode
operator|<=
literal|0xffff
operator|&&
name|inst
operator|.
name|size_req
operator|!=
literal|4
condition|)
block|{
comment|/* Insn may have a 16-bit form.  */
name|Rn
operator|=
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
expr_stmt|;
if|if
condition|(
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|immisreg
condition|)
block|{
name|inst
operator|.
name|instruction
operator|=
name|THUMB_OP16
argument_list|(
name|opcode
argument_list|)
expr_stmt|;
comment|/* [Rn, Ri] */
if|if
condition|(
name|Rn
operator|<=
literal|7
operator|&&
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|imm
operator|<=
literal|7
condition|)
goto|goto
name|op16
goto|;
block|}
elseif|else
if|if
condition|(
operator|(
name|Rn
operator|<=
literal|7
operator|&&
name|opcode
operator|!=
name|T_MNEM_ldrsh
operator|&&
name|opcode
operator|!=
name|T_MNEM_ldrsb
operator|)
operator|||
operator|(
operator|(
name|Rn
operator|==
name|REG_PC
operator|||
name|Rn
operator|==
name|REG_SP
operator|)
operator|&&
name|opcode
operator|==
name|T_MNEM_ldr
operator|)
operator|||
operator|(
name|Rn
operator|==
name|REG_SP
operator|&&
name|opcode
operator|==
name|T_MNEM_str
operator|)
condition|)
block|{
comment|/* [Rn, #const] */
if|if
condition|(
name|Rn
operator|>
literal|7
condition|)
block|{
if|if
condition|(
name|Rn
operator|==
name|REG_PC
condition|)
block|{
if|if
condition|(
name|inst
operator|.
name|reloc
operator|.
name|pc_rel
condition|)
name|opcode
operator|=
name|T_MNEM_ldr_pc2
expr_stmt|;
else|else
name|opcode
operator|=
name|T_MNEM_ldr_pc
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|opcode
operator|==
name|T_MNEM_ldr
condition|)
name|opcode
operator|=
name|T_MNEM_ldr_sp
expr_stmt|;
else|else
name|opcode
operator|=
name|T_MNEM_str_sp
expr_stmt|;
block|}
name|inst
operator|.
name|instruction
operator|=
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
operator|<<
literal|8
expr_stmt|;
block|}
else|else
block|{
name|inst
operator|.
name|instruction
operator|=
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
operator|<<
literal|3
expr_stmt|;
block|}
name|inst
operator|.
name|instruction
operator||=
name|THUMB_OP16
argument_list|(
name|opcode
argument_list|)
expr_stmt|;
if|if
condition|(
name|inst
operator|.
name|size_req
operator|==
literal|2
condition|)
name|inst
operator|.
name|reloc
operator|.
name|type
operator|=
name|BFD_RELOC_ARM_THUMB_OFFSET
expr_stmt|;
else|else
name|inst
operator|.
name|relax
operator|=
name|opcode
expr_stmt|;
return|return;
block|}
block|}
comment|/* Definitely a 32-bit variant.  */
name|inst
operator|.
name|instruction
operator|=
name|THUMB_OP32
argument_list|(
name|opcode
argument_list|)
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
operator|<<
literal|12
expr_stmt|;
name|encode_thumb32_addr_mode
argument_list|(
literal|1
argument_list|,
comment|/*is_t=*/
name|FALSE
argument_list|,
comment|/*is_d=*/
name|FALSE
argument_list|)
expr_stmt|;
return|return;
block|}
name|constraint
argument_list|(
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
operator|>
literal|7
argument_list|,
name|BAD_HIREG
argument_list|)
expr_stmt|;
if|if
condition|(
name|inst
operator|.
name|instruction
operator|==
name|T_MNEM_ldrsh
operator|||
name|inst
operator|.
name|instruction
operator|==
name|T_MNEM_ldrsb
condition|)
block|{
comment|/* Only [Rn,Rm] is acceptable.  */
name|constraint
argument_list|(
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
operator|>
literal|7
operator|||
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|imm
operator|>
literal|7
argument_list|,
name|BAD_HIREG
argument_list|)
expr_stmt|;
name|constraint
argument_list|(
operator|!
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|isreg
operator|||
operator|!
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|immisreg
operator|||
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|postind
operator|||
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|shifted
operator|||
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|negative
argument_list|,
name|_
argument_list|(
literal|"Thumb does not support this addressing mode"
argument_list|)
argument_list|)
expr_stmt|;
name|inst
operator|.
name|instruction
operator|=
name|THUMB_OP16
argument_list|(
name|inst
operator|.
name|instruction
argument_list|)
expr_stmt|;
goto|goto
name|op16
goto|;
block|}
name|inst
operator|.
name|instruction
operator|=
name|THUMB_OP16
argument_list|(
name|inst
operator|.
name|instruction
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|isreg
condition|)
if|if
condition|(
name|move_or_literal_pool
argument_list|(
literal|0
argument_list|,
comment|/*thumb_p=*/
name|TRUE
argument_list|,
comment|/*mode_3=*/
name|FALSE
argument_list|)
condition|)
return|return;
name|constraint
argument_list|(
operator|!
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|preind
operator|||
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|shifted
operator|||
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|writeback
argument_list|,
name|_
argument_list|(
literal|"Thumb does not support this addressing mode"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
operator|==
name|REG_PC
operator|||
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
operator|==
name|REG_SP
condition|)
block|{
name|constraint
argument_list|(
name|inst
operator|.
name|instruction
operator|&
literal|0x0600
argument_list|,
name|_
argument_list|(
literal|"byte or halfword not valid for base register"
argument_list|)
argument_list|)
expr_stmt|;
name|constraint
argument_list|(
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
operator|==
name|REG_PC
operator|&&
operator|!
operator|(
name|inst
operator|.
name|instruction
operator|&
name|THUMB_LOAD_BIT
operator|)
argument_list|,
name|_
argument_list|(
literal|"r15 based store not allowed"
argument_list|)
argument_list|)
expr_stmt|;
name|constraint
argument_list|(
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|immisreg
argument_list|,
name|_
argument_list|(
literal|"invalid base register for register offset"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
operator|==
name|REG_PC
condition|)
name|inst
operator|.
name|instruction
operator|=
name|T_OPCODE_LDR_PC
expr_stmt|;
elseif|else
if|if
condition|(
name|inst
operator|.
name|instruction
operator|&
name|THUMB_LOAD_BIT
condition|)
name|inst
operator|.
name|instruction
operator|=
name|T_OPCODE_LDR_SP
expr_stmt|;
else|else
name|inst
operator|.
name|instruction
operator|=
name|T_OPCODE_STR_SP
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
operator|<<
literal|8
expr_stmt|;
name|inst
operator|.
name|reloc
operator|.
name|type
operator|=
name|BFD_RELOC_ARM_THUMB_OFFSET
expr_stmt|;
return|return;
block|}
name|constraint
argument_list|(
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
operator|>
literal|7
argument_list|,
name|BAD_HIREG
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|immisreg
condition|)
block|{
comment|/* Immediate offset.  */
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
operator|<<
literal|3
expr_stmt|;
name|inst
operator|.
name|reloc
operator|.
name|type
operator|=
name|BFD_RELOC_ARM_THUMB_OFFSET
expr_stmt|;
return|return;
block|}
comment|/* Register offset.  */
name|constraint
argument_list|(
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|imm
operator|>
literal|7
argument_list|,
name|BAD_HIREG
argument_list|)
expr_stmt|;
name|constraint
argument_list|(
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|negative
argument_list|,
name|_
argument_list|(
literal|"Thumb does not support this addressing mode"
argument_list|)
argument_list|)
expr_stmt|;
name|op16
label|:
switch|switch
condition|(
name|inst
operator|.
name|instruction
condition|)
block|{
case|case
name|T_OPCODE_STR_IW
case|:
name|inst
operator|.
name|instruction
operator|=
name|T_OPCODE_STR_RW
expr_stmt|;
break|break;
case|case
name|T_OPCODE_STR_IH
case|:
name|inst
operator|.
name|instruction
operator|=
name|T_OPCODE_STR_RH
expr_stmt|;
break|break;
case|case
name|T_OPCODE_STR_IB
case|:
name|inst
operator|.
name|instruction
operator|=
name|T_OPCODE_STR_RB
expr_stmt|;
break|break;
case|case
name|T_OPCODE_LDR_IW
case|:
name|inst
operator|.
name|instruction
operator|=
name|T_OPCODE_LDR_RW
expr_stmt|;
break|break;
case|case
name|T_OPCODE_LDR_IH
case|:
name|inst
operator|.
name|instruction
operator|=
name|T_OPCODE_LDR_RH
expr_stmt|;
break|break;
case|case
name|T_OPCODE_LDR_IB
case|:
name|inst
operator|.
name|instruction
operator|=
name|T_OPCODE_LDR_RB
expr_stmt|;
break|break;
case|case
literal|0x5600
comment|/* ldrsb */
case|:
case|case
literal|0x5e00
comment|/* ldrsh */
case|:
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
operator|<<
literal|3
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|imm
operator|<<
literal|6
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_t_ldstd
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|present
condition|)
block|{
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
operator|=
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
operator|+
literal|1
expr_stmt|;
name|constraint
argument_list|(
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
operator|==
name|REG_LR
argument_list|,
name|_
argument_list|(
literal|"r14 not allowed here"
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
operator|<<
literal|12
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
operator|<<
literal|8
expr_stmt|;
name|encode_thumb32_addr_mode
argument_list|(
literal|2
argument_list|,
comment|/*is_t=*/
name|FALSE
argument_list|,
comment|/*is_d=*/
name|TRUE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_t_ldstt
parameter_list|(
name|void
parameter_list|)
block|{
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
operator|<<
literal|12
expr_stmt|;
name|encode_thumb32_addr_mode
argument_list|(
literal|1
argument_list|,
comment|/*is_t=*/
name|TRUE
argument_list|,
comment|/*is_d=*/
name|FALSE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_t_mla
parameter_list|(
name|void
parameter_list|)
block|{
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
operator|<<
literal|8
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
operator|<<
literal|16
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|2
index|]
operator|.
name|reg
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|3
index|]
operator|.
name|reg
operator|<<
literal|12
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_t_mlal
parameter_list|(
name|void
parameter_list|)
block|{
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
operator|<<
literal|12
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
operator|<<
literal|8
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|2
index|]
operator|.
name|reg
operator|<<
literal|16
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|3
index|]
operator|.
name|reg
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_t_mov_cmp
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|unified_syntax
condition|)
block|{
name|int
name|r0off
init|=
operator|(
name|inst
operator|.
name|instruction
operator|==
name|T_MNEM_mov
operator|||
name|inst
operator|.
name|instruction
operator|==
name|T_MNEM_movs
operator|)
condition|?
literal|8
else|:
literal|16
decl_stmt|;
name|unsigned
name|long
name|opcode
decl_stmt|;
name|bfd_boolean
name|narrow
decl_stmt|;
name|bfd_boolean
name|low_regs
decl_stmt|;
name|low_regs
operator|=
operator|(
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
operator|<=
literal|7
operator|&&
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
operator|<=
literal|7
operator|)
expr_stmt|;
name|opcode
operator|=
name|inst
operator|.
name|instruction
expr_stmt|;
if|if
condition|(
name|current_it_mask
condition|)
name|narrow
operator|=
name|opcode
operator|!=
name|T_MNEM_movs
expr_stmt|;
else|else
name|narrow
operator|=
name|opcode
operator|!=
name|T_MNEM_movs
operator|||
name|low_regs
expr_stmt|;
if|if
condition|(
name|inst
operator|.
name|size_req
operator|==
literal|4
operator|||
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|shifted
condition|)
name|narrow
operator|=
name|FALSE
expr_stmt|;
comment|/* MOVS PC, LR is encoded as SUBS PC, LR, #0.  */
if|if
condition|(
name|opcode
operator|==
name|T_MNEM_movs
operator|&&
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|isreg
operator|&&
operator|!
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|shifted
operator|&&
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
operator|==
name|REG_PC
operator|&&
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
operator|==
name|REG_LR
condition|)
block|{
name|inst
operator|.
name|instruction
operator|=
name|T2_SUBS_PC_LR
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|isreg
condition|)
block|{
comment|/* Immediate operand.  */
if|if
condition|(
name|current_it_mask
operator|==
literal|0
operator|&&
name|opcode
operator|==
name|T_MNEM_mov
condition|)
name|narrow
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|low_regs
operator|&&
name|narrow
condition|)
block|{
name|inst
operator|.
name|instruction
operator|=
name|THUMB_OP16
argument_list|(
name|opcode
argument_list|)
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
operator|<<
literal|8
expr_stmt|;
if|if
condition|(
name|inst
operator|.
name|size_req
operator|==
literal|2
condition|)
name|inst
operator|.
name|reloc
operator|.
name|type
operator|=
name|BFD_RELOC_ARM_THUMB_IMM
expr_stmt|;
else|else
name|inst
operator|.
name|relax
operator|=
name|opcode
expr_stmt|;
block|}
else|else
block|{
name|inst
operator|.
name|instruction
operator|=
name|THUMB_OP32
argument_list|(
name|inst
operator|.
name|instruction
argument_list|)
expr_stmt|;
name|inst
operator|.
name|instruction
operator|=
operator|(
name|inst
operator|.
name|instruction
operator|&
literal|0xe1ffffff
operator|)
operator||
literal|0x10000000
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
operator|<<
name|r0off
expr_stmt|;
name|inst
operator|.
name|reloc
operator|.
name|type
operator|=
name|BFD_RELOC_ARM_T32_IMMEDIATE
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|shifted
operator|&&
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|immisreg
operator|&&
operator|(
name|inst
operator|.
name|instruction
operator|==
name|T_MNEM_mov
operator|||
name|inst
operator|.
name|instruction
operator|==
name|T_MNEM_movs
operator|)
condition|)
block|{
comment|/* Register shifts are encoded as separate shift instructions.  */
name|bfd_boolean
name|flags
init|=
operator|(
name|inst
operator|.
name|instruction
operator|==
name|T_MNEM_movs
operator|)
decl_stmt|;
if|if
condition|(
name|current_it_mask
condition|)
name|narrow
operator|=
operator|!
name|flags
expr_stmt|;
else|else
name|narrow
operator|=
name|flags
expr_stmt|;
if|if
condition|(
name|inst
operator|.
name|size_req
operator|==
literal|4
condition|)
name|narrow
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
operator|!
name|low_regs
operator|||
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|imm
operator|>
literal|7
condition|)
name|narrow
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
operator|!=
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
condition|)
name|narrow
operator|=
name|FALSE
expr_stmt|;
switch|switch
condition|(
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|shift_kind
condition|)
block|{
case|case
name|SHIFT_LSL
case|:
name|opcode
operator|=
name|narrow
condition|?
name|T_OPCODE_LSL_R
else|:
name|THUMB_OP32
argument_list|(
name|T_MNEM_lsl
argument_list|)
expr_stmt|;
break|break;
case|case
name|SHIFT_ASR
case|:
name|opcode
operator|=
name|narrow
condition|?
name|T_OPCODE_ASR_R
else|:
name|THUMB_OP32
argument_list|(
name|T_MNEM_asr
argument_list|)
expr_stmt|;
break|break;
case|case
name|SHIFT_LSR
case|:
name|opcode
operator|=
name|narrow
condition|?
name|T_OPCODE_LSR_R
else|:
name|THUMB_OP32
argument_list|(
name|T_MNEM_lsr
argument_list|)
expr_stmt|;
break|break;
case|case
name|SHIFT_ROR
case|:
name|opcode
operator|=
name|narrow
condition|?
name|T_OPCODE_ROR_R
else|:
name|THUMB_OP32
argument_list|(
name|T_MNEM_ror
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|inst
operator|.
name|instruction
operator|=
name|opcode
expr_stmt|;
if|if
condition|(
name|narrow
condition|)
block|{
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|imm
operator|<<
literal|3
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|flags
condition|)
name|inst
operator|.
name|instruction
operator||=
name|CONDS_BIT
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
operator|<<
literal|8
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
operator|<<
literal|16
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|imm
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|narrow
condition|)
block|{
comment|/* Some mov with immediate shift have narrow variants. 	     Register shifts are handled above.  */
if|if
condition|(
name|low_regs
operator|&&
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|shifted
operator|&&
operator|(
name|inst
operator|.
name|instruction
operator|==
name|T_MNEM_mov
operator|||
name|inst
operator|.
name|instruction
operator|==
name|T_MNEM_movs
operator|)
condition|)
block|{
if|if
condition|(
name|current_it_mask
condition|)
name|narrow
operator|=
operator|(
name|inst
operator|.
name|instruction
operator|==
name|T_MNEM_mov
operator|)
expr_stmt|;
else|else
name|narrow
operator|=
operator|(
name|inst
operator|.
name|instruction
operator|==
name|T_MNEM_movs
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|narrow
condition|)
block|{
switch|switch
condition|(
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|shift_kind
condition|)
block|{
case|case
name|SHIFT_LSL
case|:
name|inst
operator|.
name|instruction
operator|=
name|T_OPCODE_LSL_I
expr_stmt|;
break|break;
case|case
name|SHIFT_LSR
case|:
name|inst
operator|.
name|instruction
operator|=
name|T_OPCODE_LSR_I
expr_stmt|;
break|break;
case|case
name|SHIFT_ASR
case|:
name|inst
operator|.
name|instruction
operator|=
name|T_OPCODE_ASR_I
expr_stmt|;
break|break;
default|default:
name|narrow
operator|=
name|FALSE
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|narrow
condition|)
block|{
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
operator|<<
literal|3
expr_stmt|;
name|inst
operator|.
name|reloc
operator|.
name|type
operator|=
name|BFD_RELOC_ARM_THUMB_SHIFT
expr_stmt|;
block|}
else|else
block|{
name|inst
operator|.
name|instruction
operator|=
name|THUMB_OP32
argument_list|(
name|inst
operator|.
name|instruction
argument_list|)
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
operator|<<
name|r0off
expr_stmt|;
name|encode_thumb32_shifted_operand
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
else|else
switch|switch
condition|(
name|inst
operator|.
name|instruction
condition|)
block|{
case|case
name|T_MNEM_mov
case|:
name|inst
operator|.
name|instruction
operator|=
name|T_OPCODE_MOV_HR
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
operator|(
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
operator|&
literal|0x8
operator|)
operator|<<
literal|4
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
operator|(
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
operator|&
literal|0x7
operator|)
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
operator|<<
literal|3
expr_stmt|;
break|break;
case|case
name|T_MNEM_movs
case|:
comment|/* We know we have low registers at this point. 	       Generate ADD Rd, Rs, #0.  */
name|inst
operator|.
name|instruction
operator|=
name|T_OPCODE_ADD_I3
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
operator|<<
literal|3
expr_stmt|;
break|break;
case|case
name|T_MNEM_cmp
case|:
if|if
condition|(
name|low_regs
condition|)
block|{
name|inst
operator|.
name|instruction
operator|=
name|T_OPCODE_CMP_LR
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
operator|<<
literal|3
expr_stmt|;
block|}
else|else
block|{
name|inst
operator|.
name|instruction
operator|=
name|T_OPCODE_CMP_HR
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
operator|(
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
operator|&
literal|0x8
operator|)
operator|<<
literal|4
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
operator|(
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
operator|&
literal|0x7
operator|)
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
operator|<<
literal|3
expr_stmt|;
block|}
break|break;
block|}
return|return;
block|}
name|inst
operator|.
name|instruction
operator|=
name|THUMB_OP16
argument_list|(
name|inst
operator|.
name|instruction
argument_list|)
expr_stmt|;
if|if
condition|(
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|isreg
condition|)
block|{
if|if
condition|(
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
operator|<
literal|8
operator|&&
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
operator|<
literal|8
condition|)
block|{
comment|/* A move of two lowregs is encoded as ADD Rd, Rs, #0 	     since a MOV instruction produces unpredictable results.  */
if|if
condition|(
name|inst
operator|.
name|instruction
operator|==
name|T_OPCODE_MOV_I8
condition|)
name|inst
operator|.
name|instruction
operator|=
name|T_OPCODE_ADD_I3
expr_stmt|;
else|else
name|inst
operator|.
name|instruction
operator|=
name|T_OPCODE_CMP_LR
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
operator|<<
literal|3
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|inst
operator|.
name|instruction
operator|==
name|T_OPCODE_MOV_I8
condition|)
name|inst
operator|.
name|instruction
operator|=
name|T_OPCODE_MOV_HR
expr_stmt|;
else|else
name|inst
operator|.
name|instruction
operator|=
name|T_OPCODE_CMP_HR
expr_stmt|;
name|do_t_cpy
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
name|constraint
argument_list|(
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
operator|>
literal|7
argument_list|,
name|_
argument_list|(
literal|"only lo regs allowed with immediate"
argument_list|)
argument_list|)
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
operator|<<
literal|8
expr_stmt|;
name|inst
operator|.
name|reloc
operator|.
name|type
operator|=
name|BFD_RELOC_ARM_THUMB_IMM
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|do_t_mov16
parameter_list|(
name|void
parameter_list|)
block|{
name|bfd_vma
name|imm
decl_stmt|;
name|bfd_boolean
name|top
decl_stmt|;
name|top
operator|=
operator|(
name|inst
operator|.
name|instruction
operator|&
literal|0x00800000
operator|)
operator|!=
literal|0
expr_stmt|;
if|if
condition|(
name|inst
operator|.
name|reloc
operator|.
name|type
operator|==
name|BFD_RELOC_ARM_MOVW
condition|)
block|{
name|constraint
argument_list|(
name|top
argument_list|,
name|_
argument_list|(
literal|":lower16: not allowed this instruction"
argument_list|)
argument_list|)
expr_stmt|;
name|inst
operator|.
name|reloc
operator|.
name|type
operator|=
name|BFD_RELOC_ARM_THUMB_MOVW
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|inst
operator|.
name|reloc
operator|.
name|type
operator|==
name|BFD_RELOC_ARM_MOVT
condition|)
block|{
name|constraint
argument_list|(
operator|!
name|top
argument_list|,
name|_
argument_list|(
literal|":upper16: not allowed this instruction"
argument_list|)
argument_list|)
expr_stmt|;
name|inst
operator|.
name|reloc
operator|.
name|type
operator|=
name|BFD_RELOC_ARM_THUMB_MOVT
expr_stmt|;
block|}
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
operator|<<
literal|8
expr_stmt|;
if|if
condition|(
name|inst
operator|.
name|reloc
operator|.
name|type
operator|==
name|BFD_RELOC_UNUSED
condition|)
block|{
name|imm
operator|=
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_add_number
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
operator|(
name|imm
operator|&
literal|0xf000
operator|)
operator|<<
literal|4
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
operator|(
name|imm
operator|&
literal|0x0800
operator|)
operator|<<
literal|15
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
operator|(
name|imm
operator|&
literal|0x0700
operator|)
operator|<<
literal|4
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
operator|(
name|imm
operator|&
literal|0x00ff
operator|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|do_t_mvn_tst
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|unified_syntax
condition|)
block|{
name|int
name|r0off
init|=
operator|(
name|inst
operator|.
name|instruction
operator|==
name|T_MNEM_mvn
operator|||
name|inst
operator|.
name|instruction
operator|==
name|T_MNEM_mvns
operator|)
condition|?
literal|8
else|:
literal|16
decl_stmt|;
name|bfd_boolean
name|narrow
decl_stmt|;
if|if
condition|(
name|inst
operator|.
name|size_req
operator|==
literal|4
operator|||
name|inst
operator|.
name|instruction
operator|>
literal|0xffff
operator|||
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|shifted
operator|||
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
operator|>
literal|7
operator|||
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
operator|>
literal|7
condition|)
name|narrow
operator|=
name|FALSE
expr_stmt|;
elseif|else
if|if
condition|(
name|inst
operator|.
name|instruction
operator|==
name|T_MNEM_cmn
condition|)
name|narrow
operator|=
name|TRUE
expr_stmt|;
elseif|else
if|if
condition|(
name|THUMB_SETS_FLAGS
argument_list|(
name|inst
operator|.
name|instruction
argument_list|)
condition|)
name|narrow
operator|=
operator|(
name|current_it_mask
operator|==
literal|0
operator|)
expr_stmt|;
else|else
name|narrow
operator|=
operator|(
name|current_it_mask
operator|!=
literal|0
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|isreg
condition|)
block|{
comment|/* For an immediate, we always generate a 32-bit opcode; 	     section relaxation will shrink it later if possible.  */
if|if
condition|(
name|inst
operator|.
name|instruction
operator|<
literal|0xffff
condition|)
name|inst
operator|.
name|instruction
operator|=
name|THUMB_OP32
argument_list|(
name|inst
operator|.
name|instruction
argument_list|)
expr_stmt|;
name|inst
operator|.
name|instruction
operator|=
operator|(
name|inst
operator|.
name|instruction
operator|&
literal|0xe1ffffff
operator|)
operator||
literal|0x10000000
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
operator|<<
name|r0off
expr_stmt|;
name|inst
operator|.
name|reloc
operator|.
name|type
operator|=
name|BFD_RELOC_ARM_T32_IMMEDIATE
expr_stmt|;
block|}
else|else
block|{
comment|/* See if we can do this with a 16-bit instruction.  */
if|if
condition|(
name|narrow
condition|)
block|{
name|inst
operator|.
name|instruction
operator|=
name|THUMB_OP16
argument_list|(
name|inst
operator|.
name|instruction
argument_list|)
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
operator|<<
literal|3
expr_stmt|;
block|}
else|else
block|{
name|constraint
argument_list|(
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|shifted
operator|&&
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|immisreg
argument_list|,
name|_
argument_list|(
literal|"shift must be constant"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|inst
operator|.
name|instruction
operator|<
literal|0xffff
condition|)
name|inst
operator|.
name|instruction
operator|=
name|THUMB_OP32
argument_list|(
name|inst
operator|.
name|instruction
argument_list|)
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
operator|<<
name|r0off
expr_stmt|;
name|encode_thumb32_shifted_operand
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|constraint
argument_list|(
name|inst
operator|.
name|instruction
operator|>
literal|0xffff
operator|||
name|inst
operator|.
name|instruction
operator|==
name|T_MNEM_mvns
argument_list|,
name|BAD_THUMB32
argument_list|)
expr_stmt|;
name|constraint
argument_list|(
operator|!
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|isreg
operator|||
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|shifted
argument_list|,
name|_
argument_list|(
literal|"unshifted register required"
argument_list|)
argument_list|)
expr_stmt|;
name|constraint
argument_list|(
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
operator|>
literal|7
operator|||
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
operator|>
literal|7
argument_list|,
name|BAD_HIREG
argument_list|)
expr_stmt|;
name|inst
operator|.
name|instruction
operator|=
name|THUMB_OP16
argument_list|(
name|inst
operator|.
name|instruction
argument_list|)
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
operator|<<
literal|3
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|do_t_mrs
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|flags
decl_stmt|;
if|if
condition|(
name|do_vfp_nsyn_mrs
argument_list|()
operator|==
name|SUCCESS
condition|)
return|return;
name|flags
operator|=
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|imm
operator|&
operator|(
name|PSR_c
operator||
name|PSR_x
operator||
name|PSR_s
operator||
name|PSR_f
operator||
name|SPSR_BIT
operator|)
expr_stmt|;
if|if
condition|(
name|flags
operator|==
literal|0
condition|)
block|{
name|constraint
argument_list|(
operator|!
name|ARM_CPU_HAS_FEATURE
argument_list|(
name|cpu_variant
argument_list|,
name|arm_ext_v7m
argument_list|)
argument_list|,
name|_
argument_list|(
literal|"selected processor does not support "
literal|"requested special purpose register"
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|constraint
argument_list|(
operator|!
name|ARM_CPU_HAS_FEATURE
argument_list|(
name|cpu_variant
argument_list|,
name|arm_ext_v1
argument_list|)
argument_list|,
name|_
argument_list|(
literal|"selected processor does not support "
literal|"requested special purpose register %x"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* mrs only accepts CPSR/SPSR/CPSR_all/SPSR_all.  */
name|constraint
argument_list|(
operator|(
name|flags
operator|&
operator|~
name|SPSR_BIT
operator|)
operator|!=
operator|(
name|PSR_c
operator||
name|PSR_f
operator|)
argument_list|,
name|_
argument_list|(
literal|"'CPSR' or 'SPSR' expected"
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
operator|<<
literal|8
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
operator|(
name|flags
operator|&
name|SPSR_BIT
operator|)
operator|>>
literal|2
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|imm
operator|&
literal|0xff
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_t_msr
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|flags
decl_stmt|;
if|if
condition|(
name|do_vfp_nsyn_msr
argument_list|()
operator|==
name|SUCCESS
condition|)
return|return;
name|constraint
argument_list|(
operator|!
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|isreg
argument_list|,
name|_
argument_list|(
literal|"Thumb encoding does not support an immediate here"
argument_list|)
argument_list|)
expr_stmt|;
name|flags
operator|=
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|imm
expr_stmt|;
if|if
condition|(
name|flags
operator|&
operator|~
literal|0xff
condition|)
block|{
name|constraint
argument_list|(
operator|!
name|ARM_CPU_HAS_FEATURE
argument_list|(
name|cpu_variant
argument_list|,
name|arm_ext_v1
argument_list|)
argument_list|,
name|_
argument_list|(
literal|"selected processor does not support "
literal|"requested special purpose register"
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|constraint
argument_list|(
operator|!
name|ARM_CPU_HAS_FEATURE
argument_list|(
name|cpu_variant
argument_list|,
name|arm_ext_v7m
argument_list|)
argument_list|,
name|_
argument_list|(
literal|"selected processor does not support "
literal|"requested special purpose register"
argument_list|)
argument_list|)
expr_stmt|;
name|flags
operator||=
name|PSR_f
expr_stmt|;
block|}
name|inst
operator|.
name|instruction
operator||=
operator|(
name|flags
operator|&
name|SPSR_BIT
operator|)
operator|>>
literal|2
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
operator|(
name|flags
operator|&
operator|~
name|SPSR_BIT
operator|)
operator|>>
literal|8
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
operator|(
name|flags
operator|&
literal|0xff
operator|)
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
operator|<<
literal|16
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_t_mul
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
name|inst
operator|.
name|operands
index|[
literal|2
index|]
operator|.
name|present
condition|)
name|inst
operator|.
name|operands
index|[
literal|2
index|]
operator|.
name|reg
operator|=
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
expr_stmt|;
comment|/* There is no 32-bit MULS and no 16-bit MUL. */
if|if
condition|(
name|unified_syntax
operator|&&
name|inst
operator|.
name|instruction
operator|==
name|T_MNEM_mul
condition|)
block|{
name|inst
operator|.
name|instruction
operator|=
name|THUMB_OP32
argument_list|(
name|inst
operator|.
name|instruction
argument_list|)
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
operator|<<
literal|8
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
operator|<<
literal|16
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|2
index|]
operator|.
name|reg
operator|<<
literal|0
expr_stmt|;
block|}
else|else
block|{
name|constraint
argument_list|(
operator|!
name|unified_syntax
operator|&&
name|inst
operator|.
name|instruction
operator|==
name|T_MNEM_muls
argument_list|,
name|BAD_THUMB32
argument_list|)
expr_stmt|;
name|constraint
argument_list|(
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
operator|>
literal|7
operator|||
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
operator|>
literal|7
argument_list|,
name|BAD_HIREG
argument_list|)
expr_stmt|;
name|inst
operator|.
name|instruction
operator|=
name|THUMB_OP16
argument_list|(
name|inst
operator|.
name|instruction
argument_list|)
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
expr_stmt|;
if|if
condition|(
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
operator|==
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
condition|)
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|2
index|]
operator|.
name|reg
operator|<<
literal|3
expr_stmt|;
elseif|else
if|if
condition|(
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
operator|==
name|inst
operator|.
name|operands
index|[
literal|2
index|]
operator|.
name|reg
condition|)
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
operator|<<
literal|3
expr_stmt|;
else|else
name|constraint
argument_list|(
literal|1
argument_list|,
name|_
argument_list|(
literal|"dest must overlap one source register"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|do_t_mull
parameter_list|(
name|void
parameter_list|)
block|{
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
operator|<<
literal|12
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
operator|<<
literal|8
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|2
index|]
operator|.
name|reg
operator|<<
literal|16
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|3
index|]
operator|.
name|reg
expr_stmt|;
if|if
condition|(
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
operator|==
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
condition|)
name|as_tsktsk
argument_list|(
name|_
argument_list|(
literal|"rdhi and rdlo must be different"
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_t_nop
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|unified_syntax
condition|)
block|{
if|if
condition|(
name|inst
operator|.
name|size_req
operator|==
literal|4
operator|||
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|imm
operator|>
literal|15
condition|)
block|{
name|inst
operator|.
name|instruction
operator|=
name|THUMB_OP32
argument_list|(
name|inst
operator|.
name|instruction
argument_list|)
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|imm
expr_stmt|;
block|}
else|else
block|{
name|inst
operator|.
name|instruction
operator|=
name|THUMB_OP16
argument_list|(
name|inst
operator|.
name|instruction
argument_list|)
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|imm
operator|<<
literal|4
expr_stmt|;
block|}
block|}
else|else
block|{
name|constraint
argument_list|(
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|present
argument_list|,
name|_
argument_list|(
literal|"Thumb does not support NOP with hints"
argument_list|)
argument_list|)
expr_stmt|;
name|inst
operator|.
name|instruction
operator|=
literal|0x46c0
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|do_t_neg
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|unified_syntax
condition|)
block|{
name|bfd_boolean
name|narrow
decl_stmt|;
if|if
condition|(
name|THUMB_SETS_FLAGS
argument_list|(
name|inst
operator|.
name|instruction
argument_list|)
condition|)
name|narrow
operator|=
operator|(
name|current_it_mask
operator|==
literal|0
operator|)
expr_stmt|;
else|else
name|narrow
operator|=
operator|(
name|current_it_mask
operator|!=
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
operator|>
literal|7
operator|||
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
operator|>
literal|7
condition|)
name|narrow
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|inst
operator|.
name|size_req
operator|==
literal|4
condition|)
name|narrow
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
operator|!
name|narrow
condition|)
block|{
name|inst
operator|.
name|instruction
operator|=
name|THUMB_OP32
argument_list|(
name|inst
operator|.
name|instruction
argument_list|)
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
operator|<<
literal|8
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
operator|<<
literal|16
expr_stmt|;
block|}
else|else
block|{
name|inst
operator|.
name|instruction
operator|=
name|THUMB_OP16
argument_list|(
name|inst
operator|.
name|instruction
argument_list|)
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
operator|<<
literal|3
expr_stmt|;
block|}
block|}
else|else
block|{
name|constraint
argument_list|(
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
operator|>
literal|7
operator|||
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
operator|>
literal|7
argument_list|,
name|BAD_HIREG
argument_list|)
expr_stmt|;
name|constraint
argument_list|(
name|THUMB_SETS_FLAGS
argument_list|(
name|inst
operator|.
name|instruction
argument_list|)
argument_list|,
name|BAD_THUMB32
argument_list|)
expr_stmt|;
name|inst
operator|.
name|instruction
operator|=
name|THUMB_OP16
argument_list|(
name|inst
operator|.
name|instruction
argument_list|)
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
operator|<<
literal|3
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|do_t_pkhbt
parameter_list|(
name|void
parameter_list|)
block|{
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
operator|<<
literal|8
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
operator|<<
literal|16
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|2
index|]
operator|.
name|reg
expr_stmt|;
if|if
condition|(
name|inst
operator|.
name|operands
index|[
literal|3
index|]
operator|.
name|present
condition|)
block|{
name|unsigned
name|int
name|val
init|=
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_add_number
decl_stmt|;
name|constraint
argument_list|(
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_op
operator|!=
name|O_constant
argument_list|,
name|_
argument_list|(
literal|"expression too complex"
argument_list|)
argument_list|)
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
operator|(
name|val
operator|&
literal|0x1c
operator|)
operator|<<
literal|10
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
operator|(
name|val
operator|&
literal|0x03
operator|)
operator|<<
literal|6
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|do_t_pkhtb
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
name|inst
operator|.
name|operands
index|[
literal|3
index|]
operator|.
name|present
condition|)
name|inst
operator|.
name|instruction
operator|&=
operator|~
literal|0x00000020
expr_stmt|;
name|do_t_pkhbt
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_t_pld
parameter_list|(
name|void
parameter_list|)
block|{
name|encode_thumb32_addr_mode
argument_list|(
literal|0
argument_list|,
comment|/*is_t=*/
name|FALSE
argument_list|,
comment|/*is_d=*/
name|FALSE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_t_push_pop
parameter_list|(
name|void
parameter_list|)
block|{
name|unsigned
name|mask
decl_stmt|;
name|constraint
argument_list|(
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|writeback
argument_list|,
name|_
argument_list|(
literal|"push/pop do not support {reglist}^"
argument_list|)
argument_list|)
expr_stmt|;
name|constraint
argument_list|(
name|inst
operator|.
name|reloc
operator|.
name|type
operator|!=
name|BFD_RELOC_UNUSED
argument_list|,
name|_
argument_list|(
literal|"expression too complex"
argument_list|)
argument_list|)
expr_stmt|;
name|mask
operator|=
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|imm
expr_stmt|;
if|if
condition|(
operator|(
name|mask
operator|&
operator|~
literal|0xff
operator|)
operator|==
literal|0
condition|)
name|inst
operator|.
name|instruction
operator|=
name|THUMB_OP16
argument_list|(
name|inst
operator|.
name|instruction
argument_list|)
operator||
name|mask
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|inst
operator|.
name|instruction
operator|==
name|T_MNEM_push
operator|&&
operator|(
name|mask
operator|&
operator|~
literal|0xff
operator|)
operator|==
literal|1
operator|<<
name|REG_LR
operator|)
operator|||
operator|(
name|inst
operator|.
name|instruction
operator|==
name|T_MNEM_pop
operator|&&
operator|(
name|mask
operator|&
operator|~
literal|0xff
operator|)
operator|==
literal|1
operator|<<
name|REG_PC
operator|)
condition|)
block|{
name|inst
operator|.
name|instruction
operator|=
name|THUMB_OP16
argument_list|(
name|inst
operator|.
name|instruction
argument_list|)
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|THUMB_PP_PC_LR
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|mask
operator|&
literal|0xff
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|unified_syntax
condition|)
block|{
name|inst
operator|.
name|instruction
operator|=
name|THUMB_OP32
argument_list|(
name|inst
operator|.
name|instruction
argument_list|)
expr_stmt|;
name|encode_thumb2_ldmstm
argument_list|(
literal|13
argument_list|,
name|mask
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"invalid register list to push/pop instruction"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|do_t_rbit
parameter_list|(
name|void
parameter_list|)
block|{
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
operator|<<
literal|8
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
operator|<<
literal|16
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_t_rd_rm
parameter_list|(
name|void
parameter_list|)
block|{
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
operator|<<
literal|8
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_t_rev
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
operator|<=
literal|7
operator|&&
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
operator|<=
literal|7
operator|&&
name|inst
operator|.
name|size_req
operator|!=
literal|4
condition|)
block|{
name|inst
operator|.
name|instruction
operator|=
name|THUMB_OP16
argument_list|(
name|inst
operator|.
name|instruction
argument_list|)
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
operator|<<
literal|3
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|unified_syntax
condition|)
block|{
name|inst
operator|.
name|instruction
operator|=
name|THUMB_OP32
argument_list|(
name|inst
operator|.
name|instruction
argument_list|)
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
operator|<<
literal|8
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
operator|<<
literal|16
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
expr_stmt|;
block|}
else|else
name|inst
operator|.
name|error
operator|=
name|BAD_HIREG
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_t_rsb
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|Rd
decl_stmt|,
name|Rs
decl_stmt|;
name|Rd
operator|=
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
expr_stmt|;
name|Rs
operator|=
operator|(
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|present
condition|?
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
comment|/* Rd, Rs, foo */
else|:
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
operator|)
expr_stmt|;
comment|/* Rd, foo -> Rd, Rd, foo */
name|inst
operator|.
name|instruction
operator||=
name|Rd
operator|<<
literal|8
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|Rs
operator|<<
literal|16
expr_stmt|;
if|if
condition|(
operator|!
name|inst
operator|.
name|operands
index|[
literal|2
index|]
operator|.
name|isreg
condition|)
block|{
name|bfd_boolean
name|narrow
decl_stmt|;
if|if
condition|(
operator|(
name|inst
operator|.
name|instruction
operator|&
literal|0x00100000
operator|)
operator|!=
literal|0
condition|)
name|narrow
operator|=
operator|(
name|current_it_mask
operator|==
literal|0
operator|)
expr_stmt|;
else|else
name|narrow
operator|=
operator|(
name|current_it_mask
operator|!=
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|Rd
operator|>
literal|7
operator|||
name|Rs
operator|>
literal|7
condition|)
name|narrow
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|inst
operator|.
name|size_req
operator|==
literal|4
operator|||
operator|!
name|unified_syntax
condition|)
name|narrow
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_op
operator|!=
name|O_constant
operator|||
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_add_number
operator|!=
literal|0
condition|)
name|narrow
operator|=
name|FALSE
expr_stmt|;
comment|/* Turn rsb #0 into 16-bit neg.  We should probably do this via          relaxation, but it doesn't seem worth the hassle.  */
if|if
condition|(
name|narrow
condition|)
block|{
name|inst
operator|.
name|reloc
operator|.
name|type
operator|=
name|BFD_RELOC_UNUSED
expr_stmt|;
name|inst
operator|.
name|instruction
operator|=
name|THUMB_OP16
argument_list|(
name|T_MNEM_negs
argument_list|)
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|Rs
operator|<<
literal|3
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|Rd
expr_stmt|;
block|}
else|else
block|{
name|inst
operator|.
name|instruction
operator|=
operator|(
name|inst
operator|.
name|instruction
operator|&
literal|0xe1ffffff
operator|)
operator||
literal|0x10000000
expr_stmt|;
name|inst
operator|.
name|reloc
operator|.
name|type
operator|=
name|BFD_RELOC_ARM_T32_IMMEDIATE
expr_stmt|;
block|}
block|}
else|else
name|encode_thumb32_shifted_operand
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_t_setend
parameter_list|(
name|void
parameter_list|)
block|{
name|constraint
argument_list|(
name|current_it_mask
argument_list|,
name|BAD_NOT_IT
argument_list|)
expr_stmt|;
if|if
condition|(
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|imm
condition|)
name|inst
operator|.
name|instruction
operator||=
literal|0x8
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_t_shift
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|present
condition|)
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
operator|=
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
expr_stmt|;
if|if
condition|(
name|unified_syntax
condition|)
block|{
name|bfd_boolean
name|narrow
decl_stmt|;
name|int
name|shift_kind
decl_stmt|;
switch|switch
condition|(
name|inst
operator|.
name|instruction
condition|)
block|{
case|case
name|T_MNEM_asr
case|:
case|case
name|T_MNEM_asrs
case|:
name|shift_kind
operator|=
name|SHIFT_ASR
expr_stmt|;
break|break;
case|case
name|T_MNEM_lsl
case|:
case|case
name|T_MNEM_lsls
case|:
name|shift_kind
operator|=
name|SHIFT_LSL
expr_stmt|;
break|break;
case|case
name|T_MNEM_lsr
case|:
case|case
name|T_MNEM_lsrs
case|:
name|shift_kind
operator|=
name|SHIFT_LSR
expr_stmt|;
break|break;
case|case
name|T_MNEM_ror
case|:
case|case
name|T_MNEM_rors
case|:
name|shift_kind
operator|=
name|SHIFT_ROR
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|THUMB_SETS_FLAGS
argument_list|(
name|inst
operator|.
name|instruction
argument_list|)
condition|)
name|narrow
operator|=
operator|(
name|current_it_mask
operator|==
literal|0
operator|)
expr_stmt|;
else|else
name|narrow
operator|=
operator|(
name|current_it_mask
operator|!=
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
operator|>
literal|7
operator|||
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
operator|>
literal|7
condition|)
name|narrow
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
operator|!
name|inst
operator|.
name|operands
index|[
literal|2
index|]
operator|.
name|isreg
operator|&&
name|shift_kind
operator|==
name|SHIFT_ROR
condition|)
name|narrow
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|inst
operator|.
name|operands
index|[
literal|2
index|]
operator|.
name|isreg
operator|&&
operator|(
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
operator|!=
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
operator|||
name|inst
operator|.
name|operands
index|[
literal|2
index|]
operator|.
name|reg
operator|>
literal|7
operator|)
condition|)
name|narrow
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|inst
operator|.
name|size_req
operator|==
literal|4
condition|)
name|narrow
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
operator|!
name|narrow
condition|)
block|{
if|if
condition|(
name|inst
operator|.
name|operands
index|[
literal|2
index|]
operator|.
name|isreg
condition|)
block|{
name|inst
operator|.
name|instruction
operator|=
name|THUMB_OP32
argument_list|(
name|inst
operator|.
name|instruction
argument_list|)
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
operator|<<
literal|8
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
operator|<<
literal|16
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|2
index|]
operator|.
name|reg
expr_stmt|;
block|}
else|else
block|{
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|shifted
operator|=
literal|1
expr_stmt|;
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|shift_kind
operator|=
name|shift_kind
expr_stmt|;
name|inst
operator|.
name|instruction
operator|=
name|THUMB_OP32
argument_list|(
name|THUMB_SETS_FLAGS
argument_list|(
name|inst
operator|.
name|instruction
argument_list|)
condition|?
name|T_MNEM_movs
else|:
name|T_MNEM_mov
argument_list|)
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
operator|<<
literal|8
expr_stmt|;
name|encode_thumb32_shifted_operand
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* Prevent the incorrect generation of an ARM_IMMEDIATE fixup.  */
name|inst
operator|.
name|reloc
operator|.
name|type
operator|=
name|BFD_RELOC_UNUSED
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|inst
operator|.
name|operands
index|[
literal|2
index|]
operator|.
name|isreg
condition|)
block|{
switch|switch
condition|(
name|shift_kind
condition|)
block|{
case|case
name|SHIFT_ASR
case|:
name|inst
operator|.
name|instruction
operator|=
name|T_OPCODE_ASR_R
expr_stmt|;
break|break;
case|case
name|SHIFT_LSL
case|:
name|inst
operator|.
name|instruction
operator|=
name|T_OPCODE_LSL_R
expr_stmt|;
break|break;
case|case
name|SHIFT_LSR
case|:
name|inst
operator|.
name|instruction
operator|=
name|T_OPCODE_LSR_R
expr_stmt|;
break|break;
case|case
name|SHIFT_ROR
case|:
name|inst
operator|.
name|instruction
operator|=
name|T_OPCODE_ROR_R
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|2
index|]
operator|.
name|reg
operator|<<
literal|3
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
name|shift_kind
condition|)
block|{
case|case
name|SHIFT_ASR
case|:
name|inst
operator|.
name|instruction
operator|=
name|T_OPCODE_ASR_I
expr_stmt|;
break|break;
case|case
name|SHIFT_LSL
case|:
name|inst
operator|.
name|instruction
operator|=
name|T_OPCODE_LSL_I
expr_stmt|;
break|break;
case|case
name|SHIFT_LSR
case|:
name|inst
operator|.
name|instruction
operator|=
name|T_OPCODE_LSR_I
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|inst
operator|.
name|reloc
operator|.
name|type
operator|=
name|BFD_RELOC_ARM_THUMB_SHIFT
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
operator|<<
literal|3
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|constraint
argument_list|(
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
operator|>
literal|7
operator|||
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
operator|>
literal|7
argument_list|,
name|BAD_HIREG
argument_list|)
expr_stmt|;
name|constraint
argument_list|(
name|THUMB_SETS_FLAGS
argument_list|(
name|inst
operator|.
name|instruction
argument_list|)
argument_list|,
name|BAD_THUMB32
argument_list|)
expr_stmt|;
if|if
condition|(
name|inst
operator|.
name|operands
index|[
literal|2
index|]
operator|.
name|isreg
condition|)
comment|/* Rd, {Rs,} Rn */
block|{
name|constraint
argument_list|(
name|inst
operator|.
name|operands
index|[
literal|2
index|]
operator|.
name|reg
operator|>
literal|7
argument_list|,
name|BAD_HIREG
argument_list|)
expr_stmt|;
name|constraint
argument_list|(
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
operator|!=
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
argument_list|,
name|_
argument_list|(
literal|"source1 and dest must be same register"
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|inst
operator|.
name|instruction
condition|)
block|{
case|case
name|T_MNEM_asr
case|:
name|inst
operator|.
name|instruction
operator|=
name|T_OPCODE_ASR_R
expr_stmt|;
break|break;
case|case
name|T_MNEM_lsl
case|:
name|inst
operator|.
name|instruction
operator|=
name|T_OPCODE_LSL_R
expr_stmt|;
break|break;
case|case
name|T_MNEM_lsr
case|:
name|inst
operator|.
name|instruction
operator|=
name|T_OPCODE_LSR_R
expr_stmt|;
break|break;
case|case
name|T_MNEM_ror
case|:
name|inst
operator|.
name|instruction
operator|=
name|T_OPCODE_ROR_R
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|2
index|]
operator|.
name|reg
operator|<<
literal|3
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
name|inst
operator|.
name|instruction
condition|)
block|{
case|case
name|T_MNEM_asr
case|:
name|inst
operator|.
name|instruction
operator|=
name|T_OPCODE_ASR_I
expr_stmt|;
break|break;
case|case
name|T_MNEM_lsl
case|:
name|inst
operator|.
name|instruction
operator|=
name|T_OPCODE_LSL_I
expr_stmt|;
break|break;
case|case
name|T_MNEM_lsr
case|:
name|inst
operator|.
name|instruction
operator|=
name|T_OPCODE_LSR_I
expr_stmt|;
break|break;
case|case
name|T_MNEM_ror
case|:
name|inst
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"ror #imm not supported"
argument_list|)
expr_stmt|;
return|return;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|inst
operator|.
name|reloc
operator|.
name|type
operator|=
name|BFD_RELOC_ARM_THUMB_SHIFT
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
operator|<<
literal|3
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|do_t_simd
parameter_list|(
name|void
parameter_list|)
block|{
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
operator|<<
literal|8
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
operator|<<
literal|16
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|2
index|]
operator|.
name|reg
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_t_smc
parameter_list|(
name|void
parameter_list|)
block|{
name|unsigned
name|int
name|value
init|=
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_add_number
decl_stmt|;
name|constraint
argument_list|(
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_op
operator|!=
name|O_constant
argument_list|,
name|_
argument_list|(
literal|"expression too complex"
argument_list|)
argument_list|)
expr_stmt|;
name|inst
operator|.
name|reloc
operator|.
name|type
operator|=
name|BFD_RELOC_UNUSED
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
operator|(
name|value
operator|&
literal|0xf000
operator|)
operator|>>
literal|12
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
operator|(
name|value
operator|&
literal|0x0ff0
operator|)
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
operator|(
name|value
operator|&
literal|0x000f
operator|)
operator|<<
literal|16
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_t_ssat
parameter_list|(
name|void
parameter_list|)
block|{
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
operator|<<
literal|8
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|imm
operator|-
literal|1
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|2
index|]
operator|.
name|reg
operator|<<
literal|16
expr_stmt|;
if|if
condition|(
name|inst
operator|.
name|operands
index|[
literal|3
index|]
operator|.
name|present
condition|)
block|{
name|constraint
argument_list|(
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_op
operator|!=
name|O_constant
argument_list|,
name|_
argument_list|(
literal|"expression too complex"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_add_number
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|inst
operator|.
name|operands
index|[
literal|3
index|]
operator|.
name|shift_kind
operator|==
name|SHIFT_ASR
condition|)
name|inst
operator|.
name|instruction
operator||=
literal|0x00200000
expr_stmt|;
comment|/* sh bit */
name|inst
operator|.
name|instruction
operator||=
operator|(
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_add_number
operator|&
literal|0x1c
operator|)
operator|<<
literal|10
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
operator|(
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_add_number
operator|&
literal|0x03
operator|)
operator|<<
literal|6
expr_stmt|;
block|}
name|inst
operator|.
name|reloc
operator|.
name|type
operator|=
name|BFD_RELOC_UNUSED
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|do_t_ssat16
parameter_list|(
name|void
parameter_list|)
block|{
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
operator|<<
literal|8
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|imm
operator|-
literal|1
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|2
index|]
operator|.
name|reg
operator|<<
literal|16
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_t_strex
parameter_list|(
name|void
parameter_list|)
block|{
name|constraint
argument_list|(
operator|!
name|inst
operator|.
name|operands
index|[
literal|2
index|]
operator|.
name|isreg
operator|||
operator|!
name|inst
operator|.
name|operands
index|[
literal|2
index|]
operator|.
name|preind
operator|||
name|inst
operator|.
name|operands
index|[
literal|2
index|]
operator|.
name|postind
operator|||
name|inst
operator|.
name|operands
index|[
literal|2
index|]
operator|.
name|writeback
operator|||
name|inst
operator|.
name|operands
index|[
literal|2
index|]
operator|.
name|immisreg
operator|||
name|inst
operator|.
name|operands
index|[
literal|2
index|]
operator|.
name|shifted
operator|||
name|inst
operator|.
name|operands
index|[
literal|2
index|]
operator|.
name|negative
argument_list|,
name|BAD_ADDR_MODE
argument_list|)
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
operator|<<
literal|8
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
operator|<<
literal|12
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|2
index|]
operator|.
name|reg
operator|<<
literal|16
expr_stmt|;
name|inst
operator|.
name|reloc
operator|.
name|type
operator|=
name|BFD_RELOC_ARM_T32_OFFSET_U8
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_t_strexd
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
name|inst
operator|.
name|operands
index|[
literal|2
index|]
operator|.
name|present
condition|)
name|inst
operator|.
name|operands
index|[
literal|2
index|]
operator|.
name|reg
operator|=
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
operator|+
literal|1
expr_stmt|;
name|constraint
argument_list|(
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
operator|==
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
operator|||
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
operator|==
name|inst
operator|.
name|operands
index|[
literal|2
index|]
operator|.
name|reg
operator|||
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
operator|==
name|inst
operator|.
name|operands
index|[
literal|3
index|]
operator|.
name|reg
operator|||
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
operator|==
name|inst
operator|.
name|operands
index|[
literal|2
index|]
operator|.
name|reg
argument_list|,
name|BAD_OVERLAP
argument_list|)
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
operator|<<
literal|12
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|2
index|]
operator|.
name|reg
operator|<<
literal|8
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|3
index|]
operator|.
name|reg
operator|<<
literal|16
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_t_sxtah
parameter_list|(
name|void
parameter_list|)
block|{
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
operator|<<
literal|8
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
operator|<<
literal|16
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|2
index|]
operator|.
name|reg
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|3
index|]
operator|.
name|imm
operator|<<
literal|4
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_t_sxth
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|inst
operator|.
name|instruction
operator|<=
literal|0xffff
operator|&&
name|inst
operator|.
name|size_req
operator|!=
literal|4
operator|&&
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
operator|<=
literal|7
operator|&&
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
operator|<=
literal|7
operator|&&
operator|(
operator|!
name|inst
operator|.
name|operands
index|[
literal|2
index|]
operator|.
name|present
operator|||
name|inst
operator|.
name|operands
index|[
literal|2
index|]
operator|.
name|imm
operator|==
literal|0
operator|)
condition|)
block|{
name|inst
operator|.
name|instruction
operator|=
name|THUMB_OP16
argument_list|(
name|inst
operator|.
name|instruction
argument_list|)
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
operator|<<
literal|3
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|unified_syntax
condition|)
block|{
if|if
condition|(
name|inst
operator|.
name|instruction
operator|<=
literal|0xffff
condition|)
name|inst
operator|.
name|instruction
operator|=
name|THUMB_OP32
argument_list|(
name|inst
operator|.
name|instruction
argument_list|)
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
operator|<<
literal|8
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|2
index|]
operator|.
name|imm
operator|<<
literal|4
expr_stmt|;
block|}
else|else
block|{
name|constraint
argument_list|(
name|inst
operator|.
name|operands
index|[
literal|2
index|]
operator|.
name|present
operator|&&
name|inst
operator|.
name|operands
index|[
literal|2
index|]
operator|.
name|imm
operator|!=
literal|0
argument_list|,
name|_
argument_list|(
literal|"Thumb encoding does not support rotation"
argument_list|)
argument_list|)
expr_stmt|;
name|constraint
argument_list|(
literal|1
argument_list|,
name|BAD_HIREG
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|do_t_swi
parameter_list|(
name|void
parameter_list|)
block|{
name|inst
operator|.
name|reloc
operator|.
name|type
operator|=
name|BFD_RELOC_ARM_SWI
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_t_tb
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|half
decl_stmt|;
name|half
operator|=
operator|(
name|inst
operator|.
name|instruction
operator|&
literal|0x10
operator|)
operator|!=
literal|0
expr_stmt|;
name|constraint
argument_list|(
name|current_it_mask
operator|&&
name|current_it_mask
operator|!=
literal|0x10
argument_list|,
name|BAD_BRANCH
argument_list|)
expr_stmt|;
name|constraint
argument_list|(
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|immisreg
argument_list|,
name|_
argument_list|(
literal|"instruction requires register index"
argument_list|)
argument_list|)
expr_stmt|;
name|constraint
argument_list|(
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|imm
operator|==
literal|15
argument_list|,
name|_
argument_list|(
literal|"PC is not a valid index register"
argument_list|)
argument_list|)
expr_stmt|;
name|constraint
argument_list|(
operator|!
name|half
operator|&&
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|shifted
argument_list|,
name|_
argument_list|(
literal|"instruction does not allow shifted index"
argument_list|)
argument_list|)
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
operator|(
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
operator|<<
literal|16
operator|)
operator||
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|imm
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_t_usat
parameter_list|(
name|void
parameter_list|)
block|{
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
operator|<<
literal|8
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|imm
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|2
index|]
operator|.
name|reg
operator|<<
literal|16
expr_stmt|;
if|if
condition|(
name|inst
operator|.
name|operands
index|[
literal|3
index|]
operator|.
name|present
condition|)
block|{
name|constraint
argument_list|(
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_op
operator|!=
name|O_constant
argument_list|,
name|_
argument_list|(
literal|"expression too complex"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_add_number
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|inst
operator|.
name|operands
index|[
literal|3
index|]
operator|.
name|shift_kind
operator|==
name|SHIFT_ASR
condition|)
name|inst
operator|.
name|instruction
operator||=
literal|0x00200000
expr_stmt|;
comment|/* sh bit */
name|inst
operator|.
name|instruction
operator||=
operator|(
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_add_number
operator|&
literal|0x1c
operator|)
operator|<<
literal|10
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
operator|(
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_add_number
operator|&
literal|0x03
operator|)
operator|<<
literal|6
expr_stmt|;
block|}
name|inst
operator|.
name|reloc
operator|.
name|type
operator|=
name|BFD_RELOC_UNUSED
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|do_t_usat16
parameter_list|(
name|void
parameter_list|)
block|{
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
operator|<<
literal|8
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|imm
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|2
index|]
operator|.
name|reg
operator|<<
literal|16
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Neon instruction encoder helpers.  */
end_comment

begin_comment
comment|/* Encodings for the different types for various Neon opcodes.  */
end_comment

begin_comment
comment|/* An "invalid" code for the following tables.  */
end_comment

begin_define
define|#
directive|define
name|N_INV
value|-1u
end_define

begin_struct
struct|struct
name|neon_tab_entry
block|{
name|unsigned
name|integer
decl_stmt|;
name|unsigned
name|float_or_poly
decl_stmt|;
name|unsigned
name|scalar_or_imm
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Map overloaded Neon opcodes to their respective encodings.  */
end_comment

begin_define
define|#
directive|define
name|NEON_ENC_TAB
define|\
value|X(vabd,	0x0000700, 0x1200d00, N_INV),		\   X(vmax,	0x0000600, 0x0000f00, N_INV),		\   X(vmin,	0x0000610, 0x0200f00, N_INV),		\   X(vpadd,	0x0000b10, 0x1000d00, N_INV),		\   X(vpmax,	0x0000a00, 0x1000f00, N_INV),		\   X(vpmin,	0x0000a10, 0x1200f00, N_INV),		\   X(vadd,	0x0000800, 0x0000d00, N_INV),		\   X(vsub,	0x1000800, 0x0200d00, N_INV),		\   X(vceq,	0x1000810, 0x0000e00, 0x1b10100),	\   X(vcge,	0x0000310, 0x1000e00, 0x1b10080),	\   X(vcgt,	0x0000300, 0x1200e00, 0x1b10000),	\
comment|/* Register variants of the following two instructions are encoded as      vcge / vcgt with the operands reversed. */
value|\   X(vclt,	0x0000300, 0x1200e00, 0x1b10200),	\   X(vcle,	0x0000310, 0x1000e00, 0x1b10180),	\   X(vmla,	0x0000900, 0x0000d10, 0x0800040),	\   X(vmls,	0x1000900, 0x0200d10, 0x0800440),	\   X(vmul,	0x0000910, 0x1000d10, 0x0800840),	\   X(vmull,	0x0800c00, 0x0800e00, 0x0800a40),
comment|/* polynomial not float.  */
value|\   X(vmlal,	0x0800800, N_INV,     0x0800240),	\   X(vmlsl,	0x0800a00, N_INV,     0x0800640),	\   X(vqdmlal,	0x0800900, N_INV,     0x0800340),	\   X(vqdmlsl,	0x0800b00, N_INV,     0x0800740),	\   X(vqdmull,	0x0800d00, N_INV,     0x0800b40),	\   X(vqdmulh,    0x0000b00, N_INV,     0x0800c40),	\   X(vqrdmulh,   0x1000b00, N_INV,     0x0800d40),	\   X(vshl,	0x0000400, N_INV,     0x0800510),	\   X(vqshl,	0x0000410, N_INV,     0x0800710),	\   X(vand,	0x0000110, N_INV,     0x0800030),	\   X(vbic,	0x0100110, N_INV,     0x0800030),	\   X(veor,	0x1000110, N_INV,     N_INV),		\   X(vorn,	0x0300110, N_INV,     0x0800010),	\   X(vorr,	0x0200110, N_INV,     0x0800010),	\   X(vmvn,	0x1b00580, N_INV,     0x0800030),	\   X(vshll,	0x1b20300, N_INV,     0x0800a10),
comment|/* max shift, immediate.  */
value|\   X(vcvt,       0x1b30600, N_INV,     0x0800e10),
comment|/* integer, fixed-point.  */
value|\   X(vdup,       0xe800b10, N_INV,     0x1b00c00),
comment|/* arm, scalar.  */
value|\   X(vld1,       0x0200000, 0x0a00000, 0x0a00c00),
comment|/* interlv, lane, dup.  */
value|\   X(vst1,	0x0000000, 0x0800000, N_INV),		\   X(vld2,	0x0200100, 0x0a00100, 0x0a00d00),	\   X(vst2,	0x0000100, 0x0800100, N_INV),		\   X(vld3,	0x0200200, 0x0a00200, 0x0a00e00),	\   X(vst3,	0x0000200, 0x0800200, N_INV),		\   X(vld4,	0x0200300, 0x0a00300, 0x0a00f00),	\   X(vst4,	0x0000300, 0x0800300, N_INV),		\   X(vmovn,	0x1b20200, N_INV,     N_INV),		\   X(vtrn,	0x1b20080, N_INV,     N_INV),		\   X(vqmovn,	0x1b20200, N_INV,     N_INV),		\   X(vqmovun,	0x1b20240, N_INV,     N_INV),		\   X(vnmul,      0xe200a40, 0xe200b40, N_INV),		\   X(vnmla,      0xe000a40, 0xe000b40, N_INV),		\   X(vnmls,      0xe100a40, 0xe100b40, N_INV),		\   X(vcmp,	0xeb40a40, 0xeb40b40, N_INV),		\   X(vcmpz,	0xeb50a40, 0xeb50b40, N_INV),		\   X(vcmpe,	0xeb40ac0, 0xeb40bc0, N_INV),		\   X(vcmpez,     0xeb50ac0, 0xeb50bc0, N_INV)
end_define

begin_enum
enum|enum
name|neon_opc
block|{
define|#
directive|define
name|X
parameter_list|(
name|OPC
parameter_list|,
name|I
parameter_list|,
name|F
parameter_list|,
name|S
parameter_list|)
value|N_MNEM_##OPC
name|NEON_ENC_TAB
undef|#
directive|undef
name|X
block|}
enum|;
end_enum

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|neon_tab_entry
name|neon_enc_tab
index|[]
init|=
block|{
define|#
directive|define
name|X
parameter_list|(
name|OPC
parameter_list|,
name|I
parameter_list|,
name|F
parameter_list|,
name|S
parameter_list|)
value|{ (I), (F), (S) }
name|NEON_ENC_TAB
undef|#
directive|undef
name|X
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|NEON_ENC_INTEGER
parameter_list|(
name|X
parameter_list|)
value|(neon_enc_tab[(X)& 0x0fffffff].integer)
end_define

begin_define
define|#
directive|define
name|NEON_ENC_ARMREG
parameter_list|(
name|X
parameter_list|)
value|(neon_enc_tab[(X)& 0x0fffffff].integer)
end_define

begin_define
define|#
directive|define
name|NEON_ENC_POLY
parameter_list|(
name|X
parameter_list|)
value|(neon_enc_tab[(X)& 0x0fffffff].float_or_poly)
end_define

begin_define
define|#
directive|define
name|NEON_ENC_FLOAT
parameter_list|(
name|X
parameter_list|)
value|(neon_enc_tab[(X)& 0x0fffffff].float_or_poly)
end_define

begin_define
define|#
directive|define
name|NEON_ENC_SCALAR
parameter_list|(
name|X
parameter_list|)
value|(neon_enc_tab[(X)& 0x0fffffff].scalar_or_imm)
end_define

begin_define
define|#
directive|define
name|NEON_ENC_IMMED
parameter_list|(
name|X
parameter_list|)
value|(neon_enc_tab[(X)& 0x0fffffff].scalar_or_imm)
end_define

begin_define
define|#
directive|define
name|NEON_ENC_INTERLV
parameter_list|(
name|X
parameter_list|)
value|(neon_enc_tab[(X)& 0x0fffffff].integer)
end_define

begin_define
define|#
directive|define
name|NEON_ENC_LANE
parameter_list|(
name|X
parameter_list|)
value|(neon_enc_tab[(X)& 0x0fffffff].float_or_poly)
end_define

begin_define
define|#
directive|define
name|NEON_ENC_DUP
parameter_list|(
name|X
parameter_list|)
value|(neon_enc_tab[(X)& 0x0fffffff].scalar_or_imm)
end_define

begin_define
define|#
directive|define
name|NEON_ENC_SINGLE
parameter_list|(
name|X
parameter_list|)
define|\
value|((neon_enc_tab[(X)& 0x0fffffff].integer) | ((X)& 0xf0000000))
end_define

begin_define
define|#
directive|define
name|NEON_ENC_DOUBLE
parameter_list|(
name|X
parameter_list|)
define|\
value|((neon_enc_tab[(X)& 0x0fffffff].float_or_poly) | ((X)& 0xf0000000))
end_define

begin_comment
comment|/* Define shapes for instruction operands. The following mnemonic characters    are used in this table:       F - VFP S<n> register      D - Neon D<n> register      Q - Neon Q<n> register      I - Immediate      S - Scalar      R - ARM register      L - D<n> register list        This table is used to generate various data:      - enumerations of the form NS_DDR to be used as arguments to        neon_select_shape.      - a table classifying shapes into single, double, quad, mixed.      - a table used to drive neon_select_shape. */
end_comment

begin_define
define|#
directive|define
name|NEON_SHAPE_DEF
define|\
value|X(3, (D, D, D), DOUBLE),		\   X(3, (Q, Q, Q), QUAD),		\   X(3, (D, D, I), DOUBLE),		\   X(3, (Q, Q, I), QUAD),		\   X(3, (D, D, S), DOUBLE),		\   X(3, (Q, Q, S), QUAD),		\   X(2, (D, D), DOUBLE),			\   X(2, (Q, Q), QUAD),			\   X(2, (D, S), DOUBLE),			\   X(2, (Q, S), QUAD),			\   X(2, (D, R), DOUBLE),			\   X(2, (Q, R), QUAD),			\   X(2, (D, I), DOUBLE),			\   X(2, (Q, I), QUAD),			\   X(3, (D, L, D), DOUBLE),		\   X(2, (D, Q), MIXED),			\   X(2, (Q, D), MIXED),			\   X(3, (D, Q, I), MIXED),		\   X(3, (Q, D, I), MIXED),		\   X(3, (Q, D, D), MIXED),		\   X(3, (D, Q, Q), MIXED),		\   X(3, (Q, Q, D), MIXED),		\   X(3, (Q, D, S), MIXED),		\   X(3, (D, Q, S), MIXED),		\   X(4, (D, D, D, I), DOUBLE),		\   X(4, (Q, Q, Q, I), QUAD),		\   X(2, (F, F), SINGLE),			\   X(3, (F, F, F), SINGLE),		\   X(2, (F, I), SINGLE),			\   X(2, (F, D), MIXED),			\   X(2, (D, F), MIXED),			\   X(3, (F, F, I), MIXED),		\   X(4, (R, R, F, F), SINGLE),		\   X(4, (F, F, R, R), SINGLE),		\   X(3, (D, R, R), DOUBLE),		\   X(3, (R, R, D), DOUBLE),		\   X(2, (S, R), SINGLE),			\   X(2, (R, S), SINGLE),			\   X(2, (F, R), SINGLE),			\   X(2, (R, F), SINGLE)
end_define

begin_define
define|#
directive|define
name|S2
parameter_list|(
name|A
parameter_list|,
name|B
parameter_list|)
value|NS_##A##B
end_define

begin_define
define|#
directive|define
name|S3
parameter_list|(
name|A
parameter_list|,
name|B
parameter_list|,
name|C
parameter_list|)
value|NS_##A##B##C
end_define

begin_define
define|#
directive|define
name|S4
parameter_list|(
name|A
parameter_list|,
name|B
parameter_list|,
name|C
parameter_list|,
name|D
parameter_list|)
value|NS_##A##B##C##D
end_define

begin_define
define|#
directive|define
name|X
parameter_list|(
name|N
parameter_list|,
name|L
parameter_list|,
name|C
parameter_list|)
value|S##N L
end_define

begin_enum
enum|enum
name|neon_shape
block|{
name|NEON_SHAPE_DEF
block|,
name|NS_NULL
block|}
enum|;
end_enum

begin_undef
undef|#
directive|undef
name|X
end_undef

begin_undef
undef|#
directive|undef
name|S2
end_undef

begin_undef
undef|#
directive|undef
name|S3
end_undef

begin_undef
undef|#
directive|undef
name|S4
end_undef

begin_enum
enum|enum
name|neon_shape_class
block|{
name|SC_SINGLE
block|,
name|SC_DOUBLE
block|,
name|SC_QUAD
block|,
name|SC_MIXED
block|}
enum|;
end_enum

begin_define
define|#
directive|define
name|X
parameter_list|(
name|N
parameter_list|,
name|L
parameter_list|,
name|C
parameter_list|)
value|SC_##C
end_define

begin_decl_stmt
specifier|static
name|enum
name|neon_shape_class
name|neon_shape_class
index|[]
init|=
block|{
name|NEON_SHAPE_DEF
block|}
decl_stmt|;
end_decl_stmt

begin_undef
undef|#
directive|undef
name|X
end_undef

begin_enum
enum|enum
name|neon_shape_el
block|{
name|SE_F
block|,
name|SE_D
block|,
name|SE_Q
block|,
name|SE_I
block|,
name|SE_S
block|,
name|SE_R
block|,
name|SE_L
block|}
enum|;
end_enum

begin_comment
comment|/* Register widths of above.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|neon_shape_el_size
index|[]
init|=
block|{
literal|32
block|,
literal|64
block|,
literal|128
block|,
literal|0
block|,
literal|32
block|,
literal|32
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|neon_shape_info
block|{
name|unsigned
name|els
decl_stmt|;
name|enum
name|neon_shape_el
name|el
index|[
name|NEON_MAX_TYPE_ELS
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|S2
parameter_list|(
name|A
parameter_list|,
name|B
parameter_list|)
value|{ SE_##A, SE_##B }
end_define

begin_define
define|#
directive|define
name|S3
parameter_list|(
name|A
parameter_list|,
name|B
parameter_list|,
name|C
parameter_list|)
value|{ SE_##A, SE_##B, SE_##C }
end_define

begin_define
define|#
directive|define
name|S4
parameter_list|(
name|A
parameter_list|,
name|B
parameter_list|,
name|C
parameter_list|,
name|D
parameter_list|)
value|{ SE_##A, SE_##B, SE_##C, SE_##D }
end_define

begin_define
define|#
directive|define
name|X
parameter_list|(
name|N
parameter_list|,
name|L
parameter_list|,
name|C
parameter_list|)
value|{ N, S##N L }
end_define

begin_decl_stmt
specifier|static
name|struct
name|neon_shape_info
name|neon_shape_tab
index|[]
init|=
block|{
name|NEON_SHAPE_DEF
block|}
decl_stmt|;
end_decl_stmt

begin_undef
undef|#
directive|undef
name|X
end_undef

begin_undef
undef|#
directive|undef
name|S2
end_undef

begin_undef
undef|#
directive|undef
name|S3
end_undef

begin_undef
undef|#
directive|undef
name|S4
end_undef

begin_comment
comment|/* Bit masks used in type checking given instructions.   'N_EQK' means the type must be the same as (or based on in some way) the key    type, which itself is marked with the 'N_KEY' bit. If the 'N_EQK' bit is    set, various other bits can be set as well in order to modify the meaning of    the type constraint.  */
end_comment

begin_enum
enum|enum
name|neon_type_mask
block|{
name|N_S8
init|=
literal|0x000001
block|,
name|N_S16
init|=
literal|0x000002
block|,
name|N_S32
init|=
literal|0x000004
block|,
name|N_S64
init|=
literal|0x000008
block|,
name|N_U8
init|=
literal|0x000010
block|,
name|N_U16
init|=
literal|0x000020
block|,
name|N_U32
init|=
literal|0x000040
block|,
name|N_U64
init|=
literal|0x000080
block|,
name|N_I8
init|=
literal|0x000100
block|,
name|N_I16
init|=
literal|0x000200
block|,
name|N_I32
init|=
literal|0x000400
block|,
name|N_I64
init|=
literal|0x000800
block|,
name|N_8
init|=
literal|0x001000
block|,
name|N_16
init|=
literal|0x002000
block|,
name|N_32
init|=
literal|0x004000
block|,
name|N_64
init|=
literal|0x008000
block|,
name|N_P8
init|=
literal|0x010000
block|,
name|N_P16
init|=
literal|0x020000
block|,
name|N_F32
init|=
literal|0x040000
block|,
name|N_F64
init|=
literal|0x080000
block|,
name|N_KEY
init|=
literal|0x100000
block|,
comment|/* key element (main type specifier).  */
name|N_EQK
init|=
literal|0x200000
block|,
comment|/* given operand has the same type& size as the key.  */
name|N_VFP
init|=
literal|0x400000
block|,
comment|/* VFP mode: operand size must match register width.  */
name|N_DBL
init|=
literal|0x000001
block|,
comment|/* if N_EQK, this operand is twice the size.  */
name|N_HLF
init|=
literal|0x000002
block|,
comment|/* if N_EQK, this operand is half the size.  */
name|N_SGN
init|=
literal|0x000004
block|,
comment|/* if N_EQK, this operand is forced to be signed.  */
name|N_UNS
init|=
literal|0x000008
block|,
comment|/* if N_EQK, this operand is forced to be unsigned.  */
name|N_INT
init|=
literal|0x000010
block|,
comment|/* if N_EQK, this operand is forced to be integer.  */
name|N_FLT
init|=
literal|0x000020
block|,
comment|/* if N_EQK, this operand is forced to be float.  */
name|N_SIZ
init|=
literal|0x000040
block|,
comment|/* if N_EQK, this operand is forced to be size-only.  */
name|N_UTYP
init|=
literal|0
block|,
name|N_MAX_NONSPECIAL
init|=
name|N_F64
block|}
enum|;
end_enum

begin_define
define|#
directive|define
name|N_ALLMODS
value|(N_DBL | N_HLF | N_SGN | N_UNS | N_INT | N_FLT | N_SIZ)
end_define

begin_define
define|#
directive|define
name|N_SU_ALL
value|(N_S8 | N_S16 | N_S32 | N_S64 | N_U8 | N_U16 | N_U32 | N_U64)
end_define

begin_define
define|#
directive|define
name|N_SU_32
value|(N_S8 | N_S16 | N_S32 | N_U8 | N_U16 | N_U32)
end_define

begin_define
define|#
directive|define
name|N_SU_16_64
value|(N_S16 | N_S32 | N_S64 | N_U16 | N_U32 | N_U64)
end_define

begin_define
define|#
directive|define
name|N_SUF_32
value|(N_SU_32 | N_F32)
end_define

begin_define
define|#
directive|define
name|N_I_ALL
value|(N_I8 | N_I16 | N_I32 | N_I64)
end_define

begin_define
define|#
directive|define
name|N_IF_32
value|(N_I8 | N_I16 | N_I32 | N_F32)
end_define

begin_comment
comment|/* Pass this as the first type argument to neon_check_type to ignore types    altogether.  */
end_comment

begin_define
define|#
directive|define
name|N_IGNORE_TYPE
value|(N_KEY | N_EQK)
end_define

begin_comment
comment|/* Select a "shape" for the current instruction (describing register types or    sizes) from a list of alternatives. Return NS_NULL if the current instruction    doesn't fit. For non-polymorphic shapes, checking is usually done as a    function of operand parsing, so this function doesn't need to be called.    Shapes should be listed in order of decreasing length.  */
end_comment

begin_function
specifier|static
name|enum
name|neon_shape
name|neon_select_shape
parameter_list|(
name|enum
name|neon_shape
name|shape
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
name|enum
name|neon_shape
name|first_shape
init|=
name|shape
decl_stmt|;
comment|/* Fix missing optional operands. FIXME: we don't know at this point how      many arguments we should have, so this makes the assumption that we have> 1. This is true of all current Neon opcodes, I think, but may not be      true in the future.  */
if|if
condition|(
operator|!
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|present
condition|)
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|=
name|inst
operator|.
name|operands
index|[
literal|0
index|]
expr_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|shape
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|shape
operator|!=
name|NS_NULL
condition|;
name|shape
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
argument_list|)
control|)
block|{
name|unsigned
name|j
decl_stmt|;
name|int
name|matches
init|=
literal|1
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|neon_shape_tab
index|[
name|shape
index|]
operator|.
name|els
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|inst
operator|.
name|operands
index|[
name|j
index|]
operator|.
name|present
condition|)
block|{
name|matches
operator|=
literal|0
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|neon_shape_tab
index|[
name|shape
index|]
operator|.
name|el
index|[
name|j
index|]
condition|)
block|{
case|case
name|SE_F
case|:
if|if
condition|(
operator|!
operator|(
name|inst
operator|.
name|operands
index|[
name|j
index|]
operator|.
name|isreg
operator|&&
name|inst
operator|.
name|operands
index|[
name|j
index|]
operator|.
name|isvec
operator|&&
name|inst
operator|.
name|operands
index|[
name|j
index|]
operator|.
name|issingle
operator|&&
operator|!
name|inst
operator|.
name|operands
index|[
name|j
index|]
operator|.
name|isquad
operator|)
condition|)
name|matches
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|SE_D
case|:
if|if
condition|(
operator|!
operator|(
name|inst
operator|.
name|operands
index|[
name|j
index|]
operator|.
name|isreg
operator|&&
name|inst
operator|.
name|operands
index|[
name|j
index|]
operator|.
name|isvec
operator|&&
operator|!
name|inst
operator|.
name|operands
index|[
name|j
index|]
operator|.
name|isquad
operator|&&
operator|!
name|inst
operator|.
name|operands
index|[
name|j
index|]
operator|.
name|issingle
operator|)
condition|)
name|matches
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|SE_R
case|:
if|if
condition|(
operator|!
operator|(
name|inst
operator|.
name|operands
index|[
name|j
index|]
operator|.
name|isreg
operator|&&
operator|!
name|inst
operator|.
name|operands
index|[
name|j
index|]
operator|.
name|isvec
operator|)
condition|)
name|matches
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|SE_Q
case|:
if|if
condition|(
operator|!
operator|(
name|inst
operator|.
name|operands
index|[
name|j
index|]
operator|.
name|isreg
operator|&&
name|inst
operator|.
name|operands
index|[
name|j
index|]
operator|.
name|isvec
operator|&&
name|inst
operator|.
name|operands
index|[
name|j
index|]
operator|.
name|isquad
operator|&&
operator|!
name|inst
operator|.
name|operands
index|[
name|j
index|]
operator|.
name|issingle
operator|)
condition|)
name|matches
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|SE_I
case|:
if|if
condition|(
operator|!
operator|(
operator|!
name|inst
operator|.
name|operands
index|[
name|j
index|]
operator|.
name|isreg
operator|&&
operator|!
name|inst
operator|.
name|operands
index|[
name|j
index|]
operator|.
name|isscalar
operator|)
condition|)
name|matches
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|SE_S
case|:
if|if
condition|(
operator|!
operator|(
operator|!
name|inst
operator|.
name|operands
index|[
name|j
index|]
operator|.
name|isreg
operator|&&
name|inst
operator|.
name|operands
index|[
name|j
index|]
operator|.
name|isscalar
operator|)
condition|)
name|matches
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|SE_L
case|:
break|break;
block|}
block|}
if|if
condition|(
name|matches
condition|)
break|break;
block|}
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
if|if
condition|(
name|shape
operator|==
name|NS_NULL
operator|&&
name|first_shape
operator|!=
name|NS_NULL
condition|)
name|first_error
argument_list|(
name|_
argument_list|(
literal|"invalid instruction shape"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|shape
return|;
block|}
end_function

begin_comment
comment|/* True if SHAPE is predominantly a quadword operation (most of the time, this    means the Q bit should be set).  */
end_comment

begin_function
specifier|static
name|int
name|neon_quad
parameter_list|(
name|enum
name|neon_shape
name|shape
parameter_list|)
block|{
return|return
name|neon_shape_class
index|[
name|shape
index|]
operator|==
name|SC_QUAD
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|neon_modify_type_size
parameter_list|(
name|unsigned
name|typebits
parameter_list|,
name|enum
name|neon_el_type
modifier|*
name|g_type
parameter_list|,
name|unsigned
modifier|*
name|g_size
parameter_list|)
block|{
comment|/* Allow modification to be made to types which are constrained to be      based on the key element, based on bits set alongside N_EQK.  */
if|if
condition|(
operator|(
name|typebits
operator|&
name|N_EQK
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|typebits
operator|&
name|N_HLF
operator|)
operator|!=
literal|0
condition|)
operator|*
name|g_size
operator|/=
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|typebits
operator|&
name|N_DBL
operator|)
operator|!=
literal|0
condition|)
operator|*
name|g_size
operator|*=
literal|2
expr_stmt|;
if|if
condition|(
operator|(
name|typebits
operator|&
name|N_SGN
operator|)
operator|!=
literal|0
condition|)
operator|*
name|g_type
operator|=
name|NT_signed
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|typebits
operator|&
name|N_UNS
operator|)
operator|!=
literal|0
condition|)
operator|*
name|g_type
operator|=
name|NT_unsigned
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|typebits
operator|&
name|N_INT
operator|)
operator|!=
literal|0
condition|)
operator|*
name|g_type
operator|=
name|NT_integer
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|typebits
operator|&
name|N_FLT
operator|)
operator|!=
literal|0
condition|)
operator|*
name|g_type
operator|=
name|NT_float
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|typebits
operator|&
name|N_SIZ
operator|)
operator|!=
literal|0
condition|)
operator|*
name|g_type
operator|=
name|NT_untyped
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return operand OPNO promoted by bits set in THISARG. KEY should be the "key"    operand type, i.e. the single type specified in a Neon instruction when it    is the only one given.  */
end_comment

begin_function
specifier|static
name|struct
name|neon_type_el
name|neon_type_promote
parameter_list|(
name|struct
name|neon_type_el
modifier|*
name|key
parameter_list|,
name|unsigned
name|thisarg
parameter_list|)
block|{
name|struct
name|neon_type_el
name|dest
init|=
operator|*
name|key
decl_stmt|;
name|assert
argument_list|(
operator|(
name|thisarg
operator|&
name|N_EQK
operator|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|neon_modify_type_size
argument_list|(
name|thisarg
argument_list|,
operator|&
name|dest
operator|.
name|type
argument_list|,
operator|&
name|dest
operator|.
name|size
argument_list|)
expr_stmt|;
return|return
name|dest
return|;
block|}
end_function

begin_comment
comment|/* Convert Neon type and size into compact bitmask representation.  */
end_comment

begin_function
specifier|static
name|enum
name|neon_type_mask
name|type_chk_of_el_type
parameter_list|(
name|enum
name|neon_el_type
name|type
parameter_list|,
name|unsigned
name|size
parameter_list|)
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|NT_untyped
case|:
switch|switch
condition|(
name|size
condition|)
block|{
case|case
literal|8
case|:
return|return
name|N_8
return|;
case|case
literal|16
case|:
return|return
name|N_16
return|;
case|case
literal|32
case|:
return|return
name|N_32
return|;
case|case
literal|64
case|:
return|return
name|N_64
return|;
default|default:
empty_stmt|;
block|}
break|break;
case|case
name|NT_integer
case|:
switch|switch
condition|(
name|size
condition|)
block|{
case|case
literal|8
case|:
return|return
name|N_I8
return|;
case|case
literal|16
case|:
return|return
name|N_I16
return|;
case|case
literal|32
case|:
return|return
name|N_I32
return|;
case|case
literal|64
case|:
return|return
name|N_I64
return|;
default|default:
empty_stmt|;
block|}
break|break;
case|case
name|NT_float
case|:
switch|switch
condition|(
name|size
condition|)
block|{
case|case
literal|32
case|:
return|return
name|N_F32
return|;
case|case
literal|64
case|:
return|return
name|N_F64
return|;
default|default:
empty_stmt|;
block|}
break|break;
case|case
name|NT_poly
case|:
switch|switch
condition|(
name|size
condition|)
block|{
case|case
literal|8
case|:
return|return
name|N_P8
return|;
case|case
literal|16
case|:
return|return
name|N_P16
return|;
default|default:
empty_stmt|;
block|}
break|break;
case|case
name|NT_signed
case|:
switch|switch
condition|(
name|size
condition|)
block|{
case|case
literal|8
case|:
return|return
name|N_S8
return|;
case|case
literal|16
case|:
return|return
name|N_S16
return|;
case|case
literal|32
case|:
return|return
name|N_S32
return|;
case|case
literal|64
case|:
return|return
name|N_S64
return|;
default|default:
empty_stmt|;
block|}
break|break;
case|case
name|NT_unsigned
case|:
switch|switch
condition|(
name|size
condition|)
block|{
case|case
literal|8
case|:
return|return
name|N_U8
return|;
case|case
literal|16
case|:
return|return
name|N_U16
return|;
case|case
literal|32
case|:
return|return
name|N_U32
return|;
case|case
literal|64
case|:
return|return
name|N_U64
return|;
default|default:
empty_stmt|;
block|}
break|break;
default|default:
empty_stmt|;
block|}
return|return
name|N_UTYP
return|;
block|}
end_function

begin_comment
comment|/* Convert compact Neon bitmask type representation to a type and size. Only    handles the case where a single bit is set in the mask.  */
end_comment

begin_function
specifier|static
name|int
name|el_type_of_type_chk
parameter_list|(
name|enum
name|neon_el_type
modifier|*
name|type
parameter_list|,
name|unsigned
modifier|*
name|size
parameter_list|,
name|enum
name|neon_type_mask
name|mask
parameter_list|)
block|{
if|if
condition|(
operator|(
name|mask
operator|&
name|N_EQK
operator|)
operator|!=
literal|0
condition|)
return|return
name|FAIL
return|;
if|if
condition|(
operator|(
name|mask
operator|&
operator|(
name|N_S8
operator||
name|N_U8
operator||
name|N_I8
operator||
name|N_8
operator||
name|N_P8
operator|)
operator|)
operator|!=
literal|0
condition|)
operator|*
name|size
operator|=
literal|8
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|mask
operator|&
operator|(
name|N_S16
operator||
name|N_U16
operator||
name|N_I16
operator||
name|N_16
operator||
name|N_P16
operator|)
operator|)
operator|!=
literal|0
condition|)
operator|*
name|size
operator|=
literal|16
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|mask
operator|&
operator|(
name|N_S32
operator||
name|N_U32
operator||
name|N_I32
operator||
name|N_32
operator||
name|N_F32
operator|)
operator|)
operator|!=
literal|0
condition|)
operator|*
name|size
operator|=
literal|32
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|mask
operator|&
operator|(
name|N_S64
operator||
name|N_U64
operator||
name|N_I64
operator||
name|N_64
operator||
name|N_F64
operator|)
operator|)
operator|!=
literal|0
condition|)
operator|*
name|size
operator|=
literal|64
expr_stmt|;
else|else
return|return
name|FAIL
return|;
if|if
condition|(
operator|(
name|mask
operator|&
operator|(
name|N_S8
operator||
name|N_S16
operator||
name|N_S32
operator||
name|N_S64
operator|)
operator|)
operator|!=
literal|0
condition|)
operator|*
name|type
operator|=
name|NT_signed
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|mask
operator|&
operator|(
name|N_U8
operator||
name|N_U16
operator||
name|N_U32
operator||
name|N_U64
operator|)
operator|)
operator|!=
literal|0
condition|)
operator|*
name|type
operator|=
name|NT_unsigned
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|mask
operator|&
operator|(
name|N_I8
operator||
name|N_I16
operator||
name|N_I32
operator||
name|N_I64
operator|)
operator|)
operator|!=
literal|0
condition|)
operator|*
name|type
operator|=
name|NT_integer
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|mask
operator|&
operator|(
name|N_8
operator||
name|N_16
operator||
name|N_32
operator||
name|N_64
operator|)
operator|)
operator|!=
literal|0
condition|)
operator|*
name|type
operator|=
name|NT_untyped
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|mask
operator|&
operator|(
name|N_P8
operator||
name|N_P16
operator|)
operator|)
operator|!=
literal|0
condition|)
operator|*
name|type
operator|=
name|NT_poly
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|mask
operator|&
operator|(
name|N_F32
operator||
name|N_F64
operator|)
operator|)
operator|!=
literal|0
condition|)
operator|*
name|type
operator|=
name|NT_float
expr_stmt|;
else|else
return|return
name|FAIL
return|;
return|return
name|SUCCESS
return|;
block|}
end_function

begin_comment
comment|/* Modify a bitmask of allowed types. This is only needed for type    relaxation.  */
end_comment

begin_function
specifier|static
name|unsigned
name|modify_types_allowed
parameter_list|(
name|unsigned
name|allowed
parameter_list|,
name|unsigned
name|mods
parameter_list|)
block|{
name|unsigned
name|size
decl_stmt|;
name|enum
name|neon_el_type
name|type
decl_stmt|;
name|unsigned
name|destmask
decl_stmt|;
name|int
name|i
decl_stmt|;
name|destmask
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|N_MAX_NONSPECIAL
condition|;
name|i
operator|<<=
literal|1
control|)
block|{
if|if
condition|(
name|el_type_of_type_chk
argument_list|(
operator|&
name|type
argument_list|,
operator|&
name|size
argument_list|,
name|allowed
operator|&
name|i
argument_list|)
operator|==
name|SUCCESS
condition|)
block|{
name|neon_modify_type_size
argument_list|(
name|mods
argument_list|,
operator|&
name|type
argument_list|,
operator|&
name|size
argument_list|)
expr_stmt|;
name|destmask
operator||=
name|type_chk_of_el_type
argument_list|(
name|type
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|destmask
return|;
block|}
end_function

begin_comment
comment|/* Check type and return type classification.    The manual states (paraphrase): If one datatype is given, it indicates the    type given in:     - the second operand, if there is one     - the operand, if there is no second operand     - the result, if there are no operands.    This isn't quite good enough though, so we use a concept of a "key" datatype    which is set on a per-instruction basis, which is the one which matters when    only one data type is written.    Note: this function has side-effects (e.g. filling in missing operands). All    Neon instructions should call it before performing bit encoding.  */
end_comment

begin_function
specifier|static
name|struct
name|neon_type_el
name|neon_check_type
parameter_list|(
name|unsigned
name|els
parameter_list|,
name|enum
name|neon_shape
name|ns
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
name|unsigned
name|i
decl_stmt|,
name|pass
decl_stmt|,
name|key_el
init|=
literal|0
decl_stmt|;
name|unsigned
name|types
index|[
name|NEON_MAX_TYPE_ELS
index|]
decl_stmt|;
name|enum
name|neon_el_type
name|k_type
init|=
name|NT_invtype
decl_stmt|;
name|unsigned
name|k_size
init|=
operator|-
literal|1u
decl_stmt|;
name|struct
name|neon_type_el
name|badtype
init|=
block|{
name|NT_invtype
block|,
operator|-
literal|1
block|}
decl_stmt|;
name|unsigned
name|key_allowed
init|=
literal|0
decl_stmt|;
comment|/* Optional registers in Neon instructions are always (not) in operand 1.      Fill in the missing operand here, if it was omitted.  */
if|if
condition|(
name|els
operator|>
literal|1
operator|&&
operator|!
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|present
condition|)
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|=
name|inst
operator|.
name|operands
index|[
literal|0
index|]
expr_stmt|;
comment|/* Suck up all the varargs.  */
name|va_start
argument_list|(
name|ap
argument_list|,
name|ns
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|els
condition|;
name|i
operator|++
control|)
block|{
name|unsigned
name|thisarg
init|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|unsigned
argument_list|)
decl_stmt|;
if|if
condition|(
name|thisarg
operator|==
name|N_IGNORE_TYPE
condition|)
block|{
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
return|return
name|badtype
return|;
block|}
name|types
index|[
name|i
index|]
operator|=
name|thisarg
expr_stmt|;
if|if
condition|(
operator|(
name|thisarg
operator|&
name|N_KEY
operator|)
operator|!=
literal|0
condition|)
name|key_el
operator|=
name|i
expr_stmt|;
block|}
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
if|if
condition|(
name|inst
operator|.
name|vectype
operator|.
name|elems
operator|>
literal|0
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|els
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|inst
operator|.
name|operands
index|[
name|i
index|]
operator|.
name|vectype
operator|.
name|type
operator|!=
name|NT_invtype
condition|)
block|{
name|first_error
argument_list|(
name|_
argument_list|(
literal|"types specified in both the mnemonic and operands"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|badtype
return|;
block|}
comment|/* Duplicate inst.vectype elements here as necessary.      FIXME: No idea if this is exactly the same as the ARM assembler,      particularly when an insn takes one register and one non-register      operand. */
if|if
condition|(
name|inst
operator|.
name|vectype
operator|.
name|elems
operator|==
literal|1
operator|&&
name|els
operator|>
literal|1
condition|)
block|{
name|unsigned
name|j
decl_stmt|;
name|inst
operator|.
name|vectype
operator|.
name|elems
operator|=
name|els
expr_stmt|;
name|inst
operator|.
name|vectype
operator|.
name|el
index|[
name|key_el
index|]
operator|=
name|inst
operator|.
name|vectype
operator|.
name|el
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|els
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|j
operator|!=
name|key_el
condition|)
name|inst
operator|.
name|vectype
operator|.
name|el
index|[
name|j
index|]
operator|=
name|neon_type_promote
argument_list|(
operator|&
name|inst
operator|.
name|vectype
operator|.
name|el
index|[
name|key_el
index|]
argument_list|,
name|types
index|[
name|j
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|inst
operator|.
name|vectype
operator|.
name|elems
operator|==
literal|0
operator|&&
name|els
operator|>
literal|0
condition|)
block|{
name|unsigned
name|j
decl_stmt|;
comment|/* No types were given after the mnemonic, so look for types specified          after each operand. We allow some flexibility here; as long as the          "key" operand has a type, we can infer the others.  */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|els
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|inst
operator|.
name|operands
index|[
name|j
index|]
operator|.
name|vectype
operator|.
name|type
operator|!=
name|NT_invtype
condition|)
name|inst
operator|.
name|vectype
operator|.
name|el
index|[
name|j
index|]
operator|=
name|inst
operator|.
name|operands
index|[
name|j
index|]
operator|.
name|vectype
expr_stmt|;
if|if
condition|(
name|inst
operator|.
name|operands
index|[
name|key_el
index|]
operator|.
name|vectype
operator|.
name|type
operator|!=
name|NT_invtype
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|els
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|inst
operator|.
name|operands
index|[
name|j
index|]
operator|.
name|vectype
operator|.
name|type
operator|==
name|NT_invtype
condition|)
name|inst
operator|.
name|vectype
operator|.
name|el
index|[
name|j
index|]
operator|=
name|neon_type_promote
argument_list|(
operator|&
name|inst
operator|.
name|vectype
operator|.
name|el
index|[
name|key_el
index|]
argument_list|,
name|types
index|[
name|j
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|first_error
argument_list|(
name|_
argument_list|(
literal|"operand types can't be inferred"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|badtype
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|inst
operator|.
name|vectype
operator|.
name|elems
operator|!=
name|els
condition|)
block|{
name|first_error
argument_list|(
name|_
argument_list|(
literal|"type specifier has the wrong number of parts"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|badtype
return|;
block|}
for|for
control|(
name|pass
operator|=
literal|0
init|;
name|pass
operator|<
literal|2
condition|;
name|pass
operator|++
control|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|els
condition|;
name|i
operator|++
control|)
block|{
name|unsigned
name|thisarg
init|=
name|types
index|[
name|i
index|]
decl_stmt|;
name|unsigned
name|types_allowed
init|=
operator|(
operator|(
name|thisarg
operator|&
name|N_EQK
operator|)
operator|!=
literal|0
operator|&&
name|pass
operator|!=
literal|0
operator|)
condition|?
name|modify_types_allowed
argument_list|(
name|key_allowed
argument_list|,
name|thisarg
argument_list|)
else|:
name|thisarg
decl_stmt|;
name|enum
name|neon_el_type
name|g_type
init|=
name|inst
operator|.
name|vectype
operator|.
name|el
index|[
name|i
index|]
operator|.
name|type
decl_stmt|;
name|unsigned
name|g_size
init|=
name|inst
operator|.
name|vectype
operator|.
name|el
index|[
name|i
index|]
operator|.
name|size
decl_stmt|;
comment|/* Decay more-specific signed& unsigned types to sign-insensitive 	     integer types if sign-specific variants are unavailable.  */
if|if
condition|(
operator|(
name|g_type
operator|==
name|NT_signed
operator|||
name|g_type
operator|==
name|NT_unsigned
operator|)
operator|&&
operator|(
name|types_allowed
operator|&
name|N_SU_ALL
operator|)
operator|==
literal|0
condition|)
name|g_type
operator|=
name|NT_integer
expr_stmt|;
comment|/* If only untyped args are allowed, decay any more specific types to 	     them. Some instructions only care about signs for some element 	     sizes, so handle that properly.  */
if|if
condition|(
operator|(
name|g_size
operator|==
literal|8
operator|&&
operator|(
name|types_allowed
operator|&
name|N_8
operator|)
operator|!=
literal|0
operator|)
operator|||
operator|(
name|g_size
operator|==
literal|16
operator|&&
operator|(
name|types_allowed
operator|&
name|N_16
operator|)
operator|!=
literal|0
operator|)
operator|||
operator|(
name|g_size
operator|==
literal|32
operator|&&
operator|(
name|types_allowed
operator|&
name|N_32
operator|)
operator|!=
literal|0
operator|)
operator|||
operator|(
name|g_size
operator|==
literal|64
operator|&&
operator|(
name|types_allowed
operator|&
name|N_64
operator|)
operator|!=
literal|0
operator|)
condition|)
name|g_type
operator|=
name|NT_untyped
expr_stmt|;
if|if
condition|(
name|pass
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|thisarg
operator|&
name|N_KEY
operator|)
operator|!=
literal|0
condition|)
block|{
name|k_type
operator|=
name|g_type
expr_stmt|;
name|k_size
operator|=
name|g_size
expr_stmt|;
name|key_allowed
operator|=
name|thisarg
operator|&
operator|~
name|N_KEY
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|(
name|thisarg
operator|&
name|N_VFP
operator|)
operator|!=
literal|0
condition|)
block|{
name|enum
name|neon_shape_el
name|regshape
init|=
name|neon_shape_tab
index|[
name|ns
index|]
operator|.
name|el
index|[
name|i
index|]
decl_stmt|;
name|unsigned
name|regwidth
init|=
name|neon_shape_el_size
index|[
name|regshape
index|]
decl_stmt|,
name|match
decl_stmt|;
comment|/* In VFP mode, operands must match register widths. If we                      have a key operand, use its width, else use the width of                      the current operand.  */
if|if
condition|(
name|k_size
operator|!=
operator|-
literal|1u
condition|)
name|match
operator|=
name|k_size
expr_stmt|;
else|else
name|match
operator|=
name|g_size
expr_stmt|;
if|if
condition|(
name|regwidth
operator|!=
name|match
condition|)
block|{
name|first_error
argument_list|(
name|_
argument_list|(
literal|"operand size must match register width"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|badtype
return|;
block|}
block|}
if|if
condition|(
operator|(
name|thisarg
operator|&
name|N_EQK
operator|)
operator|==
literal|0
condition|)
block|{
name|unsigned
name|given_type
init|=
name|type_chk_of_el_type
argument_list|(
name|g_type
argument_list|,
name|g_size
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|given_type
operator|&
name|types_allowed
operator|)
operator|==
literal|0
condition|)
block|{
name|first_error
argument_list|(
name|_
argument_list|(
literal|"bad type in Neon instruction"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|badtype
return|;
block|}
block|}
else|else
block|{
name|enum
name|neon_el_type
name|mod_k_type
init|=
name|k_type
decl_stmt|;
name|unsigned
name|mod_k_size
init|=
name|k_size
decl_stmt|;
name|neon_modify_type_size
argument_list|(
name|thisarg
argument_list|,
operator|&
name|mod_k_type
argument_list|,
operator|&
name|mod_k_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|g_type
operator|!=
name|mod_k_type
operator|||
name|g_size
operator|!=
name|mod_k_size
condition|)
block|{
name|first_error
argument_list|(
name|_
argument_list|(
literal|"inconsistent types in Neon instruction"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|badtype
return|;
block|}
block|}
block|}
block|}
block|}
return|return
name|inst
operator|.
name|vectype
operator|.
name|el
index|[
name|key_el
index|]
return|;
block|}
end_function

begin_comment
comment|/* Neon-style VFP instruction forwarding.  */
end_comment

begin_comment
comment|/* Thumb VFP instructions have 0xE in the condition field.  */
end_comment

begin_function
specifier|static
name|void
name|do_vfp_cond_or_thumb
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|thumb_mode
condition|)
name|inst
operator|.
name|instruction
operator||=
literal|0xe0000000
expr_stmt|;
else|else
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|cond
operator|<<
literal|28
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Look up and encode a simple mnemonic, for use as a helper function for the    Neon-style VFP syntax.  This avoids duplication of bits of the insns table,    etc.  It is assumed that operand parsing has already been done, and that the    operands are in the form expected by the given opcode (this isn't necessarily    the same as the form in which they were parsed, hence some massaging must    take place before this function is called).    Checks current arch version against that in the looked-up opcode.  */
end_comment

begin_function
specifier|static
name|void
name|do_vfp_nsyn_opcode
parameter_list|(
specifier|const
name|char
modifier|*
name|opname
parameter_list|)
block|{
specifier|const
name|struct
name|asm_opcode
modifier|*
name|opcode
decl_stmt|;
name|opcode
operator|=
name|hash_find
argument_list|(
name|arm_ops_hsh
argument_list|,
name|opname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|opcode
condition|)
name|abort
argument_list|()
expr_stmt|;
name|constraint
argument_list|(
operator|!
name|ARM_CPU_HAS_FEATURE
argument_list|(
name|cpu_variant
argument_list|,
name|thumb_mode
condition|?
operator|*
name|opcode
operator|->
name|tvariant
else|:
operator|*
name|opcode
operator|->
name|avariant
argument_list|)
argument_list|,
name|_
argument_list|(
name|BAD_FPU
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|thumb_mode
condition|)
block|{
name|inst
operator|.
name|instruction
operator|=
name|opcode
operator|->
name|tvalue
expr_stmt|;
name|opcode
operator|->
name|tencode
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|inst
operator|.
name|instruction
operator|=
operator|(
name|inst
operator|.
name|cond
operator|<<
literal|28
operator|)
operator||
name|opcode
operator|->
name|avalue
expr_stmt|;
name|opcode
operator|->
name|aencode
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|do_vfp_nsyn_add_sub
parameter_list|(
name|enum
name|neon_shape
name|rs
parameter_list|)
block|{
name|int
name|is_add
init|=
operator|(
name|inst
operator|.
name|instruction
operator|&
literal|0x0fffffff
operator|)
operator|==
name|N_MNEM_vadd
decl_stmt|;
if|if
condition|(
name|rs
operator|==
name|NS_FFF
condition|)
block|{
if|if
condition|(
name|is_add
condition|)
name|do_vfp_nsyn_opcode
argument_list|(
literal|"fadds"
argument_list|)
expr_stmt|;
else|else
name|do_vfp_nsyn_opcode
argument_list|(
literal|"fsubs"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|is_add
condition|)
name|do_vfp_nsyn_opcode
argument_list|(
literal|"faddd"
argument_list|)
expr_stmt|;
else|else
name|do_vfp_nsyn_opcode
argument_list|(
literal|"fsubd"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Check operand types to see if this is a VFP instruction, and if so call    PFN ().  */
end_comment

begin_function
specifier|static
name|int
name|try_vfp_nsyn
parameter_list|(
name|int
name|args
parameter_list|,
name|void
function_decl|(
modifier|*
name|pfn
function_decl|)
parameter_list|(
name|enum
name|neon_shape
parameter_list|)
parameter_list|)
block|{
name|enum
name|neon_shape
name|rs
decl_stmt|;
name|struct
name|neon_type_el
name|et
decl_stmt|;
switch|switch
condition|(
name|args
condition|)
block|{
case|case
literal|2
case|:
name|rs
operator|=
name|neon_select_shape
argument_list|(
name|NS_FF
argument_list|,
name|NS_DD
argument_list|,
name|NS_NULL
argument_list|)
expr_stmt|;
name|et
operator|=
name|neon_check_type
argument_list|(
literal|2
argument_list|,
name|rs
argument_list|,
name|N_EQK
operator||
name|N_VFP
argument_list|,
name|N_F32
operator||
name|N_F64
operator||
name|N_KEY
operator||
name|N_VFP
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|rs
operator|=
name|neon_select_shape
argument_list|(
name|NS_FFF
argument_list|,
name|NS_DDD
argument_list|,
name|NS_NULL
argument_list|)
expr_stmt|;
name|et
operator|=
name|neon_check_type
argument_list|(
literal|3
argument_list|,
name|rs
argument_list|,
name|N_EQK
operator||
name|N_VFP
argument_list|,
name|N_EQK
operator||
name|N_VFP
argument_list|,
name|N_F32
operator||
name|N_F64
operator||
name|N_KEY
operator||
name|N_VFP
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|et
operator|.
name|type
operator|!=
name|NT_invtype
condition|)
block|{
name|pfn
argument_list|(
name|rs
argument_list|)
expr_stmt|;
return|return
name|SUCCESS
return|;
block|}
else|else
name|inst
operator|.
name|error
operator|=
name|NULL
expr_stmt|;
return|return
name|FAIL
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_vfp_nsyn_mla_mls
parameter_list|(
name|enum
name|neon_shape
name|rs
parameter_list|)
block|{
name|int
name|is_mla
init|=
operator|(
name|inst
operator|.
name|instruction
operator|&
literal|0x0fffffff
operator|)
operator|==
name|N_MNEM_vmla
decl_stmt|;
if|if
condition|(
name|rs
operator|==
name|NS_FFF
condition|)
block|{
if|if
condition|(
name|is_mla
condition|)
name|do_vfp_nsyn_opcode
argument_list|(
literal|"fmacs"
argument_list|)
expr_stmt|;
else|else
name|do_vfp_nsyn_opcode
argument_list|(
literal|"fmscs"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|is_mla
condition|)
name|do_vfp_nsyn_opcode
argument_list|(
literal|"fmacd"
argument_list|)
expr_stmt|;
else|else
name|do_vfp_nsyn_opcode
argument_list|(
literal|"fmscd"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|do_vfp_nsyn_mul
parameter_list|(
name|enum
name|neon_shape
name|rs
parameter_list|)
block|{
if|if
condition|(
name|rs
operator|==
name|NS_FFF
condition|)
name|do_vfp_nsyn_opcode
argument_list|(
literal|"fmuls"
argument_list|)
expr_stmt|;
else|else
name|do_vfp_nsyn_opcode
argument_list|(
literal|"fmuld"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_vfp_nsyn_abs_neg
parameter_list|(
name|enum
name|neon_shape
name|rs
parameter_list|)
block|{
name|int
name|is_neg
init|=
operator|(
name|inst
operator|.
name|instruction
operator|&
literal|0x80
operator|)
operator|!=
literal|0
decl_stmt|;
name|neon_check_type
argument_list|(
literal|2
argument_list|,
name|rs
argument_list|,
name|N_EQK
operator||
name|N_VFP
argument_list|,
name|N_F32
operator||
name|N_F64
operator||
name|N_VFP
operator||
name|N_KEY
argument_list|)
expr_stmt|;
if|if
condition|(
name|rs
operator|==
name|NS_FF
condition|)
block|{
if|if
condition|(
name|is_neg
condition|)
name|do_vfp_nsyn_opcode
argument_list|(
literal|"fnegs"
argument_list|)
expr_stmt|;
else|else
name|do_vfp_nsyn_opcode
argument_list|(
literal|"fabss"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|is_neg
condition|)
name|do_vfp_nsyn_opcode
argument_list|(
literal|"fnegd"
argument_list|)
expr_stmt|;
else|else
name|do_vfp_nsyn_opcode
argument_list|(
literal|"fabsd"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Encode single-precision (only!) VFP fldm/fstm instructions. Double precision    insns belong to Neon, and are handled elsewhere.  */
end_comment

begin_function
specifier|static
name|void
name|do_vfp_nsyn_ldm_stm
parameter_list|(
name|int
name|is_dbmode
parameter_list|)
block|{
name|int
name|is_ldm
init|=
operator|(
name|inst
operator|.
name|instruction
operator|&
operator|(
literal|1
operator|<<
literal|20
operator|)
operator|)
operator|!=
literal|0
decl_stmt|;
if|if
condition|(
name|is_ldm
condition|)
block|{
if|if
condition|(
name|is_dbmode
condition|)
name|do_vfp_nsyn_opcode
argument_list|(
literal|"fldmdbs"
argument_list|)
expr_stmt|;
else|else
name|do_vfp_nsyn_opcode
argument_list|(
literal|"fldmias"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|is_dbmode
condition|)
name|do_vfp_nsyn_opcode
argument_list|(
literal|"fstmdbs"
argument_list|)
expr_stmt|;
else|else
name|do_vfp_nsyn_opcode
argument_list|(
literal|"fstmias"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|do_vfp_nsyn_sqrt
parameter_list|(
name|void
parameter_list|)
block|{
name|enum
name|neon_shape
name|rs
init|=
name|neon_select_shape
argument_list|(
name|NS_FF
argument_list|,
name|NS_DD
argument_list|,
name|NS_NULL
argument_list|)
decl_stmt|;
name|neon_check_type
argument_list|(
literal|2
argument_list|,
name|rs
argument_list|,
name|N_EQK
operator||
name|N_VFP
argument_list|,
name|N_F32
operator||
name|N_F64
operator||
name|N_KEY
operator||
name|N_VFP
argument_list|)
expr_stmt|;
if|if
condition|(
name|rs
operator|==
name|NS_FF
condition|)
name|do_vfp_nsyn_opcode
argument_list|(
literal|"fsqrts"
argument_list|)
expr_stmt|;
else|else
name|do_vfp_nsyn_opcode
argument_list|(
literal|"fsqrtd"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_vfp_nsyn_div
parameter_list|(
name|void
parameter_list|)
block|{
name|enum
name|neon_shape
name|rs
init|=
name|neon_select_shape
argument_list|(
name|NS_FFF
argument_list|,
name|NS_DDD
argument_list|,
name|NS_NULL
argument_list|)
decl_stmt|;
name|neon_check_type
argument_list|(
literal|3
argument_list|,
name|rs
argument_list|,
name|N_EQK
operator||
name|N_VFP
argument_list|,
name|N_EQK
operator||
name|N_VFP
argument_list|,
name|N_F32
operator||
name|N_F64
operator||
name|N_KEY
operator||
name|N_VFP
argument_list|)
expr_stmt|;
if|if
condition|(
name|rs
operator|==
name|NS_FFF
condition|)
name|do_vfp_nsyn_opcode
argument_list|(
literal|"fdivs"
argument_list|)
expr_stmt|;
else|else
name|do_vfp_nsyn_opcode
argument_list|(
literal|"fdivd"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_vfp_nsyn_nmul
parameter_list|(
name|void
parameter_list|)
block|{
name|enum
name|neon_shape
name|rs
init|=
name|neon_select_shape
argument_list|(
name|NS_FFF
argument_list|,
name|NS_DDD
argument_list|,
name|NS_NULL
argument_list|)
decl_stmt|;
name|neon_check_type
argument_list|(
literal|3
argument_list|,
name|rs
argument_list|,
name|N_EQK
operator||
name|N_VFP
argument_list|,
name|N_EQK
operator||
name|N_VFP
argument_list|,
name|N_F32
operator||
name|N_F64
operator||
name|N_KEY
operator||
name|N_VFP
argument_list|)
expr_stmt|;
if|if
condition|(
name|rs
operator|==
name|NS_FFF
condition|)
block|{
name|inst
operator|.
name|instruction
operator|=
name|NEON_ENC_SINGLE
argument_list|(
name|inst
operator|.
name|instruction
argument_list|)
expr_stmt|;
name|do_vfp_sp_dyadic
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|inst
operator|.
name|instruction
operator|=
name|NEON_ENC_DOUBLE
argument_list|(
name|inst
operator|.
name|instruction
argument_list|)
expr_stmt|;
name|do_vfp_dp_rd_rn_rm
argument_list|()
expr_stmt|;
block|}
name|do_vfp_cond_or_thumb
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_vfp_nsyn_cmp
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|isreg
condition|)
block|{
name|enum
name|neon_shape
name|rs
init|=
name|neon_select_shape
argument_list|(
name|NS_FF
argument_list|,
name|NS_DD
argument_list|,
name|NS_NULL
argument_list|)
decl_stmt|;
name|neon_check_type
argument_list|(
literal|2
argument_list|,
name|rs
argument_list|,
name|N_EQK
operator||
name|N_VFP
argument_list|,
name|N_F32
operator||
name|N_F64
operator||
name|N_KEY
operator||
name|N_VFP
argument_list|)
expr_stmt|;
if|if
condition|(
name|rs
operator|==
name|NS_FF
condition|)
block|{
name|inst
operator|.
name|instruction
operator|=
name|NEON_ENC_SINGLE
argument_list|(
name|inst
operator|.
name|instruction
argument_list|)
expr_stmt|;
name|do_vfp_sp_monadic
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|inst
operator|.
name|instruction
operator|=
name|NEON_ENC_DOUBLE
argument_list|(
name|inst
operator|.
name|instruction
argument_list|)
expr_stmt|;
name|do_vfp_dp_rd_rm
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
name|enum
name|neon_shape
name|rs
init|=
name|neon_select_shape
argument_list|(
name|NS_FI
argument_list|,
name|NS_DI
argument_list|,
name|NS_NULL
argument_list|)
decl_stmt|;
name|neon_check_type
argument_list|(
literal|2
argument_list|,
name|rs
argument_list|,
name|N_F32
operator||
name|N_F64
operator||
name|N_KEY
operator||
name|N_VFP
argument_list|,
name|N_EQK
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|inst
operator|.
name|instruction
operator|&
literal|0x0fffffff
condition|)
block|{
case|case
name|N_MNEM_vcmp
case|:
name|inst
operator|.
name|instruction
operator|+=
name|N_MNEM_vcmpz
operator|-
name|N_MNEM_vcmp
expr_stmt|;
break|break;
case|case
name|N_MNEM_vcmpe
case|:
name|inst
operator|.
name|instruction
operator|+=
name|N_MNEM_vcmpez
operator|-
name|N_MNEM_vcmpe
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|rs
operator|==
name|NS_FI
condition|)
block|{
name|inst
operator|.
name|instruction
operator|=
name|NEON_ENC_SINGLE
argument_list|(
name|inst
operator|.
name|instruction
argument_list|)
expr_stmt|;
name|do_vfp_sp_compare_z
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|inst
operator|.
name|instruction
operator|=
name|NEON_ENC_DOUBLE
argument_list|(
name|inst
operator|.
name|instruction
argument_list|)
expr_stmt|;
name|do_vfp_dp_rd
argument_list|()
expr_stmt|;
block|}
block|}
name|do_vfp_cond_or_thumb
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|nsyn_insert_sp
parameter_list|(
name|void
parameter_list|)
block|{
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|=
name|inst
operator|.
name|operands
index|[
literal|0
index|]
expr_stmt|;
name|memset
argument_list|(
operator|&
name|inst
operator|.
name|operands
index|[
literal|0
index|]
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
name|inst
operator|.
name|operands
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
operator|=
literal|13
expr_stmt|;
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|isreg
operator|=
literal|1
expr_stmt|;
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|writeback
operator|=
literal|1
expr_stmt|;
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|present
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_vfp_nsyn_push
parameter_list|(
name|void
parameter_list|)
block|{
name|nsyn_insert_sp
argument_list|()
expr_stmt|;
if|if
condition|(
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|issingle
condition|)
name|do_vfp_nsyn_opcode
argument_list|(
literal|"fstmdbs"
argument_list|)
expr_stmt|;
else|else
name|do_vfp_nsyn_opcode
argument_list|(
literal|"fstmdbd"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_vfp_nsyn_pop
parameter_list|(
name|void
parameter_list|)
block|{
name|nsyn_insert_sp
argument_list|()
expr_stmt|;
if|if
condition|(
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|issingle
condition|)
name|do_vfp_nsyn_opcode
argument_list|(
literal|"fldmias"
argument_list|)
expr_stmt|;
else|else
name|do_vfp_nsyn_opcode
argument_list|(
literal|"fldmiad"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Fix up Neon data-processing instructions, ORing in the correct bits for    ARM mode or Thumb mode and moving the encoded bit 24 to bit 28.  */
end_comment

begin_function
specifier|static
name|unsigned
name|neon_dp_fixup
parameter_list|(
name|unsigned
name|i
parameter_list|)
block|{
if|if
condition|(
name|thumb_mode
condition|)
block|{
comment|/* The U bit is at bit 24 by default. Move to bit 28 in Thumb mode.  */
if|if
condition|(
name|i
operator|&
operator|(
literal|1
operator|<<
literal|24
operator|)
condition|)
name|i
operator||=
literal|1
operator|<<
literal|28
expr_stmt|;
name|i
operator|&=
operator|~
operator|(
literal|1
operator|<<
literal|24
operator|)
expr_stmt|;
name|i
operator||=
literal|0xef000000
expr_stmt|;
block|}
else|else
name|i
operator||=
literal|0xf2000000
expr_stmt|;
return|return
name|i
return|;
block|}
end_function

begin_comment
comment|/* Turn a size (8, 16, 32, 64) into the respective bit number minus 3    (0, 1, 2, 3).  */
end_comment

begin_function
specifier|static
name|unsigned
name|neon_logbits
parameter_list|(
name|unsigned
name|x
parameter_list|)
block|{
return|return
name|ffs
argument_list|(
name|x
argument_list|)
operator|-
literal|4
return|;
block|}
end_function

begin_define
define|#
directive|define
name|LOW4
parameter_list|(
name|R
parameter_list|)
value|((R)& 0xf)
end_define

begin_define
define|#
directive|define
name|HI1
parameter_list|(
name|R
parameter_list|)
value|(((R)>> 4)& 1)
end_define

begin_comment
comment|/* Encode insns with bit pattern:    |28/24|23|22 |21 20|19 16|15 12|11    8|7|6|5|4|3  0|   |  U  |x |D  |size | Rn  | Rd  |x x x x|N|Q|M|x| Rm |      SIZE is passed in bits. -1 means size field isn't changed, in case it has a   different meaning for some instruction.  */
end_comment

begin_function
specifier|static
name|void
name|neon_three_same
parameter_list|(
name|int
name|isquad
parameter_list|,
name|int
name|ubit
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|inst
operator|.
name|instruction
operator||=
name|LOW4
argument_list|(
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
argument_list|)
operator|<<
literal|12
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|HI1
argument_list|(
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
argument_list|)
operator|<<
literal|22
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|LOW4
argument_list|(
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
argument_list|)
operator|<<
literal|16
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|HI1
argument_list|(
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
argument_list|)
operator|<<
literal|7
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|LOW4
argument_list|(
name|inst
operator|.
name|operands
index|[
literal|2
index|]
operator|.
name|reg
argument_list|)
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|HI1
argument_list|(
name|inst
operator|.
name|operands
index|[
literal|2
index|]
operator|.
name|reg
argument_list|)
operator|<<
literal|5
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
operator|(
name|isquad
operator|!=
literal|0
operator|)
operator|<<
literal|6
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
operator|(
name|ubit
operator|!=
literal|0
operator|)
operator|<<
literal|24
expr_stmt|;
if|if
condition|(
name|size
operator|!=
operator|-
literal|1
condition|)
name|inst
operator|.
name|instruction
operator||=
name|neon_logbits
argument_list|(
name|size
argument_list|)
operator|<<
literal|20
expr_stmt|;
name|inst
operator|.
name|instruction
operator|=
name|neon_dp_fixup
argument_list|(
name|inst
operator|.
name|instruction
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Encode instructions of the form:    |28/24|23|22|21 20|19 18|17 16|15 12|11      7|6|5|4|3  0|   |  U  |x |D |x  x |size |x  x | Rd  |x x x x x|Q|M|x| Rm |    Don't write size if SIZE == -1.  */
end_comment

begin_function
specifier|static
name|void
name|neon_two_same
parameter_list|(
name|int
name|qbit
parameter_list|,
name|int
name|ubit
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|inst
operator|.
name|instruction
operator||=
name|LOW4
argument_list|(
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
argument_list|)
operator|<<
literal|12
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|HI1
argument_list|(
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
argument_list|)
operator|<<
literal|22
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|LOW4
argument_list|(
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
argument_list|)
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|HI1
argument_list|(
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
argument_list|)
operator|<<
literal|5
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
operator|(
name|qbit
operator|!=
literal|0
operator|)
operator|<<
literal|6
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
operator|(
name|ubit
operator|!=
literal|0
operator|)
operator|<<
literal|24
expr_stmt|;
if|if
condition|(
name|size
operator|!=
operator|-
literal|1
condition|)
name|inst
operator|.
name|instruction
operator||=
name|neon_logbits
argument_list|(
name|size
argument_list|)
operator|<<
literal|18
expr_stmt|;
name|inst
operator|.
name|instruction
operator|=
name|neon_dp_fixup
argument_list|(
name|inst
operator|.
name|instruction
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Neon instruction encoders, in approximate order of appearance.  */
end_comment

begin_function
specifier|static
name|void
name|do_neon_dyadic_i_su
parameter_list|(
name|void
parameter_list|)
block|{
name|enum
name|neon_shape
name|rs
init|=
name|neon_select_shape
argument_list|(
name|NS_DDD
argument_list|,
name|NS_QQQ
argument_list|,
name|NS_NULL
argument_list|)
decl_stmt|;
name|struct
name|neon_type_el
name|et
init|=
name|neon_check_type
argument_list|(
literal|3
argument_list|,
name|rs
argument_list|,
name|N_EQK
argument_list|,
name|N_EQK
argument_list|,
name|N_SU_32
operator||
name|N_KEY
argument_list|)
decl_stmt|;
name|neon_three_same
argument_list|(
name|neon_quad
argument_list|(
name|rs
argument_list|)
argument_list|,
name|et
operator|.
name|type
operator|==
name|NT_unsigned
argument_list|,
name|et
operator|.
name|size
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_neon_dyadic_i64_su
parameter_list|(
name|void
parameter_list|)
block|{
name|enum
name|neon_shape
name|rs
init|=
name|neon_select_shape
argument_list|(
name|NS_DDD
argument_list|,
name|NS_QQQ
argument_list|,
name|NS_NULL
argument_list|)
decl_stmt|;
name|struct
name|neon_type_el
name|et
init|=
name|neon_check_type
argument_list|(
literal|3
argument_list|,
name|rs
argument_list|,
name|N_EQK
argument_list|,
name|N_EQK
argument_list|,
name|N_SU_ALL
operator||
name|N_KEY
argument_list|)
decl_stmt|;
name|neon_three_same
argument_list|(
name|neon_quad
argument_list|(
name|rs
argument_list|)
argument_list|,
name|et
operator|.
name|type
operator|==
name|NT_unsigned
argument_list|,
name|et
operator|.
name|size
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|neon_imm_shift
parameter_list|(
name|int
name|write_ubit
parameter_list|,
name|int
name|uval
parameter_list|,
name|int
name|isquad
parameter_list|,
name|struct
name|neon_type_el
name|et
parameter_list|,
name|unsigned
name|immbits
parameter_list|)
block|{
name|unsigned
name|size
init|=
name|et
operator|.
name|size
operator|>>
literal|3
decl_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|LOW4
argument_list|(
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
argument_list|)
operator|<<
literal|12
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|HI1
argument_list|(
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
argument_list|)
operator|<<
literal|22
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|LOW4
argument_list|(
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
argument_list|)
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|HI1
argument_list|(
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
argument_list|)
operator|<<
literal|5
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
operator|(
name|isquad
operator|!=
literal|0
operator|)
operator|<<
literal|6
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|immbits
operator|<<
literal|16
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
operator|(
name|size
operator|>>
literal|3
operator|)
operator|<<
literal|7
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
operator|(
name|size
operator|&
literal|0x7
operator|)
operator|<<
literal|19
expr_stmt|;
if|if
condition|(
name|write_ubit
condition|)
name|inst
operator|.
name|instruction
operator||=
operator|(
name|uval
operator|!=
literal|0
operator|)
operator|<<
literal|24
expr_stmt|;
name|inst
operator|.
name|instruction
operator|=
name|neon_dp_fixup
argument_list|(
name|inst
operator|.
name|instruction
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_neon_shl_imm
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
name|inst
operator|.
name|operands
index|[
literal|2
index|]
operator|.
name|isreg
condition|)
block|{
name|enum
name|neon_shape
name|rs
init|=
name|neon_select_shape
argument_list|(
name|NS_DDI
argument_list|,
name|NS_QQI
argument_list|,
name|NS_NULL
argument_list|)
decl_stmt|;
name|struct
name|neon_type_el
name|et
init|=
name|neon_check_type
argument_list|(
literal|2
argument_list|,
name|rs
argument_list|,
name|N_EQK
argument_list|,
name|N_KEY
operator||
name|N_I_ALL
argument_list|)
decl_stmt|;
name|inst
operator|.
name|instruction
operator|=
name|NEON_ENC_IMMED
argument_list|(
name|inst
operator|.
name|instruction
argument_list|)
expr_stmt|;
name|neon_imm_shift
argument_list|(
name|FALSE
argument_list|,
literal|0
argument_list|,
name|neon_quad
argument_list|(
name|rs
argument_list|)
argument_list|,
name|et
argument_list|,
name|inst
operator|.
name|operands
index|[
literal|2
index|]
operator|.
name|imm
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|enum
name|neon_shape
name|rs
init|=
name|neon_select_shape
argument_list|(
name|NS_DDD
argument_list|,
name|NS_QQQ
argument_list|,
name|NS_NULL
argument_list|)
decl_stmt|;
name|struct
name|neon_type_el
name|et
init|=
name|neon_check_type
argument_list|(
literal|3
argument_list|,
name|rs
argument_list|,
name|N_EQK
argument_list|,
name|N_SU_ALL
operator||
name|N_KEY
argument_list|,
name|N_EQK
operator||
name|N_SGN
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|tmp
decl_stmt|;
comment|/* VSHL/VQSHL 3-register variants have syntax such as:            vshl.xx Dd, Dm, Dn          whereas other 3-register operations encoded by neon_three_same have          syntax like:            vadd.xx Dd, Dn, Dm          (i.e. with Dn& Dm reversed). Swap operands[1].reg and operands[2].reg          here.  */
name|tmp
operator|=
name|inst
operator|.
name|operands
index|[
literal|2
index|]
operator|.
name|reg
expr_stmt|;
name|inst
operator|.
name|operands
index|[
literal|2
index|]
operator|.
name|reg
operator|=
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
expr_stmt|;
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
operator|=
name|tmp
expr_stmt|;
name|inst
operator|.
name|instruction
operator|=
name|NEON_ENC_INTEGER
argument_list|(
name|inst
operator|.
name|instruction
argument_list|)
expr_stmt|;
name|neon_three_same
argument_list|(
name|neon_quad
argument_list|(
name|rs
argument_list|)
argument_list|,
name|et
operator|.
name|type
operator|==
name|NT_unsigned
argument_list|,
name|et
operator|.
name|size
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|do_neon_qshl_imm
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
name|inst
operator|.
name|operands
index|[
literal|2
index|]
operator|.
name|isreg
condition|)
block|{
name|enum
name|neon_shape
name|rs
init|=
name|neon_select_shape
argument_list|(
name|NS_DDI
argument_list|,
name|NS_QQI
argument_list|,
name|NS_NULL
argument_list|)
decl_stmt|;
name|struct
name|neon_type_el
name|et
init|=
name|neon_check_type
argument_list|(
literal|2
argument_list|,
name|rs
argument_list|,
name|N_EQK
argument_list|,
name|N_SU_ALL
operator||
name|N_KEY
argument_list|)
decl_stmt|;
name|inst
operator|.
name|instruction
operator|=
name|NEON_ENC_IMMED
argument_list|(
name|inst
operator|.
name|instruction
argument_list|)
expr_stmt|;
name|neon_imm_shift
argument_list|(
name|TRUE
argument_list|,
name|et
operator|.
name|type
operator|==
name|NT_unsigned
argument_list|,
name|neon_quad
argument_list|(
name|rs
argument_list|)
argument_list|,
name|et
argument_list|,
name|inst
operator|.
name|operands
index|[
literal|2
index|]
operator|.
name|imm
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|enum
name|neon_shape
name|rs
init|=
name|neon_select_shape
argument_list|(
name|NS_DDD
argument_list|,
name|NS_QQQ
argument_list|,
name|NS_NULL
argument_list|)
decl_stmt|;
name|struct
name|neon_type_el
name|et
init|=
name|neon_check_type
argument_list|(
literal|3
argument_list|,
name|rs
argument_list|,
name|N_EQK
argument_list|,
name|N_SU_ALL
operator||
name|N_KEY
argument_list|,
name|N_EQK
operator||
name|N_SGN
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|tmp
decl_stmt|;
comment|/* See note in do_neon_shl_imm.  */
name|tmp
operator|=
name|inst
operator|.
name|operands
index|[
literal|2
index|]
operator|.
name|reg
expr_stmt|;
name|inst
operator|.
name|operands
index|[
literal|2
index|]
operator|.
name|reg
operator|=
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
expr_stmt|;
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
operator|=
name|tmp
expr_stmt|;
name|inst
operator|.
name|instruction
operator|=
name|NEON_ENC_INTEGER
argument_list|(
name|inst
operator|.
name|instruction
argument_list|)
expr_stmt|;
name|neon_three_same
argument_list|(
name|neon_quad
argument_list|(
name|rs
argument_list|)
argument_list|,
name|et
operator|.
name|type
operator|==
name|NT_unsigned
argument_list|,
name|et
operator|.
name|size
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|do_neon_rshl
parameter_list|(
name|void
parameter_list|)
block|{
name|enum
name|neon_shape
name|rs
init|=
name|neon_select_shape
argument_list|(
name|NS_DDD
argument_list|,
name|NS_QQQ
argument_list|,
name|NS_NULL
argument_list|)
decl_stmt|;
name|struct
name|neon_type_el
name|et
init|=
name|neon_check_type
argument_list|(
literal|3
argument_list|,
name|rs
argument_list|,
name|N_EQK
argument_list|,
name|N_EQK
argument_list|,
name|N_SU_ALL
operator||
name|N_KEY
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|tmp
decl_stmt|;
name|tmp
operator|=
name|inst
operator|.
name|operands
index|[
literal|2
index|]
operator|.
name|reg
expr_stmt|;
name|inst
operator|.
name|operands
index|[
literal|2
index|]
operator|.
name|reg
operator|=
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
expr_stmt|;
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
operator|=
name|tmp
expr_stmt|;
name|neon_three_same
argument_list|(
name|neon_quad
argument_list|(
name|rs
argument_list|)
argument_list|,
name|et
operator|.
name|type
operator|==
name|NT_unsigned
argument_list|,
name|et
operator|.
name|size
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|neon_cmode_for_logic_imm
parameter_list|(
name|unsigned
name|immediate
parameter_list|,
name|unsigned
modifier|*
name|immbits
parameter_list|,
name|int
name|size
parameter_list|)
block|{
comment|/* Handle .I8 pseudo-instructions.  */
if|if
condition|(
name|size
operator|==
literal|8
condition|)
block|{
comment|/* Unfortunately, this will make everything apart from zero out-of-range.          FIXME is this the intended semantics? There doesn't seem much point in          accepting .I8 if so.  */
name|immediate
operator||=
name|immediate
operator|<<
literal|8
expr_stmt|;
name|size
operator|=
literal|16
expr_stmt|;
block|}
if|if
condition|(
name|size
operator|>=
literal|32
condition|)
block|{
if|if
condition|(
name|immediate
operator|==
operator|(
name|immediate
operator|&
literal|0x000000ff
operator|)
condition|)
block|{
operator|*
name|immbits
operator|=
name|immediate
expr_stmt|;
return|return
literal|0x1
return|;
block|}
elseif|else
if|if
condition|(
name|immediate
operator|==
operator|(
name|immediate
operator|&
literal|0x0000ff00
operator|)
condition|)
block|{
operator|*
name|immbits
operator|=
name|immediate
operator|>>
literal|8
expr_stmt|;
return|return
literal|0x3
return|;
block|}
elseif|else
if|if
condition|(
name|immediate
operator|==
operator|(
name|immediate
operator|&
literal|0x00ff0000
operator|)
condition|)
block|{
operator|*
name|immbits
operator|=
name|immediate
operator|>>
literal|16
expr_stmt|;
return|return
literal|0x5
return|;
block|}
elseif|else
if|if
condition|(
name|immediate
operator|==
operator|(
name|immediate
operator|&
literal|0xff000000
operator|)
condition|)
block|{
operator|*
name|immbits
operator|=
name|immediate
operator|>>
literal|24
expr_stmt|;
return|return
literal|0x7
return|;
block|}
if|if
condition|(
operator|(
name|immediate
operator|&
literal|0xffff
operator|)
operator|!=
operator|(
name|immediate
operator|>>
literal|16
operator|)
condition|)
goto|goto
name|bad_immediate
goto|;
name|immediate
operator|&=
literal|0xffff
expr_stmt|;
block|}
if|if
condition|(
name|immediate
operator|==
operator|(
name|immediate
operator|&
literal|0x000000ff
operator|)
condition|)
block|{
operator|*
name|immbits
operator|=
name|immediate
expr_stmt|;
return|return
literal|0x9
return|;
block|}
elseif|else
if|if
condition|(
name|immediate
operator|==
operator|(
name|immediate
operator|&
literal|0x0000ff00
operator|)
condition|)
block|{
operator|*
name|immbits
operator|=
name|immediate
operator|>>
literal|8
expr_stmt|;
return|return
literal|0xb
return|;
block|}
name|bad_immediate
label|:
name|first_error
argument_list|(
name|_
argument_list|(
literal|"immediate value out of range"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
block|}
end_function

begin_comment
comment|/* True if IMM has form 0bAAAAAAAABBBBBBBBCCCCCCCCDDDDDDDD for bits    A, B, C, D.  */
end_comment

begin_function
specifier|static
name|int
name|neon_bits_same_in_bytes
parameter_list|(
name|unsigned
name|imm
parameter_list|)
block|{
return|return
operator|(
operator|(
name|imm
operator|&
literal|0x000000ff
operator|)
operator|==
literal|0
operator|||
operator|(
name|imm
operator|&
literal|0x000000ff
operator|)
operator|==
literal|0x000000ff
operator|)
operator|&&
operator|(
operator|(
name|imm
operator|&
literal|0x0000ff00
operator|)
operator|==
literal|0
operator|||
operator|(
name|imm
operator|&
literal|0x0000ff00
operator|)
operator|==
literal|0x0000ff00
operator|)
operator|&&
operator|(
operator|(
name|imm
operator|&
literal|0x00ff0000
operator|)
operator|==
literal|0
operator|||
operator|(
name|imm
operator|&
literal|0x00ff0000
operator|)
operator|==
literal|0x00ff0000
operator|)
operator|&&
operator|(
operator|(
name|imm
operator|&
literal|0xff000000
operator|)
operator|==
literal|0
operator|||
operator|(
name|imm
operator|&
literal|0xff000000
operator|)
operator|==
literal|0xff000000
operator|)
return|;
block|}
end_function

begin_comment
comment|/* For immediate of above form, return 0bABCD.  */
end_comment

begin_function
specifier|static
name|unsigned
name|neon_squash_bits
parameter_list|(
name|unsigned
name|imm
parameter_list|)
block|{
return|return
operator|(
name|imm
operator|&
literal|0x01
operator|)
operator||
operator|(
operator|(
name|imm
operator|&
literal|0x0100
operator|)
operator|>>
literal|7
operator|)
operator||
operator|(
operator|(
name|imm
operator|&
literal|0x010000
operator|)
operator|>>
literal|14
operator|)
operator||
operator|(
operator|(
name|imm
operator|&
literal|0x01000000
operator|)
operator|>>
literal|21
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Compress quarter-float representation to 0b...000 abcdefgh.  */
end_comment

begin_function
specifier|static
name|unsigned
name|neon_qfloat_bits
parameter_list|(
name|unsigned
name|imm
parameter_list|)
block|{
return|return
operator|(
operator|(
name|imm
operator|>>
literal|19
operator|)
operator|&
literal|0x7f
operator|)
operator||
operator|(
operator|(
name|imm
operator|>>
literal|24
operator|)
operator|&
literal|0x80
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Returns CMODE. IMMBITS [7:0] is set to bits suitable for inserting into    the instruction. *OP is passed as the initial value of the op field, and    may be set to a different value depending on the constant (i.e.    "MOV I64, 0bAAAAAAAABBBB..." which uses OP = 1 despite being MOV not    MVN).  If the immediate looks like a repeated parttern then also    try smaller element sizes.  */
end_comment

begin_function
specifier|static
name|int
name|neon_cmode_for_move_imm
parameter_list|(
name|unsigned
name|immlo
parameter_list|,
name|unsigned
name|immhi
parameter_list|,
name|int
name|float_p
parameter_list|,
name|unsigned
modifier|*
name|immbits
parameter_list|,
name|int
modifier|*
name|op
parameter_list|,
name|int
name|size
parameter_list|,
name|enum
name|neon_el_type
name|type
parameter_list|)
block|{
comment|/* Only permit float immediates (including 0.0/-0.0) if the operand type is      float.  */
if|if
condition|(
name|type
operator|==
name|NT_float
operator|&&
operator|!
name|float_p
condition|)
return|return
name|FAIL
return|;
if|if
condition|(
name|type
operator|==
name|NT_float
operator|&&
name|is_quarter_float
argument_list|(
name|immlo
argument_list|)
operator|&&
name|immhi
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|size
operator|!=
literal|32
operator|||
operator|*
name|op
operator|==
literal|1
condition|)
return|return
name|FAIL
return|;
operator|*
name|immbits
operator|=
name|neon_qfloat_bits
argument_list|(
name|immlo
argument_list|)
expr_stmt|;
return|return
literal|0xf
return|;
block|}
if|if
condition|(
name|size
operator|==
literal|64
condition|)
block|{
if|if
condition|(
name|neon_bits_same_in_bytes
argument_list|(
name|immhi
argument_list|)
operator|&&
name|neon_bits_same_in_bytes
argument_list|(
name|immlo
argument_list|)
condition|)
block|{
if|if
condition|(
operator|*
name|op
operator|==
literal|1
condition|)
return|return
name|FAIL
return|;
operator|*
name|immbits
operator|=
operator|(
name|neon_squash_bits
argument_list|(
name|immhi
argument_list|)
operator|<<
literal|4
operator|)
operator||
name|neon_squash_bits
argument_list|(
name|immlo
argument_list|)
expr_stmt|;
operator|*
name|op
operator|=
literal|1
expr_stmt|;
return|return
literal|0xe
return|;
block|}
if|if
condition|(
name|immhi
operator|!=
name|immlo
condition|)
return|return
name|FAIL
return|;
block|}
if|if
condition|(
name|size
operator|>=
literal|32
condition|)
block|{
if|if
condition|(
name|immlo
operator|==
operator|(
name|immlo
operator|&
literal|0x000000ff
operator|)
condition|)
block|{
operator|*
name|immbits
operator|=
name|immlo
expr_stmt|;
return|return
literal|0x0
return|;
block|}
elseif|else
if|if
condition|(
name|immlo
operator|==
operator|(
name|immlo
operator|&
literal|0x0000ff00
operator|)
condition|)
block|{
operator|*
name|immbits
operator|=
name|immlo
operator|>>
literal|8
expr_stmt|;
return|return
literal|0x2
return|;
block|}
elseif|else
if|if
condition|(
name|immlo
operator|==
operator|(
name|immlo
operator|&
literal|0x00ff0000
operator|)
condition|)
block|{
operator|*
name|immbits
operator|=
name|immlo
operator|>>
literal|16
expr_stmt|;
return|return
literal|0x4
return|;
block|}
elseif|else
if|if
condition|(
name|immlo
operator|==
operator|(
name|immlo
operator|&
literal|0xff000000
operator|)
condition|)
block|{
operator|*
name|immbits
operator|=
name|immlo
operator|>>
literal|24
expr_stmt|;
return|return
literal|0x6
return|;
block|}
elseif|else
if|if
condition|(
name|immlo
operator|==
operator|(
operator|(
name|immlo
operator|&
literal|0x0000ff00
operator|)
operator||
literal|0x000000ff
operator|)
condition|)
block|{
operator|*
name|immbits
operator|=
operator|(
name|immlo
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
return|return
literal|0xc
return|;
block|}
elseif|else
if|if
condition|(
name|immlo
operator|==
operator|(
operator|(
name|immlo
operator|&
literal|0x00ff0000
operator|)
operator||
literal|0x0000ffff
operator|)
condition|)
block|{
operator|*
name|immbits
operator|=
operator|(
name|immlo
operator|>>
literal|16
operator|)
operator|&
literal|0xff
expr_stmt|;
return|return
literal|0xd
return|;
block|}
if|if
condition|(
operator|(
name|immlo
operator|&
literal|0xffff
operator|)
operator|!=
operator|(
name|immlo
operator|>>
literal|16
operator|)
condition|)
return|return
name|FAIL
return|;
name|immlo
operator|&=
literal|0xffff
expr_stmt|;
block|}
if|if
condition|(
name|size
operator|>=
literal|16
condition|)
block|{
if|if
condition|(
name|immlo
operator|==
operator|(
name|immlo
operator|&
literal|0x000000ff
operator|)
condition|)
block|{
operator|*
name|immbits
operator|=
name|immlo
expr_stmt|;
return|return
literal|0x8
return|;
block|}
elseif|else
if|if
condition|(
name|immlo
operator|==
operator|(
name|immlo
operator|&
literal|0x0000ff00
operator|)
condition|)
block|{
operator|*
name|immbits
operator|=
name|immlo
operator|>>
literal|8
expr_stmt|;
return|return
literal|0xa
return|;
block|}
if|if
condition|(
operator|(
name|immlo
operator|&
literal|0xff
operator|)
operator|!=
operator|(
name|immlo
operator|>>
literal|8
operator|)
condition|)
return|return
name|FAIL
return|;
name|immlo
operator|&=
literal|0xff
expr_stmt|;
block|}
if|if
condition|(
name|immlo
operator|==
operator|(
name|immlo
operator|&
literal|0x000000ff
operator|)
condition|)
block|{
comment|/* Don't allow MVN with 8-bit immediate.  */
if|if
condition|(
operator|*
name|op
operator|==
literal|1
condition|)
return|return
name|FAIL
return|;
operator|*
name|immbits
operator|=
name|immlo
expr_stmt|;
return|return
literal|0xe
return|;
block|}
return|return
name|FAIL
return|;
block|}
end_function

begin_comment
comment|/* Write immediate bits [7:0] to the following locations:    |28/24|23     19|18 16|15                    4|3     0|   |  a  |x x x x x|b c d|x x x x x x x x x x x x|e f g h|    This function is used by VMOV/VMVN/VORR/VBIC.  */
end_comment

begin_function
specifier|static
name|void
name|neon_write_immbits
parameter_list|(
name|unsigned
name|immbits
parameter_list|)
block|{
name|inst
operator|.
name|instruction
operator||=
name|immbits
operator|&
literal|0xf
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
operator|(
operator|(
name|immbits
operator|>>
literal|4
operator|)
operator|&
literal|0x7
operator|)
operator|<<
literal|16
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
operator|(
operator|(
name|immbits
operator|>>
literal|7
operator|)
operator|&
literal|0x1
operator|)
operator|<<
literal|24
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Invert low-order SIZE bits of XHI:XLO.  */
end_comment

begin_function
specifier|static
name|void
name|neon_invert_size
parameter_list|(
name|unsigned
modifier|*
name|xlo
parameter_list|,
name|unsigned
modifier|*
name|xhi
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|unsigned
name|immlo
init|=
name|xlo
condition|?
operator|*
name|xlo
else|:
literal|0
decl_stmt|;
name|unsigned
name|immhi
init|=
name|xhi
condition|?
operator|*
name|xhi
else|:
literal|0
decl_stmt|;
switch|switch
condition|(
name|size
condition|)
block|{
case|case
literal|8
case|:
name|immlo
operator|=
operator|(
operator|~
name|immlo
operator|)
operator|&
literal|0xff
expr_stmt|;
break|break;
case|case
literal|16
case|:
name|immlo
operator|=
operator|(
operator|~
name|immlo
operator|)
operator|&
literal|0xffff
expr_stmt|;
break|break;
case|case
literal|64
case|:
name|immhi
operator|=
operator|(
operator|~
name|immhi
operator|)
operator|&
literal|0xffffffff
expr_stmt|;
comment|/* fall through.  */
case|case
literal|32
case|:
name|immlo
operator|=
operator|(
operator|~
name|immlo
operator|)
operator|&
literal|0xffffffff
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|xlo
condition|)
operator|*
name|xlo
operator|=
name|immlo
expr_stmt|;
if|if
condition|(
name|xhi
condition|)
operator|*
name|xhi
operator|=
name|immhi
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_neon_logic
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|inst
operator|.
name|operands
index|[
literal|2
index|]
operator|.
name|present
operator|&&
name|inst
operator|.
name|operands
index|[
literal|2
index|]
operator|.
name|isreg
condition|)
block|{
name|enum
name|neon_shape
name|rs
init|=
name|neon_select_shape
argument_list|(
name|NS_DDD
argument_list|,
name|NS_QQQ
argument_list|,
name|NS_NULL
argument_list|)
decl_stmt|;
name|neon_check_type
argument_list|(
literal|3
argument_list|,
name|rs
argument_list|,
name|N_IGNORE_TYPE
argument_list|)
expr_stmt|;
comment|/* U bit and size field were set as part of the bitmask.  */
name|inst
operator|.
name|instruction
operator|=
name|NEON_ENC_INTEGER
argument_list|(
name|inst
operator|.
name|instruction
argument_list|)
expr_stmt|;
name|neon_three_same
argument_list|(
name|neon_quad
argument_list|(
name|rs
argument_list|)
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|enum
name|neon_shape
name|rs
init|=
name|neon_select_shape
argument_list|(
name|NS_DI
argument_list|,
name|NS_QI
argument_list|,
name|NS_NULL
argument_list|)
decl_stmt|;
name|struct
name|neon_type_el
name|et
init|=
name|neon_check_type
argument_list|(
literal|2
argument_list|,
name|rs
argument_list|,
name|N_I8
operator||
name|N_I16
operator||
name|N_I32
operator||
name|N_I64
operator||
name|N_F32
operator||
name|N_KEY
argument_list|,
name|N_EQK
argument_list|)
decl_stmt|;
name|enum
name|neon_opc
name|opcode
init|=
name|inst
operator|.
name|instruction
operator|&
literal|0x0fffffff
decl_stmt|;
name|unsigned
name|immbits
decl_stmt|;
name|int
name|cmode
decl_stmt|;
if|if
condition|(
name|et
operator|.
name|type
operator|==
name|NT_invtype
condition|)
return|return;
name|inst
operator|.
name|instruction
operator|=
name|NEON_ENC_IMMED
argument_list|(
name|inst
operator|.
name|instruction
argument_list|)
expr_stmt|;
name|immbits
operator|=
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|imm
expr_stmt|;
if|if
condition|(
name|et
operator|.
name|size
operator|==
literal|64
condition|)
block|{
comment|/* .i64 is a pseudo-op, so the immediate must be a repeating 	     pattern.  */
if|if
condition|(
name|immbits
operator|!=
operator|(
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|regisimm
condition|?
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
else|:
literal|0
operator|)
condition|)
block|{
comment|/* Set immbits to an invalid constant.  */
name|immbits
operator|=
literal|0xdeadbeef
expr_stmt|;
block|}
block|}
switch|switch
condition|(
name|opcode
condition|)
block|{
case|case
name|N_MNEM_vbic
case|:
name|cmode
operator|=
name|neon_cmode_for_logic_imm
argument_list|(
name|immbits
argument_list|,
operator|&
name|immbits
argument_list|,
name|et
operator|.
name|size
argument_list|)
expr_stmt|;
break|break;
case|case
name|N_MNEM_vorr
case|:
name|cmode
operator|=
name|neon_cmode_for_logic_imm
argument_list|(
name|immbits
argument_list|,
operator|&
name|immbits
argument_list|,
name|et
operator|.
name|size
argument_list|)
expr_stmt|;
break|break;
case|case
name|N_MNEM_vand
case|:
comment|/* Pseudo-instruction for VBIC.  */
name|neon_invert_size
argument_list|(
operator|&
name|immbits
argument_list|,
literal|0
argument_list|,
name|et
operator|.
name|size
argument_list|)
expr_stmt|;
name|cmode
operator|=
name|neon_cmode_for_logic_imm
argument_list|(
name|immbits
argument_list|,
operator|&
name|immbits
argument_list|,
name|et
operator|.
name|size
argument_list|)
expr_stmt|;
break|break;
case|case
name|N_MNEM_vorn
case|:
comment|/* Pseudo-instruction for VORR.  */
name|neon_invert_size
argument_list|(
operator|&
name|immbits
argument_list|,
literal|0
argument_list|,
name|et
operator|.
name|size
argument_list|)
expr_stmt|;
name|cmode
operator|=
name|neon_cmode_for_logic_imm
argument_list|(
name|immbits
argument_list|,
operator|&
name|immbits
argument_list|,
name|et
operator|.
name|size
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|cmode
operator|==
name|FAIL
condition|)
return|return;
name|inst
operator|.
name|instruction
operator||=
name|neon_quad
argument_list|(
name|rs
argument_list|)
operator|<<
literal|6
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|LOW4
argument_list|(
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
argument_list|)
operator|<<
literal|12
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|HI1
argument_list|(
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
argument_list|)
operator|<<
literal|22
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|cmode
operator|<<
literal|8
expr_stmt|;
name|neon_write_immbits
argument_list|(
name|immbits
argument_list|)
expr_stmt|;
name|inst
operator|.
name|instruction
operator|=
name|neon_dp_fixup
argument_list|(
name|inst
operator|.
name|instruction
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|do_neon_bitfield
parameter_list|(
name|void
parameter_list|)
block|{
name|enum
name|neon_shape
name|rs
init|=
name|neon_select_shape
argument_list|(
name|NS_DDD
argument_list|,
name|NS_QQQ
argument_list|,
name|NS_NULL
argument_list|)
decl_stmt|;
name|neon_check_type
argument_list|(
literal|3
argument_list|,
name|rs
argument_list|,
name|N_IGNORE_TYPE
argument_list|)
expr_stmt|;
name|neon_three_same
argument_list|(
name|neon_quad
argument_list|(
name|rs
argument_list|)
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|neon_dyadic_misc
parameter_list|(
name|enum
name|neon_el_type
name|ubit_meaning
parameter_list|,
name|unsigned
name|types
parameter_list|,
name|unsigned
name|destbits
parameter_list|)
block|{
name|enum
name|neon_shape
name|rs
init|=
name|neon_select_shape
argument_list|(
name|NS_DDD
argument_list|,
name|NS_QQQ
argument_list|,
name|NS_NULL
argument_list|)
decl_stmt|;
name|struct
name|neon_type_el
name|et
init|=
name|neon_check_type
argument_list|(
literal|3
argument_list|,
name|rs
argument_list|,
name|N_EQK
operator||
name|destbits
argument_list|,
name|N_EQK
argument_list|,
name|types
operator||
name|N_KEY
argument_list|)
decl_stmt|;
if|if
condition|(
name|et
operator|.
name|type
operator|==
name|NT_float
condition|)
block|{
name|inst
operator|.
name|instruction
operator|=
name|NEON_ENC_FLOAT
argument_list|(
name|inst
operator|.
name|instruction
argument_list|)
expr_stmt|;
name|neon_three_same
argument_list|(
name|neon_quad
argument_list|(
name|rs
argument_list|)
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|inst
operator|.
name|instruction
operator|=
name|NEON_ENC_INTEGER
argument_list|(
name|inst
operator|.
name|instruction
argument_list|)
expr_stmt|;
name|neon_three_same
argument_list|(
name|neon_quad
argument_list|(
name|rs
argument_list|)
argument_list|,
name|et
operator|.
name|type
operator|==
name|ubit_meaning
argument_list|,
name|et
operator|.
name|size
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|do_neon_dyadic_if_su
parameter_list|(
name|void
parameter_list|)
block|{
name|neon_dyadic_misc
argument_list|(
name|NT_unsigned
argument_list|,
name|N_SUF_32
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_neon_dyadic_if_su_d
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* This version only allow D registers, but that constraint is enforced during      operand parsing so we don't need to do anything extra here.  */
name|neon_dyadic_misc
argument_list|(
name|NT_unsigned
argument_list|,
name|N_SUF_32
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_neon_dyadic_if_i_d
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* The "untyped" case can't happen. Do this to stop the "U" bit being      affected if we specify unsigned args.  */
name|neon_dyadic_misc
argument_list|(
name|NT_untyped
argument_list|,
name|N_IF_32
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_enum
enum|enum
name|vfp_or_neon_is_neon_bits
block|{
name|NEON_CHECK_CC
init|=
literal|1
block|,
name|NEON_CHECK_ARCH
init|=
literal|2
block|}
enum|;
end_enum

begin_comment
comment|/* Call this function if an instruction which may have belonged to the VFP or    Neon instruction sets, but turned out to be a Neon instruction (due to the    operand types involved, etc.). We have to check and/or fix-up a couple of    things:       - Make sure the user hasn't attempted to make a Neon instruction        conditional.      - Alter the value in the condition code field if necessary.      - Make sure that the arch supports Neon instructions.     Which of these operations take place depends on bits from enum    vfp_or_neon_is_neon_bits.     WARNING: This function has side effects! If NEON_CHECK_CC is used and the    current instruction's condition is COND_ALWAYS, the condition field is    changed to inst.uncond_value. This is necessary because instructions shared    between VFP and Neon may be conditional for the VFP variants only, and the    unconditional Neon version must have, e.g., 0xF in the condition field.  */
end_comment

begin_function
specifier|static
name|int
name|vfp_or_neon_is_neon
parameter_list|(
name|unsigned
name|check
parameter_list|)
block|{
comment|/* Conditions are always legal in Thumb mode (IT blocks).  */
if|if
condition|(
operator|!
name|thumb_mode
operator|&&
operator|(
name|check
operator|&
name|NEON_CHECK_CC
operator|)
condition|)
block|{
if|if
condition|(
name|inst
operator|.
name|cond
operator|!=
name|COND_ALWAYS
condition|)
block|{
name|first_error
argument_list|(
name|_
argument_list|(
name|BAD_COND
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
block|}
if|if
condition|(
name|inst
operator|.
name|uncond_value
operator|!=
operator|-
literal|1
condition|)
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|uncond_value
operator|<<
literal|28
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|check
operator|&
name|NEON_CHECK_ARCH
operator|)
operator|&&
operator|!
name|ARM_CPU_HAS_FEATURE
argument_list|(
name|cpu_variant
argument_list|,
name|fpu_neon_ext_v1
argument_list|)
condition|)
block|{
name|first_error
argument_list|(
name|_
argument_list|(
name|BAD_FPU
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
block|}
return|return
name|SUCCESS
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_neon_addsub_if_i
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|try_vfp_nsyn
argument_list|(
literal|3
argument_list|,
name|do_vfp_nsyn_add_sub
argument_list|)
operator|==
name|SUCCESS
condition|)
return|return;
if|if
condition|(
name|vfp_or_neon_is_neon
argument_list|(
name|NEON_CHECK_CC
operator||
name|NEON_CHECK_ARCH
argument_list|)
operator|==
name|FAIL
condition|)
return|return;
comment|/* The "untyped" case can't happen. Do this to stop the "U" bit being      affected if we specify unsigned args.  */
name|neon_dyadic_misc
argument_list|(
name|NT_untyped
argument_list|,
name|N_IF_32
operator||
name|N_I64
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Swaps operands 1 and 2. If operand 1 (optional arg) was omitted, we want the    result to be:      V<op> A,B     (A is operand 0, B is operand 2)    to mean:      V<op> A,B,A    not:      V<op> A,B,B    so handle that case specially.  */
end_comment

begin_function
specifier|static
name|void
name|neon_exchange_operands
parameter_list|(
name|void
parameter_list|)
block|{
name|void
modifier|*
name|scratch
init|=
name|alloca
argument_list|(
sizeof|sizeof
argument_list|(
name|inst
operator|.
name|operands
index|[
literal|0
index|]
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|present
condition|)
block|{
comment|/* Swap operands[1] and operands[2].  */
name|memcpy
argument_list|(
name|scratch
argument_list|,
operator|&
name|inst
operator|.
name|operands
index|[
literal|1
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|inst
operator|.
name|operands
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|=
name|inst
operator|.
name|operands
index|[
literal|2
index|]
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|inst
operator|.
name|operands
index|[
literal|2
index|]
argument_list|,
name|scratch
argument_list|,
sizeof|sizeof
argument_list|(
name|inst
operator|.
name|operands
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|=
name|inst
operator|.
name|operands
index|[
literal|2
index|]
expr_stmt|;
name|inst
operator|.
name|operands
index|[
literal|2
index|]
operator|=
name|inst
operator|.
name|operands
index|[
literal|0
index|]
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|neon_compare
parameter_list|(
name|unsigned
name|regtypes
parameter_list|,
name|unsigned
name|immtypes
parameter_list|,
name|int
name|invert
parameter_list|)
block|{
if|if
condition|(
name|inst
operator|.
name|operands
index|[
literal|2
index|]
operator|.
name|isreg
condition|)
block|{
if|if
condition|(
name|invert
condition|)
name|neon_exchange_operands
argument_list|()
expr_stmt|;
name|neon_dyadic_misc
argument_list|(
name|NT_unsigned
argument_list|,
name|regtypes
argument_list|,
name|N_SIZ
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|enum
name|neon_shape
name|rs
init|=
name|neon_select_shape
argument_list|(
name|NS_DDI
argument_list|,
name|NS_QQI
argument_list|,
name|NS_NULL
argument_list|)
decl_stmt|;
name|struct
name|neon_type_el
name|et
init|=
name|neon_check_type
argument_list|(
literal|2
argument_list|,
name|rs
argument_list|,
name|N_EQK
operator||
name|N_SIZ
argument_list|,
name|immtypes
operator||
name|N_KEY
argument_list|)
decl_stmt|;
name|inst
operator|.
name|instruction
operator|=
name|NEON_ENC_IMMED
argument_list|(
name|inst
operator|.
name|instruction
argument_list|)
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|LOW4
argument_list|(
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
argument_list|)
operator|<<
literal|12
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|HI1
argument_list|(
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
argument_list|)
operator|<<
literal|22
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|LOW4
argument_list|(
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
argument_list|)
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|HI1
argument_list|(
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
argument_list|)
operator|<<
literal|5
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|neon_quad
argument_list|(
name|rs
argument_list|)
operator|<<
literal|6
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
operator|(
name|et
operator|.
name|type
operator|==
name|NT_float
operator|)
operator|<<
literal|10
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|neon_logbits
argument_list|(
name|et
operator|.
name|size
argument_list|)
operator|<<
literal|18
expr_stmt|;
name|inst
operator|.
name|instruction
operator|=
name|neon_dp_fixup
argument_list|(
name|inst
operator|.
name|instruction
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|do_neon_cmp
parameter_list|(
name|void
parameter_list|)
block|{
name|neon_compare
argument_list|(
name|N_SUF_32
argument_list|,
name|N_S8
operator||
name|N_S16
operator||
name|N_S32
operator||
name|N_F32
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_neon_cmp_inv
parameter_list|(
name|void
parameter_list|)
block|{
name|neon_compare
argument_list|(
name|N_SUF_32
argument_list|,
name|N_S8
operator||
name|N_S16
operator||
name|N_S32
operator||
name|N_F32
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_neon_ceq
parameter_list|(
name|void
parameter_list|)
block|{
name|neon_compare
argument_list|(
name|N_IF_32
argument_list|,
name|N_IF_32
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* For multiply instructions, we have the possibility of 16-bit or 32-bit    scalars, which are encoded in 5 bits, M : Rm.    For 16-bit scalars, the register is encoded in Rm[2:0] and the index in    M:Rm[3], and for 32-bit scalars, the register is encoded in Rm[3:0] and the    index in M.  */
end_comment

begin_function
specifier|static
name|unsigned
name|neon_scalar_for_mul
parameter_list|(
name|unsigned
name|scalar
parameter_list|,
name|unsigned
name|elsize
parameter_list|)
block|{
name|unsigned
name|regno
init|=
name|NEON_SCALAR_REG
argument_list|(
name|scalar
argument_list|)
decl_stmt|;
name|unsigned
name|elno
init|=
name|NEON_SCALAR_INDEX
argument_list|(
name|scalar
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|elsize
condition|)
block|{
case|case
literal|16
case|:
if|if
condition|(
name|regno
operator|>
literal|7
operator|||
name|elno
operator|>
literal|3
condition|)
goto|goto
name|bad_scalar
goto|;
return|return
name|regno
operator||
operator|(
name|elno
operator|<<
literal|3
operator|)
return|;
case|case
literal|32
case|:
if|if
condition|(
name|regno
operator|>
literal|15
operator|||
name|elno
operator|>
literal|1
condition|)
goto|goto
name|bad_scalar
goto|;
return|return
name|regno
operator||
operator|(
name|elno
operator|<<
literal|4
operator|)
return|;
default|default:
name|bad_scalar
label|:
name|first_error
argument_list|(
name|_
argument_list|(
literal|"scalar out of range for multiply instruction"
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Encode multiply / multiply-accumulate scalar instructions.  */
end_comment

begin_function
specifier|static
name|void
name|neon_mul_mac
parameter_list|(
name|struct
name|neon_type_el
name|et
parameter_list|,
name|int
name|ubit
parameter_list|)
block|{
name|unsigned
name|scalar
decl_stmt|;
comment|/* Give a more helpful error message if we have an invalid type.  */
if|if
condition|(
name|et
operator|.
name|type
operator|==
name|NT_invtype
condition|)
return|return;
name|scalar
operator|=
name|neon_scalar_for_mul
argument_list|(
name|inst
operator|.
name|operands
index|[
literal|2
index|]
operator|.
name|reg
argument_list|,
name|et
operator|.
name|size
argument_list|)
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|LOW4
argument_list|(
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
argument_list|)
operator|<<
literal|12
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|HI1
argument_list|(
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
argument_list|)
operator|<<
literal|22
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|LOW4
argument_list|(
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
argument_list|)
operator|<<
literal|16
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|HI1
argument_list|(
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
argument_list|)
operator|<<
literal|7
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|LOW4
argument_list|(
name|scalar
argument_list|)
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|HI1
argument_list|(
name|scalar
argument_list|)
operator|<<
literal|5
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
operator|(
name|et
operator|.
name|type
operator|==
name|NT_float
operator|)
operator|<<
literal|8
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|neon_logbits
argument_list|(
name|et
operator|.
name|size
argument_list|)
operator|<<
literal|20
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
operator|(
name|ubit
operator|!=
literal|0
operator|)
operator|<<
literal|24
expr_stmt|;
name|inst
operator|.
name|instruction
operator|=
name|neon_dp_fixup
argument_list|(
name|inst
operator|.
name|instruction
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_neon_mac_maybe_scalar
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|try_vfp_nsyn
argument_list|(
literal|3
argument_list|,
name|do_vfp_nsyn_mla_mls
argument_list|)
operator|==
name|SUCCESS
condition|)
return|return;
if|if
condition|(
name|vfp_or_neon_is_neon
argument_list|(
name|NEON_CHECK_CC
operator||
name|NEON_CHECK_ARCH
argument_list|)
operator|==
name|FAIL
condition|)
return|return;
if|if
condition|(
name|inst
operator|.
name|operands
index|[
literal|2
index|]
operator|.
name|isscalar
condition|)
block|{
name|enum
name|neon_shape
name|rs
init|=
name|neon_select_shape
argument_list|(
name|NS_DDS
argument_list|,
name|NS_QQS
argument_list|,
name|NS_NULL
argument_list|)
decl_stmt|;
name|struct
name|neon_type_el
name|et
init|=
name|neon_check_type
argument_list|(
literal|3
argument_list|,
name|rs
argument_list|,
name|N_EQK
argument_list|,
name|N_EQK
argument_list|,
name|N_I16
operator||
name|N_I32
operator||
name|N_F32
operator||
name|N_KEY
argument_list|)
decl_stmt|;
name|inst
operator|.
name|instruction
operator|=
name|NEON_ENC_SCALAR
argument_list|(
name|inst
operator|.
name|instruction
argument_list|)
expr_stmt|;
name|neon_mul_mac
argument_list|(
name|et
argument_list|,
name|neon_quad
argument_list|(
name|rs
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* The "untyped" case can't happen.  Do this to stop the "U" bit being 	 affected if we specify unsigned args.  */
name|neon_dyadic_misc
argument_list|(
name|NT_untyped
argument_list|,
name|N_IF_32
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|do_neon_tst
parameter_list|(
name|void
parameter_list|)
block|{
name|enum
name|neon_shape
name|rs
init|=
name|neon_select_shape
argument_list|(
name|NS_DDD
argument_list|,
name|NS_QQQ
argument_list|,
name|NS_NULL
argument_list|)
decl_stmt|;
name|struct
name|neon_type_el
name|et
init|=
name|neon_check_type
argument_list|(
literal|3
argument_list|,
name|rs
argument_list|,
name|N_EQK
argument_list|,
name|N_EQK
argument_list|,
name|N_8
operator||
name|N_16
operator||
name|N_32
operator||
name|N_KEY
argument_list|)
decl_stmt|;
name|neon_three_same
argument_list|(
name|neon_quad
argument_list|(
name|rs
argument_list|)
argument_list|,
literal|0
argument_list|,
name|et
operator|.
name|size
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* VMUL with 3 registers allows the P8 type. The scalar version supports the    same types as the MAC equivalents. The polynomial type for this instruction    is encoded the same as the integer type.  */
end_comment

begin_function
specifier|static
name|void
name|do_neon_mul
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|try_vfp_nsyn
argument_list|(
literal|3
argument_list|,
name|do_vfp_nsyn_mul
argument_list|)
operator|==
name|SUCCESS
condition|)
return|return;
if|if
condition|(
name|vfp_or_neon_is_neon
argument_list|(
name|NEON_CHECK_CC
operator||
name|NEON_CHECK_ARCH
argument_list|)
operator|==
name|FAIL
condition|)
return|return;
if|if
condition|(
name|inst
operator|.
name|operands
index|[
literal|2
index|]
operator|.
name|isscalar
condition|)
name|do_neon_mac_maybe_scalar
argument_list|()
expr_stmt|;
else|else
name|neon_dyadic_misc
argument_list|(
name|NT_poly
argument_list|,
name|N_I8
operator||
name|N_I16
operator||
name|N_I32
operator||
name|N_F32
operator||
name|N_P8
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_neon_qdmulh
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|inst
operator|.
name|operands
index|[
literal|2
index|]
operator|.
name|isscalar
condition|)
block|{
name|enum
name|neon_shape
name|rs
init|=
name|neon_select_shape
argument_list|(
name|NS_DDS
argument_list|,
name|NS_QQS
argument_list|,
name|NS_NULL
argument_list|)
decl_stmt|;
name|struct
name|neon_type_el
name|et
init|=
name|neon_check_type
argument_list|(
literal|3
argument_list|,
name|rs
argument_list|,
name|N_EQK
argument_list|,
name|N_EQK
argument_list|,
name|N_S16
operator||
name|N_S32
operator||
name|N_KEY
argument_list|)
decl_stmt|;
name|inst
operator|.
name|instruction
operator|=
name|NEON_ENC_SCALAR
argument_list|(
name|inst
operator|.
name|instruction
argument_list|)
expr_stmt|;
name|neon_mul_mac
argument_list|(
name|et
argument_list|,
name|neon_quad
argument_list|(
name|rs
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|enum
name|neon_shape
name|rs
init|=
name|neon_select_shape
argument_list|(
name|NS_DDD
argument_list|,
name|NS_QQQ
argument_list|,
name|NS_NULL
argument_list|)
decl_stmt|;
name|struct
name|neon_type_el
name|et
init|=
name|neon_check_type
argument_list|(
literal|3
argument_list|,
name|rs
argument_list|,
name|N_EQK
argument_list|,
name|N_EQK
argument_list|,
name|N_S16
operator||
name|N_S32
operator||
name|N_KEY
argument_list|)
decl_stmt|;
name|inst
operator|.
name|instruction
operator|=
name|NEON_ENC_INTEGER
argument_list|(
name|inst
operator|.
name|instruction
argument_list|)
expr_stmt|;
comment|/* The U bit (rounding) comes from bit mask.  */
name|neon_three_same
argument_list|(
name|neon_quad
argument_list|(
name|rs
argument_list|)
argument_list|,
literal|0
argument_list|,
name|et
operator|.
name|size
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|do_neon_fcmp_absolute
parameter_list|(
name|void
parameter_list|)
block|{
name|enum
name|neon_shape
name|rs
init|=
name|neon_select_shape
argument_list|(
name|NS_DDD
argument_list|,
name|NS_QQQ
argument_list|,
name|NS_NULL
argument_list|)
decl_stmt|;
name|neon_check_type
argument_list|(
literal|3
argument_list|,
name|rs
argument_list|,
name|N_EQK
argument_list|,
name|N_EQK
argument_list|,
name|N_F32
operator||
name|N_KEY
argument_list|)
expr_stmt|;
comment|/* Size field comes from bit mask.  */
name|neon_three_same
argument_list|(
name|neon_quad
argument_list|(
name|rs
argument_list|)
argument_list|,
literal|1
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_neon_fcmp_absolute_inv
parameter_list|(
name|void
parameter_list|)
block|{
name|neon_exchange_operands
argument_list|()
expr_stmt|;
name|do_neon_fcmp_absolute
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_neon_step
parameter_list|(
name|void
parameter_list|)
block|{
name|enum
name|neon_shape
name|rs
init|=
name|neon_select_shape
argument_list|(
name|NS_DDD
argument_list|,
name|NS_QQQ
argument_list|,
name|NS_NULL
argument_list|)
decl_stmt|;
name|neon_check_type
argument_list|(
literal|3
argument_list|,
name|rs
argument_list|,
name|N_EQK
argument_list|,
name|N_EQK
argument_list|,
name|N_F32
operator||
name|N_KEY
argument_list|)
expr_stmt|;
name|neon_three_same
argument_list|(
name|neon_quad
argument_list|(
name|rs
argument_list|)
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_neon_abs_neg
parameter_list|(
name|void
parameter_list|)
block|{
name|enum
name|neon_shape
name|rs
decl_stmt|;
name|struct
name|neon_type_el
name|et
decl_stmt|;
if|if
condition|(
name|try_vfp_nsyn
argument_list|(
literal|2
argument_list|,
name|do_vfp_nsyn_abs_neg
argument_list|)
operator|==
name|SUCCESS
condition|)
return|return;
if|if
condition|(
name|vfp_or_neon_is_neon
argument_list|(
name|NEON_CHECK_CC
operator||
name|NEON_CHECK_ARCH
argument_list|)
operator|==
name|FAIL
condition|)
return|return;
name|rs
operator|=
name|neon_select_shape
argument_list|(
name|NS_DD
argument_list|,
name|NS_QQ
argument_list|,
name|NS_NULL
argument_list|)
expr_stmt|;
name|et
operator|=
name|neon_check_type
argument_list|(
literal|2
argument_list|,
name|rs
argument_list|,
name|N_EQK
argument_list|,
name|N_S8
operator||
name|N_S16
operator||
name|N_S32
operator||
name|N_F32
operator||
name|N_KEY
argument_list|)
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|LOW4
argument_list|(
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
argument_list|)
operator|<<
literal|12
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|HI1
argument_list|(
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
argument_list|)
operator|<<
literal|22
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|LOW4
argument_list|(
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
argument_list|)
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|HI1
argument_list|(
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
argument_list|)
operator|<<
literal|5
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|neon_quad
argument_list|(
name|rs
argument_list|)
operator|<<
literal|6
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
operator|(
name|et
operator|.
name|type
operator|==
name|NT_float
operator|)
operator|<<
literal|10
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|neon_logbits
argument_list|(
name|et
operator|.
name|size
argument_list|)
operator|<<
literal|18
expr_stmt|;
name|inst
operator|.
name|instruction
operator|=
name|neon_dp_fixup
argument_list|(
name|inst
operator|.
name|instruction
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_neon_sli
parameter_list|(
name|void
parameter_list|)
block|{
name|enum
name|neon_shape
name|rs
init|=
name|neon_select_shape
argument_list|(
name|NS_DDI
argument_list|,
name|NS_QQI
argument_list|,
name|NS_NULL
argument_list|)
decl_stmt|;
name|struct
name|neon_type_el
name|et
init|=
name|neon_check_type
argument_list|(
literal|2
argument_list|,
name|rs
argument_list|,
name|N_EQK
argument_list|,
name|N_8
operator||
name|N_16
operator||
name|N_32
operator||
name|N_64
operator||
name|N_KEY
argument_list|)
decl_stmt|;
name|int
name|imm
init|=
name|inst
operator|.
name|operands
index|[
literal|2
index|]
operator|.
name|imm
decl_stmt|;
name|constraint
argument_list|(
name|imm
operator|<
literal|0
operator|||
operator|(
name|unsigned
operator|)
name|imm
operator|>=
name|et
operator|.
name|size
argument_list|,
name|_
argument_list|(
literal|"immediate out of range for insert"
argument_list|)
argument_list|)
expr_stmt|;
name|neon_imm_shift
argument_list|(
name|FALSE
argument_list|,
literal|0
argument_list|,
name|neon_quad
argument_list|(
name|rs
argument_list|)
argument_list|,
name|et
argument_list|,
name|imm
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_neon_sri
parameter_list|(
name|void
parameter_list|)
block|{
name|enum
name|neon_shape
name|rs
init|=
name|neon_select_shape
argument_list|(
name|NS_DDI
argument_list|,
name|NS_QQI
argument_list|,
name|NS_NULL
argument_list|)
decl_stmt|;
name|struct
name|neon_type_el
name|et
init|=
name|neon_check_type
argument_list|(
literal|2
argument_list|,
name|rs
argument_list|,
name|N_EQK
argument_list|,
name|N_8
operator||
name|N_16
operator||
name|N_32
operator||
name|N_64
operator||
name|N_KEY
argument_list|)
decl_stmt|;
name|int
name|imm
init|=
name|inst
operator|.
name|operands
index|[
literal|2
index|]
operator|.
name|imm
decl_stmt|;
name|constraint
argument_list|(
name|imm
operator|<
literal|1
operator|||
operator|(
name|unsigned
operator|)
name|imm
operator|>
name|et
operator|.
name|size
argument_list|,
name|_
argument_list|(
literal|"immediate out of range for insert"
argument_list|)
argument_list|)
expr_stmt|;
name|neon_imm_shift
argument_list|(
name|FALSE
argument_list|,
literal|0
argument_list|,
name|neon_quad
argument_list|(
name|rs
argument_list|)
argument_list|,
name|et
argument_list|,
name|et
operator|.
name|size
operator|-
name|imm
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_neon_qshlu_imm
parameter_list|(
name|void
parameter_list|)
block|{
name|enum
name|neon_shape
name|rs
init|=
name|neon_select_shape
argument_list|(
name|NS_DDI
argument_list|,
name|NS_QQI
argument_list|,
name|NS_NULL
argument_list|)
decl_stmt|;
name|struct
name|neon_type_el
name|et
init|=
name|neon_check_type
argument_list|(
literal|2
argument_list|,
name|rs
argument_list|,
name|N_EQK
operator||
name|N_UNS
argument_list|,
name|N_S8
operator||
name|N_S16
operator||
name|N_S32
operator||
name|N_S64
operator||
name|N_KEY
argument_list|)
decl_stmt|;
name|int
name|imm
init|=
name|inst
operator|.
name|operands
index|[
literal|2
index|]
operator|.
name|imm
decl_stmt|;
name|constraint
argument_list|(
name|imm
operator|<
literal|0
operator|||
operator|(
name|unsigned
operator|)
name|imm
operator|>=
name|et
operator|.
name|size
argument_list|,
name|_
argument_list|(
literal|"immediate out of range for shift"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Only encodes the 'U present' variant of the instruction.      In this case, signed types have OP (bit 8) set to 0.      Unsigned types have OP set to 1.  */
name|inst
operator|.
name|instruction
operator||=
operator|(
name|et
operator|.
name|type
operator|==
name|NT_unsigned
operator|)
operator|<<
literal|8
expr_stmt|;
comment|/* The rest of the bits are the same as other immediate shifts.  */
name|neon_imm_shift
argument_list|(
name|FALSE
argument_list|,
literal|0
argument_list|,
name|neon_quad
argument_list|(
name|rs
argument_list|)
argument_list|,
name|et
argument_list|,
name|imm
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_neon_qmovn
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|neon_type_el
name|et
init|=
name|neon_check_type
argument_list|(
literal|2
argument_list|,
name|NS_DQ
argument_list|,
name|N_EQK
operator||
name|N_HLF
argument_list|,
name|N_SU_16_64
operator||
name|N_KEY
argument_list|)
decl_stmt|;
comment|/* Saturating move where operands can be signed or unsigned, and the      destination has the same signedness.  */
name|inst
operator|.
name|instruction
operator|=
name|NEON_ENC_INTEGER
argument_list|(
name|inst
operator|.
name|instruction
argument_list|)
expr_stmt|;
if|if
condition|(
name|et
operator|.
name|type
operator|==
name|NT_unsigned
condition|)
name|inst
operator|.
name|instruction
operator||=
literal|0xc0
expr_stmt|;
else|else
name|inst
operator|.
name|instruction
operator||=
literal|0x80
expr_stmt|;
name|neon_two_same
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|,
name|et
operator|.
name|size
operator|/
literal|2
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_neon_qmovun
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|neon_type_el
name|et
init|=
name|neon_check_type
argument_list|(
literal|2
argument_list|,
name|NS_DQ
argument_list|,
name|N_EQK
operator||
name|N_HLF
operator||
name|N_UNS
argument_list|,
name|N_S16
operator||
name|N_S32
operator||
name|N_S64
operator||
name|N_KEY
argument_list|)
decl_stmt|;
comment|/* Saturating move with unsigned results. Operands must be signed.  */
name|inst
operator|.
name|instruction
operator|=
name|NEON_ENC_INTEGER
argument_list|(
name|inst
operator|.
name|instruction
argument_list|)
expr_stmt|;
name|neon_two_same
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|,
name|et
operator|.
name|size
operator|/
literal|2
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_neon_rshift_sat_narrow
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* FIXME: Types for narrowing. If operands are signed, results can be signed      or unsigned. If operands are unsigned, results must also be unsigned.  */
name|struct
name|neon_type_el
name|et
init|=
name|neon_check_type
argument_list|(
literal|2
argument_list|,
name|NS_DQI
argument_list|,
name|N_EQK
operator||
name|N_HLF
argument_list|,
name|N_SU_16_64
operator||
name|N_KEY
argument_list|)
decl_stmt|;
name|int
name|imm
init|=
name|inst
operator|.
name|operands
index|[
literal|2
index|]
operator|.
name|imm
decl_stmt|;
comment|/* This gets the bounds check, size encoding and immediate bits calculation      right.  */
name|et
operator|.
name|size
operator|/=
literal|2
expr_stmt|;
comment|/* VQ{R}SHRN.I<size><Dd>,<Qm>, #0 is a synonym for      VQMOVN.I<size><Dd>,<Qm>.  */
if|if
condition|(
name|imm
operator|==
literal|0
condition|)
block|{
name|inst
operator|.
name|operands
index|[
literal|2
index|]
operator|.
name|present
operator|=
literal|0
expr_stmt|;
name|inst
operator|.
name|instruction
operator|=
name|N_MNEM_vqmovn
expr_stmt|;
name|do_neon_qmovn
argument_list|()
expr_stmt|;
return|return;
block|}
name|constraint
argument_list|(
name|imm
operator|<
literal|1
operator|||
operator|(
name|unsigned
operator|)
name|imm
operator|>
name|et
operator|.
name|size
argument_list|,
name|_
argument_list|(
literal|"immediate out of range"
argument_list|)
argument_list|)
expr_stmt|;
name|neon_imm_shift
argument_list|(
name|TRUE
argument_list|,
name|et
operator|.
name|type
operator|==
name|NT_unsigned
argument_list|,
literal|0
argument_list|,
name|et
argument_list|,
name|et
operator|.
name|size
operator|-
name|imm
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_neon_rshift_sat_narrow_u
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* FIXME: Types for narrowing. If operands are signed, results can be signed      or unsigned. If operands are unsigned, results must also be unsigned.  */
name|struct
name|neon_type_el
name|et
init|=
name|neon_check_type
argument_list|(
literal|2
argument_list|,
name|NS_DQI
argument_list|,
name|N_EQK
operator||
name|N_HLF
operator||
name|N_UNS
argument_list|,
name|N_S16
operator||
name|N_S32
operator||
name|N_S64
operator||
name|N_KEY
argument_list|)
decl_stmt|;
name|int
name|imm
init|=
name|inst
operator|.
name|operands
index|[
literal|2
index|]
operator|.
name|imm
decl_stmt|;
comment|/* This gets the bounds check, size encoding and immediate bits calculation      right.  */
name|et
operator|.
name|size
operator|/=
literal|2
expr_stmt|;
comment|/* VQSHRUN.I<size><Dd>,<Qm>, #0 is a synonym for      VQMOVUN.I<size><Dd>,<Qm>.  */
if|if
condition|(
name|imm
operator|==
literal|0
condition|)
block|{
name|inst
operator|.
name|operands
index|[
literal|2
index|]
operator|.
name|present
operator|=
literal|0
expr_stmt|;
name|inst
operator|.
name|instruction
operator|=
name|N_MNEM_vqmovun
expr_stmt|;
name|do_neon_qmovun
argument_list|()
expr_stmt|;
return|return;
block|}
name|constraint
argument_list|(
name|imm
operator|<
literal|1
operator|||
operator|(
name|unsigned
operator|)
name|imm
operator|>
name|et
operator|.
name|size
argument_list|,
name|_
argument_list|(
literal|"immediate out of range"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* FIXME: The manual is kind of unclear about what value U should have in      VQ{R}SHRUN instructions, but U=0, op=0 definitely encodes VRSHR, so it      must be 1.  */
name|neon_imm_shift
argument_list|(
name|TRUE
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|et
argument_list|,
name|et
operator|.
name|size
operator|-
name|imm
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_neon_movn
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|neon_type_el
name|et
init|=
name|neon_check_type
argument_list|(
literal|2
argument_list|,
name|NS_DQ
argument_list|,
name|N_EQK
operator||
name|N_HLF
argument_list|,
name|N_I16
operator||
name|N_I32
operator||
name|N_I64
operator||
name|N_KEY
argument_list|)
decl_stmt|;
name|inst
operator|.
name|instruction
operator|=
name|NEON_ENC_INTEGER
argument_list|(
name|inst
operator|.
name|instruction
argument_list|)
expr_stmt|;
name|neon_two_same
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|,
name|et
operator|.
name|size
operator|/
literal|2
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_neon_rshift_narrow
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|neon_type_el
name|et
init|=
name|neon_check_type
argument_list|(
literal|2
argument_list|,
name|NS_DQI
argument_list|,
name|N_EQK
operator||
name|N_HLF
argument_list|,
name|N_I16
operator||
name|N_I32
operator||
name|N_I64
operator||
name|N_KEY
argument_list|)
decl_stmt|;
name|int
name|imm
init|=
name|inst
operator|.
name|operands
index|[
literal|2
index|]
operator|.
name|imm
decl_stmt|;
comment|/* This gets the bounds check, size encoding and immediate bits calculation      right.  */
name|et
operator|.
name|size
operator|/=
literal|2
expr_stmt|;
comment|/* If immediate is zero then we are a pseudo-instruction for      VMOVN.I<size><Dd>,<Qm>  */
if|if
condition|(
name|imm
operator|==
literal|0
condition|)
block|{
name|inst
operator|.
name|operands
index|[
literal|2
index|]
operator|.
name|present
operator|=
literal|0
expr_stmt|;
name|inst
operator|.
name|instruction
operator|=
name|N_MNEM_vmovn
expr_stmt|;
name|do_neon_movn
argument_list|()
expr_stmt|;
return|return;
block|}
name|constraint
argument_list|(
name|imm
operator|<
literal|1
operator|||
operator|(
name|unsigned
operator|)
name|imm
operator|>
name|et
operator|.
name|size
argument_list|,
name|_
argument_list|(
literal|"immediate out of range for narrowing operation"
argument_list|)
argument_list|)
expr_stmt|;
name|neon_imm_shift
argument_list|(
name|FALSE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|et
argument_list|,
name|et
operator|.
name|size
operator|-
name|imm
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_neon_shll
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* FIXME: Type checking when lengthening.  */
name|struct
name|neon_type_el
name|et
init|=
name|neon_check_type
argument_list|(
literal|2
argument_list|,
name|NS_QDI
argument_list|,
name|N_EQK
operator||
name|N_DBL
argument_list|,
name|N_I8
operator||
name|N_I16
operator||
name|N_I32
operator||
name|N_KEY
argument_list|)
decl_stmt|;
name|unsigned
name|imm
init|=
name|inst
operator|.
name|operands
index|[
literal|2
index|]
operator|.
name|imm
decl_stmt|;
if|if
condition|(
name|imm
operator|==
name|et
operator|.
name|size
condition|)
block|{
comment|/* Maximum shift variant.  */
name|inst
operator|.
name|instruction
operator|=
name|NEON_ENC_INTEGER
argument_list|(
name|inst
operator|.
name|instruction
argument_list|)
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|LOW4
argument_list|(
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
argument_list|)
operator|<<
literal|12
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|HI1
argument_list|(
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
argument_list|)
operator|<<
literal|22
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|LOW4
argument_list|(
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
argument_list|)
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|HI1
argument_list|(
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
argument_list|)
operator|<<
literal|5
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|neon_logbits
argument_list|(
name|et
operator|.
name|size
argument_list|)
operator|<<
literal|18
expr_stmt|;
name|inst
operator|.
name|instruction
operator|=
name|neon_dp_fixup
argument_list|(
name|inst
operator|.
name|instruction
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* A more-specific type check for non-max versions.  */
name|et
operator|=
name|neon_check_type
argument_list|(
literal|2
argument_list|,
name|NS_QDI
argument_list|,
name|N_EQK
operator||
name|N_DBL
argument_list|,
name|N_SU_32
operator||
name|N_KEY
argument_list|)
expr_stmt|;
name|inst
operator|.
name|instruction
operator|=
name|NEON_ENC_IMMED
argument_list|(
name|inst
operator|.
name|instruction
argument_list|)
expr_stmt|;
name|neon_imm_shift
argument_list|(
name|TRUE
argument_list|,
name|et
operator|.
name|type
operator|==
name|NT_unsigned
argument_list|,
literal|0
argument_list|,
name|et
argument_list|,
name|imm
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Check the various types for the VCVT instruction, and return which version    the current instruction is.  */
end_comment

begin_function
specifier|static
name|int
name|neon_cvt_flavour
parameter_list|(
name|enum
name|neon_shape
name|rs
parameter_list|)
block|{
define|#
directive|define
name|CVT_VAR
parameter_list|(
name|C
parameter_list|,
name|X
parameter_list|,
name|Y
parameter_list|)
define|\
value|et = neon_check_type (2, rs, whole_reg | (X), whole_reg | (Y));	\   if (et.type != NT_invtype)						\     {									\       inst.error = NULL;						\       return (C);							\     }
name|struct
name|neon_type_el
name|et
decl_stmt|;
name|unsigned
name|whole_reg
init|=
operator|(
name|rs
operator|==
name|NS_FFI
operator|||
name|rs
operator|==
name|NS_FD
operator|||
name|rs
operator|==
name|NS_DF
operator|||
name|rs
operator|==
name|NS_FF
operator|)
condition|?
name|N_VFP
else|:
literal|0
decl_stmt|;
comment|/* The instruction versions which take an immediate take one register      argument, which is extended to the width of the full register. Thus the      "source" and "destination" registers must have the same width.  Hack that      here by making the size equal to the key (wider, in this case) operand.  */
name|unsigned
name|key
init|=
operator|(
name|rs
operator|==
name|NS_QQI
operator|||
name|rs
operator|==
name|NS_DDI
operator|||
name|rs
operator|==
name|NS_FFI
operator|)
condition|?
name|N_KEY
else|:
literal|0
decl_stmt|;
name|CVT_VAR
argument_list|(
literal|0
argument_list|,
name|N_S32
argument_list|,
name|N_F32
argument_list|)
expr_stmt|;
name|CVT_VAR
argument_list|(
literal|1
argument_list|,
name|N_U32
argument_list|,
name|N_F32
argument_list|)
expr_stmt|;
name|CVT_VAR
argument_list|(
literal|2
argument_list|,
name|N_F32
argument_list|,
name|N_S32
argument_list|)
expr_stmt|;
name|CVT_VAR
argument_list|(
literal|3
argument_list|,
name|N_F32
argument_list|,
name|N_U32
argument_list|)
expr_stmt|;
name|whole_reg
operator|=
name|N_VFP
expr_stmt|;
comment|/* VFP instructions.  */
name|CVT_VAR
argument_list|(
literal|4
argument_list|,
name|N_F32
argument_list|,
name|N_F64
argument_list|)
expr_stmt|;
name|CVT_VAR
argument_list|(
literal|5
argument_list|,
name|N_F64
argument_list|,
name|N_F32
argument_list|)
expr_stmt|;
name|CVT_VAR
argument_list|(
literal|6
argument_list|,
name|N_S32
argument_list|,
name|N_F64
operator||
name|key
argument_list|)
expr_stmt|;
name|CVT_VAR
argument_list|(
literal|7
argument_list|,
name|N_U32
argument_list|,
name|N_F64
operator||
name|key
argument_list|)
expr_stmt|;
name|CVT_VAR
argument_list|(
literal|8
argument_list|,
name|N_F64
operator||
name|key
argument_list|,
name|N_S32
argument_list|)
expr_stmt|;
name|CVT_VAR
argument_list|(
literal|9
argument_list|,
name|N_F64
operator||
name|key
argument_list|,
name|N_U32
argument_list|)
expr_stmt|;
comment|/* VFP instructions with bitshift.  */
name|CVT_VAR
argument_list|(
literal|10
argument_list|,
name|N_F32
operator||
name|key
argument_list|,
name|N_S16
argument_list|)
expr_stmt|;
name|CVT_VAR
argument_list|(
literal|11
argument_list|,
name|N_F32
operator||
name|key
argument_list|,
name|N_U16
argument_list|)
expr_stmt|;
name|CVT_VAR
argument_list|(
literal|12
argument_list|,
name|N_F64
operator||
name|key
argument_list|,
name|N_S16
argument_list|)
expr_stmt|;
name|CVT_VAR
argument_list|(
literal|13
argument_list|,
name|N_F64
operator||
name|key
argument_list|,
name|N_U16
argument_list|)
expr_stmt|;
name|CVT_VAR
argument_list|(
literal|14
argument_list|,
name|N_S16
argument_list|,
name|N_F32
operator||
name|key
argument_list|)
expr_stmt|;
name|CVT_VAR
argument_list|(
literal|15
argument_list|,
name|N_U16
argument_list|,
name|N_F32
operator||
name|key
argument_list|)
expr_stmt|;
name|CVT_VAR
argument_list|(
literal|16
argument_list|,
name|N_S16
argument_list|,
name|N_F64
operator||
name|key
argument_list|)
expr_stmt|;
name|CVT_VAR
argument_list|(
literal|17
argument_list|,
name|N_U16
argument_list|,
name|N_F64
operator||
name|key
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
undef|#
directive|undef
name|CVT_VAR
block|}
end_function

begin_comment
comment|/* Neon-syntax VFP conversions.  */
end_comment

begin_function
specifier|static
name|void
name|do_vfp_nsyn_cvt
parameter_list|(
name|enum
name|neon_shape
name|rs
parameter_list|,
name|int
name|flavour
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|opname
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|rs
operator|==
name|NS_DDI
operator|||
name|rs
operator|==
name|NS_QQI
operator|||
name|rs
operator|==
name|NS_FFI
condition|)
block|{
comment|/* Conversions with immediate bitshift.  */
specifier|const
name|char
modifier|*
name|enc
index|[]
init|=
block|{
literal|"ftosls"
block|,
literal|"ftouls"
block|,
literal|"fsltos"
block|,
literal|"fultos"
block|,
name|NULL
block|,
name|NULL
block|,
literal|"ftosld"
block|,
literal|"ftould"
block|,
literal|"fsltod"
block|,
literal|"fultod"
block|,
literal|"fshtos"
block|,
literal|"fuhtos"
block|,
literal|"fshtod"
block|,
literal|"fuhtod"
block|,
literal|"ftoshs"
block|,
literal|"ftouhs"
block|,
literal|"ftoshd"
block|,
literal|"ftouhd"
block|}
decl_stmt|;
if|if
condition|(
name|flavour
operator|>=
literal|0
operator|&&
name|flavour
operator|<
operator|(
name|int
operator|)
name|ARRAY_SIZE
argument_list|(
name|enc
argument_list|)
condition|)
block|{
name|opname
operator|=
name|enc
index|[
name|flavour
index|]
expr_stmt|;
name|constraint
argument_list|(
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
operator|!=
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
argument_list|,
name|_
argument_list|(
literal|"operands 0 and 1 must be the same register"
argument_list|)
argument_list|)
expr_stmt|;
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|=
name|inst
operator|.
name|operands
index|[
literal|2
index|]
expr_stmt|;
name|memset
argument_list|(
operator|&
name|inst
operator|.
name|operands
index|[
literal|2
index|]
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
name|inst
operator|.
name|operands
index|[
literal|2
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Conversions without bitshift.  */
specifier|const
name|char
modifier|*
name|enc
index|[]
init|=
block|{
literal|"ftosizs"
block|,
literal|"ftouizs"
block|,
literal|"fsitos"
block|,
literal|"fuitos"
block|,
literal|"fcvtsd"
block|,
literal|"fcvtds"
block|,
literal|"ftosizd"
block|,
literal|"ftouizd"
block|,
literal|"fsitod"
block|,
literal|"fuitod"
block|}
decl_stmt|;
if|if
condition|(
name|flavour
operator|>=
literal|0
operator|&&
name|flavour
operator|<
operator|(
name|int
operator|)
name|ARRAY_SIZE
argument_list|(
name|enc
argument_list|)
condition|)
name|opname
operator|=
name|enc
index|[
name|flavour
index|]
expr_stmt|;
block|}
if|if
condition|(
name|opname
condition|)
name|do_vfp_nsyn_opcode
argument_list|(
name|opname
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_vfp_nsyn_cvtz
parameter_list|(
name|void
parameter_list|)
block|{
name|enum
name|neon_shape
name|rs
init|=
name|neon_select_shape
argument_list|(
name|NS_FF
argument_list|,
name|NS_FD
argument_list|,
name|NS_NULL
argument_list|)
decl_stmt|;
name|int
name|flavour
init|=
name|neon_cvt_flavour
argument_list|(
name|rs
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|enc
index|[]
init|=
block|{
literal|"ftosizs"
block|,
literal|"ftouizs"
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
literal|"ftosizd"
block|,
literal|"ftouizd"
block|}
decl_stmt|;
if|if
condition|(
name|flavour
operator|>=
literal|0
operator|&&
name|flavour
operator|<
operator|(
name|int
operator|)
name|ARRAY_SIZE
argument_list|(
name|enc
argument_list|)
operator|&&
name|enc
index|[
name|flavour
index|]
condition|)
name|do_vfp_nsyn_opcode
argument_list|(
name|enc
index|[
name|flavour
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_neon_cvt
parameter_list|(
name|void
parameter_list|)
block|{
name|enum
name|neon_shape
name|rs
init|=
name|neon_select_shape
argument_list|(
name|NS_DDI
argument_list|,
name|NS_QQI
argument_list|,
name|NS_FFI
argument_list|,
name|NS_DD
argument_list|,
name|NS_QQ
argument_list|,
name|NS_FD
argument_list|,
name|NS_DF
argument_list|,
name|NS_FF
argument_list|,
name|NS_NULL
argument_list|)
decl_stmt|;
name|int
name|flavour
init|=
name|neon_cvt_flavour
argument_list|(
name|rs
argument_list|)
decl_stmt|;
comment|/* VFP rather than Neon conversions.  */
if|if
condition|(
name|flavour
operator|>=
literal|4
condition|)
block|{
name|do_vfp_nsyn_cvt
argument_list|(
name|rs
argument_list|,
name|flavour
argument_list|)
expr_stmt|;
return|return;
block|}
switch|switch
condition|(
name|rs
condition|)
block|{
case|case
name|NS_DDI
case|:
case|case
name|NS_QQI
case|:
block|{
if|if
condition|(
name|vfp_or_neon_is_neon
argument_list|(
name|NEON_CHECK_CC
operator||
name|NEON_CHECK_ARCH
argument_list|)
operator|==
name|FAIL
condition|)
return|return;
comment|/* Fixed-point conversion with #0 immediate is encoded as an            integer conversion.  */
if|if
condition|(
name|inst
operator|.
name|operands
index|[
literal|2
index|]
operator|.
name|present
operator|&&
name|inst
operator|.
name|operands
index|[
literal|2
index|]
operator|.
name|imm
operator|==
literal|0
condition|)
goto|goto
name|int_encode
goto|;
name|unsigned
name|immbits
init|=
literal|32
operator|-
name|inst
operator|.
name|operands
index|[
literal|2
index|]
operator|.
name|imm
decl_stmt|;
name|unsigned
name|enctab
index|[]
init|=
block|{
literal|0x0000100
block|,
literal|0x1000100
block|,
literal|0x0
block|,
literal|0x1000000
block|}
decl_stmt|;
name|inst
operator|.
name|instruction
operator|=
name|NEON_ENC_IMMED
argument_list|(
name|inst
operator|.
name|instruction
argument_list|)
expr_stmt|;
if|if
condition|(
name|flavour
operator|!=
operator|-
literal|1
condition|)
name|inst
operator|.
name|instruction
operator||=
name|enctab
index|[
name|flavour
index|]
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|LOW4
argument_list|(
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
argument_list|)
operator|<<
literal|12
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|HI1
argument_list|(
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
argument_list|)
operator|<<
literal|22
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|LOW4
argument_list|(
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
argument_list|)
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|HI1
argument_list|(
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
argument_list|)
operator|<<
literal|5
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|neon_quad
argument_list|(
name|rs
argument_list|)
operator|<<
literal|6
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
literal|1
operator|<<
literal|21
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|immbits
operator|<<
literal|16
expr_stmt|;
name|inst
operator|.
name|instruction
operator|=
name|neon_dp_fixup
argument_list|(
name|inst
operator|.
name|instruction
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|NS_DD
case|:
case|case
name|NS_QQ
case|:
name|int_encode
label|:
block|{
name|unsigned
name|enctab
index|[]
init|=
block|{
literal|0x100
block|,
literal|0x180
block|,
literal|0x0
block|,
literal|0x080
block|}
decl_stmt|;
name|inst
operator|.
name|instruction
operator|=
name|NEON_ENC_INTEGER
argument_list|(
name|inst
operator|.
name|instruction
argument_list|)
expr_stmt|;
if|if
condition|(
name|vfp_or_neon_is_neon
argument_list|(
name|NEON_CHECK_CC
operator||
name|NEON_CHECK_ARCH
argument_list|)
operator|==
name|FAIL
condition|)
return|return;
if|if
condition|(
name|flavour
operator|!=
operator|-
literal|1
condition|)
name|inst
operator|.
name|instruction
operator||=
name|enctab
index|[
name|flavour
index|]
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|LOW4
argument_list|(
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
argument_list|)
operator|<<
literal|12
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|HI1
argument_list|(
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
argument_list|)
operator|<<
literal|22
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|LOW4
argument_list|(
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
argument_list|)
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|HI1
argument_list|(
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
argument_list|)
operator|<<
literal|5
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|neon_quad
argument_list|(
name|rs
argument_list|)
operator|<<
literal|6
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
literal|2
operator|<<
literal|18
expr_stmt|;
name|inst
operator|.
name|instruction
operator|=
name|neon_dp_fixup
argument_list|(
name|inst
operator|.
name|instruction
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
comment|/* Some VFP conversions go here (s32<-> f32, u32<-> f32).  */
name|do_vfp_nsyn_cvt
argument_list|(
name|rs
argument_list|,
name|flavour
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|neon_move_immediate
parameter_list|(
name|void
parameter_list|)
block|{
name|enum
name|neon_shape
name|rs
init|=
name|neon_select_shape
argument_list|(
name|NS_DI
argument_list|,
name|NS_QI
argument_list|,
name|NS_NULL
argument_list|)
decl_stmt|;
name|struct
name|neon_type_el
name|et
init|=
name|neon_check_type
argument_list|(
literal|2
argument_list|,
name|rs
argument_list|,
name|N_I8
operator||
name|N_I16
operator||
name|N_I32
operator||
name|N_I64
operator||
name|N_F32
operator||
name|N_KEY
argument_list|,
name|N_EQK
argument_list|)
decl_stmt|;
name|unsigned
name|immlo
decl_stmt|,
name|immhi
init|=
literal|0
decl_stmt|,
name|immbits
decl_stmt|;
name|int
name|op
decl_stmt|,
name|cmode
decl_stmt|,
name|float_p
decl_stmt|;
name|constraint
argument_list|(
name|et
operator|.
name|type
operator|==
name|NT_invtype
argument_list|,
name|_
argument_list|(
literal|"operand size must be specified for immediate VMOV"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We start out as an MVN instruction if OP = 1, MOV otherwise.  */
name|op
operator|=
operator|(
name|inst
operator|.
name|instruction
operator|&
operator|(
literal|1
operator|<<
literal|5
operator|)
operator|)
operator|!=
literal|0
expr_stmt|;
name|immlo
operator|=
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|imm
expr_stmt|;
if|if
condition|(
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|regisimm
condition|)
name|immhi
operator|=
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
expr_stmt|;
name|constraint
argument_list|(
name|et
operator|.
name|size
operator|<
literal|32
operator|&&
operator|(
name|immlo
operator|&
operator|~
operator|(
operator|(
literal|1
operator|<<
name|et
operator|.
name|size
operator|)
operator|-
literal|1
operator|)
operator|)
operator|!=
literal|0
argument_list|,
name|_
argument_list|(
literal|"immediate has bits set outside the operand size"
argument_list|)
argument_list|)
expr_stmt|;
name|float_p
operator|=
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|immisfloat
expr_stmt|;
if|if
condition|(
operator|(
name|cmode
operator|=
name|neon_cmode_for_move_imm
argument_list|(
name|immlo
argument_list|,
name|immhi
argument_list|,
name|float_p
argument_list|,
operator|&
name|immbits
argument_list|,
operator|&
name|op
argument_list|,
name|et
operator|.
name|size
argument_list|,
name|et
operator|.
name|type
argument_list|)
operator|)
operator|==
name|FAIL
condition|)
block|{
comment|/* Invert relevant bits only.  */
name|neon_invert_size
argument_list|(
operator|&
name|immlo
argument_list|,
operator|&
name|immhi
argument_list|,
name|et
operator|.
name|size
argument_list|)
expr_stmt|;
comment|/* Flip from VMOV/VMVN to VMVN/VMOV. Some immediate types are unavailable          with one or the other; those cases are caught by          neon_cmode_for_move_imm.  */
name|op
operator|=
operator|!
name|op
expr_stmt|;
if|if
condition|(
operator|(
name|cmode
operator|=
name|neon_cmode_for_move_imm
argument_list|(
name|immlo
argument_list|,
name|immhi
argument_list|,
name|float_p
argument_list|,
operator|&
name|immbits
argument_list|,
operator|&
name|op
argument_list|,
name|et
operator|.
name|size
argument_list|,
name|et
operator|.
name|type
argument_list|)
operator|)
operator|==
name|FAIL
condition|)
block|{
name|first_error
argument_list|(
name|_
argument_list|(
literal|"immediate out of range"
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|inst
operator|.
name|instruction
operator|&=
operator|~
operator|(
literal|1
operator|<<
literal|5
operator|)
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|op
operator|<<
literal|5
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|LOW4
argument_list|(
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
argument_list|)
operator|<<
literal|12
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|HI1
argument_list|(
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
argument_list|)
operator|<<
literal|22
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|neon_quad
argument_list|(
name|rs
argument_list|)
operator|<<
literal|6
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|cmode
operator|<<
literal|8
expr_stmt|;
name|neon_write_immbits
argument_list|(
name|immbits
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_neon_mvn
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|isreg
condition|)
block|{
name|enum
name|neon_shape
name|rs
init|=
name|neon_select_shape
argument_list|(
name|NS_DD
argument_list|,
name|NS_QQ
argument_list|,
name|NS_NULL
argument_list|)
decl_stmt|;
name|inst
operator|.
name|instruction
operator|=
name|NEON_ENC_INTEGER
argument_list|(
name|inst
operator|.
name|instruction
argument_list|)
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|LOW4
argument_list|(
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
argument_list|)
operator|<<
literal|12
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|HI1
argument_list|(
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
argument_list|)
operator|<<
literal|22
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|LOW4
argument_list|(
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
argument_list|)
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|HI1
argument_list|(
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
argument_list|)
operator|<<
literal|5
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|neon_quad
argument_list|(
name|rs
argument_list|)
operator|<<
literal|6
expr_stmt|;
block|}
else|else
block|{
name|inst
operator|.
name|instruction
operator|=
name|NEON_ENC_IMMED
argument_list|(
name|inst
operator|.
name|instruction
argument_list|)
expr_stmt|;
name|neon_move_immediate
argument_list|()
expr_stmt|;
block|}
name|inst
operator|.
name|instruction
operator|=
name|neon_dp_fixup
argument_list|(
name|inst
operator|.
name|instruction
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Encode instructions of form:    |28/24|23|22|21 20|19 16|15 12|11    8|7|6|5|4|3  0|   |  U  |x |D |size | Rn  | Rd  |x x x x|N|x|M|x| Rm |  */
end_comment

begin_function
specifier|static
name|void
name|neon_mixed_length
parameter_list|(
name|struct
name|neon_type_el
name|et
parameter_list|,
name|unsigned
name|size
parameter_list|)
block|{
name|inst
operator|.
name|instruction
operator||=
name|LOW4
argument_list|(
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
argument_list|)
operator|<<
literal|12
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|HI1
argument_list|(
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
argument_list|)
operator|<<
literal|22
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|LOW4
argument_list|(
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
argument_list|)
operator|<<
literal|16
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|HI1
argument_list|(
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
argument_list|)
operator|<<
literal|7
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|LOW4
argument_list|(
name|inst
operator|.
name|operands
index|[
literal|2
index|]
operator|.
name|reg
argument_list|)
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|HI1
argument_list|(
name|inst
operator|.
name|operands
index|[
literal|2
index|]
operator|.
name|reg
argument_list|)
operator|<<
literal|5
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
operator|(
name|et
operator|.
name|type
operator|==
name|NT_unsigned
operator|)
operator|<<
literal|24
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|neon_logbits
argument_list|(
name|size
argument_list|)
operator|<<
literal|20
expr_stmt|;
name|inst
operator|.
name|instruction
operator|=
name|neon_dp_fixup
argument_list|(
name|inst
operator|.
name|instruction
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_neon_dyadic_long
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* FIXME: Type checking for lengthening op.  */
name|struct
name|neon_type_el
name|et
init|=
name|neon_check_type
argument_list|(
literal|3
argument_list|,
name|NS_QDD
argument_list|,
name|N_EQK
operator||
name|N_DBL
argument_list|,
name|N_EQK
argument_list|,
name|N_SU_32
operator||
name|N_KEY
argument_list|)
decl_stmt|;
name|neon_mixed_length
argument_list|(
name|et
argument_list|,
name|et
operator|.
name|size
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_neon_abal
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|neon_type_el
name|et
init|=
name|neon_check_type
argument_list|(
literal|3
argument_list|,
name|NS_QDD
argument_list|,
name|N_EQK
operator||
name|N_INT
operator||
name|N_DBL
argument_list|,
name|N_EQK
argument_list|,
name|N_SU_32
operator||
name|N_KEY
argument_list|)
decl_stmt|;
name|neon_mixed_length
argument_list|(
name|et
argument_list|,
name|et
operator|.
name|size
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|neon_mac_reg_scalar_long
parameter_list|(
name|unsigned
name|regtypes
parameter_list|,
name|unsigned
name|scalartypes
parameter_list|)
block|{
if|if
condition|(
name|inst
operator|.
name|operands
index|[
literal|2
index|]
operator|.
name|isscalar
condition|)
block|{
name|struct
name|neon_type_el
name|et
init|=
name|neon_check_type
argument_list|(
literal|3
argument_list|,
name|NS_QDS
argument_list|,
name|N_EQK
operator||
name|N_DBL
argument_list|,
name|N_EQK
argument_list|,
name|regtypes
operator||
name|N_KEY
argument_list|)
decl_stmt|;
name|inst
operator|.
name|instruction
operator|=
name|NEON_ENC_SCALAR
argument_list|(
name|inst
operator|.
name|instruction
argument_list|)
expr_stmt|;
name|neon_mul_mac
argument_list|(
name|et
argument_list|,
name|et
operator|.
name|type
operator|==
name|NT_unsigned
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|struct
name|neon_type_el
name|et
init|=
name|neon_check_type
argument_list|(
literal|3
argument_list|,
name|NS_QDD
argument_list|,
name|N_EQK
operator||
name|N_DBL
argument_list|,
name|N_EQK
argument_list|,
name|scalartypes
operator||
name|N_KEY
argument_list|)
decl_stmt|;
name|inst
operator|.
name|instruction
operator|=
name|NEON_ENC_INTEGER
argument_list|(
name|inst
operator|.
name|instruction
argument_list|)
expr_stmt|;
name|neon_mixed_length
argument_list|(
name|et
argument_list|,
name|et
operator|.
name|size
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|do_neon_mac_maybe_scalar_long
parameter_list|(
name|void
parameter_list|)
block|{
name|neon_mac_reg_scalar_long
argument_list|(
name|N_S16
operator||
name|N_S32
operator||
name|N_U16
operator||
name|N_U32
argument_list|,
name|N_SU_32
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_neon_dyadic_wide
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|neon_type_el
name|et
init|=
name|neon_check_type
argument_list|(
literal|3
argument_list|,
name|NS_QQD
argument_list|,
name|N_EQK
operator||
name|N_DBL
argument_list|,
name|N_EQK
operator||
name|N_DBL
argument_list|,
name|N_SU_32
operator||
name|N_KEY
argument_list|)
decl_stmt|;
name|neon_mixed_length
argument_list|(
name|et
argument_list|,
name|et
operator|.
name|size
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_neon_dyadic_narrow
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|neon_type_el
name|et
init|=
name|neon_check_type
argument_list|(
literal|3
argument_list|,
name|NS_QDD
argument_list|,
name|N_EQK
operator||
name|N_DBL
argument_list|,
name|N_EQK
argument_list|,
name|N_I16
operator||
name|N_I32
operator||
name|N_I64
operator||
name|N_KEY
argument_list|)
decl_stmt|;
comment|/* Operand sign is unimportant, and the U bit is part of the opcode,      so force the operand type to integer.  */
name|et
operator|.
name|type
operator|=
name|NT_integer
expr_stmt|;
name|neon_mixed_length
argument_list|(
name|et
argument_list|,
name|et
operator|.
name|size
operator|/
literal|2
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_neon_mul_sat_scalar_long
parameter_list|(
name|void
parameter_list|)
block|{
name|neon_mac_reg_scalar_long
argument_list|(
name|N_S16
operator||
name|N_S32
argument_list|,
name|N_S16
operator||
name|N_S32
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_neon_vmull
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|inst
operator|.
name|operands
index|[
literal|2
index|]
operator|.
name|isscalar
condition|)
name|do_neon_mac_maybe_scalar_long
argument_list|()
expr_stmt|;
else|else
block|{
name|struct
name|neon_type_el
name|et
init|=
name|neon_check_type
argument_list|(
literal|3
argument_list|,
name|NS_QDD
argument_list|,
name|N_EQK
operator||
name|N_DBL
argument_list|,
name|N_EQK
argument_list|,
name|N_SU_32
operator||
name|N_P8
operator||
name|N_KEY
argument_list|)
decl_stmt|;
if|if
condition|(
name|et
operator|.
name|type
operator|==
name|NT_poly
condition|)
name|inst
operator|.
name|instruction
operator|=
name|NEON_ENC_POLY
argument_list|(
name|inst
operator|.
name|instruction
argument_list|)
expr_stmt|;
else|else
name|inst
operator|.
name|instruction
operator|=
name|NEON_ENC_INTEGER
argument_list|(
name|inst
operator|.
name|instruction
argument_list|)
expr_stmt|;
comment|/* For polynomial encoding, size field must be 0b00 and the U bit must be          zero. Should be OK as-is.  */
name|neon_mixed_length
argument_list|(
name|et
argument_list|,
name|et
operator|.
name|size
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|do_neon_ext
parameter_list|(
name|void
parameter_list|)
block|{
name|enum
name|neon_shape
name|rs
init|=
name|neon_select_shape
argument_list|(
name|NS_DDDI
argument_list|,
name|NS_QQQI
argument_list|,
name|NS_NULL
argument_list|)
decl_stmt|;
name|struct
name|neon_type_el
name|et
init|=
name|neon_check_type
argument_list|(
literal|3
argument_list|,
name|rs
argument_list|,
name|N_EQK
argument_list|,
name|N_EQK
argument_list|,
name|N_8
operator||
name|N_16
operator||
name|N_32
operator||
name|N_64
operator||
name|N_KEY
argument_list|)
decl_stmt|;
name|unsigned
name|imm
init|=
operator|(
name|inst
operator|.
name|operands
index|[
literal|3
index|]
operator|.
name|imm
operator|*
name|et
operator|.
name|size
operator|)
operator|/
literal|8
decl_stmt|;
name|constraint
argument_list|(
name|imm
operator|>=
operator|(
name|neon_quad
argument_list|(
name|rs
argument_list|)
condition|?
literal|16
else|:
literal|8
operator|)
argument_list|,
name|_
argument_list|(
literal|"shift out of range"
argument_list|)
argument_list|)
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|LOW4
argument_list|(
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
argument_list|)
operator|<<
literal|12
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|HI1
argument_list|(
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
argument_list|)
operator|<<
literal|22
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|LOW4
argument_list|(
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
argument_list|)
operator|<<
literal|16
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|HI1
argument_list|(
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
argument_list|)
operator|<<
literal|7
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|LOW4
argument_list|(
name|inst
operator|.
name|operands
index|[
literal|2
index|]
operator|.
name|reg
argument_list|)
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|HI1
argument_list|(
name|inst
operator|.
name|operands
index|[
literal|2
index|]
operator|.
name|reg
argument_list|)
operator|<<
literal|5
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|neon_quad
argument_list|(
name|rs
argument_list|)
operator|<<
literal|6
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|imm
operator|<<
literal|8
expr_stmt|;
name|inst
operator|.
name|instruction
operator|=
name|neon_dp_fixup
argument_list|(
name|inst
operator|.
name|instruction
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_neon_rev
parameter_list|(
name|void
parameter_list|)
block|{
name|enum
name|neon_shape
name|rs
init|=
name|neon_select_shape
argument_list|(
name|NS_DD
argument_list|,
name|NS_QQ
argument_list|,
name|NS_NULL
argument_list|)
decl_stmt|;
name|struct
name|neon_type_el
name|et
init|=
name|neon_check_type
argument_list|(
literal|2
argument_list|,
name|rs
argument_list|,
name|N_EQK
argument_list|,
name|N_8
operator||
name|N_16
operator||
name|N_32
operator||
name|N_KEY
argument_list|)
decl_stmt|;
name|unsigned
name|op
init|=
operator|(
name|inst
operator|.
name|instruction
operator|>>
literal|7
operator|)
operator|&
literal|3
decl_stmt|;
comment|/* N (width of reversed regions) is encoded as part of the bitmask. We      extract it here to check the elements to be reversed are smaller.      Otherwise we'd get a reserved instruction.  */
name|unsigned
name|elsize
init|=
operator|(
name|op
operator|==
literal|2
operator|)
condition|?
literal|16
else|:
operator|(
name|op
operator|==
literal|1
operator|)
condition|?
literal|32
else|:
operator|(
name|op
operator|==
literal|0
operator|)
condition|?
literal|64
else|:
literal|0
decl_stmt|;
name|assert
argument_list|(
name|elsize
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|constraint
argument_list|(
name|et
operator|.
name|size
operator|>=
name|elsize
argument_list|,
name|_
argument_list|(
literal|"elements must be smaller than reversal region"
argument_list|)
argument_list|)
expr_stmt|;
name|neon_two_same
argument_list|(
name|neon_quad
argument_list|(
name|rs
argument_list|)
argument_list|,
literal|1
argument_list|,
name|et
operator|.
name|size
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_neon_dup
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|isscalar
condition|)
block|{
name|enum
name|neon_shape
name|rs
init|=
name|neon_select_shape
argument_list|(
name|NS_DS
argument_list|,
name|NS_QS
argument_list|,
name|NS_NULL
argument_list|)
decl_stmt|;
name|struct
name|neon_type_el
name|et
init|=
name|neon_check_type
argument_list|(
literal|2
argument_list|,
name|rs
argument_list|,
name|N_EQK
argument_list|,
name|N_8
operator||
name|N_16
operator||
name|N_32
operator||
name|N_KEY
argument_list|)
decl_stmt|;
name|unsigned
name|sizebits
init|=
name|et
operator|.
name|size
operator|>>
literal|3
decl_stmt|;
name|unsigned
name|dm
init|=
name|NEON_SCALAR_REG
argument_list|(
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
argument_list|)
decl_stmt|;
name|int
name|logsize
init|=
name|neon_logbits
argument_list|(
name|et
operator|.
name|size
argument_list|)
decl_stmt|;
name|unsigned
name|x
init|=
name|NEON_SCALAR_INDEX
argument_list|(
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
argument_list|)
operator|<<
name|logsize
decl_stmt|;
if|if
condition|(
name|vfp_or_neon_is_neon
argument_list|(
name|NEON_CHECK_CC
argument_list|)
operator|==
name|FAIL
condition|)
return|return;
name|inst
operator|.
name|instruction
operator|=
name|NEON_ENC_SCALAR
argument_list|(
name|inst
operator|.
name|instruction
argument_list|)
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|LOW4
argument_list|(
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
argument_list|)
operator|<<
literal|12
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|HI1
argument_list|(
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
argument_list|)
operator|<<
literal|22
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|LOW4
argument_list|(
name|dm
argument_list|)
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|HI1
argument_list|(
name|dm
argument_list|)
operator|<<
literal|5
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|neon_quad
argument_list|(
name|rs
argument_list|)
operator|<<
literal|6
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|x
operator|<<
literal|17
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|sizebits
operator|<<
literal|16
expr_stmt|;
name|inst
operator|.
name|instruction
operator|=
name|neon_dp_fixup
argument_list|(
name|inst
operator|.
name|instruction
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|enum
name|neon_shape
name|rs
init|=
name|neon_select_shape
argument_list|(
name|NS_DR
argument_list|,
name|NS_QR
argument_list|,
name|NS_NULL
argument_list|)
decl_stmt|;
name|struct
name|neon_type_el
name|et
init|=
name|neon_check_type
argument_list|(
literal|2
argument_list|,
name|rs
argument_list|,
name|N_8
operator||
name|N_16
operator||
name|N_32
operator||
name|N_KEY
argument_list|,
name|N_EQK
argument_list|)
decl_stmt|;
comment|/* Duplicate ARM register to lanes of vector.  */
name|inst
operator|.
name|instruction
operator|=
name|NEON_ENC_ARMREG
argument_list|(
name|inst
operator|.
name|instruction
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|et
operator|.
name|size
condition|)
block|{
case|case
literal|8
case|:
name|inst
operator|.
name|instruction
operator||=
literal|0x400000
expr_stmt|;
break|break;
case|case
literal|16
case|:
name|inst
operator|.
name|instruction
operator||=
literal|0x000020
expr_stmt|;
break|break;
case|case
literal|32
case|:
name|inst
operator|.
name|instruction
operator||=
literal|0x000000
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|inst
operator|.
name|instruction
operator||=
name|LOW4
argument_list|(
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
argument_list|)
operator|<<
literal|12
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|LOW4
argument_list|(
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
argument_list|)
operator|<<
literal|16
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|HI1
argument_list|(
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
argument_list|)
operator|<<
literal|7
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|neon_quad
argument_list|(
name|rs
argument_list|)
operator|<<
literal|21
expr_stmt|;
comment|/* The encoding for this instruction is identical for the ARM and Thumb          variants, except for the condition field.  */
name|do_vfp_cond_or_thumb
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* VMOV has particularly many variations. It can be one of:      0. VMOV<c><q><Qd>,<Qm>      1. VMOV<c><q><Dd>,<Dm>    (Register operations, which are VORR with Rm = Rn.)      2. VMOV<c><q>.<dt><Qd>, #<imm>      3. VMOV<c><q>.<dt><Dd>, #<imm>    (Immediate loads.)      4. VMOV<c><q>.<size><Dn[x]>,<Rd>    (ARM register to scalar.)      5. VMOV<c><q><Dm>,<Rd>,<Rn>    (Two ARM registers to vector.)      6. VMOV<c><q>.<dt><Rd>,<Dn[x]>    (Scalar to ARM register.)      7. VMOV<c><q><Rd>,<Rn>,<Dm>    (Vector to two ARM registers.)      8. VMOV.F32<Sd>,<Sm>      9. VMOV.F64<Dd>,<Dm>    (VFP register moves.)     10. VMOV.F32<Sd>, #imm     11. VMOV.F64<Dd>, #imm    (VFP float immediate load.)     12. VMOV<Rd>,<Sm>    (VFP single to ARM reg.)     13. VMOV<Sd>,<Rm>    (ARM reg to VFP single.)     14. VMOV<Rd>,<Re>,<Sn>,<Sm>    (Two ARM regs to two VFP singles.)     15. VMOV<Sd>,<Se>,<Rn>,<Rm>    (Two VFP singles to two ARM regs.)       These cases can be disambiguated using neon_select_shape, except cases 1/9    and 3/11 which depend on the operand type too.        All the encoded bits are hardcoded by this function.        Cases 4, 6 may be used with VFPv1 and above (only 32-bit transfers!).    Cases 5, 7 may be used with VFPv2 and above.        FIXME: Some of the checking may be a bit sloppy (in a couple of cases you    can specify a type where it doesn't make sense to, and is ignored). */
end_comment

begin_function
specifier|static
name|void
name|do_neon_mov
parameter_list|(
name|void
parameter_list|)
block|{
name|enum
name|neon_shape
name|rs
init|=
name|neon_select_shape
argument_list|(
name|NS_RRFF
argument_list|,
name|NS_FFRR
argument_list|,
name|NS_DRR
argument_list|,
name|NS_RRD
argument_list|,
name|NS_QQ
argument_list|,
name|NS_DD
argument_list|,
name|NS_QI
argument_list|,
name|NS_DI
argument_list|,
name|NS_SR
argument_list|,
name|NS_RS
argument_list|,
name|NS_FF
argument_list|,
name|NS_FI
argument_list|,
name|NS_RF
argument_list|,
name|NS_FR
argument_list|,
name|NS_NULL
argument_list|)
decl_stmt|;
name|struct
name|neon_type_el
name|et
decl_stmt|;
specifier|const
name|char
modifier|*
name|ldconst
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|rs
condition|)
block|{
case|case
name|NS_DD
case|:
comment|/* case 1/9.  */
name|et
operator|=
name|neon_check_type
argument_list|(
literal|2
argument_list|,
name|rs
argument_list|,
name|N_EQK
argument_list|,
name|N_F64
operator||
name|N_KEY
argument_list|)
expr_stmt|;
comment|/* It is not an error here if no type is given.  */
name|inst
operator|.
name|error
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|et
operator|.
name|type
operator|==
name|NT_float
operator|&&
name|et
operator|.
name|size
operator|==
literal|64
condition|)
block|{
name|do_vfp_nsyn_opcode
argument_list|(
literal|"fcpyd"
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* fall through.  */
case|case
name|NS_QQ
case|:
comment|/* case 0/1.  */
block|{
if|if
condition|(
name|vfp_or_neon_is_neon
argument_list|(
name|NEON_CHECK_CC
operator||
name|NEON_CHECK_ARCH
argument_list|)
operator|==
name|FAIL
condition|)
return|return;
comment|/* The architecture manual I have doesn't explicitly state which            value the U bit should have for register->register moves, but            the equivalent VORR instruction has U = 0, so do that.  */
name|inst
operator|.
name|instruction
operator|=
literal|0x0200110
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|LOW4
argument_list|(
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
argument_list|)
operator|<<
literal|12
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|HI1
argument_list|(
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
argument_list|)
operator|<<
literal|22
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|LOW4
argument_list|(
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
argument_list|)
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|HI1
argument_list|(
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
argument_list|)
operator|<<
literal|5
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|LOW4
argument_list|(
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
argument_list|)
operator|<<
literal|16
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|HI1
argument_list|(
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
argument_list|)
operator|<<
literal|7
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|neon_quad
argument_list|(
name|rs
argument_list|)
operator|<<
literal|6
expr_stmt|;
name|inst
operator|.
name|instruction
operator|=
name|neon_dp_fixup
argument_list|(
name|inst
operator|.
name|instruction
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|NS_DI
case|:
comment|/* case 3/11.  */
name|et
operator|=
name|neon_check_type
argument_list|(
literal|2
argument_list|,
name|rs
argument_list|,
name|N_EQK
argument_list|,
name|N_F64
operator||
name|N_KEY
argument_list|)
expr_stmt|;
name|inst
operator|.
name|error
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|et
operator|.
name|type
operator|==
name|NT_float
operator|&&
name|et
operator|.
name|size
operator|==
literal|64
condition|)
block|{
comment|/* case 11 (fconstd).  */
name|ldconst
operator|=
literal|"fconstd"
expr_stmt|;
goto|goto
name|encode_fconstd
goto|;
block|}
comment|/* fall through.  */
case|case
name|NS_QI
case|:
comment|/* case 2/3.  */
if|if
condition|(
name|vfp_or_neon_is_neon
argument_list|(
name|NEON_CHECK_CC
operator||
name|NEON_CHECK_ARCH
argument_list|)
operator|==
name|FAIL
condition|)
return|return;
name|inst
operator|.
name|instruction
operator|=
literal|0x0800010
expr_stmt|;
name|neon_move_immediate
argument_list|()
expr_stmt|;
name|inst
operator|.
name|instruction
operator|=
name|neon_dp_fixup
argument_list|(
name|inst
operator|.
name|instruction
argument_list|)
expr_stmt|;
break|break;
case|case
name|NS_SR
case|:
comment|/* case 4.  */
block|{
name|unsigned
name|bcdebits
init|=
literal|0
decl_stmt|;
name|struct
name|neon_type_el
name|et
init|=
name|neon_check_type
argument_list|(
literal|2
argument_list|,
name|NS_NULL
argument_list|,
name|N_8
operator||
name|N_16
operator||
name|N_32
operator||
name|N_KEY
argument_list|,
name|N_EQK
argument_list|)
decl_stmt|;
name|int
name|logsize
init|=
name|neon_logbits
argument_list|(
name|et
operator|.
name|size
argument_list|)
decl_stmt|;
name|unsigned
name|dn
init|=
name|NEON_SCALAR_REG
argument_list|(
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
argument_list|)
decl_stmt|;
name|unsigned
name|x
init|=
name|NEON_SCALAR_INDEX
argument_list|(
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
argument_list|)
decl_stmt|;
name|constraint
argument_list|(
operator|!
name|ARM_CPU_HAS_FEATURE
argument_list|(
name|cpu_variant
argument_list|,
name|fpu_vfp_ext_v1
argument_list|)
argument_list|,
name|_
argument_list|(
name|BAD_FPU
argument_list|)
argument_list|)
expr_stmt|;
name|constraint
argument_list|(
operator|!
name|ARM_CPU_HAS_FEATURE
argument_list|(
name|cpu_variant
argument_list|,
name|fpu_neon_ext_v1
argument_list|)
operator|&&
name|et
operator|.
name|size
operator|!=
literal|32
argument_list|,
name|_
argument_list|(
name|BAD_FPU
argument_list|)
argument_list|)
expr_stmt|;
name|constraint
argument_list|(
name|et
operator|.
name|type
operator|==
name|NT_invtype
argument_list|,
name|_
argument_list|(
literal|"bad type for scalar"
argument_list|)
argument_list|)
expr_stmt|;
name|constraint
argument_list|(
name|x
operator|>=
literal|64
operator|/
name|et
operator|.
name|size
argument_list|,
name|_
argument_list|(
literal|"scalar index out of range"
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|et
operator|.
name|size
condition|)
block|{
case|case
literal|8
case|:
name|bcdebits
operator|=
literal|0x8
expr_stmt|;
break|break;
case|case
literal|16
case|:
name|bcdebits
operator|=
literal|0x1
expr_stmt|;
break|break;
case|case
literal|32
case|:
name|bcdebits
operator|=
literal|0x0
expr_stmt|;
break|break;
default|default:
empty_stmt|;
block|}
name|bcdebits
operator||=
name|x
operator|<<
name|logsize
expr_stmt|;
name|inst
operator|.
name|instruction
operator|=
literal|0xe000b10
expr_stmt|;
name|do_vfp_cond_or_thumb
argument_list|()
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|LOW4
argument_list|(
name|dn
argument_list|)
operator|<<
literal|16
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|HI1
argument_list|(
name|dn
argument_list|)
operator|<<
literal|7
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
operator|<<
literal|12
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
operator|(
name|bcdebits
operator|&
literal|3
operator|)
operator|<<
literal|5
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
operator|(
name|bcdebits
operator|>>
literal|2
operator|)
operator|<<
literal|21
expr_stmt|;
block|}
break|break;
case|case
name|NS_DRR
case|:
comment|/* case 5 (fmdrr).  */
name|constraint
argument_list|(
operator|!
name|ARM_CPU_HAS_FEATURE
argument_list|(
name|cpu_variant
argument_list|,
name|fpu_vfp_ext_v2
argument_list|)
argument_list|,
name|_
argument_list|(
name|BAD_FPU
argument_list|)
argument_list|)
expr_stmt|;
name|inst
operator|.
name|instruction
operator|=
literal|0xc400b10
expr_stmt|;
name|do_vfp_cond_or_thumb
argument_list|()
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|LOW4
argument_list|(
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
argument_list|)
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|HI1
argument_list|(
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
argument_list|)
operator|<<
literal|5
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
operator|<<
literal|12
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|2
index|]
operator|.
name|reg
operator|<<
literal|16
expr_stmt|;
break|break;
case|case
name|NS_RS
case|:
comment|/* case 6.  */
block|{
name|struct
name|neon_type_el
name|et
init|=
name|neon_check_type
argument_list|(
literal|2
argument_list|,
name|NS_NULL
argument_list|,
name|N_EQK
argument_list|,
name|N_S8
operator||
name|N_S16
operator||
name|N_U8
operator||
name|N_U16
operator||
name|N_32
operator||
name|N_KEY
argument_list|)
decl_stmt|;
name|unsigned
name|logsize
init|=
name|neon_logbits
argument_list|(
name|et
operator|.
name|size
argument_list|)
decl_stmt|;
name|unsigned
name|dn
init|=
name|NEON_SCALAR_REG
argument_list|(
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
argument_list|)
decl_stmt|;
name|unsigned
name|x
init|=
name|NEON_SCALAR_INDEX
argument_list|(
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
argument_list|)
decl_stmt|;
name|unsigned
name|abcdebits
init|=
literal|0
decl_stmt|;
name|constraint
argument_list|(
operator|!
name|ARM_CPU_HAS_FEATURE
argument_list|(
name|cpu_variant
argument_list|,
name|fpu_vfp_ext_v1
argument_list|)
argument_list|,
name|_
argument_list|(
name|BAD_FPU
argument_list|)
argument_list|)
expr_stmt|;
name|constraint
argument_list|(
operator|!
name|ARM_CPU_HAS_FEATURE
argument_list|(
name|cpu_variant
argument_list|,
name|fpu_neon_ext_v1
argument_list|)
operator|&&
name|et
operator|.
name|size
operator|!=
literal|32
argument_list|,
name|_
argument_list|(
name|BAD_FPU
argument_list|)
argument_list|)
expr_stmt|;
name|constraint
argument_list|(
name|et
operator|.
name|type
operator|==
name|NT_invtype
argument_list|,
name|_
argument_list|(
literal|"bad type for scalar"
argument_list|)
argument_list|)
expr_stmt|;
name|constraint
argument_list|(
name|x
operator|>=
literal|64
operator|/
name|et
operator|.
name|size
argument_list|,
name|_
argument_list|(
literal|"scalar index out of range"
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|et
operator|.
name|size
condition|)
block|{
case|case
literal|8
case|:
name|abcdebits
operator|=
operator|(
name|et
operator|.
name|type
operator|==
name|NT_signed
operator|)
condition|?
literal|0x08
else|:
literal|0x18
expr_stmt|;
break|break;
case|case
literal|16
case|:
name|abcdebits
operator|=
operator|(
name|et
operator|.
name|type
operator|==
name|NT_signed
operator|)
condition|?
literal|0x01
else|:
literal|0x11
expr_stmt|;
break|break;
case|case
literal|32
case|:
name|abcdebits
operator|=
literal|0x00
expr_stmt|;
break|break;
default|default:
empty_stmt|;
block|}
name|abcdebits
operator||=
name|x
operator|<<
name|logsize
expr_stmt|;
name|inst
operator|.
name|instruction
operator|=
literal|0xe100b10
expr_stmt|;
name|do_vfp_cond_or_thumb
argument_list|()
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|LOW4
argument_list|(
name|dn
argument_list|)
operator|<<
literal|16
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|HI1
argument_list|(
name|dn
argument_list|)
operator|<<
literal|7
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
operator|<<
literal|12
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
operator|(
name|abcdebits
operator|&
literal|3
operator|)
operator|<<
literal|5
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
operator|(
name|abcdebits
operator|>>
literal|2
operator|)
operator|<<
literal|21
expr_stmt|;
block|}
break|break;
case|case
name|NS_RRD
case|:
comment|/* case 7 (fmrrd).  */
name|constraint
argument_list|(
operator|!
name|ARM_CPU_HAS_FEATURE
argument_list|(
name|cpu_variant
argument_list|,
name|fpu_vfp_ext_v2
argument_list|)
argument_list|,
name|_
argument_list|(
name|BAD_FPU
argument_list|)
argument_list|)
expr_stmt|;
name|inst
operator|.
name|instruction
operator|=
literal|0xc500b10
expr_stmt|;
name|do_vfp_cond_or_thumb
argument_list|()
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
operator|<<
literal|12
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
operator|<<
literal|16
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|LOW4
argument_list|(
name|inst
operator|.
name|operands
index|[
literal|2
index|]
operator|.
name|reg
argument_list|)
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|HI1
argument_list|(
name|inst
operator|.
name|operands
index|[
literal|2
index|]
operator|.
name|reg
argument_list|)
operator|<<
literal|5
expr_stmt|;
break|break;
case|case
name|NS_FF
case|:
comment|/* case 8 (fcpys).  */
name|do_vfp_nsyn_opcode
argument_list|(
literal|"fcpys"
argument_list|)
expr_stmt|;
break|break;
case|case
name|NS_FI
case|:
comment|/* case 10 (fconsts).  */
name|ldconst
operator|=
literal|"fconsts"
expr_stmt|;
name|encode_fconstd
label|:
if|if
condition|(
name|is_quarter_float
argument_list|(
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|imm
argument_list|)
condition|)
block|{
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|imm
operator|=
name|neon_qfloat_bits
argument_list|(
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|imm
argument_list|)
expr_stmt|;
name|do_vfp_nsyn_opcode
argument_list|(
name|ldconst
argument_list|)
expr_stmt|;
block|}
else|else
name|first_error
argument_list|(
name|_
argument_list|(
literal|"immediate out of range"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|NS_RF
case|:
comment|/* case 12 (fmrs).  */
name|do_vfp_nsyn_opcode
argument_list|(
literal|"fmrs"
argument_list|)
expr_stmt|;
break|break;
case|case
name|NS_FR
case|:
comment|/* case 13 (fmsr).  */
name|do_vfp_nsyn_opcode
argument_list|(
literal|"fmsr"
argument_list|)
expr_stmt|;
break|break;
comment|/* The encoders for the fmrrs and fmsrr instructions expect three operands        (one of which is a list), but we have parsed four.  Do some fiddling to        make the operands what do_vfp_reg2_from_sp2 and do_vfp_sp2_from_reg2        expect.  */
case|case
name|NS_RRFF
case|:
comment|/* case 14 (fmrrs).  */
name|constraint
argument_list|(
name|inst
operator|.
name|operands
index|[
literal|3
index|]
operator|.
name|reg
operator|!=
name|inst
operator|.
name|operands
index|[
literal|2
index|]
operator|.
name|reg
operator|+
literal|1
argument_list|,
name|_
argument_list|(
literal|"VFP registers must be adjacent"
argument_list|)
argument_list|)
expr_stmt|;
name|inst
operator|.
name|operands
index|[
literal|2
index|]
operator|.
name|imm
operator|=
literal|2
expr_stmt|;
name|memset
argument_list|(
operator|&
name|inst
operator|.
name|operands
index|[
literal|3
index|]
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
name|inst
operator|.
name|operands
index|[
literal|3
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|do_vfp_nsyn_opcode
argument_list|(
literal|"fmrrs"
argument_list|)
expr_stmt|;
break|break;
case|case
name|NS_FFRR
case|:
comment|/* case 15 (fmsrr).  */
name|constraint
argument_list|(
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
operator|!=
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
operator|+
literal|1
argument_list|,
name|_
argument_list|(
literal|"VFP registers must be adjacent"
argument_list|)
argument_list|)
expr_stmt|;
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|=
name|inst
operator|.
name|operands
index|[
literal|2
index|]
expr_stmt|;
name|inst
operator|.
name|operands
index|[
literal|2
index|]
operator|=
name|inst
operator|.
name|operands
index|[
literal|3
index|]
expr_stmt|;
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|imm
operator|=
literal|2
expr_stmt|;
name|memset
argument_list|(
operator|&
name|inst
operator|.
name|operands
index|[
literal|3
index|]
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
name|inst
operator|.
name|operands
index|[
literal|3
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|do_vfp_nsyn_opcode
argument_list|(
literal|"fmsrr"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|do_neon_rshift_round_imm
parameter_list|(
name|void
parameter_list|)
block|{
name|enum
name|neon_shape
name|rs
init|=
name|neon_select_shape
argument_list|(
name|NS_DDI
argument_list|,
name|NS_QQI
argument_list|,
name|NS_NULL
argument_list|)
decl_stmt|;
name|struct
name|neon_type_el
name|et
init|=
name|neon_check_type
argument_list|(
literal|2
argument_list|,
name|rs
argument_list|,
name|N_EQK
argument_list|,
name|N_SU_ALL
operator||
name|N_KEY
argument_list|)
decl_stmt|;
name|int
name|imm
init|=
name|inst
operator|.
name|operands
index|[
literal|2
index|]
operator|.
name|imm
decl_stmt|;
comment|/* imm == 0 case is encoded as VMOV for V{R}SHR.  */
if|if
condition|(
name|imm
operator|==
literal|0
condition|)
block|{
name|inst
operator|.
name|operands
index|[
literal|2
index|]
operator|.
name|present
operator|=
literal|0
expr_stmt|;
name|do_neon_mov
argument_list|()
expr_stmt|;
return|return;
block|}
name|constraint
argument_list|(
name|imm
operator|<
literal|1
operator|||
operator|(
name|unsigned
operator|)
name|imm
operator|>
name|et
operator|.
name|size
argument_list|,
name|_
argument_list|(
literal|"immediate out of range for shift"
argument_list|)
argument_list|)
expr_stmt|;
name|neon_imm_shift
argument_list|(
name|TRUE
argument_list|,
name|et
operator|.
name|type
operator|==
name|NT_unsigned
argument_list|,
name|neon_quad
argument_list|(
name|rs
argument_list|)
argument_list|,
name|et
argument_list|,
name|et
operator|.
name|size
operator|-
name|imm
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_neon_movl
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|neon_type_el
name|et
init|=
name|neon_check_type
argument_list|(
literal|2
argument_list|,
name|NS_QD
argument_list|,
name|N_EQK
operator||
name|N_DBL
argument_list|,
name|N_SU_32
operator||
name|N_KEY
argument_list|)
decl_stmt|;
name|unsigned
name|sizebits
init|=
name|et
operator|.
name|size
operator|>>
literal|3
decl_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|sizebits
operator|<<
literal|19
expr_stmt|;
name|neon_two_same
argument_list|(
literal|0
argument_list|,
name|et
operator|.
name|type
operator|==
name|NT_unsigned
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_neon_trn
parameter_list|(
name|void
parameter_list|)
block|{
name|enum
name|neon_shape
name|rs
init|=
name|neon_select_shape
argument_list|(
name|NS_DD
argument_list|,
name|NS_QQ
argument_list|,
name|NS_NULL
argument_list|)
decl_stmt|;
name|struct
name|neon_type_el
name|et
init|=
name|neon_check_type
argument_list|(
literal|2
argument_list|,
name|rs
argument_list|,
name|N_EQK
argument_list|,
name|N_8
operator||
name|N_16
operator||
name|N_32
operator||
name|N_KEY
argument_list|)
decl_stmt|;
name|inst
operator|.
name|instruction
operator|=
name|NEON_ENC_INTEGER
argument_list|(
name|inst
operator|.
name|instruction
argument_list|)
expr_stmt|;
name|neon_two_same
argument_list|(
name|neon_quad
argument_list|(
name|rs
argument_list|)
argument_list|,
literal|1
argument_list|,
name|et
operator|.
name|size
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_neon_zip_uzp
parameter_list|(
name|void
parameter_list|)
block|{
name|enum
name|neon_shape
name|rs
init|=
name|neon_select_shape
argument_list|(
name|NS_DD
argument_list|,
name|NS_QQ
argument_list|,
name|NS_NULL
argument_list|)
decl_stmt|;
name|struct
name|neon_type_el
name|et
init|=
name|neon_check_type
argument_list|(
literal|2
argument_list|,
name|rs
argument_list|,
name|N_EQK
argument_list|,
name|N_8
operator||
name|N_16
operator||
name|N_32
operator||
name|N_KEY
argument_list|)
decl_stmt|;
if|if
condition|(
name|rs
operator|==
name|NS_DD
operator|&&
name|et
operator|.
name|size
operator|==
literal|32
condition|)
block|{
comment|/* Special case: encode as VTRN.32<Dd>,<Dm>.  */
name|inst
operator|.
name|instruction
operator|=
name|N_MNEM_vtrn
expr_stmt|;
name|do_neon_trn
argument_list|()
expr_stmt|;
return|return;
block|}
name|neon_two_same
argument_list|(
name|neon_quad
argument_list|(
name|rs
argument_list|)
argument_list|,
literal|1
argument_list|,
name|et
operator|.
name|size
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_neon_sat_abs_neg
parameter_list|(
name|void
parameter_list|)
block|{
name|enum
name|neon_shape
name|rs
init|=
name|neon_select_shape
argument_list|(
name|NS_DD
argument_list|,
name|NS_QQ
argument_list|,
name|NS_NULL
argument_list|)
decl_stmt|;
name|struct
name|neon_type_el
name|et
init|=
name|neon_check_type
argument_list|(
literal|2
argument_list|,
name|rs
argument_list|,
name|N_EQK
argument_list|,
name|N_S8
operator||
name|N_S16
operator||
name|N_S32
operator||
name|N_KEY
argument_list|)
decl_stmt|;
name|neon_two_same
argument_list|(
name|neon_quad
argument_list|(
name|rs
argument_list|)
argument_list|,
literal|1
argument_list|,
name|et
operator|.
name|size
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_neon_pair_long
parameter_list|(
name|void
parameter_list|)
block|{
name|enum
name|neon_shape
name|rs
init|=
name|neon_select_shape
argument_list|(
name|NS_DD
argument_list|,
name|NS_QQ
argument_list|,
name|NS_NULL
argument_list|)
decl_stmt|;
name|struct
name|neon_type_el
name|et
init|=
name|neon_check_type
argument_list|(
literal|2
argument_list|,
name|rs
argument_list|,
name|N_EQK
argument_list|,
name|N_SU_32
operator||
name|N_KEY
argument_list|)
decl_stmt|;
comment|/* Unsigned is encoded in OP field (bit 7) for these instruction.  */
name|inst
operator|.
name|instruction
operator||=
operator|(
name|et
operator|.
name|type
operator|==
name|NT_unsigned
operator|)
operator|<<
literal|7
expr_stmt|;
name|neon_two_same
argument_list|(
name|neon_quad
argument_list|(
name|rs
argument_list|)
argument_list|,
literal|1
argument_list|,
name|et
operator|.
name|size
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_neon_recip_est
parameter_list|(
name|void
parameter_list|)
block|{
name|enum
name|neon_shape
name|rs
init|=
name|neon_select_shape
argument_list|(
name|NS_DD
argument_list|,
name|NS_QQ
argument_list|,
name|NS_NULL
argument_list|)
decl_stmt|;
name|struct
name|neon_type_el
name|et
init|=
name|neon_check_type
argument_list|(
literal|2
argument_list|,
name|rs
argument_list|,
name|N_EQK
operator||
name|N_FLT
argument_list|,
name|N_F32
operator||
name|N_U32
operator||
name|N_KEY
argument_list|)
decl_stmt|;
name|inst
operator|.
name|instruction
operator||=
operator|(
name|et
operator|.
name|type
operator|==
name|NT_float
operator|)
operator|<<
literal|8
expr_stmt|;
name|neon_two_same
argument_list|(
name|neon_quad
argument_list|(
name|rs
argument_list|)
argument_list|,
literal|1
argument_list|,
name|et
operator|.
name|size
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_neon_cls
parameter_list|(
name|void
parameter_list|)
block|{
name|enum
name|neon_shape
name|rs
init|=
name|neon_select_shape
argument_list|(
name|NS_DD
argument_list|,
name|NS_QQ
argument_list|,
name|NS_NULL
argument_list|)
decl_stmt|;
name|struct
name|neon_type_el
name|et
init|=
name|neon_check_type
argument_list|(
literal|2
argument_list|,
name|rs
argument_list|,
name|N_EQK
argument_list|,
name|N_S8
operator||
name|N_S16
operator||
name|N_S32
operator||
name|N_KEY
argument_list|)
decl_stmt|;
name|neon_two_same
argument_list|(
name|neon_quad
argument_list|(
name|rs
argument_list|)
argument_list|,
literal|1
argument_list|,
name|et
operator|.
name|size
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_neon_clz
parameter_list|(
name|void
parameter_list|)
block|{
name|enum
name|neon_shape
name|rs
init|=
name|neon_select_shape
argument_list|(
name|NS_DD
argument_list|,
name|NS_QQ
argument_list|,
name|NS_NULL
argument_list|)
decl_stmt|;
name|struct
name|neon_type_el
name|et
init|=
name|neon_check_type
argument_list|(
literal|2
argument_list|,
name|rs
argument_list|,
name|N_EQK
argument_list|,
name|N_I8
operator||
name|N_I16
operator||
name|N_I32
operator||
name|N_KEY
argument_list|)
decl_stmt|;
name|neon_two_same
argument_list|(
name|neon_quad
argument_list|(
name|rs
argument_list|)
argument_list|,
literal|1
argument_list|,
name|et
operator|.
name|size
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_neon_cnt
parameter_list|(
name|void
parameter_list|)
block|{
name|enum
name|neon_shape
name|rs
init|=
name|neon_select_shape
argument_list|(
name|NS_DD
argument_list|,
name|NS_QQ
argument_list|,
name|NS_NULL
argument_list|)
decl_stmt|;
name|struct
name|neon_type_el
name|et
init|=
name|neon_check_type
argument_list|(
literal|2
argument_list|,
name|rs
argument_list|,
name|N_EQK
operator||
name|N_INT
argument_list|,
name|N_8
operator||
name|N_KEY
argument_list|)
decl_stmt|;
name|neon_two_same
argument_list|(
name|neon_quad
argument_list|(
name|rs
argument_list|)
argument_list|,
literal|1
argument_list|,
name|et
operator|.
name|size
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_neon_swp
parameter_list|(
name|void
parameter_list|)
block|{
name|enum
name|neon_shape
name|rs
init|=
name|neon_select_shape
argument_list|(
name|NS_DD
argument_list|,
name|NS_QQ
argument_list|,
name|NS_NULL
argument_list|)
decl_stmt|;
name|neon_two_same
argument_list|(
name|neon_quad
argument_list|(
name|rs
argument_list|)
argument_list|,
literal|1
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_neon_tbl_tbx
parameter_list|(
name|void
parameter_list|)
block|{
name|unsigned
name|listlenbits
decl_stmt|;
name|neon_check_type
argument_list|(
literal|3
argument_list|,
name|NS_DLD
argument_list|,
name|N_EQK
argument_list|,
name|N_EQK
argument_list|,
name|N_8
operator||
name|N_KEY
argument_list|)
expr_stmt|;
if|if
condition|(
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|imm
operator|<
literal|1
operator|||
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|imm
operator|>
literal|4
condition|)
block|{
name|first_error
argument_list|(
name|_
argument_list|(
literal|"bad list length for table lookup"
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|listlenbits
operator|=
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|imm
operator|-
literal|1
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|LOW4
argument_list|(
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
argument_list|)
operator|<<
literal|12
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|HI1
argument_list|(
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
argument_list|)
operator|<<
literal|22
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|LOW4
argument_list|(
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
argument_list|)
operator|<<
literal|16
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|HI1
argument_list|(
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
argument_list|)
operator|<<
literal|7
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|LOW4
argument_list|(
name|inst
operator|.
name|operands
index|[
literal|2
index|]
operator|.
name|reg
argument_list|)
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|HI1
argument_list|(
name|inst
operator|.
name|operands
index|[
literal|2
index|]
operator|.
name|reg
argument_list|)
operator|<<
literal|5
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|listlenbits
operator|<<
literal|8
expr_stmt|;
name|inst
operator|.
name|instruction
operator|=
name|neon_dp_fixup
argument_list|(
name|inst
operator|.
name|instruction
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_neon_ldm_stm
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* P, U and L bits are part of bitmask.  */
name|int
name|is_dbmode
init|=
operator|(
name|inst
operator|.
name|instruction
operator|&
operator|(
literal|1
operator|<<
literal|24
operator|)
operator|)
operator|!=
literal|0
decl_stmt|;
name|unsigned
name|offsetbits
init|=
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|imm
operator|*
literal|2
decl_stmt|;
if|if
condition|(
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|issingle
condition|)
block|{
name|do_vfp_nsyn_ldm_stm
argument_list|(
name|is_dbmode
argument_list|)
expr_stmt|;
return|return;
block|}
name|constraint
argument_list|(
name|is_dbmode
operator|&&
operator|!
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|writeback
argument_list|,
name|_
argument_list|(
literal|"writeback (!) must be used for VLDMDB and VSTMDB"
argument_list|)
argument_list|)
expr_stmt|;
name|constraint
argument_list|(
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|imm
operator|<
literal|1
operator|||
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|imm
operator|>
literal|16
argument_list|,
name|_
argument_list|(
literal|"register list must contain at least 1 and at most 16 "
literal|"registers"
argument_list|)
argument_list|)
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
operator|<<
literal|16
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|writeback
operator|<<
literal|21
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|LOW4
argument_list|(
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
argument_list|)
operator|<<
literal|12
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|HI1
argument_list|(
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
argument_list|)
operator|<<
literal|22
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|offsetbits
expr_stmt|;
name|do_vfp_cond_or_thumb
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_neon_ldr_str
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|is_ldr
init|=
operator|(
name|inst
operator|.
name|instruction
operator|&
operator|(
literal|1
operator|<<
literal|20
operator|)
operator|)
operator|!=
literal|0
decl_stmt|;
if|if
condition|(
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|issingle
condition|)
block|{
if|if
condition|(
name|is_ldr
condition|)
name|do_vfp_nsyn_opcode
argument_list|(
literal|"flds"
argument_list|)
expr_stmt|;
else|else
name|do_vfp_nsyn_opcode
argument_list|(
literal|"fsts"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|is_ldr
condition|)
name|do_vfp_nsyn_opcode
argument_list|(
literal|"fldd"
argument_list|)
expr_stmt|;
else|else
name|do_vfp_nsyn_opcode
argument_list|(
literal|"fstd"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* "interleave" version also handles non-interleaving register VLD1/VST1    instructions.  */
end_comment

begin_function
specifier|static
name|void
name|do_neon_ld_st_interleave
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|neon_type_el
name|et
init|=
name|neon_check_type
argument_list|(
literal|1
argument_list|,
name|NS_NULL
argument_list|,
name|N_8
operator||
name|N_16
operator||
name|N_32
operator||
name|N_64
argument_list|)
decl_stmt|;
name|unsigned
name|alignbits
init|=
literal|0
decl_stmt|;
name|unsigned
name|idx
decl_stmt|;
comment|/* The bits in this table go:      0: register stride of one (0) or two (1)      1,2: register list length, minus one (1, 2, 3, 4).      3,4:<n> in instruction type, minus one (VLD<n> / VST<n>).      We use -1 for invalid entries.  */
specifier|const
name|int
name|typetable
index|[]
init|=
block|{
literal|0x7
block|,
operator|-
literal|1
block|,
literal|0xa
block|,
operator|-
literal|1
block|,
literal|0x6
block|,
operator|-
literal|1
block|,
literal|0x2
block|,
operator|-
literal|1
block|,
comment|/* VLD1 / VST1.  */
operator|-
literal|1
block|,
operator|-
literal|1
block|,
literal|0x8
block|,
literal|0x9
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
literal|0x3
block|,
operator|-
literal|1
block|,
comment|/* VLD2 / VST2.  */
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
literal|0x4
block|,
literal|0x5
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
comment|/* VLD3 / VST3.  */
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
literal|0x0
block|,
literal|0x1
comment|/* VLD4 / VST4.  */
block|}
decl_stmt|;
name|int
name|typebits
decl_stmt|;
if|if
condition|(
name|et
operator|.
name|type
operator|==
name|NT_invtype
condition|)
return|return;
if|if
condition|(
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|immisalign
condition|)
switch|switch
condition|(
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|imm
operator|>>
literal|8
condition|)
block|{
case|case
literal|64
case|:
name|alignbits
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|128
case|:
if|if
condition|(
name|NEON_REGLIST_LENGTH
argument_list|(
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|imm
argument_list|)
operator|==
literal|3
condition|)
goto|goto
name|bad_alignment
goto|;
name|alignbits
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|256
case|:
if|if
condition|(
name|NEON_REGLIST_LENGTH
argument_list|(
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|imm
argument_list|)
operator|==
literal|3
condition|)
goto|goto
name|bad_alignment
goto|;
name|alignbits
operator|=
literal|3
expr_stmt|;
break|break;
default|default:
name|bad_alignment
label|:
name|first_error
argument_list|(
name|_
argument_list|(
literal|"bad alignment"
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|inst
operator|.
name|instruction
operator||=
name|alignbits
operator|<<
literal|4
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|neon_logbits
argument_list|(
name|et
operator|.
name|size
argument_list|)
operator|<<
literal|6
expr_stmt|;
comment|/* Bits [4:6] of the immediate in a list specifier encode register stride      (minus 1) in bit 4, and list length in bits [5:6]. We put the<n> of      VLD<n>/VST<n> in bits [9:8] of the initial bitmask. Suck it out here, look      up the right value for "type" in a table based on this value and the given      list style, then stick it back.  */
name|idx
operator|=
operator|(
operator|(
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|imm
operator|>>
literal|4
operator|)
operator|&
literal|7
operator|)
operator||
operator|(
operator|(
operator|(
name|inst
operator|.
name|instruction
operator|>>
literal|8
operator|)
operator|&
literal|3
operator|)
operator|<<
literal|3
operator|)
expr_stmt|;
name|typebits
operator|=
name|typetable
index|[
name|idx
index|]
expr_stmt|;
name|constraint
argument_list|(
name|typebits
operator|==
operator|-
literal|1
argument_list|,
name|_
argument_list|(
literal|"bad list type for instruction"
argument_list|)
argument_list|)
expr_stmt|;
name|inst
operator|.
name|instruction
operator|&=
operator|~
literal|0xf00
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|typebits
operator|<<
literal|8
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Check alignment is valid for do_neon_ld_st_lane and do_neon_ld_dup.    *DO_ALIGN is set to 1 if the relevant alignment bit should be set, 0    otherwise. The variable arguments are a list of pairs of legal (size, align)    values, terminated with -1.  */
end_comment

begin_function
specifier|static
name|int
name|neon_alignment_bit
parameter_list|(
name|int
name|size
parameter_list|,
name|int
name|align
parameter_list|,
name|int
modifier|*
name|do_align
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
name|int
name|result
init|=
name|FAIL
decl_stmt|,
name|thissize
decl_stmt|,
name|thisalign
decl_stmt|;
if|if
condition|(
operator|!
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|immisalign
condition|)
block|{
operator|*
name|do_align
operator|=
literal|0
expr_stmt|;
return|return
name|SUCCESS
return|;
block|}
name|va_start
argument_list|(
name|ap
argument_list|,
name|do_align
argument_list|)
expr_stmt|;
do|do
block|{
name|thissize
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
argument_list|)
expr_stmt|;
if|if
condition|(
name|thissize
operator|==
operator|-
literal|1
condition|)
break|break;
name|thisalign
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|==
name|thissize
operator|&&
name|align
operator|==
name|thisalign
condition|)
name|result
operator|=
name|SUCCESS
expr_stmt|;
block|}
do|while
condition|(
name|result
operator|!=
name|SUCCESS
condition|)
do|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|SUCCESS
condition|)
operator|*
name|do_align
operator|=
literal|1
expr_stmt|;
else|else
name|first_error
argument_list|(
name|_
argument_list|(
literal|"unsupported alignment for instruction"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_neon_ld_st_lane
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|neon_type_el
name|et
init|=
name|neon_check_type
argument_list|(
literal|1
argument_list|,
name|NS_NULL
argument_list|,
name|N_8
operator||
name|N_16
operator||
name|N_32
argument_list|)
decl_stmt|;
name|int
name|align_good
decl_stmt|,
name|do_align
init|=
literal|0
decl_stmt|;
name|int
name|logsize
init|=
name|neon_logbits
argument_list|(
name|et
operator|.
name|size
argument_list|)
decl_stmt|;
name|int
name|align
init|=
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|imm
operator|>>
literal|8
decl_stmt|;
name|int
name|n
init|=
operator|(
name|inst
operator|.
name|instruction
operator|>>
literal|8
operator|)
operator|&
literal|3
decl_stmt|;
name|int
name|max_el
init|=
literal|64
operator|/
name|et
operator|.
name|size
decl_stmt|;
if|if
condition|(
name|et
operator|.
name|type
operator|==
name|NT_invtype
condition|)
return|return;
name|constraint
argument_list|(
name|NEON_REGLIST_LENGTH
argument_list|(
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|imm
argument_list|)
operator|!=
name|n
operator|+
literal|1
argument_list|,
name|_
argument_list|(
literal|"bad list length"
argument_list|)
argument_list|)
expr_stmt|;
name|constraint
argument_list|(
name|NEON_LANE
argument_list|(
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|imm
argument_list|)
operator|>=
name|max_el
argument_list|,
name|_
argument_list|(
literal|"scalar index out of range"
argument_list|)
argument_list|)
expr_stmt|;
name|constraint
argument_list|(
name|n
operator|!=
literal|0
operator|&&
name|NEON_REG_STRIDE
argument_list|(
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|imm
argument_list|)
operator|==
literal|2
operator|&&
name|et
operator|.
name|size
operator|==
literal|8
argument_list|,
name|_
argument_list|(
literal|"stride of 2 unavailable when element size is 8"
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|n
condition|)
block|{
case|case
literal|0
case|:
comment|/* VLD1 / VST1.  */
name|align_good
operator|=
name|neon_alignment_bit
argument_list|(
name|et
operator|.
name|size
argument_list|,
name|align
argument_list|,
operator|&
name|do_align
argument_list|,
literal|16
argument_list|,
literal|16
argument_list|,
literal|32
argument_list|,
literal|32
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|align_good
operator|==
name|FAIL
condition|)
return|return;
if|if
condition|(
name|do_align
condition|)
block|{
name|unsigned
name|alignbits
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|et
operator|.
name|size
condition|)
block|{
case|case
literal|16
case|:
name|alignbits
operator|=
literal|0x1
expr_stmt|;
break|break;
case|case
literal|32
case|:
name|alignbits
operator|=
literal|0x3
expr_stmt|;
break|break;
default|default:
empty_stmt|;
block|}
name|inst
operator|.
name|instruction
operator||=
name|alignbits
operator|<<
literal|4
expr_stmt|;
block|}
break|break;
case|case
literal|1
case|:
comment|/* VLD2 / VST2.  */
name|align_good
operator|=
name|neon_alignment_bit
argument_list|(
name|et
operator|.
name|size
argument_list|,
name|align
argument_list|,
operator|&
name|do_align
argument_list|,
literal|8
argument_list|,
literal|16
argument_list|,
literal|16
argument_list|,
literal|32
argument_list|,
literal|32
argument_list|,
literal|64
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|align_good
operator|==
name|FAIL
condition|)
return|return;
if|if
condition|(
name|do_align
condition|)
name|inst
operator|.
name|instruction
operator||=
literal|1
operator|<<
literal|4
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|/* VLD3 / VST3.  */
name|constraint
argument_list|(
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|immisalign
argument_list|,
name|_
argument_list|(
literal|"can't use alignment with this instruction"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
comment|/* VLD4 / VST4.  */
name|align_good
operator|=
name|neon_alignment_bit
argument_list|(
name|et
operator|.
name|size
argument_list|,
name|align
argument_list|,
operator|&
name|do_align
argument_list|,
literal|8
argument_list|,
literal|32
argument_list|,
literal|16
argument_list|,
literal|64
argument_list|,
literal|32
argument_list|,
literal|64
argument_list|,
literal|32
argument_list|,
literal|128
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|align_good
operator|==
name|FAIL
condition|)
return|return;
if|if
condition|(
name|do_align
condition|)
block|{
name|unsigned
name|alignbits
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|et
operator|.
name|size
condition|)
block|{
case|case
literal|8
case|:
name|alignbits
operator|=
literal|0x1
expr_stmt|;
break|break;
case|case
literal|16
case|:
name|alignbits
operator|=
literal|0x1
expr_stmt|;
break|break;
case|case
literal|32
case|:
name|alignbits
operator|=
operator|(
name|align
operator|==
literal|64
operator|)
condition|?
literal|0x1
else|:
literal|0x2
expr_stmt|;
break|break;
default|default:
empty_stmt|;
block|}
name|inst
operator|.
name|instruction
operator||=
name|alignbits
operator|<<
literal|4
expr_stmt|;
block|}
break|break;
default|default:
empty_stmt|;
block|}
comment|/* Reg stride of 2 is encoded in bit 5 when size==16, bit 6 when size==32.  */
if|if
condition|(
name|n
operator|!=
literal|0
operator|&&
name|NEON_REG_STRIDE
argument_list|(
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|imm
argument_list|)
operator|==
literal|2
condition|)
name|inst
operator|.
name|instruction
operator||=
literal|1
operator|<<
operator|(
literal|4
operator|+
name|logsize
operator|)
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|NEON_LANE
argument_list|(
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|imm
argument_list|)
operator|<<
operator|(
name|logsize
operator|+
literal|5
operator|)
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|logsize
operator|<<
literal|10
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Encode single n-element structure to all lanes VLD<n> instructions.  */
end_comment

begin_function
specifier|static
name|void
name|do_neon_ld_dup
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|neon_type_el
name|et
init|=
name|neon_check_type
argument_list|(
literal|1
argument_list|,
name|NS_NULL
argument_list|,
name|N_8
operator||
name|N_16
operator||
name|N_32
argument_list|)
decl_stmt|;
name|int
name|align_good
decl_stmt|,
name|do_align
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|et
operator|.
name|type
operator|==
name|NT_invtype
condition|)
return|return;
switch|switch
condition|(
operator|(
name|inst
operator|.
name|instruction
operator|>>
literal|8
operator|)
operator|&
literal|3
condition|)
block|{
case|case
literal|0
case|:
comment|/* VLD1.  */
name|assert
argument_list|(
name|NEON_REG_STRIDE
argument_list|(
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|imm
argument_list|)
operator|!=
literal|2
argument_list|)
expr_stmt|;
name|align_good
operator|=
name|neon_alignment_bit
argument_list|(
name|et
operator|.
name|size
argument_list|,
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|imm
operator|>>
literal|8
argument_list|,
operator|&
name|do_align
argument_list|,
literal|16
argument_list|,
literal|16
argument_list|,
literal|32
argument_list|,
literal|32
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|align_good
operator|==
name|FAIL
condition|)
return|return;
switch|switch
condition|(
name|NEON_REGLIST_LENGTH
argument_list|(
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|imm
argument_list|)
condition|)
block|{
case|case
literal|1
case|:
break|break;
case|case
literal|2
case|:
name|inst
operator|.
name|instruction
operator||=
literal|1
operator|<<
literal|5
expr_stmt|;
break|break;
default|default:
name|first_error
argument_list|(
name|_
argument_list|(
literal|"bad list length"
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|inst
operator|.
name|instruction
operator||=
name|neon_logbits
argument_list|(
name|et
operator|.
name|size
argument_list|)
operator|<<
literal|6
expr_stmt|;
break|break;
case|case
literal|1
case|:
comment|/* VLD2.  */
name|align_good
operator|=
name|neon_alignment_bit
argument_list|(
name|et
operator|.
name|size
argument_list|,
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|imm
operator|>>
literal|8
argument_list|,
operator|&
name|do_align
argument_list|,
literal|8
argument_list|,
literal|16
argument_list|,
literal|16
argument_list|,
literal|32
argument_list|,
literal|32
argument_list|,
literal|64
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|align_good
operator|==
name|FAIL
condition|)
return|return;
name|constraint
argument_list|(
name|NEON_REGLIST_LENGTH
argument_list|(
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|imm
argument_list|)
operator|!=
literal|2
argument_list|,
name|_
argument_list|(
literal|"bad list length"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|NEON_REG_STRIDE
argument_list|(
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|imm
argument_list|)
operator|==
literal|2
condition|)
name|inst
operator|.
name|instruction
operator||=
literal|1
operator|<<
literal|5
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|neon_logbits
argument_list|(
name|et
operator|.
name|size
argument_list|)
operator|<<
literal|6
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|/* VLD3.  */
name|constraint
argument_list|(
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|immisalign
argument_list|,
name|_
argument_list|(
literal|"can't use alignment with this instruction"
argument_list|)
argument_list|)
expr_stmt|;
name|constraint
argument_list|(
name|NEON_REGLIST_LENGTH
argument_list|(
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|imm
argument_list|)
operator|!=
literal|3
argument_list|,
name|_
argument_list|(
literal|"bad list length"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|NEON_REG_STRIDE
argument_list|(
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|imm
argument_list|)
operator|==
literal|2
condition|)
name|inst
operator|.
name|instruction
operator||=
literal|1
operator|<<
literal|5
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|neon_logbits
argument_list|(
name|et
operator|.
name|size
argument_list|)
operator|<<
literal|6
expr_stmt|;
break|break;
case|case
literal|3
case|:
comment|/* VLD4.  */
block|{
name|int
name|align
init|=
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|imm
operator|>>
literal|8
decl_stmt|;
name|align_good
operator|=
name|neon_alignment_bit
argument_list|(
name|et
operator|.
name|size
argument_list|,
name|align
argument_list|,
operator|&
name|do_align
argument_list|,
literal|8
argument_list|,
literal|32
argument_list|,
literal|16
argument_list|,
literal|64
argument_list|,
literal|32
argument_list|,
literal|64
argument_list|,
literal|32
argument_list|,
literal|128
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|align_good
operator|==
name|FAIL
condition|)
return|return;
name|constraint
argument_list|(
name|NEON_REGLIST_LENGTH
argument_list|(
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|imm
argument_list|)
operator|!=
literal|4
argument_list|,
name|_
argument_list|(
literal|"bad list length"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|NEON_REG_STRIDE
argument_list|(
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|imm
argument_list|)
operator|==
literal|2
condition|)
name|inst
operator|.
name|instruction
operator||=
literal|1
operator|<<
literal|5
expr_stmt|;
if|if
condition|(
name|et
operator|.
name|size
operator|==
literal|32
operator|&&
name|align
operator|==
literal|128
condition|)
name|inst
operator|.
name|instruction
operator||=
literal|0x3
operator|<<
literal|6
expr_stmt|;
else|else
name|inst
operator|.
name|instruction
operator||=
name|neon_logbits
argument_list|(
name|et
operator|.
name|size
argument_list|)
operator|<<
literal|6
expr_stmt|;
block|}
break|break;
default|default:
empty_stmt|;
block|}
name|inst
operator|.
name|instruction
operator||=
name|do_align
operator|<<
literal|4
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Disambiguate VLD<n> and VST<n> instructions, and fill in common bits (those    apart from bits [11:4].  */
end_comment

begin_function
specifier|static
name|void
name|do_neon_ldx_stx
parameter_list|(
name|void
parameter_list|)
block|{
switch|switch
condition|(
name|NEON_LANE
argument_list|(
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|imm
argument_list|)
condition|)
block|{
case|case
name|NEON_INTERLEAVE_LANES
case|:
name|inst
operator|.
name|instruction
operator|=
name|NEON_ENC_INTERLV
argument_list|(
name|inst
operator|.
name|instruction
argument_list|)
expr_stmt|;
name|do_neon_ld_st_interleave
argument_list|()
expr_stmt|;
break|break;
case|case
name|NEON_ALL_LANES
case|:
name|inst
operator|.
name|instruction
operator|=
name|NEON_ENC_DUP
argument_list|(
name|inst
operator|.
name|instruction
argument_list|)
expr_stmt|;
name|do_neon_ld_dup
argument_list|()
expr_stmt|;
break|break;
default|default:
name|inst
operator|.
name|instruction
operator|=
name|NEON_ENC_LANE
argument_list|(
name|inst
operator|.
name|instruction
argument_list|)
expr_stmt|;
name|do_neon_ld_st_lane
argument_list|()
expr_stmt|;
block|}
comment|/* L bit comes from bit mask.  */
name|inst
operator|.
name|instruction
operator||=
name|LOW4
argument_list|(
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
argument_list|)
operator|<<
literal|12
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|HI1
argument_list|(
name|inst
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
argument_list|)
operator|<<
literal|22
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|reg
operator|<<
literal|16
expr_stmt|;
if|if
condition|(
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|postind
condition|)
block|{
name|int
name|postreg
init|=
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|imm
operator|&
literal|0xf
decl_stmt|;
name|constraint
argument_list|(
operator|!
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|immisreg
argument_list|,
name|_
argument_list|(
literal|"post-index must be a register"
argument_list|)
argument_list|)
expr_stmt|;
name|constraint
argument_list|(
name|postreg
operator|==
literal|0xd
operator|||
name|postreg
operator|==
literal|0xf
argument_list|,
name|_
argument_list|(
literal|"bad register for post-index"
argument_list|)
argument_list|)
expr_stmt|;
name|inst
operator|.
name|instruction
operator||=
name|postreg
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|inst
operator|.
name|operands
index|[
literal|1
index|]
operator|.
name|writeback
condition|)
block|{
name|inst
operator|.
name|instruction
operator||=
literal|0xd
expr_stmt|;
block|}
else|else
name|inst
operator|.
name|instruction
operator||=
literal|0xf
expr_stmt|;
if|if
condition|(
name|thumb_mode
condition|)
name|inst
operator|.
name|instruction
operator||=
literal|0xf9000000
expr_stmt|;
else|else
name|inst
operator|.
name|instruction
operator||=
literal|0xf4000000
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Overall per-instruction processing.	*/
end_comment

begin_comment
comment|/* We need to be able to fix up arbitrary expressions in some statements.    This is so that we can handle symbols that are an arbitrary distance from    the pc.  The most common cases are of the form ((+/-sym -/+ . - 8)& mask),    which returns part of an address in a form which will be valid for    a data instruction.	We do this by pushing the expression into a symbol    in the expr_section, and creating a fix for that.  */
end_comment

begin_function
specifier|static
name|void
name|fix_new_arm
parameter_list|(
name|fragS
modifier|*
name|frag
parameter_list|,
name|int
name|where
parameter_list|,
name|short
name|int
name|size
parameter_list|,
name|expressionS
modifier|*
name|exp
parameter_list|,
name|int
name|pc_rel
parameter_list|,
name|int
name|reloc
parameter_list|)
block|{
name|fixS
modifier|*
name|new_fix
decl_stmt|;
switch|switch
condition|(
name|exp
operator|->
name|X_op
condition|)
block|{
case|case
name|O_constant
case|:
case|case
name|O_symbol
case|:
case|case
name|O_add
case|:
case|case
name|O_subtract
case|:
name|new_fix
operator|=
name|fix_new_exp
argument_list|(
name|frag
argument_list|,
name|where
argument_list|,
name|size
argument_list|,
name|exp
argument_list|,
name|pc_rel
argument_list|,
name|reloc
argument_list|)
expr_stmt|;
break|break;
default|default:
name|new_fix
operator|=
name|fix_new
argument_list|(
name|frag
argument_list|,
name|where
argument_list|,
name|size
argument_list|,
name|make_expr_symbol
argument_list|(
name|exp
argument_list|)
argument_list|,
literal|0
argument_list|,
name|pc_rel
argument_list|,
name|reloc
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Mark whether the fix is to a THUMB instruction, or an ARM      instruction.  */
name|new_fix
operator|->
name|tc_fix_data
operator|=
name|thumb_mode
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Create a frg for an instruction requiring relaxation.  */
end_comment

begin_function
specifier|static
name|void
name|output_relax_insn
parameter_list|(
name|void
parameter_list|)
block|{
name|char
modifier|*
name|to
decl_stmt|;
name|symbolS
modifier|*
name|sym
decl_stmt|;
name|int
name|offset
decl_stmt|;
comment|/* The size of the instruction is unknown, so tie the debug info to the      start of the instruction.  */
name|dwarf2_emit_insn
argument_list|(
literal|0
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_op
condition|)
block|{
case|case
name|O_symbol
case|:
name|sym
operator|=
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_add_symbol
expr_stmt|;
name|offset
operator|=
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_add_number
expr_stmt|;
break|break;
case|case
name|O_constant
case|:
name|sym
operator|=
name|NULL
expr_stmt|;
name|offset
operator|=
name|inst
operator|.
name|reloc
operator|.
name|exp
operator|.
name|X_add_number
expr_stmt|;
break|break;
default|default:
name|sym
operator|=
name|make_expr_symbol
argument_list|(
operator|&
name|inst
operator|.
name|reloc
operator|.
name|exp
argument_list|)
expr_stmt|;
name|offset
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|to
operator|=
name|frag_var
argument_list|(
name|rs_machine_dependent
argument_list|,
name|INSN_SIZE
argument_list|,
name|THUMB_SIZE
argument_list|,
name|inst
operator|.
name|relax
argument_list|,
name|sym
argument_list|,
name|offset
argument_list|,
name|NULL
comment|/*offset, opcode*/
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|to
argument_list|,
name|inst
operator|.
name|instruction
argument_list|,
name|THUMB_SIZE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Write a 32-bit thumb instruction to buf.  */
end_comment

begin_function
specifier|static
name|void
name|put_thumb32_insn
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|unsigned
name|long
name|insn
parameter_list|)
block|{
name|md_number_to_chars
argument_list|(
name|buf
argument_list|,
name|insn
operator|>>
literal|16
argument_list|,
name|THUMB_SIZE
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|buf
operator|+
name|THUMB_SIZE
argument_list|,
name|insn
argument_list|,
name|THUMB_SIZE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|output_inst
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|)
block|{
name|char
modifier|*
name|to
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|inst
operator|.
name|error
condition|)
block|{
name|as_bad
argument_list|(
literal|"%s -- `%s'"
argument_list|,
name|inst
operator|.
name|error
argument_list|,
name|str
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|inst
operator|.
name|relax
condition|)
block|{
name|output_relax_insn
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|inst
operator|.
name|size
operator|==
literal|0
condition|)
return|return;
name|to
operator|=
name|frag_more
argument_list|(
name|inst
operator|.
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|thumb_mode
operator|&&
operator|(
name|inst
operator|.
name|size
operator|>
name|THUMB_SIZE
operator|)
condition|)
block|{
name|assert
argument_list|(
name|inst
operator|.
name|size
operator|==
operator|(
literal|2
operator|*
name|THUMB_SIZE
operator|)
argument_list|)
expr_stmt|;
name|put_thumb32_insn
argument_list|(
name|to
argument_list|,
name|inst
operator|.
name|instruction
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|inst
operator|.
name|size
operator|>
name|INSN_SIZE
condition|)
block|{
name|assert
argument_list|(
name|inst
operator|.
name|size
operator|==
operator|(
literal|2
operator|*
name|INSN_SIZE
operator|)
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|to
argument_list|,
name|inst
operator|.
name|instruction
argument_list|,
name|INSN_SIZE
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|to
operator|+
name|INSN_SIZE
argument_list|,
name|inst
operator|.
name|instruction
argument_list|,
name|INSN_SIZE
argument_list|)
expr_stmt|;
block|}
else|else
name|md_number_to_chars
argument_list|(
name|to
argument_list|,
name|inst
operator|.
name|instruction
argument_list|,
name|inst
operator|.
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|inst
operator|.
name|reloc
operator|.
name|type
operator|!=
name|BFD_RELOC_UNUSED
condition|)
name|fix_new_arm
argument_list|(
name|frag_now
argument_list|,
name|to
operator|-
name|frag_now
operator|->
name|fr_literal
argument_list|,
name|inst
operator|.
name|size
argument_list|,
operator|&
name|inst
operator|.
name|reloc
operator|.
name|exp
argument_list|,
name|inst
operator|.
name|reloc
operator|.
name|pc_rel
argument_list|,
name|inst
operator|.
name|reloc
operator|.
name|type
argument_list|)
expr_stmt|;
name|dwarf2_emit_insn
argument_list|(
name|inst
operator|.
name|size
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Tag values used in struct asm_opcode's tag field.  */
end_comment

begin_enum
enum|enum
name|opcode_tag
block|{
name|OT_unconditional
block|,
comment|/* Instruction cannot be conditionalized. 			   The ARM condition field is still 0xE.  */
name|OT_unconditionalF
block|,
comment|/* Instruction cannot be conditionalized 			   and carries 0xF in its ARM condition field.  */
name|OT_csuffix
block|,
comment|/* Instruction takes a conditional suffix.  */
name|OT_csuffixF
block|,
comment|/* Some forms of the instruction take a conditional                            suffix, others place 0xF where the condition field                            would be.  */
name|OT_cinfix3
block|,
comment|/* Instruction takes a conditional infix, 			   beginning at character index 3.  (In 			   unified mode, it becomes a suffix.)  */
name|OT_cinfix3_deprecated
block|,
comment|/* The same as OT_cinfix3.  This is used for 			    tsts, cmps, cmns, and teqs. */
name|OT_cinfix3_legacy
block|,
comment|/* Legacy instruction takes a conditional infix at 			   character index 3, even in unified mode.  Used for 			   legacy instructions where suffix and infix forms 			   may be ambiguous.  */
name|OT_csuf_or_in3
block|,
comment|/* Instruction takes either a conditional 			   suffix or an infix at character index 3.  */
name|OT_odd_infix_unc
block|,
comment|/* This is the unconditional variant of an 			   instruction that takes a conditional infix 			   at an unusual position.  In unified mode, 			   this variant will accept a suffix.  */
name|OT_odd_infix_0
comment|/* Values greater than or equal to OT_odd_infix_0 			   are the conditional variants of instructions that 			   take conditional infixes in unusual positions. 			   The infix appears at character index 			   (tag - OT_odd_infix_0).  These are not accepted 			   in unified mode.  */
block|}
enum|;
end_enum

begin_comment
comment|/* Subroutine of md_assemble, responsible for looking up the primary    opcode from the mnemonic the user wrote.  STR points to the    beginning of the mnemonic.     This is not simply a hash table lookup, because of conditional    variants.  Most instructions have conditional variants, which are    expressed with a _conditional affix_ to the mnemonic.  If we were    to encode each conditional variant as a literal string in the opcode    table, it would have approximately 20,000 entries.     Most mnemonics take this affix as a suffix, and in unified syntax,    'most' is upgraded to 'all'.  However, in the divided syntax, some    instructions take the affix as an infix, notably the s-variants of    the arithmetic instructions.  Of those instructions, all but six    have the infix appear after the third character of the mnemonic.     Accordingly, the algorithm for looking up primary opcodes given    an identifier is:     1. Look up the identifier in the opcode table.       If we find a match, go to step U.     2. Look up the last two characters of the identifier in the       conditions table.  If we find a match, look up the first N-2       characters of the identifier in the opcode table.  If we       find a match, go to step CE.     3. Look up the fourth and fifth characters of the identifier in       the conditions table.  If we find a match, extract those       characters from the identifier, and look up the remaining       characters in the opcode table.  If we find a match, go       to step CM.     4. Fail.     U. Examine the tag field of the opcode structure, in case this is       one of the six instructions with its conditional infix in an       unusual place.  If it is, the tag tells us where to find the       infix; look it up in the conditions table and set inst.cond       accordingly.  Otherwise, this is an unconditional instruction.       Again set inst.cond accordingly.  Return the opcode structure.    CE. Examine the tag field to make sure this is an instruction that       should receive a conditional suffix.  If it is not, fail.       Otherwise, set inst.cond from the suffix we already looked up,       and return the opcode structure.    CM. Examine the tag field to make sure this is an instruction that       should receive a conditional infix after the third character.       If it is not, fail.  Otherwise, undo the edits to the current       line of input and proceed as for case CE.  */
end_comment

begin_function
specifier|static
specifier|const
name|struct
name|asm_opcode
modifier|*
name|opcode_lookup
parameter_list|(
name|char
modifier|*
modifier|*
name|str
parameter_list|)
block|{
name|char
modifier|*
name|end
decl_stmt|,
modifier|*
name|base
decl_stmt|;
name|char
modifier|*
name|affix
decl_stmt|;
specifier|const
name|struct
name|asm_opcode
modifier|*
name|opcode
decl_stmt|;
specifier|const
name|struct
name|asm_cond
modifier|*
name|cond
decl_stmt|;
name|char
name|save
index|[
literal|2
index|]
decl_stmt|;
name|bfd_boolean
name|neon_supported
decl_stmt|;
name|neon_supported
operator|=
name|ARM_CPU_HAS_FEATURE
argument_list|(
name|cpu_variant
argument_list|,
name|fpu_neon_ext_v1
argument_list|)
expr_stmt|;
comment|/* Scan up to the end of the mnemonic, which must end in white space,      '.' (in unified mode, or for Neon instructions), or end of string.  */
for|for
control|(
name|base
operator|=
name|end
operator|=
operator|*
name|str
init|;
operator|*
name|end
operator|!=
literal|'\0'
condition|;
name|end
operator|++
control|)
if|if
condition|(
operator|*
name|end
operator|==
literal|' '
operator|||
operator|(
operator|(
name|unified_syntax
operator|||
name|neon_supported
operator|)
operator|&&
operator|*
name|end
operator|==
literal|'.'
operator|)
condition|)
break|break;
if|if
condition|(
name|end
operator|==
name|base
condition|)
return|return
literal|0
return|;
comment|/* Handle a possible width suffix and/or Neon type suffix.  */
if|if
condition|(
name|end
index|[
literal|0
index|]
operator|==
literal|'.'
condition|)
block|{
name|int
name|offset
init|=
literal|2
decl_stmt|;
comment|/* The .w and .n suffixes are only valid if the unified syntax is in          use.  */
if|if
condition|(
name|unified_syntax
operator|&&
name|end
index|[
literal|1
index|]
operator|==
literal|'w'
condition|)
name|inst
operator|.
name|size_req
operator|=
literal|4
expr_stmt|;
elseif|else
if|if
condition|(
name|unified_syntax
operator|&&
name|end
index|[
literal|1
index|]
operator|==
literal|'n'
condition|)
name|inst
operator|.
name|size_req
operator|=
literal|2
expr_stmt|;
else|else
name|offset
operator|=
literal|0
expr_stmt|;
name|inst
operator|.
name|vectype
operator|.
name|elems
operator|=
literal|0
expr_stmt|;
operator|*
name|str
operator|=
name|end
operator|+
name|offset
expr_stmt|;
if|if
condition|(
name|end
index|[
name|offset
index|]
operator|==
literal|'.'
condition|)
block|{
comment|/* See if we have a Neon type suffix (possible in either unified or              non-unified ARM syntax mode).  */
if|if
condition|(
name|parse_neon_type
argument_list|(
operator|&
name|inst
operator|.
name|vectype
argument_list|,
name|str
argument_list|)
operator|==
name|FAIL
condition|)
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|end
index|[
name|offset
index|]
operator|!=
literal|'\0'
operator|&&
name|end
index|[
name|offset
index|]
operator|!=
literal|' '
condition|)
return|return
literal|0
return|;
block|}
else|else
operator|*
name|str
operator|=
name|end
expr_stmt|;
comment|/* Look for unaffixed or special-case affixed mnemonic.  */
name|opcode
operator|=
name|hash_find_n
argument_list|(
name|arm_ops_hsh
argument_list|,
name|base
argument_list|,
name|end
operator|-
name|base
argument_list|)
expr_stmt|;
if|if
condition|(
name|opcode
condition|)
block|{
comment|/* step U */
if|if
condition|(
name|opcode
operator|->
name|tag
operator|<
name|OT_odd_infix_0
condition|)
block|{
name|inst
operator|.
name|cond
operator|=
name|COND_ALWAYS
expr_stmt|;
return|return
name|opcode
return|;
block|}
if|if
condition|(
name|unified_syntax
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"conditional infixes are deprecated in unified syntax"
argument_list|)
argument_list|)
expr_stmt|;
name|affix
operator|=
name|base
operator|+
operator|(
name|opcode
operator|->
name|tag
operator|-
name|OT_odd_infix_0
operator|)
expr_stmt|;
name|cond
operator|=
name|hash_find_n
argument_list|(
name|arm_cond_hsh
argument_list|,
name|affix
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|cond
argument_list|)
expr_stmt|;
name|inst
operator|.
name|cond
operator|=
name|cond
operator|->
name|value
expr_stmt|;
return|return
name|opcode
return|;
block|}
comment|/* Cannot have a conditional suffix on a mnemonic of less than two      characters.  */
if|if
condition|(
name|end
operator|-
name|base
operator|<
literal|3
condition|)
return|return
literal|0
return|;
comment|/* Look for suffixed mnemonic.  */
name|affix
operator|=
name|end
operator|-
literal|2
expr_stmt|;
name|cond
operator|=
name|hash_find_n
argument_list|(
name|arm_cond_hsh
argument_list|,
name|affix
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|opcode
operator|=
name|hash_find_n
argument_list|(
name|arm_ops_hsh
argument_list|,
name|base
argument_list|,
name|affix
operator|-
name|base
argument_list|)
expr_stmt|;
if|if
condition|(
name|opcode
operator|&&
name|cond
condition|)
block|{
comment|/* step CE */
switch|switch
condition|(
name|opcode
operator|->
name|tag
condition|)
block|{
case|case
name|OT_cinfix3_legacy
case|:
comment|/* Ignore conditional suffixes matched on infix only mnemonics.  */
break|break;
case|case
name|OT_cinfix3
case|:
case|case
name|OT_cinfix3_deprecated
case|:
case|case
name|OT_odd_infix_unc
case|:
if|if
condition|(
operator|!
name|unified_syntax
condition|)
return|return
literal|0
return|;
comment|/* else fall through */
case|case
name|OT_csuffix
case|:
case|case
name|OT_csuffixF
case|:
case|case
name|OT_csuf_or_in3
case|:
name|inst
operator|.
name|cond
operator|=
name|cond
operator|->
name|value
expr_stmt|;
return|return
name|opcode
return|;
case|case
name|OT_unconditional
case|:
case|case
name|OT_unconditionalF
case|:
if|if
condition|(
name|thumb_mode
condition|)
block|{
name|inst
operator|.
name|cond
operator|=
name|cond
operator|->
name|value
expr_stmt|;
block|}
else|else
block|{
comment|/* delayed diagnostic */
name|inst
operator|.
name|error
operator|=
name|BAD_COND
expr_stmt|;
name|inst
operator|.
name|cond
operator|=
name|COND_ALWAYS
expr_stmt|;
block|}
return|return
name|opcode
return|;
default|default:
return|return
literal|0
return|;
block|}
block|}
comment|/* Cannot have a usual-position infix on a mnemonic of less than      six characters (five would be a suffix).  */
if|if
condition|(
name|end
operator|-
name|base
operator|<
literal|6
condition|)
return|return
literal|0
return|;
comment|/* Look for infixed mnemonic in the usual position.  */
name|affix
operator|=
name|base
operator|+
literal|3
expr_stmt|;
name|cond
operator|=
name|hash_find_n
argument_list|(
name|arm_cond_hsh
argument_list|,
name|affix
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cond
condition|)
return|return
literal|0
return|;
name|memcpy
argument_list|(
name|save
argument_list|,
name|affix
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|memmove
argument_list|(
name|affix
argument_list|,
name|affix
operator|+
literal|2
argument_list|,
operator|(
name|end
operator|-
name|affix
operator|)
operator|-
literal|2
argument_list|)
expr_stmt|;
name|opcode
operator|=
name|hash_find_n
argument_list|(
name|arm_ops_hsh
argument_list|,
name|base
argument_list|,
operator|(
name|end
operator|-
name|base
operator|)
operator|-
literal|2
argument_list|)
expr_stmt|;
name|memmove
argument_list|(
name|affix
operator|+
literal|2
argument_list|,
name|affix
argument_list|,
operator|(
name|end
operator|-
name|affix
operator|)
operator|-
literal|2
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|affix
argument_list|,
name|save
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|opcode
operator|&&
operator|(
name|opcode
operator|->
name|tag
operator|==
name|OT_cinfix3
operator|||
name|opcode
operator|->
name|tag
operator|==
name|OT_cinfix3_deprecated
operator|||
name|opcode
operator|->
name|tag
operator|==
name|OT_csuf_or_in3
operator|||
name|opcode
operator|->
name|tag
operator|==
name|OT_cinfix3_legacy
operator|)
condition|)
block|{
comment|/* step CM */
if|if
condition|(
name|unified_syntax
operator|&&
operator|(
name|opcode
operator|->
name|tag
operator|==
name|OT_cinfix3
operator|||
name|opcode
operator|->
name|tag
operator|==
name|OT_cinfix3_deprecated
operator|)
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"conditional infixes are deprecated in unified syntax"
argument_list|)
argument_list|)
expr_stmt|;
name|inst
operator|.
name|cond
operator|=
name|cond
operator|->
name|value
expr_stmt|;
return|return
name|opcode
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|md_assemble
parameter_list|(
name|char
modifier|*
name|str
parameter_list|)
block|{
name|char
modifier|*
name|p
init|=
name|str
decl_stmt|;
specifier|const
name|struct
name|asm_opcode
modifier|*
name|opcode
decl_stmt|;
comment|/* Align the previous label if needed.  */
if|if
condition|(
name|last_label_seen
operator|!=
name|NULL
condition|)
block|{
name|symbol_set_frag
argument_list|(
name|last_label_seen
argument_list|,
name|frag_now
argument_list|)
expr_stmt|;
name|S_SET_VALUE
argument_list|(
name|last_label_seen
argument_list|,
operator|(
name|valueT
operator|)
name|frag_now_fix
argument_list|()
argument_list|)
expr_stmt|;
name|S_SET_SEGMENT
argument_list|(
name|last_label_seen
argument_list|,
name|now_seg
argument_list|)
expr_stmt|;
block|}
name|memset
argument_list|(
operator|&
name|inst
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
name|inst
argument_list|)
argument_list|)
expr_stmt|;
name|inst
operator|.
name|reloc
operator|.
name|type
operator|=
name|BFD_RELOC_UNUSED
expr_stmt|;
name|opcode
operator|=
name|opcode_lookup
argument_list|(
operator|&
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|opcode
condition|)
block|{
comment|/* It wasn't an instruction, but it might be a register alias of 	 the form alias .req reg, or a Neon .dn/.qn directive.  */
if|if
condition|(
operator|!
name|create_register_alias
argument_list|(
name|str
argument_list|,
name|p
argument_list|)
operator|&&
operator|!
name|create_neon_reg_alias
argument_list|(
name|str
argument_list|,
name|p
argument_list|)
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"bad instruction `%s'"
argument_list|)
argument_list|,
name|str
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|opcode
operator|->
name|tag
operator|==
name|OT_cinfix3_deprecated
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"s suffix on comparison instruction is deprecated"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* The value which unconditional instructions should have in place of the      condition field.  */
name|inst
operator|.
name|uncond_value
operator|=
operator|(
name|opcode
operator|->
name|tag
operator|==
name|OT_csuffixF
operator|)
condition|?
literal|0xf
else|:
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|thumb_mode
condition|)
block|{
name|arm_feature_set
name|variant
decl_stmt|;
name|variant
operator|=
name|cpu_variant
expr_stmt|;
comment|/* Only allow coprocessor instructions on Thumb-2 capable devices.  */
if|if
condition|(
operator|!
name|ARM_CPU_HAS_FEATURE
argument_list|(
name|variant
argument_list|,
name|arm_arch_t2
argument_list|)
condition|)
name|ARM_CLEAR_FEATURE
argument_list|(
name|variant
argument_list|,
name|variant
argument_list|,
name|fpu_any_hard
argument_list|)
expr_stmt|;
comment|/* Check that this instruction is supported for this CPU.  */
if|if
condition|(
operator|!
name|opcode
operator|->
name|tvariant
operator|||
operator|(
name|thumb_mode
operator|==
literal|1
operator|&&
operator|!
name|ARM_CPU_HAS_FEATURE
argument_list|(
name|variant
argument_list|,
operator|*
name|opcode
operator|->
name|tvariant
argument_list|)
operator|)
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"selected processor does not support `%s'"
argument_list|)
argument_list|,
name|str
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|inst
operator|.
name|cond
operator|!=
name|COND_ALWAYS
operator|&&
operator|!
name|unified_syntax
operator|&&
name|opcode
operator|->
name|tencode
operator|!=
name|do_t_branch
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Thumb does not support conditional execution"
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|ARM_CPU_HAS_FEATURE
argument_list|(
name|variant
argument_list|,
name|arm_ext_v6t2
argument_list|)
operator|&&
operator|!
name|inst
operator|.
name|size_req
condition|)
block|{
comment|/* Implicit require narrow instructions on Thumb-1.  This avoids 	     relaxation accidentally introducing Thumb-2 instructions.  */
if|if
condition|(
name|opcode
operator|->
name|tencode
operator|!=
name|do_t_blx
operator|&&
name|opcode
operator|->
name|tencode
operator|!=
name|do_t_branch23
condition|)
name|inst
operator|.
name|size_req
operator|=
literal|2
expr_stmt|;
block|}
comment|/* Check conditional suffixes.  */
if|if
condition|(
name|current_it_mask
condition|)
block|{
name|int
name|cond
decl_stmt|;
name|cond
operator|=
name|current_cc
operator|^
operator|(
operator|(
name|current_it_mask
operator|>>
literal|4
operator|)
operator|&
literal|1
operator|)
operator|^
literal|1
expr_stmt|;
name|current_it_mask
operator|<<=
literal|1
expr_stmt|;
name|current_it_mask
operator|&=
literal|0x1f
expr_stmt|;
comment|/* The BKPT instruction is unconditional even in an IT block.  */
if|if
condition|(
operator|!
name|inst
operator|.
name|error
operator|&&
name|cond
operator|!=
name|inst
operator|.
name|cond
operator|&&
name|opcode
operator|->
name|tencode
operator|!=
name|do_t_bkpt
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"incorrect condition in IT block"
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
elseif|else
if|if
condition|(
name|inst
operator|.
name|cond
operator|!=
name|COND_ALWAYS
operator|&&
name|opcode
operator|->
name|tencode
operator|!=
name|do_t_branch
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"thumb conditional instrunction not in IT block"
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|mapping_state
argument_list|(
name|MAP_THUMB
argument_list|)
expr_stmt|;
name|inst
operator|.
name|instruction
operator|=
name|opcode
operator|->
name|tvalue
expr_stmt|;
if|if
condition|(
operator|!
name|parse_operands
argument_list|(
name|p
argument_list|,
name|opcode
operator|->
name|operands
argument_list|)
condition|)
name|opcode
operator|->
name|tencode
argument_list|()
expr_stmt|;
comment|/* Clear current_it_mask at the end of an IT block.  */
if|if
condition|(
name|current_it_mask
operator|==
literal|0x10
condition|)
name|current_it_mask
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|inst
operator|.
name|error
operator|||
name|inst
operator|.
name|relax
operator|)
condition|)
block|{
name|assert
argument_list|(
name|inst
operator|.
name|instruction
operator|<
literal|0xe800
operator|||
name|inst
operator|.
name|instruction
operator|>
literal|0xffff
argument_list|)
expr_stmt|;
name|inst
operator|.
name|size
operator|=
operator|(
name|inst
operator|.
name|instruction
operator|>
literal|0xffff
condition|?
literal|4
else|:
literal|2
operator|)
expr_stmt|;
if|if
condition|(
name|inst
operator|.
name|size_req
operator|&&
name|inst
operator|.
name|size_req
operator|!=
name|inst
operator|.
name|size
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"cannot honor width suffix -- `%s'"
argument_list|)
argument_list|,
name|str
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* Something has gone badly wrong if we try to relax a fixed size          instruction.  */
name|assert
argument_list|(
name|inst
operator|.
name|size_req
operator|==
literal|0
operator|||
operator|!
name|inst
operator|.
name|relax
argument_list|)
expr_stmt|;
name|ARM_MERGE_FEATURE_SETS
argument_list|(
name|thumb_arch_used
argument_list|,
name|thumb_arch_used
argument_list|,
operator|*
name|opcode
operator|->
name|tvariant
argument_list|)
expr_stmt|;
comment|/* Many Thumb-2 instructions also have Thumb-1 variants, so explicitly 	 set those bits when Thumb-2 32-bit instructions are seen.  ie. 	 anything other than bl/blx. 	 This is overly pessimistic for relaxable instructions.  */
if|if
condition|(
operator|(
name|inst
operator|.
name|size
operator|==
literal|4
operator|&&
operator|(
name|inst
operator|.
name|instruction
operator|&
literal|0xf800e800
operator|)
operator|!=
literal|0xf000e800
operator|)
operator|||
name|inst
operator|.
name|relax
condition|)
name|ARM_MERGE_FEATURE_SETS
argument_list|(
name|thumb_arch_used
argument_list|,
name|thumb_arch_used
argument_list|,
name|arm_ext_v6t2
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ARM_CPU_HAS_FEATURE
argument_list|(
name|cpu_variant
argument_list|,
name|arm_ext_v1
argument_list|)
condition|)
block|{
comment|/* Check that this instruction is supported for this CPU.  */
if|if
condition|(
operator|!
name|opcode
operator|->
name|avariant
operator|||
operator|!
name|ARM_CPU_HAS_FEATURE
argument_list|(
name|cpu_variant
argument_list|,
operator|*
name|opcode
operator|->
name|avariant
argument_list|)
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"selected processor does not support `%s'"
argument_list|)
argument_list|,
name|str
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|inst
operator|.
name|size_req
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"width suffixes are invalid in ARM mode -- `%s'"
argument_list|)
argument_list|,
name|str
argument_list|)
expr_stmt|;
return|return;
block|}
name|mapping_state
argument_list|(
name|MAP_ARM
argument_list|)
expr_stmt|;
name|inst
operator|.
name|instruction
operator|=
name|opcode
operator|->
name|avalue
expr_stmt|;
if|if
condition|(
name|opcode
operator|->
name|tag
operator|==
name|OT_unconditionalF
condition|)
name|inst
operator|.
name|instruction
operator||=
literal|0xF
operator|<<
literal|28
expr_stmt|;
else|else
name|inst
operator|.
name|instruction
operator||=
name|inst
operator|.
name|cond
operator|<<
literal|28
expr_stmt|;
name|inst
operator|.
name|size
operator|=
name|INSN_SIZE
expr_stmt|;
if|if
condition|(
operator|!
name|parse_operands
argument_list|(
name|p
argument_list|,
name|opcode
operator|->
name|operands
argument_list|)
condition|)
name|opcode
operator|->
name|aencode
argument_list|()
expr_stmt|;
comment|/* Arm mode bx is marked as both v4T and v5 because it's still required          on a hypothetical non-thumb v5 core.  */
if|if
condition|(
name|ARM_CPU_HAS_FEATURE
argument_list|(
operator|*
name|opcode
operator|->
name|avariant
argument_list|,
name|arm_ext_v4t
argument_list|)
operator|||
name|ARM_CPU_HAS_FEATURE
argument_list|(
operator|*
name|opcode
operator|->
name|avariant
argument_list|,
name|arm_ext_v5
argument_list|)
condition|)
name|ARM_MERGE_FEATURE_SETS
argument_list|(
name|arm_arch_used
argument_list|,
name|arm_arch_used
argument_list|,
name|arm_ext_v4t
argument_list|)
expr_stmt|;
else|else
name|ARM_MERGE_FEATURE_SETS
argument_list|(
name|arm_arch_used
argument_list|,
name|arm_arch_used
argument_list|,
operator|*
name|opcode
operator|->
name|avariant
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"attempt to use an ARM instruction on a Thumb-only processor "
literal|"-- `%s'"
argument_list|)
argument_list|,
name|str
argument_list|)
expr_stmt|;
return|return;
block|}
name|output_inst
argument_list|(
name|str
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Various frobbings of labels and their addresses.  */
end_comment

begin_function
name|void
name|arm_start_line_hook
parameter_list|(
name|void
parameter_list|)
block|{
name|last_label_seen
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
name|void
name|arm_frob_label
parameter_list|(
name|symbolS
modifier|*
name|sym
parameter_list|)
block|{
name|last_label_seen
operator|=
name|sym
expr_stmt|;
name|ARM_SET_THUMB
argument_list|(
name|sym
argument_list|,
name|thumb_mode
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
name|OBJ_COFF
operator|||
name|defined
name|OBJ_ELF
name|ARM_SET_INTERWORK
argument_list|(
name|sym
argument_list|,
name|support_interwork
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Note - do not allow local symbols (.Lxxx) to be labeled      as Thumb functions.  This is because these labels, whilst      they exist inside Thumb code, are not the entry points for      possible ARM->Thumb calls.	 Also, these labels can be used      as part of a computed goto or switch statement.  eg gcc      can generate code that looks like this:  		ldr  r2, [pc, .Laaa] 		lsl  r3, r3, #2 		ldr  r2, [r3, r2] 		mov  pc, r2         .Lbbb:  .word .Lxxx        .Lccc:  .word .Lyyy        ..etc...        .Laaa:	.word Lbbb       The first instruction loads the address of the jump table.      The second instruction converts a table index into a byte offset.      The third instruction gets the jump address out of the table.      The fourth instruction performs the jump.       If the address stored at .Laaa is that of a symbol which has the      Thumb_Func bit set, then the linker will arrange for this address      to have the bottom bit set, which in turn would mean that the      address computation performed by the third instruction would end      up with the bottom bit set.  Since the ARM is capable of unaligned      word loads, the instruction would then load the incorrect address      out of the jump table, and chaos would ensue.  */
if|if
condition|(
name|label_is_thumb_function_name
operator|&&
operator|(
name|S_GET_NAME
argument_list|(
name|sym
argument_list|)
index|[
literal|0
index|]
operator|!=
literal|'.'
operator|||
name|S_GET_NAME
argument_list|(
name|sym
argument_list|)
index|[
literal|1
index|]
operator|!=
literal|'L'
operator|)
operator|&&
operator|(
name|bfd_get_section_flags
argument_list|(
name|stdoutput
argument_list|,
name|now_seg
argument_list|)
operator|&
name|SEC_CODE
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* When the address of a Thumb function is taken the bottom 	 bit of that address should be set.  This will allow 	 interworking between Arm and Thumb functions to work 	 correctly.  */
name|THUMB_SET_FUNC
argument_list|(
name|sym
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|label_is_thumb_function_name
operator|=
name|FALSE
expr_stmt|;
block|}
name|dwarf2_emit_label
argument_list|(
name|sym
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|arm_data_in_code
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|thumb_mode
operator|&&
operator|!
name|strncmp
argument_list|(
name|input_line_pointer
operator|+
literal|1
argument_list|,
literal|"data:"
argument_list|,
literal|5
argument_list|)
condition|)
block|{
operator|*
name|input_line_pointer
operator|=
literal|'/'
expr_stmt|;
name|input_line_pointer
operator|+=
literal|5
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
literal|0
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|arm_canonicalize_symbol_name
parameter_list|(
name|char
modifier|*
name|name
parameter_list|)
block|{
name|int
name|len
decl_stmt|;
if|if
condition|(
name|thumb_mode
operator|&&
operator|(
name|len
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
operator|)
operator|>
literal|5
operator|&&
name|streq
argument_list|(
name|name
operator|+
name|len
operator|-
literal|5
argument_list|,
literal|"/data"
argument_list|)
condition|)
operator|*
operator|(
name|name
operator|+
name|len
operator|-
literal|5
operator|)
operator|=
literal|0
expr_stmt|;
return|return
name|name
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Table of all register names defined by default.  The user can    define additional names with .req.  Note that all register names    should appear in both upper and lowercase variants.	Some registers    also have mixed-case names.	*/
end_comment

begin_define
define|#
directive|define
name|REGDEF
parameter_list|(
name|s
parameter_list|,
name|n
parameter_list|,
name|t
parameter_list|)
value|{ #s, n, REG_TYPE_##t, TRUE, 0 }
end_define

begin_define
define|#
directive|define
name|REGNUM
parameter_list|(
name|p
parameter_list|,
name|n
parameter_list|,
name|t
parameter_list|)
value|REGDEF(p##n, n, t)
end_define

begin_define
define|#
directive|define
name|REGNUM2
parameter_list|(
name|p
parameter_list|,
name|n
parameter_list|,
name|t
parameter_list|)
value|REGDEF(p##n, 2 * n, t)
end_define

begin_define
define|#
directive|define
name|REGSET
parameter_list|(
name|p
parameter_list|,
name|t
parameter_list|)
define|\
value|REGNUM(p, 0,t), REGNUM(p, 1,t), REGNUM(p, 2,t), REGNUM(p, 3,t), \   REGNUM(p, 4,t), REGNUM(p, 5,t), REGNUM(p, 6,t), REGNUM(p, 7,t), \   REGNUM(p, 8,t), REGNUM(p, 9,t), REGNUM(p,10,t), REGNUM(p,11,t), \   REGNUM(p,12,t), REGNUM(p,13,t), REGNUM(p,14,t), REGNUM(p,15,t)
end_define

begin_define
define|#
directive|define
name|REGSETH
parameter_list|(
name|p
parameter_list|,
name|t
parameter_list|)
define|\
value|REGNUM(p,16,t), REGNUM(p,17,t), REGNUM(p,18,t), REGNUM(p,19,t), \   REGNUM(p,20,t), REGNUM(p,21,t), REGNUM(p,22,t), REGNUM(p,23,t), \   REGNUM(p,24,t), REGNUM(p,25,t), REGNUM(p,26,t), REGNUM(p,27,t), \   REGNUM(p,28,t), REGNUM(p,29,t), REGNUM(p,30,t), REGNUM(p,31,t)
end_define

begin_define
define|#
directive|define
name|REGSET2
parameter_list|(
name|p
parameter_list|,
name|t
parameter_list|)
define|\
value|REGNUM2(p, 0,t), REGNUM2(p, 1,t), REGNUM2(p, 2,t), REGNUM2(p, 3,t), \   REGNUM2(p, 4,t), REGNUM2(p, 5,t), REGNUM2(p, 6,t), REGNUM2(p, 7,t), \   REGNUM2(p, 8,t), REGNUM2(p, 9,t), REGNUM2(p,10,t), REGNUM2(p,11,t), \   REGNUM2(p,12,t), REGNUM2(p,13,t), REGNUM2(p,14,t), REGNUM2(p,15,t)
end_define

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|reg_entry
name|reg_names
index|[]
init|=
block|{
comment|/* ARM integer registers.  */
name|REGSET
argument_list|(
name|r
argument_list|,
name|RN
argument_list|)
block|,
name|REGSET
argument_list|(
name|R
argument_list|,
name|RN
argument_list|)
block|,
comment|/* ATPCS synonyms.  */
name|REGDEF
argument_list|(
name|a1
argument_list|,
literal|0
argument_list|,
name|RN
argument_list|)
block|,
name|REGDEF
argument_list|(
name|a2
argument_list|,
literal|1
argument_list|,
name|RN
argument_list|)
block|,
name|REGDEF
argument_list|(
name|a3
argument_list|,
literal|2
argument_list|,
name|RN
argument_list|)
block|,
name|REGDEF
argument_list|(
name|a4
argument_list|,
literal|3
argument_list|,
name|RN
argument_list|)
block|,
name|REGDEF
argument_list|(
name|v1
argument_list|,
literal|4
argument_list|,
name|RN
argument_list|)
block|,
name|REGDEF
argument_list|(
name|v2
argument_list|,
literal|5
argument_list|,
name|RN
argument_list|)
block|,
name|REGDEF
argument_list|(
name|v3
argument_list|,
literal|6
argument_list|,
name|RN
argument_list|)
block|,
name|REGDEF
argument_list|(
name|v4
argument_list|,
literal|7
argument_list|,
name|RN
argument_list|)
block|,
name|REGDEF
argument_list|(
name|v5
argument_list|,
literal|8
argument_list|,
name|RN
argument_list|)
block|,
name|REGDEF
argument_list|(
name|v6
argument_list|,
literal|9
argument_list|,
name|RN
argument_list|)
block|,
name|REGDEF
argument_list|(
name|v7
argument_list|,
literal|10
argument_list|,
name|RN
argument_list|)
block|,
name|REGDEF
argument_list|(
name|v8
argument_list|,
literal|11
argument_list|,
name|RN
argument_list|)
block|,
name|REGDEF
argument_list|(
name|A1
argument_list|,
literal|0
argument_list|,
name|RN
argument_list|)
block|,
name|REGDEF
argument_list|(
name|A2
argument_list|,
literal|1
argument_list|,
name|RN
argument_list|)
block|,
name|REGDEF
argument_list|(
name|A3
argument_list|,
literal|2
argument_list|,
name|RN
argument_list|)
block|,
name|REGDEF
argument_list|(
name|A4
argument_list|,
literal|3
argument_list|,
name|RN
argument_list|)
block|,
name|REGDEF
argument_list|(
name|V1
argument_list|,
literal|4
argument_list|,
name|RN
argument_list|)
block|,
name|REGDEF
argument_list|(
name|V2
argument_list|,
literal|5
argument_list|,
name|RN
argument_list|)
block|,
name|REGDEF
argument_list|(
name|V3
argument_list|,
literal|6
argument_list|,
name|RN
argument_list|)
block|,
name|REGDEF
argument_list|(
name|V4
argument_list|,
literal|7
argument_list|,
name|RN
argument_list|)
block|,
name|REGDEF
argument_list|(
name|V5
argument_list|,
literal|8
argument_list|,
name|RN
argument_list|)
block|,
name|REGDEF
argument_list|(
name|V6
argument_list|,
literal|9
argument_list|,
name|RN
argument_list|)
block|,
name|REGDEF
argument_list|(
name|V7
argument_list|,
literal|10
argument_list|,
name|RN
argument_list|)
block|,
name|REGDEF
argument_list|(
name|V8
argument_list|,
literal|11
argument_list|,
name|RN
argument_list|)
block|,
comment|/* Well-known aliases.  */
name|REGDEF
argument_list|(
name|wr
argument_list|,
literal|7
argument_list|,
name|RN
argument_list|)
block|,
name|REGDEF
argument_list|(
name|sb
argument_list|,
literal|9
argument_list|,
name|RN
argument_list|)
block|,
name|REGDEF
argument_list|(
name|sl
argument_list|,
literal|10
argument_list|,
name|RN
argument_list|)
block|,
name|REGDEF
argument_list|(
name|fp
argument_list|,
literal|11
argument_list|,
name|RN
argument_list|)
block|,
name|REGDEF
argument_list|(
name|ip
argument_list|,
literal|12
argument_list|,
name|RN
argument_list|)
block|,
name|REGDEF
argument_list|(
name|sp
argument_list|,
literal|13
argument_list|,
name|RN
argument_list|)
block|,
name|REGDEF
argument_list|(
name|lr
argument_list|,
literal|14
argument_list|,
name|RN
argument_list|)
block|,
name|REGDEF
argument_list|(
name|pc
argument_list|,
literal|15
argument_list|,
name|RN
argument_list|)
block|,
name|REGDEF
argument_list|(
name|WR
argument_list|,
literal|7
argument_list|,
name|RN
argument_list|)
block|,
name|REGDEF
argument_list|(
name|SB
argument_list|,
literal|9
argument_list|,
name|RN
argument_list|)
block|,
name|REGDEF
argument_list|(
name|SL
argument_list|,
literal|10
argument_list|,
name|RN
argument_list|)
block|,
name|REGDEF
argument_list|(
name|FP
argument_list|,
literal|11
argument_list|,
name|RN
argument_list|)
block|,
name|REGDEF
argument_list|(
name|IP
argument_list|,
literal|12
argument_list|,
name|RN
argument_list|)
block|,
name|REGDEF
argument_list|(
name|SP
argument_list|,
literal|13
argument_list|,
name|RN
argument_list|)
block|,
name|REGDEF
argument_list|(
name|LR
argument_list|,
literal|14
argument_list|,
name|RN
argument_list|)
block|,
name|REGDEF
argument_list|(
name|PC
argument_list|,
literal|15
argument_list|,
name|RN
argument_list|)
block|,
comment|/* Coprocessor numbers.  */
name|REGSET
argument_list|(
name|p
argument_list|,
name|CP
argument_list|)
block|,
name|REGSET
argument_list|(
name|P
argument_list|,
name|CP
argument_list|)
block|,
comment|/* Coprocessor register numbers.  The "cr" variants are for backward      compatibility.  */
name|REGSET
argument_list|(
name|c
argument_list|,
name|CN
argument_list|)
block|,
name|REGSET
argument_list|(
name|C
argument_list|,
name|CN
argument_list|)
block|,
name|REGSET
argument_list|(
name|cr
argument_list|,
name|CN
argument_list|)
block|,
name|REGSET
argument_list|(
name|CR
argument_list|,
name|CN
argument_list|)
block|,
comment|/* FPA registers.  */
name|REGNUM
argument_list|(
name|f
argument_list|,
literal|0
argument_list|,
name|FN
argument_list|)
block|,
name|REGNUM
argument_list|(
name|f
argument_list|,
literal|1
argument_list|,
name|FN
argument_list|)
block|,
name|REGNUM
argument_list|(
name|f
argument_list|,
literal|2
argument_list|,
name|FN
argument_list|)
block|,
name|REGNUM
argument_list|(
name|f
argument_list|,
literal|3
argument_list|,
name|FN
argument_list|)
block|,
name|REGNUM
argument_list|(
name|f
argument_list|,
literal|4
argument_list|,
name|FN
argument_list|)
block|,
name|REGNUM
argument_list|(
name|f
argument_list|,
literal|5
argument_list|,
name|FN
argument_list|)
block|,
name|REGNUM
argument_list|(
name|f
argument_list|,
literal|6
argument_list|,
name|FN
argument_list|)
block|,
name|REGNUM
argument_list|(
name|f
argument_list|,
literal|7
argument_list|,
name|FN
argument_list|)
block|,
name|REGNUM
argument_list|(
name|F
argument_list|,
literal|0
argument_list|,
name|FN
argument_list|)
block|,
name|REGNUM
argument_list|(
name|F
argument_list|,
literal|1
argument_list|,
name|FN
argument_list|)
block|,
name|REGNUM
argument_list|(
name|F
argument_list|,
literal|2
argument_list|,
name|FN
argument_list|)
block|,
name|REGNUM
argument_list|(
name|F
argument_list|,
literal|3
argument_list|,
name|FN
argument_list|)
block|,
name|REGNUM
argument_list|(
name|F
argument_list|,
literal|4
argument_list|,
name|FN
argument_list|)
block|,
name|REGNUM
argument_list|(
name|F
argument_list|,
literal|5
argument_list|,
name|FN
argument_list|)
block|,
name|REGNUM
argument_list|(
name|F
argument_list|,
literal|6
argument_list|,
name|FN
argument_list|)
block|,
name|REGNUM
argument_list|(
name|F
argument_list|,
literal|7
argument_list|,
name|FN
argument_list|)
block|,
comment|/* VFP SP registers.	*/
name|REGSET
argument_list|(
name|s
argument_list|,
name|VFS
argument_list|)
block|,
name|REGSET
argument_list|(
name|S
argument_list|,
name|VFS
argument_list|)
block|,
name|REGSETH
argument_list|(
name|s
argument_list|,
name|VFS
argument_list|)
block|,
name|REGSETH
argument_list|(
name|S
argument_list|,
name|VFS
argument_list|)
block|,
comment|/* VFP DP Registers.	*/
name|REGSET
argument_list|(
name|d
argument_list|,
name|VFD
argument_list|)
block|,
name|REGSET
argument_list|(
name|D
argument_list|,
name|VFD
argument_list|)
block|,
comment|/* Extra Neon DP registers.  */
name|REGSETH
argument_list|(
name|d
argument_list|,
name|VFD
argument_list|)
block|,
name|REGSETH
argument_list|(
name|D
argument_list|,
name|VFD
argument_list|)
block|,
comment|/* Neon QP registers.  */
name|REGSET2
argument_list|(
name|q
argument_list|,
name|NQ
argument_list|)
block|,
name|REGSET2
argument_list|(
name|Q
argument_list|,
name|NQ
argument_list|)
block|,
comment|/* VFP control registers.  */
name|REGDEF
argument_list|(
name|fpsid
argument_list|,
literal|0
argument_list|,
name|VFC
argument_list|)
block|,
name|REGDEF
argument_list|(
name|fpscr
argument_list|,
literal|1
argument_list|,
name|VFC
argument_list|)
block|,
name|REGDEF
argument_list|(
name|fpexc
argument_list|,
literal|8
argument_list|,
name|VFC
argument_list|)
block|,
name|REGDEF
argument_list|(
name|FPSID
argument_list|,
literal|0
argument_list|,
name|VFC
argument_list|)
block|,
name|REGDEF
argument_list|(
name|FPSCR
argument_list|,
literal|1
argument_list|,
name|VFC
argument_list|)
block|,
name|REGDEF
argument_list|(
name|FPEXC
argument_list|,
literal|8
argument_list|,
name|VFC
argument_list|)
block|,
name|REGDEF
argument_list|(
name|fpinst
argument_list|,
literal|9
argument_list|,
name|VFC
argument_list|)
block|,
name|REGDEF
argument_list|(
name|fpinst2
argument_list|,
literal|10
argument_list|,
name|VFC
argument_list|)
block|,
name|REGDEF
argument_list|(
name|FPINST
argument_list|,
literal|9
argument_list|,
name|VFC
argument_list|)
block|,
name|REGDEF
argument_list|(
name|FPINST2
argument_list|,
literal|10
argument_list|,
name|VFC
argument_list|)
block|,
name|REGDEF
argument_list|(
name|mvfr0
argument_list|,
literal|7
argument_list|,
name|VFC
argument_list|)
block|,
name|REGDEF
argument_list|(
name|mvfr1
argument_list|,
literal|6
argument_list|,
name|VFC
argument_list|)
block|,
name|REGDEF
argument_list|(
name|MVFR0
argument_list|,
literal|7
argument_list|,
name|VFC
argument_list|)
block|,
name|REGDEF
argument_list|(
name|MVFR1
argument_list|,
literal|6
argument_list|,
name|VFC
argument_list|)
block|,
comment|/* Maverick DSP coprocessor registers.  */
name|REGSET
argument_list|(
name|mvf
argument_list|,
name|MVF
argument_list|)
block|,
name|REGSET
argument_list|(
name|mvd
argument_list|,
name|MVD
argument_list|)
block|,
name|REGSET
argument_list|(
name|mvfx
argument_list|,
name|MVFX
argument_list|)
block|,
name|REGSET
argument_list|(
name|mvdx
argument_list|,
name|MVDX
argument_list|)
block|,
name|REGSET
argument_list|(
name|MVF
argument_list|,
name|MVF
argument_list|)
block|,
name|REGSET
argument_list|(
name|MVD
argument_list|,
name|MVD
argument_list|)
block|,
name|REGSET
argument_list|(
name|MVFX
argument_list|,
name|MVFX
argument_list|)
block|,
name|REGSET
argument_list|(
name|MVDX
argument_list|,
name|MVDX
argument_list|)
block|,
name|REGNUM
argument_list|(
name|mvax
argument_list|,
literal|0
argument_list|,
name|MVAX
argument_list|)
block|,
name|REGNUM
argument_list|(
name|mvax
argument_list|,
literal|1
argument_list|,
name|MVAX
argument_list|)
block|,
name|REGNUM
argument_list|(
name|mvax
argument_list|,
literal|2
argument_list|,
name|MVAX
argument_list|)
block|,
name|REGNUM
argument_list|(
name|mvax
argument_list|,
literal|3
argument_list|,
name|MVAX
argument_list|)
block|,
name|REGDEF
argument_list|(
name|dspsc
argument_list|,
literal|0
argument_list|,
name|DSPSC
argument_list|)
block|,
name|REGNUM
argument_list|(
name|MVAX
argument_list|,
literal|0
argument_list|,
name|MVAX
argument_list|)
block|,
name|REGNUM
argument_list|(
name|MVAX
argument_list|,
literal|1
argument_list|,
name|MVAX
argument_list|)
block|,
name|REGNUM
argument_list|(
name|MVAX
argument_list|,
literal|2
argument_list|,
name|MVAX
argument_list|)
block|,
name|REGNUM
argument_list|(
name|MVAX
argument_list|,
literal|3
argument_list|,
name|MVAX
argument_list|)
block|,
name|REGDEF
argument_list|(
name|DSPSC
argument_list|,
literal|0
argument_list|,
name|DSPSC
argument_list|)
block|,
comment|/* iWMMXt data registers - p0, c0-15.	 */
name|REGSET
argument_list|(
name|wr
argument_list|,
name|MMXWR
argument_list|)
block|,
name|REGSET
argument_list|(
name|wR
argument_list|,
name|MMXWR
argument_list|)
block|,
name|REGSET
argument_list|(
name|WR
argument_list|,
name|MMXWR
argument_list|)
block|,
comment|/* iWMMXt control registers - p1, c0-3.  */
name|REGDEF
argument_list|(
name|wcid
argument_list|,
literal|0
argument_list|,
name|MMXWC
argument_list|)
block|,
name|REGDEF
argument_list|(
name|wCID
argument_list|,
literal|0
argument_list|,
name|MMXWC
argument_list|)
block|,
name|REGDEF
argument_list|(
name|WCID
argument_list|,
literal|0
argument_list|,
name|MMXWC
argument_list|)
block|,
name|REGDEF
argument_list|(
name|wcon
argument_list|,
literal|1
argument_list|,
name|MMXWC
argument_list|)
block|,
name|REGDEF
argument_list|(
name|wCon
argument_list|,
literal|1
argument_list|,
name|MMXWC
argument_list|)
block|,
name|REGDEF
argument_list|(
name|WCON
argument_list|,
literal|1
argument_list|,
name|MMXWC
argument_list|)
block|,
name|REGDEF
argument_list|(
name|wcssf
argument_list|,
literal|2
argument_list|,
name|MMXWC
argument_list|)
block|,
name|REGDEF
argument_list|(
name|wCSSF
argument_list|,
literal|2
argument_list|,
name|MMXWC
argument_list|)
block|,
name|REGDEF
argument_list|(
name|WCSSF
argument_list|,
literal|2
argument_list|,
name|MMXWC
argument_list|)
block|,
name|REGDEF
argument_list|(
name|wcasf
argument_list|,
literal|3
argument_list|,
name|MMXWC
argument_list|)
block|,
name|REGDEF
argument_list|(
name|wCASF
argument_list|,
literal|3
argument_list|,
name|MMXWC
argument_list|)
block|,
name|REGDEF
argument_list|(
name|WCASF
argument_list|,
literal|3
argument_list|,
name|MMXWC
argument_list|)
block|,
comment|/* iWMMXt scalar (constant/offset) registers - p1, c8-11.  */
name|REGDEF
argument_list|(
name|wcgr0
argument_list|,
literal|8
argument_list|,
name|MMXWCG
argument_list|)
block|,
name|REGDEF
argument_list|(
name|wCGR0
argument_list|,
literal|8
argument_list|,
name|MMXWCG
argument_list|)
block|,
name|REGDEF
argument_list|(
name|WCGR0
argument_list|,
literal|8
argument_list|,
name|MMXWCG
argument_list|)
block|,
name|REGDEF
argument_list|(
name|wcgr1
argument_list|,
literal|9
argument_list|,
name|MMXWCG
argument_list|)
block|,
name|REGDEF
argument_list|(
name|wCGR1
argument_list|,
literal|9
argument_list|,
name|MMXWCG
argument_list|)
block|,
name|REGDEF
argument_list|(
name|WCGR1
argument_list|,
literal|9
argument_list|,
name|MMXWCG
argument_list|)
block|,
name|REGDEF
argument_list|(
name|wcgr2
argument_list|,
literal|10
argument_list|,
name|MMXWCG
argument_list|)
block|,
name|REGDEF
argument_list|(
name|wCGR2
argument_list|,
literal|10
argument_list|,
name|MMXWCG
argument_list|)
block|,
name|REGDEF
argument_list|(
name|WCGR2
argument_list|,
literal|10
argument_list|,
name|MMXWCG
argument_list|)
block|,
name|REGDEF
argument_list|(
name|wcgr3
argument_list|,
literal|11
argument_list|,
name|MMXWCG
argument_list|)
block|,
name|REGDEF
argument_list|(
name|wCGR3
argument_list|,
literal|11
argument_list|,
name|MMXWCG
argument_list|)
block|,
name|REGDEF
argument_list|(
name|WCGR3
argument_list|,
literal|11
argument_list|,
name|MMXWCG
argument_list|)
block|,
comment|/* XScale accumulator registers.  */
name|REGNUM
argument_list|(
name|acc
argument_list|,
literal|0
argument_list|,
name|XSCALE
argument_list|)
block|,
name|REGNUM
argument_list|(
name|ACC
argument_list|,
literal|0
argument_list|,
name|XSCALE
argument_list|)
block|, }
decl_stmt|;
end_decl_stmt

begin_undef
undef|#
directive|undef
name|REGDEF
end_undef

begin_undef
undef|#
directive|undef
name|REGNUM
end_undef

begin_undef
undef|#
directive|undef
name|REGSET
end_undef

begin_comment
comment|/* Table of all PSR suffixes.  Bare "CPSR" and "SPSR" are handled    within psr_required_here.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|asm_psr
name|psrs
index|[]
init|=
block|{
comment|/* Backward compatibility notation.  Note that "all" is no longer      truly all possible PSR bits.  */
block|{
literal|"all"
block|,
name|PSR_c
operator||
name|PSR_f
block|}
block|,
block|{
literal|"flg"
block|,
name|PSR_f
block|}
block|,
block|{
literal|"ctl"
block|,
name|PSR_c
block|}
block|,
comment|/* Individual flags.	*/
block|{
literal|"f"
block|,
name|PSR_f
block|}
block|,
block|{
literal|"c"
block|,
name|PSR_c
block|}
block|,
block|{
literal|"x"
block|,
name|PSR_x
block|}
block|,
block|{
literal|"s"
block|,
name|PSR_s
block|}
block|,
comment|/* Combinations of flags.  */
block|{
literal|"fs"
block|,
name|PSR_f
operator||
name|PSR_s
block|}
block|,
block|{
literal|"fx"
block|,
name|PSR_f
operator||
name|PSR_x
block|}
block|,
block|{
literal|"fc"
block|,
name|PSR_f
operator||
name|PSR_c
block|}
block|,
block|{
literal|"sf"
block|,
name|PSR_s
operator||
name|PSR_f
block|}
block|,
block|{
literal|"sx"
block|,
name|PSR_s
operator||
name|PSR_x
block|}
block|,
block|{
literal|"sc"
block|,
name|PSR_s
operator||
name|PSR_c
block|}
block|,
block|{
literal|"xf"
block|,
name|PSR_x
operator||
name|PSR_f
block|}
block|,
block|{
literal|"xs"
block|,
name|PSR_x
operator||
name|PSR_s
block|}
block|,
block|{
literal|"xc"
block|,
name|PSR_x
operator||
name|PSR_c
block|}
block|,
block|{
literal|"cf"
block|,
name|PSR_c
operator||
name|PSR_f
block|}
block|,
block|{
literal|"cs"
block|,
name|PSR_c
operator||
name|PSR_s
block|}
block|,
block|{
literal|"cx"
block|,
name|PSR_c
operator||
name|PSR_x
block|}
block|,
block|{
literal|"fsx"
block|,
name|PSR_f
operator||
name|PSR_s
operator||
name|PSR_x
block|}
block|,
block|{
literal|"fsc"
block|,
name|PSR_f
operator||
name|PSR_s
operator||
name|PSR_c
block|}
block|,
block|{
literal|"fxs"
block|,
name|PSR_f
operator||
name|PSR_x
operator||
name|PSR_s
block|}
block|,
block|{
literal|"fxc"
block|,
name|PSR_f
operator||
name|PSR_x
operator||
name|PSR_c
block|}
block|,
block|{
literal|"fcs"
block|,
name|PSR_f
operator||
name|PSR_c
operator||
name|PSR_s
block|}
block|,
block|{
literal|"fcx"
block|,
name|PSR_f
operator||
name|PSR_c
operator||
name|PSR_x
block|}
block|,
block|{
literal|"sfx"
block|,
name|PSR_s
operator||
name|PSR_f
operator||
name|PSR_x
block|}
block|,
block|{
literal|"sfc"
block|,
name|PSR_s
operator||
name|PSR_f
operator||
name|PSR_c
block|}
block|,
block|{
literal|"sxf"
block|,
name|PSR_s
operator||
name|PSR_x
operator||
name|PSR_f
block|}
block|,
block|{
literal|"sxc"
block|,
name|PSR_s
operator||
name|PSR_x
operator||
name|PSR_c
block|}
block|,
block|{
literal|"scf"
block|,
name|PSR_s
operator||
name|PSR_c
operator||
name|PSR_f
block|}
block|,
block|{
literal|"scx"
block|,
name|PSR_s
operator||
name|PSR_c
operator||
name|PSR_x
block|}
block|,
block|{
literal|"xfs"
block|,
name|PSR_x
operator||
name|PSR_f
operator||
name|PSR_s
block|}
block|,
block|{
literal|"xfc"
block|,
name|PSR_x
operator||
name|PSR_f
operator||
name|PSR_c
block|}
block|,
block|{
literal|"xsf"
block|,
name|PSR_x
operator||
name|PSR_s
operator||
name|PSR_f
block|}
block|,
block|{
literal|"xsc"
block|,
name|PSR_x
operator||
name|PSR_s
operator||
name|PSR_c
block|}
block|,
block|{
literal|"xcf"
block|,
name|PSR_x
operator||
name|PSR_c
operator||
name|PSR_f
block|}
block|,
block|{
literal|"xcs"
block|,
name|PSR_x
operator||
name|PSR_c
operator||
name|PSR_s
block|}
block|,
block|{
literal|"cfs"
block|,
name|PSR_c
operator||
name|PSR_f
operator||
name|PSR_s
block|}
block|,
block|{
literal|"cfx"
block|,
name|PSR_c
operator||
name|PSR_f
operator||
name|PSR_x
block|}
block|,
block|{
literal|"csf"
block|,
name|PSR_c
operator||
name|PSR_s
operator||
name|PSR_f
block|}
block|,
block|{
literal|"csx"
block|,
name|PSR_c
operator||
name|PSR_s
operator||
name|PSR_x
block|}
block|,
block|{
literal|"cxf"
block|,
name|PSR_c
operator||
name|PSR_x
operator||
name|PSR_f
block|}
block|,
block|{
literal|"cxs"
block|,
name|PSR_c
operator||
name|PSR_x
operator||
name|PSR_s
block|}
block|,
block|{
literal|"fsxc"
block|,
name|PSR_f
operator||
name|PSR_s
operator||
name|PSR_x
operator||
name|PSR_c
block|}
block|,
block|{
literal|"fscx"
block|,
name|PSR_f
operator||
name|PSR_s
operator||
name|PSR_c
operator||
name|PSR_x
block|}
block|,
block|{
literal|"fxsc"
block|,
name|PSR_f
operator||
name|PSR_x
operator||
name|PSR_s
operator||
name|PSR_c
block|}
block|,
block|{
literal|"fxcs"
block|,
name|PSR_f
operator||
name|PSR_x
operator||
name|PSR_c
operator||
name|PSR_s
block|}
block|,
block|{
literal|"fcsx"
block|,
name|PSR_f
operator||
name|PSR_c
operator||
name|PSR_s
operator||
name|PSR_x
block|}
block|,
block|{
literal|"fcxs"
block|,
name|PSR_f
operator||
name|PSR_c
operator||
name|PSR_x
operator||
name|PSR_s
block|}
block|,
block|{
literal|"sfxc"
block|,
name|PSR_s
operator||
name|PSR_f
operator||
name|PSR_x
operator||
name|PSR_c
block|}
block|,
block|{
literal|"sfcx"
block|,
name|PSR_s
operator||
name|PSR_f
operator||
name|PSR_c
operator||
name|PSR_x
block|}
block|,
block|{
literal|"sxfc"
block|,
name|PSR_s
operator||
name|PSR_x
operator||
name|PSR_f
operator||
name|PSR_c
block|}
block|,
block|{
literal|"sxcf"
block|,
name|PSR_s
operator||
name|PSR_x
operator||
name|PSR_c
operator||
name|PSR_f
block|}
block|,
block|{
literal|"scfx"
block|,
name|PSR_s
operator||
name|PSR_c
operator||
name|PSR_f
operator||
name|PSR_x
block|}
block|,
block|{
literal|"scxf"
block|,
name|PSR_s
operator||
name|PSR_c
operator||
name|PSR_x
operator||
name|PSR_f
block|}
block|,
block|{
literal|"xfsc"
block|,
name|PSR_x
operator||
name|PSR_f
operator||
name|PSR_s
operator||
name|PSR_c
block|}
block|,
block|{
literal|"xfcs"
block|,
name|PSR_x
operator||
name|PSR_f
operator||
name|PSR_c
operator||
name|PSR_s
block|}
block|,
block|{
literal|"xsfc"
block|,
name|PSR_x
operator||
name|PSR_s
operator||
name|PSR_f
operator||
name|PSR_c
block|}
block|,
block|{
literal|"xscf"
block|,
name|PSR_x
operator||
name|PSR_s
operator||
name|PSR_c
operator||
name|PSR_f
block|}
block|,
block|{
literal|"xcfs"
block|,
name|PSR_x
operator||
name|PSR_c
operator||
name|PSR_f
operator||
name|PSR_s
block|}
block|,
block|{
literal|"xcsf"
block|,
name|PSR_x
operator||
name|PSR_c
operator||
name|PSR_s
operator||
name|PSR_f
block|}
block|,
block|{
literal|"cfsx"
block|,
name|PSR_c
operator||
name|PSR_f
operator||
name|PSR_s
operator||
name|PSR_x
block|}
block|,
block|{
literal|"cfxs"
block|,
name|PSR_c
operator||
name|PSR_f
operator||
name|PSR_x
operator||
name|PSR_s
block|}
block|,
block|{
literal|"csfx"
block|,
name|PSR_c
operator||
name|PSR_s
operator||
name|PSR_f
operator||
name|PSR_x
block|}
block|,
block|{
literal|"csxf"
block|,
name|PSR_c
operator||
name|PSR_s
operator||
name|PSR_x
operator||
name|PSR_f
block|}
block|,
block|{
literal|"cxfs"
block|,
name|PSR_c
operator||
name|PSR_x
operator||
name|PSR_f
operator||
name|PSR_s
block|}
block|,
block|{
literal|"cxsf"
block|,
name|PSR_c
operator||
name|PSR_x
operator||
name|PSR_s
operator||
name|PSR_f
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Table of V7M psr names.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|asm_psr
name|v7m_psrs
index|[]
init|=
block|{
block|{
literal|"apsr"
block|,
literal|0
block|}
block|,
block|{
literal|"APSR"
block|,
literal|0
block|}
block|,
block|{
literal|"iapsr"
block|,
literal|1
block|}
block|,
block|{
literal|"IAPSR"
block|,
literal|1
block|}
block|,
block|{
literal|"eapsr"
block|,
literal|2
block|}
block|,
block|{
literal|"EAPSR"
block|,
literal|2
block|}
block|,
block|{
literal|"psr"
block|,
literal|3
block|}
block|,
block|{
literal|"PSR"
block|,
literal|3
block|}
block|,
block|{
literal|"xpsr"
block|,
literal|3
block|}
block|,
block|{
literal|"XPSR"
block|,
literal|3
block|}
block|,
block|{
literal|"xPSR"
block|,
literal|3
block|}
block|,
block|{
literal|"ipsr"
block|,
literal|5
block|}
block|,
block|{
literal|"IPSR"
block|,
literal|5
block|}
block|,
block|{
literal|"epsr"
block|,
literal|6
block|}
block|,
block|{
literal|"EPSR"
block|,
literal|6
block|}
block|,
block|{
literal|"iepsr"
block|,
literal|7
block|}
block|,
block|{
literal|"IEPSR"
block|,
literal|7
block|}
block|,
block|{
literal|"msp"
block|,
literal|8
block|}
block|,
block|{
literal|"MSP"
block|,
literal|8
block|}
block|,
block|{
literal|"psp"
block|,
literal|9
block|}
block|,
block|{
literal|"PSP"
block|,
literal|9
block|}
block|,
block|{
literal|"primask"
block|,
literal|16
block|}
block|,
block|{
literal|"PRIMASK"
block|,
literal|16
block|}
block|,
block|{
literal|"basepri"
block|,
literal|17
block|}
block|,
block|{
literal|"BASEPRI"
block|,
literal|17
block|}
block|,
block|{
literal|"basepri_max"
block|,
literal|18
block|}
block|,
block|{
literal|"BASEPRI_MAX"
block|,
literal|18
block|}
block|,
block|{
literal|"faultmask"
block|,
literal|19
block|}
block|,
block|{
literal|"FAULTMASK"
block|,
literal|19
block|}
block|,
block|{
literal|"control"
block|,
literal|20
block|}
block|,
block|{
literal|"CONTROL"
block|,
literal|20
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Table of all shift-in-operand names.	 */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|asm_shift_name
name|shift_names
index|[]
init|=
block|{
block|{
literal|"asl"
block|,
name|SHIFT_LSL
block|}
block|,
block|{
literal|"ASL"
block|,
name|SHIFT_LSL
block|}
block|,
block|{
literal|"lsl"
block|,
name|SHIFT_LSL
block|}
block|,
block|{
literal|"LSL"
block|,
name|SHIFT_LSL
block|}
block|,
block|{
literal|"lsr"
block|,
name|SHIFT_LSR
block|}
block|,
block|{
literal|"LSR"
block|,
name|SHIFT_LSR
block|}
block|,
block|{
literal|"asr"
block|,
name|SHIFT_ASR
block|}
block|,
block|{
literal|"ASR"
block|,
name|SHIFT_ASR
block|}
block|,
block|{
literal|"ror"
block|,
name|SHIFT_ROR
block|}
block|,
block|{
literal|"ROR"
block|,
name|SHIFT_ROR
block|}
block|,
block|{
literal|"rrx"
block|,
name|SHIFT_RRX
block|}
block|,
block|{
literal|"RRX"
block|,
name|SHIFT_RRX
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Table of all explicit relocation names.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|OBJ_ELF
end_ifdef

begin_decl_stmt
specifier|static
name|struct
name|reloc_entry
name|reloc_names
index|[]
init|=
block|{
block|{
literal|"got"
block|,
name|BFD_RELOC_ARM_GOT32
block|}
block|,
block|{
literal|"GOT"
block|,
name|BFD_RELOC_ARM_GOT32
block|}
block|,
block|{
literal|"gotoff"
block|,
name|BFD_RELOC_ARM_GOTOFF
block|}
block|,
block|{
literal|"GOTOFF"
block|,
name|BFD_RELOC_ARM_GOTOFF
block|}
block|,
block|{
literal|"plt"
block|,
name|BFD_RELOC_ARM_PLT32
block|}
block|,
block|{
literal|"PLT"
block|,
name|BFD_RELOC_ARM_PLT32
block|}
block|,
block|{
literal|"target1"
block|,
name|BFD_RELOC_ARM_TARGET1
block|}
block|,
block|{
literal|"TARGET1"
block|,
name|BFD_RELOC_ARM_TARGET1
block|}
block|,
block|{
literal|"target2"
block|,
name|BFD_RELOC_ARM_TARGET2
block|}
block|,
block|{
literal|"TARGET2"
block|,
name|BFD_RELOC_ARM_TARGET2
block|}
block|,
block|{
literal|"sbrel"
block|,
name|BFD_RELOC_ARM_SBREL32
block|}
block|,
block|{
literal|"SBREL"
block|,
name|BFD_RELOC_ARM_SBREL32
block|}
block|,
block|{
literal|"tlsgd"
block|,
name|BFD_RELOC_ARM_TLS_GD32
block|}
block|,
block|{
literal|"TLSGD"
block|,
name|BFD_RELOC_ARM_TLS_GD32
block|}
block|,
block|{
literal|"tlsldm"
block|,
name|BFD_RELOC_ARM_TLS_LDM32
block|}
block|,
block|{
literal|"TLSLDM"
block|,
name|BFD_RELOC_ARM_TLS_LDM32
block|}
block|,
block|{
literal|"tlsldo"
block|,
name|BFD_RELOC_ARM_TLS_LDO32
block|}
block|,
block|{
literal|"TLSLDO"
block|,
name|BFD_RELOC_ARM_TLS_LDO32
block|}
block|,
block|{
literal|"gottpoff"
block|,
name|BFD_RELOC_ARM_TLS_IE32
block|}
block|,
block|{
literal|"GOTTPOFF"
block|,
name|BFD_RELOC_ARM_TLS_IE32
block|}
block|,
block|{
literal|"tpoff"
block|,
name|BFD_RELOC_ARM_TLS_LE32
block|}
block|,
block|{
literal|"TPOFF"
block|,
name|BFD_RELOC_ARM_TLS_LE32
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Table of all conditional affixes.  0xF is not defined as a condition code.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|asm_cond
name|conds
index|[]
init|=
block|{
block|{
literal|"eq"
block|,
literal|0x0
block|}
block|,
block|{
literal|"ne"
block|,
literal|0x1
block|}
block|,
block|{
literal|"cs"
block|,
literal|0x2
block|}
block|,
block|{
literal|"hs"
block|,
literal|0x2
block|}
block|,
block|{
literal|"cc"
block|,
literal|0x3
block|}
block|,
block|{
literal|"ul"
block|,
literal|0x3
block|}
block|,
block|{
literal|"lo"
block|,
literal|0x3
block|}
block|,
block|{
literal|"mi"
block|,
literal|0x4
block|}
block|,
block|{
literal|"pl"
block|,
literal|0x5
block|}
block|,
block|{
literal|"vs"
block|,
literal|0x6
block|}
block|,
block|{
literal|"vc"
block|,
literal|0x7
block|}
block|,
block|{
literal|"hi"
block|,
literal|0x8
block|}
block|,
block|{
literal|"ls"
block|,
literal|0x9
block|}
block|,
block|{
literal|"ge"
block|,
literal|0xa
block|}
block|,
block|{
literal|"lt"
block|,
literal|0xb
block|}
block|,
block|{
literal|"gt"
block|,
literal|0xc
block|}
block|,
block|{
literal|"le"
block|,
literal|0xd
block|}
block|,
block|{
literal|"al"
block|,
literal|0xe
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|asm_barrier_opt
name|barrier_opt_names
index|[]
init|=
block|{
block|{
literal|"sy"
block|,
literal|0xf
block|}
block|,
block|{
literal|"un"
block|,
literal|0x7
block|}
block|,
block|{
literal|"st"
block|,
literal|0xe
block|}
block|,
block|{
literal|"unst"
block|,
literal|0x6
block|}
block|,
block|{
literal|"ish"
block|,
literal|0xb
block|}
block|,
block|{
literal|"sh"
block|,
literal|0xb
block|}
block|,
block|{
literal|"ishst"
block|,
literal|0xa
block|}
block|,
block|{
literal|"shst"
block|,
literal|0xa
block|}
block|,
block|{
literal|"nsh"
block|,
literal|0x7
block|}
block|,
block|{
literal|"nshst"
block|,
literal|0x6
block|}
block|,
block|{
literal|"osh"
block|,
literal|0x3
block|}
block|,
block|{
literal|"oshst"
block|,
literal|0x2
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Table of ARM-format instructions.	*/
end_comment

begin_comment
comment|/* Macros for gluing together operand strings.  N.B. In all cases    other than OPS0, the trailing OP_stop comes from default    zero-initialization of the unspecified elements of the array.  */
end_comment

begin_define
define|#
directive|define
name|OPS0
parameter_list|()
value|{ OP_stop, }
end_define

begin_define
define|#
directive|define
name|OPS1
parameter_list|(
name|a
parameter_list|)
value|{ OP_##a, }
end_define

begin_define
define|#
directive|define
name|OPS2
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|{ OP_##a,OP_##b, }
end_define

begin_define
define|#
directive|define
name|OPS3
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|)
value|{ OP_##a,OP_##b,OP_##c, }
end_define

begin_define
define|#
directive|define
name|OPS4
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|,
name|d
parameter_list|)
value|{ OP_##a,OP_##b,OP_##c,OP_##d, }
end_define

begin_define
define|#
directive|define
name|OPS5
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|,
name|d
parameter_list|,
name|e
parameter_list|)
value|{ OP_##a,OP_##b,OP_##c,OP_##d,OP_##e, }
end_define

begin_define
define|#
directive|define
name|OPS6
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|,
name|d
parameter_list|,
name|e
parameter_list|,
name|f
parameter_list|)
value|{ OP_##a,OP_##b,OP_##c,OP_##d,OP_##e,OP_##f, }
end_define

begin_comment
comment|/* These macros abstract out the exact format of the mnemonic table and    save some repeated characters.  */
end_comment

begin_comment
comment|/* The normal sort of mnemonic; has a Thumb variant; takes a conditional suffix.  */
end_comment

begin_define
define|#
directive|define
name|TxCE
parameter_list|(
name|mnem
parameter_list|,
name|op
parameter_list|,
name|top
parameter_list|,
name|nops
parameter_list|,
name|ops
parameter_list|,
name|ae
parameter_list|,
name|te
parameter_list|)
define|\
value|{ #mnem, OPS##nops ops, OT_csuffix, 0x##op, top, ARM_VARIANT, \     THUMB_VARIANT, do_##ae, do_##te }
end_define

begin_comment
comment|/* Two variants of the above - TCE for a numeric Thumb opcode, tCE for    a T_MNEM_xyz enumerator.  */
end_comment

begin_define
define|#
directive|define
name|TCE
parameter_list|(
name|mnem
parameter_list|,
name|aop
parameter_list|,
name|top
parameter_list|,
name|nops
parameter_list|,
name|ops
parameter_list|,
name|ae
parameter_list|,
name|te
parameter_list|)
define|\
value|TxCE(mnem, aop, 0x##top, nops, ops, ae, te)
end_define

begin_define
define|#
directive|define
name|tCE
parameter_list|(
name|mnem
parameter_list|,
name|aop
parameter_list|,
name|top
parameter_list|,
name|nops
parameter_list|,
name|ops
parameter_list|,
name|ae
parameter_list|,
name|te
parameter_list|)
define|\
value|TxCE(mnem, aop, T_MNEM_##top, nops, ops, ae, te)
end_define

begin_comment
comment|/* Second most common sort of mnemonic: has a Thumb variant, takes a conditional    infix after the third character.  */
end_comment

begin_define
define|#
directive|define
name|TxC3
parameter_list|(
name|mnem
parameter_list|,
name|op
parameter_list|,
name|top
parameter_list|,
name|nops
parameter_list|,
name|ops
parameter_list|,
name|ae
parameter_list|,
name|te
parameter_list|)
define|\
value|{ #mnem, OPS##nops ops, OT_cinfix3, 0x##op, top, ARM_VARIANT, \     THUMB_VARIANT, do_##ae, do_##te }
end_define

begin_define
define|#
directive|define
name|TxC3w
parameter_list|(
name|mnem
parameter_list|,
name|op
parameter_list|,
name|top
parameter_list|,
name|nops
parameter_list|,
name|ops
parameter_list|,
name|ae
parameter_list|,
name|te
parameter_list|)
define|\
value|{ #mnem, OPS##nops ops, OT_cinfix3_deprecated, 0x##op, top, ARM_VARIANT, \     THUMB_VARIANT, do_##ae, do_##te }
end_define

begin_define
define|#
directive|define
name|TC3
parameter_list|(
name|mnem
parameter_list|,
name|aop
parameter_list|,
name|top
parameter_list|,
name|nops
parameter_list|,
name|ops
parameter_list|,
name|ae
parameter_list|,
name|te
parameter_list|)
define|\
value|TxC3(mnem, aop, 0x##top, nops, ops, ae, te)
end_define

begin_define
define|#
directive|define
name|TC3w
parameter_list|(
name|mnem
parameter_list|,
name|aop
parameter_list|,
name|top
parameter_list|,
name|nops
parameter_list|,
name|ops
parameter_list|,
name|ae
parameter_list|,
name|te
parameter_list|)
define|\
value|TxC3w(mnem, aop, 0x##top, nops, ops, ae, te)
end_define

begin_define
define|#
directive|define
name|tC3
parameter_list|(
name|mnem
parameter_list|,
name|aop
parameter_list|,
name|top
parameter_list|,
name|nops
parameter_list|,
name|ops
parameter_list|,
name|ae
parameter_list|,
name|te
parameter_list|)
define|\
value|TxC3(mnem, aop, T_MNEM_##top, nops, ops, ae, te)
end_define

begin_define
define|#
directive|define
name|tC3w
parameter_list|(
name|mnem
parameter_list|,
name|aop
parameter_list|,
name|top
parameter_list|,
name|nops
parameter_list|,
name|ops
parameter_list|,
name|ae
parameter_list|,
name|te
parameter_list|)
define|\
value|TxC3w(mnem, aop, T_MNEM_##top, nops, ops, ae, te)
end_define

begin_comment
comment|/* Mnemonic with a conditional infix in an unusual place.  Each and every variant has to    appear in the condition table.  */
end_comment

begin_define
define|#
directive|define
name|TxCM_
parameter_list|(
name|m1
parameter_list|,
name|m2
parameter_list|,
name|m3
parameter_list|,
name|op
parameter_list|,
name|top
parameter_list|,
name|nops
parameter_list|,
name|ops
parameter_list|,
name|ae
parameter_list|,
name|te
parameter_list|)
define|\
value|{ #m1 #m2 #m3, OPS##nops ops, sizeof(#m2) == 1 ? OT_odd_infix_unc : OT_odd_infix_0 + sizeof(#m1) - 1, \     0x##op, top, ARM_VARIANT, THUMB_VARIANT, do_##ae, do_##te }
end_define

begin_define
define|#
directive|define
name|TxCM
parameter_list|(
name|m1
parameter_list|,
name|m2
parameter_list|,
name|op
parameter_list|,
name|top
parameter_list|,
name|nops
parameter_list|,
name|ops
parameter_list|,
name|ae
parameter_list|,
name|te
parameter_list|)
define|\
value|TxCM_(m1,   , m2, op, top, nops, ops, ae, te),	\   TxCM_(m1, eq, m2, op, top, nops, ops, ae, te),	\   TxCM_(m1, ne, m2, op, top, nops, ops, ae, te),	\   TxCM_(m1, cs, m2, op, top, nops, ops, ae, te),	\   TxCM_(m1, hs, m2, op, top, nops, ops, ae, te),	\   TxCM_(m1, cc, m2, op, top, nops, ops, ae, te),	\   TxCM_(m1, ul, m2, op, top, nops, ops, ae, te),	\   TxCM_(m1, lo, m2, op, top, nops, ops, ae, te),	\   TxCM_(m1, mi, m2, op, top, nops, ops, ae, te),	\   TxCM_(m1, pl, m2, op, top, nops, ops, ae, te),	\   TxCM_(m1, vs, m2, op, top, nops, ops, ae, te),	\   TxCM_(m1, vc, m2, op, top, nops, ops, ae, te),	\   TxCM_(m1, hi, m2, op, top, nops, ops, ae, te),	\   TxCM_(m1, ls, m2, op, top, nops, ops, ae, te),	\   TxCM_(m1, ge, m2, op, top, nops, ops, ae, te),	\   TxCM_(m1, lt, m2, op, top, nops, ops, ae, te),	\   TxCM_(m1, gt, m2, op, top, nops, ops, ae, te),	\   TxCM_(m1, le, m2, op, top, nops, ops, ae, te),	\   TxCM_(m1, al, m2, op, top, nops, ops, ae, te)
end_define

begin_define
define|#
directive|define
name|TCM
parameter_list|(
name|m1
parameter_list|,
name|m2
parameter_list|,
name|aop
parameter_list|,
name|top
parameter_list|,
name|nops
parameter_list|,
name|ops
parameter_list|,
name|ae
parameter_list|,
name|te
parameter_list|)
define|\
value|TxCM(m1,m2, aop, 0x##top, nops, ops, ae, te)
end_define

begin_define
define|#
directive|define
name|tCM
parameter_list|(
name|m1
parameter_list|,
name|m2
parameter_list|,
name|aop
parameter_list|,
name|top
parameter_list|,
name|nops
parameter_list|,
name|ops
parameter_list|,
name|ae
parameter_list|,
name|te
parameter_list|)
define|\
value|TxCM(m1,m2, aop, T_MNEM_##top, nops, ops, ae, te)
end_define

begin_comment
comment|/* Mnemonic that cannot be conditionalized.  The ARM condition-code    field is still 0xE.  Many of the Thumb variants can be executed    conditionally, so this is checked separately.  */
end_comment

begin_define
define|#
directive|define
name|TUE
parameter_list|(
name|mnem
parameter_list|,
name|op
parameter_list|,
name|top
parameter_list|,
name|nops
parameter_list|,
name|ops
parameter_list|,
name|ae
parameter_list|,
name|te
parameter_list|)
define|\
value|{ #mnem, OPS##nops ops, OT_unconditional, 0x##op, 0x##top, ARM_VARIANT, \     THUMB_VARIANT, do_##ae, do_##te }
end_define

begin_comment
comment|/* Mnemonic that cannot be conditionalized, and bears 0xF in its ARM    condition code field.  */
end_comment

begin_define
define|#
directive|define
name|TUF
parameter_list|(
name|mnem
parameter_list|,
name|op
parameter_list|,
name|top
parameter_list|,
name|nops
parameter_list|,
name|ops
parameter_list|,
name|ae
parameter_list|,
name|te
parameter_list|)
define|\
value|{ #mnem, OPS##nops ops, OT_unconditionalF, 0x##op, 0x##top, ARM_VARIANT, \     THUMB_VARIANT, do_##ae, do_##te }
end_define

begin_comment
comment|/* ARM-only variants of all the above.  */
end_comment

begin_define
define|#
directive|define
name|CE
parameter_list|(
name|mnem
parameter_list|,
name|op
parameter_list|,
name|nops
parameter_list|,
name|ops
parameter_list|,
name|ae
parameter_list|)
define|\
value|{ #mnem, OPS##nops ops, OT_csuffix, 0x##op, 0x0, ARM_VARIANT, 0, do_##ae, NULL }
end_define

begin_define
define|#
directive|define
name|C3
parameter_list|(
name|mnem
parameter_list|,
name|op
parameter_list|,
name|nops
parameter_list|,
name|ops
parameter_list|,
name|ae
parameter_list|)
define|\
value|{ #mnem, OPS##nops ops, OT_cinfix3, 0x##op, 0x0, ARM_VARIANT, 0, do_##ae, NULL }
end_define

begin_comment
comment|/* Legacy mnemonics that always have conditional infix after the third    character.  */
end_comment

begin_define
define|#
directive|define
name|CL
parameter_list|(
name|mnem
parameter_list|,
name|op
parameter_list|,
name|nops
parameter_list|,
name|ops
parameter_list|,
name|ae
parameter_list|)
define|\
value|{ #mnem, OPS##nops ops, OT_cinfix3_legacy, \     0x##op, 0x0, ARM_VARIANT, 0, do_##ae, NULL }
end_define

begin_comment
comment|/* Coprocessor instructions.  Isomorphic between Arm and Thumb-2.  */
end_comment

begin_define
define|#
directive|define
name|cCE
parameter_list|(
name|mnem
parameter_list|,
name|op
parameter_list|,
name|nops
parameter_list|,
name|ops
parameter_list|,
name|ae
parameter_list|)
define|\
value|{ #mnem, OPS##nops ops, OT_csuffix, 0x##op, 0xe##op, ARM_VARIANT, ARM_VARIANT, do_##ae, do_##ae }
end_define

begin_comment
comment|/* Legacy coprocessor instructions where conditional infix and conditional    suffix are ambiguous.  For consistency this includes all FPA instructions,    not just the potentially ambiguous ones.  */
end_comment

begin_define
define|#
directive|define
name|cCL
parameter_list|(
name|mnem
parameter_list|,
name|op
parameter_list|,
name|nops
parameter_list|,
name|ops
parameter_list|,
name|ae
parameter_list|)
define|\
value|{ #mnem, OPS##nops ops, OT_cinfix3_legacy, \     0x##op, 0xe##op, ARM_VARIANT, ARM_VARIANT, do_##ae, do_##ae }
end_define

begin_comment
comment|/* Coprocessor, takes either a suffix or a position-3 infix    (for an FPA corner case). */
end_comment

begin_define
define|#
directive|define
name|C3E
parameter_list|(
name|mnem
parameter_list|,
name|op
parameter_list|,
name|nops
parameter_list|,
name|ops
parameter_list|,
name|ae
parameter_list|)
define|\
value|{ #mnem, OPS##nops ops, OT_csuf_or_in3, \     0x##op, 0xe##op, ARM_VARIANT, ARM_VARIANT, do_##ae, do_##ae }
end_define

begin_define
define|#
directive|define
name|xCM_
parameter_list|(
name|m1
parameter_list|,
name|m2
parameter_list|,
name|m3
parameter_list|,
name|op
parameter_list|,
name|nops
parameter_list|,
name|ops
parameter_list|,
name|ae
parameter_list|)
define|\
value|{ #m1 #m2 #m3, OPS##nops ops, \     sizeof(#m2) == 1 ? OT_odd_infix_unc : OT_odd_infix_0 + sizeof(#m1) - 1, \     0x##op, 0x0, ARM_VARIANT, 0, do_##ae, NULL }
end_define

begin_define
define|#
directive|define
name|CM
parameter_list|(
name|m1
parameter_list|,
name|m2
parameter_list|,
name|op
parameter_list|,
name|nops
parameter_list|,
name|ops
parameter_list|,
name|ae
parameter_list|)
define|\
value|xCM_(m1,   , m2, op, nops, ops, ae),	\   xCM_(m1, eq, m2, op, nops, ops, ae),	\   xCM_(m1, ne, m2, op, nops, ops, ae),	\   xCM_(m1, cs, m2, op, nops, ops, ae),	\   xCM_(m1, hs, m2, op, nops, ops, ae),	\   xCM_(m1, cc, m2, op, nops, ops, ae),	\   xCM_(m1, ul, m2, op, nops, ops, ae),	\   xCM_(m1, lo, m2, op, nops, ops, ae),	\   xCM_(m1, mi, m2, op, nops, ops, ae),	\   xCM_(m1, pl, m2, op, nops, ops, ae),	\   xCM_(m1, vs, m2, op, nops, ops, ae),	\   xCM_(m1, vc, m2, op, nops, ops, ae),	\   xCM_(m1, hi, m2, op, nops, ops, ae),	\   xCM_(m1, ls, m2, op, nops, ops, ae),	\   xCM_(m1, ge, m2, op, nops, ops, ae),	\   xCM_(m1, lt, m2, op, nops, ops, ae),	\   xCM_(m1, gt, m2, op, nops, ops, ae),	\   xCM_(m1, le, m2, op, nops, ops, ae),	\   xCM_(m1, al, m2, op, nops, ops, ae)
end_define

begin_define
define|#
directive|define
name|UE
parameter_list|(
name|mnem
parameter_list|,
name|op
parameter_list|,
name|nops
parameter_list|,
name|ops
parameter_list|,
name|ae
parameter_list|)
define|\
value|{ #mnem, OPS##nops ops, OT_unconditional, 0x##op, 0, ARM_VARIANT, 0, do_##ae, NULL }
end_define

begin_define
define|#
directive|define
name|UF
parameter_list|(
name|mnem
parameter_list|,
name|op
parameter_list|,
name|nops
parameter_list|,
name|ops
parameter_list|,
name|ae
parameter_list|)
define|\
value|{ #mnem, OPS##nops ops, OT_unconditionalF, 0x##op, 0, ARM_VARIANT, 0, do_##ae, NULL }
end_define

begin_comment
comment|/* Neon data-processing. ARM versions are unconditional with cond=0xf.    The Thumb and ARM variants are mostly the same (bits 0-23 and 24/28), so we    use the same encoding function for each.  */
end_comment

begin_define
define|#
directive|define
name|NUF
parameter_list|(
name|mnem
parameter_list|,
name|op
parameter_list|,
name|nops
parameter_list|,
name|ops
parameter_list|,
name|enc
parameter_list|)
define|\
value|{ #mnem, OPS##nops ops, OT_unconditionalF, 0x##op, 0x##op,		\     ARM_VARIANT, THUMB_VARIANT, do_##enc, do_##enc }
end_define

begin_comment
comment|/* Neon data processing, version which indirects through neon_enc_tab for    the various overloaded versions of opcodes.  */
end_comment

begin_define
define|#
directive|define
name|nUF
parameter_list|(
name|mnem
parameter_list|,
name|op
parameter_list|,
name|nops
parameter_list|,
name|ops
parameter_list|,
name|enc
parameter_list|)
define|\
value|{ #mnem, OPS##nops ops, OT_unconditionalF, N_MNEM_##op, N_MNEM_##op,	\     ARM_VARIANT, THUMB_VARIANT, do_##enc, do_##enc }
end_define

begin_comment
comment|/* Neon insn with conditional suffix for the ARM version, non-overloaded    version.  */
end_comment

begin_define
define|#
directive|define
name|NCE_tag
parameter_list|(
name|mnem
parameter_list|,
name|op
parameter_list|,
name|nops
parameter_list|,
name|ops
parameter_list|,
name|enc
parameter_list|,
name|tag
parameter_list|)
define|\
value|{ #mnem, OPS##nops ops, tag, 0x##op, 0x##op, ARM_VARIANT,		\     THUMB_VARIANT, do_##enc, do_##enc }
end_define

begin_define
define|#
directive|define
name|NCE
parameter_list|(
name|mnem
parameter_list|,
name|op
parameter_list|,
name|nops
parameter_list|,
name|ops
parameter_list|,
name|enc
parameter_list|)
define|\
value|NCE_tag(mnem, op, nops, ops, enc, OT_csuffix)
end_define

begin_define
define|#
directive|define
name|NCEF
parameter_list|(
name|mnem
parameter_list|,
name|op
parameter_list|,
name|nops
parameter_list|,
name|ops
parameter_list|,
name|enc
parameter_list|)
define|\
value|NCE_tag(mnem, op, nops, ops, enc, OT_csuffixF)
end_define

begin_comment
comment|/* Neon insn with conditional suffix for the ARM version, overloaded types.  */
end_comment

begin_define
define|#
directive|define
name|nCE_tag
parameter_list|(
name|mnem
parameter_list|,
name|op
parameter_list|,
name|nops
parameter_list|,
name|ops
parameter_list|,
name|enc
parameter_list|,
name|tag
parameter_list|)
define|\
value|{ #mnem, OPS##nops ops, tag, N_MNEM_##op, N_MNEM_##op,		\     ARM_VARIANT, THUMB_VARIANT, do_##enc, do_##enc }
end_define

begin_define
define|#
directive|define
name|nCE
parameter_list|(
name|mnem
parameter_list|,
name|op
parameter_list|,
name|nops
parameter_list|,
name|ops
parameter_list|,
name|enc
parameter_list|)
define|\
value|nCE_tag(mnem, op, nops, ops, enc, OT_csuffix)
end_define

begin_define
define|#
directive|define
name|nCEF
parameter_list|(
name|mnem
parameter_list|,
name|op
parameter_list|,
name|nops
parameter_list|,
name|ops
parameter_list|,
name|enc
parameter_list|)
define|\
value|nCE_tag(mnem, op, nops, ops, enc, OT_csuffixF)
end_define

begin_define
define|#
directive|define
name|do_0
value|0
end_define

begin_comment
comment|/* Thumb-only, unconditional.  */
end_comment

begin_define
define|#
directive|define
name|UT
parameter_list|(
name|mnem
parameter_list|,
name|op
parameter_list|,
name|nops
parameter_list|,
name|ops
parameter_list|,
name|te
parameter_list|)
value|TUE(mnem,  0, op, nops, ops, 0, te)
end_define

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|asm_opcode
name|insns
index|[]
init|=
block|{
define|#
directive|define
name|ARM_VARIANT
value|&arm_ext_v1
comment|/* Core ARM Instructions.  */
define|#
directive|define
name|THUMB_VARIANT
value|&arm_ext_v4t
name|tCE
argument_list|(
name|and
argument_list|,
literal|0000000
argument_list|,
name|and
argument_list|,
literal|3
argument_list|,
operator|(
name|RR
expr|,
name|oRR
expr|,
name|SH
operator|)
argument_list|,
name|arit
argument_list|,
name|t_arit3c
argument_list|)
block|,
name|tC3
argument_list|(
name|ands
argument_list|,
literal|0100000
argument_list|,
name|ands
argument_list|,
literal|3
argument_list|,
operator|(
name|RR
expr|,
name|oRR
expr|,
name|SH
operator|)
argument_list|,
name|arit
argument_list|,
name|t_arit3c
argument_list|)
block|,
name|tCE
argument_list|(
name|eor
argument_list|,
literal|0200000
argument_list|,
name|eor
argument_list|,
literal|3
argument_list|,
operator|(
name|RR
expr|,
name|oRR
expr|,
name|SH
operator|)
argument_list|,
name|arit
argument_list|,
name|t_arit3c
argument_list|)
block|,
name|tC3
argument_list|(
name|eors
argument_list|,
literal|0300000
argument_list|,
name|eors
argument_list|,
literal|3
argument_list|,
operator|(
name|RR
expr|,
name|oRR
expr|,
name|SH
operator|)
argument_list|,
name|arit
argument_list|,
name|t_arit3c
argument_list|)
block|,
name|tCE
argument_list|(
name|sub
argument_list|,
literal|0400000
argument_list|,
name|sub
argument_list|,
literal|3
argument_list|,
operator|(
name|RR
expr|,
name|oRR
expr|,
name|SH
operator|)
argument_list|,
name|arit
argument_list|,
name|t_add_sub
argument_list|)
block|,
name|tC3
argument_list|(
name|subs
argument_list|,
literal|0500000
argument_list|,
name|subs
argument_list|,
literal|3
argument_list|,
operator|(
name|RR
expr|,
name|oRR
expr|,
name|SH
operator|)
argument_list|,
name|arit
argument_list|,
name|t_add_sub
argument_list|)
block|,
name|tCE
argument_list|(
name|add
argument_list|,
literal|0800000
argument_list|,
name|add
argument_list|,
literal|3
argument_list|,
operator|(
name|RR
expr|,
name|oRR
expr|,
name|SHG
operator|)
argument_list|,
name|arit
argument_list|,
name|t_add_sub
argument_list|)
block|,
name|tC3
argument_list|(
name|adds
argument_list|,
literal|0900000
argument_list|,
name|adds
argument_list|,
literal|3
argument_list|,
operator|(
name|RR
expr|,
name|oRR
expr|,
name|SHG
operator|)
argument_list|,
name|arit
argument_list|,
name|t_add_sub
argument_list|)
block|,
name|tCE
argument_list|(
name|adc
argument_list|,
literal|0a00000
argument_list|,
name|adc
argument_list|,
literal|3
argument_list|,
operator|(
name|RR
expr|,
name|oRR
expr|,
name|SH
operator|)
argument_list|,
name|arit
argument_list|,
name|t_arit3c
argument_list|)
block|,
name|tC3
argument_list|(
name|adcs
argument_list|,
literal|0b00000
argument_list|,
name|adcs
argument_list|,
literal|3
argument_list|,
operator|(
name|RR
expr|,
name|oRR
expr|,
name|SH
operator|)
argument_list|,
name|arit
argument_list|,
name|t_arit3c
argument_list|)
block|,
name|tCE
argument_list|(
name|sbc
argument_list|,
literal|0c00000
argument_list|,
name|sbc
argument_list|,
literal|3
argument_list|,
operator|(
name|RR
expr|,
name|oRR
expr|,
name|SH
operator|)
argument_list|,
name|arit
argument_list|,
name|t_arit3
argument_list|)
block|,
name|tC3
argument_list|(
name|sbcs
argument_list|,
literal|0d00000
argument_list|,
name|sbcs
argument_list|,
literal|3
argument_list|,
operator|(
name|RR
expr|,
name|oRR
expr|,
name|SH
operator|)
argument_list|,
name|arit
argument_list|,
name|t_arit3
argument_list|)
block|,
name|tCE
argument_list|(
name|orr
argument_list|,
literal|1800000
argument_list|,
name|orr
argument_list|,
literal|3
argument_list|,
operator|(
name|RR
expr|,
name|oRR
expr|,
name|SH
operator|)
argument_list|,
name|arit
argument_list|,
name|t_arit3c
argument_list|)
block|,
name|tC3
argument_list|(
name|orrs
argument_list|,
literal|1900000
argument_list|,
name|orrs
argument_list|,
literal|3
argument_list|,
operator|(
name|RR
expr|,
name|oRR
expr|,
name|SH
operator|)
argument_list|,
name|arit
argument_list|,
name|t_arit3c
argument_list|)
block|,
name|tCE
argument_list|(
name|bic
argument_list|,
literal|1c00000
argument_list|,
name|bic
argument_list|,
literal|3
argument_list|,
operator|(
name|RR
expr|,
name|oRR
expr|,
name|SH
operator|)
argument_list|,
name|arit
argument_list|,
name|t_arit3
argument_list|)
block|,
name|tC3
argument_list|(
name|bics
argument_list|,
literal|1d00000
argument_list|,
name|bics
argument_list|,
literal|3
argument_list|,
operator|(
name|RR
expr|,
name|oRR
expr|,
name|SH
operator|)
argument_list|,
name|arit
argument_list|,
name|t_arit3
argument_list|)
block|,
comment|/* The p-variants of tst/cmp/cmn/teq (below) are the pre-V6 mechanism     for setting PSR flag bits.  They are obsolete in V6 and do not     have Thumb equivalents. */
name|tCE
argument_list|(
name|tst
argument_list|,
literal|1100000
argument_list|,
name|tst
argument_list|,
literal|2
argument_list|,
operator|(
name|RR
expr|,
name|SH
operator|)
argument_list|,
name|cmp
argument_list|,
name|t_mvn_tst
argument_list|)
block|,
name|tC3w
argument_list|(
name|tsts
argument_list|,
literal|1100000
argument_list|,
name|tst
argument_list|,
literal|2
argument_list|,
operator|(
name|RR
expr|,
name|SH
operator|)
argument_list|,
name|cmp
argument_list|,
name|t_mvn_tst
argument_list|)
block|,
name|CL
argument_list|(
name|tstp
argument_list|,
literal|110f000
argument_list|,
literal|2
argument_list|,
operator|(
name|RR
expr|,
name|SH
operator|)
argument_list|,
name|cmp
argument_list|)
block|,
name|tCE
argument_list|(
name|cmp
argument_list|,
literal|1500000
argument_list|,
name|cmp
argument_list|,
literal|2
argument_list|,
operator|(
name|RR
expr|,
name|SH
operator|)
argument_list|,
name|cmp
argument_list|,
name|t_mov_cmp
argument_list|)
block|,
name|tC3w
argument_list|(
name|cmps
argument_list|,
literal|1500000
argument_list|,
name|cmp
argument_list|,
literal|2
argument_list|,
operator|(
name|RR
expr|,
name|SH
operator|)
argument_list|,
name|cmp
argument_list|,
name|t_mov_cmp
argument_list|)
block|,
name|CL
argument_list|(
name|cmpp
argument_list|,
literal|150f000
argument_list|,
literal|2
argument_list|,
operator|(
name|RR
expr|,
name|SH
operator|)
argument_list|,
name|cmp
argument_list|)
block|,
name|tCE
argument_list|(
name|cmn
argument_list|,
literal|1700000
argument_list|,
name|cmn
argument_list|,
literal|2
argument_list|,
operator|(
name|RR
expr|,
name|SH
operator|)
argument_list|,
name|cmp
argument_list|,
name|t_mvn_tst
argument_list|)
block|,
name|tC3w
argument_list|(
name|cmns
argument_list|,
literal|1700000
argument_list|,
name|cmn
argument_list|,
literal|2
argument_list|,
operator|(
name|RR
expr|,
name|SH
operator|)
argument_list|,
name|cmp
argument_list|,
name|t_mvn_tst
argument_list|)
block|,
name|CL
argument_list|(
name|cmnp
argument_list|,
literal|170f000
argument_list|,
literal|2
argument_list|,
operator|(
name|RR
expr|,
name|SH
operator|)
argument_list|,
name|cmp
argument_list|)
block|,
name|tCE
argument_list|(
name|mov
argument_list|,
literal|1a00000
argument_list|,
name|mov
argument_list|,
literal|2
argument_list|,
operator|(
name|RR
expr|,
name|SH
operator|)
argument_list|,
name|mov
argument_list|,
name|t_mov_cmp
argument_list|)
block|,
name|tC3
argument_list|(
name|movs
argument_list|,
literal|1b00000
argument_list|,
name|movs
argument_list|,
literal|2
argument_list|,
operator|(
name|RR
expr|,
name|SH
operator|)
argument_list|,
name|mov
argument_list|,
name|t_mov_cmp
argument_list|)
block|,
name|tCE
argument_list|(
name|mvn
argument_list|,
literal|1e00000
argument_list|,
name|mvn
argument_list|,
literal|2
argument_list|,
operator|(
name|RR
expr|,
name|SH
operator|)
argument_list|,
name|mov
argument_list|,
name|t_mvn_tst
argument_list|)
block|,
name|tC3
argument_list|(
name|mvns
argument_list|,
literal|1f00000
argument_list|,
name|mvns
argument_list|,
literal|2
argument_list|,
operator|(
name|RR
expr|,
name|SH
operator|)
argument_list|,
name|mov
argument_list|,
name|t_mvn_tst
argument_list|)
block|,
name|tCE
argument_list|(
name|ldr
argument_list|,
literal|4100000
argument_list|,
name|ldr
argument_list|,
literal|2
argument_list|,
operator|(
name|RR
expr|,
name|ADDRGLDR
operator|)
argument_list|,
name|ldst
argument_list|,
name|t_ldst
argument_list|)
block|,
name|tC3
argument_list|(
name|ldrb
argument_list|,
literal|4500000
argument_list|,
name|ldrb
argument_list|,
literal|2
argument_list|,
operator|(
name|RR
expr|,
name|ADDRGLDR
operator|)
argument_list|,
name|ldst
argument_list|,
name|t_ldst
argument_list|)
block|,
name|tCE
argument_list|(
name|str
argument_list|,
literal|4000000
argument_list|,
name|str
argument_list|,
literal|2
argument_list|,
operator|(
name|RR
expr|,
name|ADDRGLDR
operator|)
argument_list|,
name|ldst
argument_list|,
name|t_ldst
argument_list|)
block|,
name|tC3
argument_list|(
name|strb
argument_list|,
literal|4400000
argument_list|,
name|strb
argument_list|,
literal|2
argument_list|,
operator|(
name|RR
expr|,
name|ADDRGLDR
operator|)
argument_list|,
name|ldst
argument_list|,
name|t_ldst
argument_list|)
block|,
name|tCE
argument_list|(
name|stm
argument_list|,
literal|8800000
argument_list|,
name|stmia
argument_list|,
literal|2
argument_list|,
operator|(
name|RRw
expr|,
name|REGLST
operator|)
argument_list|,
name|ldmstm
argument_list|,
name|t_ldmstm
argument_list|)
block|,
name|tC3
argument_list|(
name|stmia
argument_list|,
literal|8800000
argument_list|,
name|stmia
argument_list|,
literal|2
argument_list|,
operator|(
name|RRw
expr|,
name|REGLST
operator|)
argument_list|,
name|ldmstm
argument_list|,
name|t_ldmstm
argument_list|)
block|,
name|tC3
argument_list|(
name|stmea
argument_list|,
literal|8800000
argument_list|,
name|stmia
argument_list|,
literal|2
argument_list|,
operator|(
name|RRw
expr|,
name|REGLST
operator|)
argument_list|,
name|ldmstm
argument_list|,
name|t_ldmstm
argument_list|)
block|,
name|tCE
argument_list|(
name|ldm
argument_list|,
literal|8900000
argument_list|,
name|ldmia
argument_list|,
literal|2
argument_list|,
operator|(
name|RRw
expr|,
name|REGLST
operator|)
argument_list|,
name|ldmstm
argument_list|,
name|t_ldmstm
argument_list|)
block|,
name|tC3
argument_list|(
name|ldmia
argument_list|,
literal|8900000
argument_list|,
name|ldmia
argument_list|,
literal|2
argument_list|,
operator|(
name|RRw
expr|,
name|REGLST
operator|)
argument_list|,
name|ldmstm
argument_list|,
name|t_ldmstm
argument_list|)
block|,
name|tC3
argument_list|(
name|ldmfd
argument_list|,
literal|8900000
argument_list|,
name|ldmia
argument_list|,
literal|2
argument_list|,
operator|(
name|RRw
expr|,
name|REGLST
operator|)
argument_list|,
name|ldmstm
argument_list|,
name|t_ldmstm
argument_list|)
block|,
name|TCE
argument_list|(
name|swi
argument_list|,
name|f000000
argument_list|,
name|df00
argument_list|,
literal|1
argument_list|,
operator|(
name|EXPi
operator|)
argument_list|,
name|swi
argument_list|,
name|t_swi
argument_list|)
block|,
name|TCE
argument_list|(
name|svc
argument_list|,
name|f000000
argument_list|,
name|df00
argument_list|,
literal|1
argument_list|,
operator|(
name|EXPi
operator|)
argument_list|,
name|swi
argument_list|,
name|t_swi
argument_list|)
block|,
name|tCE
argument_list|(
name|b
argument_list|,
name|a000000
argument_list|,
name|b
argument_list|,
literal|1
argument_list|,
operator|(
name|EXPr
operator|)
argument_list|,
name|branch
argument_list|,
name|t_branch
argument_list|)
block|,
name|TCE
argument_list|(
name|bl
argument_list|,
name|b000000
argument_list|,
name|f000f800
argument_list|,
literal|1
argument_list|,
operator|(
name|EXPr
operator|)
argument_list|,
name|bl
argument_list|,
name|t_branch23
argument_list|)
block|,
comment|/* Pseudo ops.  */
name|tCE
argument_list|(
name|adr
argument_list|,
literal|28f0000
argument_list|,
name|adr
argument_list|,
literal|2
argument_list|,
operator|(
name|RR
expr|,
name|EXP
operator|)
argument_list|,
name|adr
argument_list|,
name|t_adr
argument_list|)
block|,
name|C3
argument_list|(
name|adrl
argument_list|,
literal|28f0000
argument_list|,
literal|2
argument_list|,
operator|(
name|RR
expr|,
name|EXP
operator|)
argument_list|,
name|adrl
argument_list|)
block|,
name|tCE
argument_list|(
name|nop
argument_list|,
literal|1a00000
argument_list|,
name|nop
argument_list|,
literal|1
argument_list|,
operator|(
name|oI255c
operator|)
argument_list|,
name|nop
argument_list|,
name|t_nop
argument_list|)
block|,
comment|/* Thumb-compatibility pseudo ops.  */
name|tCE
argument_list|(
name|lsl
argument_list|,
literal|1a00000
argument_list|,
name|lsl
argument_list|,
literal|3
argument_list|,
operator|(
name|RR
expr|,
name|oRR
expr|,
name|SH
operator|)
argument_list|,
name|shift
argument_list|,
name|t_shift
argument_list|)
block|,
name|tC3
argument_list|(
name|lsls
argument_list|,
literal|1b00000
argument_list|,
name|lsls
argument_list|,
literal|3
argument_list|,
operator|(
name|RR
expr|,
name|oRR
expr|,
name|SH
operator|)
argument_list|,
name|shift
argument_list|,
name|t_shift
argument_list|)
block|,
name|tCE
argument_list|(
name|lsr
argument_list|,
literal|1a00020
argument_list|,
name|lsr
argument_list|,
literal|3
argument_list|,
operator|(
name|RR
expr|,
name|oRR
expr|,
name|SH
operator|)
argument_list|,
name|shift
argument_list|,
name|t_shift
argument_list|)
block|,
name|tC3
argument_list|(
name|lsrs
argument_list|,
literal|1b00020
argument_list|,
name|lsrs
argument_list|,
literal|3
argument_list|,
operator|(
name|RR
expr|,
name|oRR
expr|,
name|SH
operator|)
argument_list|,
name|shift
argument_list|,
name|t_shift
argument_list|)
block|,
name|tCE
argument_list|(
name|asr
argument_list|,
literal|1a00040
argument_list|,
name|asr
argument_list|,
literal|3
argument_list|,
operator|(
name|RR
expr|,
name|oRR
expr|,
name|SH
operator|)
argument_list|,
name|shift
argument_list|,
name|t_shift
argument_list|)
block|,
name|tC3
argument_list|(
name|asrs
argument_list|,
literal|1b00040
argument_list|,
name|asrs
argument_list|,
literal|3
argument_list|,
operator|(
name|RR
expr|,
name|oRR
expr|,
name|SH
operator|)
argument_list|,
name|shift
argument_list|,
name|t_shift
argument_list|)
block|,
name|tCE
argument_list|(
name|ror
argument_list|,
literal|1a00060
argument_list|,
name|ror
argument_list|,
literal|3
argument_list|,
operator|(
name|RR
expr|,
name|oRR
expr|,
name|SH
operator|)
argument_list|,
name|shift
argument_list|,
name|t_shift
argument_list|)
block|,
name|tC3
argument_list|(
name|rors
argument_list|,
literal|1b00060
argument_list|,
name|rors
argument_list|,
literal|3
argument_list|,
operator|(
name|RR
expr|,
name|oRR
expr|,
name|SH
operator|)
argument_list|,
name|shift
argument_list|,
name|t_shift
argument_list|)
block|,
name|tCE
argument_list|(
name|neg
argument_list|,
literal|2600000
argument_list|,
name|neg
argument_list|,
literal|2
argument_list|,
operator|(
name|RR
expr|,
name|RR
operator|)
argument_list|,
name|rd_rn
argument_list|,
name|t_neg
argument_list|)
block|,
name|tC3
argument_list|(
name|negs
argument_list|,
literal|2700000
argument_list|,
name|negs
argument_list|,
literal|2
argument_list|,
operator|(
name|RR
expr|,
name|RR
operator|)
argument_list|,
name|rd_rn
argument_list|,
name|t_neg
argument_list|)
block|,
name|tCE
argument_list|(
name|push
argument_list|,
literal|92d0000
argument_list|,
name|push
argument_list|,
literal|1
argument_list|,
operator|(
name|REGLST
operator|)
argument_list|,
name|push_pop
argument_list|,
name|t_push_pop
argument_list|)
block|,
name|tCE
argument_list|(
name|pop
argument_list|,
literal|8bd0000
argument_list|,
name|pop
argument_list|,
literal|1
argument_list|,
operator|(
name|REGLST
operator|)
argument_list|,
name|push_pop
argument_list|,
name|t_push_pop
argument_list|)
block|,
comment|/* These may simplify to neg.  */
name|TCE
argument_list|(
name|rsb
argument_list|,
literal|0600000
argument_list|,
name|ebc00000
argument_list|,
literal|3
argument_list|,
operator|(
name|RR
expr|,
name|oRR
expr|,
name|SH
operator|)
argument_list|,
name|arit
argument_list|,
name|t_rsb
argument_list|)
block|,
name|TC3
argument_list|(
name|rsbs
argument_list|,
literal|0700000
argument_list|,
name|ebd00000
argument_list|,
literal|3
argument_list|,
operator|(
name|RR
expr|,
name|oRR
expr|,
name|SH
operator|)
argument_list|,
name|arit
argument_list|,
name|t_rsb
argument_list|)
block|,
name|TCE
argument_list|(
name|rrx
argument_list|,
literal|1a00060
argument_list|,
name|ea4f0030
argument_list|,
literal|2
argument_list|,
operator|(
name|RR
expr|,
name|RR
operator|)
argument_list|,
name|rd_rm
argument_list|,
name|t_rd_rm
argument_list|)
block|,
name|TCE
argument_list|(
name|rrxs
argument_list|,
literal|1b00060
argument_list|,
name|ea5f0030
argument_list|,
literal|2
argument_list|,
operator|(
name|RR
expr|,
name|RR
operator|)
argument_list|,
name|rd_rm
argument_list|,
name|t_rd_rm
argument_list|)
block|,
undef|#
directive|undef
name|THUMB_VARIANT
define|#
directive|define
name|THUMB_VARIANT
value|&arm_ext_v6
name|TCE
argument_list|(
name|cpy
argument_list|,
literal|1a00000
argument_list|,
literal|4600
argument_list|,
literal|2
argument_list|,
operator|(
name|RR
expr|,
name|RR
operator|)
argument_list|,
name|rd_rm
argument_list|,
name|t_cpy
argument_list|)
block|,
comment|/* V1 instructions with no Thumb analogue prior to V6T2.  */
undef|#
directive|undef
name|THUMB_VARIANT
define|#
directive|define
name|THUMB_VARIANT
value|&arm_ext_v6t2
name|TCE
argument_list|(
name|teq
argument_list|,
literal|1300000
argument_list|,
name|ea900f00
argument_list|,
literal|2
argument_list|,
operator|(
name|RR
expr|,
name|SH
operator|)
argument_list|,
name|cmp
argument_list|,
name|t_mvn_tst
argument_list|)
block|,
name|TC3w
argument_list|(
name|teqs
argument_list|,
literal|1300000
argument_list|,
name|ea900f00
argument_list|,
literal|2
argument_list|,
operator|(
name|RR
expr|,
name|SH
operator|)
argument_list|,
name|cmp
argument_list|,
name|t_mvn_tst
argument_list|)
block|,
name|CL
argument_list|(
name|teqp
argument_list|,
literal|130f000
argument_list|,
literal|2
argument_list|,
operator|(
name|RR
expr|,
name|SH
operator|)
argument_list|,
name|cmp
argument_list|)
block|,
name|TC3
argument_list|(
name|ldrt
argument_list|,
literal|4300000
argument_list|,
name|f8500e00
argument_list|,
literal|2
argument_list|,
operator|(
name|RR
expr|,
name|ADDR
operator|)
argument_list|,
name|ldstt
argument_list|,
name|t_ldstt
argument_list|)
block|,
name|TC3
argument_list|(
name|ldrbt
argument_list|,
literal|4700000
argument_list|,
name|f8100e00
argument_list|,
literal|2
argument_list|,
operator|(
name|RR
expr|,
name|ADDR
operator|)
argument_list|,
name|ldstt
argument_list|,
name|t_ldstt
argument_list|)
block|,
name|TC3
argument_list|(
name|strt
argument_list|,
literal|4200000
argument_list|,
name|f8400e00
argument_list|,
literal|2
argument_list|,
operator|(
name|RR
expr|,
name|ADDR
operator|)
argument_list|,
name|ldstt
argument_list|,
name|t_ldstt
argument_list|)
block|,
name|TC3
argument_list|(
name|strbt
argument_list|,
literal|4600000
argument_list|,
name|f8000e00
argument_list|,
literal|2
argument_list|,
operator|(
name|RR
expr|,
name|ADDR
operator|)
argument_list|,
name|ldstt
argument_list|,
name|t_ldstt
argument_list|)
block|,
name|TC3
argument_list|(
name|stmdb
argument_list|,
literal|9000000
argument_list|,
name|e9000000
argument_list|,
literal|2
argument_list|,
operator|(
name|RRw
expr|,
name|REGLST
operator|)
argument_list|,
name|ldmstm
argument_list|,
name|t_ldmstm
argument_list|)
block|,
name|TC3
argument_list|(
name|stmfd
argument_list|,
literal|9000000
argument_list|,
name|e9000000
argument_list|,
literal|2
argument_list|,
operator|(
name|RRw
expr|,
name|REGLST
operator|)
argument_list|,
name|ldmstm
argument_list|,
name|t_ldmstm
argument_list|)
block|,
name|TC3
argument_list|(
name|ldmdb
argument_list|,
literal|9100000
argument_list|,
name|e9100000
argument_list|,
literal|2
argument_list|,
operator|(
name|RRw
expr|,
name|REGLST
operator|)
argument_list|,
name|ldmstm
argument_list|,
name|t_ldmstm
argument_list|)
block|,
name|TC3
argument_list|(
name|ldmea
argument_list|,
literal|9100000
argument_list|,
name|e9100000
argument_list|,
literal|2
argument_list|,
operator|(
name|RRw
expr|,
name|REGLST
operator|)
argument_list|,
name|ldmstm
argument_list|,
name|t_ldmstm
argument_list|)
block|,
comment|/* V1 instructions with no Thumb analogue at all.  */
name|CE
argument_list|(
name|rsc
argument_list|,
literal|0e00000
argument_list|,
literal|3
argument_list|,
operator|(
name|RR
expr|,
name|oRR
expr|,
name|SH
operator|)
argument_list|,
name|arit
argument_list|)
block|,
name|C3
argument_list|(
name|rscs
argument_list|,
literal|0f00000
argument_list|,
literal|3
argument_list|,
operator|(
name|RR
expr|,
name|oRR
expr|,
name|SH
operator|)
argument_list|,
name|arit
argument_list|)
block|,
name|C3
argument_list|(
name|stmib
argument_list|,
literal|9800000
argument_list|,
literal|2
argument_list|,
operator|(
name|RRw
expr|,
name|REGLST
operator|)
argument_list|,
name|ldmstm
argument_list|)
block|,
name|C3
argument_list|(
name|stmfa
argument_list|,
literal|9800000
argument_list|,
literal|2
argument_list|,
operator|(
name|RRw
expr|,
name|REGLST
operator|)
argument_list|,
name|ldmstm
argument_list|)
block|,
name|C3
argument_list|(
name|stmda
argument_list|,
literal|8000000
argument_list|,
literal|2
argument_list|,
operator|(
name|RRw
expr|,
name|REGLST
operator|)
argument_list|,
name|ldmstm
argument_list|)
block|,
name|C3
argument_list|(
name|stmed
argument_list|,
literal|8000000
argument_list|,
literal|2
argument_list|,
operator|(
name|RRw
expr|,
name|REGLST
operator|)
argument_list|,
name|ldmstm
argument_list|)
block|,
name|C3
argument_list|(
name|ldmib
argument_list|,
literal|9900000
argument_list|,
literal|2
argument_list|,
operator|(
name|RRw
expr|,
name|REGLST
operator|)
argument_list|,
name|ldmstm
argument_list|)
block|,
name|C3
argument_list|(
name|ldmed
argument_list|,
literal|9900000
argument_list|,
literal|2
argument_list|,
operator|(
name|RRw
expr|,
name|REGLST
operator|)
argument_list|,
name|ldmstm
argument_list|)
block|,
name|C3
argument_list|(
name|ldmda
argument_list|,
literal|8100000
argument_list|,
literal|2
argument_list|,
operator|(
name|RRw
expr|,
name|REGLST
operator|)
argument_list|,
name|ldmstm
argument_list|)
block|,
name|C3
argument_list|(
name|ldmfa
argument_list|,
literal|8100000
argument_list|,
literal|2
argument_list|,
operator|(
name|RRw
expr|,
name|REGLST
operator|)
argument_list|,
name|ldmstm
argument_list|)
block|,
undef|#
directive|undef
name|ARM_VARIANT
define|#
directive|define
name|ARM_VARIANT
value|&arm_ext_v2
comment|/* ARM 2 - multiplies.	*/
undef|#
directive|undef
name|THUMB_VARIANT
define|#
directive|define
name|THUMB_VARIANT
value|&arm_ext_v4t
name|tCE
argument_list|(
name|mul
argument_list|,
literal|0000090
argument_list|,
name|mul
argument_list|,
literal|3
argument_list|,
operator|(
name|RRnpc
expr|,
name|RRnpc
expr|,
name|oRR
operator|)
argument_list|,
name|mul
argument_list|,
name|t_mul
argument_list|)
block|,
name|tC3
argument_list|(
name|muls
argument_list|,
literal|0100090
argument_list|,
name|muls
argument_list|,
literal|3
argument_list|,
operator|(
name|RRnpc
expr|,
name|RRnpc
expr|,
name|oRR
operator|)
argument_list|,
name|mul
argument_list|,
name|t_mul
argument_list|)
block|,
undef|#
directive|undef
name|THUMB_VARIANT
define|#
directive|define
name|THUMB_VARIANT
value|&arm_ext_v6t2
name|TCE
argument_list|(
name|mla
argument_list|,
literal|0200090
argument_list|,
name|fb000000
argument_list|,
literal|4
argument_list|,
operator|(
name|RRnpc
expr|,
name|RRnpc
expr|,
name|RRnpc
expr|,
name|RRnpc
operator|)
argument_list|,
name|mlas
argument_list|,
name|t_mla
argument_list|)
block|,
name|C3
argument_list|(
name|mlas
argument_list|,
literal|0300090
argument_list|,
literal|4
argument_list|,
operator|(
name|RRnpc
expr|,
name|RRnpc
expr|,
name|RRnpc
expr|,
name|RRnpc
operator|)
argument_list|,
name|mlas
argument_list|)
block|,
comment|/* Generic coprocessor instructions.	*/
name|TCE
argument_list|(
name|cdp
argument_list|,
name|e000000
argument_list|,
name|ee000000
argument_list|,
literal|6
argument_list|,
operator|(
name|RCP
expr|,
name|I15b
expr|,
name|RCN
expr|,
name|RCN
expr|,
name|RCN
expr|,
name|oI7b
operator|)
argument_list|,
name|cdp
argument_list|,
name|cdp
argument_list|)
block|,
name|TCE
argument_list|(
name|ldc
argument_list|,
name|c100000
argument_list|,
name|ec100000
argument_list|,
literal|3
argument_list|,
operator|(
name|RCP
expr|,
name|RCN
expr|,
name|ADDRGLDC
operator|)
argument_list|,
name|lstc
argument_list|,
name|lstc
argument_list|)
block|,
name|TC3
argument_list|(
name|ldcl
argument_list|,
name|c500000
argument_list|,
name|ec500000
argument_list|,
literal|3
argument_list|,
operator|(
name|RCP
expr|,
name|RCN
expr|,
name|ADDRGLDC
operator|)
argument_list|,
name|lstc
argument_list|,
name|lstc
argument_list|)
block|,
name|TCE
argument_list|(
name|stc
argument_list|,
name|c000000
argument_list|,
name|ec000000
argument_list|,
literal|3
argument_list|,
operator|(
name|RCP
expr|,
name|RCN
expr|,
name|ADDRGLDC
operator|)
argument_list|,
name|lstc
argument_list|,
name|lstc
argument_list|)
block|,
name|TC3
argument_list|(
name|stcl
argument_list|,
name|c400000
argument_list|,
name|ec400000
argument_list|,
literal|3
argument_list|,
operator|(
name|RCP
expr|,
name|RCN
expr|,
name|ADDRGLDC
operator|)
argument_list|,
name|lstc
argument_list|,
name|lstc
argument_list|)
block|,
name|TCE
argument_list|(
name|mcr
argument_list|,
name|e000010
argument_list|,
name|ee000010
argument_list|,
literal|6
argument_list|,
operator|(
name|RCP
expr|,
name|I7b
expr|,
name|RR
expr|,
name|RCN
expr|,
name|RCN
expr|,
name|oI7b
operator|)
argument_list|,
name|co_reg
argument_list|,
name|co_reg
argument_list|)
block|,
name|TCE
argument_list|(
name|mrc
argument_list|,
name|e100010
argument_list|,
name|ee100010
argument_list|,
literal|6
argument_list|,
operator|(
name|RCP
expr|,
name|I7b
expr|,
name|APSR_RR
expr|,
name|RCN
expr|,
name|RCN
expr|,
name|oI7b
operator|)
argument_list|,
name|co_reg
argument_list|,
name|co_reg
argument_list|)
block|,
undef|#
directive|undef
name|ARM_VARIANT
define|#
directive|define
name|ARM_VARIANT
value|&arm_ext_v2s
comment|/* ARM 3 - swp instructions.  */
name|CE
argument_list|(
name|swp
argument_list|,
literal|1000090
argument_list|,
literal|3
argument_list|,
operator|(
name|RRnpc
expr|,
name|RRnpc
expr|,
name|RRnpcb
operator|)
argument_list|,
name|rd_rm_rn
argument_list|)
block|,
name|C3
argument_list|(
name|swpb
argument_list|,
literal|1400090
argument_list|,
literal|3
argument_list|,
operator|(
name|RRnpc
expr|,
name|RRnpc
expr|,
name|RRnpcb
operator|)
argument_list|,
name|rd_rm_rn
argument_list|)
block|,
undef|#
directive|undef
name|ARM_VARIANT
define|#
directive|define
name|ARM_VARIANT
value|&arm_ext_v3
comment|/* ARM 6 Status register instructions.	*/
name|TCE
argument_list|(
name|mrs
argument_list|,
literal|10f0000
argument_list|,
name|f3ef8000
argument_list|,
literal|2
argument_list|,
operator|(
name|APSR_RR
expr|,
name|RVC_PSR
operator|)
argument_list|,
name|mrs
argument_list|,
name|t_mrs
argument_list|)
block|,
name|TCE
argument_list|(
name|msr
argument_list|,
literal|120f000
argument_list|,
name|f3808000
argument_list|,
literal|2
argument_list|,
operator|(
name|RVC_PSR
expr|,
name|RR_EXi
operator|)
argument_list|,
name|msr
argument_list|,
name|t_msr
argument_list|)
block|,
undef|#
directive|undef
name|ARM_VARIANT
define|#
directive|define
name|ARM_VARIANT
value|&arm_ext_v3m
comment|/* ARM 7M long multiplies.  */
name|TCE
argument_list|(
name|smull
argument_list|,
literal|0c00090
argument_list|,
name|fb800000
argument_list|,
literal|4
argument_list|,
operator|(
name|RRnpc
expr|,
name|RRnpc
expr|,
name|RRnpc
expr|,
name|RRnpc
operator|)
argument_list|,
name|mull
argument_list|,
name|t_mull
argument_list|)
block|,
name|CM
argument_list|(
name|smull
argument_list|,
name|s
argument_list|,
literal|0d00090
argument_list|,
literal|4
argument_list|,
operator|(
name|RRnpc
expr|,
name|RRnpc
expr|,
name|RRnpc
expr|,
name|RRnpc
operator|)
argument_list|,
name|mull
argument_list|)
block|,
name|TCE
argument_list|(
name|umull
argument_list|,
literal|0800090
argument_list|,
name|fba00000
argument_list|,
literal|4
argument_list|,
operator|(
name|RRnpc
expr|,
name|RRnpc
expr|,
name|RRnpc
expr|,
name|RRnpc
operator|)
argument_list|,
name|mull
argument_list|,
name|t_mull
argument_list|)
block|,
name|CM
argument_list|(
name|umull
argument_list|,
name|s
argument_list|,
literal|0900090
argument_list|,
literal|4
argument_list|,
operator|(
name|RRnpc
expr|,
name|RRnpc
expr|,
name|RRnpc
expr|,
name|RRnpc
operator|)
argument_list|,
name|mull
argument_list|)
block|,
name|TCE
argument_list|(
name|smlal
argument_list|,
literal|0e00090
argument_list|,
name|fbc00000
argument_list|,
literal|4
argument_list|,
operator|(
name|RRnpc
expr|,
name|RRnpc
expr|,
name|RRnpc
expr|,
name|RRnpc
operator|)
argument_list|,
name|mull
argument_list|,
name|t_mull
argument_list|)
block|,
name|CM
argument_list|(
name|smlal
argument_list|,
name|s
argument_list|,
literal|0f00090
argument_list|,
literal|4
argument_list|,
operator|(
name|RRnpc
expr|,
name|RRnpc
expr|,
name|RRnpc
expr|,
name|RRnpc
operator|)
argument_list|,
name|mull
argument_list|)
block|,
name|TCE
argument_list|(
name|umlal
argument_list|,
literal|0a00090
argument_list|,
name|fbe00000
argument_list|,
literal|4
argument_list|,
operator|(
name|RRnpc
expr|,
name|RRnpc
expr|,
name|RRnpc
expr|,
name|RRnpc
operator|)
argument_list|,
name|mull
argument_list|,
name|t_mull
argument_list|)
block|,
name|CM
argument_list|(
name|umlal
argument_list|,
name|s
argument_list|,
literal|0b00090
argument_list|,
literal|4
argument_list|,
operator|(
name|RRnpc
expr|,
name|RRnpc
expr|,
name|RRnpc
expr|,
name|RRnpc
operator|)
argument_list|,
name|mull
argument_list|)
block|,
undef|#
directive|undef
name|ARM_VARIANT
define|#
directive|define
name|ARM_VARIANT
value|&arm_ext_v4
comment|/* ARM Architecture 4.	*/
undef|#
directive|undef
name|THUMB_VARIANT
define|#
directive|define
name|THUMB_VARIANT
value|&arm_ext_v4t
name|tC3
argument_list|(
name|ldrh
argument_list|,
literal|01000b0
argument_list|,
name|ldrh
argument_list|,
literal|2
argument_list|,
operator|(
name|RR
expr|,
name|ADDRGLDRS
operator|)
argument_list|,
name|ldstv4
argument_list|,
name|t_ldst
argument_list|)
block|,
name|tC3
argument_list|(
name|strh
argument_list|,
literal|00000b0
argument_list|,
name|strh
argument_list|,
literal|2
argument_list|,
operator|(
name|RR
expr|,
name|ADDRGLDRS
operator|)
argument_list|,
name|ldstv4
argument_list|,
name|t_ldst
argument_list|)
block|,
name|tC3
argument_list|(
name|ldrsh
argument_list|,
literal|01000f0
argument_list|,
name|ldrsh
argument_list|,
literal|2
argument_list|,
operator|(
name|RR
expr|,
name|ADDRGLDRS
operator|)
argument_list|,
name|ldstv4
argument_list|,
name|t_ldst
argument_list|)
block|,
name|tC3
argument_list|(
name|ldrsb
argument_list|,
literal|01000d0
argument_list|,
name|ldrsb
argument_list|,
literal|2
argument_list|,
operator|(
name|RR
expr|,
name|ADDRGLDRS
operator|)
argument_list|,
name|ldstv4
argument_list|,
name|t_ldst
argument_list|)
block|,
name|tCM
argument_list|(
name|ld
argument_list|,
name|sh
argument_list|,
literal|01000f0
argument_list|,
name|ldrsh
argument_list|,
literal|2
argument_list|,
operator|(
name|RR
expr|,
name|ADDRGLDRS
operator|)
argument_list|,
name|ldstv4
argument_list|,
name|t_ldst
argument_list|)
block|,
name|tCM
argument_list|(
name|ld
argument_list|,
name|sb
argument_list|,
literal|01000d0
argument_list|,
name|ldrsb
argument_list|,
literal|2
argument_list|,
operator|(
name|RR
expr|,
name|ADDRGLDRS
operator|)
argument_list|,
name|ldstv4
argument_list|,
name|t_ldst
argument_list|)
block|,
undef|#
directive|undef
name|ARM_VARIANT
define|#
directive|define
name|ARM_VARIANT
value|&arm_ext_v4t_5
comment|/* ARM Architecture 4T.  */
comment|/* Note: bx (and blx) are required on V5, even if the processor does      not support Thumb.	 */
name|TCE
argument_list|(
name|bx
argument_list|,
literal|12fff10
argument_list|,
literal|4700
argument_list|,
literal|1
argument_list|,
operator|(
name|RR
operator|)
argument_list|,
name|bx
argument_list|,
name|t_bx
argument_list|)
block|,
undef|#
directive|undef
name|ARM_VARIANT
define|#
directive|define
name|ARM_VARIANT
value|&arm_ext_v5
comment|/*  ARM Architecture 5T.	 */
undef|#
directive|undef
name|THUMB_VARIANT
define|#
directive|define
name|THUMB_VARIANT
value|&arm_ext_v5t
comment|/* Note: blx has 2 variants; the .value coded here is for      BLX(2).  Only this variant has conditional execution.  */
name|TCE
argument_list|(
name|blx
argument_list|,
literal|12fff30
argument_list|,
literal|4780
argument_list|,
literal|1
argument_list|,
operator|(
name|RR_EXr
operator|)
argument_list|,
name|blx
argument_list|,
name|t_blx
argument_list|)
block|,
name|TUE
argument_list|(
name|bkpt
argument_list|,
literal|1200070
argument_list|,
name|be00
argument_list|,
literal|1
argument_list|,
operator|(
name|oIffffb
operator|)
argument_list|,
name|bkpt
argument_list|,
name|t_bkpt
argument_list|)
block|,
undef|#
directive|undef
name|THUMB_VARIANT
define|#
directive|define
name|THUMB_VARIANT
value|&arm_ext_v6t2
name|TCE
argument_list|(
name|clz
argument_list|,
literal|16f0f10
argument_list|,
name|fab0f080
argument_list|,
literal|2
argument_list|,
operator|(
name|RRnpc
expr|,
name|RRnpc
operator|)
argument_list|,
name|rd_rm
argument_list|,
name|t_clz
argument_list|)
block|,
name|TUF
argument_list|(
name|ldc2
argument_list|,
name|c100000
argument_list|,
name|fc100000
argument_list|,
literal|3
argument_list|,
operator|(
name|RCP
expr|,
name|RCN
expr|,
name|ADDRGLDC
operator|)
argument_list|,
name|lstc
argument_list|,
name|lstc
argument_list|)
block|,
name|TUF
argument_list|(
name|ldc2l
argument_list|,
name|c500000
argument_list|,
name|fc500000
argument_list|,
literal|3
argument_list|,
operator|(
name|RCP
expr|,
name|RCN
expr|,
name|ADDRGLDC
operator|)
argument_list|,
name|lstc
argument_list|,
name|lstc
argument_list|)
block|,
name|TUF
argument_list|(
name|stc2
argument_list|,
name|c000000
argument_list|,
name|fc000000
argument_list|,
literal|3
argument_list|,
operator|(
name|RCP
expr|,
name|RCN
expr|,
name|ADDRGLDC
operator|)
argument_list|,
name|lstc
argument_list|,
name|lstc
argument_list|)
block|,
name|TUF
argument_list|(
name|stc2l
argument_list|,
name|c400000
argument_list|,
name|fc400000
argument_list|,
literal|3
argument_list|,
operator|(
name|RCP
expr|,
name|RCN
expr|,
name|ADDRGLDC
operator|)
argument_list|,
name|lstc
argument_list|,
name|lstc
argument_list|)
block|,
name|TUF
argument_list|(
name|cdp2
argument_list|,
name|e000000
argument_list|,
name|fe000000
argument_list|,
literal|6
argument_list|,
operator|(
name|RCP
expr|,
name|I15b
expr|,
name|RCN
expr|,
name|RCN
expr|,
name|RCN
expr|,
name|oI7b
operator|)
argument_list|,
name|cdp
argument_list|,
name|cdp
argument_list|)
block|,
name|TUF
argument_list|(
name|mcr2
argument_list|,
name|e000010
argument_list|,
name|fe000010
argument_list|,
literal|6
argument_list|,
operator|(
name|RCP
expr|,
name|I7b
expr|,
name|RR
expr|,
name|RCN
expr|,
name|RCN
expr|,
name|oI7b
operator|)
argument_list|,
name|co_reg
argument_list|,
name|co_reg
argument_list|)
block|,
name|TUF
argument_list|(
name|mrc2
argument_list|,
name|e100010
argument_list|,
name|fe100010
argument_list|,
literal|6
argument_list|,
operator|(
name|RCP
expr|,
name|I7b
expr|,
name|APSR_RR
expr|,
name|RCN
expr|,
name|RCN
expr|,
name|oI7b
operator|)
argument_list|,
name|co_reg
argument_list|,
name|co_reg
argument_list|)
block|,
undef|#
directive|undef
name|ARM_VARIANT
define|#
directive|define
name|ARM_VARIANT
value|&arm_ext_v5exp
comment|/*  ARM Architecture 5TExP.  */
name|TCE
argument_list|(
name|smlabb
argument_list|,
literal|1000080
argument_list|,
name|fb100000
argument_list|,
literal|4
argument_list|,
operator|(
name|RRnpc
expr|,
name|RRnpc
expr|,
name|RRnpc
expr|,
name|RRnpc
operator|)
argument_list|,
name|smla
argument_list|,
name|t_mla
argument_list|)
block|,
name|TCE
argument_list|(
name|smlatb
argument_list|,
literal|10000a0
argument_list|,
name|fb100020
argument_list|,
literal|4
argument_list|,
operator|(
name|RRnpc
expr|,
name|RRnpc
expr|,
name|RRnpc
expr|,
name|RRnpc
operator|)
argument_list|,
name|smla
argument_list|,
name|t_mla
argument_list|)
block|,
name|TCE
argument_list|(
name|smlabt
argument_list|,
literal|10000c0
argument_list|,
name|fb100010
argument_list|,
literal|4
argument_list|,
operator|(
name|RRnpc
expr|,
name|RRnpc
expr|,
name|RRnpc
expr|,
name|RRnpc
operator|)
argument_list|,
name|smla
argument_list|,
name|t_mla
argument_list|)
block|,
name|TCE
argument_list|(
name|smlatt
argument_list|,
literal|10000e0
argument_list|,
name|fb100030
argument_list|,
literal|4
argument_list|,
operator|(
name|RRnpc
expr|,
name|RRnpc
expr|,
name|RRnpc
expr|,
name|RRnpc
operator|)
argument_list|,
name|smla
argument_list|,
name|t_mla
argument_list|)
block|,
name|TCE
argument_list|(
name|smlawb
argument_list|,
literal|1200080
argument_list|,
name|fb300000
argument_list|,
literal|4
argument_list|,
operator|(
name|RRnpc
expr|,
name|RRnpc
expr|,
name|RRnpc
expr|,
name|RRnpc
operator|)
argument_list|,
name|smla
argument_list|,
name|t_mla
argument_list|)
block|,
name|TCE
argument_list|(
name|smlawt
argument_list|,
literal|12000c0
argument_list|,
name|fb300010
argument_list|,
literal|4
argument_list|,
operator|(
name|RRnpc
expr|,
name|RRnpc
expr|,
name|RRnpc
expr|,
name|RRnpc
operator|)
argument_list|,
name|smla
argument_list|,
name|t_mla
argument_list|)
block|,
name|TCE
argument_list|(
name|smlalbb
argument_list|,
literal|1400080
argument_list|,
name|fbc00080
argument_list|,
literal|4
argument_list|,
operator|(
name|RRnpc
expr|,
name|RRnpc
expr|,
name|RRnpc
expr|,
name|RRnpc
operator|)
argument_list|,
name|smlal
argument_list|,
name|t_mlal
argument_list|)
block|,
name|TCE
argument_list|(
name|smlaltb
argument_list|,
literal|14000a0
argument_list|,
name|fbc000a0
argument_list|,
literal|4
argument_list|,
operator|(
name|RRnpc
expr|,
name|RRnpc
expr|,
name|RRnpc
expr|,
name|RRnpc
operator|)
argument_list|,
name|smlal
argument_list|,
name|t_mlal
argument_list|)
block|,
name|TCE
argument_list|(
name|smlalbt
argument_list|,
literal|14000c0
argument_list|,
name|fbc00090
argument_list|,
literal|4
argument_list|,
operator|(
name|RRnpc
expr|,
name|RRnpc
expr|,
name|RRnpc
expr|,
name|RRnpc
operator|)
argument_list|,
name|smlal
argument_list|,
name|t_mlal
argument_list|)
block|,
name|TCE
argument_list|(
name|smlaltt
argument_list|,
literal|14000e0
argument_list|,
name|fbc000b0
argument_list|,
literal|4
argument_list|,
operator|(
name|RRnpc
expr|,
name|RRnpc
expr|,
name|RRnpc
expr|,
name|RRnpc
operator|)
argument_list|,
name|smlal
argument_list|,
name|t_mlal
argument_list|)
block|,
name|TCE
argument_list|(
name|smulbb
argument_list|,
literal|1600080
argument_list|,
name|fb10f000
argument_list|,
literal|3
argument_list|,
operator|(
name|RRnpc
expr|,
name|RRnpc
expr|,
name|RRnpc
operator|)
argument_list|,
name|smul
argument_list|,
name|t_simd
argument_list|)
block|,
name|TCE
argument_list|(
name|smultb
argument_list|,
literal|16000a0
argument_list|,
name|fb10f020
argument_list|,
literal|3
argument_list|,
operator|(
name|RRnpc
expr|,
name|RRnpc
expr|,
name|RRnpc
operator|)
argument_list|,
name|smul
argument_list|,
name|t_simd
argument_list|)
block|,
name|TCE
argument_list|(
name|smulbt
argument_list|,
literal|16000c0
argument_list|,
name|fb10f010
argument_list|,
literal|3
argument_list|,
operator|(
name|RRnpc
expr|,
name|RRnpc
expr|,
name|RRnpc
operator|)
argument_list|,
name|smul
argument_list|,
name|t_simd
argument_list|)
block|,
name|TCE
argument_list|(
name|smultt
argument_list|,
literal|16000e0
argument_list|,
name|fb10f030
argument_list|,
literal|3
argument_list|,
operator|(
name|RRnpc
expr|,
name|RRnpc
expr|,
name|RRnpc
operator|)
argument_list|,
name|smul
argument_list|,
name|t_simd
argument_list|)
block|,
name|TCE
argument_list|(
name|smulwb
argument_list|,
literal|12000a0
argument_list|,
name|fb30f000
argument_list|,
literal|3
argument_list|,
operator|(
name|RRnpc
expr|,
name|RRnpc
expr|,
name|RRnpc
operator|)
argument_list|,
name|smul
argument_list|,
name|t_simd
argument_list|)
block|,
name|TCE
argument_list|(
name|smulwt
argument_list|,
literal|12000e0
argument_list|,
name|fb30f010
argument_list|,
literal|3
argument_list|,
operator|(
name|RRnpc
expr|,
name|RRnpc
expr|,
name|RRnpc
operator|)
argument_list|,
name|smul
argument_list|,
name|t_simd
argument_list|)
block|,
name|TCE
argument_list|(
name|qadd
argument_list|,
literal|1000050
argument_list|,
name|fa80f080
argument_list|,
literal|3
argument_list|,
operator|(
name|RRnpc
expr|,
name|RRnpc
expr|,
name|RRnpc
operator|)
argument_list|,
name|rd_rm_rn
argument_list|,
name|rd_rm_rn
argument_list|)
block|,
name|TCE
argument_list|(
name|qdadd
argument_list|,
literal|1400050
argument_list|,
name|fa80f090
argument_list|,
literal|3
argument_list|,
operator|(
name|RRnpc
expr|,
name|RRnpc
expr|,
name|RRnpc
operator|)
argument_list|,
name|rd_rm_rn
argument_list|,
name|rd_rm_rn
argument_list|)
block|,
name|TCE
argument_list|(
name|qsub
argument_list|,
literal|1200050
argument_list|,
name|fa80f0a0
argument_list|,
literal|3
argument_list|,
operator|(
name|RRnpc
expr|,
name|RRnpc
expr|,
name|RRnpc
operator|)
argument_list|,
name|rd_rm_rn
argument_list|,
name|rd_rm_rn
argument_list|)
block|,
name|TCE
argument_list|(
name|qdsub
argument_list|,
literal|1600050
argument_list|,
name|fa80f0b0
argument_list|,
literal|3
argument_list|,
operator|(
name|RRnpc
expr|,
name|RRnpc
expr|,
name|RRnpc
operator|)
argument_list|,
name|rd_rm_rn
argument_list|,
name|rd_rm_rn
argument_list|)
block|,
undef|#
directive|undef
name|ARM_VARIANT
define|#
directive|define
name|ARM_VARIANT
value|&arm_ext_v5e
comment|/*  ARM Architecture 5TE.  */
name|TUF
argument_list|(
name|pld
argument_list|,
literal|450f000
argument_list|,
name|f810f000
argument_list|,
literal|1
argument_list|,
operator|(
name|ADDR
operator|)
argument_list|,
name|pld
argument_list|,
name|t_pld
argument_list|)
block|,
name|TC3
argument_list|(
name|ldrd
argument_list|,
literal|00000d0
argument_list|,
name|e8500000
argument_list|,
literal|3
argument_list|,
operator|(
name|RRnpc
expr|,
name|oRRnpc
expr|,
name|ADDRGLDRS
operator|)
argument_list|,
name|ldrd
argument_list|,
name|t_ldstd
argument_list|)
block|,
name|TC3
argument_list|(
name|strd
argument_list|,
literal|00000f0
argument_list|,
name|e8400000
argument_list|,
literal|3
argument_list|,
operator|(
name|RRnpc
expr|,
name|oRRnpc
expr|,
name|ADDRGLDRS
operator|)
argument_list|,
name|ldrd
argument_list|,
name|t_ldstd
argument_list|)
block|,
name|TCE
argument_list|(
name|mcrr
argument_list|,
name|c400000
argument_list|,
name|ec400000
argument_list|,
literal|5
argument_list|,
operator|(
name|RCP
expr|,
name|I15b
expr|,
name|RRnpc
expr|,
name|RRnpc
expr|,
name|RCN
operator|)
argument_list|,
name|co_reg2c
argument_list|,
name|co_reg2c
argument_list|)
block|,
name|TCE
argument_list|(
name|mrrc
argument_list|,
name|c500000
argument_list|,
name|ec500000
argument_list|,
literal|5
argument_list|,
operator|(
name|RCP
expr|,
name|I15b
expr|,
name|RRnpc
expr|,
name|RRnpc
expr|,
name|RCN
operator|)
argument_list|,
name|co_reg2c
argument_list|,
name|co_reg2c
argument_list|)
block|,
undef|#
directive|undef
name|ARM_VARIANT
define|#
directive|define
name|ARM_VARIANT
value|&arm_ext_v5j
comment|/*  ARM Architecture 5TEJ.  */
name|TCE
argument_list|(
name|bxj
argument_list|,
literal|12fff20
argument_list|,
name|f3c08f00
argument_list|,
literal|1
argument_list|,
operator|(
name|RR
operator|)
argument_list|,
name|bxj
argument_list|,
name|t_bxj
argument_list|)
block|,
undef|#
directive|undef
name|ARM_VARIANT
define|#
directive|define
name|ARM_VARIANT
value|&arm_ext_v6
comment|/*  ARM V6.  */
undef|#
directive|undef
name|THUMB_VARIANT
define|#
directive|define
name|THUMB_VARIANT
value|&arm_ext_v6
name|TUF
argument_list|(
name|cpsie
argument_list|,
literal|1080000
argument_list|,
name|b660
argument_list|,
literal|2
argument_list|,
operator|(
name|CPSF
expr|,
name|oI31b
operator|)
argument_list|,
name|cpsi
argument_list|,
name|t_cpsi
argument_list|)
block|,
name|TUF
argument_list|(
name|cpsid
argument_list|,
literal|10c0000
argument_list|,
name|b670
argument_list|,
literal|2
argument_list|,
operator|(
name|CPSF
expr|,
name|oI31b
operator|)
argument_list|,
name|cpsi
argument_list|,
name|t_cpsi
argument_list|)
block|,
name|tCE
argument_list|(
name|rev
argument_list|,
literal|6bf0f30
argument_list|,
name|rev
argument_list|,
literal|2
argument_list|,
operator|(
name|RRnpc
expr|,
name|RRnpc
operator|)
argument_list|,
name|rd_rm
argument_list|,
name|t_rev
argument_list|)
block|,
name|tCE
argument_list|(
name|rev16
argument_list|,
literal|6bf0fb0
argument_list|,
name|rev16
argument_list|,
literal|2
argument_list|,
operator|(
name|RRnpc
expr|,
name|RRnpc
operator|)
argument_list|,
name|rd_rm
argument_list|,
name|t_rev
argument_list|)
block|,
name|tCE
argument_list|(
name|revsh
argument_list|,
literal|6ff0fb0
argument_list|,
name|revsh
argument_list|,
literal|2
argument_list|,
operator|(
name|RRnpc
expr|,
name|RRnpc
operator|)
argument_list|,
name|rd_rm
argument_list|,
name|t_rev
argument_list|)
block|,
name|tCE
argument_list|(
name|sxth
argument_list|,
literal|6bf0070
argument_list|,
name|sxth
argument_list|,
literal|3
argument_list|,
operator|(
name|RRnpc
expr|,
name|RRnpc
expr|,
name|oROR
operator|)
argument_list|,
name|sxth
argument_list|,
name|t_sxth
argument_list|)
block|,
name|tCE
argument_list|(
name|uxth
argument_list|,
literal|6ff0070
argument_list|,
name|uxth
argument_list|,
literal|3
argument_list|,
operator|(
name|RRnpc
expr|,
name|RRnpc
expr|,
name|oROR
operator|)
argument_list|,
name|sxth
argument_list|,
name|t_sxth
argument_list|)
block|,
name|tCE
argument_list|(
name|sxtb
argument_list|,
literal|6af0070
argument_list|,
name|sxtb
argument_list|,
literal|3
argument_list|,
operator|(
name|RRnpc
expr|,
name|RRnpc
expr|,
name|oROR
operator|)
argument_list|,
name|sxth
argument_list|,
name|t_sxth
argument_list|)
block|,
name|tCE
argument_list|(
name|uxtb
argument_list|,
literal|6ef0070
argument_list|,
name|uxtb
argument_list|,
literal|3
argument_list|,
operator|(
name|RRnpc
expr|,
name|RRnpc
expr|,
name|oROR
operator|)
argument_list|,
name|sxth
argument_list|,
name|t_sxth
argument_list|)
block|,
name|TUF
argument_list|(
name|setend
argument_list|,
literal|1010000
argument_list|,
name|b650
argument_list|,
literal|1
argument_list|,
operator|(
name|ENDI
operator|)
argument_list|,
name|setend
argument_list|,
name|t_setend
argument_list|)
block|,
undef|#
directive|undef
name|THUMB_VARIANT
define|#
directive|define
name|THUMB_VARIANT
value|&arm_ext_v6t2
name|TCE
argument_list|(
name|ldrex
argument_list|,
literal|1900f9f
argument_list|,
name|e8500f00
argument_list|,
literal|2
argument_list|,
operator|(
name|RRnpc
expr|,
name|ADDR
operator|)
argument_list|,
name|ldrex
argument_list|,
name|t_ldrex
argument_list|)
block|,
name|TCE
argument_list|(
name|strex
argument_list|,
literal|1800f90
argument_list|,
name|e8400000
argument_list|,
literal|3
argument_list|,
operator|(
name|RRnpc
expr|,
name|RRnpc
expr|,
name|ADDR
operator|)
argument_list|,
name|strex
argument_list|,
name|t_strex
argument_list|)
block|,
name|TUF
argument_list|(
name|mcrr2
argument_list|,
name|c400000
argument_list|,
name|fc400000
argument_list|,
literal|5
argument_list|,
operator|(
name|RCP
expr|,
name|I15b
expr|,
name|RRnpc
expr|,
name|RRnpc
expr|,
name|RCN
operator|)
argument_list|,
name|co_reg2c
argument_list|,
name|co_reg2c
argument_list|)
block|,
name|TUF
argument_list|(
name|mrrc2
argument_list|,
name|c500000
argument_list|,
name|fc500000
argument_list|,
literal|5
argument_list|,
operator|(
name|RCP
expr|,
name|I15b
expr|,
name|RRnpc
expr|,
name|RRnpc
expr|,
name|RCN
operator|)
argument_list|,
name|co_reg2c
argument_list|,
name|co_reg2c
argument_list|)
block|,
name|TCE
argument_list|(
name|ssat
argument_list|,
literal|6a00010
argument_list|,
name|f3000000
argument_list|,
literal|4
argument_list|,
operator|(
name|RRnpc
expr|,
name|I32
expr|,
name|RRnpc
expr|,
name|oSHllar
operator|)
argument_list|,
name|ssat
argument_list|,
name|t_ssat
argument_list|)
block|,
name|TCE
argument_list|(
name|usat
argument_list|,
literal|6e00010
argument_list|,
name|f3800000
argument_list|,
literal|4
argument_list|,
operator|(
name|RRnpc
expr|,
name|I31
expr|,
name|RRnpc
expr|,
name|oSHllar
operator|)
argument_list|,
name|usat
argument_list|,
name|t_usat
argument_list|)
block|,
comment|/*  ARM V6 not included in V7M (eg. integer SIMD).  */
undef|#
directive|undef
name|THUMB_VARIANT
define|#
directive|define
name|THUMB_VARIANT
value|&arm_ext_v6_notm
name|TUF
argument_list|(
name|cps
argument_list|,
literal|1020000
argument_list|,
name|f3af8100
argument_list|,
literal|1
argument_list|,
operator|(
name|I31b
operator|)
argument_list|,
name|imm0
argument_list|,
name|t_cps
argument_list|)
block|,
name|TCE
argument_list|(
name|pkhbt
argument_list|,
literal|6800010
argument_list|,
name|eac00000
argument_list|,
literal|4
argument_list|,
operator|(
name|RRnpc
expr|,
name|RRnpc
expr|,
name|RRnpc
expr|,
name|oSHll
operator|)
argument_list|,
name|pkhbt
argument_list|,
name|t_pkhbt
argument_list|)
block|,
name|TCE
argument_list|(
name|pkhtb
argument_list|,
literal|6800050
argument_list|,
name|eac00020
argument_list|,
literal|4
argument_list|,
operator|(
name|RRnpc
expr|,
name|RRnpc
expr|,
name|RRnpc
expr|,
name|oSHar
operator|)
argument_list|,
name|pkhtb
argument_list|,
name|t_pkhtb
argument_list|)
block|,
name|TCE
argument_list|(
name|qadd16
argument_list|,
literal|6200f10
argument_list|,
name|fa90f010
argument_list|,
literal|3
argument_list|,
operator|(
name|RRnpc
expr|,
name|RRnpc
expr|,
name|RRnpc
operator|)
argument_list|,
name|rd_rn_rm
argument_list|,
name|t_simd
argument_list|)
block|,
name|TCE
argument_list|(
name|qadd8
argument_list|,
literal|6200f90
argument_list|,
name|fa80f010
argument_list|,
literal|3
argument_list|,
operator|(
name|RRnpc
expr|,
name|RRnpc
expr|,
name|RRnpc
operator|)
argument_list|,
name|rd_rn_rm
argument_list|,
name|t_simd
argument_list|)
block|,
name|TCE
argument_list|(
name|qaddsubx
argument_list|,
literal|6200f30
argument_list|,
name|faa0f010
argument_list|,
literal|3
argument_list|,
operator|(
name|RRnpc
expr|,
name|RRnpc
expr|,
name|RRnpc
operator|)
argument_list|,
name|rd_rn_rm
argument_list|,
name|t_simd
argument_list|)
block|,
name|TCE
argument_list|(
name|qsub16
argument_list|,
literal|6200f70
argument_list|,
name|fad0f010
argument_list|,
literal|3
argument_list|,
operator|(
name|RRnpc
expr|,
name|RRnpc
expr|,
name|RRnpc
operator|)
argument_list|,
name|rd_rn_rm
argument_list|,
name|t_simd
argument_list|)
block|,
name|TCE
argument_list|(
name|qsub8
argument_list|,
literal|6200ff0
argument_list|,
name|fac0f010
argument_list|,
literal|3
argument_list|,
operator|(
name|RRnpc
expr|,
name|RRnpc
expr|,
name|RRnpc
operator|)
argument_list|,
name|rd_rn_rm
argument_list|,
name|t_simd
argument_list|)
block|,
name|TCE
argument_list|(
name|qsubaddx
argument_list|,
literal|6200f50
argument_list|,
name|fae0f010
argument_list|,
literal|3
argument_list|,
operator|(
name|RRnpc
expr|,
name|RRnpc
expr|,
name|RRnpc
operator|)
argument_list|,
name|rd_rn_rm
argument_list|,
name|t_simd
argument_list|)
block|,
name|TCE
argument_list|(
name|sadd16
argument_list|,
literal|6100f10
argument_list|,
name|fa90f000
argument_list|,
literal|3
argument_list|,
operator|(
name|RRnpc
expr|,
name|RRnpc
expr|,
name|RRnpc
operator|)
argument_list|,
name|rd_rn_rm
argument_list|,
name|t_simd
argument_list|)
block|,
name|TCE
argument_list|(
name|sadd8
argument_list|,
literal|6100f90
argument_list|,
name|fa80f000
argument_list|,
literal|3
argument_list|,
operator|(
name|RRnpc
expr|,
name|RRnpc
expr|,
name|RRnpc
operator|)
argument_list|,
name|rd_rn_rm
argument_list|,
name|t_simd
argument_list|)
block|,
name|TCE
argument_list|(
name|saddsubx
argument_list|,
literal|6100f30
argument_list|,
name|faa0f000
argument_list|,
literal|3
argument_list|,
operator|(
name|RRnpc
expr|,
name|RRnpc
expr|,
name|RRnpc
operator|)
argument_list|,
name|rd_rn_rm
argument_list|,
name|t_simd
argument_list|)
block|,
name|TCE
argument_list|(
name|shadd16
argument_list|,
literal|6300f10
argument_list|,
name|fa90f020
argument_list|,
literal|3
argument_list|,
operator|(
name|RRnpc
expr|,
name|RRnpc
expr|,
name|RRnpc
operator|)
argument_list|,
name|rd_rn_rm
argument_list|,
name|t_simd
argument_list|)
block|,
name|TCE
argument_list|(
name|shadd8
argument_list|,
literal|6300f90
argument_list|,
name|fa80f020
argument_list|,
literal|3
argument_list|,
operator|(
name|RRnpc
expr|,
name|RRnpc
expr|,
name|RRnpc
operator|)
argument_list|,
name|rd_rn_rm
argument_list|,
name|t_simd
argument_list|)
block|,
name|TCE
argument_list|(
name|shaddsubx
argument_list|,
literal|6300f30
argument_list|,
name|faa0f020
argument_list|,
literal|3
argument_list|,
operator|(
name|RRnpc
expr|,
name|RRnpc
expr|,
name|RRnpc
operator|)
argument_list|,
name|rd_rn_rm
argument_list|,
name|t_simd
argument_list|)
block|,
name|TCE
argument_list|(
name|shsub16
argument_list|,
literal|6300f70
argument_list|,
name|fad0f020
argument_list|,
literal|3
argument_list|,
operator|(
name|RRnpc
expr|,
name|RRnpc
expr|,
name|RRnpc
operator|)
argument_list|,
name|rd_rn_rm
argument_list|,
name|t_simd
argument_list|)
block|,
name|TCE
argument_list|(
name|shsub8
argument_list|,
literal|6300ff0
argument_list|,
name|fac0f020
argument_list|,
literal|3
argument_list|,
operator|(
name|RRnpc
expr|,
name|RRnpc
expr|,
name|RRnpc
operator|)
argument_list|,
name|rd_rn_rm
argument_list|,
name|t_simd
argument_list|)
block|,
name|TCE
argument_list|(
name|shsubaddx
argument_list|,
literal|6300f50
argument_list|,
name|fae0f020
argument_list|,
literal|3
argument_list|,
operator|(
name|RRnpc
expr|,
name|RRnpc
expr|,
name|RRnpc
operator|)
argument_list|,
name|rd_rn_rm
argument_list|,
name|t_simd
argument_list|)
block|,
name|TCE
argument_list|(
name|ssub16
argument_list|,
literal|6100f70
argument_list|,
name|fad0f000
argument_list|,
literal|3
argument_list|,
operator|(
name|RRnpc
expr|,
name|RRnpc
expr|,
name|RRnpc
operator|)
argument_list|,
name|rd_rn_rm
argument_list|,
name|t_simd
argument_list|)
block|,
name|TCE
argument_list|(
name|ssub8
argument_list|,
literal|6100ff0
argument_list|,
name|fac0f000
argument_list|,
literal|3
argument_list|,
operator|(
name|RRnpc
expr|,
name|RRnpc
expr|,
name|RRnpc
operator|)
argument_list|,
name|rd_rn_rm
argument_list|,
name|t_simd
argument_list|)
block|,
name|TCE
argument_list|(
name|ssubaddx
argument_list|,
literal|6100f50
argument_list|,
name|fae0f000
argument_list|,
literal|3
argument_list|,
operator|(
name|RRnpc
expr|,
name|RRnpc
expr|,
name|RRnpc
operator|)
argument_list|,
name|rd_rn_rm
argument_list|,
name|t_simd
argument_list|)
block|,
name|TCE
argument_list|(
name|uadd16
argument_list|,
literal|6500f10
argument_list|,
name|fa90f040
argument_list|,
literal|3
argument_list|,
operator|(
name|RRnpc
expr|,
name|RRnpc
expr|,
name|RRnpc
operator|)
argument_list|,
name|rd_rn_rm
argument_list|,
name|t_simd
argument_list|)
block|,
name|TCE
argument_list|(
name|uadd8
argument_list|,
literal|6500f90
argument_list|,
name|fa80f040
argument_list|,
literal|3
argument_list|,
operator|(
name|RRnpc
expr|,
name|RRnpc
expr|,
name|RRnpc
operator|)
argument_list|,
name|rd_rn_rm
argument_list|,
name|t_simd
argument_list|)
block|,
name|TCE
argument_list|(
name|uaddsubx
argument_list|,
literal|6500f30
argument_list|,
name|faa0f040
argument_list|,
literal|3
argument_list|,
operator|(
name|RRnpc
expr|,
name|RRnpc
expr|,
name|RRnpc
operator|)
argument_list|,
name|rd_rn_rm
argument_list|,
name|t_simd
argument_list|)
block|,
name|TCE
argument_list|(
name|uhadd16
argument_list|,
literal|6700f10
argument_list|,
name|fa90f060
argument_list|,
literal|3
argument_list|,
operator|(
name|RRnpc
expr|,
name|RRnpc
expr|,
name|RRnpc
operator|)
argument_list|,
name|rd_rn_rm
argument_list|,
name|t_simd
argument_list|)
block|,
name|TCE
argument_list|(
name|uhadd8
argument_list|,
literal|6700f90
argument_list|,
name|fa80f060
argument_list|,
literal|3
argument_list|,
operator|(
name|RRnpc
expr|,
name|RRnpc
expr|,
name|RRnpc
operator|)
argument_list|,
name|rd_rn_rm
argument_list|,
name|t_simd
argument_list|)
block|,
name|TCE
argument_list|(
name|uhaddsubx
argument_list|,
literal|6700f30
argument_list|,
name|faa0f060
argument_list|,
literal|3
argument_list|,
operator|(
name|RRnpc
expr|,
name|RRnpc
expr|,
name|RRnpc
operator|)
argument_list|,
name|rd_rn_rm
argument_list|,
name|t_simd
argument_list|)
block|,
name|TCE
argument_list|(
name|uhsub16
argument_list|,
literal|6700f70
argument_list|,
name|fad0f060
argument_list|,
literal|3
argument_list|,
operator|(
name|RRnpc
expr|,
name|RRnpc
expr|,
name|RRnpc
operator|)
argument_list|,
name|rd_rn_rm
argument_list|,
name|t_simd
argument_list|)
block|,
name|TCE
argument_list|(
name|uhsub8
argument_list|,
literal|6700ff0
argument_list|,
name|fac0f060
argument_list|,
literal|3
argument_list|,
operator|(
name|RRnpc
expr|,
name|RRnpc
expr|,
name|RRnpc
operator|)
argument_list|,
name|rd_rn_rm
argument_list|,
name|t_simd
argument_list|)
block|,
name|TCE
argument_list|(
name|uhsubaddx
argument_list|,
literal|6700f50
argument_list|,
name|fae0f060
argument_list|,
literal|3
argument_list|,
operator|(
name|RRnpc
expr|,
name|RRnpc
expr|,
name|RRnpc
operator|)
argument_list|,
name|rd_rn_rm
argument_list|,
name|t_simd
argument_list|)
block|,
name|TCE
argument_list|(
name|uqadd16
argument_list|,
literal|6600f10
argument_list|,
name|fa90f050
argument_list|,
literal|3
argument_list|,
operator|(
name|RRnpc
expr|,
name|RRnpc
expr|,
name|RRnpc
operator|)
argument_list|,
name|rd_rn_rm
argument_list|,
name|t_simd
argument_list|)
block|,
name|TCE
argument_list|(
name|uqadd8
argument_list|,
literal|6600f90
argument_list|,
name|fa80f050
argument_list|,
literal|3
argument_list|,
operator|(
name|RRnpc
expr|,
name|RRnpc
expr|,
name|RRnpc
operator|)
argument_list|,
name|rd_rn_rm
argument_list|,
name|t_simd
argument_list|)
block|,
name|TCE
argument_list|(
name|uqaddsubx
argument_list|,
literal|6600f30
argument_list|,
name|faa0f050
argument_list|,
literal|3
argument_list|,
operator|(
name|RRnpc
expr|,
name|RRnpc
expr|,
name|RRnpc
operator|)
argument_list|,
name|rd_rn_rm
argument_list|,
name|t_simd
argument_list|)
block|,
name|TCE
argument_list|(
name|uqsub16
argument_list|,
literal|6600f70
argument_list|,
name|fad0f050
argument_list|,
literal|3
argument_list|,
operator|(
name|RRnpc
expr|,
name|RRnpc
expr|,
name|RRnpc
operator|)
argument_list|,
name|rd_rn_rm
argument_list|,
name|t_simd
argument_list|)
block|,
name|TCE
argument_list|(
name|uqsub8
argument_list|,
literal|6600ff0
argument_list|,
name|fac0f050
argument_list|,
literal|3
argument_list|,
operator|(
name|RRnpc
expr|,
name|RRnpc
expr|,
name|RRnpc
operator|)
argument_list|,
name|rd_rn_rm
argument_list|,
name|t_simd
argument_list|)
block|,
name|TCE
argument_list|(
name|uqsubaddx
argument_list|,
literal|6600f50
argument_list|,
name|fae0f050
argument_list|,
literal|3
argument_list|,
operator|(
name|RRnpc
expr|,
name|RRnpc
expr|,
name|RRnpc
operator|)
argument_list|,
name|rd_rn_rm
argument_list|,
name|t_simd
argument_list|)
block|,
name|TCE
argument_list|(
name|usub16
argument_list|,
literal|6500f70
argument_list|,
name|fad0f040
argument_list|,
literal|3
argument_list|,
operator|(
name|RRnpc
expr|,
name|RRnpc
expr|,
name|RRnpc
operator|)
argument_list|,
name|rd_rn_rm
argument_list|,
name|t_simd
argument_list|)
block|,
name|TCE
argument_list|(
name|usub8
argument_list|,
literal|6500ff0
argument_list|,
name|fac0f040
argument_list|,
literal|3
argument_list|,
operator|(
name|RRnpc
expr|,
name|RRnpc
expr|,
name|RRnpc
operator|)
argument_list|,
name|rd_rn_rm
argument_list|,
name|t_simd
argument_list|)
block|,
name|TCE
argument_list|(
name|usubaddx
argument_list|,
literal|6500f50
argument_list|,
name|fae0f040
argument_list|,
literal|3
argument_list|,
operator|(
name|RRnpc
expr|,
name|RRnpc
expr|,
name|RRnpc
operator|)
argument_list|,
name|rd_rn_rm
argument_list|,
name|t_simd
argument_list|)
block|,
name|TUF
argument_list|(
name|rfeia
argument_list|,
literal|8900a00
argument_list|,
name|e990c000
argument_list|,
literal|1
argument_list|,
operator|(
name|RRw
operator|)
argument_list|,
name|rfe
argument_list|,
name|rfe
argument_list|)
block|,
name|UF
argument_list|(
name|rfeib
argument_list|,
literal|9900a00
argument_list|,
literal|1
argument_list|,
operator|(
name|RRw
operator|)
argument_list|,
name|rfe
argument_list|)
block|,
name|UF
argument_list|(
name|rfeda
argument_list|,
literal|8100a00
argument_list|,
literal|1
argument_list|,
operator|(
name|RRw
operator|)
argument_list|,
name|rfe
argument_list|)
block|,
name|TUF
argument_list|(
name|rfedb
argument_list|,
literal|9100a00
argument_list|,
name|e810c000
argument_list|,
literal|1
argument_list|,
operator|(
name|RRw
operator|)
argument_list|,
name|rfe
argument_list|,
name|rfe
argument_list|)
block|,
name|TUF
argument_list|(
name|rfefd
argument_list|,
literal|8900a00
argument_list|,
name|e990c000
argument_list|,
literal|1
argument_list|,
operator|(
name|RRw
operator|)
argument_list|,
name|rfe
argument_list|,
name|rfe
argument_list|)
block|,
name|UF
argument_list|(
name|rfefa
argument_list|,
literal|9900a00
argument_list|,
literal|1
argument_list|,
operator|(
name|RRw
operator|)
argument_list|,
name|rfe
argument_list|)
block|,
name|UF
argument_list|(
name|rfeea
argument_list|,
literal|8100a00
argument_list|,
literal|1
argument_list|,
operator|(
name|RRw
operator|)
argument_list|,
name|rfe
argument_list|)
block|,
name|TUF
argument_list|(
name|rfeed
argument_list|,
literal|9100a00
argument_list|,
name|e810c000
argument_list|,
literal|1
argument_list|,
operator|(
name|RRw
operator|)
argument_list|,
name|rfe
argument_list|,
name|rfe
argument_list|)
block|,
name|TCE
argument_list|(
name|sxtah
argument_list|,
literal|6b00070
argument_list|,
name|fa00f080
argument_list|,
literal|4
argument_list|,
operator|(
name|RRnpc
expr|,
name|RRnpc
expr|,
name|RRnpc
expr|,
name|oROR
operator|)
argument_list|,
name|sxtah
argument_list|,
name|t_sxtah
argument_list|)
block|,
name|TCE
argument_list|(
name|sxtab16
argument_list|,
literal|6800070
argument_list|,
name|fa20f080
argument_list|,
literal|4
argument_list|,
operator|(
name|RRnpc
expr|,
name|RRnpc
expr|,
name|RRnpc
expr|,
name|oROR
operator|)
argument_list|,
name|sxtah
argument_list|,
name|t_sxtah
argument_list|)
block|,
name|TCE
argument_list|(
name|sxtab
argument_list|,
literal|6a00070
argument_list|,
name|fa40f080
argument_list|,
literal|4
argument_list|,
operator|(
name|RRnpc
expr|,
name|RRnpc
expr|,
name|RRnpc
expr|,
name|oROR
operator|)
argument_list|,
name|sxtah
argument_list|,
name|t_sxtah
argument_list|)
block|,
name|TCE
argument_list|(
name|sxtb16
argument_list|,
literal|68f0070
argument_list|,
name|fa2ff080
argument_list|,
literal|3
argument_list|,
operator|(
name|RRnpc
expr|,
name|RRnpc
expr|,
name|oROR
operator|)
argument_list|,
name|sxth
argument_list|,
name|t_sxth
argument_list|)
block|,
name|TCE
argument_list|(
name|uxtah
argument_list|,
literal|6f00070
argument_list|,
name|fa10f080
argument_list|,
literal|4
argument_list|,
operator|(
name|RRnpc
expr|,
name|RRnpc
expr|,
name|RRnpc
expr|,
name|oROR
operator|)
argument_list|,
name|sxtah
argument_list|,
name|t_sxtah
argument_list|)
block|,
name|TCE
argument_list|(
name|uxtab16
argument_list|,
literal|6c00070
argument_list|,
name|fa30f080
argument_list|,
literal|4
argument_list|,
operator|(
name|RRnpc
expr|,
name|RRnpc
expr|,
name|RRnpc
expr|,
name|oROR
operator|)
argument_list|,
name|sxtah
argument_list|,
name|t_sxtah
argument_list|)
block|,
name|TCE
argument_list|(
name|uxtab
argument_list|,
literal|6e00070
argument_list|,
name|fa50f080
argument_list|,
literal|4
argument_list|,
operator|(
name|RRnpc
expr|,
name|RRnpc
expr|,
name|RRnpc
expr|,
name|oROR
operator|)
argument_list|,
name|sxtah
argument_list|,
name|t_sxtah
argument_list|)
block|,
name|TCE
argument_list|(
name|uxtb16
argument_list|,
literal|6cf0070
argument_list|,
name|fa3ff080
argument_list|,
literal|3
argument_list|,
operator|(
name|RRnpc
expr|,
name|RRnpc
expr|,
name|oROR
operator|)
argument_list|,
name|sxth
argument_list|,
name|t_sxth
argument_list|)
block|,
name|TCE
argument_list|(
name|sel
argument_list|,
literal|6800fb0
argument_list|,
name|faa0f080
argument_list|,
literal|3
argument_list|,
operator|(
name|RRnpc
expr|,
name|RRnpc
expr|,
name|RRnpc
operator|)
argument_list|,
name|rd_rn_rm
argument_list|,
name|t_simd
argument_list|)
block|,
name|TCE
argument_list|(
name|smlad
argument_list|,
literal|7000010
argument_list|,
name|fb200000
argument_list|,
literal|4
argument_list|,
operator|(
name|RRnpc
expr|,
name|RRnpc
expr|,
name|RRnpc
expr|,
name|RRnpc
operator|)
argument_list|,
name|smla
argument_list|,
name|t_mla
argument_list|)
block|,
name|TCE
argument_list|(
name|smladx
argument_list|,
literal|7000030
argument_list|,
name|fb200010
argument_list|,
literal|4
argument_list|,
operator|(
name|RRnpc
expr|,
name|RRnpc
expr|,
name|RRnpc
expr|,
name|RRnpc
operator|)
argument_list|,
name|smla
argument_list|,
name|t_mla
argument_list|)
block|,
name|TCE
argument_list|(
name|smlald
argument_list|,
literal|7400010
argument_list|,
name|fbc000c0
argument_list|,
literal|4
argument_list|,
operator|(
name|RRnpc
expr|,
name|RRnpc
expr|,
name|RRnpc
expr|,
name|RRnpc
operator|)
argument_list|,
name|smlal
argument_list|,
name|t_mlal
argument_list|)
block|,
name|TCE
argument_list|(
name|smlaldx
argument_list|,
literal|7400030
argument_list|,
name|fbc000d0
argument_list|,
literal|4
argument_list|,
operator|(
name|RRnpc
expr|,
name|RRnpc
expr|,
name|RRnpc
expr|,
name|RRnpc
operator|)
argument_list|,
name|smlal
argument_list|,
name|t_mlal
argument_list|)
block|,
name|TCE
argument_list|(
name|smlsd
argument_list|,
literal|7000050
argument_list|,
name|fb400000
argument_list|,
literal|4
argument_list|,
operator|(
name|RRnpc
expr|,
name|RRnpc
expr|,
name|RRnpc
expr|,
name|RRnpc
operator|)
argument_list|,
name|smla
argument_list|,
name|t_mla
argument_list|)
block|,
name|TCE
argument_list|(
name|smlsdx
argument_list|,
literal|7000070
argument_list|,
name|fb400010
argument_list|,
literal|4
argument_list|,
operator|(
name|RRnpc
expr|,
name|RRnpc
expr|,
name|RRnpc
expr|,
name|RRnpc
operator|)
argument_list|,
name|smla
argument_list|,
name|t_mla
argument_list|)
block|,
name|TCE
argument_list|(
name|smlsld
argument_list|,
literal|7400050
argument_list|,
name|fbd000c0
argument_list|,
literal|4
argument_list|,
operator|(
name|RRnpc
expr|,
name|RRnpc
expr|,
name|RRnpc
expr|,
name|RRnpc
operator|)
argument_list|,
name|smlal
argument_list|,
name|t_mlal
argument_list|)
block|,
name|TCE
argument_list|(
name|smlsldx
argument_list|,
literal|7400070
argument_list|,
name|fbd000d0
argument_list|,
literal|4
argument_list|,
operator|(
name|RRnpc
expr|,
name|RRnpc
expr|,
name|RRnpc
expr|,
name|RRnpc
operator|)
argument_list|,
name|smlal
argument_list|,
name|t_mlal
argument_list|)
block|,
name|TCE
argument_list|(
name|smmla
argument_list|,
literal|7500010
argument_list|,
name|fb500000
argument_list|,
literal|4
argument_list|,
operator|(
name|RRnpc
expr|,
name|RRnpc
expr|,
name|RRnpc
expr|,
name|RRnpc
operator|)
argument_list|,
name|smla
argument_list|,
name|t_mla
argument_list|)
block|,
name|TCE
argument_list|(
name|smmlar
argument_list|,
literal|7500030
argument_list|,
name|fb500010
argument_list|,
literal|4
argument_list|,
operator|(
name|RRnpc
expr|,
name|RRnpc
expr|,
name|RRnpc
expr|,
name|RRnpc
operator|)
argument_list|,
name|smla
argument_list|,
name|t_mla
argument_list|)
block|,
name|TCE
argument_list|(
name|smmls
argument_list|,
literal|75000d0
argument_list|,
name|fb600000
argument_list|,
literal|4
argument_list|,
operator|(
name|RRnpc
expr|,
name|RRnpc
expr|,
name|RRnpc
expr|,
name|RRnpc
operator|)
argument_list|,
name|smla
argument_list|,
name|t_mla
argument_list|)
block|,
name|TCE
argument_list|(
name|smmlsr
argument_list|,
literal|75000f0
argument_list|,
name|fb600010
argument_list|,
literal|4
argument_list|,
operator|(
name|RRnpc
expr|,
name|RRnpc
expr|,
name|RRnpc
expr|,
name|RRnpc
operator|)
argument_list|,
name|smla
argument_list|,
name|t_mla
argument_list|)
block|,
name|TCE
argument_list|(
name|smmul
argument_list|,
literal|750f010
argument_list|,
name|fb50f000
argument_list|,
literal|3
argument_list|,
operator|(
name|RRnpc
expr|,
name|RRnpc
expr|,
name|RRnpc
operator|)
argument_list|,
name|smul
argument_list|,
name|t_simd
argument_list|)
block|,
name|TCE
argument_list|(
name|smmulr
argument_list|,
literal|750f030
argument_list|,
name|fb50f010
argument_list|,
literal|3
argument_list|,
operator|(
name|RRnpc
expr|,
name|RRnpc
expr|,
name|RRnpc
operator|)
argument_list|,
name|smul
argument_list|,
name|t_simd
argument_list|)
block|,
name|TCE
argument_list|(
name|smuad
argument_list|,
literal|700f010
argument_list|,
name|fb20f000
argument_list|,
literal|3
argument_list|,
operator|(
name|RRnpc
expr|,
name|RRnpc
expr|,
name|RRnpc
operator|)
argument_list|,
name|smul
argument_list|,
name|t_simd
argument_list|)
block|,
name|TCE
argument_list|(
name|smuadx
argument_list|,
literal|700f030
argument_list|,
name|fb20f010
argument_list|,
literal|3
argument_list|,
operator|(
name|RRnpc
expr|,
name|RRnpc
expr|,
name|RRnpc
operator|)
argument_list|,
name|smul
argument_list|,
name|t_simd
argument_list|)
block|,
name|TCE
argument_list|(
name|smusd
argument_list|,
literal|700f050
argument_list|,
name|fb40f000
argument_list|,
literal|3
argument_list|,
operator|(
name|RRnpc
expr|,
name|RRnpc
expr|,
name|RRnpc
operator|)
argument_list|,
name|smul
argument_list|,
name|t_simd
argument_list|)
block|,
name|TCE
argument_list|(
name|smusdx
argument_list|,
literal|700f070
argument_list|,
name|fb40f010
argument_list|,
literal|3
argument_list|,
operator|(
name|RRnpc
expr|,
name|RRnpc
expr|,
name|RRnpc
operator|)
argument_list|,
name|smul
argument_list|,
name|t_simd
argument_list|)
block|,
name|TUF
argument_list|(
name|srsia
argument_list|,
literal|8c00500
argument_list|,
name|e980c000
argument_list|,
literal|2
argument_list|,
operator|(
name|oRRw
expr|,
name|I31w
operator|)
argument_list|,
name|srs
argument_list|,
name|srs
argument_list|)
block|,
name|UF
argument_list|(
name|srsib
argument_list|,
literal|9c00500
argument_list|,
literal|2
argument_list|,
operator|(
name|oRRw
expr|,
name|I31w
operator|)
argument_list|,
name|srs
argument_list|)
block|,
name|UF
argument_list|(
name|srsda
argument_list|,
literal|8400500
argument_list|,
literal|2
argument_list|,
operator|(
name|oRRw
expr|,
name|I31w
operator|)
argument_list|,
name|srs
argument_list|)
block|,
name|TUF
argument_list|(
name|srsdb
argument_list|,
literal|9400500
argument_list|,
name|e800c000
argument_list|,
literal|2
argument_list|,
operator|(
name|oRRw
expr|,
name|I31w
operator|)
argument_list|,
name|srs
argument_list|,
name|srs
argument_list|)
block|,
name|TCE
argument_list|(
name|ssat16
argument_list|,
literal|6a00f30
argument_list|,
name|f3200000
argument_list|,
literal|3
argument_list|,
operator|(
name|RRnpc
expr|,
name|I16
expr|,
name|RRnpc
operator|)
argument_list|,
name|ssat16
argument_list|,
name|t_ssat16
argument_list|)
block|,
name|TCE
argument_list|(
name|umaal
argument_list|,
literal|0400090
argument_list|,
name|fbe00060
argument_list|,
literal|4
argument_list|,
operator|(
name|RRnpc
expr|,
name|RRnpc
expr|,
name|RRnpc
expr|,
name|RRnpc
operator|)
argument_list|,
name|smlal
argument_list|,
name|t_mlal
argument_list|)
block|,
name|TCE
argument_list|(
name|usad8
argument_list|,
literal|780f010
argument_list|,
name|fb70f000
argument_list|,
literal|3
argument_list|,
operator|(
name|RRnpc
expr|,
name|RRnpc
expr|,
name|RRnpc
operator|)
argument_list|,
name|smul
argument_list|,
name|t_simd
argument_list|)
block|,
name|TCE
argument_list|(
name|usada8
argument_list|,
literal|7800010
argument_list|,
name|fb700000
argument_list|,
literal|4
argument_list|,
operator|(
name|RRnpc
expr|,
name|RRnpc
expr|,
name|RRnpc
expr|,
name|RRnpc
operator|)
argument_list|,
name|smla
argument_list|,
name|t_mla
argument_list|)
block|,
name|TCE
argument_list|(
name|usat16
argument_list|,
literal|6e00f30
argument_list|,
name|f3a00000
argument_list|,
literal|3
argument_list|,
operator|(
name|RRnpc
expr|,
name|I15
expr|,
name|RRnpc
operator|)
argument_list|,
name|usat16
argument_list|,
name|t_usat16
argument_list|)
block|,
undef|#
directive|undef
name|ARM_VARIANT
define|#
directive|define
name|ARM_VARIANT
value|&arm_ext_v6k
undef|#
directive|undef
name|THUMB_VARIANT
define|#
directive|define
name|THUMB_VARIANT
value|&arm_ext_v6k
name|tCE
argument_list|(
name|yield
argument_list|,
literal|320f001
argument_list|,
name|yield
argument_list|,
literal|0
argument_list|,
operator|(
operator|)
argument_list|,
name|noargs
argument_list|,
name|t_hint
argument_list|)
block|,
name|tCE
argument_list|(
name|wfe
argument_list|,
literal|320f002
argument_list|,
name|wfe
argument_list|,
literal|0
argument_list|,
operator|(
operator|)
argument_list|,
name|noargs
argument_list|,
name|t_hint
argument_list|)
block|,
name|tCE
argument_list|(
name|wfi
argument_list|,
literal|320f003
argument_list|,
name|wfi
argument_list|,
literal|0
argument_list|,
operator|(
operator|)
argument_list|,
name|noargs
argument_list|,
name|t_hint
argument_list|)
block|,
name|tCE
argument_list|(
name|sev
argument_list|,
literal|320f004
argument_list|,
name|sev
argument_list|,
literal|0
argument_list|,
operator|(
operator|)
argument_list|,
name|noargs
argument_list|,
name|t_hint
argument_list|)
block|,
undef|#
directive|undef
name|THUMB_VARIANT
define|#
directive|define
name|THUMB_VARIANT
value|&arm_ext_v6_notm
name|TCE
argument_list|(
name|ldrexd
argument_list|,
literal|1b00f9f
argument_list|,
name|e8d0007f
argument_list|,
literal|3
argument_list|,
operator|(
name|RRnpc
expr|,
name|oRRnpc
expr|,
name|RRnpcb
operator|)
argument_list|,
name|ldrexd
argument_list|,
name|t_ldrexd
argument_list|)
block|,
name|TCE
argument_list|(
name|strexd
argument_list|,
literal|1a00f90
argument_list|,
name|e8c00070
argument_list|,
literal|4
argument_list|,
operator|(
name|RRnpc
expr|,
name|RRnpc
expr|,
name|oRRnpc
expr|,
name|RRnpcb
operator|)
argument_list|,
name|strexd
argument_list|,
name|t_strexd
argument_list|)
block|,
undef|#
directive|undef
name|THUMB_VARIANT
define|#
directive|define
name|THUMB_VARIANT
value|&arm_ext_v6t2
name|TCE
argument_list|(
name|ldrexb
argument_list|,
literal|1d00f9f
argument_list|,
name|e8d00f4f
argument_list|,
literal|2
argument_list|,
operator|(
name|RRnpc
expr|,
name|RRnpcb
operator|)
argument_list|,
name|rd_rn
argument_list|,
name|rd_rn
argument_list|)
block|,
name|TCE
argument_list|(
name|ldrexh
argument_list|,
literal|1f00f9f
argument_list|,
name|e8d00f5f
argument_list|,
literal|2
argument_list|,
operator|(
name|RRnpc
expr|,
name|RRnpcb
operator|)
argument_list|,
name|rd_rn
argument_list|,
name|rd_rn
argument_list|)
block|,
name|TCE
argument_list|(
name|strexb
argument_list|,
literal|1c00f90
argument_list|,
name|e8c00f40
argument_list|,
literal|3
argument_list|,
operator|(
name|RRnpc
expr|,
name|RRnpc
expr|,
name|ADDR
operator|)
argument_list|,
name|strex
argument_list|,
name|rm_rd_rn
argument_list|)
block|,
name|TCE
argument_list|(
name|strexh
argument_list|,
literal|1e00f90
argument_list|,
name|e8c00f50
argument_list|,
literal|3
argument_list|,
operator|(
name|RRnpc
expr|,
name|RRnpc
expr|,
name|ADDR
operator|)
argument_list|,
name|strex
argument_list|,
name|rm_rd_rn
argument_list|)
block|,
name|TUF
argument_list|(
name|clrex
argument_list|,
literal|57ff01f
argument_list|,
name|f3bf8f2f
argument_list|,
literal|0
argument_list|,
operator|(
operator|)
argument_list|,
name|noargs
argument_list|,
name|noargs
argument_list|)
block|,
undef|#
directive|undef
name|ARM_VARIANT
define|#
directive|define
name|ARM_VARIANT
value|&arm_ext_v6z
name|TCE
argument_list|(
name|smc
argument_list|,
literal|1600070
argument_list|,
name|f7f08000
argument_list|,
literal|1
argument_list|,
operator|(
name|EXPi
operator|)
argument_list|,
name|smc
argument_list|,
name|t_smc
argument_list|)
block|,
undef|#
directive|undef
name|ARM_VARIANT
define|#
directive|define
name|ARM_VARIANT
value|&arm_ext_v6t2
name|TCE
argument_list|(
name|bfc
argument_list|,
literal|7c0001f
argument_list|,
name|f36f0000
argument_list|,
literal|3
argument_list|,
operator|(
name|RRnpc
expr|,
name|I31
expr|,
name|I32
operator|)
argument_list|,
name|bfc
argument_list|,
name|t_bfc
argument_list|)
block|,
name|TCE
argument_list|(
name|bfi
argument_list|,
literal|7c00010
argument_list|,
name|f3600000
argument_list|,
literal|4
argument_list|,
operator|(
name|RRnpc
expr|,
name|RRnpc_I0
expr|,
name|I31
expr|,
name|I32
operator|)
argument_list|,
name|bfi
argument_list|,
name|t_bfi
argument_list|)
block|,
name|TCE
argument_list|(
name|sbfx
argument_list|,
literal|7a00050
argument_list|,
name|f3400000
argument_list|,
literal|4
argument_list|,
operator|(
name|RR
expr|,
name|RR
expr|,
name|I31
expr|,
name|I32
operator|)
argument_list|,
name|bfx
argument_list|,
name|t_bfx
argument_list|)
block|,
name|TCE
argument_list|(
name|ubfx
argument_list|,
literal|7e00050
argument_list|,
name|f3c00000
argument_list|,
literal|4
argument_list|,
operator|(
name|RR
expr|,
name|RR
expr|,
name|I31
expr|,
name|I32
operator|)
argument_list|,
name|bfx
argument_list|,
name|t_bfx
argument_list|)
block|,
name|TCE
argument_list|(
name|mls
argument_list|,
literal|0600090
argument_list|,
name|fb000010
argument_list|,
literal|4
argument_list|,
operator|(
name|RRnpc
expr|,
name|RRnpc
expr|,
name|RRnpc
expr|,
name|RRnpc
operator|)
argument_list|,
name|mlas
argument_list|,
name|t_mla
argument_list|)
block|,
name|TCE
argument_list|(
name|movw
argument_list|,
literal|3000000
argument_list|,
name|f2400000
argument_list|,
literal|2
argument_list|,
operator|(
name|RRnpc
expr|,
name|HALF
operator|)
argument_list|,
name|mov16
argument_list|,
name|t_mov16
argument_list|)
block|,
name|TCE
argument_list|(
name|movt
argument_list|,
literal|3400000
argument_list|,
name|f2c00000
argument_list|,
literal|2
argument_list|,
operator|(
name|RRnpc
expr|,
name|HALF
operator|)
argument_list|,
name|mov16
argument_list|,
name|t_mov16
argument_list|)
block|,
name|TCE
argument_list|(
name|rbit
argument_list|,
literal|6ff0f30
argument_list|,
name|fa90f0a0
argument_list|,
literal|2
argument_list|,
operator|(
name|RR
expr|,
name|RR
operator|)
argument_list|,
name|rd_rm
argument_list|,
name|t_rbit
argument_list|)
block|,
name|TC3
argument_list|(
name|ldrht
argument_list|,
literal|03000b0
argument_list|,
name|f8300e00
argument_list|,
literal|2
argument_list|,
operator|(
name|RR
expr|,
name|ADDR
operator|)
argument_list|,
name|ldsttv4
argument_list|,
name|t_ldstt
argument_list|)
block|,
name|TC3
argument_list|(
name|ldrsht
argument_list|,
literal|03000f0
argument_list|,
name|f9300e00
argument_list|,
literal|2
argument_list|,
operator|(
name|RR
expr|,
name|ADDR
operator|)
argument_list|,
name|ldsttv4
argument_list|,
name|t_ldstt
argument_list|)
block|,
name|TC3
argument_list|(
name|ldrsbt
argument_list|,
literal|03000d0
argument_list|,
name|f9100e00
argument_list|,
literal|2
argument_list|,
operator|(
name|RR
expr|,
name|ADDR
operator|)
argument_list|,
name|ldsttv4
argument_list|,
name|t_ldstt
argument_list|)
block|,
name|TC3
argument_list|(
name|strht
argument_list|,
literal|02000b0
argument_list|,
name|f8200e00
argument_list|,
literal|2
argument_list|,
operator|(
name|RR
expr|,
name|ADDR
operator|)
argument_list|,
name|ldsttv4
argument_list|,
name|t_ldstt
argument_list|)
block|,
name|UT
argument_list|(
name|cbnz
argument_list|,
name|b900
argument_list|,
literal|2
argument_list|,
operator|(
name|RR
expr|,
name|EXP
operator|)
argument_list|,
name|t_cbz
argument_list|)
block|,
name|UT
argument_list|(
name|cbz
argument_list|,
name|b100
argument_list|,
literal|2
argument_list|,
operator|(
name|RR
expr|,
name|EXP
operator|)
argument_list|,
name|t_cbz
argument_list|)
block|,
comment|/* ARM does not really have an IT instruction, so always allow it.  */
undef|#
directive|undef
name|ARM_VARIANT
define|#
directive|define
name|ARM_VARIANT
value|&arm_ext_v1
name|TUE
argument_list|(
name|it
argument_list|,
literal|0
argument_list|,
name|bf08
argument_list|,
literal|1
argument_list|,
operator|(
name|COND
operator|)
argument_list|,
name|it
argument_list|,
name|t_it
argument_list|)
block|,
name|TUE
argument_list|(
name|itt
argument_list|,
literal|0
argument_list|,
name|bf0c
argument_list|,
literal|1
argument_list|,
operator|(
name|COND
operator|)
argument_list|,
name|it
argument_list|,
name|t_it
argument_list|)
block|,
name|TUE
argument_list|(
name|ite
argument_list|,
literal|0
argument_list|,
name|bf04
argument_list|,
literal|1
argument_list|,
operator|(
name|COND
operator|)
argument_list|,
name|it
argument_list|,
name|t_it
argument_list|)
block|,
name|TUE
argument_list|(
name|ittt
argument_list|,
literal|0
argument_list|,
name|bf0e
argument_list|,
literal|1
argument_list|,
operator|(
name|COND
operator|)
argument_list|,
name|it
argument_list|,
name|t_it
argument_list|)
block|,
name|TUE
argument_list|(
name|itet
argument_list|,
literal|0
argument_list|,
name|bf06
argument_list|,
literal|1
argument_list|,
operator|(
name|COND
operator|)
argument_list|,
name|it
argument_list|,
name|t_it
argument_list|)
block|,
name|TUE
argument_list|(
name|itte
argument_list|,
literal|0
argument_list|,
name|bf0a
argument_list|,
literal|1
argument_list|,
operator|(
name|COND
operator|)
argument_list|,
name|it
argument_list|,
name|t_it
argument_list|)
block|,
name|TUE
argument_list|(
name|itee
argument_list|,
literal|0
argument_list|,
name|bf02
argument_list|,
literal|1
argument_list|,
operator|(
name|COND
operator|)
argument_list|,
name|it
argument_list|,
name|t_it
argument_list|)
block|,
name|TUE
argument_list|(
name|itttt
argument_list|,
literal|0
argument_list|,
name|bf0f
argument_list|,
literal|1
argument_list|,
operator|(
name|COND
operator|)
argument_list|,
name|it
argument_list|,
name|t_it
argument_list|)
block|,
name|TUE
argument_list|(
name|itett
argument_list|,
literal|0
argument_list|,
name|bf07
argument_list|,
literal|1
argument_list|,
operator|(
name|COND
operator|)
argument_list|,
name|it
argument_list|,
name|t_it
argument_list|)
block|,
name|TUE
argument_list|(
name|ittet
argument_list|,
literal|0
argument_list|,
name|bf0b
argument_list|,
literal|1
argument_list|,
operator|(
name|COND
operator|)
argument_list|,
name|it
argument_list|,
name|t_it
argument_list|)
block|,
name|TUE
argument_list|(
name|iteet
argument_list|,
literal|0
argument_list|,
name|bf03
argument_list|,
literal|1
argument_list|,
operator|(
name|COND
operator|)
argument_list|,
name|it
argument_list|,
name|t_it
argument_list|)
block|,
name|TUE
argument_list|(
name|ittte
argument_list|,
literal|0
argument_list|,
name|bf0d
argument_list|,
literal|1
argument_list|,
operator|(
name|COND
operator|)
argument_list|,
name|it
argument_list|,
name|t_it
argument_list|)
block|,
name|TUE
argument_list|(
name|itete
argument_list|,
literal|0
argument_list|,
name|bf05
argument_list|,
literal|1
argument_list|,
operator|(
name|COND
operator|)
argument_list|,
name|it
argument_list|,
name|t_it
argument_list|)
block|,
name|TUE
argument_list|(
name|ittee
argument_list|,
literal|0
argument_list|,
name|bf09
argument_list|,
literal|1
argument_list|,
operator|(
name|COND
operator|)
argument_list|,
name|it
argument_list|,
name|t_it
argument_list|)
block|,
name|TUE
argument_list|(
name|iteee
argument_list|,
literal|0
argument_list|,
name|bf01
argument_list|,
literal|1
argument_list|,
operator|(
name|COND
operator|)
argument_list|,
name|it
argument_list|,
name|t_it
argument_list|)
block|,
comment|/* Thumb2 only instructions.  */
undef|#
directive|undef
name|ARM_VARIANT
define|#
directive|define
name|ARM_VARIANT
value|NULL
name|TCE
argument_list|(
name|addw
argument_list|,
literal|0
argument_list|,
name|f2000000
argument_list|,
literal|3
argument_list|,
operator|(
name|RR
expr|,
name|RR
expr|,
name|EXPi
operator|)
argument_list|,
literal|0
argument_list|,
name|t_add_sub_w
argument_list|)
block|,
name|TCE
argument_list|(
name|subw
argument_list|,
literal|0
argument_list|,
name|f2a00000
argument_list|,
literal|3
argument_list|,
operator|(
name|RR
expr|,
name|RR
expr|,
name|EXPi
operator|)
argument_list|,
literal|0
argument_list|,
name|t_add_sub_w
argument_list|)
block|,
name|TCE
argument_list|(
name|tbb
argument_list|,
literal|0
argument_list|,
name|e8d0f000
argument_list|,
literal|1
argument_list|,
operator|(
name|TB
operator|)
argument_list|,
literal|0
argument_list|,
name|t_tb
argument_list|)
block|,
name|TCE
argument_list|(
name|tbh
argument_list|,
literal|0
argument_list|,
name|e8d0f010
argument_list|,
literal|1
argument_list|,
operator|(
name|TB
operator|)
argument_list|,
literal|0
argument_list|,
name|t_tb
argument_list|)
block|,
comment|/* Thumb-2 hardware division instructions (R and M profiles only).  */
undef|#
directive|undef
name|THUMB_VARIANT
define|#
directive|define
name|THUMB_VARIANT
value|&arm_ext_div
name|TCE
argument_list|(
name|sdiv
argument_list|,
literal|0
argument_list|,
name|fb90f0f0
argument_list|,
literal|3
argument_list|,
operator|(
name|RR
expr|,
name|oRR
expr|,
name|RR
operator|)
argument_list|,
literal|0
argument_list|,
name|t_div
argument_list|)
block|,
name|TCE
argument_list|(
name|udiv
argument_list|,
literal|0
argument_list|,
name|fbb0f0f0
argument_list|,
literal|3
argument_list|,
operator|(
name|RR
expr|,
name|oRR
expr|,
name|RR
operator|)
argument_list|,
literal|0
argument_list|,
name|t_div
argument_list|)
block|,
comment|/* ARM V7 instructions.  */
undef|#
directive|undef
name|ARM_VARIANT
define|#
directive|define
name|ARM_VARIANT
value|&arm_ext_v7
undef|#
directive|undef
name|THUMB_VARIANT
define|#
directive|define
name|THUMB_VARIANT
value|&arm_ext_v7
name|TUF
argument_list|(
name|pli
argument_list|,
literal|450f000
argument_list|,
name|f910f000
argument_list|,
literal|1
argument_list|,
operator|(
name|ADDR
operator|)
argument_list|,
name|pli
argument_list|,
name|t_pld
argument_list|)
block|,
name|TCE
argument_list|(
name|dbg
argument_list|,
literal|320f0f0
argument_list|,
name|f3af80f0
argument_list|,
literal|1
argument_list|,
operator|(
name|I15
operator|)
argument_list|,
name|dbg
argument_list|,
name|t_dbg
argument_list|)
block|,
name|TUF
argument_list|(
name|dmb
argument_list|,
literal|57ff050
argument_list|,
name|f3bf8f50
argument_list|,
literal|1
argument_list|,
operator|(
name|oBARRIER
operator|)
argument_list|,
name|barrier
argument_list|,
name|t_barrier
argument_list|)
block|,
name|TUF
argument_list|(
name|dsb
argument_list|,
literal|57ff040
argument_list|,
name|f3bf8f40
argument_list|,
literal|1
argument_list|,
operator|(
name|oBARRIER
operator|)
argument_list|,
name|barrier
argument_list|,
name|t_barrier
argument_list|)
block|,
name|TUF
argument_list|(
name|isb
argument_list|,
literal|57ff060
argument_list|,
name|f3bf8f60
argument_list|,
literal|1
argument_list|,
operator|(
name|oBARRIER
operator|)
argument_list|,
name|barrier
argument_list|,
name|t_barrier
argument_list|)
block|,
undef|#
directive|undef
name|ARM_VARIANT
define|#
directive|define
name|ARM_VARIANT
value|&fpu_fpa_ext_v1
comment|/* Core FPA instruction set (V1).  */
name|cCE
argument_list|(
name|wfs
argument_list|,
name|e200110
argument_list|,
literal|1
argument_list|,
operator|(
name|RR
operator|)
argument_list|,
name|rd
argument_list|)
block|,
name|cCE
argument_list|(
name|rfs
argument_list|,
name|e300110
argument_list|,
literal|1
argument_list|,
operator|(
name|RR
operator|)
argument_list|,
name|rd
argument_list|)
block|,
name|cCE
argument_list|(
name|wfc
argument_list|,
name|e400110
argument_list|,
literal|1
argument_list|,
operator|(
name|RR
operator|)
argument_list|,
name|rd
argument_list|)
block|,
name|cCE
argument_list|(
name|rfc
argument_list|,
name|e500110
argument_list|,
literal|1
argument_list|,
operator|(
name|RR
operator|)
argument_list|,
name|rd
argument_list|)
block|,
name|cCL
argument_list|(
name|ldfs
argument_list|,
name|c100100
argument_list|,
literal|2
argument_list|,
operator|(
name|RF
expr|,
name|ADDRGLDC
operator|)
argument_list|,
name|rd_cpaddr
argument_list|)
block|,
name|cCL
argument_list|(
name|ldfd
argument_list|,
name|c108100
argument_list|,
literal|2
argument_list|,
operator|(
name|RF
expr|,
name|ADDRGLDC
operator|)
argument_list|,
name|rd_cpaddr
argument_list|)
block|,
name|cCL
argument_list|(
name|ldfe
argument_list|,
name|c500100
argument_list|,
literal|2
argument_list|,
operator|(
name|RF
expr|,
name|ADDRGLDC
operator|)
argument_list|,
name|rd_cpaddr
argument_list|)
block|,
name|cCL
argument_list|(
name|ldfp
argument_list|,
name|c508100
argument_list|,
literal|2
argument_list|,
operator|(
name|RF
expr|,
name|ADDRGLDC
operator|)
argument_list|,
name|rd_cpaddr
argument_list|)
block|,
name|cCL
argument_list|(
name|stfs
argument_list|,
name|c000100
argument_list|,
literal|2
argument_list|,
operator|(
name|RF
expr|,
name|ADDRGLDC
operator|)
argument_list|,
name|rd_cpaddr
argument_list|)
block|,
name|cCL
argument_list|(
name|stfd
argument_list|,
name|c008100
argument_list|,
literal|2
argument_list|,
operator|(
name|RF
expr|,
name|ADDRGLDC
operator|)
argument_list|,
name|rd_cpaddr
argument_list|)
block|,
name|cCL
argument_list|(
name|stfe
argument_list|,
name|c400100
argument_list|,
literal|2
argument_list|,
operator|(
name|RF
expr|,
name|ADDRGLDC
operator|)
argument_list|,
name|rd_cpaddr
argument_list|)
block|,
name|cCL
argument_list|(
name|stfp
argument_list|,
name|c408100
argument_list|,
literal|2
argument_list|,
operator|(
name|RF
expr|,
name|ADDRGLDC
operator|)
argument_list|,
name|rd_cpaddr
argument_list|)
block|,
name|cCL
argument_list|(
name|mvfs
argument_list|,
name|e008100
argument_list|,
literal|2
argument_list|,
operator|(
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|mvfsp
argument_list|,
name|e008120
argument_list|,
literal|2
argument_list|,
operator|(
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|mvfsm
argument_list|,
name|e008140
argument_list|,
literal|2
argument_list|,
operator|(
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|mvfsz
argument_list|,
name|e008160
argument_list|,
literal|2
argument_list|,
operator|(
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|mvfd
argument_list|,
name|e008180
argument_list|,
literal|2
argument_list|,
operator|(
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|mvfdp
argument_list|,
name|e0081a0
argument_list|,
literal|2
argument_list|,
operator|(
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|mvfdm
argument_list|,
name|e0081c0
argument_list|,
literal|2
argument_list|,
operator|(
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|mvfdz
argument_list|,
name|e0081e0
argument_list|,
literal|2
argument_list|,
operator|(
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|mvfe
argument_list|,
name|e088100
argument_list|,
literal|2
argument_list|,
operator|(
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|mvfep
argument_list|,
name|e088120
argument_list|,
literal|2
argument_list|,
operator|(
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|mvfem
argument_list|,
name|e088140
argument_list|,
literal|2
argument_list|,
operator|(
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|mvfez
argument_list|,
name|e088160
argument_list|,
literal|2
argument_list|,
operator|(
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|mnfs
argument_list|,
name|e108100
argument_list|,
literal|2
argument_list|,
operator|(
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|mnfsp
argument_list|,
name|e108120
argument_list|,
literal|2
argument_list|,
operator|(
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|mnfsm
argument_list|,
name|e108140
argument_list|,
literal|2
argument_list|,
operator|(
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|mnfsz
argument_list|,
name|e108160
argument_list|,
literal|2
argument_list|,
operator|(
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|mnfd
argument_list|,
name|e108180
argument_list|,
literal|2
argument_list|,
operator|(
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|mnfdp
argument_list|,
name|e1081a0
argument_list|,
literal|2
argument_list|,
operator|(
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|mnfdm
argument_list|,
name|e1081c0
argument_list|,
literal|2
argument_list|,
operator|(
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|mnfdz
argument_list|,
name|e1081e0
argument_list|,
literal|2
argument_list|,
operator|(
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|mnfe
argument_list|,
name|e188100
argument_list|,
literal|2
argument_list|,
operator|(
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|mnfep
argument_list|,
name|e188120
argument_list|,
literal|2
argument_list|,
operator|(
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|mnfem
argument_list|,
name|e188140
argument_list|,
literal|2
argument_list|,
operator|(
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|mnfez
argument_list|,
name|e188160
argument_list|,
literal|2
argument_list|,
operator|(
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|abss
argument_list|,
name|e208100
argument_list|,
literal|2
argument_list|,
operator|(
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|abssp
argument_list|,
name|e208120
argument_list|,
literal|2
argument_list|,
operator|(
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|abssm
argument_list|,
name|e208140
argument_list|,
literal|2
argument_list|,
operator|(
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|abssz
argument_list|,
name|e208160
argument_list|,
literal|2
argument_list|,
operator|(
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|absd
argument_list|,
name|e208180
argument_list|,
literal|2
argument_list|,
operator|(
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|absdp
argument_list|,
name|e2081a0
argument_list|,
literal|2
argument_list|,
operator|(
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|absdm
argument_list|,
name|e2081c0
argument_list|,
literal|2
argument_list|,
operator|(
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|absdz
argument_list|,
name|e2081e0
argument_list|,
literal|2
argument_list|,
operator|(
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|abse
argument_list|,
name|e288100
argument_list|,
literal|2
argument_list|,
operator|(
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|absep
argument_list|,
name|e288120
argument_list|,
literal|2
argument_list|,
operator|(
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|absem
argument_list|,
name|e288140
argument_list|,
literal|2
argument_list|,
operator|(
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|absez
argument_list|,
name|e288160
argument_list|,
literal|2
argument_list|,
operator|(
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|rnds
argument_list|,
name|e308100
argument_list|,
literal|2
argument_list|,
operator|(
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|rndsp
argument_list|,
name|e308120
argument_list|,
literal|2
argument_list|,
operator|(
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|rndsm
argument_list|,
name|e308140
argument_list|,
literal|2
argument_list|,
operator|(
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|rndsz
argument_list|,
name|e308160
argument_list|,
literal|2
argument_list|,
operator|(
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|rndd
argument_list|,
name|e308180
argument_list|,
literal|2
argument_list|,
operator|(
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|rnddp
argument_list|,
name|e3081a0
argument_list|,
literal|2
argument_list|,
operator|(
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|rnddm
argument_list|,
name|e3081c0
argument_list|,
literal|2
argument_list|,
operator|(
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|rnddz
argument_list|,
name|e3081e0
argument_list|,
literal|2
argument_list|,
operator|(
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|rnde
argument_list|,
name|e388100
argument_list|,
literal|2
argument_list|,
operator|(
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|rndep
argument_list|,
name|e388120
argument_list|,
literal|2
argument_list|,
operator|(
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|rndem
argument_list|,
name|e388140
argument_list|,
literal|2
argument_list|,
operator|(
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|rndez
argument_list|,
name|e388160
argument_list|,
literal|2
argument_list|,
operator|(
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|sqts
argument_list|,
name|e408100
argument_list|,
literal|2
argument_list|,
operator|(
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|sqtsp
argument_list|,
name|e408120
argument_list|,
literal|2
argument_list|,
operator|(
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|sqtsm
argument_list|,
name|e408140
argument_list|,
literal|2
argument_list|,
operator|(
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|sqtsz
argument_list|,
name|e408160
argument_list|,
literal|2
argument_list|,
operator|(
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|sqtd
argument_list|,
name|e408180
argument_list|,
literal|2
argument_list|,
operator|(
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|sqtdp
argument_list|,
name|e4081a0
argument_list|,
literal|2
argument_list|,
operator|(
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|sqtdm
argument_list|,
name|e4081c0
argument_list|,
literal|2
argument_list|,
operator|(
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|sqtdz
argument_list|,
name|e4081e0
argument_list|,
literal|2
argument_list|,
operator|(
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|sqte
argument_list|,
name|e488100
argument_list|,
literal|2
argument_list|,
operator|(
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|sqtep
argument_list|,
name|e488120
argument_list|,
literal|2
argument_list|,
operator|(
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|sqtem
argument_list|,
name|e488140
argument_list|,
literal|2
argument_list|,
operator|(
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|sqtez
argument_list|,
name|e488160
argument_list|,
literal|2
argument_list|,
operator|(
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|logs
argument_list|,
name|e508100
argument_list|,
literal|2
argument_list|,
operator|(
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|logsp
argument_list|,
name|e508120
argument_list|,
literal|2
argument_list|,
operator|(
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|logsm
argument_list|,
name|e508140
argument_list|,
literal|2
argument_list|,
operator|(
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|logsz
argument_list|,
name|e508160
argument_list|,
literal|2
argument_list|,
operator|(
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|logd
argument_list|,
name|e508180
argument_list|,
literal|2
argument_list|,
operator|(
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|logdp
argument_list|,
name|e5081a0
argument_list|,
literal|2
argument_list|,
operator|(
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|logdm
argument_list|,
name|e5081c0
argument_list|,
literal|2
argument_list|,
operator|(
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|logdz
argument_list|,
name|e5081e0
argument_list|,
literal|2
argument_list|,
operator|(
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|loge
argument_list|,
name|e588100
argument_list|,
literal|2
argument_list|,
operator|(
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|logep
argument_list|,
name|e588120
argument_list|,
literal|2
argument_list|,
operator|(
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|logem
argument_list|,
name|e588140
argument_list|,
literal|2
argument_list|,
operator|(
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|logez
argument_list|,
name|e588160
argument_list|,
literal|2
argument_list|,
operator|(
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|lgns
argument_list|,
name|e608100
argument_list|,
literal|2
argument_list|,
operator|(
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|lgnsp
argument_list|,
name|e608120
argument_list|,
literal|2
argument_list|,
operator|(
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|lgnsm
argument_list|,
name|e608140
argument_list|,
literal|2
argument_list|,
operator|(
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|lgnsz
argument_list|,
name|e608160
argument_list|,
literal|2
argument_list|,
operator|(
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|lgnd
argument_list|,
name|e608180
argument_list|,
literal|2
argument_list|,
operator|(
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|lgndp
argument_list|,
name|e6081a0
argument_list|,
literal|2
argument_list|,
operator|(
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|lgndm
argument_list|,
name|e6081c0
argument_list|,
literal|2
argument_list|,
operator|(
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|lgndz
argument_list|,
name|e6081e0
argument_list|,
literal|2
argument_list|,
operator|(
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|lgne
argument_list|,
name|e688100
argument_list|,
literal|2
argument_list|,
operator|(
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|lgnep
argument_list|,
name|e688120
argument_list|,
literal|2
argument_list|,
operator|(
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|lgnem
argument_list|,
name|e688140
argument_list|,
literal|2
argument_list|,
operator|(
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|lgnez
argument_list|,
name|e688160
argument_list|,
literal|2
argument_list|,
operator|(
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|exps
argument_list|,
name|e708100
argument_list|,
literal|2
argument_list|,
operator|(
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|expsp
argument_list|,
name|e708120
argument_list|,
literal|2
argument_list|,
operator|(
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|expsm
argument_list|,
name|e708140
argument_list|,
literal|2
argument_list|,
operator|(
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|expsz
argument_list|,
name|e708160
argument_list|,
literal|2
argument_list|,
operator|(
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|expd
argument_list|,
name|e708180
argument_list|,
literal|2
argument_list|,
operator|(
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|expdp
argument_list|,
name|e7081a0
argument_list|,
literal|2
argument_list|,
operator|(
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|expdm
argument_list|,
name|e7081c0
argument_list|,
literal|2
argument_list|,
operator|(
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|expdz
argument_list|,
name|e7081e0
argument_list|,
literal|2
argument_list|,
operator|(
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|expe
argument_list|,
name|e788100
argument_list|,
literal|2
argument_list|,
operator|(
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|expep
argument_list|,
name|e788120
argument_list|,
literal|2
argument_list|,
operator|(
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|expem
argument_list|,
name|e788140
argument_list|,
literal|2
argument_list|,
operator|(
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|expdz
argument_list|,
name|e788160
argument_list|,
literal|2
argument_list|,
operator|(
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|sins
argument_list|,
name|e808100
argument_list|,
literal|2
argument_list|,
operator|(
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|sinsp
argument_list|,
name|e808120
argument_list|,
literal|2
argument_list|,
operator|(
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|sinsm
argument_list|,
name|e808140
argument_list|,
literal|2
argument_list|,
operator|(
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|sinsz
argument_list|,
name|e808160
argument_list|,
literal|2
argument_list|,
operator|(
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|sind
argument_list|,
name|e808180
argument_list|,
literal|2
argument_list|,
operator|(
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|sindp
argument_list|,
name|e8081a0
argument_list|,
literal|2
argument_list|,
operator|(
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|sindm
argument_list|,
name|e8081c0
argument_list|,
literal|2
argument_list|,
operator|(
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|sindz
argument_list|,
name|e8081e0
argument_list|,
literal|2
argument_list|,
operator|(
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|sine
argument_list|,
name|e888100
argument_list|,
literal|2
argument_list|,
operator|(
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|sinep
argument_list|,
name|e888120
argument_list|,
literal|2
argument_list|,
operator|(
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|sinem
argument_list|,
name|e888140
argument_list|,
literal|2
argument_list|,
operator|(
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|sinez
argument_list|,
name|e888160
argument_list|,
literal|2
argument_list|,
operator|(
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|coss
argument_list|,
name|e908100
argument_list|,
literal|2
argument_list|,
operator|(
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|cossp
argument_list|,
name|e908120
argument_list|,
literal|2
argument_list|,
operator|(
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|cossm
argument_list|,
name|e908140
argument_list|,
literal|2
argument_list|,
operator|(
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|cossz
argument_list|,
name|e908160
argument_list|,
literal|2
argument_list|,
operator|(
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|cosd
argument_list|,
name|e908180
argument_list|,
literal|2
argument_list|,
operator|(
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|cosdp
argument_list|,
name|e9081a0
argument_list|,
literal|2
argument_list|,
operator|(
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|cosdm
argument_list|,
name|e9081c0
argument_list|,
literal|2
argument_list|,
operator|(
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|cosdz
argument_list|,
name|e9081e0
argument_list|,
literal|2
argument_list|,
operator|(
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|cose
argument_list|,
name|e988100
argument_list|,
literal|2
argument_list|,
operator|(
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|cosep
argument_list|,
name|e988120
argument_list|,
literal|2
argument_list|,
operator|(
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|cosem
argument_list|,
name|e988140
argument_list|,
literal|2
argument_list|,
operator|(
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|cosez
argument_list|,
name|e988160
argument_list|,
literal|2
argument_list|,
operator|(
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|tans
argument_list|,
name|ea08100
argument_list|,
literal|2
argument_list|,
operator|(
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|tansp
argument_list|,
name|ea08120
argument_list|,
literal|2
argument_list|,
operator|(
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|tansm
argument_list|,
name|ea08140
argument_list|,
literal|2
argument_list|,
operator|(
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|tansz
argument_list|,
name|ea08160
argument_list|,
literal|2
argument_list|,
operator|(
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|tand
argument_list|,
name|ea08180
argument_list|,
literal|2
argument_list|,
operator|(
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|tandp
argument_list|,
name|ea081a0
argument_list|,
literal|2
argument_list|,
operator|(
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|tandm
argument_list|,
name|ea081c0
argument_list|,
literal|2
argument_list|,
operator|(
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|tandz
argument_list|,
name|ea081e0
argument_list|,
literal|2
argument_list|,
operator|(
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|tane
argument_list|,
name|ea88100
argument_list|,
literal|2
argument_list|,
operator|(
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|tanep
argument_list|,
name|ea88120
argument_list|,
literal|2
argument_list|,
operator|(
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|tanem
argument_list|,
name|ea88140
argument_list|,
literal|2
argument_list|,
operator|(
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|tanez
argument_list|,
name|ea88160
argument_list|,
literal|2
argument_list|,
operator|(
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|asns
argument_list|,
name|eb08100
argument_list|,
literal|2
argument_list|,
operator|(
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|asnsp
argument_list|,
name|eb08120
argument_list|,
literal|2
argument_list|,
operator|(
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|asnsm
argument_list|,
name|eb08140
argument_list|,
literal|2
argument_list|,
operator|(
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|asnsz
argument_list|,
name|eb08160
argument_list|,
literal|2
argument_list|,
operator|(
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|asnd
argument_list|,
name|eb08180
argument_list|,
literal|2
argument_list|,
operator|(
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|asndp
argument_list|,
name|eb081a0
argument_list|,
literal|2
argument_list|,
operator|(
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|asndm
argument_list|,
name|eb081c0
argument_list|,
literal|2
argument_list|,
operator|(
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|asndz
argument_list|,
name|eb081e0
argument_list|,
literal|2
argument_list|,
operator|(
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|asne
argument_list|,
name|eb88100
argument_list|,
literal|2
argument_list|,
operator|(
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|asnep
argument_list|,
name|eb88120
argument_list|,
literal|2
argument_list|,
operator|(
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|asnem
argument_list|,
name|eb88140
argument_list|,
literal|2
argument_list|,
operator|(
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|asnez
argument_list|,
name|eb88160
argument_list|,
literal|2
argument_list|,
operator|(
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|acss
argument_list|,
name|ec08100
argument_list|,
literal|2
argument_list|,
operator|(
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|acssp
argument_list|,
name|ec08120
argument_list|,
literal|2
argument_list|,
operator|(
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|acssm
argument_list|,
name|ec08140
argument_list|,
literal|2
argument_list|,
operator|(
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|acssz
argument_list|,
name|ec08160
argument_list|,
literal|2
argument_list|,
operator|(
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|acsd
argument_list|,
name|ec08180
argument_list|,
literal|2
argument_list|,
operator|(
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|acsdp
argument_list|,
name|ec081a0
argument_list|,
literal|2
argument_list|,
operator|(
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|acsdm
argument_list|,
name|ec081c0
argument_list|,
literal|2
argument_list|,
operator|(
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|acsdz
argument_list|,
name|ec081e0
argument_list|,
literal|2
argument_list|,
operator|(
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|acse
argument_list|,
name|ec88100
argument_list|,
literal|2
argument_list|,
operator|(
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|acsep
argument_list|,
name|ec88120
argument_list|,
literal|2
argument_list|,
operator|(
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|acsem
argument_list|,
name|ec88140
argument_list|,
literal|2
argument_list|,
operator|(
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|acsez
argument_list|,
name|ec88160
argument_list|,
literal|2
argument_list|,
operator|(
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|atns
argument_list|,
name|ed08100
argument_list|,
literal|2
argument_list|,
operator|(
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|atnsp
argument_list|,
name|ed08120
argument_list|,
literal|2
argument_list|,
operator|(
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|atnsm
argument_list|,
name|ed08140
argument_list|,
literal|2
argument_list|,
operator|(
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|atnsz
argument_list|,
name|ed08160
argument_list|,
literal|2
argument_list|,
operator|(
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|atnd
argument_list|,
name|ed08180
argument_list|,
literal|2
argument_list|,
operator|(
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|atndp
argument_list|,
name|ed081a0
argument_list|,
literal|2
argument_list|,
operator|(
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|atndm
argument_list|,
name|ed081c0
argument_list|,
literal|2
argument_list|,
operator|(
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|atndz
argument_list|,
name|ed081e0
argument_list|,
literal|2
argument_list|,
operator|(
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|atne
argument_list|,
name|ed88100
argument_list|,
literal|2
argument_list|,
operator|(
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|atnep
argument_list|,
name|ed88120
argument_list|,
literal|2
argument_list|,
operator|(
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|atnem
argument_list|,
name|ed88140
argument_list|,
literal|2
argument_list|,
operator|(
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|atnez
argument_list|,
name|ed88160
argument_list|,
literal|2
argument_list|,
operator|(
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|urds
argument_list|,
name|ee08100
argument_list|,
literal|2
argument_list|,
operator|(
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|urdsp
argument_list|,
name|ee08120
argument_list|,
literal|2
argument_list|,
operator|(
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|urdsm
argument_list|,
name|ee08140
argument_list|,
literal|2
argument_list|,
operator|(
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|urdsz
argument_list|,
name|ee08160
argument_list|,
literal|2
argument_list|,
operator|(
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|urdd
argument_list|,
name|ee08180
argument_list|,
literal|2
argument_list|,
operator|(
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|urddp
argument_list|,
name|ee081a0
argument_list|,
literal|2
argument_list|,
operator|(
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|urddm
argument_list|,
name|ee081c0
argument_list|,
literal|2
argument_list|,
operator|(
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|urddz
argument_list|,
name|ee081e0
argument_list|,
literal|2
argument_list|,
operator|(
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|urde
argument_list|,
name|ee88100
argument_list|,
literal|2
argument_list|,
operator|(
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|urdep
argument_list|,
name|ee88120
argument_list|,
literal|2
argument_list|,
operator|(
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|urdem
argument_list|,
name|ee88140
argument_list|,
literal|2
argument_list|,
operator|(
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|urdez
argument_list|,
name|ee88160
argument_list|,
literal|2
argument_list|,
operator|(
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|nrms
argument_list|,
name|ef08100
argument_list|,
literal|2
argument_list|,
operator|(
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|nrmsp
argument_list|,
name|ef08120
argument_list|,
literal|2
argument_list|,
operator|(
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|nrmsm
argument_list|,
name|ef08140
argument_list|,
literal|2
argument_list|,
operator|(
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|nrmsz
argument_list|,
name|ef08160
argument_list|,
literal|2
argument_list|,
operator|(
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|nrmd
argument_list|,
name|ef08180
argument_list|,
literal|2
argument_list|,
operator|(
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|nrmdp
argument_list|,
name|ef081a0
argument_list|,
literal|2
argument_list|,
operator|(
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|nrmdm
argument_list|,
name|ef081c0
argument_list|,
literal|2
argument_list|,
operator|(
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|nrmdz
argument_list|,
name|ef081e0
argument_list|,
literal|2
argument_list|,
operator|(
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|nrme
argument_list|,
name|ef88100
argument_list|,
literal|2
argument_list|,
operator|(
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|nrmep
argument_list|,
name|ef88120
argument_list|,
literal|2
argument_list|,
operator|(
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|nrmem
argument_list|,
name|ef88140
argument_list|,
literal|2
argument_list|,
operator|(
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|nrmez
argument_list|,
name|ef88160
argument_list|,
literal|2
argument_list|,
operator|(
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|adfs
argument_list|,
name|e000100
argument_list|,
literal|3
argument_list|,
operator|(
name|RF
expr|,
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|adfsp
argument_list|,
name|e000120
argument_list|,
literal|3
argument_list|,
operator|(
name|RF
expr|,
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|adfsm
argument_list|,
name|e000140
argument_list|,
literal|3
argument_list|,
operator|(
name|RF
expr|,
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|adfsz
argument_list|,
name|e000160
argument_list|,
literal|3
argument_list|,
operator|(
name|RF
expr|,
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|adfd
argument_list|,
name|e000180
argument_list|,
literal|3
argument_list|,
operator|(
name|RF
expr|,
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|adfdp
argument_list|,
name|e0001a0
argument_list|,
literal|3
argument_list|,
operator|(
name|RF
expr|,
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|adfdm
argument_list|,
name|e0001c0
argument_list|,
literal|3
argument_list|,
operator|(
name|RF
expr|,
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|adfdz
argument_list|,
name|e0001e0
argument_list|,
literal|3
argument_list|,
operator|(
name|RF
expr|,
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|adfe
argument_list|,
name|e080100
argument_list|,
literal|3
argument_list|,
operator|(
name|RF
expr|,
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|adfep
argument_list|,
name|e080120
argument_list|,
literal|3
argument_list|,
operator|(
name|RF
expr|,
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|adfem
argument_list|,
name|e080140
argument_list|,
literal|3
argument_list|,
operator|(
name|RF
expr|,
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|adfez
argument_list|,
name|e080160
argument_list|,
literal|3
argument_list|,
operator|(
name|RF
expr|,
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|sufs
argument_list|,
name|e200100
argument_list|,
literal|3
argument_list|,
operator|(
name|RF
expr|,
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|sufsp
argument_list|,
name|e200120
argument_list|,
literal|3
argument_list|,
operator|(
name|RF
expr|,
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|sufsm
argument_list|,
name|e200140
argument_list|,
literal|3
argument_list|,
operator|(
name|RF
expr|,
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|sufsz
argument_list|,
name|e200160
argument_list|,
literal|3
argument_list|,
operator|(
name|RF
expr|,
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|sufd
argument_list|,
name|e200180
argument_list|,
literal|3
argument_list|,
operator|(
name|RF
expr|,
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|sufdp
argument_list|,
name|e2001a0
argument_list|,
literal|3
argument_list|,
operator|(
name|RF
expr|,
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|sufdm
argument_list|,
name|e2001c0
argument_list|,
literal|3
argument_list|,
operator|(
name|RF
expr|,
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|sufdz
argument_list|,
name|e2001e0
argument_list|,
literal|3
argument_list|,
operator|(
name|RF
expr|,
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|sufe
argument_list|,
name|e280100
argument_list|,
literal|3
argument_list|,
operator|(
name|RF
expr|,
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|sufep
argument_list|,
name|e280120
argument_list|,
literal|3
argument_list|,
operator|(
name|RF
expr|,
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|sufem
argument_list|,
name|e280140
argument_list|,
literal|3
argument_list|,
operator|(
name|RF
expr|,
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|sufez
argument_list|,
name|e280160
argument_list|,
literal|3
argument_list|,
operator|(
name|RF
expr|,
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|rsfs
argument_list|,
name|e300100
argument_list|,
literal|3
argument_list|,
operator|(
name|RF
expr|,
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|rsfsp
argument_list|,
name|e300120
argument_list|,
literal|3
argument_list|,
operator|(
name|RF
expr|,
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|rsfsm
argument_list|,
name|e300140
argument_list|,
literal|3
argument_list|,
operator|(
name|RF
expr|,
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|rsfsz
argument_list|,
name|e300160
argument_list|,
literal|3
argument_list|,
operator|(
name|RF
expr|,
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|rsfd
argument_list|,
name|e300180
argument_list|,
literal|3
argument_list|,
operator|(
name|RF
expr|,
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|rsfdp
argument_list|,
name|e3001a0
argument_list|,
literal|3
argument_list|,
operator|(
name|RF
expr|,
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|rsfdm
argument_list|,
name|e3001c0
argument_list|,
literal|3
argument_list|,
operator|(
name|RF
expr|,
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|rsfdz
argument_list|,
name|e3001e0
argument_list|,
literal|3
argument_list|,
operator|(
name|RF
expr|,
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|rsfe
argument_list|,
name|e380100
argument_list|,
literal|3
argument_list|,
operator|(
name|RF
expr|,
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|rsfep
argument_list|,
name|e380120
argument_list|,
literal|3
argument_list|,
operator|(
name|RF
expr|,
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|rsfem
argument_list|,
name|e380140
argument_list|,
literal|3
argument_list|,
operator|(
name|RF
expr|,
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|rsfez
argument_list|,
name|e380160
argument_list|,
literal|3
argument_list|,
operator|(
name|RF
expr|,
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|mufs
argument_list|,
name|e100100
argument_list|,
literal|3
argument_list|,
operator|(
name|RF
expr|,
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|mufsp
argument_list|,
name|e100120
argument_list|,
literal|3
argument_list|,
operator|(
name|RF
expr|,
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|mufsm
argument_list|,
name|e100140
argument_list|,
literal|3
argument_list|,
operator|(
name|RF
expr|,
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|mufsz
argument_list|,
name|e100160
argument_list|,
literal|3
argument_list|,
operator|(
name|RF
expr|,
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|mufd
argument_list|,
name|e100180
argument_list|,
literal|3
argument_list|,
operator|(
name|RF
expr|,
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|mufdp
argument_list|,
name|e1001a0
argument_list|,
literal|3
argument_list|,
operator|(
name|RF
expr|,
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|mufdm
argument_list|,
name|e1001c0
argument_list|,
literal|3
argument_list|,
operator|(
name|RF
expr|,
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|mufdz
argument_list|,
name|e1001e0
argument_list|,
literal|3
argument_list|,
operator|(
name|RF
expr|,
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|mufe
argument_list|,
name|e180100
argument_list|,
literal|3
argument_list|,
operator|(
name|RF
expr|,
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|mufep
argument_list|,
name|e180120
argument_list|,
literal|3
argument_list|,
operator|(
name|RF
expr|,
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|mufem
argument_list|,
name|e180140
argument_list|,
literal|3
argument_list|,
operator|(
name|RF
expr|,
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|mufez
argument_list|,
name|e180160
argument_list|,
literal|3
argument_list|,
operator|(
name|RF
expr|,
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|dvfs
argument_list|,
name|e400100
argument_list|,
literal|3
argument_list|,
operator|(
name|RF
expr|,
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|dvfsp
argument_list|,
name|e400120
argument_list|,
literal|3
argument_list|,
operator|(
name|RF
expr|,
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|dvfsm
argument_list|,
name|e400140
argument_list|,
literal|3
argument_list|,
operator|(
name|RF
expr|,
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|dvfsz
argument_list|,
name|e400160
argument_list|,
literal|3
argument_list|,
operator|(
name|RF
expr|,
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|dvfd
argument_list|,
name|e400180
argument_list|,
literal|3
argument_list|,
operator|(
name|RF
expr|,
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|dvfdp
argument_list|,
name|e4001a0
argument_list|,
literal|3
argument_list|,
operator|(
name|RF
expr|,
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|dvfdm
argument_list|,
name|e4001c0
argument_list|,
literal|3
argument_list|,
operator|(
name|RF
expr|,
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|dvfdz
argument_list|,
name|e4001e0
argument_list|,
literal|3
argument_list|,
operator|(
name|RF
expr|,
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|dvfe
argument_list|,
name|e480100
argument_list|,
literal|3
argument_list|,
operator|(
name|RF
expr|,
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|dvfep
argument_list|,
name|e480120
argument_list|,
literal|3
argument_list|,
operator|(
name|RF
expr|,
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|dvfem
argument_list|,
name|e480140
argument_list|,
literal|3
argument_list|,
operator|(
name|RF
expr|,
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|dvfez
argument_list|,
name|e480160
argument_list|,
literal|3
argument_list|,
operator|(
name|RF
expr|,
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|rdfs
argument_list|,
name|e500100
argument_list|,
literal|3
argument_list|,
operator|(
name|RF
expr|,
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|rdfsp
argument_list|,
name|e500120
argument_list|,
literal|3
argument_list|,
operator|(
name|RF
expr|,
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|rdfsm
argument_list|,
name|e500140
argument_list|,
literal|3
argument_list|,
operator|(
name|RF
expr|,
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|rdfsz
argument_list|,
name|e500160
argument_list|,
literal|3
argument_list|,
operator|(
name|RF
expr|,
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|rdfd
argument_list|,
name|e500180
argument_list|,
literal|3
argument_list|,
operator|(
name|RF
expr|,
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|rdfdp
argument_list|,
name|e5001a0
argument_list|,
literal|3
argument_list|,
operator|(
name|RF
expr|,
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|rdfdm
argument_list|,
name|e5001c0
argument_list|,
literal|3
argument_list|,
operator|(
name|RF
expr|,
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|rdfdz
argument_list|,
name|e5001e0
argument_list|,
literal|3
argument_list|,
operator|(
name|RF
expr|,
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|rdfe
argument_list|,
name|e580100
argument_list|,
literal|3
argument_list|,
operator|(
name|RF
expr|,
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|rdfep
argument_list|,
name|e580120
argument_list|,
literal|3
argument_list|,
operator|(
name|RF
expr|,
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|rdfem
argument_list|,
name|e580140
argument_list|,
literal|3
argument_list|,
operator|(
name|RF
expr|,
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|rdfez
argument_list|,
name|e580160
argument_list|,
literal|3
argument_list|,
operator|(
name|RF
expr|,
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|pows
argument_list|,
name|e600100
argument_list|,
literal|3
argument_list|,
operator|(
name|RF
expr|,
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|powsp
argument_list|,
name|e600120
argument_list|,
literal|3
argument_list|,
operator|(
name|RF
expr|,
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|powsm
argument_list|,
name|e600140
argument_list|,
literal|3
argument_list|,
operator|(
name|RF
expr|,
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|powsz
argument_list|,
name|e600160
argument_list|,
literal|3
argument_list|,
operator|(
name|RF
expr|,
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|powd
argument_list|,
name|e600180
argument_list|,
literal|3
argument_list|,
operator|(
name|RF
expr|,
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|powdp
argument_list|,
name|e6001a0
argument_list|,
literal|3
argument_list|,
operator|(
name|RF
expr|,
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|powdm
argument_list|,
name|e6001c0
argument_list|,
literal|3
argument_list|,
operator|(
name|RF
expr|,
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|powdz
argument_list|,
name|e6001e0
argument_list|,
literal|3
argument_list|,
operator|(
name|RF
expr|,
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|powe
argument_list|,
name|e680100
argument_list|,
literal|3
argument_list|,
operator|(
name|RF
expr|,
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|powep
argument_list|,
name|e680120
argument_list|,
literal|3
argument_list|,
operator|(
name|RF
expr|,
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|powem
argument_list|,
name|e680140
argument_list|,
literal|3
argument_list|,
operator|(
name|RF
expr|,
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|powez
argument_list|,
name|e680160
argument_list|,
literal|3
argument_list|,
operator|(
name|RF
expr|,
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|rpws
argument_list|,
name|e700100
argument_list|,
literal|3
argument_list|,
operator|(
name|RF
expr|,
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|rpwsp
argument_list|,
name|e700120
argument_list|,
literal|3
argument_list|,
operator|(
name|RF
expr|,
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|rpwsm
argument_list|,
name|e700140
argument_list|,
literal|3
argument_list|,
operator|(
name|RF
expr|,
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|rpwsz
argument_list|,
name|e700160
argument_list|,
literal|3
argument_list|,
operator|(
name|RF
expr|,
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|rpwd
argument_list|,
name|e700180
argument_list|,
literal|3
argument_list|,
operator|(
name|RF
expr|,
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|rpwdp
argument_list|,
name|e7001a0
argument_list|,
literal|3
argument_list|,
operator|(
name|RF
expr|,
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|rpwdm
argument_list|,
name|e7001c0
argument_list|,
literal|3
argument_list|,
operator|(
name|RF
expr|,
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|rpwdz
argument_list|,
name|e7001e0
argument_list|,
literal|3
argument_list|,
operator|(
name|RF
expr|,
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|rpwe
argument_list|,
name|e780100
argument_list|,
literal|3
argument_list|,
operator|(
name|RF
expr|,
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|rpwep
argument_list|,
name|e780120
argument_list|,
literal|3
argument_list|,
operator|(
name|RF
expr|,
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|rpwem
argument_list|,
name|e780140
argument_list|,
literal|3
argument_list|,
operator|(
name|RF
expr|,
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|rpwez
argument_list|,
name|e780160
argument_list|,
literal|3
argument_list|,
operator|(
name|RF
expr|,
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|rmfs
argument_list|,
name|e800100
argument_list|,
literal|3
argument_list|,
operator|(
name|RF
expr|,
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|rmfsp
argument_list|,
name|e800120
argument_list|,
literal|3
argument_list|,
operator|(
name|RF
expr|,
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|rmfsm
argument_list|,
name|e800140
argument_list|,
literal|3
argument_list|,
operator|(
name|RF
expr|,
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|rmfsz
argument_list|,
name|e800160
argument_list|,
literal|3
argument_list|,
operator|(
name|RF
expr|,
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|rmfd
argument_list|,
name|e800180
argument_list|,
literal|3
argument_list|,
operator|(
name|RF
expr|,
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|rmfdp
argument_list|,
name|e8001a0
argument_list|,
literal|3
argument_list|,
operator|(
name|RF
expr|,
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|rmfdm
argument_list|,
name|e8001c0
argument_list|,
literal|3
argument_list|,
operator|(
name|RF
expr|,
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|rmfdz
argument_list|,
name|e8001e0
argument_list|,
literal|3
argument_list|,
operator|(
name|RF
expr|,
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|rmfe
argument_list|,
name|e880100
argument_list|,
literal|3
argument_list|,
operator|(
name|RF
expr|,
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|rmfep
argument_list|,
name|e880120
argument_list|,
literal|3
argument_list|,
operator|(
name|RF
expr|,
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|rmfem
argument_list|,
name|e880140
argument_list|,
literal|3
argument_list|,
operator|(
name|RF
expr|,
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|rmfez
argument_list|,
name|e880160
argument_list|,
literal|3
argument_list|,
operator|(
name|RF
expr|,
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|fmls
argument_list|,
name|e900100
argument_list|,
literal|3
argument_list|,
operator|(
name|RF
expr|,
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|fmlsp
argument_list|,
name|e900120
argument_list|,
literal|3
argument_list|,
operator|(
name|RF
expr|,
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|fmlsm
argument_list|,
name|e900140
argument_list|,
literal|3
argument_list|,
operator|(
name|RF
expr|,
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|fmlsz
argument_list|,
name|e900160
argument_list|,
literal|3
argument_list|,
operator|(
name|RF
expr|,
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|fmld
argument_list|,
name|e900180
argument_list|,
literal|3
argument_list|,
operator|(
name|RF
expr|,
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|fmldp
argument_list|,
name|e9001a0
argument_list|,
literal|3
argument_list|,
operator|(
name|RF
expr|,
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|fmldm
argument_list|,
name|e9001c0
argument_list|,
literal|3
argument_list|,
operator|(
name|RF
expr|,
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|fmldz
argument_list|,
name|e9001e0
argument_list|,
literal|3
argument_list|,
operator|(
name|RF
expr|,
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|fmle
argument_list|,
name|e980100
argument_list|,
literal|3
argument_list|,
operator|(
name|RF
expr|,
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|fmlep
argument_list|,
name|e980120
argument_list|,
literal|3
argument_list|,
operator|(
name|RF
expr|,
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|fmlem
argument_list|,
name|e980140
argument_list|,
literal|3
argument_list|,
operator|(
name|RF
expr|,
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|fmlez
argument_list|,
name|e980160
argument_list|,
literal|3
argument_list|,
operator|(
name|RF
expr|,
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|fdvs
argument_list|,
name|ea00100
argument_list|,
literal|3
argument_list|,
operator|(
name|RF
expr|,
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|fdvsp
argument_list|,
name|ea00120
argument_list|,
literal|3
argument_list|,
operator|(
name|RF
expr|,
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|fdvsm
argument_list|,
name|ea00140
argument_list|,
literal|3
argument_list|,
operator|(
name|RF
expr|,
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|fdvsz
argument_list|,
name|ea00160
argument_list|,
literal|3
argument_list|,
operator|(
name|RF
expr|,
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|fdvd
argument_list|,
name|ea00180
argument_list|,
literal|3
argument_list|,
operator|(
name|RF
expr|,
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|fdvdp
argument_list|,
name|ea001a0
argument_list|,
literal|3
argument_list|,
operator|(
name|RF
expr|,
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|fdvdm
argument_list|,
name|ea001c0
argument_list|,
literal|3
argument_list|,
operator|(
name|RF
expr|,
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|fdvdz
argument_list|,
name|ea001e0
argument_list|,
literal|3
argument_list|,
operator|(
name|RF
expr|,
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|fdve
argument_list|,
name|ea80100
argument_list|,
literal|3
argument_list|,
operator|(
name|RF
expr|,
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|fdvep
argument_list|,
name|ea80120
argument_list|,
literal|3
argument_list|,
operator|(
name|RF
expr|,
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|fdvem
argument_list|,
name|ea80140
argument_list|,
literal|3
argument_list|,
operator|(
name|RF
expr|,
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|fdvez
argument_list|,
name|ea80160
argument_list|,
literal|3
argument_list|,
operator|(
name|RF
expr|,
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|frds
argument_list|,
name|eb00100
argument_list|,
literal|3
argument_list|,
operator|(
name|RF
expr|,
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|frdsp
argument_list|,
name|eb00120
argument_list|,
literal|3
argument_list|,
operator|(
name|RF
expr|,
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|frdsm
argument_list|,
name|eb00140
argument_list|,
literal|3
argument_list|,
operator|(
name|RF
expr|,
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|frdsz
argument_list|,
name|eb00160
argument_list|,
literal|3
argument_list|,
operator|(
name|RF
expr|,
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|frdd
argument_list|,
name|eb00180
argument_list|,
literal|3
argument_list|,
operator|(
name|RF
expr|,
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|frddp
argument_list|,
name|eb001a0
argument_list|,
literal|3
argument_list|,
operator|(
name|RF
expr|,
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|frddm
argument_list|,
name|eb001c0
argument_list|,
literal|3
argument_list|,
operator|(
name|RF
expr|,
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|frddz
argument_list|,
name|eb001e0
argument_list|,
literal|3
argument_list|,
operator|(
name|RF
expr|,
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|frde
argument_list|,
name|eb80100
argument_list|,
literal|3
argument_list|,
operator|(
name|RF
expr|,
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|frdep
argument_list|,
name|eb80120
argument_list|,
literal|3
argument_list|,
operator|(
name|RF
expr|,
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|frdem
argument_list|,
name|eb80140
argument_list|,
literal|3
argument_list|,
operator|(
name|RF
expr|,
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|frdez
argument_list|,
name|eb80160
argument_list|,
literal|3
argument_list|,
operator|(
name|RF
expr|,
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|pols
argument_list|,
name|ec00100
argument_list|,
literal|3
argument_list|,
operator|(
name|RF
expr|,
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|polsp
argument_list|,
name|ec00120
argument_list|,
literal|3
argument_list|,
operator|(
name|RF
expr|,
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|polsm
argument_list|,
name|ec00140
argument_list|,
literal|3
argument_list|,
operator|(
name|RF
expr|,
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|polsz
argument_list|,
name|ec00160
argument_list|,
literal|3
argument_list|,
operator|(
name|RF
expr|,
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|pold
argument_list|,
name|ec00180
argument_list|,
literal|3
argument_list|,
operator|(
name|RF
expr|,
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|poldp
argument_list|,
name|ec001a0
argument_list|,
literal|3
argument_list|,
operator|(
name|RF
expr|,
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|poldm
argument_list|,
name|ec001c0
argument_list|,
literal|3
argument_list|,
operator|(
name|RF
expr|,
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|poldz
argument_list|,
name|ec001e0
argument_list|,
literal|3
argument_list|,
operator|(
name|RF
expr|,
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|pole
argument_list|,
name|ec80100
argument_list|,
literal|3
argument_list|,
operator|(
name|RF
expr|,
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|polep
argument_list|,
name|ec80120
argument_list|,
literal|3
argument_list|,
operator|(
name|RF
expr|,
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|polem
argument_list|,
name|ec80140
argument_list|,
literal|3
argument_list|,
operator|(
name|RF
expr|,
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|polez
argument_list|,
name|ec80160
argument_list|,
literal|3
argument_list|,
operator|(
name|RF
expr|,
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCE
argument_list|(
name|cmf
argument_list|,
name|e90f110
argument_list|,
literal|2
argument_list|,
operator|(
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|fpa_cmp
argument_list|)
block|,
name|C3E
argument_list|(
name|cmfe
argument_list|,
name|ed0f110
argument_list|,
literal|2
argument_list|,
operator|(
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|fpa_cmp
argument_list|)
block|,
name|cCE
argument_list|(
name|cnf
argument_list|,
name|eb0f110
argument_list|,
literal|2
argument_list|,
operator|(
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|fpa_cmp
argument_list|)
block|,
name|C3E
argument_list|(
name|cnfe
argument_list|,
name|ef0f110
argument_list|,
literal|2
argument_list|,
operator|(
name|RF
expr|,
name|RF_IF
operator|)
argument_list|,
name|fpa_cmp
argument_list|)
block|,
name|cCL
argument_list|(
name|flts
argument_list|,
name|e000110
argument_list|,
literal|2
argument_list|,
operator|(
name|RF
expr|,
name|RR
operator|)
argument_list|,
name|rn_rd
argument_list|)
block|,
name|cCL
argument_list|(
name|fltsp
argument_list|,
name|e000130
argument_list|,
literal|2
argument_list|,
operator|(
name|RF
expr|,
name|RR
operator|)
argument_list|,
name|rn_rd
argument_list|)
block|,
name|cCL
argument_list|(
name|fltsm
argument_list|,
name|e000150
argument_list|,
literal|2
argument_list|,
operator|(
name|RF
expr|,
name|RR
operator|)
argument_list|,
name|rn_rd
argument_list|)
block|,
name|cCL
argument_list|(
name|fltsz
argument_list|,
name|e000170
argument_list|,
literal|2
argument_list|,
operator|(
name|RF
expr|,
name|RR
operator|)
argument_list|,
name|rn_rd
argument_list|)
block|,
name|cCL
argument_list|(
name|fltd
argument_list|,
name|e000190
argument_list|,
literal|2
argument_list|,
operator|(
name|RF
expr|,
name|RR
operator|)
argument_list|,
name|rn_rd
argument_list|)
block|,
name|cCL
argument_list|(
name|fltdp
argument_list|,
name|e0001b0
argument_list|,
literal|2
argument_list|,
operator|(
name|RF
expr|,
name|RR
operator|)
argument_list|,
name|rn_rd
argument_list|)
block|,
name|cCL
argument_list|(
name|fltdm
argument_list|,
name|e0001d0
argument_list|,
literal|2
argument_list|,
operator|(
name|RF
expr|,
name|RR
operator|)
argument_list|,
name|rn_rd
argument_list|)
block|,
name|cCL
argument_list|(
name|fltdz
argument_list|,
name|e0001f0
argument_list|,
literal|2
argument_list|,
operator|(
name|RF
expr|,
name|RR
operator|)
argument_list|,
name|rn_rd
argument_list|)
block|,
name|cCL
argument_list|(
name|flte
argument_list|,
name|e080110
argument_list|,
literal|2
argument_list|,
operator|(
name|RF
expr|,
name|RR
operator|)
argument_list|,
name|rn_rd
argument_list|)
block|,
name|cCL
argument_list|(
name|fltep
argument_list|,
name|e080130
argument_list|,
literal|2
argument_list|,
operator|(
name|RF
expr|,
name|RR
operator|)
argument_list|,
name|rn_rd
argument_list|)
block|,
name|cCL
argument_list|(
name|fltem
argument_list|,
name|e080150
argument_list|,
literal|2
argument_list|,
operator|(
name|RF
expr|,
name|RR
operator|)
argument_list|,
name|rn_rd
argument_list|)
block|,
name|cCL
argument_list|(
name|fltez
argument_list|,
name|e080170
argument_list|,
literal|2
argument_list|,
operator|(
name|RF
expr|,
name|RR
operator|)
argument_list|,
name|rn_rd
argument_list|)
block|,
comment|/* The implementation of the FIX instruction is broken on some      assemblers, in that it accepts a precision specifier as well as a      rounding specifier, despite the fact that this is meaningless.      To be more compatible, we accept it as well, though of course it      does not set any bits.  */
name|cCE
argument_list|(
name|fix
argument_list|,
name|e100110
argument_list|,
literal|2
argument_list|,
operator|(
name|RR
expr|,
name|RF
operator|)
argument_list|,
name|rd_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|fixp
argument_list|,
name|e100130
argument_list|,
literal|2
argument_list|,
operator|(
name|RR
expr|,
name|RF
operator|)
argument_list|,
name|rd_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|fixm
argument_list|,
name|e100150
argument_list|,
literal|2
argument_list|,
operator|(
name|RR
expr|,
name|RF
operator|)
argument_list|,
name|rd_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|fixz
argument_list|,
name|e100170
argument_list|,
literal|2
argument_list|,
operator|(
name|RR
expr|,
name|RF
operator|)
argument_list|,
name|rd_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|fixsp
argument_list|,
name|e100130
argument_list|,
literal|2
argument_list|,
operator|(
name|RR
expr|,
name|RF
operator|)
argument_list|,
name|rd_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|fixsm
argument_list|,
name|e100150
argument_list|,
literal|2
argument_list|,
operator|(
name|RR
expr|,
name|RF
operator|)
argument_list|,
name|rd_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|fixsz
argument_list|,
name|e100170
argument_list|,
literal|2
argument_list|,
operator|(
name|RR
expr|,
name|RF
operator|)
argument_list|,
name|rd_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|fixdp
argument_list|,
name|e100130
argument_list|,
literal|2
argument_list|,
operator|(
name|RR
expr|,
name|RF
operator|)
argument_list|,
name|rd_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|fixdm
argument_list|,
name|e100150
argument_list|,
literal|2
argument_list|,
operator|(
name|RR
expr|,
name|RF
operator|)
argument_list|,
name|rd_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|fixdz
argument_list|,
name|e100170
argument_list|,
literal|2
argument_list|,
operator|(
name|RR
expr|,
name|RF
operator|)
argument_list|,
name|rd_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|fixep
argument_list|,
name|e100130
argument_list|,
literal|2
argument_list|,
operator|(
name|RR
expr|,
name|RF
operator|)
argument_list|,
name|rd_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|fixem
argument_list|,
name|e100150
argument_list|,
literal|2
argument_list|,
operator|(
name|RR
expr|,
name|RF
operator|)
argument_list|,
name|rd_rm
argument_list|)
block|,
name|cCL
argument_list|(
name|fixez
argument_list|,
name|e100170
argument_list|,
literal|2
argument_list|,
operator|(
name|RR
expr|,
name|RF
operator|)
argument_list|,
name|rd_rm
argument_list|)
block|,
comment|/* Instructions that were new with the real FPA, call them V2.  */
undef|#
directive|undef
name|ARM_VARIANT
define|#
directive|define
name|ARM_VARIANT
value|&fpu_fpa_ext_v2
name|cCE
argument_list|(
name|lfm
argument_list|,
name|c100200
argument_list|,
literal|3
argument_list|,
operator|(
name|RF
expr|,
name|I4b
expr|,
name|ADDR
operator|)
argument_list|,
name|fpa_ldmstm
argument_list|)
block|,
name|cCL
argument_list|(
name|lfmfd
argument_list|,
name|c900200
argument_list|,
literal|3
argument_list|,
operator|(
name|RF
expr|,
name|I4b
expr|,
name|ADDR
operator|)
argument_list|,
name|fpa_ldmstm
argument_list|)
block|,
name|cCL
argument_list|(
name|lfmea
argument_list|,
name|d100200
argument_list|,
literal|3
argument_list|,
operator|(
name|RF
expr|,
name|I4b
expr|,
name|ADDR
operator|)
argument_list|,
name|fpa_ldmstm
argument_list|)
block|,
name|cCE
argument_list|(
name|sfm
argument_list|,
name|c000200
argument_list|,
literal|3
argument_list|,
operator|(
name|RF
expr|,
name|I4b
expr|,
name|ADDR
operator|)
argument_list|,
name|fpa_ldmstm
argument_list|)
block|,
name|cCL
argument_list|(
name|sfmfd
argument_list|,
name|d000200
argument_list|,
literal|3
argument_list|,
operator|(
name|RF
expr|,
name|I4b
expr|,
name|ADDR
operator|)
argument_list|,
name|fpa_ldmstm
argument_list|)
block|,
name|cCL
argument_list|(
name|sfmea
argument_list|,
name|c800200
argument_list|,
literal|3
argument_list|,
operator|(
name|RF
expr|,
name|I4b
expr|,
name|ADDR
operator|)
argument_list|,
name|fpa_ldmstm
argument_list|)
block|,
undef|#
directive|undef
name|ARM_VARIANT
define|#
directive|define
name|ARM_VARIANT
value|&fpu_vfp_ext_v1xd
comment|/* VFP V1xD (single precision).  */
comment|/* Moves and type conversions.  */
name|cCE
argument_list|(
name|fcpys
argument_list|,
name|eb00a40
argument_list|,
literal|2
argument_list|,
operator|(
name|RVS
expr|,
name|RVS
operator|)
argument_list|,
name|vfp_sp_monadic
argument_list|)
block|,
name|cCE
argument_list|(
name|fmrs
argument_list|,
name|e100a10
argument_list|,
literal|2
argument_list|,
operator|(
name|RR
expr|,
name|RVS
operator|)
argument_list|,
name|vfp_reg_from_sp
argument_list|)
block|,
name|cCE
argument_list|(
name|fmsr
argument_list|,
name|e000a10
argument_list|,
literal|2
argument_list|,
operator|(
name|RVS
expr|,
name|RR
operator|)
argument_list|,
name|vfp_sp_from_reg
argument_list|)
block|,
name|cCE
argument_list|(
name|fmstat
argument_list|,
name|ef1fa10
argument_list|,
literal|0
argument_list|,
operator|(
operator|)
argument_list|,
name|noargs
argument_list|)
block|,
name|cCE
argument_list|(
name|fsitos
argument_list|,
name|eb80ac0
argument_list|,
literal|2
argument_list|,
operator|(
name|RVS
expr|,
name|RVS
operator|)
argument_list|,
name|vfp_sp_monadic
argument_list|)
block|,
name|cCE
argument_list|(
name|fuitos
argument_list|,
name|eb80a40
argument_list|,
literal|2
argument_list|,
operator|(
name|RVS
expr|,
name|RVS
operator|)
argument_list|,
name|vfp_sp_monadic
argument_list|)
block|,
name|cCE
argument_list|(
name|ftosis
argument_list|,
name|ebd0a40
argument_list|,
literal|2
argument_list|,
operator|(
name|RVS
expr|,
name|RVS
operator|)
argument_list|,
name|vfp_sp_monadic
argument_list|)
block|,
name|cCE
argument_list|(
name|ftosizs
argument_list|,
name|ebd0ac0
argument_list|,
literal|2
argument_list|,
operator|(
name|RVS
expr|,
name|RVS
operator|)
argument_list|,
name|vfp_sp_monadic
argument_list|)
block|,
name|cCE
argument_list|(
name|ftouis
argument_list|,
name|ebc0a40
argument_list|,
literal|2
argument_list|,
operator|(
name|RVS
expr|,
name|RVS
operator|)
argument_list|,
name|vfp_sp_monadic
argument_list|)
block|,
name|cCE
argument_list|(
name|ftouizs
argument_list|,
name|ebc0ac0
argument_list|,
literal|2
argument_list|,
operator|(
name|RVS
expr|,
name|RVS
operator|)
argument_list|,
name|vfp_sp_monadic
argument_list|)
block|,
name|cCE
argument_list|(
name|fmrx
argument_list|,
name|ef00a10
argument_list|,
literal|2
argument_list|,
operator|(
name|RR
expr|,
name|RVC
operator|)
argument_list|,
name|rd_rn
argument_list|)
block|,
name|cCE
argument_list|(
name|fmxr
argument_list|,
name|ee00a10
argument_list|,
literal|2
argument_list|,
operator|(
name|RVC
expr|,
name|RR
operator|)
argument_list|,
name|rn_rd
argument_list|)
block|,
name|cCE
argument_list|(
name|vmrs
argument_list|,
name|ef00a10
argument_list|,
literal|2
argument_list|,
operator|(
name|APSR_RR
expr|,
name|RVC
operator|)
argument_list|,
name|vfp_vmrs
argument_list|)
block|,
name|cCE
argument_list|(
name|vmsr
argument_list|,
name|ee00a10
argument_list|,
literal|2
argument_list|,
operator|(
name|RVC
expr|,
name|RR
operator|)
argument_list|,
name|vfp_vmsr
argument_list|)
block|,
comment|/* Memory operations.	 */
name|cCE
argument_list|(
name|flds
argument_list|,
name|d100a00
argument_list|,
literal|2
argument_list|,
operator|(
name|RVS
expr|,
name|ADDRGLDC
operator|)
argument_list|,
name|vfp_sp_ldst
argument_list|)
block|,
name|cCE
argument_list|(
name|fsts
argument_list|,
name|d000a00
argument_list|,
literal|2
argument_list|,
operator|(
name|RVS
expr|,
name|ADDRGLDC
operator|)
argument_list|,
name|vfp_sp_ldst
argument_list|)
block|,
name|cCE
argument_list|(
name|fldmias
argument_list|,
name|c900a00
argument_list|,
literal|2
argument_list|,
operator|(
name|RRw
expr|,
name|VRSLST
operator|)
argument_list|,
name|vfp_sp_ldstmia
argument_list|)
block|,
name|cCE
argument_list|(
name|fldmfds
argument_list|,
name|c900a00
argument_list|,
literal|2
argument_list|,
operator|(
name|RRw
expr|,
name|VRSLST
operator|)
argument_list|,
name|vfp_sp_ldstmia
argument_list|)
block|,
name|cCE
argument_list|(
name|fldmdbs
argument_list|,
name|d300a00
argument_list|,
literal|2
argument_list|,
operator|(
name|RRw
expr|,
name|VRSLST
operator|)
argument_list|,
name|vfp_sp_ldstmdb
argument_list|)
block|,
name|cCE
argument_list|(
name|fldmeas
argument_list|,
name|d300a00
argument_list|,
literal|2
argument_list|,
operator|(
name|RRw
expr|,
name|VRSLST
operator|)
argument_list|,
name|vfp_sp_ldstmdb
argument_list|)
block|,
name|cCE
argument_list|(
name|fldmiax
argument_list|,
name|c900b00
argument_list|,
literal|2
argument_list|,
operator|(
name|RRw
expr|,
name|VRDLST
operator|)
argument_list|,
name|vfp_xp_ldstmia
argument_list|)
block|,
name|cCE
argument_list|(
name|fldmfdx
argument_list|,
name|c900b00
argument_list|,
literal|2
argument_list|,
operator|(
name|RRw
expr|,
name|VRDLST
operator|)
argument_list|,
name|vfp_xp_ldstmia
argument_list|)
block|,
name|cCE
argument_list|(
name|fldmdbx
argument_list|,
name|d300b00
argument_list|,
literal|2
argument_list|,
operator|(
name|RRw
expr|,
name|VRDLST
operator|)
argument_list|,
name|vfp_xp_ldstmdb
argument_list|)
block|,
name|cCE
argument_list|(
name|fldmeax
argument_list|,
name|d300b00
argument_list|,
literal|2
argument_list|,
operator|(
name|RRw
expr|,
name|VRDLST
operator|)
argument_list|,
name|vfp_xp_ldstmdb
argument_list|)
block|,
name|cCE
argument_list|(
name|fstmias
argument_list|,
name|c800a00
argument_list|,
literal|2
argument_list|,
operator|(
name|RRw
expr|,
name|VRSLST
operator|)
argument_list|,
name|vfp_sp_ldstmia
argument_list|)
block|,
name|cCE
argument_list|(
name|fstmeas
argument_list|,
name|c800a00
argument_list|,
literal|2
argument_list|,
operator|(
name|RRw
expr|,
name|VRSLST
operator|)
argument_list|,
name|vfp_sp_ldstmia
argument_list|)
block|,
name|cCE
argument_list|(
name|fstmdbs
argument_list|,
name|d200a00
argument_list|,
literal|2
argument_list|,
operator|(
name|RRw
expr|,
name|VRSLST
operator|)
argument_list|,
name|vfp_sp_ldstmdb
argument_list|)
block|,
name|cCE
argument_list|(
name|fstmfds
argument_list|,
name|d200a00
argument_list|,
literal|2
argument_list|,
operator|(
name|RRw
expr|,
name|VRSLST
operator|)
argument_list|,
name|vfp_sp_ldstmdb
argument_list|)
block|,
name|cCE
argument_list|(
name|fstmiax
argument_list|,
name|c800b00
argument_list|,
literal|2
argument_list|,
operator|(
name|RRw
expr|,
name|VRDLST
operator|)
argument_list|,
name|vfp_xp_ldstmia
argument_list|)
block|,
name|cCE
argument_list|(
name|fstmeax
argument_list|,
name|c800b00
argument_list|,
literal|2
argument_list|,
operator|(
name|RRw
expr|,
name|VRDLST
operator|)
argument_list|,
name|vfp_xp_ldstmia
argument_list|)
block|,
name|cCE
argument_list|(
name|fstmdbx
argument_list|,
name|d200b00
argument_list|,
literal|2
argument_list|,
operator|(
name|RRw
expr|,
name|VRDLST
operator|)
argument_list|,
name|vfp_xp_ldstmdb
argument_list|)
block|,
name|cCE
argument_list|(
name|fstmfdx
argument_list|,
name|d200b00
argument_list|,
literal|2
argument_list|,
operator|(
name|RRw
expr|,
name|VRDLST
operator|)
argument_list|,
name|vfp_xp_ldstmdb
argument_list|)
block|,
comment|/* Monadic operations.  */
name|cCE
argument_list|(
name|fabss
argument_list|,
name|eb00ac0
argument_list|,
literal|2
argument_list|,
operator|(
name|RVS
expr|,
name|RVS
operator|)
argument_list|,
name|vfp_sp_monadic
argument_list|)
block|,
name|cCE
argument_list|(
name|fnegs
argument_list|,
name|eb10a40
argument_list|,
literal|2
argument_list|,
operator|(
name|RVS
expr|,
name|RVS
operator|)
argument_list|,
name|vfp_sp_monadic
argument_list|)
block|,
name|cCE
argument_list|(
name|fsqrts
argument_list|,
name|eb10ac0
argument_list|,
literal|2
argument_list|,
operator|(
name|RVS
expr|,
name|RVS
operator|)
argument_list|,
name|vfp_sp_monadic
argument_list|)
block|,
comment|/* Dyadic operations.	 */
name|cCE
argument_list|(
name|fadds
argument_list|,
name|e300a00
argument_list|,
literal|3
argument_list|,
operator|(
name|RVS
expr|,
name|RVS
expr|,
name|RVS
operator|)
argument_list|,
name|vfp_sp_dyadic
argument_list|)
block|,
name|cCE
argument_list|(
name|fsubs
argument_list|,
name|e300a40
argument_list|,
literal|3
argument_list|,
operator|(
name|RVS
expr|,
name|RVS
expr|,
name|RVS
operator|)
argument_list|,
name|vfp_sp_dyadic
argument_list|)
block|,
name|cCE
argument_list|(
name|fmuls
argument_list|,
name|e200a00
argument_list|,
literal|3
argument_list|,
operator|(
name|RVS
expr|,
name|RVS
expr|,
name|RVS
operator|)
argument_list|,
name|vfp_sp_dyadic
argument_list|)
block|,
name|cCE
argument_list|(
name|fdivs
argument_list|,
name|e800a00
argument_list|,
literal|3
argument_list|,
operator|(
name|RVS
expr|,
name|RVS
expr|,
name|RVS
operator|)
argument_list|,
name|vfp_sp_dyadic
argument_list|)
block|,
name|cCE
argument_list|(
name|fmacs
argument_list|,
name|e000a00
argument_list|,
literal|3
argument_list|,
operator|(
name|RVS
expr|,
name|RVS
expr|,
name|RVS
operator|)
argument_list|,
name|vfp_sp_dyadic
argument_list|)
block|,
name|cCE
argument_list|(
name|fmscs
argument_list|,
name|e100a00
argument_list|,
literal|3
argument_list|,
operator|(
name|RVS
expr|,
name|RVS
expr|,
name|RVS
operator|)
argument_list|,
name|vfp_sp_dyadic
argument_list|)
block|,
name|cCE
argument_list|(
name|fnmuls
argument_list|,
name|e200a40
argument_list|,
literal|3
argument_list|,
operator|(
name|RVS
expr|,
name|RVS
expr|,
name|RVS
operator|)
argument_list|,
name|vfp_sp_dyadic
argument_list|)
block|,
name|cCE
argument_list|(
name|fnmacs
argument_list|,
name|e000a40
argument_list|,
literal|3
argument_list|,
operator|(
name|RVS
expr|,
name|RVS
expr|,
name|RVS
operator|)
argument_list|,
name|vfp_sp_dyadic
argument_list|)
block|,
name|cCE
argument_list|(
name|fnmscs
argument_list|,
name|e100a40
argument_list|,
literal|3
argument_list|,
operator|(
name|RVS
expr|,
name|RVS
expr|,
name|RVS
operator|)
argument_list|,
name|vfp_sp_dyadic
argument_list|)
block|,
comment|/* Comparisons.  */
name|cCE
argument_list|(
name|fcmps
argument_list|,
name|eb40a40
argument_list|,
literal|2
argument_list|,
operator|(
name|RVS
expr|,
name|RVS
operator|)
argument_list|,
name|vfp_sp_monadic
argument_list|)
block|,
name|cCE
argument_list|(
name|fcmpzs
argument_list|,
name|eb50a40
argument_list|,
literal|1
argument_list|,
operator|(
name|RVS
operator|)
argument_list|,
name|vfp_sp_compare_z
argument_list|)
block|,
name|cCE
argument_list|(
name|fcmpes
argument_list|,
name|eb40ac0
argument_list|,
literal|2
argument_list|,
operator|(
name|RVS
expr|,
name|RVS
operator|)
argument_list|,
name|vfp_sp_monadic
argument_list|)
block|,
name|cCE
argument_list|(
name|fcmpezs
argument_list|,
name|eb50ac0
argument_list|,
literal|1
argument_list|,
operator|(
name|RVS
operator|)
argument_list|,
name|vfp_sp_compare_z
argument_list|)
block|,
undef|#
directive|undef
name|ARM_VARIANT
define|#
directive|define
name|ARM_VARIANT
value|&fpu_vfp_ext_v1
comment|/* VFP V1 (Double precision).  */
comment|/* Moves and type conversions.  */
name|cCE
argument_list|(
name|fcpyd
argument_list|,
name|eb00b40
argument_list|,
literal|2
argument_list|,
operator|(
name|RVD
expr|,
name|RVD
operator|)
argument_list|,
name|vfp_dp_rd_rm
argument_list|)
block|,
name|cCE
argument_list|(
name|fcvtds
argument_list|,
name|eb70ac0
argument_list|,
literal|2
argument_list|,
operator|(
name|RVD
expr|,
name|RVS
operator|)
argument_list|,
name|vfp_dp_sp_cvt
argument_list|)
block|,
name|cCE
argument_list|(
name|fcvtsd
argument_list|,
name|eb70bc0
argument_list|,
literal|2
argument_list|,
operator|(
name|RVS
expr|,
name|RVD
operator|)
argument_list|,
name|vfp_sp_dp_cvt
argument_list|)
block|,
name|cCE
argument_list|(
name|fmdhr
argument_list|,
name|e200b10
argument_list|,
literal|2
argument_list|,
operator|(
name|RVD
expr|,
name|RR
operator|)
argument_list|,
name|vfp_dp_rn_rd
argument_list|)
block|,
name|cCE
argument_list|(
name|fmdlr
argument_list|,
name|e000b10
argument_list|,
literal|2
argument_list|,
operator|(
name|RVD
expr|,
name|RR
operator|)
argument_list|,
name|vfp_dp_rn_rd
argument_list|)
block|,
name|cCE
argument_list|(
name|fmrdh
argument_list|,
name|e300b10
argument_list|,
literal|2
argument_list|,
operator|(
name|RR
expr|,
name|RVD
operator|)
argument_list|,
name|vfp_dp_rd_rn
argument_list|)
block|,
name|cCE
argument_list|(
name|fmrdl
argument_list|,
name|e100b10
argument_list|,
literal|2
argument_list|,
operator|(
name|RR
expr|,
name|RVD
operator|)
argument_list|,
name|vfp_dp_rd_rn
argument_list|)
block|,
name|cCE
argument_list|(
name|fsitod
argument_list|,
name|eb80bc0
argument_list|,
literal|2
argument_list|,
operator|(
name|RVD
expr|,
name|RVS
operator|)
argument_list|,
name|vfp_dp_sp_cvt
argument_list|)
block|,
name|cCE
argument_list|(
name|fuitod
argument_list|,
name|eb80b40
argument_list|,
literal|2
argument_list|,
operator|(
name|RVD
expr|,
name|RVS
operator|)
argument_list|,
name|vfp_dp_sp_cvt
argument_list|)
block|,
name|cCE
argument_list|(
name|ftosid
argument_list|,
name|ebd0b40
argument_list|,
literal|2
argument_list|,
operator|(
name|RVS
expr|,
name|RVD
operator|)
argument_list|,
name|vfp_sp_dp_cvt
argument_list|)
block|,
name|cCE
argument_list|(
name|ftosizd
argument_list|,
name|ebd0bc0
argument_list|,
literal|2
argument_list|,
operator|(
name|RVS
expr|,
name|RVD
operator|)
argument_list|,
name|vfp_sp_dp_cvt
argument_list|)
block|,
name|cCE
argument_list|(
name|ftouid
argument_list|,
name|ebc0b40
argument_list|,
literal|2
argument_list|,
operator|(
name|RVS
expr|,
name|RVD
operator|)
argument_list|,
name|vfp_sp_dp_cvt
argument_list|)
block|,
name|cCE
argument_list|(
name|ftouizd
argument_list|,
name|ebc0bc0
argument_list|,
literal|2
argument_list|,
operator|(
name|RVS
expr|,
name|RVD
operator|)
argument_list|,
name|vfp_sp_dp_cvt
argument_list|)
block|,
comment|/* Memory operations.	 */
name|cCE
argument_list|(
name|fldd
argument_list|,
name|d100b00
argument_list|,
literal|2
argument_list|,
operator|(
name|RVD
expr|,
name|ADDRGLDC
operator|)
argument_list|,
name|vfp_dp_ldst
argument_list|)
block|,
name|cCE
argument_list|(
name|fstd
argument_list|,
name|d000b00
argument_list|,
literal|2
argument_list|,
operator|(
name|RVD
expr|,
name|ADDRGLDC
operator|)
argument_list|,
name|vfp_dp_ldst
argument_list|)
block|,
name|cCE
argument_list|(
name|fldmiad
argument_list|,
name|c900b00
argument_list|,
literal|2
argument_list|,
operator|(
name|RRw
expr|,
name|VRDLST
operator|)
argument_list|,
name|vfp_dp_ldstmia
argument_list|)
block|,
name|cCE
argument_list|(
name|fldmfdd
argument_list|,
name|c900b00
argument_list|,
literal|2
argument_list|,
operator|(
name|RRw
expr|,
name|VRDLST
operator|)
argument_list|,
name|vfp_dp_ldstmia
argument_list|)
block|,
name|cCE
argument_list|(
name|fldmdbd
argument_list|,
name|d300b00
argument_list|,
literal|2
argument_list|,
operator|(
name|RRw
expr|,
name|VRDLST
operator|)
argument_list|,
name|vfp_dp_ldstmdb
argument_list|)
block|,
name|cCE
argument_list|(
name|fldmead
argument_list|,
name|d300b00
argument_list|,
literal|2
argument_list|,
operator|(
name|RRw
expr|,
name|VRDLST
operator|)
argument_list|,
name|vfp_dp_ldstmdb
argument_list|)
block|,
name|cCE
argument_list|(
name|fstmiad
argument_list|,
name|c800b00
argument_list|,
literal|2
argument_list|,
operator|(
name|RRw
expr|,
name|VRDLST
operator|)
argument_list|,
name|vfp_dp_ldstmia
argument_list|)
block|,
name|cCE
argument_list|(
name|fstmead
argument_list|,
name|c800b00
argument_list|,
literal|2
argument_list|,
operator|(
name|RRw
expr|,
name|VRDLST
operator|)
argument_list|,
name|vfp_dp_ldstmia
argument_list|)
block|,
name|cCE
argument_list|(
name|fstmdbd
argument_list|,
name|d200b00
argument_list|,
literal|2
argument_list|,
operator|(
name|RRw
expr|,
name|VRDLST
operator|)
argument_list|,
name|vfp_dp_ldstmdb
argument_list|)
block|,
name|cCE
argument_list|(
name|fstmfdd
argument_list|,
name|d200b00
argument_list|,
literal|2
argument_list|,
operator|(
name|RRw
expr|,
name|VRDLST
operator|)
argument_list|,
name|vfp_dp_ldstmdb
argument_list|)
block|,
comment|/* Monadic operations.  */
name|cCE
argument_list|(
name|fabsd
argument_list|,
name|eb00bc0
argument_list|,
literal|2
argument_list|,
operator|(
name|RVD
expr|,
name|RVD
operator|)
argument_list|,
name|vfp_dp_rd_rm
argument_list|)
block|,
name|cCE
argument_list|(
name|fnegd
argument_list|,
name|eb10b40
argument_list|,
literal|2
argument_list|,
operator|(
name|RVD
expr|,
name|RVD
operator|)
argument_list|,
name|vfp_dp_rd_rm
argument_list|)
block|,
name|cCE
argument_list|(
name|fsqrtd
argument_list|,
name|eb10bc0
argument_list|,
literal|2
argument_list|,
operator|(
name|RVD
expr|,
name|RVD
operator|)
argument_list|,
name|vfp_dp_rd_rm
argument_list|)
block|,
comment|/* Dyadic operations.	 */
name|cCE
argument_list|(
name|faddd
argument_list|,
name|e300b00
argument_list|,
literal|3
argument_list|,
operator|(
name|RVD
expr|,
name|RVD
expr|,
name|RVD
operator|)
argument_list|,
name|vfp_dp_rd_rn_rm
argument_list|)
block|,
name|cCE
argument_list|(
name|fsubd
argument_list|,
name|e300b40
argument_list|,
literal|3
argument_list|,
operator|(
name|RVD
expr|,
name|RVD
expr|,
name|RVD
operator|)
argument_list|,
name|vfp_dp_rd_rn_rm
argument_list|)
block|,
name|cCE
argument_list|(
name|fmuld
argument_list|,
name|e200b00
argument_list|,
literal|3
argument_list|,
operator|(
name|RVD
expr|,
name|RVD
expr|,
name|RVD
operator|)
argument_list|,
name|vfp_dp_rd_rn_rm
argument_list|)
block|,
name|cCE
argument_list|(
name|fdivd
argument_list|,
name|e800b00
argument_list|,
literal|3
argument_list|,
operator|(
name|RVD
expr|,
name|RVD
expr|,
name|RVD
operator|)
argument_list|,
name|vfp_dp_rd_rn_rm
argument_list|)
block|,
name|cCE
argument_list|(
name|fmacd
argument_list|,
name|e000b00
argument_list|,
literal|3
argument_list|,
operator|(
name|RVD
expr|,
name|RVD
expr|,
name|RVD
operator|)
argument_list|,
name|vfp_dp_rd_rn_rm
argument_list|)
block|,
name|cCE
argument_list|(
name|fmscd
argument_list|,
name|e100b00
argument_list|,
literal|3
argument_list|,
operator|(
name|RVD
expr|,
name|RVD
expr|,
name|RVD
operator|)
argument_list|,
name|vfp_dp_rd_rn_rm
argument_list|)
block|,
name|cCE
argument_list|(
name|fnmuld
argument_list|,
name|e200b40
argument_list|,
literal|3
argument_list|,
operator|(
name|RVD
expr|,
name|RVD
expr|,
name|RVD
operator|)
argument_list|,
name|vfp_dp_rd_rn_rm
argument_list|)
block|,
name|cCE
argument_list|(
name|fnmacd
argument_list|,
name|e000b40
argument_list|,
literal|3
argument_list|,
operator|(
name|RVD
expr|,
name|RVD
expr|,
name|RVD
operator|)
argument_list|,
name|vfp_dp_rd_rn_rm
argument_list|)
block|,
name|cCE
argument_list|(
name|fnmscd
argument_list|,
name|e100b40
argument_list|,
literal|3
argument_list|,
operator|(
name|RVD
expr|,
name|RVD
expr|,
name|RVD
operator|)
argument_list|,
name|vfp_dp_rd_rn_rm
argument_list|)
block|,
comment|/* Comparisons.  */
name|cCE
argument_list|(
name|fcmpd
argument_list|,
name|eb40b40
argument_list|,
literal|2
argument_list|,
operator|(
name|RVD
expr|,
name|RVD
operator|)
argument_list|,
name|vfp_dp_rd_rm
argument_list|)
block|,
name|cCE
argument_list|(
name|fcmpzd
argument_list|,
name|eb50b40
argument_list|,
literal|1
argument_list|,
operator|(
name|RVD
operator|)
argument_list|,
name|vfp_dp_rd
argument_list|)
block|,
name|cCE
argument_list|(
name|fcmped
argument_list|,
name|eb40bc0
argument_list|,
literal|2
argument_list|,
operator|(
name|RVD
expr|,
name|RVD
operator|)
argument_list|,
name|vfp_dp_rd_rm
argument_list|)
block|,
name|cCE
argument_list|(
name|fcmpezd
argument_list|,
name|eb50bc0
argument_list|,
literal|1
argument_list|,
operator|(
name|RVD
operator|)
argument_list|,
name|vfp_dp_rd
argument_list|)
block|,
undef|#
directive|undef
name|ARM_VARIANT
define|#
directive|define
name|ARM_VARIANT
value|&fpu_vfp_ext_v2
name|cCE
argument_list|(
name|fmsrr
argument_list|,
name|c400a10
argument_list|,
literal|3
argument_list|,
operator|(
name|VRSLST
expr|,
name|RR
expr|,
name|RR
operator|)
argument_list|,
name|vfp_sp2_from_reg2
argument_list|)
block|,
name|cCE
argument_list|(
name|fmrrs
argument_list|,
name|c500a10
argument_list|,
literal|3
argument_list|,
operator|(
name|RR
expr|,
name|RR
expr|,
name|VRSLST
operator|)
argument_list|,
name|vfp_reg2_from_sp2
argument_list|)
block|,
name|cCE
argument_list|(
name|fmdrr
argument_list|,
name|c400b10
argument_list|,
literal|3
argument_list|,
operator|(
name|RVD
expr|,
name|RR
expr|,
name|RR
operator|)
argument_list|,
name|vfp_dp_rm_rd_rn
argument_list|)
block|,
name|cCE
argument_list|(
name|fmrrd
argument_list|,
name|c500b10
argument_list|,
literal|3
argument_list|,
operator|(
name|RR
expr|,
name|RR
expr|,
name|RVD
operator|)
argument_list|,
name|vfp_dp_rd_rn_rm
argument_list|)
block|,
comment|/* Instructions which may belong to either the Neon or VFP instruction sets.    Individual encoder functions perform additional architecture checks.  */
undef|#
directive|undef
name|ARM_VARIANT
define|#
directive|define
name|ARM_VARIANT
value|&fpu_vfp_ext_v1xd
undef|#
directive|undef
name|THUMB_VARIANT
define|#
directive|define
name|THUMB_VARIANT
value|&fpu_vfp_ext_v1xd
comment|/* These mnemonics are unique to VFP.  */
name|NCE
argument_list|(
name|vsqrt
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
operator|(
name|RVSD
expr|,
name|RVSD
operator|)
argument_list|,
name|vfp_nsyn_sqrt
argument_list|)
block|,
name|NCE
argument_list|(
name|vdiv
argument_list|,
literal|0
argument_list|,
literal|3
argument_list|,
operator|(
name|RVSD
expr|,
name|RVSD
expr|,
name|RVSD
operator|)
argument_list|,
name|vfp_nsyn_div
argument_list|)
block|,
name|nCE
argument_list|(
name|vnmul
argument_list|,
name|vnmul
argument_list|,
literal|3
argument_list|,
operator|(
name|RVSD
expr|,
name|RVSD
expr|,
name|RVSD
operator|)
argument_list|,
name|vfp_nsyn_nmul
argument_list|)
block|,
name|nCE
argument_list|(
name|vnmla
argument_list|,
name|vnmla
argument_list|,
literal|3
argument_list|,
operator|(
name|RVSD
expr|,
name|RVSD
expr|,
name|RVSD
operator|)
argument_list|,
name|vfp_nsyn_nmul
argument_list|)
block|,
name|nCE
argument_list|(
name|vnmls
argument_list|,
name|vnmls
argument_list|,
literal|3
argument_list|,
operator|(
name|RVSD
expr|,
name|RVSD
expr|,
name|RVSD
operator|)
argument_list|,
name|vfp_nsyn_nmul
argument_list|)
block|,
name|nCE
argument_list|(
name|vcmp
argument_list|,
name|vcmp
argument_list|,
literal|2
argument_list|,
operator|(
name|RVSD
expr|,
name|RVSD_I0
operator|)
argument_list|,
name|vfp_nsyn_cmp
argument_list|)
block|,
name|nCE
argument_list|(
name|vcmpe
argument_list|,
name|vcmpe
argument_list|,
literal|2
argument_list|,
operator|(
name|RVSD
expr|,
name|RVSD_I0
operator|)
argument_list|,
name|vfp_nsyn_cmp
argument_list|)
block|,
name|NCE
argument_list|(
name|vpush
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
operator|(
name|VRSDLST
operator|)
argument_list|,
name|vfp_nsyn_push
argument_list|)
block|,
name|NCE
argument_list|(
name|vpop
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
operator|(
name|VRSDLST
operator|)
argument_list|,
name|vfp_nsyn_pop
argument_list|)
block|,
name|NCE
argument_list|(
name|vcvtz
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
operator|(
name|RVSD
expr|,
name|RVSD
operator|)
argument_list|,
name|vfp_nsyn_cvtz
argument_list|)
block|,
comment|/* Mnemonics shared by Neon and VFP.  */
name|nCEF
argument_list|(
name|vmul
argument_list|,
name|vmul
argument_list|,
literal|3
argument_list|,
operator|(
name|RNSDQ
expr|,
name|oRNSDQ
expr|,
name|RNSDQ_RNSC
operator|)
argument_list|,
name|neon_mul
argument_list|)
block|,
name|nCEF
argument_list|(
name|vmla
argument_list|,
name|vmla
argument_list|,
literal|3
argument_list|,
operator|(
name|RNSDQ
expr|,
name|oRNSDQ
expr|,
name|RNSDQ_RNSC
operator|)
argument_list|,
name|neon_mac_maybe_scalar
argument_list|)
block|,
name|nCEF
argument_list|(
name|vmls
argument_list|,
name|vmls
argument_list|,
literal|3
argument_list|,
operator|(
name|RNSDQ
expr|,
name|oRNSDQ
expr|,
name|RNSDQ_RNSC
operator|)
argument_list|,
name|neon_mac_maybe_scalar
argument_list|)
block|,
name|nCEF
argument_list|(
name|vadd
argument_list|,
name|vadd
argument_list|,
literal|3
argument_list|,
operator|(
name|RNSDQ
expr|,
name|oRNSDQ
expr|,
name|RNSDQ
operator|)
argument_list|,
name|neon_addsub_if_i
argument_list|)
block|,
name|nCEF
argument_list|(
name|vsub
argument_list|,
name|vsub
argument_list|,
literal|3
argument_list|,
operator|(
name|RNSDQ
expr|,
name|oRNSDQ
expr|,
name|RNSDQ
operator|)
argument_list|,
name|neon_addsub_if_i
argument_list|)
block|,
name|NCEF
argument_list|(
name|vabs
argument_list|,
literal|1b10300
argument_list|,
literal|2
argument_list|,
operator|(
name|RNSDQ
expr|,
name|RNSDQ
operator|)
argument_list|,
name|neon_abs_neg
argument_list|)
block|,
name|NCEF
argument_list|(
name|vneg
argument_list|,
literal|1b10380
argument_list|,
literal|2
argument_list|,
operator|(
name|RNSDQ
expr|,
name|RNSDQ
operator|)
argument_list|,
name|neon_abs_neg
argument_list|)
block|,
name|NCE
argument_list|(
name|vldm
argument_list|,
name|c900b00
argument_list|,
literal|2
argument_list|,
operator|(
name|RRw
expr|,
name|VRSDLST
operator|)
argument_list|,
name|neon_ldm_stm
argument_list|)
block|,
name|NCE
argument_list|(
name|vldmia
argument_list|,
name|c900b00
argument_list|,
literal|2
argument_list|,
operator|(
name|RRw
expr|,
name|VRSDLST
operator|)
argument_list|,
name|neon_ldm_stm
argument_list|)
block|,
name|NCE
argument_list|(
name|vldmdb
argument_list|,
name|d100b00
argument_list|,
literal|2
argument_list|,
operator|(
name|RRw
expr|,
name|VRSDLST
operator|)
argument_list|,
name|neon_ldm_stm
argument_list|)
block|,
name|NCE
argument_list|(
name|vstm
argument_list|,
name|c800b00
argument_list|,
literal|2
argument_list|,
operator|(
name|RRw
expr|,
name|VRSDLST
operator|)
argument_list|,
name|neon_ldm_stm
argument_list|)
block|,
name|NCE
argument_list|(
name|vstmia
argument_list|,
name|c800b00
argument_list|,
literal|2
argument_list|,
operator|(
name|RRw
expr|,
name|VRSDLST
operator|)
argument_list|,
name|neon_ldm_stm
argument_list|)
block|,
name|NCE
argument_list|(
name|vstmdb
argument_list|,
name|d000b00
argument_list|,
literal|2
argument_list|,
operator|(
name|RRw
expr|,
name|VRSDLST
operator|)
argument_list|,
name|neon_ldm_stm
argument_list|)
block|,
name|NCE
argument_list|(
name|vldr
argument_list|,
name|d100b00
argument_list|,
literal|2
argument_list|,
operator|(
name|RVSD
expr|,
name|ADDRGLDC
operator|)
argument_list|,
name|neon_ldr_str
argument_list|)
block|,
name|NCE
argument_list|(
name|vstr
argument_list|,
name|d000b00
argument_list|,
literal|2
argument_list|,
operator|(
name|RVSD
expr|,
name|ADDRGLDC
operator|)
argument_list|,
name|neon_ldr_str
argument_list|)
block|,
name|nCEF
argument_list|(
name|vcvt
argument_list|,
name|vcvt
argument_list|,
literal|3
argument_list|,
operator|(
name|RNSDQ
expr|,
name|RNSDQ
expr|,
name|oI32b
operator|)
argument_list|,
name|neon_cvt
argument_list|)
block|,
comment|/* NOTE: All VMOV encoding is special-cased!  */
name|NCE
argument_list|(
name|vmov
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
operator|(
name|VMOV
operator|)
argument_list|,
name|neon_mov
argument_list|)
block|,
name|NCE
argument_list|(
name|vmovq
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
operator|(
name|VMOV
operator|)
argument_list|,
name|neon_mov
argument_list|)
block|,
undef|#
directive|undef
name|THUMB_VARIANT
define|#
directive|define
name|THUMB_VARIANT
value|&fpu_neon_ext_v1
undef|#
directive|undef
name|ARM_VARIANT
define|#
directive|define
name|ARM_VARIANT
value|&fpu_neon_ext_v1
comment|/* Data processing with three registers of the same length.  */
comment|/* integer ops, valid types S8 S16 S32 U8 U16 U32.  */
name|NUF
argument_list|(
name|vaba
argument_list|,
literal|0000710
argument_list|,
literal|3
argument_list|,
operator|(
name|RNDQ
expr|,
name|RNDQ
expr|,
name|RNDQ
operator|)
argument_list|,
name|neon_dyadic_i_su
argument_list|)
block|,
name|NUF
argument_list|(
name|vabaq
argument_list|,
literal|0000710
argument_list|,
literal|3
argument_list|,
operator|(
name|RNQ
expr|,
name|RNQ
expr|,
name|RNQ
operator|)
argument_list|,
name|neon_dyadic_i_su
argument_list|)
block|,
name|NUF
argument_list|(
name|vhadd
argument_list|,
literal|0000000
argument_list|,
literal|3
argument_list|,
operator|(
name|RNDQ
expr|,
name|oRNDQ
expr|,
name|RNDQ
operator|)
argument_list|,
name|neon_dyadic_i_su
argument_list|)
block|,
name|NUF
argument_list|(
name|vhaddq
argument_list|,
literal|0000000
argument_list|,
literal|3
argument_list|,
operator|(
name|RNQ
expr|,
name|oRNQ
expr|,
name|RNQ
operator|)
argument_list|,
name|neon_dyadic_i_su
argument_list|)
block|,
name|NUF
argument_list|(
name|vrhadd
argument_list|,
literal|0000100
argument_list|,
literal|3
argument_list|,
operator|(
name|RNDQ
expr|,
name|oRNDQ
expr|,
name|RNDQ
operator|)
argument_list|,
name|neon_dyadic_i_su
argument_list|)
block|,
name|NUF
argument_list|(
name|vrhaddq
argument_list|,
literal|0000100
argument_list|,
literal|3
argument_list|,
operator|(
name|RNQ
expr|,
name|oRNQ
expr|,
name|RNQ
operator|)
argument_list|,
name|neon_dyadic_i_su
argument_list|)
block|,
name|NUF
argument_list|(
name|vhsub
argument_list|,
literal|0000200
argument_list|,
literal|3
argument_list|,
operator|(
name|RNDQ
expr|,
name|oRNDQ
expr|,
name|RNDQ
operator|)
argument_list|,
name|neon_dyadic_i_su
argument_list|)
block|,
name|NUF
argument_list|(
name|vhsubq
argument_list|,
literal|0000200
argument_list|,
literal|3
argument_list|,
operator|(
name|RNQ
expr|,
name|oRNQ
expr|,
name|RNQ
operator|)
argument_list|,
name|neon_dyadic_i_su
argument_list|)
block|,
comment|/* integer ops, valid types S8 S16 S32 S64 U8 U16 U32 U64.  */
name|NUF
argument_list|(
name|vqadd
argument_list|,
literal|0000010
argument_list|,
literal|3
argument_list|,
operator|(
name|RNDQ
expr|,
name|oRNDQ
expr|,
name|RNDQ
operator|)
argument_list|,
name|neon_dyadic_i64_su
argument_list|)
block|,
name|NUF
argument_list|(
name|vqaddq
argument_list|,
literal|0000010
argument_list|,
literal|3
argument_list|,
operator|(
name|RNQ
expr|,
name|oRNQ
expr|,
name|RNQ
operator|)
argument_list|,
name|neon_dyadic_i64_su
argument_list|)
block|,
name|NUF
argument_list|(
name|vqsub
argument_list|,
literal|0000210
argument_list|,
literal|3
argument_list|,
operator|(
name|RNDQ
expr|,
name|oRNDQ
expr|,
name|RNDQ
operator|)
argument_list|,
name|neon_dyadic_i64_su
argument_list|)
block|,
name|NUF
argument_list|(
name|vqsubq
argument_list|,
literal|0000210
argument_list|,
literal|3
argument_list|,
operator|(
name|RNQ
expr|,
name|oRNQ
expr|,
name|RNQ
operator|)
argument_list|,
name|neon_dyadic_i64_su
argument_list|)
block|,
name|NUF
argument_list|(
name|vrshl
argument_list|,
literal|0000500
argument_list|,
literal|3
argument_list|,
operator|(
name|RNDQ
expr|,
name|oRNDQ
expr|,
name|RNDQ
operator|)
argument_list|,
name|neon_rshl
argument_list|)
block|,
name|NUF
argument_list|(
name|vrshlq
argument_list|,
literal|0000500
argument_list|,
literal|3
argument_list|,
operator|(
name|RNQ
expr|,
name|oRNQ
expr|,
name|RNQ
operator|)
argument_list|,
name|neon_rshl
argument_list|)
block|,
name|NUF
argument_list|(
name|vqrshl
argument_list|,
literal|0000510
argument_list|,
literal|3
argument_list|,
operator|(
name|RNDQ
expr|,
name|oRNDQ
expr|,
name|RNDQ
operator|)
argument_list|,
name|neon_rshl
argument_list|)
block|,
name|NUF
argument_list|(
name|vqrshlq
argument_list|,
literal|0000510
argument_list|,
literal|3
argument_list|,
operator|(
name|RNQ
expr|,
name|oRNQ
expr|,
name|RNQ
operator|)
argument_list|,
name|neon_rshl
argument_list|)
block|,
comment|/* If not immediate, fall back to neon_dyadic_i64_su.      shl_imm should accept I8 I16 I32 I64,      qshl_imm should accept S8 S16 S32 S64 U8 U16 U32 U64.  */
name|nUF
argument_list|(
name|vshl
argument_list|,
name|vshl
argument_list|,
literal|3
argument_list|,
operator|(
name|RNDQ
expr|,
name|oRNDQ
expr|,
name|RNDQ_I63b
operator|)
argument_list|,
name|neon_shl_imm
argument_list|)
block|,
name|nUF
argument_list|(
name|vshlq
argument_list|,
name|vshl
argument_list|,
literal|3
argument_list|,
operator|(
name|RNQ
expr|,
name|oRNQ
expr|,
name|RNDQ_I63b
operator|)
argument_list|,
name|neon_shl_imm
argument_list|)
block|,
name|nUF
argument_list|(
name|vqshl
argument_list|,
name|vqshl
argument_list|,
literal|3
argument_list|,
operator|(
name|RNDQ
expr|,
name|oRNDQ
expr|,
name|RNDQ_I63b
operator|)
argument_list|,
name|neon_qshl_imm
argument_list|)
block|,
name|nUF
argument_list|(
name|vqshlq
argument_list|,
name|vqshl
argument_list|,
literal|3
argument_list|,
operator|(
name|RNQ
expr|,
name|oRNQ
expr|,
name|RNDQ_I63b
operator|)
argument_list|,
name|neon_qshl_imm
argument_list|)
block|,
comment|/* Logic ops, types optional& ignored.  */
name|nUF
argument_list|(
name|vand
argument_list|,
name|vand
argument_list|,
literal|2
argument_list|,
operator|(
name|RNDQ
expr|,
name|NILO
operator|)
argument_list|,
name|neon_logic
argument_list|)
block|,
name|nUF
argument_list|(
name|vandq
argument_list|,
name|vand
argument_list|,
literal|2
argument_list|,
operator|(
name|RNQ
expr|,
name|NILO
operator|)
argument_list|,
name|neon_logic
argument_list|)
block|,
name|nUF
argument_list|(
name|vbic
argument_list|,
name|vbic
argument_list|,
literal|2
argument_list|,
operator|(
name|RNDQ
expr|,
name|NILO
operator|)
argument_list|,
name|neon_logic
argument_list|)
block|,
name|nUF
argument_list|(
name|vbicq
argument_list|,
name|vbic
argument_list|,
literal|2
argument_list|,
operator|(
name|RNQ
expr|,
name|NILO
operator|)
argument_list|,
name|neon_logic
argument_list|)
block|,
name|nUF
argument_list|(
name|vorr
argument_list|,
name|vorr
argument_list|,
literal|2
argument_list|,
operator|(
name|RNDQ
expr|,
name|NILO
operator|)
argument_list|,
name|neon_logic
argument_list|)
block|,
name|nUF
argument_list|(
name|vorrq
argument_list|,
name|vorr
argument_list|,
literal|2
argument_list|,
operator|(
name|RNQ
expr|,
name|NILO
operator|)
argument_list|,
name|neon_logic
argument_list|)
block|,
name|nUF
argument_list|(
name|vorn
argument_list|,
name|vorn
argument_list|,
literal|2
argument_list|,
operator|(
name|RNDQ
expr|,
name|NILO
operator|)
argument_list|,
name|neon_logic
argument_list|)
block|,
name|nUF
argument_list|(
name|vornq
argument_list|,
name|vorn
argument_list|,
literal|2
argument_list|,
operator|(
name|RNQ
expr|,
name|NILO
operator|)
argument_list|,
name|neon_logic
argument_list|)
block|,
name|nUF
argument_list|(
name|veor
argument_list|,
name|veor
argument_list|,
literal|3
argument_list|,
operator|(
name|RNDQ
expr|,
name|oRNDQ
expr|,
name|RNDQ
operator|)
argument_list|,
name|neon_logic
argument_list|)
block|,
name|nUF
argument_list|(
name|veorq
argument_list|,
name|veor
argument_list|,
literal|3
argument_list|,
operator|(
name|RNQ
expr|,
name|oRNQ
expr|,
name|RNQ
operator|)
argument_list|,
name|neon_logic
argument_list|)
block|,
comment|/* Bitfield ops, untyped.  */
name|NUF
argument_list|(
name|vbsl
argument_list|,
literal|1100110
argument_list|,
literal|3
argument_list|,
operator|(
name|RNDQ
expr|,
name|RNDQ
expr|,
name|RNDQ
operator|)
argument_list|,
name|neon_bitfield
argument_list|)
block|,
name|NUF
argument_list|(
name|vbslq
argument_list|,
literal|1100110
argument_list|,
literal|3
argument_list|,
operator|(
name|RNQ
expr|,
name|RNQ
expr|,
name|RNQ
operator|)
argument_list|,
name|neon_bitfield
argument_list|)
block|,
name|NUF
argument_list|(
name|vbit
argument_list|,
literal|1200110
argument_list|,
literal|3
argument_list|,
operator|(
name|RNDQ
expr|,
name|RNDQ
expr|,
name|RNDQ
operator|)
argument_list|,
name|neon_bitfield
argument_list|)
block|,
name|NUF
argument_list|(
name|vbitq
argument_list|,
literal|1200110
argument_list|,
literal|3
argument_list|,
operator|(
name|RNQ
expr|,
name|RNQ
expr|,
name|RNQ
operator|)
argument_list|,
name|neon_bitfield
argument_list|)
block|,
name|NUF
argument_list|(
name|vbif
argument_list|,
literal|1300110
argument_list|,
literal|3
argument_list|,
operator|(
name|RNDQ
expr|,
name|RNDQ
expr|,
name|RNDQ
operator|)
argument_list|,
name|neon_bitfield
argument_list|)
block|,
name|NUF
argument_list|(
name|vbifq
argument_list|,
literal|1300110
argument_list|,
literal|3
argument_list|,
operator|(
name|RNQ
expr|,
name|RNQ
expr|,
name|RNQ
operator|)
argument_list|,
name|neon_bitfield
argument_list|)
block|,
comment|/* Int and float variants, types S8 S16 S32 U8 U16 U32 F32.  */
name|nUF
argument_list|(
name|vabd
argument_list|,
name|vabd
argument_list|,
literal|3
argument_list|,
operator|(
name|RNDQ
expr|,
name|oRNDQ
expr|,
name|RNDQ
operator|)
argument_list|,
name|neon_dyadic_if_su
argument_list|)
block|,
name|nUF
argument_list|(
name|vabdq
argument_list|,
name|vabd
argument_list|,
literal|3
argument_list|,
operator|(
name|RNQ
expr|,
name|oRNQ
expr|,
name|RNQ
operator|)
argument_list|,
name|neon_dyadic_if_su
argument_list|)
block|,
name|nUF
argument_list|(
name|vmax
argument_list|,
name|vmax
argument_list|,
literal|3
argument_list|,
operator|(
name|RNDQ
expr|,
name|oRNDQ
expr|,
name|RNDQ
operator|)
argument_list|,
name|neon_dyadic_if_su
argument_list|)
block|,
name|nUF
argument_list|(
name|vmaxq
argument_list|,
name|vmax
argument_list|,
literal|3
argument_list|,
operator|(
name|RNQ
expr|,
name|oRNQ
expr|,
name|RNQ
operator|)
argument_list|,
name|neon_dyadic_if_su
argument_list|)
block|,
name|nUF
argument_list|(
name|vmin
argument_list|,
name|vmin
argument_list|,
literal|3
argument_list|,
operator|(
name|RNDQ
expr|,
name|oRNDQ
expr|,
name|RNDQ
operator|)
argument_list|,
name|neon_dyadic_if_su
argument_list|)
block|,
name|nUF
argument_list|(
name|vminq
argument_list|,
name|vmin
argument_list|,
literal|3
argument_list|,
operator|(
name|RNQ
expr|,
name|oRNQ
expr|,
name|RNQ
operator|)
argument_list|,
name|neon_dyadic_if_su
argument_list|)
block|,
comment|/* Comparisons. Types S8 S16 S32 U8 U16 U32 F32. Non-immediate versions fall      back to neon_dyadic_if_su.  */
name|nUF
argument_list|(
name|vcge
argument_list|,
name|vcge
argument_list|,
literal|3
argument_list|,
operator|(
name|RNDQ
expr|,
name|oRNDQ
expr|,
name|RNDQ_I0
operator|)
argument_list|,
name|neon_cmp
argument_list|)
block|,
name|nUF
argument_list|(
name|vcgeq
argument_list|,
name|vcge
argument_list|,
literal|3
argument_list|,
operator|(
name|RNQ
expr|,
name|oRNQ
expr|,
name|RNDQ_I0
operator|)
argument_list|,
name|neon_cmp
argument_list|)
block|,
name|nUF
argument_list|(
name|vcgt
argument_list|,
name|vcgt
argument_list|,
literal|3
argument_list|,
operator|(
name|RNDQ
expr|,
name|oRNDQ
expr|,
name|RNDQ_I0
operator|)
argument_list|,
name|neon_cmp
argument_list|)
block|,
name|nUF
argument_list|(
name|vcgtq
argument_list|,
name|vcgt
argument_list|,
literal|3
argument_list|,
operator|(
name|RNQ
expr|,
name|oRNQ
expr|,
name|RNDQ_I0
operator|)
argument_list|,
name|neon_cmp
argument_list|)
block|,
name|nUF
argument_list|(
name|vclt
argument_list|,
name|vclt
argument_list|,
literal|3
argument_list|,
operator|(
name|RNDQ
expr|,
name|oRNDQ
expr|,
name|RNDQ_I0
operator|)
argument_list|,
name|neon_cmp_inv
argument_list|)
block|,
name|nUF
argument_list|(
name|vcltq
argument_list|,
name|vclt
argument_list|,
literal|3
argument_list|,
operator|(
name|RNQ
expr|,
name|oRNQ
expr|,
name|RNDQ_I0
operator|)
argument_list|,
name|neon_cmp_inv
argument_list|)
block|,
name|nUF
argument_list|(
name|vcle
argument_list|,
name|vcle
argument_list|,
literal|3
argument_list|,
operator|(
name|RNDQ
expr|,
name|oRNDQ
expr|,
name|RNDQ_I0
operator|)
argument_list|,
name|neon_cmp_inv
argument_list|)
block|,
name|nUF
argument_list|(
name|vcleq
argument_list|,
name|vcle
argument_list|,
literal|3
argument_list|,
operator|(
name|RNQ
expr|,
name|oRNQ
expr|,
name|RNDQ_I0
operator|)
argument_list|,
name|neon_cmp_inv
argument_list|)
block|,
comment|/* Comparison. Type I8 I16 I32 F32.  */
name|nUF
argument_list|(
name|vceq
argument_list|,
name|vceq
argument_list|,
literal|3
argument_list|,
operator|(
name|RNDQ
expr|,
name|oRNDQ
expr|,
name|RNDQ_I0
operator|)
argument_list|,
name|neon_ceq
argument_list|)
block|,
name|nUF
argument_list|(
name|vceqq
argument_list|,
name|vceq
argument_list|,
literal|3
argument_list|,
operator|(
name|RNQ
expr|,
name|oRNQ
expr|,
name|RNDQ_I0
operator|)
argument_list|,
name|neon_ceq
argument_list|)
block|,
comment|/* As above, D registers only.  */
name|nUF
argument_list|(
name|vpmax
argument_list|,
name|vpmax
argument_list|,
literal|3
argument_list|,
operator|(
name|RND
expr|,
name|oRND
expr|,
name|RND
operator|)
argument_list|,
name|neon_dyadic_if_su_d
argument_list|)
block|,
name|nUF
argument_list|(
name|vpmin
argument_list|,
name|vpmin
argument_list|,
literal|3
argument_list|,
operator|(
name|RND
expr|,
name|oRND
expr|,
name|RND
operator|)
argument_list|,
name|neon_dyadic_if_su_d
argument_list|)
block|,
comment|/* Int and float variants, signedness unimportant.  */
name|nUF
argument_list|(
name|vmlaq
argument_list|,
name|vmla
argument_list|,
literal|3
argument_list|,
operator|(
name|RNQ
expr|,
name|oRNQ
expr|,
name|RNDQ_RNSC
operator|)
argument_list|,
name|neon_mac_maybe_scalar
argument_list|)
block|,
name|nUF
argument_list|(
name|vmlsq
argument_list|,
name|vmls
argument_list|,
literal|3
argument_list|,
operator|(
name|RNQ
expr|,
name|oRNQ
expr|,
name|RNDQ_RNSC
operator|)
argument_list|,
name|neon_mac_maybe_scalar
argument_list|)
block|,
name|nUF
argument_list|(
name|vpadd
argument_list|,
name|vpadd
argument_list|,
literal|3
argument_list|,
operator|(
name|RND
expr|,
name|oRND
expr|,
name|RND
operator|)
argument_list|,
name|neon_dyadic_if_i_d
argument_list|)
block|,
comment|/* Add/sub take types I8 I16 I32 I64 F32.  */
name|nUF
argument_list|(
name|vaddq
argument_list|,
name|vadd
argument_list|,
literal|3
argument_list|,
operator|(
name|RNQ
expr|,
name|oRNQ
expr|,
name|RNQ
operator|)
argument_list|,
name|neon_addsub_if_i
argument_list|)
block|,
name|nUF
argument_list|(
name|vsubq
argument_list|,
name|vsub
argument_list|,
literal|3
argument_list|,
operator|(
name|RNQ
expr|,
name|oRNQ
expr|,
name|RNQ
operator|)
argument_list|,
name|neon_addsub_if_i
argument_list|)
block|,
comment|/* vtst takes sizes 8, 16, 32.  */
name|NUF
argument_list|(
name|vtst
argument_list|,
literal|0000810
argument_list|,
literal|3
argument_list|,
operator|(
name|RNDQ
expr|,
name|oRNDQ
expr|,
name|RNDQ
operator|)
argument_list|,
name|neon_tst
argument_list|)
block|,
name|NUF
argument_list|(
name|vtstq
argument_list|,
literal|0000810
argument_list|,
literal|3
argument_list|,
operator|(
name|RNQ
expr|,
name|oRNQ
expr|,
name|RNQ
operator|)
argument_list|,
name|neon_tst
argument_list|)
block|,
comment|/* VMUL takes I8 I16 I32 F32 P8.  */
name|nUF
argument_list|(
name|vmulq
argument_list|,
name|vmul
argument_list|,
literal|3
argument_list|,
operator|(
name|RNQ
expr|,
name|oRNQ
expr|,
name|RNDQ_RNSC
operator|)
argument_list|,
name|neon_mul
argument_list|)
block|,
comment|/* VQD{R}MULH takes S16 S32.  */
name|nUF
argument_list|(
name|vqdmulh
argument_list|,
name|vqdmulh
argument_list|,
literal|3
argument_list|,
operator|(
name|RNDQ
expr|,
name|oRNDQ
expr|,
name|RNDQ_RNSC
operator|)
argument_list|,
name|neon_qdmulh
argument_list|)
block|,
name|nUF
argument_list|(
name|vqdmulhq
argument_list|,
name|vqdmulh
argument_list|,
literal|3
argument_list|,
operator|(
name|RNQ
expr|,
name|oRNQ
expr|,
name|RNDQ_RNSC
operator|)
argument_list|,
name|neon_qdmulh
argument_list|)
block|,
name|nUF
argument_list|(
name|vqrdmulh
argument_list|,
name|vqrdmulh
argument_list|,
literal|3
argument_list|,
operator|(
name|RNDQ
expr|,
name|oRNDQ
expr|,
name|RNDQ_RNSC
operator|)
argument_list|,
name|neon_qdmulh
argument_list|)
block|,
name|nUF
argument_list|(
name|vqrdmulhq
argument_list|,
name|vqrdmulh
argument_list|,
literal|3
argument_list|,
operator|(
name|RNQ
expr|,
name|oRNQ
expr|,
name|RNDQ_RNSC
operator|)
argument_list|,
name|neon_qdmulh
argument_list|)
block|,
name|NUF
argument_list|(
name|vacge
argument_list|,
literal|0000e10
argument_list|,
literal|3
argument_list|,
operator|(
name|RNDQ
expr|,
name|oRNDQ
expr|,
name|RNDQ
operator|)
argument_list|,
name|neon_fcmp_absolute
argument_list|)
block|,
name|NUF
argument_list|(
name|vacgeq
argument_list|,
literal|0000e10
argument_list|,
literal|3
argument_list|,
operator|(
name|RNQ
expr|,
name|oRNQ
expr|,
name|RNQ
operator|)
argument_list|,
name|neon_fcmp_absolute
argument_list|)
block|,
name|NUF
argument_list|(
name|vacgt
argument_list|,
literal|0200e10
argument_list|,
literal|3
argument_list|,
operator|(
name|RNDQ
expr|,
name|oRNDQ
expr|,
name|RNDQ
operator|)
argument_list|,
name|neon_fcmp_absolute
argument_list|)
block|,
name|NUF
argument_list|(
name|vacgtq
argument_list|,
literal|0200e10
argument_list|,
literal|3
argument_list|,
operator|(
name|RNQ
expr|,
name|oRNQ
expr|,
name|RNQ
operator|)
argument_list|,
name|neon_fcmp_absolute
argument_list|)
block|,
name|NUF
argument_list|(
name|vaclt
argument_list|,
literal|0200e10
argument_list|,
literal|3
argument_list|,
operator|(
name|RNDQ
expr|,
name|oRNDQ
expr|,
name|RNDQ
operator|)
argument_list|,
name|neon_fcmp_absolute_inv
argument_list|)
block|,
name|NUF
argument_list|(
name|vacltq
argument_list|,
literal|0200e10
argument_list|,
literal|3
argument_list|,
operator|(
name|RNQ
expr|,
name|oRNQ
expr|,
name|RNQ
operator|)
argument_list|,
name|neon_fcmp_absolute_inv
argument_list|)
block|,
name|NUF
argument_list|(
name|vacle
argument_list|,
literal|0000e10
argument_list|,
literal|3
argument_list|,
operator|(
name|RNDQ
expr|,
name|oRNDQ
expr|,
name|RNDQ
operator|)
argument_list|,
name|neon_fcmp_absolute_inv
argument_list|)
block|,
name|NUF
argument_list|(
name|vacleq
argument_list|,
literal|0000e10
argument_list|,
literal|3
argument_list|,
operator|(
name|RNQ
expr|,
name|oRNQ
expr|,
name|RNQ
operator|)
argument_list|,
name|neon_fcmp_absolute_inv
argument_list|)
block|,
name|NUF
argument_list|(
name|vrecps
argument_list|,
literal|0000f10
argument_list|,
literal|3
argument_list|,
operator|(
name|RNDQ
expr|,
name|oRNDQ
expr|,
name|RNDQ
operator|)
argument_list|,
name|neon_step
argument_list|)
block|,
name|NUF
argument_list|(
name|vrecpsq
argument_list|,
literal|0000f10
argument_list|,
literal|3
argument_list|,
operator|(
name|RNQ
expr|,
name|oRNQ
expr|,
name|RNQ
operator|)
argument_list|,
name|neon_step
argument_list|)
block|,
name|NUF
argument_list|(
name|vrsqrts
argument_list|,
literal|0200f10
argument_list|,
literal|3
argument_list|,
operator|(
name|RNDQ
expr|,
name|oRNDQ
expr|,
name|RNDQ
operator|)
argument_list|,
name|neon_step
argument_list|)
block|,
name|NUF
argument_list|(
name|vrsqrtsq
argument_list|,
literal|0200f10
argument_list|,
literal|3
argument_list|,
operator|(
name|RNQ
expr|,
name|oRNQ
expr|,
name|RNQ
operator|)
argument_list|,
name|neon_step
argument_list|)
block|,
comment|/* Two address, int/float. Types S8 S16 S32 F32.  */
name|NUF
argument_list|(
name|vabsq
argument_list|,
literal|1b10300
argument_list|,
literal|2
argument_list|,
operator|(
name|RNQ
expr|,
name|RNQ
operator|)
argument_list|,
name|neon_abs_neg
argument_list|)
block|,
name|NUF
argument_list|(
name|vnegq
argument_list|,
literal|1b10380
argument_list|,
literal|2
argument_list|,
operator|(
name|RNQ
expr|,
name|RNQ
operator|)
argument_list|,
name|neon_abs_neg
argument_list|)
block|,
comment|/* Data processing with two registers and a shift amount.  */
comment|/* Right shifts, and variants with rounding.      Types accepted S8 S16 S32 S64 U8 U16 U32 U64.  */
name|NUF
argument_list|(
name|vshr
argument_list|,
literal|0800010
argument_list|,
literal|3
argument_list|,
operator|(
name|RNDQ
expr|,
name|oRNDQ
expr|,
name|I64z
operator|)
argument_list|,
name|neon_rshift_round_imm
argument_list|)
block|,
name|NUF
argument_list|(
name|vshrq
argument_list|,
literal|0800010
argument_list|,
literal|3
argument_list|,
operator|(
name|RNQ
expr|,
name|oRNQ
expr|,
name|I64z
operator|)
argument_list|,
name|neon_rshift_round_imm
argument_list|)
block|,
name|NUF
argument_list|(
name|vrshr
argument_list|,
literal|0800210
argument_list|,
literal|3
argument_list|,
operator|(
name|RNDQ
expr|,
name|oRNDQ
expr|,
name|I64z
operator|)
argument_list|,
name|neon_rshift_round_imm
argument_list|)
block|,
name|NUF
argument_list|(
name|vrshrq
argument_list|,
literal|0800210
argument_list|,
literal|3
argument_list|,
operator|(
name|RNQ
expr|,
name|oRNQ
expr|,
name|I64z
operator|)
argument_list|,
name|neon_rshift_round_imm
argument_list|)
block|,
name|NUF
argument_list|(
name|vsra
argument_list|,
literal|0800110
argument_list|,
literal|3
argument_list|,
operator|(
name|RNDQ
expr|,
name|oRNDQ
expr|,
name|I64
operator|)
argument_list|,
name|neon_rshift_round_imm
argument_list|)
block|,
name|NUF
argument_list|(
name|vsraq
argument_list|,
literal|0800110
argument_list|,
literal|3
argument_list|,
operator|(
name|RNQ
expr|,
name|oRNQ
expr|,
name|I64
operator|)
argument_list|,
name|neon_rshift_round_imm
argument_list|)
block|,
name|NUF
argument_list|(
name|vrsra
argument_list|,
literal|0800310
argument_list|,
literal|3
argument_list|,
operator|(
name|RNDQ
expr|,
name|oRNDQ
expr|,
name|I64
operator|)
argument_list|,
name|neon_rshift_round_imm
argument_list|)
block|,
name|NUF
argument_list|(
name|vrsraq
argument_list|,
literal|0800310
argument_list|,
literal|3
argument_list|,
operator|(
name|RNQ
expr|,
name|oRNQ
expr|,
name|I64
operator|)
argument_list|,
name|neon_rshift_round_imm
argument_list|)
block|,
comment|/* Shift and insert. Sizes accepted 8 16 32 64.  */
name|NUF
argument_list|(
name|vsli
argument_list|,
literal|1800510
argument_list|,
literal|3
argument_list|,
operator|(
name|RNDQ
expr|,
name|oRNDQ
expr|,
name|I63
operator|)
argument_list|,
name|neon_sli
argument_list|)
block|,
name|NUF
argument_list|(
name|vsliq
argument_list|,
literal|1800510
argument_list|,
literal|3
argument_list|,
operator|(
name|RNQ
expr|,
name|oRNQ
expr|,
name|I63
operator|)
argument_list|,
name|neon_sli
argument_list|)
block|,
name|NUF
argument_list|(
name|vsri
argument_list|,
literal|1800410
argument_list|,
literal|3
argument_list|,
operator|(
name|RNDQ
expr|,
name|oRNDQ
expr|,
name|I64
operator|)
argument_list|,
name|neon_sri
argument_list|)
block|,
name|NUF
argument_list|(
name|vsriq
argument_list|,
literal|1800410
argument_list|,
literal|3
argument_list|,
operator|(
name|RNQ
expr|,
name|oRNQ
expr|,
name|I64
operator|)
argument_list|,
name|neon_sri
argument_list|)
block|,
comment|/* QSHL{U} immediate accepts S8 S16 S32 S64 U8 U16 U32 U64.  */
name|NUF
argument_list|(
name|vqshlu
argument_list|,
literal|1800610
argument_list|,
literal|3
argument_list|,
operator|(
name|RNDQ
expr|,
name|oRNDQ
expr|,
name|I63
operator|)
argument_list|,
name|neon_qshlu_imm
argument_list|)
block|,
name|NUF
argument_list|(
name|vqshluq
argument_list|,
literal|1800610
argument_list|,
literal|3
argument_list|,
operator|(
name|RNQ
expr|,
name|oRNQ
expr|,
name|I63
operator|)
argument_list|,
name|neon_qshlu_imm
argument_list|)
block|,
comment|/* Right shift immediate, saturating& narrowing, with rounding variants.      Types accepted S16 S32 S64 U16 U32 U64.  */
name|NUF
argument_list|(
name|vqshrn
argument_list|,
literal|0800910
argument_list|,
literal|3
argument_list|,
operator|(
name|RND
expr|,
name|RNQ
expr|,
name|I32z
operator|)
argument_list|,
name|neon_rshift_sat_narrow
argument_list|)
block|,
name|NUF
argument_list|(
name|vqrshrn
argument_list|,
literal|0800950
argument_list|,
literal|3
argument_list|,
operator|(
name|RND
expr|,
name|RNQ
expr|,
name|I32z
operator|)
argument_list|,
name|neon_rshift_sat_narrow
argument_list|)
block|,
comment|/* As above, unsigned. Types accepted S16 S32 S64.  */
name|NUF
argument_list|(
name|vqshrun
argument_list|,
literal|0800810
argument_list|,
literal|3
argument_list|,
operator|(
name|RND
expr|,
name|RNQ
expr|,
name|I32z
operator|)
argument_list|,
name|neon_rshift_sat_narrow_u
argument_list|)
block|,
name|NUF
argument_list|(
name|vqrshrun
argument_list|,
literal|0800850
argument_list|,
literal|3
argument_list|,
operator|(
name|RND
expr|,
name|RNQ
expr|,
name|I32z
operator|)
argument_list|,
name|neon_rshift_sat_narrow_u
argument_list|)
block|,
comment|/* Right shift narrowing. Types accepted I16 I32 I64.  */
name|NUF
argument_list|(
name|vshrn
argument_list|,
literal|0800810
argument_list|,
literal|3
argument_list|,
operator|(
name|RND
expr|,
name|RNQ
expr|,
name|I32z
operator|)
argument_list|,
name|neon_rshift_narrow
argument_list|)
block|,
name|NUF
argument_list|(
name|vrshrn
argument_list|,
literal|0800850
argument_list|,
literal|3
argument_list|,
operator|(
name|RND
expr|,
name|RNQ
expr|,
name|I32z
operator|)
argument_list|,
name|neon_rshift_narrow
argument_list|)
block|,
comment|/* Special case. Types S8 S16 S32 U8 U16 U32. Handles max shift variant.  */
name|nUF
argument_list|(
name|vshll
argument_list|,
name|vshll
argument_list|,
literal|3
argument_list|,
operator|(
name|RNQ
expr|,
name|RND
expr|,
name|I32
operator|)
argument_list|,
name|neon_shll
argument_list|)
block|,
comment|/* CVT with optional immediate for fixed-point variant.  */
name|nUF
argument_list|(
name|vcvtq
argument_list|,
name|vcvt
argument_list|,
literal|3
argument_list|,
operator|(
name|RNQ
expr|,
name|RNQ
expr|,
name|oI32b
operator|)
argument_list|,
name|neon_cvt
argument_list|)
block|,
name|nUF
argument_list|(
name|vmvn
argument_list|,
name|vmvn
argument_list|,
literal|2
argument_list|,
operator|(
name|RNDQ
expr|,
name|RNDQ_IMVNb
operator|)
argument_list|,
name|neon_mvn
argument_list|)
block|,
name|nUF
argument_list|(
name|vmvnq
argument_list|,
name|vmvn
argument_list|,
literal|2
argument_list|,
operator|(
name|RNQ
expr|,
name|RNDQ_IMVNb
operator|)
argument_list|,
name|neon_mvn
argument_list|)
block|,
comment|/* Data processing, three registers of different lengths.  */
comment|/* Dyadic, long insns. Types S8 S16 S32 U8 U16 U32.  */
name|NUF
argument_list|(
name|vabal
argument_list|,
literal|0800500
argument_list|,
literal|3
argument_list|,
operator|(
name|RNQ
expr|,
name|RND
expr|,
name|RND
operator|)
argument_list|,
name|neon_abal
argument_list|)
block|,
name|NUF
argument_list|(
name|vabdl
argument_list|,
literal|0800700
argument_list|,
literal|3
argument_list|,
operator|(
name|RNQ
expr|,
name|RND
expr|,
name|RND
operator|)
argument_list|,
name|neon_dyadic_long
argument_list|)
block|,
name|NUF
argument_list|(
name|vaddl
argument_list|,
literal|0800000
argument_list|,
literal|3
argument_list|,
operator|(
name|RNQ
expr|,
name|RND
expr|,
name|RND
operator|)
argument_list|,
name|neon_dyadic_long
argument_list|)
block|,
name|NUF
argument_list|(
name|vsubl
argument_list|,
literal|0800200
argument_list|,
literal|3
argument_list|,
operator|(
name|RNQ
expr|,
name|RND
expr|,
name|RND
operator|)
argument_list|,
name|neon_dyadic_long
argument_list|)
block|,
comment|/* If not scalar, fall back to neon_dyadic_long.      Vector types as above, scalar types S16 S32 U16 U32.  */
name|nUF
argument_list|(
name|vmlal
argument_list|,
name|vmlal
argument_list|,
literal|3
argument_list|,
operator|(
name|RNQ
expr|,
name|RND
expr|,
name|RND_RNSC
operator|)
argument_list|,
name|neon_mac_maybe_scalar_long
argument_list|)
block|,
name|nUF
argument_list|(
name|vmlsl
argument_list|,
name|vmlsl
argument_list|,
literal|3
argument_list|,
operator|(
name|RNQ
expr|,
name|RND
expr|,
name|RND_RNSC
operator|)
argument_list|,
name|neon_mac_maybe_scalar_long
argument_list|)
block|,
comment|/* Dyadic, widening insns. Types S8 S16 S32 U8 U16 U32.  */
name|NUF
argument_list|(
name|vaddw
argument_list|,
literal|0800100
argument_list|,
literal|3
argument_list|,
operator|(
name|RNQ
expr|,
name|oRNQ
expr|,
name|RND
operator|)
argument_list|,
name|neon_dyadic_wide
argument_list|)
block|,
name|NUF
argument_list|(
name|vsubw
argument_list|,
literal|0800300
argument_list|,
literal|3
argument_list|,
operator|(
name|RNQ
expr|,
name|oRNQ
expr|,
name|RND
operator|)
argument_list|,
name|neon_dyadic_wide
argument_list|)
block|,
comment|/* Dyadic, narrowing insns. Types I16 I32 I64.  */
name|NUF
argument_list|(
name|vaddhn
argument_list|,
literal|0800400
argument_list|,
literal|3
argument_list|,
operator|(
name|RND
expr|,
name|RNQ
expr|,
name|RNQ
operator|)
argument_list|,
name|neon_dyadic_narrow
argument_list|)
block|,
name|NUF
argument_list|(
name|vraddhn
argument_list|,
literal|1800400
argument_list|,
literal|3
argument_list|,
operator|(
name|RND
expr|,
name|RNQ
expr|,
name|RNQ
operator|)
argument_list|,
name|neon_dyadic_narrow
argument_list|)
block|,
name|NUF
argument_list|(
name|vsubhn
argument_list|,
literal|0800600
argument_list|,
literal|3
argument_list|,
operator|(
name|RND
expr|,
name|RNQ
expr|,
name|RNQ
operator|)
argument_list|,
name|neon_dyadic_narrow
argument_list|)
block|,
name|NUF
argument_list|(
name|vrsubhn
argument_list|,
literal|1800600
argument_list|,
literal|3
argument_list|,
operator|(
name|RND
expr|,
name|RNQ
expr|,
name|RNQ
operator|)
argument_list|,
name|neon_dyadic_narrow
argument_list|)
block|,
comment|/* Saturating doubling multiplies. Types S16 S32.  */
name|nUF
argument_list|(
name|vqdmlal
argument_list|,
name|vqdmlal
argument_list|,
literal|3
argument_list|,
operator|(
name|RNQ
expr|,
name|RND
expr|,
name|RND_RNSC
operator|)
argument_list|,
name|neon_mul_sat_scalar_long
argument_list|)
block|,
name|nUF
argument_list|(
name|vqdmlsl
argument_list|,
name|vqdmlsl
argument_list|,
literal|3
argument_list|,
operator|(
name|RNQ
expr|,
name|RND
expr|,
name|RND_RNSC
operator|)
argument_list|,
name|neon_mul_sat_scalar_long
argument_list|)
block|,
name|nUF
argument_list|(
name|vqdmull
argument_list|,
name|vqdmull
argument_list|,
literal|3
argument_list|,
operator|(
name|RNQ
expr|,
name|RND
expr|,
name|RND_RNSC
operator|)
argument_list|,
name|neon_mul_sat_scalar_long
argument_list|)
block|,
comment|/* VMULL. Vector types S8 S16 S32 U8 U16 U32 P8, scalar types      S16 S32 U16 U32.  */
name|nUF
argument_list|(
name|vmull
argument_list|,
name|vmull
argument_list|,
literal|3
argument_list|,
operator|(
name|RNQ
expr|,
name|RND
expr|,
name|RND_RNSC
operator|)
argument_list|,
name|neon_vmull
argument_list|)
block|,
comment|/* Extract. Size 8.  */
name|NUF
argument_list|(
name|vext
argument_list|,
literal|0b00000
argument_list|,
literal|4
argument_list|,
operator|(
name|RNDQ
expr|,
name|oRNDQ
expr|,
name|RNDQ
expr|,
name|I15
operator|)
argument_list|,
name|neon_ext
argument_list|)
block|,
name|NUF
argument_list|(
name|vextq
argument_list|,
literal|0b00000
argument_list|,
literal|4
argument_list|,
operator|(
name|RNQ
expr|,
name|oRNQ
expr|,
name|RNQ
expr|,
name|I15
operator|)
argument_list|,
name|neon_ext
argument_list|)
block|,
comment|/* Two registers, miscellaneous.  */
comment|/* Reverse. Sizes 8 16 32 (must be< size in opcode).  */
name|NUF
argument_list|(
name|vrev64
argument_list|,
literal|1b00000
argument_list|,
literal|2
argument_list|,
operator|(
name|RNDQ
expr|,
name|RNDQ
operator|)
argument_list|,
name|neon_rev
argument_list|)
block|,
name|NUF
argument_list|(
name|vrev64q
argument_list|,
literal|1b00000
argument_list|,
literal|2
argument_list|,
operator|(
name|RNQ
expr|,
name|RNQ
operator|)
argument_list|,
name|neon_rev
argument_list|)
block|,
name|NUF
argument_list|(
name|vrev32
argument_list|,
literal|1b00080
argument_list|,
literal|2
argument_list|,
operator|(
name|RNDQ
expr|,
name|RNDQ
operator|)
argument_list|,
name|neon_rev
argument_list|)
block|,
name|NUF
argument_list|(
name|vrev32q
argument_list|,
literal|1b00080
argument_list|,
literal|2
argument_list|,
operator|(
name|RNQ
expr|,
name|RNQ
operator|)
argument_list|,
name|neon_rev
argument_list|)
block|,
name|NUF
argument_list|(
name|vrev16
argument_list|,
literal|1b00100
argument_list|,
literal|2
argument_list|,
operator|(
name|RNDQ
expr|,
name|RNDQ
operator|)
argument_list|,
name|neon_rev
argument_list|)
block|,
name|NUF
argument_list|(
name|vrev16q
argument_list|,
literal|1b00100
argument_list|,
literal|2
argument_list|,
operator|(
name|RNQ
expr|,
name|RNQ
operator|)
argument_list|,
name|neon_rev
argument_list|)
block|,
comment|/* Vector replicate. Sizes 8 16 32.  */
name|nCE
argument_list|(
name|vdup
argument_list|,
name|vdup
argument_list|,
literal|2
argument_list|,
operator|(
name|RNDQ
expr|,
name|RR_RNSC
operator|)
argument_list|,
name|neon_dup
argument_list|)
block|,
name|nCE
argument_list|(
name|vdupq
argument_list|,
name|vdup
argument_list|,
literal|2
argument_list|,
operator|(
name|RNQ
expr|,
name|RR_RNSC
operator|)
argument_list|,
name|neon_dup
argument_list|)
block|,
comment|/* VMOVL. Types S8 S16 S32 U8 U16 U32.  */
name|NUF
argument_list|(
name|vmovl
argument_list|,
literal|0800a10
argument_list|,
literal|2
argument_list|,
operator|(
name|RNQ
expr|,
name|RND
operator|)
argument_list|,
name|neon_movl
argument_list|)
block|,
comment|/* VMOVN. Types I16 I32 I64.  */
name|nUF
argument_list|(
name|vmovn
argument_list|,
name|vmovn
argument_list|,
literal|2
argument_list|,
operator|(
name|RND
expr|,
name|RNQ
operator|)
argument_list|,
name|neon_movn
argument_list|)
block|,
comment|/* VQMOVN. Types S16 S32 S64 U16 U32 U64.  */
name|nUF
argument_list|(
name|vqmovn
argument_list|,
name|vqmovn
argument_list|,
literal|2
argument_list|,
operator|(
name|RND
expr|,
name|RNQ
operator|)
argument_list|,
name|neon_qmovn
argument_list|)
block|,
comment|/* VQMOVUN. Types S16 S32 S64.  */
name|nUF
argument_list|(
name|vqmovun
argument_list|,
name|vqmovun
argument_list|,
literal|2
argument_list|,
operator|(
name|RND
expr|,
name|RNQ
operator|)
argument_list|,
name|neon_qmovun
argument_list|)
block|,
comment|/* VZIP / VUZP. Sizes 8 16 32.  */
name|NUF
argument_list|(
name|vzip
argument_list|,
literal|1b20180
argument_list|,
literal|2
argument_list|,
operator|(
name|RNDQ
expr|,
name|RNDQ
operator|)
argument_list|,
name|neon_zip_uzp
argument_list|)
block|,
name|NUF
argument_list|(
name|vzipq
argument_list|,
literal|1b20180
argument_list|,
literal|2
argument_list|,
operator|(
name|RNQ
expr|,
name|RNQ
operator|)
argument_list|,
name|neon_zip_uzp
argument_list|)
block|,
name|NUF
argument_list|(
name|vuzp
argument_list|,
literal|1b20100
argument_list|,
literal|2
argument_list|,
operator|(
name|RNDQ
expr|,
name|RNDQ
operator|)
argument_list|,
name|neon_zip_uzp
argument_list|)
block|,
name|NUF
argument_list|(
name|vuzpq
argument_list|,
literal|1b20100
argument_list|,
literal|2
argument_list|,
operator|(
name|RNQ
expr|,
name|RNQ
operator|)
argument_list|,
name|neon_zip_uzp
argument_list|)
block|,
comment|/* VQABS / VQNEG. Types S8 S16 S32.  */
name|NUF
argument_list|(
name|vqabs
argument_list|,
literal|1b00700
argument_list|,
literal|2
argument_list|,
operator|(
name|RNDQ
expr|,
name|RNDQ
operator|)
argument_list|,
name|neon_sat_abs_neg
argument_list|)
block|,
name|NUF
argument_list|(
name|vqabsq
argument_list|,
literal|1b00700
argument_list|,
literal|2
argument_list|,
operator|(
name|RNQ
expr|,
name|RNQ
operator|)
argument_list|,
name|neon_sat_abs_neg
argument_list|)
block|,
name|NUF
argument_list|(
name|vqneg
argument_list|,
literal|1b00780
argument_list|,
literal|2
argument_list|,
operator|(
name|RNDQ
expr|,
name|RNDQ
operator|)
argument_list|,
name|neon_sat_abs_neg
argument_list|)
block|,
name|NUF
argument_list|(
name|vqnegq
argument_list|,
literal|1b00780
argument_list|,
literal|2
argument_list|,
operator|(
name|RNQ
expr|,
name|RNQ
operator|)
argument_list|,
name|neon_sat_abs_neg
argument_list|)
block|,
comment|/* Pairwise, lengthening. Types S8 S16 S32 U8 U16 U32.  */
name|NUF
argument_list|(
name|vpadal
argument_list|,
literal|1b00600
argument_list|,
literal|2
argument_list|,
operator|(
name|RNDQ
expr|,
name|RNDQ
operator|)
argument_list|,
name|neon_pair_long
argument_list|)
block|,
name|NUF
argument_list|(
name|vpadalq
argument_list|,
literal|1b00600
argument_list|,
literal|2
argument_list|,
operator|(
name|RNQ
expr|,
name|RNQ
operator|)
argument_list|,
name|neon_pair_long
argument_list|)
block|,
name|NUF
argument_list|(
name|vpaddl
argument_list|,
literal|1b00200
argument_list|,
literal|2
argument_list|,
operator|(
name|RNDQ
expr|,
name|RNDQ
operator|)
argument_list|,
name|neon_pair_long
argument_list|)
block|,
name|NUF
argument_list|(
name|vpaddlq
argument_list|,
literal|1b00200
argument_list|,
literal|2
argument_list|,
operator|(
name|RNQ
expr|,
name|RNQ
operator|)
argument_list|,
name|neon_pair_long
argument_list|)
block|,
comment|/* Reciprocal estimates. Types U32 F32.  */
name|NUF
argument_list|(
name|vrecpe
argument_list|,
literal|1b30400
argument_list|,
literal|2
argument_list|,
operator|(
name|RNDQ
expr|,
name|RNDQ
operator|)
argument_list|,
name|neon_recip_est
argument_list|)
block|,
name|NUF
argument_list|(
name|vrecpeq
argument_list|,
literal|1b30400
argument_list|,
literal|2
argument_list|,
operator|(
name|RNQ
expr|,
name|RNQ
operator|)
argument_list|,
name|neon_recip_est
argument_list|)
block|,
name|NUF
argument_list|(
name|vrsqrte
argument_list|,
literal|1b30480
argument_list|,
literal|2
argument_list|,
operator|(
name|RNDQ
expr|,
name|RNDQ
operator|)
argument_list|,
name|neon_recip_est
argument_list|)
block|,
name|NUF
argument_list|(
name|vrsqrteq
argument_list|,
literal|1b30480
argument_list|,
literal|2
argument_list|,
operator|(
name|RNQ
expr|,
name|RNQ
operator|)
argument_list|,
name|neon_recip_est
argument_list|)
block|,
comment|/* VCLS. Types S8 S16 S32.  */
name|NUF
argument_list|(
name|vcls
argument_list|,
literal|1b00400
argument_list|,
literal|2
argument_list|,
operator|(
name|RNDQ
expr|,
name|RNDQ
operator|)
argument_list|,
name|neon_cls
argument_list|)
block|,
name|NUF
argument_list|(
name|vclsq
argument_list|,
literal|1b00400
argument_list|,
literal|2
argument_list|,
operator|(
name|RNQ
expr|,
name|RNQ
operator|)
argument_list|,
name|neon_cls
argument_list|)
block|,
comment|/* VCLZ. Types I8 I16 I32.  */
name|NUF
argument_list|(
name|vclz
argument_list|,
literal|1b00480
argument_list|,
literal|2
argument_list|,
operator|(
name|RNDQ
expr|,
name|RNDQ
operator|)
argument_list|,
name|neon_clz
argument_list|)
block|,
name|NUF
argument_list|(
name|vclzq
argument_list|,
literal|1b00480
argument_list|,
literal|2
argument_list|,
operator|(
name|RNQ
expr|,
name|RNQ
operator|)
argument_list|,
name|neon_clz
argument_list|)
block|,
comment|/* VCNT. Size 8.  */
name|NUF
argument_list|(
name|vcnt
argument_list|,
literal|1b00500
argument_list|,
literal|2
argument_list|,
operator|(
name|RNDQ
expr|,
name|RNDQ
operator|)
argument_list|,
name|neon_cnt
argument_list|)
block|,
name|NUF
argument_list|(
name|vcntq
argument_list|,
literal|1b00500
argument_list|,
literal|2
argument_list|,
operator|(
name|RNQ
expr|,
name|RNQ
operator|)
argument_list|,
name|neon_cnt
argument_list|)
block|,
comment|/* Two address, untyped.  */
name|NUF
argument_list|(
name|vswp
argument_list|,
literal|1b20000
argument_list|,
literal|2
argument_list|,
operator|(
name|RNDQ
expr|,
name|RNDQ
operator|)
argument_list|,
name|neon_swp
argument_list|)
block|,
name|NUF
argument_list|(
name|vswpq
argument_list|,
literal|1b20000
argument_list|,
literal|2
argument_list|,
operator|(
name|RNQ
expr|,
name|RNQ
operator|)
argument_list|,
name|neon_swp
argument_list|)
block|,
comment|/* VTRN. Sizes 8 16 32.  */
name|nUF
argument_list|(
name|vtrn
argument_list|,
name|vtrn
argument_list|,
literal|2
argument_list|,
operator|(
name|RNDQ
expr|,
name|RNDQ
operator|)
argument_list|,
name|neon_trn
argument_list|)
block|,
name|nUF
argument_list|(
name|vtrnq
argument_list|,
name|vtrn
argument_list|,
literal|2
argument_list|,
operator|(
name|RNQ
expr|,
name|RNQ
operator|)
argument_list|,
name|neon_trn
argument_list|)
block|,
comment|/* Table lookup. Size 8.  */
name|NUF
argument_list|(
name|vtbl
argument_list|,
literal|1b00800
argument_list|,
literal|3
argument_list|,
operator|(
name|RND
expr|,
name|NRDLST
expr|,
name|RND
operator|)
argument_list|,
name|neon_tbl_tbx
argument_list|)
block|,
name|NUF
argument_list|(
name|vtbx
argument_list|,
literal|1b00840
argument_list|,
literal|3
argument_list|,
operator|(
name|RND
expr|,
name|NRDLST
expr|,
name|RND
operator|)
argument_list|,
name|neon_tbl_tbx
argument_list|)
block|,
undef|#
directive|undef
name|THUMB_VARIANT
define|#
directive|define
name|THUMB_VARIANT
value|&fpu_vfp_v3_or_neon_ext
undef|#
directive|undef
name|ARM_VARIANT
define|#
directive|define
name|ARM_VARIANT
value|&fpu_vfp_v3_or_neon_ext
comment|/* Neon element/structure load/store.  */
name|nUF
argument_list|(
name|vld1
argument_list|,
name|vld1
argument_list|,
literal|2
argument_list|,
operator|(
name|NSTRLST
expr|,
name|ADDR
operator|)
argument_list|,
name|neon_ldx_stx
argument_list|)
block|,
name|nUF
argument_list|(
name|vst1
argument_list|,
name|vst1
argument_list|,
literal|2
argument_list|,
operator|(
name|NSTRLST
expr|,
name|ADDR
operator|)
argument_list|,
name|neon_ldx_stx
argument_list|)
block|,
name|nUF
argument_list|(
name|vld2
argument_list|,
name|vld2
argument_list|,
literal|2
argument_list|,
operator|(
name|NSTRLST
expr|,
name|ADDR
operator|)
argument_list|,
name|neon_ldx_stx
argument_list|)
block|,
name|nUF
argument_list|(
name|vst2
argument_list|,
name|vst2
argument_list|,
literal|2
argument_list|,
operator|(
name|NSTRLST
expr|,
name|ADDR
operator|)
argument_list|,
name|neon_ldx_stx
argument_list|)
block|,
name|nUF
argument_list|(
name|vld3
argument_list|,
name|vld3
argument_list|,
literal|2
argument_list|,
operator|(
name|NSTRLST
expr|,
name|ADDR
operator|)
argument_list|,
name|neon_ldx_stx
argument_list|)
block|,
name|nUF
argument_list|(
name|vst3
argument_list|,
name|vst3
argument_list|,
literal|2
argument_list|,
operator|(
name|NSTRLST
expr|,
name|ADDR
operator|)
argument_list|,
name|neon_ldx_stx
argument_list|)
block|,
name|nUF
argument_list|(
name|vld4
argument_list|,
name|vld4
argument_list|,
literal|2
argument_list|,
operator|(
name|NSTRLST
expr|,
name|ADDR
operator|)
argument_list|,
name|neon_ldx_stx
argument_list|)
block|,
name|nUF
argument_list|(
name|vst4
argument_list|,
name|vst4
argument_list|,
literal|2
argument_list|,
operator|(
name|NSTRLST
expr|,
name|ADDR
operator|)
argument_list|,
name|neon_ldx_stx
argument_list|)
block|,
undef|#
directive|undef
name|THUMB_VARIANT
define|#
directive|define
name|THUMB_VARIANT
value|&fpu_vfp_ext_v3
undef|#
directive|undef
name|ARM_VARIANT
define|#
directive|define
name|ARM_VARIANT
value|&fpu_vfp_ext_v3
name|cCE
argument_list|(
name|fconsts
argument_list|,
name|eb00a00
argument_list|,
literal|2
argument_list|,
operator|(
name|RVS
expr|,
name|I255
operator|)
argument_list|,
name|vfp_sp_const
argument_list|)
block|,
name|cCE
argument_list|(
name|fconstd
argument_list|,
name|eb00b00
argument_list|,
literal|2
argument_list|,
operator|(
name|RVD
expr|,
name|I255
operator|)
argument_list|,
name|vfp_dp_const
argument_list|)
block|,
name|cCE
argument_list|(
name|fshtos
argument_list|,
name|eba0a40
argument_list|,
literal|2
argument_list|,
operator|(
name|RVS
expr|,
name|I16z
operator|)
argument_list|,
name|vfp_sp_conv_16
argument_list|)
block|,
name|cCE
argument_list|(
name|fshtod
argument_list|,
name|eba0b40
argument_list|,
literal|2
argument_list|,
operator|(
name|RVD
expr|,
name|I16z
operator|)
argument_list|,
name|vfp_dp_conv_16
argument_list|)
block|,
name|cCE
argument_list|(
name|fsltos
argument_list|,
name|eba0ac0
argument_list|,
literal|2
argument_list|,
operator|(
name|RVS
expr|,
name|I32
operator|)
argument_list|,
name|vfp_sp_conv_32
argument_list|)
block|,
name|cCE
argument_list|(
name|fsltod
argument_list|,
name|eba0bc0
argument_list|,
literal|2
argument_list|,
operator|(
name|RVD
expr|,
name|I32
operator|)
argument_list|,
name|vfp_dp_conv_32
argument_list|)
block|,
name|cCE
argument_list|(
name|fuhtos
argument_list|,
name|ebb0a40
argument_list|,
literal|2
argument_list|,
operator|(
name|RVS
expr|,
name|I16z
operator|)
argument_list|,
name|vfp_sp_conv_16
argument_list|)
block|,
name|cCE
argument_list|(
name|fuhtod
argument_list|,
name|ebb0b40
argument_list|,
literal|2
argument_list|,
operator|(
name|RVD
expr|,
name|I16z
operator|)
argument_list|,
name|vfp_dp_conv_16
argument_list|)
block|,
name|cCE
argument_list|(
name|fultos
argument_list|,
name|ebb0ac0
argument_list|,
literal|2
argument_list|,
operator|(
name|RVS
expr|,
name|I32
operator|)
argument_list|,
name|vfp_sp_conv_32
argument_list|)
block|,
name|cCE
argument_list|(
name|fultod
argument_list|,
name|ebb0bc0
argument_list|,
literal|2
argument_list|,
operator|(
name|RVD
expr|,
name|I32
operator|)
argument_list|,
name|vfp_dp_conv_32
argument_list|)
block|,
name|cCE
argument_list|(
name|ftoshs
argument_list|,
name|ebe0a40
argument_list|,
literal|2
argument_list|,
operator|(
name|RVS
expr|,
name|I16z
operator|)
argument_list|,
name|vfp_sp_conv_16
argument_list|)
block|,
name|cCE
argument_list|(
name|ftoshd
argument_list|,
name|ebe0b40
argument_list|,
literal|2
argument_list|,
operator|(
name|RVD
expr|,
name|I16z
operator|)
argument_list|,
name|vfp_dp_conv_16
argument_list|)
block|,
name|cCE
argument_list|(
name|ftosls
argument_list|,
name|ebe0ac0
argument_list|,
literal|2
argument_list|,
operator|(
name|RVS
expr|,
name|I32
operator|)
argument_list|,
name|vfp_sp_conv_32
argument_list|)
block|,
name|cCE
argument_list|(
name|ftosld
argument_list|,
name|ebe0bc0
argument_list|,
literal|2
argument_list|,
operator|(
name|RVD
expr|,
name|I32
operator|)
argument_list|,
name|vfp_dp_conv_32
argument_list|)
block|,
name|cCE
argument_list|(
name|ftouhs
argument_list|,
name|ebf0a40
argument_list|,
literal|2
argument_list|,
operator|(
name|RVS
expr|,
name|I16z
operator|)
argument_list|,
name|vfp_sp_conv_16
argument_list|)
block|,
name|cCE
argument_list|(
name|ftouhd
argument_list|,
name|ebf0b40
argument_list|,
literal|2
argument_list|,
operator|(
name|RVD
expr|,
name|I16z
operator|)
argument_list|,
name|vfp_dp_conv_16
argument_list|)
block|,
name|cCE
argument_list|(
name|ftouls
argument_list|,
name|ebf0ac0
argument_list|,
literal|2
argument_list|,
operator|(
name|RVS
expr|,
name|I32
operator|)
argument_list|,
name|vfp_sp_conv_32
argument_list|)
block|,
name|cCE
argument_list|(
name|ftould
argument_list|,
name|ebf0bc0
argument_list|,
literal|2
argument_list|,
operator|(
name|RVD
expr|,
name|I32
operator|)
argument_list|,
name|vfp_dp_conv_32
argument_list|)
block|,
undef|#
directive|undef
name|THUMB_VARIANT
undef|#
directive|undef
name|ARM_VARIANT
define|#
directive|define
name|ARM_VARIANT
value|&arm_cext_xscale
comment|/* Intel XScale extensions.	 */
name|cCE
argument_list|(
name|mia
argument_list|,
name|e200010
argument_list|,
literal|3
argument_list|,
operator|(
name|RXA
expr|,
name|RRnpc
expr|,
name|RRnpc
operator|)
argument_list|,
name|xsc_mia
argument_list|)
block|,
name|cCE
argument_list|(
name|miaph
argument_list|,
name|e280010
argument_list|,
literal|3
argument_list|,
operator|(
name|RXA
expr|,
name|RRnpc
expr|,
name|RRnpc
operator|)
argument_list|,
name|xsc_mia
argument_list|)
block|,
name|cCE
argument_list|(
name|miabb
argument_list|,
name|e2c0010
argument_list|,
literal|3
argument_list|,
operator|(
name|RXA
expr|,
name|RRnpc
expr|,
name|RRnpc
operator|)
argument_list|,
name|xsc_mia
argument_list|)
block|,
name|cCE
argument_list|(
name|miabt
argument_list|,
name|e2d0010
argument_list|,
literal|3
argument_list|,
operator|(
name|RXA
expr|,
name|RRnpc
expr|,
name|RRnpc
operator|)
argument_list|,
name|xsc_mia
argument_list|)
block|,
name|cCE
argument_list|(
name|miatb
argument_list|,
name|e2e0010
argument_list|,
literal|3
argument_list|,
operator|(
name|RXA
expr|,
name|RRnpc
expr|,
name|RRnpc
operator|)
argument_list|,
name|xsc_mia
argument_list|)
block|,
name|cCE
argument_list|(
name|miatt
argument_list|,
name|e2f0010
argument_list|,
literal|3
argument_list|,
operator|(
name|RXA
expr|,
name|RRnpc
expr|,
name|RRnpc
operator|)
argument_list|,
name|xsc_mia
argument_list|)
block|,
name|cCE
argument_list|(
name|mar
argument_list|,
name|c400000
argument_list|,
literal|3
argument_list|,
operator|(
name|RXA
expr|,
name|RRnpc
expr|,
name|RRnpc
operator|)
argument_list|,
name|xsc_mar
argument_list|)
block|,
name|cCE
argument_list|(
name|mra
argument_list|,
name|c500000
argument_list|,
literal|3
argument_list|,
operator|(
name|RRnpc
expr|,
name|RRnpc
expr|,
name|RXA
operator|)
argument_list|,
name|xsc_mra
argument_list|)
block|,
undef|#
directive|undef
name|ARM_VARIANT
define|#
directive|define
name|ARM_VARIANT
value|&arm_cext_iwmmxt
comment|/* Intel Wireless MMX technology.  */
name|cCE
argument_list|(
name|tandcb
argument_list|,
name|e13f130
argument_list|,
literal|1
argument_list|,
operator|(
name|RR
operator|)
argument_list|,
name|iwmmxt_tandorc
argument_list|)
block|,
name|cCE
argument_list|(
name|tandch
argument_list|,
name|e53f130
argument_list|,
literal|1
argument_list|,
operator|(
name|RR
operator|)
argument_list|,
name|iwmmxt_tandorc
argument_list|)
block|,
name|cCE
argument_list|(
name|tandcw
argument_list|,
name|e93f130
argument_list|,
literal|1
argument_list|,
operator|(
name|RR
operator|)
argument_list|,
name|iwmmxt_tandorc
argument_list|)
block|,
name|cCE
argument_list|(
name|tbcstb
argument_list|,
name|e400010
argument_list|,
literal|2
argument_list|,
operator|(
name|RIWR
expr|,
name|RR
operator|)
argument_list|,
name|rn_rd
argument_list|)
block|,
name|cCE
argument_list|(
name|tbcsth
argument_list|,
name|e400050
argument_list|,
literal|2
argument_list|,
operator|(
name|RIWR
expr|,
name|RR
operator|)
argument_list|,
name|rn_rd
argument_list|)
block|,
name|cCE
argument_list|(
name|tbcstw
argument_list|,
name|e400090
argument_list|,
literal|2
argument_list|,
operator|(
name|RIWR
expr|,
name|RR
operator|)
argument_list|,
name|rn_rd
argument_list|)
block|,
name|cCE
argument_list|(
name|textrcb
argument_list|,
name|e130170
argument_list|,
literal|2
argument_list|,
operator|(
name|RR
expr|,
name|I7
operator|)
argument_list|,
name|iwmmxt_textrc
argument_list|)
block|,
name|cCE
argument_list|(
name|textrch
argument_list|,
name|e530170
argument_list|,
literal|2
argument_list|,
operator|(
name|RR
expr|,
name|I7
operator|)
argument_list|,
name|iwmmxt_textrc
argument_list|)
block|,
name|cCE
argument_list|(
name|textrcw
argument_list|,
name|e930170
argument_list|,
literal|2
argument_list|,
operator|(
name|RR
expr|,
name|I7
operator|)
argument_list|,
name|iwmmxt_textrc
argument_list|)
block|,
name|cCE
argument_list|(
name|textrmub
argument_list|,
name|e100070
argument_list|,
literal|3
argument_list|,
operator|(
name|RR
expr|,
name|RIWR
expr|,
name|I7
operator|)
argument_list|,
name|iwmmxt_textrm
argument_list|)
block|,
name|cCE
argument_list|(
name|textrmuh
argument_list|,
name|e500070
argument_list|,
literal|3
argument_list|,
operator|(
name|RR
expr|,
name|RIWR
expr|,
name|I7
operator|)
argument_list|,
name|iwmmxt_textrm
argument_list|)
block|,
name|cCE
argument_list|(
name|textrmuw
argument_list|,
name|e900070
argument_list|,
literal|3
argument_list|,
operator|(
name|RR
expr|,
name|RIWR
expr|,
name|I7
operator|)
argument_list|,
name|iwmmxt_textrm
argument_list|)
block|,
name|cCE
argument_list|(
name|textrmsb
argument_list|,
name|e100078
argument_list|,
literal|3
argument_list|,
operator|(
name|RR
expr|,
name|RIWR
expr|,
name|I7
operator|)
argument_list|,
name|iwmmxt_textrm
argument_list|)
block|,
name|cCE
argument_list|(
name|textrmsh
argument_list|,
name|e500078
argument_list|,
literal|3
argument_list|,
operator|(
name|RR
expr|,
name|RIWR
expr|,
name|I7
operator|)
argument_list|,
name|iwmmxt_textrm
argument_list|)
block|,
name|cCE
argument_list|(
name|textrmsw
argument_list|,
name|e900078
argument_list|,
literal|3
argument_list|,
operator|(
name|RR
expr|,
name|RIWR
expr|,
name|I7
operator|)
argument_list|,
name|iwmmxt_textrm
argument_list|)
block|,
name|cCE
argument_list|(
name|tinsrb
argument_list|,
name|e600010
argument_list|,
literal|3
argument_list|,
operator|(
name|RIWR
expr|,
name|RR
expr|,
name|I7
operator|)
argument_list|,
name|iwmmxt_tinsr
argument_list|)
block|,
name|cCE
argument_list|(
name|tinsrh
argument_list|,
name|e600050
argument_list|,
literal|3
argument_list|,
operator|(
name|RIWR
expr|,
name|RR
expr|,
name|I7
operator|)
argument_list|,
name|iwmmxt_tinsr
argument_list|)
block|,
name|cCE
argument_list|(
name|tinsrw
argument_list|,
name|e600090
argument_list|,
literal|3
argument_list|,
operator|(
name|RIWR
expr|,
name|RR
expr|,
name|I7
operator|)
argument_list|,
name|iwmmxt_tinsr
argument_list|)
block|,
name|cCE
argument_list|(
name|tmcr
argument_list|,
name|e000110
argument_list|,
literal|2
argument_list|,
operator|(
name|RIWC_RIWG
expr|,
name|RR
operator|)
argument_list|,
name|rn_rd
argument_list|)
block|,
name|cCE
argument_list|(
name|tmcrr
argument_list|,
name|c400000
argument_list|,
literal|3
argument_list|,
operator|(
name|RIWR
expr|,
name|RR
expr|,
name|RR
operator|)
argument_list|,
name|rm_rd_rn
argument_list|)
block|,
name|cCE
argument_list|(
name|tmia
argument_list|,
name|e200010
argument_list|,
literal|3
argument_list|,
operator|(
name|RIWR
expr|,
name|RR
expr|,
name|RR
operator|)
argument_list|,
name|iwmmxt_tmia
argument_list|)
block|,
name|cCE
argument_list|(
name|tmiaph
argument_list|,
name|e280010
argument_list|,
literal|3
argument_list|,
operator|(
name|RIWR
expr|,
name|RR
expr|,
name|RR
operator|)
argument_list|,
name|iwmmxt_tmia
argument_list|)
block|,
name|cCE
argument_list|(
name|tmiabb
argument_list|,
name|e2c0010
argument_list|,
literal|3
argument_list|,
operator|(
name|RIWR
expr|,
name|RR
expr|,
name|RR
operator|)
argument_list|,
name|iwmmxt_tmia
argument_list|)
block|,
name|cCE
argument_list|(
name|tmiabt
argument_list|,
name|e2d0010
argument_list|,
literal|3
argument_list|,
operator|(
name|RIWR
expr|,
name|RR
expr|,
name|RR
operator|)
argument_list|,
name|iwmmxt_tmia
argument_list|)
block|,
name|cCE
argument_list|(
name|tmiatb
argument_list|,
name|e2e0010
argument_list|,
literal|3
argument_list|,
operator|(
name|RIWR
expr|,
name|RR
expr|,
name|RR
operator|)
argument_list|,
name|iwmmxt_tmia
argument_list|)
block|,
name|cCE
argument_list|(
name|tmiatt
argument_list|,
name|e2f0010
argument_list|,
literal|3
argument_list|,
operator|(
name|RIWR
expr|,
name|RR
expr|,
name|RR
operator|)
argument_list|,
name|iwmmxt_tmia
argument_list|)
block|,
name|cCE
argument_list|(
name|tmovmskb
argument_list|,
name|e100030
argument_list|,
literal|2
argument_list|,
operator|(
name|RR
expr|,
name|RIWR
operator|)
argument_list|,
name|rd_rn
argument_list|)
block|,
name|cCE
argument_list|(
name|tmovmskh
argument_list|,
name|e500030
argument_list|,
literal|2
argument_list|,
operator|(
name|RR
expr|,
name|RIWR
operator|)
argument_list|,
name|rd_rn
argument_list|)
block|,
name|cCE
argument_list|(
name|tmovmskw
argument_list|,
name|e900030
argument_list|,
literal|2
argument_list|,
operator|(
name|RR
expr|,
name|RIWR
operator|)
argument_list|,
name|rd_rn
argument_list|)
block|,
name|cCE
argument_list|(
name|tmrc
argument_list|,
name|e100110
argument_list|,
literal|2
argument_list|,
operator|(
name|RR
expr|,
name|RIWC_RIWG
operator|)
argument_list|,
name|rd_rn
argument_list|)
block|,
name|cCE
argument_list|(
name|tmrrc
argument_list|,
name|c500000
argument_list|,
literal|3
argument_list|,
operator|(
name|RR
expr|,
name|RR
expr|,
name|RIWR
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCE
argument_list|(
name|torcb
argument_list|,
name|e13f150
argument_list|,
literal|1
argument_list|,
operator|(
name|RR
operator|)
argument_list|,
name|iwmmxt_tandorc
argument_list|)
block|,
name|cCE
argument_list|(
name|torch
argument_list|,
name|e53f150
argument_list|,
literal|1
argument_list|,
operator|(
name|RR
operator|)
argument_list|,
name|iwmmxt_tandorc
argument_list|)
block|,
name|cCE
argument_list|(
name|torcw
argument_list|,
name|e93f150
argument_list|,
literal|1
argument_list|,
operator|(
name|RR
operator|)
argument_list|,
name|iwmmxt_tandorc
argument_list|)
block|,
name|cCE
argument_list|(
name|waccb
argument_list|,
name|e0001c0
argument_list|,
literal|2
argument_list|,
operator|(
name|RIWR
expr|,
name|RIWR
operator|)
argument_list|,
name|rd_rn
argument_list|)
block|,
name|cCE
argument_list|(
name|wacch
argument_list|,
name|e4001c0
argument_list|,
literal|2
argument_list|,
operator|(
name|RIWR
expr|,
name|RIWR
operator|)
argument_list|,
name|rd_rn
argument_list|)
block|,
name|cCE
argument_list|(
name|waccw
argument_list|,
name|e8001c0
argument_list|,
literal|2
argument_list|,
operator|(
name|RIWR
expr|,
name|RIWR
operator|)
argument_list|,
name|rd_rn
argument_list|)
block|,
name|cCE
argument_list|(
name|waddbss
argument_list|,
name|e300180
argument_list|,
literal|3
argument_list|,
operator|(
name|RIWR
expr|,
name|RIWR
expr|,
name|RIWR
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCE
argument_list|(
name|waddb
argument_list|,
name|e000180
argument_list|,
literal|3
argument_list|,
operator|(
name|RIWR
expr|,
name|RIWR
expr|,
name|RIWR
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCE
argument_list|(
name|waddbus
argument_list|,
name|e100180
argument_list|,
literal|3
argument_list|,
operator|(
name|RIWR
expr|,
name|RIWR
expr|,
name|RIWR
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCE
argument_list|(
name|waddhss
argument_list|,
name|e700180
argument_list|,
literal|3
argument_list|,
operator|(
name|RIWR
expr|,
name|RIWR
expr|,
name|RIWR
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCE
argument_list|(
name|waddh
argument_list|,
name|e400180
argument_list|,
literal|3
argument_list|,
operator|(
name|RIWR
expr|,
name|RIWR
expr|,
name|RIWR
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCE
argument_list|(
name|waddhus
argument_list|,
name|e500180
argument_list|,
literal|3
argument_list|,
operator|(
name|RIWR
expr|,
name|RIWR
expr|,
name|RIWR
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCE
argument_list|(
name|waddwss
argument_list|,
name|eb00180
argument_list|,
literal|3
argument_list|,
operator|(
name|RIWR
expr|,
name|RIWR
expr|,
name|RIWR
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCE
argument_list|(
name|waddw
argument_list|,
name|e800180
argument_list|,
literal|3
argument_list|,
operator|(
name|RIWR
expr|,
name|RIWR
expr|,
name|RIWR
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCE
argument_list|(
name|waddwus
argument_list|,
name|e900180
argument_list|,
literal|3
argument_list|,
operator|(
name|RIWR
expr|,
name|RIWR
expr|,
name|RIWR
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCE
argument_list|(
name|waligni
argument_list|,
name|e000020
argument_list|,
literal|4
argument_list|,
operator|(
name|RIWR
expr|,
name|RIWR
expr|,
name|RIWR
expr|,
name|I7
operator|)
argument_list|,
name|iwmmxt_waligni
argument_list|)
block|,
name|cCE
argument_list|(
name|walignr0
argument_list|,
name|e800020
argument_list|,
literal|3
argument_list|,
operator|(
name|RIWR
expr|,
name|RIWR
expr|,
name|RIWR
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCE
argument_list|(
name|walignr1
argument_list|,
name|e900020
argument_list|,
literal|3
argument_list|,
operator|(
name|RIWR
expr|,
name|RIWR
expr|,
name|RIWR
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCE
argument_list|(
name|walignr2
argument_list|,
name|ea00020
argument_list|,
literal|3
argument_list|,
operator|(
name|RIWR
expr|,
name|RIWR
expr|,
name|RIWR
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCE
argument_list|(
name|walignr3
argument_list|,
name|eb00020
argument_list|,
literal|3
argument_list|,
operator|(
name|RIWR
expr|,
name|RIWR
expr|,
name|RIWR
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCE
argument_list|(
name|wand
argument_list|,
name|e200000
argument_list|,
literal|3
argument_list|,
operator|(
name|RIWR
expr|,
name|RIWR
expr|,
name|RIWR
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCE
argument_list|(
name|wandn
argument_list|,
name|e300000
argument_list|,
literal|3
argument_list|,
operator|(
name|RIWR
expr|,
name|RIWR
expr|,
name|RIWR
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCE
argument_list|(
name|wavg2b
argument_list|,
name|e800000
argument_list|,
literal|3
argument_list|,
operator|(
name|RIWR
expr|,
name|RIWR
expr|,
name|RIWR
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCE
argument_list|(
name|wavg2br
argument_list|,
name|e900000
argument_list|,
literal|3
argument_list|,
operator|(
name|RIWR
expr|,
name|RIWR
expr|,
name|RIWR
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCE
argument_list|(
name|wavg2h
argument_list|,
name|ec00000
argument_list|,
literal|3
argument_list|,
operator|(
name|RIWR
expr|,
name|RIWR
expr|,
name|RIWR
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCE
argument_list|(
name|wavg2hr
argument_list|,
name|ed00000
argument_list|,
literal|3
argument_list|,
operator|(
name|RIWR
expr|,
name|RIWR
expr|,
name|RIWR
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCE
argument_list|(
name|wcmpeqb
argument_list|,
name|e000060
argument_list|,
literal|3
argument_list|,
operator|(
name|RIWR
expr|,
name|RIWR
expr|,
name|RIWR
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCE
argument_list|(
name|wcmpeqh
argument_list|,
name|e400060
argument_list|,
literal|3
argument_list|,
operator|(
name|RIWR
expr|,
name|RIWR
expr|,
name|RIWR
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCE
argument_list|(
name|wcmpeqw
argument_list|,
name|e800060
argument_list|,
literal|3
argument_list|,
operator|(
name|RIWR
expr|,
name|RIWR
expr|,
name|RIWR
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCE
argument_list|(
name|wcmpgtub
argument_list|,
name|e100060
argument_list|,
literal|3
argument_list|,
operator|(
name|RIWR
expr|,
name|RIWR
expr|,
name|RIWR
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCE
argument_list|(
name|wcmpgtuh
argument_list|,
name|e500060
argument_list|,
literal|3
argument_list|,
operator|(
name|RIWR
expr|,
name|RIWR
expr|,
name|RIWR
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCE
argument_list|(
name|wcmpgtuw
argument_list|,
name|e900060
argument_list|,
literal|3
argument_list|,
operator|(
name|RIWR
expr|,
name|RIWR
expr|,
name|RIWR
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCE
argument_list|(
name|wcmpgtsb
argument_list|,
name|e300060
argument_list|,
literal|3
argument_list|,
operator|(
name|RIWR
expr|,
name|RIWR
expr|,
name|RIWR
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCE
argument_list|(
name|wcmpgtsh
argument_list|,
name|e700060
argument_list|,
literal|3
argument_list|,
operator|(
name|RIWR
expr|,
name|RIWR
expr|,
name|RIWR
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCE
argument_list|(
name|wcmpgtsw
argument_list|,
name|eb00060
argument_list|,
literal|3
argument_list|,
operator|(
name|RIWR
expr|,
name|RIWR
expr|,
name|RIWR
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCE
argument_list|(
name|wldrb
argument_list|,
name|c100000
argument_list|,
literal|2
argument_list|,
operator|(
name|RIWR
expr|,
name|ADDR
operator|)
argument_list|,
name|iwmmxt_wldstbh
argument_list|)
block|,
name|cCE
argument_list|(
name|wldrh
argument_list|,
name|c500000
argument_list|,
literal|2
argument_list|,
operator|(
name|RIWR
expr|,
name|ADDR
operator|)
argument_list|,
name|iwmmxt_wldstbh
argument_list|)
block|,
name|cCE
argument_list|(
name|wldrw
argument_list|,
name|c100100
argument_list|,
literal|2
argument_list|,
operator|(
name|RIWR_RIWC
expr|,
name|ADDR
operator|)
argument_list|,
name|iwmmxt_wldstw
argument_list|)
block|,
name|cCE
argument_list|(
name|wldrd
argument_list|,
name|c500100
argument_list|,
literal|2
argument_list|,
operator|(
name|RIWR
expr|,
name|ADDR
operator|)
argument_list|,
name|iwmmxt_wldstd
argument_list|)
block|,
name|cCE
argument_list|(
name|wmacs
argument_list|,
name|e600100
argument_list|,
literal|3
argument_list|,
operator|(
name|RIWR
expr|,
name|RIWR
expr|,
name|RIWR
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCE
argument_list|(
name|wmacsz
argument_list|,
name|e700100
argument_list|,
literal|3
argument_list|,
operator|(
name|RIWR
expr|,
name|RIWR
expr|,
name|RIWR
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCE
argument_list|(
name|wmacu
argument_list|,
name|e400100
argument_list|,
literal|3
argument_list|,
operator|(
name|RIWR
expr|,
name|RIWR
expr|,
name|RIWR
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCE
argument_list|(
name|wmacuz
argument_list|,
name|e500100
argument_list|,
literal|3
argument_list|,
operator|(
name|RIWR
expr|,
name|RIWR
expr|,
name|RIWR
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCE
argument_list|(
name|wmadds
argument_list|,
name|ea00100
argument_list|,
literal|3
argument_list|,
operator|(
name|RIWR
expr|,
name|RIWR
expr|,
name|RIWR
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCE
argument_list|(
name|wmaddu
argument_list|,
name|e800100
argument_list|,
literal|3
argument_list|,
operator|(
name|RIWR
expr|,
name|RIWR
expr|,
name|RIWR
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCE
argument_list|(
name|wmaxsb
argument_list|,
name|e200160
argument_list|,
literal|3
argument_list|,
operator|(
name|RIWR
expr|,
name|RIWR
expr|,
name|RIWR
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCE
argument_list|(
name|wmaxsh
argument_list|,
name|e600160
argument_list|,
literal|3
argument_list|,
operator|(
name|RIWR
expr|,
name|RIWR
expr|,
name|RIWR
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCE
argument_list|(
name|wmaxsw
argument_list|,
name|ea00160
argument_list|,
literal|3
argument_list|,
operator|(
name|RIWR
expr|,
name|RIWR
expr|,
name|RIWR
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCE
argument_list|(
name|wmaxub
argument_list|,
name|e000160
argument_list|,
literal|3
argument_list|,
operator|(
name|RIWR
expr|,
name|RIWR
expr|,
name|RIWR
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCE
argument_list|(
name|wmaxuh
argument_list|,
name|e400160
argument_list|,
literal|3
argument_list|,
operator|(
name|RIWR
expr|,
name|RIWR
expr|,
name|RIWR
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCE
argument_list|(
name|wmaxuw
argument_list|,
name|e800160
argument_list|,
literal|3
argument_list|,
operator|(
name|RIWR
expr|,
name|RIWR
expr|,
name|RIWR
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCE
argument_list|(
name|wminsb
argument_list|,
name|e300160
argument_list|,
literal|3
argument_list|,
operator|(
name|RIWR
expr|,
name|RIWR
expr|,
name|RIWR
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCE
argument_list|(
name|wminsh
argument_list|,
name|e700160
argument_list|,
literal|3
argument_list|,
operator|(
name|RIWR
expr|,
name|RIWR
expr|,
name|RIWR
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCE
argument_list|(
name|wminsw
argument_list|,
name|eb00160
argument_list|,
literal|3
argument_list|,
operator|(
name|RIWR
expr|,
name|RIWR
expr|,
name|RIWR
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCE
argument_list|(
name|wminub
argument_list|,
name|e100160
argument_list|,
literal|3
argument_list|,
operator|(
name|RIWR
expr|,
name|RIWR
expr|,
name|RIWR
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCE
argument_list|(
name|wminuh
argument_list|,
name|e500160
argument_list|,
literal|3
argument_list|,
operator|(
name|RIWR
expr|,
name|RIWR
expr|,
name|RIWR
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCE
argument_list|(
name|wminuw
argument_list|,
name|e900160
argument_list|,
literal|3
argument_list|,
operator|(
name|RIWR
expr|,
name|RIWR
expr|,
name|RIWR
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCE
argument_list|(
name|wmov
argument_list|,
name|e000000
argument_list|,
literal|2
argument_list|,
operator|(
name|RIWR
expr|,
name|RIWR
operator|)
argument_list|,
name|iwmmxt_wmov
argument_list|)
block|,
name|cCE
argument_list|(
name|wmulsm
argument_list|,
name|e300100
argument_list|,
literal|3
argument_list|,
operator|(
name|RIWR
expr|,
name|RIWR
expr|,
name|RIWR
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCE
argument_list|(
name|wmulsl
argument_list|,
name|e200100
argument_list|,
literal|3
argument_list|,
operator|(
name|RIWR
expr|,
name|RIWR
expr|,
name|RIWR
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCE
argument_list|(
name|wmulum
argument_list|,
name|e100100
argument_list|,
literal|3
argument_list|,
operator|(
name|RIWR
expr|,
name|RIWR
expr|,
name|RIWR
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCE
argument_list|(
name|wmulul
argument_list|,
name|e000100
argument_list|,
literal|3
argument_list|,
operator|(
name|RIWR
expr|,
name|RIWR
expr|,
name|RIWR
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCE
argument_list|(
name|wor
argument_list|,
name|e000000
argument_list|,
literal|3
argument_list|,
operator|(
name|RIWR
expr|,
name|RIWR
expr|,
name|RIWR
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCE
argument_list|(
name|wpackhss
argument_list|,
name|e700080
argument_list|,
literal|3
argument_list|,
operator|(
name|RIWR
expr|,
name|RIWR
expr|,
name|RIWR
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCE
argument_list|(
name|wpackhus
argument_list|,
name|e500080
argument_list|,
literal|3
argument_list|,
operator|(
name|RIWR
expr|,
name|RIWR
expr|,
name|RIWR
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCE
argument_list|(
name|wpackwss
argument_list|,
name|eb00080
argument_list|,
literal|3
argument_list|,
operator|(
name|RIWR
expr|,
name|RIWR
expr|,
name|RIWR
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCE
argument_list|(
name|wpackwus
argument_list|,
name|e900080
argument_list|,
literal|3
argument_list|,
operator|(
name|RIWR
expr|,
name|RIWR
expr|,
name|RIWR
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCE
argument_list|(
name|wpackdss
argument_list|,
name|ef00080
argument_list|,
literal|3
argument_list|,
operator|(
name|RIWR
expr|,
name|RIWR
expr|,
name|RIWR
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCE
argument_list|(
name|wpackdus
argument_list|,
name|ed00080
argument_list|,
literal|3
argument_list|,
operator|(
name|RIWR
expr|,
name|RIWR
expr|,
name|RIWR
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCE
argument_list|(
name|wrorh
argument_list|,
name|e700040
argument_list|,
literal|3
argument_list|,
operator|(
name|RIWR
expr|,
name|RIWR
expr|,
name|RIWR_I32z
operator|)
argument_list|,
name|iwmmxt_wrwrwr_or_imm5
argument_list|)
block|,
name|cCE
argument_list|(
name|wrorhg
argument_list|,
name|e700148
argument_list|,
literal|3
argument_list|,
operator|(
name|RIWR
expr|,
name|RIWR
expr|,
name|RIWG
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCE
argument_list|(
name|wrorw
argument_list|,
name|eb00040
argument_list|,
literal|3
argument_list|,
operator|(
name|RIWR
expr|,
name|RIWR
expr|,
name|RIWR_I32z
operator|)
argument_list|,
name|iwmmxt_wrwrwr_or_imm5
argument_list|)
block|,
name|cCE
argument_list|(
name|wrorwg
argument_list|,
name|eb00148
argument_list|,
literal|3
argument_list|,
operator|(
name|RIWR
expr|,
name|RIWR
expr|,
name|RIWG
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCE
argument_list|(
name|wrord
argument_list|,
name|ef00040
argument_list|,
literal|3
argument_list|,
operator|(
name|RIWR
expr|,
name|RIWR
expr|,
name|RIWR_I32z
operator|)
argument_list|,
name|iwmmxt_wrwrwr_or_imm5
argument_list|)
block|,
name|cCE
argument_list|(
name|wrordg
argument_list|,
name|ef00148
argument_list|,
literal|3
argument_list|,
operator|(
name|RIWR
expr|,
name|RIWR
expr|,
name|RIWG
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCE
argument_list|(
name|wsadb
argument_list|,
name|e000120
argument_list|,
literal|3
argument_list|,
operator|(
name|RIWR
expr|,
name|RIWR
expr|,
name|RIWR
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCE
argument_list|(
name|wsadbz
argument_list|,
name|e100120
argument_list|,
literal|3
argument_list|,
operator|(
name|RIWR
expr|,
name|RIWR
expr|,
name|RIWR
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCE
argument_list|(
name|wsadh
argument_list|,
name|e400120
argument_list|,
literal|3
argument_list|,
operator|(
name|RIWR
expr|,
name|RIWR
expr|,
name|RIWR
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCE
argument_list|(
name|wsadhz
argument_list|,
name|e500120
argument_list|,
literal|3
argument_list|,
operator|(
name|RIWR
expr|,
name|RIWR
expr|,
name|RIWR
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCE
argument_list|(
name|wshufh
argument_list|,
name|e0001e0
argument_list|,
literal|3
argument_list|,
operator|(
name|RIWR
expr|,
name|RIWR
expr|,
name|I255
operator|)
argument_list|,
name|iwmmxt_wshufh
argument_list|)
block|,
name|cCE
argument_list|(
name|wsllh
argument_list|,
name|e500040
argument_list|,
literal|3
argument_list|,
operator|(
name|RIWR
expr|,
name|RIWR
expr|,
name|RIWR_I32z
operator|)
argument_list|,
name|iwmmxt_wrwrwr_or_imm5
argument_list|)
block|,
name|cCE
argument_list|(
name|wsllhg
argument_list|,
name|e500148
argument_list|,
literal|3
argument_list|,
operator|(
name|RIWR
expr|,
name|RIWR
expr|,
name|RIWG
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCE
argument_list|(
name|wsllw
argument_list|,
name|e900040
argument_list|,
literal|3
argument_list|,
operator|(
name|RIWR
expr|,
name|RIWR
expr|,
name|RIWR_I32z
operator|)
argument_list|,
name|iwmmxt_wrwrwr_or_imm5
argument_list|)
block|,
name|cCE
argument_list|(
name|wsllwg
argument_list|,
name|e900148
argument_list|,
literal|3
argument_list|,
operator|(
name|RIWR
expr|,
name|RIWR
expr|,
name|RIWG
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCE
argument_list|(
name|wslld
argument_list|,
name|ed00040
argument_list|,
literal|3
argument_list|,
operator|(
name|RIWR
expr|,
name|RIWR
expr|,
name|RIWR_I32z
operator|)
argument_list|,
name|iwmmxt_wrwrwr_or_imm5
argument_list|)
block|,
name|cCE
argument_list|(
name|wslldg
argument_list|,
name|ed00148
argument_list|,
literal|3
argument_list|,
operator|(
name|RIWR
expr|,
name|RIWR
expr|,
name|RIWG
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCE
argument_list|(
name|wsrah
argument_list|,
name|e400040
argument_list|,
literal|3
argument_list|,
operator|(
name|RIWR
expr|,
name|RIWR
expr|,
name|RIWR_I32z
operator|)
argument_list|,
name|iwmmxt_wrwrwr_or_imm5
argument_list|)
block|,
name|cCE
argument_list|(
name|wsrahg
argument_list|,
name|e400148
argument_list|,
literal|3
argument_list|,
operator|(
name|RIWR
expr|,
name|RIWR
expr|,
name|RIWG
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCE
argument_list|(
name|wsraw
argument_list|,
name|e800040
argument_list|,
literal|3
argument_list|,
operator|(
name|RIWR
expr|,
name|RIWR
expr|,
name|RIWR_I32z
operator|)
argument_list|,
name|iwmmxt_wrwrwr_or_imm5
argument_list|)
block|,
name|cCE
argument_list|(
name|wsrawg
argument_list|,
name|e800148
argument_list|,
literal|3
argument_list|,
operator|(
name|RIWR
expr|,
name|RIWR
expr|,
name|RIWG
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCE
argument_list|(
name|wsrad
argument_list|,
name|ec00040
argument_list|,
literal|3
argument_list|,
operator|(
name|RIWR
expr|,
name|RIWR
expr|,
name|RIWR_I32z
operator|)
argument_list|,
name|iwmmxt_wrwrwr_or_imm5
argument_list|)
block|,
name|cCE
argument_list|(
name|wsradg
argument_list|,
name|ec00148
argument_list|,
literal|3
argument_list|,
operator|(
name|RIWR
expr|,
name|RIWR
expr|,
name|RIWG
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCE
argument_list|(
name|wsrlh
argument_list|,
name|e600040
argument_list|,
literal|3
argument_list|,
operator|(
name|RIWR
expr|,
name|RIWR
expr|,
name|RIWR_I32z
operator|)
argument_list|,
name|iwmmxt_wrwrwr_or_imm5
argument_list|)
block|,
name|cCE
argument_list|(
name|wsrlhg
argument_list|,
name|e600148
argument_list|,
literal|3
argument_list|,
operator|(
name|RIWR
expr|,
name|RIWR
expr|,
name|RIWG
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCE
argument_list|(
name|wsrlw
argument_list|,
name|ea00040
argument_list|,
literal|3
argument_list|,
operator|(
name|RIWR
expr|,
name|RIWR
expr|,
name|RIWR_I32z
operator|)
argument_list|,
name|iwmmxt_wrwrwr_or_imm5
argument_list|)
block|,
name|cCE
argument_list|(
name|wsrlwg
argument_list|,
name|ea00148
argument_list|,
literal|3
argument_list|,
operator|(
name|RIWR
expr|,
name|RIWR
expr|,
name|RIWG
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCE
argument_list|(
name|wsrld
argument_list|,
name|ee00040
argument_list|,
literal|3
argument_list|,
operator|(
name|RIWR
expr|,
name|RIWR
expr|,
name|RIWR_I32z
operator|)
argument_list|,
name|iwmmxt_wrwrwr_or_imm5
argument_list|)
block|,
name|cCE
argument_list|(
name|wsrldg
argument_list|,
name|ee00148
argument_list|,
literal|3
argument_list|,
operator|(
name|RIWR
expr|,
name|RIWR
expr|,
name|RIWG
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCE
argument_list|(
name|wstrb
argument_list|,
name|c000000
argument_list|,
literal|2
argument_list|,
operator|(
name|RIWR
expr|,
name|ADDR
operator|)
argument_list|,
name|iwmmxt_wldstbh
argument_list|)
block|,
name|cCE
argument_list|(
name|wstrh
argument_list|,
name|c400000
argument_list|,
literal|2
argument_list|,
operator|(
name|RIWR
expr|,
name|ADDR
operator|)
argument_list|,
name|iwmmxt_wldstbh
argument_list|)
block|,
name|cCE
argument_list|(
name|wstrw
argument_list|,
name|c000100
argument_list|,
literal|2
argument_list|,
operator|(
name|RIWR_RIWC
expr|,
name|ADDR
operator|)
argument_list|,
name|iwmmxt_wldstw
argument_list|)
block|,
name|cCE
argument_list|(
name|wstrd
argument_list|,
name|c400100
argument_list|,
literal|2
argument_list|,
operator|(
name|RIWR
expr|,
name|ADDR
operator|)
argument_list|,
name|iwmmxt_wldstd
argument_list|)
block|,
name|cCE
argument_list|(
name|wsubbss
argument_list|,
name|e3001a0
argument_list|,
literal|3
argument_list|,
operator|(
name|RIWR
expr|,
name|RIWR
expr|,
name|RIWR
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCE
argument_list|(
name|wsubb
argument_list|,
name|e0001a0
argument_list|,
literal|3
argument_list|,
operator|(
name|RIWR
expr|,
name|RIWR
expr|,
name|RIWR
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCE
argument_list|(
name|wsubbus
argument_list|,
name|e1001a0
argument_list|,
literal|3
argument_list|,
operator|(
name|RIWR
expr|,
name|RIWR
expr|,
name|RIWR
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCE
argument_list|(
name|wsubhss
argument_list|,
name|e7001a0
argument_list|,
literal|3
argument_list|,
operator|(
name|RIWR
expr|,
name|RIWR
expr|,
name|RIWR
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCE
argument_list|(
name|wsubh
argument_list|,
name|e4001a0
argument_list|,
literal|3
argument_list|,
operator|(
name|RIWR
expr|,
name|RIWR
expr|,
name|RIWR
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCE
argument_list|(
name|wsubhus
argument_list|,
name|e5001a0
argument_list|,
literal|3
argument_list|,
operator|(
name|RIWR
expr|,
name|RIWR
expr|,
name|RIWR
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCE
argument_list|(
name|wsubwss
argument_list|,
name|eb001a0
argument_list|,
literal|3
argument_list|,
operator|(
name|RIWR
expr|,
name|RIWR
expr|,
name|RIWR
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCE
argument_list|(
name|wsubw
argument_list|,
name|e8001a0
argument_list|,
literal|3
argument_list|,
operator|(
name|RIWR
expr|,
name|RIWR
expr|,
name|RIWR
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCE
argument_list|(
name|wsubwus
argument_list|,
name|e9001a0
argument_list|,
literal|3
argument_list|,
operator|(
name|RIWR
expr|,
name|RIWR
expr|,
name|RIWR
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCE
argument_list|(
name|wunpckehub
argument_list|,
name|e0000c0
argument_list|,
literal|2
argument_list|,
operator|(
name|RIWR
expr|,
name|RIWR
operator|)
argument_list|,
name|rd_rn
argument_list|)
block|,
name|cCE
argument_list|(
name|wunpckehuh
argument_list|,
name|e4000c0
argument_list|,
literal|2
argument_list|,
operator|(
name|RIWR
expr|,
name|RIWR
operator|)
argument_list|,
name|rd_rn
argument_list|)
block|,
name|cCE
argument_list|(
name|wunpckehuw
argument_list|,
name|e8000c0
argument_list|,
literal|2
argument_list|,
operator|(
name|RIWR
expr|,
name|RIWR
operator|)
argument_list|,
name|rd_rn
argument_list|)
block|,
name|cCE
argument_list|(
name|wunpckehsb
argument_list|,
name|e2000c0
argument_list|,
literal|2
argument_list|,
operator|(
name|RIWR
expr|,
name|RIWR
operator|)
argument_list|,
name|rd_rn
argument_list|)
block|,
name|cCE
argument_list|(
name|wunpckehsh
argument_list|,
name|e6000c0
argument_list|,
literal|2
argument_list|,
operator|(
name|RIWR
expr|,
name|RIWR
operator|)
argument_list|,
name|rd_rn
argument_list|)
block|,
name|cCE
argument_list|(
name|wunpckehsw
argument_list|,
name|ea000c0
argument_list|,
literal|2
argument_list|,
operator|(
name|RIWR
expr|,
name|RIWR
operator|)
argument_list|,
name|rd_rn
argument_list|)
block|,
name|cCE
argument_list|(
name|wunpckihb
argument_list|,
name|e1000c0
argument_list|,
literal|3
argument_list|,
operator|(
name|RIWR
expr|,
name|RIWR
expr|,
name|RIWR
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCE
argument_list|(
name|wunpckihh
argument_list|,
name|e5000c0
argument_list|,
literal|3
argument_list|,
operator|(
name|RIWR
expr|,
name|RIWR
expr|,
name|RIWR
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCE
argument_list|(
name|wunpckihw
argument_list|,
name|e9000c0
argument_list|,
literal|3
argument_list|,
operator|(
name|RIWR
expr|,
name|RIWR
expr|,
name|RIWR
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCE
argument_list|(
name|wunpckelub
argument_list|,
name|e0000e0
argument_list|,
literal|2
argument_list|,
operator|(
name|RIWR
expr|,
name|RIWR
operator|)
argument_list|,
name|rd_rn
argument_list|)
block|,
name|cCE
argument_list|(
name|wunpckeluh
argument_list|,
name|e4000e0
argument_list|,
literal|2
argument_list|,
operator|(
name|RIWR
expr|,
name|RIWR
operator|)
argument_list|,
name|rd_rn
argument_list|)
block|,
name|cCE
argument_list|(
name|wunpckeluw
argument_list|,
name|e8000e0
argument_list|,
literal|2
argument_list|,
operator|(
name|RIWR
expr|,
name|RIWR
operator|)
argument_list|,
name|rd_rn
argument_list|)
block|,
name|cCE
argument_list|(
name|wunpckelsb
argument_list|,
name|e2000e0
argument_list|,
literal|2
argument_list|,
operator|(
name|RIWR
expr|,
name|RIWR
operator|)
argument_list|,
name|rd_rn
argument_list|)
block|,
name|cCE
argument_list|(
name|wunpckelsh
argument_list|,
name|e6000e0
argument_list|,
literal|2
argument_list|,
operator|(
name|RIWR
expr|,
name|RIWR
operator|)
argument_list|,
name|rd_rn
argument_list|)
block|,
name|cCE
argument_list|(
name|wunpckelsw
argument_list|,
name|ea000e0
argument_list|,
literal|2
argument_list|,
operator|(
name|RIWR
expr|,
name|RIWR
operator|)
argument_list|,
name|rd_rn
argument_list|)
block|,
name|cCE
argument_list|(
name|wunpckilb
argument_list|,
name|e1000e0
argument_list|,
literal|3
argument_list|,
operator|(
name|RIWR
expr|,
name|RIWR
expr|,
name|RIWR
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCE
argument_list|(
name|wunpckilh
argument_list|,
name|e5000e0
argument_list|,
literal|3
argument_list|,
operator|(
name|RIWR
expr|,
name|RIWR
expr|,
name|RIWR
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCE
argument_list|(
name|wunpckilw
argument_list|,
name|e9000e0
argument_list|,
literal|3
argument_list|,
operator|(
name|RIWR
expr|,
name|RIWR
expr|,
name|RIWR
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCE
argument_list|(
name|wxor
argument_list|,
name|e100000
argument_list|,
literal|3
argument_list|,
operator|(
name|RIWR
expr|,
name|RIWR
expr|,
name|RIWR
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCE
argument_list|(
name|wzero
argument_list|,
name|e300000
argument_list|,
literal|1
argument_list|,
operator|(
name|RIWR
operator|)
argument_list|,
name|iwmmxt_wzero
argument_list|)
block|,
undef|#
directive|undef
name|ARM_VARIANT
define|#
directive|define
name|ARM_VARIANT
value|&arm_cext_iwmmxt2
comment|/* Intel Wireless MMX technology, version 2.  */
name|cCE
argument_list|(
name|torvscb
argument_list|,
name|e13f190
argument_list|,
literal|1
argument_list|,
operator|(
name|RR
operator|)
argument_list|,
name|iwmmxt_tandorc
argument_list|)
block|,
name|cCE
argument_list|(
name|torvsch
argument_list|,
name|e53f190
argument_list|,
literal|1
argument_list|,
operator|(
name|RR
operator|)
argument_list|,
name|iwmmxt_tandorc
argument_list|)
block|,
name|cCE
argument_list|(
name|torvscw
argument_list|,
name|e93f190
argument_list|,
literal|1
argument_list|,
operator|(
name|RR
operator|)
argument_list|,
name|iwmmxt_tandorc
argument_list|)
block|,
name|cCE
argument_list|(
name|wabsb
argument_list|,
name|e2001c0
argument_list|,
literal|2
argument_list|,
operator|(
name|RIWR
expr|,
name|RIWR
operator|)
argument_list|,
name|rd_rn
argument_list|)
block|,
name|cCE
argument_list|(
name|wabsh
argument_list|,
name|e6001c0
argument_list|,
literal|2
argument_list|,
operator|(
name|RIWR
expr|,
name|RIWR
operator|)
argument_list|,
name|rd_rn
argument_list|)
block|,
name|cCE
argument_list|(
name|wabsw
argument_list|,
name|ea001c0
argument_list|,
literal|2
argument_list|,
operator|(
name|RIWR
expr|,
name|RIWR
operator|)
argument_list|,
name|rd_rn
argument_list|)
block|,
name|cCE
argument_list|(
name|wabsdiffb
argument_list|,
name|e1001c0
argument_list|,
literal|3
argument_list|,
operator|(
name|RIWR
expr|,
name|RIWR
expr|,
name|RIWR
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCE
argument_list|(
name|wabsdiffh
argument_list|,
name|e5001c0
argument_list|,
literal|3
argument_list|,
operator|(
name|RIWR
expr|,
name|RIWR
expr|,
name|RIWR
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCE
argument_list|(
name|wabsdiffw
argument_list|,
name|e9001c0
argument_list|,
literal|3
argument_list|,
operator|(
name|RIWR
expr|,
name|RIWR
expr|,
name|RIWR
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCE
argument_list|(
name|waddbhusl
argument_list|,
name|e2001a0
argument_list|,
literal|3
argument_list|,
operator|(
name|RIWR
expr|,
name|RIWR
expr|,
name|RIWR
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCE
argument_list|(
name|waddbhusm
argument_list|,
name|e6001a0
argument_list|,
literal|3
argument_list|,
operator|(
name|RIWR
expr|,
name|RIWR
expr|,
name|RIWR
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCE
argument_list|(
name|waddhc
argument_list|,
name|e600180
argument_list|,
literal|3
argument_list|,
operator|(
name|RIWR
expr|,
name|RIWR
expr|,
name|RIWR
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCE
argument_list|(
name|waddwc
argument_list|,
name|ea00180
argument_list|,
literal|3
argument_list|,
operator|(
name|RIWR
expr|,
name|RIWR
expr|,
name|RIWR
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCE
argument_list|(
name|waddsubhx
argument_list|,
name|ea001a0
argument_list|,
literal|3
argument_list|,
operator|(
name|RIWR
expr|,
name|RIWR
expr|,
name|RIWR
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCE
argument_list|(
name|wavg4
argument_list|,
name|e400000
argument_list|,
literal|3
argument_list|,
operator|(
name|RIWR
expr|,
name|RIWR
expr|,
name|RIWR
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCE
argument_list|(
name|wavg4r
argument_list|,
name|e500000
argument_list|,
literal|3
argument_list|,
operator|(
name|RIWR
expr|,
name|RIWR
expr|,
name|RIWR
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCE
argument_list|(
name|wmaddsn
argument_list|,
name|ee00100
argument_list|,
literal|3
argument_list|,
operator|(
name|RIWR
expr|,
name|RIWR
expr|,
name|RIWR
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCE
argument_list|(
name|wmaddsx
argument_list|,
name|eb00100
argument_list|,
literal|3
argument_list|,
operator|(
name|RIWR
expr|,
name|RIWR
expr|,
name|RIWR
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCE
argument_list|(
name|wmaddun
argument_list|,
name|ec00100
argument_list|,
literal|3
argument_list|,
operator|(
name|RIWR
expr|,
name|RIWR
expr|,
name|RIWR
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCE
argument_list|(
name|wmaddux
argument_list|,
name|e900100
argument_list|,
literal|3
argument_list|,
operator|(
name|RIWR
expr|,
name|RIWR
expr|,
name|RIWR
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCE
argument_list|(
name|wmerge
argument_list|,
name|e000080
argument_list|,
literal|4
argument_list|,
operator|(
name|RIWR
expr|,
name|RIWR
expr|,
name|RIWR
expr|,
name|I7
operator|)
argument_list|,
name|iwmmxt_wmerge
argument_list|)
block|,
name|cCE
argument_list|(
name|wmiabb
argument_list|,
name|e0000a0
argument_list|,
literal|3
argument_list|,
operator|(
name|RIWR
expr|,
name|RIWR
expr|,
name|RIWR
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCE
argument_list|(
name|wmiabt
argument_list|,
name|e1000a0
argument_list|,
literal|3
argument_list|,
operator|(
name|RIWR
expr|,
name|RIWR
expr|,
name|RIWR
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCE
argument_list|(
name|wmiatb
argument_list|,
name|e2000a0
argument_list|,
literal|3
argument_list|,
operator|(
name|RIWR
expr|,
name|RIWR
expr|,
name|RIWR
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCE
argument_list|(
name|wmiatt
argument_list|,
name|e3000a0
argument_list|,
literal|3
argument_list|,
operator|(
name|RIWR
expr|,
name|RIWR
expr|,
name|RIWR
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCE
argument_list|(
name|wmiabbn
argument_list|,
name|e4000a0
argument_list|,
literal|3
argument_list|,
operator|(
name|RIWR
expr|,
name|RIWR
expr|,
name|RIWR
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCE
argument_list|(
name|wmiabtn
argument_list|,
name|e5000a0
argument_list|,
literal|3
argument_list|,
operator|(
name|RIWR
expr|,
name|RIWR
expr|,
name|RIWR
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCE
argument_list|(
name|wmiatbn
argument_list|,
name|e6000a0
argument_list|,
literal|3
argument_list|,
operator|(
name|RIWR
expr|,
name|RIWR
expr|,
name|RIWR
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCE
argument_list|(
name|wmiattn
argument_list|,
name|e7000a0
argument_list|,
literal|3
argument_list|,
operator|(
name|RIWR
expr|,
name|RIWR
expr|,
name|RIWR
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCE
argument_list|(
name|wmiawbb
argument_list|,
name|e800120
argument_list|,
literal|3
argument_list|,
operator|(
name|RIWR
expr|,
name|RIWR
expr|,
name|RIWR
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCE
argument_list|(
name|wmiawbt
argument_list|,
name|e900120
argument_list|,
literal|3
argument_list|,
operator|(
name|RIWR
expr|,
name|RIWR
expr|,
name|RIWR
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCE
argument_list|(
name|wmiawtb
argument_list|,
name|ea00120
argument_list|,
literal|3
argument_list|,
operator|(
name|RIWR
expr|,
name|RIWR
expr|,
name|RIWR
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCE
argument_list|(
name|wmiawtt
argument_list|,
name|eb00120
argument_list|,
literal|3
argument_list|,
operator|(
name|RIWR
expr|,
name|RIWR
expr|,
name|RIWR
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCE
argument_list|(
name|wmiawbbn
argument_list|,
name|ec00120
argument_list|,
literal|3
argument_list|,
operator|(
name|RIWR
expr|,
name|RIWR
expr|,
name|RIWR
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCE
argument_list|(
name|wmiawbtn
argument_list|,
name|ed00120
argument_list|,
literal|3
argument_list|,
operator|(
name|RIWR
expr|,
name|RIWR
expr|,
name|RIWR
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCE
argument_list|(
name|wmiawtbn
argument_list|,
name|ee00120
argument_list|,
literal|3
argument_list|,
operator|(
name|RIWR
expr|,
name|RIWR
expr|,
name|RIWR
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCE
argument_list|(
name|wmiawttn
argument_list|,
name|ef00120
argument_list|,
literal|3
argument_list|,
operator|(
name|RIWR
expr|,
name|RIWR
expr|,
name|RIWR
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCE
argument_list|(
name|wmulsmr
argument_list|,
name|ef00100
argument_list|,
literal|3
argument_list|,
operator|(
name|RIWR
expr|,
name|RIWR
expr|,
name|RIWR
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCE
argument_list|(
name|wmulumr
argument_list|,
name|ed00100
argument_list|,
literal|3
argument_list|,
operator|(
name|RIWR
expr|,
name|RIWR
expr|,
name|RIWR
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCE
argument_list|(
name|wmulwumr
argument_list|,
name|ec000c0
argument_list|,
literal|3
argument_list|,
operator|(
name|RIWR
expr|,
name|RIWR
expr|,
name|RIWR
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCE
argument_list|(
name|wmulwsmr
argument_list|,
name|ee000c0
argument_list|,
literal|3
argument_list|,
operator|(
name|RIWR
expr|,
name|RIWR
expr|,
name|RIWR
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCE
argument_list|(
name|wmulwum
argument_list|,
name|ed000c0
argument_list|,
literal|3
argument_list|,
operator|(
name|RIWR
expr|,
name|RIWR
expr|,
name|RIWR
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCE
argument_list|(
name|wmulwsm
argument_list|,
name|ef000c0
argument_list|,
literal|3
argument_list|,
operator|(
name|RIWR
expr|,
name|RIWR
expr|,
name|RIWR
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCE
argument_list|(
name|wmulwl
argument_list|,
name|eb000c0
argument_list|,
literal|3
argument_list|,
operator|(
name|RIWR
expr|,
name|RIWR
expr|,
name|RIWR
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCE
argument_list|(
name|wqmiabb
argument_list|,
name|e8000a0
argument_list|,
literal|3
argument_list|,
operator|(
name|RIWR
expr|,
name|RIWR
expr|,
name|RIWR
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCE
argument_list|(
name|wqmiabt
argument_list|,
name|e9000a0
argument_list|,
literal|3
argument_list|,
operator|(
name|RIWR
expr|,
name|RIWR
expr|,
name|RIWR
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCE
argument_list|(
name|wqmiatb
argument_list|,
name|ea000a0
argument_list|,
literal|3
argument_list|,
operator|(
name|RIWR
expr|,
name|RIWR
expr|,
name|RIWR
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCE
argument_list|(
name|wqmiatt
argument_list|,
name|eb000a0
argument_list|,
literal|3
argument_list|,
operator|(
name|RIWR
expr|,
name|RIWR
expr|,
name|RIWR
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCE
argument_list|(
name|wqmiabbn
argument_list|,
name|ec000a0
argument_list|,
literal|3
argument_list|,
operator|(
name|RIWR
expr|,
name|RIWR
expr|,
name|RIWR
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCE
argument_list|(
name|wqmiabtn
argument_list|,
name|ed000a0
argument_list|,
literal|3
argument_list|,
operator|(
name|RIWR
expr|,
name|RIWR
expr|,
name|RIWR
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCE
argument_list|(
name|wqmiatbn
argument_list|,
name|ee000a0
argument_list|,
literal|3
argument_list|,
operator|(
name|RIWR
expr|,
name|RIWR
expr|,
name|RIWR
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCE
argument_list|(
name|wqmiattn
argument_list|,
name|ef000a0
argument_list|,
literal|3
argument_list|,
operator|(
name|RIWR
expr|,
name|RIWR
expr|,
name|RIWR
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCE
argument_list|(
name|wqmulm
argument_list|,
name|e100080
argument_list|,
literal|3
argument_list|,
operator|(
name|RIWR
expr|,
name|RIWR
expr|,
name|RIWR
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCE
argument_list|(
name|wqmulmr
argument_list|,
name|e300080
argument_list|,
literal|3
argument_list|,
operator|(
name|RIWR
expr|,
name|RIWR
expr|,
name|RIWR
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCE
argument_list|(
name|wqmulwm
argument_list|,
name|ec000e0
argument_list|,
literal|3
argument_list|,
operator|(
name|RIWR
expr|,
name|RIWR
expr|,
name|RIWR
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCE
argument_list|(
name|wqmulwmr
argument_list|,
name|ee000e0
argument_list|,
literal|3
argument_list|,
operator|(
name|RIWR
expr|,
name|RIWR
expr|,
name|RIWR
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCE
argument_list|(
name|wsubaddhx
argument_list|,
name|ed001c0
argument_list|,
literal|3
argument_list|,
operator|(
name|RIWR
expr|,
name|RIWR
expr|,
name|RIWR
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
undef|#
directive|undef
name|ARM_VARIANT
define|#
directive|define
name|ARM_VARIANT
value|&arm_cext_maverick
comment|/* Cirrus Maverick instructions.	*/
name|cCE
argument_list|(
name|cfldrs
argument_list|,
name|c100400
argument_list|,
literal|2
argument_list|,
operator|(
name|RMF
expr|,
name|ADDRGLDC
operator|)
argument_list|,
name|rd_cpaddr
argument_list|)
block|,
name|cCE
argument_list|(
name|cfldrd
argument_list|,
name|c500400
argument_list|,
literal|2
argument_list|,
operator|(
name|RMD
expr|,
name|ADDRGLDC
operator|)
argument_list|,
name|rd_cpaddr
argument_list|)
block|,
name|cCE
argument_list|(
name|cfldr32
argument_list|,
name|c100500
argument_list|,
literal|2
argument_list|,
operator|(
name|RMFX
expr|,
name|ADDRGLDC
operator|)
argument_list|,
name|rd_cpaddr
argument_list|)
block|,
name|cCE
argument_list|(
name|cfldr64
argument_list|,
name|c500500
argument_list|,
literal|2
argument_list|,
operator|(
name|RMDX
expr|,
name|ADDRGLDC
operator|)
argument_list|,
name|rd_cpaddr
argument_list|)
block|,
name|cCE
argument_list|(
name|cfstrs
argument_list|,
name|c000400
argument_list|,
literal|2
argument_list|,
operator|(
name|RMF
expr|,
name|ADDRGLDC
operator|)
argument_list|,
name|rd_cpaddr
argument_list|)
block|,
name|cCE
argument_list|(
name|cfstrd
argument_list|,
name|c400400
argument_list|,
literal|2
argument_list|,
operator|(
name|RMD
expr|,
name|ADDRGLDC
operator|)
argument_list|,
name|rd_cpaddr
argument_list|)
block|,
name|cCE
argument_list|(
name|cfstr32
argument_list|,
name|c000500
argument_list|,
literal|2
argument_list|,
operator|(
name|RMFX
expr|,
name|ADDRGLDC
operator|)
argument_list|,
name|rd_cpaddr
argument_list|)
block|,
name|cCE
argument_list|(
name|cfstr64
argument_list|,
name|c400500
argument_list|,
literal|2
argument_list|,
operator|(
name|RMDX
expr|,
name|ADDRGLDC
operator|)
argument_list|,
name|rd_cpaddr
argument_list|)
block|,
name|cCE
argument_list|(
name|cfmvsr
argument_list|,
name|e000450
argument_list|,
literal|2
argument_list|,
operator|(
name|RMF
expr|,
name|RR
operator|)
argument_list|,
name|rn_rd
argument_list|)
block|,
name|cCE
argument_list|(
name|cfmvrs
argument_list|,
name|e100450
argument_list|,
literal|2
argument_list|,
operator|(
name|RR
expr|,
name|RMF
operator|)
argument_list|,
name|rd_rn
argument_list|)
block|,
name|cCE
argument_list|(
name|cfmvdlr
argument_list|,
name|e000410
argument_list|,
literal|2
argument_list|,
operator|(
name|RMD
expr|,
name|RR
operator|)
argument_list|,
name|rn_rd
argument_list|)
block|,
name|cCE
argument_list|(
name|cfmvrdl
argument_list|,
name|e100410
argument_list|,
literal|2
argument_list|,
operator|(
name|RR
expr|,
name|RMD
operator|)
argument_list|,
name|rd_rn
argument_list|)
block|,
name|cCE
argument_list|(
name|cfmvdhr
argument_list|,
name|e000430
argument_list|,
literal|2
argument_list|,
operator|(
name|RMD
expr|,
name|RR
operator|)
argument_list|,
name|rn_rd
argument_list|)
block|,
name|cCE
argument_list|(
name|cfmvrdh
argument_list|,
name|e100430
argument_list|,
literal|2
argument_list|,
operator|(
name|RR
expr|,
name|RMD
operator|)
argument_list|,
name|rd_rn
argument_list|)
block|,
name|cCE
argument_list|(
name|cfmv64lr
argument_list|,
name|e000510
argument_list|,
literal|2
argument_list|,
operator|(
name|RMDX
expr|,
name|RR
operator|)
argument_list|,
name|rn_rd
argument_list|)
block|,
name|cCE
argument_list|(
name|cfmvr64l
argument_list|,
name|e100510
argument_list|,
literal|2
argument_list|,
operator|(
name|RR
expr|,
name|RMDX
operator|)
argument_list|,
name|rd_rn
argument_list|)
block|,
name|cCE
argument_list|(
name|cfmv64hr
argument_list|,
name|e000530
argument_list|,
literal|2
argument_list|,
operator|(
name|RMDX
expr|,
name|RR
operator|)
argument_list|,
name|rn_rd
argument_list|)
block|,
name|cCE
argument_list|(
name|cfmvr64h
argument_list|,
name|e100530
argument_list|,
literal|2
argument_list|,
operator|(
name|RR
expr|,
name|RMDX
operator|)
argument_list|,
name|rd_rn
argument_list|)
block|,
name|cCE
argument_list|(
name|cfmval32
argument_list|,
name|e200440
argument_list|,
literal|2
argument_list|,
operator|(
name|RMAX
expr|,
name|RMFX
operator|)
argument_list|,
name|rd_rn
argument_list|)
block|,
name|cCE
argument_list|(
name|cfmv32al
argument_list|,
name|e100440
argument_list|,
literal|2
argument_list|,
operator|(
name|RMFX
expr|,
name|RMAX
operator|)
argument_list|,
name|rd_rn
argument_list|)
block|,
name|cCE
argument_list|(
name|cfmvam32
argument_list|,
name|e200460
argument_list|,
literal|2
argument_list|,
operator|(
name|RMAX
expr|,
name|RMFX
operator|)
argument_list|,
name|rd_rn
argument_list|)
block|,
name|cCE
argument_list|(
name|cfmv32am
argument_list|,
name|e100460
argument_list|,
literal|2
argument_list|,
operator|(
name|RMFX
expr|,
name|RMAX
operator|)
argument_list|,
name|rd_rn
argument_list|)
block|,
name|cCE
argument_list|(
name|cfmvah32
argument_list|,
name|e200480
argument_list|,
literal|2
argument_list|,
operator|(
name|RMAX
expr|,
name|RMFX
operator|)
argument_list|,
name|rd_rn
argument_list|)
block|,
name|cCE
argument_list|(
name|cfmv32ah
argument_list|,
name|e100480
argument_list|,
literal|2
argument_list|,
operator|(
name|RMFX
expr|,
name|RMAX
operator|)
argument_list|,
name|rd_rn
argument_list|)
block|,
name|cCE
argument_list|(
name|cfmva32
argument_list|,
name|e2004a0
argument_list|,
literal|2
argument_list|,
operator|(
name|RMAX
expr|,
name|RMFX
operator|)
argument_list|,
name|rd_rn
argument_list|)
block|,
name|cCE
argument_list|(
name|cfmv32a
argument_list|,
name|e1004a0
argument_list|,
literal|2
argument_list|,
operator|(
name|RMFX
expr|,
name|RMAX
operator|)
argument_list|,
name|rd_rn
argument_list|)
block|,
name|cCE
argument_list|(
name|cfmva64
argument_list|,
name|e2004c0
argument_list|,
literal|2
argument_list|,
operator|(
name|RMAX
expr|,
name|RMDX
operator|)
argument_list|,
name|rd_rn
argument_list|)
block|,
name|cCE
argument_list|(
name|cfmv64a
argument_list|,
name|e1004c0
argument_list|,
literal|2
argument_list|,
operator|(
name|RMDX
expr|,
name|RMAX
operator|)
argument_list|,
name|rd_rn
argument_list|)
block|,
name|cCE
argument_list|(
name|cfmvsc32
argument_list|,
name|e2004e0
argument_list|,
literal|2
argument_list|,
operator|(
name|RMDS
expr|,
name|RMDX
operator|)
argument_list|,
name|mav_dspsc
argument_list|)
block|,
name|cCE
argument_list|(
name|cfmv32sc
argument_list|,
name|e1004e0
argument_list|,
literal|2
argument_list|,
operator|(
name|RMDX
expr|,
name|RMDS
operator|)
argument_list|,
name|rd
argument_list|)
block|,
name|cCE
argument_list|(
name|cfcpys
argument_list|,
name|e000400
argument_list|,
literal|2
argument_list|,
operator|(
name|RMF
expr|,
name|RMF
operator|)
argument_list|,
name|rd_rn
argument_list|)
block|,
name|cCE
argument_list|(
name|cfcpyd
argument_list|,
name|e000420
argument_list|,
literal|2
argument_list|,
operator|(
name|RMD
expr|,
name|RMD
operator|)
argument_list|,
name|rd_rn
argument_list|)
block|,
name|cCE
argument_list|(
name|cfcvtsd
argument_list|,
name|e000460
argument_list|,
literal|2
argument_list|,
operator|(
name|RMD
expr|,
name|RMF
operator|)
argument_list|,
name|rd_rn
argument_list|)
block|,
name|cCE
argument_list|(
name|cfcvtds
argument_list|,
name|e000440
argument_list|,
literal|2
argument_list|,
operator|(
name|RMF
expr|,
name|RMD
operator|)
argument_list|,
name|rd_rn
argument_list|)
block|,
name|cCE
argument_list|(
name|cfcvt32s
argument_list|,
name|e000480
argument_list|,
literal|2
argument_list|,
operator|(
name|RMF
expr|,
name|RMFX
operator|)
argument_list|,
name|rd_rn
argument_list|)
block|,
name|cCE
argument_list|(
name|cfcvt32d
argument_list|,
name|e0004a0
argument_list|,
literal|2
argument_list|,
operator|(
name|RMD
expr|,
name|RMFX
operator|)
argument_list|,
name|rd_rn
argument_list|)
block|,
name|cCE
argument_list|(
name|cfcvt64s
argument_list|,
name|e0004c0
argument_list|,
literal|2
argument_list|,
operator|(
name|RMF
expr|,
name|RMDX
operator|)
argument_list|,
name|rd_rn
argument_list|)
block|,
name|cCE
argument_list|(
name|cfcvt64d
argument_list|,
name|e0004e0
argument_list|,
literal|2
argument_list|,
operator|(
name|RMD
expr|,
name|RMDX
operator|)
argument_list|,
name|rd_rn
argument_list|)
block|,
name|cCE
argument_list|(
name|cfcvts32
argument_list|,
name|e100580
argument_list|,
literal|2
argument_list|,
operator|(
name|RMFX
expr|,
name|RMF
operator|)
argument_list|,
name|rd_rn
argument_list|)
block|,
name|cCE
argument_list|(
name|cfcvtd32
argument_list|,
name|e1005a0
argument_list|,
literal|2
argument_list|,
operator|(
name|RMFX
expr|,
name|RMD
operator|)
argument_list|,
name|rd_rn
argument_list|)
block|,
name|cCE
argument_list|(
name|cftruncs32
argument_list|,
name|e1005c0
argument_list|,
literal|2
argument_list|,
operator|(
name|RMFX
expr|,
name|RMF
operator|)
argument_list|,
name|rd_rn
argument_list|)
block|,
name|cCE
argument_list|(
name|cftruncd32
argument_list|,
name|e1005e0
argument_list|,
literal|2
argument_list|,
operator|(
name|RMFX
expr|,
name|RMD
operator|)
argument_list|,
name|rd_rn
argument_list|)
block|,
name|cCE
argument_list|(
name|cfrshl32
argument_list|,
name|e000550
argument_list|,
literal|3
argument_list|,
operator|(
name|RMFX
expr|,
name|RMFX
expr|,
name|RR
operator|)
argument_list|,
name|mav_triple
argument_list|)
block|,
name|cCE
argument_list|(
name|cfrshl64
argument_list|,
name|e000570
argument_list|,
literal|3
argument_list|,
operator|(
name|RMDX
expr|,
name|RMDX
expr|,
name|RR
operator|)
argument_list|,
name|mav_triple
argument_list|)
block|,
name|cCE
argument_list|(
name|cfsh32
argument_list|,
name|e000500
argument_list|,
literal|3
argument_list|,
operator|(
name|RMFX
expr|,
name|RMFX
expr|,
name|I63s
operator|)
argument_list|,
name|mav_shift
argument_list|)
block|,
name|cCE
argument_list|(
name|cfsh64
argument_list|,
name|e200500
argument_list|,
literal|3
argument_list|,
operator|(
name|RMDX
expr|,
name|RMDX
expr|,
name|I63s
operator|)
argument_list|,
name|mav_shift
argument_list|)
block|,
name|cCE
argument_list|(
name|cfcmps
argument_list|,
name|e100490
argument_list|,
literal|3
argument_list|,
operator|(
name|RR
expr|,
name|RMF
expr|,
name|RMF
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCE
argument_list|(
name|cfcmpd
argument_list|,
name|e1004b0
argument_list|,
literal|3
argument_list|,
operator|(
name|RR
expr|,
name|RMD
expr|,
name|RMD
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCE
argument_list|(
name|cfcmp32
argument_list|,
name|e100590
argument_list|,
literal|3
argument_list|,
operator|(
name|RR
expr|,
name|RMFX
expr|,
name|RMFX
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCE
argument_list|(
name|cfcmp64
argument_list|,
name|e1005b0
argument_list|,
literal|3
argument_list|,
operator|(
name|RR
expr|,
name|RMDX
expr|,
name|RMDX
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCE
argument_list|(
name|cfabss
argument_list|,
name|e300400
argument_list|,
literal|2
argument_list|,
operator|(
name|RMF
expr|,
name|RMF
operator|)
argument_list|,
name|rd_rn
argument_list|)
block|,
name|cCE
argument_list|(
name|cfabsd
argument_list|,
name|e300420
argument_list|,
literal|2
argument_list|,
operator|(
name|RMD
expr|,
name|RMD
operator|)
argument_list|,
name|rd_rn
argument_list|)
block|,
name|cCE
argument_list|(
name|cfnegs
argument_list|,
name|e300440
argument_list|,
literal|2
argument_list|,
operator|(
name|RMF
expr|,
name|RMF
operator|)
argument_list|,
name|rd_rn
argument_list|)
block|,
name|cCE
argument_list|(
name|cfnegd
argument_list|,
name|e300460
argument_list|,
literal|2
argument_list|,
operator|(
name|RMD
expr|,
name|RMD
operator|)
argument_list|,
name|rd_rn
argument_list|)
block|,
name|cCE
argument_list|(
name|cfadds
argument_list|,
name|e300480
argument_list|,
literal|3
argument_list|,
operator|(
name|RMF
expr|,
name|RMF
expr|,
name|RMF
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCE
argument_list|(
name|cfaddd
argument_list|,
name|e3004a0
argument_list|,
literal|3
argument_list|,
operator|(
name|RMD
expr|,
name|RMD
expr|,
name|RMD
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCE
argument_list|(
name|cfsubs
argument_list|,
name|e3004c0
argument_list|,
literal|3
argument_list|,
operator|(
name|RMF
expr|,
name|RMF
expr|,
name|RMF
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCE
argument_list|(
name|cfsubd
argument_list|,
name|e3004e0
argument_list|,
literal|3
argument_list|,
operator|(
name|RMD
expr|,
name|RMD
expr|,
name|RMD
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCE
argument_list|(
name|cfmuls
argument_list|,
name|e100400
argument_list|,
literal|3
argument_list|,
operator|(
name|RMF
expr|,
name|RMF
expr|,
name|RMF
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCE
argument_list|(
name|cfmuld
argument_list|,
name|e100420
argument_list|,
literal|3
argument_list|,
operator|(
name|RMD
expr|,
name|RMD
expr|,
name|RMD
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCE
argument_list|(
name|cfabs32
argument_list|,
name|e300500
argument_list|,
literal|2
argument_list|,
operator|(
name|RMFX
expr|,
name|RMFX
operator|)
argument_list|,
name|rd_rn
argument_list|)
block|,
name|cCE
argument_list|(
name|cfabs64
argument_list|,
name|e300520
argument_list|,
literal|2
argument_list|,
operator|(
name|RMDX
expr|,
name|RMDX
operator|)
argument_list|,
name|rd_rn
argument_list|)
block|,
name|cCE
argument_list|(
name|cfneg32
argument_list|,
name|e300540
argument_list|,
literal|2
argument_list|,
operator|(
name|RMFX
expr|,
name|RMFX
operator|)
argument_list|,
name|rd_rn
argument_list|)
block|,
name|cCE
argument_list|(
name|cfneg64
argument_list|,
name|e300560
argument_list|,
literal|2
argument_list|,
operator|(
name|RMDX
expr|,
name|RMDX
operator|)
argument_list|,
name|rd_rn
argument_list|)
block|,
name|cCE
argument_list|(
name|cfadd32
argument_list|,
name|e300580
argument_list|,
literal|3
argument_list|,
operator|(
name|RMFX
expr|,
name|RMFX
expr|,
name|RMFX
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCE
argument_list|(
name|cfadd64
argument_list|,
name|e3005a0
argument_list|,
literal|3
argument_list|,
operator|(
name|RMDX
expr|,
name|RMDX
expr|,
name|RMDX
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCE
argument_list|(
name|cfsub32
argument_list|,
name|e3005c0
argument_list|,
literal|3
argument_list|,
operator|(
name|RMFX
expr|,
name|RMFX
expr|,
name|RMFX
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCE
argument_list|(
name|cfsub64
argument_list|,
name|e3005e0
argument_list|,
literal|3
argument_list|,
operator|(
name|RMDX
expr|,
name|RMDX
expr|,
name|RMDX
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCE
argument_list|(
name|cfmul32
argument_list|,
name|e100500
argument_list|,
literal|3
argument_list|,
operator|(
name|RMFX
expr|,
name|RMFX
expr|,
name|RMFX
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCE
argument_list|(
name|cfmul64
argument_list|,
name|e100520
argument_list|,
literal|3
argument_list|,
operator|(
name|RMDX
expr|,
name|RMDX
expr|,
name|RMDX
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCE
argument_list|(
name|cfmac32
argument_list|,
name|e100540
argument_list|,
literal|3
argument_list|,
operator|(
name|RMFX
expr|,
name|RMFX
expr|,
name|RMFX
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCE
argument_list|(
name|cfmsc32
argument_list|,
name|e100560
argument_list|,
literal|3
argument_list|,
operator|(
name|RMFX
expr|,
name|RMFX
expr|,
name|RMFX
operator|)
argument_list|,
name|rd_rn_rm
argument_list|)
block|,
name|cCE
argument_list|(
name|cfmadd32
argument_list|,
name|e000600
argument_list|,
literal|4
argument_list|,
operator|(
name|RMAX
expr|,
name|RMFX
expr|,
name|RMFX
expr|,
name|RMFX
operator|)
argument_list|,
name|mav_quad
argument_list|)
block|,
name|cCE
argument_list|(
name|cfmsub32
argument_list|,
name|e100600
argument_list|,
literal|4
argument_list|,
operator|(
name|RMAX
expr|,
name|RMFX
expr|,
name|RMFX
expr|,
name|RMFX
operator|)
argument_list|,
name|mav_quad
argument_list|)
block|,
name|cCE
argument_list|(
name|cfmadda32
argument_list|,
name|e200600
argument_list|,
literal|4
argument_list|,
operator|(
name|RMAX
expr|,
name|RMAX
expr|,
name|RMFX
expr|,
name|RMFX
operator|)
argument_list|,
name|mav_quad
argument_list|)
block|,
name|cCE
argument_list|(
name|cfmsuba32
argument_list|,
name|e300600
argument_list|,
literal|4
argument_list|,
operator|(
name|RMAX
expr|,
name|RMAX
expr|,
name|RMFX
expr|,
name|RMFX
operator|)
argument_list|,
name|mav_quad
argument_list|)
block|, }
decl_stmt|;
end_decl_stmt

begin_undef
undef|#
directive|undef
name|ARM_VARIANT
end_undef

begin_undef
undef|#
directive|undef
name|THUMB_VARIANT
end_undef

begin_undef
undef|#
directive|undef
name|TCE
end_undef

begin_undef
undef|#
directive|undef
name|TCM
end_undef

begin_undef
undef|#
directive|undef
name|TUE
end_undef

begin_undef
undef|#
directive|undef
name|TUF
end_undef

begin_undef
undef|#
directive|undef
name|TCC
end_undef

begin_undef
undef|#
directive|undef
name|cCE
end_undef

begin_undef
undef|#
directive|undef
name|cCL
end_undef

begin_undef
undef|#
directive|undef
name|C3E
end_undef

begin_undef
undef|#
directive|undef
name|CE
end_undef

begin_undef
undef|#
directive|undef
name|CM
end_undef

begin_undef
undef|#
directive|undef
name|UE
end_undef

begin_undef
undef|#
directive|undef
name|UF
end_undef

begin_undef
undef|#
directive|undef
name|UT
end_undef

begin_undef
undef|#
directive|undef
name|NUF
end_undef

begin_undef
undef|#
directive|undef
name|nUF
end_undef

begin_undef
undef|#
directive|undef
name|NCE
end_undef

begin_undef
undef|#
directive|undef
name|nCE
end_undef

begin_undef
undef|#
directive|undef
name|OPS0
end_undef

begin_undef
undef|#
directive|undef
name|OPS1
end_undef

begin_undef
undef|#
directive|undef
name|OPS2
end_undef

begin_undef
undef|#
directive|undef
name|OPS3
end_undef

begin_undef
undef|#
directive|undef
name|OPS4
end_undef

begin_undef
undef|#
directive|undef
name|OPS5
end_undef

begin_undef
undef|#
directive|undef
name|OPS6
end_undef

begin_undef
undef|#
directive|undef
name|do_0
end_undef

begin_escape
end_escape

begin_comment
comment|/* MD interface: bits in the object file.  */
end_comment

begin_comment
comment|/* Turn an integer of n bytes (in val) into a stream of bytes appropriate    for use in the a.out file, and stores them in the array pointed to by buf.    This knows about the endian-ness of the target machine and does    THE RIGHT THING, whatever it is.  Possible values for n are 1 (byte)    2 (short) and 4 (long)  Floating numbers are put out as a series of    LITTLENUMS (shorts, here at least).	*/
end_comment

begin_function
name|void
name|md_number_to_chars
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|valueT
name|val
parameter_list|,
name|int
name|n
parameter_list|)
block|{
if|if
condition|(
name|target_big_endian
condition|)
name|number_to_chars_bigendian
argument_list|(
name|buf
argument_list|,
name|val
argument_list|,
name|n
argument_list|)
expr_stmt|;
else|else
name|number_to_chars_littleendian
argument_list|(
name|buf
argument_list|,
name|val
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|valueT
name|md_chars_to_number
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|n
parameter_list|)
block|{
name|valueT
name|result
init|=
literal|0
decl_stmt|;
name|unsigned
name|char
modifier|*
name|where
init|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|buf
decl_stmt|;
if|if
condition|(
name|target_big_endian
condition|)
block|{
while|while
condition|(
name|n
operator|--
condition|)
block|{
name|result
operator|<<=
literal|8
expr_stmt|;
name|result
operator||=
operator|(
operator|*
name|where
operator|++
operator|&
literal|255
operator|)
expr_stmt|;
block|}
block|}
else|else
block|{
while|while
condition|(
name|n
operator|--
condition|)
block|{
name|result
operator|<<=
literal|8
expr_stmt|;
name|result
operator||=
operator|(
name|where
index|[
name|n
index|]
operator|&
literal|255
operator|)
expr_stmt|;
block|}
block|}
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* MD interface: Sections.  */
end_comment

begin_comment
comment|/* Estimate the size of a frag before relaxing.  Assume everything fits in    2 bytes.  */
end_comment

begin_function
name|int
name|md_estimate_size_before_relax
parameter_list|(
name|fragS
modifier|*
name|fragp
parameter_list|,
name|segT
name|segtype
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|fragp
operator|->
name|fr_var
operator|=
literal|2
expr_stmt|;
return|return
literal|2
return|;
block|}
end_function

begin_comment
comment|/* Convert a machine dependent frag.  */
end_comment

begin_function
name|void
name|md_convert_frag
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|segT
name|asec
name|ATTRIBUTE_UNUSED
parameter_list|,
name|fragS
modifier|*
name|fragp
parameter_list|)
block|{
name|unsigned
name|long
name|insn
decl_stmt|;
name|unsigned
name|long
name|old_op
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|expressionS
name|exp
decl_stmt|;
name|fixS
modifier|*
name|fixp
decl_stmt|;
name|int
name|reloc_type
decl_stmt|;
name|int
name|pc_rel
decl_stmt|;
name|int
name|opcode
decl_stmt|;
name|buf
operator|=
name|fragp
operator|->
name|fr_literal
operator|+
name|fragp
operator|->
name|fr_fix
expr_stmt|;
name|old_op
operator|=
name|bfd_get_16
argument_list|(
name|abfd
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|fragp
operator|->
name|fr_symbol
condition|)
block|{
name|exp
operator|.
name|X_op
operator|=
name|O_symbol
expr_stmt|;
name|exp
operator|.
name|X_add_symbol
operator|=
name|fragp
operator|->
name|fr_symbol
expr_stmt|;
block|}
else|else
block|{
name|exp
operator|.
name|X_op
operator|=
name|O_constant
expr_stmt|;
block|}
name|exp
operator|.
name|X_add_number
operator|=
name|fragp
operator|->
name|fr_offset
expr_stmt|;
name|opcode
operator|=
name|fragp
operator|->
name|fr_subtype
expr_stmt|;
switch|switch
condition|(
name|opcode
condition|)
block|{
case|case
name|T_MNEM_ldr_pc
case|:
case|case
name|T_MNEM_ldr_pc2
case|:
case|case
name|T_MNEM_ldr_sp
case|:
case|case
name|T_MNEM_str_sp
case|:
case|case
name|T_MNEM_ldr
case|:
case|case
name|T_MNEM_ldrb
case|:
case|case
name|T_MNEM_ldrh
case|:
case|case
name|T_MNEM_str
case|:
case|case
name|T_MNEM_strb
case|:
case|case
name|T_MNEM_strh
case|:
if|if
condition|(
name|fragp
operator|->
name|fr_var
operator|==
literal|4
condition|)
block|{
name|insn
operator|=
name|THUMB_OP32
argument_list|(
name|opcode
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|old_op
operator|>>
literal|12
operator|)
operator|==
literal|4
operator|||
operator|(
name|old_op
operator|>>
literal|12
operator|)
operator|==
literal|9
condition|)
block|{
name|insn
operator||=
operator|(
name|old_op
operator|&
literal|0x700
operator|)
operator|<<
literal|4
expr_stmt|;
block|}
else|else
block|{
name|insn
operator||=
operator|(
name|old_op
operator|&
literal|7
operator|)
operator|<<
literal|12
expr_stmt|;
name|insn
operator||=
operator|(
name|old_op
operator|&
literal|0x38
operator|)
operator|<<
literal|13
expr_stmt|;
block|}
name|insn
operator||=
literal|0x00000c00
expr_stmt|;
name|put_thumb32_insn
argument_list|(
name|buf
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|reloc_type
operator|=
name|BFD_RELOC_ARM_T32_OFFSET_IMM
expr_stmt|;
block|}
else|else
block|{
name|reloc_type
operator|=
name|BFD_RELOC_ARM_THUMB_OFFSET
expr_stmt|;
block|}
name|pc_rel
operator|=
operator|(
name|opcode
operator|==
name|T_MNEM_ldr_pc2
operator|)
expr_stmt|;
break|break;
case|case
name|T_MNEM_adr
case|:
if|if
condition|(
name|fragp
operator|->
name|fr_var
operator|==
literal|4
condition|)
block|{
name|insn
operator|=
name|THUMB_OP32
argument_list|(
name|opcode
argument_list|)
expr_stmt|;
name|insn
operator||=
operator|(
name|old_op
operator|&
literal|0xf0
operator|)
operator|<<
literal|4
expr_stmt|;
name|put_thumb32_insn
argument_list|(
name|buf
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|reloc_type
operator|=
name|BFD_RELOC_ARM_T32_ADD_PC12
expr_stmt|;
block|}
else|else
block|{
name|reloc_type
operator|=
name|BFD_RELOC_ARM_THUMB_ADD
expr_stmt|;
name|exp
operator|.
name|X_add_number
operator|-=
literal|4
expr_stmt|;
block|}
name|pc_rel
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|T_MNEM_mov
case|:
case|case
name|T_MNEM_movs
case|:
case|case
name|T_MNEM_cmp
case|:
case|case
name|T_MNEM_cmn
case|:
if|if
condition|(
name|fragp
operator|->
name|fr_var
operator|==
literal|4
condition|)
block|{
name|int
name|r0off
init|=
operator|(
name|opcode
operator|==
name|T_MNEM_mov
operator|||
name|opcode
operator|==
name|T_MNEM_movs
operator|)
condition|?
literal|0
else|:
literal|8
decl_stmt|;
name|insn
operator|=
name|THUMB_OP32
argument_list|(
name|opcode
argument_list|)
expr_stmt|;
name|insn
operator|=
operator|(
name|insn
operator|&
literal|0xe1ffffff
operator|)
operator||
literal|0x10000000
expr_stmt|;
name|insn
operator||=
operator|(
name|old_op
operator|&
literal|0x700
operator|)
operator|<<
name|r0off
expr_stmt|;
name|put_thumb32_insn
argument_list|(
name|buf
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|reloc_type
operator|=
name|BFD_RELOC_ARM_T32_IMMEDIATE
expr_stmt|;
block|}
else|else
block|{
name|reloc_type
operator|=
name|BFD_RELOC_ARM_THUMB_IMM
expr_stmt|;
block|}
name|pc_rel
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|T_MNEM_b
case|:
if|if
condition|(
name|fragp
operator|->
name|fr_var
operator|==
literal|4
condition|)
block|{
name|insn
operator|=
name|THUMB_OP32
argument_list|(
name|opcode
argument_list|)
expr_stmt|;
name|put_thumb32_insn
argument_list|(
name|buf
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|reloc_type
operator|=
name|BFD_RELOC_THUMB_PCREL_BRANCH25
expr_stmt|;
block|}
else|else
name|reloc_type
operator|=
name|BFD_RELOC_THUMB_PCREL_BRANCH12
expr_stmt|;
name|pc_rel
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|T_MNEM_bcond
case|:
if|if
condition|(
name|fragp
operator|->
name|fr_var
operator|==
literal|4
condition|)
block|{
name|insn
operator|=
name|THUMB_OP32
argument_list|(
name|opcode
argument_list|)
expr_stmt|;
name|insn
operator||=
operator|(
name|old_op
operator|&
literal|0xf00
operator|)
operator|<<
literal|14
expr_stmt|;
name|put_thumb32_insn
argument_list|(
name|buf
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|reloc_type
operator|=
name|BFD_RELOC_THUMB_PCREL_BRANCH20
expr_stmt|;
block|}
else|else
name|reloc_type
operator|=
name|BFD_RELOC_THUMB_PCREL_BRANCH9
expr_stmt|;
name|pc_rel
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|T_MNEM_add_sp
case|:
case|case
name|T_MNEM_add_pc
case|:
case|case
name|T_MNEM_inc_sp
case|:
case|case
name|T_MNEM_dec_sp
case|:
if|if
condition|(
name|fragp
operator|->
name|fr_var
operator|==
literal|4
condition|)
block|{
comment|/* ??? Choose between add and addw.  */
name|insn
operator|=
name|THUMB_OP32
argument_list|(
name|opcode
argument_list|)
expr_stmt|;
name|insn
operator||=
operator|(
name|old_op
operator|&
literal|0xf0
operator|)
operator|<<
literal|4
expr_stmt|;
name|put_thumb32_insn
argument_list|(
name|buf
argument_list|,
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|opcode
operator|==
name|T_MNEM_add_pc
condition|)
name|reloc_type
operator|=
name|BFD_RELOC_ARM_T32_IMM12
expr_stmt|;
else|else
name|reloc_type
operator|=
name|BFD_RELOC_ARM_T32_ADD_IMM
expr_stmt|;
block|}
else|else
name|reloc_type
operator|=
name|BFD_RELOC_ARM_THUMB_ADD
expr_stmt|;
name|pc_rel
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|T_MNEM_addi
case|:
case|case
name|T_MNEM_addis
case|:
case|case
name|T_MNEM_subi
case|:
case|case
name|T_MNEM_subis
case|:
if|if
condition|(
name|fragp
operator|->
name|fr_var
operator|==
literal|4
condition|)
block|{
name|insn
operator|=
name|THUMB_OP32
argument_list|(
name|opcode
argument_list|)
expr_stmt|;
name|insn
operator||=
operator|(
name|old_op
operator|&
literal|0xf0
operator|)
operator|<<
literal|4
expr_stmt|;
name|insn
operator||=
operator|(
name|old_op
operator|&
literal|0xf
operator|)
operator|<<
literal|16
expr_stmt|;
name|put_thumb32_insn
argument_list|(
name|buf
argument_list|,
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn
operator|&
operator|(
literal|1
operator|<<
literal|20
operator|)
condition|)
name|reloc_type
operator|=
name|BFD_RELOC_ARM_T32_ADD_IMM
expr_stmt|;
else|else
name|reloc_type
operator|=
name|BFD_RELOC_ARM_T32_IMMEDIATE
expr_stmt|;
block|}
else|else
name|reloc_type
operator|=
name|BFD_RELOC_ARM_THUMB_ADD
expr_stmt|;
name|pc_rel
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|fixp
operator|=
name|fix_new_exp
argument_list|(
name|fragp
argument_list|,
name|fragp
operator|->
name|fr_fix
argument_list|,
name|fragp
operator|->
name|fr_var
argument_list|,
operator|&
name|exp
argument_list|,
name|pc_rel
argument_list|,
name|reloc_type
argument_list|)
expr_stmt|;
name|fixp
operator|->
name|fx_file
operator|=
name|fragp
operator|->
name|fr_file
expr_stmt|;
name|fixp
operator|->
name|fx_line
operator|=
name|fragp
operator|->
name|fr_line
expr_stmt|;
name|fragp
operator|->
name|fr_fix
operator|+=
name|fragp
operator|->
name|fr_var
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the size of a relaxable immediate operand instruction.    SHIFT and SIZE specify the form of the allowable immediate.  */
end_comment

begin_function
specifier|static
name|int
name|relax_immediate
parameter_list|(
name|fragS
modifier|*
name|fragp
parameter_list|,
name|int
name|size
parameter_list|,
name|int
name|shift
parameter_list|)
block|{
name|offsetT
name|offset
decl_stmt|;
name|offsetT
name|mask
decl_stmt|;
name|offsetT
name|low
decl_stmt|;
comment|/* ??? Should be able to do better than this.  */
if|if
condition|(
name|fragp
operator|->
name|fr_symbol
condition|)
return|return
literal|4
return|;
name|low
operator|=
operator|(
literal|1
operator|<<
name|shift
operator|)
operator|-
literal|1
expr_stmt|;
name|mask
operator|=
operator|(
literal|1
operator|<<
operator|(
name|shift
operator|+
name|size
operator|)
operator|)
operator|-
operator|(
literal|1
operator|<<
name|shift
operator|)
expr_stmt|;
name|offset
operator|=
name|fragp
operator|->
name|fr_offset
expr_stmt|;
comment|/* Force misaligned offsets to 32-bit variant.  */
if|if
condition|(
name|offset
operator|&
name|low
condition|)
return|return
literal|4
return|;
if|if
condition|(
name|offset
operator|&
operator|~
name|mask
condition|)
return|return
literal|4
return|;
return|return
literal|2
return|;
block|}
end_function

begin_comment
comment|/* Get the address of a symbol during relaxation.  */
end_comment

begin_function
specifier|static
name|addressT
name|relaxed_symbol_addr
parameter_list|(
name|fragS
modifier|*
name|fragp
parameter_list|,
name|long
name|stretch
parameter_list|)
block|{
name|fragS
modifier|*
name|sym_frag
decl_stmt|;
name|addressT
name|addr
decl_stmt|;
name|symbolS
modifier|*
name|sym
decl_stmt|;
name|sym
operator|=
name|fragp
operator|->
name|fr_symbol
expr_stmt|;
name|sym_frag
operator|=
name|symbol_get_frag
argument_list|(
name|sym
argument_list|)
expr_stmt|;
name|know
argument_list|(
name|S_GET_SEGMENT
argument_list|(
name|sym
argument_list|)
operator|!=
name|absolute_section
operator|||
name|sym_frag
operator|==
operator|&
name|zero_address_frag
argument_list|)
expr_stmt|;
name|addr
operator|=
name|S_GET_VALUE
argument_list|(
name|sym
argument_list|)
operator|+
name|fragp
operator|->
name|fr_offset
expr_stmt|;
comment|/* If frag has yet to be reached on this pass, assume it will      move by STRETCH just as we did.  If this is not so, it will      be because some frag between grows, and that will force      another pass.  */
if|if
condition|(
name|stretch
operator|!=
literal|0
operator|&&
name|sym_frag
operator|->
name|relax_marker
operator|!=
name|fragp
operator|->
name|relax_marker
condition|)
name|addr
operator|+=
name|stretch
expr_stmt|;
return|return
name|addr
return|;
block|}
end_function

begin_comment
comment|/* Return the size of a relaxable adr pseudo-instruction or PC-relative    load.  */
end_comment

begin_function
specifier|static
name|int
name|relax_adr
parameter_list|(
name|fragS
modifier|*
name|fragp
parameter_list|,
name|asection
modifier|*
name|sec
parameter_list|,
name|long
name|stretch
parameter_list|)
block|{
name|addressT
name|addr
decl_stmt|;
name|offsetT
name|val
decl_stmt|;
comment|/* Assume worst case for symbols not known to be in the same section.  */
if|if
condition|(
operator|!
name|S_IS_DEFINED
argument_list|(
name|fragp
operator|->
name|fr_symbol
argument_list|)
operator|||
name|sec
operator|!=
name|S_GET_SEGMENT
argument_list|(
name|fragp
operator|->
name|fr_symbol
argument_list|)
condition|)
return|return
literal|4
return|;
name|val
operator|=
name|relaxed_symbol_addr
argument_list|(
name|fragp
argument_list|,
name|stretch
argument_list|)
expr_stmt|;
name|addr
operator|=
name|fragp
operator|->
name|fr_address
operator|+
name|fragp
operator|->
name|fr_fix
expr_stmt|;
name|addr
operator|=
operator|(
name|addr
operator|+
literal|4
operator|)
operator|&
operator|~
literal|3
expr_stmt|;
comment|/* Force misaligned targets to 32-bit variant.  */
if|if
condition|(
name|val
operator|&
literal|3
condition|)
return|return
literal|4
return|;
name|val
operator|-=
name|addr
expr_stmt|;
if|if
condition|(
name|val
operator|<
literal|0
operator|||
name|val
operator|>
literal|1020
condition|)
return|return
literal|4
return|;
return|return
literal|2
return|;
block|}
end_function

begin_comment
comment|/* Return the size of a relaxable add/sub immediate instruction.  */
end_comment

begin_function
specifier|static
name|int
name|relax_addsub
parameter_list|(
name|fragS
modifier|*
name|fragp
parameter_list|,
name|asection
modifier|*
name|sec
parameter_list|)
block|{
name|char
modifier|*
name|buf
decl_stmt|;
name|int
name|op
decl_stmt|;
name|buf
operator|=
name|fragp
operator|->
name|fr_literal
operator|+
name|fragp
operator|->
name|fr_fix
expr_stmt|;
name|op
operator|=
name|bfd_get_16
argument_list|(
name|sec
operator|->
name|owner
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|op
operator|&
literal|0xf
operator|)
operator|==
operator|(
operator|(
name|op
operator|>>
literal|4
operator|)
operator|&
literal|0xf
operator|)
condition|)
return|return
name|relax_immediate
argument_list|(
name|fragp
argument_list|,
literal|8
argument_list|,
literal|0
argument_list|)
return|;
else|else
return|return
name|relax_immediate
argument_list|(
name|fragp
argument_list|,
literal|3
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return the size of a relaxable branch instruction.  BITS is the    size of the offset field in the narrow instruction.  */
end_comment

begin_function
specifier|static
name|int
name|relax_branch
parameter_list|(
name|fragS
modifier|*
name|fragp
parameter_list|,
name|asection
modifier|*
name|sec
parameter_list|,
name|int
name|bits
parameter_list|,
name|long
name|stretch
parameter_list|)
block|{
name|addressT
name|addr
decl_stmt|;
name|offsetT
name|val
decl_stmt|;
name|offsetT
name|limit
decl_stmt|;
comment|/* Assume worst case for symbols not known to be in the same section.  */
if|if
condition|(
operator|!
name|S_IS_DEFINED
argument_list|(
name|fragp
operator|->
name|fr_symbol
argument_list|)
operator|||
name|sec
operator|!=
name|S_GET_SEGMENT
argument_list|(
name|fragp
operator|->
name|fr_symbol
argument_list|)
condition|)
return|return
literal|4
return|;
name|val
operator|=
name|relaxed_symbol_addr
argument_list|(
name|fragp
argument_list|,
name|stretch
argument_list|)
expr_stmt|;
name|addr
operator|=
name|fragp
operator|->
name|fr_address
operator|+
name|fragp
operator|->
name|fr_fix
operator|+
literal|4
expr_stmt|;
name|val
operator|-=
name|addr
expr_stmt|;
comment|/* Offset is a signed value *2 */
name|limit
operator|=
literal|1
operator|<<
name|bits
expr_stmt|;
if|if
condition|(
name|val
operator|>=
name|limit
operator|||
name|val
operator|<
operator|-
name|limit
condition|)
return|return
literal|4
return|;
return|return
literal|2
return|;
block|}
end_function

begin_comment
comment|/* Relax a machine dependent frag.  This returns the amount by which    the current size of the frag should change.  */
end_comment

begin_function
name|int
name|arm_relax_frag
parameter_list|(
name|asection
modifier|*
name|sec
parameter_list|,
name|fragS
modifier|*
name|fragp
parameter_list|,
name|long
name|stretch
parameter_list|)
block|{
name|int
name|oldsize
decl_stmt|;
name|int
name|newsize
decl_stmt|;
name|oldsize
operator|=
name|fragp
operator|->
name|fr_var
expr_stmt|;
switch|switch
condition|(
name|fragp
operator|->
name|fr_subtype
condition|)
block|{
case|case
name|T_MNEM_ldr_pc2
case|:
name|newsize
operator|=
name|relax_adr
argument_list|(
name|fragp
argument_list|,
name|sec
argument_list|,
name|stretch
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_MNEM_ldr_pc
case|:
case|case
name|T_MNEM_ldr_sp
case|:
case|case
name|T_MNEM_str_sp
case|:
name|newsize
operator|=
name|relax_immediate
argument_list|(
name|fragp
argument_list|,
literal|8
argument_list|,
literal|2
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_MNEM_ldr
case|:
case|case
name|T_MNEM_str
case|:
name|newsize
operator|=
name|relax_immediate
argument_list|(
name|fragp
argument_list|,
literal|5
argument_list|,
literal|2
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_MNEM_ldrh
case|:
case|case
name|T_MNEM_strh
case|:
name|newsize
operator|=
name|relax_immediate
argument_list|(
name|fragp
argument_list|,
literal|5
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_MNEM_ldrb
case|:
case|case
name|T_MNEM_strb
case|:
name|newsize
operator|=
name|relax_immediate
argument_list|(
name|fragp
argument_list|,
literal|5
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_MNEM_adr
case|:
name|newsize
operator|=
name|relax_adr
argument_list|(
name|fragp
argument_list|,
name|sec
argument_list|,
name|stretch
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_MNEM_mov
case|:
case|case
name|T_MNEM_movs
case|:
case|case
name|T_MNEM_cmp
case|:
case|case
name|T_MNEM_cmn
case|:
name|newsize
operator|=
name|relax_immediate
argument_list|(
name|fragp
argument_list|,
literal|8
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_MNEM_b
case|:
name|newsize
operator|=
name|relax_branch
argument_list|(
name|fragp
argument_list|,
name|sec
argument_list|,
literal|11
argument_list|,
name|stretch
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_MNEM_bcond
case|:
name|newsize
operator|=
name|relax_branch
argument_list|(
name|fragp
argument_list|,
name|sec
argument_list|,
literal|8
argument_list|,
name|stretch
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_MNEM_add_sp
case|:
case|case
name|T_MNEM_add_pc
case|:
name|newsize
operator|=
name|relax_immediate
argument_list|(
name|fragp
argument_list|,
literal|8
argument_list|,
literal|2
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_MNEM_inc_sp
case|:
case|case
name|T_MNEM_dec_sp
case|:
name|newsize
operator|=
name|relax_immediate
argument_list|(
name|fragp
argument_list|,
literal|7
argument_list|,
literal|2
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_MNEM_addi
case|:
case|case
name|T_MNEM_addis
case|:
case|case
name|T_MNEM_subi
case|:
case|case
name|T_MNEM_subis
case|:
name|newsize
operator|=
name|relax_addsub
argument_list|(
name|fragp
argument_list|,
name|sec
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|fragp
operator|->
name|fr_var
operator|=
name|newsize
expr_stmt|;
comment|/* Freeze wide instructions that are at or before the same location as      in the previous pass.  This avoids infinite loops.      Don't freeze them unconditionally because targets may be artificialy      misaligned by the expansion of preceeding frags.  */
if|if
condition|(
name|stretch
operator|<=
literal|0
operator|&&
name|newsize
operator|>
literal|2
condition|)
block|{
name|md_convert_frag
argument_list|(
name|sec
operator|->
name|owner
argument_list|,
name|sec
argument_list|,
name|fragp
argument_list|)
expr_stmt|;
name|frag_wane
argument_list|(
name|fragp
argument_list|)
expr_stmt|;
block|}
return|return
name|newsize
operator|-
name|oldsize
return|;
block|}
end_function

begin_comment
comment|/* Round up a section size to the appropriate boundary.	 */
end_comment

begin_function
name|valueT
name|md_section_align
parameter_list|(
name|segT
name|segment
name|ATTRIBUTE_UNUSED
parameter_list|,
name|valueT
name|size
parameter_list|)
block|{
if|#
directive|if
operator|(
name|defined
argument_list|(
name|OBJ_AOUT
argument_list|)
operator|||
name|defined
argument_list|(
name|OBJ_MAYBE_AOUT
argument_list|)
operator|)
if|if
condition|(
name|OUTPUT_FLAVOR
operator|==
name|bfd_target_aout_flavour
condition|)
block|{
comment|/* For a.out, force the section size to be aligned.  If we don't do 	 this, BFD will align it for us, but it will not write out the 	 final bytes of the section.  This may be a bug in BFD, but it is 	 easier to fix it here since that is how the other a.out targets 	 work.  */
name|int
name|align
decl_stmt|;
name|align
operator|=
name|bfd_get_section_alignment
argument_list|(
name|stdoutput
argument_list|,
name|segment
argument_list|)
expr_stmt|;
name|size
operator|=
operator|(
operator|(
name|size
operator|+
operator|(
literal|1
operator|<<
name|align
operator|)
operator|-
literal|1
operator|)
operator|&
operator|(
operator|(
name|valueT
operator|)
operator|-
literal|1
operator|<<
name|align
operator|)
operator|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
name|size
return|;
block|}
end_function

begin_comment
comment|/* This is called from HANDLE_ALIGN in write.c.	 Fill in the contents    of an rs_align_code fragment.  */
end_comment

begin_function
name|void
name|arm_handle_align
parameter_list|(
name|fragS
modifier|*
name|fragP
parameter_list|)
block|{
specifier|static
name|char
specifier|const
name|arm_noop
index|[
literal|4
index|]
init|=
block|{
literal|0x00
block|,
literal|0x00
block|,
literal|0xa0
block|,
literal|0xe1
block|}
decl_stmt|;
specifier|static
name|char
specifier|const
name|thumb_noop
index|[
literal|2
index|]
init|=
block|{
literal|0xc0
block|,
literal|0x46
block|}
decl_stmt|;
specifier|static
name|char
specifier|const
name|arm_bigend_noop
index|[
literal|4
index|]
init|=
block|{
literal|0xe1
block|,
literal|0xa0
block|,
literal|0x00
block|,
literal|0x00
block|}
decl_stmt|;
specifier|static
name|char
specifier|const
name|thumb_bigend_noop
index|[
literal|2
index|]
init|=
block|{
literal|0x46
block|,
literal|0xc0
block|}
decl_stmt|;
name|int
name|bytes
decl_stmt|,
name|fix
decl_stmt|,
name|noop_size
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
specifier|const
name|char
modifier|*
name|noop
decl_stmt|;
if|if
condition|(
name|fragP
operator|->
name|fr_type
operator|!=
name|rs_align_code
condition|)
return|return;
name|bytes
operator|=
name|fragP
operator|->
name|fr_next
operator|->
name|fr_address
operator|-
name|fragP
operator|->
name|fr_address
operator|-
name|fragP
operator|->
name|fr_fix
expr_stmt|;
name|p
operator|=
name|fragP
operator|->
name|fr_literal
operator|+
name|fragP
operator|->
name|fr_fix
expr_stmt|;
name|fix
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|bytes
operator|>
name|MAX_MEM_FOR_RS_ALIGN_CODE
condition|)
name|bytes
operator|&=
name|MAX_MEM_FOR_RS_ALIGN_CODE
expr_stmt|;
if|if
condition|(
name|fragP
operator|->
name|tc_frag_data
condition|)
block|{
if|if
condition|(
name|target_big_endian
condition|)
name|noop
operator|=
name|thumb_bigend_noop
expr_stmt|;
else|else
name|noop
operator|=
name|thumb_noop
expr_stmt|;
name|noop_size
operator|=
sizeof|sizeof
argument_list|(
name|thumb_noop
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|target_big_endian
condition|)
name|noop
operator|=
name|arm_bigend_noop
expr_stmt|;
else|else
name|noop
operator|=
name|arm_noop
expr_stmt|;
name|noop_size
operator|=
sizeof|sizeof
argument_list|(
name|arm_noop
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bytes
operator|&
operator|(
name|noop_size
operator|-
literal|1
operator|)
condition|)
block|{
name|fix
operator|=
name|bytes
operator|&
operator|(
name|noop_size
operator|-
literal|1
operator|)
expr_stmt|;
name|memset
argument_list|(
name|p
argument_list|,
literal|0
argument_list|,
name|fix
argument_list|)
expr_stmt|;
name|p
operator|+=
name|fix
expr_stmt|;
name|bytes
operator|-=
name|fix
expr_stmt|;
block|}
while|while
condition|(
name|bytes
operator|>=
name|noop_size
condition|)
block|{
name|memcpy
argument_list|(
name|p
argument_list|,
name|noop
argument_list|,
name|noop_size
argument_list|)
expr_stmt|;
name|p
operator|+=
name|noop_size
expr_stmt|;
name|bytes
operator|-=
name|noop_size
expr_stmt|;
name|fix
operator|+=
name|noop_size
expr_stmt|;
block|}
name|fragP
operator|->
name|fr_fix
operator|+=
name|fix
expr_stmt|;
name|fragP
operator|->
name|fr_var
operator|=
name|noop_size
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Called from md_do_align.  Used to create an alignment    frag in a code section.  */
end_comment

begin_function
name|void
name|arm_frag_align_code
parameter_list|(
name|int
name|n
parameter_list|,
name|int
name|max
parameter_list|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
comment|/* We assume that there will never be a requirement      to support alignments greater than 32 bytes.  */
if|if
condition|(
name|max
operator|>
name|MAX_MEM_FOR_RS_ALIGN_CODE
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"alignments greater than 32 bytes not supported in .text sections."
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|=
name|frag_var
argument_list|(
name|rs_align_code
argument_list|,
name|MAX_MEM_FOR_RS_ALIGN_CODE
argument_list|,
literal|1
argument_list|,
operator|(
name|relax_substateT
operator|)
name|max
argument_list|,
operator|(
name|symbolS
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|offsetT
operator|)
name|n
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Perform target specific initialisation of a frag.  */
end_comment

begin_function
name|void
name|arm_init_frag
parameter_list|(
name|fragS
modifier|*
name|fragP
parameter_list|)
block|{
comment|/* Record whether this frag is in an ARM or a THUMB area.  */
name|fragP
operator|->
name|tc_frag_data
operator|=
name|thumb_mode
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|OBJ_ELF
end_ifdef

begin_comment
comment|/* When we change sections we need to issue a new mapping symbol.  */
end_comment

begin_function
name|void
name|arm_elf_change_section
parameter_list|(
name|void
parameter_list|)
block|{
name|flagword
name|flags
decl_stmt|;
name|segment_info_type
modifier|*
name|seginfo
decl_stmt|;
comment|/* Link an unlinked unwind index table section to the .text section.	*/
if|if
condition|(
name|elf_section_type
argument_list|(
name|now_seg
argument_list|)
operator|==
name|SHT_ARM_EXIDX
operator|&&
name|elf_linked_to_section
argument_list|(
name|now_seg
argument_list|)
operator|==
name|NULL
condition|)
name|elf_linked_to_section
argument_list|(
name|now_seg
argument_list|)
operator|=
name|text_section
expr_stmt|;
if|if
condition|(
operator|!
name|SEG_NORMAL
argument_list|(
name|now_seg
argument_list|)
condition|)
return|return;
name|flags
operator|=
name|bfd_get_section_flags
argument_list|(
name|stdoutput
argument_list|,
name|now_seg
argument_list|)
expr_stmt|;
comment|/* We can ignore sections that only contain debug info.  */
if|if
condition|(
operator|(
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|==
literal|0
condition|)
return|return;
name|seginfo
operator|=
name|seg_info
argument_list|(
name|now_seg
argument_list|)
expr_stmt|;
name|mapstate
operator|=
name|seginfo
operator|->
name|tc_segment_info_data
operator|.
name|mapstate
expr_stmt|;
name|marked_pr_dependency
operator|=
name|seginfo
operator|->
name|tc_segment_info_data
operator|.
name|marked_pr_dependency
expr_stmt|;
block|}
end_function

begin_function
name|int
name|arm_elf_section_type
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
if|if
condition|(
name|len
operator|==
literal|5
operator|&&
name|strncmp
argument_list|(
name|str
argument_list|,
literal|"exidx"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
return|return
name|SHT_ARM_EXIDX
return|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Code to deal with unwinding tables.	*/
end_comment

begin_function_decl
specifier|static
name|void
name|add_unwind_adjustsp
parameter_list|(
name|offsetT
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Cenerate and deferred unwind frame offset.  */
end_comment

begin_function
specifier|static
name|void
name|flush_pending_unwind
parameter_list|(
name|void
parameter_list|)
block|{
name|offsetT
name|offset
decl_stmt|;
name|offset
operator|=
name|unwind
operator|.
name|pending_offset
expr_stmt|;
name|unwind
operator|.
name|pending_offset
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|offset
operator|!=
literal|0
condition|)
name|add_unwind_adjustsp
argument_list|(
name|offset
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add an opcode to this list for this function.  Two-byte opcodes should    be passed as op[0]<< 8 | op[1].  The list of opcodes is built in reverse    order.  */
end_comment

begin_function
specifier|static
name|void
name|add_unwind_opcode
parameter_list|(
name|valueT
name|op
parameter_list|,
name|int
name|length
parameter_list|)
block|{
comment|/* Add any deferred stack adjustment.	 */
if|if
condition|(
name|unwind
operator|.
name|pending_offset
condition|)
name|flush_pending_unwind
argument_list|()
expr_stmt|;
name|unwind
operator|.
name|sp_restored
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|unwind
operator|.
name|opcode_count
operator|+
name|length
operator|>
name|unwind
operator|.
name|opcode_alloc
condition|)
block|{
name|unwind
operator|.
name|opcode_alloc
operator|+=
name|ARM_OPCODE_CHUNK_SIZE
expr_stmt|;
if|if
condition|(
name|unwind
operator|.
name|opcodes
condition|)
name|unwind
operator|.
name|opcodes
operator|=
name|xrealloc
argument_list|(
name|unwind
operator|.
name|opcodes
argument_list|,
name|unwind
operator|.
name|opcode_alloc
argument_list|)
expr_stmt|;
else|else
name|unwind
operator|.
name|opcodes
operator|=
name|xmalloc
argument_list|(
name|unwind
operator|.
name|opcode_alloc
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|length
operator|>
literal|0
condition|)
block|{
name|length
operator|--
expr_stmt|;
name|unwind
operator|.
name|opcodes
index|[
name|unwind
operator|.
name|opcode_count
index|]
operator|=
name|op
operator|&
literal|0xff
expr_stmt|;
name|op
operator|>>=
literal|8
expr_stmt|;
name|unwind
operator|.
name|opcode_count
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Add unwind opcodes to adjust the stack pointer.  */
end_comment

begin_function
specifier|static
name|void
name|add_unwind_adjustsp
parameter_list|(
name|offsetT
name|offset
parameter_list|)
block|{
name|valueT
name|op
decl_stmt|;
if|if
condition|(
name|offset
operator|>
literal|0x200
condition|)
block|{
comment|/* We need at most 5 bytes to hold a 32-bit value in a uleb128.  */
name|char
name|bytes
index|[
literal|5
index|]
decl_stmt|;
name|int
name|n
decl_stmt|;
name|valueT
name|o
decl_stmt|;
comment|/* Long form: 0xb2, uleb128.  */
comment|/* This might not fit in a word so add the individual bytes, 	 remembering the list is built in reverse order.  */
name|o
operator|=
call|(
name|valueT
call|)
argument_list|(
operator|(
name|offset
operator|-
literal|0x204
operator|)
operator|>>
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|o
operator|==
literal|0
condition|)
name|add_unwind_opcode
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Calculate the uleb128 encoding of the offset.	*/
name|n
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|o
condition|)
block|{
name|bytes
index|[
name|n
index|]
operator|=
name|o
operator|&
literal|0x7f
expr_stmt|;
name|o
operator|>>=
literal|7
expr_stmt|;
if|if
condition|(
name|o
condition|)
name|bytes
index|[
name|n
index|]
operator||=
literal|0x80
expr_stmt|;
name|n
operator|++
expr_stmt|;
block|}
comment|/* Add the insn.	*/
for|for
control|(
init|;
name|n
condition|;
name|n
operator|--
control|)
name|add_unwind_opcode
argument_list|(
name|bytes
index|[
name|n
operator|-
literal|1
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|add_unwind_opcode
argument_list|(
literal|0xb2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|offset
operator|>
literal|0x100
condition|)
block|{
comment|/* Two short opcodes.  */
name|add_unwind_opcode
argument_list|(
literal|0x3f
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|op
operator|=
operator|(
name|offset
operator|-
literal|0x104
operator|)
operator|>>
literal|2
expr_stmt|;
name|add_unwind_opcode
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|offset
operator|>
literal|0
condition|)
block|{
comment|/* Short opcode.	*/
name|op
operator|=
operator|(
name|offset
operator|-
literal|4
operator|)
operator|>>
literal|2
expr_stmt|;
name|add_unwind_opcode
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|offset
operator|<
literal|0
condition|)
block|{
name|offset
operator|=
operator|-
name|offset
expr_stmt|;
while|while
condition|(
name|offset
operator|>
literal|0x100
condition|)
block|{
name|add_unwind_opcode
argument_list|(
literal|0x7f
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|offset
operator|-=
literal|0x100
expr_stmt|;
block|}
name|op
operator|=
operator|(
operator|(
name|offset
operator|-
literal|4
operator|)
operator|>>
literal|2
operator|)
operator||
literal|0x40
expr_stmt|;
name|add_unwind_opcode
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Finish the list of unwind opcodes for this function.	 */
end_comment

begin_function
specifier|static
name|void
name|finish_unwind_opcodes
parameter_list|(
name|void
parameter_list|)
block|{
name|valueT
name|op
decl_stmt|;
if|if
condition|(
name|unwind
operator|.
name|fp_used
condition|)
block|{
comment|/* Adjust sp as necessary.  */
name|unwind
operator|.
name|pending_offset
operator|+=
name|unwind
operator|.
name|fp_offset
operator|-
name|unwind
operator|.
name|frame_size
expr_stmt|;
name|flush_pending_unwind
argument_list|()
expr_stmt|;
comment|/* After restoring sp from the frame pointer.  */
name|op
operator|=
literal|0x90
operator||
name|unwind
operator|.
name|fp_reg
expr_stmt|;
name|add_unwind_opcode
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|flush_pending_unwind
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Start an exception table entry.  If idx is nonzero this is an index table    entry.  */
end_comment

begin_function
specifier|static
name|void
name|start_unwind_section
parameter_list|(
specifier|const
name|segT
name|text_seg
parameter_list|,
name|int
name|idx
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|text_name
decl_stmt|;
specifier|const
name|char
modifier|*
name|prefix
decl_stmt|;
specifier|const
name|char
modifier|*
name|prefix_once
decl_stmt|;
specifier|const
name|char
modifier|*
name|group_name
decl_stmt|;
name|size_t
name|prefix_len
decl_stmt|;
name|size_t
name|text_len
decl_stmt|;
name|char
modifier|*
name|sec_name
decl_stmt|;
name|size_t
name|sec_name_len
decl_stmt|;
name|int
name|type
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|int
name|linkonce
decl_stmt|;
if|if
condition|(
name|idx
condition|)
block|{
name|prefix
operator|=
name|ELF_STRING_ARM_unwind
expr_stmt|;
name|prefix_once
operator|=
name|ELF_STRING_ARM_unwind_once
expr_stmt|;
name|type
operator|=
name|SHT_ARM_EXIDX
expr_stmt|;
block|}
else|else
block|{
name|prefix
operator|=
name|ELF_STRING_ARM_unwind_info
expr_stmt|;
name|prefix_once
operator|=
name|ELF_STRING_ARM_unwind_info_once
expr_stmt|;
name|type
operator|=
name|SHT_PROGBITS
expr_stmt|;
block|}
name|text_name
operator|=
name|segment_name
argument_list|(
name|text_seg
argument_list|)
expr_stmt|;
if|if
condition|(
name|streq
argument_list|(
name|text_name
argument_list|,
literal|".text"
argument_list|)
condition|)
name|text_name
operator|=
literal|""
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|text_name
argument_list|,
literal|".gnu.linkonce.t."
argument_list|,
name|strlen
argument_list|(
literal|".gnu.linkonce.t."
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|prefix
operator|=
name|prefix_once
expr_stmt|;
name|text_name
operator|+=
name|strlen
argument_list|(
literal|".gnu.linkonce.t."
argument_list|)
expr_stmt|;
block|}
name|prefix_len
operator|=
name|strlen
argument_list|(
name|prefix
argument_list|)
expr_stmt|;
name|text_len
operator|=
name|strlen
argument_list|(
name|text_name
argument_list|)
expr_stmt|;
name|sec_name_len
operator|=
name|prefix_len
operator|+
name|text_len
expr_stmt|;
name|sec_name
operator|=
name|xmalloc
argument_list|(
name|sec_name_len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|sec_name
argument_list|,
name|prefix
argument_list|,
name|prefix_len
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|sec_name
operator|+
name|prefix_len
argument_list|,
name|text_name
argument_list|,
name|text_len
argument_list|)
expr_stmt|;
name|sec_name
index|[
name|prefix_len
operator|+
name|text_len
index|]
operator|=
literal|'\0'
expr_stmt|;
name|flags
operator|=
name|SHF_ALLOC
expr_stmt|;
name|linkonce
operator|=
literal|0
expr_stmt|;
name|group_name
operator|=
literal|0
expr_stmt|;
comment|/* Handle COMDAT group.  */
if|if
condition|(
name|prefix
operator|!=
name|prefix_once
operator|&&
operator|(
name|text_seg
operator|->
name|flags
operator|&
name|SEC_LINK_ONCE
operator|)
operator|!=
literal|0
condition|)
block|{
name|group_name
operator|=
name|elf_group_name
argument_list|(
name|text_seg
argument_list|)
expr_stmt|;
if|if
condition|(
name|group_name
operator|==
name|NULL
condition|)
block|{
name|as_bad
argument_list|(
literal|"Group section `%s' has no group signature"
argument_list|,
name|segment_name
argument_list|(
name|text_seg
argument_list|)
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
name|flags
operator||=
name|SHF_GROUP
expr_stmt|;
name|linkonce
operator|=
literal|1
expr_stmt|;
block|}
name|obj_elf_change_section
argument_list|(
name|sec_name
argument_list|,
name|type
argument_list|,
name|flags
argument_list|,
literal|0
argument_list|,
name|group_name
argument_list|,
name|linkonce
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Set the setion link for index tables.  */
if|if
condition|(
name|idx
condition|)
name|elf_linked_to_section
argument_list|(
name|now_seg
argument_list|)
operator|=
name|text_seg
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Start an unwind table entry.	 HAVE_DATA is nonzero if we have additional    personality routine data.  Returns zero, or the index table value for    and inline entry.  */
end_comment

begin_function
specifier|static
name|valueT
name|create_unwind_entry
parameter_list|(
name|int
name|have_data
parameter_list|)
block|{
name|int
name|size
decl_stmt|;
name|addressT
name|where
decl_stmt|;
name|char
modifier|*
name|ptr
decl_stmt|;
comment|/* The current word of data.	*/
name|valueT
name|data
decl_stmt|;
comment|/* The number of bytes left in this word.  */
name|int
name|n
decl_stmt|;
name|finish_unwind_opcodes
argument_list|()
expr_stmt|;
comment|/* Remember the current text section.	 */
name|unwind
operator|.
name|saved_seg
operator|=
name|now_seg
expr_stmt|;
name|unwind
operator|.
name|saved_subseg
operator|=
name|now_subseg
expr_stmt|;
name|start_unwind_section
argument_list|(
name|now_seg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|unwind
operator|.
name|personality_routine
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|unwind
operator|.
name|personality_index
operator|==
operator|-
literal|2
condition|)
block|{
if|if
condition|(
name|have_data
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"handerdata in cantunwind frame"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
comment|/* EXIDX_CANTUNWIND.  */
block|}
comment|/* Use a default personality routine if none is specified.  */
if|if
condition|(
name|unwind
operator|.
name|personality_index
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|unwind
operator|.
name|opcode_count
operator|>
literal|3
condition|)
name|unwind
operator|.
name|personality_index
operator|=
literal|1
expr_stmt|;
else|else
name|unwind
operator|.
name|personality_index
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Space for the personality routine entry.  */
if|if
condition|(
name|unwind
operator|.
name|personality_index
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|unwind
operator|.
name|opcode_count
operator|>
literal|3
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"too many unwind opcodes for personality routine 0"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|have_data
condition|)
block|{
comment|/* All the data is inline in the index table.  */
name|data
operator|=
literal|0x80
expr_stmt|;
name|n
operator|=
literal|3
expr_stmt|;
while|while
condition|(
name|unwind
operator|.
name|opcode_count
operator|>
literal|0
condition|)
block|{
name|unwind
operator|.
name|opcode_count
operator|--
expr_stmt|;
name|data
operator|=
operator|(
name|data
operator|<<
literal|8
operator|)
operator||
name|unwind
operator|.
name|opcodes
index|[
name|unwind
operator|.
name|opcode_count
index|]
expr_stmt|;
name|n
operator|--
expr_stmt|;
block|}
comment|/* Pad with "finish" opcodes.  */
while|while
condition|(
name|n
operator|--
condition|)
name|data
operator|=
operator|(
name|data
operator|<<
literal|8
operator|)
operator||
literal|0xb0
expr_stmt|;
return|return
name|data
return|;
block|}
name|size
operator|=
literal|0
expr_stmt|;
block|}
else|else
comment|/* We get two opcodes "free" in the first word.	 */
name|size
operator|=
name|unwind
operator|.
name|opcode_count
operator|-
literal|2
expr_stmt|;
block|}
else|else
comment|/* An extra byte is required for the opcode count.	*/
name|size
operator|=
name|unwind
operator|.
name|opcode_count
operator|+
literal|1
expr_stmt|;
name|size
operator|=
operator|(
name|size
operator|+
literal|3
operator|)
operator|>>
literal|2
expr_stmt|;
if|if
condition|(
name|size
operator|>
literal|0xff
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"too many unwind opcodes"
argument_list|)
argument_list|)
expr_stmt|;
name|frag_align
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|record_alignment
argument_list|(
name|now_seg
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|unwind
operator|.
name|table_entry
operator|=
name|expr_build_dot
argument_list|()
expr_stmt|;
comment|/* Allocate the table entry.	*/
name|ptr
operator|=
name|frag_more
argument_list|(
operator|(
name|size
operator|<<
literal|2
operator|)
operator|+
literal|4
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|ptr
argument_list|,
literal|0
argument_list|,
operator|(
name|size
operator|<<
literal|2
operator|)
operator|+
literal|4
argument_list|)
expr_stmt|;
name|where
operator|=
name|frag_now_fix
argument_list|()
operator|-
operator|(
operator|(
name|size
operator|<<
literal|2
operator|)
operator|+
literal|4
operator|)
expr_stmt|;
switch|switch
condition|(
name|unwind
operator|.
name|personality_index
condition|)
block|{
case|case
operator|-
literal|1
case|:
comment|/* ??? Should this be a PLT generating relocation?  */
comment|/* Custom personality routine.  */
name|fix_new
argument_list|(
name|frag_now
argument_list|,
name|where
argument_list|,
literal|4
argument_list|,
name|unwind
operator|.
name|personality_routine
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
name|BFD_RELOC_ARM_PREL31
argument_list|)
expr_stmt|;
name|where
operator|+=
literal|4
expr_stmt|;
name|ptr
operator|+=
literal|4
expr_stmt|;
comment|/* Set the first byte to the number of additional words.	*/
name|data
operator|=
name|size
operator|-
literal|1
expr_stmt|;
name|n
operator|=
literal|3
expr_stmt|;
break|break;
comment|/* ABI defined personality routines.  */
case|case
literal|0
case|:
comment|/* Three opcodes bytes are packed into the first word.  */
name|data
operator|=
literal|0x80
expr_stmt|;
name|n
operator|=
literal|3
expr_stmt|;
break|break;
case|case
literal|1
case|:
case|case
literal|2
case|:
comment|/* The size and first two opcode bytes go in the first word.  */
name|data
operator|=
operator|(
operator|(
literal|0x80
operator|+
name|unwind
operator|.
name|personality_index
operator|)
operator|<<
literal|8
operator|)
operator||
name|size
expr_stmt|;
name|n
operator|=
literal|2
expr_stmt|;
break|break;
default|default:
comment|/* Should never happen.  */
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* Pack the opcodes into words (MSB first), reversing the list at the same      time.  */
while|while
condition|(
name|unwind
operator|.
name|opcode_count
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|n
operator|==
literal|0
condition|)
block|{
name|md_number_to_chars
argument_list|(
name|ptr
argument_list|,
name|data
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|ptr
operator|+=
literal|4
expr_stmt|;
name|n
operator|=
literal|4
expr_stmt|;
name|data
operator|=
literal|0
expr_stmt|;
block|}
name|unwind
operator|.
name|opcode_count
operator|--
expr_stmt|;
name|n
operator|--
expr_stmt|;
name|data
operator|=
operator|(
name|data
operator|<<
literal|8
operator|)
operator||
name|unwind
operator|.
name|opcodes
index|[
name|unwind
operator|.
name|opcode_count
index|]
expr_stmt|;
block|}
comment|/* Finish off the last word.	*/
if|if
condition|(
name|n
operator|<
literal|4
condition|)
block|{
comment|/* Pad with "finish" opcodes.  */
while|while
condition|(
name|n
operator|--
condition|)
name|data
operator|=
operator|(
name|data
operator|<<
literal|8
operator|)
operator||
literal|0xb0
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|ptr
argument_list|,
name|data
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|have_data
condition|)
block|{
comment|/* Add an empty descriptor if there is no user-specified data.   */
name|ptr
operator|=
name|frag_more
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|ptr
argument_list|,
literal|0
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Initialize the DWARF-2 unwind information for this procedure.  */
end_comment

begin_function
name|void
name|tc_arm_frame_initial_instructions
parameter_list|(
name|void
parameter_list|)
block|{
name|cfi_add_CFA_def_cfa
argument_list|(
name|REG_SP
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* OBJ_ELF */
end_comment

begin_comment
comment|/* Convert REGNAME to a DWARF-2 register number.  */
end_comment

begin_function
name|int
name|tc_arm_regname_to_dw2regnum
parameter_list|(
name|char
modifier|*
name|regname
parameter_list|)
block|{
name|int
name|reg
init|=
name|arm_reg_parse
argument_list|(
operator|&
name|regname
argument_list|,
name|REG_TYPE_RN
argument_list|)
decl_stmt|;
if|if
condition|(
name|reg
operator|==
name|FAIL
condition|)
return|return
operator|-
literal|1
return|;
return|return
name|reg
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|TE_PE
end_ifdef

begin_function
name|void
name|tc_pe_dwarf2_emit_offset
parameter_list|(
name|symbolS
modifier|*
name|symbol
parameter_list|,
name|unsigned
name|int
name|size
parameter_list|)
block|{
name|expressionS
name|expr
decl_stmt|;
name|expr
operator|.
name|X_op
operator|=
name|O_secrel
expr_stmt|;
name|expr
operator|.
name|X_add_symbol
operator|=
name|symbol
expr_stmt|;
name|expr
operator|.
name|X_add_number
operator|=
literal|0
expr_stmt|;
name|emit_expr
argument_list|(
operator|&
name|expr
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MD interface: Symbol and relocation handling.  */
end_comment

begin_comment
comment|/* Return the address within the segment that a PC-relative fixup is    relative to.  For ARM, PC-relative fixups applied to instructions    are generally relative to the location of the fixup plus 8 bytes.    Thumb branches are offset by 4, and Thumb loads relative to PC    require special handling.  */
end_comment

begin_function
name|long
name|md_pcrel_from_section
parameter_list|(
name|fixS
modifier|*
name|fixP
parameter_list|,
name|segT
name|seg
parameter_list|)
block|{
name|offsetT
name|base
init|=
name|fixP
operator|->
name|fx_where
operator|+
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_address
decl_stmt|;
comment|/* If this is pc-relative and we are going to emit a relocation      then we just want to put out any pipeline compensation that the linker      will need.  Otherwise we want to use the calculated base.      For WinCE we skip the bias for externals as well, since this      is how the MS ARM-CE assembler behaves and we want to be compatible.  */
if|if
condition|(
name|fixP
operator|->
name|fx_pcrel
operator|&&
operator|(
operator|(
name|fixP
operator|->
name|fx_addsy
operator|&&
name|S_GET_SEGMENT
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
operator|!=
name|seg
operator|)
operator|||
operator|(
name|arm_force_relocation
argument_list|(
name|fixP
argument_list|)
ifdef|#
directive|ifdef
name|TE_WINCE
operator|&&
operator|!
name|S_IS_EXTERNAL
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
endif|#
directive|endif
operator|)
operator|)
condition|)
name|base
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|fixP
operator|->
name|fx_r_type
condition|)
block|{
comment|/* PC relative addressing on the Thumb is slightly odd as the 	 bottom two bits of the PC are forced to zero for the 	 calculation.  This happens *after* application of the 	 pipeline offset.  However, Thumb adrl already adjusts for 	 this, so we need not do it again.  */
case|case
name|BFD_RELOC_ARM_THUMB_ADD
case|:
return|return
name|base
operator|&
operator|~
literal|3
return|;
case|case
name|BFD_RELOC_ARM_THUMB_OFFSET
case|:
case|case
name|BFD_RELOC_ARM_T32_OFFSET_IMM
case|:
case|case
name|BFD_RELOC_ARM_T32_ADD_PC12
case|:
case|case
name|BFD_RELOC_ARM_T32_CP_OFF_IMM
case|:
return|return
operator|(
name|base
operator|+
literal|4
operator|)
operator|&
operator|~
literal|3
return|;
comment|/* Thumb branches are simply offset by +4.  */
case|case
name|BFD_RELOC_THUMB_PCREL_BRANCH7
case|:
case|case
name|BFD_RELOC_THUMB_PCREL_BRANCH9
case|:
case|case
name|BFD_RELOC_THUMB_PCREL_BRANCH12
case|:
case|case
name|BFD_RELOC_THUMB_PCREL_BRANCH20
case|:
case|case
name|BFD_RELOC_THUMB_PCREL_BRANCH23
case|:
case|case
name|BFD_RELOC_THUMB_PCREL_BRANCH25
case|:
case|case
name|BFD_RELOC_THUMB_PCREL_BLX
case|:
return|return
name|base
operator|+
literal|4
return|;
comment|/* ARM mode branches are offset by +8.  However, the Windows CE 	 loader expects the relocation not to take this into account.  */
case|case
name|BFD_RELOC_ARM_PCREL_BRANCH
case|:
case|case
name|BFD_RELOC_ARM_PCREL_CALL
case|:
case|case
name|BFD_RELOC_ARM_PCREL_JUMP
case|:
case|case
name|BFD_RELOC_ARM_PCREL_BLX
case|:
case|case
name|BFD_RELOC_ARM_PLT32
case|:
ifdef|#
directive|ifdef
name|TE_WINCE
comment|/* When handling fixups immediately, because we have already           discovered the value of a symbol, or the address of the frag involved 	 we must account for the offset by +8, as the OS loader will never see the reloc.          see fixup_segment() in write.c          The S_IS_EXTERNAL test handles the case of global symbols.          Those need the calculated base, not just the pipe compensation the linker will need.  */
if|if
condition|(
name|fixP
operator|->
name|fx_pcrel
operator|&&
name|fixP
operator|->
name|fx_addsy
operator|!=
name|NULL
operator|&&
operator|(
name|S_GET_SEGMENT
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
operator|==
name|seg
operator|)
operator|&&
operator|(
name|S_IS_EXTERNAL
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
operator|||
operator|!
name|arm_force_relocation
argument_list|(
name|fixP
argument_list|)
operator|)
condition|)
return|return
name|base
operator|+
literal|8
return|;
return|return
name|base
return|;
else|#
directive|else
return|return
name|base
operator|+
literal|8
return|;
endif|#
directive|endif
comment|/* ARM mode loads relative to PC are also offset by +8.  Unlike 	 branches, the Windows CE loader *does* expect the relocation 	 to take this into account.  */
case|case
name|BFD_RELOC_ARM_OFFSET_IMM
case|:
case|case
name|BFD_RELOC_ARM_OFFSET_IMM8
case|:
case|case
name|BFD_RELOC_ARM_HWLITERAL
case|:
case|case
name|BFD_RELOC_ARM_LITERAL
case|:
case|case
name|BFD_RELOC_ARM_CP_OFF_IMM
case|:
return|return
name|base
operator|+
literal|8
return|;
comment|/* Other PC-relative relocations are un-offset.  */
default|default:
return|return
name|base
return|;
block|}
block|}
end_function

begin_comment
comment|/* Under ELF we need to default _GLOBAL_OFFSET_TABLE.    Otherwise we have no need to default values of symbols.  */
end_comment

begin_function
name|symbolS
modifier|*
name|md_undefined_symbol
parameter_list|(
name|char
modifier|*
name|name
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|OBJ_ELF
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'_'
operator|&&
name|name
index|[
literal|1
index|]
operator|==
literal|'G'
operator|&&
name|streq
argument_list|(
name|name
argument_list|,
name|GLOBAL_OFFSET_TABLE_NAME
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|GOT_symbol
condition|)
block|{
if|if
condition|(
name|symbol_find
argument_list|(
name|name
argument_list|)
condition|)
name|as_bad
argument_list|(
literal|"GOT already in the symbol table"
argument_list|)
expr_stmt|;
name|GOT_symbol
operator|=
name|symbol_new
argument_list|(
name|name
argument_list|,
name|undefined_section
argument_list|,
operator|(
name|valueT
operator|)
literal|0
argument_list|,
operator|&
name|zero_address_frag
argument_list|)
expr_stmt|;
block|}
return|return
name|GOT_symbol
return|;
block|}
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Subroutine of md_apply_fix.	 Check to see if an immediate can be    computed as two separate immediate values, added together.  We    already know that this value cannot be computed by just one ARM    instruction.	 */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|validate_immediate_twopart
parameter_list|(
name|unsigned
name|int
name|val
parameter_list|,
name|unsigned
name|int
modifier|*
name|highpart
parameter_list|)
block|{
name|unsigned
name|int
name|a
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|+=
literal|2
control|)
if|if
condition|(
operator|(
operator|(
name|a
operator|=
name|rotate_left
argument_list|(
name|val
argument_list|,
name|i
argument_list|)
operator|)
operator|&
literal|0xff
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|a
operator|&
literal|0xff00
condition|)
block|{
if|if
condition|(
name|a
operator|&
operator|~
literal|0xffff
condition|)
continue|continue;
operator|*
name|highpart
operator|=
operator|(
name|a
operator|>>
literal|8
operator|)
operator||
operator|(
operator|(
name|i
operator|+
literal|24
operator|)
operator|<<
literal|7
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|a
operator|&
literal|0xff0000
condition|)
block|{
if|if
condition|(
name|a
operator|&
literal|0xff000000
condition|)
continue|continue;
operator|*
name|highpart
operator|=
operator|(
name|a
operator|>>
literal|16
operator|)
operator||
operator|(
operator|(
name|i
operator|+
literal|16
operator|)
operator|<<
literal|7
operator|)
expr_stmt|;
block|}
else|else
block|{
name|assert
argument_list|(
name|a
operator|&
literal|0xff000000
argument_list|)
expr_stmt|;
operator|*
name|highpart
operator|=
operator|(
name|a
operator|>>
literal|24
operator|)
operator||
operator|(
operator|(
name|i
operator|+
literal|8
operator|)
operator|<<
literal|7
operator|)
expr_stmt|;
block|}
return|return
operator|(
name|a
operator|&
literal|0xff
operator|)
operator||
operator|(
name|i
operator|<<
literal|7
operator|)
return|;
block|}
return|return
name|FAIL
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|validate_offset_imm
parameter_list|(
name|unsigned
name|int
name|val
parameter_list|,
name|int
name|hwse
parameter_list|)
block|{
if|if
condition|(
operator|(
name|hwse
operator|&&
name|val
operator|>
literal|255
operator|)
operator|||
name|val
operator|>
literal|4095
condition|)
return|return
name|FAIL
return|;
return|return
name|val
return|;
block|}
end_function

begin_comment
comment|/* Subroutine of md_apply_fix.	 Do those data_ops which can take a    negative immediate constant by altering the instruction.  A bit of    a hack really. 	MOV<-> MVN 	AND<-> BIC 	ADC<-> SBC 	by inverting the second operand, and 	ADD<-> SUB 	CMP<-> CMN 	by negating the second operand.	 */
end_comment

begin_function
specifier|static
name|int
name|negate_data_op
parameter_list|(
name|unsigned
name|long
modifier|*
name|instruction
parameter_list|,
name|unsigned
name|long
name|value
parameter_list|)
block|{
name|int
name|op
decl_stmt|,
name|new_inst
decl_stmt|;
name|unsigned
name|long
name|negated
decl_stmt|,
name|inverted
decl_stmt|;
name|negated
operator|=
name|encode_arm_immediate
argument_list|(
operator|-
name|value
argument_list|)
expr_stmt|;
name|inverted
operator|=
name|encode_arm_immediate
argument_list|(
operator|~
name|value
argument_list|)
expr_stmt|;
name|op
operator|=
operator|(
operator|*
name|instruction
operator|>>
name|DATA_OP_SHIFT
operator|)
operator|&
literal|0xf
expr_stmt|;
switch|switch
condition|(
name|op
condition|)
block|{
comment|/* First negates.	 */
case|case
name|OPCODE_SUB
case|:
comment|/* ADD<-> SUB	 */
name|new_inst
operator|=
name|OPCODE_ADD
expr_stmt|;
name|value
operator|=
name|negated
expr_stmt|;
break|break;
case|case
name|OPCODE_ADD
case|:
name|new_inst
operator|=
name|OPCODE_SUB
expr_stmt|;
name|value
operator|=
name|negated
expr_stmt|;
break|break;
case|case
name|OPCODE_CMP
case|:
comment|/* CMP<-> CMN	 */
name|new_inst
operator|=
name|OPCODE_CMN
expr_stmt|;
name|value
operator|=
name|negated
expr_stmt|;
break|break;
case|case
name|OPCODE_CMN
case|:
name|new_inst
operator|=
name|OPCODE_CMP
expr_stmt|;
name|value
operator|=
name|negated
expr_stmt|;
break|break;
comment|/* Now Inverted ops.  */
case|case
name|OPCODE_MOV
case|:
comment|/* MOV<-> MVN	 */
name|new_inst
operator|=
name|OPCODE_MVN
expr_stmt|;
name|value
operator|=
name|inverted
expr_stmt|;
break|break;
case|case
name|OPCODE_MVN
case|:
name|new_inst
operator|=
name|OPCODE_MOV
expr_stmt|;
name|value
operator|=
name|inverted
expr_stmt|;
break|break;
case|case
name|OPCODE_AND
case|:
comment|/* AND<-> BIC	 */
name|new_inst
operator|=
name|OPCODE_BIC
expr_stmt|;
name|value
operator|=
name|inverted
expr_stmt|;
break|break;
case|case
name|OPCODE_BIC
case|:
name|new_inst
operator|=
name|OPCODE_AND
expr_stmt|;
name|value
operator|=
name|inverted
expr_stmt|;
break|break;
case|case
name|OPCODE_ADC
case|:
comment|/* ADC<-> SBC  */
name|new_inst
operator|=
name|OPCODE_SBC
expr_stmt|;
name|value
operator|=
name|inverted
expr_stmt|;
break|break;
case|case
name|OPCODE_SBC
case|:
name|new_inst
operator|=
name|OPCODE_ADC
expr_stmt|;
name|value
operator|=
name|inverted
expr_stmt|;
break|break;
comment|/* We cannot do anything.	 */
default|default:
return|return
name|FAIL
return|;
block|}
if|if
condition|(
name|value
operator|==
operator|(
name|unsigned
operator|)
name|FAIL
condition|)
return|return
name|FAIL
return|;
operator|*
name|instruction
operator|&=
name|OPCODE_MASK
expr_stmt|;
operator|*
name|instruction
operator||=
name|new_inst
operator|<<
name|DATA_OP_SHIFT
expr_stmt|;
return|return
name|value
return|;
block|}
end_function

begin_comment
comment|/* Like negate_data_op, but for Thumb-2.   */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|thumb32_negate_data_op
parameter_list|(
name|offsetT
modifier|*
name|instruction
parameter_list|,
name|unsigned
name|int
name|value
parameter_list|)
block|{
name|int
name|op
decl_stmt|,
name|new_inst
decl_stmt|;
name|int
name|rd
decl_stmt|;
name|unsigned
name|int
name|negated
decl_stmt|,
name|inverted
decl_stmt|;
name|negated
operator|=
name|encode_thumb32_immediate
argument_list|(
operator|-
name|value
argument_list|)
expr_stmt|;
name|inverted
operator|=
name|encode_thumb32_immediate
argument_list|(
operator|~
name|value
argument_list|)
expr_stmt|;
name|rd
operator|=
operator|(
operator|*
name|instruction
operator|>>
literal|8
operator|)
operator|&
literal|0xf
expr_stmt|;
name|op
operator|=
operator|(
operator|*
name|instruction
operator|>>
name|T2_DATA_OP_SHIFT
operator|)
operator|&
literal|0xf
expr_stmt|;
switch|switch
condition|(
name|op
condition|)
block|{
comment|/* ADD<-> SUB.  Includes CMP<-> CMN.  */
case|case
name|T2_OPCODE_SUB
case|:
name|new_inst
operator|=
name|T2_OPCODE_ADD
expr_stmt|;
name|value
operator|=
name|negated
expr_stmt|;
break|break;
case|case
name|T2_OPCODE_ADD
case|:
name|new_inst
operator|=
name|T2_OPCODE_SUB
expr_stmt|;
name|value
operator|=
name|negated
expr_stmt|;
break|break;
comment|/* ORR<-> ORN.  Includes MOV<-> MVN.  */
case|case
name|T2_OPCODE_ORR
case|:
name|new_inst
operator|=
name|T2_OPCODE_ORN
expr_stmt|;
name|value
operator|=
name|inverted
expr_stmt|;
break|break;
case|case
name|T2_OPCODE_ORN
case|:
name|new_inst
operator|=
name|T2_OPCODE_ORR
expr_stmt|;
name|value
operator|=
name|inverted
expr_stmt|;
break|break;
comment|/* AND<-> BIC.  TST has no inverted equivalent.  */
case|case
name|T2_OPCODE_AND
case|:
name|new_inst
operator|=
name|T2_OPCODE_BIC
expr_stmt|;
if|if
condition|(
name|rd
operator|==
literal|15
condition|)
name|value
operator|=
name|FAIL
expr_stmt|;
else|else
name|value
operator|=
name|inverted
expr_stmt|;
break|break;
case|case
name|T2_OPCODE_BIC
case|:
name|new_inst
operator|=
name|T2_OPCODE_AND
expr_stmt|;
name|value
operator|=
name|inverted
expr_stmt|;
break|break;
comment|/* ADC<-> SBC  */
case|case
name|T2_OPCODE_ADC
case|:
name|new_inst
operator|=
name|T2_OPCODE_SBC
expr_stmt|;
name|value
operator|=
name|inverted
expr_stmt|;
break|break;
case|case
name|T2_OPCODE_SBC
case|:
name|new_inst
operator|=
name|T2_OPCODE_ADC
expr_stmt|;
name|value
operator|=
name|inverted
expr_stmt|;
break|break;
comment|/* We cannot do anything.	 */
default|default:
return|return
name|FAIL
return|;
block|}
if|if
condition|(
name|value
operator|==
operator|(
name|unsigned
name|int
operator|)
name|FAIL
condition|)
return|return
name|FAIL
return|;
operator|*
name|instruction
operator|&=
name|T2_OPCODE_MASK
expr_stmt|;
operator|*
name|instruction
operator||=
name|new_inst
operator|<<
name|T2_DATA_OP_SHIFT
expr_stmt|;
return|return
name|value
return|;
block|}
end_function

begin_comment
comment|/* Read a 32-bit thumb instruction from buf.  */
end_comment

begin_function
specifier|static
name|unsigned
name|long
name|get_thumb32_insn
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|)
block|{
name|unsigned
name|long
name|insn
decl_stmt|;
name|insn
operator|=
name|md_chars_to_number
argument_list|(
name|buf
argument_list|,
name|THUMB_SIZE
argument_list|)
operator|<<
literal|16
expr_stmt|;
name|insn
operator||=
name|md_chars_to_number
argument_list|(
name|buf
operator|+
name|THUMB_SIZE
argument_list|,
name|THUMB_SIZE
argument_list|)
expr_stmt|;
return|return
name|insn
return|;
block|}
end_function

begin_comment
comment|/* We usually want to set the low bit on the address of thumb function    symbols.  In particular .word foo - . should have the low bit set.    Generic code tries to fold the difference of two symbols to    a constant.  Prevent this and force a relocation when the first symbols    is a thumb function.  */
end_comment

begin_function
name|int
name|arm_optimize_expr
parameter_list|(
name|expressionS
modifier|*
name|l
parameter_list|,
name|operatorT
name|op
parameter_list|,
name|expressionS
modifier|*
name|r
parameter_list|)
block|{
if|if
condition|(
name|op
operator|==
name|O_subtract
operator|&&
name|l
operator|->
name|X_op
operator|==
name|O_symbol
operator|&&
name|r
operator|->
name|X_op
operator|==
name|O_symbol
operator|&&
name|THUMB_IS_FUNC
argument_list|(
name|l
operator|->
name|X_add_symbol
argument_list|)
condition|)
block|{
name|l
operator|->
name|X_op
operator|=
name|O_subtract
expr_stmt|;
name|l
operator|->
name|X_op_symbol
operator|=
name|r
operator|->
name|X_add_symbol
expr_stmt|;
name|l
operator|->
name|X_add_number
operator|-=
name|r
operator|->
name|X_add_number
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* Process as normal.  */
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|md_apply_fix
parameter_list|(
name|fixS
modifier|*
name|fixP
parameter_list|,
name|valueT
modifier|*
name|valP
parameter_list|,
name|segT
name|seg
parameter_list|)
block|{
name|offsetT
name|value
init|=
operator|*
name|valP
decl_stmt|;
name|offsetT
name|newval
decl_stmt|;
name|unsigned
name|int
name|newimm
decl_stmt|;
name|unsigned
name|long
name|temp
decl_stmt|;
name|int
name|sign
decl_stmt|;
name|char
modifier|*
name|buf
init|=
name|fixP
operator|->
name|fx_where
operator|+
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_literal
decl_stmt|;
name|assert
argument_list|(
name|fixP
operator|->
name|fx_r_type
operator|<=
name|BFD_RELOC_UNUSED
argument_list|)
expr_stmt|;
comment|/* Note whether this will delete the relocation.  */
if|if
condition|(
name|fixP
operator|->
name|fx_addsy
operator|==
literal|0
operator|&&
operator|!
name|fixP
operator|->
name|fx_pcrel
condition|)
name|fixP
operator|->
name|fx_done
operator|=
literal|1
expr_stmt|;
comment|/* On a 64-bit host, silently truncate 'value' to 32 bits for      consistency with the behavior on 32-bit hosts.  Remember value      for emit_reloc.  */
name|value
operator|&=
literal|0xffffffff
expr_stmt|;
name|value
operator|^=
literal|0x80000000
expr_stmt|;
name|value
operator|-=
literal|0x80000000
expr_stmt|;
operator|*
name|valP
operator|=
name|value
expr_stmt|;
name|fixP
operator|->
name|fx_addnumber
operator|=
name|value
expr_stmt|;
comment|/* Same treatment for fixP->fx_offset.  */
name|fixP
operator|->
name|fx_offset
operator|&=
literal|0xffffffff
expr_stmt|;
name|fixP
operator|->
name|fx_offset
operator|^=
literal|0x80000000
expr_stmt|;
name|fixP
operator|->
name|fx_offset
operator|-=
literal|0x80000000
expr_stmt|;
switch|switch
condition|(
name|fixP
operator|->
name|fx_r_type
condition|)
block|{
case|case
name|BFD_RELOC_NONE
case|:
comment|/* This will need to go in the object file.  */
name|fixP
operator|->
name|fx_done
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_ARM_IMMEDIATE
case|:
comment|/* We claim that this fixup has been processed here, 	 even if in fact we generate an error because we do 	 not have a reloc for it, so tc_gen_reloc will reject it.  */
name|fixP
operator|->
name|fx_done
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|fixP
operator|->
name|fx_addsy
operator|&&
operator|!
name|S_IS_DEFINED
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
condition|)
block|{
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"undefined symbol %s used as an immediate value"
argument_list|)
argument_list|,
name|S_GET_NAME
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|newimm
operator|=
name|encode_arm_immediate
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|temp
operator|=
name|md_chars_to_number
argument_list|(
name|buf
argument_list|,
name|INSN_SIZE
argument_list|)
expr_stmt|;
comment|/* If the instruction will fail, see if we can fix things up by 	 changing the opcode.  */
if|if
condition|(
name|newimm
operator|==
operator|(
name|unsigned
name|int
operator|)
name|FAIL
operator|&&
operator|(
name|newimm
operator|=
name|negate_data_op
argument_list|(
operator|&
name|temp
argument_list|,
name|value
argument_list|)
operator|)
operator|==
operator|(
name|unsigned
name|int
operator|)
name|FAIL
condition|)
block|{
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"invalid constant (%lx) after fixup"
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|value
argument_list|)
expr_stmt|;
break|break;
block|}
name|newimm
operator||=
operator|(
name|temp
operator|&
literal|0xfffff000
operator|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|buf
argument_list|,
operator|(
name|valueT
operator|)
name|newimm
argument_list|,
name|INSN_SIZE
argument_list|)
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_ARM_ADRL_IMMEDIATE
case|:
block|{
name|unsigned
name|int
name|highpart
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|newinsn
init|=
literal|0xe1a00000
decl_stmt|;
comment|/* nop.  */
name|newimm
operator|=
name|encode_arm_immediate
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|temp
operator|=
name|md_chars_to_number
argument_list|(
name|buf
argument_list|,
name|INSN_SIZE
argument_list|)
expr_stmt|;
comment|/* If the instruction will fail, see if we can fix things up by 	   changing the opcode.	 */
if|if
condition|(
name|newimm
operator|==
operator|(
name|unsigned
name|int
operator|)
name|FAIL
operator|&&
operator|(
name|newimm
operator|=
name|negate_data_op
argument_list|(
operator|&
name|temp
argument_list|,
name|value
argument_list|)
operator|)
operator|==
operator|(
name|unsigned
name|int
operator|)
name|FAIL
condition|)
block|{
comment|/* No ?  OK - try using two ADD instructions to generate 	       the value.  */
name|newimm
operator|=
name|validate_immediate_twopart
argument_list|(
name|value
argument_list|,
operator|&
name|highpart
argument_list|)
expr_stmt|;
comment|/* Yes - then make sure that the second instruction is 	       also an add.  */
if|if
condition|(
name|newimm
operator|!=
operator|(
name|unsigned
name|int
operator|)
name|FAIL
condition|)
name|newinsn
operator|=
name|temp
expr_stmt|;
comment|/* Still No ?  Try using a negated value.  */
elseif|else
if|if
condition|(
operator|(
name|newimm
operator|=
name|validate_immediate_twopart
argument_list|(
operator|-
name|value
argument_list|,
operator|&
name|highpart
argument_list|)
operator|)
operator|!=
operator|(
name|unsigned
name|int
operator|)
name|FAIL
condition|)
name|temp
operator|=
name|newinsn
operator|=
operator|(
name|temp
operator|&
name|OPCODE_MASK
operator|)
operator||
name|OPCODE_SUB
operator|<<
name|DATA_OP_SHIFT
expr_stmt|;
comment|/* Otherwise - give up.  */
else|else
block|{
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"unable to compute ADRL instructions for PC offset of 0x%lx"
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|value
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Replace the first operand in the 2nd instruction (which 	       is the PC) with the destination register.  We have 	       already added in the PC in the first instruction and we 	       do not want to do it again.  */
name|newinsn
operator|&=
operator|~
literal|0xf0000
expr_stmt|;
name|newinsn
operator||=
operator|(
operator|(
name|newinsn
operator|&
literal|0x0f000
operator|)
operator|<<
literal|4
operator|)
expr_stmt|;
block|}
name|newimm
operator||=
operator|(
name|temp
operator|&
literal|0xfffff000
operator|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|buf
argument_list|,
operator|(
name|valueT
operator|)
name|newimm
argument_list|,
name|INSN_SIZE
argument_list|)
expr_stmt|;
name|highpart
operator||=
operator|(
name|newinsn
operator|&
literal|0xfffff000
operator|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|buf
operator|+
name|INSN_SIZE
argument_list|,
operator|(
name|valueT
operator|)
name|highpart
argument_list|,
name|INSN_SIZE
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|BFD_RELOC_ARM_OFFSET_IMM
case|:
if|if
condition|(
operator|!
name|fixP
operator|->
name|fx_done
operator|&&
name|seg
operator|->
name|use_rela_p
condition|)
name|value
operator|=
literal|0
expr_stmt|;
case|case
name|BFD_RELOC_ARM_LITERAL
case|:
name|sign
operator|=
name|value
operator|>=
literal|0
expr_stmt|;
if|if
condition|(
name|value
operator|<
literal|0
condition|)
name|value
operator|=
operator|-
name|value
expr_stmt|;
if|if
condition|(
name|validate_offset_imm
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
operator|==
name|FAIL
condition|)
block|{
if|if
condition|(
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_ARM_LITERAL
condition|)
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"invalid literal constant: pool needs to be closer"
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"bad immediate value for offset (%ld)"
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|value
argument_list|)
expr_stmt|;
break|break;
block|}
name|newval
operator|=
name|md_chars_to_number
argument_list|(
name|buf
argument_list|,
name|INSN_SIZE
argument_list|)
expr_stmt|;
name|newval
operator|&=
literal|0xff7ff000
expr_stmt|;
name|newval
operator||=
name|value
operator||
operator|(
name|sign
condition|?
name|INDEX_UP
else|:
literal|0
operator|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|buf
argument_list|,
name|newval
argument_list|,
name|INSN_SIZE
argument_list|)
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_ARM_OFFSET_IMM8
case|:
case|case
name|BFD_RELOC_ARM_HWLITERAL
case|:
name|sign
operator|=
name|value
operator|>=
literal|0
expr_stmt|;
if|if
condition|(
name|value
operator|<
literal|0
condition|)
name|value
operator|=
operator|-
name|value
expr_stmt|;
if|if
condition|(
name|validate_offset_imm
argument_list|(
name|value
argument_list|,
literal|1
argument_list|)
operator|==
name|FAIL
condition|)
block|{
if|if
condition|(
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_ARM_HWLITERAL
condition|)
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"invalid literal constant: pool needs to be closer"
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"bad immediate value for 8-bit offset (%ld)"
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|value
argument_list|)
expr_stmt|;
break|break;
block|}
name|newval
operator|=
name|md_chars_to_number
argument_list|(
name|buf
argument_list|,
name|INSN_SIZE
argument_list|)
expr_stmt|;
name|newval
operator|&=
literal|0xff7ff0f0
expr_stmt|;
name|newval
operator||=
operator|(
operator|(
name|value
operator|>>
literal|4
operator|)
operator|<<
literal|8
operator|)
operator||
operator|(
name|value
operator|&
literal|0xf
operator|)
operator||
operator|(
name|sign
condition|?
name|INDEX_UP
else|:
literal|0
operator|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|buf
argument_list|,
name|newval
argument_list|,
name|INSN_SIZE
argument_list|)
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_ARM_T32_OFFSET_U8
case|:
if|if
condition|(
name|value
operator|<
literal|0
operator|||
name|value
operator|>
literal|1020
operator|||
name|value
operator|%
literal|4
operator|!=
literal|0
condition|)
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"bad immediate value for offset (%ld)"
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|value
argument_list|)
expr_stmt|;
name|value
operator|/=
literal|4
expr_stmt|;
name|newval
operator|=
name|md_chars_to_number
argument_list|(
name|buf
operator|+
literal|2
argument_list|,
name|THUMB_SIZE
argument_list|)
expr_stmt|;
name|newval
operator||=
name|value
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|buf
operator|+
literal|2
argument_list|,
name|newval
argument_list|,
name|THUMB_SIZE
argument_list|)
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_ARM_T32_OFFSET_IMM
case|:
comment|/* This is a complicated relocation used for all varieties of Thumb32 	 load/store instruction with immediate offset:  	 1110 100P u1WL NNNN XXXX YYYY iiii iiii - +/-(U) pre/post(P) 8-bit, 	                                           *4, optional writeback(W) 						   (doubleword load/store)  	 1111 100S uTTL 1111 XXXX iiii iiii iiii - +/-(U) 12-bit PC-rel 	 1111 100S 0TTL NNNN XXXX 1Pu1 iiii iiii - +/-(U) pre/post(P) 8-bit 	 1111 100S 0TTL NNNN XXXX 1110 iiii iiii - positive 8-bit (T instruction) 	 1111 100S 1TTL NNNN XXXX iiii iiii iiii - positive 12-bit 	 1111 100S 0TTL NNNN XXXX 1100 iiii iiii - negative 8-bit  	 Uppercase letters indicate bits that are already encoded at 	 this point.  Lowercase letters are our problem.  For the 	 second block of instructions, the secondary opcode nybble 	 (bits 8..11) is present, and bit 23 is zero, even if this is 	 a PC-relative operation.  */
name|newval
operator|=
name|md_chars_to_number
argument_list|(
name|buf
argument_list|,
name|THUMB_SIZE
argument_list|)
expr_stmt|;
name|newval
operator|<<=
literal|16
expr_stmt|;
name|newval
operator||=
name|md_chars_to_number
argument_list|(
name|buf
operator|+
name|THUMB_SIZE
argument_list|,
name|THUMB_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|newval
operator|&
literal|0xf0000000
operator|)
operator|==
literal|0xe0000000
condition|)
block|{
comment|/* Doubleword load/store: 8-bit offset, scaled by 4.  */
if|if
condition|(
name|value
operator|>=
literal|0
condition|)
name|newval
operator||=
operator|(
literal|1
operator|<<
literal|23
operator|)
expr_stmt|;
else|else
name|value
operator|=
operator|-
name|value
expr_stmt|;
if|if
condition|(
name|value
operator|%
literal|4
operator|!=
literal|0
condition|)
block|{
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"offset not a multiple of 4"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|value
operator|/=
literal|4
expr_stmt|;
if|if
condition|(
name|value
operator|>
literal|0xff
condition|)
block|{
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"offset out of range"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|newval
operator|&=
operator|~
literal|0xff
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|newval
operator|&
literal|0x000f0000
operator|)
operator|==
literal|0x000f0000
condition|)
block|{
comment|/* PC-relative, 12-bit offset.  */
if|if
condition|(
name|value
operator|>=
literal|0
condition|)
name|newval
operator||=
operator|(
literal|1
operator|<<
literal|23
operator|)
expr_stmt|;
else|else
name|value
operator|=
operator|-
name|value
expr_stmt|;
if|if
condition|(
name|value
operator|>
literal|0xfff
condition|)
block|{
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"offset out of range"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|newval
operator|&=
operator|~
literal|0xfff
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|newval
operator|&
literal|0x00000100
operator|)
operator|==
literal|0x00000100
condition|)
block|{
comment|/* Writeback: 8-bit, +/- offset.  */
if|if
condition|(
name|value
operator|>=
literal|0
condition|)
name|newval
operator||=
operator|(
literal|1
operator|<<
literal|9
operator|)
expr_stmt|;
else|else
name|value
operator|=
operator|-
name|value
expr_stmt|;
if|if
condition|(
name|value
operator|>
literal|0xff
condition|)
block|{
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"offset out of range"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|newval
operator|&=
operator|~
literal|0xff
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|newval
operator|&
literal|0x00000f00
operator|)
operator|==
literal|0x00000e00
condition|)
block|{
comment|/* T-instruction: positive 8-bit offset.  */
if|if
condition|(
name|value
operator|<
literal|0
operator|||
name|value
operator|>
literal|0xff
condition|)
block|{
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"offset out of range"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|newval
operator|&=
operator|~
literal|0xff
expr_stmt|;
name|newval
operator||=
name|value
expr_stmt|;
block|}
else|else
block|{
comment|/* Positive 12-bit or negative 8-bit offset.  */
name|int
name|limit
decl_stmt|;
if|if
condition|(
name|value
operator|>=
literal|0
condition|)
block|{
name|newval
operator||=
operator|(
literal|1
operator|<<
literal|23
operator|)
expr_stmt|;
name|limit
operator|=
literal|0xfff
expr_stmt|;
block|}
else|else
block|{
name|value
operator|=
operator|-
name|value
expr_stmt|;
name|limit
operator|=
literal|0xff
expr_stmt|;
block|}
if|if
condition|(
name|value
operator|>
name|limit
condition|)
block|{
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"offset out of range"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|newval
operator|&=
operator|~
name|limit
expr_stmt|;
block|}
name|newval
operator||=
name|value
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|buf
argument_list|,
operator|(
name|newval
operator|>>
literal|16
operator|)
operator|&
literal|0xffff
argument_list|,
name|THUMB_SIZE
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|buf
operator|+
name|THUMB_SIZE
argument_list|,
name|newval
operator|&
literal|0xffff
argument_list|,
name|THUMB_SIZE
argument_list|)
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_ARM_SHIFT_IMM
case|:
name|newval
operator|=
name|md_chars_to_number
argument_list|(
name|buf
argument_list|,
name|INSN_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|unsigned
name|long
operator|)
name|value
operator|)
operator|>
literal|32
operator|||
operator|(
name|value
operator|==
literal|32
operator|&&
operator|(
operator|(
operator|(
name|newval
operator|&
literal|0x60
operator|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|newval
operator|&
literal|0x60
operator|)
operator|==
literal|0x60
operator|)
operator|)
condition|)
block|{
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"shift expression is too large"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|value
operator|==
literal|0
condition|)
comment|/* Shifts of zero must be done as lsl.	*/
name|newval
operator|&=
operator|~
literal|0x60
expr_stmt|;
elseif|else
if|if
condition|(
name|value
operator|==
literal|32
condition|)
name|value
operator|=
literal|0
expr_stmt|;
name|newval
operator|&=
literal|0xfffff07f
expr_stmt|;
name|newval
operator||=
operator|(
name|value
operator|&
literal|0x1f
operator|)
operator|<<
literal|7
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|buf
argument_list|,
name|newval
argument_list|,
name|INSN_SIZE
argument_list|)
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_ARM_T32_IMMEDIATE
case|:
case|case
name|BFD_RELOC_ARM_T32_ADD_IMM
case|:
case|case
name|BFD_RELOC_ARM_T32_IMM12
case|:
case|case
name|BFD_RELOC_ARM_T32_ADD_PC12
case|:
comment|/* We claim that this fixup has been processed here, 	 even if in fact we generate an error because we do 	 not have a reloc for it, so tc_gen_reloc will reject it.  */
name|fixP
operator|->
name|fx_done
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|fixP
operator|->
name|fx_addsy
operator|&&
operator|!
name|S_IS_DEFINED
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
condition|)
block|{
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"undefined symbol %s used as an immediate value"
argument_list|)
argument_list|,
name|S_GET_NAME
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|newval
operator|=
name|md_chars_to_number
argument_list|(
name|buf
argument_list|,
name|THUMB_SIZE
argument_list|)
expr_stmt|;
name|newval
operator|<<=
literal|16
expr_stmt|;
name|newval
operator||=
name|md_chars_to_number
argument_list|(
name|buf
operator|+
literal|2
argument_list|,
name|THUMB_SIZE
argument_list|)
expr_stmt|;
name|newimm
operator|=
name|FAIL
expr_stmt|;
if|if
condition|(
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_ARM_T32_IMMEDIATE
operator|||
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_ARM_T32_ADD_IMM
condition|)
block|{
name|newimm
operator|=
name|encode_thumb32_immediate
argument_list|(
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|newimm
operator|==
operator|(
name|unsigned
name|int
operator|)
name|FAIL
condition|)
name|newimm
operator|=
name|thumb32_negate_data_op
argument_list|(
operator|&
name|newval
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fixP
operator|->
name|fx_r_type
operator|!=
name|BFD_RELOC_ARM_T32_IMMEDIATE
operator|&&
name|newimm
operator|==
operator|(
name|unsigned
name|int
operator|)
name|FAIL
condition|)
block|{
comment|/* Turn add/sum into addw/subw.  */
if|if
condition|(
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_ARM_T32_ADD_IMM
condition|)
name|newval
operator|=
operator|(
name|newval
operator|&
literal|0xfeffffff
operator|)
operator||
literal|0x02000000
expr_stmt|;
comment|/* 12 bit immediate for addw/subw.  */
if|if
condition|(
name|value
operator|<
literal|0
condition|)
block|{
name|value
operator|=
operator|-
name|value
expr_stmt|;
name|newval
operator|^=
literal|0x00a00000
expr_stmt|;
block|}
if|if
condition|(
name|value
operator|>
literal|0xfff
condition|)
name|newimm
operator|=
operator|(
name|unsigned
name|int
operator|)
name|FAIL
expr_stmt|;
else|else
name|newimm
operator|=
name|value
expr_stmt|;
block|}
if|if
condition|(
name|newimm
operator|==
operator|(
name|unsigned
name|int
operator|)
name|FAIL
condition|)
block|{
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"invalid constant (%lx) after fixup"
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|value
argument_list|)
expr_stmt|;
break|break;
block|}
name|newval
operator||=
operator|(
name|newimm
operator|&
literal|0x800
operator|)
operator|<<
literal|15
expr_stmt|;
name|newval
operator||=
operator|(
name|newimm
operator|&
literal|0x700
operator|)
operator|<<
literal|4
expr_stmt|;
name|newval
operator||=
operator|(
name|newimm
operator|&
literal|0x0ff
operator|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|buf
argument_list|,
call|(
name|valueT
call|)
argument_list|(
operator|(
name|newval
operator|>>
literal|16
operator|)
operator|&
literal|0xffff
argument_list|)
argument_list|,
name|THUMB_SIZE
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|buf
operator|+
literal|2
argument_list|,
call|(
name|valueT
call|)
argument_list|(
name|newval
operator|&
literal|0xffff
argument_list|)
argument_list|,
name|THUMB_SIZE
argument_list|)
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_ARM_SMC
case|:
if|if
condition|(
operator|(
operator|(
name|unsigned
name|long
operator|)
name|value
operator|)
operator|>
literal|0xffff
condition|)
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"invalid smc expression"
argument_list|)
argument_list|)
expr_stmt|;
name|newval
operator|=
name|md_chars_to_number
argument_list|(
name|buf
argument_list|,
name|INSN_SIZE
argument_list|)
expr_stmt|;
name|newval
operator||=
operator|(
name|value
operator|&
literal|0xf
operator|)
operator||
operator|(
operator|(
name|value
operator|&
literal|0xfff0
operator|)
operator|<<
literal|4
operator|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|buf
argument_list|,
name|newval
argument_list|,
name|INSN_SIZE
argument_list|)
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_ARM_SWI
case|:
if|if
condition|(
name|fixP
operator|->
name|tc_fix_data
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|unsigned
name|long
operator|)
name|value
operator|)
operator|>
literal|0xff
condition|)
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"invalid swi expression"
argument_list|)
argument_list|)
expr_stmt|;
name|newval
operator|=
name|md_chars_to_number
argument_list|(
name|buf
argument_list|,
name|THUMB_SIZE
argument_list|)
expr_stmt|;
name|newval
operator||=
name|value
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|buf
argument_list|,
name|newval
argument_list|,
name|THUMB_SIZE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
operator|(
name|unsigned
name|long
operator|)
name|value
operator|)
operator|>
literal|0x00ffffff
condition|)
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"invalid swi expression"
argument_list|)
argument_list|)
expr_stmt|;
name|newval
operator|=
name|md_chars_to_number
argument_list|(
name|buf
argument_list|,
name|INSN_SIZE
argument_list|)
expr_stmt|;
name|newval
operator||=
name|value
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|buf
argument_list|,
name|newval
argument_list|,
name|INSN_SIZE
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|BFD_RELOC_ARM_MULTI
case|:
if|if
condition|(
operator|(
operator|(
name|unsigned
name|long
operator|)
name|value
operator|)
operator|>
literal|0xffff
condition|)
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"invalid expression in load/store multiple"
argument_list|)
argument_list|)
expr_stmt|;
name|newval
operator|=
name|value
operator||
name|md_chars_to_number
argument_list|(
name|buf
argument_list|,
name|INSN_SIZE
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|buf
argument_list|,
name|newval
argument_list|,
name|INSN_SIZE
argument_list|)
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|OBJ_ELF
case|case
name|BFD_RELOC_ARM_PCREL_CALL
case|:
name|newval
operator|=
name|md_chars_to_number
argument_list|(
name|buf
argument_list|,
name|INSN_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|newval
operator|&
literal|0xf0000000
operator|)
operator|==
literal|0xf0000000
condition|)
name|temp
operator|=
literal|1
expr_stmt|;
else|else
name|temp
operator|=
literal|3
expr_stmt|;
goto|goto
name|arm_branch_common
goto|;
case|case
name|BFD_RELOC_ARM_PCREL_JUMP
case|:
case|case
name|BFD_RELOC_ARM_PLT32
case|:
endif|#
directive|endif
case|case
name|BFD_RELOC_ARM_PCREL_BRANCH
case|:
name|temp
operator|=
literal|3
expr_stmt|;
goto|goto
name|arm_branch_common
goto|;
case|case
name|BFD_RELOC_ARM_PCREL_BLX
case|:
name|temp
operator|=
literal|1
expr_stmt|;
name|arm_branch_common
label|:
comment|/* We are going to store value (shifted right by two) in the 	 instruction, in a 24 bit, signed field.  Bits 26 through 32 either 	 all clear or all set and bit 0 must be clear.  For B/BL bit 1 must 	 also be be clear.  */
if|if
condition|(
name|value
operator|&
name|temp
condition|)
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"misaligned branch destination"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|value
operator|&
operator|(
name|offsetT
operator|)
literal|0xfe000000
operator|)
operator|!=
operator|(
name|offsetT
operator|)
literal|0
operator|&&
operator|(
name|value
operator|&
operator|(
name|offsetT
operator|)
literal|0xfe000000
operator|)
operator|!=
operator|(
name|offsetT
operator|)
literal|0xfe000000
condition|)
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"branch out of range"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fixP
operator|->
name|fx_done
operator|||
operator|!
name|seg
operator|->
name|use_rela_p
condition|)
block|{
name|newval
operator|=
name|md_chars_to_number
argument_list|(
name|buf
argument_list|,
name|INSN_SIZE
argument_list|)
expr_stmt|;
name|newval
operator||=
operator|(
name|value
operator|>>
literal|2
operator|)
operator|&
literal|0x00ffffff
expr_stmt|;
comment|/* Set the H bit on BLX instructions.  */
if|if
condition|(
name|temp
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|value
operator|&
literal|2
condition|)
name|newval
operator||=
literal|0x01000000
expr_stmt|;
else|else
name|newval
operator|&=
operator|~
literal|0x01000000
expr_stmt|;
block|}
name|md_number_to_chars
argument_list|(
name|buf
argument_list|,
name|newval
argument_list|,
name|INSN_SIZE
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|BFD_RELOC_THUMB_PCREL_BRANCH7
case|:
comment|/* CBZ */
comment|/* CBZ can only branch forward.  */
comment|/* Attempts to use CBZ to branch to the next instruction          (which, strictly speaking, are prohibited) will be turned into          no-ops.  	 FIXME: It may be better to remove the instruction completely and 	 perform relaxation.  */
if|if
condition|(
name|value
operator|==
operator|-
literal|2
condition|)
block|{
name|newval
operator|=
name|md_chars_to_number
argument_list|(
name|buf
argument_list|,
name|THUMB_SIZE
argument_list|)
expr_stmt|;
name|newval
operator|=
literal|0xbf00
expr_stmt|;
comment|/* NOP encoding T1 */
name|md_number_to_chars
argument_list|(
name|buf
argument_list|,
name|newval
argument_list|,
name|THUMB_SIZE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|value
operator|&
operator|~
literal|0x7e
condition|)
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"branch out of range"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fixP
operator|->
name|fx_done
operator|||
operator|!
name|seg
operator|->
name|use_rela_p
condition|)
block|{
name|newval
operator|=
name|md_chars_to_number
argument_list|(
name|buf
argument_list|,
name|THUMB_SIZE
argument_list|)
expr_stmt|;
name|newval
operator||=
operator|(
operator|(
name|value
operator|&
literal|0x3e
operator|)
operator|<<
literal|2
operator|)
operator||
operator|(
operator|(
name|value
operator|&
literal|0x40
operator|)
operator|<<
literal|3
operator|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|buf
argument_list|,
name|newval
argument_list|,
name|THUMB_SIZE
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|BFD_RELOC_THUMB_PCREL_BRANCH9
case|:
comment|/* Conditional branch.	*/
if|if
condition|(
operator|(
name|value
operator|&
operator|~
literal|0xff
operator|)
operator|&&
operator|(
operator|(
name|value
operator|&
operator|~
literal|0xff
operator|)
operator|!=
operator|~
literal|0xff
operator|)
condition|)
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"branch out of range"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fixP
operator|->
name|fx_done
operator|||
operator|!
name|seg
operator|->
name|use_rela_p
condition|)
block|{
name|newval
operator|=
name|md_chars_to_number
argument_list|(
name|buf
argument_list|,
name|THUMB_SIZE
argument_list|)
expr_stmt|;
name|newval
operator||=
operator|(
name|value
operator|&
literal|0x1ff
operator|)
operator|>>
literal|1
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|buf
argument_list|,
name|newval
argument_list|,
name|THUMB_SIZE
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|BFD_RELOC_THUMB_PCREL_BRANCH12
case|:
comment|/* Unconditional branch.  */
if|if
condition|(
operator|(
name|value
operator|&
operator|~
literal|0x7ff
operator|)
operator|&&
operator|(
operator|(
name|value
operator|&
operator|~
literal|0x7ff
operator|)
operator|!=
operator|~
literal|0x7ff
operator|)
condition|)
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"branch out of range"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fixP
operator|->
name|fx_done
operator|||
operator|!
name|seg
operator|->
name|use_rela_p
condition|)
block|{
name|newval
operator|=
name|md_chars_to_number
argument_list|(
name|buf
argument_list|,
name|THUMB_SIZE
argument_list|)
expr_stmt|;
name|newval
operator||=
operator|(
name|value
operator|&
literal|0xfff
operator|)
operator|>>
literal|1
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|buf
argument_list|,
name|newval
argument_list|,
name|THUMB_SIZE
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|BFD_RELOC_THUMB_PCREL_BRANCH20
case|:
if|if
condition|(
operator|(
name|value
operator|&
operator|~
literal|0x1fffff
operator|)
operator|&&
operator|(
operator|(
name|value
operator|&
operator|~
literal|0x1fffff
operator|)
operator|!=
operator|~
literal|0x1fffff
operator|)
condition|)
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"conditional branch out of range"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fixP
operator|->
name|fx_done
operator|||
operator|!
name|seg
operator|->
name|use_rela_p
condition|)
block|{
name|offsetT
name|newval2
decl_stmt|;
name|addressT
name|S
decl_stmt|,
name|J1
decl_stmt|,
name|J2
decl_stmt|,
name|lo
decl_stmt|,
name|hi
decl_stmt|;
name|S
operator|=
operator|(
name|value
operator|&
literal|0x00100000
operator|)
operator|>>
literal|20
expr_stmt|;
name|J2
operator|=
operator|(
name|value
operator|&
literal|0x00080000
operator|)
operator|>>
literal|19
expr_stmt|;
name|J1
operator|=
operator|(
name|value
operator|&
literal|0x00040000
operator|)
operator|>>
literal|18
expr_stmt|;
name|hi
operator|=
operator|(
name|value
operator|&
literal|0x0003f000
operator|)
operator|>>
literal|12
expr_stmt|;
name|lo
operator|=
operator|(
name|value
operator|&
literal|0x00000ffe
operator|)
operator|>>
literal|1
expr_stmt|;
name|newval
operator|=
name|md_chars_to_number
argument_list|(
name|buf
argument_list|,
name|THUMB_SIZE
argument_list|)
expr_stmt|;
name|newval2
operator|=
name|md_chars_to_number
argument_list|(
name|buf
operator|+
name|THUMB_SIZE
argument_list|,
name|THUMB_SIZE
argument_list|)
expr_stmt|;
name|newval
operator||=
operator|(
name|S
operator|<<
literal|10
operator|)
operator||
name|hi
expr_stmt|;
name|newval2
operator||=
operator|(
name|J1
operator|<<
literal|13
operator|)
operator||
operator|(
name|J2
operator|<<
literal|11
operator|)
operator||
name|lo
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|buf
argument_list|,
name|newval
argument_list|,
name|THUMB_SIZE
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|buf
operator|+
name|THUMB_SIZE
argument_list|,
name|newval2
argument_list|,
name|THUMB_SIZE
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|BFD_RELOC_THUMB_PCREL_BLX
case|:
case|case
name|BFD_RELOC_THUMB_PCREL_BRANCH23
case|:
if|if
condition|(
operator|(
name|value
operator|&
operator|~
literal|0x3fffff
operator|)
operator|&&
operator|(
operator|(
name|value
operator|&
operator|~
literal|0x3fffff
operator|)
operator|!=
operator|~
literal|0x3fffff
operator|)
condition|)
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"branch out of range"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_THUMB_PCREL_BLX
condition|)
comment|/* For a BLX instruction, make sure that the relocation is rounded up 	   to a word boundary.  This follows the semantics of the instruction 	   which specifies that bit 1 of the target address will come from bit 	   1 of the base address.  */
name|value
operator|=
operator|(
name|value
operator|+
literal|1
operator|)
operator|&
operator|~
literal|1
expr_stmt|;
if|if
condition|(
name|fixP
operator|->
name|fx_done
operator|||
operator|!
name|seg
operator|->
name|use_rela_p
condition|)
block|{
name|offsetT
name|newval2
decl_stmt|;
name|newval
operator|=
name|md_chars_to_number
argument_list|(
name|buf
argument_list|,
name|THUMB_SIZE
argument_list|)
expr_stmt|;
name|newval2
operator|=
name|md_chars_to_number
argument_list|(
name|buf
operator|+
name|THUMB_SIZE
argument_list|,
name|THUMB_SIZE
argument_list|)
expr_stmt|;
name|newval
operator||=
operator|(
name|value
operator|&
literal|0x7fffff
operator|)
operator|>>
literal|12
expr_stmt|;
name|newval2
operator||=
operator|(
name|value
operator|&
literal|0xfff
operator|)
operator|>>
literal|1
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|buf
argument_list|,
name|newval
argument_list|,
name|THUMB_SIZE
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|buf
operator|+
name|THUMB_SIZE
argument_list|,
name|newval2
argument_list|,
name|THUMB_SIZE
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|BFD_RELOC_THUMB_PCREL_BRANCH25
case|:
if|if
condition|(
operator|(
name|value
operator|&
operator|~
literal|0x1ffffff
operator|)
operator|&&
operator|(
operator|(
name|value
operator|&
operator|~
literal|0x1ffffff
operator|)
operator|!=
operator|~
literal|0x1ffffff
operator|)
condition|)
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"branch out of range"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fixP
operator|->
name|fx_done
operator|||
operator|!
name|seg
operator|->
name|use_rela_p
condition|)
block|{
name|offsetT
name|newval2
decl_stmt|;
name|addressT
name|S
decl_stmt|,
name|I1
decl_stmt|,
name|I2
decl_stmt|,
name|lo
decl_stmt|,
name|hi
decl_stmt|;
name|S
operator|=
operator|(
name|value
operator|&
literal|0x01000000
operator|)
operator|>>
literal|24
expr_stmt|;
name|I1
operator|=
operator|(
name|value
operator|&
literal|0x00800000
operator|)
operator|>>
literal|23
expr_stmt|;
name|I2
operator|=
operator|(
name|value
operator|&
literal|0x00400000
operator|)
operator|>>
literal|22
expr_stmt|;
name|hi
operator|=
operator|(
name|value
operator|&
literal|0x003ff000
operator|)
operator|>>
literal|12
expr_stmt|;
name|lo
operator|=
operator|(
name|value
operator|&
literal|0x00000ffe
operator|)
operator|>>
literal|1
expr_stmt|;
name|I1
operator|=
operator|!
operator|(
name|I1
operator|^
name|S
operator|)
expr_stmt|;
name|I2
operator|=
operator|!
operator|(
name|I2
operator|^
name|S
operator|)
expr_stmt|;
name|newval
operator|=
name|md_chars_to_number
argument_list|(
name|buf
argument_list|,
name|THUMB_SIZE
argument_list|)
expr_stmt|;
name|newval2
operator|=
name|md_chars_to_number
argument_list|(
name|buf
operator|+
name|THUMB_SIZE
argument_list|,
name|THUMB_SIZE
argument_list|)
expr_stmt|;
name|newval
operator||=
operator|(
name|S
operator|<<
literal|10
operator|)
operator||
name|hi
expr_stmt|;
name|newval2
operator||=
operator|(
name|I1
operator|<<
literal|13
operator|)
operator||
operator|(
name|I2
operator|<<
literal|11
operator|)
operator||
name|lo
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|buf
argument_list|,
name|newval
argument_list|,
name|THUMB_SIZE
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|buf
operator|+
name|THUMB_SIZE
argument_list|,
name|newval2
argument_list|,
name|THUMB_SIZE
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|BFD_RELOC_8
case|:
if|if
condition|(
name|fixP
operator|->
name|fx_done
operator|||
operator|!
name|seg
operator|->
name|use_rela_p
condition|)
name|md_number_to_chars
argument_list|(
name|buf
argument_list|,
name|value
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_16
case|:
if|if
condition|(
name|fixP
operator|->
name|fx_done
operator|||
operator|!
name|seg
operator|->
name|use_rela_p
condition|)
name|md_number_to_chars
argument_list|(
name|buf
argument_list|,
name|value
argument_list|,
literal|2
argument_list|)
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|OBJ_ELF
case|case
name|BFD_RELOC_ARM_TLS_GD32
case|:
case|case
name|BFD_RELOC_ARM_TLS_LE32
case|:
case|case
name|BFD_RELOC_ARM_TLS_IE32
case|:
case|case
name|BFD_RELOC_ARM_TLS_LDM32
case|:
case|case
name|BFD_RELOC_ARM_TLS_LDO32
case|:
name|S_SET_THREAD_LOCAL
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
expr_stmt|;
comment|/* fall through */
case|case
name|BFD_RELOC_ARM_GOT32
case|:
case|case
name|BFD_RELOC_ARM_GOTOFF
case|:
case|case
name|BFD_RELOC_ARM_TARGET2
case|:
if|if
condition|(
name|fixP
operator|->
name|fx_done
operator|||
operator|!
name|seg
operator|->
name|use_rela_p
condition|)
name|md_number_to_chars
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|,
literal|4
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|BFD_RELOC_RVA
case|:
case|case
name|BFD_RELOC_32
case|:
case|case
name|BFD_RELOC_ARM_TARGET1
case|:
case|case
name|BFD_RELOC_ARM_ROSEGREL32
case|:
case|case
name|BFD_RELOC_ARM_SBREL32
case|:
case|case
name|BFD_RELOC_32_PCREL
case|:
ifdef|#
directive|ifdef
name|TE_PE
case|case
name|BFD_RELOC_32_SECREL
case|:
endif|#
directive|endif
if|if
condition|(
name|fixP
operator|->
name|fx_done
operator|||
operator|!
name|seg
operator|->
name|use_rela_p
condition|)
ifdef|#
directive|ifdef
name|TE_WINCE
comment|/* For WinCE we only do this for pcrel fixups.  */
if|if
condition|(
name|fixP
operator|->
name|fx_done
operator|||
name|fixP
operator|->
name|fx_pcrel
condition|)
endif|#
directive|endif
name|md_number_to_chars
argument_list|(
name|buf
argument_list|,
name|value
argument_list|,
literal|4
argument_list|)
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|OBJ_ELF
case|case
name|BFD_RELOC_ARM_PREL31
case|:
if|if
condition|(
name|fixP
operator|->
name|fx_done
operator|||
operator|!
name|seg
operator|->
name|use_rela_p
condition|)
block|{
name|newval
operator|=
name|md_chars_to_number
argument_list|(
name|buf
argument_list|,
literal|4
argument_list|)
operator|&
literal|0x80000000
expr_stmt|;
if|if
condition|(
operator|(
name|value
operator|^
operator|(
name|value
operator|>>
literal|1
operator|)
operator|)
operator|&
literal|0x40000000
condition|)
block|{
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"rel31 relocation overflow"
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|newval
operator||=
name|value
operator|&
literal|0x7fffffff
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|buf
argument_list|,
name|newval
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
break|break;
endif|#
directive|endif
case|case
name|BFD_RELOC_ARM_CP_OFF_IMM
case|:
case|case
name|BFD_RELOC_ARM_T32_CP_OFF_IMM
case|:
if|if
condition|(
name|value
operator|<
operator|-
literal|1023
operator|||
name|value
operator|>
literal|1023
operator|||
operator|(
name|value
operator|&
literal|3
operator|)
condition|)
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"co-processor offset out of range"
argument_list|)
argument_list|)
expr_stmt|;
name|cp_off_common
label|:
name|sign
operator|=
name|value
operator|>=
literal|0
expr_stmt|;
if|if
condition|(
name|value
operator|<
literal|0
condition|)
name|value
operator|=
operator|-
name|value
expr_stmt|;
if|if
condition|(
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_ARM_CP_OFF_IMM
operator|||
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_ARM_CP_OFF_IMM_S2
condition|)
name|newval
operator|=
name|md_chars_to_number
argument_list|(
name|buf
argument_list|,
name|INSN_SIZE
argument_list|)
expr_stmt|;
else|else
name|newval
operator|=
name|get_thumb32_insn
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|newval
operator|&=
literal|0xff7fff00
expr_stmt|;
name|newval
operator||=
operator|(
name|value
operator|>>
literal|2
operator|)
operator||
operator|(
name|sign
condition|?
name|INDEX_UP
else|:
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_ARM_CP_OFF_IMM
operator|||
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_ARM_CP_OFF_IMM_S2
condition|)
name|md_number_to_chars
argument_list|(
name|buf
argument_list|,
name|newval
argument_list|,
name|INSN_SIZE
argument_list|)
expr_stmt|;
else|else
name|put_thumb32_insn
argument_list|(
name|buf
argument_list|,
name|newval
argument_list|)
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_ARM_CP_OFF_IMM_S2
case|:
case|case
name|BFD_RELOC_ARM_T32_CP_OFF_IMM_S2
case|:
if|if
condition|(
name|value
operator|<
operator|-
literal|255
operator|||
name|value
operator|>
literal|255
condition|)
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"co-processor offset out of range"
argument_list|)
argument_list|)
expr_stmt|;
name|value
operator|*=
literal|4
expr_stmt|;
goto|goto
name|cp_off_common
goto|;
case|case
name|BFD_RELOC_ARM_THUMB_OFFSET
case|:
name|newval
operator|=
name|md_chars_to_number
argument_list|(
name|buf
argument_list|,
name|THUMB_SIZE
argument_list|)
expr_stmt|;
comment|/* Exactly what ranges, and where the offset is inserted depends 	 on the type of instruction, we can establish this from the 	 top 4 bits.  */
switch|switch
condition|(
name|newval
operator|>>
literal|12
condition|)
block|{
case|case
literal|4
case|:
comment|/* PC load.  */
comment|/* Thumb PC loads are somewhat odd, bit 1 of the PC is 	     forced to zero for these loads; md_pcrel_from has already 	     compensated for this.  */
if|if
condition|(
name|value
operator|&
literal|3
condition|)
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"invalid offset, target not word aligned (0x%08lX)"
argument_list|)
argument_list|,
operator|(
operator|(
operator|(
name|unsigned
name|long
operator|)
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_address
operator|+
operator|(
name|unsigned
name|long
operator|)
name|fixP
operator|->
name|fx_where
operator|)
operator|&
operator|~
literal|3
operator|)
operator|+
operator|(
name|unsigned
name|long
operator|)
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|&
operator|~
literal|0x3fc
condition|)
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"invalid offset, value too big (0x%08lX)"
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|value
argument_list|)
expr_stmt|;
name|newval
operator||=
name|value
operator|>>
literal|2
expr_stmt|;
break|break;
case|case
literal|9
case|:
comment|/* SP load/store.  */
if|if
condition|(
name|value
operator|&
operator|~
literal|0x3fc
condition|)
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"invalid offset, value too big (0x%08lX)"
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|value
argument_list|)
expr_stmt|;
name|newval
operator||=
name|value
operator|>>
literal|2
expr_stmt|;
break|break;
case|case
literal|6
case|:
comment|/* Word load/store.  */
if|if
condition|(
name|value
operator|&
operator|~
literal|0x7c
condition|)
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"invalid offset, value too big (0x%08lX)"
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|value
argument_list|)
expr_stmt|;
name|newval
operator||=
name|value
operator|<<
literal|4
expr_stmt|;
comment|/* 6 - 2.  */
break|break;
case|case
literal|7
case|:
comment|/* Byte load/store.  */
if|if
condition|(
name|value
operator|&
operator|~
literal|0x1f
condition|)
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"invalid offset, value too big (0x%08lX)"
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|value
argument_list|)
expr_stmt|;
name|newval
operator||=
name|value
operator|<<
literal|6
expr_stmt|;
break|break;
case|case
literal|8
case|:
comment|/* Halfword load/store.	 */
if|if
condition|(
name|value
operator|&
operator|~
literal|0x3e
condition|)
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"invalid offset, value too big (0x%08lX)"
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|value
argument_list|)
expr_stmt|;
name|newval
operator||=
name|value
operator|<<
literal|5
expr_stmt|;
comment|/* 6 - 1.  */
break|break;
default|default:
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
literal|"Unable to process relocation for thumb opcode: %lx"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|newval
argument_list|)
expr_stmt|;
break|break;
block|}
name|md_number_to_chars
argument_list|(
name|buf
argument_list|,
name|newval
argument_list|,
name|THUMB_SIZE
argument_list|)
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_ARM_THUMB_ADD
case|:
comment|/* This is a complicated relocation, since we use it for all of 	 the following immediate relocations:  	    3bit ADD/SUB 	    8bit ADD/SUB 	    9bit ADD/SUB SP word-aligned 	   10bit ADD PC/SP word-aligned  	 The type of instruction being processed is encoded in the 	 instruction field:  	   0x8000  SUB 	   0x00F0  Rd 	   0x000F  Rs       */
name|newval
operator|=
name|md_chars_to_number
argument_list|(
name|buf
argument_list|,
name|THUMB_SIZE
argument_list|)
expr_stmt|;
block|{
name|int
name|rd
init|=
operator|(
name|newval
operator|>>
literal|4
operator|)
operator|&
literal|0xf
decl_stmt|;
name|int
name|rs
init|=
name|newval
operator|&
literal|0xf
decl_stmt|;
name|int
name|subtract
init|=
operator|!
operator|!
operator|(
name|newval
operator|&
literal|0x8000
operator|)
decl_stmt|;
comment|/* Check for HI regs, only very restricted cases allowed: 	   Adjusting SP, and using PC or SP to get an address.	*/
if|if
condition|(
operator|(
name|rd
operator|>
literal|7
operator|&&
operator|(
name|rd
operator|!=
name|REG_SP
operator|||
name|rs
operator|!=
name|REG_SP
operator|)
operator|)
operator|||
operator|(
name|rs
operator|>
literal|7
operator|&&
name|rs
operator|!=
name|REG_SP
operator|&&
name|rs
operator|!=
name|REG_PC
operator|)
condition|)
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"invalid Hi register with immediate"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If value is negative, choose the opposite instruction.  */
if|if
condition|(
name|value
operator|<
literal|0
condition|)
block|{
name|value
operator|=
operator|-
name|value
expr_stmt|;
name|subtract
operator|=
operator|!
name|subtract
expr_stmt|;
if|if
condition|(
name|value
operator|<
literal|0
condition|)
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"immediate value out of range"
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rd
operator|==
name|REG_SP
condition|)
block|{
if|if
condition|(
name|value
operator|&
operator|~
literal|0x1fc
condition|)
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"invalid immediate for stack address calculation"
argument_list|)
argument_list|)
expr_stmt|;
name|newval
operator|=
name|subtract
condition|?
name|T_OPCODE_SUB_ST
else|:
name|T_OPCODE_ADD_ST
expr_stmt|;
name|newval
operator||=
name|value
operator|>>
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rs
operator|==
name|REG_PC
operator|||
name|rs
operator|==
name|REG_SP
condition|)
block|{
if|if
condition|(
name|subtract
operator|||
name|value
operator|&
operator|~
literal|0x3fc
condition|)
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"invalid immediate for address calculation (value = 0x%08lX)"
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|value
argument_list|)
expr_stmt|;
name|newval
operator|=
operator|(
name|rs
operator|==
name|REG_PC
condition|?
name|T_OPCODE_ADD_PC
else|:
name|T_OPCODE_ADD_SP
operator|)
expr_stmt|;
name|newval
operator||=
name|rd
operator|<<
literal|8
expr_stmt|;
name|newval
operator||=
name|value
operator|>>
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rs
operator|==
name|rd
condition|)
block|{
if|if
condition|(
name|value
operator|&
operator|~
literal|0xff
condition|)
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"immediate value out of range"
argument_list|)
argument_list|)
expr_stmt|;
name|newval
operator|=
name|subtract
condition|?
name|T_OPCODE_SUB_I8
else|:
name|T_OPCODE_ADD_I8
expr_stmt|;
name|newval
operator||=
operator|(
name|rd
operator|<<
literal|8
operator|)
operator||
name|value
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|value
operator|&
operator|~
literal|0x7
condition|)
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"immediate value out of range"
argument_list|)
argument_list|)
expr_stmt|;
name|newval
operator|=
name|subtract
condition|?
name|T_OPCODE_SUB_I3
else|:
name|T_OPCODE_ADD_I3
expr_stmt|;
name|newval
operator||=
name|rd
operator||
operator|(
name|rs
operator|<<
literal|3
operator|)
operator||
operator|(
name|value
operator|<<
literal|6
operator|)
expr_stmt|;
block|}
block|}
name|md_number_to_chars
argument_list|(
name|buf
argument_list|,
name|newval
argument_list|,
name|THUMB_SIZE
argument_list|)
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_ARM_THUMB_IMM
case|:
name|newval
operator|=
name|md_chars_to_number
argument_list|(
name|buf
argument_list|,
name|THUMB_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|<
literal|0
operator|||
name|value
operator|>
literal|255
condition|)
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"invalid immediate: %ld is too large"
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|value
argument_list|)
expr_stmt|;
name|newval
operator||=
name|value
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|buf
argument_list|,
name|newval
argument_list|,
name|THUMB_SIZE
argument_list|)
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_ARM_THUMB_SHIFT
case|:
comment|/* 5bit shift value (0..32).  LSL cannot take 32.	 */
name|newval
operator|=
name|md_chars_to_number
argument_list|(
name|buf
argument_list|,
name|THUMB_SIZE
argument_list|)
operator|&
literal|0xf83f
expr_stmt|;
name|temp
operator|=
name|newval
operator|&
literal|0xf800
expr_stmt|;
if|if
condition|(
name|value
operator|<
literal|0
operator|||
name|value
operator|>
literal|32
operator|||
operator|(
name|value
operator|==
literal|32
operator|&&
name|temp
operator|==
name|T_OPCODE_LSL_I
operator|)
condition|)
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"invalid shift value: %ld"
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|value
argument_list|)
expr_stmt|;
comment|/* Shifts of zero must be encoded as LSL.	 */
if|if
condition|(
name|value
operator|==
literal|0
condition|)
name|newval
operator|=
operator|(
name|newval
operator|&
literal|0x003f
operator|)
operator||
name|T_OPCODE_LSL_I
expr_stmt|;
comment|/* Shifts of 32 are encoded as zero.  */
elseif|else
if|if
condition|(
name|value
operator|==
literal|32
condition|)
name|value
operator|=
literal|0
expr_stmt|;
name|newval
operator||=
name|value
operator|<<
literal|6
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|buf
argument_list|,
name|newval
argument_list|,
name|THUMB_SIZE
argument_list|)
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_VTABLE_INHERIT
case|:
case|case
name|BFD_RELOC_VTABLE_ENTRY
case|:
name|fixP
operator|->
name|fx_done
operator|=
literal|0
expr_stmt|;
return|return;
case|case
name|BFD_RELOC_ARM_MOVW
case|:
case|case
name|BFD_RELOC_ARM_MOVT
case|:
case|case
name|BFD_RELOC_ARM_THUMB_MOVW
case|:
case|case
name|BFD_RELOC_ARM_THUMB_MOVT
case|:
if|if
condition|(
name|fixP
operator|->
name|fx_done
operator|||
operator|!
name|seg
operator|->
name|use_rela_p
condition|)
block|{
comment|/* REL format relocations are limited to a 16-bit addend.  */
if|if
condition|(
operator|!
name|fixP
operator|->
name|fx_done
condition|)
block|{
if|if
condition|(
name|value
operator|<
operator|-
literal|0x1000
operator|||
name|value
operator|>
literal|0xffff
condition|)
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"offset too big"
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_ARM_MOVT
operator|||
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_ARM_THUMB_MOVT
condition|)
block|{
name|value
operator|>>=
literal|16
expr_stmt|;
block|}
if|if
condition|(
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_ARM_THUMB_MOVW
operator|||
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_ARM_THUMB_MOVT
condition|)
block|{
name|newval
operator|=
name|get_thumb32_insn
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|newval
operator|&=
literal|0xfbf08f00
expr_stmt|;
name|newval
operator||=
operator|(
name|value
operator|&
literal|0xf000
operator|)
operator|<<
literal|4
expr_stmt|;
name|newval
operator||=
operator|(
name|value
operator|&
literal|0x0800
operator|)
operator|<<
literal|15
expr_stmt|;
name|newval
operator||=
operator|(
name|value
operator|&
literal|0x0700
operator|)
operator|<<
literal|4
expr_stmt|;
name|newval
operator||=
operator|(
name|value
operator|&
literal|0x00ff
operator|)
expr_stmt|;
name|put_thumb32_insn
argument_list|(
name|buf
argument_list|,
name|newval
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|newval
operator|=
name|md_chars_to_number
argument_list|(
name|buf
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|newval
operator|&=
literal|0xfff0f000
expr_stmt|;
name|newval
operator||=
name|value
operator|&
literal|0x0fff
expr_stmt|;
name|newval
operator||=
operator|(
name|value
operator|&
literal|0xf000
operator|)
operator|<<
literal|4
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|buf
argument_list|,
name|newval
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
block|}
return|return;
case|case
name|BFD_RELOC_ARM_ALU_PC_G0_NC
case|:
case|case
name|BFD_RELOC_ARM_ALU_PC_G0
case|:
case|case
name|BFD_RELOC_ARM_ALU_PC_G1_NC
case|:
case|case
name|BFD_RELOC_ARM_ALU_PC_G1
case|:
case|case
name|BFD_RELOC_ARM_ALU_PC_G2
case|:
case|case
name|BFD_RELOC_ARM_ALU_SB_G0_NC
case|:
case|case
name|BFD_RELOC_ARM_ALU_SB_G0
case|:
case|case
name|BFD_RELOC_ARM_ALU_SB_G1_NC
case|:
case|case
name|BFD_RELOC_ARM_ALU_SB_G1
case|:
case|case
name|BFD_RELOC_ARM_ALU_SB_G2
case|:
name|assert
argument_list|(
operator|!
name|fixP
operator|->
name|fx_done
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|seg
operator|->
name|use_rela_p
condition|)
block|{
name|bfd_vma
name|insn
decl_stmt|;
name|bfd_vma
name|encoded_addend
decl_stmt|;
name|bfd_vma
name|addend_abs
init|=
name|abs
argument_list|(
name|value
argument_list|)
decl_stmt|;
comment|/* Check that the absolute value of the addend can be             expressed as an 8-bit constant plus a rotation.  */
name|encoded_addend
operator|=
name|encode_arm_immediate
argument_list|(
name|addend_abs
argument_list|)
expr_stmt|;
if|if
condition|(
name|encoded_addend
operator|==
operator|(
name|unsigned
name|int
operator|)
name|FAIL
condition|)
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"the offset 0x%08lX is not representable"
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|addend_abs
argument_list|)
expr_stmt|;
comment|/* Extract the instruction.  */
name|insn
operator|=
name|md_chars_to_number
argument_list|(
name|buf
argument_list|,
name|INSN_SIZE
argument_list|)
expr_stmt|;
comment|/* If the addend is positive, use an ADD instruction.             Otherwise use a SUB.  Take care not to destroy the S bit.  */
name|insn
operator|&=
literal|0xff1fffff
expr_stmt|;
if|if
condition|(
name|value
operator|<
literal|0
condition|)
name|insn
operator||=
literal|1
operator|<<
literal|22
expr_stmt|;
else|else
name|insn
operator||=
literal|1
operator|<<
literal|23
expr_stmt|;
comment|/* Place the encoded addend into the first 12 bits of the             instruction.  */
name|insn
operator|&=
literal|0xfffff000
expr_stmt|;
name|insn
operator||=
name|encoded_addend
expr_stmt|;
comment|/* Update the instruction.  */
name|md_number_to_chars
argument_list|(
name|buf
argument_list|,
name|insn
argument_list|,
name|INSN_SIZE
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|BFD_RELOC_ARM_LDR_PC_G0
case|:
case|case
name|BFD_RELOC_ARM_LDR_PC_G1
case|:
case|case
name|BFD_RELOC_ARM_LDR_PC_G2
case|:
case|case
name|BFD_RELOC_ARM_LDR_SB_G0
case|:
case|case
name|BFD_RELOC_ARM_LDR_SB_G1
case|:
case|case
name|BFD_RELOC_ARM_LDR_SB_G2
case|:
name|assert
argument_list|(
operator|!
name|fixP
operator|->
name|fx_done
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|seg
operator|->
name|use_rela_p
condition|)
block|{
name|bfd_vma
name|insn
decl_stmt|;
name|bfd_vma
name|addend_abs
init|=
name|abs
argument_list|(
name|value
argument_list|)
decl_stmt|;
comment|/* Check that the absolute value of the addend can be              encoded in 12 bits.  */
if|if
condition|(
name|addend_abs
operator|>=
literal|0x1000
condition|)
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"bad offset 0x%08lX (only 12 bits available for the magnitude)"
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|addend_abs
argument_list|)
expr_stmt|;
comment|/* Extract the instruction.  */
name|insn
operator|=
name|md_chars_to_number
argument_list|(
name|buf
argument_list|,
name|INSN_SIZE
argument_list|)
expr_stmt|;
comment|/* If the addend is negative, clear bit 23 of the instruction.              Otherwise set it.  */
if|if
condition|(
name|value
operator|<
literal|0
condition|)
name|insn
operator|&=
operator|~
operator|(
literal|1
operator|<<
literal|23
operator|)
expr_stmt|;
else|else
name|insn
operator||=
literal|1
operator|<<
literal|23
expr_stmt|;
comment|/* Place the absolute value of the addend into the first 12 bits              of the instruction.  */
name|insn
operator|&=
literal|0xfffff000
expr_stmt|;
name|insn
operator||=
name|addend_abs
expr_stmt|;
comment|/* Update the instruction.  */
name|md_number_to_chars
argument_list|(
name|buf
argument_list|,
name|insn
argument_list|,
name|INSN_SIZE
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|BFD_RELOC_ARM_LDRS_PC_G0
case|:
case|case
name|BFD_RELOC_ARM_LDRS_PC_G1
case|:
case|case
name|BFD_RELOC_ARM_LDRS_PC_G2
case|:
case|case
name|BFD_RELOC_ARM_LDRS_SB_G0
case|:
case|case
name|BFD_RELOC_ARM_LDRS_SB_G1
case|:
case|case
name|BFD_RELOC_ARM_LDRS_SB_G2
case|:
name|assert
argument_list|(
operator|!
name|fixP
operator|->
name|fx_done
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|seg
operator|->
name|use_rela_p
condition|)
block|{
name|bfd_vma
name|insn
decl_stmt|;
name|bfd_vma
name|addend_abs
init|=
name|abs
argument_list|(
name|value
argument_list|)
decl_stmt|;
comment|/* Check that the absolute value of the addend can be              encoded in 8 bits.  */
if|if
condition|(
name|addend_abs
operator|>=
literal|0x100
condition|)
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"bad offset 0x%08lX (only 8 bits available for the magnitude)"
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|addend_abs
argument_list|)
expr_stmt|;
comment|/* Extract the instruction.  */
name|insn
operator|=
name|md_chars_to_number
argument_list|(
name|buf
argument_list|,
name|INSN_SIZE
argument_list|)
expr_stmt|;
comment|/* If the addend is negative, clear bit 23 of the instruction.              Otherwise set it.  */
if|if
condition|(
name|value
operator|<
literal|0
condition|)
name|insn
operator|&=
operator|~
operator|(
literal|1
operator|<<
literal|23
operator|)
expr_stmt|;
else|else
name|insn
operator||=
literal|1
operator|<<
literal|23
expr_stmt|;
comment|/* Place the first four bits of the absolute value of the addend              into the first 4 bits of the instruction, and the remaining              four into bits 8 .. 11.  */
name|insn
operator|&=
literal|0xfffff0f0
expr_stmt|;
name|insn
operator||=
operator|(
name|addend_abs
operator|&
literal|0xf
operator|)
operator||
operator|(
operator|(
name|addend_abs
operator|&
literal|0xf0
operator|)
operator|<<
literal|4
operator|)
expr_stmt|;
comment|/* Update the instruction.  */
name|md_number_to_chars
argument_list|(
name|buf
argument_list|,
name|insn
argument_list|,
name|INSN_SIZE
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|BFD_RELOC_ARM_LDC_PC_G0
case|:
case|case
name|BFD_RELOC_ARM_LDC_PC_G1
case|:
case|case
name|BFD_RELOC_ARM_LDC_PC_G2
case|:
case|case
name|BFD_RELOC_ARM_LDC_SB_G0
case|:
case|case
name|BFD_RELOC_ARM_LDC_SB_G1
case|:
case|case
name|BFD_RELOC_ARM_LDC_SB_G2
case|:
name|assert
argument_list|(
operator|!
name|fixP
operator|->
name|fx_done
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|seg
operator|->
name|use_rela_p
condition|)
block|{
name|bfd_vma
name|insn
decl_stmt|;
name|bfd_vma
name|addend_abs
init|=
name|abs
argument_list|(
name|value
argument_list|)
decl_stmt|;
comment|/* Check that the absolute value of the addend is a multiple of              four and, when divided by four, fits in 8 bits.  */
if|if
condition|(
name|addend_abs
operator|&
literal|0x3
condition|)
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"bad offset 0x%08lX (must be word-aligned)"
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|addend_abs
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|addend_abs
operator|>>
literal|2
operator|)
operator|>
literal|0xff
condition|)
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"bad offset 0x%08lX (must be an 8-bit number of words)"
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|addend_abs
argument_list|)
expr_stmt|;
comment|/* Extract the instruction.  */
name|insn
operator|=
name|md_chars_to_number
argument_list|(
name|buf
argument_list|,
name|INSN_SIZE
argument_list|)
expr_stmt|;
comment|/* If the addend is negative, clear bit 23 of the instruction.              Otherwise set it.  */
if|if
condition|(
name|value
operator|<
literal|0
condition|)
name|insn
operator|&=
operator|~
operator|(
literal|1
operator|<<
literal|23
operator|)
expr_stmt|;
else|else
name|insn
operator||=
literal|1
operator|<<
literal|23
expr_stmt|;
comment|/* Place the addend (divided by four) into the first eight              bits of the instruction.  */
name|insn
operator|&=
literal|0xfffffff0
expr_stmt|;
name|insn
operator||=
name|addend_abs
operator|>>
literal|2
expr_stmt|;
comment|/* Update the instruction.  */
name|md_number_to_chars
argument_list|(
name|buf
argument_list|,
name|insn
argument_list|,
name|INSN_SIZE
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|BFD_RELOC_UNUSED
case|:
default|default:
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"bad relocation fixup type (%d)"
argument_list|)
argument_list|,
name|fixP
operator|->
name|fx_r_type
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Translate internal representation of relocation info to BFD target    format.  */
end_comment

begin_function
name|arelent
modifier|*
name|tc_gen_reloc
parameter_list|(
name|asection
modifier|*
name|section
parameter_list|,
name|fixS
modifier|*
name|fixp
parameter_list|)
block|{
name|arelent
modifier|*
name|reloc
decl_stmt|;
name|bfd_reloc_code_real_type
name|code
decl_stmt|;
name|reloc
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|arelent
argument_list|)
argument_list|)
expr_stmt|;
name|reloc
operator|->
name|sym_ptr_ptr
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|asymbol
operator|*
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|reloc
operator|->
name|sym_ptr_ptr
operator|=
name|symbol_get_bfdsym
argument_list|(
name|fixp
operator|->
name|fx_addsy
argument_list|)
expr_stmt|;
name|reloc
operator|->
name|address
operator|=
name|fixp
operator|->
name|fx_frag
operator|->
name|fr_address
operator|+
name|fixp
operator|->
name|fx_where
expr_stmt|;
if|if
condition|(
name|fixp
operator|->
name|fx_pcrel
condition|)
block|{
if|if
condition|(
name|section
operator|->
name|use_rela_p
condition|)
name|fixp
operator|->
name|fx_offset
operator|-=
name|md_pcrel_from_section
argument_list|(
name|fixp
argument_list|,
name|section
argument_list|)
expr_stmt|;
else|else
name|fixp
operator|->
name|fx_offset
operator|=
name|reloc
operator|->
name|address
expr_stmt|;
block|}
name|reloc
operator|->
name|addend
operator|=
name|fixp
operator|->
name|fx_offset
expr_stmt|;
switch|switch
condition|(
name|fixp
operator|->
name|fx_r_type
condition|)
block|{
case|case
name|BFD_RELOC_8
case|:
if|if
condition|(
name|fixp
operator|->
name|fx_pcrel
condition|)
block|{
name|code
operator|=
name|BFD_RELOC_8_PCREL
expr_stmt|;
break|break;
block|}
case|case
name|BFD_RELOC_16
case|:
if|if
condition|(
name|fixp
operator|->
name|fx_pcrel
condition|)
block|{
name|code
operator|=
name|BFD_RELOC_16_PCREL
expr_stmt|;
break|break;
block|}
case|case
name|BFD_RELOC_32
case|:
if|if
condition|(
name|fixp
operator|->
name|fx_pcrel
condition|)
block|{
name|code
operator|=
name|BFD_RELOC_32_PCREL
expr_stmt|;
break|break;
block|}
case|case
name|BFD_RELOC_ARM_MOVW
case|:
if|if
condition|(
name|fixp
operator|->
name|fx_pcrel
condition|)
block|{
name|code
operator|=
name|BFD_RELOC_ARM_MOVW_PCREL
expr_stmt|;
break|break;
block|}
case|case
name|BFD_RELOC_ARM_MOVT
case|:
if|if
condition|(
name|fixp
operator|->
name|fx_pcrel
condition|)
block|{
name|code
operator|=
name|BFD_RELOC_ARM_MOVT_PCREL
expr_stmt|;
break|break;
block|}
case|case
name|BFD_RELOC_ARM_THUMB_MOVW
case|:
if|if
condition|(
name|fixp
operator|->
name|fx_pcrel
condition|)
block|{
name|code
operator|=
name|BFD_RELOC_ARM_THUMB_MOVW_PCREL
expr_stmt|;
break|break;
block|}
case|case
name|BFD_RELOC_ARM_THUMB_MOVT
case|:
if|if
condition|(
name|fixp
operator|->
name|fx_pcrel
condition|)
block|{
name|code
operator|=
name|BFD_RELOC_ARM_THUMB_MOVT_PCREL
expr_stmt|;
break|break;
block|}
case|case
name|BFD_RELOC_NONE
case|:
case|case
name|BFD_RELOC_ARM_PCREL_BRANCH
case|:
case|case
name|BFD_RELOC_ARM_PCREL_BLX
case|:
case|case
name|BFD_RELOC_RVA
case|:
case|case
name|BFD_RELOC_THUMB_PCREL_BRANCH7
case|:
case|case
name|BFD_RELOC_THUMB_PCREL_BRANCH9
case|:
case|case
name|BFD_RELOC_THUMB_PCREL_BRANCH12
case|:
case|case
name|BFD_RELOC_THUMB_PCREL_BRANCH20
case|:
case|case
name|BFD_RELOC_THUMB_PCREL_BRANCH23
case|:
case|case
name|BFD_RELOC_THUMB_PCREL_BRANCH25
case|:
case|case
name|BFD_RELOC_THUMB_PCREL_BLX
case|:
case|case
name|BFD_RELOC_VTABLE_ENTRY
case|:
case|case
name|BFD_RELOC_VTABLE_INHERIT
case|:
ifdef|#
directive|ifdef
name|TE_PE
case|case
name|BFD_RELOC_32_SECREL
case|:
endif|#
directive|endif
name|code
operator|=
name|fixp
operator|->
name|fx_r_type
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_ARM_LITERAL
case|:
case|case
name|BFD_RELOC_ARM_HWLITERAL
case|:
comment|/* If this is called then the a literal has 	 been referenced across a section boundary.  */
name|as_bad_where
argument_list|(
name|fixp
operator|->
name|fx_file
argument_list|,
name|fixp
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"literal referenced across section boundary"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
ifdef|#
directive|ifdef
name|OBJ_ELF
case|case
name|BFD_RELOC_ARM_GOT32
case|:
case|case
name|BFD_RELOC_ARM_GOTOFF
case|:
case|case
name|BFD_RELOC_ARM_PLT32
case|:
case|case
name|BFD_RELOC_ARM_TARGET1
case|:
case|case
name|BFD_RELOC_ARM_ROSEGREL32
case|:
case|case
name|BFD_RELOC_ARM_SBREL32
case|:
case|case
name|BFD_RELOC_ARM_PREL31
case|:
case|case
name|BFD_RELOC_ARM_TARGET2
case|:
case|case
name|BFD_RELOC_ARM_TLS_LE32
case|:
case|case
name|BFD_RELOC_ARM_TLS_LDO32
case|:
case|case
name|BFD_RELOC_ARM_PCREL_CALL
case|:
case|case
name|BFD_RELOC_ARM_PCREL_JUMP
case|:
case|case
name|BFD_RELOC_ARM_ALU_PC_G0_NC
case|:
case|case
name|BFD_RELOC_ARM_ALU_PC_G0
case|:
case|case
name|BFD_RELOC_ARM_ALU_PC_G1_NC
case|:
case|case
name|BFD_RELOC_ARM_ALU_PC_G1
case|:
case|case
name|BFD_RELOC_ARM_ALU_PC_G2
case|:
case|case
name|BFD_RELOC_ARM_LDR_PC_G0
case|:
case|case
name|BFD_RELOC_ARM_LDR_PC_G1
case|:
case|case
name|BFD_RELOC_ARM_LDR_PC_G2
case|:
case|case
name|BFD_RELOC_ARM_LDRS_PC_G0
case|:
case|case
name|BFD_RELOC_ARM_LDRS_PC_G1
case|:
case|case
name|BFD_RELOC_ARM_LDRS_PC_G2
case|:
case|case
name|BFD_RELOC_ARM_LDC_PC_G0
case|:
case|case
name|BFD_RELOC_ARM_LDC_PC_G1
case|:
case|case
name|BFD_RELOC_ARM_LDC_PC_G2
case|:
case|case
name|BFD_RELOC_ARM_ALU_SB_G0_NC
case|:
case|case
name|BFD_RELOC_ARM_ALU_SB_G0
case|:
case|case
name|BFD_RELOC_ARM_ALU_SB_G1_NC
case|:
case|case
name|BFD_RELOC_ARM_ALU_SB_G1
case|:
case|case
name|BFD_RELOC_ARM_ALU_SB_G2
case|:
case|case
name|BFD_RELOC_ARM_LDR_SB_G0
case|:
case|case
name|BFD_RELOC_ARM_LDR_SB_G1
case|:
case|case
name|BFD_RELOC_ARM_LDR_SB_G2
case|:
case|case
name|BFD_RELOC_ARM_LDRS_SB_G0
case|:
case|case
name|BFD_RELOC_ARM_LDRS_SB_G1
case|:
case|case
name|BFD_RELOC_ARM_LDRS_SB_G2
case|:
case|case
name|BFD_RELOC_ARM_LDC_SB_G0
case|:
case|case
name|BFD_RELOC_ARM_LDC_SB_G1
case|:
case|case
name|BFD_RELOC_ARM_LDC_SB_G2
case|:
name|code
operator|=
name|fixp
operator|->
name|fx_r_type
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_ARM_TLS_GD32
case|:
case|case
name|BFD_RELOC_ARM_TLS_IE32
case|:
case|case
name|BFD_RELOC_ARM_TLS_LDM32
case|:
comment|/* BFD will include the symbol's address in the addend. 	 But we don't want that, so subtract it out again here.  */
if|if
condition|(
operator|!
name|S_IS_COMMON
argument_list|(
name|fixp
operator|->
name|fx_addsy
argument_list|)
condition|)
name|reloc
operator|->
name|addend
operator|-=
operator|(
operator|*
name|reloc
operator|->
name|sym_ptr_ptr
operator|)
operator|->
name|value
expr_stmt|;
name|code
operator|=
name|fixp
operator|->
name|fx_r_type
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|BFD_RELOC_ARM_IMMEDIATE
case|:
name|as_bad_where
argument_list|(
name|fixp
operator|->
name|fx_file
argument_list|,
name|fixp
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"internal relocation (type: IMMEDIATE) not fixed up"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
case|case
name|BFD_RELOC_ARM_ADRL_IMMEDIATE
case|:
name|as_bad_where
argument_list|(
name|fixp
operator|->
name|fx_file
argument_list|,
name|fixp
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"ADRL used for a symbol not defined in the same file"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
case|case
name|BFD_RELOC_ARM_OFFSET_IMM
case|:
if|if
condition|(
name|section
operator|->
name|use_rela_p
condition|)
block|{
name|code
operator|=
name|fixp
operator|->
name|fx_r_type
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|fixp
operator|->
name|fx_addsy
operator|!=
name|NULL
operator|&&
operator|!
name|S_IS_DEFINED
argument_list|(
name|fixp
operator|->
name|fx_addsy
argument_list|)
operator|&&
name|S_IS_LOCAL
argument_list|(
name|fixp
operator|->
name|fx_addsy
argument_list|)
condition|)
block|{
name|as_bad_where
argument_list|(
name|fixp
operator|->
name|fx_file
argument_list|,
name|fixp
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"undefined local label `%s'"
argument_list|)
argument_list|,
name|S_GET_NAME
argument_list|(
name|fixp
operator|->
name|fx_addsy
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|as_bad_where
argument_list|(
name|fixp
operator|->
name|fx_file
argument_list|,
name|fixp
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"internal_relocation (type: OFFSET_IMM) not fixed up"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
default|default:
block|{
name|char
modifier|*
name|type
decl_stmt|;
switch|switch
condition|(
name|fixp
operator|->
name|fx_r_type
condition|)
block|{
case|case
name|BFD_RELOC_NONE
case|:
name|type
operator|=
literal|"NONE"
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_ARM_OFFSET_IMM8
case|:
name|type
operator|=
literal|"OFFSET_IMM8"
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_ARM_SHIFT_IMM
case|:
name|type
operator|=
literal|"SHIFT_IMM"
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_ARM_SMC
case|:
name|type
operator|=
literal|"SMC"
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_ARM_SWI
case|:
name|type
operator|=
literal|"SWI"
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_ARM_MULTI
case|:
name|type
operator|=
literal|"MULTI"
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_ARM_CP_OFF_IMM
case|:
name|type
operator|=
literal|"CP_OFF_IMM"
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_ARM_T32_CP_OFF_IMM
case|:
name|type
operator|=
literal|"T32_CP_OFF_IMM"
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_ARM_THUMB_ADD
case|:
name|type
operator|=
literal|"THUMB_ADD"
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_ARM_THUMB_SHIFT
case|:
name|type
operator|=
literal|"THUMB_SHIFT"
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_ARM_THUMB_IMM
case|:
name|type
operator|=
literal|"THUMB_IMM"
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_ARM_THUMB_OFFSET
case|:
name|type
operator|=
literal|"THUMB_OFFSET"
expr_stmt|;
break|break;
default|default:
name|type
operator|=
name|_
argument_list|(
literal|"<unknown>"
argument_list|)
expr_stmt|;
break|break;
block|}
name|as_bad_where
argument_list|(
name|fixp
operator|->
name|fx_file
argument_list|,
name|fixp
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"cannot represent %s relocation in this object file format"
argument_list|)
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
ifdef|#
directive|ifdef
name|OBJ_ELF
if|if
condition|(
operator|(
name|code
operator|==
name|BFD_RELOC_32_PCREL
operator|||
name|code
operator|==
name|BFD_RELOC_32
operator|)
operator|&&
name|GOT_symbol
operator|&&
name|fixp
operator|->
name|fx_addsy
operator|==
name|GOT_symbol
condition|)
block|{
name|code
operator|=
name|BFD_RELOC_ARM_GOTPC
expr_stmt|;
name|reloc
operator|->
name|addend
operator|=
name|fixp
operator|->
name|fx_offset
operator|=
name|reloc
operator|->
name|address
expr_stmt|;
block|}
endif|#
directive|endif
name|reloc
operator|->
name|howto
operator|=
name|bfd_reloc_type_lookup
argument_list|(
name|stdoutput
argument_list|,
name|code
argument_list|)
expr_stmt|;
if|if
condition|(
name|reloc
operator|->
name|howto
operator|==
name|NULL
condition|)
block|{
name|as_bad_where
argument_list|(
name|fixp
operator|->
name|fx_file
argument_list|,
name|fixp
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"cannot represent %s relocation in this object file format"
argument_list|)
argument_list|,
name|bfd_get_reloc_code_name
argument_list|(
name|code
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* HACK: Since arm ELF uses Rel instead of Rela, encode the      vtable entry to be used in the relocation's section offset.  */
if|if
condition|(
name|fixp
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_VTABLE_ENTRY
condition|)
name|reloc
operator|->
name|address
operator|=
name|fixp
operator|->
name|fx_offset
expr_stmt|;
return|return
name|reloc
return|;
block|}
end_function

begin_comment
comment|/* This fix_new is called by cons via TC_CONS_FIX_NEW.	*/
end_comment

begin_function
name|void
name|cons_fix_new_arm
parameter_list|(
name|fragS
modifier|*
name|frag
parameter_list|,
name|int
name|where
parameter_list|,
name|int
name|size
parameter_list|,
name|expressionS
modifier|*
name|exp
parameter_list|)
block|{
name|bfd_reloc_code_real_type
name|type
decl_stmt|;
name|int
name|pcrel
init|=
literal|0
decl_stmt|;
comment|/* Pick a reloc.      FIXME: @@ Should look at CPU word size.  */
switch|switch
condition|(
name|size
condition|)
block|{
case|case
literal|1
case|:
name|type
operator|=
name|BFD_RELOC_8
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|type
operator|=
name|BFD_RELOC_16
expr_stmt|;
break|break;
case|case
literal|4
case|:
default|default:
name|type
operator|=
name|BFD_RELOC_32
expr_stmt|;
break|break;
case|case
literal|8
case|:
name|type
operator|=
name|BFD_RELOC_64
expr_stmt|;
break|break;
block|}
ifdef|#
directive|ifdef
name|TE_PE
if|if
condition|(
name|exp
operator|->
name|X_op
operator|==
name|O_secrel
condition|)
block|{
name|exp
operator|->
name|X_op
operator|=
name|O_symbol
expr_stmt|;
name|type
operator|=
name|BFD_RELOC_32_SECREL
expr_stmt|;
block|}
endif|#
directive|endif
name|fix_new_exp
argument_list|(
name|frag
argument_list|,
name|where
argument_list|,
operator|(
name|int
operator|)
name|size
argument_list|,
name|exp
argument_list|,
name|pcrel
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
name|OBJ_COFF
operator|||
name|defined
name|OBJ_ELF
end_if

begin_function
name|void
name|arm_validate_fix
parameter_list|(
name|fixS
modifier|*
name|fixP
parameter_list|)
block|{
comment|/* If the destination of the branch is a defined symbol which does not have      the THUMB_FUNC attribute, then we must be calling a function which has      the (interfacearm) attribute.  We look for the Thumb entry point to that      function and change the branch to refer to that function instead.	*/
if|if
condition|(
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_THUMB_PCREL_BRANCH23
operator|&&
name|fixP
operator|->
name|fx_addsy
operator|!=
name|NULL
operator|&&
name|S_IS_DEFINED
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
operator|&&
operator|!
name|THUMB_IS_FUNC
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
condition|)
block|{
name|fixP
operator|->
name|fx_addsy
operator|=
name|find_real_start
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|arm_force_relocation
parameter_list|(
name|struct
name|fix
modifier|*
name|fixp
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|OBJ_COFF
argument_list|)
operator|&&
name|defined
argument_list|(
name|TE_PE
argument_list|)
if|if
condition|(
name|fixp
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_RVA
condition|)
return|return
literal|1
return|;
endif|#
directive|endif
comment|/* Resolve these relocations even if the symbol is extern or weak.  */
if|if
condition|(
name|fixp
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_ARM_IMMEDIATE
operator|||
name|fixp
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_ARM_OFFSET_IMM
operator|||
name|fixp
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_ARM_ADRL_IMMEDIATE
operator|||
name|fixp
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_ARM_T32_ADD_IMM
operator|||
name|fixp
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_ARM_T32_IMMEDIATE
operator|||
name|fixp
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_ARM_T32_IMM12
operator|||
name|fixp
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_ARM_T32_ADD_PC12
condition|)
return|return
literal|0
return|;
comment|/* Always leave these relocations for the linker.  */
if|if
condition|(
operator|(
name|fixp
operator|->
name|fx_r_type
operator|>=
name|BFD_RELOC_ARM_ALU_PC_G0_NC
operator|&&
name|fixp
operator|->
name|fx_r_type
operator|<=
name|BFD_RELOC_ARM_LDC_SB_G2
operator|)
operator|||
name|fixp
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_ARM_LDR_PC_G0
condition|)
return|return
literal|1
return|;
comment|/* Always generate relocations against function symbols.  */
if|if
condition|(
name|fixp
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_32
operator|&&
name|fixp
operator|->
name|fx_addsy
operator|&&
operator|(
name|symbol_get_bfdsym
argument_list|(
name|fixp
operator|->
name|fx_addsy
argument_list|)
operator|->
name|flags
operator|&
name|BSF_FUNCTION
operator|)
condition|)
return|return
literal|1
return|;
return|return
name|generic_force_reloc
argument_list|(
name|fixp
argument_list|)
return|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|OBJ_ELF
argument_list|)
operator|||
name|defined
argument_list|(
name|OBJ_COFF
argument_list|)
end_if

begin_comment
comment|/* Relocations against function names must be left unadjusted,    so that the linker can use this information to generate interworking    stubs.  The MIPS version of this function    also prevents relocations that are mips-16 specific, but I do not    know why it does this.     FIXME:    There is one other problem that ought to be addressed here, but    which currently is not:  Taking the address of a label (rather    than a function) and then later jumping to that address.  Such    addresses also ought to have their bottom bit set (assuming that    they reside in Thumb code), but at the moment they will not.	 */
end_comment

begin_function
name|bfd_boolean
name|arm_fix_adjustable
parameter_list|(
name|fixS
modifier|*
name|fixP
parameter_list|)
block|{
if|if
condition|(
name|fixP
operator|->
name|fx_addsy
operator|==
name|NULL
condition|)
return|return
literal|1
return|;
comment|/* Preserve relocations against symbols with function type.  */
if|if
condition|(
name|symbol_get_bfdsym
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
operator|->
name|flags
operator|&
name|BSF_FUNCTION
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|THUMB_IS_FUNC
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
operator|&&
name|fixP
operator|->
name|fx_subsy
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
comment|/* We need the symbol name for the VTABLE entries.  */
if|if
condition|(
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_VTABLE_INHERIT
operator|||
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_VTABLE_ENTRY
condition|)
return|return
literal|0
return|;
comment|/* Don't allow symbols to be discarded on GOT related relocs.	 */
if|if
condition|(
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_ARM_PLT32
operator|||
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_ARM_GOT32
operator|||
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_ARM_GOTOFF
operator|||
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_ARM_TLS_GD32
operator|||
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_ARM_TLS_LE32
operator|||
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_ARM_TLS_IE32
operator|||
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_ARM_TLS_LDM32
operator|||
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_ARM_TLS_LDO32
operator|||
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_ARM_TARGET2
condition|)
return|return
literal|0
return|;
comment|/* Similarly for group relocations.  */
if|if
condition|(
operator|(
name|fixP
operator|->
name|fx_r_type
operator|>=
name|BFD_RELOC_ARM_ALU_PC_G0_NC
operator|&&
name|fixP
operator|->
name|fx_r_type
operator|<=
name|BFD_RELOC_ARM_LDC_SB_G2
operator|)
operator|||
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_ARM_LDR_PC_G0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_ARM_MOVW
operator|||
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_ARM_MOVT
operator|||
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_ARM_THUMB_MOVW
operator|||
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_ARM_THUMB_MOVT
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* defined (OBJ_ELF) || defined (OBJ_COFF) */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|OBJ_ELF
end_ifdef

begin_function
specifier|const
name|char
modifier|*
name|elf32_arm_target_format
parameter_list|(
name|void
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|TE_SYMBIAN
return|return
operator|(
name|target_big_endian
condition|?
literal|"elf32-bigarm-symbian"
else|:
literal|"elf32-littlearm-symbian"
operator|)
return|;
elif|#
directive|elif
name|defined
argument_list|(
name|TE_VXWORKS
argument_list|)
return|return
operator|(
name|target_big_endian
condition|?
literal|"elf32-bigarm-vxworks"
else|:
literal|"elf32-littlearm-vxworks"
operator|)
return|;
else|#
directive|else
if|if
condition|(
name|target_big_endian
condition|)
return|return
literal|"elf32-bigarm"
return|;
else|else
return|return
literal|"elf32-littlearm"
return|;
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|armelf_frob_symbol
parameter_list|(
name|symbolS
modifier|*
name|symp
parameter_list|,
name|int
modifier|*
name|puntp
parameter_list|)
block|{
name|elf_frob_symbol
argument_list|(
name|symp
argument_list|,
name|puntp
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MD interface: Finalization.	*/
end_comment

begin_comment
comment|/* A good place to do this, although this was probably not intended    for this kind of use.  We need to dump the literal pool before    references are made to a null symbol pointer.  */
end_comment

begin_function
name|void
name|arm_cleanup
parameter_list|(
name|void
parameter_list|)
block|{
name|literal_pool
modifier|*
name|pool
decl_stmt|;
for|for
control|(
name|pool
operator|=
name|list_of_pools
init|;
name|pool
condition|;
name|pool
operator|=
name|pool
operator|->
name|next
control|)
block|{
comment|/* Put it at the end of the relevent section.  */
name|subseg_set
argument_list|(
name|pool
operator|->
name|section
argument_list|,
name|pool
operator|->
name|sub_section
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|OBJ_ELF
name|arm_elf_change_section
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|s_ltorg
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Adjust the symbol table.  This marks Thumb symbols as distinct from    ARM ones.  */
end_comment

begin_function
name|void
name|arm_adjust_symtab
parameter_list|(
name|void
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|OBJ_COFF
name|symbolS
modifier|*
name|sym
decl_stmt|;
for|for
control|(
name|sym
operator|=
name|symbol_rootP
init|;
name|sym
operator|!=
name|NULL
condition|;
name|sym
operator|=
name|symbol_next
argument_list|(
name|sym
argument_list|)
control|)
block|{
if|if
condition|(
name|ARM_IS_THUMB
argument_list|(
name|sym
argument_list|)
condition|)
block|{
if|if
condition|(
name|THUMB_IS_FUNC
argument_list|(
name|sym
argument_list|)
condition|)
block|{
comment|/* Mark the symbol as a Thumb function.  */
if|if
condition|(
name|S_GET_STORAGE_CLASS
argument_list|(
name|sym
argument_list|)
operator|==
name|C_STAT
operator|||
name|S_GET_STORAGE_CLASS
argument_list|(
name|sym
argument_list|)
operator|==
name|C_LABEL
condition|)
comment|/* This can happen!	 */
name|S_SET_STORAGE_CLASS
argument_list|(
name|sym
argument_list|,
name|C_THUMBSTATFUNC
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|S_GET_STORAGE_CLASS
argument_list|(
name|sym
argument_list|)
operator|==
name|C_EXT
condition|)
name|S_SET_STORAGE_CLASS
argument_list|(
name|sym
argument_list|,
name|C_THUMBEXTFUNC
argument_list|)
expr_stmt|;
else|else
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"%s: unexpected function type: %d"
argument_list|)
argument_list|,
name|S_GET_NAME
argument_list|(
name|sym
argument_list|)
argument_list|,
name|S_GET_STORAGE_CLASS
argument_list|(
name|sym
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
switch|switch
condition|(
name|S_GET_STORAGE_CLASS
argument_list|(
name|sym
argument_list|)
condition|)
block|{
case|case
name|C_EXT
case|:
name|S_SET_STORAGE_CLASS
argument_list|(
name|sym
argument_list|,
name|C_THUMBEXT
argument_list|)
expr_stmt|;
break|break;
case|case
name|C_STAT
case|:
name|S_SET_STORAGE_CLASS
argument_list|(
name|sym
argument_list|,
name|C_THUMBSTAT
argument_list|)
expr_stmt|;
break|break;
case|case
name|C_LABEL
case|:
name|S_SET_STORAGE_CLASS
argument_list|(
name|sym
argument_list|,
name|C_THUMBLABEL
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* Do nothing.  */
break|break;
block|}
block|}
if|if
condition|(
name|ARM_IS_INTERWORK
argument_list|(
name|sym
argument_list|)
condition|)
name|coffsymbol
argument_list|(
name|symbol_get_bfdsym
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|->
name|native
operator|->
name|u
operator|.
name|syment
operator|.
name|n_flags
operator|=
literal|0xFF
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|OBJ_ELF
name|symbolS
modifier|*
name|sym
decl_stmt|;
name|char
name|bind
decl_stmt|;
for|for
control|(
name|sym
operator|=
name|symbol_rootP
init|;
name|sym
operator|!=
name|NULL
condition|;
name|sym
operator|=
name|symbol_next
argument_list|(
name|sym
argument_list|)
control|)
block|{
if|if
condition|(
name|ARM_IS_THUMB
argument_list|(
name|sym
argument_list|)
condition|)
block|{
name|elf_symbol_type
modifier|*
name|elf_sym
decl_stmt|;
name|elf_sym
operator|=
name|elf_symbol
argument_list|(
name|symbol_get_bfdsym
argument_list|(
name|sym
argument_list|)
argument_list|)
expr_stmt|;
name|bind
operator|=
name|ELF_ST_BIND
argument_list|(
name|elf_sym
operator|->
name|internal_elf_sym
operator|.
name|st_info
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_is_arm_special_symbol_name
argument_list|(
name|elf_sym
operator|->
name|symbol
operator|.
name|name
argument_list|,
name|BFD_ARM_SPECIAL_SYM_TYPE_ANY
argument_list|)
condition|)
block|{
comment|/* If it's a .thumb_func, declare it as so, 		 otherwise tag label as .code 16.  */
if|if
condition|(
name|THUMB_IS_FUNC
argument_list|(
name|sym
argument_list|)
condition|)
name|elf_sym
operator|->
name|internal_elf_sym
operator|.
name|st_info
operator|=
name|ELF_ST_INFO
argument_list|(
name|bind
argument_list|,
name|STT_ARM_TFUNC
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|EF_ARM_EABI_VERSION
argument_list|(
name|meabi_flags
argument_list|)
operator|<
name|EF_ARM_EABI_VER4
condition|)
name|elf_sym
operator|->
name|internal_elf_sym
operator|.
name|st_info
operator|=
name|ELF_ST_INFO
argument_list|(
name|bind
argument_list|,
name|STT_ARM_16BIT
argument_list|)
expr_stmt|;
block|}
block|}
block|}
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* MD interface: Initialization.  */
end_comment

begin_function
specifier|static
name|void
name|set_constant_flonums
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_FLOAT_VALS
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|atof_ieee
argument_list|(
operator|(
name|char
operator|*
operator|)
name|fp_const
index|[
name|i
index|]
argument_list|,
literal|'x'
argument_list|,
name|fp_values
index|[
name|i
index|]
argument_list|)
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Auto-select Thumb mode if it's the only available instruction set for the    given architecture.  */
end_comment

begin_function
specifier|static
name|void
name|autoselect_thumb_from_cpu_variant
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
name|ARM_CPU_HAS_FEATURE
argument_list|(
name|cpu_variant
argument_list|,
name|arm_ext_v1
argument_list|)
condition|)
name|opcode_select
argument_list|(
literal|16
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|md_begin
parameter_list|(
name|void
parameter_list|)
block|{
name|unsigned
name|mach
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|(
name|arm_ops_hsh
operator|=
name|hash_new
argument_list|()
operator|)
operator|==
name|NULL
operator|||
operator|(
name|arm_cond_hsh
operator|=
name|hash_new
argument_list|()
operator|)
operator|==
name|NULL
operator|||
operator|(
name|arm_shift_hsh
operator|=
name|hash_new
argument_list|()
operator|)
operator|==
name|NULL
operator|||
operator|(
name|arm_psr_hsh
operator|=
name|hash_new
argument_list|()
operator|)
operator|==
name|NULL
operator|||
operator|(
name|arm_v7m_psr_hsh
operator|=
name|hash_new
argument_list|()
operator|)
operator|==
name|NULL
operator|||
operator|(
name|arm_reg_hsh
operator|=
name|hash_new
argument_list|()
operator|)
operator|==
name|NULL
operator|||
operator|(
name|arm_reloc_hsh
operator|=
name|hash_new
argument_list|()
operator|)
operator|==
name|NULL
operator|||
operator|(
name|arm_barrier_opt_hsh
operator|=
name|hash_new
argument_list|()
operator|)
operator|==
name|NULL
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"virtual memory exhausted"
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|insns
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|asm_opcode
argument_list|)
condition|;
name|i
operator|++
control|)
name|hash_insert
argument_list|(
name|arm_ops_hsh
argument_list|,
name|insns
index|[
name|i
index|]
operator|.
name|template
argument_list|,
call|(
name|PTR
call|)
argument_list|(
name|insns
operator|+
name|i
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|conds
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|asm_cond
argument_list|)
condition|;
name|i
operator|++
control|)
name|hash_insert
argument_list|(
name|arm_cond_hsh
argument_list|,
name|conds
index|[
name|i
index|]
operator|.
name|template
argument_list|,
call|(
name|PTR
call|)
argument_list|(
name|conds
operator|+
name|i
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|shift_names
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|asm_shift_name
argument_list|)
condition|;
name|i
operator|++
control|)
name|hash_insert
argument_list|(
name|arm_shift_hsh
argument_list|,
name|shift_names
index|[
name|i
index|]
operator|.
name|name
argument_list|,
call|(
name|PTR
call|)
argument_list|(
name|shift_names
operator|+
name|i
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|psrs
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|asm_psr
argument_list|)
condition|;
name|i
operator|++
control|)
name|hash_insert
argument_list|(
name|arm_psr_hsh
argument_list|,
name|psrs
index|[
name|i
index|]
operator|.
name|template
argument_list|,
call|(
name|PTR
call|)
argument_list|(
name|psrs
operator|+
name|i
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|v7m_psrs
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|asm_psr
argument_list|)
condition|;
name|i
operator|++
control|)
name|hash_insert
argument_list|(
name|arm_v7m_psr_hsh
argument_list|,
name|v7m_psrs
index|[
name|i
index|]
operator|.
name|template
argument_list|,
call|(
name|PTR
call|)
argument_list|(
name|v7m_psrs
operator|+
name|i
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|reg_names
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|reg_entry
argument_list|)
condition|;
name|i
operator|++
control|)
name|hash_insert
argument_list|(
name|arm_reg_hsh
argument_list|,
name|reg_names
index|[
name|i
index|]
operator|.
name|name
argument_list|,
call|(
name|PTR
call|)
argument_list|(
name|reg_names
operator|+
name|i
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|barrier_opt_names
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|asm_barrier_opt
argument_list|)
condition|;
name|i
operator|++
control|)
name|hash_insert
argument_list|(
name|arm_barrier_opt_hsh
argument_list|,
name|barrier_opt_names
index|[
name|i
index|]
operator|.
name|template
argument_list|,
call|(
name|PTR
call|)
argument_list|(
name|barrier_opt_names
operator|+
name|i
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|OBJ_ELF
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|reloc_names
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|reloc_entry
argument_list|)
condition|;
name|i
operator|++
control|)
name|hash_insert
argument_list|(
name|arm_reloc_hsh
argument_list|,
name|reloc_names
index|[
name|i
index|]
operator|.
name|name
argument_list|,
call|(
name|PTR
call|)
argument_list|(
name|reloc_names
operator|+
name|i
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|set_constant_flonums
argument_list|()
expr_stmt|;
comment|/* Set the cpu variant based on the command-line options.  We prefer      -mcpu= over -march= if both are set (as for GCC); and we prefer      -mfpu= over any other way of setting the floating point unit.      Use of legacy options with new options are faulted.  */
if|if
condition|(
name|legacy_cpu
condition|)
block|{
if|if
condition|(
name|mcpu_cpu_opt
operator|||
name|march_cpu_opt
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"use of old and new-style options to set CPU type"
argument_list|)
argument_list|)
expr_stmt|;
name|mcpu_cpu_opt
operator|=
name|legacy_cpu
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|mcpu_cpu_opt
condition|)
name|mcpu_cpu_opt
operator|=
name|march_cpu_opt
expr_stmt|;
if|if
condition|(
name|legacy_fpu
condition|)
block|{
if|if
condition|(
name|mfpu_opt
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"use of old and new-style options to set FPU type"
argument_list|)
argument_list|)
expr_stmt|;
name|mfpu_opt
operator|=
name|legacy_fpu
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|mfpu_opt
condition|)
block|{
if|#
directive|if
operator|!
operator|(
name|defined
argument_list|(
name|TE_LINUX
argument_list|)
operator|||
name|defined
argument_list|(
name|TE_NetBSD
argument_list|)
operator|||
name|defined
argument_list|(
name|TE_VXWORKS
argument_list|)
operator|)
comment|/* Some environments specify a default FPU.  If they don't, infer it 	 from the processor.  */
if|if
condition|(
name|mcpu_fpu_opt
condition|)
name|mfpu_opt
operator|=
name|mcpu_fpu_opt
expr_stmt|;
else|else
name|mfpu_opt
operator|=
name|march_fpu_opt
expr_stmt|;
else|#
directive|else
name|mfpu_opt
operator|=
operator|&
name|fpu_default
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
operator|!
name|mfpu_opt
condition|)
block|{
if|if
condition|(
name|mcpu_cpu_opt
operator|!=
name|NULL
condition|)
name|mfpu_opt
operator|=
operator|&
name|fpu_default
expr_stmt|;
elseif|else
if|if
condition|(
name|mcpu_fpu_opt
operator|!=
name|NULL
operator|&&
name|ARM_CPU_HAS_FEATURE
argument_list|(
operator|*
name|mcpu_fpu_opt
argument_list|,
name|arm_ext_v5
argument_list|)
condition|)
name|mfpu_opt
operator|=
operator|&
name|fpu_arch_vfp_v2
expr_stmt|;
else|else
name|mfpu_opt
operator|=
operator|&
name|fpu_arch_fpa
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|CPU_DEFAULT
if|if
condition|(
operator|!
name|mcpu_cpu_opt
condition|)
block|{
name|mcpu_cpu_opt
operator|=
operator|&
name|cpu_default
expr_stmt|;
name|selected_cpu
operator|=
name|cpu_default
expr_stmt|;
block|}
else|#
directive|else
if|if
condition|(
name|mcpu_cpu_opt
condition|)
name|selected_cpu
operator|=
operator|*
name|mcpu_cpu_opt
expr_stmt|;
else|else
name|mcpu_cpu_opt
operator|=
operator|&
name|arm_arch_any
expr_stmt|;
endif|#
directive|endif
name|ARM_MERGE_FEATURE_SETS
argument_list|(
name|cpu_variant
argument_list|,
operator|*
name|mcpu_cpu_opt
argument_list|,
operator|*
name|mfpu_opt
argument_list|)
expr_stmt|;
name|autoselect_thumb_from_cpu_variant
argument_list|()
expr_stmt|;
name|arm_arch_used
operator|=
name|thumb_arch_used
operator|=
name|arm_arch_none
expr_stmt|;
if|#
directive|if
name|defined
name|OBJ_COFF
operator|||
name|defined
name|OBJ_ELF
block|{
name|unsigned
name|int
name|flags
init|=
literal|0
decl_stmt|;
if|#
directive|if
name|defined
name|OBJ_ELF
name|flags
operator|=
name|meabi_flags
expr_stmt|;
switch|switch
condition|(
name|meabi_flags
condition|)
block|{
case|case
name|EF_ARM_EABI_UNKNOWN
case|:
endif|#
directive|endif
comment|/* Set the flags in the private structure.  */
if|if
condition|(
name|uses_apcs_26
condition|)
name|flags
operator||=
name|F_APCS26
expr_stmt|;
if|if
condition|(
name|support_interwork
condition|)
name|flags
operator||=
name|F_INTERWORK
expr_stmt|;
if|if
condition|(
name|uses_apcs_float
condition|)
name|flags
operator||=
name|F_APCS_FLOAT
expr_stmt|;
if|if
condition|(
name|pic_code
condition|)
name|flags
operator||=
name|F_PIC
expr_stmt|;
if|if
condition|(
operator|!
name|ARM_CPU_HAS_FEATURE
argument_list|(
name|cpu_variant
argument_list|,
name|fpu_any_hard
argument_list|)
condition|)
name|flags
operator||=
name|F_SOFT_FLOAT
expr_stmt|;
switch|switch
condition|(
name|mfloat_abi_opt
condition|)
block|{
case|case
name|ARM_FLOAT_ABI_SOFT
case|:
case|case
name|ARM_FLOAT_ABI_SOFTFP
case|:
name|flags
operator||=
name|F_SOFT_FLOAT
expr_stmt|;
break|break;
case|case
name|ARM_FLOAT_ABI_HARD
case|:
if|if
condition|(
name|flags
operator|&
name|F_SOFT_FLOAT
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"hard-float conflicts with specified fpu"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Using pure-endian doubles (even if soft-float).	*/
if|if
condition|(
name|ARM_CPU_HAS_FEATURE
argument_list|(
name|cpu_variant
argument_list|,
name|fpu_endian_pure
argument_list|)
condition|)
name|flags
operator||=
name|F_VFP_FLOAT
expr_stmt|;
if|#
directive|if
name|defined
name|OBJ_ELF
if|if
condition|(
name|ARM_CPU_HAS_FEATURE
argument_list|(
name|cpu_variant
argument_list|,
name|fpu_arch_maverick
argument_list|)
condition|)
name|flags
operator||=
name|EF_ARM_MAVERICK_FLOAT
expr_stmt|;
break|break;
case|case
name|EF_ARM_EABI_VER4
case|:
case|case
name|EF_ARM_EABI_VER5
case|:
comment|/* No additional flags to set.	*/
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
name|bfd_set_private_flags
argument_list|(
name|stdoutput
argument_list|,
name|flags
argument_list|)
expr_stmt|;
comment|/* We have run out flags in the COFF header to encode the        status of ATPCS support, so instead we create a dummy,        empty, debug section called .arm.atpcs.	*/
if|if
condition|(
name|atpcs
condition|)
block|{
name|asection
modifier|*
name|sec
decl_stmt|;
name|sec
operator|=
name|bfd_make_section
argument_list|(
name|stdoutput
argument_list|,
literal|".arm.atpcs"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sec
operator|!=
name|NULL
condition|)
block|{
name|bfd_set_section_flags
argument_list|(
name|stdoutput
argument_list|,
name|sec
argument_list|,
name|SEC_READONLY
operator||
name|SEC_DEBUGGING
comment|/* | SEC_HAS_CONTENTS */
argument_list|)
expr_stmt|;
name|bfd_set_section_size
argument_list|(
name|stdoutput
argument_list|,
name|sec
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bfd_set_section_contents
argument_list|(
name|stdoutput
argument_list|,
name|sec
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
endif|#
directive|endif
comment|/* Record the CPU type as well.  */
if|if
condition|(
name|ARM_CPU_HAS_FEATURE
argument_list|(
name|cpu_variant
argument_list|,
name|arm_cext_iwmmxt2
argument_list|)
condition|)
name|mach
operator|=
name|bfd_mach_arm_iWMMXt2
expr_stmt|;
elseif|else
if|if
condition|(
name|ARM_CPU_HAS_FEATURE
argument_list|(
name|cpu_variant
argument_list|,
name|arm_cext_iwmmxt
argument_list|)
condition|)
name|mach
operator|=
name|bfd_mach_arm_iWMMXt
expr_stmt|;
elseif|else
if|if
condition|(
name|ARM_CPU_HAS_FEATURE
argument_list|(
name|cpu_variant
argument_list|,
name|arm_cext_xscale
argument_list|)
condition|)
name|mach
operator|=
name|bfd_mach_arm_XScale
expr_stmt|;
elseif|else
if|if
condition|(
name|ARM_CPU_HAS_FEATURE
argument_list|(
name|cpu_variant
argument_list|,
name|arm_cext_maverick
argument_list|)
condition|)
name|mach
operator|=
name|bfd_mach_arm_ep9312
expr_stmt|;
elseif|else
if|if
condition|(
name|ARM_CPU_HAS_FEATURE
argument_list|(
name|cpu_variant
argument_list|,
name|arm_ext_v5e
argument_list|)
condition|)
name|mach
operator|=
name|bfd_mach_arm_5TE
expr_stmt|;
elseif|else
if|if
condition|(
name|ARM_CPU_HAS_FEATURE
argument_list|(
name|cpu_variant
argument_list|,
name|arm_ext_v5
argument_list|)
condition|)
block|{
if|if
condition|(
name|ARM_CPU_HAS_FEATURE
argument_list|(
name|cpu_variant
argument_list|,
name|arm_ext_v4t
argument_list|)
condition|)
name|mach
operator|=
name|bfd_mach_arm_5T
expr_stmt|;
else|else
name|mach
operator|=
name|bfd_mach_arm_5
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ARM_CPU_HAS_FEATURE
argument_list|(
name|cpu_variant
argument_list|,
name|arm_ext_v4
argument_list|)
condition|)
block|{
if|if
condition|(
name|ARM_CPU_HAS_FEATURE
argument_list|(
name|cpu_variant
argument_list|,
name|arm_ext_v4t
argument_list|)
condition|)
name|mach
operator|=
name|bfd_mach_arm_4T
expr_stmt|;
else|else
name|mach
operator|=
name|bfd_mach_arm_4
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ARM_CPU_HAS_FEATURE
argument_list|(
name|cpu_variant
argument_list|,
name|arm_ext_v3m
argument_list|)
condition|)
name|mach
operator|=
name|bfd_mach_arm_3M
expr_stmt|;
elseif|else
if|if
condition|(
name|ARM_CPU_HAS_FEATURE
argument_list|(
name|cpu_variant
argument_list|,
name|arm_ext_v3
argument_list|)
condition|)
name|mach
operator|=
name|bfd_mach_arm_3
expr_stmt|;
elseif|else
if|if
condition|(
name|ARM_CPU_HAS_FEATURE
argument_list|(
name|cpu_variant
argument_list|,
name|arm_ext_v2s
argument_list|)
condition|)
name|mach
operator|=
name|bfd_mach_arm_2a
expr_stmt|;
elseif|else
if|if
condition|(
name|ARM_CPU_HAS_FEATURE
argument_list|(
name|cpu_variant
argument_list|,
name|arm_ext_v2
argument_list|)
condition|)
name|mach
operator|=
name|bfd_mach_arm_2
expr_stmt|;
else|else
name|mach
operator|=
name|bfd_mach_arm_unknown
expr_stmt|;
name|bfd_set_arch_mach
argument_list|(
name|stdoutput
argument_list|,
name|TARGET_ARCH
argument_list|,
name|mach
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Command line processing.  */
end_comment

begin_comment
comment|/* md_parse_option       Invocation line includes a switch not recognized by the base assembler.       See if it's a processor-specific option.        This routine is somewhat complicated by the need for backwards       compatibility (since older releases of gcc can't be changed).       The new options try to make the interface as compatible as       possible with GCC.        New options (supported) are:  	      -mcpu=<cpu name>		 Assemble for selected processor 	      -march=<architecture name> Assemble for selected architecture 	      -mfpu=<fpu architecture>	 Assemble for selected FPU. 	      -EB/-mbig-endian		 Big-endian 	      -EL/-mlittle-endian	 Little-endian 	      -k			 Generate PIC code 	      -mthumb			 Start in Thumb mode 	      -mthumb-interwork		 Code supports ARM/Thumb interworking        For now we will also provide support for:  	      -mapcs-32			 32-bit Program counter 	      -mapcs-26			 26-bit Program counter 	      -macps-float		 Floats passed in FP registers 	      -mapcs-reentrant		 Reentrant code 	      -matpcs       (sometime these will probably be replaced with -mapcs=<list of options>       and -matpcs=<list of options>)        The remaining options are only supported for back-wards compatibility.       Cpu variants, the arm part is optional: 	      -m[arm]1		      Currently not supported. 	      -m[arm]2, -m[arm]250    Arm 2 and Arm 250 processor 	      -m[arm]3		      Arm 3 processor 	      -m[arm]6[xx],	      Arm 6 processors 	      -m[arm]7[xx][t][[d]m]   Arm 7 processors 	      -m[arm]8[10]	      Arm 8 processors 	      -m[arm]9[20][tdmi]      Arm 9 processors 	      -mstrongarm[110[0]]     StrongARM processors 	      -mxscale		      XScale processors 	      -m[arm]v[2345[t[e]]]    Arm architectures 	      -mall		      All (except the ARM1)       FP variants: 	      -mfpa10, -mfpa11	      FPA10 and 11 co-processor instructions 	      -mfpe-old		      (No float load/store multiples) 	      -mvfpxd		      VFP Single precision 	      -mvfp		      All VFP 	      -mno-fpu		      Disable all floating point instructions        The following CPU names are recognized: 	      arm1, arm2, arm250, arm3, arm6, arm600, arm610, arm620, 	      arm7, arm7m, arm7d, arm7dm, arm7di, arm7dmi, arm70, arm700, 	      arm700i, arm710 arm710t, arm720, arm720t, arm740t, arm710c, 	      arm7100, arm7500, arm7500fe, arm7tdmi, arm8, arm810, arm9, 	      arm920, arm920t, arm940t, arm946, arm966, arm9tdmi, arm9e, 	      arm10t arm10e, arm1020t, arm1020e, arm10200e, 	      strongarm, strongarm110, strongarm1100, strongarm1110, xscale.        */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|md_shortopts
init|=
literal|"m:k"
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|ARM_BI_ENDIAN
end_ifdef

begin_define
define|#
directive|define
name|OPTION_EB
value|(OPTION_MD_BASE + 0)
end_define

begin_define
define|#
directive|define
name|OPTION_EL
value|(OPTION_MD_BASE + 1)
end_define

begin_else
else|#
directive|else
end_else

begin_if
if|#
directive|if
name|TARGET_BYTES_BIG_ENDIAN
end_if

begin_define
define|#
directive|define
name|OPTION_EB
value|(OPTION_MD_BASE + 0)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|OPTION_EL
value|(OPTION_MD_BASE + 1)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|struct
name|option
name|md_longopts
index|[]
init|=
block|{
ifdef|#
directive|ifdef
name|OPTION_EB
block|{
literal|"EB"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_EB
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|OPTION_EL
block|{
literal|"EL"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_EL
block|}
block|,
endif|#
directive|endif
block|{
name|NULL
block|,
name|no_argument
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|size_t
name|md_longopts_size
init|=
sizeof|sizeof
argument_list|(
name|md_longopts
argument_list|)
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|arm_option_table
block|{
name|char
modifier|*
name|option
decl_stmt|;
comment|/* Option name to match.  */
name|char
modifier|*
name|help
decl_stmt|;
comment|/* Help information.  */
name|int
modifier|*
name|var
decl_stmt|;
comment|/* Variable to change.	*/
name|int
name|value
decl_stmt|;
comment|/* What to change it to.  */
name|char
modifier|*
name|deprecated
decl_stmt|;
comment|/* If non-null, print this message.  */
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|arm_option_table
name|arm_opts
index|[]
init|=
block|{
block|{
literal|"k"
block|,
name|N_
argument_list|(
literal|"generate PIC code"
argument_list|)
block|,
operator|&
name|pic_code
block|,
literal|1
block|,
name|NULL
block|}
block|,
block|{
literal|"mthumb"
block|,
name|N_
argument_list|(
literal|"assemble Thumb code"
argument_list|)
block|,
operator|&
name|thumb_mode
block|,
literal|1
block|,
name|NULL
block|}
block|,
block|{
literal|"mthumb-interwork"
block|,
name|N_
argument_list|(
literal|"support ARM/Thumb interworking"
argument_list|)
block|,
operator|&
name|support_interwork
block|,
literal|1
block|,
name|NULL
block|}
block|,
block|{
literal|"mapcs-32"
block|,
name|N_
argument_list|(
literal|"code uses 32-bit program counter"
argument_list|)
block|,
operator|&
name|uses_apcs_26
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"mapcs-26"
block|,
name|N_
argument_list|(
literal|"code uses 26-bit program counter"
argument_list|)
block|,
operator|&
name|uses_apcs_26
block|,
literal|1
block|,
name|NULL
block|}
block|,
block|{
literal|"mapcs-float"
block|,
name|N_
argument_list|(
literal|"floating point args are in fp regs"
argument_list|)
block|,
operator|&
name|uses_apcs_float
block|,
literal|1
block|,
name|NULL
block|}
block|,
block|{
literal|"mapcs-reentrant"
block|,
name|N_
argument_list|(
literal|"re-entrant code"
argument_list|)
block|,
operator|&
name|pic_code
block|,
literal|1
block|,
name|NULL
block|}
block|,
block|{
literal|"matpcs"
block|,
name|N_
argument_list|(
literal|"code is ATPCS conformant"
argument_list|)
block|,
operator|&
name|atpcs
block|,
literal|1
block|,
name|NULL
block|}
block|,
block|{
literal|"mbig-endian"
block|,
name|N_
argument_list|(
literal|"assemble for big-endian"
argument_list|)
block|,
operator|&
name|target_big_endian
block|,
literal|1
block|,
name|NULL
block|}
block|,
block|{
literal|"mlittle-endian"
block|,
name|N_
argument_list|(
literal|"assemble for little-endian"
argument_list|)
block|,
operator|&
name|target_big_endian
block|,
literal|0
block|,
name|NULL
block|}
block|,
comment|/* These are recognized by the assembler, but have no affect on code.	 */
block|{
literal|"mapcs-frame"
block|,
name|N_
argument_list|(
literal|"use frame pointer"
argument_list|)
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"mapcs-stack-check"
block|,
name|N_
argument_list|(
literal|"use stack size checking"
argument_list|)
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|arm_legacy_option_table
block|{
name|char
modifier|*
name|option
decl_stmt|;
comment|/* Option name to match.  */
specifier|const
name|arm_feature_set
modifier|*
modifier|*
name|var
decl_stmt|;
comment|/* Variable to change.	*/
specifier|const
name|arm_feature_set
name|value
decl_stmt|;
comment|/* What to change it to.  */
name|char
modifier|*
name|deprecated
decl_stmt|;
comment|/* If non-null, print this message.  */
block|}
struct|;
end_struct

begin_decl_stmt
specifier|const
name|struct
name|arm_legacy_option_table
name|arm_legacy_opts
index|[]
init|=
block|{
comment|/* DON'T add any new processors to this list -- we want the whole list      to go away...  Add them to the processors table instead.  */
block|{
literal|"marm1"
block|,
operator|&
name|legacy_cpu
block|,
name|ARM_ARCH_V1
block|,
name|N_
argument_list|(
literal|"use -mcpu=arm1"
argument_list|)
block|}
block|,
block|{
literal|"m1"
block|,
operator|&
name|legacy_cpu
block|,
name|ARM_ARCH_V1
block|,
name|N_
argument_list|(
literal|"use -mcpu=arm1"
argument_list|)
block|}
block|,
block|{
literal|"marm2"
block|,
operator|&
name|legacy_cpu
block|,
name|ARM_ARCH_V2
block|,
name|N_
argument_list|(
literal|"use -mcpu=arm2"
argument_list|)
block|}
block|,
block|{
literal|"m2"
block|,
operator|&
name|legacy_cpu
block|,
name|ARM_ARCH_V2
block|,
name|N_
argument_list|(
literal|"use -mcpu=arm2"
argument_list|)
block|}
block|,
block|{
literal|"marm250"
block|,
operator|&
name|legacy_cpu
block|,
name|ARM_ARCH_V2S
block|,
name|N_
argument_list|(
literal|"use -mcpu=arm250"
argument_list|)
block|}
block|,
block|{
literal|"m250"
block|,
operator|&
name|legacy_cpu
block|,
name|ARM_ARCH_V2S
block|,
name|N_
argument_list|(
literal|"use -mcpu=arm250"
argument_list|)
block|}
block|,
block|{
literal|"marm3"
block|,
operator|&
name|legacy_cpu
block|,
name|ARM_ARCH_V2S
block|,
name|N_
argument_list|(
literal|"use -mcpu=arm3"
argument_list|)
block|}
block|,
block|{
literal|"m3"
block|,
operator|&
name|legacy_cpu
block|,
name|ARM_ARCH_V2S
block|,
name|N_
argument_list|(
literal|"use -mcpu=arm3"
argument_list|)
block|}
block|,
block|{
literal|"marm6"
block|,
operator|&
name|legacy_cpu
block|,
name|ARM_ARCH_V3
block|,
name|N_
argument_list|(
literal|"use -mcpu=arm6"
argument_list|)
block|}
block|,
block|{
literal|"m6"
block|,
operator|&
name|legacy_cpu
block|,
name|ARM_ARCH_V3
block|,
name|N_
argument_list|(
literal|"use -mcpu=arm6"
argument_list|)
block|}
block|,
block|{
literal|"marm600"
block|,
operator|&
name|legacy_cpu
block|,
name|ARM_ARCH_V3
block|,
name|N_
argument_list|(
literal|"use -mcpu=arm600"
argument_list|)
block|}
block|,
block|{
literal|"m600"
block|,
operator|&
name|legacy_cpu
block|,
name|ARM_ARCH_V3
block|,
name|N_
argument_list|(
literal|"use -mcpu=arm600"
argument_list|)
block|}
block|,
block|{
literal|"marm610"
block|,
operator|&
name|legacy_cpu
block|,
name|ARM_ARCH_V3
block|,
name|N_
argument_list|(
literal|"use -mcpu=arm610"
argument_list|)
block|}
block|,
block|{
literal|"m610"
block|,
operator|&
name|legacy_cpu
block|,
name|ARM_ARCH_V3
block|,
name|N_
argument_list|(
literal|"use -mcpu=arm610"
argument_list|)
block|}
block|,
block|{
literal|"marm620"
block|,
operator|&
name|legacy_cpu
block|,
name|ARM_ARCH_V3
block|,
name|N_
argument_list|(
literal|"use -mcpu=arm620"
argument_list|)
block|}
block|,
block|{
literal|"m620"
block|,
operator|&
name|legacy_cpu
block|,
name|ARM_ARCH_V3
block|,
name|N_
argument_list|(
literal|"use -mcpu=arm620"
argument_list|)
block|}
block|,
block|{
literal|"marm7"
block|,
operator|&
name|legacy_cpu
block|,
name|ARM_ARCH_V3
block|,
name|N_
argument_list|(
literal|"use -mcpu=arm7"
argument_list|)
block|}
block|,
block|{
literal|"m7"
block|,
operator|&
name|legacy_cpu
block|,
name|ARM_ARCH_V3
block|,
name|N_
argument_list|(
literal|"use -mcpu=arm7"
argument_list|)
block|}
block|,
block|{
literal|"marm70"
block|,
operator|&
name|legacy_cpu
block|,
name|ARM_ARCH_V3
block|,
name|N_
argument_list|(
literal|"use -mcpu=arm70"
argument_list|)
block|}
block|,
block|{
literal|"m70"
block|,
operator|&
name|legacy_cpu
block|,
name|ARM_ARCH_V3
block|,
name|N_
argument_list|(
literal|"use -mcpu=arm70"
argument_list|)
block|}
block|,
block|{
literal|"marm700"
block|,
operator|&
name|legacy_cpu
block|,
name|ARM_ARCH_V3
block|,
name|N_
argument_list|(
literal|"use -mcpu=arm700"
argument_list|)
block|}
block|,
block|{
literal|"m700"
block|,
operator|&
name|legacy_cpu
block|,
name|ARM_ARCH_V3
block|,
name|N_
argument_list|(
literal|"use -mcpu=arm700"
argument_list|)
block|}
block|,
block|{
literal|"marm700i"
block|,
operator|&
name|legacy_cpu
block|,
name|ARM_ARCH_V3
block|,
name|N_
argument_list|(
literal|"use -mcpu=arm700i"
argument_list|)
block|}
block|,
block|{
literal|"m700i"
block|,
operator|&
name|legacy_cpu
block|,
name|ARM_ARCH_V3
block|,
name|N_
argument_list|(
literal|"use -mcpu=arm700i"
argument_list|)
block|}
block|,
block|{
literal|"marm710"
block|,
operator|&
name|legacy_cpu
block|,
name|ARM_ARCH_V3
block|,
name|N_
argument_list|(
literal|"use -mcpu=arm710"
argument_list|)
block|}
block|,
block|{
literal|"m710"
block|,
operator|&
name|legacy_cpu
block|,
name|ARM_ARCH_V3
block|,
name|N_
argument_list|(
literal|"use -mcpu=arm710"
argument_list|)
block|}
block|,
block|{
literal|"marm710c"
block|,
operator|&
name|legacy_cpu
block|,
name|ARM_ARCH_V3
block|,
name|N_
argument_list|(
literal|"use -mcpu=arm710c"
argument_list|)
block|}
block|,
block|{
literal|"m710c"
block|,
operator|&
name|legacy_cpu
block|,
name|ARM_ARCH_V3
block|,
name|N_
argument_list|(
literal|"use -mcpu=arm710c"
argument_list|)
block|}
block|,
block|{
literal|"marm720"
block|,
operator|&
name|legacy_cpu
block|,
name|ARM_ARCH_V3
block|,
name|N_
argument_list|(
literal|"use -mcpu=arm720"
argument_list|)
block|}
block|,
block|{
literal|"m720"
block|,
operator|&
name|legacy_cpu
block|,
name|ARM_ARCH_V3
block|,
name|N_
argument_list|(
literal|"use -mcpu=arm720"
argument_list|)
block|}
block|,
block|{
literal|"marm7d"
block|,
operator|&
name|legacy_cpu
block|,
name|ARM_ARCH_V3
block|,
name|N_
argument_list|(
literal|"use -mcpu=arm7d"
argument_list|)
block|}
block|,
block|{
literal|"m7d"
block|,
operator|&
name|legacy_cpu
block|,
name|ARM_ARCH_V3
block|,
name|N_
argument_list|(
literal|"use -mcpu=arm7d"
argument_list|)
block|}
block|,
block|{
literal|"marm7di"
block|,
operator|&
name|legacy_cpu
block|,
name|ARM_ARCH_V3
block|,
name|N_
argument_list|(
literal|"use -mcpu=arm7di"
argument_list|)
block|}
block|,
block|{
literal|"m7di"
block|,
operator|&
name|legacy_cpu
block|,
name|ARM_ARCH_V3
block|,
name|N_
argument_list|(
literal|"use -mcpu=arm7di"
argument_list|)
block|}
block|,
block|{
literal|"marm7m"
block|,
operator|&
name|legacy_cpu
block|,
name|ARM_ARCH_V3M
block|,
name|N_
argument_list|(
literal|"use -mcpu=arm7m"
argument_list|)
block|}
block|,
block|{
literal|"m7m"
block|,
operator|&
name|legacy_cpu
block|,
name|ARM_ARCH_V3M
block|,
name|N_
argument_list|(
literal|"use -mcpu=arm7m"
argument_list|)
block|}
block|,
block|{
literal|"marm7dm"
block|,
operator|&
name|legacy_cpu
block|,
name|ARM_ARCH_V3M
block|,
name|N_
argument_list|(
literal|"use -mcpu=arm7dm"
argument_list|)
block|}
block|,
block|{
literal|"m7dm"
block|,
operator|&
name|legacy_cpu
block|,
name|ARM_ARCH_V3M
block|,
name|N_
argument_list|(
literal|"use -mcpu=arm7dm"
argument_list|)
block|}
block|,
block|{
literal|"marm7dmi"
block|,
operator|&
name|legacy_cpu
block|,
name|ARM_ARCH_V3M
block|,
name|N_
argument_list|(
literal|"use -mcpu=arm7dmi"
argument_list|)
block|}
block|,
block|{
literal|"m7dmi"
block|,
operator|&
name|legacy_cpu
block|,
name|ARM_ARCH_V3M
block|,
name|N_
argument_list|(
literal|"use -mcpu=arm7dmi"
argument_list|)
block|}
block|,
block|{
literal|"marm7100"
block|,
operator|&
name|legacy_cpu
block|,
name|ARM_ARCH_V3
block|,
name|N_
argument_list|(
literal|"use -mcpu=arm7100"
argument_list|)
block|}
block|,
block|{
literal|"m7100"
block|,
operator|&
name|legacy_cpu
block|,
name|ARM_ARCH_V3
block|,
name|N_
argument_list|(
literal|"use -mcpu=arm7100"
argument_list|)
block|}
block|,
block|{
literal|"marm7500"
block|,
operator|&
name|legacy_cpu
block|,
name|ARM_ARCH_V3
block|,
name|N_
argument_list|(
literal|"use -mcpu=arm7500"
argument_list|)
block|}
block|,
block|{
literal|"m7500"
block|,
operator|&
name|legacy_cpu
block|,
name|ARM_ARCH_V3
block|,
name|N_
argument_list|(
literal|"use -mcpu=arm7500"
argument_list|)
block|}
block|,
block|{
literal|"marm7500fe"
block|,
operator|&
name|legacy_cpu
block|,
name|ARM_ARCH_V3
block|,
name|N_
argument_list|(
literal|"use -mcpu=arm7500fe"
argument_list|)
block|}
block|,
block|{
literal|"m7500fe"
block|,
operator|&
name|legacy_cpu
block|,
name|ARM_ARCH_V3
block|,
name|N_
argument_list|(
literal|"use -mcpu=arm7500fe"
argument_list|)
block|}
block|,
block|{
literal|"marm7t"
block|,
operator|&
name|legacy_cpu
block|,
name|ARM_ARCH_V4T
block|,
name|N_
argument_list|(
literal|"use -mcpu=arm7tdmi"
argument_list|)
block|}
block|,
block|{
literal|"m7t"
block|,
operator|&
name|legacy_cpu
block|,
name|ARM_ARCH_V4T
block|,
name|N_
argument_list|(
literal|"use -mcpu=arm7tdmi"
argument_list|)
block|}
block|,
block|{
literal|"marm7tdmi"
block|,
operator|&
name|legacy_cpu
block|,
name|ARM_ARCH_V4T
block|,
name|N_
argument_list|(
literal|"use -mcpu=arm7tdmi"
argument_list|)
block|}
block|,
block|{
literal|"m7tdmi"
block|,
operator|&
name|legacy_cpu
block|,
name|ARM_ARCH_V4T
block|,
name|N_
argument_list|(
literal|"use -mcpu=arm7tdmi"
argument_list|)
block|}
block|,
block|{
literal|"marm710t"
block|,
operator|&
name|legacy_cpu
block|,
name|ARM_ARCH_V4T
block|,
name|N_
argument_list|(
literal|"use -mcpu=arm710t"
argument_list|)
block|}
block|,
block|{
literal|"m710t"
block|,
operator|&
name|legacy_cpu
block|,
name|ARM_ARCH_V4T
block|,
name|N_
argument_list|(
literal|"use -mcpu=arm710t"
argument_list|)
block|}
block|,
block|{
literal|"marm720t"
block|,
operator|&
name|legacy_cpu
block|,
name|ARM_ARCH_V4T
block|,
name|N_
argument_list|(
literal|"use -mcpu=arm720t"
argument_list|)
block|}
block|,
block|{
literal|"m720t"
block|,
operator|&
name|legacy_cpu
block|,
name|ARM_ARCH_V4T
block|,
name|N_
argument_list|(
literal|"use -mcpu=arm720t"
argument_list|)
block|}
block|,
block|{
literal|"marm740t"
block|,
operator|&
name|legacy_cpu
block|,
name|ARM_ARCH_V4T
block|,
name|N_
argument_list|(
literal|"use -mcpu=arm740t"
argument_list|)
block|}
block|,
block|{
literal|"m740t"
block|,
operator|&
name|legacy_cpu
block|,
name|ARM_ARCH_V4T
block|,
name|N_
argument_list|(
literal|"use -mcpu=arm740t"
argument_list|)
block|}
block|,
block|{
literal|"marm8"
block|,
operator|&
name|legacy_cpu
block|,
name|ARM_ARCH_V4
block|,
name|N_
argument_list|(
literal|"use -mcpu=arm8"
argument_list|)
block|}
block|,
block|{
literal|"m8"
block|,
operator|&
name|legacy_cpu
block|,
name|ARM_ARCH_V4
block|,
name|N_
argument_list|(
literal|"use -mcpu=arm8"
argument_list|)
block|}
block|,
block|{
literal|"marm810"
block|,
operator|&
name|legacy_cpu
block|,
name|ARM_ARCH_V4
block|,
name|N_
argument_list|(
literal|"use -mcpu=arm810"
argument_list|)
block|}
block|,
block|{
literal|"m810"
block|,
operator|&
name|legacy_cpu
block|,
name|ARM_ARCH_V4
block|,
name|N_
argument_list|(
literal|"use -mcpu=arm810"
argument_list|)
block|}
block|,
block|{
literal|"marm9"
block|,
operator|&
name|legacy_cpu
block|,
name|ARM_ARCH_V4T
block|,
name|N_
argument_list|(
literal|"use -mcpu=arm9"
argument_list|)
block|}
block|,
block|{
literal|"m9"
block|,
operator|&
name|legacy_cpu
block|,
name|ARM_ARCH_V4T
block|,
name|N_
argument_list|(
literal|"use -mcpu=arm9"
argument_list|)
block|}
block|,
block|{
literal|"marm9tdmi"
block|,
operator|&
name|legacy_cpu
block|,
name|ARM_ARCH_V4T
block|,
name|N_
argument_list|(
literal|"use -mcpu=arm9tdmi"
argument_list|)
block|}
block|,
block|{
literal|"m9tdmi"
block|,
operator|&
name|legacy_cpu
block|,
name|ARM_ARCH_V4T
block|,
name|N_
argument_list|(
literal|"use -mcpu=arm9tdmi"
argument_list|)
block|}
block|,
block|{
literal|"marm920"
block|,
operator|&
name|legacy_cpu
block|,
name|ARM_ARCH_V4T
block|,
name|N_
argument_list|(
literal|"use -mcpu=arm920"
argument_list|)
block|}
block|,
block|{
literal|"m920"
block|,
operator|&
name|legacy_cpu
block|,
name|ARM_ARCH_V4T
block|,
name|N_
argument_list|(
literal|"use -mcpu=arm920"
argument_list|)
block|}
block|,
block|{
literal|"marm940"
block|,
operator|&
name|legacy_cpu
block|,
name|ARM_ARCH_V4T
block|,
name|N_
argument_list|(
literal|"use -mcpu=arm940"
argument_list|)
block|}
block|,
block|{
literal|"m940"
block|,
operator|&
name|legacy_cpu
block|,
name|ARM_ARCH_V4T
block|,
name|N_
argument_list|(
literal|"use -mcpu=arm940"
argument_list|)
block|}
block|,
block|{
literal|"mstrongarm"
block|,
operator|&
name|legacy_cpu
block|,
name|ARM_ARCH_V4
block|,
name|N_
argument_list|(
literal|"use -mcpu=strongarm"
argument_list|)
block|}
block|,
block|{
literal|"mstrongarm110"
block|,
operator|&
name|legacy_cpu
block|,
name|ARM_ARCH_V4
block|,
name|N_
argument_list|(
literal|"use -mcpu=strongarm110"
argument_list|)
block|}
block|,
block|{
literal|"mstrongarm1100"
block|,
operator|&
name|legacy_cpu
block|,
name|ARM_ARCH_V4
block|,
name|N_
argument_list|(
literal|"use -mcpu=strongarm1100"
argument_list|)
block|}
block|,
block|{
literal|"mstrongarm1110"
block|,
operator|&
name|legacy_cpu
block|,
name|ARM_ARCH_V4
block|,
name|N_
argument_list|(
literal|"use -mcpu=strongarm1110"
argument_list|)
block|}
block|,
block|{
literal|"mxscale"
block|,
operator|&
name|legacy_cpu
block|,
name|ARM_ARCH_XSCALE
block|,
name|N_
argument_list|(
literal|"use -mcpu=xscale"
argument_list|)
block|}
block|,
block|{
literal|"miwmmxt"
block|,
operator|&
name|legacy_cpu
block|,
name|ARM_ARCH_IWMMXT
block|,
name|N_
argument_list|(
literal|"use -mcpu=iwmmxt"
argument_list|)
block|}
block|,
block|{
literal|"mall"
block|,
operator|&
name|legacy_cpu
block|,
name|ARM_ANY
block|,
name|N_
argument_list|(
literal|"use -mcpu=all"
argument_list|)
block|}
block|,
comment|/* Architecture variants -- don't add any more to this list either.  */
block|{
literal|"mv2"
block|,
operator|&
name|legacy_cpu
block|,
name|ARM_ARCH_V2
block|,
name|N_
argument_list|(
literal|"use -march=armv2"
argument_list|)
block|}
block|,
block|{
literal|"marmv2"
block|,
operator|&
name|legacy_cpu
block|,
name|ARM_ARCH_V2
block|,
name|N_
argument_list|(
literal|"use -march=armv2"
argument_list|)
block|}
block|,
block|{
literal|"mv2a"
block|,
operator|&
name|legacy_cpu
block|,
name|ARM_ARCH_V2S
block|,
name|N_
argument_list|(
literal|"use -march=armv2a"
argument_list|)
block|}
block|,
block|{
literal|"marmv2a"
block|,
operator|&
name|legacy_cpu
block|,
name|ARM_ARCH_V2S
block|,
name|N_
argument_list|(
literal|"use -march=armv2a"
argument_list|)
block|}
block|,
block|{
literal|"mv3"
block|,
operator|&
name|legacy_cpu
block|,
name|ARM_ARCH_V3
block|,
name|N_
argument_list|(
literal|"use -march=armv3"
argument_list|)
block|}
block|,
block|{
literal|"marmv3"
block|,
operator|&
name|legacy_cpu
block|,
name|ARM_ARCH_V3
block|,
name|N_
argument_list|(
literal|"use -march=armv3"
argument_list|)
block|}
block|,
block|{
literal|"mv3m"
block|,
operator|&
name|legacy_cpu
block|,
name|ARM_ARCH_V3M
block|,
name|N_
argument_list|(
literal|"use -march=armv3m"
argument_list|)
block|}
block|,
block|{
literal|"marmv3m"
block|,
operator|&
name|legacy_cpu
block|,
name|ARM_ARCH_V3M
block|,
name|N_
argument_list|(
literal|"use -march=armv3m"
argument_list|)
block|}
block|,
block|{
literal|"mv4"
block|,
operator|&
name|legacy_cpu
block|,
name|ARM_ARCH_V4
block|,
name|N_
argument_list|(
literal|"use -march=armv4"
argument_list|)
block|}
block|,
block|{
literal|"marmv4"
block|,
operator|&
name|legacy_cpu
block|,
name|ARM_ARCH_V4
block|,
name|N_
argument_list|(
literal|"use -march=armv4"
argument_list|)
block|}
block|,
block|{
literal|"mv4t"
block|,
operator|&
name|legacy_cpu
block|,
name|ARM_ARCH_V4T
block|,
name|N_
argument_list|(
literal|"use -march=armv4t"
argument_list|)
block|}
block|,
block|{
literal|"marmv4t"
block|,
operator|&
name|legacy_cpu
block|,
name|ARM_ARCH_V4T
block|,
name|N_
argument_list|(
literal|"use -march=armv4t"
argument_list|)
block|}
block|,
block|{
literal|"mv5"
block|,
operator|&
name|legacy_cpu
block|,
name|ARM_ARCH_V5
block|,
name|N_
argument_list|(
literal|"use -march=armv5"
argument_list|)
block|}
block|,
block|{
literal|"marmv5"
block|,
operator|&
name|legacy_cpu
block|,
name|ARM_ARCH_V5
block|,
name|N_
argument_list|(
literal|"use -march=armv5"
argument_list|)
block|}
block|,
block|{
literal|"mv5t"
block|,
operator|&
name|legacy_cpu
block|,
name|ARM_ARCH_V5T
block|,
name|N_
argument_list|(
literal|"use -march=armv5t"
argument_list|)
block|}
block|,
block|{
literal|"marmv5t"
block|,
operator|&
name|legacy_cpu
block|,
name|ARM_ARCH_V5T
block|,
name|N_
argument_list|(
literal|"use -march=armv5t"
argument_list|)
block|}
block|,
block|{
literal|"mv5e"
block|,
operator|&
name|legacy_cpu
block|,
name|ARM_ARCH_V5TE
block|,
name|N_
argument_list|(
literal|"use -march=armv5te"
argument_list|)
block|}
block|,
block|{
literal|"marmv5e"
block|,
operator|&
name|legacy_cpu
block|,
name|ARM_ARCH_V5TE
block|,
name|N_
argument_list|(
literal|"use -march=armv5te"
argument_list|)
block|}
block|,
comment|/* Floating point variants -- don't add any more to this list either.	 */
block|{
literal|"mfpe-old"
block|,
operator|&
name|legacy_fpu
block|,
name|FPU_ARCH_FPE
block|,
name|N_
argument_list|(
literal|"use -mfpu=fpe"
argument_list|)
block|}
block|,
block|{
literal|"mfpa10"
block|,
operator|&
name|legacy_fpu
block|,
name|FPU_ARCH_FPA
block|,
name|N_
argument_list|(
literal|"use -mfpu=fpa10"
argument_list|)
block|}
block|,
block|{
literal|"mfpa11"
block|,
operator|&
name|legacy_fpu
block|,
name|FPU_ARCH_FPA
block|,
name|N_
argument_list|(
literal|"use -mfpu=fpa11"
argument_list|)
block|}
block|,
block|{
literal|"mno-fpu"
block|,
operator|&
name|legacy_fpu
block|,
name|ARM_ARCH_NONE
block|,
name|N_
argument_list|(
literal|"use either -mfpu=softfpa or -mfpu=softvfp"
argument_list|)
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
name|ARM_ARCH_NONE
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|arm_cpu_option_table
block|{
name|char
modifier|*
name|name
decl_stmt|;
specifier|const
name|arm_feature_set
name|value
decl_stmt|;
comment|/* For some CPUs we assume an FPU unless the user explicitly sets      -mfpu=...	*/
specifier|const
name|arm_feature_set
name|default_fpu
decl_stmt|;
comment|/* The canonical name of the CPU, or NULL to use NAME converted to upper      case.  */
specifier|const
name|char
modifier|*
name|canonical_name
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* This list should, at a minimum, contain all the cpu names    recognized by GCC.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|arm_cpu_option_table
name|arm_cpus
index|[]
init|=
block|{
block|{
literal|"all"
block|,
name|ARM_ANY
block|,
name|FPU_ARCH_FPA
block|,
name|NULL
block|}
block|,
block|{
literal|"arm1"
block|,
name|ARM_ARCH_V1
block|,
name|FPU_ARCH_FPA
block|,
name|NULL
block|}
block|,
block|{
literal|"arm2"
block|,
name|ARM_ARCH_V2
block|,
name|FPU_ARCH_FPA
block|,
name|NULL
block|}
block|,
block|{
literal|"arm250"
block|,
name|ARM_ARCH_V2S
block|,
name|FPU_ARCH_FPA
block|,
name|NULL
block|}
block|,
block|{
literal|"arm3"
block|,
name|ARM_ARCH_V2S
block|,
name|FPU_ARCH_FPA
block|,
name|NULL
block|}
block|,
block|{
literal|"arm6"
block|,
name|ARM_ARCH_V3
block|,
name|FPU_ARCH_FPA
block|,
name|NULL
block|}
block|,
block|{
literal|"arm60"
block|,
name|ARM_ARCH_V3
block|,
name|FPU_ARCH_FPA
block|,
name|NULL
block|}
block|,
block|{
literal|"arm600"
block|,
name|ARM_ARCH_V3
block|,
name|FPU_ARCH_FPA
block|,
name|NULL
block|}
block|,
block|{
literal|"arm610"
block|,
name|ARM_ARCH_V3
block|,
name|FPU_ARCH_FPA
block|,
name|NULL
block|}
block|,
block|{
literal|"arm620"
block|,
name|ARM_ARCH_V3
block|,
name|FPU_ARCH_FPA
block|,
name|NULL
block|}
block|,
block|{
literal|"arm7"
block|,
name|ARM_ARCH_V3
block|,
name|FPU_ARCH_FPA
block|,
name|NULL
block|}
block|,
block|{
literal|"arm7m"
block|,
name|ARM_ARCH_V3M
block|,
name|FPU_ARCH_FPA
block|,
name|NULL
block|}
block|,
block|{
literal|"arm7d"
block|,
name|ARM_ARCH_V3
block|,
name|FPU_ARCH_FPA
block|,
name|NULL
block|}
block|,
block|{
literal|"arm7dm"
block|,
name|ARM_ARCH_V3M
block|,
name|FPU_ARCH_FPA
block|,
name|NULL
block|}
block|,
block|{
literal|"arm7di"
block|,
name|ARM_ARCH_V3
block|,
name|FPU_ARCH_FPA
block|,
name|NULL
block|}
block|,
block|{
literal|"arm7dmi"
block|,
name|ARM_ARCH_V3M
block|,
name|FPU_ARCH_FPA
block|,
name|NULL
block|}
block|,
block|{
literal|"arm70"
block|,
name|ARM_ARCH_V3
block|,
name|FPU_ARCH_FPA
block|,
name|NULL
block|}
block|,
block|{
literal|"arm700"
block|,
name|ARM_ARCH_V3
block|,
name|FPU_ARCH_FPA
block|,
name|NULL
block|}
block|,
block|{
literal|"arm700i"
block|,
name|ARM_ARCH_V3
block|,
name|FPU_ARCH_FPA
block|,
name|NULL
block|}
block|,
block|{
literal|"arm710"
block|,
name|ARM_ARCH_V3
block|,
name|FPU_ARCH_FPA
block|,
name|NULL
block|}
block|,
block|{
literal|"arm710t"
block|,
name|ARM_ARCH_V4T
block|,
name|FPU_ARCH_FPA
block|,
name|NULL
block|}
block|,
block|{
literal|"arm720"
block|,
name|ARM_ARCH_V3
block|,
name|FPU_ARCH_FPA
block|,
name|NULL
block|}
block|,
block|{
literal|"arm720t"
block|,
name|ARM_ARCH_V4T
block|,
name|FPU_ARCH_FPA
block|,
name|NULL
block|}
block|,
block|{
literal|"arm740t"
block|,
name|ARM_ARCH_V4T
block|,
name|FPU_ARCH_FPA
block|,
name|NULL
block|}
block|,
block|{
literal|"arm710c"
block|,
name|ARM_ARCH_V3
block|,
name|FPU_ARCH_FPA
block|,
name|NULL
block|}
block|,
block|{
literal|"arm7100"
block|,
name|ARM_ARCH_V3
block|,
name|FPU_ARCH_FPA
block|,
name|NULL
block|}
block|,
block|{
literal|"arm7500"
block|,
name|ARM_ARCH_V3
block|,
name|FPU_ARCH_FPA
block|,
name|NULL
block|}
block|,
block|{
literal|"arm7500fe"
block|,
name|ARM_ARCH_V3
block|,
name|FPU_ARCH_FPA
block|,
name|NULL
block|}
block|,
block|{
literal|"arm7t"
block|,
name|ARM_ARCH_V4T
block|,
name|FPU_ARCH_FPA
block|,
name|NULL
block|}
block|,
block|{
literal|"arm7tdmi"
block|,
name|ARM_ARCH_V4T
block|,
name|FPU_ARCH_FPA
block|,
name|NULL
block|}
block|,
block|{
literal|"arm7tdmi-s"
block|,
name|ARM_ARCH_V4T
block|,
name|FPU_ARCH_FPA
block|,
name|NULL
block|}
block|,
block|{
literal|"arm8"
block|,
name|ARM_ARCH_V4
block|,
name|FPU_ARCH_FPA
block|,
name|NULL
block|}
block|,
block|{
literal|"arm810"
block|,
name|ARM_ARCH_V4
block|,
name|FPU_ARCH_FPA
block|,
name|NULL
block|}
block|,
block|{
literal|"strongarm"
block|,
name|ARM_ARCH_V4
block|,
name|FPU_ARCH_FPA
block|,
name|NULL
block|}
block|,
block|{
literal|"strongarm1"
block|,
name|ARM_ARCH_V4
block|,
name|FPU_ARCH_FPA
block|,
name|NULL
block|}
block|,
block|{
literal|"strongarm110"
block|,
name|ARM_ARCH_V4
block|,
name|FPU_ARCH_FPA
block|,
name|NULL
block|}
block|,
block|{
literal|"strongarm1100"
block|,
name|ARM_ARCH_V4
block|,
name|FPU_ARCH_FPA
block|,
name|NULL
block|}
block|,
block|{
literal|"strongarm1110"
block|,
name|ARM_ARCH_V4
block|,
name|FPU_ARCH_FPA
block|,
name|NULL
block|}
block|,
block|{
literal|"arm9"
block|,
name|ARM_ARCH_V4T
block|,
name|FPU_ARCH_FPA
block|,
name|NULL
block|}
block|,
block|{
literal|"arm920"
block|,
name|ARM_ARCH_V4T
block|,
name|FPU_ARCH_FPA
block|,
literal|"ARM920T"
block|}
block|,
block|{
literal|"arm920t"
block|,
name|ARM_ARCH_V4T
block|,
name|FPU_ARCH_FPA
block|,
name|NULL
block|}
block|,
block|{
literal|"arm922t"
block|,
name|ARM_ARCH_V4T
block|,
name|FPU_ARCH_FPA
block|,
name|NULL
block|}
block|,
block|{
literal|"arm940t"
block|,
name|ARM_ARCH_V4T
block|,
name|FPU_ARCH_FPA
block|,
name|NULL
block|}
block|,
block|{
literal|"arm9tdmi"
block|,
name|ARM_ARCH_V4T
block|,
name|FPU_ARCH_FPA
block|,
name|NULL
block|}
block|,
comment|/* For V5 or later processors we default to using VFP; but the user      should really set the FPU type explicitly.	 */
block|{
literal|"arm9e-r0"
block|,
name|ARM_ARCH_V5TExP
block|,
name|FPU_ARCH_VFP_V2
block|,
name|NULL
block|}
block|,
block|{
literal|"arm9e"
block|,
name|ARM_ARCH_V5TE
block|,
name|FPU_ARCH_VFP_V2
block|,
name|NULL
block|}
block|,
block|{
literal|"arm926ej"
block|,
name|ARM_ARCH_V5TEJ
block|,
name|FPU_ARCH_VFP_V2
block|,
literal|"ARM926EJ-S"
block|}
block|,
block|{
literal|"arm926ejs"
block|,
name|ARM_ARCH_V5TEJ
block|,
name|FPU_ARCH_VFP_V2
block|,
literal|"ARM926EJ-S"
block|}
block|,
block|{
literal|"arm926ej-s"
block|,
name|ARM_ARCH_V5TEJ
block|,
name|FPU_ARCH_VFP_V2
block|,
name|NULL
block|}
block|,
block|{
literal|"arm946e-r0"
block|,
name|ARM_ARCH_V5TExP
block|,
name|FPU_ARCH_VFP_V2
block|,
name|NULL
block|}
block|,
block|{
literal|"arm946e"
block|,
name|ARM_ARCH_V5TE
block|,
name|FPU_ARCH_VFP_V2
block|,
literal|"ARM946E-S"
block|}
block|,
block|{
literal|"arm946e-s"
block|,
name|ARM_ARCH_V5TE
block|,
name|FPU_ARCH_VFP_V2
block|,
name|NULL
block|}
block|,
block|{
literal|"arm966e-r0"
block|,
name|ARM_ARCH_V5TExP
block|,
name|FPU_ARCH_VFP_V2
block|,
name|NULL
block|}
block|,
block|{
literal|"arm966e"
block|,
name|ARM_ARCH_V5TE
block|,
name|FPU_ARCH_VFP_V2
block|,
literal|"ARM966E-S"
block|}
block|,
block|{
literal|"arm966e-s"
block|,
name|ARM_ARCH_V5TE
block|,
name|FPU_ARCH_VFP_V2
block|,
name|NULL
block|}
block|,
block|{
literal|"arm968e-s"
block|,
name|ARM_ARCH_V5TE
block|,
name|FPU_ARCH_VFP_V2
block|,
name|NULL
block|}
block|,
block|{
literal|"arm10t"
block|,
name|ARM_ARCH_V5T
block|,
name|FPU_ARCH_VFP_V1
block|,
name|NULL
block|}
block|,
block|{
literal|"arm10tdmi"
block|,
name|ARM_ARCH_V5T
block|,
name|FPU_ARCH_VFP_V1
block|,
name|NULL
block|}
block|,
block|{
literal|"arm10e"
block|,
name|ARM_ARCH_V5TE
block|,
name|FPU_ARCH_VFP_V2
block|,
name|NULL
block|}
block|,
block|{
literal|"arm1020"
block|,
name|ARM_ARCH_V5TE
block|,
name|FPU_ARCH_VFP_V2
block|,
literal|"ARM1020E"
block|}
block|,
block|{
literal|"arm1020t"
block|,
name|ARM_ARCH_V5T
block|,
name|FPU_ARCH_VFP_V1
block|,
name|NULL
block|}
block|,
block|{
literal|"arm1020e"
block|,
name|ARM_ARCH_V5TE
block|,
name|FPU_ARCH_VFP_V2
block|,
name|NULL
block|}
block|,
block|{
literal|"arm1022e"
block|,
name|ARM_ARCH_V5TE
block|,
name|FPU_ARCH_VFP_V2
block|,
name|NULL
block|}
block|,
block|{
literal|"arm1026ejs"
block|,
name|ARM_ARCH_V5TEJ
block|,
name|FPU_ARCH_VFP_V2
block|,
literal|"ARM1026EJ-S"
block|}
block|,
block|{
literal|"arm1026ej-s"
block|,
name|ARM_ARCH_V5TEJ
block|,
name|FPU_ARCH_VFP_V2
block|,
name|NULL
block|}
block|,
block|{
literal|"arm1136js"
block|,
name|ARM_ARCH_V6
block|,
name|FPU_NONE
block|,
literal|"ARM1136J-S"
block|}
block|,
block|{
literal|"arm1136j-s"
block|,
name|ARM_ARCH_V6
block|,
name|FPU_NONE
block|,
name|NULL
block|}
block|,
block|{
literal|"arm1136jfs"
block|,
name|ARM_ARCH_V6
block|,
name|FPU_ARCH_VFP_V2
block|,
literal|"ARM1136JF-S"
block|}
block|,
block|{
literal|"arm1136jf-s"
block|,
name|ARM_ARCH_V6
block|,
name|FPU_ARCH_VFP_V2
block|,
name|NULL
block|}
block|,
block|{
literal|"mpcore"
block|,
name|ARM_ARCH_V6K
block|,
name|FPU_ARCH_VFP_V2
block|,
name|NULL
block|}
block|,
block|{
literal|"mpcorenovfp"
block|,
name|ARM_ARCH_V6K
block|,
name|FPU_NONE
block|,
name|NULL
block|}
block|,
block|{
literal|"arm1156t2-s"
block|,
name|ARM_ARCH_V6T2
block|,
name|FPU_NONE
block|,
name|NULL
block|}
block|,
block|{
literal|"arm1156t2f-s"
block|,
name|ARM_ARCH_V6T2
block|,
name|FPU_ARCH_VFP_V2
block|,
name|NULL
block|}
block|,
block|{
literal|"arm1176jz-s"
block|,
name|ARM_ARCH_V6ZK
block|,
name|FPU_NONE
block|,
name|NULL
block|}
block|,
block|{
literal|"arm1176jzf-s"
block|,
name|ARM_ARCH_V6ZK
block|,
name|FPU_ARCH_VFP_V2
block|,
name|NULL
block|}
block|,
block|{
literal|"cortex-a8"
block|,
name|ARM_ARCH_V7A
block|,
name|ARM_FEATURE
argument_list|(
literal|0
argument_list|,
name|FPU_VFP_V3
operator||
name|FPU_NEON_EXT_V1
argument_list|)
block|,
name|NULL
block|}
block|,
block|{
literal|"cortex-a9"
block|,
name|ARM_ARCH_V7A
block|,
name|ARM_FEATURE
argument_list|(
literal|0
argument_list|,
name|FPU_VFP_V3
operator||
name|FPU_NEON_EXT_V1
argument_list|)
block|,
name|NULL
block|}
block|,
block|{
literal|"cortex-r4"
block|,
name|ARM_ARCH_V7R
block|,
name|FPU_NONE
block|,
name|NULL
block|}
block|,
block|{
literal|"cortex-m3"
block|,
name|ARM_ARCH_V7M
block|,
name|FPU_NONE
block|,
name|NULL
block|}
block|,
comment|/* ??? XSCALE is really an architecture.  */
block|{
literal|"xscale"
block|,
name|ARM_ARCH_XSCALE
block|,
name|FPU_ARCH_VFP_V2
block|,
name|NULL
block|}
block|,
comment|/* ??? iwmmxt is not a processor.  */
block|{
literal|"iwmmxt"
block|,
name|ARM_ARCH_IWMMXT
block|,
name|FPU_ARCH_VFP_V2
block|,
name|NULL
block|}
block|,
block|{
literal|"iwmmxt2"
block|,
name|ARM_ARCH_IWMMXT2
block|,
name|FPU_ARCH_VFP_V2
block|,
name|NULL
block|}
block|,
block|{
literal|"i80200"
block|,
name|ARM_ARCH_XSCALE
block|,
name|FPU_ARCH_VFP_V2
block|,
name|NULL
block|}
block|,
comment|/* Maverick */
block|{
literal|"ep9312"
block|,
name|ARM_FEATURE
argument_list|(
name|ARM_AEXT_V4T
argument_list|,
name|ARM_CEXT_MAVERICK
argument_list|)
block|,
name|FPU_ARCH_MAVERICK
block|,
literal|"ARM920T"
block|}
block|,
block|{
name|NULL
block|,
name|ARM_ARCH_NONE
block|,
name|ARM_ARCH_NONE
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|arm_arch_option_table
block|{
name|char
modifier|*
name|name
decl_stmt|;
specifier|const
name|arm_feature_set
name|value
decl_stmt|;
specifier|const
name|arm_feature_set
name|default_fpu
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* This list should, at a minimum, contain all the architecture names    recognized by GCC.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|arm_arch_option_table
name|arm_archs
index|[]
init|=
block|{
block|{
literal|"all"
block|,
name|ARM_ANY
block|,
name|FPU_ARCH_FPA
block|}
block|,
block|{
literal|"armv1"
block|,
name|ARM_ARCH_V1
block|,
name|FPU_ARCH_FPA
block|}
block|,
block|{
literal|"armv2"
block|,
name|ARM_ARCH_V2
block|,
name|FPU_ARCH_FPA
block|}
block|,
block|{
literal|"armv2a"
block|,
name|ARM_ARCH_V2S
block|,
name|FPU_ARCH_FPA
block|}
block|,
block|{
literal|"armv2s"
block|,
name|ARM_ARCH_V2S
block|,
name|FPU_ARCH_FPA
block|}
block|,
block|{
literal|"armv3"
block|,
name|ARM_ARCH_V3
block|,
name|FPU_ARCH_FPA
block|}
block|,
block|{
literal|"armv3m"
block|,
name|ARM_ARCH_V3M
block|,
name|FPU_ARCH_FPA
block|}
block|,
block|{
literal|"armv4"
block|,
name|ARM_ARCH_V4
block|,
name|FPU_ARCH_FPA
block|}
block|,
block|{
literal|"armv4xm"
block|,
name|ARM_ARCH_V4xM
block|,
name|FPU_ARCH_FPA
block|}
block|,
block|{
literal|"armv4t"
block|,
name|ARM_ARCH_V4T
block|,
name|FPU_ARCH_FPA
block|}
block|,
block|{
literal|"armv4txm"
block|,
name|ARM_ARCH_V4TxM
block|,
name|FPU_ARCH_FPA
block|}
block|,
block|{
literal|"armv5"
block|,
name|ARM_ARCH_V5
block|,
name|FPU_ARCH_VFP
block|}
block|,
block|{
literal|"armv5t"
block|,
name|ARM_ARCH_V5T
block|,
name|FPU_ARCH_VFP
block|}
block|,
block|{
literal|"armv5txm"
block|,
name|ARM_ARCH_V5TxM
block|,
name|FPU_ARCH_VFP
block|}
block|,
block|{
literal|"armv5te"
block|,
name|ARM_ARCH_V5TE
block|,
name|FPU_ARCH_VFP
block|}
block|,
block|{
literal|"armv5texp"
block|,
name|ARM_ARCH_V5TExP
block|,
name|FPU_ARCH_VFP
block|}
block|,
block|{
literal|"armv5tej"
block|,
name|ARM_ARCH_V5TEJ
block|,
name|FPU_ARCH_VFP
block|}
block|,
block|{
literal|"armv6"
block|,
name|ARM_ARCH_V6
block|,
name|FPU_ARCH_VFP
block|}
block|,
block|{
literal|"armv6j"
block|,
name|ARM_ARCH_V6
block|,
name|FPU_ARCH_VFP
block|}
block|,
block|{
literal|"armv6k"
block|,
name|ARM_ARCH_V6K
block|,
name|FPU_ARCH_VFP
block|}
block|,
block|{
literal|"armv6z"
block|,
name|ARM_ARCH_V6Z
block|,
name|FPU_ARCH_VFP
block|}
block|,
block|{
literal|"armv6zk"
block|,
name|ARM_ARCH_V6ZK
block|,
name|FPU_ARCH_VFP
block|}
block|,
block|{
literal|"armv6t2"
block|,
name|ARM_ARCH_V6T2
block|,
name|FPU_ARCH_VFP
block|}
block|,
block|{
literal|"armv6kt2"
block|,
name|ARM_ARCH_V6KT2
block|,
name|FPU_ARCH_VFP
block|}
block|,
block|{
literal|"armv6zt2"
block|,
name|ARM_ARCH_V6ZT2
block|,
name|FPU_ARCH_VFP
block|}
block|,
block|{
literal|"armv6zkt2"
block|,
name|ARM_ARCH_V6ZKT2
block|,
name|FPU_ARCH_VFP
block|}
block|,
block|{
literal|"armv7"
block|,
name|ARM_ARCH_V7
block|,
name|FPU_ARCH_VFP
block|}
block|,
comment|/* The official spelling of the ARMv7 profile variants is the dashed form.      Accept the non-dashed form for compatibility with old toolchains.  */
block|{
literal|"armv7a"
block|,
name|ARM_ARCH_V7A
block|,
name|FPU_ARCH_VFP
block|}
block|,
block|{
literal|"armv7r"
block|,
name|ARM_ARCH_V7R
block|,
name|FPU_ARCH_VFP
block|}
block|,
block|{
literal|"armv7m"
block|,
name|ARM_ARCH_V7M
block|,
name|FPU_ARCH_VFP
block|}
block|,
block|{
literal|"armv7-a"
block|,
name|ARM_ARCH_V7A
block|,
name|FPU_ARCH_VFP
block|}
block|,
block|{
literal|"armv7-r"
block|,
name|ARM_ARCH_V7R
block|,
name|FPU_ARCH_VFP
block|}
block|,
block|{
literal|"armv7-m"
block|,
name|ARM_ARCH_V7M
block|,
name|FPU_ARCH_VFP
block|}
block|,
block|{
literal|"xscale"
block|,
name|ARM_ARCH_XSCALE
block|,
name|FPU_ARCH_VFP
block|}
block|,
block|{
literal|"iwmmxt"
block|,
name|ARM_ARCH_IWMMXT
block|,
name|FPU_ARCH_VFP
block|}
block|,
block|{
literal|"iwmmxt2"
block|,
name|ARM_ARCH_IWMMXT2
block|,
name|FPU_ARCH_VFP
block|}
block|,
block|{
name|NULL
block|,
name|ARM_ARCH_NONE
block|,
name|ARM_ARCH_NONE
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ISA extensions in the co-processor space.  */
end_comment

begin_struct
struct|struct
name|arm_option_cpu_value_table
block|{
name|char
modifier|*
name|name
decl_stmt|;
specifier|const
name|arm_feature_set
name|value
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|arm_option_cpu_value_table
name|arm_extensions
index|[]
init|=
block|{
block|{
literal|"maverick"
block|,
name|ARM_FEATURE
argument_list|(
literal|0
argument_list|,
argument|ARM_CEXT_MAVERICK
argument_list|)
block|}
block|,
block|{
literal|"xscale"
block|,
name|ARM_FEATURE
argument_list|(
literal|0
argument_list|,
argument|ARM_CEXT_XSCALE
argument_list|)
block|}
block|,
block|{
literal|"iwmmxt"
block|,
name|ARM_FEATURE
argument_list|(
literal|0
argument_list|,
argument|ARM_CEXT_IWMMXT
argument_list|)
block|}
block|,
block|{
literal|"iwmmxt2"
block|,
name|ARM_FEATURE
argument_list|(
literal|0
argument_list|,
argument|ARM_CEXT_IWMMXT2
argument_list|)
block|}
block|,
block|{
literal|"sec"
block|,
name|ARM_FEATURE
argument_list|(
argument|ARM_EXT_V6Z
argument_list|,
literal|0
argument_list|)
block|}
block|,
block|{
name|NULL
block|,
name|ARM_ARCH_NONE
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This list should, at a minimum, contain all the fpu names    recognized by GCC.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|arm_option_cpu_value_table
name|arm_fpus
index|[]
init|=
block|{
block|{
literal|"softfpa"
block|,
name|FPU_NONE
block|}
block|,
block|{
literal|"fpe"
block|,
name|FPU_ARCH_FPE
block|}
block|,
block|{
literal|"fpe2"
block|,
name|FPU_ARCH_FPE
block|}
block|,
block|{
literal|"fpe3"
block|,
name|FPU_ARCH_FPA
block|}
block|,
comment|/* Third release supports LFM/SFM.  */
block|{
literal|"fpa"
block|,
name|FPU_ARCH_FPA
block|}
block|,
block|{
literal|"fpa10"
block|,
name|FPU_ARCH_FPA
block|}
block|,
block|{
literal|"fpa11"
block|,
name|FPU_ARCH_FPA
block|}
block|,
block|{
literal|"arm7500fe"
block|,
name|FPU_ARCH_FPA
block|}
block|,
block|{
literal|"softvfp"
block|,
name|FPU_ARCH_VFP
block|}
block|,
block|{
literal|"softvfp+vfp"
block|,
name|FPU_ARCH_VFP_V2
block|}
block|,
block|{
literal|"vfp"
block|,
name|FPU_ARCH_VFP_V2
block|}
block|,
block|{
literal|"vfpv2"
block|,
name|FPU_ARCH_VFP_V2
block|}
block|,
block|{
literal|"vfp9"
block|,
name|FPU_ARCH_VFP_V2
block|}
block|,
block|{
literal|"vfp3"
block|,
name|FPU_ARCH_VFP_V3
block|}
block|,
block|{
literal|"vfpv3"
block|,
name|FPU_ARCH_VFP_V3
block|}
block|,
block|{
literal|"vfp10"
block|,
name|FPU_ARCH_VFP_V2
block|}
block|,
block|{
literal|"vfp10-r0"
block|,
name|FPU_ARCH_VFP_V1
block|}
block|,
block|{
literal|"vfpxd"
block|,
name|FPU_ARCH_VFP_V1xD
block|}
block|,
block|{
literal|"arm1020t"
block|,
name|FPU_ARCH_VFP_V1
block|}
block|,
block|{
literal|"arm1020e"
block|,
name|FPU_ARCH_VFP_V2
block|}
block|,
block|{
literal|"arm1136jfs"
block|,
name|FPU_ARCH_VFP_V2
block|}
block|,
block|{
literal|"arm1136jf-s"
block|,
name|FPU_ARCH_VFP_V2
block|}
block|,
block|{
literal|"maverick"
block|,
name|FPU_ARCH_MAVERICK
block|}
block|,
block|{
literal|"neon"
block|,
name|FPU_ARCH_VFP_V3_PLUS_NEON_V1
block|}
block|,
block|{
name|NULL
block|,
name|ARM_ARCH_NONE
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|arm_option_value_table
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|long
name|value
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|arm_option_value_table
name|arm_float_abis
index|[]
init|=
block|{
block|{
literal|"hard"
block|,
name|ARM_FLOAT_ABI_HARD
block|}
block|,
block|{
literal|"softfp"
block|,
name|ARM_FLOAT_ABI_SOFTFP
block|}
block|,
block|{
literal|"soft"
block|,
name|ARM_FLOAT_ABI_SOFT
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|OBJ_ELF
end_ifdef

begin_comment
comment|/* We only know how to output GNU and ver 4/5 (AAELF) formats.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|arm_option_value_table
name|arm_eabis
index|[]
init|=
block|{
block|{
literal|"gnu"
block|,
name|EF_ARM_EABI_UNKNOWN
block|}
block|,
block|{
literal|"4"
block|,
name|EF_ARM_EABI_VER4
block|}
block|,
block|{
literal|"5"
block|,
name|EF_ARM_EABI_VER5
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_struct
struct|struct
name|arm_long_option_table
block|{
name|char
modifier|*
name|option
decl_stmt|;
comment|/* Substring to match.	*/
name|char
modifier|*
name|help
decl_stmt|;
comment|/* Help information.  */
name|int
function_decl|(
modifier|*
name|func
function_decl|)
parameter_list|(
name|char
modifier|*
name|subopt
parameter_list|)
function_decl|;
comment|/* Function to decode sub-option.  */
name|char
modifier|*
name|deprecated
decl_stmt|;
comment|/* If non-null, print this message.  */
block|}
struct|;
end_struct

begin_function
specifier|static
name|int
name|arm_parse_extension
parameter_list|(
name|char
modifier|*
name|str
parameter_list|,
specifier|const
name|arm_feature_set
modifier|*
modifier|*
name|opt_p
parameter_list|)
block|{
name|arm_feature_set
modifier|*
name|ext_set
init|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|arm_feature_set
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Copy the feature set, so that we can modify it.  */
operator|*
name|ext_set
operator|=
operator|*
operator|*
name|opt_p
expr_stmt|;
operator|*
name|opt_p
operator|=
name|ext_set
expr_stmt|;
while|while
condition|(
name|str
operator|!=
name|NULL
operator|&&
operator|*
name|str
operator|!=
literal|0
condition|)
block|{
specifier|const
name|struct
name|arm_option_cpu_value_table
modifier|*
name|opt
decl_stmt|;
name|char
modifier|*
name|ext
decl_stmt|;
name|int
name|optlen
decl_stmt|;
if|if
condition|(
operator|*
name|str
operator|!=
literal|'+'
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"invalid architectural extension"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|str
operator|++
expr_stmt|;
name|ext
operator|=
name|strchr
argument_list|(
name|str
argument_list|,
literal|'+'
argument_list|)
expr_stmt|;
if|if
condition|(
name|ext
operator|!=
name|NULL
condition|)
name|optlen
operator|=
name|ext
operator|-
name|str
expr_stmt|;
else|else
name|optlen
operator|=
name|strlen
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|optlen
operator|==
literal|0
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"missing architectural extension"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
for|for
control|(
name|opt
operator|=
name|arm_extensions
init|;
name|opt
operator|->
name|name
operator|!=
name|NULL
condition|;
name|opt
operator|++
control|)
if|if
condition|(
name|strncmp
argument_list|(
name|opt
operator|->
name|name
argument_list|,
name|str
argument_list|,
name|optlen
argument_list|)
operator|==
literal|0
condition|)
block|{
name|ARM_MERGE_FEATURE_SETS
argument_list|(
operator|*
name|ext_set
argument_list|,
operator|*
name|ext_set
argument_list|,
name|opt
operator|->
name|value
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|opt
operator|->
name|name
operator|==
name|NULL
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"unknown architectural extnsion `%s'"
argument_list|)
argument_list|,
name|str
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|str
operator|=
name|ext
expr_stmt|;
block|}
empty_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|arm_parse_cpu
parameter_list|(
name|char
modifier|*
name|str
parameter_list|)
block|{
specifier|const
name|struct
name|arm_cpu_option_table
modifier|*
name|opt
decl_stmt|;
name|char
modifier|*
name|ext
init|=
name|strchr
argument_list|(
name|str
argument_list|,
literal|'+'
argument_list|)
decl_stmt|;
name|int
name|optlen
decl_stmt|;
if|if
condition|(
name|ext
operator|!=
name|NULL
condition|)
name|optlen
operator|=
name|ext
operator|-
name|str
expr_stmt|;
else|else
name|optlen
operator|=
name|strlen
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|optlen
operator|==
literal|0
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"missing cpu name `%s'"
argument_list|)
argument_list|,
name|str
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
for|for
control|(
name|opt
operator|=
name|arm_cpus
init|;
name|opt
operator|->
name|name
operator|!=
name|NULL
condition|;
name|opt
operator|++
control|)
if|if
condition|(
name|strncmp
argument_list|(
name|opt
operator|->
name|name
argument_list|,
name|str
argument_list|,
name|optlen
argument_list|)
operator|==
literal|0
condition|)
block|{
name|mcpu_cpu_opt
operator|=
operator|&
name|opt
operator|->
name|value
expr_stmt|;
name|mcpu_fpu_opt
operator|=
operator|&
name|opt
operator|->
name|default_fpu
expr_stmt|;
if|if
condition|(
name|opt
operator|->
name|canonical_name
condition|)
name|strcpy
argument_list|(
name|selected_cpu_name
argument_list|,
name|opt
operator|->
name|canonical_name
argument_list|)
expr_stmt|;
else|else
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|optlen
condition|;
name|i
operator|++
control|)
name|selected_cpu_name
index|[
name|i
index|]
operator|=
name|TOUPPER
argument_list|(
name|opt
operator|->
name|name
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|selected_cpu_name
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|ext
operator|!=
name|NULL
condition|)
return|return
name|arm_parse_extension
argument_list|(
name|ext
argument_list|,
operator|&
name|mcpu_cpu_opt
argument_list|)
return|;
return|return
literal|1
return|;
block|}
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"unknown cpu `%s'"
argument_list|)
argument_list|,
name|str
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|arm_parse_arch
parameter_list|(
name|char
modifier|*
name|str
parameter_list|)
block|{
specifier|const
name|struct
name|arm_arch_option_table
modifier|*
name|opt
decl_stmt|;
name|char
modifier|*
name|ext
init|=
name|strchr
argument_list|(
name|str
argument_list|,
literal|'+'
argument_list|)
decl_stmt|;
name|int
name|optlen
decl_stmt|;
if|if
condition|(
name|ext
operator|!=
name|NULL
condition|)
name|optlen
operator|=
name|ext
operator|-
name|str
expr_stmt|;
else|else
name|optlen
operator|=
name|strlen
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|optlen
operator|==
literal|0
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"missing architecture name `%s'"
argument_list|)
argument_list|,
name|str
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
for|for
control|(
name|opt
operator|=
name|arm_archs
init|;
name|opt
operator|->
name|name
operator|!=
name|NULL
condition|;
name|opt
operator|++
control|)
if|if
condition|(
name|strncmp
argument_list|(
name|opt
operator|->
name|name
argument_list|,
name|str
argument_list|,
name|optlen
argument_list|)
operator|==
literal|0
condition|)
block|{
name|march_cpu_opt
operator|=
operator|&
name|opt
operator|->
name|value
expr_stmt|;
name|march_fpu_opt
operator|=
operator|&
name|opt
operator|->
name|default_fpu
expr_stmt|;
name|strcpy
argument_list|(
name|selected_cpu_name
argument_list|,
name|opt
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|ext
operator|!=
name|NULL
condition|)
return|return
name|arm_parse_extension
argument_list|(
name|ext
argument_list|,
operator|&
name|march_cpu_opt
argument_list|)
return|;
return|return
literal|1
return|;
block|}
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"unknown architecture `%s'\n"
argument_list|)
argument_list|,
name|str
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|arm_parse_fpu
parameter_list|(
name|char
modifier|*
name|str
parameter_list|)
block|{
specifier|const
name|struct
name|arm_option_cpu_value_table
modifier|*
name|opt
decl_stmt|;
for|for
control|(
name|opt
operator|=
name|arm_fpus
init|;
name|opt
operator|->
name|name
operator|!=
name|NULL
condition|;
name|opt
operator|++
control|)
if|if
condition|(
name|streq
argument_list|(
name|opt
operator|->
name|name
argument_list|,
name|str
argument_list|)
condition|)
block|{
name|mfpu_opt
operator|=
operator|&
name|opt
operator|->
name|value
expr_stmt|;
return|return
literal|1
return|;
block|}
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"unknown floating point format `%s'\n"
argument_list|)
argument_list|,
name|str
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|arm_parse_float_abi
parameter_list|(
name|char
modifier|*
name|str
parameter_list|)
block|{
specifier|const
name|struct
name|arm_option_value_table
modifier|*
name|opt
decl_stmt|;
for|for
control|(
name|opt
operator|=
name|arm_float_abis
init|;
name|opt
operator|->
name|name
operator|!=
name|NULL
condition|;
name|opt
operator|++
control|)
if|if
condition|(
name|streq
argument_list|(
name|opt
operator|->
name|name
argument_list|,
name|str
argument_list|)
condition|)
block|{
name|mfloat_abi_opt
operator|=
name|opt
operator|->
name|value
expr_stmt|;
return|return
literal|1
return|;
block|}
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"unknown floating point abi `%s'\n"
argument_list|)
argument_list|,
name|str
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|OBJ_ELF
end_ifdef

begin_function
specifier|static
name|int
name|arm_parse_eabi
parameter_list|(
name|char
modifier|*
name|str
parameter_list|)
block|{
specifier|const
name|struct
name|arm_option_value_table
modifier|*
name|opt
decl_stmt|;
for|for
control|(
name|opt
operator|=
name|arm_eabis
init|;
name|opt
operator|->
name|name
operator|!=
name|NULL
condition|;
name|opt
operator|++
control|)
if|if
condition|(
name|streq
argument_list|(
name|opt
operator|->
name|name
argument_list|,
name|str
argument_list|)
condition|)
block|{
name|meabi_flags
operator|=
name|opt
operator|->
name|value
expr_stmt|;
return|return
literal|1
return|;
block|}
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"unknown EABI `%s'\n"
argument_list|)
argument_list|,
name|str
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|struct
name|arm_long_option_table
name|arm_long_opts
index|[]
init|=
block|{
block|{
literal|"mcpu="
block|,
name|N_
argument_list|(
literal|"<cpu name>\t  assemble for CPU<cpu name>"
argument_list|)
block|,
name|arm_parse_cpu
block|,
name|NULL
block|}
block|,
block|{
literal|"march="
block|,
name|N_
argument_list|(
literal|"<arch name>\t  assemble for architecture<arch name>"
argument_list|)
block|,
name|arm_parse_arch
block|,
name|NULL
block|}
block|,
block|{
literal|"mfpu="
block|,
name|N_
argument_list|(
literal|"<fpu name>\t  assemble for FPU architecture<fpu name>"
argument_list|)
block|,
name|arm_parse_fpu
block|,
name|NULL
block|}
block|,
block|{
literal|"mfloat-abi="
block|,
name|N_
argument_list|(
literal|"<abi>\t  assemble for floating point ABI<abi>"
argument_list|)
block|,
name|arm_parse_float_abi
block|,
name|NULL
block|}
block|,
ifdef|#
directive|ifdef
name|OBJ_ELF
block|{
literal|"meabi="
block|,
name|N_
argument_list|(
literal|"<ver>\t  assemble for eabi version<ver>"
argument_list|)
block|,
name|arm_parse_eabi
block|,
name|NULL
block|}
block|,
endif|#
directive|endif
block|{
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|md_parse_option
parameter_list|(
name|int
name|c
parameter_list|,
name|char
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|arm_option_table
modifier|*
name|opt
decl_stmt|;
specifier|const
name|struct
name|arm_legacy_option_table
modifier|*
name|fopt
decl_stmt|;
name|struct
name|arm_long_option_table
modifier|*
name|lopt
decl_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
ifdef|#
directive|ifdef
name|OPTION_EB
case|case
name|OPTION_EB
case|:
name|target_big_endian
operator|=
literal|1
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|OPTION_EL
case|case
name|OPTION_EL
case|:
name|target_big_endian
operator|=
literal|0
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
literal|'a'
case|:
comment|/* Listing option.  Just ignore these, we don't support additional 	 ones.	*/
return|return
literal|0
return|;
default|default:
for|for
control|(
name|opt
operator|=
name|arm_opts
init|;
name|opt
operator|->
name|option
operator|!=
name|NULL
condition|;
name|opt
operator|++
control|)
block|{
if|if
condition|(
name|c
operator|==
name|opt
operator|->
name|option
index|[
literal|0
index|]
operator|&&
operator|(
operator|(
name|arg
operator|==
name|NULL
operator|&&
name|opt
operator|->
name|option
index|[
literal|1
index|]
operator|==
literal|0
operator|)
operator|||
name|streq
argument_list|(
name|arg
argument_list|,
name|opt
operator|->
name|option
operator|+
literal|1
argument_list|)
operator|)
condition|)
block|{
if|#
directive|if
name|WARN_DEPRECATED
comment|/* If the option is deprecated, tell the user.  */
if|if
condition|(
name|opt
operator|->
name|deprecated
operator|!=
name|NULL
condition|)
name|as_tsktsk
argument_list|(
name|_
argument_list|(
literal|"option `-%c%s' is deprecated: %s"
argument_list|)
argument_list|,
name|c
argument_list|,
name|arg
condition|?
name|arg
else|:
literal|""
argument_list|,
name|_
argument_list|(
name|opt
operator|->
name|deprecated
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|opt
operator|->
name|var
operator|!=
name|NULL
condition|)
operator|*
name|opt
operator|->
name|var
operator|=
name|opt
operator|->
name|value
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
for|for
control|(
name|fopt
operator|=
name|arm_legacy_opts
init|;
name|fopt
operator|->
name|option
operator|!=
name|NULL
condition|;
name|fopt
operator|++
control|)
block|{
if|if
condition|(
name|c
operator|==
name|fopt
operator|->
name|option
index|[
literal|0
index|]
operator|&&
operator|(
operator|(
name|arg
operator|==
name|NULL
operator|&&
name|fopt
operator|->
name|option
index|[
literal|1
index|]
operator|==
literal|0
operator|)
operator|||
name|streq
argument_list|(
name|arg
argument_list|,
name|fopt
operator|->
name|option
operator|+
literal|1
argument_list|)
operator|)
condition|)
block|{
if|#
directive|if
name|WARN_DEPRECATED
comment|/* If the option is deprecated, tell the user.  */
if|if
condition|(
name|fopt
operator|->
name|deprecated
operator|!=
name|NULL
condition|)
name|as_tsktsk
argument_list|(
name|_
argument_list|(
literal|"option `-%c%s' is deprecated: %s"
argument_list|)
argument_list|,
name|c
argument_list|,
name|arg
condition|?
name|arg
else|:
literal|""
argument_list|,
name|_
argument_list|(
name|fopt
operator|->
name|deprecated
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|fopt
operator|->
name|var
operator|!=
name|NULL
condition|)
operator|*
name|fopt
operator|->
name|var
operator|=
operator|&
name|fopt
operator|->
name|value
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
for|for
control|(
name|lopt
operator|=
name|arm_long_opts
init|;
name|lopt
operator|->
name|option
operator|!=
name|NULL
condition|;
name|lopt
operator|++
control|)
block|{
comment|/* These options are expected to have an argument.  */
if|if
condition|(
name|c
operator|==
name|lopt
operator|->
name|option
index|[
literal|0
index|]
operator|&&
name|arg
operator|!=
name|NULL
operator|&&
name|strncmp
argument_list|(
name|arg
argument_list|,
name|lopt
operator|->
name|option
operator|+
literal|1
argument_list|,
name|strlen
argument_list|(
name|lopt
operator|->
name|option
operator|+
literal|1
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
if|#
directive|if
name|WARN_DEPRECATED
comment|/* If the option is deprecated, tell the user.  */
if|if
condition|(
name|lopt
operator|->
name|deprecated
operator|!=
name|NULL
condition|)
name|as_tsktsk
argument_list|(
name|_
argument_list|(
literal|"option `-%c%s' is deprecated: %s"
argument_list|)
argument_list|,
name|c
argument_list|,
name|arg
argument_list|,
name|_
argument_list|(
name|lopt
operator|->
name|deprecated
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Call the sup-option parser.  */
return|return
name|lopt
operator|->
name|func
argument_list|(
name|arg
operator|+
name|strlen
argument_list|(
name|lopt
operator|->
name|option
argument_list|)
operator|-
literal|1
argument_list|)
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
name|void
name|md_show_usage
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
name|struct
name|arm_option_table
modifier|*
name|opt
decl_stmt|;
name|struct
name|arm_long_option_table
modifier|*
name|lopt
decl_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
name|_
argument_list|(
literal|" ARM-specific assembler options:\n"
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|opt
operator|=
name|arm_opts
init|;
name|opt
operator|->
name|option
operator|!=
name|NULL
condition|;
name|opt
operator|++
control|)
if|if
condition|(
name|opt
operator|->
name|help
operator|!=
name|NULL
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"  -%-23s%s\n"
argument_list|,
name|opt
operator|->
name|option
argument_list|,
name|_
argument_list|(
name|opt
operator|->
name|help
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|lopt
operator|=
name|arm_long_opts
init|;
name|lopt
operator|->
name|option
operator|!=
name|NULL
condition|;
name|lopt
operator|++
control|)
if|if
condition|(
name|lopt
operator|->
name|help
operator|!=
name|NULL
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"  -%s%s\n"
argument_list|,
name|lopt
operator|->
name|option
argument_list|,
name|_
argument_list|(
name|lopt
operator|->
name|help
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|OPTION_EB
name|fprintf
argument_list|(
name|fp
argument_list|,
name|_
argument_list|(
literal|"\   -EB                     assemble code for a big-endian cpu\n"
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|OPTION_EL
name|fprintf
argument_list|(
name|fp
argument_list|,
name|_
argument_list|(
literal|"\   -EL                     assemble code for a little-endian cpu\n"
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|OBJ_ELF
end_ifdef

begin_typedef
typedef|typedef
struct|struct
block|{
name|int
name|val
decl_stmt|;
name|arm_feature_set
name|flags
decl_stmt|;
block|}
name|cpu_arch_ver_table
typedef|;
end_typedef

begin_comment
comment|/* Mapping from CPU features to EABI CPU arch values.  Table must be sorted    least features first.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|cpu_arch_ver_table
name|cpu_arch_ver
index|[]
init|=
block|{
block|{
literal|1
block|,
name|ARM_ARCH_V4
block|}
block|,
block|{
literal|2
block|,
name|ARM_ARCH_V4T
block|}
block|,
block|{
literal|3
block|,
name|ARM_ARCH_V5
block|}
block|,
block|{
literal|4
block|,
name|ARM_ARCH_V5TE
block|}
block|,
block|{
literal|5
block|,
name|ARM_ARCH_V5TEJ
block|}
block|,
block|{
literal|6
block|,
name|ARM_ARCH_V6
block|}
block|,
block|{
literal|7
block|,
name|ARM_ARCH_V6Z
block|}
block|,
block|{
literal|8
block|,
name|ARM_ARCH_V6K
block|}
block|,
block|{
literal|9
block|,
name|ARM_ARCH_V6T2
block|}
block|,
block|{
literal|10
block|,
name|ARM_ARCH_V7A
block|}
block|,
block|{
literal|10
block|,
name|ARM_ARCH_V7R
block|}
block|,
block|{
literal|10
block|,
name|ARM_ARCH_V7M
block|}
block|,
block|{
literal|0
block|,
name|ARM_ARCH_NONE
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set the public EABI object attributes.  */
end_comment

begin_function
specifier|static
name|void
name|aeabi_set_public_attributes
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|arch
decl_stmt|;
name|arm_feature_set
name|flags
decl_stmt|;
name|arm_feature_set
name|tmp
decl_stmt|;
specifier|const
name|cpu_arch_ver_table
modifier|*
name|p
decl_stmt|;
comment|/* Choose the architecture based on the capabilities of the requested cpu      (if any) and/or the instructions actually used.  */
name|ARM_MERGE_FEATURE_SETS
argument_list|(
name|flags
argument_list|,
name|arm_arch_used
argument_list|,
name|thumb_arch_used
argument_list|)
expr_stmt|;
name|ARM_MERGE_FEATURE_SETS
argument_list|(
name|flags
argument_list|,
name|flags
argument_list|,
operator|*
name|mfpu_opt
argument_list|)
expr_stmt|;
name|ARM_MERGE_FEATURE_SETS
argument_list|(
name|flags
argument_list|,
name|flags
argument_list|,
name|selected_cpu
argument_list|)
expr_stmt|;
comment|/*Allow the user to override the reported architecture.  */
if|if
condition|(
name|object_arch
condition|)
block|{
name|ARM_CLEAR_FEATURE
argument_list|(
name|flags
argument_list|,
name|flags
argument_list|,
name|arm_arch_any
argument_list|)
expr_stmt|;
name|ARM_MERGE_FEATURE_SETS
argument_list|(
name|flags
argument_list|,
name|flags
argument_list|,
operator|*
name|object_arch
argument_list|)
expr_stmt|;
block|}
name|tmp
operator|=
name|flags
expr_stmt|;
name|arch
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|p
operator|=
name|cpu_arch_ver
init|;
name|p
operator|->
name|val
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
name|ARM_CPU_HAS_FEATURE
argument_list|(
name|tmp
argument_list|,
name|p
operator|->
name|flags
argument_list|)
condition|)
block|{
name|arch
operator|=
name|p
operator|->
name|val
expr_stmt|;
name|ARM_CLEAR_FEATURE
argument_list|(
name|tmp
argument_list|,
name|tmp
argument_list|,
name|p
operator|->
name|flags
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Tag_CPU_name.  */
if|if
condition|(
name|selected_cpu_name
index|[
literal|0
index|]
condition|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|selected_cpu_name
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|p
argument_list|,
literal|"armv"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
block|{
name|int
name|i
decl_stmt|;
name|p
operator|+=
literal|4
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|p
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
name|p
index|[
name|i
index|]
operator|=
name|TOUPPER
argument_list|(
name|p
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|bfd_elf_add_proc_attr_string
argument_list|(
name|stdoutput
argument_list|,
literal|5
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
comment|/* Tag_CPU_arch.  */
name|bfd_elf_add_proc_attr_int
argument_list|(
name|stdoutput
argument_list|,
literal|6
argument_list|,
name|arch
argument_list|)
expr_stmt|;
comment|/* Tag_CPU_arch_profile.  */
if|if
condition|(
name|ARM_CPU_HAS_FEATURE
argument_list|(
name|flags
argument_list|,
name|arm_ext_v7a
argument_list|)
condition|)
name|bfd_elf_add_proc_attr_int
argument_list|(
name|stdoutput
argument_list|,
literal|7
argument_list|,
literal|'A'
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ARM_CPU_HAS_FEATURE
argument_list|(
name|flags
argument_list|,
name|arm_ext_v7r
argument_list|)
condition|)
name|bfd_elf_add_proc_attr_int
argument_list|(
name|stdoutput
argument_list|,
literal|7
argument_list|,
literal|'R'
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ARM_CPU_HAS_FEATURE
argument_list|(
name|flags
argument_list|,
name|arm_ext_v7m
argument_list|)
condition|)
name|bfd_elf_add_proc_attr_int
argument_list|(
name|stdoutput
argument_list|,
literal|7
argument_list|,
literal|'M'
argument_list|)
expr_stmt|;
comment|/* Tag_ARM_ISA_use.  */
if|if
condition|(
name|ARM_CPU_HAS_FEATURE
argument_list|(
name|arm_arch_used
argument_list|,
name|arm_arch_full
argument_list|)
condition|)
name|bfd_elf_add_proc_attr_int
argument_list|(
name|stdoutput
argument_list|,
literal|8
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Tag_THUMB_ISA_use.  */
if|if
condition|(
name|ARM_CPU_HAS_FEATURE
argument_list|(
name|thumb_arch_used
argument_list|,
name|arm_arch_full
argument_list|)
condition|)
name|bfd_elf_add_proc_attr_int
argument_list|(
name|stdoutput
argument_list|,
literal|9
argument_list|,
name|ARM_CPU_HAS_FEATURE
argument_list|(
name|thumb_arch_used
argument_list|,
name|arm_arch_t2
argument_list|)
condition|?
literal|2
else|:
literal|1
argument_list|)
expr_stmt|;
comment|/* Tag_VFP_arch.  */
if|if
condition|(
name|ARM_CPU_HAS_FEATURE
argument_list|(
name|thumb_arch_used
argument_list|,
name|fpu_vfp_ext_v3
argument_list|)
operator|||
name|ARM_CPU_HAS_FEATURE
argument_list|(
name|arm_arch_used
argument_list|,
name|fpu_vfp_ext_v3
argument_list|)
condition|)
name|bfd_elf_add_proc_attr_int
argument_list|(
name|stdoutput
argument_list|,
literal|10
argument_list|,
literal|3
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ARM_CPU_HAS_FEATURE
argument_list|(
name|thumb_arch_used
argument_list|,
name|fpu_vfp_ext_v2
argument_list|)
operator|||
name|ARM_CPU_HAS_FEATURE
argument_list|(
name|arm_arch_used
argument_list|,
name|fpu_vfp_ext_v2
argument_list|)
condition|)
name|bfd_elf_add_proc_attr_int
argument_list|(
name|stdoutput
argument_list|,
literal|10
argument_list|,
literal|2
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ARM_CPU_HAS_FEATURE
argument_list|(
name|thumb_arch_used
argument_list|,
name|fpu_vfp_ext_v1
argument_list|)
operator|||
name|ARM_CPU_HAS_FEATURE
argument_list|(
name|arm_arch_used
argument_list|,
name|fpu_vfp_ext_v1
argument_list|)
operator|||
name|ARM_CPU_HAS_FEATURE
argument_list|(
name|thumb_arch_used
argument_list|,
name|fpu_vfp_ext_v1xd
argument_list|)
operator|||
name|ARM_CPU_HAS_FEATURE
argument_list|(
name|arm_arch_used
argument_list|,
name|fpu_vfp_ext_v1xd
argument_list|)
condition|)
name|bfd_elf_add_proc_attr_int
argument_list|(
name|stdoutput
argument_list|,
literal|10
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Tag_WMMX_arch.  */
if|if
condition|(
name|ARM_CPU_HAS_FEATURE
argument_list|(
name|thumb_arch_used
argument_list|,
name|arm_cext_iwmmxt
argument_list|)
operator|||
name|ARM_CPU_HAS_FEATURE
argument_list|(
name|arm_arch_used
argument_list|,
name|arm_cext_iwmmxt
argument_list|)
condition|)
name|bfd_elf_add_proc_attr_int
argument_list|(
name|stdoutput
argument_list|,
literal|11
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Tag_NEON_arch.  */
if|if
condition|(
name|ARM_CPU_HAS_FEATURE
argument_list|(
name|thumb_arch_used
argument_list|,
name|fpu_neon_ext_v1
argument_list|)
operator|||
name|ARM_CPU_HAS_FEATURE
argument_list|(
name|arm_arch_used
argument_list|,
name|fpu_neon_ext_v1
argument_list|)
condition|)
name|bfd_elf_add_proc_attr_int
argument_list|(
name|stdoutput
argument_list|,
literal|12
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add the default contents for the .ARM.attributes section.  */
end_comment

begin_function
name|void
name|arm_md_end
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|EF_ARM_EABI_VERSION
argument_list|(
name|meabi_flags
argument_list|)
operator|<
name|EF_ARM_EABI_VER4
condition|)
return|return;
name|aeabi_set_public_attributes
argument_list|()
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* OBJ_ELF */
end_comment

begin_comment
comment|/* Parse a .cpu directive.  */
end_comment

begin_function
specifier|static
name|void
name|s_arm_cpu
parameter_list|(
name|int
name|ignored
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
specifier|const
name|struct
name|arm_cpu_option_table
modifier|*
name|opt
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|char
name|saved_char
decl_stmt|;
name|name
operator|=
name|input_line_pointer
expr_stmt|;
while|while
condition|(
operator|*
name|input_line_pointer
operator|&&
operator|!
name|ISSPACE
argument_list|(
operator|*
name|input_line_pointer
argument_list|)
condition|)
name|input_line_pointer
operator|++
expr_stmt|;
name|saved_char
operator|=
operator|*
name|input_line_pointer
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
literal|0
expr_stmt|;
comment|/* Skip the first "all" entry.  */
for|for
control|(
name|opt
operator|=
name|arm_cpus
operator|+
literal|1
init|;
name|opt
operator|->
name|name
operator|!=
name|NULL
condition|;
name|opt
operator|++
control|)
if|if
condition|(
name|streq
argument_list|(
name|opt
operator|->
name|name
argument_list|,
name|name
argument_list|)
condition|)
block|{
name|mcpu_cpu_opt
operator|=
operator|&
name|opt
operator|->
name|value
expr_stmt|;
name|selected_cpu
operator|=
name|opt
operator|->
name|value
expr_stmt|;
if|if
condition|(
name|opt
operator|->
name|canonical_name
condition|)
name|strcpy
argument_list|(
name|selected_cpu_name
argument_list|,
name|opt
operator|->
name|canonical_name
argument_list|)
expr_stmt|;
else|else
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|opt
operator|->
name|name
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
name|selected_cpu_name
index|[
name|i
index|]
operator|=
name|TOUPPER
argument_list|(
name|opt
operator|->
name|name
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|selected_cpu_name
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|ARM_MERGE_FEATURE_SETS
argument_list|(
name|cpu_variant
argument_list|,
operator|*
name|mcpu_cpu_opt
argument_list|,
operator|*
name|mfpu_opt
argument_list|)
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
name|saved_char
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"unknown cpu `%s'"
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
name|saved_char
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Parse a .arch directive.  */
end_comment

begin_function
specifier|static
name|void
name|s_arm_arch
parameter_list|(
name|int
name|ignored
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
specifier|const
name|struct
name|arm_arch_option_table
modifier|*
name|opt
decl_stmt|;
name|char
name|saved_char
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|name
operator|=
name|input_line_pointer
expr_stmt|;
while|while
condition|(
operator|*
name|input_line_pointer
operator|&&
operator|!
name|ISSPACE
argument_list|(
operator|*
name|input_line_pointer
argument_list|)
condition|)
name|input_line_pointer
operator|++
expr_stmt|;
name|saved_char
operator|=
operator|*
name|input_line_pointer
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
literal|0
expr_stmt|;
comment|/* Skip the first "all" entry.  */
for|for
control|(
name|opt
operator|=
name|arm_archs
operator|+
literal|1
init|;
name|opt
operator|->
name|name
operator|!=
name|NULL
condition|;
name|opt
operator|++
control|)
if|if
condition|(
name|streq
argument_list|(
name|opt
operator|->
name|name
argument_list|,
name|name
argument_list|)
condition|)
block|{
name|mcpu_cpu_opt
operator|=
operator|&
name|opt
operator|->
name|value
expr_stmt|;
name|selected_cpu
operator|=
name|opt
operator|->
name|value
expr_stmt|;
name|strcpy
argument_list|(
name|selected_cpu_name
argument_list|,
name|opt
operator|->
name|name
argument_list|)
expr_stmt|;
name|ARM_MERGE_FEATURE_SETS
argument_list|(
name|cpu_variant
argument_list|,
operator|*
name|mcpu_cpu_opt
argument_list|,
operator|*
name|mfpu_opt
argument_list|)
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
name|saved_char
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"unknown architecture `%s'\n"
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
name|saved_char
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Parse a .arch_extension directive.  */
end_comment

begin_function
specifier|static
name|void
name|s_arm_arch_extension
parameter_list|(
name|int
name|ignored
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
specifier|const
name|struct
name|arm_option_cpu_value_table
modifier|*
name|opt
decl_stmt|;
name|char
name|saved_char
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|name
operator|=
name|input_line_pointer
expr_stmt|;
while|while
condition|(
operator|*
name|input_line_pointer
operator|&&
operator|!
name|ISSPACE
argument_list|(
operator|*
name|input_line_pointer
argument_list|)
condition|)
name|input_line_pointer
operator|++
expr_stmt|;
name|saved_char
operator|=
operator|*
name|input_line_pointer
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|opt
operator|=
name|arm_extensions
init|;
name|opt
operator|->
name|name
operator|!=
name|NULL
condition|;
name|opt
operator|++
control|)
if|if
condition|(
name|streq
argument_list|(
name|opt
operator|->
name|name
argument_list|,
name|name
argument_list|)
condition|)
block|{
name|ARM_MERGE_FEATURE_SETS
argument_list|(
name|cpu_variant
argument_list|,
name|cpu_variant
argument_list|,
name|opt
operator|->
name|value
argument_list|)
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
name|saved_char
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"unknown architecture `%s'\n"
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
name|saved_char
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Parse a .object_arch directive.  */
end_comment

begin_function
specifier|static
name|void
name|s_arm_object_arch
parameter_list|(
name|int
name|ignored
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
specifier|const
name|struct
name|arm_arch_option_table
modifier|*
name|opt
decl_stmt|;
name|char
name|saved_char
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|name
operator|=
name|input_line_pointer
expr_stmt|;
while|while
condition|(
operator|*
name|input_line_pointer
operator|&&
operator|!
name|ISSPACE
argument_list|(
operator|*
name|input_line_pointer
argument_list|)
condition|)
name|input_line_pointer
operator|++
expr_stmt|;
name|saved_char
operator|=
operator|*
name|input_line_pointer
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
literal|0
expr_stmt|;
comment|/* Skip the first "all" entry.  */
for|for
control|(
name|opt
operator|=
name|arm_archs
operator|+
literal|1
init|;
name|opt
operator|->
name|name
operator|!=
name|NULL
condition|;
name|opt
operator|++
control|)
if|if
condition|(
name|streq
argument_list|(
name|opt
operator|->
name|name
argument_list|,
name|name
argument_list|)
condition|)
block|{
name|object_arch
operator|=
operator|&
name|opt
operator|->
name|value
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
name|saved_char
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"unknown architecture `%s'\n"
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
name|saved_char
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Parse a .fpu directive.  */
end_comment

begin_function
specifier|static
name|void
name|s_arm_fpu
parameter_list|(
name|int
name|ignored
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
specifier|const
name|struct
name|arm_option_cpu_value_table
modifier|*
name|opt
decl_stmt|;
name|char
name|saved_char
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|name
operator|=
name|input_line_pointer
expr_stmt|;
while|while
condition|(
operator|*
name|input_line_pointer
operator|&&
operator|!
name|ISSPACE
argument_list|(
operator|*
name|input_line_pointer
argument_list|)
condition|)
name|input_line_pointer
operator|++
expr_stmt|;
name|saved_char
operator|=
operator|*
name|input_line_pointer
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|opt
operator|=
name|arm_fpus
init|;
name|opt
operator|->
name|name
operator|!=
name|NULL
condition|;
name|opt
operator|++
control|)
if|if
condition|(
name|streq
argument_list|(
name|opt
operator|->
name|name
argument_list|,
name|name
argument_list|)
condition|)
block|{
name|mfpu_opt
operator|=
operator|&
name|opt
operator|->
name|value
expr_stmt|;
name|ARM_MERGE_FEATURE_SETS
argument_list|(
name|cpu_variant
argument_list|,
operator|*
name|mcpu_cpu_opt
argument_list|,
operator|*
name|mfpu_opt
argument_list|)
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
name|saved_char
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"unknown floating point format `%s'\n"
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
name|saved_char
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Copy symbol information.  */
end_comment

begin_function
name|void
name|arm_copy_symbol_attributes
parameter_list|(
name|symbolS
modifier|*
name|dest
parameter_list|,
name|symbolS
modifier|*
name|src
parameter_list|)
block|{
name|ARM_GET_FLAG
argument_list|(
name|dest
argument_list|)
operator|=
name|ARM_GET_FLAG
argument_list|(
name|src
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

