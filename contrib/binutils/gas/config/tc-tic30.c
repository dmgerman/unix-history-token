begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* tc-c30.c -- Assembly code for the Texas Instruments TMS320C30    Copyright (C) 1998 Free Software Foundation.    Contributed by Steven Haworth (steve@pm.cse.rmit.edu.au)     This file is part of GAS, the GNU Assembler.     GAS is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     GAS is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with GAS; see the file COPYING.  If not, write to the Free    Software Foundation, 59 Temple Place - Suite 330, Boston, MA    02111-1307, USA.  */
end_comment

begin_comment
comment|/*    Texas Instruments TMS320C30 machine specific gas.    Written by Steven Haworth (steve@pm.cse.rmit.edu.au).    Bugs& suggestions are completely welcome.  This is free software.    Please help us make it better.  */
end_comment

begin_include
include|#
directive|include
file|"as.h"
end_include

begin_include
include|#
directive|include
file|"opcode/tic30.h"
end_include

begin_comment
comment|/* put here all non-digit non-letter charcters that may occur in an operand */
end_comment

begin_decl_stmt
specifier|static
name|char
name|operand_special_chars
index|[]
init|=
literal|"%$-+(,)*._~/<>&^!:[@]"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|ordinal_names
index|[]
init|=
block|{
literal|"first"
block|,
literal|"second"
block|,
literal|"third"
block|,
literal|"fourth"
block|,
literal|"fifth"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|int
name|md_reloc_size
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|md_long_jump_size
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|md_short_jump_size
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
name|comment_chars
index|[]
init|=
literal|";"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
name|line_comment_chars
index|[]
init|=
literal|"*"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
name|line_separator_chars
index|[]
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
modifier|*
name|md_shortopts
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|option
name|md_longopts
index|[]
init|=
block|{
block|{
name|NULL
block|,
name|no_argument
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|size_t
name|md_longopts_size
init|=
sizeof|sizeof
argument_list|(
name|md_longopts
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Chars that mean this number is a floating point constant */
end_comment

begin_comment
comment|/* As in 0f12.456 */
end_comment

begin_comment
comment|/* or    0d1.2345e12 */
end_comment

begin_decl_stmt
specifier|const
name|char
name|FLT_CHARS
index|[]
init|=
literal|"fFdDxX"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Chars that can be used to separate mant from exp in floating point nums */
end_comment

begin_decl_stmt
specifier|const
name|char
name|EXP_CHARS
index|[]
init|=
literal|"eE"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* tables for lexical analysis */
end_comment

begin_decl_stmt
specifier|static
name|char
name|opcode_chars
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|register_chars
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|operand_chars
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|space_chars
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|identifier_chars
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|digit_chars
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* lexical macros */
end_comment

begin_define
define|#
directive|define
name|is_opcode_char
parameter_list|(
name|x
parameter_list|)
value|(opcode_chars[(unsigned char) x])
end_define

begin_define
define|#
directive|define
name|is_operand_char
parameter_list|(
name|x
parameter_list|)
value|(operand_chars[(unsigned char) x])
end_define

begin_define
define|#
directive|define
name|is_register_char
parameter_list|(
name|x
parameter_list|)
value|(register_chars[(unsigned char) x])
end_define

begin_define
define|#
directive|define
name|is_space_char
parameter_list|(
name|x
parameter_list|)
value|(space_chars[(unsigned char) x])
end_define

begin_define
define|#
directive|define
name|is_identifier_char
parameter_list|(
name|x
parameter_list|)
value|(identifier_chars[(unsigned char) x])
end_define

begin_define
define|#
directive|define
name|is_digit_char
parameter_list|(
name|x
parameter_list|)
value|(digit_chars[(unsigned char) x])
end_define

begin_decl_stmt
specifier|const
name|pseudo_typeS
name|md_pseudo_table
index|[]
init|=
block|{
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_undef
undef|#
directive|undef
name|USE_STDOUT
end_undef

begin_define
define|#
directive|define
name|USE_STDOUT
value|1
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|USE_STDARG
end_ifdef

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_function
name|int
name|debug
parameter_list|(
specifier|const
name|char
modifier|*
name|string
parameter_list|,
modifier|...
parameter_list|)
block|{
if|if
condition|(
name|flag_debug
condition|)
block|{
name|va_list
name|argptr
decl_stmt|;
name|char
name|str
index|[
literal|100
index|]
decl_stmt|;
name|va_start
argument_list|(
name|argptr
argument_list|,
name|string
argument_list|)
expr_stmt|;
name|vsprintf
argument_list|(
name|str
argument_list|,
name|string
argument_list|,
name|argptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|str
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|va_end
argument_list|(
name|argptr
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|str
argument_list|,
name|USE_STDOUT
condition|?
name|stdout
else|:
name|stderr
argument_list|)
expr_stmt|;
return|return
name|strlen
argument_list|(
name|str
argument_list|)
return|;
block|}
else|else
return|return
literal|0
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_function
name|int
name|debug
parameter_list|(
name|string
parameter_list|,
name|va_alist
parameter_list|)
specifier|const
name|char
modifier|*
name|string
decl_stmt|;
function|va_dcl
block|{
if|if
condition|(
name|flag_debug
condition|)
block|{
name|va_list
name|argptr
decl_stmt|;
name|char
name|str
index|[
literal|100
index|]
decl_stmt|;
name|int
name|cnt
decl_stmt|;
name|va_start
argument_list|(
name|argptr
argument_list|,
name|string
argument_list|)
expr_stmt|;
name|cnt
operator|=
name|vsprintf
argument_list|(
name|str
argument_list|,
name|string
argument_list|,
name|argptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|str
index|[
literal|0
index|]
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|va_end
argument_list|(
name|argptr
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|str
argument_list|,
name|USE_STDOUT
condition|?
name|stdout
else|:
name|stderr
argument_list|)
expr_stmt|;
return|return
operator|(
name|cnt
operator|)
return|;
block|}
else|else
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* hash table for opcode lookup */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|hash_control
modifier|*
name|op_hash
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* hash table for parallel opcode lookup */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|hash_control
modifier|*
name|parop_hash
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* hash table for register lookup */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|hash_control
modifier|*
name|reg_hash
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* hash table for indirect addressing lookup */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|hash_control
modifier|*
name|ind_hash
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|md_begin
parameter_list|()
block|{
specifier|const
name|char
modifier|*
name|hash_err
decl_stmt|;
name|debug
argument_list|(
literal|"In md_begin()\n"
argument_list|)
expr_stmt|;
name|op_hash
operator|=
name|hash_new
argument_list|()
expr_stmt|;
block|{
specifier|const
name|template
modifier|*
name|current_optab
init|=
name|tic30_optab
decl_stmt|;
for|for
control|(
init|;
name|current_optab
operator|<
name|tic30_optab_end
condition|;
name|current_optab
operator|++
control|)
block|{
name|hash_err
operator|=
name|hash_insert
argument_list|(
name|op_hash
argument_list|,
name|current_optab
operator|->
name|name
argument_list|,
operator|(
name|char
operator|*
operator|)
name|current_optab
argument_list|)
expr_stmt|;
if|if
condition|(
name|hash_err
condition|)
name|as_fatal
argument_list|(
literal|"Internal Error: Can't Hash %s: %s"
argument_list|,
name|current_optab
operator|->
name|name
argument_list|,
name|hash_err
argument_list|)
expr_stmt|;
block|}
block|}
name|parop_hash
operator|=
name|hash_new
argument_list|()
expr_stmt|;
block|{
specifier|const
name|partemplate
modifier|*
name|current_parop
init|=
name|tic30_paroptab
decl_stmt|;
for|for
control|(
init|;
name|current_parop
operator|<
name|tic30_paroptab_end
condition|;
name|current_parop
operator|++
control|)
block|{
name|hash_err
operator|=
name|hash_insert
argument_list|(
name|parop_hash
argument_list|,
name|current_parop
operator|->
name|name
argument_list|,
operator|(
name|char
operator|*
operator|)
name|current_parop
argument_list|)
expr_stmt|;
if|if
condition|(
name|hash_err
condition|)
name|as_fatal
argument_list|(
literal|"Internal Error: Can't Hash %s: %s"
argument_list|,
name|current_parop
operator|->
name|name
argument_list|,
name|hash_err
argument_list|)
expr_stmt|;
block|}
block|}
name|reg_hash
operator|=
name|hash_new
argument_list|()
expr_stmt|;
block|{
specifier|const
name|reg
modifier|*
name|current_reg
init|=
name|tic30_regtab
decl_stmt|;
for|for
control|(
init|;
name|current_reg
operator|<
name|tic30_regtab_end
condition|;
name|current_reg
operator|++
control|)
block|{
name|hash_err
operator|=
name|hash_insert
argument_list|(
name|reg_hash
argument_list|,
name|current_reg
operator|->
name|name
argument_list|,
operator|(
name|char
operator|*
operator|)
name|current_reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|hash_err
condition|)
name|as_fatal
argument_list|(
literal|"Internal Error: Can't Hash %s: %s"
argument_list|,
name|current_reg
operator|->
name|name
argument_list|,
name|hash_err
argument_list|)
expr_stmt|;
block|}
block|}
name|ind_hash
operator|=
name|hash_new
argument_list|()
expr_stmt|;
block|{
specifier|const
name|ind_addr_type
modifier|*
name|current_ind
init|=
name|tic30_indaddr_tab
decl_stmt|;
for|for
control|(
init|;
name|current_ind
operator|<
name|tic30_indaddrtab_end
condition|;
name|current_ind
operator|++
control|)
block|{
name|hash_err
operator|=
name|hash_insert
argument_list|(
name|ind_hash
argument_list|,
name|current_ind
operator|->
name|syntax
argument_list|,
operator|(
name|char
operator|*
operator|)
name|current_ind
argument_list|)
expr_stmt|;
if|if
condition|(
name|hash_err
condition|)
name|as_fatal
argument_list|(
literal|"Internal Error: Can't Hash %s: %s"
argument_list|,
name|current_ind
operator|->
name|syntax
argument_list|,
name|hash_err
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* fill in lexical tables:  opcode_chars, operand_chars, space_chars */
block|{
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
literal|256
condition|;
name|c
operator|++
control|)
block|{
if|if
condition|(
name|islower
argument_list|(
name|c
argument_list|)
operator|||
name|isdigit
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|opcode_chars
index|[
name|c
index|]
operator|=
name|c
expr_stmt|;
name|register_chars
index|[
name|c
index|]
operator|=
name|c
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isupper
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|opcode_chars
index|[
name|c
index|]
operator|=
name|tolower
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|register_chars
index|[
name|c
index|]
operator|=
name|opcode_chars
index|[
name|c
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|')'
operator|||
name|c
operator|==
literal|'('
condition|)
block|{
name|register_chars
index|[
name|c
index|]
operator|=
name|c
expr_stmt|;
block|}
if|if
condition|(
name|isupper
argument_list|(
name|c
argument_list|)
operator|||
name|islower
argument_list|(
name|c
argument_list|)
operator|||
name|isdigit
argument_list|(
name|c
argument_list|)
condition|)
name|operand_chars
index|[
name|c
index|]
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|isdigit
argument_list|(
name|c
argument_list|)
operator|||
name|c
operator|==
literal|'-'
condition|)
name|digit_chars
index|[
name|c
index|]
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|isalpha
argument_list|(
name|c
argument_list|)
operator|||
name|c
operator|==
literal|'_'
operator|||
name|c
operator|==
literal|'.'
operator|||
name|isdigit
argument_list|(
name|c
argument_list|)
condition|)
name|identifier_chars
index|[
name|c
index|]
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
condition|)
name|space_chars
index|[
name|c
index|]
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'_'
condition|)
name|opcode_chars
index|[
name|c
index|]
operator|=
name|c
expr_stmt|;
block|}
for|for
control|(
name|p
operator|=
name|operand_special_chars
init|;
operator|*
name|p
operator|!=
literal|'\0'
condition|;
name|p
operator|++
control|)
name|operand_chars
index|[
operator|(
name|unsigned
name|char
operator|)
operator|*
name|p
index|]
operator|=
operator|*
name|p
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Address Mode OR values */
end_comment

begin_define
define|#
directive|define
name|AM_Register
value|0x00000000
end_define

begin_define
define|#
directive|define
name|AM_Direct
value|0x00200000
end_define

begin_define
define|#
directive|define
name|AM_Indirect
value|0x00400000
end_define

begin_define
define|#
directive|define
name|AM_Immediate
value|0x00600000
end_define

begin_define
define|#
directive|define
name|AM_NotReq
value|0xFFFFFFFF
end_define

begin_comment
comment|/* PC Relative OR values */
end_comment

begin_define
define|#
directive|define
name|PC_Register
value|0x00000000
end_define

begin_define
define|#
directive|define
name|PC_Relative
value|0x02000000
end_define

begin_typedef
typedef|typedef
struct|struct
block|{
name|unsigned
name|op_type
decl_stmt|;
struct|struct
block|{
name|int
name|resolved
decl_stmt|;
name|unsigned
name|address
decl_stmt|;
name|char
modifier|*
name|label
decl_stmt|;
name|expressionS
name|direct_expr
decl_stmt|;
block|}
name|direct
struct|;
struct|struct
block|{
name|unsigned
name|mod
decl_stmt|;
name|int
name|ARnum
decl_stmt|;
name|unsigned
name|char
name|disp
decl_stmt|;
block|}
name|indirect
struct|;
struct|struct
block|{
name|unsigned
name|opcode
decl_stmt|;
block|}
name|reg
struct|;
struct|struct
block|{
name|int
name|resolved
decl_stmt|;
name|int
name|decimal_found
decl_stmt|;
name|float
name|f_number
decl_stmt|;
name|int
name|s_number
decl_stmt|;
name|unsigned
name|int
name|u_number
decl_stmt|;
name|char
modifier|*
name|label
decl_stmt|;
name|expressionS
name|imm_expr
decl_stmt|;
block|}
name|immediate
struct|;
block|}
name|operand
typedef|;
end_typedef

begin_decl_stmt
name|int
name|tic30_parallel_insn
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|operand
modifier|*
name|tic30_operand
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|tic30_find_parallel_insn
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|template
modifier|*
name|opcode
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|tic30_insn
block|{
name|template
modifier|*
name|tm
decl_stmt|;
comment|/* Template of current instruction */
name|unsigned
name|opcode
decl_stmt|;
comment|/* Final opcode */
name|int
name|operands
decl_stmt|;
comment|/* Number of given operands */
comment|/* Type of operand given in instruction */
name|operand
modifier|*
name|operand_type
index|[
name|MAX_OPERANDS
index|]
decl_stmt|;
name|unsigned
name|addressing_mode
decl_stmt|;
comment|/* Final addressing mode of instruction */
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|tic30_insn
name|insn
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|found_parallel_insn
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|md_assemble
parameter_list|(
name|line
parameter_list|)
name|char
modifier|*
name|line
decl_stmt|;
block|{
name|template
modifier|*
name|opcode
decl_stmt|;
name|char
modifier|*
name|current_posn
decl_stmt|;
name|char
modifier|*
name|token_start
decl_stmt|;
name|char
name|save_char
decl_stmt|;
name|int
name|count
decl_stmt|;
name|debug
argument_list|(
literal|"In md_assemble() with argument %s\n"
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|insn
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|found_parallel_insn
condition|)
block|{
name|debug
argument_list|(
literal|"Line is second part of parallel instruction\n\n"
argument_list|)
expr_stmt|;
name|found_parallel_insn
operator|=
literal|0
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|current_posn
operator|=
name|tic30_find_parallel_insn
argument_list|(
name|line
argument_list|,
name|input_line_pointer
operator|+
literal|1
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|current_posn
operator|=
name|line
expr_stmt|;
else|else
name|found_parallel_insn
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|is_space_char
argument_list|(
operator|*
name|current_posn
argument_list|)
condition|)
name|current_posn
operator|++
expr_stmt|;
name|token_start
operator|=
name|current_posn
expr_stmt|;
if|if
condition|(
operator|!
name|is_opcode_char
argument_list|(
operator|*
name|current_posn
argument_list|)
condition|)
block|{
name|as_bad
argument_list|(
literal|"Invalid character %s in opcode"
argument_list|,
name|output_invalid
argument_list|(
operator|*
name|current_posn
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Check if instruction is a parallel instruction by seeing if the first      character is a q. */
if|if
condition|(
operator|*
name|token_start
operator|==
literal|'q'
condition|)
block|{
if|if
condition|(
name|tic30_parallel_insn
argument_list|(
name|token_start
argument_list|)
condition|)
block|{
if|if
condition|(
name|found_parallel_insn
condition|)
name|free
argument_list|(
name|token_start
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
while|while
condition|(
name|is_opcode_char
argument_list|(
operator|*
name|current_posn
argument_list|)
condition|)
name|current_posn
operator|++
expr_stmt|;
block|{
comment|/* Find instruction */
name|save_char
operator|=
operator|*
name|current_posn
expr_stmt|;
operator|*
name|current_posn
operator|=
literal|'\0'
expr_stmt|;
name|opcode
operator|=
operator|(
name|template
operator|*
operator|)
name|hash_find
argument_list|(
name|op_hash
argument_list|,
name|token_start
argument_list|)
expr_stmt|;
if|if
condition|(
name|opcode
condition|)
block|{
name|debug
argument_list|(
literal|"Found instruction %s\n"
argument_list|,
name|opcode
operator|->
name|name
argument_list|)
expr_stmt|;
name|insn
operator|.
name|tm
operator|=
name|opcode
expr_stmt|;
block|}
else|else
block|{
name|debug
argument_list|(
literal|"Didn't find insn\n"
argument_list|)
expr_stmt|;
name|as_bad
argument_list|(
literal|"Unknown TMS320C30 instruction: %s"
argument_list|,
name|token_start
argument_list|)
expr_stmt|;
return|return;
block|}
operator|*
name|current_posn
operator|=
name|save_char
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|current_posn
operator|!=
name|END_OF_INSN
condition|)
block|{
comment|/* Find operands */
name|int
name|paren_not_balanced
decl_stmt|;
name|int
name|expecting_operand
init|=
literal|0
decl_stmt|;
name|int
name|this_operand
decl_stmt|;
do|do
block|{
comment|/* skip optional white space before operand */
while|while
condition|(
operator|!
name|is_operand_char
argument_list|(
operator|*
name|current_posn
argument_list|)
operator|&&
operator|*
name|current_posn
operator|!=
name|END_OF_INSN
condition|)
block|{
if|if
condition|(
operator|!
name|is_space_char
argument_list|(
operator|*
name|current_posn
argument_list|)
condition|)
block|{
name|as_bad
argument_list|(
literal|"Invalid character %s before %s operand"
argument_list|,
name|output_invalid
argument_list|(
operator|*
name|current_posn
argument_list|)
argument_list|,
name|ordinal_names
index|[
name|insn
operator|.
name|operands
index|]
argument_list|)
expr_stmt|;
return|return;
block|}
name|current_posn
operator|++
expr_stmt|;
block|}
name|token_start
operator|=
name|current_posn
expr_stmt|;
comment|/* after white space */
name|paren_not_balanced
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|paren_not_balanced
operator|||
operator|*
name|current_posn
operator|!=
literal|','
condition|)
block|{
if|if
condition|(
operator|*
name|current_posn
operator|==
name|END_OF_INSN
condition|)
block|{
if|if
condition|(
name|paren_not_balanced
condition|)
block|{
name|as_bad
argument_list|(
literal|"Unbalanced parenthesis in %s operand."
argument_list|,
name|ordinal_names
index|[
name|insn
operator|.
name|operands
index|]
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
break|break;
comment|/* we are done */
block|}
elseif|else
if|if
condition|(
operator|!
name|is_operand_char
argument_list|(
operator|*
name|current_posn
argument_list|)
operator|&&
operator|!
name|is_space_char
argument_list|(
operator|*
name|current_posn
argument_list|)
condition|)
block|{
name|as_bad
argument_list|(
literal|"Invalid character %s in %s operand"
argument_list|,
name|output_invalid
argument_list|(
operator|*
name|current_posn
argument_list|)
argument_list|,
name|ordinal_names
index|[
name|insn
operator|.
name|operands
index|]
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|*
name|current_posn
operator|==
literal|'('
condition|)
operator|++
name|paren_not_balanced
expr_stmt|;
if|if
condition|(
operator|*
name|current_posn
operator|==
literal|')'
condition|)
operator|--
name|paren_not_balanced
expr_stmt|;
name|current_posn
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|current_posn
operator|!=
name|token_start
condition|)
block|{
comment|/* yes, we've read in another operand */
name|this_operand
operator|=
name|insn
operator|.
name|operands
operator|++
expr_stmt|;
if|if
condition|(
name|insn
operator|.
name|operands
operator|>
name|MAX_OPERANDS
condition|)
block|{
name|as_bad
argument_list|(
literal|"Spurious operands; (%d operands/instruction max)"
argument_list|,
name|MAX_OPERANDS
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* now parse operand adding info to 'insn' as we go along */
name|save_char
operator|=
operator|*
name|current_posn
expr_stmt|;
operator|*
name|current_posn
operator|=
literal|'\0'
expr_stmt|;
name|insn
operator|.
name|operand_type
index|[
name|this_operand
index|]
operator|=
name|tic30_operand
argument_list|(
name|token_start
argument_list|)
expr_stmt|;
operator|*
name|current_posn
operator|=
name|save_char
expr_stmt|;
if|if
condition|(
name|insn
operator|.
name|operand_type
index|[
name|this_operand
index|]
operator|==
name|NULL
condition|)
return|return;
block|}
else|else
block|{
if|if
condition|(
name|expecting_operand
condition|)
block|{
name|as_bad
argument_list|(
literal|"Expecting operand after ','; got nothing"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|*
name|current_posn
operator|==
literal|','
condition|)
block|{
name|as_bad
argument_list|(
literal|"Expecting operand before ','; got nothing"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* now *current_posn must be either ',' or END_OF_INSN */
if|if
condition|(
operator|*
name|current_posn
operator|==
literal|','
condition|)
block|{
if|if
condition|(
operator|*
operator|++
name|current_posn
operator|==
name|END_OF_INSN
condition|)
block|{
comment|/* just skip it, if it's \n complain */
name|as_bad
argument_list|(
literal|"Expecting operand after ','; got nothing"
argument_list|)
expr_stmt|;
return|return;
block|}
name|expecting_operand
operator|=
literal|1
expr_stmt|;
block|}
block|}
do|while
condition|(
operator|*
name|current_posn
operator|!=
name|END_OF_INSN
condition|)
do|;
comment|/* until we get end of insn */
block|}
name|debug
argument_list|(
literal|"Number of operands found: %d\n"
argument_list|,
name|insn
operator|.
name|operands
argument_list|)
expr_stmt|;
comment|/* Check that number of operands is correct */
if|if
condition|(
name|insn
operator|.
name|operands
operator|!=
name|insn
operator|.
name|tm
operator|->
name|operands
condition|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|numops
init|=
name|insn
operator|.
name|tm
operator|->
name|operands
decl_stmt|;
comment|/* If operands are not the same, then see if any of the operands are not          required.  Then recheck with number of given operands.  If they are still not          the same, then give an error, otherwise carry on. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|insn
operator|.
name|tm
operator|->
name|operands
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|insn
operator|.
name|tm
operator|->
name|operand_types
index|[
name|i
index|]
operator|&
name|NotReq
condition|)
name|numops
operator|--
expr_stmt|;
if|if
condition|(
name|insn
operator|.
name|operands
operator|!=
name|numops
condition|)
block|{
name|as_bad
argument_list|(
literal|"Incorrect number of operands given"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|insn
operator|.
name|addressing_mode
operator|=
name|AM_NotReq
expr_stmt|;
for|for
control|(
name|count
operator|=
literal|0
init|;
name|count
operator|<
name|insn
operator|.
name|operands
condition|;
name|count
operator|++
control|)
block|{
if|if
condition|(
name|insn
operator|.
name|operand_type
index|[
name|count
index|]
operator|->
name|op_type
operator|&
name|insn
operator|.
name|tm
operator|->
name|operand_types
index|[
name|count
index|]
condition|)
block|{
name|debug
argument_list|(
literal|"Operand %d matches\n"
argument_list|,
name|count
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* If instruction has two operands and has an AddressMode modifier then set 	     addressing mode type for instruction */
if|if
condition|(
name|insn
operator|.
name|tm
operator|->
name|opcode_modifier
operator|==
name|AddressMode
condition|)
block|{
name|int
name|addr_insn
init|=
literal|0
decl_stmt|;
comment|/* Store instruction uses the second operand for the address mode. */
if|if
condition|(
operator|(
name|insn
operator|.
name|tm
operator|->
name|operand_types
index|[
literal|1
index|]
operator|&
operator|(
name|Indirect
operator||
name|Direct
operator|)
operator|)
operator|==
operator|(
name|Indirect
operator||
name|Direct
operator|)
condition|)
name|addr_insn
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|insn
operator|.
name|operand_type
index|[
name|addr_insn
index|]
operator|->
name|op_type
operator|&
operator|(
name|AllReg
operator|)
condition|)
name|insn
operator|.
name|addressing_mode
operator|=
name|AM_Register
expr_stmt|;
elseif|else
if|if
condition|(
name|insn
operator|.
name|operand_type
index|[
name|addr_insn
index|]
operator|->
name|op_type
operator|&
name|Direct
condition|)
name|insn
operator|.
name|addressing_mode
operator|=
name|AM_Direct
expr_stmt|;
elseif|else
if|if
condition|(
name|insn
operator|.
name|operand_type
index|[
name|addr_insn
index|]
operator|->
name|op_type
operator|&
name|Indirect
condition|)
name|insn
operator|.
name|addressing_mode
operator|=
name|AM_Indirect
expr_stmt|;
else|else
name|insn
operator|.
name|addressing_mode
operator|=
name|AM_Immediate
expr_stmt|;
block|}
block|}
else|else
block|{
name|as_bad
argument_list|(
literal|"The %s operand doesn't match"
argument_list|,
name|ordinal_names
index|[
name|count
index|]
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* Now set the addressing mode for 3 operand instructions. */
if|if
condition|(
operator|(
name|insn
operator|.
name|tm
operator|->
name|operand_types
index|[
literal|0
index|]
operator|&
name|op3T1
operator|)
operator|&&
operator|(
name|insn
operator|.
name|tm
operator|->
name|operand_types
index|[
literal|1
index|]
operator|&
name|op3T2
operator|)
condition|)
block|{
comment|/* Set the addressing mode to the values used for 2 operand instructions in the          G addressing field of the opcode. */
name|char
modifier|*
name|p
decl_stmt|;
switch|switch
condition|(
name|insn
operator|.
name|operand_type
index|[
literal|0
index|]
operator|->
name|op_type
condition|)
block|{
case|case
name|Rn
case|:
case|case
name|ARn
case|:
case|case
name|DPReg
case|:
case|case
name|OtherReg
case|:
if|if
condition|(
name|insn
operator|.
name|operand_type
index|[
literal|1
index|]
operator|->
name|op_type
operator|&
operator|(
name|AllReg
operator|)
condition|)
name|insn
operator|.
name|addressing_mode
operator|=
name|AM_Register
expr_stmt|;
elseif|else
if|if
condition|(
name|insn
operator|.
name|operand_type
index|[
literal|1
index|]
operator|->
name|op_type
operator|&
name|Indirect
condition|)
name|insn
operator|.
name|addressing_mode
operator|=
name|AM_Direct
expr_stmt|;
else|else
block|{
comment|/* Shouldn't make it to this stage */
name|as_bad
argument_list|(
literal|"Incompatible first and second operands in instruction"
argument_list|)
expr_stmt|;
return|return;
block|}
break|break;
case|case
name|Indirect
case|:
if|if
condition|(
name|insn
operator|.
name|operand_type
index|[
literal|1
index|]
operator|->
name|op_type
operator|&
operator|(
name|AllReg
operator|)
condition|)
name|insn
operator|.
name|addressing_mode
operator|=
name|AM_Indirect
expr_stmt|;
elseif|else
if|if
condition|(
name|insn
operator|.
name|operand_type
index|[
literal|1
index|]
operator|->
name|op_type
operator|&
name|Indirect
condition|)
name|insn
operator|.
name|addressing_mode
operator|=
name|AM_Immediate
expr_stmt|;
else|else
block|{
comment|/* Shouldn't make it to this stage */
name|as_bad
argument_list|(
literal|"Incompatible first and second operands in instruction"
argument_list|)
expr_stmt|;
return|return;
block|}
break|break;
block|}
comment|/* Now make up the opcode for the 3 operand instructions.  As in parallel          instructions, there will be no unresolved values, so they can be fully formed          and added to the frag table. */
name|insn
operator|.
name|opcode
operator|=
name|insn
operator|.
name|tm
operator|->
name|base_opcode
expr_stmt|;
if|if
condition|(
name|insn
operator|.
name|operand_type
index|[
literal|0
index|]
operator|->
name|op_type
operator|&
name|Indirect
condition|)
block|{
name|insn
operator|.
name|opcode
operator||=
operator|(
name|insn
operator|.
name|operand_type
index|[
literal|0
index|]
operator|->
name|indirect
operator|.
name|ARnum
operator|)
expr_stmt|;
name|insn
operator|.
name|opcode
operator||=
operator|(
name|insn
operator|.
name|operand_type
index|[
literal|0
index|]
operator|->
name|indirect
operator|.
name|mod
operator|<<
literal|3
operator|)
expr_stmt|;
block|}
else|else
name|insn
operator|.
name|opcode
operator||=
operator|(
name|insn
operator|.
name|operand_type
index|[
literal|0
index|]
operator|->
name|reg
operator|.
name|opcode
operator|)
expr_stmt|;
if|if
condition|(
name|insn
operator|.
name|operand_type
index|[
literal|1
index|]
operator|->
name|op_type
operator|&
name|Indirect
condition|)
block|{
name|insn
operator|.
name|opcode
operator||=
operator|(
name|insn
operator|.
name|operand_type
index|[
literal|1
index|]
operator|->
name|indirect
operator|.
name|ARnum
operator|<<
literal|8
operator|)
expr_stmt|;
name|insn
operator|.
name|opcode
operator||=
operator|(
name|insn
operator|.
name|operand_type
index|[
literal|1
index|]
operator|->
name|indirect
operator|.
name|mod
operator|<<
literal|11
operator|)
expr_stmt|;
block|}
else|else
name|insn
operator|.
name|opcode
operator||=
operator|(
name|insn
operator|.
name|operand_type
index|[
literal|1
index|]
operator|->
name|reg
operator|.
name|opcode
operator|<<
literal|8
operator|)
expr_stmt|;
if|if
condition|(
name|insn
operator|.
name|operands
operator|==
literal|3
condition|)
name|insn
operator|.
name|opcode
operator||=
operator|(
name|insn
operator|.
name|operand_type
index|[
literal|2
index|]
operator|->
name|reg
operator|.
name|opcode
operator|<<
literal|16
operator|)
expr_stmt|;
name|insn
operator|.
name|opcode
operator||=
name|insn
operator|.
name|addressing_mode
expr_stmt|;
name|p
operator|=
name|frag_more
argument_list|(
name|INSN_SIZE
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|p
argument_list|,
operator|(
name|valueT
operator|)
name|insn
operator|.
name|opcode
argument_list|,
name|INSN_SIZE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Not a three operand instruction */
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|am_insn
init|=
operator|-
literal|1
decl_stmt|;
name|insn
operator|.
name|opcode
operator|=
name|insn
operator|.
name|tm
operator|->
name|base_opcode
expr_stmt|;
comment|/* Create frag for instruction - all instructions are 4 bytes long. */
name|p
operator|=
name|frag_more
argument_list|(
name|INSN_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|insn
operator|.
name|operands
operator|>
literal|0
operator|)
operator|&&
operator|(
name|insn
operator|.
name|tm
operator|->
name|opcode_modifier
operator|==
name|AddressMode
operator|)
condition|)
block|{
name|insn
operator|.
name|opcode
operator||=
name|insn
operator|.
name|addressing_mode
expr_stmt|;
if|if
condition|(
name|insn
operator|.
name|addressing_mode
operator|==
name|AM_Indirect
condition|)
block|{
comment|/* Determine which operand gives the addressing mode */
if|if
condition|(
name|insn
operator|.
name|operand_type
index|[
literal|0
index|]
operator|->
name|op_type
operator|&
name|Indirect
condition|)
name|am_insn
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|insn
operator|.
name|operands
operator|>
literal|1
operator|)
operator|&&
operator|(
name|insn
operator|.
name|operand_type
index|[
literal|1
index|]
operator|->
name|op_type
operator|&
name|Indirect
operator|)
condition|)
name|am_insn
operator|=
literal|1
expr_stmt|;
name|insn
operator|.
name|opcode
operator||=
operator|(
name|insn
operator|.
name|operand_type
index|[
name|am_insn
index|]
operator|->
name|indirect
operator|.
name|disp
operator|)
expr_stmt|;
name|insn
operator|.
name|opcode
operator||=
operator|(
name|insn
operator|.
name|operand_type
index|[
name|am_insn
index|]
operator|->
name|indirect
operator|.
name|ARnum
operator|<<
literal|8
operator|)
expr_stmt|;
name|insn
operator|.
name|opcode
operator||=
operator|(
name|insn
operator|.
name|operand_type
index|[
name|am_insn
index|]
operator|->
name|indirect
operator|.
name|mod
operator|<<
literal|11
operator|)
expr_stmt|;
if|if
condition|(
name|insn
operator|.
name|operands
operator|>
literal|1
condition|)
name|insn
operator|.
name|opcode
operator||=
operator|(
name|insn
operator|.
name|operand_type
index|[
operator|!
name|am_insn
index|]
operator|->
name|reg
operator|.
name|opcode
operator|<<
literal|16
operator|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|p
argument_list|,
operator|(
name|valueT
operator|)
name|insn
operator|.
name|opcode
argument_list|,
name|INSN_SIZE
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|insn
operator|.
name|addressing_mode
operator|==
name|AM_Register
condition|)
block|{
name|insn
operator|.
name|opcode
operator||=
operator|(
name|insn
operator|.
name|operand_type
index|[
literal|0
index|]
operator|->
name|reg
operator|.
name|opcode
operator|)
expr_stmt|;
if|if
condition|(
name|insn
operator|.
name|operands
operator|>
literal|1
condition|)
name|insn
operator|.
name|opcode
operator||=
operator|(
name|insn
operator|.
name|operand_type
index|[
literal|1
index|]
operator|->
name|reg
operator|.
name|opcode
operator|<<
literal|16
operator|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|p
argument_list|,
operator|(
name|valueT
operator|)
name|insn
operator|.
name|opcode
argument_list|,
name|INSN_SIZE
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|insn
operator|.
name|addressing_mode
operator|==
name|AM_Direct
condition|)
block|{
if|if
condition|(
name|insn
operator|.
name|operand_type
index|[
literal|0
index|]
operator|->
name|op_type
operator|&
name|Direct
condition|)
name|am_insn
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|insn
operator|.
name|operands
operator|>
literal|1
operator|)
operator|&&
operator|(
name|insn
operator|.
name|operand_type
index|[
literal|1
index|]
operator|->
name|op_type
operator|&
name|Direct
operator|)
condition|)
name|am_insn
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|insn
operator|.
name|operands
operator|>
literal|1
condition|)
name|insn
operator|.
name|opcode
operator||=
operator|(
name|insn
operator|.
name|operand_type
index|[
operator|!
name|am_insn
index|]
operator|->
name|reg
operator|.
name|opcode
operator|<<
literal|16
operator|)
expr_stmt|;
if|if
condition|(
name|insn
operator|.
name|operand_type
index|[
name|am_insn
index|]
operator|->
name|direct
operator|.
name|resolved
operator|==
literal|1
condition|)
block|{
comment|/* Resolved values can be placed straight into instruction word, and output */
name|insn
operator|.
name|opcode
operator||=
operator|(
name|insn
operator|.
name|operand_type
index|[
name|am_insn
index|]
operator|->
name|direct
operator|.
name|address
operator|&
literal|0x0000FFFF
operator|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|p
argument_list|,
operator|(
name|valueT
operator|)
name|insn
operator|.
name|opcode
argument_list|,
name|INSN_SIZE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Unresolved direct addressing mode instruction */
name|md_number_to_chars
argument_list|(
name|p
argument_list|,
operator|(
name|valueT
operator|)
name|insn
operator|.
name|opcode
argument_list|,
name|INSN_SIZE
argument_list|)
expr_stmt|;
name|fix_new_exp
argument_list|(
name|frag_now
argument_list|,
name|p
operator|+
literal|2
operator|-
operator|(
name|frag_now
operator|->
name|fr_literal
operator|)
argument_list|,
literal|2
argument_list|,
operator|&
name|insn
operator|.
name|operand_type
index|[
name|am_insn
index|]
operator|->
name|direct
operator|.
name|direct_expr
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|insn
operator|.
name|addressing_mode
operator|==
name|AM_Immediate
condition|)
block|{
if|if
condition|(
name|insn
operator|.
name|operand_type
index|[
literal|0
index|]
operator|->
name|immediate
operator|.
name|resolved
operator|==
literal|1
condition|)
block|{
name|char
modifier|*
name|keeploc
decl_stmt|;
name|int
name|size
decl_stmt|;
if|if
condition|(
name|insn
operator|.
name|operands
operator|>
literal|1
condition|)
name|insn
operator|.
name|opcode
operator||=
operator|(
name|insn
operator|.
name|operand_type
index|[
literal|1
index|]
operator|->
name|reg
operator|.
name|opcode
operator|<<
literal|16
operator|)
expr_stmt|;
switch|switch
condition|(
name|insn
operator|.
name|tm
operator|->
name|imm_arg_type
condition|)
block|{
case|case
name|Imm_Float
case|:
name|debug
argument_list|(
literal|"Floating point first operand\n"
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|p
argument_list|,
operator|(
name|valueT
operator|)
name|insn
operator|.
name|opcode
argument_list|,
name|INSN_SIZE
argument_list|)
expr_stmt|;
name|keeploc
operator|=
name|input_line_pointer
expr_stmt|;
name|input_line_pointer
operator|=
name|insn
operator|.
name|operand_type
index|[
literal|0
index|]
operator|->
name|immediate
operator|.
name|label
expr_stmt|;
if|if
condition|(
name|md_atof
argument_list|(
literal|'f'
argument_list|,
name|p
operator|+
literal|2
argument_list|,
operator|&
name|size
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|as_bad
argument_list|(
literal|"invalid short form floating point immediate operand"
argument_list|)
expr_stmt|;
return|return;
block|}
name|input_line_pointer
operator|=
name|keeploc
expr_stmt|;
break|break;
case|case
name|Imm_UInt
case|:
name|debug
argument_list|(
literal|"Unsigned int first operand\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn
operator|.
name|operand_type
index|[
literal|0
index|]
operator|->
name|immediate
operator|.
name|decimal_found
condition|)
name|as_warn
argument_list|(
literal|"rounding down first operand float to unsigned int"
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn
operator|.
name|operand_type
index|[
literal|0
index|]
operator|->
name|immediate
operator|.
name|u_number
operator|>
literal|0xFFFF
condition|)
name|as_warn
argument_list|(
literal|"only lower 16-bits of first operand are used"
argument_list|)
expr_stmt|;
name|insn
operator|.
name|opcode
operator||=
operator|(
name|insn
operator|.
name|operand_type
index|[
literal|0
index|]
operator|->
name|immediate
operator|.
name|u_number
operator|&
literal|0x0000FFFFL
operator|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|p
argument_list|,
operator|(
name|valueT
operator|)
name|insn
operator|.
name|opcode
argument_list|,
name|INSN_SIZE
argument_list|)
expr_stmt|;
break|break;
case|case
name|Imm_SInt
case|:
name|debug
argument_list|(
literal|"Int first operand\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn
operator|.
name|operand_type
index|[
literal|0
index|]
operator|->
name|immediate
operator|.
name|decimal_found
condition|)
name|as_warn
argument_list|(
literal|"rounding down first operand float to signed int"
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn
operator|.
name|operand_type
index|[
literal|0
index|]
operator|->
name|immediate
operator|.
name|s_number
operator|<
operator|-
literal|32768
operator|||
name|insn
operator|.
name|operand_type
index|[
literal|0
index|]
operator|->
name|immediate
operator|.
name|s_number
operator|>
literal|32767
condition|)
block|{
name|as_bad
argument_list|(
literal|"first operand is too large for 16-bit signed int"
argument_list|)
expr_stmt|;
return|return;
block|}
name|insn
operator|.
name|opcode
operator||=
operator|(
name|insn
operator|.
name|operand_type
index|[
literal|0
index|]
operator|->
name|immediate
operator|.
name|s_number
operator|&
literal|0x0000FFFFL
operator|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|p
argument_list|,
operator|(
name|valueT
operator|)
name|insn
operator|.
name|opcode
argument_list|,
name|INSN_SIZE
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
comment|/* Unresolved immediate label */
if|if
condition|(
name|insn
operator|.
name|operands
operator|>
literal|1
condition|)
name|insn
operator|.
name|opcode
operator||=
operator|(
name|insn
operator|.
name|operand_type
index|[
literal|1
index|]
operator|->
name|reg
operator|.
name|opcode
operator|<<
literal|16
operator|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|p
argument_list|,
operator|(
name|valueT
operator|)
name|insn
operator|.
name|opcode
argument_list|,
name|INSN_SIZE
argument_list|)
expr_stmt|;
name|fix_new_exp
argument_list|(
name|frag_now
argument_list|,
name|p
operator|+
literal|2
operator|-
operator|(
name|frag_now
operator|->
name|fr_literal
operator|)
argument_list|,
literal|2
argument_list|,
operator|&
name|insn
operator|.
name|operand_type
index|[
literal|0
index|]
operator|->
name|immediate
operator|.
name|imm_expr
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|insn
operator|.
name|tm
operator|->
name|opcode_modifier
operator|==
name|PCRel
condition|)
block|{
comment|/* Conditional Branch and Call instructions */
if|if
condition|(
operator|(
name|insn
operator|.
name|tm
operator|->
name|operand_types
index|[
literal|0
index|]
operator|&
operator|(
name|AllReg
operator||
name|Disp
operator|)
operator|)
operator|==
operator|(
name|AllReg
operator||
name|Disp
operator|)
condition|)
block|{
if|if
condition|(
name|insn
operator|.
name|operand_type
index|[
literal|0
index|]
operator|->
name|op_type
operator|&
operator|(
name|AllReg
operator|)
condition|)
block|{
name|insn
operator|.
name|opcode
operator||=
operator|(
name|insn
operator|.
name|operand_type
index|[
literal|0
index|]
operator|->
name|reg
operator|.
name|opcode
operator|)
expr_stmt|;
name|insn
operator|.
name|opcode
operator||=
name|PC_Register
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|p
argument_list|,
operator|(
name|valueT
operator|)
name|insn
operator|.
name|opcode
argument_list|,
name|INSN_SIZE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|insn
operator|.
name|opcode
operator||=
name|PC_Relative
expr_stmt|;
if|if
condition|(
name|insn
operator|.
name|operand_type
index|[
literal|0
index|]
operator|->
name|immediate
operator|.
name|resolved
operator|==
literal|1
condition|)
block|{
name|insn
operator|.
name|opcode
operator||=
operator|(
name|insn
operator|.
name|operand_type
index|[
literal|0
index|]
operator|->
name|immediate
operator|.
name|s_number
operator|&
literal|0x0000FFFF
operator|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|p
argument_list|,
operator|(
name|valueT
operator|)
name|insn
operator|.
name|opcode
argument_list|,
name|INSN_SIZE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|md_number_to_chars
argument_list|(
name|p
argument_list|,
operator|(
name|valueT
operator|)
name|insn
operator|.
name|opcode
argument_list|,
name|INSN_SIZE
argument_list|)
expr_stmt|;
name|fix_new_exp
argument_list|(
name|frag_now
argument_list|,
name|p
operator|+
literal|2
operator|-
operator|(
name|frag_now
operator|->
name|fr_literal
operator|)
argument_list|,
literal|2
argument_list|,
operator|&
name|insn
operator|.
name|operand_type
index|[
literal|0
index|]
operator|->
name|immediate
operator|.
name|imm_expr
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|insn
operator|.
name|tm
operator|->
name|operand_types
index|[
literal|0
index|]
operator|&
name|ARn
operator|)
operator|==
name|ARn
condition|)
block|{
comment|/* Decrement and Branch instructions */
name|insn
operator|.
name|opcode
operator||=
operator|(
operator|(
name|insn
operator|.
name|operand_type
index|[
literal|0
index|]
operator|->
name|reg
operator|.
name|opcode
operator|-
literal|0x08
operator|)
operator|<<
literal|22
operator|)
expr_stmt|;
if|if
condition|(
name|insn
operator|.
name|operand_type
index|[
literal|1
index|]
operator|->
name|op_type
operator|&
operator|(
name|AllReg
operator|)
condition|)
block|{
name|insn
operator|.
name|opcode
operator||=
operator|(
name|insn
operator|.
name|operand_type
index|[
literal|1
index|]
operator|->
name|reg
operator|.
name|opcode
operator|)
expr_stmt|;
name|insn
operator|.
name|opcode
operator||=
name|PC_Register
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|p
argument_list|,
operator|(
name|valueT
operator|)
name|insn
operator|.
name|opcode
argument_list|,
name|INSN_SIZE
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|insn
operator|.
name|operand_type
index|[
literal|1
index|]
operator|->
name|immediate
operator|.
name|resolved
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|insn
operator|.
name|operand_type
index|[
literal|0
index|]
operator|->
name|immediate
operator|.
name|decimal_found
condition|)
block|{
name|as_bad
argument_list|(
literal|"first operand is floating point"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|insn
operator|.
name|operand_type
index|[
literal|0
index|]
operator|->
name|immediate
operator|.
name|s_number
operator|<
operator|-
literal|32768
operator|||
name|insn
operator|.
name|operand_type
index|[
literal|0
index|]
operator|->
name|immediate
operator|.
name|s_number
operator|>
literal|32767
condition|)
block|{
name|as_bad
argument_list|(
literal|"first operand is too large for 16-bit signed int"
argument_list|)
expr_stmt|;
return|return;
block|}
name|insn
operator|.
name|opcode
operator||=
operator|(
name|insn
operator|.
name|operand_type
index|[
literal|1
index|]
operator|->
name|immediate
operator|.
name|s_number
operator|)
expr_stmt|;
name|insn
operator|.
name|opcode
operator||=
name|PC_Relative
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|p
argument_list|,
operator|(
name|valueT
operator|)
name|insn
operator|.
name|opcode
argument_list|,
name|INSN_SIZE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|insn
operator|.
name|opcode
operator||=
name|PC_Relative
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|p
argument_list|,
operator|(
name|valueT
operator|)
name|insn
operator|.
name|opcode
argument_list|,
name|INSN_SIZE
argument_list|)
expr_stmt|;
name|fix_new_exp
argument_list|(
name|frag_now
argument_list|,
name|p
operator|+
literal|2
operator|-
name|frag_now
operator|->
name|fr_literal
argument_list|,
literal|2
argument_list|,
operator|&
name|insn
operator|.
name|operand_type
index|[
literal|1
index|]
operator|->
name|immediate
operator|.
name|imm_expr
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|insn
operator|.
name|tm
operator|->
name|operand_types
index|[
literal|0
index|]
operator|==
name|IVector
condition|)
block|{
comment|/* Trap instructions */
if|if
condition|(
name|insn
operator|.
name|operand_type
index|[
literal|0
index|]
operator|->
name|op_type
operator|&
name|IVector
condition|)
name|insn
operator|.
name|opcode
operator||=
operator|(
name|insn
operator|.
name|operand_type
index|[
literal|0
index|]
operator|->
name|immediate
operator|.
name|u_number
operator|)
expr_stmt|;
else|else
block|{
comment|/* Shouldn't get here */
name|as_bad
argument_list|(
literal|"interrupt vector for trap instruction out of range"
argument_list|)
expr_stmt|;
return|return;
block|}
name|md_number_to_chars
argument_list|(
name|p
argument_list|,
operator|(
name|valueT
operator|)
name|insn
operator|.
name|opcode
argument_list|,
name|INSN_SIZE
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|insn
operator|.
name|tm
operator|->
name|opcode_modifier
operator|==
name|StackOp
operator|||
name|insn
operator|.
name|tm
operator|->
name|opcode_modifier
operator|==
name|Rotate
condition|)
block|{
comment|/* Push, Pop and Rotate instructions */
name|insn
operator|.
name|opcode
operator||=
operator|(
name|insn
operator|.
name|operand_type
index|[
literal|0
index|]
operator|->
name|reg
operator|.
name|opcode
operator|<<
literal|16
operator|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|p
argument_list|,
operator|(
name|valueT
operator|)
name|insn
operator|.
name|opcode
argument_list|,
name|INSN_SIZE
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|insn
operator|.
name|tm
operator|->
name|operand_types
index|[
literal|0
index|]
operator|&
operator|(
name|Abs24
operator||
name|Direct
operator|)
operator|)
operator|==
operator|(
name|Abs24
operator||
name|Direct
operator|)
condition|)
block|{
comment|/* LDP Instruction needs to be tested for before the next section */
if|if
condition|(
name|insn
operator|.
name|operand_type
index|[
literal|0
index|]
operator|->
name|op_type
operator|&
name|Direct
condition|)
block|{
if|if
condition|(
name|insn
operator|.
name|operand_type
index|[
literal|0
index|]
operator|->
name|direct
operator|.
name|resolved
operator|==
literal|1
condition|)
block|{
comment|/* Direct addressing uses lower 8 bits of direct address */
name|insn
operator|.
name|opcode
operator||=
operator|(
name|insn
operator|.
name|operand_type
index|[
literal|0
index|]
operator|->
name|direct
operator|.
name|address
operator|&
literal|0x00FF0000
operator|)
operator|>>
literal|16
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|p
argument_list|,
operator|(
name|valueT
operator|)
name|insn
operator|.
name|opcode
argument_list|,
name|INSN_SIZE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fixS
modifier|*
name|fix
decl_stmt|;
name|md_number_to_chars
argument_list|(
name|p
argument_list|,
operator|(
name|valueT
operator|)
name|insn
operator|.
name|opcode
argument_list|,
name|INSN_SIZE
argument_list|)
expr_stmt|;
name|fix
operator|=
name|fix_new_exp
argument_list|(
name|frag_now
argument_list|,
name|p
operator|+
literal|3
operator|-
operator|(
name|frag_now
operator|->
name|fr_literal
operator|)
argument_list|,
literal|1
argument_list|,
operator|&
name|insn
operator|.
name|operand_type
index|[
literal|0
index|]
operator|->
name|direct
operator|.
name|direct_expr
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Ensure that the assembler doesn't complain about fitting a 24-bit 		     address into 8 bits. */
name|fix
operator|->
name|fx_no_overflow
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|insn
operator|.
name|operand_type
index|[
literal|0
index|]
operator|->
name|immediate
operator|.
name|resolved
operator|==
literal|1
condition|)
block|{
comment|/* Immediate addressing uses upper 8 bits of address */
if|if
condition|(
name|insn
operator|.
name|operand_type
index|[
literal|0
index|]
operator|->
name|immediate
operator|.
name|u_number
operator|>
literal|0x00FFFFFF
condition|)
block|{
name|as_bad
argument_list|(
literal|"LDP instruction needs a 24-bit operand"
argument_list|)
expr_stmt|;
return|return;
block|}
name|insn
operator|.
name|opcode
operator||=
operator|(
operator|(
name|insn
operator|.
name|operand_type
index|[
literal|0
index|]
operator|->
name|immediate
operator|.
name|u_number
operator|&
literal|0x00FF0000
operator|)
operator|>>
literal|16
operator|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|p
argument_list|,
operator|(
name|valueT
operator|)
name|insn
operator|.
name|opcode
argument_list|,
name|INSN_SIZE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fixS
modifier|*
name|fix
decl_stmt|;
name|md_number_to_chars
argument_list|(
name|p
argument_list|,
operator|(
name|valueT
operator|)
name|insn
operator|.
name|opcode
argument_list|,
name|INSN_SIZE
argument_list|)
expr_stmt|;
name|fix
operator|=
name|fix_new_exp
argument_list|(
name|frag_now
argument_list|,
name|p
operator|+
literal|3
operator|-
operator|(
name|frag_now
operator|->
name|fr_literal
operator|)
argument_list|,
literal|1
argument_list|,
operator|&
name|insn
operator|.
name|operand_type
index|[
literal|0
index|]
operator|->
name|immediate
operator|.
name|imm_expr
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fix
operator|->
name|fx_no_overflow
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|insn
operator|.
name|tm
operator|->
name|operand_types
index|[
literal|0
index|]
operator|&
operator|(
name|Imm24
operator|)
condition|)
block|{
comment|/* Unconditional Branch and Call instructions */
if|if
condition|(
name|insn
operator|.
name|operand_type
index|[
literal|0
index|]
operator|->
name|immediate
operator|.
name|resolved
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|insn
operator|.
name|operand_type
index|[
literal|0
index|]
operator|->
name|immediate
operator|.
name|u_number
operator|>
literal|0x00FFFFFF
condition|)
name|as_warn
argument_list|(
literal|"first operand is too large for a 24-bit displacement"
argument_list|)
expr_stmt|;
name|insn
operator|.
name|opcode
operator||=
operator|(
name|insn
operator|.
name|operand_type
index|[
literal|0
index|]
operator|->
name|immediate
operator|.
name|u_number
operator|&
literal|0x00FFFFFF
operator|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|p
argument_list|,
operator|(
name|valueT
operator|)
name|insn
operator|.
name|opcode
argument_list|,
name|INSN_SIZE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|md_number_to_chars
argument_list|(
name|p
argument_list|,
operator|(
name|valueT
operator|)
name|insn
operator|.
name|opcode
argument_list|,
name|INSN_SIZE
argument_list|)
expr_stmt|;
name|fix_new_exp
argument_list|(
name|frag_now
argument_list|,
name|p
operator|+
literal|1
operator|-
operator|(
name|frag_now
operator|->
name|fr_literal
operator|)
argument_list|,
literal|3
argument_list|,
operator|&
name|insn
operator|.
name|operand_type
index|[
literal|0
index|]
operator|->
name|immediate
operator|.
name|imm_expr
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|insn
operator|.
name|tm
operator|->
name|operand_types
index|[
literal|0
index|]
operator|&
name|NotReq
condition|)
block|{
comment|/* Check for NOP instruction without arguments. */
name|md_number_to_chars
argument_list|(
name|p
argument_list|,
operator|(
name|valueT
operator|)
name|insn
operator|.
name|opcode
argument_list|,
name|INSN_SIZE
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|insn
operator|.
name|tm
operator|->
name|operands
operator|==
literal|0
condition|)
block|{
comment|/* Check for instructions without operands. */
name|md_number_to_chars
argument_list|(
name|p
argument_list|,
operator|(
name|valueT
operator|)
name|insn
operator|.
name|opcode
argument_list|,
name|INSN_SIZE
argument_list|)
expr_stmt|;
block|}
block|}
name|debug
argument_list|(
literal|"Addressing mode: %08X\n"
argument_list|,
name|insn
operator|.
name|addressing_mode
argument_list|)
expr_stmt|;
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|insn
operator|.
name|operands
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|insn
operator|.
name|operand_type
index|[
name|i
index|]
operator|->
name|immediate
operator|.
name|label
condition|)
name|free
argument_list|(
name|insn
operator|.
name|operand_type
index|[
name|i
index|]
operator|->
name|immediate
operator|.
name|label
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|insn
operator|.
name|operand_type
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|debug
argument_list|(
literal|"Final opcode: %08X\n"
argument_list|,
name|insn
operator|.
name|opcode
argument_list|)
expr_stmt|;
name|debug
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_struct
struct|struct
name|tic30_par_insn
block|{
name|partemplate
modifier|*
name|tm
decl_stmt|;
comment|/* Template of current parallel instruction */
name|int
name|operands
index|[
literal|2
index|]
decl_stmt|;
comment|/* Number of given operands for each insn */
comment|/* Type of operand given in instruction */
name|operand
modifier|*
name|operand_type
index|[
literal|2
index|]
index|[
name|MAX_OPERANDS
index|]
decl_stmt|;
name|int
name|swap_operands
decl_stmt|;
comment|/* Whether to swap operands around. */
name|unsigned
name|p_field
decl_stmt|;
comment|/* Value of p field in multiply add/sub instructions */
name|unsigned
name|opcode
decl_stmt|;
comment|/* Final opcode */
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|tic30_par_insn
name|p_insn
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|tic30_parallel_insn
parameter_list|(
name|char
modifier|*
name|token
parameter_list|)
block|{
specifier|static
name|partemplate
modifier|*
name|p_opcode
decl_stmt|;
name|char
modifier|*
name|current_posn
init|=
name|token
decl_stmt|;
name|char
modifier|*
name|token_start
decl_stmt|;
name|char
name|save_char
decl_stmt|;
name|debug
argument_list|(
literal|"In tic30_parallel_insn with %s\n"
argument_list|,
name|token
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|p_insn
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
name|p_insn
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|is_opcode_char
argument_list|(
operator|*
name|current_posn
argument_list|)
condition|)
name|current_posn
operator|++
expr_stmt|;
block|{
comment|/* Find instruction */
name|save_char
operator|=
operator|*
name|current_posn
expr_stmt|;
operator|*
name|current_posn
operator|=
literal|'\0'
expr_stmt|;
name|p_opcode
operator|=
operator|(
name|partemplate
operator|*
operator|)
name|hash_find
argument_list|(
name|parop_hash
argument_list|,
name|token
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_opcode
condition|)
block|{
name|debug
argument_list|(
literal|"Found instruction %s\n"
argument_list|,
name|p_opcode
operator|->
name|name
argument_list|)
expr_stmt|;
name|p_insn
operator|.
name|tm
operator|=
name|p_opcode
expr_stmt|;
block|}
else|else
block|{
name|char
name|first_opcode
index|[
literal|6
index|]
init|=
block|{
literal|0
block|}
decl_stmt|;
name|char
name|second_opcode
index|[
literal|6
index|]
init|=
block|{
literal|0
block|}
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|current_opcode
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|char_ptr
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|strlen
argument_list|(
name|token
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|char
name|ch
init|=
operator|*
operator|(
name|token
operator|+
name|i
operator|)
decl_stmt|;
if|if
condition|(
name|ch
operator|==
literal|'_'
operator|&&
name|current_opcode
operator|==
operator|-
literal|1
condition|)
block|{
name|current_opcode
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|ch
operator|==
literal|'_'
operator|&&
name|current_opcode
operator|==
literal|0
condition|)
block|{
name|current_opcode
operator|=
literal|1
expr_stmt|;
name|char_ptr
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
switch|switch
condition|(
name|current_opcode
condition|)
block|{
case|case
literal|0
case|:
name|first_opcode
index|[
name|char_ptr
operator|++
index|]
operator|=
name|ch
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|second_opcode
index|[
name|char_ptr
operator|++
index|]
operator|=
name|ch
expr_stmt|;
break|break;
block|}
block|}
name|debug
argument_list|(
literal|"first_opcode = %s\n"
argument_list|,
name|first_opcode
argument_list|)
expr_stmt|;
name|debug
argument_list|(
literal|"second_opcode = %s\n"
argument_list|,
name|second_opcode
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|token
argument_list|,
literal|"q_%s_%s"
argument_list|,
name|second_opcode
argument_list|,
name|first_opcode
argument_list|)
expr_stmt|;
name|p_opcode
operator|=
operator|(
name|partemplate
operator|*
operator|)
name|hash_find
argument_list|(
name|parop_hash
argument_list|,
name|token
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_opcode
condition|)
block|{
name|debug
argument_list|(
literal|"Found instruction %s\n"
argument_list|,
name|p_opcode
operator|->
name|name
argument_list|)
expr_stmt|;
name|p_insn
operator|.
name|tm
operator|=
name|p_opcode
expr_stmt|;
name|p_insn
operator|.
name|swap_operands
operator|=
literal|1
expr_stmt|;
block|}
else|else
return|return
literal|0
return|;
block|}
operator|*
name|current_posn
operator|=
name|save_char
expr_stmt|;
block|}
block|{
comment|/* Find operands */
name|int
name|paren_not_balanced
decl_stmt|;
name|int
name|expecting_operand
init|=
literal|0
decl_stmt|;
name|int
name|found_separator
init|=
literal|0
decl_stmt|;
do|do
block|{
comment|/* skip optional white space before operand */
while|while
condition|(
operator|!
name|is_operand_char
argument_list|(
operator|*
name|current_posn
argument_list|)
operator|&&
operator|*
name|current_posn
operator|!=
name|END_OF_INSN
condition|)
block|{
if|if
condition|(
operator|!
name|is_space_char
argument_list|(
operator|*
name|current_posn
argument_list|)
operator|&&
operator|*
name|current_posn
operator|!=
name|PARALLEL_SEPARATOR
condition|)
block|{
name|as_bad
argument_list|(
literal|"Invalid character %s before %s operand"
argument_list|,
name|output_invalid
argument_list|(
operator|*
name|current_posn
argument_list|)
argument_list|,
name|ordinal_names
index|[
name|insn
operator|.
name|operands
index|]
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
operator|*
name|current_posn
operator|==
name|PARALLEL_SEPARATOR
condition|)
name|found_separator
operator|=
literal|1
expr_stmt|;
name|current_posn
operator|++
expr_stmt|;
block|}
name|token_start
operator|=
name|current_posn
expr_stmt|;
comment|/* after white space */
name|paren_not_balanced
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|paren_not_balanced
operator|||
operator|*
name|current_posn
operator|!=
literal|','
condition|)
block|{
if|if
condition|(
operator|*
name|current_posn
operator|==
name|END_OF_INSN
condition|)
block|{
if|if
condition|(
name|paren_not_balanced
condition|)
block|{
name|as_bad
argument_list|(
literal|"Unbalanced parenthesis in %s operand."
argument_list|,
name|ordinal_names
index|[
name|insn
operator|.
name|operands
index|]
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
break|break;
comment|/* we are done */
block|}
elseif|else
if|if
condition|(
operator|*
name|current_posn
operator|==
name|PARALLEL_SEPARATOR
condition|)
block|{
while|while
condition|(
name|is_space_char
argument_list|(
operator|*
operator|(
name|current_posn
operator|-
literal|1
operator|)
argument_list|)
condition|)
name|current_posn
operator|--
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
operator|!
name|is_operand_char
argument_list|(
operator|*
name|current_posn
argument_list|)
operator|&&
operator|!
name|is_space_char
argument_list|(
operator|*
name|current_posn
argument_list|)
condition|)
block|{
name|as_bad
argument_list|(
literal|"Invalid character %s in %s operand"
argument_list|,
name|output_invalid
argument_list|(
operator|*
name|current_posn
argument_list|)
argument_list|,
name|ordinal_names
index|[
name|insn
operator|.
name|operands
index|]
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
operator|*
name|current_posn
operator|==
literal|'('
condition|)
operator|++
name|paren_not_balanced
expr_stmt|;
if|if
condition|(
operator|*
name|current_posn
operator|==
literal|')'
condition|)
operator|--
name|paren_not_balanced
expr_stmt|;
name|current_posn
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|current_posn
operator|!=
name|token_start
condition|)
block|{
comment|/* yes, we've read in another operand */
name|p_insn
operator|.
name|operands
index|[
name|found_separator
index|]
operator|++
expr_stmt|;
if|if
condition|(
name|p_insn
operator|.
name|operands
index|[
name|found_separator
index|]
operator|>
name|MAX_OPERANDS
condition|)
block|{
name|as_bad
argument_list|(
literal|"Spurious operands; (%d operands/instruction max)"
argument_list|,
name|MAX_OPERANDS
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* now parse operand adding info to 'insn' as we go along */
name|save_char
operator|=
operator|*
name|current_posn
expr_stmt|;
operator|*
name|current_posn
operator|=
literal|'\0'
expr_stmt|;
name|p_insn
operator|.
name|operand_type
index|[
name|found_separator
index|]
index|[
name|p_insn
operator|.
name|operands
index|[
name|found_separator
index|]
operator|-
literal|1
index|]
operator|=
name|tic30_operand
argument_list|(
name|token_start
argument_list|)
expr_stmt|;
operator|*
name|current_posn
operator|=
name|save_char
expr_stmt|;
if|if
condition|(
operator|!
name|p_insn
operator|.
name|operand_type
index|[
name|found_separator
index|]
index|[
name|p_insn
operator|.
name|operands
index|[
name|found_separator
index|]
operator|-
literal|1
index|]
condition|)
return|return
literal|1
return|;
block|}
else|else
block|{
if|if
condition|(
name|expecting_operand
condition|)
block|{
name|as_bad
argument_list|(
literal|"Expecting operand after ','; got nothing"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
operator|*
name|current_posn
operator|==
literal|','
condition|)
block|{
name|as_bad
argument_list|(
literal|"Expecting operand before ','; got nothing"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
comment|/* now *current_posn must be either ',' or END_OF_INSN */
if|if
condition|(
operator|*
name|current_posn
operator|==
literal|','
condition|)
block|{
if|if
condition|(
operator|*
operator|++
name|current_posn
operator|==
name|END_OF_INSN
condition|)
block|{
comment|/* just skip it, if it's \n complain */
name|as_bad
argument_list|(
literal|"Expecting operand after ','; got nothing"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|expecting_operand
operator|=
literal|1
expr_stmt|;
block|}
block|}
do|while
condition|(
operator|*
name|current_posn
operator|!=
name|END_OF_INSN
condition|)
do|;
comment|/* until we get end of insn */
block|}
if|if
condition|(
name|p_insn
operator|.
name|swap_operands
condition|)
block|{
name|int
name|temp_num
decl_stmt|,
name|i
decl_stmt|;
name|operand
modifier|*
name|temp_op
decl_stmt|;
name|temp_num
operator|=
name|p_insn
operator|.
name|operands
index|[
literal|0
index|]
expr_stmt|;
name|p_insn
operator|.
name|operands
index|[
literal|0
index|]
operator|=
name|p_insn
operator|.
name|operands
index|[
literal|1
index|]
expr_stmt|;
name|p_insn
operator|.
name|operands
index|[
literal|1
index|]
operator|=
name|temp_num
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_OPERANDS
condition|;
name|i
operator|++
control|)
block|{
name|temp_op
operator|=
name|p_insn
operator|.
name|operand_type
index|[
literal|0
index|]
index|[
name|i
index|]
expr_stmt|;
name|p_insn
operator|.
name|operand_type
index|[
literal|0
index|]
index|[
name|i
index|]
operator|=
name|p_insn
operator|.
name|operand_type
index|[
literal|1
index|]
index|[
name|i
index|]
expr_stmt|;
name|p_insn
operator|.
name|operand_type
index|[
literal|1
index|]
index|[
name|i
index|]
operator|=
name|temp_op
expr_stmt|;
block|}
block|}
if|if
condition|(
name|p_insn
operator|.
name|operands
index|[
literal|0
index|]
operator|!=
name|p_insn
operator|.
name|tm
operator|->
name|operands_1
condition|)
block|{
name|as_bad
argument_list|(
literal|"incorrect number of operands given in the first instruction"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|p_insn
operator|.
name|operands
index|[
literal|1
index|]
operator|!=
name|p_insn
operator|.
name|tm
operator|->
name|operands_2
condition|)
block|{
name|as_bad
argument_list|(
literal|"incorrect number of operands given in the second instruction"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|debug
argument_list|(
literal|"Number of operands in first insn: %d\n"
argument_list|,
name|p_insn
operator|.
name|operands
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|debug
argument_list|(
literal|"Number of operands in second insn: %d\n"
argument_list|,
name|p_insn
operator|.
name|operands
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|{
comment|/* Now check if operands are correct */
name|int
name|count
decl_stmt|;
name|int
name|num_rn
init|=
literal|0
decl_stmt|;
name|int
name|num_ind
init|=
literal|0
decl_stmt|;
for|for
control|(
name|count
operator|=
literal|0
init|;
name|count
operator|<
literal|2
condition|;
name|count
operator|++
control|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p_insn
operator|.
name|operands
index|[
name|count
index|]
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|p_insn
operator|.
name|operand_type
index|[
name|count
index|]
index|[
name|i
index|]
operator|->
name|op_type
operator|&
name|p_insn
operator|.
name|tm
operator|->
name|operand_types
index|[
name|count
index|]
index|[
name|i
index|]
operator|)
operator|==
literal|0
condition|)
block|{
name|as_bad
argument_list|(
literal|"%s instruction, operand %d doesn't match"
argument_list|,
name|ordinal_names
index|[
name|count
index|]
argument_list|,
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* Get number of R register and indirect reference contained within the first 	       two operands of each instruction.  This is required for the multiply 	       parallel instructions which require two R registers and two indirect 	       references, but not in any particular place. */
if|if
condition|(
operator|(
name|p_insn
operator|.
name|operand_type
index|[
name|count
index|]
index|[
name|i
index|]
operator|->
name|op_type
operator|&
name|Rn
operator|)
operator|&&
name|i
operator|<
literal|2
condition|)
name|num_rn
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|p_insn
operator|.
name|operand_type
index|[
name|count
index|]
index|[
name|i
index|]
operator|->
name|op_type
operator|&
name|Indirect
operator|)
operator|&&
name|i
operator|<
literal|2
condition|)
name|num_ind
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|p_insn
operator|.
name|tm
operator|->
name|operand_types
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|&
operator|(
name|Indirect
operator||
name|Rn
operator|)
operator|)
operator|==
operator|(
name|Indirect
operator||
name|Rn
operator|)
condition|)
block|{
comment|/* Check for the multiply instructions */
if|if
condition|(
name|num_rn
operator|!=
literal|2
condition|)
block|{
name|as_bad
argument_list|(
literal|"incorrect format for multiply parallel instruction"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|num_ind
operator|!=
literal|2
condition|)
block|{
comment|/* Shouldn't get here */
name|as_bad
argument_list|(
literal|"incorrect format for multiply parallel instruction"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
operator|(
name|p_insn
operator|.
name|operand_type
index|[
literal|0
index|]
index|[
literal|2
index|]
operator|->
name|reg
operator|.
name|opcode
operator|!=
literal|0x00
operator|)
operator|&&
operator|(
name|p_insn
operator|.
name|operand_type
index|[
literal|0
index|]
index|[
literal|2
index|]
operator|->
name|reg
operator|.
name|opcode
operator|!=
literal|0x01
operator|)
condition|)
block|{
name|as_bad
argument_list|(
literal|"destination for multiply can only be R0 or R1"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
operator|(
name|p_insn
operator|.
name|operand_type
index|[
literal|1
index|]
index|[
literal|2
index|]
operator|->
name|reg
operator|.
name|opcode
operator|!=
literal|0x02
operator|)
operator|&&
operator|(
name|p_insn
operator|.
name|operand_type
index|[
literal|1
index|]
index|[
literal|2
index|]
operator|->
name|reg
operator|.
name|opcode
operator|!=
literal|0x03
operator|)
condition|)
block|{
name|as_bad
argument_list|(
literal|"destination for add/subtract can only be R2 or R3"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* Now determine the P field for the instruction */
if|if
condition|(
name|p_insn
operator|.
name|operand_type
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|->
name|op_type
operator|&
name|Indirect
condition|)
block|{
if|if
condition|(
name|p_insn
operator|.
name|operand_type
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|->
name|op_type
operator|&
name|Indirect
condition|)
name|p_insn
operator|.
name|p_field
operator|=
literal|0x00000000
expr_stmt|;
comment|/* Ind * Ind, Rn  +/- Rn  */
elseif|else
if|if
condition|(
name|p_insn
operator|.
name|operand_type
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|->
name|op_type
operator|&
name|Indirect
condition|)
name|p_insn
operator|.
name|p_field
operator|=
literal|0x01000000
expr_stmt|;
comment|/* Ind * Rn,  Ind +/- Rn  */
else|else
name|p_insn
operator|.
name|p_field
operator|=
literal|0x03000000
expr_stmt|;
comment|/* Ind * Rn,  Rn  +/- Ind */
block|}
else|else
block|{
if|if
condition|(
name|p_insn
operator|.
name|operand_type
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|->
name|op_type
operator|&
name|Rn
condition|)
name|p_insn
operator|.
name|p_field
operator|=
literal|0x02000000
expr_stmt|;
comment|/* Rn  * Rn,  Ind +/- Ind */
elseif|else
if|if
condition|(
name|p_insn
operator|.
name|operand_type
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|->
name|op_type
operator|&
name|Indirect
condition|)
block|{
name|operand
modifier|*
name|temp
decl_stmt|;
name|p_insn
operator|.
name|p_field
operator|=
literal|0x01000000
expr_stmt|;
comment|/* Rn  * Ind, Ind +/- Rn  */
comment|/* Need to swap the two multiply operands around so that everything is in 		   its place for the opcode makeup ie so Ind * Rn, Ind +/- Rn */
name|temp
operator|=
name|p_insn
operator|.
name|operand_type
index|[
literal|0
index|]
index|[
literal|0
index|]
expr_stmt|;
name|p_insn
operator|.
name|operand_type
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|=
name|p_insn
operator|.
name|operand_type
index|[
literal|0
index|]
index|[
literal|1
index|]
expr_stmt|;
name|p_insn
operator|.
name|operand_type
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|=
name|temp
expr_stmt|;
block|}
else|else
block|{
name|operand
modifier|*
name|temp
decl_stmt|;
name|p_insn
operator|.
name|p_field
operator|=
literal|0x03000000
expr_stmt|;
comment|/* Rn  * Ind, Rn  +/- Ind */
name|temp
operator|=
name|p_insn
operator|.
name|operand_type
index|[
literal|0
index|]
index|[
literal|0
index|]
expr_stmt|;
name|p_insn
operator|.
name|operand_type
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|=
name|p_insn
operator|.
name|operand_type
index|[
literal|0
index|]
index|[
literal|1
index|]
expr_stmt|;
name|p_insn
operator|.
name|operand_type
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|=
name|temp
expr_stmt|;
block|}
block|}
block|}
block|}
name|debug
argument_list|(
literal|"P field: %08X\n"
argument_list|,
name|p_insn
operator|.
name|p_field
argument_list|)
expr_stmt|;
comment|/* Finalise opcode.  This is easier for parallel instructions as they have to be      fully resolved, there are no memory addresses allowed, except through indirect      addressing, so there are no labels to resolve. */
block|{
name|p_insn
operator|.
name|opcode
operator|=
name|p_insn
operator|.
name|tm
operator|->
name|base_opcode
expr_stmt|;
switch|switch
condition|(
name|p_insn
operator|.
name|tm
operator|->
name|oporder
condition|)
block|{
case|case
name|OO_4op1
case|:
name|p_insn
operator|.
name|opcode
operator||=
operator|(
name|p_insn
operator|.
name|operand_type
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|->
name|indirect
operator|.
name|ARnum
operator|)
expr_stmt|;
name|p_insn
operator|.
name|opcode
operator||=
operator|(
name|p_insn
operator|.
name|operand_type
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|->
name|indirect
operator|.
name|mod
operator|<<
literal|3
operator|)
expr_stmt|;
name|p_insn
operator|.
name|opcode
operator||=
operator|(
name|p_insn
operator|.
name|operand_type
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|->
name|indirect
operator|.
name|ARnum
operator|<<
literal|8
operator|)
expr_stmt|;
name|p_insn
operator|.
name|opcode
operator||=
operator|(
name|p_insn
operator|.
name|operand_type
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|->
name|indirect
operator|.
name|mod
operator|<<
literal|11
operator|)
expr_stmt|;
name|p_insn
operator|.
name|opcode
operator||=
operator|(
name|p_insn
operator|.
name|operand_type
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|->
name|reg
operator|.
name|opcode
operator|<<
literal|16
operator|)
expr_stmt|;
name|p_insn
operator|.
name|opcode
operator||=
operator|(
name|p_insn
operator|.
name|operand_type
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|->
name|reg
operator|.
name|opcode
operator|<<
literal|22
operator|)
expr_stmt|;
break|break;
case|case
name|OO_4op2
case|:
name|p_insn
operator|.
name|opcode
operator||=
operator|(
name|p_insn
operator|.
name|operand_type
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|->
name|indirect
operator|.
name|ARnum
operator|)
expr_stmt|;
name|p_insn
operator|.
name|opcode
operator||=
operator|(
name|p_insn
operator|.
name|operand_type
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|->
name|indirect
operator|.
name|mod
operator|<<
literal|3
operator|)
expr_stmt|;
name|p_insn
operator|.
name|opcode
operator||=
operator|(
name|p_insn
operator|.
name|operand_type
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|->
name|indirect
operator|.
name|ARnum
operator|<<
literal|8
operator|)
expr_stmt|;
name|p_insn
operator|.
name|opcode
operator||=
operator|(
name|p_insn
operator|.
name|operand_type
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|->
name|indirect
operator|.
name|mod
operator|<<
literal|11
operator|)
expr_stmt|;
name|p_insn
operator|.
name|opcode
operator||=
operator|(
name|p_insn
operator|.
name|operand_type
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|->
name|reg
operator|.
name|opcode
operator|<<
literal|19
operator|)
expr_stmt|;
name|p_insn
operator|.
name|opcode
operator||=
operator|(
name|p_insn
operator|.
name|operand_type
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|->
name|reg
operator|.
name|opcode
operator|<<
literal|22
operator|)
expr_stmt|;
if|if
condition|(
name|p_insn
operator|.
name|operand_type
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|->
name|reg
operator|.
name|opcode
operator|==
name|p_insn
operator|.
name|operand_type
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|->
name|reg
operator|.
name|opcode
condition|)
name|as_warn
argument_list|(
literal|"loading the same register in parallel operation"
argument_list|)
expr_stmt|;
break|break;
case|case
name|OO_4op3
case|:
name|p_insn
operator|.
name|opcode
operator||=
operator|(
name|p_insn
operator|.
name|operand_type
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|->
name|indirect
operator|.
name|ARnum
operator|)
expr_stmt|;
name|p_insn
operator|.
name|opcode
operator||=
operator|(
name|p_insn
operator|.
name|operand_type
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|->
name|indirect
operator|.
name|mod
operator|<<
literal|3
operator|)
expr_stmt|;
name|p_insn
operator|.
name|opcode
operator||=
operator|(
name|p_insn
operator|.
name|operand_type
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|->
name|indirect
operator|.
name|ARnum
operator|<<
literal|8
operator|)
expr_stmt|;
name|p_insn
operator|.
name|opcode
operator||=
operator|(
name|p_insn
operator|.
name|operand_type
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|->
name|indirect
operator|.
name|mod
operator|<<
literal|11
operator|)
expr_stmt|;
name|p_insn
operator|.
name|opcode
operator||=
operator|(
name|p_insn
operator|.
name|operand_type
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|->
name|reg
operator|.
name|opcode
operator|<<
literal|16
operator|)
expr_stmt|;
name|p_insn
operator|.
name|opcode
operator||=
operator|(
name|p_insn
operator|.
name|operand_type
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|->
name|reg
operator|.
name|opcode
operator|<<
literal|22
operator|)
expr_stmt|;
break|break;
case|case
name|OO_5op1
case|:
name|p_insn
operator|.
name|opcode
operator||=
operator|(
name|p_insn
operator|.
name|operand_type
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|->
name|indirect
operator|.
name|ARnum
operator|)
expr_stmt|;
name|p_insn
operator|.
name|opcode
operator||=
operator|(
name|p_insn
operator|.
name|operand_type
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|->
name|indirect
operator|.
name|mod
operator|<<
literal|3
operator|)
expr_stmt|;
name|p_insn
operator|.
name|opcode
operator||=
operator|(
name|p_insn
operator|.
name|operand_type
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|->
name|indirect
operator|.
name|ARnum
operator|<<
literal|8
operator|)
expr_stmt|;
name|p_insn
operator|.
name|opcode
operator||=
operator|(
name|p_insn
operator|.
name|operand_type
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|->
name|indirect
operator|.
name|mod
operator|<<
literal|11
operator|)
expr_stmt|;
name|p_insn
operator|.
name|opcode
operator||=
operator|(
name|p_insn
operator|.
name|operand_type
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|->
name|reg
operator|.
name|opcode
operator|<<
literal|16
operator|)
expr_stmt|;
name|p_insn
operator|.
name|opcode
operator||=
operator|(
name|p_insn
operator|.
name|operand_type
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|->
name|reg
operator|.
name|opcode
operator|<<
literal|19
operator|)
expr_stmt|;
name|p_insn
operator|.
name|opcode
operator||=
operator|(
name|p_insn
operator|.
name|operand_type
index|[
literal|0
index|]
index|[
literal|2
index|]
operator|->
name|reg
operator|.
name|opcode
operator|<<
literal|22
operator|)
expr_stmt|;
break|break;
case|case
name|OO_5op2
case|:
name|p_insn
operator|.
name|opcode
operator||=
operator|(
name|p_insn
operator|.
name|operand_type
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|->
name|indirect
operator|.
name|ARnum
operator|)
expr_stmt|;
name|p_insn
operator|.
name|opcode
operator||=
operator|(
name|p_insn
operator|.
name|operand_type
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|->
name|indirect
operator|.
name|mod
operator|<<
literal|3
operator|)
expr_stmt|;
name|p_insn
operator|.
name|opcode
operator||=
operator|(
name|p_insn
operator|.
name|operand_type
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|->
name|indirect
operator|.
name|ARnum
operator|<<
literal|8
operator|)
expr_stmt|;
name|p_insn
operator|.
name|opcode
operator||=
operator|(
name|p_insn
operator|.
name|operand_type
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|->
name|indirect
operator|.
name|mod
operator|<<
literal|11
operator|)
expr_stmt|;
name|p_insn
operator|.
name|opcode
operator||=
operator|(
name|p_insn
operator|.
name|operand_type
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|->
name|reg
operator|.
name|opcode
operator|<<
literal|16
operator|)
expr_stmt|;
name|p_insn
operator|.
name|opcode
operator||=
operator|(
name|p_insn
operator|.
name|operand_type
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|->
name|reg
operator|.
name|opcode
operator|<<
literal|19
operator|)
expr_stmt|;
name|p_insn
operator|.
name|opcode
operator||=
operator|(
name|p_insn
operator|.
name|operand_type
index|[
literal|0
index|]
index|[
literal|2
index|]
operator|->
name|reg
operator|.
name|opcode
operator|<<
literal|22
operator|)
expr_stmt|;
break|break;
case|case
name|OO_PField
case|:
name|p_insn
operator|.
name|opcode
operator||=
name|p_insn
operator|.
name|p_field
expr_stmt|;
if|if
condition|(
name|p_insn
operator|.
name|operand_type
index|[
literal|0
index|]
index|[
literal|2
index|]
operator|->
name|reg
operator|.
name|opcode
operator|==
literal|0x01
condition|)
name|p_insn
operator|.
name|opcode
operator||=
literal|0x00800000
expr_stmt|;
if|if
condition|(
name|p_insn
operator|.
name|operand_type
index|[
literal|1
index|]
index|[
literal|2
index|]
operator|->
name|reg
operator|.
name|opcode
operator|==
literal|0x03
condition|)
name|p_insn
operator|.
name|opcode
operator||=
literal|0x00400000
expr_stmt|;
switch|switch
condition|(
name|p_insn
operator|.
name|p_field
condition|)
block|{
case|case
literal|0x00000000
case|:
name|p_insn
operator|.
name|opcode
operator||=
operator|(
name|p_insn
operator|.
name|operand_type
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|->
name|indirect
operator|.
name|ARnum
operator|)
expr_stmt|;
name|p_insn
operator|.
name|opcode
operator||=
operator|(
name|p_insn
operator|.
name|operand_type
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|->
name|indirect
operator|.
name|mod
operator|<<
literal|3
operator|)
expr_stmt|;
name|p_insn
operator|.
name|opcode
operator||=
operator|(
name|p_insn
operator|.
name|operand_type
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|->
name|indirect
operator|.
name|ARnum
operator|<<
literal|8
operator|)
expr_stmt|;
name|p_insn
operator|.
name|opcode
operator||=
operator|(
name|p_insn
operator|.
name|operand_type
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|->
name|indirect
operator|.
name|mod
operator|<<
literal|11
operator|)
expr_stmt|;
name|p_insn
operator|.
name|opcode
operator||=
operator|(
name|p_insn
operator|.
name|operand_type
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|->
name|reg
operator|.
name|opcode
operator|<<
literal|16
operator|)
expr_stmt|;
name|p_insn
operator|.
name|opcode
operator||=
operator|(
name|p_insn
operator|.
name|operand_type
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|->
name|reg
operator|.
name|opcode
operator|<<
literal|19
operator|)
expr_stmt|;
break|break;
case|case
literal|0x01000000
case|:
name|p_insn
operator|.
name|opcode
operator||=
operator|(
name|p_insn
operator|.
name|operand_type
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|->
name|indirect
operator|.
name|ARnum
operator|)
expr_stmt|;
name|p_insn
operator|.
name|opcode
operator||=
operator|(
name|p_insn
operator|.
name|operand_type
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|->
name|indirect
operator|.
name|mod
operator|<<
literal|3
operator|)
expr_stmt|;
name|p_insn
operator|.
name|opcode
operator||=
operator|(
name|p_insn
operator|.
name|operand_type
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|->
name|indirect
operator|.
name|ARnum
operator|<<
literal|8
operator|)
expr_stmt|;
name|p_insn
operator|.
name|opcode
operator||=
operator|(
name|p_insn
operator|.
name|operand_type
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|->
name|indirect
operator|.
name|mod
operator|<<
literal|11
operator|)
expr_stmt|;
name|p_insn
operator|.
name|opcode
operator||=
operator|(
name|p_insn
operator|.
name|operand_type
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|->
name|reg
operator|.
name|opcode
operator|<<
literal|16
operator|)
expr_stmt|;
name|p_insn
operator|.
name|opcode
operator||=
operator|(
name|p_insn
operator|.
name|operand_type
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|->
name|reg
operator|.
name|opcode
operator|<<
literal|19
operator|)
expr_stmt|;
break|break;
case|case
literal|0x02000000
case|:
name|p_insn
operator|.
name|opcode
operator||=
operator|(
name|p_insn
operator|.
name|operand_type
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|->
name|indirect
operator|.
name|ARnum
operator|)
expr_stmt|;
name|p_insn
operator|.
name|opcode
operator||=
operator|(
name|p_insn
operator|.
name|operand_type
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|->
name|indirect
operator|.
name|mod
operator|<<
literal|3
operator|)
expr_stmt|;
name|p_insn
operator|.
name|opcode
operator||=
operator|(
name|p_insn
operator|.
name|operand_type
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|->
name|indirect
operator|.
name|ARnum
operator|<<
literal|8
operator|)
expr_stmt|;
name|p_insn
operator|.
name|opcode
operator||=
operator|(
name|p_insn
operator|.
name|operand_type
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|->
name|indirect
operator|.
name|mod
operator|<<
literal|11
operator|)
expr_stmt|;
name|p_insn
operator|.
name|opcode
operator||=
operator|(
name|p_insn
operator|.
name|operand_type
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|->
name|reg
operator|.
name|opcode
operator|<<
literal|16
operator|)
expr_stmt|;
name|p_insn
operator|.
name|opcode
operator||=
operator|(
name|p_insn
operator|.
name|operand_type
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|->
name|reg
operator|.
name|opcode
operator|<<
literal|19
operator|)
expr_stmt|;
break|break;
case|case
literal|0x03000000
case|:
name|p_insn
operator|.
name|opcode
operator||=
operator|(
name|p_insn
operator|.
name|operand_type
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|->
name|indirect
operator|.
name|ARnum
operator|)
expr_stmt|;
name|p_insn
operator|.
name|opcode
operator||=
operator|(
name|p_insn
operator|.
name|operand_type
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|->
name|indirect
operator|.
name|mod
operator|<<
literal|3
operator|)
expr_stmt|;
name|p_insn
operator|.
name|opcode
operator||=
operator|(
name|p_insn
operator|.
name|operand_type
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|->
name|indirect
operator|.
name|ARnum
operator|<<
literal|8
operator|)
expr_stmt|;
name|p_insn
operator|.
name|opcode
operator||=
operator|(
name|p_insn
operator|.
name|operand_type
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|->
name|indirect
operator|.
name|mod
operator|<<
literal|11
operator|)
expr_stmt|;
name|p_insn
operator|.
name|opcode
operator||=
operator|(
name|p_insn
operator|.
name|operand_type
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|->
name|reg
operator|.
name|opcode
operator|<<
literal|16
operator|)
expr_stmt|;
name|p_insn
operator|.
name|opcode
operator||=
operator|(
name|p_insn
operator|.
name|operand_type
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|->
name|reg
operator|.
name|opcode
operator|<<
literal|19
operator|)
expr_stmt|;
break|break;
block|}
break|break;
block|}
block|}
comment|/* Opcode is finalised at this point for all parallel instructions. */
block|{
comment|/* Output opcode */
name|char
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|frag_more
argument_list|(
name|INSN_SIZE
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|p
argument_list|,
operator|(
name|valueT
operator|)
name|p_insn
operator|.
name|opcode
argument_list|,
name|INSN_SIZE
argument_list|)
expr_stmt|;
block|}
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
name|i
operator|++
control|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|p_insn
operator|.
name|operands
index|[
name|i
index|]
condition|;
name|j
operator|++
control|)
name|free
argument_list|(
name|p_insn
operator|.
name|operand_type
index|[
name|i
index|]
index|[
name|j
index|]
argument_list|)
expr_stmt|;
block|}
name|debug
argument_list|(
literal|"Final opcode: %08X\n"
argument_list|,
name|p_insn
operator|.
name|opcode
argument_list|)
expr_stmt|;
name|debug
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
name|operand
modifier|*
name|tic30_operand
parameter_list|(
name|token
parameter_list|)
name|char
modifier|*
name|token
decl_stmt|;
block|{
name|int
name|count
decl_stmt|;
name|char
name|ind_buffer
index|[
name|strlen
argument_list|(
name|token
argument_list|)
index|]
decl_stmt|;
name|operand
modifier|*
name|current_op
decl_stmt|;
name|debug
argument_list|(
literal|"In tic30_operand with %s\n"
argument_list|,
name|token
argument_list|)
expr_stmt|;
name|current_op
operator|=
operator|(
name|operand
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|operand
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|current_op
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
name|operand
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|token
operator|==
name|DIRECT_REFERENCE
condition|)
block|{
name|char
modifier|*
name|token_posn
init|=
name|token
operator|+
literal|1
decl_stmt|;
name|int
name|direct_label
init|=
literal|0
decl_stmt|;
name|debug
argument_list|(
literal|"Found direct reference\n"
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|token_posn
condition|)
block|{
if|if
condition|(
operator|!
name|is_digit_char
argument_list|(
operator|*
name|token_posn
argument_list|)
condition|)
name|direct_label
operator|=
literal|1
expr_stmt|;
name|token_posn
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|direct_label
condition|)
block|{
name|char
modifier|*
name|save_input_line_pointer
decl_stmt|;
name|segT
name|retval
decl_stmt|;
name|debug
argument_list|(
literal|"Direct reference is a label\n"
argument_list|)
expr_stmt|;
name|current_op
operator|->
name|direct
operator|.
name|label
operator|=
name|token
operator|+
literal|1
expr_stmt|;
name|save_input_line_pointer
operator|=
name|input_line_pointer
expr_stmt|;
name|input_line_pointer
operator|=
name|token
operator|+
literal|1
expr_stmt|;
name|debug
argument_list|(
literal|"Current input_line_pointer: %s\n"
argument_list|,
name|input_line_pointer
argument_list|)
expr_stmt|;
name|retval
operator|=
name|expression
argument_list|(
operator|&
name|current_op
operator|->
name|direct
operator|.
name|direct_expr
argument_list|)
expr_stmt|;
name|debug
argument_list|(
literal|"Expression type: %d\n"
argument_list|,
name|current_op
operator|->
name|direct
operator|.
name|direct_expr
operator|.
name|X_op
argument_list|)
expr_stmt|;
name|debug
argument_list|(
literal|"Expression addnum: %d\n"
argument_list|,
name|current_op
operator|->
name|direct
operator|.
name|direct_expr
operator|.
name|X_add_number
argument_list|)
expr_stmt|;
name|debug
argument_list|(
literal|"Segment: %d\n"
argument_list|,
name|retval
argument_list|)
expr_stmt|;
name|input_line_pointer
operator|=
name|save_input_line_pointer
expr_stmt|;
if|if
condition|(
name|current_op
operator|->
name|direct
operator|.
name|direct_expr
operator|.
name|X_op
operator|==
name|O_constant
condition|)
block|{
name|current_op
operator|->
name|direct
operator|.
name|address
operator|=
name|current_op
operator|->
name|direct
operator|.
name|direct_expr
operator|.
name|X_add_number
expr_stmt|;
name|current_op
operator|->
name|direct
operator|.
name|resolved
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
name|debug
argument_list|(
literal|"Direct reference is a number\n"
argument_list|)
expr_stmt|;
name|current_op
operator|->
name|direct
operator|.
name|address
operator|=
name|atoi
argument_list|(
name|token
operator|+
literal|1
argument_list|)
expr_stmt|;
name|current_op
operator|->
name|direct
operator|.
name|resolved
operator|=
literal|1
expr_stmt|;
block|}
name|current_op
operator|->
name|op_type
operator|=
name|Direct
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|token
operator|==
name|INDIRECT_REFERENCE
condition|)
block|{
comment|/* Indirect reference operand */
name|int
name|found_ar
init|=
literal|0
decl_stmt|;
name|int
name|found_disp
init|=
literal|0
decl_stmt|;
name|int
name|ar_number
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|disp_number
init|=
literal|0
decl_stmt|;
name|int
name|buffer_posn
init|=
literal|1
decl_stmt|;
name|ind_addr_type
modifier|*
name|ind_addr_op
decl_stmt|;
name|debug
argument_list|(
literal|"Found indirect reference\n"
argument_list|)
expr_stmt|;
name|ind_buffer
index|[
literal|0
index|]
operator|=
operator|*
name|token
expr_stmt|;
for|for
control|(
name|count
operator|=
literal|1
init|;
name|count
operator|<
name|strlen
argument_list|(
name|token
argument_list|)
condition|;
name|count
operator|++
control|)
block|{
comment|/* Strip operand */
name|ind_buffer
index|[
name|buffer_posn
index|]
operator|=
name|tolower
argument_list|(
operator|*
operator|(
name|token
operator|+
name|count
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
operator|(
name|token
operator|+
name|count
operator|-
literal|1
operator|)
operator|==
literal|'a'
operator|||
operator|*
operator|(
name|token
operator|+
name|count
operator|-
literal|1
operator|)
operator|==
literal|'A'
operator|)
operator|&&
operator|(
operator|*
operator|(
name|token
operator|+
name|count
operator|)
operator|==
literal|'r'
operator|||
operator|*
operator|(
name|token
operator|+
name|count
operator|)
operator|==
literal|'R'
operator|)
condition|)
block|{
comment|/* AR reference is found, so get its number and remove it from the buffer 	         so it can pass through hash_find() */
if|if
condition|(
name|found_ar
condition|)
block|{
name|as_bad
argument_list|(
literal|"More than one AR register found in indirect reference"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
operator|*
operator|(
name|token
operator|+
name|count
operator|+
literal|1
operator|)
operator|<
literal|'0'
operator|||
operator|*
operator|(
name|token
operator|+
name|count
operator|+
literal|1
operator|)
operator|>
literal|'7'
condition|)
block|{
name|as_bad
argument_list|(
literal|"Illegal AR register in indirect reference"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|ar_number
operator|=
operator|*
operator|(
name|token
operator|+
name|count
operator|+
literal|1
operator|)
operator|-
literal|'0'
expr_stmt|;
name|found_ar
operator|=
literal|1
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
operator|(
name|token
operator|+
name|count
operator|)
operator|==
literal|'('
condition|)
block|{
comment|/* Parenthesis found, so check if a displacement value is inside.  If so, get 	         the value and remove it from the buffer. */
if|if
condition|(
name|is_digit_char
argument_list|(
operator|*
operator|(
name|token
operator|+
name|count
operator|+
literal|1
operator|)
argument_list|)
condition|)
block|{
name|char
name|disp
index|[
literal|10
index|]
decl_stmt|;
name|int
name|disp_posn
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|found_disp
condition|)
block|{
name|as_bad
argument_list|(
literal|"More than one displacement found in indirect reference"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|count
operator|++
expr_stmt|;
while|while
condition|(
operator|*
operator|(
name|token
operator|+
name|count
operator|)
operator|!=
literal|')'
condition|)
block|{
if|if
condition|(
operator|!
name|is_digit_char
argument_list|(
operator|*
operator|(
name|token
operator|+
name|count
operator|)
argument_list|)
condition|)
block|{
name|as_bad
argument_list|(
literal|"Invalid displacement in indirect reference"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|disp
index|[
name|disp_posn
operator|++
index|]
operator|=
operator|*
operator|(
name|token
operator|+
operator|(
name|count
operator|++
operator|)
operator|)
expr_stmt|;
block|}
name|disp
index|[
name|disp_posn
index|]
operator|=
literal|'\0'
expr_stmt|;
name|disp_number
operator|=
name|atoi
argument_list|(
name|disp
argument_list|)
expr_stmt|;
name|count
operator|--
expr_stmt|;
name|found_disp
operator|=
literal|1
expr_stmt|;
block|}
block|}
name|buffer_posn
operator|++
expr_stmt|;
block|}
name|ind_buffer
index|[
name|buffer_posn
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|!
name|found_ar
condition|)
block|{
name|as_bad
argument_list|(
literal|"AR register not found in indirect reference"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|ind_addr_op
operator|=
operator|(
name|ind_addr_type
operator|*
operator|)
name|hash_find
argument_list|(
name|ind_hash
argument_list|,
name|ind_buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|ind_addr_op
condition|)
block|{
name|debug
argument_list|(
literal|"Found indirect reference: %s\n"
argument_list|,
name|ind_addr_op
operator|->
name|syntax
argument_list|)
expr_stmt|;
if|if
condition|(
name|ind_addr_op
operator|->
name|displacement
operator|==
name|IMPLIED_DISP
condition|)
block|{
name|found_disp
operator|=
literal|1
expr_stmt|;
name|disp_number
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|ind_addr_op
operator|->
name|displacement
operator|==
name|DISP_REQUIRED
operator|)
operator|&&
operator|!
name|found_disp
condition|)
block|{
comment|/* Maybe an implied displacement of 1 again */
name|as_bad
argument_list|(
literal|"required displacement wasn't given in indirect reference"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
else|else
block|{
name|as_bad
argument_list|(
literal|"illegal indirect reference"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|found_disp
operator|&&
operator|(
name|disp_number
operator|<
literal|0
operator|||
name|disp_number
operator|>
literal|255
operator|)
condition|)
block|{
name|as_bad
argument_list|(
literal|"displacement must be an unsigned 8-bit number"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|current_op
operator|->
name|indirect
operator|.
name|mod
operator|=
name|ind_addr_op
operator|->
name|modfield
expr_stmt|;
name|current_op
operator|->
name|indirect
operator|.
name|disp
operator|=
name|disp_number
expr_stmt|;
name|current_op
operator|->
name|indirect
operator|.
name|ARnum
operator|=
name|ar_number
expr_stmt|;
name|current_op
operator|->
name|op_type
operator|=
name|Indirect
expr_stmt|;
block|}
else|else
block|{
name|reg
modifier|*
name|regop
init|=
operator|(
name|reg
operator|*
operator|)
name|hash_find
argument_list|(
name|reg_hash
argument_list|,
name|token
argument_list|)
decl_stmt|;
if|if
condition|(
name|regop
condition|)
block|{
name|debug
argument_list|(
literal|"Found register operand: %s\n"
argument_list|,
name|regop
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|regop
operator|->
name|regtype
operator|==
name|REG_ARn
condition|)
name|current_op
operator|->
name|op_type
operator|=
name|ARn
expr_stmt|;
elseif|else
if|if
condition|(
name|regop
operator|->
name|regtype
operator|==
name|REG_Rn
condition|)
name|current_op
operator|->
name|op_type
operator|=
name|Rn
expr_stmt|;
elseif|else
if|if
condition|(
name|regop
operator|->
name|regtype
operator|==
name|REG_DP
condition|)
name|current_op
operator|->
name|op_type
operator|=
name|DPReg
expr_stmt|;
else|else
name|current_op
operator|->
name|op_type
operator|=
name|OtherReg
expr_stmt|;
name|current_op
operator|->
name|reg
operator|.
name|opcode
operator|=
name|regop
operator|->
name|opcode
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|is_digit_char
argument_list|(
operator|*
name|token
argument_list|)
operator|||
operator|*
operator|(
name|token
operator|+
literal|1
operator|)
operator|==
literal|'x'
operator|||
name|strchr
argument_list|(
name|token
argument_list|,
literal|'h'
argument_list|)
condition|)
block|{
name|char
modifier|*
name|save_input_line_pointer
decl_stmt|;
name|segT
name|retval
decl_stmt|;
name|debug
argument_list|(
literal|"Probably a label: %s\n"
argument_list|,
name|token
argument_list|)
expr_stmt|;
name|current_op
operator|->
name|immediate
operator|.
name|label
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|strlen
argument_list|(
name|token
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|current_op
operator|->
name|immediate
operator|.
name|label
argument_list|,
name|token
argument_list|)
expr_stmt|;
name|current_op
operator|->
name|immediate
operator|.
name|label
index|[
name|strlen
argument_list|(
name|token
argument_list|)
index|]
operator|=
literal|'\0'
expr_stmt|;
name|save_input_line_pointer
operator|=
name|input_line_pointer
expr_stmt|;
name|input_line_pointer
operator|=
name|token
expr_stmt|;
name|debug
argument_list|(
literal|"Current input_line_pointer: %s\n"
argument_list|,
name|input_line_pointer
argument_list|)
expr_stmt|;
name|retval
operator|=
name|expression
argument_list|(
operator|&
name|current_op
operator|->
name|immediate
operator|.
name|imm_expr
argument_list|)
expr_stmt|;
name|debug
argument_list|(
literal|"Expression type: %d\n"
argument_list|,
name|current_op
operator|->
name|immediate
operator|.
name|imm_expr
operator|.
name|X_op
argument_list|)
expr_stmt|;
name|debug
argument_list|(
literal|"Expression addnum: %d\n"
argument_list|,
name|current_op
operator|->
name|immediate
operator|.
name|imm_expr
operator|.
name|X_add_number
argument_list|)
expr_stmt|;
name|debug
argument_list|(
literal|"Segment: %d\n"
argument_list|,
name|retval
argument_list|)
expr_stmt|;
name|input_line_pointer
operator|=
name|save_input_line_pointer
expr_stmt|;
if|if
condition|(
name|current_op
operator|->
name|immediate
operator|.
name|imm_expr
operator|.
name|X_op
operator|==
name|O_constant
condition|)
block|{
name|current_op
operator|->
name|immediate
operator|.
name|s_number
operator|=
name|current_op
operator|->
name|immediate
operator|.
name|imm_expr
operator|.
name|X_add_number
expr_stmt|;
name|current_op
operator|->
name|immediate
operator|.
name|u_number
operator|=
operator|(
name|unsigned
name|int
operator|)
name|current_op
operator|->
name|immediate
operator|.
name|imm_expr
operator|.
name|X_add_number
expr_stmt|;
name|current_op
operator|->
name|immediate
operator|.
name|resolved
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
name|unsigned
name|count
decl_stmt|;
name|debug
argument_list|(
literal|"Found a number or displacement\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|count
operator|=
literal|0
init|;
name|count
operator|<
name|strlen
argument_list|(
name|token
argument_list|)
condition|;
name|count
operator|++
control|)
if|if
condition|(
operator|*
operator|(
name|token
operator|+
name|count
operator|)
operator|==
literal|'.'
condition|)
name|current_op
operator|->
name|immediate
operator|.
name|decimal_found
operator|=
literal|1
expr_stmt|;
name|current_op
operator|->
name|immediate
operator|.
name|label
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|strlen
argument_list|(
name|token
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|current_op
operator|->
name|immediate
operator|.
name|label
argument_list|,
name|token
argument_list|)
expr_stmt|;
name|current_op
operator|->
name|immediate
operator|.
name|label
index|[
name|strlen
argument_list|(
name|token
argument_list|)
index|]
operator|=
literal|'\0'
expr_stmt|;
name|current_op
operator|->
name|immediate
operator|.
name|f_number
operator|=
operator|(
name|float
operator|)
name|atof
argument_list|(
name|token
argument_list|)
expr_stmt|;
name|current_op
operator|->
name|immediate
operator|.
name|s_number
operator|=
operator|(
name|int
operator|)
name|atoi
argument_list|(
name|token
argument_list|)
expr_stmt|;
name|current_op
operator|->
name|immediate
operator|.
name|u_number
operator|=
operator|(
name|unsigned
name|int
operator|)
name|atoi
argument_list|(
name|token
argument_list|)
expr_stmt|;
name|current_op
operator|->
name|immediate
operator|.
name|resolved
operator|=
literal|1
expr_stmt|;
block|}
name|current_op
operator|->
name|op_type
operator|=
name|Disp
operator||
name|Abs24
operator||
name|Imm16
operator||
name|Imm24
expr_stmt|;
if|if
condition|(
name|current_op
operator|->
name|immediate
operator|.
name|u_number
operator|>=
literal|0
operator|&&
name|current_op
operator|->
name|immediate
operator|.
name|u_number
operator|<=
literal|31
condition|)
name|current_op
operator|->
name|op_type
operator||=
name|IVector
expr_stmt|;
block|}
block|}
return|return
name|current_op
return|;
block|}
end_function

begin_comment
comment|/* next_line points to the next line after the current instruction (current_line).    Search for the parallel bars, and if found, merge two lines into internal syntax    for a parallel instruction:    q_[INSN1]_[INSN2] [OPERANDS1] | [OPERANDS2]    By this stage, all comments are scrubbed, and only the bare lines are given.  */
end_comment

begin_define
define|#
directive|define
name|NONE
value|0
end_define

begin_define
define|#
directive|define
name|START_OPCODE
value|1
end_define

begin_define
define|#
directive|define
name|END_OPCODE
value|2
end_define

begin_define
define|#
directive|define
name|START_OPERANDS
value|3
end_define

begin_define
define|#
directive|define
name|END_OPERANDS
value|4
end_define

begin_function
name|char
modifier|*
name|tic30_find_parallel_insn
parameter_list|(
name|current_line
parameter_list|,
name|next_line
parameter_list|)
name|char
modifier|*
name|current_line
decl_stmt|;
name|char
modifier|*
name|next_line
decl_stmt|;
block|{
name|int
name|found_parallel
init|=
literal|0
decl_stmt|;
name|char
name|first_opcode
index|[
literal|256
index|]
decl_stmt|;
name|char
name|second_opcode
index|[
literal|256
index|]
decl_stmt|;
name|char
name|first_operands
index|[
literal|256
index|]
decl_stmt|;
name|char
name|second_operands
index|[
literal|256
index|]
decl_stmt|;
name|char
modifier|*
name|parallel_insn
decl_stmt|;
name|debug
argument_list|(
literal|"In tic30_find_parallel_insn()\n"
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|is_end_of_line
index|[
operator|(
name|int
operator|)
operator|*
name|next_line
index|]
condition|)
block|{
if|if
condition|(
operator|*
name|next_line
operator|==
name|PARALLEL_SEPARATOR
operator|&&
operator|*
operator|(
name|next_line
operator|+
literal|1
operator|)
operator|==
name|PARALLEL_SEPARATOR
condition|)
block|{
name|found_parallel
operator|=
literal|1
expr_stmt|;
name|next_line
operator|++
expr_stmt|;
break|break;
block|}
name|next_line
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|found_parallel
condition|)
return|return
name|NULL
return|;
name|debug
argument_list|(
literal|"Found a parallel instruction\n"
argument_list|)
expr_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|opcode
decl_stmt|,
modifier|*
name|operands
decl_stmt|,
modifier|*
name|line
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|opcode
operator|=
operator|&
name|first_opcode
index|[
literal|0
index|]
expr_stmt|;
name|operands
operator|=
operator|&
name|first_operands
index|[
literal|0
index|]
expr_stmt|;
name|line
operator|=
name|current_line
expr_stmt|;
block|}
else|else
block|{
name|opcode
operator|=
operator|&
name|second_opcode
index|[
literal|0
index|]
expr_stmt|;
name|operands
operator|=
operator|&
name|second_operands
index|[
literal|0
index|]
expr_stmt|;
name|line
operator|=
name|next_line
expr_stmt|;
block|}
block|{
name|int
name|search_status
init|=
name|NONE
decl_stmt|;
name|int
name|char_ptr
init|=
literal|0
decl_stmt|;
name|char
name|c
decl_stmt|;
while|while
condition|(
operator|!
name|is_end_of_line
index|[
call|(
name|int
call|)
argument_list|(
name|c
operator|=
operator|*
name|line
argument_list|)
index|]
operator|&&
operator|*
name|line
condition|)
block|{
if|if
condition|(
name|is_opcode_char
argument_list|(
name|c
argument_list|)
operator|&&
name|search_status
operator|==
name|NONE
condition|)
block|{
name|opcode
index|[
name|char_ptr
operator|++
index|]
operator|=
name|tolower
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|search_status
operator|=
name|START_OPCODE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|is_opcode_char
argument_list|(
name|c
argument_list|)
operator|&&
name|search_status
operator|==
name|START_OPCODE
condition|)
block|{
name|opcode
index|[
name|char_ptr
operator|++
index|]
operator|=
name|tolower
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|is_opcode_char
argument_list|(
name|c
argument_list|)
operator|&&
name|search_status
operator|==
name|START_OPCODE
condition|)
block|{
name|opcode
index|[
name|char_ptr
index|]
operator|=
literal|'\0'
expr_stmt|;
name|char_ptr
operator|=
literal|0
expr_stmt|;
name|search_status
operator|=
name|END_OPCODE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|is_operand_char
argument_list|(
name|c
argument_list|)
operator|&&
name|search_status
operator|==
name|START_OPERANDS
condition|)
block|{
name|operands
index|[
name|char_ptr
operator|++
index|]
operator|=
name|c
expr_stmt|;
block|}
if|if
condition|(
name|is_operand_char
argument_list|(
name|c
argument_list|)
operator|&&
name|search_status
operator|==
name|END_OPCODE
condition|)
block|{
name|operands
index|[
name|char_ptr
operator|++
index|]
operator|=
name|c
expr_stmt|;
name|search_status
operator|=
name|START_OPERANDS
expr_stmt|;
block|}
name|line
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|search_status
operator|!=
name|START_OPERANDS
condition|)
return|return
name|NULL
return|;
name|operands
index|[
name|char_ptr
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
block|}
block|}
name|parallel_insn
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|strlen
argument_list|(
name|first_opcode
argument_list|)
operator|+
name|strlen
argument_list|(
name|first_operands
argument_list|)
operator|+
name|strlen
argument_list|(
name|second_opcode
argument_list|)
operator|+
name|strlen
argument_list|(
name|second_operands
argument_list|)
operator|+
literal|8
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|parallel_insn
argument_list|,
literal|"q_%s_%s %s | %s"
argument_list|,
name|first_opcode
argument_list|,
name|second_opcode
argument_list|,
name|first_operands
argument_list|,
name|second_operands
argument_list|)
expr_stmt|;
name|debug
argument_list|(
literal|"parallel insn = %s\n"
argument_list|,
name|parallel_insn
argument_list|)
expr_stmt|;
return|return
name|parallel_insn
return|;
block|}
end_function

begin_undef
undef|#
directive|undef
name|NONE
end_undef

begin_undef
undef|#
directive|undef
name|START_OPCODE
end_undef

begin_undef
undef|#
directive|undef
name|END_OPCODE
end_undef

begin_undef
undef|#
directive|undef
name|START_OPERANDS
end_undef

begin_undef
undef|#
directive|undef
name|END_OPERANDS
end_undef

begin_comment
comment|/* In order to get gas to ignore any | chars at the start of a line,    this function returns true if a | is found in a line. */
end_comment

begin_function
name|int
name|tic30_unrecognized_line
parameter_list|(
name|c
parameter_list|)
name|int
name|c
decl_stmt|;
block|{
name|debug
argument_list|(
literal|"In tc_unrecognized_line\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|c
operator|==
name|PARALLEL_SEPARATOR
operator|)
return|;
block|}
end_function

begin_function
name|int
name|md_estimate_size_before_relax
parameter_list|(
name|fragP
parameter_list|,
name|segment
parameter_list|)
name|fragS
modifier|*
name|fragP
decl_stmt|;
name|segT
name|segment
decl_stmt|;
block|{
name|debug
argument_list|(
literal|"In md_estimate_size_before_relax()\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|md_convert_frag
parameter_list|(
name|abfd
parameter_list|,
name|sec
parameter_list|,
name|fragP
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|segT
name|sec
decl_stmt|;
specifier|register
name|fragS
modifier|*
name|fragP
decl_stmt|;
block|{
name|debug
argument_list|(
literal|"In md_convert_frag()\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|md_create_short_jump
parameter_list|(
name|ptr
parameter_list|,
name|from_addr
parameter_list|,
name|to_addr
parameter_list|,
name|frag
parameter_list|,
name|to_symbol
parameter_list|)
name|char
modifier|*
name|ptr
decl_stmt|;
name|addressT
name|from_addr
decl_stmt|,
name|to_addr
decl_stmt|;
name|fragS
modifier|*
name|frag
decl_stmt|;
name|symbolS
modifier|*
name|to_symbol
decl_stmt|;
block|{
name|debug
argument_list|(
literal|"In md_create_short_jump()\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|md_create_long_jump
parameter_list|(
name|ptr
parameter_list|,
name|from_addr
parameter_list|,
name|to_addr
parameter_list|,
name|frag
parameter_list|,
name|to_symbol
parameter_list|)
name|char
modifier|*
name|ptr
decl_stmt|;
name|addressT
name|from_addr
decl_stmt|,
name|to_addr
decl_stmt|;
name|fragS
modifier|*
name|frag
decl_stmt|;
name|symbolS
modifier|*
name|to_symbol
decl_stmt|;
block|{
name|debug
argument_list|(
literal|"In md_create_long_jump()\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|md_apply_fix
parameter_list|(
name|fixP
parameter_list|,
name|valP
parameter_list|)
name|fixS
modifier|*
name|fixP
decl_stmt|;
name|valueT
modifier|*
name|valP
decl_stmt|;
block|{
name|valueT
name|value
init|=
operator|*
name|valP
decl_stmt|;
name|debug
argument_list|(
literal|"In md_apply_fix() with value = %ld\n"
argument_list|,
operator|(
name|long
operator|)
name|value
argument_list|)
expr_stmt|;
name|debug
argument_list|(
literal|"Values in fixP\n"
argument_list|)
expr_stmt|;
name|debug
argument_list|(
literal|"fx_size = %d\n"
argument_list|,
name|fixP
operator|->
name|fx_size
argument_list|)
expr_stmt|;
name|debug
argument_list|(
literal|"fx_pcrel = %d\n"
argument_list|,
name|fixP
operator|->
name|fx_pcrel
argument_list|)
expr_stmt|;
name|debug
argument_list|(
literal|"fx_where = %d\n"
argument_list|,
name|fixP
operator|->
name|fx_where
argument_list|)
expr_stmt|;
name|debug
argument_list|(
literal|"fx_offset = %d\n"
argument_list|,
operator|(
name|int
operator|)
name|fixP
operator|->
name|fx_offset
argument_list|)
expr_stmt|;
block|{
name|char
modifier|*
name|buf
init|=
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_literal
operator|+
name|fixP
operator|->
name|fx_where
decl_stmt|;
name|value
operator|/=
name|INSN_SIZE
expr_stmt|;
if|if
condition|(
name|fixP
operator|->
name|fx_size
operator|==
literal|1
condition|)
block|{
comment|/* Special fix for LDP instruction. */
name|value
operator|=
operator|(
name|value
operator|&
literal|0x00FF0000
operator|)
operator|>>
literal|16
expr_stmt|;
block|}
name|debug
argument_list|(
literal|"new value = %ld\n"
argument_list|,
operator|(
name|long
operator|)
name|value
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|buf
argument_list|,
name|value
argument_list|,
name|fixP
operator|->
name|fx_size
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
name|int
name|md_parse_option
parameter_list|(
name|c
parameter_list|,
name|arg
parameter_list|)
name|int
name|c
decl_stmt|;
name|char
modifier|*
name|arg
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|debug
argument_list|(
literal|"In md_parse_option()\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|c
condition|;
name|i
operator|++
control|)
block|{
name|printf
argument_list|(
literal|"%c\n"
argument_list|,
name|arg
index|[
name|c
index|]
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|md_show_usage
parameter_list|(
name|stream
parameter_list|)
name|FILE
modifier|*
name|stream
decl_stmt|;
block|{
name|debug
argument_list|(
literal|"In md_show_usage()\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|symbolS
modifier|*
name|md_undefined_symbol
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|debug
argument_list|(
literal|"In md_undefined_symbol()\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|symbolS
operator|*
operator|)
literal|0
return|;
block|}
end_function

begin_function
name|valueT
name|md_section_align
parameter_list|(
name|segment
parameter_list|,
name|size
parameter_list|)
name|segT
name|segment
decl_stmt|;
name|valueT
name|size
decl_stmt|;
block|{
name|debug
argument_list|(
literal|"In md_section_align() segment = %d and size = %d\n"
argument_list|,
name|segment
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|size
operator|=
operator|(
name|size
operator|+
literal|3
operator|)
operator|/
literal|4
expr_stmt|;
name|size
operator|*=
literal|4
expr_stmt|;
name|debug
argument_list|(
literal|"New size value = %d\n"
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return
name|size
return|;
block|}
end_function

begin_function
name|long
name|md_pcrel_from
parameter_list|(
name|fixP
parameter_list|)
name|fixS
modifier|*
name|fixP
decl_stmt|;
block|{
name|int
name|offset
decl_stmt|;
name|debug
argument_list|(
literal|"In md_pcrel_from()\n"
argument_list|)
expr_stmt|;
name|debug
argument_list|(
literal|"fx_where = %d\n"
argument_list|,
name|fixP
operator|->
name|fx_where
argument_list|)
expr_stmt|;
name|debug
argument_list|(
literal|"fx_size = %d\n"
argument_list|,
name|fixP
operator|->
name|fx_size
argument_list|)
expr_stmt|;
comment|/* Find the opcode that represents the current instruction in the fr_literal      storage area, and check bit 21.  Bit 21 contains whether the current instruction      is a delayed one or not, and then set the offset value appropriately. */
if|if
condition|(
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_literal
index|[
name|fixP
operator|->
name|fx_where
operator|-
name|fixP
operator|->
name|fx_size
operator|+
literal|1
index|]
operator|&
literal|0x20
condition|)
name|offset
operator|=
literal|3
expr_stmt|;
else|else
name|offset
operator|=
literal|1
expr_stmt|;
name|debug
argument_list|(
literal|"offset = %d\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
comment|/* PC Relative instructions have a format:      displacement = Label - (PC + offset)      This function returns PC + offset where:      fx_where - fx_size = PC      INSN_SIZE * offset = offset number of instructions    */
return|return
name|fixP
operator|->
name|fx_where
operator|-
name|fixP
operator|->
name|fx_size
operator|+
operator|(
name|INSN_SIZE
operator|*
name|offset
operator|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|md_atof
parameter_list|(
name|what_statement_type
parameter_list|,
name|literalP
parameter_list|,
name|sizeP
parameter_list|)
name|int
name|what_statement_type
decl_stmt|;
name|char
modifier|*
name|literalP
decl_stmt|;
name|int
modifier|*
name|sizeP
decl_stmt|;
block|{
name|int
name|prec
decl_stmt|;
name|char
modifier|*
name|token
decl_stmt|;
name|char
name|keepval
decl_stmt|;
name|unsigned
name|long
name|value
decl_stmt|;
comment|/*  char *atof_ieee (); */
name|float
name|float_value
decl_stmt|;
name|debug
argument_list|(
literal|"In md_atof()\n"
argument_list|)
expr_stmt|;
name|debug
argument_list|(
literal|"precision = %c\n"
argument_list|,
name|what_statement_type
argument_list|)
expr_stmt|;
name|debug
argument_list|(
literal|"literal = %s\n"
argument_list|,
name|literalP
argument_list|)
expr_stmt|;
name|debug
argument_list|(
literal|"line = "
argument_list|)
expr_stmt|;
name|token
operator|=
name|input_line_pointer
expr_stmt|;
while|while
condition|(
operator|!
name|is_end_of_line
index|[
operator|(
name|unsigned
operator|)
operator|*
name|input_line_pointer
index|]
operator|&&
operator|(
operator|*
name|input_line_pointer
operator|)
operator|&&
operator|(
operator|*
name|input_line_pointer
operator|!=
literal|','
operator|)
condition|)
block|{
name|debug
argument_list|(
literal|"%c"
argument_list|,
operator|*
name|input_line_pointer
argument_list|)
expr_stmt|;
name|input_line_pointer
operator|++
expr_stmt|;
block|}
name|keepval
operator|=
operator|*
name|input_line_pointer
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
literal|'\0'
expr_stmt|;
name|debug
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|float_value
operator|=
operator|(
name|float
operator|)
name|atof
argument_list|(
name|token
argument_list|)
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
name|keepval
expr_stmt|;
name|debug
argument_list|(
literal|"float_value = %f\n"
argument_list|,
name|float_value
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|what_statement_type
condition|)
block|{
case|case
literal|'f'
case|:
case|case
literal|'F'
case|:
case|case
literal|'s'
case|:
case|case
literal|'S'
case|:
name|prec
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
case|case
literal|'D'
case|:
case|case
literal|'r'
case|:
case|case
literal|'R'
case|:
name|prec
operator|=
literal|4
expr_stmt|;
break|break;
default|default:
operator|*
name|sizeP
operator|=
literal|0
expr_stmt|;
return|return
literal|"Bad call to MD_ATOF()"
return|;
block|}
if|if
condition|(
name|float_value
operator|==
literal|0.0
condition|)
block|{
name|value
operator|=
operator|(
name|prec
operator|==
literal|2
operator|)
condition|?
literal|0x00008000L
else|:
literal|0x80000000L
expr_stmt|;
block|}
else|else
block|{
name|unsigned
name|long
name|exp
decl_stmt|,
name|sign
decl_stmt|,
name|mant
decl_stmt|,
name|tmsfloat
decl_stmt|;
name|tmsfloat
operator|=
operator|*
operator|(
operator|(
name|long
operator|*
operator|)
operator|&
name|float_value
operator|)
expr_stmt|;
name|sign
operator|=
name|tmsfloat
operator|&
literal|0x80000000
expr_stmt|;
name|mant
operator|=
name|tmsfloat
operator|&
literal|0x007FFFFF
expr_stmt|;
name|exp
operator|=
name|tmsfloat
operator|&
literal|0x7F800000
expr_stmt|;
name|exp
operator|<<=
literal|1
expr_stmt|;
if|if
condition|(
name|exp
operator|==
literal|0xFF000000
condition|)
block|{
if|if
condition|(
name|mant
operator|==
literal|0
condition|)
name|value
operator|=
literal|0x7F7FFFFF
expr_stmt|;
elseif|else
if|if
condition|(
name|sign
operator|==
literal|0
condition|)
name|value
operator|=
literal|0x7F7FFFFF
expr_stmt|;
else|else
name|value
operator|=
literal|0x7F800000
expr_stmt|;
block|}
else|else
block|{
name|exp
operator|-=
literal|0x7F000000
expr_stmt|;
if|if
condition|(
name|sign
condition|)
block|{
name|mant
operator|=
name|mant
operator|&
literal|0x007FFFFF
expr_stmt|;
name|mant
operator|=
operator|-
name|mant
expr_stmt|;
name|mant
operator|=
name|mant
operator|&
literal|0x00FFFFFF
expr_stmt|;
if|if
condition|(
name|mant
operator|==
literal|0
condition|)
block|{
name|mant
operator||=
literal|0x00800000
expr_stmt|;
name|exp
operator|=
operator|(
name|long
operator|)
name|exp
operator|-
literal|0x01000000
expr_stmt|;
block|}
block|}
name|tmsfloat
operator|=
name|exp
operator||
name|mant
expr_stmt|;
name|value
operator|=
name|tmsfloat
expr_stmt|;
block|}
if|if
condition|(
name|prec
operator|==
literal|2
condition|)
block|{
name|long
name|exp
decl_stmt|,
name|mant
decl_stmt|;
if|if
condition|(
name|tmsfloat
operator|==
literal|0x80000000
condition|)
block|{
name|value
operator|=
literal|0x8000
expr_stmt|;
block|}
else|else
block|{
name|value
operator|=
literal|0
expr_stmt|;
name|exp
operator|=
operator|(
name|tmsfloat
operator|&
literal|0xFF000000
operator|)
expr_stmt|;
name|exp
operator|>>=
literal|24
expr_stmt|;
name|mant
operator|=
name|tmsfloat
operator|&
literal|0x007FFFFF
expr_stmt|;
if|if
condition|(
name|tmsfloat
operator|&
literal|0x00800000
condition|)
block|{
name|mant
operator||=
literal|0xFF000000
expr_stmt|;
name|mant
operator|+=
literal|0x00000800
expr_stmt|;
name|mant
operator|>>=
literal|12
expr_stmt|;
name|mant
operator||=
literal|0x00000800
expr_stmt|;
name|mant
operator|&=
literal|0x0FFF
expr_stmt|;
if|if
condition|(
name|exp
operator|>
literal|7
condition|)
name|value
operator|=
literal|0x7800
expr_stmt|;
block|}
else|else
block|{
name|mant
operator||=
literal|0x00800000
expr_stmt|;
name|mant
operator|+=
literal|0x00000800
expr_stmt|;
name|exp
operator|+=
operator|(
name|mant
operator|>>
literal|24
operator|)
expr_stmt|;
name|mant
operator|>>=
literal|12
expr_stmt|;
name|mant
operator|&=
literal|0x07FF
expr_stmt|;
if|if
condition|(
name|exp
operator|>
literal|7
condition|)
name|value
operator|=
literal|0x77FF
expr_stmt|;
block|}
if|if
condition|(
name|exp
operator|<
operator|-
literal|8
condition|)
name|value
operator|=
literal|0x8000
expr_stmt|;
if|if
condition|(
name|value
operator|==
literal|0
condition|)
block|{
name|mant
operator|=
operator|(
name|exp
operator|<<
literal|12
operator|)
operator||
name|mant
expr_stmt|;
name|value
operator|=
name|mant
operator|&
literal|0xFFFF
expr_stmt|;
block|}
block|}
block|}
block|}
name|md_number_to_chars
argument_list|(
name|literalP
argument_list|,
name|value
argument_list|,
name|prec
argument_list|)
expr_stmt|;
operator|*
name|sizeP
operator|=
name|prec
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|md_number_to_chars
parameter_list|(
name|buf
parameter_list|,
name|val
parameter_list|,
name|n
parameter_list|)
name|char
modifier|*
name|buf
decl_stmt|;
name|valueT
name|val
decl_stmt|;
name|int
name|n
decl_stmt|;
block|{
name|debug
argument_list|(
literal|"In md_number_to_chars()\n"
argument_list|)
expr_stmt|;
name|number_to_chars_bigendian
argument_list|(
name|buf
argument_list|,
name|val
argument_list|,
name|n
argument_list|)
expr_stmt|;
comment|/*  number_to_chars_littleendian(buf,val,n); */
block|}
end_function

begin_define
define|#
directive|define
name|F
parameter_list|(
name|SZ
parameter_list|,
name|PCREL
parameter_list|)
value|(((SZ)<< 1) + (PCREL))
end_define

begin_define
define|#
directive|define
name|MAP
parameter_list|(
name|SZ
parameter_list|,
name|PCREL
parameter_list|,
name|TYPE
parameter_list|)
value|case F(SZ,PCREL): code = (TYPE); break
end_define

begin_function
name|arelent
modifier|*
name|tc_gen_reloc
parameter_list|(
name|section
parameter_list|,
name|fixP
parameter_list|)
name|asection
modifier|*
name|section
decl_stmt|;
name|fixS
modifier|*
name|fixP
decl_stmt|;
block|{
name|arelent
modifier|*
name|rel
decl_stmt|;
name|bfd_reloc_code_real_type
name|code
init|=
literal|0
decl_stmt|;
name|debug
argument_list|(
literal|"In tc_gen_reloc()\n"
argument_list|)
expr_stmt|;
name|debug
argument_list|(
literal|"fixP.size = %d\n"
argument_list|,
name|fixP
operator|->
name|fx_size
argument_list|)
expr_stmt|;
name|debug
argument_list|(
literal|"fixP.pcrel = %d\n"
argument_list|,
name|fixP
operator|->
name|fx_pcrel
argument_list|)
expr_stmt|;
name|debug
argument_list|(
literal|"addsy.name = %s\n"
argument_list|,
name|S_GET_NAME
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|F
argument_list|(
name|fixP
operator|->
name|fx_size
argument_list|,
name|fixP
operator|->
name|fx_pcrel
argument_list|)
condition|)
block|{
name|MAP
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
name|BFD_RELOC_TIC30_LDP
argument_list|)
expr_stmt|;
name|MAP
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|,
name|BFD_RELOC_16
argument_list|)
expr_stmt|;
name|MAP
argument_list|(
literal|3
argument_list|,
literal|0
argument_list|,
name|BFD_RELOC_24
argument_list|)
expr_stmt|;
name|MAP
argument_list|(
literal|2
argument_list|,
literal|1
argument_list|,
name|BFD_RELOC_16_PCREL
argument_list|)
expr_stmt|;
name|MAP
argument_list|(
literal|4
argument_list|,
literal|0
argument_list|,
name|BFD_RELOC_32
argument_list|)
expr_stmt|;
default|default:
name|as_bad
argument_list|(
literal|"Can not do %d byte %srelocation"
argument_list|,
name|fixP
operator|->
name|fx_size
argument_list|,
name|fixP
operator|->
name|fx_pcrel
condition|?
literal|"pc-relative "
else|:
literal|""
argument_list|)
expr_stmt|;
block|}
undef|#
directive|undef
name|MAP
undef|#
directive|undef
name|F
name|rel
operator|=
operator|(
name|arelent
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|arelent
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|rel
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|rel
operator|->
name|sym_ptr_ptr
operator|=
operator|&
name|fixP
operator|->
name|fx_addsy
operator|->
name|bsym
expr_stmt|;
name|rel
operator|->
name|address
operator|=
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_address
operator|+
name|fixP
operator|->
name|fx_where
expr_stmt|;
if|if
condition|(
name|fixP
operator|->
name|fx_pcrel
condition|)
name|rel
operator|->
name|addend
operator|=
name|fixP
operator|->
name|fx_addnumber
expr_stmt|;
else|else
name|rel
operator|->
name|addend
operator|=
literal|0
expr_stmt|;
name|rel
operator|->
name|howto
operator|=
name|bfd_reloc_type_lookup
argument_list|(
name|stdoutput
argument_list|,
name|code
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rel
operator|->
name|howto
condition|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|name
operator|=
name|S_GET_NAME
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
name|name
operator|=
literal|"<unknown>"
expr_stmt|;
name|as_fatal
argument_list|(
literal|"Cannot generate relocation type for symbol %s, code %s"
argument_list|,
name|name
argument_list|,
name|bfd_get_reloc_code_name
argument_list|(
name|code
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|rel
return|;
block|}
end_function

begin_function
name|void
name|tc_aout_pre_write_hook
parameter_list|()
block|{
name|debug
argument_list|(
literal|"In tc_aout_pre_write_hook()\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|md_operand
parameter_list|(
name|expressionP
parameter_list|)
name|expressionS
modifier|*
name|expressionP
decl_stmt|;
block|{
name|debug
argument_list|(
literal|"In md_operand()\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|char
name|output_invalid_buf
index|[
literal|8
index|]
decl_stmt|;
end_decl_stmt

begin_function
name|char
modifier|*
name|output_invalid
parameter_list|(
name|c
parameter_list|)
name|char
name|c
decl_stmt|;
block|{
if|if
condition|(
name|isprint
argument_list|(
name|c
argument_list|)
condition|)
name|sprintf
argument_list|(
name|output_invalid_buf
argument_list|,
literal|"'%c'"
argument_list|,
name|c
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|output_invalid_buf
argument_list|,
literal|"(0x%x)"
argument_list|,
operator|(
name|unsigned
operator|)
name|c
argument_list|)
expr_stmt|;
return|return
name|output_invalid_buf
return|;
block|}
end_function

end_unit

