begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* tc-ppc.c -- Assemble for the PowerPC or POWER (RS/6000)    Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001    Free Software Foundation, Inc.    Written by Ian Lance Taylor, Cygnus Support.     This file is part of GAS, the GNU Assembler.     GAS is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     GAS is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with GAS; see the file COPYING.  If not, write to the Free    Software Foundation, 59 Temple Place - Suite 330, Boston, MA    02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|"as.h"
end_include

begin_include
include|#
directive|include
file|"subsegs.h"
end_include

begin_include
include|#
directive|include
file|"opcode/ppc.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|OBJ_ELF
end_ifdef

begin_include
include|#
directive|include
file|"elf/ppc.h"
end_include

begin_include
include|#
directive|include
file|"dwarf2dbg.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|TE_PE
end_ifdef

begin_include
include|#
directive|include
file|"coff/pe.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* This is the assembler for the PowerPC or POWER (RS/6000) chips.  */
end_comment

begin_comment
comment|/* Tell the main code what the endianness is.  */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|target_big_endian
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Whether or not, we've set target_big_endian.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|set_target_endian
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Whether to use user friendly register names.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|TARGET_REG_NAMES_P
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|TE_PE
end_ifdef

begin_define
define|#
directive|define
name|TARGET_REG_NAMES_P
value|true
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|TARGET_REG_NAMES_P
value|false
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|boolean
name|reg_names_p
init|=
name|TARGET_REG_NAMES_P
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|register_name
name|PARAMS
argument_list|(
operator|(
name|expressionS
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ppc_set_cpu
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|long
name|ppc_insert_operand
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|long
name|insn
operator|,
specifier|const
expr|struct
name|powerpc_operand
operator|*
name|operand
operator|,
name|offsetT
name|val
operator|,
name|char
operator|*
name|file
operator|,
name|unsigned
name|int
name|line
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ppc_macro
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
name|str
operator|,
specifier|const
expr|struct
name|powerpc_macro
operator|*
name|macro
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ppc_byte
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ppc_is_toc_sym
name|PARAMS
argument_list|(
operator|(
name|symbolS
operator|*
name|sym
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ppc_tc
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|OBJ_XCOFF
end_ifdef

begin_decl_stmt
specifier|static
name|void
name|ppc_comm
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ppc_bb
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ppc_bc
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ppc_bf
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ppc_biei
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ppc_bs
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ppc_eb
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ppc_ec
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ppc_ef
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ppc_es
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ppc_csect
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ppc_change_csect
name|PARAMS
argument_list|(
operator|(
name|symbolS
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ppc_function
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ppc_extern
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ppc_lglobl
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ppc_section
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ppc_named_section
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ppc_stabx
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ppc_rename
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ppc_toc
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ppc_xcoff_cons
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ppc_machine
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ppc_vbyte
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|OBJ_ELF
end_ifdef

begin_decl_stmt
specifier|static
name|bfd_reloc_code_real_type
name|ppc_elf_suffix
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|,
name|expressionS
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ppc_elf_cons
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ppc_elf_rdata
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ppc_elf_lcomm
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ppc_elf_validate_fix
name|PARAMS
argument_list|(
operator|(
name|fixS
operator|*
operator|,
name|segT
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|TE_PE
end_ifdef

begin_decl_stmt
specifier|static
name|void
name|ppc_set_current_section
name|PARAMS
argument_list|(
operator|(
name|segT
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ppc_previous
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ppc_pdata
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ppc_ydata
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ppc_reldata
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ppc_rdata
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ppc_ualong
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ppc_znop
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ppc_pe_comm
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ppc_pe_section
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ppc_pe_function
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ppc_pe_tocd
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* Generic assembler global variables which must be defined by all    targets.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|OBJ_ELF
end_ifdef

begin_comment
comment|/* This string holds the chars that always start a comment.  If the    pre-processor is disabled, these aren't very useful.  The macro    tc_comment_chars points to this.  We use this, rather than the    usual comment_chars, so that we can switch for Solaris conventions.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
name|ppc_solaris_comment_chars
index|[]
init|=
literal|"#!"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
name|ppc_eabi_comment_chars
index|[]
init|=
literal|"#"
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|TARGET_SOLARIS_COMMENT
end_ifdef

begin_decl_stmt
specifier|const
name|char
modifier|*
name|ppc_comment_chars
init|=
name|ppc_solaris_comment_chars
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|const
name|char
modifier|*
name|ppc_comment_chars
init|=
name|ppc_eabi_comment_chars
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|const
name|char
name|comment_chars
index|[]
init|=
literal|"#"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Characters which start a comment at the beginning of a line.  */
end_comment

begin_decl_stmt
specifier|const
name|char
name|line_comment_chars
index|[]
init|=
literal|"#"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Characters which may be used to separate multiple commands on a    single line.  */
end_comment

begin_decl_stmt
specifier|const
name|char
name|line_separator_chars
index|[]
init|=
literal|";"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Characters which are used to indicate an exponent in a floating    point number.  */
end_comment

begin_decl_stmt
specifier|const
name|char
name|EXP_CHARS
index|[]
init|=
literal|"eE"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Characters which mean that a number is a floating point constant,    as in 0d1.0.  */
end_comment

begin_decl_stmt
specifier|const
name|char
name|FLT_CHARS
index|[]
init|=
literal|"dD"
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* The target specific pseudo-ops which we support.  */
end_comment

begin_decl_stmt
specifier|const
name|pseudo_typeS
name|md_pseudo_table
index|[]
init|=
block|{
comment|/* Pseudo-ops which must be overridden.  */
block|{
literal|"byte"
block|,
name|ppc_byte
block|,
literal|0
block|}
block|,
ifdef|#
directive|ifdef
name|OBJ_XCOFF
comment|/* Pseudo-ops specific to the RS/6000 XCOFF format.  Some of these      legitimately belong in the obj-*.c file.  However, XCOFF is based      on COFF, and is only implemented for the RS/6000.  We just use      obj-coff.c, and add what we need here.  */
block|{
literal|"comm"
block|,
name|ppc_comm
block|,
literal|0
block|}
block|,
block|{
literal|"lcomm"
block|,
name|ppc_comm
block|,
literal|1
block|}
block|,
block|{
literal|"bb"
block|,
name|ppc_bb
block|,
literal|0
block|}
block|,
block|{
literal|"bc"
block|,
name|ppc_bc
block|,
literal|0
block|}
block|,
block|{
literal|"bf"
block|,
name|ppc_bf
block|,
literal|0
block|}
block|,
block|{
literal|"bi"
block|,
name|ppc_biei
block|,
literal|0
block|}
block|,
block|{
literal|"bs"
block|,
name|ppc_bs
block|,
literal|0
block|}
block|,
block|{
literal|"csect"
block|,
name|ppc_csect
block|,
literal|0
block|}
block|,
block|{
literal|"data"
block|,
name|ppc_section
block|,
literal|'d'
block|}
block|,
block|{
literal|"eb"
block|,
name|ppc_eb
block|,
literal|0
block|}
block|,
block|{
literal|"ec"
block|,
name|ppc_ec
block|,
literal|0
block|}
block|,
block|{
literal|"ef"
block|,
name|ppc_ef
block|,
literal|0
block|}
block|,
block|{
literal|"ei"
block|,
name|ppc_biei
block|,
literal|1
block|}
block|,
block|{
literal|"es"
block|,
name|ppc_es
block|,
literal|0
block|}
block|,
block|{
literal|"extern"
block|,
name|ppc_extern
block|,
literal|0
block|}
block|,
block|{
literal|"function"
block|,
name|ppc_function
block|,
literal|0
block|}
block|,
block|{
literal|"lglobl"
block|,
name|ppc_lglobl
block|,
literal|0
block|}
block|,
block|{
literal|"rename"
block|,
name|ppc_rename
block|,
literal|0
block|}
block|,
block|{
literal|"section"
block|,
name|ppc_named_section
block|,
literal|0
block|}
block|,
block|{
literal|"stabx"
block|,
name|ppc_stabx
block|,
literal|0
block|}
block|,
block|{
literal|"text"
block|,
name|ppc_section
block|,
literal|'t'
block|}
block|,
block|{
literal|"toc"
block|,
name|ppc_toc
block|,
literal|0
block|}
block|,
block|{
literal|"long"
block|,
name|ppc_xcoff_cons
block|,
literal|2
block|}
block|,
block|{
literal|"llong"
block|,
name|ppc_xcoff_cons
block|,
literal|3
block|}
block|,
block|{
literal|"word"
block|,
name|ppc_xcoff_cons
block|,
literal|1
block|}
block|,
block|{
literal|"short"
block|,
name|ppc_xcoff_cons
block|,
literal|1
block|}
block|,
block|{
literal|"vbyte"
block|,
name|ppc_vbyte
block|,
literal|0
block|}
block|,
block|{
literal|"machine"
block|,
name|ppc_machine
block|,
literal|0
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|OBJ_ELF
block|{
literal|"long"
block|,
name|ppc_elf_cons
block|,
literal|4
block|}
block|,
block|{
literal|"word"
block|,
name|ppc_elf_cons
block|,
literal|2
block|}
block|,
block|{
literal|"short"
block|,
name|ppc_elf_cons
block|,
literal|2
block|}
block|,
block|{
literal|"rdata"
block|,
name|ppc_elf_rdata
block|,
literal|0
block|}
block|,
block|{
literal|"rodata"
block|,
name|ppc_elf_rdata
block|,
literal|0
block|}
block|,
block|{
literal|"lcomm"
block|,
name|ppc_elf_lcomm
block|,
literal|0
block|}
block|,
block|{
literal|"file"
block|,
name|dwarf2_directive_file
block|,
literal|0
block|}
block|,
block|{
literal|"loc"
block|,
name|dwarf2_directive_loc
block|,
literal|0
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TE_PE
comment|/* Pseudo-ops specific to the Windows NT PowerPC PE (coff) format */
block|{
literal|"previous"
block|,
name|ppc_previous
block|,
literal|0
block|}
block|,
block|{
literal|"pdata"
block|,
name|ppc_pdata
block|,
literal|0
block|}
block|,
block|{
literal|"ydata"
block|,
name|ppc_ydata
block|,
literal|0
block|}
block|,
block|{
literal|"reldata"
block|,
name|ppc_reldata
block|,
literal|0
block|}
block|,
block|{
literal|"rdata"
block|,
name|ppc_rdata
block|,
literal|0
block|}
block|,
block|{
literal|"ualong"
block|,
name|ppc_ualong
block|,
literal|0
block|}
block|,
block|{
literal|"znop"
block|,
name|ppc_znop
block|,
literal|0
block|}
block|,
block|{
literal|"comm"
block|,
name|ppc_pe_comm
block|,
literal|0
block|}
block|,
block|{
literal|"lcomm"
block|,
name|ppc_pe_comm
block|,
literal|1
block|}
block|,
block|{
literal|"section"
block|,
name|ppc_pe_section
block|,
literal|0
block|}
block|,
block|{
literal|"function"
block|,
name|ppc_pe_function
block|,
literal|0
block|}
block|,
block|{
literal|"tocd"
block|,
name|ppc_pe_tocd
block|,
literal|0
block|}
block|,
endif|#
directive|endif
comment|/* This pseudo-op is used even when not generating XCOFF output.  */
block|{
literal|"tc"
block|,
name|ppc_tc
block|,
literal|0
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Predefined register names if -mregnames (or default for Windows NT).  */
end_comment

begin_comment
comment|/* In general, there are lots of them, in an attempt to be compatible */
end_comment

begin_comment
comment|/* with a number of other Windows NT assemblers.                      */
end_comment

begin_comment
comment|/* Structure to hold information about predefined registers.  */
end_comment

begin_struct
struct|struct
name|pd_reg
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|value
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* List of registers that are pre-defined:     Each general register has predefined names of the form:    1. r<reg_num> which has the value<reg_num>.    2. r.<reg_num> which has the value<reg_num>.     Each floating point register has predefined names of the form:    1. f<reg_num> which has the value<reg_num>.    2. f.<reg_num> which has the value<reg_num>.     Each vector unit register has predefined names of the form:    1. v<reg_num> which has the value<reg_num>.    2. v.<reg_num> which has the value<reg_num>.     Each condition register has predefined names of the form:    1. cr<reg_num> which has the value<reg_num>.    2. cr.<reg_num> which has the value<reg_num>.     There are individual registers as well:    sp or r.sp     has the value 1    rtoc or r.toc  has the value 2    fpscr          has the value 0    xer            has the value 1    lr             has the value 8    ctr            has the value 9    pmr            has the value 0    dar            has the value 19    dsisr          has the value 18    dec            has the value 22    sdr1           has the value 25    srr0           has the value 26    srr1           has the value 27     The table is sorted. Suitable for searching by a binary search.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|pd_reg
name|pre_defined_registers
index|[]
init|=
block|{
block|{
literal|"cr.0"
block|,
literal|0
block|}
block|,
comment|/* Condition Registers */
block|{
literal|"cr.1"
block|,
literal|1
block|}
block|,
block|{
literal|"cr.2"
block|,
literal|2
block|}
block|,
block|{
literal|"cr.3"
block|,
literal|3
block|}
block|,
block|{
literal|"cr.4"
block|,
literal|4
block|}
block|,
block|{
literal|"cr.5"
block|,
literal|5
block|}
block|,
block|{
literal|"cr.6"
block|,
literal|6
block|}
block|,
block|{
literal|"cr.7"
block|,
literal|7
block|}
block|,
block|{
literal|"cr0"
block|,
literal|0
block|}
block|,
block|{
literal|"cr1"
block|,
literal|1
block|}
block|,
block|{
literal|"cr2"
block|,
literal|2
block|}
block|,
block|{
literal|"cr3"
block|,
literal|3
block|}
block|,
block|{
literal|"cr4"
block|,
literal|4
block|}
block|,
block|{
literal|"cr5"
block|,
literal|5
block|}
block|,
block|{
literal|"cr6"
block|,
literal|6
block|}
block|,
block|{
literal|"cr7"
block|,
literal|7
block|}
block|,
block|{
literal|"ctr"
block|,
literal|9
block|}
block|,
block|{
literal|"dar"
block|,
literal|19
block|}
block|,
comment|/* Data Access Register */
block|{
literal|"dec"
block|,
literal|22
block|}
block|,
comment|/* Decrementer */
block|{
literal|"dsisr"
block|,
literal|18
block|}
block|,
comment|/* Data Storage Interrupt Status Register */
block|{
literal|"f.0"
block|,
literal|0
block|}
block|,
comment|/* Floating point registers */
block|{
literal|"f.1"
block|,
literal|1
block|}
block|,
block|{
literal|"f.10"
block|,
literal|10
block|}
block|,
block|{
literal|"f.11"
block|,
literal|11
block|}
block|,
block|{
literal|"f.12"
block|,
literal|12
block|}
block|,
block|{
literal|"f.13"
block|,
literal|13
block|}
block|,
block|{
literal|"f.14"
block|,
literal|14
block|}
block|,
block|{
literal|"f.15"
block|,
literal|15
block|}
block|,
block|{
literal|"f.16"
block|,
literal|16
block|}
block|,
block|{
literal|"f.17"
block|,
literal|17
block|}
block|,
block|{
literal|"f.18"
block|,
literal|18
block|}
block|,
block|{
literal|"f.19"
block|,
literal|19
block|}
block|,
block|{
literal|"f.2"
block|,
literal|2
block|}
block|,
block|{
literal|"f.20"
block|,
literal|20
block|}
block|,
block|{
literal|"f.21"
block|,
literal|21
block|}
block|,
block|{
literal|"f.22"
block|,
literal|22
block|}
block|,
block|{
literal|"f.23"
block|,
literal|23
block|}
block|,
block|{
literal|"f.24"
block|,
literal|24
block|}
block|,
block|{
literal|"f.25"
block|,
literal|25
block|}
block|,
block|{
literal|"f.26"
block|,
literal|26
block|}
block|,
block|{
literal|"f.27"
block|,
literal|27
block|}
block|,
block|{
literal|"f.28"
block|,
literal|28
block|}
block|,
block|{
literal|"f.29"
block|,
literal|29
block|}
block|,
block|{
literal|"f.3"
block|,
literal|3
block|}
block|,
block|{
literal|"f.30"
block|,
literal|30
block|}
block|,
block|{
literal|"f.31"
block|,
literal|31
block|}
block|,
block|{
literal|"f.4"
block|,
literal|4
block|}
block|,
block|{
literal|"f.5"
block|,
literal|5
block|}
block|,
block|{
literal|"f.6"
block|,
literal|6
block|}
block|,
block|{
literal|"f.7"
block|,
literal|7
block|}
block|,
block|{
literal|"f.8"
block|,
literal|8
block|}
block|,
block|{
literal|"f.9"
block|,
literal|9
block|}
block|,
block|{
literal|"f0"
block|,
literal|0
block|}
block|,
block|{
literal|"f1"
block|,
literal|1
block|}
block|,
block|{
literal|"f10"
block|,
literal|10
block|}
block|,
block|{
literal|"f11"
block|,
literal|11
block|}
block|,
block|{
literal|"f12"
block|,
literal|12
block|}
block|,
block|{
literal|"f13"
block|,
literal|13
block|}
block|,
block|{
literal|"f14"
block|,
literal|14
block|}
block|,
block|{
literal|"f15"
block|,
literal|15
block|}
block|,
block|{
literal|"f16"
block|,
literal|16
block|}
block|,
block|{
literal|"f17"
block|,
literal|17
block|}
block|,
block|{
literal|"f18"
block|,
literal|18
block|}
block|,
block|{
literal|"f19"
block|,
literal|19
block|}
block|,
block|{
literal|"f2"
block|,
literal|2
block|}
block|,
block|{
literal|"f20"
block|,
literal|20
block|}
block|,
block|{
literal|"f21"
block|,
literal|21
block|}
block|,
block|{
literal|"f22"
block|,
literal|22
block|}
block|,
block|{
literal|"f23"
block|,
literal|23
block|}
block|,
block|{
literal|"f24"
block|,
literal|24
block|}
block|,
block|{
literal|"f25"
block|,
literal|25
block|}
block|,
block|{
literal|"f26"
block|,
literal|26
block|}
block|,
block|{
literal|"f27"
block|,
literal|27
block|}
block|,
block|{
literal|"f28"
block|,
literal|28
block|}
block|,
block|{
literal|"f29"
block|,
literal|29
block|}
block|,
block|{
literal|"f3"
block|,
literal|3
block|}
block|,
block|{
literal|"f30"
block|,
literal|30
block|}
block|,
block|{
literal|"f31"
block|,
literal|31
block|}
block|,
block|{
literal|"f4"
block|,
literal|4
block|}
block|,
block|{
literal|"f5"
block|,
literal|5
block|}
block|,
block|{
literal|"f6"
block|,
literal|6
block|}
block|,
block|{
literal|"f7"
block|,
literal|7
block|}
block|,
block|{
literal|"f8"
block|,
literal|8
block|}
block|,
block|{
literal|"f9"
block|,
literal|9
block|}
block|,
block|{
literal|"fpscr"
block|,
literal|0
block|}
block|,
block|{
literal|"lr"
block|,
literal|8
block|}
block|,
comment|/* Link Register */
block|{
literal|"pmr"
block|,
literal|0
block|}
block|,
block|{
literal|"r.0"
block|,
literal|0
block|}
block|,
comment|/* General Purpose Registers */
block|{
literal|"r.1"
block|,
literal|1
block|}
block|,
block|{
literal|"r.10"
block|,
literal|10
block|}
block|,
block|{
literal|"r.11"
block|,
literal|11
block|}
block|,
block|{
literal|"r.12"
block|,
literal|12
block|}
block|,
block|{
literal|"r.13"
block|,
literal|13
block|}
block|,
block|{
literal|"r.14"
block|,
literal|14
block|}
block|,
block|{
literal|"r.15"
block|,
literal|15
block|}
block|,
block|{
literal|"r.16"
block|,
literal|16
block|}
block|,
block|{
literal|"r.17"
block|,
literal|17
block|}
block|,
block|{
literal|"r.18"
block|,
literal|18
block|}
block|,
block|{
literal|"r.19"
block|,
literal|19
block|}
block|,
block|{
literal|"r.2"
block|,
literal|2
block|}
block|,
block|{
literal|"r.20"
block|,
literal|20
block|}
block|,
block|{
literal|"r.21"
block|,
literal|21
block|}
block|,
block|{
literal|"r.22"
block|,
literal|22
block|}
block|,
block|{
literal|"r.23"
block|,
literal|23
block|}
block|,
block|{
literal|"r.24"
block|,
literal|24
block|}
block|,
block|{
literal|"r.25"
block|,
literal|25
block|}
block|,
block|{
literal|"r.26"
block|,
literal|26
block|}
block|,
block|{
literal|"r.27"
block|,
literal|27
block|}
block|,
block|{
literal|"r.28"
block|,
literal|28
block|}
block|,
block|{
literal|"r.29"
block|,
literal|29
block|}
block|,
block|{
literal|"r.3"
block|,
literal|3
block|}
block|,
block|{
literal|"r.30"
block|,
literal|30
block|}
block|,
block|{
literal|"r.31"
block|,
literal|31
block|}
block|,
block|{
literal|"r.4"
block|,
literal|4
block|}
block|,
block|{
literal|"r.5"
block|,
literal|5
block|}
block|,
block|{
literal|"r.6"
block|,
literal|6
block|}
block|,
block|{
literal|"r.7"
block|,
literal|7
block|}
block|,
block|{
literal|"r.8"
block|,
literal|8
block|}
block|,
block|{
literal|"r.9"
block|,
literal|9
block|}
block|,
block|{
literal|"r.sp"
block|,
literal|1
block|}
block|,
comment|/* Stack Pointer */
block|{
literal|"r.toc"
block|,
literal|2
block|}
block|,
comment|/* Pointer to the table of contents */
block|{
literal|"r0"
block|,
literal|0
block|}
block|,
comment|/* More general purpose registers */
block|{
literal|"r1"
block|,
literal|1
block|}
block|,
block|{
literal|"r10"
block|,
literal|10
block|}
block|,
block|{
literal|"r11"
block|,
literal|11
block|}
block|,
block|{
literal|"r12"
block|,
literal|12
block|}
block|,
block|{
literal|"r13"
block|,
literal|13
block|}
block|,
block|{
literal|"r14"
block|,
literal|14
block|}
block|,
block|{
literal|"r15"
block|,
literal|15
block|}
block|,
block|{
literal|"r16"
block|,
literal|16
block|}
block|,
block|{
literal|"r17"
block|,
literal|17
block|}
block|,
block|{
literal|"r18"
block|,
literal|18
block|}
block|,
block|{
literal|"r19"
block|,
literal|19
block|}
block|,
block|{
literal|"r2"
block|,
literal|2
block|}
block|,
block|{
literal|"r20"
block|,
literal|20
block|}
block|,
block|{
literal|"r21"
block|,
literal|21
block|}
block|,
block|{
literal|"r22"
block|,
literal|22
block|}
block|,
block|{
literal|"r23"
block|,
literal|23
block|}
block|,
block|{
literal|"r24"
block|,
literal|24
block|}
block|,
block|{
literal|"r25"
block|,
literal|25
block|}
block|,
block|{
literal|"r26"
block|,
literal|26
block|}
block|,
block|{
literal|"r27"
block|,
literal|27
block|}
block|,
block|{
literal|"r28"
block|,
literal|28
block|}
block|,
block|{
literal|"r29"
block|,
literal|29
block|}
block|,
block|{
literal|"r3"
block|,
literal|3
block|}
block|,
block|{
literal|"r30"
block|,
literal|30
block|}
block|,
block|{
literal|"r31"
block|,
literal|31
block|}
block|,
block|{
literal|"r4"
block|,
literal|4
block|}
block|,
block|{
literal|"r5"
block|,
literal|5
block|}
block|,
block|{
literal|"r6"
block|,
literal|6
block|}
block|,
block|{
literal|"r7"
block|,
literal|7
block|}
block|,
block|{
literal|"r8"
block|,
literal|8
block|}
block|,
block|{
literal|"r9"
block|,
literal|9
block|}
block|,
block|{
literal|"rtoc"
block|,
literal|2
block|}
block|,
comment|/* Table of contents */
block|{
literal|"sdr1"
block|,
literal|25
block|}
block|,
comment|/* Storage Description Register 1 */
block|{
literal|"sp"
block|,
literal|1
block|}
block|,
block|{
literal|"srr0"
block|,
literal|26
block|}
block|,
comment|/* Machine Status Save/Restore Register 0 */
block|{
literal|"srr1"
block|,
literal|27
block|}
block|,
comment|/* Machine Status Save/Restore Register 1 */
block|{
literal|"v.0"
block|,
literal|0
block|}
block|,
comment|/* Vector registers */
block|{
literal|"v.1"
block|,
literal|1
block|}
block|,
block|{
literal|"v.10"
block|,
literal|10
block|}
block|,
block|{
literal|"v.11"
block|,
literal|11
block|}
block|,
block|{
literal|"v.12"
block|,
literal|12
block|}
block|,
block|{
literal|"v.13"
block|,
literal|13
block|}
block|,
block|{
literal|"v.14"
block|,
literal|14
block|}
block|,
block|{
literal|"v.15"
block|,
literal|15
block|}
block|,
block|{
literal|"v.16"
block|,
literal|16
block|}
block|,
block|{
literal|"v.17"
block|,
literal|17
block|}
block|,
block|{
literal|"v.18"
block|,
literal|18
block|}
block|,
block|{
literal|"v.19"
block|,
literal|19
block|}
block|,
block|{
literal|"v.2"
block|,
literal|2
block|}
block|,
block|{
literal|"v.20"
block|,
literal|20
block|}
block|,
block|{
literal|"v.21"
block|,
literal|21
block|}
block|,
block|{
literal|"v.22"
block|,
literal|22
block|}
block|,
block|{
literal|"v.23"
block|,
literal|23
block|}
block|,
block|{
literal|"v.24"
block|,
literal|24
block|}
block|,
block|{
literal|"v.25"
block|,
literal|25
block|}
block|,
block|{
literal|"v.26"
block|,
literal|26
block|}
block|,
block|{
literal|"v.27"
block|,
literal|27
block|}
block|,
block|{
literal|"v.28"
block|,
literal|28
block|}
block|,
block|{
literal|"v.29"
block|,
literal|29
block|}
block|,
block|{
literal|"v.3"
block|,
literal|3
block|}
block|,
block|{
literal|"v.30"
block|,
literal|30
block|}
block|,
block|{
literal|"v.31"
block|,
literal|31
block|}
block|,
block|{
literal|"v.4"
block|,
literal|4
block|}
block|,
block|{
literal|"v.5"
block|,
literal|5
block|}
block|,
block|{
literal|"v.6"
block|,
literal|6
block|}
block|,
block|{
literal|"v.7"
block|,
literal|7
block|}
block|,
block|{
literal|"v.8"
block|,
literal|8
block|}
block|,
block|{
literal|"v.9"
block|,
literal|9
block|}
block|,
block|{
literal|"v0"
block|,
literal|0
block|}
block|,
block|{
literal|"v1"
block|,
literal|1
block|}
block|,
block|{
literal|"v10"
block|,
literal|10
block|}
block|,
block|{
literal|"v11"
block|,
literal|11
block|}
block|,
block|{
literal|"v12"
block|,
literal|12
block|}
block|,
block|{
literal|"v13"
block|,
literal|13
block|}
block|,
block|{
literal|"v14"
block|,
literal|14
block|}
block|,
block|{
literal|"v15"
block|,
literal|15
block|}
block|,
block|{
literal|"v16"
block|,
literal|16
block|}
block|,
block|{
literal|"v17"
block|,
literal|17
block|}
block|,
block|{
literal|"v18"
block|,
literal|18
block|}
block|,
block|{
literal|"v19"
block|,
literal|19
block|}
block|,
block|{
literal|"v2"
block|,
literal|2
block|}
block|,
block|{
literal|"v20"
block|,
literal|20
block|}
block|,
block|{
literal|"v21"
block|,
literal|21
block|}
block|,
block|{
literal|"v22"
block|,
literal|22
block|}
block|,
block|{
literal|"v23"
block|,
literal|23
block|}
block|,
block|{
literal|"v24"
block|,
literal|24
block|}
block|,
block|{
literal|"v25"
block|,
literal|25
block|}
block|,
block|{
literal|"v26"
block|,
literal|26
block|}
block|,
block|{
literal|"v27"
block|,
literal|27
block|}
block|,
block|{
literal|"v28"
block|,
literal|28
block|}
block|,
block|{
literal|"v29"
block|,
literal|29
block|}
block|,
block|{
literal|"v3"
block|,
literal|3
block|}
block|,
block|{
literal|"v30"
block|,
literal|30
block|}
block|,
block|{
literal|"v31"
block|,
literal|31
block|}
block|,
block|{
literal|"v4"
block|,
literal|4
block|}
block|,
block|{
literal|"v5"
block|,
literal|5
block|}
block|,
block|{
literal|"v6"
block|,
literal|6
block|}
block|,
block|{
literal|"v7"
block|,
literal|7
block|}
block|,
block|{
literal|"v8"
block|,
literal|8
block|}
block|,
block|{
literal|"v9"
block|,
literal|9
block|}
block|,
block|{
literal|"xer"
block|,
literal|1
block|}
block|,  }
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|REG_NAME_CNT
value|(sizeof (pre_defined_registers) / sizeof (struct pd_reg))
end_define

begin_comment
comment|/* Given NAME, find the register number associated with that name, return    the integer value associated with the given name or -1 on failure.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|reg_name_search
name|PARAMS
argument_list|(
operator|(
specifier|const
expr|struct
name|pd_reg
operator|*
operator|,
name|int
operator|,
specifier|const
name|char
operator|*
name|name
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|reg_name_search
parameter_list|(
name|regs
parameter_list|,
name|regcount
parameter_list|,
name|name
parameter_list|)
specifier|const
name|struct
name|pd_reg
modifier|*
name|regs
decl_stmt|;
name|int
name|regcount
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|int
name|middle
decl_stmt|,
name|low
decl_stmt|,
name|high
decl_stmt|;
name|int
name|cmp
decl_stmt|;
name|low
operator|=
literal|0
expr_stmt|;
name|high
operator|=
name|regcount
operator|-
literal|1
expr_stmt|;
do|do
block|{
name|middle
operator|=
operator|(
name|low
operator|+
name|high
operator|)
operator|/
literal|2
expr_stmt|;
name|cmp
operator|=
name|strcasecmp
argument_list|(
name|name
argument_list|,
name|regs
index|[
name|middle
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmp
operator|<
literal|0
condition|)
name|high
operator|=
name|middle
operator|-
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|cmp
operator|>
literal|0
condition|)
name|low
operator|=
name|middle
operator|+
literal|1
expr_stmt|;
else|else
return|return
name|regs
index|[
name|middle
index|]
operator|.
name|value
return|;
block|}
do|while
condition|(
name|low
operator|<=
name|high
condition|)
do|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * Summary of register_name().  *  * in:	Input_line_pointer points to 1st char of operand.  *  * out:	A expressionS.  *      The operand may have been a register: in this case, X_op == O_register,  *      X_add_number is set to the register number, and truth is returned.  *	Input_line_pointer->(next non-blank) char after operand, or is in its  *      original state.  */
end_comment

begin_function
specifier|static
name|boolean
name|register_name
parameter_list|(
name|expressionP
parameter_list|)
name|expressionS
modifier|*
name|expressionP
decl_stmt|;
block|{
name|int
name|reg_number
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|start
decl_stmt|;
name|char
name|c
decl_stmt|;
comment|/* Find the spelling of the operand */
name|start
operator|=
name|name
operator|=
name|input_line_pointer
expr_stmt|;
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'%'
operator|&&
name|isalpha
argument_list|(
name|name
index|[
literal|1
index|]
argument_list|)
condition|)
name|name
operator|=
operator|++
name|input_line_pointer
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|reg_names_p
operator|||
operator|!
name|isalpha
argument_list|(
name|name
index|[
literal|0
index|]
argument_list|)
condition|)
return|return
name|false
return|;
name|c
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
name|reg_number
operator|=
name|reg_name_search
argument_list|(
name|pre_defined_registers
argument_list|,
name|REG_NAME_CNT
argument_list|,
name|name
argument_list|)
expr_stmt|;
comment|/* look to see if it's in the register table */
if|if
condition|(
name|reg_number
operator|>=
literal|0
condition|)
block|{
name|expressionP
operator|->
name|X_op
operator|=
name|O_register
expr_stmt|;
name|expressionP
operator|->
name|X_add_number
operator|=
name|reg_number
expr_stmt|;
comment|/* make the rest nice */
name|expressionP
operator|->
name|X_add_symbol
operator|=
name|NULL
expr_stmt|;
name|expressionP
operator|->
name|X_op_symbol
operator|=
name|NULL
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
comment|/* put back the delimiting char */
return|return
name|true
return|;
block|}
else|else
block|{
comment|/* reset the line as if we had not done anything */
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
comment|/* put back the delimiting char */
name|input_line_pointer
operator|=
name|start
expr_stmt|;
comment|/* reset input_line pointer */
return|return
name|false
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This function is called for each symbol seen in an expression.  It    handles the special parsing which PowerPC assemblers are supposed    to use for condition codes.  */
end_comment

begin_comment
comment|/* Whether to do the special parsing.  */
end_comment

begin_decl_stmt
specifier|static
name|boolean
name|cr_operand
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Names to recognize in a condition code.  This table is sorted.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|pd_reg
name|cr_names
index|[]
init|=
block|{
block|{
literal|"cr0"
block|,
literal|0
block|}
block|,
block|{
literal|"cr1"
block|,
literal|1
block|}
block|,
block|{
literal|"cr2"
block|,
literal|2
block|}
block|,
block|{
literal|"cr3"
block|,
literal|3
block|}
block|,
block|{
literal|"cr4"
block|,
literal|4
block|}
block|,
block|{
literal|"cr5"
block|,
literal|5
block|}
block|,
block|{
literal|"cr6"
block|,
literal|6
block|}
block|,
block|{
literal|"cr7"
block|,
literal|7
block|}
block|,
block|{
literal|"eq"
block|,
literal|2
block|}
block|,
block|{
literal|"gt"
block|,
literal|1
block|}
block|,
block|{
literal|"lt"
block|,
literal|0
block|}
block|,
block|{
literal|"so"
block|,
literal|3
block|}
block|,
block|{
literal|"un"
block|,
literal|3
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Parsing function.  This returns non-zero if it recognized an    expression.  */
end_comment

begin_function
name|int
name|ppc_parse_name
parameter_list|(
name|name
parameter_list|,
name|expr
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|expressionS
modifier|*
name|expr
decl_stmt|;
block|{
name|int
name|val
decl_stmt|;
if|if
condition|(
operator|!
name|cr_operand
condition|)
return|return
literal|0
return|;
name|val
operator|=
name|reg_name_search
argument_list|(
name|cr_names
argument_list|,
sizeof|sizeof
name|cr_names
operator|/
sizeof|sizeof
name|cr_names
index|[
literal|0
index|]
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|<
literal|0
condition|)
return|return
literal|0
return|;
name|expr
operator|->
name|X_op
operator|=
name|O_constant
expr_stmt|;
name|expr
operator|->
name|X_add_number
operator|=
name|val
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Local variables.  */
end_comment

begin_comment
comment|/* The type of processor we are assembling for.  This is one or more    of the PPC_OPCODE flags defined in opcode/ppc.h.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|ppc_cpu
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The size of the processor we are assembling for.  This is either    PPC_OPCODE_32 or PPC_OPCODE_64.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|long
name|ppc_size
init|=
name|PPC_OPCODE_32
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Whether to target xcoff64 */
end_comment

begin_decl_stmt
specifier|static
name|int
name|ppc_xcoff64
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Opcode hash table.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|hash_control
modifier|*
name|ppc_hash
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Macro hash table.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|hash_control
modifier|*
name|ppc_macro_hash
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|OBJ_ELF
end_ifdef

begin_comment
comment|/* What type of shared library support to use */
end_comment

begin_enum
specifier|static
enum|enum
block|{
name|SHLIB_NONE
block|,
name|SHLIB_PIC
block|,
name|SHLIB_MRELOCATABLE
block|}
name|shlib
init|=
name|SHLIB_NONE
enum|;
end_enum

begin_comment
comment|/* Flags to set in the elf header */
end_comment

begin_decl_stmt
specifier|static
name|flagword
name|ppc_flags
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Whether this is Solaris or not.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|TARGET_SOLARIS_COMMENT
end_ifdef

begin_define
define|#
directive|define
name|SOLARIS_P
value|true
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|SOLARIS_P
value|false
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|boolean
name|msolaris
init|=
name|SOLARIS_P
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|OBJ_XCOFF
end_ifdef

begin_comment
comment|/* The RS/6000 assembler uses the .csect pseudo-op to generate code    using a bunch of different sections.  These assembler sections,    however, are all encompassed within the .text or .data sections of    the final output file.  We handle this by using different    subsegments within these main segments.  */
end_comment

begin_comment
comment|/* Next subsegment to allocate within the .text segment.  */
end_comment

begin_decl_stmt
specifier|static
name|subsegT
name|ppc_text_subsegment
init|=
literal|2
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Linked list of csects in the text section.  */
end_comment

begin_decl_stmt
specifier|static
name|symbolS
modifier|*
name|ppc_text_csects
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Next subsegment to allocate within the .data segment.  */
end_comment

begin_decl_stmt
specifier|static
name|subsegT
name|ppc_data_subsegment
init|=
literal|2
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Linked list of csects in the data section.  */
end_comment

begin_decl_stmt
specifier|static
name|symbolS
modifier|*
name|ppc_data_csects
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The current csect.  */
end_comment

begin_decl_stmt
specifier|static
name|symbolS
modifier|*
name|ppc_current_csect
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The RS/6000 assembler uses a TOC which holds addresses of functions    and variables.  Symbols are put in the TOC with the .tc pseudo-op.    A special relocation is used when accessing TOC entries.  We handle    the TOC as a subsegment within the .data segment.  We set it up if    we see a .toc pseudo-op, and save the csect symbol here.  */
end_comment

begin_decl_stmt
specifier|static
name|symbolS
modifier|*
name|ppc_toc_csect
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The first frag in the TOC subsegment.  */
end_comment

begin_decl_stmt
specifier|static
name|fragS
modifier|*
name|ppc_toc_frag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The first frag in the first subsegment after the TOC in the .data    segment.  NULL if there are no subsegments after the TOC.  */
end_comment

begin_decl_stmt
specifier|static
name|fragS
modifier|*
name|ppc_after_toc_frag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The current static block.  */
end_comment

begin_decl_stmt
specifier|static
name|symbolS
modifier|*
name|ppc_current_block
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The COFF debugging section; set by md_begin.  This is not the    .debug section, but is instead the secret BFD section which will    cause BFD to set the section number of a symbol to N_DEBUG.  */
end_comment

begin_decl_stmt
specifier|static
name|asection
modifier|*
name|ppc_coff_debug_section
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* OBJ_XCOFF */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|TE_PE
end_ifdef

begin_comment
comment|/* Various sections that we need for PE coff support.  */
end_comment

begin_decl_stmt
specifier|static
name|segT
name|ydata_section
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|segT
name|pdata_section
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|segT
name|reldata_section
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|segT
name|rdata_section
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|segT
name|tocdata_section
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The current section and the previous section. See ppc_previous.  */
end_comment

begin_decl_stmt
specifier|static
name|segT
name|ppc_previous_section
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|segT
name|ppc_current_section
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* TE_PE */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|OBJ_ELF
end_ifdef

begin_decl_stmt
name|symbolS
modifier|*
name|GOT_symbol
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pre-defined "_GLOBAL_OFFSET_TABLE" */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* OBJ_ELF */
end_comment

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|OBJ_ELF
end_ifdef

begin_decl_stmt
name|CONST
name|char
modifier|*
name|md_shortopts
init|=
literal|"b:l:usm:K:VQ:"
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
name|CONST
name|char
modifier|*
name|md_shortopts
init|=
literal|"um:"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|struct
name|option
name|md_longopts
index|[]
init|=
block|{
block|{
name|NULL
block|,
name|no_argument
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|size_t
name|md_longopts_size
init|=
sizeof|sizeof
argument_list|(
name|md_longopts
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|md_parse_option
parameter_list|(
name|c
parameter_list|,
name|arg
parameter_list|)
name|int
name|c
decl_stmt|;
name|char
modifier|*
name|arg
decl_stmt|;
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'u'
case|:
comment|/* -u means that any undefined symbols should be treated as 	 external, which is the default for gas anyhow.  */
break|break;
ifdef|#
directive|ifdef
name|OBJ_ELF
case|case
literal|'l'
case|:
comment|/* Solaris as takes -le (presumably for little endian).  For completeness          sake, recognize -be also.  */
if|if
condition|(
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"e"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|target_big_endian
operator|=
literal|0
expr_stmt|;
name|set_target_endian
operator|=
literal|1
expr_stmt|;
block|}
else|else
return|return
literal|0
return|;
break|break;
case|case
literal|'b'
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"e"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|target_big_endian
operator|=
literal|1
expr_stmt|;
name|set_target_endian
operator|=
literal|1
expr_stmt|;
block|}
else|else
return|return
literal|0
return|;
break|break;
case|case
literal|'K'
case|:
comment|/* Recognize -K PIC */
if|if
condition|(
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"PIC"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"pic"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|shlib
operator|=
name|SHLIB_PIC
expr_stmt|;
name|ppc_flags
operator||=
name|EF_PPC_RELOCATABLE_LIB
expr_stmt|;
block|}
else|else
return|return
literal|0
return|;
break|break;
endif|#
directive|endif
comment|/* a64 and a32 determine whether to use XCOFF64 or XCOFF32.  */
case|case
literal|'a'
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"64"
argument_list|)
operator|==
literal|0
condition|)
name|ppc_xcoff64
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"32"
argument_list|)
operator|==
literal|0
condition|)
name|ppc_xcoff64
operator|=
literal|0
expr_stmt|;
else|else
return|return
literal|0
return|;
break|break;
case|case
literal|'m'
case|:
comment|/* -mpwrx and -mpwr2 mean to assemble for the IBM POWER/2          (RIOS2).  */
if|if
condition|(
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"pwrx"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"pwr2"
argument_list|)
operator|==
literal|0
condition|)
name|ppc_cpu
operator|=
name|PPC_OPCODE_POWER
operator||
name|PPC_OPCODE_POWER2
expr_stmt|;
comment|/* -mpwr means to assemble for the IBM POWER (RIOS1).  */
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"pwr"
argument_list|)
operator|==
literal|0
condition|)
name|ppc_cpu
operator|=
name|PPC_OPCODE_POWER
expr_stmt|;
comment|/* -m601 means to assemble for the Motorola PowerPC 601, which includes          instructions that are holdovers from the Power.  */
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"601"
argument_list|)
operator|==
literal|0
condition|)
name|ppc_cpu
operator|=
name|PPC_OPCODE_PPC
operator||
name|PPC_OPCODE_601
expr_stmt|;
comment|/* -mppc, -mppc32, -m603, and -m604 mean to assemble for the          Motorola PowerPC 603/604.  */
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"ppc"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"ppc32"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"403"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"405"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"603"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"604"
argument_list|)
operator|==
literal|0
condition|)
name|ppc_cpu
operator|=
name|PPC_OPCODE_PPC
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"7400"
argument_list|)
operator|==
literal|0
condition|)
name|ppc_cpu
operator|=
name|PPC_OPCODE_PPC
operator||
name|PPC_OPCODE_ALTIVEC
expr_stmt|;
comment|/* -mppc64 and -m620 mean to assemble for the 64-bit PowerPC          620.  */
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"ppc64"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"620"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|ppc_cpu
operator|=
name|PPC_OPCODE_PPC
expr_stmt|;
name|ppc_size
operator|=
name|PPC_OPCODE_64
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"ppc64bridge"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|ppc_cpu
operator|=
name|PPC_OPCODE_PPC
operator||
name|PPC_OPCODE_64_BRIDGE
expr_stmt|;
name|ppc_size
operator|=
name|PPC_OPCODE_64
expr_stmt|;
block|}
comment|/* -mcom means assemble for the common intersection between Power 	 and PowerPC.  At present, we just allow the union, rather 	 than the intersection.  */
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"com"
argument_list|)
operator|==
literal|0
condition|)
name|ppc_cpu
operator|=
name|PPC_OPCODE_COMMON
expr_stmt|;
comment|/* -many means to assemble for any architecture (PWR/PWRX/PPC).  */
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"any"
argument_list|)
operator|==
literal|0
condition|)
name|ppc_cpu
operator|=
name|PPC_OPCODE_ANY
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"regnames"
argument_list|)
operator|==
literal|0
condition|)
name|reg_names_p
operator|=
name|true
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"no-regnames"
argument_list|)
operator|==
literal|0
condition|)
name|reg_names_p
operator|=
name|false
expr_stmt|;
ifdef|#
directive|ifdef
name|OBJ_ELF
comment|/* -mrelocatable/-mrelocatable-lib -- warn about initializations that require relocation */
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"relocatable"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|shlib
operator|=
name|SHLIB_MRELOCATABLE
expr_stmt|;
name|ppc_flags
operator||=
name|EF_PPC_RELOCATABLE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"relocatable-lib"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|shlib
operator|=
name|SHLIB_MRELOCATABLE
expr_stmt|;
name|ppc_flags
operator||=
name|EF_PPC_RELOCATABLE_LIB
expr_stmt|;
block|}
comment|/* -memb, set embedded bit */
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"emb"
argument_list|)
operator|==
literal|0
condition|)
name|ppc_flags
operator||=
name|EF_PPC_EMB
expr_stmt|;
comment|/* -mlittle/-mbig set the endianess */
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"little"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"little-endian"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|target_big_endian
operator|=
literal|0
expr_stmt|;
name|set_target_endian
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"big"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"big-endian"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|target_big_endian
operator|=
literal|1
expr_stmt|;
name|set_target_endian
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"solaris"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|msolaris
operator|=
name|true
expr_stmt|;
name|ppc_comment_chars
operator|=
name|ppc_solaris_comment_chars
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"no-solaris"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|msolaris
operator|=
name|false
expr_stmt|;
name|ppc_comment_chars
operator|=
name|ppc_eabi_comment_chars
expr_stmt|;
block|}
endif|#
directive|endif
else|else
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"invalid switch -m%s"
argument_list|)
argument_list|,
name|arg
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
break|break;
ifdef|#
directive|ifdef
name|OBJ_ELF
comment|/* -V: SVR4 argument to print version ID.  */
case|case
literal|'V'
case|:
name|print_version_id
argument_list|()
expr_stmt|;
break|break;
comment|/* -Qy, -Qn: SVR4 arguments controlling whether a .comment section 	 should be emitted or not.  FIXME: Not implemented.  */
case|case
literal|'Q'
case|:
break|break;
comment|/* Solaris takes -s to specify that .stabs go in a .stabs section, 	 rather than .stabs.excl, which is ignored by the linker. 	 FIXME: Not implemented.  */
case|case
literal|'s'
case|:
if|if
condition|(
name|arg
condition|)
return|return
literal|0
return|;
break|break;
endif|#
directive|endif
default|default:
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
name|void
name|md_show_usage
parameter_list|(
name|stream
parameter_list|)
name|FILE
modifier|*
name|stream
decl_stmt|;
block|{
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"\ PowerPC options:\n\ -u			ignored\n\ -mpwrx, -mpwr2		generate code for IBM POWER/2 (RIOS2)\n\ -mpwr			generate code for IBM POWER (RIOS1)\n\ -m601			generate code for Motorola PowerPC 601\n\ -mppc, -mppc32, -m403, -m405, -m603, -m604\n\ 			generate code for Motorola PowerPC 603/604\n\ -mppc64, -m620		generate code for Motorola PowerPC 620\n\ -mppc64bridge		generate code for PowerPC 64, including bridge insns\n\ -mcom			generate code Power/PowerPC common instructions\n\ -many			generate code for any architecture (PWR/PWRX/PPC)\n\ -mregnames		Allow symbolic names for registers\n\ -mno-regnames		Do not allow symbolic names for registers\n"
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|OBJ_ELF
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"\ -mrelocatable		support for GCC's -mrelocatble option\n\ -mrelocatable-lib	support for GCC's -mrelocatble-lib option\n\ -memb			set PPC_EMB bit in ELF flags\n\ -mlittle, -mlittle-endian\n\ 			generate code for a little endian machine\n\ -mbig, -mbig-endian	generate code for a big endian machine\n\ -msolaris		generate code for Solaris\n\ -mno-solaris		do not generate code for Solaris\n\ -V			print assembler version number\n\ -Qy, -Qn		ignored\n"
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Set ppc_cpu if it is not already set.  */
end_comment

begin_function
specifier|static
name|void
name|ppc_set_cpu
parameter_list|()
block|{
specifier|const
name|char
modifier|*
name|default_os
init|=
name|TARGET_OS
decl_stmt|;
specifier|const
name|char
modifier|*
name|default_cpu
init|=
name|TARGET_CPU
decl_stmt|;
if|if
condition|(
name|ppc_cpu
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|default_os
argument_list|,
literal|"aix"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
operator|&&
name|default_os
index|[
literal|3
index|]
operator|>=
literal|'4'
operator|&&
name|default_os
index|[
literal|3
index|]
operator|<=
literal|'9'
condition|)
name|ppc_cpu
operator|=
name|PPC_OPCODE_COMMON
expr_stmt|;
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|default_os
argument_list|,
literal|"aix3"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
name|ppc_cpu
operator|=
name|PPC_OPCODE_POWER
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|default_cpu
argument_list|,
literal|"rs6000"
argument_list|)
operator|==
literal|0
condition|)
name|ppc_cpu
operator|=
name|PPC_OPCODE_POWER
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|default_cpu
argument_list|,
literal|"powerpc"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|default_cpu
argument_list|,
literal|"powerpcle"
argument_list|)
operator|==
literal|0
condition|)
name|ppc_cpu
operator|=
name|PPC_OPCODE_PPC
expr_stmt|;
else|else
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"Unknown default cpu = %s, os = %s"
argument_list|)
argument_list|,
name|default_cpu
argument_list|,
name|default_os
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Figure out the BFD architecture to use.  */
end_comment

begin_function
name|enum
name|bfd_architecture
name|ppc_arch
parameter_list|()
block|{
specifier|const
name|char
modifier|*
name|default_cpu
init|=
name|TARGET_CPU
decl_stmt|;
name|ppc_set_cpu
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|ppc_cpu
operator|&
name|PPC_OPCODE_PPC
operator|)
operator|!=
literal|0
condition|)
return|return
name|bfd_arch_powerpc
return|;
elseif|else
if|if
condition|(
operator|(
name|ppc_cpu
operator|&
name|PPC_OPCODE_POWER
operator|)
operator|!=
literal|0
condition|)
return|return
name|bfd_arch_rs6000
return|;
elseif|else
if|if
condition|(
operator|(
name|ppc_cpu
operator|&
operator|(
name|PPC_OPCODE_COMMON
operator||
name|PPC_OPCODE_ANY
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|default_cpu
argument_list|,
literal|"rs6000"
argument_list|)
operator|==
literal|0
condition|)
return|return
name|bfd_arch_rs6000
return|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|default_cpu
argument_list|,
literal|"powerpc"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|default_cpu
argument_list|,
literal|"powerpcle"
argument_list|)
operator|==
literal|0
condition|)
return|return
name|bfd_arch_powerpc
return|;
block|}
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"Neither Power nor PowerPC opcodes were selected."
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|bfd_arch_unknown
return|;
block|}
end_function

begin_function
name|unsigned
name|long
name|ppc_mach
parameter_list|()
block|{
return|return
operator|(
name|ppc_size
operator|==
name|PPC_OPCODE_64
operator|)
condition|?
literal|620
else|:
literal|0
return|;
block|}
end_function

begin_function
name|int
name|ppc_subseg_align
parameter_list|()
block|{
return|return
operator|(
name|ppc_xcoff64
operator|)
condition|?
literal|3
else|:
literal|2
return|;
block|}
end_function

begin_function
specifier|extern
name|char
modifier|*
name|ppc_target_format
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|OBJ_COFF
ifdef|#
directive|ifdef
name|TE_PE
return|return
operator|(
name|target_big_endian
condition|?
literal|"pe-powerpc"
else|:
literal|"pe-powerpcle"
operator|)
return|;
elif|#
directive|elif
name|TE_POWERMAC
else|#
directive|else
return|return
operator|(
name|ppc_xcoff64
condition|?
literal|"aixcoff64-rs6000"
else|:
literal|"aixcoff-rs6000"
operator|)
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TE_POWERMAC
return|return
literal|"xcoff-powermac"
return|;
endif|#
directive|endif
endif|#
directive|endif
ifdef|#
directive|ifdef
name|OBJ_ELF
return|return
operator|(
name|target_big_endian
condition|?
literal|"elf32-powerpc"
else|:
literal|"elf32-powerpcle"
operator|)
return|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* This function is called when the assembler starts up.  It is called    after the options have been parsed and the output file has been    opened.  */
end_comment

begin_function
name|void
name|md_begin
parameter_list|()
block|{
specifier|register
specifier|const
name|struct
name|powerpc_opcode
modifier|*
name|op
decl_stmt|;
specifier|const
name|struct
name|powerpc_opcode
modifier|*
name|op_end
decl_stmt|;
specifier|const
name|struct
name|powerpc_macro
modifier|*
name|macro
decl_stmt|;
specifier|const
name|struct
name|powerpc_macro
modifier|*
name|macro_end
decl_stmt|;
name|boolean
name|dup_insn
init|=
name|false
decl_stmt|;
name|ppc_set_cpu
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|OBJ_ELF
comment|/* Set the ELF flags if desired.  */
if|if
condition|(
name|ppc_flags
operator|&&
operator|!
name|msolaris
condition|)
name|bfd_set_private_flags
argument_list|(
name|stdoutput
argument_list|,
name|ppc_flags
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Insert the opcodes into a hash table.  */
name|ppc_hash
operator|=
name|hash_new
argument_list|()
expr_stmt|;
name|op_end
operator|=
name|powerpc_opcodes
operator|+
name|powerpc_num_opcodes
expr_stmt|;
for|for
control|(
name|op
operator|=
name|powerpc_opcodes
init|;
name|op
operator|<
name|op_end
condition|;
name|op
operator|++
control|)
block|{
name|know
argument_list|(
operator|(
name|op
operator|->
name|opcode
operator|&
name|op
operator|->
name|mask
operator|)
operator|==
name|op
operator|->
name|opcode
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|op
operator|->
name|flags
operator|&
name|ppc_cpu
operator|)
operator|!=
literal|0
operator|&&
operator|(
operator|(
name|op
operator|->
name|flags
operator|&
operator|(
name|PPC_OPCODE_32
operator||
name|PPC_OPCODE_64
operator|)
operator|)
operator|==
literal|0
operator|||
operator|(
name|op
operator|->
name|flags
operator|&
operator|(
name|PPC_OPCODE_32
operator||
name|PPC_OPCODE_64
operator|)
operator|)
operator|==
name|ppc_size
operator|||
operator|(
name|ppc_cpu
operator|&
name|PPC_OPCODE_64_BRIDGE
operator|)
operator|!=
literal|0
operator|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|retval
decl_stmt|;
name|retval
operator|=
name|hash_insert
argument_list|(
name|ppc_hash
argument_list|,
name|op
operator|->
name|name
argument_list|,
operator|(
name|PTR
operator|)
name|op
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
condition|)
block|{
comment|/* Ignore Power duplicates for -m601 */
if|if
condition|(
operator|(
name|ppc_cpu
operator|&
name|PPC_OPCODE_601
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|op
operator|->
name|flags
operator|&
name|PPC_OPCODE_POWER
operator|)
operator|!=
literal|0
condition|)
continue|continue;
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Internal assembler error for instruction %s"
argument_list|)
argument_list|,
name|op
operator|->
name|name
argument_list|)
expr_stmt|;
name|dup_insn
operator|=
name|true
expr_stmt|;
block|}
block|}
block|}
comment|/* Insert the macros into a hash table.  */
name|ppc_macro_hash
operator|=
name|hash_new
argument_list|()
expr_stmt|;
name|macro_end
operator|=
name|powerpc_macros
operator|+
name|powerpc_num_macros
expr_stmt|;
for|for
control|(
name|macro
operator|=
name|powerpc_macros
init|;
name|macro
operator|<
name|macro_end
condition|;
name|macro
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|macro
operator|->
name|flags
operator|&
name|ppc_cpu
operator|)
operator|!=
literal|0
condition|)
block|{
specifier|const
name|char
modifier|*
name|retval
decl_stmt|;
name|retval
operator|=
name|hash_insert
argument_list|(
name|ppc_macro_hash
argument_list|,
name|macro
operator|->
name|name
argument_list|,
operator|(
name|PTR
operator|)
name|macro
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Internal assembler error for macro %s"
argument_list|)
argument_list|,
name|macro
operator|->
name|name
argument_list|)
expr_stmt|;
name|dup_insn
operator|=
name|true
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|dup_insn
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Tell the main code what the endianness is if it is not overidden by the user.  */
if|if
condition|(
operator|!
name|set_target_endian
condition|)
block|{
name|set_target_endian
operator|=
literal|1
expr_stmt|;
name|target_big_endian
operator|=
name|PPC_BIG_ENDIAN
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|OBJ_XCOFF
name|ppc_coff_debug_section
operator|=
name|coff_section_from_bfd_index
argument_list|(
name|stdoutput
argument_list|,
name|N_DEBUG
argument_list|)
expr_stmt|;
comment|/* Create dummy symbols to serve as initial csects.  This forces the      text csects to precede the data csects.  These symbols will not      be output.  */
name|ppc_text_csects
operator|=
name|symbol_make
argument_list|(
literal|"dummy\001"
argument_list|)
expr_stmt|;
name|symbol_get_tc
argument_list|(
name|ppc_text_csects
argument_list|)
operator|->
name|within
operator|=
name|ppc_text_csects
expr_stmt|;
name|ppc_data_csects
operator|=
name|symbol_make
argument_list|(
literal|"dummy\001"
argument_list|)
expr_stmt|;
name|symbol_get_tc
argument_list|(
name|ppc_data_csects
argument_list|)
operator|->
name|within
operator|=
name|ppc_data_csects
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TE_PE
name|ppc_current_section
operator|=
name|text_section
expr_stmt|;
name|ppc_previous_section
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Insert an operand value into an instruction.  */
end_comment

begin_function
specifier|static
name|unsigned
name|long
name|ppc_insert_operand
parameter_list|(
name|insn
parameter_list|,
name|operand
parameter_list|,
name|val
parameter_list|,
name|file
parameter_list|,
name|line
parameter_list|)
name|unsigned
name|long
name|insn
decl_stmt|;
specifier|const
name|struct
name|powerpc_operand
modifier|*
name|operand
decl_stmt|;
name|offsetT
name|val
decl_stmt|;
name|char
modifier|*
name|file
decl_stmt|;
name|unsigned
name|int
name|line
decl_stmt|;
block|{
if|if
condition|(
name|operand
operator|->
name|bits
operator|!=
literal|32
condition|)
block|{
name|long
name|min
decl_stmt|,
name|max
decl_stmt|;
name|offsetT
name|test
decl_stmt|;
if|if
condition|(
operator|(
name|operand
operator|->
name|flags
operator|&
name|PPC_OPERAND_SIGNED
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|operand
operator|->
name|flags
operator|&
name|PPC_OPERAND_SIGNOPT
operator|)
operator|!=
literal|0
condition|)
name|max
operator|=
operator|(
literal|1
operator|<<
name|operand
operator|->
name|bits
operator|)
operator|-
literal|1
expr_stmt|;
else|else
name|max
operator|=
operator|(
literal|1
operator|<<
operator|(
name|operand
operator|->
name|bits
operator|-
literal|1
operator|)
operator|)
operator|-
literal|1
expr_stmt|;
name|min
operator|=
operator|-
operator|(
literal|1
operator|<<
operator|(
name|operand
operator|->
name|bits
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|ppc_size
operator|==
name|PPC_OPCODE_32
condition|)
block|{
comment|/* Some people write 32 bit hex constants with the sign 		 extension done by hand.  This shouldn't really be 		 valid, but, to permit this code to assemble on a 64 		 bit host, we sign extend the 32 bit value.  */
if|if
condition|(
name|val
operator|>
literal|0
operator|&&
operator|(
name|val
operator|&
operator|(
name|offsetT
operator|)
literal|0x80000000
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|val
operator|&
operator|(
name|offsetT
operator|)
literal|0xffffffff
operator|)
operator|==
name|val
condition|)
block|{
name|val
operator|-=
literal|0x80000000
expr_stmt|;
name|val
operator|-=
literal|0x80000000
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|max
operator|=
operator|(
literal|1
operator|<<
name|operand
operator|->
name|bits
operator|)
operator|-
literal|1
expr_stmt|;
name|min
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|operand
operator|->
name|flags
operator|&
name|PPC_OPERAND_NEGATIVE
operator|)
operator|!=
literal|0
condition|)
name|test
operator|=
operator|-
name|val
expr_stmt|;
else|else
name|test
operator|=
name|val
expr_stmt|;
if|if
condition|(
name|test
operator|<
operator|(
name|offsetT
operator|)
name|min
operator|||
name|test
operator|>
operator|(
name|offsetT
operator|)
name|max
condition|)
block|{
specifier|const
name|char
modifier|*
name|err
init|=
name|_
argument_list|(
literal|"operand out of range (%s not between %ld and %ld)"
argument_list|)
decl_stmt|;
name|char
name|buf
index|[
literal|100
index|]
decl_stmt|;
name|sprint_value
argument_list|(
name|buf
argument_list|,
name|test
argument_list|)
expr_stmt|;
if|if
condition|(
name|file
operator|==
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
name|as_bad
argument_list|(
name|err
argument_list|,
name|buf
argument_list|,
name|min
argument_list|,
name|max
argument_list|)
expr_stmt|;
else|else
name|as_bad_where
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
name|err
argument_list|,
name|buf
argument_list|,
name|min
argument_list|,
name|max
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|operand
operator|->
name|insert
condition|)
block|{
specifier|const
name|char
modifier|*
name|errmsg
decl_stmt|;
name|errmsg
operator|=
name|NULL
expr_stmt|;
name|insn
operator|=
call|(
modifier|*
name|operand
operator|->
name|insert
call|)
argument_list|(
name|insn
argument_list|,
operator|(
name|long
operator|)
name|val
argument_list|,
operator|&
name|errmsg
argument_list|)
expr_stmt|;
if|if
condition|(
name|errmsg
operator|!=
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
condition|)
name|as_bad
argument_list|(
name|errmsg
argument_list|)
expr_stmt|;
block|}
else|else
name|insn
operator||=
operator|(
operator|(
operator|(
name|long
operator|)
name|val
operator|&
operator|(
operator|(
literal|1
operator|<<
name|operand
operator|->
name|bits
operator|)
operator|-
literal|1
operator|)
operator|)
operator|<<
name|operand
operator|->
name|shift
operator|)
expr_stmt|;
return|return
name|insn
return|;
block|}
end_function

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|OBJ_ELF
end_ifdef

begin_comment
comment|/* Parse @got, etc. and return the desired relocation.  */
end_comment

begin_function
specifier|static
name|bfd_reloc_code_real_type
name|ppc_elf_suffix
parameter_list|(
name|str_p
parameter_list|,
name|exp_p
parameter_list|)
name|char
modifier|*
modifier|*
name|str_p
decl_stmt|;
name|expressionS
modifier|*
name|exp_p
decl_stmt|;
block|{
struct|struct
name|map_bfd
block|{
name|char
modifier|*
name|string
decl_stmt|;
name|int
name|length
decl_stmt|;
name|bfd_reloc_code_real_type
name|reloc
decl_stmt|;
block|}
struct|;
name|char
name|ident
index|[
literal|20
index|]
decl_stmt|;
name|char
modifier|*
name|str
init|=
operator|*
name|str_p
decl_stmt|;
name|char
modifier|*
name|str2
decl_stmt|;
name|int
name|ch
decl_stmt|;
name|int
name|len
decl_stmt|;
name|struct
name|map_bfd
modifier|*
name|ptr
decl_stmt|;
define|#
directive|define
name|MAP
parameter_list|(
name|str
parameter_list|,
name|reloc
parameter_list|)
value|{ str, sizeof (str)-1, reloc }
specifier|static
name|struct
name|map_bfd
name|mapping
index|[]
init|=
block|{
name|MAP
argument_list|(
literal|"l"
argument_list|,
name|BFD_RELOC_LO16
argument_list|)
block|,
name|MAP
argument_list|(
literal|"h"
argument_list|,
name|BFD_RELOC_HI16
argument_list|)
block|,
name|MAP
argument_list|(
literal|"ha"
argument_list|,
name|BFD_RELOC_HI16_S
argument_list|)
block|,
name|MAP
argument_list|(
literal|"brtaken"
argument_list|,
name|BFD_RELOC_PPC_B16_BRTAKEN
argument_list|)
block|,
name|MAP
argument_list|(
literal|"brntaken"
argument_list|,
name|BFD_RELOC_PPC_B16_BRNTAKEN
argument_list|)
block|,
name|MAP
argument_list|(
literal|"got"
argument_list|,
name|BFD_RELOC_16_GOTOFF
argument_list|)
block|,
name|MAP
argument_list|(
literal|"got@l"
argument_list|,
name|BFD_RELOC_LO16_GOTOFF
argument_list|)
block|,
name|MAP
argument_list|(
literal|"got@h"
argument_list|,
name|BFD_RELOC_HI16_GOTOFF
argument_list|)
block|,
name|MAP
argument_list|(
literal|"got@ha"
argument_list|,
name|BFD_RELOC_HI16_S_GOTOFF
argument_list|)
block|,
name|MAP
argument_list|(
literal|"fixup"
argument_list|,
name|BFD_RELOC_CTOR
argument_list|)
block|,
comment|/* warnings with -mrelocatable */
name|MAP
argument_list|(
literal|"plt"
argument_list|,
name|BFD_RELOC_24_PLT_PCREL
argument_list|)
block|,
name|MAP
argument_list|(
literal|"pltrel24"
argument_list|,
name|BFD_RELOC_24_PLT_PCREL
argument_list|)
block|,
name|MAP
argument_list|(
literal|"copy"
argument_list|,
name|BFD_RELOC_PPC_COPY
argument_list|)
block|,
name|MAP
argument_list|(
literal|"globdat"
argument_list|,
name|BFD_RELOC_PPC_GLOB_DAT
argument_list|)
block|,
name|MAP
argument_list|(
literal|"local24pc"
argument_list|,
name|BFD_RELOC_PPC_LOCAL24PC
argument_list|)
block|,
name|MAP
argument_list|(
literal|"local"
argument_list|,
name|BFD_RELOC_PPC_LOCAL24PC
argument_list|)
block|,
name|MAP
argument_list|(
literal|"pltrel"
argument_list|,
name|BFD_RELOC_32_PLT_PCREL
argument_list|)
block|,
name|MAP
argument_list|(
literal|"plt@l"
argument_list|,
name|BFD_RELOC_LO16_PLTOFF
argument_list|)
block|,
name|MAP
argument_list|(
literal|"plt@h"
argument_list|,
name|BFD_RELOC_HI16_PLTOFF
argument_list|)
block|,
name|MAP
argument_list|(
literal|"plt@ha"
argument_list|,
name|BFD_RELOC_HI16_S_PLTOFF
argument_list|)
block|,
name|MAP
argument_list|(
literal|"sdarel"
argument_list|,
name|BFD_RELOC_GPREL16
argument_list|)
block|,
name|MAP
argument_list|(
literal|"sectoff"
argument_list|,
name|BFD_RELOC_32_BASEREL
argument_list|)
block|,
name|MAP
argument_list|(
literal|"sectoff@l"
argument_list|,
name|BFD_RELOC_LO16_BASEREL
argument_list|)
block|,
name|MAP
argument_list|(
literal|"sectoff@h"
argument_list|,
name|BFD_RELOC_HI16_BASEREL
argument_list|)
block|,
name|MAP
argument_list|(
literal|"sectoff@ha"
argument_list|,
name|BFD_RELOC_HI16_S_BASEREL
argument_list|)
block|,
name|MAP
argument_list|(
literal|"naddr"
argument_list|,
name|BFD_RELOC_PPC_EMB_NADDR32
argument_list|)
block|,
name|MAP
argument_list|(
literal|"naddr16"
argument_list|,
name|BFD_RELOC_PPC_EMB_NADDR16
argument_list|)
block|,
name|MAP
argument_list|(
literal|"naddr@l"
argument_list|,
name|BFD_RELOC_PPC_EMB_NADDR16_LO
argument_list|)
block|,
name|MAP
argument_list|(
literal|"naddr@h"
argument_list|,
name|BFD_RELOC_PPC_EMB_NADDR16_HI
argument_list|)
block|,
name|MAP
argument_list|(
literal|"naddr@ha"
argument_list|,
name|BFD_RELOC_PPC_EMB_NADDR16_HA
argument_list|)
block|,
name|MAP
argument_list|(
literal|"sdai16"
argument_list|,
name|BFD_RELOC_PPC_EMB_SDAI16
argument_list|)
block|,
name|MAP
argument_list|(
literal|"sda2rel"
argument_list|,
name|BFD_RELOC_PPC_EMB_SDA2REL
argument_list|)
block|,
name|MAP
argument_list|(
literal|"sda2i16"
argument_list|,
name|BFD_RELOC_PPC_EMB_SDA2I16
argument_list|)
block|,
name|MAP
argument_list|(
literal|"sda21"
argument_list|,
name|BFD_RELOC_PPC_EMB_SDA21
argument_list|)
block|,
name|MAP
argument_list|(
literal|"mrkref"
argument_list|,
name|BFD_RELOC_PPC_EMB_MRKREF
argument_list|)
block|,
name|MAP
argument_list|(
literal|"relsect"
argument_list|,
name|BFD_RELOC_PPC_EMB_RELSEC16
argument_list|)
block|,
name|MAP
argument_list|(
literal|"relsect@l"
argument_list|,
name|BFD_RELOC_PPC_EMB_RELST_LO
argument_list|)
block|,
name|MAP
argument_list|(
literal|"relsect@h"
argument_list|,
name|BFD_RELOC_PPC_EMB_RELST_HI
argument_list|)
block|,
name|MAP
argument_list|(
literal|"relsect@ha"
argument_list|,
name|BFD_RELOC_PPC_EMB_RELST_HA
argument_list|)
block|,
name|MAP
argument_list|(
literal|"bitfld"
argument_list|,
name|BFD_RELOC_PPC_EMB_BIT_FLD
argument_list|)
block|,
name|MAP
argument_list|(
literal|"relsda"
argument_list|,
name|BFD_RELOC_PPC_EMB_RELSDA
argument_list|)
block|,
name|MAP
argument_list|(
literal|"xgot"
argument_list|,
name|BFD_RELOC_PPC_TOC16
argument_list|)
block|,
block|{
operator|(
name|char
operator|*
operator|)
literal|0
block|,
literal|0
block|,
name|BFD_RELOC_UNUSED
block|}
block|}
decl_stmt|;
if|if
condition|(
operator|*
name|str
operator|++
operator|!=
literal|'@'
condition|)
return|return
name|BFD_RELOC_UNUSED
return|;
for|for
control|(
name|ch
operator|=
operator|*
name|str
operator|,
name|str2
operator|=
name|ident
init|;
operator|(
name|str2
operator|<
name|ident
operator|+
sizeof|sizeof
argument_list|(
name|ident
argument_list|)
operator|-
literal|1
operator|&&
operator|(
name|isalnum
argument_list|(
name|ch
argument_list|)
operator|||
name|ch
operator|==
literal|'@'
operator|)
operator|)
condition|;
name|ch
operator|=
operator|*
operator|++
name|str
control|)
block|{
operator|*
name|str2
operator|++
operator|=
operator|(
name|islower
argument_list|(
name|ch
argument_list|)
operator|)
condition|?
name|ch
else|:
name|tolower
argument_list|(
name|ch
argument_list|)
expr_stmt|;
block|}
operator|*
name|str2
operator|=
literal|'\0'
expr_stmt|;
name|len
operator|=
name|str2
operator|-
name|ident
expr_stmt|;
name|ch
operator|=
name|ident
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|ptr
operator|=
operator|&
name|mapping
index|[
literal|0
index|]
init|;
name|ptr
operator|->
name|length
operator|>
literal|0
condition|;
name|ptr
operator|++
control|)
if|if
condition|(
name|ch
operator|==
name|ptr
operator|->
name|string
index|[
literal|0
index|]
operator|&&
name|len
operator|==
name|ptr
operator|->
name|length
operator|&&
name|memcmp
argument_list|(
name|ident
argument_list|,
name|ptr
operator|->
name|string
argument_list|,
name|ptr
operator|->
name|length
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|exp_p
operator|->
name|X_add_number
operator|!=
literal|0
operator|&&
operator|(
name|ptr
operator|->
name|reloc
operator|==
name|BFD_RELOC_16_GOTOFF
operator|||
name|ptr
operator|->
name|reloc
operator|==
name|BFD_RELOC_LO16_GOTOFF
operator|||
name|ptr
operator|->
name|reloc
operator|==
name|BFD_RELOC_HI16_GOTOFF
operator|||
name|ptr
operator|->
name|reloc
operator|==
name|BFD_RELOC_HI16_S_GOTOFF
operator|)
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"identifier+constant@got means identifier@got+constant"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Now check for identifier@suffix+constant */
if|if
condition|(
operator|*
name|str
operator|==
literal|'-'
operator|||
operator|*
name|str
operator|==
literal|'+'
condition|)
block|{
name|char
modifier|*
name|orig_line
init|=
name|input_line_pointer
decl_stmt|;
name|expressionS
name|new_exp
decl_stmt|;
name|input_line_pointer
operator|=
name|str
expr_stmt|;
name|expression
argument_list|(
operator|&
name|new_exp
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_exp
operator|.
name|X_op
operator|==
name|O_constant
condition|)
block|{
name|exp_p
operator|->
name|X_add_number
operator|+=
name|new_exp
operator|.
name|X_add_number
expr_stmt|;
name|str
operator|=
name|input_line_pointer
expr_stmt|;
block|}
if|if
condition|(
operator|&
name|input_line_pointer
operator|!=
name|str_p
condition|)
name|input_line_pointer
operator|=
name|orig_line
expr_stmt|;
block|}
operator|*
name|str_p
operator|=
name|str
expr_stmt|;
return|return
name|ptr
operator|->
name|reloc
return|;
block|}
return|return
name|BFD_RELOC_UNUSED
return|;
block|}
end_function

begin_comment
comment|/* Like normal .long/.short/.word, except support @got, etc.  */
end_comment

begin_comment
comment|/* clobbers input_line_pointer, checks */
end_comment

begin_comment
comment|/* end-of-line.  */
end_comment

begin_function
specifier|static
name|void
name|ppc_elf_cons
parameter_list|(
name|nbytes
parameter_list|)
specifier|register
name|int
name|nbytes
decl_stmt|;
comment|/* 1=.byte, 2=.word, 4=.long */
block|{
name|expressionS
name|exp
decl_stmt|;
name|bfd_reloc_code_real_type
name|reloc
decl_stmt|;
if|if
condition|(
name|is_it_end_of_statement
argument_list|()
condition|)
block|{
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
do|do
block|{
name|expression
argument_list|(
operator|&
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
name|exp
operator|.
name|X_op
operator|==
name|O_symbol
operator|&&
operator|*
name|input_line_pointer
operator|==
literal|'@'
operator|&&
operator|(
name|reloc
operator|=
name|ppc_elf_suffix
argument_list|(
operator|&
name|input_line_pointer
argument_list|,
operator|&
name|exp
argument_list|)
operator|)
operator|!=
name|BFD_RELOC_UNUSED
condition|)
block|{
name|reloc_howto_type
modifier|*
name|reloc_howto
init|=
name|bfd_reloc_type_lookup
argument_list|(
name|stdoutput
argument_list|,
name|reloc
argument_list|)
decl_stmt|;
name|int
name|size
init|=
name|bfd_get_reloc_size
argument_list|(
name|reloc_howto
argument_list|)
decl_stmt|;
if|if
condition|(
name|size
operator|>
name|nbytes
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"%s relocations do not fit in %d bytes\n"
argument_list|)
argument_list|,
name|reloc_howto
operator|->
name|name
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
else|else
block|{
specifier|register
name|char
modifier|*
name|p
init|=
name|frag_more
argument_list|(
operator|(
name|int
operator|)
name|nbytes
argument_list|)
decl_stmt|;
name|int
name|offset
init|=
name|nbytes
operator|-
name|size
decl_stmt|;
name|fix_new_exp
argument_list|(
name|frag_now
argument_list|,
name|p
operator|-
name|frag_now
operator|->
name|fr_literal
operator|+
name|offset
argument_list|,
name|size
argument_list|,
operator|&
name|exp
argument_list|,
literal|0
argument_list|,
name|reloc
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|emit_expr
argument_list|(
operator|&
name|exp
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|nbytes
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|*
name|input_line_pointer
operator|++
operator|==
literal|','
condition|)
do|;
name|input_line_pointer
operator|--
expr_stmt|;
comment|/* Put terminator back into stream.  */
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Solaris pseduo op to change to the .rodata section.  */
end_comment

begin_function
specifier|static
name|void
name|ppc_elf_rdata
parameter_list|(
name|xxx
parameter_list|)
name|int
name|xxx
decl_stmt|;
block|{
name|char
modifier|*
name|save_line
init|=
name|input_line_pointer
decl_stmt|;
specifier|static
name|char
name|section
index|[]
init|=
literal|".rodata\n"
decl_stmt|;
comment|/* Just pretend this is .section .rodata */
name|input_line_pointer
operator|=
name|section
expr_stmt|;
name|obj_elf_section
argument_list|(
name|xxx
argument_list|)
expr_stmt|;
name|input_line_pointer
operator|=
name|save_line
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Pseudo op to make file scope bss items */
end_comment

begin_function
specifier|static
name|void
name|ppc_elf_lcomm
parameter_list|(
name|xxx
parameter_list|)
name|int
name|xxx
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|name
decl_stmt|;
specifier|register
name|char
name|c
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|offsetT
name|size
decl_stmt|;
specifier|register
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
name|offsetT
name|align
decl_stmt|;
name|segT
name|old_sec
decl_stmt|;
name|int
name|old_subsec
decl_stmt|;
name|char
modifier|*
name|pfrag
decl_stmt|;
name|int
name|align2
decl_stmt|;
name|name
operator|=
name|input_line_pointer
expr_stmt|;
name|c
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
comment|/* just after name is now '\0' */
name|p
operator|=
name|input_line_pointer
expr_stmt|;
operator|*
name|p
operator|=
name|c
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|!=
literal|','
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Expected comma after symbol-name: rest of line ignored."
argument_list|)
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
name|input_line_pointer
operator|++
expr_stmt|;
comment|/* skip ',' */
if|if
condition|(
operator|(
name|size
operator|=
name|get_absolute_expression
argument_list|()
operator|)
operator|<
literal|0
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|".COMMon length (%ld.)<0! Ignored."
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|size
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
comment|/* The third argument to .lcomm is the alignment.  */
if|if
condition|(
operator|*
name|input_line_pointer
operator|!=
literal|','
condition|)
name|align
operator|=
literal|8
expr_stmt|;
else|else
block|{
operator|++
name|input_line_pointer
expr_stmt|;
name|align
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
if|if
condition|(
name|align
operator|<=
literal|0
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"ignoring bad alignment"
argument_list|)
argument_list|)
expr_stmt|;
name|align
operator|=
literal|8
expr_stmt|;
block|}
block|}
operator|*
name|p
operator|=
literal|0
expr_stmt|;
name|symbolP
operator|=
name|symbol_find_or_make
argument_list|(
name|name
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|S_IS_DEFINED
argument_list|(
name|symbolP
argument_list|)
operator|&&
operator|!
name|S_IS_COMMON
argument_list|(
name|symbolP
argument_list|)
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Ignoring attempt to re-define symbol `%s'."
argument_list|)
argument_list|,
name|S_GET_NAME
argument_list|(
name|symbolP
argument_list|)
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|S_GET_VALUE
argument_list|(
name|symbolP
argument_list|)
operator|&&
name|S_GET_VALUE
argument_list|(
name|symbolP
argument_list|)
operator|!=
operator|(
name|valueT
operator|)
name|size
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Length of .lcomm \"%s\" is already %ld. Not changed to %ld."
argument_list|)
argument_list|,
name|S_GET_NAME
argument_list|(
name|symbolP
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|S_GET_VALUE
argument_list|(
name|symbolP
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|size
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
comment|/* allocate_bss: */
name|old_sec
operator|=
name|now_seg
expr_stmt|;
name|old_subsec
operator|=
name|now_subseg
expr_stmt|;
if|if
condition|(
name|align
condition|)
block|{
comment|/* convert to a power of 2 alignment */
for|for
control|(
name|align2
operator|=
literal|0
init|;
operator|(
name|align
operator|&
literal|1
operator|)
operator|==
literal|0
condition|;
name|align
operator|>>=
literal|1
operator|,
operator|++
name|align2
control|)
empty_stmt|;
if|if
condition|(
name|align
operator|!=
literal|1
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Common alignment not a power of 2"
argument_list|)
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
block|}
else|else
name|align2
operator|=
literal|0
expr_stmt|;
name|record_alignment
argument_list|(
name|bss_section
argument_list|,
name|align2
argument_list|)
expr_stmt|;
name|subseg_set
argument_list|(
name|bss_section
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|align2
condition|)
name|frag_align
argument_list|(
name|align2
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|S_GET_SEGMENT
argument_list|(
name|symbolP
argument_list|)
operator|==
name|bss_section
condition|)
name|symbol_get_frag
argument_list|(
name|symbolP
argument_list|)
operator|->
name|fr_symbol
operator|=
literal|0
expr_stmt|;
name|symbol_set_frag
argument_list|(
name|symbolP
argument_list|,
name|frag_now
argument_list|)
expr_stmt|;
name|pfrag
operator|=
name|frag_var
argument_list|(
name|rs_org
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
operator|(
name|relax_substateT
operator|)
literal|0
argument_list|,
name|symbolP
argument_list|,
name|size
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
operator|*
name|pfrag
operator|=
literal|0
expr_stmt|;
name|S_SET_SIZE
argument_list|(
name|symbolP
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|S_SET_SEGMENT
argument_list|(
name|symbolP
argument_list|,
name|bss_section
argument_list|)
expr_stmt|;
name|subseg_set
argument_list|(
name|old_sec
argument_list|,
name|old_subsec
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Validate any relocations emitted for -mrelocatable, possibly adding    fixups for word relocations in writable segments, so we can adjust    them at runtime.  */
end_comment

begin_function
specifier|static
name|void
name|ppc_elf_validate_fix
parameter_list|(
name|fixp
parameter_list|,
name|seg
parameter_list|)
name|fixS
modifier|*
name|fixp
decl_stmt|;
name|segT
name|seg
decl_stmt|;
block|{
if|if
condition|(
name|fixp
operator|->
name|fx_done
operator|||
name|fixp
operator|->
name|fx_pcrel
condition|)
return|return;
switch|switch
condition|(
name|shlib
condition|)
block|{
case|case
name|SHLIB_NONE
case|:
case|case
name|SHLIB_PIC
case|:
return|return;
case|case
name|SHLIB_MRELOCATABLE
case|:
if|if
condition|(
name|fixp
operator|->
name|fx_r_type
operator|<=
name|BFD_RELOC_UNUSED
operator|&&
name|fixp
operator|->
name|fx_r_type
operator|!=
name|BFD_RELOC_16_GOTOFF
operator|&&
name|fixp
operator|->
name|fx_r_type
operator|!=
name|BFD_RELOC_HI16_GOTOFF
operator|&&
name|fixp
operator|->
name|fx_r_type
operator|!=
name|BFD_RELOC_LO16_GOTOFF
operator|&&
name|fixp
operator|->
name|fx_r_type
operator|!=
name|BFD_RELOC_HI16_S_GOTOFF
operator|&&
name|fixp
operator|->
name|fx_r_type
operator|!=
name|BFD_RELOC_32_BASEREL
operator|&&
name|fixp
operator|->
name|fx_r_type
operator|!=
name|BFD_RELOC_LO16_BASEREL
operator|&&
name|fixp
operator|->
name|fx_r_type
operator|!=
name|BFD_RELOC_HI16_BASEREL
operator|&&
name|fixp
operator|->
name|fx_r_type
operator|!=
name|BFD_RELOC_HI16_S_BASEREL
operator|&&
name|strcmp
argument_list|(
name|segment_name
argument_list|(
name|seg
argument_list|)
argument_list|,
literal|".got2"
argument_list|)
operator|!=
literal|0
operator|&&
name|strcmp
argument_list|(
name|segment_name
argument_list|(
name|seg
argument_list|)
argument_list|,
literal|".dtors"
argument_list|)
operator|!=
literal|0
operator|&&
name|strcmp
argument_list|(
name|segment_name
argument_list|(
name|seg
argument_list|)
argument_list|,
literal|".ctors"
argument_list|)
operator|!=
literal|0
operator|&&
name|strcmp
argument_list|(
name|segment_name
argument_list|(
name|seg
argument_list|)
argument_list|,
literal|".fixup"
argument_list|)
operator|!=
literal|0
operator|&&
name|strcmp
argument_list|(
name|segment_name
argument_list|(
name|seg
argument_list|)
argument_list|,
literal|".stab"
argument_list|)
operator|!=
literal|0
operator|&&
name|strcmp
argument_list|(
name|segment_name
argument_list|(
name|seg
argument_list|)
argument_list|,
literal|".gcc_except_table"
argument_list|)
operator|!=
literal|0
operator|&&
name|strcmp
argument_list|(
name|segment_name
argument_list|(
name|seg
argument_list|)
argument_list|,
literal|".eh_frame"
argument_list|)
operator|!=
literal|0
operator|&&
name|strcmp
argument_list|(
name|segment_name
argument_list|(
name|seg
argument_list|)
argument_list|,
literal|".ex_shared"
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|seg
operator|->
name|flags
operator|&
operator|(
name|SEC_READONLY
operator||
name|SEC_CODE
operator|)
operator|)
operator|!=
literal|0
operator|||
name|fixp
operator|->
name|fx_r_type
operator|!=
name|BFD_RELOC_CTOR
condition|)
block|{
name|as_bad_where
argument_list|(
name|fixp
operator|->
name|fx_file
argument_list|,
name|fixp
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"Relocation cannot be done when using -mrelocatable"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* OBJ_ELF */
end_comment

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|TE_PE
end_ifdef

begin_comment
comment|/*  * Summary of parse_toc_entry().  *  * in:	Input_line_pointer points to the '[' in one of:  *  *        [toc] [tocv] [toc32] [toc64]  *  *      Anything else is an error of one kind or another.  *  * out:  *   return value: success or failure  *   toc_kind:     kind of toc reference  *   input_line_pointer:  *     success: first char after the ']'  *     failure: unchanged  *  * settings:  *  *     [toc]   - rv == success, toc_kind = default_toc  *     [tocv]  - rv == success, toc_kind = data_in_toc  *     [toc32] - rv == success, toc_kind = must_be_32  *     [toc64] - rv == success, toc_kind = must_be_64  *  */
end_comment

begin_enum
enum|enum
name|toc_size_qualifier
block|{
name|default_toc
block|,
comment|/* The toc cell constructed should be the system default size */
name|data_in_toc
block|,
comment|/* This is a direct reference to a toc cell                   */
name|must_be_32
block|,
comment|/* The toc cell constructed must be 32 bits wide              */
name|must_be_64
comment|/* The toc cell constructed must be 64 bits wide              */
block|}
enum|;
end_enum

begin_function
specifier|static
name|int
name|parse_toc_entry
parameter_list|(
name|toc_kind
parameter_list|)
name|enum
name|toc_size_qualifier
modifier|*
name|toc_kind
decl_stmt|;
block|{
name|char
modifier|*
name|start
decl_stmt|;
name|char
modifier|*
name|toc_spec
decl_stmt|;
name|char
name|c
decl_stmt|;
name|enum
name|toc_size_qualifier
name|t
decl_stmt|;
comment|/* save the input_line_pointer */
name|start
operator|=
name|input_line_pointer
expr_stmt|;
comment|/* skip over the '[' , and whitespace */
operator|++
name|input_line_pointer
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
comment|/* find the spelling of the operand */
name|toc_spec
operator|=
name|input_line_pointer
expr_stmt|;
name|c
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|toc_spec
argument_list|,
literal|"toc"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|t
operator|=
name|default_toc
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|toc_spec
argument_list|,
literal|"tocv"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|t
operator|=
name|data_in_toc
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|toc_spec
argument_list|,
literal|"toc32"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|t
operator|=
name|must_be_32
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|toc_spec
argument_list|,
literal|"toc64"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|t
operator|=
name|must_be_64
expr_stmt|;
block|}
else|else
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"syntax error: invalid toc specifier `%s'"
argument_list|)
argument_list|,
name|toc_spec
argument_list|)
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
comment|/* put back the delimiting char */
name|input_line_pointer
operator|=
name|start
expr_stmt|;
comment|/* reset input_line pointer */
return|return
literal|0
return|;
block|}
comment|/* now find the ']' */
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
comment|/* put back the delimiting char */
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
comment|/* leading whitespace could be there.  */
name|c
operator|=
operator|*
name|input_line_pointer
operator|++
expr_stmt|;
comment|/* input_line_pointer->past char in c.  */
if|if
condition|(
name|c
operator|!=
literal|']'
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"syntax error: expected `]', found  `%c'"
argument_list|)
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|input_line_pointer
operator|=
name|start
expr_stmt|;
comment|/* reset input_line pointer */
return|return
literal|0
return|;
block|}
operator|*
name|toc_kind
operator|=
name|t
expr_stmt|;
comment|/* set return value */
return|return
literal|1
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* We need to keep a list of fixups.  We can't simply generate them as    we go, because that would require us to first create the frag, and    that would screw up references to ``.''.  */
end_comment

begin_struct
struct|struct
name|ppc_fixup
block|{
name|expressionS
name|exp
decl_stmt|;
name|int
name|opindex
decl_stmt|;
name|bfd_reloc_code_real_type
name|reloc
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|MAX_INSN_FIXUPS
value|(5)
end_define

begin_comment
comment|/* This routine is called for each instruction to be assembled.  */
end_comment

begin_function
name|void
name|md_assemble
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|char
modifier|*
name|s
decl_stmt|;
specifier|const
name|struct
name|powerpc_opcode
modifier|*
name|opcode
decl_stmt|;
name|unsigned
name|long
name|insn
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|opindex_ptr
decl_stmt|;
name|int
name|skip_optional
decl_stmt|;
name|int
name|need_paren
decl_stmt|;
name|int
name|next_opindex
decl_stmt|;
name|struct
name|ppc_fixup
name|fixups
index|[
name|MAX_INSN_FIXUPS
index|]
decl_stmt|;
name|int
name|fc
decl_stmt|;
name|char
modifier|*
name|f
decl_stmt|;
name|int
name|i
decl_stmt|;
ifdef|#
directive|ifdef
name|OBJ_ELF
name|bfd_reloc_code_real_type
name|reloc
decl_stmt|;
endif|#
directive|endif
comment|/* Get the opcode.  */
for|for
control|(
name|s
operator|=
name|str
init|;
operator|*
name|s
operator|!=
literal|'\0'
operator|&&
operator|!
name|isspace
argument_list|(
operator|*
name|s
argument_list|)
condition|;
name|s
operator|++
control|)
empty_stmt|;
if|if
condition|(
operator|*
name|s
operator|!=
literal|'\0'
condition|)
operator|*
name|s
operator|++
operator|=
literal|'\0'
expr_stmt|;
comment|/* Look up the opcode in the hash table.  */
name|opcode
operator|=
operator|(
specifier|const
expr|struct
name|powerpc_opcode
operator|*
operator|)
name|hash_find
argument_list|(
name|ppc_hash
argument_list|,
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|opcode
operator|==
operator|(
specifier|const
expr|struct
name|powerpc_opcode
operator|*
operator|)
name|NULL
condition|)
block|{
specifier|const
name|struct
name|powerpc_macro
modifier|*
name|macro
decl_stmt|;
name|macro
operator|=
operator|(
specifier|const
expr|struct
name|powerpc_macro
operator|*
operator|)
name|hash_find
argument_list|(
name|ppc_macro_hash
argument_list|,
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|macro
operator|==
operator|(
specifier|const
expr|struct
name|powerpc_macro
operator|*
operator|)
name|NULL
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Unrecognized opcode: `%s'"
argument_list|)
argument_list|,
name|str
argument_list|)
expr_stmt|;
else|else
name|ppc_macro
argument_list|(
name|s
argument_list|,
name|macro
argument_list|)
expr_stmt|;
return|return;
block|}
name|insn
operator|=
name|opcode
operator|->
name|opcode
expr_stmt|;
name|str
operator|=
name|s
expr_stmt|;
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|str
argument_list|)
condition|)
operator|++
name|str
expr_stmt|;
comment|/* PowerPC operands are just expressions.  The only real issue is      that a few operand types are optional.  All cases which might use      an optional operand separate the operands only with commas (in      some cases parentheses are used, as in ``lwz 1,0(1)'' but such      cases never have optional operands).  There is never more than      one optional operand for an instruction.  So, before we start      seriously parsing the operands, we check to see if we have an      optional operand, and, if we do, we count the number of commas to      see whether the operand should be omitted.  */
name|skip_optional
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|opindex_ptr
operator|=
name|opcode
operator|->
name|operands
init|;
operator|*
name|opindex_ptr
operator|!=
literal|0
condition|;
name|opindex_ptr
operator|++
control|)
block|{
specifier|const
name|struct
name|powerpc_operand
modifier|*
name|operand
decl_stmt|;
name|operand
operator|=
operator|&
name|powerpc_operands
index|[
operator|*
name|opindex_ptr
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|operand
operator|->
name|flags
operator|&
name|PPC_OPERAND_OPTIONAL
operator|)
operator|!=
literal|0
condition|)
block|{
name|unsigned
name|int
name|opcount
decl_stmt|;
comment|/* There is an optional operand.  Count the number of 	     commas in the input line.  */
if|if
condition|(
operator|*
name|str
operator|==
literal|'\0'
condition|)
name|opcount
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|opcount
operator|=
literal|1
expr_stmt|;
name|s
operator|=
name|str
expr_stmt|;
while|while
condition|(
operator|(
name|s
operator|=
name|strchr
argument_list|(
name|s
argument_list|,
literal|','
argument_list|)
operator|)
operator|!=
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
block|{
operator|++
name|opcount
expr_stmt|;
operator|++
name|s
expr_stmt|;
block|}
block|}
comment|/* If there are fewer operands in the line then are called 	     for by the instruction, we want to skip the optional 	     operand.  */
if|if
condition|(
name|opcount
operator|<
name|strlen
argument_list|(
name|opcode
operator|->
name|operands
argument_list|)
condition|)
name|skip_optional
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
comment|/* Gather the operands.  */
name|need_paren
operator|=
literal|0
expr_stmt|;
name|next_opindex
operator|=
literal|0
expr_stmt|;
name|fc
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|opindex_ptr
operator|=
name|opcode
operator|->
name|operands
init|;
operator|*
name|opindex_ptr
operator|!=
literal|0
condition|;
name|opindex_ptr
operator|++
control|)
block|{
specifier|const
name|struct
name|powerpc_operand
modifier|*
name|operand
decl_stmt|;
specifier|const
name|char
modifier|*
name|errmsg
decl_stmt|;
name|char
modifier|*
name|hold
decl_stmt|;
name|expressionS
name|ex
decl_stmt|;
name|char
name|endc
decl_stmt|;
if|if
condition|(
name|next_opindex
operator|==
literal|0
condition|)
name|operand
operator|=
operator|&
name|powerpc_operands
index|[
operator|*
name|opindex_ptr
index|]
expr_stmt|;
else|else
block|{
name|operand
operator|=
operator|&
name|powerpc_operands
index|[
name|next_opindex
index|]
expr_stmt|;
name|next_opindex
operator|=
literal|0
expr_stmt|;
block|}
name|errmsg
operator|=
name|NULL
expr_stmt|;
comment|/* If this is a fake operand, then we do not expect anything 	 from the input.  */
if|if
condition|(
operator|(
name|operand
operator|->
name|flags
operator|&
name|PPC_OPERAND_FAKE
operator|)
operator|!=
literal|0
condition|)
block|{
name|insn
operator|=
call|(
modifier|*
name|operand
operator|->
name|insert
call|)
argument_list|(
name|insn
argument_list|,
literal|0L
argument_list|,
operator|&
name|errmsg
argument_list|)
expr_stmt|;
if|if
condition|(
name|errmsg
operator|!=
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
condition|)
name|as_bad
argument_list|(
name|errmsg
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* If this is an optional operand, and we are skipping it, just 	 insert a zero.  */
if|if
condition|(
operator|(
name|operand
operator|->
name|flags
operator|&
name|PPC_OPERAND_OPTIONAL
operator|)
operator|!=
literal|0
operator|&&
name|skip_optional
condition|)
block|{
if|if
condition|(
name|operand
operator|->
name|insert
condition|)
block|{
name|insn
operator|=
call|(
modifier|*
name|operand
operator|->
name|insert
call|)
argument_list|(
name|insn
argument_list|,
literal|0L
argument_list|,
operator|&
name|errmsg
argument_list|)
expr_stmt|;
if|if
condition|(
name|errmsg
operator|!=
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
condition|)
name|as_bad
argument_list|(
name|errmsg
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|operand
operator|->
name|flags
operator|&
name|PPC_OPERAND_NEXT
operator|)
operator|!=
literal|0
condition|)
name|next_opindex
operator|=
operator|*
name|opindex_ptr
operator|+
literal|1
expr_stmt|;
continue|continue;
block|}
comment|/* Gather the operand.  */
name|hold
operator|=
name|input_line_pointer
expr_stmt|;
name|input_line_pointer
operator|=
name|str
expr_stmt|;
ifdef|#
directive|ifdef
name|TE_PE
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|'['
condition|)
block|{
comment|/* We are expecting something like the second argument here:  	        lwz r4,[toc].GS.0.static_int(rtoc)                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 	     The argument following the `]' must be a symbol name, and the              register must be the toc register: 'rtoc' or '2'  	     The effect is to 0 as the displacement field 	     in the instruction, and issue an IMAGE_REL_PPC_TOCREL16 (or 	     the appropriate variation) reloc against it based on the symbol. 	     The linker will build the toc, and insert the resolved toc offset.  	     Note: 	     o The size of the toc entry is currently assumed to be 	       32 bits. This should not be assumed to be a hard coded 	       number. 	     o In an effort to cope with a change from 32 to 64 bits, 	       there are also toc entries that are specified to be 	       either 32 or 64 bits:                  lwz r4,[toc32].GS.0.static_int(rtoc) 	         lwz r4,[toc64].GS.0.static_int(rtoc) 	       These demand toc entries of the specified size, and the 	       instruction probably requires it.           */
name|int
name|valid_toc
decl_stmt|;
name|enum
name|toc_size_qualifier
name|toc_kind
decl_stmt|;
name|bfd_reloc_code_real_type
name|toc_reloc
decl_stmt|;
comment|/* go parse off the [tocXX] part */
name|valid_toc
operator|=
name|parse_toc_entry
argument_list|(
operator|&
name|toc_kind
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|valid_toc
condition|)
block|{
comment|/* Note: message has already been issued.     */
comment|/* FIXME: what sort of recovery should we do? */
comment|/*        demand_rest_of_line(); return; ?    */
block|}
comment|/* Now get the symbol following the ']' */
name|expression
argument_list|(
operator|&
name|ex
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|toc_kind
condition|)
block|{
case|case
name|default_toc
case|:
comment|/* In this case, we may not have seen the symbol yet, since  */
comment|/* it is allowed to appear on a .extern or .globl or just be */
comment|/* a label in the .data section.                             */
name|toc_reloc
operator|=
name|BFD_RELOC_PPC_TOC16
expr_stmt|;
break|break;
case|case
name|data_in_toc
case|:
comment|/* 1. The symbol must be defined and either in the toc        */
comment|/*    section, or a global.                                   */
comment|/* 2. The reloc generated must have the TOCDEFN flag set in   */
comment|/*    upper bit mess of the reloc type.                       */
comment|/* FIXME: It's a little confusing what the tocv qualifier can */
comment|/*        be used for. At the very least, I've seen three     */
comment|/*        uses, only one of which I'm sure I can explain.     */
if|if
condition|(
name|ex
operator|.
name|X_op
operator|==
name|O_symbol
condition|)
block|{
name|assert
argument_list|(
name|ex
operator|.
name|X_add_symbol
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|symbol_get_bfdsym
argument_list|(
name|ex
operator|.
name|X_add_symbol
argument_list|)
operator|->
name|section
operator|!=
name|tocdata_section
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"[tocv] symbol is not a toc symbol"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|toc_reloc
operator|=
name|BFD_RELOC_PPC_TOC16
expr_stmt|;
break|break;
case|case
name|must_be_32
case|:
comment|/* FIXME: these next two specifically specify 32/64 bit toc   */
comment|/*        entries. We don't support them today. Is this the   */
comment|/*        right way to say that?                              */
name|toc_reloc
operator|=
name|BFD_RELOC_UNUSED
expr_stmt|;
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Unimplemented toc32 expression modifier"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|must_be_64
case|:
comment|/* FIXME: see above */
name|toc_reloc
operator|=
name|BFD_RELOC_UNUSED
expr_stmt|;
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Unimplemented toc64 expression modifier"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"Unexpected return value [%d] from parse_toc_entry!\n"
argument_list|)
argument_list|,
name|toc_kind
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
break|break;
block|}
comment|/* We need to generate a fixup for this expression.  */
if|if
condition|(
name|fc
operator|>=
name|MAX_INSN_FIXUPS
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"too many fixups"
argument_list|)
argument_list|)
expr_stmt|;
name|fixups
index|[
name|fc
index|]
operator|.
name|reloc
operator|=
name|toc_reloc
expr_stmt|;
name|fixups
index|[
name|fc
index|]
operator|.
name|exp
operator|=
name|ex
expr_stmt|;
name|fixups
index|[
name|fc
index|]
operator|.
name|opindex
operator|=
operator|*
name|opindex_ptr
expr_stmt|;
operator|++
name|fc
expr_stmt|;
comment|/* Ok. We've set up the fixup for the instruction. Now make it 	     look like the constant 0 was found here */
name|ex
operator|.
name|X_unsigned
operator|=
literal|1
expr_stmt|;
name|ex
operator|.
name|X_op
operator|=
name|O_constant
expr_stmt|;
name|ex
operator|.
name|X_add_number
operator|=
literal|0
expr_stmt|;
name|ex
operator|.
name|X_add_symbol
operator|=
name|NULL
expr_stmt|;
name|ex
operator|.
name|X_op_symbol
operator|=
name|NULL
expr_stmt|;
block|}
else|else
endif|#
directive|endif
comment|/* TE_PE */
block|{
if|if
condition|(
operator|!
name|register_name
argument_list|(
operator|&
name|ex
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|operand
operator|->
name|flags
operator|&
name|PPC_OPERAND_CR
operator|)
operator|!=
literal|0
condition|)
name|cr_operand
operator|=
name|true
expr_stmt|;
name|expression
argument_list|(
operator|&
name|ex
argument_list|)
expr_stmt|;
name|cr_operand
operator|=
name|false
expr_stmt|;
block|}
block|}
name|str
operator|=
name|input_line_pointer
expr_stmt|;
name|input_line_pointer
operator|=
name|hold
expr_stmt|;
if|if
condition|(
name|ex
operator|.
name|X_op
operator|==
name|O_illegal
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"illegal operand"
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ex
operator|.
name|X_op
operator|==
name|O_absent
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"missing operand"
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ex
operator|.
name|X_op
operator|==
name|O_register
condition|)
block|{
name|insn
operator|=
name|ppc_insert_operand
argument_list|(
name|insn
argument_list|,
name|operand
argument_list|,
name|ex
operator|.
name|X_add_number
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ex
operator|.
name|X_op
operator|==
name|O_constant
condition|)
block|{
ifdef|#
directive|ifdef
name|OBJ_ELF
comment|/* Allow @HA, @L, @H on constants.  */
name|char
modifier|*
name|orig_str
init|=
name|str
decl_stmt|;
if|if
condition|(
operator|(
name|reloc
operator|=
name|ppc_elf_suffix
argument_list|(
operator|&
name|str
argument_list|,
operator|&
name|ex
argument_list|)
operator|)
operator|!=
name|BFD_RELOC_UNUSED
condition|)
switch|switch
condition|(
name|reloc
condition|)
block|{
default|default:
name|str
operator|=
name|orig_str
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_LO16
case|:
comment|/* X_unsigned is the default, so if the user has done                    something which cleared it, we always produce a                    signed value.  */
if|if
condition|(
name|ex
operator|.
name|X_unsigned
operator|&&
operator|(
name|operand
operator|->
name|flags
operator|&
name|PPC_OPERAND_SIGNED
operator|)
operator|==
literal|0
condition|)
name|ex
operator|.
name|X_add_number
operator|&=
literal|0xffff
expr_stmt|;
else|else
name|ex
operator|.
name|X_add_number
operator|=
operator|(
operator|(
operator|(
name|ex
operator|.
name|X_add_number
operator|&
literal|0xffff
operator|)
operator|^
literal|0x8000
operator|)
operator|-
literal|0x8000
operator|)
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_HI16
case|:
name|ex
operator|.
name|X_add_number
operator|=
operator|(
name|ex
operator|.
name|X_add_number
operator|>>
literal|16
operator|)
operator|&
literal|0xffff
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_HI16_S
case|:
name|ex
operator|.
name|X_add_number
operator|=
operator|(
operator|(
operator|(
operator|(
name|ex
operator|.
name|X_add_number
operator|>>
literal|16
operator|)
operator|&
literal|0xffff
operator|)
operator|+
operator|(
operator|(
name|ex
operator|.
name|X_add_number
operator|>>
literal|15
operator|)
operator|&
literal|1
operator|)
operator|)
operator|&
literal|0xffff
operator|)
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
name|insn
operator|=
name|ppc_insert_operand
argument_list|(
name|insn
argument_list|,
name|operand
argument_list|,
name|ex
operator|.
name|X_add_number
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|OBJ_ELF
elseif|else
if|if
condition|(
operator|(
name|reloc
operator|=
name|ppc_elf_suffix
argument_list|(
operator|&
name|str
argument_list|,
operator|&
name|ex
argument_list|)
operator|)
operator|!=
name|BFD_RELOC_UNUSED
condition|)
block|{
comment|/* For the absoulte forms of branchs, convert the PC relative form back into 	     the absolute.  */
if|if
condition|(
operator|(
name|operand
operator|->
name|flags
operator|&
name|PPC_OPERAND_ABSOLUTE
operator|)
operator|!=
literal|0
condition|)
block|{
switch|switch
condition|(
name|reloc
condition|)
block|{
case|case
name|BFD_RELOC_PPC_B26
case|:
name|reloc
operator|=
name|BFD_RELOC_PPC_BA26
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_B16
case|:
name|reloc
operator|=
name|BFD_RELOC_PPC_BA16
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_B16_BRTAKEN
case|:
name|reloc
operator|=
name|BFD_RELOC_PPC_BA16_BRTAKEN
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_B16_BRNTAKEN
case|:
name|reloc
operator|=
name|BFD_RELOC_PPC_BA16_BRNTAKEN
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
comment|/* We need to generate a fixup for this expression.  */
if|if
condition|(
name|fc
operator|>=
name|MAX_INSN_FIXUPS
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"too many fixups"
argument_list|)
argument_list|)
expr_stmt|;
name|fixups
index|[
name|fc
index|]
operator|.
name|exp
operator|=
name|ex
expr_stmt|;
name|fixups
index|[
name|fc
index|]
operator|.
name|opindex
operator|=
literal|0
expr_stmt|;
name|fixups
index|[
name|fc
index|]
operator|.
name|reloc
operator|=
name|reloc
expr_stmt|;
operator|++
name|fc
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* OBJ_ELF */
else|else
block|{
comment|/* We need to generate a fixup for this expression.  */
if|if
condition|(
name|fc
operator|>=
name|MAX_INSN_FIXUPS
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"too many fixups"
argument_list|)
argument_list|)
expr_stmt|;
name|fixups
index|[
name|fc
index|]
operator|.
name|exp
operator|=
name|ex
expr_stmt|;
name|fixups
index|[
name|fc
index|]
operator|.
name|opindex
operator|=
operator|*
name|opindex_ptr
expr_stmt|;
name|fixups
index|[
name|fc
index|]
operator|.
name|reloc
operator|=
name|BFD_RELOC_UNUSED
expr_stmt|;
operator|++
name|fc
expr_stmt|;
block|}
if|if
condition|(
name|need_paren
condition|)
block|{
name|endc
operator|=
literal|')'
expr_stmt|;
name|need_paren
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|operand
operator|->
name|flags
operator|&
name|PPC_OPERAND_PARENS
operator|)
operator|!=
literal|0
condition|)
block|{
name|endc
operator|=
literal|'('
expr_stmt|;
name|need_paren
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|endc
operator|=
literal|','
expr_stmt|;
comment|/* The call to expression should have advanced str past any 	 whitespace.  */
if|if
condition|(
operator|*
name|str
operator|!=
name|endc
operator|&&
operator|(
name|endc
operator|!=
literal|','
operator|||
operator|*
name|str
operator|!=
literal|'\0'
operator|)
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"syntax error; found `%c' but expected `%c'"
argument_list|)
argument_list|,
operator|*
name|str
argument_list|,
name|endc
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|*
name|str
operator|!=
literal|'\0'
condition|)
operator|++
name|str
expr_stmt|;
block|}
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|str
argument_list|)
condition|)
operator|++
name|str
expr_stmt|;
if|if
condition|(
operator|*
name|str
operator|!=
literal|'\0'
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"junk at end of line: `%s'"
argument_list|)
argument_list|,
name|str
argument_list|)
expr_stmt|;
comment|/* Write out the instruction.  */
name|f
operator|=
name|frag_more
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|f
argument_list|,
name|insn
argument_list|,
literal|4
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|OBJ_ELF
name|dwarf2_emit_insn
argument_list|(
literal|4
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Create any fixups.  At this point we do not use a      bfd_reloc_code_real_type, but instead just use the      BFD_RELOC_UNUSED plus the operand index.  This lets us easily      handle fixups for any operand type, although that is admittedly      not a very exciting feature.  We pick a BFD reloc type in      md_apply_fix.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|fc
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|struct
name|powerpc_operand
modifier|*
name|operand
decl_stmt|;
name|operand
operator|=
operator|&
name|powerpc_operands
index|[
name|fixups
index|[
name|i
index|]
operator|.
name|opindex
index|]
expr_stmt|;
if|if
condition|(
name|fixups
index|[
name|i
index|]
operator|.
name|reloc
operator|!=
name|BFD_RELOC_UNUSED
condition|)
block|{
name|reloc_howto_type
modifier|*
name|reloc_howto
init|=
name|bfd_reloc_type_lookup
argument_list|(
name|stdoutput
argument_list|,
name|fixups
index|[
name|i
index|]
operator|.
name|reloc
argument_list|)
decl_stmt|;
name|int
name|size
decl_stmt|;
name|int
name|offset
decl_stmt|;
name|fixS
modifier|*
name|fixP
decl_stmt|;
if|if
condition|(
operator|!
name|reloc_howto
condition|)
name|abort
argument_list|()
expr_stmt|;
name|size
operator|=
name|bfd_get_reloc_size
argument_list|(
name|reloc_howto
argument_list|)
expr_stmt|;
name|offset
operator|=
name|target_big_endian
condition|?
operator|(
literal|4
operator|-
name|size
operator|)
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|size
operator|<
literal|1
operator|||
name|size
operator|>
literal|4
condition|)
name|abort
argument_list|()
expr_stmt|;
name|fixP
operator|=
name|fix_new_exp
argument_list|(
name|frag_now
argument_list|,
name|f
operator|-
name|frag_now
operator|->
name|fr_literal
operator|+
name|offset
argument_list|,
name|size
argument_list|,
operator|&
name|fixups
index|[
name|i
index|]
operator|.
name|exp
argument_list|,
name|reloc_howto
operator|->
name|pc_relative
argument_list|,
name|fixups
index|[
name|i
index|]
operator|.
name|reloc
argument_list|)
expr_stmt|;
comment|/* Turn off complaints that the addend is too large for things like 	     foo+100000@ha.  */
switch|switch
condition|(
name|fixups
index|[
name|i
index|]
operator|.
name|reloc
condition|)
block|{
case|case
name|BFD_RELOC_16_GOTOFF
case|:
case|case
name|BFD_RELOC_PPC_TOC16
case|:
case|case
name|BFD_RELOC_LO16
case|:
case|case
name|BFD_RELOC_HI16
case|:
case|case
name|BFD_RELOC_HI16_S
case|:
name|fixP
operator|->
name|fx_no_overflow
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
else|else
name|fix_new_exp
argument_list|(
name|frag_now
argument_list|,
name|f
operator|-
name|frag_now
operator|->
name|fr_literal
argument_list|,
literal|4
argument_list|,
operator|&
name|fixups
index|[
name|i
index|]
operator|.
name|exp
argument_list|,
operator|(
name|operand
operator|->
name|flags
operator|&
name|PPC_OPERAND_RELATIVE
operator|)
operator|!=
literal|0
argument_list|,
operator|(
call|(
name|bfd_reloc_code_real_type
call|)
argument_list|(
name|fixups
index|[
name|i
index|]
operator|.
name|opindex
operator|+
operator|(
name|int
operator|)
name|BFD_RELOC_UNUSED
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Handle a macro.  Gather all the operands, transform them as    described by the macro, and call md_assemble recursively.  All the    operands are separated by commas; we don't accept parentheses    around operands here.  */
end_comment

begin_function
specifier|static
name|void
name|ppc_macro
parameter_list|(
name|str
parameter_list|,
name|macro
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
specifier|const
name|struct
name|powerpc_macro
modifier|*
name|macro
decl_stmt|;
block|{
name|char
modifier|*
name|operands
index|[
literal|10
index|]
decl_stmt|;
name|unsigned
name|int
name|count
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
name|unsigned
name|int
name|len
decl_stmt|;
specifier|const
name|char
modifier|*
name|format
decl_stmt|;
name|int
name|arg
decl_stmt|;
name|char
modifier|*
name|send
decl_stmt|;
name|char
modifier|*
name|complete
decl_stmt|;
comment|/* Gather the users operands into the operands array.  */
name|count
operator|=
literal|0
expr_stmt|;
name|s
operator|=
name|str
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|count
operator|>=
sizeof|sizeof
name|operands
operator|/
sizeof|sizeof
name|operands
index|[
literal|0
index|]
condition|)
break|break;
name|operands
index|[
name|count
operator|++
index|]
operator|=
name|s
expr_stmt|;
name|s
operator|=
name|strchr
argument_list|(
name|s
argument_list|,
literal|','
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
break|break;
operator|*
name|s
operator|++
operator|=
literal|'\0'
expr_stmt|;
block|}
if|if
condition|(
name|count
operator|!=
name|macro
operator|->
name|operands
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"wrong number of operands"
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Work out how large the string must be (the size is unbounded      because it includes user input).  */
name|len
operator|=
literal|0
expr_stmt|;
name|format
operator|=
name|macro
operator|->
name|format
expr_stmt|;
while|while
condition|(
operator|*
name|format
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
operator|*
name|format
operator|!=
literal|'%'
condition|)
block|{
operator|++
name|len
expr_stmt|;
operator|++
name|format
expr_stmt|;
block|}
else|else
block|{
name|arg
operator|=
name|strtol
argument_list|(
name|format
operator|+
literal|1
argument_list|,
operator|&
name|send
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|know
argument_list|(
name|send
operator|!=
name|format
operator|&&
name|arg
operator|>=
literal|0
operator|&&
name|arg
operator|<
name|count
argument_list|)
expr_stmt|;
name|len
operator|+=
name|strlen
argument_list|(
name|operands
index|[
name|arg
index|]
argument_list|)
expr_stmt|;
name|format
operator|=
name|send
expr_stmt|;
block|}
block|}
comment|/* Put the string together.  */
name|complete
operator|=
name|s
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|format
operator|=
name|macro
operator|->
name|format
expr_stmt|;
while|while
condition|(
operator|*
name|format
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
operator|*
name|format
operator|!=
literal|'%'
condition|)
operator|*
name|s
operator|++
operator|=
operator|*
name|format
operator|++
expr_stmt|;
else|else
block|{
name|arg
operator|=
name|strtol
argument_list|(
name|format
operator|+
literal|1
argument_list|,
operator|&
name|send
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|s
argument_list|,
name|operands
index|[
name|arg
index|]
argument_list|)
expr_stmt|;
name|s
operator|+=
name|strlen
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|format
operator|=
name|send
expr_stmt|;
block|}
block|}
operator|*
name|s
operator|=
literal|'\0'
expr_stmt|;
comment|/* Assemble the constructed instruction.  */
name|md_assemble
argument_list|(
name|complete
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|OBJ_ELF
end_ifdef

begin_comment
comment|/* For ELF, add support for SHF_EXCLUDE and SHT_ORDERED */
end_comment

begin_function
name|int
name|ppc_section_letter
parameter_list|(
name|letter
parameter_list|,
name|ptr_msg
parameter_list|)
name|int
name|letter
decl_stmt|;
name|char
modifier|*
modifier|*
name|ptr_msg
decl_stmt|;
block|{
if|if
condition|(
name|letter
operator|==
literal|'e'
condition|)
return|return
name|SHF_EXCLUDE
return|;
operator|*
name|ptr_msg
operator|=
name|_
argument_list|(
literal|"Bad .section directive: want a,w,x,e in string"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|ppc_section_word
parameter_list|(
name|str
parameter_list|,
name|len
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
name|size_t
name|len
decl_stmt|;
block|{
if|if
condition|(
name|len
operator|==
literal|7
operator|&&
name|strncmp
argument_list|(
name|str
argument_list|,
literal|"exclude"
argument_list|,
literal|7
argument_list|)
operator|==
literal|0
condition|)
return|return
name|SHF_EXCLUDE
return|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
name|int
name|ppc_section_type
parameter_list|(
name|str
parameter_list|,
name|len
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
name|size_t
name|len
decl_stmt|;
block|{
if|if
condition|(
name|len
operator|==
literal|7
operator|&&
name|strncmp
argument_list|(
name|str
argument_list|,
literal|"ordered"
argument_list|,
literal|7
argument_list|)
operator|==
literal|0
condition|)
return|return
name|SHT_ORDERED
return|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
name|int
name|ppc_section_flags
parameter_list|(
name|flags
parameter_list|,
name|attr
parameter_list|,
name|type
parameter_list|)
name|int
name|flags
decl_stmt|;
name|int
name|attr
decl_stmt|;
name|int
name|type
decl_stmt|;
block|{
if|if
condition|(
name|type
operator|==
name|SHT_ORDERED
condition|)
name|flags
operator||=
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_SORT_ENTRIES
expr_stmt|;
if|if
condition|(
name|attr
operator|&
name|SHF_EXCLUDE
condition|)
name|flags
operator||=
name|SEC_EXCLUDE
expr_stmt|;
return|return
name|flags
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* OBJ_ELF */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Pseudo-op handling.  */
end_comment

begin_comment
comment|/* The .byte pseudo-op.  This is similar to the normal .byte    pseudo-op, but it can also take a single ASCII string.  */
end_comment

begin_function
specifier|static
name|void
name|ppc_byte
parameter_list|(
name|ignore
parameter_list|)
name|int
name|ignore
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
if|if
condition|(
operator|*
name|input_line_pointer
operator|!=
literal|'\"'
condition|)
block|{
name|cons
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Gather characters.  A real double quote is doubled.  Unusual      characters are not permitted.  */
operator|++
name|input_line_pointer
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|char
name|c
decl_stmt|;
name|c
operator|=
operator|*
name|input_line_pointer
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\"'
condition|)
block|{
if|if
condition|(
operator|*
name|input_line_pointer
operator|!=
literal|'\"'
condition|)
break|break;
operator|++
name|input_line_pointer
expr_stmt|;
block|}
name|FRAG_APPEND_1_CHAR
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|OBJ_XCOFF
end_ifdef

begin_comment
comment|/* XCOFF specific pseudo-op handling.  */
end_comment

begin_comment
comment|/* This is set if we are creating a .stabx symbol, since we don't want    to handle symbol suffixes for such symbols.  */
end_comment

begin_decl_stmt
specifier|static
name|boolean
name|ppc_stab_symbol
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The .comm and .lcomm pseudo-ops for XCOFF.  XCOFF puts common    symbols in the .bss segment as though they were local common    symbols, and uses a different smclas.  The native Aix 4.3.3 assember    aligns .comm and .lcomm to 4 bytes.  */
end_comment

begin_function
specifier|static
name|void
name|ppc_comm
parameter_list|(
name|lcomm
parameter_list|)
name|int
name|lcomm
decl_stmt|;
block|{
name|asection
modifier|*
name|current_seg
init|=
name|now_seg
decl_stmt|;
name|subsegT
name|current_subseg
init|=
name|now_subseg
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|char
name|endc
decl_stmt|;
name|char
modifier|*
name|end_name
decl_stmt|;
name|offsetT
name|size
decl_stmt|;
name|offsetT
name|align
decl_stmt|;
name|symbolS
modifier|*
name|lcomm_sym
init|=
name|NULL
decl_stmt|;
name|symbolS
modifier|*
name|sym
decl_stmt|;
name|char
modifier|*
name|pfrag
decl_stmt|;
name|name
operator|=
name|input_line_pointer
expr_stmt|;
name|endc
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
name|end_name
operator|=
name|input_line_pointer
expr_stmt|;
operator|*
name|end_name
operator|=
name|endc
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|!=
literal|','
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"missing size"
argument_list|)
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
operator|++
name|input_line_pointer
expr_stmt|;
name|size
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
if|if
condition|(
name|size
operator|<
literal|0
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"negative size"
argument_list|)
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|lcomm
condition|)
block|{
comment|/* The third argument to .comm is the alignment.  */
if|if
condition|(
operator|*
name|input_line_pointer
operator|!=
literal|','
condition|)
name|align
operator|=
literal|2
expr_stmt|;
else|else
block|{
operator|++
name|input_line_pointer
expr_stmt|;
name|align
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
if|if
condition|(
name|align
operator|<=
literal|0
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"ignoring bad alignment"
argument_list|)
argument_list|)
expr_stmt|;
name|align
operator|=
literal|2
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|char
modifier|*
name|lcomm_name
decl_stmt|;
name|char
name|lcomm_endc
decl_stmt|;
if|if
condition|(
name|size
operator|<=
literal|4
condition|)
name|align
operator|=
literal|2
expr_stmt|;
else|else
name|align
operator|=
literal|3
expr_stmt|;
comment|/* The third argument to .lcomm appears to be the real local 	 common symbol to create.  References to the symbol named in 	 the first argument are turned into references to the third 	 argument.  */
if|if
condition|(
operator|*
name|input_line_pointer
operator|!=
literal|','
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"missing real symbol name"
argument_list|)
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
operator|++
name|input_line_pointer
expr_stmt|;
name|lcomm_name
operator|=
name|input_line_pointer
expr_stmt|;
name|lcomm_endc
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
name|lcomm_sym
operator|=
name|symbol_find_or_make
argument_list|(
name|lcomm_name
argument_list|)
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
name|lcomm_endc
expr_stmt|;
block|}
operator|*
name|end_name
operator|=
literal|'\0'
expr_stmt|;
name|sym
operator|=
name|symbol_find_or_make
argument_list|(
name|name
argument_list|)
expr_stmt|;
operator|*
name|end_name
operator|=
name|endc
expr_stmt|;
if|if
condition|(
name|S_IS_DEFINED
argument_list|(
name|sym
argument_list|)
operator|||
name|S_GET_VALUE
argument_list|(
name|sym
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"attempt to redefine symbol"
argument_list|)
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
name|record_alignment
argument_list|(
name|bss_section
argument_list|,
name|align
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|lcomm
operator|||
operator|!
name|S_IS_DEFINED
argument_list|(
name|lcomm_sym
argument_list|)
condition|)
block|{
name|symbolS
modifier|*
name|def_sym
decl_stmt|;
name|offsetT
name|def_size
decl_stmt|;
if|if
condition|(
operator|!
name|lcomm
condition|)
block|{
name|def_sym
operator|=
name|sym
expr_stmt|;
name|def_size
operator|=
name|size
expr_stmt|;
name|S_SET_EXTERNAL
argument_list|(
name|sym
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|symbol_get_tc
argument_list|(
name|lcomm_sym
argument_list|)
operator|->
name|output
operator|=
literal|1
expr_stmt|;
name|def_sym
operator|=
name|lcomm_sym
expr_stmt|;
name|def_size
operator|=
literal|0
expr_stmt|;
block|}
name|subseg_set
argument_list|(
name|bss_section
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|frag_align
argument_list|(
name|align
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|symbol_set_frag
argument_list|(
name|def_sym
argument_list|,
name|frag_now
argument_list|)
expr_stmt|;
name|pfrag
operator|=
name|frag_var
argument_list|(
name|rs_org
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
operator|(
name|relax_substateT
operator|)
literal|0
argument_list|,
name|def_sym
argument_list|,
name|def_size
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
operator|*
name|pfrag
operator|=
literal|0
expr_stmt|;
name|S_SET_SEGMENT
argument_list|(
name|def_sym
argument_list|,
name|bss_section
argument_list|)
expr_stmt|;
name|symbol_get_tc
argument_list|(
name|def_sym
argument_list|)
operator|->
name|align
operator|=
name|align
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|lcomm
condition|)
block|{
comment|/* Align the size of lcomm_sym.  */
name|symbol_get_frag
argument_list|(
name|lcomm_sym
argument_list|)
operator|->
name|fr_offset
operator|=
operator|(
operator|(
name|symbol_get_frag
argument_list|(
name|lcomm_sym
argument_list|)
operator|->
name|fr_offset
operator|+
operator|(
literal|1
operator|<<
name|align
operator|)
operator|-
literal|1
operator|)
operator|&
operator|~
operator|(
operator|(
literal|1
operator|<<
name|align
operator|)
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|align
operator|>
name|symbol_get_tc
argument_list|(
name|lcomm_sym
argument_list|)
operator|->
name|align
condition|)
name|symbol_get_tc
argument_list|(
name|lcomm_sym
argument_list|)
operator|->
name|align
operator|=
name|align
expr_stmt|;
block|}
if|if
condition|(
name|lcomm
condition|)
block|{
comment|/* Make sym an offset from lcomm_sym.  */
name|S_SET_SEGMENT
argument_list|(
name|sym
argument_list|,
name|bss_section
argument_list|)
expr_stmt|;
name|symbol_set_frag
argument_list|(
name|sym
argument_list|,
name|symbol_get_frag
argument_list|(
name|lcomm_sym
argument_list|)
argument_list|)
expr_stmt|;
name|S_SET_VALUE
argument_list|(
name|sym
argument_list|,
name|symbol_get_frag
argument_list|(
name|lcomm_sym
argument_list|)
operator|->
name|fr_offset
argument_list|)
expr_stmt|;
name|symbol_get_frag
argument_list|(
name|lcomm_sym
argument_list|)
operator|->
name|fr_offset
operator|+=
name|size
expr_stmt|;
block|}
name|subseg_set
argument_list|(
name|current_seg
argument_list|,
name|current_subseg
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The .csect pseudo-op.  This switches us into a different    subsegment.  The first argument is a symbol whose value is the    start of the .csect.  In COFF, csect symbols get special aux    entries defined by the x_csect field of union internal_auxent.  The    optional second argument is the alignment (the default is 2).  */
end_comment

begin_function
specifier|static
name|void
name|ppc_csect
parameter_list|(
name|ignore
parameter_list|)
name|int
name|ignore
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|char
name|endc
decl_stmt|;
name|symbolS
modifier|*
name|sym
decl_stmt|;
name|name
operator|=
name|input_line_pointer
expr_stmt|;
name|endc
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
name|sym
operator|=
name|symbol_find_or_make
argument_list|(
name|name
argument_list|)
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
name|endc
expr_stmt|;
if|if
condition|(
name|S_GET_NAME
argument_list|(
name|sym
argument_list|)
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
comment|/* An unnamed csect is assumed to be [PR].  */
name|symbol_get_tc
argument_list|(
name|sym
argument_list|)
operator|->
name|class
operator|=
name|XMC_PR
expr_stmt|;
block|}
name|ppc_change_csect
argument_list|(
name|sym
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|','
condition|)
block|{
operator|++
name|input_line_pointer
expr_stmt|;
name|symbol_get_tc
argument_list|(
name|sym
argument_list|)
operator|->
name|align
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
block|}
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Change to a different csect.  */
end_comment

begin_function
specifier|static
name|void
name|ppc_change_csect
parameter_list|(
name|sym
parameter_list|)
name|symbolS
modifier|*
name|sym
decl_stmt|;
block|{
if|if
condition|(
name|S_IS_DEFINED
argument_list|(
name|sym
argument_list|)
condition|)
name|subseg_set
argument_list|(
name|S_GET_SEGMENT
argument_list|(
name|sym
argument_list|)
argument_list|,
name|symbol_get_tc
argument_list|(
name|sym
argument_list|)
operator|->
name|subseg
argument_list|)
expr_stmt|;
else|else
block|{
name|symbolS
modifier|*
modifier|*
name|list_ptr
decl_stmt|;
name|int
name|after_toc
decl_stmt|;
name|int
name|hold_chunksize
decl_stmt|;
name|symbolS
modifier|*
name|list
decl_stmt|;
comment|/* This is a new csect.  We need to look at the symbol class to 	 figure out whether it should go in the text section or the 	 data section.  */
name|after_toc
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|symbol_get_tc
argument_list|(
name|sym
argument_list|)
operator|->
name|class
condition|)
block|{
case|case
name|XMC_PR
case|:
case|case
name|XMC_RO
case|:
case|case
name|XMC_DB
case|:
case|case
name|XMC_GL
case|:
case|case
name|XMC_XO
case|:
case|case
name|XMC_SV
case|:
case|case
name|XMC_TI
case|:
case|case
name|XMC_TB
case|:
name|S_SET_SEGMENT
argument_list|(
name|sym
argument_list|,
name|text_section
argument_list|)
expr_stmt|;
name|symbol_get_tc
argument_list|(
name|sym
argument_list|)
operator|->
name|subseg
operator|=
name|ppc_text_subsegment
expr_stmt|;
operator|++
name|ppc_text_subsegment
expr_stmt|;
name|list_ptr
operator|=
operator|&
name|ppc_text_csects
expr_stmt|;
break|break;
case|case
name|XMC_RW
case|:
case|case
name|XMC_TC0
case|:
case|case
name|XMC_TC
case|:
case|case
name|XMC_DS
case|:
case|case
name|XMC_UA
case|:
case|case
name|XMC_BS
case|:
case|case
name|XMC_UC
case|:
if|if
condition|(
name|ppc_toc_csect
operator|!=
name|NULL
operator|&&
operator|(
name|symbol_get_tc
argument_list|(
name|ppc_toc_csect
argument_list|)
operator|->
name|subseg
operator|+
literal|1
operator|==
name|ppc_data_subsegment
operator|)
condition|)
name|after_toc
operator|=
literal|1
expr_stmt|;
name|S_SET_SEGMENT
argument_list|(
name|sym
argument_list|,
name|data_section
argument_list|)
expr_stmt|;
name|symbol_get_tc
argument_list|(
name|sym
argument_list|)
operator|->
name|subseg
operator|=
name|ppc_data_subsegment
expr_stmt|;
operator|++
name|ppc_data_subsegment
expr_stmt|;
name|list_ptr
operator|=
operator|&
name|ppc_data_csects
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* We set the obstack chunk size to a small value before          changing subsegments, so that we don't use a lot of memory          space for what may be a small section.  */
name|hold_chunksize
operator|=
name|chunksize
expr_stmt|;
name|chunksize
operator|=
literal|64
expr_stmt|;
name|subseg_new
argument_list|(
name|segment_name
argument_list|(
name|S_GET_SEGMENT
argument_list|(
name|sym
argument_list|)
argument_list|)
argument_list|,
name|symbol_get_tc
argument_list|(
name|sym
argument_list|)
operator|->
name|subseg
argument_list|)
expr_stmt|;
name|chunksize
operator|=
name|hold_chunksize
expr_stmt|;
if|if
condition|(
name|after_toc
condition|)
name|ppc_after_toc_frag
operator|=
name|frag_now
expr_stmt|;
name|symbol_set_frag
argument_list|(
name|sym
argument_list|,
name|frag_now
argument_list|)
expr_stmt|;
name|S_SET_VALUE
argument_list|(
name|sym
argument_list|,
operator|(
name|valueT
operator|)
name|frag_now_fix
argument_list|()
argument_list|)
expr_stmt|;
name|symbol_get_tc
argument_list|(
name|sym
argument_list|)
operator|->
name|align
operator|=
operator|(
name|ppc_xcoff64
operator|)
condition|?
literal|3
else|:
literal|2
expr_stmt|;
name|symbol_get_tc
argument_list|(
name|sym
argument_list|)
operator|->
name|output
operator|=
literal|1
expr_stmt|;
name|symbol_get_tc
argument_list|(
name|sym
argument_list|)
operator|->
name|within
operator|=
name|sym
expr_stmt|;
for|for
control|(
name|list
operator|=
operator|*
name|list_ptr
init|;
name|symbol_get_tc
argument_list|(
name|list
argument_list|)
operator|->
name|next
operator|!=
operator|(
name|symbolS
operator|*
operator|)
name|NULL
condition|;
name|list
operator|=
name|symbol_get_tc
argument_list|(
name|list
argument_list|)
operator|->
name|next
control|)
empty_stmt|;
name|symbol_get_tc
argument_list|(
name|list
argument_list|)
operator|->
name|next
operator|=
name|sym
expr_stmt|;
name|symbol_remove
argument_list|(
name|sym
argument_list|,
operator|&
name|symbol_rootP
argument_list|,
operator|&
name|symbol_lastP
argument_list|)
expr_stmt|;
name|symbol_append
argument_list|(
name|sym
argument_list|,
name|symbol_get_tc
argument_list|(
name|list
argument_list|)
operator|->
name|within
argument_list|,
operator|&
name|symbol_rootP
argument_list|,
operator|&
name|symbol_lastP
argument_list|)
expr_stmt|;
block|}
name|ppc_current_csect
operator|=
name|sym
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This function handles the .text and .data pseudo-ops.  These    pseudo-ops aren't really used by XCOFF; we implement them for the    convenience of people who aren't used to XCOFF.  */
end_comment

begin_function
specifier|static
name|void
name|ppc_section
parameter_list|(
name|type
parameter_list|)
name|int
name|type
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|symbolS
modifier|*
name|sym
decl_stmt|;
if|if
condition|(
name|type
operator|==
literal|'t'
condition|)
name|name
operator|=
literal|".text[PR]"
expr_stmt|;
elseif|else
if|if
condition|(
name|type
operator|==
literal|'d'
condition|)
name|name
operator|=
literal|".data[RW]"
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
name|sym
operator|=
name|symbol_find_or_make
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|ppc_change_csect
argument_list|(
name|sym
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This function handles the .section pseudo-op.  This is mostly to    give an error, since XCOFF only supports .text, .data and .bss, but    we do permit the user to name the text or data section.  */
end_comment

begin_function
specifier|static
name|void
name|ppc_named_section
parameter_list|(
name|ignore
parameter_list|)
name|int
name|ignore
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|char
modifier|*
name|user_name
decl_stmt|;
specifier|const
name|char
modifier|*
name|real_name
decl_stmt|;
name|char
name|c
decl_stmt|;
name|symbolS
modifier|*
name|sym
decl_stmt|;
name|user_name
operator|=
name|input_line_pointer
expr_stmt|;
name|c
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|user_name
argument_list|,
literal|".text"
argument_list|)
operator|==
literal|0
condition|)
name|real_name
operator|=
literal|".text[PR]"
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|user_name
argument_list|,
literal|".data"
argument_list|)
operator|==
literal|0
condition|)
name|real_name
operator|=
literal|".data[RW]"
expr_stmt|;
else|else
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"The XCOFF file format does not support arbitrary sections"
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
name|sym
operator|=
name|symbol_find_or_make
argument_list|(
name|real_name
argument_list|)
expr_stmt|;
name|ppc_change_csect
argument_list|(
name|sym
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The .extern pseudo-op.  We create an undefined symbol.  */
end_comment

begin_function
specifier|static
name|void
name|ppc_extern
parameter_list|(
name|ignore
parameter_list|)
name|int
name|ignore
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|char
name|endc
decl_stmt|;
name|name
operator|=
name|input_line_pointer
expr_stmt|;
name|endc
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|symbol_find_or_make
argument_list|(
name|name
argument_list|)
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
name|endc
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The .lglobl pseudo-op.  Keep the symbol in the symbol table.  */
end_comment

begin_function
specifier|static
name|void
name|ppc_lglobl
parameter_list|(
name|ignore
parameter_list|)
name|int
name|ignore
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|char
name|endc
decl_stmt|;
name|symbolS
modifier|*
name|sym
decl_stmt|;
name|name
operator|=
name|input_line_pointer
expr_stmt|;
name|endc
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
name|sym
operator|=
name|symbol_find_or_make
argument_list|(
name|name
argument_list|)
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
name|endc
expr_stmt|;
name|symbol_get_tc
argument_list|(
name|sym
argument_list|)
operator|->
name|output
operator|=
literal|1
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The .rename pseudo-op.  The RS/6000 assembler can rename symbols,    although I don't know why it bothers.  */
end_comment

begin_function
specifier|static
name|void
name|ppc_rename
parameter_list|(
name|ignore
parameter_list|)
name|int
name|ignore
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|char
name|endc
decl_stmt|;
name|symbolS
modifier|*
name|sym
decl_stmt|;
name|int
name|len
decl_stmt|;
name|name
operator|=
name|input_line_pointer
expr_stmt|;
name|endc
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
name|sym
operator|=
name|symbol_find_or_make
argument_list|(
name|name
argument_list|)
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
name|endc
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|!=
literal|','
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"missing rename string"
argument_list|)
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
operator|++
name|input_line_pointer
expr_stmt|;
name|symbol_get_tc
argument_list|(
name|sym
argument_list|)
operator|->
name|real_name
operator|=
name|demand_copy_C_string
argument_list|(
operator|&
name|len
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The .stabx pseudo-op.  This is similar to a normal .stabs    pseudo-op, but slightly different.  A sample is        .stabx "main:F-1",.main,142,0    The first argument is the symbol name to create.  The second is the    value, and the third is the storage class.  The fourth seems to be    always zero, and I am assuming it is the type.  */
end_comment

begin_function
specifier|static
name|void
name|ppc_stabx
parameter_list|(
name|ignore
parameter_list|)
name|int
name|ignore
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|len
decl_stmt|;
name|symbolS
modifier|*
name|sym
decl_stmt|;
name|expressionS
name|exp
decl_stmt|;
name|name
operator|=
name|demand_copy_C_string
argument_list|(
operator|&
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|!=
literal|','
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"missing value"
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
operator|++
name|input_line_pointer
expr_stmt|;
name|ppc_stab_symbol
operator|=
name|true
expr_stmt|;
name|sym
operator|=
name|symbol_make
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|ppc_stab_symbol
operator|=
name|false
expr_stmt|;
name|symbol_get_tc
argument_list|(
name|sym
argument_list|)
operator|->
name|real_name
operator|=
name|name
expr_stmt|;
operator|(
name|void
operator|)
name|expression
argument_list|(
operator|&
name|exp
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|exp
operator|.
name|X_op
condition|)
block|{
case|case
name|O_illegal
case|:
case|case
name|O_absent
case|:
case|case
name|O_big
case|:
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"illegal .stabx expression; zero assumed"
argument_list|)
argument_list|)
expr_stmt|;
name|exp
operator|.
name|X_add_number
operator|=
literal|0
expr_stmt|;
comment|/* Fall through.  */
case|case
name|O_constant
case|:
name|S_SET_VALUE
argument_list|(
name|sym
argument_list|,
operator|(
name|valueT
operator|)
name|exp
operator|.
name|X_add_number
argument_list|)
expr_stmt|;
name|symbol_set_frag
argument_list|(
name|sym
argument_list|,
operator|&
name|zero_address_frag
argument_list|)
expr_stmt|;
break|break;
case|case
name|O_symbol
case|:
if|if
condition|(
name|S_GET_SEGMENT
argument_list|(
name|exp
operator|.
name|X_add_symbol
argument_list|)
operator|==
name|undefined_section
condition|)
name|symbol_set_value_expression
argument_list|(
name|sym
argument_list|,
operator|&
name|exp
argument_list|)
expr_stmt|;
else|else
block|{
name|S_SET_VALUE
argument_list|(
name|sym
argument_list|,
name|exp
operator|.
name|X_add_number
operator|+
name|S_GET_VALUE
argument_list|(
name|exp
operator|.
name|X_add_symbol
argument_list|)
argument_list|)
expr_stmt|;
name|symbol_set_frag
argument_list|(
name|sym
argument_list|,
name|symbol_get_frag
argument_list|(
name|exp
operator|.
name|X_add_symbol
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
comment|/* The value is some complex expression.  This will probably          fail at some later point, but this is probably the right          thing to do here.  */
name|symbol_set_value_expression
argument_list|(
name|sym
argument_list|,
operator|&
name|exp
argument_list|)
expr_stmt|;
break|break;
block|}
name|S_SET_SEGMENT
argument_list|(
name|sym
argument_list|,
name|ppc_coff_debug_section
argument_list|)
expr_stmt|;
name|symbol_get_bfdsym
argument_list|(
name|sym
argument_list|)
operator|->
name|flags
operator||=
name|BSF_DEBUGGING
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|!=
literal|','
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"missing class"
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
operator|++
name|input_line_pointer
expr_stmt|;
name|S_SET_STORAGE_CLASS
argument_list|(
name|sym
argument_list|,
name|get_absolute_expression
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|!=
literal|','
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"missing type"
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
operator|++
name|input_line_pointer
expr_stmt|;
name|S_SET_DATA_TYPE
argument_list|(
name|sym
argument_list|,
name|get_absolute_expression
argument_list|()
argument_list|)
expr_stmt|;
name|symbol_get_tc
argument_list|(
name|sym
argument_list|)
operator|->
name|output
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|S_GET_STORAGE_CLASS
argument_list|(
name|sym
argument_list|)
operator|==
name|C_STSYM
condition|)
block|{
name|symbol_get_tc
argument_list|(
name|sym
argument_list|)
operator|->
name|within
operator|=
name|ppc_current_block
expr_stmt|;
comment|/* In this case :               .bs name        .stabx	"z",arrays_,133,0        .es                .comm arrays_,13768,3                resolve_symbol_value will copy the exp's "within" into sym's when the        offset is 0.  Since this seems to be corner case problem,        only do the correction for storage class C_STSYM.  A better solution        would be to have the tc	field updated in ppc_symbol_new_hook. */
if|if
condition|(
name|exp
operator|.
name|X_op
operator|==
name|O_symbol
condition|)
block|{
name|symbol_get_tc
argument_list|(
name|exp
operator|.
name|X_add_symbol
argument_list|)
operator|->
name|within
operator|=
name|ppc_current_block
expr_stmt|;
block|}
block|}
if|if
condition|(
name|exp
operator|.
name|X_op
operator|!=
name|O_symbol
operator|||
operator|!
name|S_IS_EXTERNAL
argument_list|(
name|exp
operator|.
name|X_add_symbol
argument_list|)
operator|||
name|S_GET_SEGMENT
argument_list|(
name|exp
operator|.
name|X_add_symbol
argument_list|)
operator|!=
name|bss_section
condition|)
name|ppc_frob_label
argument_list|(
name|sym
argument_list|)
expr_stmt|;
else|else
block|{
name|symbol_remove
argument_list|(
name|sym
argument_list|,
operator|&
name|symbol_rootP
argument_list|,
operator|&
name|symbol_lastP
argument_list|)
expr_stmt|;
name|symbol_append
argument_list|(
name|sym
argument_list|,
name|exp
operator|.
name|X_add_symbol
argument_list|,
operator|&
name|symbol_rootP
argument_list|,
operator|&
name|symbol_lastP
argument_list|)
expr_stmt|;
if|if
condition|(
name|symbol_get_tc
argument_list|(
name|ppc_current_csect
argument_list|)
operator|->
name|within
operator|==
name|exp
operator|.
name|X_add_symbol
condition|)
name|symbol_get_tc
argument_list|(
name|ppc_current_csect
argument_list|)
operator|->
name|within
operator|=
name|sym
expr_stmt|;
block|}
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The .function pseudo-op.  This takes several arguments.  The first    argument seems to be the external name of the symbol.  The second    argment seems to be the label for the start of the function.  gcc    uses the same name for both.  I have no idea what the third and    fourth arguments are meant to be.  The optional fifth argument is    an expression for the size of the function.  In COFF this symbol    gets an aux entry like that used for a csect.  */
end_comment

begin_function
specifier|static
name|void
name|ppc_function
parameter_list|(
name|ignore
parameter_list|)
name|int
name|ignore
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|char
name|endc
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
name|symbolS
modifier|*
name|ext_sym
decl_stmt|;
name|symbolS
modifier|*
name|lab_sym
decl_stmt|;
name|name
operator|=
name|input_line_pointer
expr_stmt|;
name|endc
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
comment|/* Ignore any [PR] suffix.  */
name|name
operator|=
name|ppc_canonicalize_symbol_name
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|s
operator|=
name|strchr
argument_list|(
name|name
argument_list|,
literal|'['
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
operator|(
name|char
operator|*
operator|)
name|NULL
operator|&&
name|strcmp
argument_list|(
name|s
operator|+
literal|1
argument_list|,
literal|"PR]"
argument_list|)
operator|==
literal|0
condition|)
operator|*
name|s
operator|=
literal|'\0'
expr_stmt|;
name|ext_sym
operator|=
name|symbol_find_or_make
argument_list|(
name|name
argument_list|)
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
name|endc
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|!=
literal|','
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"missing symbol name"
argument_list|)
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
operator|++
name|input_line_pointer
expr_stmt|;
name|name
operator|=
name|input_line_pointer
expr_stmt|;
name|endc
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
name|lab_sym
operator|=
name|symbol_find_or_make
argument_list|(
name|name
argument_list|)
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
name|endc
expr_stmt|;
if|if
condition|(
name|ext_sym
operator|!=
name|lab_sym
condition|)
block|{
name|expressionS
name|exp
decl_stmt|;
name|exp
operator|.
name|X_op
operator|=
name|O_symbol
expr_stmt|;
name|exp
operator|.
name|X_add_symbol
operator|=
name|lab_sym
expr_stmt|;
name|exp
operator|.
name|X_op_symbol
operator|=
name|NULL
expr_stmt|;
name|exp
operator|.
name|X_add_number
operator|=
literal|0
expr_stmt|;
name|exp
operator|.
name|X_unsigned
operator|=
literal|0
expr_stmt|;
name|symbol_set_value_expression
argument_list|(
name|ext_sym
argument_list|,
operator|&
name|exp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|symbol_get_tc
argument_list|(
name|ext_sym
argument_list|)
operator|->
name|class
operator|==
operator|-
literal|1
condition|)
name|symbol_get_tc
argument_list|(
name|ext_sym
argument_list|)
operator|->
name|class
operator|=
name|XMC_PR
expr_stmt|;
name|symbol_get_tc
argument_list|(
name|ext_sym
argument_list|)
operator|->
name|output
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|','
condition|)
block|{
name|expressionS
name|ignore
decl_stmt|;
comment|/* Ignore the third argument.  */
operator|++
name|input_line_pointer
expr_stmt|;
name|expression
argument_list|(
operator|&
name|ignore
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|','
condition|)
block|{
comment|/* Ignore the fourth argument.  */
operator|++
name|input_line_pointer
expr_stmt|;
name|expression
argument_list|(
operator|&
name|ignore
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|','
condition|)
block|{
comment|/* The fifth argument is the function size.  */
operator|++
name|input_line_pointer
expr_stmt|;
name|symbol_get_tc
argument_list|(
name|ext_sym
argument_list|)
operator|->
name|size
operator|=
name|symbol_new
argument_list|(
literal|"L0\001"
argument_list|,
name|absolute_section
argument_list|,
operator|(
name|valueT
operator|)
literal|0
argument_list|,
operator|&
name|zero_address_frag
argument_list|)
expr_stmt|;
name|pseudo_set
argument_list|(
name|symbol_get_tc
argument_list|(
name|ext_sym
argument_list|)
operator|->
name|size
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|S_SET_DATA_TYPE
argument_list|(
name|ext_sym
argument_list|,
name|DT_FCN
operator|<<
name|N_BTSHFT
argument_list|)
expr_stmt|;
name|SF_SET_FUNCTION
argument_list|(
name|ext_sym
argument_list|)
expr_stmt|;
name|SF_SET_PROCESS
argument_list|(
name|ext_sym
argument_list|)
expr_stmt|;
name|coff_add_linesym
argument_list|(
name|ext_sym
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The .bf pseudo-op.  This is just like a COFF C_FCN symbol named    ".bf".  */
end_comment

begin_function
specifier|static
name|void
name|ppc_bf
parameter_list|(
name|ignore
parameter_list|)
name|int
name|ignore
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|symbolS
modifier|*
name|sym
decl_stmt|;
name|sym
operator|=
name|symbol_make
argument_list|(
literal|".bf"
argument_list|)
expr_stmt|;
name|S_SET_SEGMENT
argument_list|(
name|sym
argument_list|,
name|text_section
argument_list|)
expr_stmt|;
name|symbol_set_frag
argument_list|(
name|sym
argument_list|,
name|frag_now
argument_list|)
expr_stmt|;
name|S_SET_VALUE
argument_list|(
name|sym
argument_list|,
name|frag_now_fix
argument_list|()
argument_list|)
expr_stmt|;
name|S_SET_STORAGE_CLASS
argument_list|(
name|sym
argument_list|,
name|C_FCN
argument_list|)
expr_stmt|;
name|coff_line_base
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
name|S_SET_NUMBER_AUXILIARY
argument_list|(
name|sym
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SA_SET_SYM_LNNO
argument_list|(
name|sym
argument_list|,
name|coff_line_base
argument_list|)
expr_stmt|;
name|symbol_get_tc
argument_list|(
name|sym
argument_list|)
operator|->
name|output
operator|=
literal|1
expr_stmt|;
name|ppc_frob_label
argument_list|(
name|sym
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The .ef pseudo-op.  This is just like a COFF C_FCN symbol named    ".ef", except that the line number is absolute, not relative to the    most recent ".bf" symbol.  */
end_comment

begin_function
specifier|static
name|void
name|ppc_ef
parameter_list|(
name|ignore
parameter_list|)
name|int
name|ignore
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|symbolS
modifier|*
name|sym
decl_stmt|;
name|sym
operator|=
name|symbol_make
argument_list|(
literal|".ef"
argument_list|)
expr_stmt|;
name|S_SET_SEGMENT
argument_list|(
name|sym
argument_list|,
name|text_section
argument_list|)
expr_stmt|;
name|symbol_set_frag
argument_list|(
name|sym
argument_list|,
name|frag_now
argument_list|)
expr_stmt|;
name|S_SET_VALUE
argument_list|(
name|sym
argument_list|,
name|frag_now_fix
argument_list|()
argument_list|)
expr_stmt|;
name|S_SET_STORAGE_CLASS
argument_list|(
name|sym
argument_list|,
name|C_FCN
argument_list|)
expr_stmt|;
name|S_SET_NUMBER_AUXILIARY
argument_list|(
name|sym
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SA_SET_SYM_LNNO
argument_list|(
name|sym
argument_list|,
name|get_absolute_expression
argument_list|()
argument_list|)
expr_stmt|;
name|symbol_get_tc
argument_list|(
name|sym
argument_list|)
operator|->
name|output
operator|=
literal|1
expr_stmt|;
name|ppc_frob_label
argument_list|(
name|sym
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The .bi and .ei pseudo-ops.  These take a string argument and    generates a C_BINCL or C_EINCL symbol, which goes at the start of    the symbol list.  */
end_comment

begin_function
specifier|static
name|void
name|ppc_biei
parameter_list|(
name|ei
parameter_list|)
name|int
name|ei
decl_stmt|;
block|{
specifier|static
name|symbolS
modifier|*
name|last_biei
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|len
decl_stmt|;
name|symbolS
modifier|*
name|sym
decl_stmt|;
name|symbolS
modifier|*
name|look
decl_stmt|;
name|name
operator|=
name|demand_copy_C_string
argument_list|(
operator|&
name|len
argument_list|)
expr_stmt|;
comment|/* The value of these symbols is actually file offset.  Here we set      the value to the index into the line number entries.  In      ppc_frob_symbols we set the fix_line field, which will cause BFD      to do the right thing.  */
name|sym
operator|=
name|symbol_make
argument_list|(
name|name
argument_list|)
expr_stmt|;
comment|/* obj-coff.c currently only handles line numbers correctly in the      .text section.  */
name|S_SET_SEGMENT
argument_list|(
name|sym
argument_list|,
name|text_section
argument_list|)
expr_stmt|;
name|S_SET_VALUE
argument_list|(
name|sym
argument_list|,
name|coff_n_line_nos
argument_list|)
expr_stmt|;
name|symbol_get_bfdsym
argument_list|(
name|sym
argument_list|)
operator|->
name|flags
operator||=
name|BSF_DEBUGGING
expr_stmt|;
name|S_SET_STORAGE_CLASS
argument_list|(
name|sym
argument_list|,
name|ei
condition|?
name|C_EINCL
else|:
name|C_BINCL
argument_list|)
expr_stmt|;
name|symbol_get_tc
argument_list|(
name|sym
argument_list|)
operator|->
name|output
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|look
operator|=
name|last_biei
condition|?
name|last_biei
else|:
name|symbol_rootP
init|;
operator|(
name|look
operator|!=
operator|(
name|symbolS
operator|*
operator|)
name|NULL
operator|&&
operator|(
name|S_GET_STORAGE_CLASS
argument_list|(
name|look
argument_list|)
operator|==
name|C_FILE
operator|||
name|S_GET_STORAGE_CLASS
argument_list|(
name|look
argument_list|)
operator|==
name|C_BINCL
operator|||
name|S_GET_STORAGE_CLASS
argument_list|(
name|look
argument_list|)
operator|==
name|C_EINCL
operator|)
operator|)
condition|;
name|look
operator|=
name|symbol_next
argument_list|(
name|look
argument_list|)
control|)
empty_stmt|;
if|if
condition|(
name|look
operator|!=
operator|(
name|symbolS
operator|*
operator|)
name|NULL
condition|)
block|{
name|symbol_remove
argument_list|(
name|sym
argument_list|,
operator|&
name|symbol_rootP
argument_list|,
operator|&
name|symbol_lastP
argument_list|)
expr_stmt|;
name|symbol_insert
argument_list|(
name|sym
argument_list|,
name|look
argument_list|,
operator|&
name|symbol_rootP
argument_list|,
operator|&
name|symbol_lastP
argument_list|)
expr_stmt|;
name|last_biei
operator|=
name|sym
expr_stmt|;
block|}
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The .bs pseudo-op.  This generates a C_BSTAT symbol named ".bs".    There is one argument, which is a csect symbol.  The value of the    .bs symbol is the index of this csect symbol.  */
end_comment

begin_function
specifier|static
name|void
name|ppc_bs
parameter_list|(
name|ignore
parameter_list|)
name|int
name|ignore
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|char
name|endc
decl_stmt|;
name|symbolS
modifier|*
name|csect
decl_stmt|;
name|symbolS
modifier|*
name|sym
decl_stmt|;
if|if
condition|(
name|ppc_current_block
operator|!=
name|NULL
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"nested .bs blocks"
argument_list|)
argument_list|)
expr_stmt|;
name|name
operator|=
name|input_line_pointer
expr_stmt|;
name|endc
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
name|csect
operator|=
name|symbol_find_or_make
argument_list|(
name|name
argument_list|)
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
name|endc
expr_stmt|;
name|sym
operator|=
name|symbol_make
argument_list|(
literal|".bs"
argument_list|)
expr_stmt|;
name|S_SET_SEGMENT
argument_list|(
name|sym
argument_list|,
name|now_seg
argument_list|)
expr_stmt|;
name|S_SET_STORAGE_CLASS
argument_list|(
name|sym
argument_list|,
name|C_BSTAT
argument_list|)
expr_stmt|;
name|symbol_get_bfdsym
argument_list|(
name|sym
argument_list|)
operator|->
name|flags
operator||=
name|BSF_DEBUGGING
expr_stmt|;
name|symbol_get_tc
argument_list|(
name|sym
argument_list|)
operator|->
name|output
operator|=
literal|1
expr_stmt|;
name|symbol_get_tc
argument_list|(
name|sym
argument_list|)
operator|->
name|within
operator|=
name|csect
expr_stmt|;
name|ppc_frob_label
argument_list|(
name|sym
argument_list|)
expr_stmt|;
name|ppc_current_block
operator|=
name|sym
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The .es pseudo-op.  Generate a C_ESTART symbol named .es.  */
end_comment

begin_function
specifier|static
name|void
name|ppc_es
parameter_list|(
name|ignore
parameter_list|)
name|int
name|ignore
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|symbolS
modifier|*
name|sym
decl_stmt|;
if|if
condition|(
name|ppc_current_block
operator|==
name|NULL
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|".es without preceding .bs"
argument_list|)
argument_list|)
expr_stmt|;
name|sym
operator|=
name|symbol_make
argument_list|(
literal|".es"
argument_list|)
expr_stmt|;
name|S_SET_SEGMENT
argument_list|(
name|sym
argument_list|,
name|now_seg
argument_list|)
expr_stmt|;
name|S_SET_STORAGE_CLASS
argument_list|(
name|sym
argument_list|,
name|C_ESTAT
argument_list|)
expr_stmt|;
name|symbol_get_bfdsym
argument_list|(
name|sym
argument_list|)
operator|->
name|flags
operator||=
name|BSF_DEBUGGING
expr_stmt|;
name|symbol_get_tc
argument_list|(
name|sym
argument_list|)
operator|->
name|output
operator|=
literal|1
expr_stmt|;
name|ppc_frob_label
argument_list|(
name|sym
argument_list|)
expr_stmt|;
name|ppc_current_block
operator|=
name|NULL
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The .bb pseudo-op.  Generate a C_BLOCK symbol named .bb, with a    line number.  */
end_comment

begin_function
specifier|static
name|void
name|ppc_bb
parameter_list|(
name|ignore
parameter_list|)
name|int
name|ignore
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|symbolS
modifier|*
name|sym
decl_stmt|;
name|sym
operator|=
name|symbol_make
argument_list|(
literal|".bb"
argument_list|)
expr_stmt|;
name|S_SET_SEGMENT
argument_list|(
name|sym
argument_list|,
name|text_section
argument_list|)
expr_stmt|;
name|symbol_set_frag
argument_list|(
name|sym
argument_list|,
name|frag_now
argument_list|)
expr_stmt|;
name|S_SET_VALUE
argument_list|(
name|sym
argument_list|,
name|frag_now_fix
argument_list|()
argument_list|)
expr_stmt|;
name|S_SET_STORAGE_CLASS
argument_list|(
name|sym
argument_list|,
name|C_BLOCK
argument_list|)
expr_stmt|;
name|S_SET_NUMBER_AUXILIARY
argument_list|(
name|sym
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SA_SET_SYM_LNNO
argument_list|(
name|sym
argument_list|,
name|get_absolute_expression
argument_list|()
argument_list|)
expr_stmt|;
name|symbol_get_tc
argument_list|(
name|sym
argument_list|)
operator|->
name|output
operator|=
literal|1
expr_stmt|;
name|SF_SET_PROCESS
argument_list|(
name|sym
argument_list|)
expr_stmt|;
name|ppc_frob_label
argument_list|(
name|sym
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The .eb pseudo-op.  Generate a C_BLOCK symbol named .eb, with a    line number.  */
end_comment

begin_function
specifier|static
name|void
name|ppc_eb
parameter_list|(
name|ignore
parameter_list|)
name|int
name|ignore
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|symbolS
modifier|*
name|sym
decl_stmt|;
name|sym
operator|=
name|symbol_make
argument_list|(
literal|".eb"
argument_list|)
expr_stmt|;
name|S_SET_SEGMENT
argument_list|(
name|sym
argument_list|,
name|text_section
argument_list|)
expr_stmt|;
name|symbol_set_frag
argument_list|(
name|sym
argument_list|,
name|frag_now
argument_list|)
expr_stmt|;
name|S_SET_VALUE
argument_list|(
name|sym
argument_list|,
name|frag_now_fix
argument_list|()
argument_list|)
expr_stmt|;
name|S_SET_STORAGE_CLASS
argument_list|(
name|sym
argument_list|,
name|C_BLOCK
argument_list|)
expr_stmt|;
name|S_SET_NUMBER_AUXILIARY
argument_list|(
name|sym
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SA_SET_SYM_LNNO
argument_list|(
name|sym
argument_list|,
name|get_absolute_expression
argument_list|()
argument_list|)
expr_stmt|;
name|symbol_get_tc
argument_list|(
name|sym
argument_list|)
operator|->
name|output
operator|=
literal|1
expr_stmt|;
name|SF_SET_PROCESS
argument_list|(
name|sym
argument_list|)
expr_stmt|;
name|ppc_frob_label
argument_list|(
name|sym
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The .bc pseudo-op.  This just creates a C_BCOMM symbol with a    specified name.  */
end_comment

begin_function
specifier|static
name|void
name|ppc_bc
parameter_list|(
name|ignore
parameter_list|)
name|int
name|ignore
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|len
decl_stmt|;
name|symbolS
modifier|*
name|sym
decl_stmt|;
name|name
operator|=
name|demand_copy_C_string
argument_list|(
operator|&
name|len
argument_list|)
expr_stmt|;
name|sym
operator|=
name|symbol_make
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|S_SET_SEGMENT
argument_list|(
name|sym
argument_list|,
name|ppc_coff_debug_section
argument_list|)
expr_stmt|;
name|symbol_get_bfdsym
argument_list|(
name|sym
argument_list|)
operator|->
name|flags
operator||=
name|BSF_DEBUGGING
expr_stmt|;
name|S_SET_STORAGE_CLASS
argument_list|(
name|sym
argument_list|,
name|C_BCOMM
argument_list|)
expr_stmt|;
name|S_SET_VALUE
argument_list|(
name|sym
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|symbol_get_tc
argument_list|(
name|sym
argument_list|)
operator|->
name|output
operator|=
literal|1
expr_stmt|;
name|ppc_frob_label
argument_list|(
name|sym
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The .ec pseudo-op.  This just creates a C_ECOMM symbol.  */
end_comment

begin_function
specifier|static
name|void
name|ppc_ec
parameter_list|(
name|ignore
parameter_list|)
name|int
name|ignore
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|symbolS
modifier|*
name|sym
decl_stmt|;
name|sym
operator|=
name|symbol_make
argument_list|(
literal|".ec"
argument_list|)
expr_stmt|;
name|S_SET_SEGMENT
argument_list|(
name|sym
argument_list|,
name|ppc_coff_debug_section
argument_list|)
expr_stmt|;
name|symbol_get_bfdsym
argument_list|(
name|sym
argument_list|)
operator|->
name|flags
operator||=
name|BSF_DEBUGGING
expr_stmt|;
name|S_SET_STORAGE_CLASS
argument_list|(
name|sym
argument_list|,
name|C_ECOMM
argument_list|)
expr_stmt|;
name|S_SET_VALUE
argument_list|(
name|sym
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|symbol_get_tc
argument_list|(
name|sym
argument_list|)
operator|->
name|output
operator|=
literal|1
expr_stmt|;
name|ppc_frob_label
argument_list|(
name|sym
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The .toc pseudo-op.  Switch to the .toc subsegment.  */
end_comment

begin_function
specifier|static
name|void
name|ppc_toc
parameter_list|(
name|ignore
parameter_list|)
name|int
name|ignore
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
if|if
condition|(
name|ppc_toc_csect
operator|!=
operator|(
name|symbolS
operator|*
operator|)
name|NULL
condition|)
name|subseg_set
argument_list|(
name|data_section
argument_list|,
name|symbol_get_tc
argument_list|(
name|ppc_toc_csect
argument_list|)
operator|->
name|subseg
argument_list|)
expr_stmt|;
else|else
block|{
name|subsegT
name|subseg
decl_stmt|;
name|symbolS
modifier|*
name|sym
decl_stmt|;
name|symbolS
modifier|*
name|list
decl_stmt|;
name|subseg
operator|=
name|ppc_data_subsegment
expr_stmt|;
operator|++
name|ppc_data_subsegment
expr_stmt|;
name|subseg_new
argument_list|(
name|segment_name
argument_list|(
name|data_section
argument_list|)
argument_list|,
name|subseg
argument_list|)
expr_stmt|;
name|ppc_toc_frag
operator|=
name|frag_now
expr_stmt|;
name|sym
operator|=
name|symbol_find_or_make
argument_list|(
literal|"TOC[TC0]"
argument_list|)
expr_stmt|;
name|symbol_set_frag
argument_list|(
name|sym
argument_list|,
name|frag_now
argument_list|)
expr_stmt|;
name|S_SET_SEGMENT
argument_list|(
name|sym
argument_list|,
name|data_section
argument_list|)
expr_stmt|;
name|S_SET_VALUE
argument_list|(
name|sym
argument_list|,
operator|(
name|valueT
operator|)
name|frag_now_fix
argument_list|()
argument_list|)
expr_stmt|;
name|symbol_get_tc
argument_list|(
name|sym
argument_list|)
operator|->
name|subseg
operator|=
name|subseg
expr_stmt|;
name|symbol_get_tc
argument_list|(
name|sym
argument_list|)
operator|->
name|output
operator|=
literal|1
expr_stmt|;
name|symbol_get_tc
argument_list|(
name|sym
argument_list|)
operator|->
name|within
operator|=
name|sym
expr_stmt|;
name|ppc_toc_csect
operator|=
name|sym
expr_stmt|;
for|for
control|(
name|list
operator|=
name|ppc_data_csects
init|;
name|symbol_get_tc
argument_list|(
name|list
argument_list|)
operator|->
name|next
operator|!=
operator|(
name|symbolS
operator|*
operator|)
name|NULL
condition|;
name|list
operator|=
name|symbol_get_tc
argument_list|(
name|list
argument_list|)
operator|->
name|next
control|)
empty_stmt|;
name|symbol_get_tc
argument_list|(
name|list
argument_list|)
operator|->
name|next
operator|=
name|sym
expr_stmt|;
name|symbol_remove
argument_list|(
name|sym
argument_list|,
operator|&
name|symbol_rootP
argument_list|,
operator|&
name|symbol_lastP
argument_list|)
expr_stmt|;
name|symbol_append
argument_list|(
name|sym
argument_list|,
name|symbol_get_tc
argument_list|(
name|list
argument_list|)
operator|->
name|within
argument_list|,
operator|&
name|symbol_rootP
argument_list|,
operator|&
name|symbol_lastP
argument_list|)
expr_stmt|;
block|}
name|ppc_current_csect
operator|=
name|ppc_toc_csect
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The AIX assembler automatically aligns the operands of a .long or    .short pseudo-op, and we want to be compatible.  */
end_comment

begin_function
specifier|static
name|void
name|ppc_xcoff_cons
parameter_list|(
name|log_size
parameter_list|)
name|int
name|log_size
decl_stmt|;
block|{
name|frag_align
argument_list|(
name|log_size
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|record_alignment
argument_list|(
name|now_seg
argument_list|,
name|log_size
argument_list|)
expr_stmt|;
name|cons
argument_list|(
literal|1
operator|<<
name|log_size
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ppc_machine
parameter_list|(
name|dummy
parameter_list|)
name|int
name|dummy
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|discard_rest_of_line
argument_list|()
expr_stmt|;
comment|/* What does aix use this for?  */
block|}
end_function

begin_function
specifier|static
name|void
name|ppc_vbyte
parameter_list|(
name|dummy
parameter_list|)
name|int
name|dummy
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|expressionS
name|exp
decl_stmt|;
name|int
name|byte_count
decl_stmt|;
operator|(
name|void
operator|)
name|expression
argument_list|(
operator|&
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
name|exp
operator|.
name|X_op
operator|!=
name|O_constant
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"non-constant byte count"
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|byte_count
operator|=
name|exp
operator|.
name|X_add_number
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|!=
literal|','
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"missing value"
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
operator|++
name|input_line_pointer
expr_stmt|;
name|cons
argument_list|(
name|byte_count
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* OBJ_XCOFF */
end_comment

begin_escape
end_escape

begin_comment
comment|/* The .tc pseudo-op.  This is used when generating either XCOFF or    ELF.  This takes two or more arguments.     When generating XCOFF output, the first argument is the name to    give to this location in the toc; this will be a symbol with class    TC.  The rest of the arguments are 4 byte values to actually put at    this location in the TOC; often there is just one more argument, a    relocateable symbol reference.     When not generating XCOFF output, the arguments are the same, but    the first argument is simply ignored.  */
end_comment

begin_function
specifier|static
name|void
name|ppc_tc
parameter_list|(
name|ignore
parameter_list|)
name|int
name|ignore
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|OBJ_XCOFF
comment|/* Define the TOC symbol name.  */
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|char
name|endc
decl_stmt|;
name|symbolS
modifier|*
name|sym
decl_stmt|;
if|if
condition|(
name|ppc_toc_csect
operator|==
operator|(
name|symbolS
operator|*
operator|)
name|NULL
operator|||
name|ppc_toc_csect
operator|!=
name|ppc_current_csect
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|".tc not in .toc section"
argument_list|)
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
name|name
operator|=
name|input_line_pointer
expr_stmt|;
name|endc
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
name|sym
operator|=
name|symbol_find_or_make
argument_list|(
name|name
argument_list|)
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
name|endc
expr_stmt|;
if|if
condition|(
name|S_IS_DEFINED
argument_list|(
name|sym
argument_list|)
condition|)
block|{
name|symbolS
modifier|*
name|label
decl_stmt|;
name|label
operator|=
name|symbol_get_tc
argument_list|(
name|ppc_current_csect
argument_list|)
operator|->
name|within
expr_stmt|;
if|if
condition|(
name|symbol_get_tc
argument_list|(
name|label
argument_list|)
operator|->
name|class
operator|!=
name|XMC_TC0
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|".tc with no label"
argument_list|)
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
name|S_SET_SEGMENT
argument_list|(
name|label
argument_list|,
name|S_GET_SEGMENT
argument_list|(
name|sym
argument_list|)
argument_list|)
expr_stmt|;
name|symbol_set_frag
argument_list|(
name|label
argument_list|,
name|symbol_get_frag
argument_list|(
name|sym
argument_list|)
argument_list|)
expr_stmt|;
name|S_SET_VALUE
argument_list|(
name|label
argument_list|,
name|S_GET_VALUE
argument_list|(
name|sym
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|is_end_of_line
index|[
operator|(
name|unsigned
name|char
operator|)
operator|*
name|input_line_pointer
index|]
condition|)
operator|++
name|input_line_pointer
expr_stmt|;
return|return;
block|}
name|S_SET_SEGMENT
argument_list|(
name|sym
argument_list|,
name|now_seg
argument_list|)
expr_stmt|;
name|symbol_set_frag
argument_list|(
name|sym
argument_list|,
name|frag_now
argument_list|)
expr_stmt|;
name|S_SET_VALUE
argument_list|(
name|sym
argument_list|,
operator|(
name|valueT
operator|)
name|frag_now_fix
argument_list|()
argument_list|)
expr_stmt|;
name|symbol_get_tc
argument_list|(
name|sym
argument_list|)
operator|->
name|class
operator|=
name|XMC_TC
expr_stmt|;
name|symbol_get_tc
argument_list|(
name|sym
argument_list|)
operator|->
name|output
operator|=
literal|1
expr_stmt|;
name|ppc_frob_label
argument_list|(
name|sym
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
comment|/* ! defined (OBJ_XCOFF) */
comment|/* Skip the TOC symbol name.  */
while|while
condition|(
name|is_part_of_name
argument_list|(
operator|*
name|input_line_pointer
argument_list|)
operator|||
operator|*
name|input_line_pointer
operator|==
literal|'['
operator|||
operator|*
name|input_line_pointer
operator|==
literal|']'
operator|||
operator|*
name|input_line_pointer
operator|==
literal|'{'
operator|||
operator|*
name|input_line_pointer
operator|==
literal|'}'
condition|)
operator|++
name|input_line_pointer
expr_stmt|;
comment|/* Align to a four byte boundary.  */
name|frag_align
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|record_alignment
argument_list|(
name|now_seg
argument_list|,
literal|2
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ! defined (OBJ_XCOFF) */
if|if
condition|(
operator|*
name|input_line_pointer
operator|!=
literal|','
condition|)
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
else|else
block|{
operator|++
name|input_line_pointer
expr_stmt|;
name|cons
argument_list|(
operator|(
name|ppc_size
operator|==
name|PPC_OPCODE_64
operator|)
condition|?
literal|8
else|:
literal|4
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|TE_PE
end_ifdef

begin_comment
comment|/* Pseudo-ops specific to the Windows NT PowerPC PE (coff) format */
end_comment

begin_comment
comment|/* Set the current section.  */
end_comment

begin_function
specifier|static
name|void
name|ppc_set_current_section
parameter_list|(
name|new
parameter_list|)
name|segT
name|new
decl_stmt|;
block|{
name|ppc_previous_section
operator|=
name|ppc_current_section
expr_stmt|;
name|ppc_current_section
operator|=
name|new
expr_stmt|;
block|}
end_function

begin_comment
comment|/* pseudo-op: .previous    behaviour: toggles the current section with the previous section.    errors:    None    warnings:  "No previous section" */
end_comment

begin_function
specifier|static
name|void
name|ppc_previous
parameter_list|(
name|ignore
parameter_list|)
name|int
name|ignore
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|symbolS
modifier|*
name|tmp
decl_stmt|;
if|if
condition|(
name|ppc_previous_section
operator|==
name|NULL
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"No previous section to return to. Directive ignored."
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|subseg_set
argument_list|(
name|ppc_previous_section
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ppc_set_current_section
argument_list|(
name|ppc_previous_section
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* pseudo-op: .pdata    behaviour: predefined read only data section               double word aligned    errors:    None    warnings:  None    initial:   .section .pdata "adr3"               a - don't know -- maybe a misprint 	      d - initialized data 	      r - readable 	      3 - double word aligned (that would be 4 byte boundary)     commentary:    Tag index tables (also known as the function table) for exception    handling, debugging, etc.  */
end_comment

begin_function
specifier|static
name|void
name|ppc_pdata
parameter_list|(
name|ignore
parameter_list|)
name|int
name|ignore
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
if|if
condition|(
name|pdata_section
operator|==
literal|0
condition|)
block|{
name|pdata_section
operator|=
name|subseg_new
argument_list|(
literal|".pdata"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bfd_set_section_flags
argument_list|(
name|stdoutput
argument_list|,
name|pdata_section
argument_list|,
operator|(
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_RELOC
operator||
name|SEC_READONLY
operator||
name|SEC_DATA
operator|)
argument_list|)
expr_stmt|;
name|bfd_set_section_alignment
argument_list|(
name|stdoutput
argument_list|,
name|pdata_section
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pdata_section
operator|=
name|subseg_new
argument_list|(
literal|".pdata"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|ppc_set_current_section
argument_list|(
name|pdata_section
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* pseudo-op: .ydata    behaviour: predefined read only data section               double word aligned    errors:    None    warnings:  None    initial:   .section .ydata "drw3"               a - don't know -- maybe a misprint 	      d - initialized data 	      r - readable 	      3 - double word aligned (that would be 4 byte boundary)    commentary:    Tag tables (also known as the scope table) for exception handling,    debugging, etc. */
end_comment

begin_function
specifier|static
name|void
name|ppc_ydata
parameter_list|(
name|ignore
parameter_list|)
name|int
name|ignore
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
if|if
condition|(
name|ydata_section
operator|==
literal|0
condition|)
block|{
name|ydata_section
operator|=
name|subseg_new
argument_list|(
literal|".ydata"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bfd_set_section_flags
argument_list|(
name|stdoutput
argument_list|,
name|ydata_section
argument_list|,
operator|(
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_RELOC
operator||
name|SEC_READONLY
operator||
name|SEC_DATA
operator|)
argument_list|)
expr_stmt|;
name|bfd_set_section_alignment
argument_list|(
name|stdoutput
argument_list|,
name|ydata_section
argument_list|,
literal|3
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ydata_section
operator|=
name|subseg_new
argument_list|(
literal|".ydata"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|ppc_set_current_section
argument_list|(
name|ydata_section
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* pseudo-op: .reldata    behaviour: predefined read write data section               double word aligned (4-byte) 	      FIXME: relocation is applied to it 	      FIXME: what's the difference between this and .data?    errors:    None    warnings:  None    initial:   .section .reldata "drw3" 	      d - initialized data 	      r - readable 	      w - writeable 	      3 - double word aligned (that would be 8 byte boundary)     commentary:    Like .data, but intended to hold data subject to relocation, such as    function descriptors, etc. */
end_comment

begin_function
specifier|static
name|void
name|ppc_reldata
parameter_list|(
name|ignore
parameter_list|)
name|int
name|ignore
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
if|if
condition|(
name|reldata_section
operator|==
literal|0
condition|)
block|{
name|reldata_section
operator|=
name|subseg_new
argument_list|(
literal|".reldata"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bfd_set_section_flags
argument_list|(
name|stdoutput
argument_list|,
name|reldata_section
argument_list|,
operator|(
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_RELOC
operator||
name|SEC_DATA
operator|)
argument_list|)
expr_stmt|;
name|bfd_set_section_alignment
argument_list|(
name|stdoutput
argument_list|,
name|reldata_section
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|reldata_section
operator|=
name|subseg_new
argument_list|(
literal|".reldata"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|ppc_set_current_section
argument_list|(
name|reldata_section
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* pseudo-op: .rdata    behaviour: predefined read only data section               double word aligned    errors:    None    warnings:  None    initial:   .section .rdata "dr3" 	      d - initialized data 	      r - readable 	      3 - double word aligned (that would be 4 byte boundary) */
end_comment

begin_function
specifier|static
name|void
name|ppc_rdata
parameter_list|(
name|ignore
parameter_list|)
name|int
name|ignore
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
if|if
condition|(
name|rdata_section
operator|==
literal|0
condition|)
block|{
name|rdata_section
operator|=
name|subseg_new
argument_list|(
literal|".rdata"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bfd_set_section_flags
argument_list|(
name|stdoutput
argument_list|,
name|rdata_section
argument_list|,
operator|(
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_RELOC
operator||
name|SEC_READONLY
operator||
name|SEC_DATA
operator|)
argument_list|)
expr_stmt|;
name|bfd_set_section_alignment
argument_list|(
name|stdoutput
argument_list|,
name|rdata_section
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rdata_section
operator|=
name|subseg_new
argument_list|(
literal|".rdata"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|ppc_set_current_section
argument_list|(
name|rdata_section
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* pseudo-op: .ualong    behaviour: much like .int, with the exception that no alignment is               performed. 	      FIXME: test the alignment statement    errors:    None    warnings:  None */
end_comment

begin_function
specifier|static
name|void
name|ppc_ualong
parameter_list|(
name|ignore
parameter_list|)
name|int
name|ignore
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
comment|/* try for long */
name|cons
argument_list|(
literal|4
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* pseudo-op: .znop<symbol name>    behaviour: Issue a nop instruction               Issue a IMAGE_REL_PPC_IFGLUE relocation against it, using 	      the supplied symbol name.    errors:    None    warnings:  Missing symbol name */
end_comment

begin_function
specifier|static
name|void
name|ppc_znop
parameter_list|(
name|ignore
parameter_list|)
name|int
name|ignore
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|unsigned
name|long
name|insn
decl_stmt|;
specifier|const
name|struct
name|powerpc_opcode
modifier|*
name|opcode
decl_stmt|;
name|expressionS
name|ex
decl_stmt|;
name|char
modifier|*
name|f
decl_stmt|;
name|symbolS
modifier|*
name|sym
decl_stmt|;
comment|/* Strip out the symbol name */
name|char
modifier|*
name|symbol_name
decl_stmt|;
name|char
name|c
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|unsigned
name|int
name|exp
decl_stmt|;
name|flagword
name|flags
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|symbol_name
operator|=
name|input_line_pointer
expr_stmt|;
name|c
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
name|name
operator|=
name|xmalloc
argument_list|(
name|input_line_pointer
operator|-
name|symbol_name
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|name
argument_list|,
name|symbol_name
argument_list|)
expr_stmt|;
name|sym
operator|=
name|symbol_find_or_make
argument_list|(
name|name
argument_list|)
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
comment|/* Look up the opcode in the hash table.  */
name|opcode
operator|=
operator|(
specifier|const
expr|struct
name|powerpc_opcode
operator|*
operator|)
name|hash_find
argument_list|(
name|ppc_hash
argument_list|,
literal|"nop"
argument_list|)
expr_stmt|;
comment|/* stick in the nop */
name|insn
operator|=
name|opcode
operator|->
name|opcode
expr_stmt|;
comment|/* Write out the instruction.  */
name|f
operator|=
name|frag_more
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|f
argument_list|,
name|insn
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|fix_new
argument_list|(
name|frag_now
argument_list|,
name|f
operator|-
name|frag_now
operator|->
name|fr_literal
argument_list|,
literal|4
argument_list|,
name|sym
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|BFD_RELOC_16_GOT_PCREL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* pseudo-op:    behaviour:    errors:    warnings: */
end_comment

begin_function
specifier|static
name|void
name|ppc_pe_comm
parameter_list|(
name|lcomm
parameter_list|)
name|int
name|lcomm
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|name
decl_stmt|;
specifier|register
name|char
name|c
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|offsetT
name|temp
decl_stmt|;
specifier|register
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
name|offsetT
name|align
decl_stmt|;
name|name
operator|=
name|input_line_pointer
expr_stmt|;
name|c
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
comment|/* just after name is now '\0' */
name|p
operator|=
name|input_line_pointer
expr_stmt|;
operator|*
name|p
operator|=
name|c
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|!=
literal|','
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Expected comma after symbol-name: rest of line ignored."
argument_list|)
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
name|input_line_pointer
operator|++
expr_stmt|;
comment|/* skip ',' */
if|if
condition|(
operator|(
name|temp
operator|=
name|get_absolute_expression
argument_list|()
operator|)
operator|<
literal|0
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|".COMMon length (%ld.)<0! Ignored."
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|temp
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|lcomm
condition|)
block|{
comment|/* The third argument to .comm is the alignment.  */
if|if
condition|(
operator|*
name|input_line_pointer
operator|!=
literal|','
condition|)
name|align
operator|=
literal|3
expr_stmt|;
else|else
block|{
operator|++
name|input_line_pointer
expr_stmt|;
name|align
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
if|if
condition|(
name|align
operator|<=
literal|0
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"ignoring bad alignment"
argument_list|)
argument_list|)
expr_stmt|;
name|align
operator|=
literal|3
expr_stmt|;
block|}
block|}
block|}
operator|*
name|p
operator|=
literal|0
expr_stmt|;
name|symbolP
operator|=
name|symbol_find_or_make
argument_list|(
name|name
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|S_IS_DEFINED
argument_list|(
name|symbolP
argument_list|)
operator|&&
operator|!
name|S_IS_COMMON
argument_list|(
name|symbolP
argument_list|)
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Ignoring attempt to re-define symbol `%s'."
argument_list|)
argument_list|,
name|S_GET_NAME
argument_list|(
name|symbolP
argument_list|)
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|S_GET_VALUE
argument_list|(
name|symbolP
argument_list|)
condition|)
block|{
if|if
condition|(
name|S_GET_VALUE
argument_list|(
name|symbolP
argument_list|)
operator|!=
operator|(
name|valueT
operator|)
name|temp
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Length of .comm \"%s\" is already %ld. Not changed to %ld."
argument_list|)
argument_list|,
name|S_GET_NAME
argument_list|(
name|symbolP
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|S_GET_VALUE
argument_list|(
name|symbolP
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|temp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|S_SET_VALUE
argument_list|(
name|symbolP
argument_list|,
operator|(
name|valueT
operator|)
name|temp
argument_list|)
expr_stmt|;
name|S_SET_EXTERNAL
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
block|}
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * implement the .section pseudo op:  *	.section name {, "flags"}  *                ^         ^  *                |         +--- optional flags: 'b' for bss  *                |                              'i' for info  *                +-- section name               'l' for lib  *                                               'n' for noload  *                                               'o' for over  *                                               'w' for data  *						 'd' (apparently m88k for data)  *                                               'x' for text  * But if the argument is not a quoted string, treat it as a  * subsegment number.  *  * FIXME: this is a copy of the section processing from obj-coff.c, with  * additions/changes for the moto-pas assembler support. There are three  * categories:  *  * FIXME: I just noticed this. This doesn't work at all really. It it  *        setting bits that bfd probably neither understands or uses. The  *        correct approach (?) will have to incorporate extra fields attached  *        to the section to hold the system specific stuff. (krk)  *  * Section Contents:  * 'a' - unknown - referred to in documentation, but no definition supplied  * 'c' - section has code  * 'd' - section has initialized data  * 'u' - section has uninitialized data  * 'i' - section contains directives (info)  * 'n' - section can be discarded  * 'R' - remove section at link time  *  * Section Protection:  * 'r' - section is readable  * 'w' - section is writeable  * 'x' - section is executable  * 's' - section is sharable  *  * Section Alignment:  * '0' - align to byte boundary  * '1' - align to halfword undary  * '2' - align to word boundary  * '3' - align to doubleword boundary  * '4' - align to quadword boundary  * '5' - align to 32 byte boundary  * '6' - align to 64 byte boundary  *  */
end_comment

begin_function
name|void
name|ppc_pe_section
parameter_list|(
name|ignore
parameter_list|)
name|int
name|ignore
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
comment|/* Strip out the section name */
name|char
modifier|*
name|section_name
decl_stmt|;
name|char
name|c
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|unsigned
name|int
name|exp
decl_stmt|;
name|flagword
name|flags
decl_stmt|;
name|segT
name|sec
decl_stmt|;
name|int
name|align
decl_stmt|;
name|section_name
operator|=
name|input_line_pointer
expr_stmt|;
name|c
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
name|name
operator|=
name|xmalloc
argument_list|(
name|input_line_pointer
operator|-
name|section_name
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|name
argument_list|,
name|section_name
argument_list|)
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
name|exp
operator|=
literal|0
expr_stmt|;
name|flags
operator|=
name|SEC_NO_FLAGS
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".idata$2"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|align
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".idata$3"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|align
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".idata$4"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|align
operator|=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".idata$5"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|align
operator|=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".idata$6"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|align
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|align
operator|=
literal|4
expr_stmt|;
comment|/* default alignment to 16 byte boundary */
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|','
condition|)
block|{
operator|++
name|input_line_pointer
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|!=
literal|'"'
condition|)
name|exp
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
else|else
block|{
operator|++
name|input_line_pointer
expr_stmt|;
while|while
condition|(
operator|*
name|input_line_pointer
operator|!=
literal|'"'
operator|&&
operator|!
name|is_end_of_line
index|[
operator|(
name|unsigned
name|char
operator|)
operator|*
name|input_line_pointer
index|]
condition|)
block|{
switch|switch
condition|(
operator|*
name|input_line_pointer
condition|)
block|{
comment|/* Section Contents */
case|case
literal|'a'
case|:
comment|/* unknown */
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Unsupported section attribute -- 'a'"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
comment|/* code section */
name|flags
operator||=
name|SEC_CODE
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
comment|/* section has initialized data */
name|flags
operator||=
name|SEC_DATA
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
comment|/* section has uninitialized data */
comment|/* FIXME: This is IMAGE_SCN_CNT_UNINITIALIZED_DATA 		     in winnt.h */
name|flags
operator||=
name|SEC_ROM
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
comment|/* section contains directives (info) */
comment|/* FIXME: This is IMAGE_SCN_LNK_INFO 		     in winnt.h */
name|flags
operator||=
name|SEC_HAS_CONTENTS
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
comment|/* section can be discarded */
name|flags
operator|&=
operator|~
name|SEC_LOAD
expr_stmt|;
break|break;
case|case
literal|'R'
case|:
comment|/* Remove section at link time */
name|flags
operator||=
name|SEC_NEVER_LOAD
expr_stmt|;
break|break;
comment|/* Section Protection */
case|case
literal|'r'
case|:
comment|/* section is readable */
name|flags
operator||=
name|IMAGE_SCN_MEM_READ
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
comment|/* section is writeable */
name|flags
operator||=
name|IMAGE_SCN_MEM_WRITE
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
comment|/* section is executable */
name|flags
operator||=
name|IMAGE_SCN_MEM_EXECUTE
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
comment|/* section is sharable */
name|flags
operator||=
name|IMAGE_SCN_MEM_SHARED
expr_stmt|;
break|break;
comment|/* Section Alignment */
case|case
literal|'0'
case|:
comment|/* align to byte boundary */
name|flags
operator||=
name|IMAGE_SCN_ALIGN_1BYTES
expr_stmt|;
name|align
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'1'
case|:
comment|/* align to halfword boundary */
name|flags
operator||=
name|IMAGE_SCN_ALIGN_2BYTES
expr_stmt|;
name|align
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'2'
case|:
comment|/* align to word boundary */
name|flags
operator||=
name|IMAGE_SCN_ALIGN_4BYTES
expr_stmt|;
name|align
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|'3'
case|:
comment|/* align to doubleword boundary */
name|flags
operator||=
name|IMAGE_SCN_ALIGN_8BYTES
expr_stmt|;
name|align
operator|=
literal|3
expr_stmt|;
break|break;
case|case
literal|'4'
case|:
comment|/* align to quadword boundary */
name|flags
operator||=
name|IMAGE_SCN_ALIGN_16BYTES
expr_stmt|;
name|align
operator|=
literal|4
expr_stmt|;
break|break;
case|case
literal|'5'
case|:
comment|/* align to 32 byte boundary */
name|flags
operator||=
name|IMAGE_SCN_ALIGN_32BYTES
expr_stmt|;
name|align
operator|=
literal|5
expr_stmt|;
break|break;
case|case
literal|'6'
case|:
comment|/* align to 64 byte boundary */
name|flags
operator||=
name|IMAGE_SCN_ALIGN_64BYTES
expr_stmt|;
name|align
operator|=
literal|6
expr_stmt|;
break|break;
default|default:
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"unknown section attribute '%c'"
argument_list|)
argument_list|,
operator|*
name|input_line_pointer
argument_list|)
expr_stmt|;
break|break;
block|}
operator|++
name|input_line_pointer
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|'"'
condition|)
operator|++
name|input_line_pointer
expr_stmt|;
block|}
block|}
name|sec
operator|=
name|subseg_new
argument_list|(
name|name
argument_list|,
operator|(
name|subsegT
operator|)
name|exp
argument_list|)
expr_stmt|;
name|ppc_set_current_section
argument_list|(
name|sec
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|!=
name|SEC_NO_FLAGS
condition|)
block|{
if|if
condition|(
operator|!
name|bfd_set_section_flags
argument_list|(
name|stdoutput
argument_list|,
name|sec
argument_list|,
name|flags
argument_list|)
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"error setting flags for \"%s\": %s"
argument_list|)
argument_list|,
name|bfd_section_name
argument_list|(
name|stdoutput
argument_list|,
name|sec
argument_list|)
argument_list|,
name|bfd_errmsg
argument_list|(
name|bfd_get_error
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|bfd_set_section_alignment
argument_list|(
name|stdoutput
argument_list|,
name|sec
argument_list|,
name|align
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ppc_pe_function
parameter_list|(
name|ignore
parameter_list|)
name|int
name|ignore
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|char
name|endc
decl_stmt|;
name|symbolS
modifier|*
name|ext_sym
decl_stmt|;
name|name
operator|=
name|input_line_pointer
expr_stmt|;
name|endc
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
name|ext_sym
operator|=
name|symbol_find_or_make
argument_list|(
name|name
argument_list|)
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
name|endc
expr_stmt|;
name|S_SET_DATA_TYPE
argument_list|(
name|ext_sym
argument_list|,
name|DT_FCN
operator|<<
name|N_BTSHFT
argument_list|)
expr_stmt|;
name|SF_SET_FUNCTION
argument_list|(
name|ext_sym
argument_list|)
expr_stmt|;
name|SF_SET_PROCESS
argument_list|(
name|ext_sym
argument_list|)
expr_stmt|;
name|coff_add_linesym
argument_list|(
name|ext_sym
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ppc_pe_tocd
parameter_list|(
name|ignore
parameter_list|)
name|int
name|ignore
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
if|if
condition|(
name|tocdata_section
operator|==
literal|0
condition|)
block|{
name|tocdata_section
operator|=
name|subseg_new
argument_list|(
literal|".tocd"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* FIXME: section flags won't work */
name|bfd_set_section_flags
argument_list|(
name|stdoutput
argument_list|,
name|tocdata_section
argument_list|,
operator|(
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_RELOC
operator||
name|SEC_READONLY
operator||
name|SEC_DATA
operator|)
argument_list|)
expr_stmt|;
name|bfd_set_section_alignment
argument_list|(
name|stdoutput
argument_list|,
name|tocdata_section
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rdata_section
operator|=
name|subseg_new
argument_list|(
literal|".tocd"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|ppc_set_current_section
argument_list|(
name|tocdata_section
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Don't adjust TOC relocs to use the section symbol.  */
end_comment

begin_function
name|int
name|ppc_pe_fix_adjustable
parameter_list|(
name|fix
parameter_list|)
name|fixS
modifier|*
name|fix
decl_stmt|;
block|{
return|return
name|fix
operator|->
name|fx_r_type
operator|!=
name|BFD_RELOC_PPC_TOC16
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|OBJ_XCOFF
end_ifdef

begin_comment
comment|/* XCOFF specific symbol and file handling.  */
end_comment

begin_comment
comment|/* Canonicalize the symbol name.  We use the to force the suffix, if    any, to use square brackets, and to be in upper case.  */
end_comment

begin_function
name|char
modifier|*
name|ppc_canonicalize_symbol_name
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|char
modifier|*
name|s
decl_stmt|;
if|if
condition|(
name|ppc_stab_symbol
condition|)
return|return
name|name
return|;
for|for
control|(
name|s
operator|=
name|name
init|;
operator|*
name|s
operator|!=
literal|'\0'
operator|&&
operator|*
name|s
operator|!=
literal|'{'
operator|&&
operator|*
name|s
operator|!=
literal|'['
condition|;
name|s
operator|++
control|)
empty_stmt|;
if|if
condition|(
operator|*
name|s
operator|!=
literal|'\0'
condition|)
block|{
name|char
name|brac
decl_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'['
condition|)
name|brac
operator|=
literal|']'
expr_stmt|;
else|else
block|{
operator|*
name|s
operator|=
literal|'['
expr_stmt|;
name|brac
operator|=
literal|'}'
expr_stmt|;
block|}
for|for
control|(
name|s
operator|++
init|;
operator|*
name|s
operator|!=
literal|'\0'
operator|&&
operator|*
name|s
operator|!=
name|brac
condition|;
name|s
operator|++
control|)
if|if
condition|(
name|islower
argument_list|(
operator|*
name|s
argument_list|)
condition|)
operator|*
name|s
operator|=
name|toupper
argument_list|(
operator|*
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'\0'
operator|||
name|s
index|[
literal|1
index|]
operator|!=
literal|'\0'
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"bad symbol suffix"
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|s
operator|=
literal|']'
expr_stmt|;
block|}
return|return
name|name
return|;
block|}
end_function

begin_comment
comment|/* Set the class of a symbol based on the suffix, if any.  This is    called whenever a new symbol is created.  */
end_comment

begin_function
name|void
name|ppc_symbol_new_hook
parameter_list|(
name|sym
parameter_list|)
name|symbolS
modifier|*
name|sym
decl_stmt|;
block|{
name|struct
name|ppc_tc_sy
modifier|*
name|tc
decl_stmt|;
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
name|tc
operator|=
name|symbol_get_tc
argument_list|(
name|sym
argument_list|)
expr_stmt|;
name|tc
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|tc
operator|->
name|output
operator|=
literal|0
expr_stmt|;
name|tc
operator|->
name|class
operator|=
operator|-
literal|1
expr_stmt|;
name|tc
operator|->
name|real_name
operator|=
name|NULL
expr_stmt|;
name|tc
operator|->
name|subseg
operator|=
literal|0
expr_stmt|;
name|tc
operator|->
name|align
operator|=
literal|0
expr_stmt|;
name|tc
operator|->
name|size
operator|=
name|NULL
expr_stmt|;
name|tc
operator|->
name|within
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|ppc_stab_symbol
condition|)
return|return;
name|s
operator|=
name|strchr
argument_list|(
name|S_GET_NAME
argument_list|(
name|sym
argument_list|)
argument_list|,
literal|'['
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
condition|)
block|{
comment|/* There is no suffix.  */
return|return;
block|}
operator|++
name|s
expr_stmt|;
switch|switch
condition|(
name|s
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|'B'
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|s
argument_list|,
literal|"BS]"
argument_list|)
operator|==
literal|0
condition|)
name|tc
operator|->
name|class
operator|=
name|XMC_BS
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|s
argument_list|,
literal|"DB]"
argument_list|)
operator|==
literal|0
condition|)
name|tc
operator|->
name|class
operator|=
name|XMC_DB
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|s
argument_list|,
literal|"DS]"
argument_list|)
operator|==
literal|0
condition|)
name|tc
operator|->
name|class
operator|=
name|XMC_DS
expr_stmt|;
break|break;
case|case
literal|'G'
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|s
argument_list|,
literal|"GL]"
argument_list|)
operator|==
literal|0
condition|)
name|tc
operator|->
name|class
operator|=
name|XMC_GL
expr_stmt|;
break|break;
case|case
literal|'P'
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|s
argument_list|,
literal|"PR]"
argument_list|)
operator|==
literal|0
condition|)
name|tc
operator|->
name|class
operator|=
name|XMC_PR
expr_stmt|;
break|break;
case|case
literal|'R'
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|s
argument_list|,
literal|"RO]"
argument_list|)
operator|==
literal|0
condition|)
name|tc
operator|->
name|class
operator|=
name|XMC_RO
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|s
argument_list|,
literal|"RW]"
argument_list|)
operator|==
literal|0
condition|)
name|tc
operator|->
name|class
operator|=
name|XMC_RW
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|s
argument_list|,
literal|"SV]"
argument_list|)
operator|==
literal|0
condition|)
name|tc
operator|->
name|class
operator|=
name|XMC_SV
expr_stmt|;
break|break;
case|case
literal|'T'
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|s
argument_list|,
literal|"TC]"
argument_list|)
operator|==
literal|0
condition|)
name|tc
operator|->
name|class
operator|=
name|XMC_TC
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|s
argument_list|,
literal|"TI]"
argument_list|)
operator|==
literal|0
condition|)
name|tc
operator|->
name|class
operator|=
name|XMC_TI
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|s
argument_list|,
literal|"TB]"
argument_list|)
operator|==
literal|0
condition|)
name|tc
operator|->
name|class
operator|=
name|XMC_TB
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|s
argument_list|,
literal|"TC0]"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|s
argument_list|,
literal|"T0]"
argument_list|)
operator|==
literal|0
condition|)
name|tc
operator|->
name|class
operator|=
name|XMC_TC0
expr_stmt|;
break|break;
case|case
literal|'U'
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|s
argument_list|,
literal|"UA]"
argument_list|)
operator|==
literal|0
condition|)
name|tc
operator|->
name|class
operator|=
name|XMC_UA
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|s
argument_list|,
literal|"UC]"
argument_list|)
operator|==
literal|0
condition|)
name|tc
operator|->
name|class
operator|=
name|XMC_UC
expr_stmt|;
break|break;
case|case
literal|'X'
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|s
argument_list|,
literal|"XO]"
argument_list|)
operator|==
literal|0
condition|)
name|tc
operator|->
name|class
operator|=
name|XMC_XO
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|tc
operator|->
name|class
operator|==
operator|-
literal|1
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Unrecognized symbol suffix"
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set the class of a label based on where it is defined.  This    handles symbols without suffixes.  Also, move the symbol so that it    follows the csect symbol.  */
end_comment

begin_function
name|void
name|ppc_frob_label
parameter_list|(
name|sym
parameter_list|)
name|symbolS
modifier|*
name|sym
decl_stmt|;
block|{
if|if
condition|(
name|ppc_current_csect
operator|!=
operator|(
name|symbolS
operator|*
operator|)
name|NULL
condition|)
block|{
if|if
condition|(
name|symbol_get_tc
argument_list|(
name|sym
argument_list|)
operator|->
name|class
operator|==
operator|-
literal|1
condition|)
name|symbol_get_tc
argument_list|(
name|sym
argument_list|)
operator|->
name|class
operator|=
name|symbol_get_tc
argument_list|(
name|ppc_current_csect
argument_list|)
operator|->
name|class
expr_stmt|;
name|symbol_remove
argument_list|(
name|sym
argument_list|,
operator|&
name|symbol_rootP
argument_list|,
operator|&
name|symbol_lastP
argument_list|)
expr_stmt|;
name|symbol_append
argument_list|(
name|sym
argument_list|,
name|symbol_get_tc
argument_list|(
name|ppc_current_csect
argument_list|)
operator|->
name|within
argument_list|,
operator|&
name|symbol_rootP
argument_list|,
operator|&
name|symbol_lastP
argument_list|)
expr_stmt|;
name|symbol_get_tc
argument_list|(
name|ppc_current_csect
argument_list|)
operator|->
name|within
operator|=
name|sym
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* This variable is set by ppc_frob_symbol if any absolute symbols are    seen.  It tells ppc_adjust_symtab whether it needs to look through    the symbols.  */
end_comment

begin_decl_stmt
specifier|static
name|boolean
name|ppc_saw_abs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Change the name of a symbol just before writing it out.  Set the    real name if the .rename pseudo-op was used.  Otherwise, remove any    class suffix.  Return 1 if the symbol should not be included in the    symbol table.  */
end_comment

begin_function
name|int
name|ppc_frob_symbol
parameter_list|(
name|sym
parameter_list|)
name|symbolS
modifier|*
name|sym
decl_stmt|;
block|{
specifier|static
name|symbolS
modifier|*
name|ppc_last_function
decl_stmt|;
specifier|static
name|symbolS
modifier|*
name|set_end
decl_stmt|;
comment|/* Discard symbols that should not be included in the output symbol      table.  */
if|if
condition|(
operator|!
name|symbol_used_in_reloc_p
argument_list|(
name|sym
argument_list|)
operator|&&
operator|(
operator|(
name|symbol_get_bfdsym
argument_list|(
name|sym
argument_list|)
operator|->
name|flags
operator|&
name|BSF_SECTION_SYM
operator|)
operator|!=
literal|0
operator|||
operator|(
operator|!
name|S_IS_EXTERNAL
argument_list|(
name|sym
argument_list|)
operator|&&
operator|!
name|symbol_get_tc
argument_list|(
name|sym
argument_list|)
operator|->
name|output
operator|&&
name|S_GET_STORAGE_CLASS
argument_list|(
name|sym
argument_list|)
operator|!=
name|C_FILE
operator|)
operator|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|symbol_get_tc
argument_list|(
name|sym
argument_list|)
operator|->
name|real_name
operator|!=
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
name|S_SET_NAME
argument_list|(
name|sym
argument_list|,
name|symbol_get_tc
argument_list|(
name|sym
argument_list|)
operator|->
name|real_name
argument_list|)
expr_stmt|;
else|else
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
name|name
operator|=
name|S_GET_NAME
argument_list|(
name|sym
argument_list|)
expr_stmt|;
name|s
operator|=
name|strchr
argument_list|(
name|name
argument_list|,
literal|'['
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
block|{
name|unsigned
name|int
name|len
decl_stmt|;
name|char
modifier|*
name|snew
decl_stmt|;
name|len
operator|=
name|s
operator|-
name|name
expr_stmt|;
name|snew
operator|=
name|xmalloc
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|snew
argument_list|,
name|name
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|snew
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
name|S_SET_NAME
argument_list|(
name|sym
argument_list|,
name|snew
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|set_end
operator|!=
operator|(
name|symbolS
operator|*
operator|)
name|NULL
condition|)
block|{
name|SA_SET_SYM_ENDNDX
argument_list|(
name|set_end
argument_list|,
name|sym
argument_list|)
expr_stmt|;
name|set_end
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|SF_GET_FUNCTION
argument_list|(
name|sym
argument_list|)
condition|)
block|{
if|if
condition|(
name|ppc_last_function
operator|!=
operator|(
name|symbolS
operator|*
operator|)
name|NULL
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"two .function pseudo-ops with no intervening .ef"
argument_list|)
argument_list|)
expr_stmt|;
name|ppc_last_function
operator|=
name|sym
expr_stmt|;
if|if
condition|(
name|symbol_get_tc
argument_list|(
name|sym
argument_list|)
operator|->
name|size
operator|!=
operator|(
name|symbolS
operator|*
operator|)
name|NULL
condition|)
block|{
name|resolve_symbol_value
argument_list|(
name|symbol_get_tc
argument_list|(
name|sym
argument_list|)
operator|->
name|size
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SA_SET_SYM_FSIZE
argument_list|(
name|sym
argument_list|,
operator|(
name|long
operator|)
name|S_GET_VALUE
argument_list|(
name|symbol_get_tc
argument_list|(
name|sym
argument_list|)
operator|->
name|size
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|S_GET_STORAGE_CLASS
argument_list|(
name|sym
argument_list|)
operator|==
name|C_FCN
operator|&&
name|strcmp
argument_list|(
name|S_GET_NAME
argument_list|(
name|sym
argument_list|)
argument_list|,
literal|".ef"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|ppc_last_function
operator|==
operator|(
name|symbolS
operator|*
operator|)
name|NULL
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|".ef with no preceding .function"
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|set_end
operator|=
name|ppc_last_function
expr_stmt|;
name|ppc_last_function
operator|=
name|NULL
expr_stmt|;
comment|/* We don't have a C_EFCN symbol, but we need to force the 	     COFF backend to believe that it has seen one.  */
name|coff_last_function
operator|=
name|NULL
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|S_IS_EXTERNAL
argument_list|(
name|sym
argument_list|)
operator|&&
operator|(
name|symbol_get_bfdsym
argument_list|(
name|sym
argument_list|)
operator|->
name|flags
operator|&
name|BSF_SECTION_SYM
operator|)
operator|==
literal|0
operator|&&
name|S_GET_STORAGE_CLASS
argument_list|(
name|sym
argument_list|)
operator|!=
name|C_FILE
operator|&&
name|S_GET_STORAGE_CLASS
argument_list|(
name|sym
argument_list|)
operator|!=
name|C_FCN
operator|&&
name|S_GET_STORAGE_CLASS
argument_list|(
name|sym
argument_list|)
operator|!=
name|C_BLOCK
operator|&&
name|S_GET_STORAGE_CLASS
argument_list|(
name|sym
argument_list|)
operator|!=
name|C_BSTAT
operator|&&
name|S_GET_STORAGE_CLASS
argument_list|(
name|sym
argument_list|)
operator|!=
name|C_ESTAT
operator|&&
name|S_GET_STORAGE_CLASS
argument_list|(
name|sym
argument_list|)
operator|!=
name|C_BINCL
operator|&&
name|S_GET_STORAGE_CLASS
argument_list|(
name|sym
argument_list|)
operator|!=
name|C_EINCL
operator|&&
name|S_GET_SEGMENT
argument_list|(
name|sym
argument_list|)
operator|!=
name|ppc_coff_debug_section
condition|)
name|S_SET_STORAGE_CLASS
argument_list|(
name|sym
argument_list|,
name|C_HIDEXT
argument_list|)
expr_stmt|;
if|if
condition|(
name|S_GET_STORAGE_CLASS
argument_list|(
name|sym
argument_list|)
operator|==
name|C_EXT
operator|||
name|S_GET_STORAGE_CLASS
argument_list|(
name|sym
argument_list|)
operator|==
name|C_HIDEXT
condition|)
block|{
name|int
name|i
decl_stmt|;
name|union
name|internal_auxent
modifier|*
name|a
decl_stmt|;
comment|/* Create a csect aux.  */
name|i
operator|=
name|S_GET_NUMBER_AUXILIARY
argument_list|(
name|sym
argument_list|)
expr_stmt|;
name|S_SET_NUMBER_AUXILIARY
argument_list|(
name|sym
argument_list|,
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
name|a
operator|=
operator|&
name|coffsymbol
argument_list|(
name|symbol_get_bfdsym
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|->
name|native
index|[
name|i
operator|+
literal|1
index|]
operator|.
name|u
operator|.
name|auxent
expr_stmt|;
if|if
condition|(
name|symbol_get_tc
argument_list|(
name|sym
argument_list|)
operator|->
name|class
operator|==
name|XMC_TC0
condition|)
block|{
comment|/* This is the TOC table.  */
name|know
argument_list|(
name|strcmp
argument_list|(
name|S_GET_NAME
argument_list|(
name|sym
argument_list|)
argument_list|,
literal|"TOC"
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|a
operator|->
name|x_csect
operator|.
name|x_scnlen
operator|.
name|l
operator|=
literal|0
expr_stmt|;
name|a
operator|->
name|x_csect
operator|.
name|x_smtyp
operator|=
operator|(
literal|2
operator|<<
literal|3
operator|)
operator||
name|XTY_SD
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|symbol_get_tc
argument_list|(
name|sym
argument_list|)
operator|->
name|subseg
operator|!=
literal|0
condition|)
block|{
comment|/* This is a csect symbol.  x_scnlen is the size of the 	     csect.  */
if|if
condition|(
name|symbol_get_tc
argument_list|(
name|sym
argument_list|)
operator|->
name|next
operator|==
operator|(
name|symbolS
operator|*
operator|)
name|NULL
condition|)
name|a
operator|->
name|x_csect
operator|.
name|x_scnlen
operator|.
name|l
operator|=
operator|(
name|bfd_section_size
argument_list|(
name|stdoutput
argument_list|,
name|S_GET_SEGMENT
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|-
name|S_GET_VALUE
argument_list|(
name|sym
argument_list|)
operator|)
expr_stmt|;
else|else
block|{
name|resolve_symbol_value
argument_list|(
name|symbol_get_tc
argument_list|(
name|sym
argument_list|)
operator|->
name|next
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|a
operator|->
name|x_csect
operator|.
name|x_scnlen
operator|.
name|l
operator|=
operator|(
name|S_GET_VALUE
argument_list|(
name|symbol_get_tc
argument_list|(
name|sym
argument_list|)
operator|->
name|next
argument_list|)
operator|-
name|S_GET_VALUE
argument_list|(
name|sym
argument_list|)
operator|)
expr_stmt|;
block|}
name|a
operator|->
name|x_csect
operator|.
name|x_smtyp
operator|=
operator|(
name|symbol_get_tc
argument_list|(
name|sym
argument_list|)
operator|->
name|align
operator|<<
literal|3
operator|)
operator||
name|XTY_SD
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|S_GET_SEGMENT
argument_list|(
name|sym
argument_list|)
operator|==
name|bss_section
condition|)
block|{
comment|/* This is a common symbol.  */
name|a
operator|->
name|x_csect
operator|.
name|x_scnlen
operator|.
name|l
operator|=
name|symbol_get_frag
argument_list|(
name|sym
argument_list|)
operator|->
name|fr_offset
expr_stmt|;
name|a
operator|->
name|x_csect
operator|.
name|x_smtyp
operator|=
operator|(
name|symbol_get_tc
argument_list|(
name|sym
argument_list|)
operator|->
name|align
operator|<<
literal|3
operator|)
operator||
name|XTY_CM
expr_stmt|;
if|if
condition|(
name|S_IS_EXTERNAL
argument_list|(
name|sym
argument_list|)
condition|)
name|symbol_get_tc
argument_list|(
name|sym
argument_list|)
operator|->
name|class
operator|=
name|XMC_RW
expr_stmt|;
else|else
name|symbol_get_tc
argument_list|(
name|sym
argument_list|)
operator|->
name|class
operator|=
name|XMC_BS
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|S_GET_SEGMENT
argument_list|(
name|sym
argument_list|)
operator|==
name|absolute_section
condition|)
block|{
comment|/* This is an absolute symbol.  The csect will be created by              ppc_adjust_symtab.  */
name|ppc_saw_abs
operator|=
name|true
expr_stmt|;
name|a
operator|->
name|x_csect
operator|.
name|x_smtyp
operator|=
name|XTY_LD
expr_stmt|;
if|if
condition|(
name|symbol_get_tc
argument_list|(
name|sym
argument_list|)
operator|->
name|class
operator|==
operator|-
literal|1
condition|)
name|symbol_get_tc
argument_list|(
name|sym
argument_list|)
operator|->
name|class
operator|=
name|XMC_XO
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|S_IS_DEFINED
argument_list|(
name|sym
argument_list|)
condition|)
block|{
comment|/* This is an external symbol.  */
name|a
operator|->
name|x_csect
operator|.
name|x_scnlen
operator|.
name|l
operator|=
literal|0
expr_stmt|;
name|a
operator|->
name|x_csect
operator|.
name|x_smtyp
operator|=
name|XTY_ER
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|symbol_get_tc
argument_list|(
name|sym
argument_list|)
operator|->
name|class
operator|==
name|XMC_TC
condition|)
block|{
name|symbolS
modifier|*
name|next
decl_stmt|;
comment|/* This is a TOC definition.  x_scnlen is the size of the 	     TOC entry.  */
name|next
operator|=
name|symbol_next
argument_list|(
name|sym
argument_list|)
expr_stmt|;
while|while
condition|(
name|symbol_get_tc
argument_list|(
name|next
argument_list|)
operator|->
name|class
operator|==
name|XMC_TC0
condition|)
name|next
operator|=
name|symbol_next
argument_list|(
name|next
argument_list|)
expr_stmt|;
if|if
condition|(
name|next
operator|==
operator|(
name|symbolS
operator|*
operator|)
name|NULL
operator|||
name|symbol_get_tc
argument_list|(
name|next
argument_list|)
operator|->
name|class
operator|!=
name|XMC_TC
condition|)
block|{
if|if
condition|(
name|ppc_after_toc_frag
operator|==
operator|(
name|fragS
operator|*
operator|)
name|NULL
condition|)
name|a
operator|->
name|x_csect
operator|.
name|x_scnlen
operator|.
name|l
operator|=
operator|(
name|bfd_section_size
argument_list|(
name|stdoutput
argument_list|,
name|data_section
argument_list|)
operator|-
name|S_GET_VALUE
argument_list|(
name|sym
argument_list|)
operator|)
expr_stmt|;
else|else
name|a
operator|->
name|x_csect
operator|.
name|x_scnlen
operator|.
name|l
operator|=
operator|(
name|ppc_after_toc_frag
operator|->
name|fr_address
operator|-
name|S_GET_VALUE
argument_list|(
name|sym
argument_list|)
operator|)
expr_stmt|;
block|}
else|else
block|{
name|resolve_symbol_value
argument_list|(
name|next
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|a
operator|->
name|x_csect
operator|.
name|x_scnlen
operator|.
name|l
operator|=
operator|(
name|S_GET_VALUE
argument_list|(
name|next
argument_list|)
operator|-
name|S_GET_VALUE
argument_list|(
name|sym
argument_list|)
operator|)
expr_stmt|;
block|}
name|a
operator|->
name|x_csect
operator|.
name|x_smtyp
operator|=
operator|(
literal|2
operator|<<
literal|3
operator|)
operator||
name|XTY_SD
expr_stmt|;
block|}
else|else
block|{
name|symbolS
modifier|*
name|csect
decl_stmt|;
comment|/* This is a normal symbol definition.  x_scnlen is the 	     symbol index of the containing csect.  */
if|if
condition|(
name|S_GET_SEGMENT
argument_list|(
name|sym
argument_list|)
operator|==
name|text_section
condition|)
name|csect
operator|=
name|ppc_text_csects
expr_stmt|;
elseif|else
if|if
condition|(
name|S_GET_SEGMENT
argument_list|(
name|sym
argument_list|)
operator|==
name|data_section
condition|)
name|csect
operator|=
name|ppc_data_csects
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
comment|/* Skip the initial dummy symbol.  */
name|csect
operator|=
name|symbol_get_tc
argument_list|(
name|csect
argument_list|)
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|csect
operator|==
operator|(
name|symbolS
operator|*
operator|)
name|NULL
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"warning: symbol %s has no csect"
argument_list|)
argument_list|,
name|S_GET_NAME
argument_list|(
name|sym
argument_list|)
argument_list|)
expr_stmt|;
name|a
operator|->
name|x_csect
operator|.
name|x_scnlen
operator|.
name|l
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
name|symbol_get_tc
argument_list|(
name|csect
argument_list|)
operator|->
name|next
operator|!=
operator|(
name|symbolS
operator|*
operator|)
name|NULL
condition|)
block|{
name|resolve_symbol_value
argument_list|(
name|symbol_get_tc
argument_list|(
name|csect
argument_list|)
operator|->
name|next
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|S_GET_VALUE
argument_list|(
name|symbol_get_tc
argument_list|(
name|csect
argument_list|)
operator|->
name|next
argument_list|)
operator|>
name|S_GET_VALUE
argument_list|(
name|sym
argument_list|)
condition|)
break|break;
name|csect
operator|=
name|symbol_get_tc
argument_list|(
name|csect
argument_list|)
operator|->
name|next
expr_stmt|;
block|}
name|a
operator|->
name|x_csect
operator|.
name|x_scnlen
operator|.
name|p
operator|=
name|coffsymbol
argument_list|(
name|symbol_get_bfdsym
argument_list|(
name|csect
argument_list|)
argument_list|)
operator|->
name|native
expr_stmt|;
name|coffsymbol
argument_list|(
name|symbol_get_bfdsym
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|->
name|native
index|[
name|i
operator|+
literal|1
index|]
operator|.
name|fix_scnlen
operator|=
literal|1
expr_stmt|;
block|}
name|a
operator|->
name|x_csect
operator|.
name|x_smtyp
operator|=
name|XTY_LD
expr_stmt|;
block|}
name|a
operator|->
name|x_csect
operator|.
name|x_parmhash
operator|=
literal|0
expr_stmt|;
name|a
operator|->
name|x_csect
operator|.
name|x_snhash
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|symbol_get_tc
argument_list|(
name|sym
argument_list|)
operator|->
name|class
operator|==
operator|-
literal|1
condition|)
name|a
operator|->
name|x_csect
operator|.
name|x_smclas
operator|=
name|XMC_PR
expr_stmt|;
else|else
name|a
operator|->
name|x_csect
operator|.
name|x_smclas
operator|=
name|symbol_get_tc
argument_list|(
name|sym
argument_list|)
operator|->
name|class
expr_stmt|;
name|a
operator|->
name|x_csect
operator|.
name|x_stab
operator|=
literal|0
expr_stmt|;
name|a
operator|->
name|x_csect
operator|.
name|x_snstab
operator|=
literal|0
expr_stmt|;
comment|/* Don't let the COFF backend resort these symbols.  */
name|symbol_get_bfdsym
argument_list|(
name|sym
argument_list|)
operator|->
name|flags
operator||=
name|BSF_NOT_AT_END
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|S_GET_STORAGE_CLASS
argument_list|(
name|sym
argument_list|)
operator|==
name|C_BSTAT
condition|)
block|{
comment|/* We want the value to be the symbol index of the referenced 	 csect symbol.  BFD will do that for us if we set the right 	 flags.  */
name|S_SET_VALUE
argument_list|(
name|sym
argument_list|,
operator|(
operator|(
name|valueT
operator|)
name|coffsymbol
argument_list|(
name|symbol_get_bfdsym
argument_list|(
name|symbol_get_tc
argument_list|(
name|sym
argument_list|)
operator|->
name|within
argument_list|)
argument_list|)
operator|->
name|native
operator|)
argument_list|)
expr_stmt|;
name|coffsymbol
argument_list|(
name|symbol_get_bfdsym
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|->
name|native
operator|->
name|fix_value
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|S_GET_STORAGE_CLASS
argument_list|(
name|sym
argument_list|)
operator|==
name|C_STSYM
condition|)
block|{
name|symbolS
modifier|*
name|block
decl_stmt|;
name|symbolS
modifier|*
name|csect
decl_stmt|;
comment|/* The value is the offset from the enclosing csect.  */
name|block
operator|=
name|symbol_get_tc
argument_list|(
name|sym
argument_list|)
operator|->
name|within
expr_stmt|;
name|csect
operator|=
name|symbol_get_tc
argument_list|(
name|block
argument_list|)
operator|->
name|within
expr_stmt|;
name|resolve_symbol_value
argument_list|(
name|csect
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|S_SET_VALUE
argument_list|(
name|sym
argument_list|,
name|S_GET_VALUE
argument_list|(
name|sym
argument_list|)
operator|-
name|S_GET_VALUE
argument_list|(
name|csect
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|S_GET_STORAGE_CLASS
argument_list|(
name|sym
argument_list|)
operator|==
name|C_BINCL
operator|||
name|S_GET_STORAGE_CLASS
argument_list|(
name|sym
argument_list|)
operator|==
name|C_EINCL
condition|)
block|{
comment|/* We want the value to be a file offset into the line numbers.          BFD will do that for us if we set the right flags.  We have          already set the value correctly.  */
name|coffsymbol
argument_list|(
name|symbol_get_bfdsym
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|->
name|native
operator|->
name|fix_line
operator|=
literal|1
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Adjust the symbol table.  This creates csect symbols for all    absolute symbols.  */
end_comment

begin_function
name|void
name|ppc_adjust_symtab
parameter_list|()
block|{
name|symbolS
modifier|*
name|sym
decl_stmt|;
if|if
condition|(
operator|!
name|ppc_saw_abs
condition|)
return|return;
for|for
control|(
name|sym
operator|=
name|symbol_rootP
init|;
name|sym
operator|!=
name|NULL
condition|;
name|sym
operator|=
name|symbol_next
argument_list|(
name|sym
argument_list|)
control|)
block|{
name|symbolS
modifier|*
name|csect
decl_stmt|;
name|int
name|i
decl_stmt|;
name|union
name|internal_auxent
modifier|*
name|a
decl_stmt|;
if|if
condition|(
name|S_GET_SEGMENT
argument_list|(
name|sym
argument_list|)
operator|!=
name|absolute_section
condition|)
continue|continue;
name|csect
operator|=
name|symbol_create
argument_list|(
literal|".abs[XO]"
argument_list|,
name|absolute_section
argument_list|,
name|S_GET_VALUE
argument_list|(
name|sym
argument_list|)
argument_list|,
operator|&
name|zero_address_frag
argument_list|)
expr_stmt|;
name|symbol_get_bfdsym
argument_list|(
name|csect
argument_list|)
operator|->
name|value
operator|=
name|S_GET_VALUE
argument_list|(
name|sym
argument_list|)
expr_stmt|;
name|S_SET_STORAGE_CLASS
argument_list|(
name|csect
argument_list|,
name|C_HIDEXT
argument_list|)
expr_stmt|;
name|i
operator|=
name|S_GET_NUMBER_AUXILIARY
argument_list|(
name|csect
argument_list|)
expr_stmt|;
name|S_SET_NUMBER_AUXILIARY
argument_list|(
name|csect
argument_list|,
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
name|a
operator|=
operator|&
name|coffsymbol
argument_list|(
name|symbol_get_bfdsym
argument_list|(
name|csect
argument_list|)
argument_list|)
operator|->
name|native
index|[
name|i
operator|+
literal|1
index|]
operator|.
name|u
operator|.
name|auxent
expr_stmt|;
name|a
operator|->
name|x_csect
operator|.
name|x_scnlen
operator|.
name|l
operator|=
literal|0
expr_stmt|;
name|a
operator|->
name|x_csect
operator|.
name|x_smtyp
operator|=
name|XTY_SD
expr_stmt|;
name|a
operator|->
name|x_csect
operator|.
name|x_parmhash
operator|=
literal|0
expr_stmt|;
name|a
operator|->
name|x_csect
operator|.
name|x_snhash
operator|=
literal|0
expr_stmt|;
name|a
operator|->
name|x_csect
operator|.
name|x_smclas
operator|=
name|XMC_XO
expr_stmt|;
name|a
operator|->
name|x_csect
operator|.
name|x_stab
operator|=
literal|0
expr_stmt|;
name|a
operator|->
name|x_csect
operator|.
name|x_snstab
operator|=
literal|0
expr_stmt|;
name|symbol_insert
argument_list|(
name|csect
argument_list|,
name|sym
argument_list|,
operator|&
name|symbol_rootP
argument_list|,
operator|&
name|symbol_lastP
argument_list|)
expr_stmt|;
name|i
operator|=
name|S_GET_NUMBER_AUXILIARY
argument_list|(
name|sym
argument_list|)
expr_stmt|;
name|a
operator|=
operator|&
name|coffsymbol
argument_list|(
name|symbol_get_bfdsym
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|->
name|native
index|[
name|i
index|]
operator|.
name|u
operator|.
name|auxent
expr_stmt|;
name|a
operator|->
name|x_csect
operator|.
name|x_scnlen
operator|.
name|p
operator|=
name|coffsymbol
argument_list|(
name|symbol_get_bfdsym
argument_list|(
name|csect
argument_list|)
argument_list|)
operator|->
name|native
expr_stmt|;
name|coffsymbol
argument_list|(
name|symbol_get_bfdsym
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|->
name|native
index|[
name|i
index|]
operator|.
name|fix_scnlen
operator|=
literal|1
expr_stmt|;
block|}
name|ppc_saw_abs
operator|=
name|false
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set the VMA for a section.  This is called on all the sections in    turn.  */
end_comment

begin_function
name|void
name|ppc_frob_section
parameter_list|(
name|sec
parameter_list|)
name|asection
modifier|*
name|sec
decl_stmt|;
block|{
specifier|static
name|bfd_size_type
name|vma
init|=
literal|0
decl_stmt|;
name|bfd_set_section_vma
argument_list|(
name|stdoutput
argument_list|,
name|sec
argument_list|,
name|vma
argument_list|)
expr_stmt|;
name|vma
operator|+=
name|bfd_section_size
argument_list|(
name|stdoutput
argument_list|,
name|sec
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* OBJ_XCOFF */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Turn a string in input_line_pointer into a floating point constant    of type TYPE, and store the appropriate bytes in *LITP.  The number    of LITTLENUMS emitted is stored in *SIZEP.  An error message is    returned, or NULL on OK.  */
end_comment

begin_function
name|char
modifier|*
name|md_atof
parameter_list|(
name|type
parameter_list|,
name|litp
parameter_list|,
name|sizep
parameter_list|)
name|int
name|type
decl_stmt|;
name|char
modifier|*
name|litp
decl_stmt|;
name|int
modifier|*
name|sizep
decl_stmt|;
block|{
name|int
name|prec
decl_stmt|;
name|LITTLENUM_TYPE
name|words
index|[
literal|4
index|]
decl_stmt|;
name|char
modifier|*
name|t
decl_stmt|;
name|int
name|i
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
literal|'f'
case|:
name|prec
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|prec
operator|=
literal|4
expr_stmt|;
break|break;
default|default:
operator|*
name|sizep
operator|=
literal|0
expr_stmt|;
return|return
name|_
argument_list|(
literal|"bad call to md_atof"
argument_list|)
return|;
block|}
name|t
operator|=
name|atof_ieee
argument_list|(
name|input_line_pointer
argument_list|,
name|type
argument_list|,
name|words
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
condition|)
name|input_line_pointer
operator|=
name|t
expr_stmt|;
operator|*
name|sizep
operator|=
name|prec
operator|*
literal|2
expr_stmt|;
if|if
condition|(
name|target_big_endian
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|prec
condition|;
name|i
operator|++
control|)
block|{
name|md_number_to_chars
argument_list|(
name|litp
argument_list|,
operator|(
name|valueT
operator|)
name|words
index|[
name|i
index|]
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|litp
operator|+=
literal|2
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
name|prec
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|md_number_to_chars
argument_list|(
name|litp
argument_list|,
operator|(
name|valueT
operator|)
name|words
index|[
name|i
index|]
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|litp
operator|+=
literal|2
expr_stmt|;
block|}
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Write a value out to the object file, using the appropriate    endianness.  */
end_comment

begin_function
name|void
name|md_number_to_chars
parameter_list|(
name|buf
parameter_list|,
name|val
parameter_list|,
name|n
parameter_list|)
name|char
modifier|*
name|buf
decl_stmt|;
name|valueT
name|val
decl_stmt|;
name|int
name|n
decl_stmt|;
block|{
if|if
condition|(
name|target_big_endian
condition|)
name|number_to_chars_bigendian
argument_list|(
name|buf
argument_list|,
name|val
argument_list|,
name|n
argument_list|)
expr_stmt|;
else|else
name|number_to_chars_littleendian
argument_list|(
name|buf
argument_list|,
name|val
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Align a section (I don't know why this is machine dependent).  */
end_comment

begin_function
name|valueT
name|md_section_align
parameter_list|(
name|seg
parameter_list|,
name|addr
parameter_list|)
name|asection
modifier|*
name|seg
decl_stmt|;
name|valueT
name|addr
decl_stmt|;
block|{
name|int
name|align
init|=
name|bfd_get_section_alignment
argument_list|(
name|stdoutput
argument_list|,
name|seg
argument_list|)
decl_stmt|;
return|return
operator|(
operator|(
name|addr
operator|+
operator|(
literal|1
operator|<<
name|align
operator|)
operator|-
literal|1
operator|)
operator|&
operator|(
operator|-
literal|1
operator|<<
name|align
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* We don't have any form of relaxing.  */
end_comment

begin_function
name|int
name|md_estimate_size_before_relax
parameter_list|(
name|fragp
parameter_list|,
name|seg
parameter_list|)
name|fragS
modifier|*
name|fragp
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|asection
modifier|*
name|seg
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|abort
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Convert a machine dependent frag.  We never generate these.  */
end_comment

begin_function
name|void
name|md_convert_frag
parameter_list|(
name|abfd
parameter_list|,
name|sec
parameter_list|,
name|fragp
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|asection
modifier|*
name|sec
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|fragS
modifier|*
name|fragp
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* We have no need to default values of symbols.  */
end_comment

begin_function
name|symbolS
modifier|*
name|md_undefined_symbol
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Functions concerning relocs.  */
end_comment

begin_comment
comment|/* The location from which a PC relative jump should be calculated,    given a PC relative reloc.  */
end_comment

begin_function
name|long
name|md_pcrel_from_section
parameter_list|(
name|fixp
parameter_list|,
name|sec
parameter_list|)
name|fixS
modifier|*
name|fixp
decl_stmt|;
name|segT
name|sec
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
return|return
name|fixp
operator|->
name|fx_frag
operator|->
name|fr_address
operator|+
name|fixp
operator|->
name|fx_where
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|OBJ_XCOFF
end_ifdef

begin_comment
comment|/* This is called to see whether a fixup should be adjusted to use a    section symbol.  We take the opportunity to change a fixup against    a symbol in the TOC subsegment into a reloc against the    corresponding .tc symbol.  */
end_comment

begin_function
name|int
name|ppc_fix_adjustable
parameter_list|(
name|fix
parameter_list|)
name|fixS
modifier|*
name|fix
decl_stmt|;
block|{
name|valueT
name|val
decl_stmt|;
name|resolve_symbol_value
argument_list|(
name|fix
operator|->
name|fx_addsy
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|val
operator|=
name|S_GET_VALUE
argument_list|(
name|fix
operator|->
name|fx_addsy
argument_list|)
expr_stmt|;
if|if
condition|(
name|ppc_toc_csect
operator|!=
operator|(
name|symbolS
operator|*
operator|)
name|NULL
operator|&&
name|fix
operator|->
name|fx_addsy
operator|!=
operator|(
name|symbolS
operator|*
operator|)
name|NULL
operator|&&
name|fix
operator|->
name|fx_addsy
operator|!=
name|ppc_toc_csect
operator|&&
name|S_GET_SEGMENT
argument_list|(
name|fix
operator|->
name|fx_addsy
argument_list|)
operator|==
name|data_section
operator|&&
name|val
operator|>=
name|ppc_toc_frag
operator|->
name|fr_address
operator|&&
operator|(
name|ppc_after_toc_frag
operator|==
operator|(
name|fragS
operator|*
operator|)
name|NULL
operator|||
name|val
operator|<
name|ppc_after_toc_frag
operator|->
name|fr_address
operator|)
condition|)
block|{
name|symbolS
modifier|*
name|sy
decl_stmt|;
for|for
control|(
name|sy
operator|=
name|symbol_next
argument_list|(
name|ppc_toc_csect
argument_list|)
init|;
name|sy
operator|!=
operator|(
name|symbolS
operator|*
operator|)
name|NULL
condition|;
name|sy
operator|=
name|symbol_next
argument_list|(
name|sy
argument_list|)
control|)
block|{
if|if
condition|(
name|symbol_get_tc
argument_list|(
name|sy
argument_list|)
operator|->
name|class
operator|==
name|XMC_TC0
condition|)
continue|continue;
if|if
condition|(
name|symbol_get_tc
argument_list|(
name|sy
argument_list|)
operator|->
name|class
operator|!=
name|XMC_TC
condition|)
break|break;
name|resolve_symbol_value
argument_list|(
name|sy
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|==
name|S_GET_VALUE
argument_list|(
name|sy
argument_list|)
condition|)
block|{
name|fix
operator|->
name|fx_addsy
operator|=
name|sy
expr_stmt|;
name|fix
operator|->
name|fx_addnumber
operator|=
name|val
operator|-
name|ppc_toc_frag
operator|->
name|fr_address
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
name|as_bad_where
argument_list|(
name|fix
operator|->
name|fx_file
argument_list|,
name|fix
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"symbol in .toc does not match any .tc"
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Possibly adjust the reloc to be against the csect.  */
if|if
condition|(
name|fix
operator|->
name|fx_addsy
operator|!=
operator|(
name|symbolS
operator|*
operator|)
name|NULL
operator|&&
name|symbol_get_tc
argument_list|(
name|fix
operator|->
name|fx_addsy
argument_list|)
operator|->
name|subseg
operator|==
literal|0
operator|&&
name|symbol_get_tc
argument_list|(
name|fix
operator|->
name|fx_addsy
argument_list|)
operator|->
name|class
operator|!=
name|XMC_TC0
operator|&&
name|symbol_get_tc
argument_list|(
name|fix
operator|->
name|fx_addsy
argument_list|)
operator|->
name|class
operator|!=
name|XMC_TC
operator|&&
name|S_GET_SEGMENT
argument_list|(
name|fix
operator|->
name|fx_addsy
argument_list|)
operator|!=
name|bss_section
comment|/* Don't adjust if this is a reloc in the toc section.  */
operator|&&
operator|(
name|S_GET_SEGMENT
argument_list|(
name|fix
operator|->
name|fx_addsy
argument_list|)
operator|!=
name|data_section
operator|||
name|ppc_toc_csect
operator|==
name|NULL
operator|||
name|val
operator|<
name|ppc_toc_frag
operator|->
name|fr_address
operator|||
operator|(
name|ppc_after_toc_frag
operator|!=
name|NULL
operator|&&
name|val
operator|>=
name|ppc_after_toc_frag
operator|->
name|fr_address
operator|)
operator|)
condition|)
block|{
name|symbolS
modifier|*
name|csect
decl_stmt|;
if|if
condition|(
name|S_GET_SEGMENT
argument_list|(
name|fix
operator|->
name|fx_addsy
argument_list|)
operator|==
name|text_section
condition|)
name|csect
operator|=
name|ppc_text_csects
expr_stmt|;
elseif|else
if|if
condition|(
name|S_GET_SEGMENT
argument_list|(
name|fix
operator|->
name|fx_addsy
argument_list|)
operator|==
name|data_section
condition|)
name|csect
operator|=
name|ppc_data_csects
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
comment|/* Skip the initial dummy symbol.  */
name|csect
operator|=
name|symbol_get_tc
argument_list|(
name|csect
argument_list|)
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|csect
operator|!=
operator|(
name|symbolS
operator|*
operator|)
name|NULL
condition|)
block|{
while|while
condition|(
name|symbol_get_tc
argument_list|(
name|csect
argument_list|)
operator|->
name|next
operator|!=
operator|(
name|symbolS
operator|*
operator|)
name|NULL
operator|&&
operator|(
name|symbol_get_frag
argument_list|(
name|symbol_get_tc
argument_list|(
name|csect
argument_list|)
operator|->
name|next
argument_list|)
operator|->
name|fr_address
operator|<=
name|val
operator|)
condition|)
block|{
comment|/* If the csect address equals the symbol value, then we                  have to look through the full symbol table to see                  whether this is the csect we want.  Note that we will                  only get here if the csect has zero length.  */
if|if
condition|(
operator|(
name|symbol_get_frag
argument_list|(
name|csect
argument_list|)
operator|->
name|fr_address
operator|==
name|val
operator|)
operator|&&
name|S_GET_VALUE
argument_list|(
name|csect
argument_list|)
operator|==
name|S_GET_VALUE
argument_list|(
name|fix
operator|->
name|fx_addsy
argument_list|)
condition|)
block|{
name|symbolS
modifier|*
name|scan
decl_stmt|;
for|for
control|(
name|scan
operator|=
name|symbol_next
argument_list|(
name|csect
argument_list|)
init|;
name|scan
operator|!=
name|NULL
condition|;
name|scan
operator|=
name|symbol_next
argument_list|(
name|scan
argument_list|)
control|)
block|{
if|if
condition|(
name|symbol_get_tc
argument_list|(
name|scan
argument_list|)
operator|->
name|subseg
operator|!=
literal|0
condition|)
break|break;
if|if
condition|(
name|scan
operator|==
name|fix
operator|->
name|fx_addsy
condition|)
break|break;
block|}
comment|/* If we found the symbol before the next csect                      symbol, then this is the csect we want.  */
if|if
condition|(
name|scan
operator|==
name|fix
operator|->
name|fx_addsy
condition|)
break|break;
block|}
name|csect
operator|=
name|symbol_get_tc
argument_list|(
name|csect
argument_list|)
operator|->
name|next
expr_stmt|;
block|}
name|fix
operator|->
name|fx_offset
operator|+=
operator|(
name|S_GET_VALUE
argument_list|(
name|fix
operator|->
name|fx_addsy
argument_list|)
operator|-
name|symbol_get_frag
argument_list|(
name|csect
argument_list|)
operator|->
name|fr_address
operator|)
expr_stmt|;
name|fix
operator|->
name|fx_addsy
operator|=
name|csect
expr_stmt|;
block|}
block|}
comment|/* Adjust a reloc against a .lcomm symbol to be against the base      .lcomm.  */
if|if
condition|(
name|fix
operator|->
name|fx_addsy
operator|!=
operator|(
name|symbolS
operator|*
operator|)
name|NULL
operator|&&
name|S_GET_SEGMENT
argument_list|(
name|fix
operator|->
name|fx_addsy
argument_list|)
operator|==
name|bss_section
operator|&&
operator|!
name|S_IS_EXTERNAL
argument_list|(
name|fix
operator|->
name|fx_addsy
argument_list|)
condition|)
block|{
name|resolve_symbol_value
argument_list|(
name|symbol_get_frag
argument_list|(
name|fix
operator|->
name|fx_addsy
argument_list|)
operator|->
name|fr_symbol
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|fix
operator|->
name|fx_offset
operator|+=
operator|(
name|S_GET_VALUE
argument_list|(
name|fix
operator|->
name|fx_addsy
argument_list|)
operator|-
name|S_GET_VALUE
argument_list|(
name|symbol_get_frag
argument_list|(
name|fix
operator|->
name|fx_addsy
argument_list|)
operator|->
name|fr_symbol
argument_list|)
operator|)
expr_stmt|;
name|fix
operator|->
name|fx_addsy
operator|=
name|symbol_get_frag
argument_list|(
name|fix
operator|->
name|fx_addsy
argument_list|)
operator|->
name|fr_symbol
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* A reloc from one csect to another must be kept.  The assembler    will, of course, keep relocs between sections, and it will keep    absolute relocs, but we need to force it to keep PC relative relocs    between two csects in the same section.  */
end_comment

begin_function
name|int
name|ppc_force_relocation
parameter_list|(
name|fix
parameter_list|)
name|fixS
modifier|*
name|fix
decl_stmt|;
block|{
comment|/* At this point fix->fx_addsy should already have been converted to      a csect symbol.  If the csect does not include the fragment, then      we need to force the relocation.  */
if|if
condition|(
name|fix
operator|->
name|fx_pcrel
operator|&&
name|fix
operator|->
name|fx_addsy
operator|!=
name|NULL
operator|&&
name|symbol_get_tc
argument_list|(
name|fix
operator|->
name|fx_addsy
argument_list|)
operator|->
name|subseg
operator|!=
literal|0
operator|&&
operator|(
operator|(
name|symbol_get_frag
argument_list|(
name|fix
operator|->
name|fx_addsy
argument_list|)
operator|->
name|fr_address
operator|>
name|fix
operator|->
name|fx_frag
operator|->
name|fr_address
operator|)
operator|||
operator|(
name|symbol_get_tc
argument_list|(
name|fix
operator|->
name|fx_addsy
argument_list|)
operator|->
name|next
operator|!=
name|NULL
operator|&&
operator|(
name|symbol_get_frag
argument_list|(
name|symbol_get_tc
argument_list|(
name|fix
operator|->
name|fx_addsy
argument_list|)
operator|->
name|next
argument_list|)
operator|->
name|fr_address
operator|<=
name|fix
operator|->
name|fx_frag
operator|->
name|fr_address
operator|)
operator|)
operator|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* OBJ_XCOFF */
end_comment

begin_comment
comment|/* See whether a symbol is in the TOC section.  */
end_comment

begin_function
specifier|static
name|int
name|ppc_is_toc_sym
parameter_list|(
name|sym
parameter_list|)
name|symbolS
modifier|*
name|sym
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|OBJ_XCOFF
return|return
name|symbol_get_tc
argument_list|(
name|sym
argument_list|)
operator|->
name|class
operator|==
name|XMC_TC
return|;
else|#
directive|else
return|return
name|strcmp
argument_list|(
name|segment_name
argument_list|(
name|S_GET_SEGMENT
argument_list|(
name|sym
argument_list|)
argument_list|)
argument_list|,
literal|".got"
argument_list|)
operator|==
literal|0
return|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Apply a fixup to the object code.  This is called for all the    fixups we generated by the call to fix_new_exp, above.  In the call    above we used a reloc code which was the largest legal reloc code    plus the operand index.  Here we undo that to recover the operand    index.  At this point all symbol values should be fully resolved,    and we attempt to completely resolve the reloc.  If we can not do    that, we determine the correct reloc code and put it back in the    fixup.  */
end_comment

begin_function
name|int
name|md_apply_fix3
parameter_list|(
name|fixp
parameter_list|,
name|valuep
parameter_list|,
name|seg
parameter_list|)
name|fixS
modifier|*
name|fixp
decl_stmt|;
name|valueT
modifier|*
name|valuep
decl_stmt|;
name|segT
name|seg
decl_stmt|;
block|{
name|valueT
name|value
decl_stmt|;
ifdef|#
directive|ifdef
name|OBJ_ELF
name|value
operator|=
operator|*
name|valuep
expr_stmt|;
if|if
condition|(
name|fixp
operator|->
name|fx_addsy
operator|!=
name|NULL
condition|)
block|{
comment|/* `*valuep' may contain the value of the symbol on which the reloc 	 will be based; we have to remove it.  */
if|if
condition|(
name|symbol_used_in_reloc_p
argument_list|(
name|fixp
operator|->
name|fx_addsy
argument_list|)
operator|&&
name|S_GET_SEGMENT
argument_list|(
name|fixp
operator|->
name|fx_addsy
argument_list|)
operator|!=
name|absolute_section
operator|&&
name|S_GET_SEGMENT
argument_list|(
name|fixp
operator|->
name|fx_addsy
argument_list|)
operator|!=
name|undefined_section
operator|&&
operator|!
name|bfd_is_com_section
argument_list|(
name|S_GET_SEGMENT
argument_list|(
name|fixp
operator|->
name|fx_addsy
argument_list|)
argument_list|)
condition|)
name|value
operator|-=
name|S_GET_VALUE
argument_list|(
name|fixp
operator|->
name|fx_addsy
argument_list|)
expr_stmt|;
comment|/* FIXME: Why '+'?  Better yet, what exactly is '*valuep' 	 supposed to be?  I think this is related to various similar 	 FIXMEs in tc-i386.c and tc-sparc.c.  */
if|if
condition|(
name|fixp
operator|->
name|fx_pcrel
condition|)
name|value
operator|+=
name|fixp
operator|->
name|fx_frag
operator|->
name|fr_address
operator|+
name|fixp
operator|->
name|fx_where
expr_stmt|;
block|}
else|else
block|{
name|fixp
operator|->
name|fx_done
operator|=
literal|1
expr_stmt|;
block|}
else|#
directive|else
comment|/* FIXME FIXME FIXME: The value we are passed in *valuep includes      the symbol values.  Since we are using BFD_ASSEMBLER, if we are      doing this relocation the code in write.c is going to call      bfd_install_relocation, which is also going to use the symbol      value.  That means that if the reloc is fully resolved we want to      use *valuep since bfd_install_relocation is not being used.      However, if the reloc is not fully resolved we do not want to use      *valuep, and must use fx_offset instead.  However, if the reloc      is PC relative, we do want to use *valuep since it includes the      result of md_pcrel_from.  This is confusing.  */
if|if
condition|(
name|fixp
operator|->
name|fx_addsy
operator|==
operator|(
name|symbolS
operator|*
operator|)
name|NULL
condition|)
block|{
name|value
operator|=
operator|*
name|valuep
expr_stmt|;
name|fixp
operator|->
name|fx_done
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fixp
operator|->
name|fx_pcrel
condition|)
name|value
operator|=
operator|*
name|valuep
expr_stmt|;
else|else
block|{
name|value
operator|=
name|fixp
operator|->
name|fx_offset
expr_stmt|;
if|if
condition|(
name|fixp
operator|->
name|fx_subsy
operator|!=
operator|(
name|symbolS
operator|*
operator|)
name|NULL
condition|)
block|{
if|if
condition|(
name|S_GET_SEGMENT
argument_list|(
name|fixp
operator|->
name|fx_subsy
argument_list|)
operator|==
name|absolute_section
condition|)
name|value
operator|-=
name|S_GET_VALUE
argument_list|(
name|fixp
operator|->
name|fx_subsy
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* We can't actually support subtracting a symbol.  */
name|as_bad_where
argument_list|(
name|fixp
operator|->
name|fx_file
argument_list|,
name|fixp
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"expression too complex"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
endif|#
directive|endif
if|if
condition|(
operator|(
name|int
operator|)
name|fixp
operator|->
name|fx_r_type
operator|>=
operator|(
name|int
operator|)
name|BFD_RELOC_UNUSED
condition|)
block|{
name|int
name|opindex
decl_stmt|;
specifier|const
name|struct
name|powerpc_operand
modifier|*
name|operand
decl_stmt|;
name|char
modifier|*
name|where
decl_stmt|;
name|unsigned
name|long
name|insn
decl_stmt|;
name|opindex
operator|=
operator|(
name|int
operator|)
name|fixp
operator|->
name|fx_r_type
operator|-
operator|(
name|int
operator|)
name|BFD_RELOC_UNUSED
expr_stmt|;
name|operand
operator|=
operator|&
name|powerpc_operands
index|[
name|opindex
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|OBJ_XCOFF
comment|/* It appears that an instruction like 	     l 9,LC..1(30) 	 when LC..1 is not a TOC symbol does not generate a reloc.  It 	 uses the offset of LC..1 within its csect.  However, .long 	 LC..1 will generate a reloc.  I can't find any documentation 	 on how these cases are to be distinguished, so this is a wild 	 guess.  These cases are generated by gcc -mminimal-toc.  */
if|if
condition|(
operator|(
name|operand
operator|->
name|flags
operator|&
name|PPC_OPERAND_PARENS
operator|)
operator|!=
literal|0
operator|&&
name|operand
operator|->
name|bits
operator|==
literal|16
operator|&&
name|operand
operator|->
name|shift
operator|==
literal|0
operator|&&
name|operand
operator|->
name|insert
operator|==
name|NULL
operator|&&
name|fixp
operator|->
name|fx_addsy
operator|!=
name|NULL
operator|&&
name|symbol_get_tc
argument_list|(
name|fixp
operator|->
name|fx_addsy
argument_list|)
operator|->
name|subseg
operator|!=
literal|0
operator|&&
name|symbol_get_tc
argument_list|(
name|fixp
operator|->
name|fx_addsy
argument_list|)
operator|->
name|class
operator|!=
name|XMC_TC
operator|&&
name|symbol_get_tc
argument_list|(
name|fixp
operator|->
name|fx_addsy
argument_list|)
operator|->
name|class
operator|!=
name|XMC_TC0
operator|&&
name|S_GET_SEGMENT
argument_list|(
name|fixp
operator|->
name|fx_addsy
argument_list|)
operator|!=
name|bss_section
condition|)
block|{
name|value
operator|=
name|fixp
operator|->
name|fx_offset
expr_stmt|;
name|fixp
operator|->
name|fx_done
operator|=
literal|1
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Fetch the instruction, insert the fully resolved operand 	 value, and stuff the instruction back again.  */
name|where
operator|=
name|fixp
operator|->
name|fx_frag
operator|->
name|fr_literal
operator|+
name|fixp
operator|->
name|fx_where
expr_stmt|;
if|if
condition|(
name|target_big_endian
condition|)
name|insn
operator|=
name|bfd_getb32
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|where
argument_list|)
expr_stmt|;
else|else
name|insn
operator|=
name|bfd_getl32
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|where
argument_list|)
expr_stmt|;
name|insn
operator|=
name|ppc_insert_operand
argument_list|(
name|insn
argument_list|,
name|operand
argument_list|,
operator|(
name|offsetT
operator|)
name|value
argument_list|,
name|fixp
operator|->
name|fx_file
argument_list|,
name|fixp
operator|->
name|fx_line
argument_list|)
expr_stmt|;
if|if
condition|(
name|target_big_endian
condition|)
name|bfd_putb32
argument_list|(
operator|(
name|bfd_vma
operator|)
name|insn
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|where
argument_list|)
expr_stmt|;
else|else
name|bfd_putl32
argument_list|(
operator|(
name|bfd_vma
operator|)
name|insn
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|where
argument_list|)
expr_stmt|;
if|if
condition|(
name|fixp
operator|->
name|fx_done
condition|)
block|{
comment|/* Nothing else to do here.  */
return|return
literal|1
return|;
block|}
comment|/* Determine a BFD reloc value based on the operand information. 	 We are only prepared to turn a few of the operands into 	 relocs. 	 FIXME: We need to handle the DS field at the very least. 	 FIXME: Selecting the reloc type is a bit haphazard; perhaps 	 there should be a new field in the operand table.  */
if|if
condition|(
operator|(
name|operand
operator|->
name|flags
operator|&
name|PPC_OPERAND_RELATIVE
operator|)
operator|!=
literal|0
operator|&&
name|operand
operator|->
name|bits
operator|==
literal|26
operator|&&
name|operand
operator|->
name|shift
operator|==
literal|0
condition|)
name|fixp
operator|->
name|fx_r_type
operator|=
name|BFD_RELOC_PPC_B26
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|operand
operator|->
name|flags
operator|&
name|PPC_OPERAND_RELATIVE
operator|)
operator|!=
literal|0
operator|&&
name|operand
operator|->
name|bits
operator|==
literal|16
operator|&&
name|operand
operator|->
name|shift
operator|==
literal|0
condition|)
name|fixp
operator|->
name|fx_r_type
operator|=
name|BFD_RELOC_PPC_B16
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|operand
operator|->
name|flags
operator|&
name|PPC_OPERAND_ABSOLUTE
operator|)
operator|!=
literal|0
operator|&&
name|operand
operator|->
name|bits
operator|==
literal|26
operator|&&
name|operand
operator|->
name|shift
operator|==
literal|0
condition|)
name|fixp
operator|->
name|fx_r_type
operator|=
name|BFD_RELOC_PPC_BA26
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|operand
operator|->
name|flags
operator|&
name|PPC_OPERAND_ABSOLUTE
operator|)
operator|!=
literal|0
operator|&&
name|operand
operator|->
name|bits
operator|==
literal|16
operator|&&
name|operand
operator|->
name|shift
operator|==
literal|0
condition|)
name|fixp
operator|->
name|fx_r_type
operator|=
name|BFD_RELOC_PPC_BA16
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|operand
operator|->
name|flags
operator|&
name|PPC_OPERAND_PARENS
operator|)
operator|!=
literal|0
operator|&&
name|operand
operator|->
name|bits
operator|==
literal|16
operator|&&
name|operand
operator|->
name|shift
operator|==
literal|0
operator|&&
name|fixp
operator|->
name|fx_addsy
operator|!=
name|NULL
operator|&&
name|ppc_is_toc_sym
argument_list|(
name|fixp
operator|->
name|fx_addsy
argument_list|)
condition|)
block|{
name|fixp
operator|->
name|fx_size
operator|=
literal|2
expr_stmt|;
if|if
condition|(
name|target_big_endian
condition|)
name|fixp
operator|->
name|fx_where
operator|+=
literal|2
expr_stmt|;
name|fixp
operator|->
name|fx_r_type
operator|=
name|BFD_RELOC_PPC_TOC16
expr_stmt|;
block|}
else|else
block|{
name|char
modifier|*
name|sfile
decl_stmt|;
name|unsigned
name|int
name|sline
decl_stmt|;
comment|/* Use expr_symbol_where to see if this is an expression              symbol.  */
if|if
condition|(
name|expr_symbol_where
argument_list|(
name|fixp
operator|->
name|fx_addsy
argument_list|,
operator|&
name|sfile
argument_list|,
operator|&
name|sline
argument_list|)
condition|)
name|as_bad_where
argument_list|(
name|fixp
operator|->
name|fx_file
argument_list|,
name|fixp
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"unresolved expression that must be resolved"
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|as_bad_where
argument_list|(
name|fixp
operator|->
name|fx_file
argument_list|,
name|fixp
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"unsupported relocation type"
argument_list|)
argument_list|)
expr_stmt|;
name|fixp
operator|->
name|fx_done
operator|=
literal|1
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|OBJ_ELF
name|ppc_elf_validate_fix
argument_list|(
name|fixp
argument_list|,
name|seg
argument_list|)
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|fixp
operator|->
name|fx_r_type
condition|)
block|{
case|case
name|BFD_RELOC_32
case|:
case|case
name|BFD_RELOC_CTOR
case|:
if|if
condition|(
name|fixp
operator|->
name|fx_pcrel
condition|)
name|fixp
operator|->
name|fx_r_type
operator|=
name|BFD_RELOC_32_PCREL
expr_stmt|;
comment|/* fall through */
case|case
name|BFD_RELOC_RVA
case|:
case|case
name|BFD_RELOC_32_PCREL
case|:
case|case
name|BFD_RELOC_32_BASEREL
case|:
case|case
name|BFD_RELOC_PPC_EMB_NADDR32
case|:
name|md_number_to_chars
argument_list|(
name|fixp
operator|->
name|fx_frag
operator|->
name|fr_literal
operator|+
name|fixp
operator|->
name|fx_where
argument_list|,
name|value
argument_list|,
literal|4
argument_list|)
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_64
case|:
if|if
condition|(
name|fixp
operator|->
name|fx_pcrel
condition|)
name|fixp
operator|->
name|fx_r_type
operator|=
name|BFD_RELOC_64_PCREL
expr_stmt|;
comment|/* fall through */
case|case
name|BFD_RELOC_64_PCREL
case|:
name|md_number_to_chars
argument_list|(
name|fixp
operator|->
name|fx_frag
operator|->
name|fr_literal
operator|+
name|fixp
operator|->
name|fx_where
argument_list|,
name|value
argument_list|,
literal|8
argument_list|)
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_LO16
case|:
case|case
name|BFD_RELOC_16
case|:
case|case
name|BFD_RELOC_GPREL16
case|:
case|case
name|BFD_RELOC_16_GOT_PCREL
case|:
case|case
name|BFD_RELOC_16_GOTOFF
case|:
case|case
name|BFD_RELOC_LO16_GOTOFF
case|:
case|case
name|BFD_RELOC_HI16_GOTOFF
case|:
case|case
name|BFD_RELOC_HI16_S_GOTOFF
case|:
case|case
name|BFD_RELOC_LO16_BASEREL
case|:
case|case
name|BFD_RELOC_HI16_BASEREL
case|:
case|case
name|BFD_RELOC_HI16_S_BASEREL
case|:
case|case
name|BFD_RELOC_PPC_EMB_NADDR16
case|:
case|case
name|BFD_RELOC_PPC_EMB_NADDR16_LO
case|:
case|case
name|BFD_RELOC_PPC_EMB_NADDR16_HI
case|:
case|case
name|BFD_RELOC_PPC_EMB_NADDR16_HA
case|:
case|case
name|BFD_RELOC_PPC_EMB_SDAI16
case|:
case|case
name|BFD_RELOC_PPC_EMB_SDA2REL
case|:
case|case
name|BFD_RELOC_PPC_EMB_SDA2I16
case|:
case|case
name|BFD_RELOC_PPC_EMB_RELSEC16
case|:
case|case
name|BFD_RELOC_PPC_EMB_RELST_LO
case|:
case|case
name|BFD_RELOC_PPC_EMB_RELST_HI
case|:
case|case
name|BFD_RELOC_PPC_EMB_RELST_HA
case|:
case|case
name|BFD_RELOC_PPC_EMB_RELSDA
case|:
case|case
name|BFD_RELOC_PPC_TOC16
case|:
if|if
condition|(
name|fixp
operator|->
name|fx_pcrel
condition|)
block|{
if|if
condition|(
name|fixp
operator|->
name|fx_addsy
operator|!=
name|NULL
condition|)
name|as_bad_where
argument_list|(
name|fixp
operator|->
name|fx_file
argument_list|,
name|fixp
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"cannot emit PC relative %s relocation against %s"
argument_list|)
argument_list|,
name|bfd_get_reloc_code_name
argument_list|(
name|fixp
operator|->
name|fx_r_type
argument_list|)
argument_list|,
name|S_GET_NAME
argument_list|(
name|fixp
operator|->
name|fx_addsy
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|as_bad_where
argument_list|(
name|fixp
operator|->
name|fx_file
argument_list|,
name|fixp
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"cannot emit PC relative %s relocation"
argument_list|)
argument_list|,
name|bfd_get_reloc_code_name
argument_list|(
name|fixp
operator|->
name|fx_r_type
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|md_number_to_chars
argument_list|(
name|fixp
operator|->
name|fx_frag
operator|->
name|fr_literal
operator|+
name|fixp
operator|->
name|fx_where
argument_list|,
name|value
argument_list|,
literal|2
argument_list|)
expr_stmt|;
break|break;
comment|/* This case happens when you write, for example, 	     lis %r3,(L1-L2)@ha 	     where L1 and L2 are defined later.  */
case|case
name|BFD_RELOC_HI16
case|:
if|if
condition|(
name|fixp
operator|->
name|fx_pcrel
condition|)
name|abort
argument_list|()
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|fixp
operator|->
name|fx_frag
operator|->
name|fr_literal
operator|+
name|fixp
operator|->
name|fx_where
argument_list|,
name|value
operator|>>
literal|16
argument_list|,
literal|2
argument_list|)
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_HI16_S
case|:
if|if
condition|(
name|fixp
operator|->
name|fx_pcrel
condition|)
name|abort
argument_list|()
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|fixp
operator|->
name|fx_frag
operator|->
name|fr_literal
operator|+
name|fixp
operator|->
name|fx_where
argument_list|,
operator|(
name|value
operator|+
literal|0x8000
operator|)
operator|>>
literal|16
argument_list|,
literal|2
argument_list|)
expr_stmt|;
break|break;
comment|/* Because SDA21 modifies the register field, the size is set to 4 	     bytes, rather than 2, so offset it here appropriately */
case|case
name|BFD_RELOC_PPC_EMB_SDA21
case|:
if|if
condition|(
name|fixp
operator|->
name|fx_pcrel
condition|)
name|abort
argument_list|()
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|fixp
operator|->
name|fx_frag
operator|->
name|fr_literal
operator|+
name|fixp
operator|->
name|fx_where
operator|+
operator|(
operator|(
name|target_big_endian
operator|)
condition|?
literal|2
else|:
literal|0
operator|)
argument_list|,
name|value
argument_list|,
literal|2
argument_list|)
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_8
case|:
if|if
condition|(
name|fixp
operator|->
name|fx_pcrel
condition|)
name|abort
argument_list|()
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|fixp
operator|->
name|fx_frag
operator|->
name|fr_literal
operator|+
name|fixp
operator|->
name|fx_where
argument_list|,
name|value
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_24_PLT_PCREL
case|:
case|case
name|BFD_RELOC_PPC_LOCAL24PC
case|:
if|if
condition|(
operator|!
name|fixp
operator|->
name|fx_pcrel
operator|&&
operator|!
name|fixp
operator|->
name|fx_done
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|fixp
operator|->
name|fx_done
condition|)
block|{
name|char
modifier|*
name|where
decl_stmt|;
name|unsigned
name|long
name|insn
decl_stmt|;
comment|/* Fetch the instruction, insert the fully resolved operand 	       value, and stuff the instruction back again.  */
name|where
operator|=
name|fixp
operator|->
name|fx_frag
operator|->
name|fr_literal
operator|+
name|fixp
operator|->
name|fx_where
expr_stmt|;
if|if
condition|(
name|target_big_endian
condition|)
name|insn
operator|=
name|bfd_getb32
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|where
argument_list|)
expr_stmt|;
else|else
name|insn
operator|=
name|bfd_getl32
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|where
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|value
operator|&
literal|3
operator|)
operator|!=
literal|0
condition|)
name|as_bad_where
argument_list|(
name|fixp
operator|->
name|fx_file
argument_list|,
name|fixp
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"must branch to an address a multiple of 4"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|offsetT
operator|)
name|value
operator|<
operator|-
literal|0x40000000
operator|||
operator|(
name|offsetT
operator|)
name|value
operator|>=
literal|0x40000000
condition|)
name|as_bad_where
argument_list|(
name|fixp
operator|->
name|fx_file
argument_list|,
name|fixp
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"@local or @plt branch destination is too far away, %ld bytes"
argument_list|)
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|insn
operator|=
name|insn
operator||
operator|(
name|value
operator|&
literal|0x03fffffc
operator|)
expr_stmt|;
if|if
condition|(
name|target_big_endian
condition|)
name|bfd_putb32
argument_list|(
operator|(
name|bfd_vma
operator|)
name|insn
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|where
argument_list|)
expr_stmt|;
else|else
name|bfd_putl32
argument_list|(
operator|(
name|bfd_vma
operator|)
name|insn
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|where
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|BFD_RELOC_VTABLE_INHERIT
case|:
name|fixp
operator|->
name|fx_done
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|fixp
operator|->
name|fx_addsy
operator|&&
operator|!
name|S_IS_DEFINED
argument_list|(
name|fixp
operator|->
name|fx_addsy
argument_list|)
operator|&&
operator|!
name|S_IS_WEAK
argument_list|(
name|fixp
operator|->
name|fx_addsy
argument_list|)
condition|)
name|S_SET_WEAK
argument_list|(
name|fixp
operator|->
name|fx_addsy
argument_list|)
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_VTABLE_ENTRY
case|:
name|fixp
operator|->
name|fx_done
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"Gas failure, reloc value %d\n"
argument_list|)
argument_list|,
name|fixp
operator|->
name|fx_r_type
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|OBJ_ELF
name|fixp
operator|->
name|fx_addnumber
operator|=
name|value
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|fixp
operator|->
name|fx_r_type
operator|!=
name|BFD_RELOC_PPC_TOC16
condition|)
name|fixp
operator|->
name|fx_addnumber
operator|=
literal|0
expr_stmt|;
else|else
block|{
ifdef|#
directive|ifdef
name|TE_PE
name|fixp
operator|->
name|fx_addnumber
operator|=
literal|0
expr_stmt|;
else|#
directive|else
comment|/* We want to use the offset within the data segment of the 	 symbol, not the actual VMA of the symbol.  */
name|fixp
operator|->
name|fx_addnumber
operator|=
operator|-
name|bfd_get_section_vma
argument_list|(
name|stdoutput
argument_list|,
name|S_GET_SEGMENT
argument_list|(
name|fixp
operator|->
name|fx_addsy
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
endif|#
directive|endif
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Generate a reloc for a fixup.  */
end_comment

begin_function
name|arelent
modifier|*
name|tc_gen_reloc
parameter_list|(
name|seg
parameter_list|,
name|fixp
parameter_list|)
name|asection
modifier|*
name|seg
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|fixS
modifier|*
name|fixp
decl_stmt|;
block|{
name|arelent
modifier|*
name|reloc
decl_stmt|;
name|reloc
operator|=
operator|(
name|arelent
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|arelent
argument_list|)
argument_list|)
expr_stmt|;
name|reloc
operator|->
name|sym_ptr_ptr
operator|=
operator|(
name|asymbol
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|asymbol
operator|*
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|reloc
operator|->
name|sym_ptr_ptr
operator|=
name|symbol_get_bfdsym
argument_list|(
name|fixp
operator|->
name|fx_addsy
argument_list|)
expr_stmt|;
name|reloc
operator|->
name|address
operator|=
name|fixp
operator|->
name|fx_frag
operator|->
name|fr_address
operator|+
name|fixp
operator|->
name|fx_where
expr_stmt|;
name|reloc
operator|->
name|howto
operator|=
name|bfd_reloc_type_lookup
argument_list|(
name|stdoutput
argument_list|,
name|fixp
operator|->
name|fx_r_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|reloc
operator|->
name|howto
operator|==
operator|(
name|reloc_howto_type
operator|*
operator|)
name|NULL
condition|)
block|{
name|as_bad_where
argument_list|(
name|fixp
operator|->
name|fx_file
argument_list|,
name|fixp
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"reloc %d not supported by object file format"
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|fixp
operator|->
name|fx_r_type
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|reloc
operator|->
name|addend
operator|=
name|fixp
operator|->
name|fx_addnumber
expr_stmt|;
return|return
name|reloc
return|;
block|}
end_function

end_unit

