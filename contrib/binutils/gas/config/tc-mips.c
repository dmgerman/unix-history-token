begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* tc-mips.c -- assemble code for a MIPS chip.    Copyright 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,    2003, 2004, 2005, 2006 Free Software Foundation, Inc.    Contributed by the OSF and Ralph Campbell.    Written by Keith Knowles and Ralph Campbell, working independently.    Modified for ECOFF and R4000 support by Ian Lance Taylor of Cygnus    Support.     This file is part of GAS.     GAS is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     GAS is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with GAS; see the file COPYING.  If not, write to the Free    Software Foundation, 51 Franklin Street - Fifth Floor, Boston, MA    02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"as.h"
end_include

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"subsegs.h"
end_include

begin_include
include|#
directive|include
file|"safe-ctype.h"
end_include

begin_include
include|#
directive|include
file|"opcode/mips.h"
end_include

begin_include
include|#
directive|include
file|"itbl-ops.h"
end_include

begin_include
include|#
directive|include
file|"dwarf2dbg.h"
end_include

begin_include
include|#
directive|include
file|"dw2gencfi.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_define
define|#
directive|define
name|DBG
parameter_list|(
name|x
parameter_list|)
value|printf x
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|DBG
parameter_list|(
name|x
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|OBJ_MAYBE_ELF
end_ifdef

begin_comment
comment|/* Clean up namespace so we can include obj-elf.h too.  */
end_comment

begin_function_decl
specifier|static
name|int
name|mips_output_flavor
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|int
name|mips_output_flavor
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|OUTPUT_FLAVOR
return|;
block|}
end_function

begin_undef
undef|#
directive|undef
name|OBJ_PROCESS_STAB
end_undef

begin_undef
undef|#
directive|undef
name|OUTPUT_FLAVOR
end_undef

begin_undef
undef|#
directive|undef
name|S_GET_ALIGN
end_undef

begin_undef
undef|#
directive|undef
name|S_GET_SIZE
end_undef

begin_undef
undef|#
directive|undef
name|S_SET_ALIGN
end_undef

begin_undef
undef|#
directive|undef
name|S_SET_SIZE
end_undef

begin_undef
undef|#
directive|undef
name|obj_frob_file
end_undef

begin_undef
undef|#
directive|undef
name|obj_frob_file_after_relocs
end_undef

begin_undef
undef|#
directive|undef
name|obj_frob_symbol
end_undef

begin_undef
undef|#
directive|undef
name|obj_pop_insert
end_undef

begin_undef
undef|#
directive|undef
name|obj_sec_sym_ok_for_reloc
end_undef

begin_undef
undef|#
directive|undef
name|OBJ_COPY_SYMBOL_ATTRIBUTES
end_undef

begin_include
include|#
directive|include
file|"obj-elf.h"
end_include

begin_comment
comment|/* Fix any of them that we actually care about.  */
end_comment

begin_undef
undef|#
directive|undef
name|OUTPUT_FLAVOR
end_undef

begin_define
define|#
directive|define
name|OUTPUT_FLAVOR
value|mips_output_flavor()
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|OBJ_ELF
argument_list|)
end_if

begin_include
include|#
directive|include
file|"elf/mips.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|ECOFF_DEBUGGING
end_ifndef

begin_define
define|#
directive|define
name|NO_ECOFF_DEBUGGING
end_define

begin_define
define|#
directive|define
name|ECOFF_DEBUGGING
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|int
name|mips_flag_mdebug
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Control generation of .pdr sections.  Off by default on IRIX: the native    linker doesn't know about and discards them, but relocations against them    remain, leading to rld crashes.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|TE_IRIX
end_ifdef

begin_decl_stmt
name|int
name|mips_flag_pdr
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
name|int
name|mips_flag_pdr
init|=
name|TRUE
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Control generation of error message for unsupported instructions in    Octeon. Octeon does not have floating point, and all the instructions    that use floating point registers are not allowed in Elf targets but     are allowed in Linux targets by default.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|OCTEON_ERROR_ON_UNSUPPORTED
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|octeon_error_on_unsupported
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|static
name|int
name|octeon_error_on_unsupported
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Control generation of Octeon/MIPS unaligned load/store instructions.    For ELF target, default to Octeon load/store instructions.    For Linux target, default to MIPS load/store instructions.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|OCTEON_USE_UNALIGN
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|octeon_use_unalign
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|static
name|int
name|octeon_use_unalign
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"ecoff.h"
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|OBJ_ELF
argument_list|)
operator|||
name|defined
argument_list|(
name|OBJ_MAYBE_ELF
argument_list|)
end_if

begin_decl_stmt
specifier|static
name|char
modifier|*
name|mips_regmask_frag
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|ZERO
value|0
end_define

begin_define
define|#
directive|define
name|AT
value|1
end_define

begin_define
define|#
directive|define
name|TREG
value|24
end_define

begin_define
define|#
directive|define
name|PIC_CALL_REG
value|25
end_define

begin_define
define|#
directive|define
name|KT0
value|26
end_define

begin_define
define|#
directive|define
name|KT1
value|27
end_define

begin_define
define|#
directive|define
name|GP
value|28
end_define

begin_define
define|#
directive|define
name|SP
value|29
end_define

begin_define
define|#
directive|define
name|FP
value|30
end_define

begin_define
define|#
directive|define
name|RA
value|31
end_define

begin_define
define|#
directive|define
name|ILLEGAL_REG
value|(32)
end_define

begin_comment
comment|/* Allow override of standard little-endian ECOFF format.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|ECOFF_LITTLE_FORMAT
end_ifndef

begin_define
define|#
directive|define
name|ECOFF_LITTLE_FORMAT
value|"ecoff-littlemips"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|extern
name|int
name|target_big_endian
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The name of the readonly data section.  */
end_comment

begin_define
define|#
directive|define
name|RDATA_SECTION_NAME
value|(OUTPUT_FLAVOR == bfd_target_ecoff_flavour \ 			    ? ".rdata" \ 			    : OUTPUT_FLAVOR == bfd_target_coff_flavour \ 			    ? ".rdata" \ 			    : OUTPUT_FLAVOR == bfd_target_elf_flavour \ 			    ? ".rodata" \ 			    : (abort (), ""))
end_define

begin_comment
comment|/* Information about an instruction, including its format, operands    and fixups.  */
end_comment

begin_struct
struct|struct
name|mips_cl_insn
block|{
comment|/* The opcode's entry in mips_opcodes or mips16_opcodes.  */
specifier|const
name|struct
name|mips_opcode
modifier|*
name|insn_mo
decl_stmt|;
comment|/* True if this is a mips16 instruction and if we want the extended      form of INSN_MO.  */
name|bfd_boolean
name|use_extend
decl_stmt|;
comment|/* The 16-bit extension instruction to use when USE_EXTEND is true.  */
name|unsigned
name|short
name|extend
decl_stmt|;
comment|/* The 16-bit or 32-bit bitstring of the instruction itself.  This is      a copy of INSN_MO->match with the operands filled in.  */
name|unsigned
name|long
name|insn_opcode
decl_stmt|;
comment|/* The frag that contains the instruction.  */
name|struct
name|frag
modifier|*
name|frag
decl_stmt|;
comment|/* The offset into FRAG of the first instruction byte.  */
name|long
name|where
decl_stmt|;
comment|/* The relocs associated with the instruction, if any.  */
name|fixS
modifier|*
name|fixp
index|[
literal|3
index|]
decl_stmt|;
comment|/* True if this entry cannot be moved from its current position.  */
name|unsigned
name|int
name|fixed_p
range|:
literal|1
decl_stmt|;
comment|/* True if this instruction occurred in a .set noreorder block.  */
name|unsigned
name|int
name|noreorder_p
range|:
literal|1
decl_stmt|;
comment|/* True for mips16 instructions that jump to an absolute address.  */
name|unsigned
name|int
name|mips16_absolute_jump_p
range|:
literal|1
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* The ABI to use.  */
end_comment

begin_enum
enum|enum
name|mips_abi_level
block|{
name|NO_ABI
init|=
literal|0
block|,
name|O32_ABI
block|,
name|O64_ABI
block|,
name|N32_ABI
block|,
name|N64_ABI
block|,
name|EABI_ABI
block|}
enum|;
end_enum

begin_comment
comment|/* MIPS ABI we are using for this output file.  */
end_comment

begin_decl_stmt
specifier|static
name|enum
name|mips_abi_level
name|mips_abi
init|=
name|NO_ABI
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Whether or not we have code that can call pic code.  */
end_comment

begin_decl_stmt
name|int
name|mips_abicalls
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Whether or not we have code which can be put into a shared    library.  */
end_comment

begin_decl_stmt
specifier|static
name|bfd_boolean
name|mips_in_shared
init|=
name|TRUE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This is the set of options which may be modified by the .set    pseudo-op.  We use a struct so that .set push and .set pop are more    reliable.  */
end_comment

begin_struct
struct|struct
name|mips_set_options
block|{
comment|/* MIPS ISA (Instruction Set Architecture) level.  This is set to -1      if it has not been initialized.  Changed by `.set mipsN', and the      -mipsN command line option, and the default CPU.  */
name|int
name|isa
decl_stmt|;
comment|/* Enabled Application Specific Extensions (ASEs).  These are set to -1      if they have not been initialized.  Changed by `.set<asename>', by      command line options, and based on the default architecture.  */
name|int
name|ase_mips3d
decl_stmt|;
name|int
name|ase_mdmx
decl_stmt|;
name|int
name|ase_smartmips
decl_stmt|;
name|int
name|ase_dsp
decl_stmt|;
name|int
name|ase_dspr2
decl_stmt|;
name|int
name|ase_mt
decl_stmt|;
comment|/* Whether we are assembling for the mips16 processor.  0 if we are      not, 1 if we are, and -1 if the value has not been initialized.      Changed by `.set mips16' and `.set nomips16', and the -mips16 and      -nomips16 command line options, and the default CPU.  */
name|int
name|mips16
decl_stmt|;
comment|/* Non-zero if we should not reorder instructions.  Changed by `.set      reorder' and `.set noreorder'.  */
name|int
name|noreorder
decl_stmt|;
comment|/* Non-zero if we should not permit the $at ($1) register to be used      in instructions.  Changed by `.set at' and `.set noat'.  */
name|int
name|noat
decl_stmt|;
comment|/* Non-zero if we should warn when a macro instruction expands into      more than one machine instruction.  Changed by `.set nomacro' and      `.set macro'.  */
name|int
name|warn_about_macros
decl_stmt|;
comment|/* Non-zero if we should not move instructions.  Changed by `.set      move', `.set volatile', `.set nomove', and `.set novolatile'.  */
name|int
name|nomove
decl_stmt|;
comment|/* Non-zero if we should not optimize branches by moving the target      of the branch into the delay slot.  Actually, we don't perform      this optimization anyhow.  Changed by `.set bopt' and `.set      nobopt'.  */
name|int
name|nobopt
decl_stmt|;
comment|/* Non-zero if we should not autoextend mips16 instructions.      Changed by `.set autoextend' and `.set noautoextend'.  */
name|int
name|noautoextend
decl_stmt|;
comment|/* Restrict general purpose registers and floating point registers      to 32 bit.  This is initially determined when -mgp32 or -mfp32      is passed but can changed if the assembler code uses .set mipsN.  */
name|int
name|gp32
decl_stmt|;
name|int
name|fp32
decl_stmt|;
comment|/* MIPS architecture (CPU) type.  Changed by .set arch=FOO, the -march      command line option, and the default CPU.  */
name|int
name|arch
decl_stmt|;
comment|/* True if ".set sym32" is in effect.  */
name|bfd_boolean
name|sym32
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* True if -mgp32 was passed.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|file_mips_gp32
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* True if -mfp32 was passed.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|file_mips_fp32
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This is the struct we use to hold the current set of options.  Note    that we must set the isa field to ISA_UNKNOWN and the ASE fields to    -1 to indicate that they have not been initialized.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|mips_set_options
name|mips_opts
init|=
block|{
name|ISA_UNKNOWN
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
literal|0
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|CPU_UNKNOWN
block|,
name|FALSE
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* These variables are filled in with the masks of registers used.    The object format code reads them and puts them in the appropriate    place.  */
end_comment

begin_decl_stmt
name|unsigned
name|long
name|mips_gprmask
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|long
name|mips_cprmask
index|[
literal|4
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* MIPS ISA we are using for this output file.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|file_mips_isa
init|=
name|ISA_UNKNOWN
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* True if -mips16 was passed or implied by arguments passed on the    command line (e.g., by -march).  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|file_ase_mips16
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|ISA_SUPPORTS_MIPS16E
value|(mips_opts.isa == ISA_MIPS32		\ 			      || mips_opts.isa == ISA_MIPS32R2		\ 			      || mips_opts.isa == ISA_MIPS64		\ 			      || mips_opts.isa == ISA_MIPS64R2)
end_define

begin_comment
comment|/* True if -mips3d was passed or implied by arguments passed on the    command line (e.g., by -march).  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|file_ase_mips3d
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* True if -mdmx was passed or implied by arguments passed on the    command line (e.g., by -march).  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|file_ase_mdmx
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* True if -msmartmips was passed or implied by arguments passed on the    command line (e.g., by -march).  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|file_ase_smartmips
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|ISA_SUPPORTS_SMARTMIPS
value|(mips_opts.isa == ISA_MIPS32		\ 				|| mips_opts.isa == ISA_MIPS32R2)
end_define

begin_comment
comment|/* True if -mdsp was passed or implied by arguments passed on the    command line (e.g., by -march).  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|file_ase_dsp
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|ISA_SUPPORTS_DSP_ASE
value|(mips_opts.isa == ISA_MIPS32R2		\ 			      || mips_opts.isa == ISA_MIPS64R2)
end_define

begin_define
define|#
directive|define
name|ISA_SUPPORTS_DSP64_ASE
value|(mips_opts.isa == ISA_MIPS64R2)
end_define

begin_comment
comment|/* True if -mdspr2 was passed or implied by arguments passed on the    command line (e.g., by -march).  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|file_ase_dspr2
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|ISA_SUPPORTS_DSPR2_ASE
value|(mips_opts.isa == ISA_MIPS32R2		\ 			        || mips_opts.isa == ISA_MIPS64R2)
end_define

begin_comment
comment|/* True if -mmt was passed or implied by arguments passed on the    command line (e.g., by -march).  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|file_ase_mt
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|ISA_SUPPORTS_MT_ASE
value|(mips_opts.isa == ISA_MIPS32R2		\ 			     || mips_opts.isa == ISA_MIPS64R2)
end_define

begin_comment
comment|/* The argument of the -march= flag.  The architecture we are assembling.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|file_mips_arch
init|=
name|CPU_UNKNOWN
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|mips_arch_string
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The argument of the -mtune= flag.  The architecture for which we    are optimizing.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|mips_tune
init|=
name|CPU_UNKNOWN
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|mips_tune_string
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* True when generating 32-bit code for a 64-bit processor.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|mips_32bitmode
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* True if the given ABI requires 32-bit registers.  */
end_comment

begin_define
define|#
directive|define
name|ABI_NEEDS_32BIT_REGS
parameter_list|(
name|ABI
parameter_list|)
value|((ABI) == O32_ABI)
end_define

begin_comment
comment|/* Likewise 64-bit registers.  */
end_comment

begin_define
define|#
directive|define
name|ABI_NEEDS_64BIT_REGS
parameter_list|(
name|ABI
parameter_list|)
define|\
value|((ABI) == N32_ABI 			\    || (ABI) == N64_ABI			\    || (ABI) == O64_ABI)
end_define

begin_comment
comment|/*  Return true if ISA supports 64 bit wide gp registers.  */
end_comment

begin_define
define|#
directive|define
name|ISA_HAS_64BIT_REGS
parameter_list|(
name|ISA
parameter_list|)
define|\
value|((ISA) == ISA_MIPS3			\    || (ISA) == ISA_MIPS4		\    || (ISA) == ISA_MIPS5		\    || (ISA) == ISA_MIPS64		\    || (ISA) == ISA_MIPS64R2)
end_define

begin_comment
comment|/*  Return true if ISA supports 64 bit wide float registers.  */
end_comment

begin_define
define|#
directive|define
name|ISA_HAS_64BIT_FPRS
parameter_list|(
name|ISA
parameter_list|)
define|\
value|((ISA) == ISA_MIPS3			\    || (ISA) == ISA_MIPS4		\    || (ISA) == ISA_MIPS5		\    || (ISA) == ISA_MIPS32R2		\    || (ISA) == ISA_MIPS64		\    || (ISA) == ISA_MIPS64R2)
end_define

begin_comment
comment|/* Return true if ISA supports 64-bit right rotate (dror et al.)    instructions.  */
end_comment

begin_define
define|#
directive|define
name|ISA_HAS_DROR
parameter_list|(
name|ISA
parameter_list|)
define|\
value|((ISA) == ISA_MIPS64R2)
end_define

begin_comment
comment|/* Return true if ISA supports 32-bit right rotate (ror et al.)    instructions.  */
end_comment

begin_define
define|#
directive|define
name|ISA_HAS_ROR
parameter_list|(
name|ISA
parameter_list|)
define|\
value|((ISA) == ISA_MIPS32R2		\    || (ISA) == ISA_MIPS64R2		\    || mips_opts.ase_smartmips)
end_define

begin_comment
comment|/* Return true if ISA supports ins instructions. */
end_comment

begin_define
define|#
directive|define
name|ISA_HAS_INS
parameter_list|(
name|ISA
parameter_list|)
define|\
value|((ISA) == ISA_MIPS32R2		\   || (ISA) == ISA_MIPS64R2)
end_define

begin_comment
comment|/* Return true if ISA supports single-precision floats in odd registers.  */
end_comment

begin_define
define|#
directive|define
name|ISA_HAS_ODD_SINGLE_FPR
parameter_list|(
name|ISA
parameter_list|)
define|\
value|((ISA) == ISA_MIPS32			\    || (ISA) == ISA_MIPS32R2		\    || (ISA) == ISA_MIPS64		\    || (ISA) == ISA_MIPS64R2)
end_define

begin_comment
comment|/* Return true if ISA supports move to/from high part of a 64-bit    floating-point register. */
end_comment

begin_define
define|#
directive|define
name|ISA_HAS_MXHC1
parameter_list|(
name|ISA
parameter_list|)
define|\
value|((ISA) == ISA_MIPS32R2		\    || (ISA) == ISA_MIPS64R2)
end_define

begin_define
define|#
directive|define
name|HAVE_32BIT_GPRS
define|\
value|(mips_opts.gp32 || !ISA_HAS_64BIT_REGS (mips_opts.isa))
end_define

begin_define
define|#
directive|define
name|HAVE_32BIT_FPRS
define|\
value|(mips_opts.fp32 || !ISA_HAS_64BIT_FPRS (mips_opts.isa))
end_define

begin_define
define|#
directive|define
name|HAVE_64BIT_GPRS
value|(!HAVE_32BIT_GPRS)
end_define

begin_define
define|#
directive|define
name|HAVE_64BIT_FPRS
value|(!HAVE_32BIT_FPRS)
end_define

begin_define
define|#
directive|define
name|HAVE_NEWABI
value|(mips_abi == N32_ABI || mips_abi == N64_ABI)
end_define

begin_define
define|#
directive|define
name|HAVE_64BIT_OBJECTS
value|(mips_abi == N64_ABI)
end_define

begin_comment
comment|/* True if relocations are stored in-place.  */
end_comment

begin_define
define|#
directive|define
name|HAVE_IN_PLACE_ADDENDS
value|(!HAVE_NEWABI)
end_define

begin_comment
comment|/* The ABI-derived address size.  */
end_comment

begin_define
define|#
directive|define
name|HAVE_64BIT_ADDRESSES
define|\
value|(HAVE_64BIT_GPRS&& (mips_abi == EABI_ABI || mips_abi == N64_ABI))
end_define

begin_define
define|#
directive|define
name|HAVE_32BIT_ADDRESSES
value|(!HAVE_64BIT_ADDRESSES)
end_define

begin_comment
comment|/* The size of symbolic constants (i.e., expressions of the form    "SYMBOL" or "SYMBOL + OFFSET").  */
end_comment

begin_define
define|#
directive|define
name|HAVE_32BIT_SYMBOLS
define|\
value|(HAVE_32BIT_ADDRESSES || !HAVE_64BIT_OBJECTS || mips_opts.sym32)
end_define

begin_define
define|#
directive|define
name|HAVE_64BIT_SYMBOLS
value|(!HAVE_32BIT_SYMBOLS)
end_define

begin_comment
comment|/* Addresses are loaded in different ways, depending on the address size    in use.  The n32 ABI Documentation also mandates the use of additions    with overflow checking, but existing implementations don't follow it.  */
end_comment

begin_define
define|#
directive|define
name|ADDRESS_ADD_INSN
define|\
value|(HAVE_32BIT_ADDRESSES ? "addu" : "daddu")
end_define

begin_define
define|#
directive|define
name|ADDRESS_ADDI_INSN
define|\
value|(HAVE_32BIT_ADDRESSES ? "addiu" : "daddiu")
end_define

begin_define
define|#
directive|define
name|ADDRESS_LOAD_INSN
define|\
value|(HAVE_32BIT_ADDRESSES ? "lw" : "ld")
end_define

begin_define
define|#
directive|define
name|ADDRESS_STORE_INSN
define|\
value|(HAVE_32BIT_ADDRESSES ? "sw" : "sd")
end_define

begin_comment
comment|/* Return true if the given CPU supports the MIPS16 ASE.  */
end_comment

begin_define
define|#
directive|define
name|CPU_HAS_MIPS16
parameter_list|(
name|cpu
parameter_list|)
define|\
value|(strncmp (TARGET_CPU, "mips16", sizeof ("mips16") - 1) == 0		\     || strncmp (TARGET_CANONICAL, "mips-lsi-elf", sizeof ("mips-lsi-elf") - 1) == 0)
end_define

begin_comment
comment|/* True if CPU has a dror instruction.  */
end_comment

begin_define
define|#
directive|define
name|CPU_HAS_DROR
parameter_list|(
name|CPU
parameter_list|)
value|((CPU) == CPU_VR5400 || (CPU) == CPU_VR5500)
end_define

begin_comment
comment|/* True if CPU has a ror instruction.  */
end_comment

begin_define
define|#
directive|define
name|CPU_HAS_ROR
parameter_list|(
name|CPU
parameter_list|)
value|CPU_HAS_DROR (CPU)
end_define

begin_comment
comment|/* True if mflo and mfhi can be immediately followed by instructions    which write to the HI and LO registers.     According to MIPS specifications, MIPS ISAs I, II, and III need    (at least) two instructions between the reads of HI/LO and    instructions which write them, and later ISAs do not.  Contradicting    the MIPS specifications, some MIPS IV processor user manuals (e.g.    the UM for the NEC Vr5000) document needing the instructions between    HI/LO reads and writes, as well.  Therefore, we declare only MIPS32,    MIPS64 and later ISAs to have the interlocks, plus any specific    earlier-ISA CPUs for which CPU documentation declares that the    instructions are really interlocked.  */
end_comment

begin_define
define|#
directive|define
name|hilo_interlocks
define|\
value|(mips_opts.isa == ISA_MIPS32                        \    || mips_opts.isa == ISA_MIPS32R2                   \    || mips_opts.isa == ISA_MIPS64                     \    || mips_opts.isa == ISA_MIPS64R2                   \    || mips_opts.arch == CPU_R4010                     \    || mips_opts.arch == CPU_R10000                    \    || mips_opts.arch == CPU_R12000                    \    || mips_opts.arch == CPU_RM7000                    \    || mips_opts.arch == CPU_VR5500                    \    )
end_define

begin_comment
comment|/* Whether the processor uses hardware interlocks to protect reads    from the GPRs after they are loaded from memory, and thus does not    require nops to be inserted.  This applies to instructions marked    INSN_LOAD_MEMORY_DELAY.  These nops are only required at MIPS ISA    level I.  */
end_comment

begin_define
define|#
directive|define
name|gpr_interlocks
define|\
value|(mips_opts.isa != ISA_MIPS1  \    || mips_opts.arch == CPU_R3900)
end_define

begin_comment
comment|/* Whether the processor uses hardware interlocks to avoid delays    required by coprocessor instructions, and thus does not require    nops to be inserted.  This applies to instructions marked    INSN_LOAD_COPROC_DELAY, INSN_COPROC_MOVE_DELAY, and to delays    between instructions marked INSN_WRITE_COND_CODE and ones marked    INSN_READ_COND_CODE.  These nops are only required at MIPS ISA    levels I, II, and III.  */
end_comment

begin_comment
comment|/* Itbl support may require additional care here.  */
end_comment

begin_define
define|#
directive|define
name|cop_interlocks
define|\
value|((mips_opts.isa != ISA_MIPS1                        \&& mips_opts.isa != ISA_MIPS2                     \&& mips_opts.isa != ISA_MIPS3)                    \    || mips_opts.arch == CPU_R4300                     \    )
end_define

begin_comment
comment|/* Whether the processor uses hardware interlocks to protect reads    from coprocessor registers after they are loaded from memory, and    thus does not require nops to be inserted.  This applies to    instructions marked INSN_COPROC_MEMORY_DELAY.  These nops are only    requires at MIPS ISA level I.  */
end_comment

begin_define
define|#
directive|define
name|cop_mem_interlocks
value|(mips_opts.isa != ISA_MIPS1)
end_define

begin_comment
comment|/* Is this a mfhi or mflo instruction?  */
end_comment

begin_define
define|#
directive|define
name|MF_HILO_INSN
parameter_list|(
name|PINFO
parameter_list|)
define|\
value|((PINFO& INSN_READ_HI) || (PINFO& INSN_READ_LO))
end_define

begin_comment
comment|/* MIPS PIC level.  */
end_comment

begin_decl_stmt
name|enum
name|mips_pic_level
name|mips_pic
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 1 if we should generate 32 bit offsets from the $gp register in    SVR4_PIC mode.  Currently has no meaning in other modes.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|mips_big_got
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 1 if trap instructions should used for overflow rather than break    instructions.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|mips_trap
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 1 if double width floating point constants should not be constructed    by assembling two single width halves into two single width floating    point registers which just happen to alias the double width destination    register.  On some architectures this aliasing can be disabled by a bit    in the status register, and the setting of this bit cannot be determined    automatically at assemble time.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|mips_disable_float_construction
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero if any .set noreorder directives were used.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|mips_any_noreorder
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero if nops should be inserted when the register referenced in    an mfhi/mflo instruction is read in the next two instructions.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|mips_7000_hilo_fix
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The size of objects in the small data section.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|g_switch_value
init|=
literal|8
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Whether the -G option was used.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|g_switch_seen
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|N_RMASK
value|0xc4
end_define

begin_define
define|#
directive|define
name|N_VFP
value|0xd4
end_define

begin_comment
comment|/* If we can determine in advance that GP optimization won't be    possible, we can skip the relaxation stuff that tries to produce    GP-relative references.  This makes delay slot optimization work    better.     This function can only provide a guess, but it seems to work for    gcc output.  It needs to guess right for gcc, otherwise gcc    will put what it thinks is a GP-relative instruction in a branch    delay slot.     I don't know if a fix is needed for the SVR4_PIC mode.  I've only    fixed it for the non-PIC mode.  KR 95/04/07  */
end_comment

begin_function_decl
specifier|static
name|int
name|nopic_need_relax
parameter_list|(
name|symbolS
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* handle of the OPCODE hash table */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|hash_control
modifier|*
name|op_hash
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The opcode hash table we use for the mips16.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|hash_control
modifier|*
name|mips16_op_hash
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This array holds the chars that always start a comment.  If the     pre-processor is disabled, these aren't very useful */
end_comment

begin_decl_stmt
specifier|const
name|char
name|comment_chars
index|[]
init|=
literal|"#"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This array holds the chars that only start a comment at the beginning of    a line.  If the line seems to have the form '# 123 filename'    .line and .file directives will appear in the pre-processed output */
end_comment

begin_comment
comment|/* Note that input_file.c hand checks for '#' at the beginning of the    first line of the input file.  This is because the compiler outputs    #NO_APP at the beginning of its output.  */
end_comment

begin_comment
comment|/* Also note that C style comments are always supported.  */
end_comment

begin_decl_stmt
specifier|const
name|char
name|line_comment_chars
index|[]
init|=
literal|"#"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This array holds machine specific line separator characters.  */
end_comment

begin_decl_stmt
specifier|const
name|char
name|line_separator_chars
index|[]
init|=
literal|";"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Chars that can be used to separate mant from exp in floating point nums */
end_comment

begin_decl_stmt
specifier|const
name|char
name|EXP_CHARS
index|[]
init|=
literal|"eE"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Chars that mean this number is a floating point constant */
end_comment

begin_comment
comment|/* As in 0f12.456 */
end_comment

begin_comment
comment|/* or    0d1.2345e12 */
end_comment

begin_decl_stmt
specifier|const
name|char
name|FLT_CHARS
index|[]
init|=
literal|"rRsSfFdDxXpP"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Also be aware that MAXIMUM_NUMBER_OF_CHARS_FOR_FLOAT may have to be    changed in read.c .  Ideally it shouldn't have to know about it at all,    but nothing is ideal around here.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|insn_error
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|auto_align
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* When outputting SVR4 PIC code, the assembler needs to know the    offset in the stack frame from which to restore the $gp register.    This is set by the .cprestore pseudo-op, and saved in this    variable.  */
end_comment

begin_decl_stmt
specifier|static
name|offsetT
name|mips_cprestore_offset
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Similar for NewABI PIC code, where $gp is callee-saved.  NewABI has some    more optimizations, it can use a register value instead of a memory-saved    offset and even an other register than $gp as global pointer.  */
end_comment

begin_decl_stmt
specifier|static
name|offsetT
name|mips_cpreturn_offset
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|mips_cpreturn_register
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|mips_gp_register
init|=
name|GP
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|mips_gprel_offset
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Whether mips_cprestore_offset has been set in the current function    (or whether it has already been warned about, if not).  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|mips_cprestore_valid
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This is the register which holds the stack frame, as set by the    .frame pseudo-op.  This is needed to implement .cprestore.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|mips_frame_reg
init|=
name|SP
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Whether mips_frame_reg has been set in the current function    (or whether it has already been warned about, if not).  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|mips_frame_reg_valid
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* To output NOP instructions correctly, we need to keep information    about the previous two instructions.  */
end_comment

begin_comment
comment|/* Whether we are optimizing.  The default value of 2 means to remove    unneeded NOPs and swap branch instructions when possible.  A value    of 1 means to not swap branches.  A value of 0 means to always    insert NOPs.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|mips_optimize
init|=
literal|2
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Debugging level.  -g sets this to 2.  -gN sets this to N.  -g0 is    equivalent to seeing no -g option at all.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|mips_debug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The maximum number of NOPs needed to avoid the VR4130 mflo/mfhi errata.  */
end_comment

begin_define
define|#
directive|define
name|MAX_VR4130_NOPS
value|4
end_define

begin_comment
comment|/* The maximum number of NOPs needed to fill delay slots.  */
end_comment

begin_define
define|#
directive|define
name|MAX_DELAY_NOPS
value|2
end_define

begin_comment
comment|/* The maximum number of NOPs needed for any purpose.  */
end_comment

begin_define
define|#
directive|define
name|MAX_NOPS
value|4
end_define

begin_comment
comment|/* A list of previous instructions, with index 0 being the most recent.    We need to look back MAX_NOPS instructions when filling delay slots    or working around processor errata.  We need to look back one    instruction further if we're thinking about using history[0] to    fill a branch delay slot.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|mips_cl_insn
name|history
index|[
literal|1
operator|+
name|MAX_NOPS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nop instructions used by emit_nop.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|mips_cl_insn
name|nop_insn
decl_stmt|,
name|mips16_nop_insn
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The appropriate nop for the current mode.  */
end_comment

begin_define
define|#
directive|define
name|NOP_INSN
value|(mips_opts.mips16 ?&mips16_nop_insn :&nop_insn)
end_define

begin_comment
comment|/* If this is set, it points to a frag holding nop instructions which    were inserted before the start of a noreorder section.  If those    nops turn out to be unnecessary, the size of the frag can be    decreased.  */
end_comment

begin_decl_stmt
specifier|static
name|fragS
modifier|*
name|prev_nop_frag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The number of nop instructions we created in prev_nop_frag.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|prev_nop_frag_holds
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The number of nop instructions that we know we need in    prev_nop_frag.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|prev_nop_frag_required
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The number of instructions we've seen since prev_nop_frag.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|prev_nop_frag_since
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* For ECOFF and ELF, relocations against symbols are done in two    parts, with a HI relocation and a LO relocation.  Each relocation    has only 16 bits of space to store an addend.  This means that in    order for the linker to handle carries correctly, it must be able    to locate both the HI and the LO relocation.  This means that the    relocations must appear in order in the relocation table.     In order to implement this, we keep track of each unmatched HI    relocation.  We then sort them so that they immediately precede the    corresponding LO relocation.  */
end_comment

begin_struct
struct|struct
name|mips_hi_fixup
block|{
comment|/* Next HI fixup.  */
name|struct
name|mips_hi_fixup
modifier|*
name|next
decl_stmt|;
comment|/* This fixup.  */
name|fixS
modifier|*
name|fixp
decl_stmt|;
comment|/* The section this fixup is in.  */
name|segT
name|seg
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* The list of unmatched HI relocs.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|mips_hi_fixup
modifier|*
name|mips_hi_fixup_list
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The frag containing the last explicit relocation operator.    Null if explicit relocations have not been used.  */
end_comment

begin_decl_stmt
specifier|static
name|fragS
modifier|*
name|prev_reloc_op_frag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Map normal MIPS register numbers to mips16 register numbers.  */
end_comment

begin_define
define|#
directive|define
name|X
value|ILLEGAL_REG
end_define

begin_decl_stmt
specifier|static
specifier|const
name|int
name|mips32_to_16_reg_map
index|[]
init|=
block|{
name|X
block|,
name|X
block|,
literal|2
block|,
literal|3
block|,
literal|4
block|,
literal|5
block|,
literal|6
block|,
literal|7
block|,
name|X
block|,
name|X
block|,
name|X
block|,
name|X
block|,
name|X
block|,
name|X
block|,
name|X
block|,
name|X
block|,
literal|0
block|,
literal|1
block|,
name|X
block|,
name|X
block|,
name|X
block|,
name|X
block|,
name|X
block|,
name|X
block|,
name|X
block|,
name|X
block|,
name|X
block|,
name|X
block|,
name|X
block|,
name|X
block|,
name|X
block|,
name|X
block|}
decl_stmt|;
end_decl_stmt

begin_undef
undef|#
directive|undef
name|X
end_undef

begin_comment
comment|/* Map mips16 register numbers to normal MIPS register numbers.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|unsigned
name|int
name|mips16_to_32_reg_map
index|[]
init|=
block|{
literal|16
block|,
literal|17
block|,
literal|2
block|,
literal|3
block|,
literal|4
block|,
literal|5
block|,
literal|6
block|,
literal|7
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Classifies the kind of instructions we're interested in when    implementing -mfix-vr4120.  */
end_comment

begin_enum
enum|enum
name|fix_vr4120_class
block|{
name|FIX_VR4120_MACC
block|,
name|FIX_VR4120_DMACC
block|,
name|FIX_VR4120_MULT
block|,
name|FIX_VR4120_DMULT
block|,
name|FIX_VR4120_DIV
block|,
name|FIX_VR4120_MTHILO
block|,
name|NUM_FIX_VR4120_CLASSES
block|}
enum|;
end_enum

begin_comment
comment|/* Given two FIX_VR4120_* values X and Y, bit Y of element X is set if    there must be at least one other instruction between an instruction    of type X and an instruction of type Y.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|vr4120_conflicts
index|[
name|NUM_FIX_VR4120_CLASSES
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* True if -mfix-vr4120 is in force.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|mips_fix_vr4120
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ...likewise -mfix-vr4130.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|mips_fix_vr4130
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* We don't relax branches by default, since this causes us to expand    `la .l2 - .l1' if there's a branch between .l1 and .l2, because we    fail to compute the offset before expanding the macro to the most    efficient expansion.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|mips_relax_branch
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* The expansion of many macros depends on the type of symbol that    they refer to.  For example, when generating position-dependent code,    a macro that refers to a symbol may have two different expansions,    one which uses GP-relative addresses and one which uses absolute    addresses.  When generating SVR4-style PIC, a macro may have    different expansions for local and global symbols.     We handle these situations by generating both sequences and putting    them in variant frags.  In position-dependent code, the first sequence    will be the GP-relative one and the second sequence will be the    absolute one.  In SVR4 PIC, the first sequence will be for global    symbols and the second will be for local symbols.     The frag's "subtype" is RELAX_ENCODE (FIRST, SECOND), where FIRST and    SECOND are the lengths of the two sequences in bytes.  These fields    can be extracted using RELAX_FIRST() and RELAX_SECOND().  In addition,    the subtype has the following flags:     RELAX_USE_SECOND 	Set if it has been decided that we should use the second 	sequence instead of the first.     RELAX_SECOND_LONGER 	Set in the first variant frag if the macro's second implementation 	is longer than its first.  This refers to the macro as a whole, 	not an individual relaxation.     RELAX_NOMACRO 	Set in the first variant frag if the macro appeared in a .set nomacro 	block and if one alternative requires a warning but the other does not.     RELAX_DELAY_SLOT 	Like RELAX_NOMACRO, but indicates that the macro appears in a branch 	delay slot.     The frag's "opcode" points to the first fixup for relaxable code.     Relaxable macros are generated using a sequence such as:        relax_start (SYMBOL);       ... generate first expansion ...       relax_switch ();       ... generate second expansion ...       relax_end ();     The code and fixups for the unwanted alternative are discarded    by md_convert_frag.  */
end_comment

begin_define
define|#
directive|define
name|RELAX_ENCODE
parameter_list|(
name|FIRST
parameter_list|,
name|SECOND
parameter_list|)
value|(((FIRST)<< 8) | (SECOND))
end_define

begin_define
define|#
directive|define
name|RELAX_FIRST
parameter_list|(
name|X
parameter_list|)
value|(((X)>> 8)& 0xff)
end_define

begin_define
define|#
directive|define
name|RELAX_SECOND
parameter_list|(
name|X
parameter_list|)
value|((X)& 0xff)
end_define

begin_define
define|#
directive|define
name|RELAX_USE_SECOND
value|0x10000
end_define

begin_define
define|#
directive|define
name|RELAX_SECOND_LONGER
value|0x20000
end_define

begin_define
define|#
directive|define
name|RELAX_NOMACRO
value|0x40000
end_define

begin_define
define|#
directive|define
name|RELAX_DELAY_SLOT
value|0x80000
end_define

begin_comment
comment|/* Branch without likely bit.  If label is out of range, we turn:   	beq reg1, reg2, label 	delay slot     into          bne reg1, reg2, 0f         nop         j label      0: delay slot     with the following opcode replacements:  	beq<-> bne 	blez<-> bgtz 	bltz<-> bgez 	bc1f<-> bc1t  	bltzal<-> bgezal  (with jal label instead of j label)     Even though keeping the delay slot instruction in the delay slot of    the branch would be more efficient, it would be very tricky to do    correctly, because we'd have to introduce a variable frag *after*    the delay slot instruction, and expand that instead.  Let's do it    the easy way for now, even if the branch-not-taken case now costs    one additional instruction.  Out-of-range branches are not supposed    to be common, anyway.     Branch likely.  If label is out of range, we turn:  	beql reg1, reg2, label 	delay slot (annulled if branch not taken)     into          beql reg1, reg2, 1f         nop         beql $0, $0, 2f         nop      1: j[al] label         delay slot (executed only if branch taken)      2:     It would be possible to generate a shorter sequence by losing the    likely bit, generating something like:  	bne reg1, reg2, 0f 	nop 	j[al] label 	delay slot (executed only if branch taken)      0:  	beql -> bne 	bnel -> beq 	blezl -> bgtz 	bgtzl -> blez 	bltzl -> bgez 	bgezl -> bltz 	bc1fl -> bc1t 	bc1tl -> bc1f  	bltzall -> bgezal  (with jal label instead of j label) 	bgezall -> bltzal  (ditto)      but it's not clear that it would actually improve performance.  */
end_comment

begin_define
define|#
directive|define
name|RELAX_BRANCH_ENCODE
parameter_list|(
name|uncond
parameter_list|,
name|likely
parameter_list|,
name|link
parameter_list|,
name|toofar
parameter_list|)
define|\
value|((relax_substateT) \    (0xc0000000 \     | ((toofar) ? 1 : 0) \     | ((link) ? 2 : 0) \     | ((likely) ? 4 : 0) \     | ((uncond) ? 8 : 0)))
end_define

begin_define
define|#
directive|define
name|RELAX_BRANCH_P
parameter_list|(
name|i
parameter_list|)
value|(((i)& 0xf0000000) == 0xc0000000)
end_define

begin_define
define|#
directive|define
name|RELAX_BRANCH_UNCOND
parameter_list|(
name|i
parameter_list|)
value|(((i)& 8) != 0)
end_define

begin_define
define|#
directive|define
name|RELAX_BRANCH_LIKELY
parameter_list|(
name|i
parameter_list|)
value|(((i)& 4) != 0)
end_define

begin_define
define|#
directive|define
name|RELAX_BRANCH_LINK
parameter_list|(
name|i
parameter_list|)
value|(((i)& 2) != 0)
end_define

begin_define
define|#
directive|define
name|RELAX_BRANCH_TOOFAR
parameter_list|(
name|i
parameter_list|)
value|(((i)& 1) != 0)
end_define

begin_comment
comment|/* For mips16 code, we use an entirely different form of relaxation.    mips16 supports two versions of most instructions which take    immediate values: a small one which takes some small value, and a    larger one which takes a 16 bit value.  Since branches also follow    this pattern, relaxing these values is required.     We can assemble both mips16 and normal MIPS code in a single    object.  Therefore, we need to support this type of relaxation at    the same time that we support the relaxation described above.  We    use the high bit of the subtype field to distinguish these cases.     The information we store for this type of relaxation is the    argument code found in the opcode file for this relocation, whether    the user explicitly requested a small or extended form, and whether    the relocation is in a jump or jal delay slot.  That tells us the    size of the value, and how it should be stored.  We also store    whether the fragment is considered to be extended or not.  We also    store whether this is known to be a branch to a different section,    whether we have tried to relax this frag yet, and whether we have    ever extended a PC relative fragment because of a shift count.  */
end_comment

begin_define
define|#
directive|define
name|RELAX_MIPS16_ENCODE
parameter_list|(
name|type
parameter_list|,
name|small
parameter_list|,
name|ext
parameter_list|,
name|dslot
parameter_list|,
name|jal_dslot
parameter_list|)
define|\
value|(0x80000000							\    | ((type)& 0xff)						\    | ((small) ? 0x100 : 0)					\    | ((ext) ? 0x200 : 0)					\    | ((dslot) ? 0x400 : 0)					\    | ((jal_dslot) ? 0x800 : 0))
end_define

begin_define
define|#
directive|define
name|RELAX_MIPS16_P
parameter_list|(
name|i
parameter_list|)
value|(((i)& 0xc0000000) == 0x80000000)
end_define

begin_define
define|#
directive|define
name|RELAX_MIPS16_TYPE
parameter_list|(
name|i
parameter_list|)
value|((i)& 0xff)
end_define

begin_define
define|#
directive|define
name|RELAX_MIPS16_USER_SMALL
parameter_list|(
name|i
parameter_list|)
value|(((i)& 0x100) != 0)
end_define

begin_define
define|#
directive|define
name|RELAX_MIPS16_USER_EXT
parameter_list|(
name|i
parameter_list|)
value|(((i)& 0x200) != 0)
end_define

begin_define
define|#
directive|define
name|RELAX_MIPS16_DSLOT
parameter_list|(
name|i
parameter_list|)
value|(((i)& 0x400) != 0)
end_define

begin_define
define|#
directive|define
name|RELAX_MIPS16_JAL_DSLOT
parameter_list|(
name|i
parameter_list|)
value|(((i)& 0x800) != 0)
end_define

begin_define
define|#
directive|define
name|RELAX_MIPS16_EXTENDED
parameter_list|(
name|i
parameter_list|)
value|(((i)& 0x1000) != 0)
end_define

begin_define
define|#
directive|define
name|RELAX_MIPS16_MARK_EXTENDED
parameter_list|(
name|i
parameter_list|)
value|((i) | 0x1000)
end_define

begin_define
define|#
directive|define
name|RELAX_MIPS16_CLEAR_EXTENDED
parameter_list|(
name|i
parameter_list|)
value|((i)&~ 0x1000)
end_define

begin_define
define|#
directive|define
name|RELAX_MIPS16_LONG_BRANCH
parameter_list|(
name|i
parameter_list|)
value|(((i)& 0x2000) != 0)
end_define

begin_define
define|#
directive|define
name|RELAX_MIPS16_MARK_LONG_BRANCH
parameter_list|(
name|i
parameter_list|)
value|((i) | 0x2000)
end_define

begin_define
define|#
directive|define
name|RELAX_MIPS16_CLEAR_LONG_BRANCH
parameter_list|(
name|i
parameter_list|)
value|((i)&~ 0x2000)
end_define

begin_comment
comment|/* Is the given value a sign-extended 32-bit value?  */
end_comment

begin_define
define|#
directive|define
name|IS_SEXT_32BIT_NUM
parameter_list|(
name|x
parameter_list|)
define|\
value|(((x)&~ (offsetT) 0x7fffffff) == 0					\    || (((x)&~ (offsetT) 0x7fffffff) == ~ (offsetT) 0x7fffffff))
end_define

begin_comment
comment|/* Is the given value a sign-extended 16-bit value?  */
end_comment

begin_define
define|#
directive|define
name|IS_SEXT_16BIT_NUM
parameter_list|(
name|x
parameter_list|)
define|\
value|(((x)&~ (offsetT) 0x7fff) == 0					\    || (((x)&~ (offsetT) 0x7fff) == ~ (offsetT) 0x7fff))
end_define

begin_comment
comment|/* Is the given value a zero-extended 32-bit value?  Or a negated one?  */
end_comment

begin_define
define|#
directive|define
name|IS_ZEXT_32BIT_NUM
parameter_list|(
name|x
parameter_list|)
define|\
value|(((x)&~ (offsetT) 0xffffffff) == 0					\    || (((x)&~ (offsetT) 0xffffffff) == ~ (offsetT) 0xffffffff))
end_define

begin_comment
comment|/* Replace bits MASK<< SHIFT of STRUCT with the equivalent bits in    VALUE<< SHIFT.  VALUE is evaluated exactly once.  */
end_comment

begin_define
define|#
directive|define
name|INSERT_BITS
parameter_list|(
name|STRUCT
parameter_list|,
name|VALUE
parameter_list|,
name|MASK
parameter_list|,
name|SHIFT
parameter_list|)
define|\
value|(STRUCT) = (((STRUCT)& ~((MASK)<< (SHIFT))) \ 	      | (((VALUE)& (MASK))<< (SHIFT)))
end_define

begin_comment
comment|/* Extract bits MASK<< SHIFT from STRUCT and shift them right    SHIFT places.  */
end_comment

begin_define
define|#
directive|define
name|EXTRACT_BITS
parameter_list|(
name|STRUCT
parameter_list|,
name|MASK
parameter_list|,
name|SHIFT
parameter_list|)
define|\
value|(((STRUCT)>> (SHIFT))& (MASK))
end_define

begin_comment
comment|/* Change INSN's opcode so that the operand given by FIELD has value VALUE.    INSN is a mips_cl_insn structure and VALUE is evaluated exactly once.     include/opcode/mips.h specifies operand fields using the macros    OP_MASK_<FIELD> and OP_SH_<FIELD>.  The MIPS16 equivalents start    with "MIPS16OP" instead of "OP".  */
end_comment

begin_define
define|#
directive|define
name|INSERT_OPERAND
parameter_list|(
name|FIELD
parameter_list|,
name|INSN
parameter_list|,
name|VALUE
parameter_list|)
define|\
value|INSERT_BITS ((INSN).insn_opcode, VALUE, OP_MASK_##FIELD, OP_SH_##FIELD)
end_define

begin_define
define|#
directive|define
name|MIPS16_INSERT_OPERAND
parameter_list|(
name|FIELD
parameter_list|,
name|INSN
parameter_list|,
name|VALUE
parameter_list|)
define|\
value|INSERT_BITS ((INSN).insn_opcode, VALUE, \ 		MIPS16OP_MASK_##FIELD, MIPS16OP_SH_##FIELD)
end_define

begin_comment
comment|/* Extract the operand given by FIELD from mips_cl_insn INSN.  */
end_comment

begin_define
define|#
directive|define
name|EXTRACT_OPERAND
parameter_list|(
name|FIELD
parameter_list|,
name|INSN
parameter_list|)
define|\
value|EXTRACT_BITS ((INSN).insn_opcode, OP_MASK_##FIELD, OP_SH_##FIELD)
end_define

begin_define
define|#
directive|define
name|MIPS16_EXTRACT_OPERAND
parameter_list|(
name|FIELD
parameter_list|,
name|INSN
parameter_list|)
define|\
value|EXTRACT_BITS ((INSN).insn_opcode, \ 		MIPS16OP_MASK_##FIELD, \ 		MIPS16OP_SH_##FIELD)
end_define

begin_escape
end_escape

begin_comment
comment|/* Global variables used when generating relaxable macros.  See the    comment above RELAX_ENCODE for more details about how relaxation    is used.  */
end_comment

begin_struct
specifier|static
struct|struct
block|{
comment|/* 0 if we're not emitting a relaxable macro.      1 if we're emitting the first of the two relaxation alternatives.      2 if we're emitting the second alternative.  */
name|int
name|sequence
decl_stmt|;
comment|/* The first relaxable fixup in the current frag.  (In other words,      the first fixup that refers to relaxable code.)  */
name|fixS
modifier|*
name|first_fixup
decl_stmt|;
comment|/* sizes[0] says how many bytes of the first alternative are stored in      the current frag.  Likewise sizes[1] for the second alternative.  */
name|unsigned
name|int
name|sizes
index|[
literal|2
index|]
decl_stmt|;
comment|/* The symbol on which the choice of sequence depends.  */
name|symbolS
modifier|*
name|symbol
decl_stmt|;
block|}
name|mips_relax
struct|;
end_struct

begin_escape
end_escape

begin_comment
comment|/* Global variables used to decide whether a macro needs a warning.  */
end_comment

begin_struct
specifier|static
struct|struct
block|{
comment|/* True if the macro is in a branch delay slot.  */
name|bfd_boolean
name|delay_slot_p
decl_stmt|;
comment|/* For relaxable macros, sizes[0] is the length of the first alternative      in bytes and sizes[1] is the length of the second alternative.      For non-relaxable macros, both elements give the length of the      macro in bytes.  */
name|unsigned
name|int
name|sizes
index|[
literal|2
index|]
decl_stmt|;
comment|/* The first variant frag for this macro.  */
name|fragS
modifier|*
name|first_frag
decl_stmt|;
block|}
name|mips_macro_warning
struct|;
end_struct

begin_escape
end_escape

begin_comment
comment|/* Prototypes for static functions.  */
end_comment

begin_define
define|#
directive|define
name|internalError
parameter_list|()
define|\
value|as_fatal (_("internal Error, line %d, %s"), __LINE__, __FILE__)
end_define

begin_enum
enum|enum
name|mips_regclass
block|{
name|MIPS_GR_REG
block|,
name|MIPS_FP_REG
block|,
name|MIPS16_REG
block|}
enum|;
end_enum

begin_function_decl
specifier|static
name|void
name|append_insn
parameter_list|(
name|struct
name|mips_cl_insn
modifier|*
name|ip
parameter_list|,
name|expressionS
modifier|*
name|p
parameter_list|,
name|bfd_reloc_code_real_type
modifier|*
name|r
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mips_no_prev_insn
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mips16_macro_build
parameter_list|(
name|expressionS
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|va_list
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|load_register
parameter_list|(
name|int
parameter_list|,
name|expressionS
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|macro_start
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|macro_end
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|macro
parameter_list|(
name|struct
name|mips_cl_insn
modifier|*
name|ip
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mips16_macro
parameter_list|(
name|struct
name|mips_cl_insn
modifier|*
name|ip
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|LOSING_COMPILER
end_ifdef

begin_function_decl
specifier|static
name|void
name|macro2
parameter_list|(
name|struct
name|mips_cl_insn
modifier|*
name|ip
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|mips_ip
parameter_list|(
name|char
modifier|*
name|str
parameter_list|,
name|struct
name|mips_cl_insn
modifier|*
name|ip
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mips16_ip
parameter_list|(
name|char
modifier|*
name|str
parameter_list|,
name|struct
name|mips_cl_insn
modifier|*
name|ip
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mips16_immed
parameter_list|(
name|char
modifier|*
parameter_list|,
name|unsigned
name|int
parameter_list|,
name|int
parameter_list|,
name|offsetT
parameter_list|,
name|bfd_boolean
parameter_list|,
name|bfd_boolean
parameter_list|,
name|bfd_boolean
parameter_list|,
name|unsigned
name|long
modifier|*
parameter_list|,
name|bfd_boolean
modifier|*
parameter_list|,
name|unsigned
name|short
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|size_t
name|my_getSmallExpression
parameter_list|(
name|expressionS
modifier|*
parameter_list|,
name|bfd_reloc_code_real_type
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|my_getExpression
parameter_list|(
name|expressionS
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|s_align
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|s_change_sec
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|s_change_section
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|s_cons
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|s_float_cons
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|s_mips_globl
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|s_option
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|s_mipsset
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|s_abicalls
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|s_cpload
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|s_cpsetup
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|s_cplocal
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|s_cprestore
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|s_cpreturn
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|s_dtprelword
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|s_dtpreldword
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|s_gpvalue
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|s_gpword
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|s_gpdword
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|s_cpadd
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|s_insn
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|md_obj_begin
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|md_obj_end
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|s_mips_ent
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|s_mips_end
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|s_mips_frame
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|s_mips_mask
parameter_list|(
name|int
name|reg_type
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|s_mips_stab
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|s_mips_weakext
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|s_mips_file
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|s_mips_loc
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bfd_boolean
name|pic_need_relax
parameter_list|(
name|symbolS
modifier|*
parameter_list|,
name|asection
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|relaxed_branch_length
parameter_list|(
name|fragS
modifier|*
parameter_list|,
name|asection
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|validate_mips_insn
parameter_list|(
specifier|const
name|struct
name|mips_opcode
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Table and functions used to map between CPU/ISA names, and    ISA levels, and CPU numbers.  */
end_comment

begin_struct
struct|struct
name|mips_cpu_info
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
comment|/* CPU or ISA name.  */
name|int
name|flags
decl_stmt|;
comment|/* ASEs available, or ISA flag.  */
name|int
name|isa
decl_stmt|;
comment|/* ISA level.  */
name|int
name|cpu
decl_stmt|;
comment|/* CPU number (default CPU if ISA).  */
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|MIPS_CPU_IS_ISA
value|0x0001
end_define

begin_comment
comment|/* Is this an ISA?  (If 0, a CPU.) */
end_comment

begin_define
define|#
directive|define
name|MIPS_CPU_ASE_SMARTMIPS
value|0x0002
end_define

begin_comment
comment|/* CPU implements SmartMIPS ASE */
end_comment

begin_define
define|#
directive|define
name|MIPS_CPU_ASE_DSP
value|0x0004
end_define

begin_comment
comment|/* CPU implements DSP ASE */
end_comment

begin_define
define|#
directive|define
name|MIPS_CPU_ASE_MT
value|0x0008
end_define

begin_comment
comment|/* CPU implements MT ASE */
end_comment

begin_define
define|#
directive|define
name|MIPS_CPU_ASE_MIPS3D
value|0x0010
end_define

begin_comment
comment|/* CPU implements MIPS-3D ASE */
end_comment

begin_define
define|#
directive|define
name|MIPS_CPU_ASE_MDMX
value|0x0020
end_define

begin_comment
comment|/* CPU implements MDMX ASE */
end_comment

begin_define
define|#
directive|define
name|MIPS_CPU_ASE_DSPR2
value|0x0040
end_define

begin_comment
comment|/* CPU implements DSP R2 ASE */
end_comment

begin_function_decl
specifier|static
specifier|const
name|struct
name|mips_cpu_info
modifier|*
name|mips_parse_cpu
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|struct
name|mips_cpu_info
modifier|*
name|mips_cpu_info_from_isa
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|struct
name|mips_cpu_info
modifier|*
name|mips_cpu_info_from_arch
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_escape
end_escape

begin_comment
comment|/* Pseudo-op table.     The following pseudo-ops from the Kane and Heinrich MIPS book    should be defined here, but are currently unsupported: .alias,    .galive, .gjaldef, .gjrlive, .livereg, .noalias.     The following pseudo-ops from the Kane and Heinrich MIPS book are    specific to the type of debugging information being generated, and    should be defined by the object format: .aent, .begin, .bend,    .bgnb, .end, .endb, .ent, .fmask, .frame, .loc, .mask, .verstamp,    .vreg.     The following pseudo-ops from the Kane and Heinrich MIPS book are    not MIPS CPU specific, but are also not specific to the object file    format.  This file is probably the best place to define them, but    they are not currently supported: .asm0, .endr, .lab, .struct.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|pseudo_typeS
name|mips_pseudo_table
index|[]
init|=
block|{
comment|/* MIPS specific pseudo-ops.  */
block|{
literal|"option"
block|,
name|s_option
block|,
literal|0
block|}
block|,
block|{
literal|"set"
block|,
name|s_mipsset
block|,
literal|0
block|}
block|,
block|{
literal|"rdata"
block|,
name|s_change_sec
block|,
literal|'r'
block|}
block|,
block|{
literal|"sdata"
block|,
name|s_change_sec
block|,
literal|'s'
block|}
block|,
block|{
literal|"livereg"
block|,
name|s_ignore
block|,
literal|0
block|}
block|,
block|{
literal|"abicalls"
block|,
name|s_abicalls
block|,
literal|0
block|}
block|,
block|{
literal|"cpload"
block|,
name|s_cpload
block|,
literal|0
block|}
block|,
block|{
literal|"cpsetup"
block|,
name|s_cpsetup
block|,
literal|0
block|}
block|,
block|{
literal|"cplocal"
block|,
name|s_cplocal
block|,
literal|0
block|}
block|,
block|{
literal|"cprestore"
block|,
name|s_cprestore
block|,
literal|0
block|}
block|,
block|{
literal|"cpreturn"
block|,
name|s_cpreturn
block|,
literal|0
block|}
block|,
block|{
literal|"dtprelword"
block|,
name|s_dtprelword
block|,
literal|0
block|}
block|,
block|{
literal|"dtpreldword"
block|,
name|s_dtpreldword
block|,
literal|0
block|}
block|,
block|{
literal|"gpvalue"
block|,
name|s_gpvalue
block|,
literal|0
block|}
block|,
block|{
literal|"gpword"
block|,
name|s_gpword
block|,
literal|0
block|}
block|,
block|{
literal|"gpdword"
block|,
name|s_gpdword
block|,
literal|0
block|}
block|,
block|{
literal|"cpadd"
block|,
name|s_cpadd
block|,
literal|0
block|}
block|,
block|{
literal|"insn"
block|,
name|s_insn
block|,
literal|0
block|}
block|,
comment|/* Relatively generic pseudo-ops that happen to be used on MIPS      chips.  */
block|{
literal|"asciiz"
block|,
name|stringer
block|,
literal|1
block|}
block|,
block|{
literal|"bss"
block|,
name|s_change_sec
block|,
literal|'b'
block|}
block|,
block|{
literal|"err"
block|,
name|s_err
block|,
literal|0
block|}
block|,
block|{
literal|"half"
block|,
name|s_cons
block|,
literal|1
block|}
block|,
block|{
literal|"dword"
block|,
name|s_cons
block|,
literal|3
block|}
block|,
block|{
literal|"weakext"
block|,
name|s_mips_weakext
block|,
literal|0
block|}
block|,
block|{
literal|"origin"
block|,
name|s_org
block|,
literal|0
block|}
block|,
block|{
literal|"repeat"
block|,
name|s_rept
block|,
literal|0
block|}
block|,
comment|/* These pseudo-ops are defined in read.c, but must be overridden      here for one reason or another.  */
block|{
literal|"align"
block|,
name|s_align
block|,
literal|0
block|}
block|,
block|{
literal|"byte"
block|,
name|s_cons
block|,
literal|0
block|}
block|,
block|{
literal|"data"
block|,
name|s_change_sec
block|,
literal|'d'
block|}
block|,
block|{
literal|"double"
block|,
name|s_float_cons
block|,
literal|'d'
block|}
block|,
block|{
literal|"float"
block|,
name|s_float_cons
block|,
literal|'f'
block|}
block|,
block|{
literal|"globl"
block|,
name|s_mips_globl
block|,
literal|0
block|}
block|,
block|{
literal|"global"
block|,
name|s_mips_globl
block|,
literal|0
block|}
block|,
block|{
literal|"hword"
block|,
name|s_cons
block|,
literal|1
block|}
block|,
block|{
literal|"int"
block|,
name|s_cons
block|,
literal|2
block|}
block|,
block|{
literal|"long"
block|,
name|s_cons
block|,
literal|2
block|}
block|,
block|{
literal|"octa"
block|,
name|s_cons
block|,
literal|4
block|}
block|,
block|{
literal|"quad"
block|,
name|s_cons
block|,
literal|3
block|}
block|,
block|{
literal|"section"
block|,
name|s_change_section
block|,
literal|0
block|}
block|,
block|{
literal|"short"
block|,
name|s_cons
block|,
literal|1
block|}
block|,
block|{
literal|"single"
block|,
name|s_float_cons
block|,
literal|'f'
block|}
block|,
block|{
literal|"stabn"
block|,
name|s_mips_stab
block|,
literal|'n'
block|}
block|,
block|{
literal|"text"
block|,
name|s_change_sec
block|,
literal|'t'
block|}
block|,
block|{
literal|"word"
block|,
name|s_cons
block|,
literal|2
block|}
block|,
block|{
literal|"extern"
block|,
name|ecoff_directive_extern
block|,
literal|0
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
literal|0
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|pseudo_typeS
name|mips_nonecoff_pseudo_table
index|[]
init|=
block|{
comment|/* These pseudo-ops should be defined by the object file format.      However, a.out doesn't support them, so we have versions here.  */
block|{
literal|"aent"
block|,
name|s_mips_ent
block|,
literal|1
block|}
block|,
block|{
literal|"bgnb"
block|,
name|s_ignore
block|,
literal|0
block|}
block|,
block|{
literal|"end"
block|,
name|s_mips_end
block|,
literal|0
block|}
block|,
block|{
literal|"endb"
block|,
name|s_ignore
block|,
literal|0
block|}
block|,
block|{
literal|"ent"
block|,
name|s_mips_ent
block|,
literal|0
block|}
block|,
block|{
literal|"file"
block|,
name|s_mips_file
block|,
literal|0
block|}
block|,
block|{
literal|"fmask"
block|,
name|s_mips_mask
block|,
literal|'F'
block|}
block|,
block|{
literal|"frame"
block|,
name|s_mips_frame
block|,
literal|0
block|}
block|,
block|{
literal|"loc"
block|,
name|s_mips_loc
block|,
literal|0
block|}
block|,
block|{
literal|"mask"
block|,
name|s_mips_mask
block|,
literal|'R'
block|}
block|,
block|{
literal|"verstamp"
block|,
name|s_ignore
block|,
literal|0
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
literal|0
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|void
name|pop_insert
parameter_list|(
specifier|const
name|pseudo_typeS
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|void
name|mips_pop_insert
parameter_list|(
name|void
parameter_list|)
block|{
name|pop_insert
argument_list|(
name|mips_pseudo_table
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ECOFF_DEBUGGING
condition|)
name|pop_insert
argument_list|(
name|mips_nonecoff_pseudo_table
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Symbols labelling the current insn.  */
end_comment

begin_struct
struct|struct
name|insn_label_list
block|{
name|struct
name|insn_label_list
modifier|*
name|next
decl_stmt|;
name|symbolS
modifier|*
name|label
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|insn_label_list
modifier|*
name|free_insn_labels
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|label_list
value|tc_segment_info_data
end_define

begin_function_decl
specifier|static
name|void
name|mips_clear_insn_labels
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
specifier|inline
name|void
name|mips_clear_insn_labels
parameter_list|(
name|void
parameter_list|)
block|{
specifier|register
name|struct
name|insn_label_list
modifier|*
modifier|*
name|pl
decl_stmt|;
name|segment_info_type
modifier|*
name|si
decl_stmt|;
if|if
condition|(
name|now_seg
condition|)
block|{
for|for
control|(
name|pl
operator|=
operator|&
name|free_insn_labels
init|;
operator|*
name|pl
operator|!=
name|NULL
condition|;
name|pl
operator|=
operator|&
operator|(
operator|*
name|pl
operator|)
operator|->
name|next
control|)
empty_stmt|;
name|si
operator|=
name|seg_info
argument_list|(
name|now_seg
argument_list|)
expr_stmt|;
operator|*
name|pl
operator|=
name|si
operator|->
name|label_list
expr_stmt|;
name|si
operator|->
name|label_list
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_decl_stmt
specifier|static
name|char
modifier|*
name|expr_end
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Expressions which appear in instructions.  These are set by    mips_ip.  */
end_comment

begin_decl_stmt
specifier|static
name|expressionS
name|imm_expr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|expressionS
name|imm2_expr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|expressionS
name|offset_expr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Relocs associated with imm_expr and offset_expr.  */
end_comment

begin_decl_stmt
specifier|static
name|bfd_reloc_code_real_type
name|imm_reloc
index|[
literal|3
index|]
init|=
block|{
name|BFD_RELOC_UNUSED
block|,
name|BFD_RELOC_UNUSED
block|,
name|BFD_RELOC_UNUSED
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_reloc_code_real_type
name|offset_reloc
index|[
literal|3
index|]
init|=
block|{
name|BFD_RELOC_UNUSED
block|,
name|BFD_RELOC_UNUSED
block|,
name|BFD_RELOC_UNUSED
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* These are set by mips16_ip if an explicit extension is used.  */
end_comment

begin_decl_stmt
specifier|static
name|bfd_boolean
name|mips16_small
decl_stmt|,
name|mips16_ext
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|OBJ_ELF
end_ifdef

begin_comment
comment|/* The pdr segment for per procedure frame/regmask info.  Not used for    ECOFF debugging.  */
end_comment

begin_decl_stmt
specifier|static
name|segT
name|pdr_seg
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* The default target format to use.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|mips_target_format
parameter_list|(
name|void
parameter_list|)
block|{
switch|switch
condition|(
name|OUTPUT_FLAVOR
condition|)
block|{
case|case
name|bfd_target_ecoff_flavour
case|:
return|return
name|target_big_endian
condition|?
literal|"ecoff-bigmips"
else|:
name|ECOFF_LITTLE_FORMAT
return|;
case|case
name|bfd_target_coff_flavour
case|:
return|return
literal|"pe-mips"
return|;
case|case
name|bfd_target_elf_flavour
case|:
ifdef|#
directive|ifdef
name|TE_VXWORKS
if|if
condition|(
operator|!
name|HAVE_64BIT_OBJECTS
operator|&&
operator|!
name|HAVE_NEWABI
condition|)
return|return
operator|(
name|target_big_endian
condition|?
literal|"elf32-bigmips-vxworks"
else|:
literal|"elf32-littlemips-vxworks"
operator|)
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TE_TMIPS
comment|/* This is traditional mips.  */
return|return
operator|(
name|target_big_endian
condition|?
operator|(
name|HAVE_64BIT_OBJECTS
condition|?
literal|"elf64-tradbigmips"
else|:
operator|(
name|HAVE_NEWABI
condition|?
literal|"elf32-ntradbigmips"
else|:
literal|"elf32-tradbigmips"
operator|)
operator|)
else|:
operator|(
name|HAVE_64BIT_OBJECTS
condition|?
literal|"elf64-tradlittlemips"
else|:
operator|(
name|HAVE_NEWABI
condition|?
literal|"elf32-ntradlittlemips"
else|:
literal|"elf32-tradlittlemips"
operator|)
operator|)
operator|)
return|;
else|#
directive|else
return|return
operator|(
name|target_big_endian
condition|?
operator|(
name|HAVE_64BIT_OBJECTS
condition|?
literal|"elf64-bigmips"
else|:
operator|(
name|HAVE_NEWABI
condition|?
literal|"elf32-nbigmips"
else|:
literal|"elf32-bigmips"
operator|)
operator|)
else|:
operator|(
name|HAVE_64BIT_OBJECTS
condition|?
literal|"elf64-littlemips"
else|:
operator|(
name|HAVE_NEWABI
condition|?
literal|"elf32-nlittlemips"
else|:
literal|"elf32-littlemips"
operator|)
operator|)
operator|)
return|;
endif|#
directive|endif
default|default:
name|abort
argument_list|()
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
end_function

begin_comment
comment|/* Return the length of instruction INSN.  */
end_comment

begin_function
specifier|static
specifier|inline
name|unsigned
name|int
name|insn_length
parameter_list|(
specifier|const
name|struct
name|mips_cl_insn
modifier|*
name|insn
parameter_list|)
block|{
if|if
condition|(
operator|!
name|mips_opts
operator|.
name|mips16
condition|)
return|return
literal|4
return|;
return|return
name|insn
operator|->
name|mips16_absolute_jump_p
operator|||
name|insn
operator|->
name|use_extend
condition|?
literal|4
else|:
literal|2
return|;
block|}
end_function

begin_comment
comment|/* Initialise INSN from opcode entry MO.  Leave its position unspecified.  */
end_comment

begin_function
specifier|static
name|void
name|create_insn
parameter_list|(
name|struct
name|mips_cl_insn
modifier|*
name|insn
parameter_list|,
specifier|const
name|struct
name|mips_opcode
modifier|*
name|mo
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|;
name|insn
operator|->
name|insn_mo
operator|=
name|mo
expr_stmt|;
name|insn
operator|->
name|use_extend
operator|=
name|FALSE
expr_stmt|;
name|insn
operator|->
name|extend
operator|=
literal|0
expr_stmt|;
name|insn
operator|->
name|insn_opcode
operator|=
name|mo
operator|->
name|match
expr_stmt|;
name|insn
operator|->
name|frag
operator|=
name|NULL
expr_stmt|;
name|insn
operator|->
name|where
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|insn
operator|->
name|fixp
argument_list|)
condition|;
name|i
operator|++
control|)
name|insn
operator|->
name|fixp
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
name|insn
operator|->
name|fixed_p
operator|=
operator|(
name|mips_opts
operator|.
name|noreorder
operator|>
literal|0
operator|)
expr_stmt|;
name|insn
operator|->
name|noreorder_p
operator|=
operator|(
name|mips_opts
operator|.
name|noreorder
operator|>
literal|0
operator|)
expr_stmt|;
name|insn
operator|->
name|mips16_absolute_jump_p
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Install INSN at the location specified by its "frag" and "where" fields.  */
end_comment

begin_function
specifier|static
name|void
name|install_insn
parameter_list|(
specifier|const
name|struct
name|mips_cl_insn
modifier|*
name|insn
parameter_list|)
block|{
name|char
modifier|*
name|f
init|=
name|insn
operator|->
name|frag
operator|->
name|fr_literal
operator|+
name|insn
operator|->
name|where
decl_stmt|;
if|if
condition|(
operator|!
name|mips_opts
operator|.
name|mips16
condition|)
name|md_number_to_chars
argument_list|(
name|f
argument_list|,
name|insn
operator|->
name|insn_opcode
argument_list|,
literal|4
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|insn
operator|->
name|mips16_absolute_jump_p
condition|)
block|{
name|md_number_to_chars
argument_list|(
name|f
argument_list|,
name|insn
operator|->
name|insn_opcode
operator|>>
literal|16
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|f
operator|+
literal|2
argument_list|,
name|insn
operator|->
name|insn_opcode
operator|&
literal|0xffff
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|insn
operator|->
name|use_extend
condition|)
block|{
name|md_number_to_chars
argument_list|(
name|f
argument_list|,
literal|0xf000
operator||
name|insn
operator|->
name|extend
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|f
operator|+=
literal|2
expr_stmt|;
block|}
name|md_number_to_chars
argument_list|(
name|f
argument_list|,
name|insn
operator|->
name|insn_opcode
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Move INSN to offset WHERE in FRAG.  Adjust the fixups accordingly    and install the opcode in the new location.  */
end_comment

begin_function
specifier|static
name|void
name|move_insn
parameter_list|(
name|struct
name|mips_cl_insn
modifier|*
name|insn
parameter_list|,
name|fragS
modifier|*
name|frag
parameter_list|,
name|long
name|where
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|;
name|insn
operator|->
name|frag
operator|=
name|frag
expr_stmt|;
name|insn
operator|->
name|where
operator|=
name|where
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|insn
operator|->
name|fixp
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|insn
operator|->
name|fixp
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
block|{
name|insn
operator|->
name|fixp
index|[
name|i
index|]
operator|->
name|fx_frag
operator|=
name|frag
expr_stmt|;
name|insn
operator|->
name|fixp
index|[
name|i
index|]
operator|->
name|fx_where
operator|=
name|where
expr_stmt|;
block|}
name|install_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add INSN to the end of the output.  */
end_comment

begin_function
specifier|static
name|void
name|add_fixed_insn
parameter_list|(
name|struct
name|mips_cl_insn
modifier|*
name|insn
parameter_list|)
block|{
name|char
modifier|*
name|f
init|=
name|frag_more
argument_list|(
name|insn_length
argument_list|(
name|insn
argument_list|)
argument_list|)
decl_stmt|;
name|move_insn
argument_list|(
name|insn
argument_list|,
name|frag_now
argument_list|,
name|f
operator|-
name|frag_now
operator|->
name|fr_literal
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Start a variant frag and move INSN to the start of the variant part,    marking it as fixed.  The other arguments are as for frag_var.  */
end_comment

begin_function
specifier|static
name|void
name|add_relaxed_insn
parameter_list|(
name|struct
name|mips_cl_insn
modifier|*
name|insn
parameter_list|,
name|int
name|max_chars
parameter_list|,
name|int
name|var
parameter_list|,
name|relax_substateT
name|subtype
parameter_list|,
name|symbolS
modifier|*
name|symbol
parameter_list|,
name|offsetT
name|offset
parameter_list|)
block|{
name|frag_grow
argument_list|(
name|max_chars
argument_list|)
expr_stmt|;
name|move_insn
argument_list|(
name|insn
argument_list|,
name|frag_now
argument_list|,
name|frag_more
argument_list|(
literal|0
argument_list|)
operator|-
name|frag_now
operator|->
name|fr_literal
argument_list|)
expr_stmt|;
name|insn
operator|->
name|fixed_p
operator|=
literal|1
expr_stmt|;
name|frag_var
argument_list|(
name|rs_machine_dependent
argument_list|,
name|max_chars
argument_list|,
name|var
argument_list|,
name|subtype
argument_list|,
name|symbol
argument_list|,
name|offset
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Insert N copies of INSN into the history buffer, starting at    position FIRST.  Neither FIRST nor N need to be clipped.  */
end_comment

begin_function
specifier|static
name|void
name|insert_into_history
parameter_list|(
name|unsigned
name|int
name|first
parameter_list|,
name|unsigned
name|int
name|n
parameter_list|,
specifier|const
name|struct
name|mips_cl_insn
modifier|*
name|insn
parameter_list|)
block|{
if|if
condition|(
name|mips_relax
operator|.
name|sequence
operator|!=
literal|2
condition|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|ARRAY_SIZE
argument_list|(
name|history
argument_list|)
init|;
name|i
operator|--
operator|>
name|first
condition|;
control|)
if|if
condition|(
name|i
operator|>=
name|first
operator|+
name|n
condition|)
name|history
index|[
name|i
index|]
operator|=
name|history
index|[
name|i
operator|-
name|n
index|]
expr_stmt|;
else|else
name|history
index|[
name|i
index|]
operator|=
operator|*
name|insn
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Emit a nop instruction, recording it in the history buffer.  */
end_comment

begin_function
specifier|static
name|void
name|emit_nop
parameter_list|(
name|void
parameter_list|)
block|{
name|add_fixed_insn
argument_list|(
name|NOP_INSN
argument_list|)
expr_stmt|;
name|insert_into_history
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|,
name|NOP_INSN
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Initialize vr4120_conflicts.  There is a bit of duplication here:    the idea is to make it obvious at a glance that each errata is    included.  */
end_comment

begin_function
specifier|static
name|void
name|init_vr4120_conflicts
parameter_list|(
name|void
parameter_list|)
block|{
define|#
directive|define
name|CONFLICT
parameter_list|(
name|FIRST
parameter_list|,
name|SECOND
parameter_list|)
define|\
value|vr4120_conflicts[FIX_VR4120_##FIRST] |= 1<< FIX_VR4120_##SECOND
comment|/* Errata 21 - [D]DIV[U] after [D]MACC */
name|CONFLICT
argument_list|(
name|MACC
argument_list|,
name|DIV
argument_list|)
expr_stmt|;
name|CONFLICT
argument_list|(
name|DMACC
argument_list|,
name|DIV
argument_list|)
expr_stmt|;
comment|/* Errata 23 - Continuous DMULT[U]/DMACC instructions.  */
name|CONFLICT
argument_list|(
name|DMULT
argument_list|,
name|DMULT
argument_list|)
expr_stmt|;
name|CONFLICT
argument_list|(
name|DMULT
argument_list|,
name|DMACC
argument_list|)
expr_stmt|;
name|CONFLICT
argument_list|(
name|DMACC
argument_list|,
name|DMULT
argument_list|)
expr_stmt|;
name|CONFLICT
argument_list|(
name|DMACC
argument_list|,
name|DMACC
argument_list|)
expr_stmt|;
comment|/* Errata 24 - MT{LO,HI} after [D]MACC */
name|CONFLICT
argument_list|(
name|MACC
argument_list|,
name|MTHILO
argument_list|)
expr_stmt|;
name|CONFLICT
argument_list|(
name|DMACC
argument_list|,
name|MTHILO
argument_list|)
expr_stmt|;
comment|/* VR4181A errata MD(1): "If a MULT, MULTU, DMULT or DMULTU      instruction is executed immediately after a MACC or DMACC      instruction, the result of [either instruction] is incorrect."  */
name|CONFLICT
argument_list|(
name|MACC
argument_list|,
name|MULT
argument_list|)
expr_stmt|;
name|CONFLICT
argument_list|(
name|MACC
argument_list|,
name|DMULT
argument_list|)
expr_stmt|;
name|CONFLICT
argument_list|(
name|DMACC
argument_list|,
name|MULT
argument_list|)
expr_stmt|;
name|CONFLICT
argument_list|(
name|DMACC
argument_list|,
name|DMULT
argument_list|)
expr_stmt|;
comment|/* VR4181A errata MD(4): "If a MACC or DMACC instruction is      executed immediately after a DMULT, DMULTU, DIV, DIVU,      DDIV or DDIVU instruction, the result of the MACC or      DMACC instruction is incorrect.".  */
name|CONFLICT
argument_list|(
name|DMULT
argument_list|,
name|MACC
argument_list|)
expr_stmt|;
name|CONFLICT
argument_list|(
name|DMULT
argument_list|,
name|DMACC
argument_list|)
expr_stmt|;
name|CONFLICT
argument_list|(
name|DIV
argument_list|,
name|MACC
argument_list|)
expr_stmt|;
name|CONFLICT
argument_list|(
name|DIV
argument_list|,
name|DMACC
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|CONFLICT
block|}
end_function

begin_struct
struct|struct
name|regname
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|unsigned
name|int
name|num
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|RTYPE_MASK
value|0x1ff00
end_define

begin_define
define|#
directive|define
name|RTYPE_NUM
value|0x00100
end_define

begin_define
define|#
directive|define
name|RTYPE_FPU
value|0x00200
end_define

begin_define
define|#
directive|define
name|RTYPE_FCC
value|0x00400
end_define

begin_define
define|#
directive|define
name|RTYPE_VEC
value|0x00800
end_define

begin_define
define|#
directive|define
name|RTYPE_GP
value|0x01000
end_define

begin_define
define|#
directive|define
name|RTYPE_CP0
value|0x02000
end_define

begin_define
define|#
directive|define
name|RTYPE_PC
value|0x04000
end_define

begin_define
define|#
directive|define
name|RTYPE_ACC
value|0x08000
end_define

begin_define
define|#
directive|define
name|RTYPE_CCC
value|0x10000
end_define

begin_define
define|#
directive|define
name|RNUM_MASK
value|0x000ff
end_define

begin_define
define|#
directive|define
name|RWARN
value|0x80000
end_define

begin_define
define|#
directive|define
name|GENERIC_REGISTER_NUMBERS
define|\
value|{"$0",	RTYPE_NUM | 0},  \     {"$1",	RTYPE_NUM | 1},  \     {"$2",	RTYPE_NUM | 2},  \     {"$3",	RTYPE_NUM | 3},  \     {"$4",	RTYPE_NUM | 4},  \     {"$5",	RTYPE_NUM | 5},  \     {"$6",	RTYPE_NUM | 6},  \     {"$7",	RTYPE_NUM | 7},  \     {"$8",	RTYPE_NUM | 8},  \     {"$9",	RTYPE_NUM | 9},  \     {"$10",	RTYPE_NUM | 10}, \     {"$11",	RTYPE_NUM | 11}, \     {"$12",	RTYPE_NUM | 12}, \     {"$13",	RTYPE_NUM | 13}, \     {"$14",	RTYPE_NUM | 14}, \     {"$15",	RTYPE_NUM | 15}, \     {"$16",	RTYPE_NUM | 16}, \     {"$17",	RTYPE_NUM | 17}, \     {"$18",	RTYPE_NUM | 18}, \     {"$19",	RTYPE_NUM | 19}, \     {"$20",	RTYPE_NUM | 20}, \     {"$21",	RTYPE_NUM | 21}, \     {"$22",	RTYPE_NUM | 22}, \     {"$23",	RTYPE_NUM | 23}, \     {"$24",	RTYPE_NUM | 24}, \     {"$25",	RTYPE_NUM | 25}, \     {"$26",	RTYPE_NUM | 26}, \     {"$27",	RTYPE_NUM | 27}, \     {"$28",	RTYPE_NUM | 28}, \     {"$29",	RTYPE_NUM | 29}, \     {"$30",	RTYPE_NUM | 30}, \     {"$31",	RTYPE_NUM | 31}
end_define

begin_define
define|#
directive|define
name|FPU_REGISTER_NAMES
define|\
value|{"$f0",	RTYPE_FPU | 0},  \     {"$f1",	RTYPE_FPU | 1},  \     {"$f2",	RTYPE_FPU | 2},  \     {"$f3",	RTYPE_FPU | 3},  \     {"$f4",	RTYPE_FPU | 4},  \     {"$f5",	RTYPE_FPU | 5},  \     {"$f6",	RTYPE_FPU | 6},  \     {"$f7",	RTYPE_FPU | 7},  \     {"$f8",	RTYPE_FPU | 8},  \     {"$f9",	RTYPE_FPU | 9},  \     {"$f10",	RTYPE_FPU | 10}, \     {"$f11",	RTYPE_FPU | 11}, \     {"$f12",	RTYPE_FPU | 12}, \     {"$f13",	RTYPE_FPU | 13}, \     {"$f14",	RTYPE_FPU | 14}, \     {"$f15",	RTYPE_FPU | 15}, \     {"$f16",	RTYPE_FPU | 16}, \     {"$f17",	RTYPE_FPU | 17}, \     {"$f18",	RTYPE_FPU | 18}, \     {"$f19",	RTYPE_FPU | 19}, \     {"$f20",	RTYPE_FPU | 20}, \     {"$f21",	RTYPE_FPU | 21}, \     {"$f22",	RTYPE_FPU | 22}, \     {"$f23",	RTYPE_FPU | 23}, \     {"$f24",	RTYPE_FPU | 24}, \     {"$f25",	RTYPE_FPU | 25}, \     {"$f26",	RTYPE_FPU | 26}, \     {"$f27",	RTYPE_FPU | 27}, \     {"$f28",	RTYPE_FPU | 28}, \     {"$f29",	RTYPE_FPU | 29}, \     {"$f30",	RTYPE_FPU | 30}, \     {"$f31",	RTYPE_FPU | 31}
end_define

begin_define
define|#
directive|define
name|FPU_CONDITION_CODE_NAMES
define|\
value|{"$fcc0",	RTYPE_FCC | 0},  \     {"$fcc1",	RTYPE_FCC | 1},  \     {"$fcc2",	RTYPE_FCC | 2},  \     {"$fcc3",	RTYPE_FCC | 3},  \     {"$fcc4",	RTYPE_FCC | 4},  \     {"$fcc5",	RTYPE_FCC | 5},  \     {"$fcc6",	RTYPE_FCC | 6},  \     {"$fcc7",	RTYPE_FCC | 7}
end_define

begin_define
define|#
directive|define
name|COPROC_CONDITION_CODE_NAMES
define|\
value|{"$cc0",	RTYPE_FCC | RTYPE_CCC | 0}, \     {"$cc1",	RTYPE_FCC | RTYPE_CCC | 1}, \     {"$cc2",	RTYPE_FCC | RTYPE_CCC | 2}, \     {"$cc3",	RTYPE_FCC | RTYPE_CCC | 3}, \     {"$cc4",	RTYPE_FCC | RTYPE_CCC | 4}, \     {"$cc5",	RTYPE_FCC | RTYPE_CCC | 5}, \     {"$cc6",	RTYPE_FCC | RTYPE_CCC | 6}, \     {"$cc7",	RTYPE_FCC | RTYPE_CCC | 7}
end_define

begin_define
define|#
directive|define
name|N32N64_SYMBOLIC_REGISTER_NAMES
define|\
value|{"$a4",	RTYPE_GP | 8},  \     {"$a5",	RTYPE_GP | 9},  \     {"$a6",	RTYPE_GP | 10}, \     {"$a7",	RTYPE_GP | 11}, \     {"$ta0",	RTYPE_GP | 8},
comment|/* alias for $a4 */
value|\     {"$ta1",	RTYPE_GP | 9},
comment|/* alias for $a5 */
value|\     {"$ta2",	RTYPE_GP | 10},
comment|/* alias for $a6 */
value|\     {"$ta3",	RTYPE_GP | 11},
comment|/* alias for $a7 */
value|\     {"$t0",	RTYPE_GP | 12}, \     {"$t1",	RTYPE_GP | 13}, \     {"$t2",	RTYPE_GP | 14}, \     {"$t3",	RTYPE_GP | 15}
end_define

begin_define
define|#
directive|define
name|O32_SYMBOLIC_REGISTER_NAMES
define|\
value|{"$t0",	RTYPE_GP | 8},  \     {"$t1",	RTYPE_GP | 9},  \     {"$t2",	RTYPE_GP | 10}, \     {"$t3",	RTYPE_GP | 11}, \     {"$t4",	RTYPE_GP | 12}, \     {"$t5",	RTYPE_GP | 13}, \     {"$t6",	RTYPE_GP | 14}, \     {"$t7",	RTYPE_GP | 15}, \     {"$ta0",	RTYPE_GP | 12},
comment|/* alias for $t4 */
value|\     {"$ta1",	RTYPE_GP | 13},
comment|/* alias for $t5 */
value|\     {"$ta2",	RTYPE_GP | 14},
comment|/* alias for $t6 */
value|\     {"$ta3",	RTYPE_GP | 15}
end_define

begin_comment
comment|/* alias for $t7 */
end_comment

begin_comment
comment|/* Remaining symbolic register names */
end_comment

begin_define
define|#
directive|define
name|SYMBOLIC_REGISTER_NAMES
define|\
value|{"$zero",	RTYPE_GP | 0},  \     {"$at",	RTYPE_GP | 1},  \     {"$AT",	RTYPE_GP | 1},  \     {"$v0",	RTYPE_GP | 2},  \     {"$v1",	RTYPE_GP | 3},  \     {"$a0",	RTYPE_GP | 4},  \     {"$a1",	RTYPE_GP | 5},  \     {"$a2",	RTYPE_GP | 6},  \     {"$a3",	RTYPE_GP | 7},  \     {"$s0",	RTYPE_GP | 16}, \     {"$s1",	RTYPE_GP | 17}, \     {"$s2",	RTYPE_GP | 18}, \     {"$s3",	RTYPE_GP | 19}, \     {"$s4",	RTYPE_GP | 20}, \     {"$s5",	RTYPE_GP | 21}, \     {"$s6",	RTYPE_GP | 22}, \     {"$s7",	RTYPE_GP | 23}, \     {"$t8",	RTYPE_GP | 24}, \     {"$t9",	RTYPE_GP | 25}, \     {"$k0",	RTYPE_GP | 26}, \     {"$kt0",	RTYPE_GP | 26}, \     {"$k1",	RTYPE_GP | 27}, \     {"$kt1",	RTYPE_GP | 27}, \     {"$gp",	RTYPE_GP | 28}, \     {"$sp",	RTYPE_GP | 29}, \     {"$s8",	RTYPE_GP | 30}, \     {"$fp",	RTYPE_GP | 30}, \     {"$ra",	RTYPE_GP | 31}
end_define

begin_define
define|#
directive|define
name|MIPS16_SPECIAL_REGISTER_NAMES
define|\
value|{"$pc",	RTYPE_PC | 0}
end_define

begin_define
define|#
directive|define
name|MDMX_VECTOR_REGISTER_NAMES
define|\
comment|/* {"$v0",	RTYPE_VEC | 0},  clash with REG 2 above */
define|\
comment|/* {"$v1",	RTYPE_VEC | 1},  clash with REG 3 above */
define|\
value|{"$v2",	RTYPE_VEC | 2},  \     {"$v3",	RTYPE_VEC | 3},  \     {"$v4",	RTYPE_VEC | 4},  \     {"$v5",	RTYPE_VEC | 5},  \     {"$v6",	RTYPE_VEC | 6},  \     {"$v7",	RTYPE_VEC | 7},  \     {"$v8",	RTYPE_VEC | 8},  \     {"$v9",	RTYPE_VEC | 9},  \     {"$v10",	RTYPE_VEC | 10}, \     {"$v11",	RTYPE_VEC | 11}, \     {"$v12",	RTYPE_VEC | 12}, \     {"$v13",	RTYPE_VEC | 13}, \     {"$v14",	RTYPE_VEC | 14}, \     {"$v15",	RTYPE_VEC | 15}, \     {"$v16",	RTYPE_VEC | 16}, \     {"$v17",	RTYPE_VEC | 17}, \     {"$v18",	RTYPE_VEC | 18}, \     {"$v19",	RTYPE_VEC | 19}, \     {"$v20",	RTYPE_VEC | 20}, \     {"$v21",	RTYPE_VEC | 21}, \     {"$v22",	RTYPE_VEC | 22}, \     {"$v23",	RTYPE_VEC | 23}, \     {"$v24",	RTYPE_VEC | 24}, \     {"$v25",	RTYPE_VEC | 25}, \     {"$v26",	RTYPE_VEC | 26}, \     {"$v27",	RTYPE_VEC | 27}, \     {"$v28",	RTYPE_VEC | 28}, \     {"$v29",	RTYPE_VEC | 29}, \     {"$v30",	RTYPE_VEC | 30}, \     {"$v31",	RTYPE_VEC | 31}
end_define

begin_define
define|#
directive|define
name|MIPS_DSP_ACCUMULATOR_NAMES
define|\
value|{"$ac0",	RTYPE_ACC | 0}, \     {"$ac1",	RTYPE_ACC | 1}, \     {"$ac2",	RTYPE_ACC | 2}, \     {"$ac3",	RTYPE_ACC | 3}
end_define

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|regname
name|reg_names
index|[]
init|=
block|{
name|GENERIC_REGISTER_NUMBERS
block|,
name|FPU_REGISTER_NAMES
block|,
name|FPU_CONDITION_CODE_NAMES
block|,
name|COPROC_CONDITION_CODE_NAMES
block|,
comment|/* The $txx registers depends on the abi,      these will be added later into the symbol table from      one of the tables below once mips_abi is set after       parsing of arguments from the command line. */
name|SYMBOLIC_REGISTER_NAMES
block|,
name|MIPS16_SPECIAL_REGISTER_NAMES
block|,
name|MDMX_VECTOR_REGISTER_NAMES
block|,
name|MIPS_DSP_ACCUMULATOR_NAMES
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|regname
name|reg_names_o32
index|[]
init|=
block|{
name|O32_SYMBOLIC_REGISTER_NAMES
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|regname
name|reg_names_n32n64
index|[]
init|=
block|{
name|N32N64_SYMBOLIC_REGISTER_NAMES
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|reg_lookup
parameter_list|(
name|char
modifier|*
modifier|*
name|s
parameter_list|,
name|unsigned
name|int
name|types
parameter_list|,
name|unsigned
name|int
modifier|*
name|regnop
parameter_list|)
block|{
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
name|char
modifier|*
name|e
decl_stmt|;
name|char
name|save_c
decl_stmt|;
name|int
name|reg
init|=
operator|-
literal|1
decl_stmt|;
comment|/* Find end of name.  */
name|e
operator|=
operator|*
name|s
expr_stmt|;
if|if
condition|(
name|is_name_beginner
argument_list|(
operator|*
name|e
argument_list|)
condition|)
operator|++
name|e
expr_stmt|;
while|while
condition|(
name|is_part_of_name
argument_list|(
operator|*
name|e
argument_list|)
condition|)
operator|++
name|e
expr_stmt|;
comment|/* Terminate name.  */
name|save_c
operator|=
operator|*
name|e
expr_stmt|;
operator|*
name|e
operator|=
literal|'\0'
expr_stmt|;
comment|/* Look for a register symbol.  */
if|if
condition|(
operator|(
name|symbolP
operator|=
name|symbol_find
argument_list|(
operator|*
name|s
argument_list|)
operator|)
operator|&&
name|S_GET_SEGMENT
argument_list|(
name|symbolP
argument_list|)
operator|==
name|reg_section
condition|)
block|{
name|int
name|r
init|=
name|S_GET_VALUE
argument_list|(
name|symbolP
argument_list|)
decl_stmt|;
if|if
condition|(
name|r
operator|&
name|types
condition|)
name|reg
operator|=
name|r
operator|&
name|RNUM_MASK
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|types
operator|&
name|RTYPE_VEC
operator|)
operator|&&
operator|(
name|r
operator|&
operator|~
literal|1
operator|)
operator|==
operator|(
name|RTYPE_GP
operator||
literal|2
operator|)
condition|)
comment|/* Convert GP reg $v0/1 to MDMX reg $v0/1!  */
name|reg
operator|=
operator|(
name|r
operator|&
name|RNUM_MASK
operator|)
operator|-
literal|2
expr_stmt|;
block|}
comment|/* Else see if this is a register defined in an itbl entry.  */
elseif|else
if|if
condition|(
operator|(
name|types
operator|&
name|RTYPE_GP
operator|)
operator|&&
name|itbl_have_entries
condition|)
block|{
name|char
modifier|*
name|n
init|=
operator|*
name|s
decl_stmt|;
name|unsigned
name|long
name|r
decl_stmt|;
if|if
condition|(
operator|*
name|n
operator|==
literal|'$'
condition|)
operator|++
name|n
expr_stmt|;
if|if
condition|(
name|itbl_get_reg_val
argument_list|(
name|n
argument_list|,
operator|&
name|r
argument_list|)
condition|)
name|reg
operator|=
name|r
operator|&
name|RNUM_MASK
expr_stmt|;
block|}
comment|/* Advance to next token if a register was recognised.  */
if|if
condition|(
name|reg
operator|>=
literal|0
condition|)
operator|*
name|s
operator|=
name|e
expr_stmt|;
elseif|else
if|if
condition|(
name|types
operator|&
name|RWARN
condition|)
name|as_warn
argument_list|(
literal|"Unrecognized register name `%s'"
argument_list|,
operator|*
name|s
argument_list|)
expr_stmt|;
operator|*
name|e
operator|=
name|save_c
expr_stmt|;
if|if
condition|(
name|regnop
condition|)
operator|*
name|regnop
operator|=
name|reg
expr_stmt|;
return|return
name|reg
operator|>=
literal|0
return|;
block|}
end_function

begin_comment
comment|/* This function is called once, at assembler startup time.  It should set up    all the tables, etc. that the MD part of the assembler will need.  */
end_comment

begin_function
name|void
name|md_begin
parameter_list|(
name|void
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|retval
init|=
name|NULL
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
name|int
name|broken
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|mips_pic
operator|!=
name|NO_PIC
condition|)
block|{
if|if
condition|(
name|g_switch_seen
operator|&&
name|g_switch_value
operator|!=
literal|0
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"-G may not be used in position-independent code"
argument_list|)
argument_list|)
expr_stmt|;
name|g_switch_value
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|bfd_set_arch_mach
argument_list|(
name|stdoutput
argument_list|,
name|bfd_arch_mips
argument_list|,
name|file_mips_arch
argument_list|)
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"Could not set architecture and machine"
argument_list|)
argument_list|)
expr_stmt|;
name|op_hash
operator|=
name|hash_new
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUMOPCODES
condition|;
control|)
block|{
specifier|const
name|char
modifier|*
name|name
init|=
name|mips_opcodes
index|[
name|i
index|]
operator|.
name|name
decl_stmt|;
name|retval
operator|=
name|hash_insert
argument_list|(
name|op_hash
argument_list|,
name|name
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|mips_opcodes
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"internal error: can't hash `%s': %s\n"
argument_list|)
argument_list|,
name|mips_opcodes
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|retval
argument_list|)
expr_stmt|;
comment|/* Probably a memory allocation problem?  Give up now.  */
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"Broken assembler.  No assembly attempted."
argument_list|)
argument_list|)
expr_stmt|;
block|}
do|do
block|{
if|if
condition|(
name|mips_opcodes
index|[
name|i
index|]
operator|.
name|pinfo
operator|!=
name|INSN_MACRO
condition|)
block|{
if|if
condition|(
operator|!
name|validate_mips_insn
argument_list|(
operator|&
name|mips_opcodes
index|[
name|i
index|]
argument_list|)
condition|)
name|broken
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|nop_insn
operator|.
name|insn_mo
operator|==
name|NULL
operator|&&
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"nop"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|create_insn
argument_list|(
operator|&
name|nop_insn
argument_list|,
name|mips_opcodes
operator|+
name|i
argument_list|)
expr_stmt|;
name|nop_insn
operator|.
name|fixed_p
operator|=
literal|1
expr_stmt|;
block|}
block|}
operator|++
name|i
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|i
operator|<
name|NUMOPCODES
operator|)
operator|&&
operator|!
name|strcmp
argument_list|(
name|mips_opcodes
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|name
argument_list|)
condition|)
do|;
block|}
name|mips16_op_hash
operator|=
name|hash_new
argument_list|()
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|bfd_mips16_num_opcodes
condition|)
block|{
specifier|const
name|char
modifier|*
name|name
init|=
name|mips16_opcodes
index|[
name|i
index|]
operator|.
name|name
decl_stmt|;
name|retval
operator|=
name|hash_insert
argument_list|(
name|mips16_op_hash
argument_list|,
name|name
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|mips16_opcodes
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
name|NULL
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"internal: can't hash `%s': %s"
argument_list|)
argument_list|,
name|mips16_opcodes
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|retval
argument_list|)
expr_stmt|;
do|do
block|{
if|if
condition|(
name|mips16_opcodes
index|[
name|i
index|]
operator|.
name|pinfo
operator|!=
name|INSN_MACRO
operator|&&
operator|(
operator|(
name|mips16_opcodes
index|[
name|i
index|]
operator|.
name|match
operator|&
name|mips16_opcodes
index|[
name|i
index|]
operator|.
name|mask
operator|)
operator|!=
name|mips16_opcodes
index|[
name|i
index|]
operator|.
name|match
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"internal error: bad mips16 opcode: %s %s\n"
argument_list|)
argument_list|,
name|mips16_opcodes
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|mips16_opcodes
index|[
name|i
index|]
operator|.
name|args
argument_list|)
expr_stmt|;
name|broken
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|mips16_nop_insn
operator|.
name|insn_mo
operator|==
name|NULL
operator|&&
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"nop"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|create_insn
argument_list|(
operator|&
name|mips16_nop_insn
argument_list|,
name|mips16_opcodes
operator|+
name|i
argument_list|)
expr_stmt|;
name|mips16_nop_insn
operator|.
name|fixed_p
operator|=
literal|1
expr_stmt|;
block|}
operator|++
name|i
expr_stmt|;
block|}
do|while
condition|(
name|i
operator|<
name|bfd_mips16_num_opcodes
operator|&&
name|strcmp
argument_list|(
name|mips16_opcodes
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
do|;
block|}
if|if
condition|(
name|broken
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"Broken assembler.  No assembly attempted."
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We add all the general register names to the symbol table.  This      helps us detect invalid uses of them.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|reg_names
index|[
name|i
index|]
operator|.
name|name
condition|;
name|i
operator|++
control|)
name|symbol_table_insert
argument_list|(
name|symbol_new
argument_list|(
name|reg_names
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|reg_section
argument_list|,
name|reg_names
index|[
name|i
index|]
operator|.
name|num
argument_list|,
comment|//& RNUM_MASK,
operator|&
name|zero_address_frag
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|HAVE_NEWABI
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|reg_names_n32n64
index|[
name|i
index|]
operator|.
name|name
condition|;
name|i
operator|++
control|)
name|symbol_table_insert
argument_list|(
name|symbol_new
argument_list|(
name|reg_names_n32n64
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|reg_section
argument_list|,
name|reg_names_n32n64
index|[
name|i
index|]
operator|.
name|num
argument_list|,
comment|//& RNUM_MASK,
operator|&
name|zero_address_frag
argument_list|)
argument_list|)
expr_stmt|;
else|else
for|for
control|(
name|i
operator|=
literal|0
init|;
name|reg_names_o32
index|[
name|i
index|]
operator|.
name|name
condition|;
name|i
operator|++
control|)
name|symbol_table_insert
argument_list|(
name|symbol_new
argument_list|(
name|reg_names_o32
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|reg_section
argument_list|,
name|reg_names_o32
index|[
name|i
index|]
operator|.
name|num
argument_list|,
comment|//& RNUM_MASK,
operator|&
name|zero_address_frag
argument_list|)
argument_list|)
expr_stmt|;
name|mips_no_prev_insn
argument_list|()
expr_stmt|;
name|mips_gprmask
operator|=
literal|0
expr_stmt|;
name|mips_cprmask
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|mips_cprmask
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|mips_cprmask
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|mips_cprmask
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
comment|/* set the default alignment for the text section (2**2) */
name|record_alignment
argument_list|(
name|text_section
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|bfd_set_gp_size
argument_list|(
name|stdoutput
argument_list|,
name|g_switch_value
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|OBJ_ELF
if|if
condition|(
name|IS_ELF
condition|)
block|{
comment|/* On a native system other than VxWorks, sections must be aligned 	 to 16 byte boundaries.  When configured for an embedded ELF 	 target, we don't bother.  */
if|if
condition|(
name|strcmp
argument_list|(
name|TARGET_OS
argument_list|,
literal|"elf"
argument_list|)
operator|!=
literal|0
operator|&&
name|strcmp
argument_list|(
name|TARGET_OS
argument_list|,
literal|"vxworks"
argument_list|)
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|bfd_set_section_alignment
argument_list|(
name|stdoutput
argument_list|,
name|text_section
argument_list|,
literal|4
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|bfd_set_section_alignment
argument_list|(
name|stdoutput
argument_list|,
name|data_section
argument_list|,
literal|4
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|bfd_set_section_alignment
argument_list|(
name|stdoutput
argument_list|,
name|bss_section
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
comment|/* Create a .reginfo section for register masks and a .mdebug 	 section for debugging information.  */
block|{
name|segT
name|seg
decl_stmt|;
name|subsegT
name|subseg
decl_stmt|;
name|flagword
name|flags
decl_stmt|;
name|segT
name|sec
decl_stmt|;
name|seg
operator|=
name|now_seg
expr_stmt|;
name|subseg
operator|=
name|now_subseg
expr_stmt|;
comment|/* The ABI says this section should be loaded so that the 	   running program can access it.  However, we don't load it 	   if we are configured for an embedded target */
name|flags
operator|=
name|SEC_READONLY
operator||
name|SEC_DATA
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|TARGET_OS
argument_list|,
literal|"elf"
argument_list|)
operator|!=
literal|0
condition|)
name|flags
operator||=
name|SEC_ALLOC
operator||
name|SEC_LOAD
expr_stmt|;
if|if
condition|(
name|mips_abi
operator|!=
name|N64_ABI
condition|)
block|{
name|sec
operator|=
name|subseg_new
argument_list|(
literal|".reginfo"
argument_list|,
operator|(
name|subsegT
operator|)
literal|0
argument_list|)
expr_stmt|;
name|bfd_set_section_flags
argument_list|(
name|stdoutput
argument_list|,
name|sec
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|bfd_set_section_alignment
argument_list|(
name|stdoutput
argument_list|,
name|sec
argument_list|,
name|HAVE_NEWABI
condition|?
literal|3
else|:
literal|2
argument_list|)
expr_stmt|;
name|mips_regmask_frag
operator|=
name|frag_more
argument_list|(
sizeof|sizeof
argument_list|(
name|Elf32_External_RegInfo
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* The 64-bit ABI uses a .MIPS.options section rather than                .reginfo section.  */
name|sec
operator|=
name|subseg_new
argument_list|(
literal|".MIPS.options"
argument_list|,
operator|(
name|subsegT
operator|)
literal|0
argument_list|)
expr_stmt|;
name|bfd_set_section_flags
argument_list|(
name|stdoutput
argument_list|,
name|sec
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|bfd_set_section_alignment
argument_list|(
name|stdoutput
argument_list|,
name|sec
argument_list|,
literal|3
argument_list|)
expr_stmt|;
comment|/* Set up the option header.  */
block|{
name|Elf_Internal_Options
name|opthdr
decl_stmt|;
name|char
modifier|*
name|f
decl_stmt|;
name|opthdr
operator|.
name|kind
operator|=
name|ODK_REGINFO
expr_stmt|;
name|opthdr
operator|.
name|size
operator|=
operator|(
sizeof|sizeof
argument_list|(
name|Elf_External_Options
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|Elf64_External_RegInfo
argument_list|)
operator|)
expr_stmt|;
name|opthdr
operator|.
name|section
operator|=
literal|0
expr_stmt|;
name|opthdr
operator|.
name|info
operator|=
literal|0
expr_stmt|;
name|f
operator|=
name|frag_more
argument_list|(
sizeof|sizeof
argument_list|(
name|Elf_External_Options
argument_list|)
argument_list|)
expr_stmt|;
name|bfd_mips_elf_swap_options_out
argument_list|(
name|stdoutput
argument_list|,
operator|&
name|opthdr
argument_list|,
operator|(
name|Elf_External_Options
operator|*
operator|)
name|f
argument_list|)
expr_stmt|;
name|mips_regmask_frag
operator|=
name|frag_more
argument_list|(
sizeof|sizeof
argument_list|(
name|Elf64_External_RegInfo
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ECOFF_DEBUGGING
condition|)
block|{
name|sec
operator|=
name|subseg_new
argument_list|(
literal|".mdebug"
argument_list|,
operator|(
name|subsegT
operator|)
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|bfd_set_section_flags
argument_list|(
name|stdoutput
argument_list|,
name|sec
argument_list|,
name|SEC_HAS_CONTENTS
operator||
name|SEC_READONLY
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|bfd_set_section_alignment
argument_list|(
name|stdoutput
argument_list|,
name|sec
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mips_flag_pdr
condition|)
block|{
name|pdr_seg
operator|=
name|subseg_new
argument_list|(
literal|".pdr"
argument_list|,
operator|(
name|subsegT
operator|)
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|bfd_set_section_flags
argument_list|(
name|stdoutput
argument_list|,
name|pdr_seg
argument_list|,
name|SEC_READONLY
operator||
name|SEC_RELOC
operator||
name|SEC_DEBUGGING
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|bfd_set_section_alignment
argument_list|(
name|stdoutput
argument_list|,
name|pdr_seg
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
name|subseg_set
argument_list|(
name|seg
argument_list|,
name|subseg
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* OBJ_ELF */
if|if
condition|(
operator|!
name|ECOFF_DEBUGGING
condition|)
name|md_obj_begin
argument_list|()
expr_stmt|;
if|if
condition|(
name|mips_fix_vr4120
condition|)
name|init_vr4120_conflicts
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|md_mips_end
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
name|ECOFF_DEBUGGING
condition|)
name|md_obj_end
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|md_assemble
parameter_list|(
name|char
modifier|*
name|str
parameter_list|)
block|{
name|struct
name|mips_cl_insn
name|insn
decl_stmt|;
name|bfd_reloc_code_real_type
name|unused_reloc
index|[
literal|3
index|]
init|=
block|{
name|BFD_RELOC_UNUSED
block|,
name|BFD_RELOC_UNUSED
block|,
name|BFD_RELOC_UNUSED
block|}
decl_stmt|;
name|imm_expr
operator|.
name|X_op
operator|=
name|O_absent
expr_stmt|;
name|imm2_expr
operator|.
name|X_op
operator|=
name|O_absent
expr_stmt|;
name|offset_expr
operator|.
name|X_op
operator|=
name|O_absent
expr_stmt|;
name|imm_reloc
index|[
literal|0
index|]
operator|=
name|BFD_RELOC_UNUSED
expr_stmt|;
name|imm_reloc
index|[
literal|1
index|]
operator|=
name|BFD_RELOC_UNUSED
expr_stmt|;
name|imm_reloc
index|[
literal|2
index|]
operator|=
name|BFD_RELOC_UNUSED
expr_stmt|;
name|offset_reloc
index|[
literal|0
index|]
operator|=
name|BFD_RELOC_UNUSED
expr_stmt|;
name|offset_reloc
index|[
literal|1
index|]
operator|=
name|BFD_RELOC_UNUSED
expr_stmt|;
name|offset_reloc
index|[
literal|2
index|]
operator|=
name|BFD_RELOC_UNUSED
expr_stmt|;
if|if
condition|(
name|mips_opts
operator|.
name|mips16
condition|)
name|mips16_ip
argument_list|(
name|str
argument_list|,
operator|&
name|insn
argument_list|)
expr_stmt|;
else|else
block|{
name|mips_ip
argument_list|(
name|str
argument_list|,
operator|&
name|insn
argument_list|)
expr_stmt|;
name|DBG
argument_list|(
operator|(
name|_
argument_list|(
literal|"returned from mips_ip(%s) insn_opcode = 0x%x\n"
argument_list|)
operator|,
name|str
operator|,
name|insn
operator|.
name|insn_opcode
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|insn_error
condition|)
block|{
name|as_bad
argument_list|(
literal|"%s `%s'"
argument_list|,
name|insn_error
argument_list|,
name|str
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|insn
operator|.
name|insn_mo
operator|->
name|pinfo
operator|==
name|INSN_MACRO
condition|)
block|{
name|macro_start
argument_list|()
expr_stmt|;
if|if
condition|(
name|mips_opts
operator|.
name|mips16
condition|)
name|mips16_macro
argument_list|(
operator|&
name|insn
argument_list|)
expr_stmt|;
else|else
name|macro
argument_list|(
operator|&
name|insn
argument_list|)
expr_stmt|;
name|macro_end
argument_list|()
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|imm_expr
operator|.
name|X_op
operator|!=
name|O_absent
condition|)
name|append_insn
argument_list|(
operator|&
name|insn
argument_list|,
operator|&
name|imm_expr
argument_list|,
name|imm_reloc
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|offset_expr
operator|.
name|X_op
operator|!=
name|O_absent
condition|)
name|append_insn
argument_list|(
operator|&
name|insn
argument_list|,
operator|&
name|offset_expr
argument_list|,
name|offset_reloc
argument_list|)
expr_stmt|;
else|else
name|append_insn
argument_list|(
operator|&
name|insn
argument_list|,
name|NULL
argument_list|,
name|unused_reloc
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return true if the given relocation might need a matching %lo().    This is only "might" because SVR4 R_MIPS_GOT16 relocations only    need a matching %lo() when applied to local symbols.  */
end_comment

begin_function
specifier|static
specifier|inline
name|bfd_boolean
name|reloc_needs_lo_p
parameter_list|(
name|bfd_reloc_code_real_type
name|reloc
parameter_list|)
block|{
return|return
operator|(
name|HAVE_IN_PLACE_ADDENDS
operator|&&
operator|(
name|reloc
operator|==
name|BFD_RELOC_HI16_S
operator|||
name|reloc
operator|==
name|BFD_RELOC_MIPS16_HI16_S
comment|/* VxWorks R_MIPS_GOT16 relocs never need a matching %lo(); 		 all GOT16 relocations evaluate to "G".  */
operator|||
operator|(
name|reloc
operator|==
name|BFD_RELOC_MIPS_GOT16
operator|&&
name|mips_pic
operator|!=
name|VXWORKS_PIC
operator|)
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return true if the given fixup is followed by a matching R_MIPS_LO16    relocation.  */
end_comment

begin_function
specifier|static
specifier|inline
name|bfd_boolean
name|fixup_has_matching_lo_p
parameter_list|(
name|fixS
modifier|*
name|fixp
parameter_list|)
block|{
return|return
operator|(
name|fixp
operator|->
name|fx_next
operator|!=
name|NULL
operator|&&
operator|(
name|fixp
operator|->
name|fx_next
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_LO16
operator|||
name|fixp
operator|->
name|fx_next
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_MIPS16_LO16
operator|)
operator|&&
name|fixp
operator|->
name|fx_addsy
operator|==
name|fixp
operator|->
name|fx_next
operator|->
name|fx_addsy
operator|&&
name|fixp
operator|->
name|fx_offset
operator|==
name|fixp
operator|->
name|fx_next
operator|->
name|fx_offset
operator|)
return|;
block|}
end_function

begin_comment
comment|/* See whether instruction IP reads register REG.  CLASS is the type    of register.  */
end_comment

begin_function
specifier|static
name|int
name|insn_uses_reg
parameter_list|(
specifier|const
name|struct
name|mips_cl_insn
modifier|*
name|ip
parameter_list|,
name|unsigned
name|int
name|reg
parameter_list|,
name|enum
name|mips_regclass
name|class
parameter_list|)
block|{
if|if
condition|(
name|class
operator|==
name|MIPS16_REG
condition|)
block|{
name|assert
argument_list|(
name|mips_opts
operator|.
name|mips16
argument_list|)
expr_stmt|;
name|reg
operator|=
name|mips16_to_32_reg_map
index|[
name|reg
index|]
expr_stmt|;
name|class
operator|=
name|MIPS_GR_REG
expr_stmt|;
block|}
comment|/* Don't report on general register ZERO, since it never changes.  */
if|if
condition|(
name|class
operator|==
name|MIPS_GR_REG
operator|&&
name|reg
operator|==
name|ZERO
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|class
operator|==
name|MIPS_FP_REG
condition|)
block|{
name|assert
argument_list|(
operator|!
name|mips_opts
operator|.
name|mips16
argument_list|)
expr_stmt|;
comment|/* If we are called with either $f0 or $f1, we must check $f0. 	 This is not optimal, because it will introduce an unnecessary 	 NOP between "lwc1 $f0" and "swc1 $f1".  To fix this we would 	 need to distinguish reading both $f0 and $f1 or just one of 	 them.  Note that we don't have to check the other way, 	 because there is no instruction that sets both $f0 and $f1 	 and requires a delay.  */
if|if
condition|(
operator|(
name|ip
operator|->
name|insn_mo
operator|->
name|pinfo
operator|&
name|INSN_READ_FPR_S
operator|)
operator|&&
operator|(
operator|(
name|EXTRACT_OPERAND
argument_list|(
name|FS
argument_list|,
operator|*
name|ip
argument_list|)
operator|&
operator|~
operator|(
name|unsigned
operator|)
literal|1
operator|)
operator|==
operator|(
name|reg
operator|&
operator|~
operator|(
name|unsigned
operator|)
literal|1
operator|)
operator|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|(
name|ip
operator|->
name|insn_mo
operator|->
name|pinfo
operator|&
name|INSN_READ_FPR_T
operator|)
operator|&&
operator|(
operator|(
name|EXTRACT_OPERAND
argument_list|(
name|FT
argument_list|,
operator|*
name|ip
argument_list|)
operator|&
operator|~
operator|(
name|unsigned
operator|)
literal|1
operator|)
operator|==
operator|(
name|reg
operator|&
operator|~
operator|(
name|unsigned
operator|)
literal|1
operator|)
operator|)
condition|)
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|mips_opts
operator|.
name|mips16
condition|)
block|{
if|if
condition|(
operator|(
name|ip
operator|->
name|insn_mo
operator|->
name|pinfo
operator|&
name|INSN_READ_GPR_S
operator|)
operator|&&
name|EXTRACT_OPERAND
argument_list|(
name|RS
argument_list|,
operator|*
name|ip
argument_list|)
operator|==
name|reg
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|(
name|ip
operator|->
name|insn_mo
operator|->
name|pinfo
operator|&
name|INSN_READ_GPR_T
operator|)
operator|&&
name|EXTRACT_OPERAND
argument_list|(
name|RT
argument_list|,
operator|*
name|ip
argument_list|)
operator|==
name|reg
condition|)
return|return
literal|1
return|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|ip
operator|->
name|insn_mo
operator|->
name|pinfo
operator|&
name|MIPS16_INSN_READ_X
operator|)
operator|&&
name|mips16_to_32_reg_map
index|[
name|MIPS16_EXTRACT_OPERAND
argument_list|(
name|RX
argument_list|,
operator|*
name|ip
argument_list|)
index|]
operator|==
name|reg
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|(
name|ip
operator|->
name|insn_mo
operator|->
name|pinfo
operator|&
name|MIPS16_INSN_READ_Y
operator|)
operator|&&
name|mips16_to_32_reg_map
index|[
name|MIPS16_EXTRACT_OPERAND
argument_list|(
name|RY
argument_list|,
operator|*
name|ip
argument_list|)
index|]
operator|==
name|reg
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|(
name|ip
operator|->
name|insn_mo
operator|->
name|pinfo
operator|&
name|MIPS16_INSN_READ_Z
operator|)
operator|&&
operator|(
name|mips16_to_32_reg_map
index|[
name|MIPS16_EXTRACT_OPERAND
argument_list|(
name|MOVE32Z
argument_list|,
operator|*
name|ip
argument_list|)
index|]
operator|==
name|reg
operator|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|(
name|ip
operator|->
name|insn_mo
operator|->
name|pinfo
operator|&
name|MIPS16_INSN_READ_T
operator|)
operator|&&
name|reg
operator|==
name|TREG
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|(
name|ip
operator|->
name|insn_mo
operator|->
name|pinfo
operator|&
name|MIPS16_INSN_READ_SP
operator|)
operator|&&
name|reg
operator|==
name|SP
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|(
name|ip
operator|->
name|insn_mo
operator|->
name|pinfo
operator|&
name|MIPS16_INSN_READ_31
operator|)
operator|&&
name|reg
operator|==
name|RA
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|(
name|ip
operator|->
name|insn_mo
operator|->
name|pinfo
operator|&
name|MIPS16_INSN_READ_GPR_X
operator|)
operator|&&
name|MIPS16_EXTRACT_OPERAND
argument_list|(
name|REGR32
argument_list|,
operator|*
name|ip
argument_list|)
operator|==
name|reg
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* This function returns true if modifying a register requires a    delay.  */
end_comment

begin_function
specifier|static
name|int
name|reg_needs_delay
parameter_list|(
name|unsigned
name|int
name|reg
parameter_list|)
block|{
name|unsigned
name|long
name|prev_pinfo
decl_stmt|;
name|prev_pinfo
operator|=
name|history
index|[
literal|0
index|]
operator|.
name|insn_mo
operator|->
name|pinfo
expr_stmt|;
if|if
condition|(
operator|!
name|mips_opts
operator|.
name|noreorder
operator|&&
operator|(
operator|(
operator|(
name|prev_pinfo
operator|&
name|INSN_LOAD_MEMORY_DELAY
operator|)
operator|&&
operator|!
name|gpr_interlocks
operator|)
operator|||
operator|(
operator|(
name|prev_pinfo
operator|&
name|INSN_LOAD_COPROC_DELAY
operator|)
operator|&&
operator|!
name|cop_interlocks
operator|)
operator|)
condition|)
block|{
comment|/* A load from a coprocessor or from memory.  All load delays 	 delay the use of general register rt for one instruction.  */
comment|/* Itbl support may require additional care here.  */
name|know
argument_list|(
name|prev_pinfo
operator|&
name|INSN_WRITE_GPR_T
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
operator|==
name|EXTRACT_OPERAND
argument_list|(
name|RT
argument_list|,
name|history
index|[
literal|0
index|]
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Move all labels in insn_labels to the current insertion point.  */
end_comment

begin_function
specifier|static
name|void
name|mips_move_labels
parameter_list|(
name|void
parameter_list|)
block|{
name|segment_info_type
modifier|*
name|si
init|=
name|seg_info
argument_list|(
name|now_seg
argument_list|)
decl_stmt|;
name|struct
name|insn_label_list
modifier|*
name|l
decl_stmt|;
name|valueT
name|val
decl_stmt|;
for|for
control|(
name|l
operator|=
name|si
operator|->
name|label_list
init|;
name|l
operator|!=
name|NULL
condition|;
name|l
operator|=
name|l
operator|->
name|next
control|)
block|{
name|assert
argument_list|(
name|S_GET_SEGMENT
argument_list|(
name|l
operator|->
name|label
argument_list|)
operator|==
name|now_seg
argument_list|)
expr_stmt|;
name|symbol_set_frag
argument_list|(
name|l
operator|->
name|label
argument_list|,
name|frag_now
argument_list|)
expr_stmt|;
name|val
operator|=
operator|(
name|valueT
operator|)
name|frag_now_fix
argument_list|()
expr_stmt|;
comment|/* mips16 text labels are stored as odd.  */
if|if
condition|(
name|mips_opts
operator|.
name|mips16
condition|)
operator|++
name|val
expr_stmt|;
name|S_SET_VALUE
argument_list|(
name|l
operator|->
name|label
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|s_is_linkonce
parameter_list|(
name|symbolS
modifier|*
name|sym
parameter_list|,
name|segT
name|from_seg
parameter_list|)
block|{
name|bfd_boolean
name|linkonce
init|=
name|FALSE
decl_stmt|;
name|segT
name|symseg
init|=
name|S_GET_SEGMENT
argument_list|(
name|sym
argument_list|)
decl_stmt|;
if|if
condition|(
name|symseg
operator|!=
name|from_seg
operator|&&
operator|!
name|S_IS_LOCAL
argument_list|(
name|sym
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|bfd_get_section_flags
argument_list|(
name|stdoutput
argument_list|,
name|symseg
argument_list|)
operator|&
name|SEC_LINK_ONCE
operator|)
condition|)
name|linkonce
operator|=
name|TRUE
expr_stmt|;
ifdef|#
directive|ifdef
name|OBJ_ELF
comment|/* The GNU toolchain uses an extension for ELF: a section 	 beginning with the magic string .gnu.linkonce is a 	 linkonce section.  */
if|if
condition|(
name|strncmp
argument_list|(
name|segment_name
argument_list|(
name|symseg
argument_list|)
argument_list|,
literal|".gnu.linkonce"
argument_list|,
sizeof|sizeof
expr|".gnu.linkonce"
operator|-
literal|1
argument_list|)
operator|==
literal|0
condition|)
name|linkonce
operator|=
name|TRUE
expr_stmt|;
endif|#
directive|endif
block|}
return|return
name|linkonce
return|;
block|}
end_function

begin_comment
comment|/* Mark instruction labels in mips16 mode.  This permits the linker to    handle them specially, such as generating jalx instructions when    needed.  We also make them odd for the duration of the assembly, in    order to generate the right sort of code.  We will make them even    in the adjust_symtab routine, while leaving them marked.  This is    convenient for the debugger and the disassembler.  The linker knows    to make them odd again.  */
end_comment

begin_function
specifier|static
name|void
name|mips16_mark_labels
parameter_list|(
name|void
parameter_list|)
block|{
name|segment_info_type
modifier|*
name|si
init|=
name|seg_info
argument_list|(
name|now_seg
argument_list|)
decl_stmt|;
name|struct
name|insn_label_list
modifier|*
name|l
decl_stmt|;
if|if
condition|(
operator|!
name|mips_opts
operator|.
name|mips16
condition|)
return|return;
for|for
control|(
name|l
operator|=
name|si
operator|->
name|label_list
init|;
name|l
operator|!=
name|NULL
condition|;
name|l
operator|=
name|l
operator|->
name|next
control|)
block|{
name|symbolS
modifier|*
name|label
init|=
name|l
operator|->
name|label
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|OBJ_ELF
argument_list|)
operator|||
name|defined
argument_list|(
name|OBJ_MAYBE_ELF
argument_list|)
if|if
condition|(
name|IS_ELF
condition|)
name|S_SET_OTHER
argument_list|(
name|label
argument_list|,
name|STO_MIPS16
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|S_GET_VALUE
argument_list|(
name|label
argument_list|)
operator|&
literal|1
operator|)
operator|==
literal|0
comment|/* Don't adjust the address if the label is global or weak, or 	   in a link-once section, since we'll be emitting symbol reloc 	   references to it which will be patched up by the linker, and 	   the final value of the symbol may or may not be MIPS16.  */
operator|&&
operator|!
name|S_IS_WEAK
argument_list|(
name|label
argument_list|)
operator|&&
operator|!
name|S_IS_EXTERNAL
argument_list|(
name|label
argument_list|)
operator|&&
operator|!
name|s_is_linkonce
argument_list|(
name|label
argument_list|,
name|now_seg
argument_list|)
condition|)
name|S_SET_VALUE
argument_list|(
name|label
argument_list|,
name|S_GET_VALUE
argument_list|(
name|label
argument_list|)
operator||
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* End the current frag.  Make it a variant frag and record the    relaxation info.  */
end_comment

begin_function
specifier|static
name|void
name|relax_close_frag
parameter_list|(
name|void
parameter_list|)
block|{
name|mips_macro_warning
operator|.
name|first_frag
operator|=
name|frag_now
expr_stmt|;
name|frag_var
argument_list|(
name|rs_machine_dependent
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|RELAX_ENCODE
argument_list|(
name|mips_relax
operator|.
name|sizes
index|[
literal|0
index|]
argument_list|,
name|mips_relax
operator|.
name|sizes
index|[
literal|1
index|]
argument_list|)
argument_list|,
name|mips_relax
operator|.
name|symbol
argument_list|,
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|)
name|mips_relax
operator|.
name|first_fixup
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|mips_relax
operator|.
name|sizes
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|mips_relax
operator|.
name|sizes
argument_list|)
argument_list|)
expr_stmt|;
name|mips_relax
operator|.
name|first_fixup
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Start a new relaxation sequence whose expansion depends on SYMBOL.    See the comment above RELAX_ENCODE for more details.  */
end_comment

begin_function
specifier|static
name|void
name|relax_start
parameter_list|(
name|symbolS
modifier|*
name|symbol
parameter_list|)
block|{
name|assert
argument_list|(
name|mips_relax
operator|.
name|sequence
operator|==
literal|0
argument_list|)
expr_stmt|;
name|mips_relax
operator|.
name|sequence
operator|=
literal|1
expr_stmt|;
name|mips_relax
operator|.
name|symbol
operator|=
name|symbol
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Start generating the second version of a relaxable sequence.    See the comment above RELAX_ENCODE for more details.  */
end_comment

begin_function
specifier|static
name|void
name|relax_switch
parameter_list|(
name|void
parameter_list|)
block|{
name|assert
argument_list|(
name|mips_relax
operator|.
name|sequence
operator|==
literal|1
argument_list|)
expr_stmt|;
name|mips_relax
operator|.
name|sequence
operator|=
literal|2
expr_stmt|;
block|}
end_function

begin_comment
comment|/* End the current relaxable sequence.  */
end_comment

begin_function
specifier|static
name|void
name|relax_end
parameter_list|(
name|void
parameter_list|)
block|{
name|assert
argument_list|(
name|mips_relax
operator|.
name|sequence
operator|==
literal|2
argument_list|)
expr_stmt|;
name|relax_close_frag
argument_list|()
expr_stmt|;
name|mips_relax
operator|.
name|sequence
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Classify an instruction according to the FIX_VR4120_* enumeration.    Return NUM_FIX_VR4120_CLASSES if the instruction isn't affected    by VR4120 errata.  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|classify_vr4120_insn
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
literal|"macc"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
return|return
name|FIX_VR4120_MACC
return|;
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
literal|"dmacc"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
return|return
name|FIX_VR4120_DMACC
return|;
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
literal|"mult"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
return|return
name|FIX_VR4120_MULT
return|;
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
literal|"dmult"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
return|return
name|FIX_VR4120_DMULT
return|;
if|if
condition|(
name|strstr
argument_list|(
name|name
argument_list|,
literal|"div"
argument_list|)
condition|)
return|return
name|FIX_VR4120_DIV
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"mtlo"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"mthi"
argument_list|)
operator|==
literal|0
condition|)
return|return
name|FIX_VR4120_MTHILO
return|;
return|return
name|NUM_FIX_VR4120_CLASSES
return|;
block|}
end_function

begin_comment
comment|/* Return the number of instructions that must separate INSN1 and INSN2,    where INSN1 is the earlier instruction.  Return the worst-case value    for any INSN2 if INSN2 is null.  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|insns_between
parameter_list|(
specifier|const
name|struct
name|mips_cl_insn
modifier|*
name|insn1
parameter_list|,
specifier|const
name|struct
name|mips_cl_insn
modifier|*
name|insn2
parameter_list|)
block|{
name|unsigned
name|long
name|pinfo1
decl_stmt|,
name|pinfo2
decl_stmt|;
comment|/* This function needs to know which pinfo flags are set for INSN2      and which registers INSN2 uses.  The former is stored in PINFO2 and      the latter is tested via INSN2_USES_REG.  If INSN2 is null, PINFO2      will have every flag set and INSN2_USES_REG will always return true.  */
name|pinfo1
operator|=
name|insn1
operator|->
name|insn_mo
operator|->
name|pinfo
expr_stmt|;
name|pinfo2
operator|=
name|insn2
condition|?
name|insn2
operator|->
name|insn_mo
operator|->
name|pinfo
else|:
operator|~
literal|0U
expr_stmt|;
define|#
directive|define
name|INSN2_USES_REG
parameter_list|(
name|REG
parameter_list|,
name|CLASS
parameter_list|)
define|\
value|(insn2 == NULL || insn_uses_reg (insn2, REG, CLASS))
comment|/* For most targets, write-after-read dependencies on the HI and LO      registers must be separated by at least two instructions.  */
if|if
condition|(
operator|!
name|hilo_interlocks
condition|)
block|{
if|if
condition|(
operator|(
name|pinfo1
operator|&
name|INSN_READ_LO
operator|)
operator|&&
operator|(
name|pinfo2
operator|&
name|INSN_WRITE_LO
operator|)
condition|)
return|return
literal|2
return|;
if|if
condition|(
operator|(
name|pinfo1
operator|&
name|INSN_READ_HI
operator|)
operator|&&
operator|(
name|pinfo2
operator|&
name|INSN_WRITE_HI
operator|)
condition|)
return|return
literal|2
return|;
block|}
comment|/* If we're working around r7000 errata, there must be two instructions      between an mfhi or mflo and any instruction that uses the result.  */
if|if
condition|(
name|mips_7000_hilo_fix
operator|&&
name|MF_HILO_INSN
argument_list|(
name|pinfo1
argument_list|)
operator|&&
name|INSN2_USES_REG
argument_list|(
name|EXTRACT_OPERAND
argument_list|(
name|RD
argument_list|,
operator|*
name|insn1
argument_list|)
argument_list|,
name|MIPS_GR_REG
argument_list|)
condition|)
return|return
literal|2
return|;
comment|/* If working around VR4120 errata, check for combinations that need      a single intervening instruction.  */
if|if
condition|(
name|mips_fix_vr4120
condition|)
block|{
name|unsigned
name|int
name|class1
decl_stmt|,
name|class2
decl_stmt|;
name|class1
operator|=
name|classify_vr4120_insn
argument_list|(
name|insn1
operator|->
name|insn_mo
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|class1
operator|!=
name|NUM_FIX_VR4120_CLASSES
operator|&&
name|vr4120_conflicts
index|[
name|class1
index|]
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|insn2
operator|==
name|NULL
condition|)
return|return
literal|1
return|;
name|class2
operator|=
name|classify_vr4120_insn
argument_list|(
name|insn2
operator|->
name|insn_mo
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|vr4120_conflicts
index|[
name|class1
index|]
operator|&
operator|(
literal|1
operator|<<
name|class2
operator|)
condition|)
return|return
literal|1
return|;
block|}
block|}
if|if
condition|(
operator|!
name|mips_opts
operator|.
name|mips16
condition|)
block|{
comment|/* Check for GPR or coprocessor load delays.  All such delays 	 are on the RT register.  */
comment|/* Itbl support may require additional care here.  */
if|if
condition|(
operator|(
operator|!
name|gpr_interlocks
operator|&&
operator|(
name|pinfo1
operator|&
name|INSN_LOAD_MEMORY_DELAY
operator|)
operator|)
operator|||
operator|(
operator|!
name|cop_interlocks
operator|&&
operator|(
name|pinfo1
operator|&
name|INSN_LOAD_COPROC_DELAY
operator|)
operator|)
condition|)
block|{
name|know
argument_list|(
name|pinfo1
operator|&
name|INSN_WRITE_GPR_T
argument_list|)
expr_stmt|;
if|if
condition|(
name|INSN2_USES_REG
argument_list|(
name|EXTRACT_OPERAND
argument_list|(
name|RT
argument_list|,
operator|*
name|insn1
argument_list|)
argument_list|,
name|MIPS_GR_REG
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
comment|/* Check for generic coprocessor hazards.  	 This case is not handled very well.  There is no special 	 knowledge of CP0 handling, and the coprocessors other than 	 the floating point unit are not distinguished at all.  */
comment|/* Itbl support may require additional care here. FIXME! 	 Need to modify this to include knowledge about 	 user specified delays!  */
elseif|else
if|if
condition|(
operator|(
operator|!
name|cop_interlocks
operator|&&
operator|(
name|pinfo1
operator|&
name|INSN_COPROC_MOVE_DELAY
operator|)
operator|)
operator|||
operator|(
operator|!
name|cop_mem_interlocks
operator|&&
operator|(
name|pinfo1
operator|&
name|INSN_COPROC_MEMORY_DELAY
operator|)
operator|)
condition|)
block|{
comment|/* Handle cases where INSN1 writes to a known general coprocessor 	     register.  There must be a one instruction delay before INSN2 	     if INSN2 reads that register, otherwise no delay is needed.  */
if|if
condition|(
name|pinfo1
operator|&
name|INSN_WRITE_FPR_T
condition|)
block|{
if|if
condition|(
name|INSN2_USES_REG
argument_list|(
name|EXTRACT_OPERAND
argument_list|(
name|FT
argument_list|,
operator|*
name|insn1
argument_list|)
argument_list|,
name|MIPS_FP_REG
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|pinfo1
operator|&
name|INSN_WRITE_FPR_S
condition|)
block|{
if|if
condition|(
name|INSN2_USES_REG
argument_list|(
name|EXTRACT_OPERAND
argument_list|(
name|FS
argument_list|,
operator|*
name|insn1
argument_list|)
argument_list|,
name|MIPS_FP_REG
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
else|else
block|{
comment|/* Read-after-write dependencies on the control registers 		 require a two-instruction gap.  */
if|if
condition|(
operator|(
name|pinfo1
operator|&
name|INSN_WRITE_COND_CODE
operator|)
operator|&&
operator|(
name|pinfo2
operator|&
name|INSN_READ_COND_CODE
operator|)
condition|)
return|return
literal|2
return|;
comment|/* We don't know exactly what INSN1 does.  If INSN2 is 		 also a coprocessor instruction, assume there must be 		 a one instruction gap.  */
if|if
condition|(
name|pinfo2
operator|&
name|INSN_COP
condition|)
return|return
literal|1
return|;
block|}
block|}
comment|/* Check for read-after-write dependencies on the coprocessor 	 control registers in cases where INSN1 does not need a general 	 coprocessor delay.  This means that INSN1 is a floating point 	 comparison instruction.  */
comment|/* Itbl support may require additional care here.  */
elseif|else
if|if
condition|(
operator|!
name|cop_interlocks
operator|&&
operator|(
name|pinfo1
operator|&
name|INSN_WRITE_COND_CODE
operator|)
operator|&&
operator|(
name|pinfo2
operator|&
name|INSN_READ_COND_CODE
operator|)
condition|)
return|return
literal|1
return|;
block|}
undef|#
directive|undef
name|INSN2_USES_REG
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return the number of nops that would be needed to work around the    VR4130 mflo/mfhi errata if instruction INSN immediately followed    the MAX_VR4130_NOPS instructions described by HISTORY.  */
end_comment

begin_function
specifier|static
name|int
name|nops_for_vr4130
parameter_list|(
specifier|const
name|struct
name|mips_cl_insn
modifier|*
name|history
parameter_list|,
specifier|const
name|struct
name|mips_cl_insn
modifier|*
name|insn
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|reg
decl_stmt|;
comment|/* Check if the instruction writes to HI or LO.  MTHI and MTLO      are not affected by the errata.  */
if|if
condition|(
name|insn
operator|!=
literal|0
operator|&&
operator|(
operator|(
name|insn
operator|->
name|insn_mo
operator|->
name|pinfo
operator|&
operator|(
name|INSN_WRITE_HI
operator||
name|INSN_WRITE_LO
operator|)
operator|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|insn
operator|->
name|insn_mo
operator|->
name|name
argument_list|,
literal|"mtlo"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|insn
operator|->
name|insn_mo
operator|->
name|name
argument_list|,
literal|"mthi"
argument_list|)
operator|==
literal|0
operator|)
condition|)
return|return
literal|0
return|;
comment|/* Search for the first MFLO or MFHI.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_VR4130_NOPS
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|history
index|[
name|i
index|]
operator|.
name|noreorder_p
operator|&&
name|MF_HILO_INSN
argument_list|(
name|history
index|[
name|i
index|]
operator|.
name|insn_mo
operator|->
name|pinfo
argument_list|)
condition|)
block|{
comment|/* Extract the destination register.  */
if|if
condition|(
name|mips_opts
operator|.
name|mips16
condition|)
name|reg
operator|=
name|mips16_to_32_reg_map
index|[
name|MIPS16_EXTRACT_OPERAND
argument_list|(
name|RX
argument_list|,
name|history
index|[
name|i
index|]
argument_list|)
index|]
expr_stmt|;
else|else
name|reg
operator|=
name|EXTRACT_OPERAND
argument_list|(
name|RD
argument_list|,
name|history
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* No nops are needed if INSN reads that register.  */
if|if
condition|(
name|insn
operator|!=
name|NULL
operator|&&
name|insn_uses_reg
argument_list|(
name|insn
argument_list|,
name|reg
argument_list|,
name|MIPS_GR_REG
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* ...or if any of the intervening instructions do.  */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|i
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|insn_uses_reg
argument_list|(
operator|&
name|history
index|[
name|j
index|]
argument_list|,
name|reg
argument_list|,
name|MIPS_GR_REG
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
name|MAX_VR4130_NOPS
operator|-
name|i
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return the number of nops that would be needed if instruction INSN    immediately followed the MAX_NOPS instructions given by HISTORY,    where HISTORY[0] is the most recent instruction.  If INSN is null,    return the worse-case number of nops for any instruction.  */
end_comment

begin_function
specifier|static
name|int
name|nops_for_insn
parameter_list|(
specifier|const
name|struct
name|mips_cl_insn
modifier|*
name|history
parameter_list|,
specifier|const
name|struct
name|mips_cl_insn
modifier|*
name|insn
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|nops
decl_stmt|,
name|tmp_nops
decl_stmt|;
name|nops
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_DELAY_NOPS
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|history
index|[
name|i
index|]
operator|.
name|noreorder_p
condition|)
block|{
name|tmp_nops
operator|=
name|insns_between
argument_list|(
name|history
operator|+
name|i
argument_list|,
name|insn
argument_list|)
operator|-
name|i
expr_stmt|;
if|if
condition|(
name|tmp_nops
operator|>
name|nops
condition|)
name|nops
operator|=
name|tmp_nops
expr_stmt|;
block|}
if|if
condition|(
name|mips_fix_vr4130
condition|)
block|{
name|tmp_nops
operator|=
name|nops_for_vr4130
argument_list|(
name|history
argument_list|,
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp_nops
operator|>
name|nops
condition|)
name|nops
operator|=
name|tmp_nops
expr_stmt|;
block|}
return|return
name|nops
return|;
block|}
end_function

begin_comment
comment|/* The variable arguments provide NUM_INSNS extra instructions that    might be added to HISTORY.  Return the largest number of nops that    would be needed after the extended sequence.  */
end_comment

begin_function
specifier|static
name|int
name|nops_for_sequence
parameter_list|(
name|int
name|num_insns
parameter_list|,
specifier|const
name|struct
name|mips_cl_insn
modifier|*
name|history
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|args
decl_stmt|;
name|struct
name|mips_cl_insn
name|buffer
index|[
name|MAX_NOPS
index|]
decl_stmt|;
name|struct
name|mips_cl_insn
modifier|*
name|cursor
decl_stmt|;
name|int
name|nops
decl_stmt|;
name|va_start
argument_list|(
name|args
argument_list|,
name|history
argument_list|)
expr_stmt|;
name|cursor
operator|=
name|buffer
operator|+
name|num_insns
expr_stmt|;
name|memcpy
argument_list|(
name|cursor
argument_list|,
name|history
argument_list|,
operator|(
name|MAX_NOPS
operator|-
name|num_insns
operator|)
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|cursor
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|cursor
operator|>
name|buffer
condition|)
operator|*
operator|--
name|cursor
operator|=
operator|*
name|va_arg
argument_list|(
name|args
argument_list|,
specifier|const
expr|struct
name|mips_cl_insn
operator|*
argument_list|)
expr_stmt|;
name|nops
operator|=
name|nops_for_insn
argument_list|(
name|buffer
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
return|return
name|nops
return|;
block|}
end_function

begin_comment
comment|/* Like nops_for_insn, but if INSN is a branch, take into account the    worst-case delay for the branch target.  */
end_comment

begin_function
specifier|static
name|int
name|nops_for_insn_or_target
parameter_list|(
specifier|const
name|struct
name|mips_cl_insn
modifier|*
name|history
parameter_list|,
specifier|const
name|struct
name|mips_cl_insn
modifier|*
name|insn
parameter_list|)
block|{
name|int
name|nops
decl_stmt|,
name|tmp_nops
decl_stmt|;
name|nops
operator|=
name|nops_for_insn
argument_list|(
name|history
argument_list|,
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn
operator|->
name|insn_mo
operator|->
name|pinfo
operator|&
operator|(
name|INSN_UNCOND_BRANCH_DELAY
operator||
name|INSN_COND_BRANCH_DELAY
operator||
name|INSN_COND_BRANCH_LIKELY
operator|)
condition|)
block|{
name|tmp_nops
operator|=
name|nops_for_sequence
argument_list|(
literal|2
argument_list|,
name|history
argument_list|,
name|insn
argument_list|,
name|NOP_INSN
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp_nops
operator|>
name|nops
condition|)
name|nops
operator|=
name|tmp_nops
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mips_opts
operator|.
name|mips16
operator|&&
operator|(
name|insn
operator|->
name|insn_mo
operator|->
name|pinfo
operator|&
name|MIPS16_INSN_BRANCH
operator|)
condition|)
block|{
name|tmp_nops
operator|=
name|nops_for_sequence
argument_list|(
literal|1
argument_list|,
name|history
argument_list|,
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp_nops
operator|>
name|nops
condition|)
name|nops
operator|=
name|tmp_nops
expr_stmt|;
block|}
return|return
name|nops
return|;
block|}
end_function

begin_comment
comment|/* Output an instruction.  IP is the instruction information.    ADDRESS_EXPR is an operand of the instruction to be used with    RELOC_TYPE.  */
end_comment

begin_function
specifier|static
name|void
name|append_insn
parameter_list|(
name|struct
name|mips_cl_insn
modifier|*
name|ip
parameter_list|,
name|expressionS
modifier|*
name|address_expr
parameter_list|,
name|bfd_reloc_code_real_type
modifier|*
name|reloc_type
parameter_list|)
block|{
name|unsigned
name|long
name|prev_pinfo
decl_stmt|,
name|pinfo
decl_stmt|;
name|relax_stateT
name|prev_insn_frag_type
init|=
literal|0
decl_stmt|;
name|bfd_boolean
name|relaxed_branch
init|=
name|FALSE
decl_stmt|;
name|segment_info_type
modifier|*
name|si
init|=
name|seg_info
argument_list|(
name|now_seg
argument_list|)
decl_stmt|;
comment|/* Mark instruction labels in mips16 mode.  */
name|mips16_mark_labels
argument_list|()
expr_stmt|;
name|prev_pinfo
operator|=
name|history
index|[
literal|0
index|]
operator|.
name|insn_mo
operator|->
name|pinfo
expr_stmt|;
name|pinfo
operator|=
name|ip
operator|->
name|insn_mo
operator|->
name|pinfo
expr_stmt|;
if|if
condition|(
name|mips_relax
operator|.
name|sequence
operator|!=
literal|2
operator|&&
operator|!
name|mips_opts
operator|.
name|noreorder
condition|)
block|{
comment|/* There are a lot of optimizations we could do that we don't. 	 In particular, we do not, in general, reorder instructions. 	 If you use gcc with optimization, it will reorder 	 instructions and generally do much more optimization then we 	 do here; repeating all that work in the assembler would only 	 benefit hand written assembly code, and does not seem worth 	 it.  */
name|int
name|nops
init|=
operator|(
name|mips_optimize
operator|==
literal|0
condition|?
name|nops_for_insn
argument_list|(
name|history
argument_list|,
name|NULL
argument_list|)
else|:
name|nops_for_insn_or_target
argument_list|(
name|history
argument_list|,
name|ip
argument_list|)
operator|)
decl_stmt|;
if|if
condition|(
name|nops
operator|>
literal|0
condition|)
block|{
name|fragS
modifier|*
name|old_frag
decl_stmt|;
name|unsigned
name|long
name|old_frag_offset
decl_stmt|;
name|int
name|i
decl_stmt|;
name|old_frag
operator|=
name|frag_now
expr_stmt|;
name|old_frag_offset
operator|=
name|frag_now_fix
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nops
condition|;
name|i
operator|++
control|)
name|emit_nop
argument_list|()
expr_stmt|;
if|if
condition|(
name|listing
condition|)
block|{
name|listing_prev_line
argument_list|()
expr_stmt|;
comment|/* We may be at the start of a variant frag.  In case we                  are, make sure there is enough space for the frag                  after the frags created by listing_prev_line.  The                  argument to frag_grow here must be at least as large                  as the argument to all other calls to frag_grow in                  this file.  We don't have to worry about being in the                  middle of a variant frag, because the variants insert                  all needed nop instructions themselves.  */
name|frag_grow
argument_list|(
literal|40
argument_list|)
expr_stmt|;
block|}
name|mips_move_labels
argument_list|()
expr_stmt|;
ifndef|#
directive|ifndef
name|NO_ECOFF_DEBUGGING
if|if
condition|(
name|ECOFF_DEBUGGING
condition|)
name|ecoff_fix_loc
argument_list|(
name|old_frag
argument_list|,
name|old_frag_offset
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
elseif|else
if|if
condition|(
name|mips_relax
operator|.
name|sequence
operator|!=
literal|2
operator|&&
name|prev_nop_frag
operator|!=
name|NULL
condition|)
block|{
comment|/* Work out how many nops in prev_nop_frag are needed by IP.  */
name|int
name|nops
init|=
name|nops_for_insn_or_target
argument_list|(
name|history
argument_list|,
name|ip
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|nops
operator|<=
name|prev_nop_frag_holds
argument_list|)
expr_stmt|;
comment|/* Enforce NOPS as a minimum.  */
if|if
condition|(
name|nops
operator|>
name|prev_nop_frag_required
condition|)
name|prev_nop_frag_required
operator|=
name|nops
expr_stmt|;
if|if
condition|(
name|prev_nop_frag_holds
operator|==
name|prev_nop_frag_required
condition|)
block|{
comment|/* Settle for the current number of nops.  Update the history 	     accordingly (for the benefit of any future .set reorder code).  */
name|prev_nop_frag
operator|=
name|NULL
expr_stmt|;
name|insert_into_history
argument_list|(
name|prev_nop_frag_since
argument_list|,
name|prev_nop_frag_holds
argument_list|,
name|NOP_INSN
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Allow this instruction to replace one of the nops that was 	     tentatively added to prev_nop_frag.  */
name|prev_nop_frag
operator|->
name|fr_fix
operator|-=
name|mips_opts
operator|.
name|mips16
condition|?
literal|2
else|:
literal|4
expr_stmt|;
name|prev_nop_frag_holds
operator|--
expr_stmt|;
name|prev_nop_frag_since
operator|++
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|OBJ_ELF
comment|/* The value passed to dwarf2_emit_insn is the distance between      the beginning of the current instruction and the address that      should be recorded in the debug tables.  For MIPS16 debug info      we want to use ISA-encoded addresses, so we pass -1 for an      address higher by one than the current.  */
name|dwarf2_emit_insn
argument_list|(
name|mips_opts
operator|.
name|mips16
condition|?
operator|-
literal|1
else|:
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Record the frag type before frag_var.  */
if|if
condition|(
name|history
index|[
literal|0
index|]
operator|.
name|frag
condition|)
name|prev_insn_frag_type
operator|=
name|history
index|[
literal|0
index|]
operator|.
name|frag
operator|->
name|fr_type
expr_stmt|;
if|if
condition|(
name|address_expr
operator|&&
operator|*
name|reloc_type
operator|==
name|BFD_RELOC_16_PCREL_S2
operator|&&
operator|(
name|pinfo
operator|&
name|INSN_UNCOND_BRANCH_DELAY
operator|||
name|pinfo
operator|&
name|INSN_COND_BRANCH_DELAY
operator|||
name|pinfo
operator|&
name|INSN_COND_BRANCH_LIKELY
operator|)
operator|&&
name|mips_relax_branch
comment|/* Don't try branch relaxation within .set nomacro, or within 	 .set noat if we use $at for PIC computations.  If it turns 	 out that the branch was out-of-range, we'll get an error.  */
operator|&&
operator|!
name|mips_opts
operator|.
name|warn_about_macros
operator|&&
operator|!
operator|(
name|mips_opts
operator|.
name|noat
operator|&&
name|mips_pic
operator|!=
name|NO_PIC
operator|)
operator|&&
operator|!
name|mips_opts
operator|.
name|mips16
condition|)
block|{
name|relaxed_branch
operator|=
name|TRUE
expr_stmt|;
name|add_relaxed_insn
argument_list|(
name|ip
argument_list|,
operator|(
name|relaxed_branch_length
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|(
name|pinfo
operator|&
name|INSN_UNCOND_BRANCH_DELAY
operator|)
condition|?
operator|-
literal|1
else|:
operator|(
name|pinfo
operator|&
name|INSN_COND_BRANCH_LIKELY
operator|)
condition|?
literal|1
else|:
literal|0
argument_list|)
operator|)
argument_list|,
literal|4
argument_list|,
name|RELAX_BRANCH_ENCODE
argument_list|(
name|pinfo
operator|&
name|INSN_UNCOND_BRANCH_DELAY
argument_list|,
name|pinfo
operator|&
name|INSN_COND_BRANCH_LIKELY
argument_list|,
name|pinfo
operator|&
name|INSN_WRITE_GPR_31
argument_list|,
literal|0
argument_list|)
argument_list|,
name|address_expr
operator|->
name|X_add_symbol
argument_list|,
name|address_expr
operator|->
name|X_add_number
argument_list|)
expr_stmt|;
operator|*
name|reloc_type
operator|=
name|BFD_RELOC_UNUSED
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|reloc_type
operator|>
name|BFD_RELOC_UNUSED
condition|)
block|{
comment|/* We need to set up a variant frag.  */
name|assert
argument_list|(
name|mips_opts
operator|.
name|mips16
operator|&&
name|address_expr
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|add_relaxed_insn
argument_list|(
name|ip
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|,
name|RELAX_MIPS16_ENCODE
argument_list|(
operator|*
name|reloc_type
operator|-
name|BFD_RELOC_UNUSED
argument_list|,
name|mips16_small
argument_list|,
name|mips16_ext
argument_list|,
name|prev_pinfo
operator|&
name|INSN_UNCOND_BRANCH_DELAY
argument_list|,
name|history
index|[
literal|0
index|]
operator|.
name|mips16_absolute_jump_p
argument_list|)
argument_list|,
name|make_expr_symbol
argument_list|(
name|address_expr
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mips_opts
operator|.
name|mips16
operator|&&
operator|!
name|ip
operator|->
name|use_extend
operator|&&
operator|*
name|reloc_type
operator|!=
name|BFD_RELOC_MIPS16_JMP
condition|)
block|{
if|if
condition|(
operator|(
name|pinfo
operator|&
name|INSN_UNCOND_BRANCH_DELAY
operator|)
operator|==
literal|0
condition|)
comment|/* Make sure there is enough room to swap this instruction with 	   a following jump instruction.  */
name|frag_grow
argument_list|(
literal|6
argument_list|)
expr_stmt|;
name|add_fixed_insn
argument_list|(
name|ip
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|mips_opts
operator|.
name|mips16
operator|&&
name|mips_opts
operator|.
name|noreorder
operator|&&
operator|(
name|prev_pinfo
operator|&
name|INSN_UNCOND_BRANCH_DELAY
operator|)
operator|!=
literal|0
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"extended instruction in delay slot"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mips_relax
operator|.
name|sequence
condition|)
block|{
comment|/* If we've reached the end of this frag, turn it into a variant 	     frag and record the information for the instructions we've 	     written so far.  */
if|if
condition|(
name|frag_room
argument_list|()
operator|<
literal|4
condition|)
name|relax_close_frag
argument_list|()
expr_stmt|;
name|mips_relax
operator|.
name|sizes
index|[
name|mips_relax
operator|.
name|sequence
operator|-
literal|1
index|]
operator|+=
literal|4
expr_stmt|;
block|}
if|if
condition|(
name|mips_relax
operator|.
name|sequence
operator|!=
literal|2
condition|)
name|mips_macro_warning
operator|.
name|sizes
index|[
literal|0
index|]
operator|+=
literal|4
expr_stmt|;
if|if
condition|(
name|mips_relax
operator|.
name|sequence
operator|!=
literal|1
condition|)
name|mips_macro_warning
operator|.
name|sizes
index|[
literal|1
index|]
operator|+=
literal|4
expr_stmt|;
if|if
condition|(
name|mips_opts
operator|.
name|mips16
condition|)
block|{
name|ip
operator|->
name|fixed_p
operator|=
literal|1
expr_stmt|;
name|ip
operator|->
name|mips16_absolute_jump_p
operator|=
operator|(
operator|*
name|reloc_type
operator|==
name|BFD_RELOC_MIPS16_JMP
operator|)
expr_stmt|;
block|}
name|add_fixed_insn
argument_list|(
name|ip
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|address_expr
operator|!=
name|NULL
operator|&&
operator|*
name|reloc_type
operator|<=
name|BFD_RELOC_UNUSED
condition|)
block|{
if|if
condition|(
name|address_expr
operator|->
name|X_op
operator|==
name|O_constant
condition|)
block|{
name|unsigned
name|int
name|tmp
decl_stmt|;
switch|switch
condition|(
operator|*
name|reloc_type
condition|)
block|{
case|case
name|BFD_RELOC_32
case|:
name|ip
operator|->
name|insn_opcode
operator||=
name|address_expr
operator|->
name|X_add_number
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_MIPS_HIGHEST
case|:
name|tmp
operator|=
operator|(
name|address_expr
operator|->
name|X_add_number
operator|+
literal|0x800080008000ull
operator|)
operator|>>
literal|48
expr_stmt|;
name|ip
operator|->
name|insn_opcode
operator||=
name|tmp
operator|&
literal|0xffff
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_MIPS_HIGHER
case|:
name|tmp
operator|=
operator|(
name|address_expr
operator|->
name|X_add_number
operator|+
literal|0x80008000ull
operator|)
operator|>>
literal|32
expr_stmt|;
name|ip
operator|->
name|insn_opcode
operator||=
name|tmp
operator|&
literal|0xffff
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_HI16_S
case|:
name|tmp
operator|=
operator|(
name|address_expr
operator|->
name|X_add_number
operator|+
literal|0x8000
operator|)
operator|>>
literal|16
expr_stmt|;
name|ip
operator|->
name|insn_opcode
operator||=
name|tmp
operator|&
literal|0xffff
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_HI16
case|:
name|ip
operator|->
name|insn_opcode
operator||=
operator|(
name|address_expr
operator|->
name|X_add_number
operator|>>
literal|16
operator|)
operator|&
literal|0xffff
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_UNUSED
case|:
case|case
name|BFD_RELOC_LO16
case|:
case|case
name|BFD_RELOC_MIPS_GOT_DISP
case|:
name|ip
operator|->
name|insn_opcode
operator||=
name|address_expr
operator|->
name|X_add_number
operator|&
literal|0xffff
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_MIPS_JMP
case|:
if|if
condition|(
operator|(
name|address_expr
operator|->
name|X_add_number
operator|&
literal|3
operator|)
operator|!=
literal|0
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"jump to misaligned address (0x%lx)"
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|address_expr
operator|->
name|X_add_number
argument_list|)
expr_stmt|;
name|ip
operator|->
name|insn_opcode
operator||=
operator|(
name|address_expr
operator|->
name|X_add_number
operator|>>
literal|2
operator|)
operator|&
literal|0x3ffffff
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_MIPS16_JMP
case|:
if|if
condition|(
operator|(
name|address_expr
operator|->
name|X_add_number
operator|&
literal|3
operator|)
operator|!=
literal|0
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"jump to misaligned address (0x%lx)"
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|address_expr
operator|->
name|X_add_number
argument_list|)
expr_stmt|;
name|ip
operator|->
name|insn_opcode
operator||=
operator|(
operator|(
operator|(
name|address_expr
operator|->
name|X_add_number
operator|&
literal|0x7c0000
operator|)
operator|<<
literal|3
operator|)
operator||
operator|(
operator|(
name|address_expr
operator|->
name|X_add_number
operator|&
literal|0xf800000
operator|)
operator|>>
literal|7
operator|)
operator||
operator|(
operator|(
name|address_expr
operator|->
name|X_add_number
operator|&
literal|0x3fffc
operator|)
operator|>>
literal|2
operator|)
operator|)
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_16_PCREL_S2
case|:
if|if
condition|(
operator|(
name|address_expr
operator|->
name|X_add_number
operator|&
literal|3
operator|)
operator|!=
literal|0
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"branch to misaligned address (0x%lx)"
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|address_expr
operator|->
name|X_add_number
argument_list|)
expr_stmt|;
if|if
condition|(
name|mips_relax_branch
condition|)
goto|goto
name|need_reloc
goto|;
if|if
condition|(
operator|(
name|address_expr
operator|->
name|X_add_number
operator|+
literal|0x20000
operator|)
operator|&
operator|~
literal|0x3ffff
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"branch address range overflow (0x%lx)"
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|address_expr
operator|->
name|X_add_number
argument_list|)
expr_stmt|;
name|ip
operator|->
name|insn_opcode
operator||=
operator|(
name|address_expr
operator|->
name|X_add_number
operator|>>
literal|2
operator|)
operator|&
literal|0xffff
expr_stmt|;
break|break;
default|default:
name|internalError
argument_list|()
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|*
name|reloc_type
operator|<
name|BFD_RELOC_UNUSED
condition|)
name|need_reloc
label|:
block|{
name|reloc_howto_type
modifier|*
name|howto
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* In a compound relocation, it is the final (outermost) 	     operator that determines the relocated field.  */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
literal|3
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|reloc_type
index|[
name|i
index|]
operator|==
name|BFD_RELOC_UNUSED
condition|)
break|break;
name|howto
operator|=
name|bfd_reloc_type_lookup
argument_list|(
name|stdoutput
argument_list|,
name|reloc_type
index|[
name|i
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
name|ip
operator|->
name|fixp
index|[
literal|0
index|]
operator|=
name|fix_new_exp
argument_list|(
name|ip
operator|->
name|frag
argument_list|,
name|ip
operator|->
name|where
argument_list|,
name|bfd_get_reloc_size
argument_list|(
name|howto
argument_list|)
argument_list|,
name|address_expr
argument_list|,
name|reloc_type
index|[
literal|0
index|]
operator|==
name|BFD_RELOC_16_PCREL_S2
argument_list|,
name|reloc_type
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* Tag symbols that have a R_MIPS16_26 relocation against them.  */
if|if
condition|(
name|reloc_type
index|[
literal|0
index|]
operator|==
name|BFD_RELOC_MIPS16_JMP
operator|&&
name|ip
operator|->
name|fixp
index|[
literal|0
index|]
operator|->
name|fx_addsy
condition|)
operator|*
name|symbol_get_tc
argument_list|(
name|ip
operator|->
name|fixp
index|[
literal|0
index|]
operator|->
name|fx_addsy
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* These relocations can have an addend that won't fit in 	     4 octets for 64bit assembly.  */
if|if
condition|(
name|HAVE_64BIT_GPRS
operator|&&
operator|!
name|howto
operator|->
name|partial_inplace
operator|&&
operator|(
name|reloc_type
index|[
literal|0
index|]
operator|==
name|BFD_RELOC_16
operator|||
name|reloc_type
index|[
literal|0
index|]
operator|==
name|BFD_RELOC_32
operator|||
name|reloc_type
index|[
literal|0
index|]
operator|==
name|BFD_RELOC_MIPS_JMP
operator|||
name|reloc_type
index|[
literal|0
index|]
operator|==
name|BFD_RELOC_HI16_S
operator|||
name|reloc_type
index|[
literal|0
index|]
operator|==
name|BFD_RELOC_LO16
operator|||
name|reloc_type
index|[
literal|0
index|]
operator|==
name|BFD_RELOC_GPREL16
operator|||
name|reloc_type
index|[
literal|0
index|]
operator|==
name|BFD_RELOC_MIPS_LITERAL
operator|||
name|reloc_type
index|[
literal|0
index|]
operator|==
name|BFD_RELOC_GPREL32
operator|||
name|reloc_type
index|[
literal|0
index|]
operator|==
name|BFD_RELOC_64
operator|||
name|reloc_type
index|[
literal|0
index|]
operator|==
name|BFD_RELOC_CTOR
operator|||
name|reloc_type
index|[
literal|0
index|]
operator|==
name|BFD_RELOC_MIPS_SUB
operator|||
name|reloc_type
index|[
literal|0
index|]
operator|==
name|BFD_RELOC_MIPS_HIGHEST
operator|||
name|reloc_type
index|[
literal|0
index|]
operator|==
name|BFD_RELOC_MIPS_HIGHER
operator|||
name|reloc_type
index|[
literal|0
index|]
operator|==
name|BFD_RELOC_MIPS_SCN_DISP
operator|||
name|reloc_type
index|[
literal|0
index|]
operator|==
name|BFD_RELOC_MIPS_REL16
operator|||
name|reloc_type
index|[
literal|0
index|]
operator|==
name|BFD_RELOC_MIPS_RELGOT
operator|||
name|reloc_type
index|[
literal|0
index|]
operator|==
name|BFD_RELOC_MIPS16_GPREL
operator|||
name|reloc_type
index|[
literal|0
index|]
operator|==
name|BFD_RELOC_MIPS16_HI16_S
operator|||
name|reloc_type
index|[
literal|0
index|]
operator|==
name|BFD_RELOC_MIPS16_LO16
operator|)
condition|)
name|ip
operator|->
name|fixp
index|[
literal|0
index|]
operator|->
name|fx_no_overflow
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|mips_relax
operator|.
name|sequence
condition|)
block|{
if|if
condition|(
name|mips_relax
operator|.
name|first_fixup
operator|==
literal|0
condition|)
name|mips_relax
operator|.
name|first_fixup
operator|=
name|ip
operator|->
name|fixp
index|[
literal|0
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|reloc_needs_lo_p
argument_list|(
operator|*
name|reloc_type
argument_list|)
condition|)
block|{
name|struct
name|mips_hi_fixup
modifier|*
name|hi_fixup
decl_stmt|;
comment|/* Reuse the last entry if it already has a matching %lo.  */
name|hi_fixup
operator|=
name|mips_hi_fixup_list
expr_stmt|;
if|if
condition|(
name|hi_fixup
operator|==
literal|0
operator|||
operator|!
name|fixup_has_matching_lo_p
argument_list|(
name|hi_fixup
operator|->
name|fixp
argument_list|)
condition|)
block|{
name|hi_fixup
operator|=
operator|(
operator|(
expr|struct
name|mips_hi_fixup
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|mips_hi_fixup
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|hi_fixup
operator|->
name|next
operator|=
name|mips_hi_fixup_list
expr_stmt|;
name|mips_hi_fixup_list
operator|=
name|hi_fixup
expr_stmt|;
block|}
name|hi_fixup
operator|->
name|fixp
operator|=
name|ip
operator|->
name|fixp
index|[
literal|0
index|]
expr_stmt|;
name|hi_fixup
operator|->
name|seg
operator|=
name|now_seg
expr_stmt|;
block|}
comment|/* Add fixups for the second and third relocations, if given. 	     Note that the ABI allows the second relocation to be 	     against RSS_UNDEF, RSS_GP, RSS_GP0 or RSS_LOC.  At the 	     moment we only use RSS_UNDEF, but we could add support 	     for the others if it ever becomes necessary.  */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
literal|3
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|reloc_type
index|[
name|i
index|]
operator|!=
name|BFD_RELOC_UNUSED
condition|)
block|{
name|ip
operator|->
name|fixp
index|[
name|i
index|]
operator|=
name|fix_new
argument_list|(
name|ip
operator|->
name|frag
argument_list|,
name|ip
operator|->
name|where
argument_list|,
name|ip
operator|->
name|fixp
index|[
literal|0
index|]
operator|->
name|fx_size
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|FALSE
argument_list|,
name|reloc_type
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* Use fx_tcbit to mark compound relocs.  */
name|ip
operator|->
name|fixp
index|[
literal|0
index|]
operator|->
name|fx_tcbit
operator|=
literal|1
expr_stmt|;
name|ip
operator|->
name|fixp
index|[
name|i
index|]
operator|->
name|fx_tcbit
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
name|install_insn
argument_list|(
name|ip
argument_list|)
expr_stmt|;
comment|/* Update the register mask information.  */
if|if
condition|(
operator|!
name|mips_opts
operator|.
name|mips16
condition|)
block|{
if|if
condition|(
name|pinfo
operator|&
name|INSN_WRITE_GPR_D
condition|)
name|mips_gprmask
operator||=
literal|1
operator|<<
name|EXTRACT_OPERAND
argument_list|(
name|RD
argument_list|,
operator|*
name|ip
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pinfo
operator|&
operator|(
name|INSN_WRITE_GPR_T
operator||
name|INSN_READ_GPR_T
operator|)
operator|)
operator|!=
literal|0
condition|)
name|mips_gprmask
operator||=
literal|1
operator|<<
name|EXTRACT_OPERAND
argument_list|(
name|RT
argument_list|,
operator|*
name|ip
argument_list|)
expr_stmt|;
if|if
condition|(
name|pinfo
operator|&
name|INSN_READ_GPR_S
condition|)
name|mips_gprmask
operator||=
literal|1
operator|<<
name|EXTRACT_OPERAND
argument_list|(
name|RS
argument_list|,
operator|*
name|ip
argument_list|)
expr_stmt|;
if|if
condition|(
name|pinfo
operator|&
name|INSN_WRITE_GPR_31
condition|)
name|mips_gprmask
operator||=
literal|1
operator|<<
name|RA
expr_stmt|;
if|if
condition|(
name|pinfo
operator|&
name|INSN_WRITE_FPR_D
condition|)
name|mips_cprmask
index|[
literal|1
index|]
operator||=
literal|1
operator|<<
name|EXTRACT_OPERAND
argument_list|(
name|FD
argument_list|,
operator|*
name|ip
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pinfo
operator|&
operator|(
name|INSN_WRITE_FPR_S
operator||
name|INSN_READ_FPR_S
operator|)
operator|)
operator|!=
literal|0
condition|)
name|mips_cprmask
index|[
literal|1
index|]
operator||=
literal|1
operator|<<
name|EXTRACT_OPERAND
argument_list|(
name|FS
argument_list|,
operator|*
name|ip
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pinfo
operator|&
operator|(
name|INSN_WRITE_FPR_T
operator||
name|INSN_READ_FPR_T
operator|)
operator|)
operator|!=
literal|0
condition|)
name|mips_cprmask
index|[
literal|1
index|]
operator||=
literal|1
operator|<<
name|EXTRACT_OPERAND
argument_list|(
name|FT
argument_list|,
operator|*
name|ip
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pinfo
operator|&
name|INSN_READ_FPR_R
operator|)
operator|!=
literal|0
condition|)
name|mips_cprmask
index|[
literal|1
index|]
operator||=
literal|1
operator|<<
name|EXTRACT_OPERAND
argument_list|(
name|FR
argument_list|,
operator|*
name|ip
argument_list|)
expr_stmt|;
if|if
condition|(
name|pinfo
operator|&
name|INSN_COP
condition|)
block|{
comment|/* We don't keep enough information to sort these cases out. 	     The itbl support does keep this information however, although 	     we currently don't support itbl fprmats as part of the cop 	     instruction.  May want to add this support in the future.  */
block|}
comment|/* Never set the bit for $0, which is always zero.  */
name|mips_gprmask
operator|&=
operator|~
literal|1
operator|<<
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|pinfo
operator|&
operator|(
name|MIPS16_INSN_WRITE_X
operator||
name|MIPS16_INSN_READ_X
operator|)
condition|)
name|mips_gprmask
operator||=
literal|1
operator|<<
name|MIPS16_EXTRACT_OPERAND
argument_list|(
name|RX
argument_list|,
operator|*
name|ip
argument_list|)
expr_stmt|;
if|if
condition|(
name|pinfo
operator|&
operator|(
name|MIPS16_INSN_WRITE_Y
operator||
name|MIPS16_INSN_READ_Y
operator|)
condition|)
name|mips_gprmask
operator||=
literal|1
operator|<<
name|MIPS16_EXTRACT_OPERAND
argument_list|(
name|RY
argument_list|,
operator|*
name|ip
argument_list|)
expr_stmt|;
if|if
condition|(
name|pinfo
operator|&
name|MIPS16_INSN_WRITE_Z
condition|)
name|mips_gprmask
operator||=
literal|1
operator|<<
name|MIPS16_EXTRACT_OPERAND
argument_list|(
name|RZ
argument_list|,
operator|*
name|ip
argument_list|)
expr_stmt|;
if|if
condition|(
name|pinfo
operator|&
operator|(
name|MIPS16_INSN_WRITE_T
operator||
name|MIPS16_INSN_READ_T
operator|)
condition|)
name|mips_gprmask
operator||=
literal|1
operator|<<
name|TREG
expr_stmt|;
if|if
condition|(
name|pinfo
operator|&
operator|(
name|MIPS16_INSN_WRITE_SP
operator||
name|MIPS16_INSN_READ_SP
operator|)
condition|)
name|mips_gprmask
operator||=
literal|1
operator|<<
name|SP
expr_stmt|;
if|if
condition|(
name|pinfo
operator|&
operator|(
name|MIPS16_INSN_WRITE_31
operator||
name|MIPS16_INSN_READ_31
operator|)
condition|)
name|mips_gprmask
operator||=
literal|1
operator|<<
name|RA
expr_stmt|;
if|if
condition|(
name|pinfo
operator|&
name|MIPS16_INSN_WRITE_GPR_Y
condition|)
name|mips_gprmask
operator||=
literal|1
operator|<<
name|MIPS16OP_EXTRACT_REG32R
argument_list|(
name|ip
operator|->
name|insn_opcode
argument_list|)
expr_stmt|;
if|if
condition|(
name|pinfo
operator|&
name|MIPS16_INSN_READ_Z
condition|)
name|mips_gprmask
operator||=
literal|1
operator|<<
name|MIPS16_EXTRACT_OPERAND
argument_list|(
name|MOVE32Z
argument_list|,
operator|*
name|ip
argument_list|)
expr_stmt|;
if|if
condition|(
name|pinfo
operator|&
name|MIPS16_INSN_READ_GPR_X
condition|)
name|mips_gprmask
operator||=
literal|1
operator|<<
name|MIPS16_EXTRACT_OPERAND
argument_list|(
name|REGR32
argument_list|,
operator|*
name|ip
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mips_relax
operator|.
name|sequence
operator|!=
literal|2
operator|&&
operator|!
name|mips_opts
operator|.
name|noreorder
condition|)
block|{
comment|/* Filling the branch delay slot is more complex.  We try to 	 switch the branch with the previous instruction, which we can 	 do if the previous instruction does not set up a condition 	 that the branch tests and if the branch is not itself the 	 target of any branch.  */
if|if
condition|(
operator|(
name|pinfo
operator|&
name|INSN_UNCOND_BRANCH_DELAY
operator|)
operator|||
operator|(
name|pinfo
operator|&
name|INSN_COND_BRANCH_DELAY
operator|)
condition|)
block|{
if|if
condition|(
name|mips_optimize
operator|<
literal|2
comment|/* If we have seen .set volatile or .set nomove, don't 		 optimize.  */
operator|||
name|mips_opts
operator|.
name|nomove
operator|!=
literal|0
comment|/* We can't swap if the previous instruction's position 		 is fixed.  */
operator|||
name|history
index|[
literal|0
index|]
operator|.
name|fixed_p
comment|/* If the previous previous insn was in a .set 		 noreorder, we can't swap.  Actually, the MIPS 		 assembler will swap in this situation.  However, gcc 		 configured -with-gnu-as will generate code like 		   .set noreorder 		   lw	$4,XXX 		   .set	reorder 		   INSN 		   bne	$4,$0,foo 		 in which we can not swap the bne and INSN.  If gcc is 		 not configured -with-gnu-as, it does not output the 		 .set pseudo-ops.  */
operator|||
name|history
index|[
literal|1
index|]
operator|.
name|noreorder_p
comment|/* If the branch is itself the target of a branch, we 		 can not swap.  We cheat on this; all we check for is 		 whether there is a label on this instruction.  If 		 there are any branches to anything other than a 		 label, users must use .set noreorder.  */
operator|||
name|si
operator|->
name|label_list
operator|!=
name|NULL
comment|/* If the previous instruction is in a variant frag 		 other than this branch's one, we cannot do the swap. 		 This does not apply to the mips16, which uses variant 		 frags for different purposes.  */
operator|||
operator|(
operator|!
name|mips_opts
operator|.
name|mips16
operator|&&
name|prev_insn_frag_type
operator|==
name|rs_machine_dependent
operator|)
comment|/* Check for conflicts between the branch and the instructions 		 before the candidate delay slot.  */
operator|||
name|nops_for_insn
argument_list|(
name|history
operator|+
literal|1
argument_list|,
name|ip
argument_list|)
operator|>
literal|0
comment|/* Check for conflicts between the swapped sequence and the 		 target of the branch.  */
operator|||
name|nops_for_sequence
argument_list|(
literal|2
argument_list|,
name|history
operator|+
literal|1
argument_list|,
name|ip
argument_list|,
name|history
argument_list|)
operator|>
literal|0
comment|/* We do not swap with a trap instruction, since it 		 complicates trap handlers to have the trap 		 instruction be in a delay slot.  */
operator|||
operator|(
name|prev_pinfo
operator|&
name|INSN_TRAP
operator|)
comment|/* If the branch reads a register that the previous 		 instruction sets, we can not swap.  */
operator|||
operator|(
operator|!
name|mips_opts
operator|.
name|mips16
operator|&&
operator|(
name|prev_pinfo
operator|&
name|INSN_WRITE_GPR_T
operator|)
operator|&&
name|insn_uses_reg
argument_list|(
name|ip
argument_list|,
name|EXTRACT_OPERAND
argument_list|(
name|RT
argument_list|,
name|history
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|MIPS_GR_REG
argument_list|)
operator|)
operator|||
operator|(
operator|!
name|mips_opts
operator|.
name|mips16
operator|&&
operator|(
name|prev_pinfo
operator|&
name|INSN_WRITE_GPR_D
operator|)
operator|&&
name|insn_uses_reg
argument_list|(
name|ip
argument_list|,
name|EXTRACT_OPERAND
argument_list|(
name|RD
argument_list|,
name|history
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|MIPS_GR_REG
argument_list|)
operator|)
operator|||
operator|(
name|mips_opts
operator|.
name|mips16
operator|&&
operator|(
operator|(
operator|(
name|prev_pinfo
operator|&
name|MIPS16_INSN_WRITE_X
operator|)
operator|&&
operator|(
name|insn_uses_reg
argument_list|(
name|ip
argument_list|,
name|MIPS16_EXTRACT_OPERAND
argument_list|(
name|RX
argument_list|,
name|history
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|MIPS16_REG
argument_list|)
operator|)
operator|)
operator|||
operator|(
operator|(
name|prev_pinfo
operator|&
name|MIPS16_INSN_WRITE_Y
operator|)
operator|&&
operator|(
name|insn_uses_reg
argument_list|(
name|ip
argument_list|,
name|MIPS16_EXTRACT_OPERAND
argument_list|(
name|RY
argument_list|,
name|history
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|MIPS16_REG
argument_list|)
operator|)
operator|)
operator|||
operator|(
operator|(
name|prev_pinfo
operator|&
name|MIPS16_INSN_WRITE_Z
operator|)
operator|&&
operator|(
name|insn_uses_reg
argument_list|(
name|ip
argument_list|,
name|MIPS16_EXTRACT_OPERAND
argument_list|(
name|RZ
argument_list|,
name|history
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|MIPS16_REG
argument_list|)
operator|)
operator|)
operator|||
operator|(
operator|(
name|prev_pinfo
operator|&
name|MIPS16_INSN_WRITE_T
operator|)
operator|&&
name|insn_uses_reg
argument_list|(
name|ip
argument_list|,
name|TREG
argument_list|,
name|MIPS_GR_REG
argument_list|)
operator|)
operator|||
operator|(
operator|(
name|prev_pinfo
operator|&
name|MIPS16_INSN_WRITE_31
operator|)
operator|&&
name|insn_uses_reg
argument_list|(
name|ip
argument_list|,
name|RA
argument_list|,
name|MIPS_GR_REG
argument_list|)
operator|)
operator|||
operator|(
operator|(
name|prev_pinfo
operator|&
name|MIPS16_INSN_WRITE_GPR_Y
operator|)
operator|&&
name|insn_uses_reg
argument_list|(
name|ip
argument_list|,
name|MIPS16OP_EXTRACT_REG32R
argument_list|(
name|history
index|[
literal|0
index|]
operator|.
name|insn_opcode
argument_list|)
argument_list|,
name|MIPS_GR_REG
argument_list|)
operator|)
operator|)
operator|)
comment|/* If the branch writes a register that the previous 		 instruction sets, we can not swap (we know that 		 branches write only to RD or to $31).  */
operator|||
operator|(
operator|!
name|mips_opts
operator|.
name|mips16
operator|&&
operator|(
name|prev_pinfo
operator|&
name|INSN_WRITE_GPR_T
operator|)
operator|&&
operator|(
operator|(
operator|(
name|pinfo
operator|&
name|INSN_WRITE_GPR_D
operator|)
operator|&&
operator|(
name|EXTRACT_OPERAND
argument_list|(
name|RT
argument_list|,
name|history
index|[
literal|0
index|]
argument_list|)
operator|==
name|EXTRACT_OPERAND
argument_list|(
name|RD
argument_list|,
operator|*
name|ip
argument_list|)
operator|)
operator|)
operator|||
operator|(
operator|(
name|pinfo
operator|&
name|INSN_WRITE_GPR_31
operator|)
operator|&&
name|EXTRACT_OPERAND
argument_list|(
name|RT
argument_list|,
name|history
index|[
literal|0
index|]
argument_list|)
operator|==
name|RA
operator|)
operator|)
operator|)
operator|||
operator|(
operator|!
name|mips_opts
operator|.
name|mips16
operator|&&
operator|(
name|prev_pinfo
operator|&
name|INSN_WRITE_GPR_D
operator|)
operator|&&
operator|(
operator|(
operator|(
name|pinfo
operator|&
name|INSN_WRITE_GPR_D
operator|)
operator|&&
operator|(
name|EXTRACT_OPERAND
argument_list|(
name|RD
argument_list|,
name|history
index|[
literal|0
index|]
argument_list|)
operator|==
name|EXTRACT_OPERAND
argument_list|(
name|RD
argument_list|,
operator|*
name|ip
argument_list|)
operator|)
operator|)
operator|||
operator|(
operator|(
name|pinfo
operator|&
name|INSN_WRITE_GPR_31
operator|)
operator|&&
name|EXTRACT_OPERAND
argument_list|(
name|RD
argument_list|,
name|history
index|[
literal|0
index|]
argument_list|)
operator|==
name|RA
operator|)
operator|)
operator|)
operator|||
operator|(
name|mips_opts
operator|.
name|mips16
operator|&&
operator|(
name|pinfo
operator|&
name|MIPS16_INSN_WRITE_31
operator|)
operator|&&
operator|(
operator|(
name|prev_pinfo
operator|&
name|MIPS16_INSN_WRITE_31
operator|)
operator|||
operator|(
operator|(
name|prev_pinfo
operator|&
name|MIPS16_INSN_WRITE_GPR_Y
operator|)
operator|&&
operator|(
name|MIPS16OP_EXTRACT_REG32R
argument_list|(
name|history
index|[
literal|0
index|]
operator|.
name|insn_opcode
argument_list|)
operator|==
name|RA
operator|)
operator|)
operator|)
operator|)
comment|/* If the branch writes a register that the previous 		 instruction reads, we can not swap (we know that 		 branches only write to RD or to $31).  */
operator|||
operator|(
operator|!
name|mips_opts
operator|.
name|mips16
operator|&&
operator|(
name|pinfo
operator|&
name|INSN_WRITE_GPR_D
operator|)
operator|&&
name|insn_uses_reg
argument_list|(
operator|&
name|history
index|[
literal|0
index|]
argument_list|,
name|EXTRACT_OPERAND
argument_list|(
name|RD
argument_list|,
operator|*
name|ip
argument_list|)
argument_list|,
name|MIPS_GR_REG
argument_list|)
operator|)
operator|||
operator|(
operator|!
name|mips_opts
operator|.
name|mips16
operator|&&
operator|(
name|pinfo
operator|&
name|INSN_WRITE_GPR_31
operator|)
operator|&&
name|insn_uses_reg
argument_list|(
operator|&
name|history
index|[
literal|0
index|]
argument_list|,
name|RA
argument_list|,
name|MIPS_GR_REG
argument_list|)
operator|)
operator|||
operator|(
name|mips_opts
operator|.
name|mips16
operator|&&
operator|(
name|pinfo
operator|&
name|MIPS16_INSN_WRITE_31
operator|)
operator|&&
name|insn_uses_reg
argument_list|(
operator|&
name|history
index|[
literal|0
index|]
argument_list|,
name|RA
argument_list|,
name|MIPS_GR_REG
argument_list|)
operator|)
comment|/* If one instruction sets a condition code and the                  other one uses a condition code, we can not swap.  */
operator|||
operator|(
operator|(
name|pinfo
operator|&
name|INSN_READ_COND_CODE
operator|)
operator|&&
operator|(
name|prev_pinfo
operator|&
name|INSN_WRITE_COND_CODE
operator|)
operator|)
operator|||
operator|(
operator|(
name|pinfo
operator|&
name|INSN_WRITE_COND_CODE
operator|)
operator|&&
operator|(
name|prev_pinfo
operator|&
name|INSN_READ_COND_CODE
operator|)
operator|)
comment|/* If the previous instruction uses the PC, we can not                  swap.  */
operator|||
operator|(
name|mips_opts
operator|.
name|mips16
operator|&&
operator|(
name|prev_pinfo
operator|&
name|MIPS16_INSN_READ_PC
operator|)
operator|)
comment|/* If the previous instruction had a fixup in mips16                  mode, we can not swap.  This normally means that the                  previous instruction was a 4 byte branch anyhow.  */
operator|||
operator|(
name|mips_opts
operator|.
name|mips16
operator|&&
name|history
index|[
literal|0
index|]
operator|.
name|fixp
index|[
literal|0
index|]
operator|)
comment|/* If the previous instruction is a sync, sync.l, or 		 sync.p, we can not swap.  */
operator|||
operator|(
name|prev_pinfo
operator|&
name|INSN_SYNC
operator|)
condition|)
block|{
if|if
condition|(
name|mips_opts
operator|.
name|mips16
operator|&&
operator|(
name|pinfo
operator|&
name|INSN_UNCOND_BRANCH_DELAY
operator|)
operator|&&
operator|(
name|pinfo
operator|&
operator|(
name|MIPS16_INSN_READ_X
operator||
name|MIPS16_INSN_READ_31
operator|)
operator|)
operator|&&
name|ISA_SUPPORTS_MIPS16E
condition|)
block|{
comment|/* Convert MIPS16 jr/jalr into a "compact" jump.  */
name|ip
operator|->
name|insn_opcode
operator||=
literal|0x0080
expr_stmt|;
name|install_insn
argument_list|(
name|ip
argument_list|)
expr_stmt|;
name|insert_into_history
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|,
name|ip
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* We could do even better for unconditional branches to 		     portions of this object file; we could pick up the 		     instruction at the destination, put it in the delay 		     slot, and bump the destination address.  */
name|insert_into_history
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|,
name|ip
argument_list|)
expr_stmt|;
name|emit_nop
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|mips_relax
operator|.
name|sequence
condition|)
name|mips_relax
operator|.
name|sizes
index|[
name|mips_relax
operator|.
name|sequence
operator|-
literal|1
index|]
operator|+=
literal|4
expr_stmt|;
block|}
else|else
block|{
comment|/* It looks like we can actually do the swap.  */
name|struct
name|mips_cl_insn
name|delay
init|=
name|history
index|[
literal|0
index|]
decl_stmt|;
if|if
condition|(
name|mips_opts
operator|.
name|mips16
condition|)
block|{
name|know
argument_list|(
name|delay
operator|.
name|frag
operator|==
name|ip
operator|->
name|frag
argument_list|)
expr_stmt|;
name|move_insn
argument_list|(
name|ip
argument_list|,
name|delay
operator|.
name|frag
argument_list|,
name|delay
operator|.
name|where
argument_list|)
expr_stmt|;
name|move_insn
argument_list|(
operator|&
name|delay
argument_list|,
name|ip
operator|->
name|frag
argument_list|,
name|ip
operator|->
name|where
operator|+
name|insn_length
argument_list|(
name|ip
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|relaxed_branch
condition|)
block|{
comment|/* Add the delay slot instruction to the end of the 		     current frag and shrink the fixed part of the 		     original frag.  If the branch occupies the tail of 		     the latter, move it backwards to cover the gap.  */
name|delay
operator|.
name|frag
operator|->
name|fr_fix
operator|-=
literal|4
expr_stmt|;
if|if
condition|(
name|delay
operator|.
name|frag
operator|==
name|ip
operator|->
name|frag
condition|)
name|move_insn
argument_list|(
name|ip
argument_list|,
name|ip
operator|->
name|frag
argument_list|,
name|ip
operator|->
name|where
operator|-
literal|4
argument_list|)
expr_stmt|;
name|add_fixed_insn
argument_list|(
operator|&
name|delay
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|move_insn
argument_list|(
operator|&
name|delay
argument_list|,
name|ip
operator|->
name|frag
argument_list|,
name|ip
operator|->
name|where
argument_list|)
expr_stmt|;
name|move_insn
argument_list|(
name|ip
argument_list|,
name|history
index|[
literal|0
index|]
operator|.
name|frag
argument_list|,
name|history
index|[
literal|0
index|]
operator|.
name|where
argument_list|)
expr_stmt|;
block|}
name|history
index|[
literal|0
index|]
operator|=
operator|*
name|ip
expr_stmt|;
name|delay
operator|.
name|fixed_p
operator|=
literal|1
expr_stmt|;
name|insert_into_history
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|,
operator|&
name|delay
argument_list|)
expr_stmt|;
block|}
comment|/* If that was an unconditional branch, forget the previous 	     insn information.  */
if|if
condition|(
name|pinfo
operator|&
name|INSN_UNCOND_BRANCH_DELAY
condition|)
name|mips_no_prev_insn
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pinfo
operator|&
name|INSN_COND_BRANCH_LIKELY
condition|)
block|{
comment|/* We don't yet optimize a branch likely.  What we should do 	     is look at the target, copy the instruction found there 	     into the delay slot, and increment the branch to jump to 	     the next instruction.  */
name|insert_into_history
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|,
name|ip
argument_list|)
expr_stmt|;
name|emit_nop
argument_list|()
expr_stmt|;
block|}
else|else
name|insert_into_history
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|,
name|ip
argument_list|)
expr_stmt|;
block|}
else|else
name|insert_into_history
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|,
name|ip
argument_list|)
expr_stmt|;
comment|/* We just output an insn, so the next one doesn't have a label.  */
name|mips_clear_insn_labels
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Forget that there was any previous instruction or label.  */
end_comment

begin_function
specifier|static
name|void
name|mips_no_prev_insn
parameter_list|(
name|void
parameter_list|)
block|{
name|prev_nop_frag
operator|=
name|NULL
expr_stmt|;
name|insert_into_history
argument_list|(
literal|0
argument_list|,
name|ARRAY_SIZE
argument_list|(
name|history
argument_list|)
argument_list|,
name|NOP_INSN
argument_list|)
expr_stmt|;
name|mips_clear_insn_labels
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This function must be called before we emit something other than    instructions.  It is like mips_no_prev_insn except that it inserts    any NOPS that might be needed by previous instructions.  */
end_comment

begin_function
name|void
name|mips_emit_delays
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
name|mips_opts
operator|.
name|noreorder
condition|)
block|{
name|int
name|nops
init|=
name|nops_for_insn
argument_list|(
name|history
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
if|if
condition|(
name|nops
operator|>
literal|0
condition|)
block|{
while|while
condition|(
name|nops
operator|--
operator|>
literal|0
condition|)
name|add_fixed_insn
argument_list|(
name|NOP_INSN
argument_list|)
expr_stmt|;
name|mips_move_labels
argument_list|()
expr_stmt|;
block|}
block|}
name|mips_no_prev_insn
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Start a (possibly nested) noreorder block.  */
end_comment

begin_function
specifier|static
name|void
name|start_noreorder
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|mips_opts
operator|.
name|noreorder
operator|==
literal|0
condition|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|int
name|nops
decl_stmt|;
comment|/* None of the instructions before the .set noreorder can be moved.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|history
argument_list|)
condition|;
name|i
operator|++
control|)
name|history
index|[
name|i
index|]
operator|.
name|fixed_p
operator|=
literal|1
expr_stmt|;
comment|/* Insert any nops that might be needed between the .set noreorder 	 block and the previous instructions.  We will later remove any 	 nops that turn out not to be needed.  */
name|nops
operator|=
name|nops_for_insn
argument_list|(
name|history
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|nops
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|mips_optimize
operator|!=
literal|0
condition|)
block|{
comment|/* Record the frag which holds the nop instructions, so                  that we can remove them if we don't need them.  */
name|frag_grow
argument_list|(
name|mips_opts
operator|.
name|mips16
condition|?
name|nops
operator|*
literal|2
else|:
name|nops
operator|*
literal|4
argument_list|)
expr_stmt|;
name|prev_nop_frag
operator|=
name|frag_now
expr_stmt|;
name|prev_nop_frag_holds
operator|=
name|nops
expr_stmt|;
name|prev_nop_frag_required
operator|=
literal|0
expr_stmt|;
name|prev_nop_frag_since
operator|=
literal|0
expr_stmt|;
block|}
for|for
control|(
init|;
name|nops
operator|>
literal|0
condition|;
operator|--
name|nops
control|)
name|add_fixed_insn
argument_list|(
name|NOP_INSN
argument_list|)
expr_stmt|;
comment|/* Move on to a new frag, so that it is safe to simply 	     decrease the size of prev_nop_frag.  */
name|frag_wane
argument_list|(
name|frag_now
argument_list|)
expr_stmt|;
name|frag_new
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|mips_move_labels
argument_list|()
expr_stmt|;
block|}
name|mips16_mark_labels
argument_list|()
expr_stmt|;
name|mips_clear_insn_labels
argument_list|()
expr_stmt|;
block|}
name|mips_opts
operator|.
name|noreorder
operator|++
expr_stmt|;
name|mips_any_noreorder
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* End a nested noreorder block.  */
end_comment

begin_function
specifier|static
name|void
name|end_noreorder
parameter_list|(
name|void
parameter_list|)
block|{
name|mips_opts
operator|.
name|noreorder
operator|--
expr_stmt|;
if|if
condition|(
name|mips_opts
operator|.
name|noreorder
operator|==
literal|0
operator|&&
name|prev_nop_frag
operator|!=
name|NULL
condition|)
block|{
comment|/* Commit to inserting prev_nop_frag_required nops and go back to 	 handling nop insertion the .set reorder way.  */
name|prev_nop_frag
operator|->
name|fr_fix
operator|-=
operator|(
operator|(
name|prev_nop_frag_holds
operator|-
name|prev_nop_frag_required
operator|)
operator|*
operator|(
name|mips_opts
operator|.
name|mips16
condition|?
literal|2
else|:
literal|4
operator|)
operator|)
expr_stmt|;
name|insert_into_history
argument_list|(
name|prev_nop_frag_since
argument_list|,
name|prev_nop_frag_required
argument_list|,
name|NOP_INSN
argument_list|)
expr_stmt|;
name|prev_nop_frag
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Set up global variables for the start of a new macro.  */
end_comment

begin_function
specifier|static
name|void
name|macro_start
parameter_list|(
name|void
parameter_list|)
block|{
name|memset
argument_list|(
operator|&
name|mips_macro_warning
operator|.
name|sizes
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|mips_macro_warning
operator|.
name|sizes
argument_list|)
argument_list|)
expr_stmt|;
name|mips_macro_warning
operator|.
name|delay_slot_p
operator|=
operator|(
name|mips_opts
operator|.
name|noreorder
operator|&&
operator|(
name|history
index|[
literal|0
index|]
operator|.
name|insn_mo
operator|->
name|pinfo
operator|&
operator|(
name|INSN_UNCOND_BRANCH_DELAY
operator||
name|INSN_COND_BRANCH_DELAY
operator||
name|INSN_COND_BRANCH_LIKELY
operator|)
operator|)
operator|!=
literal|0
operator|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Given that a macro is longer than 4 bytes, return the appropriate warning    for it.  Return null if no warning is needed.  SUBTYPE is a bitmask of    RELAX_DELAY_SLOT and RELAX_NOMACRO.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|macro_warning
parameter_list|(
name|relax_substateT
name|subtype
parameter_list|)
block|{
if|if
condition|(
name|subtype
operator|&
name|RELAX_DELAY_SLOT
condition|)
return|return
name|_
argument_list|(
literal|"Macro instruction expanded into multiple instructions"
literal|" in a branch delay slot"
argument_list|)
return|;
elseif|else
if|if
condition|(
name|subtype
operator|&
name|RELAX_NOMACRO
condition|)
return|return
name|_
argument_list|(
literal|"Macro instruction expanded into multiple instructions"
argument_list|)
return|;
else|else
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Finish up a macro.  Emit warnings as appropriate.  */
end_comment

begin_function
specifier|static
name|void
name|macro_end
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|mips_macro_warning
operator|.
name|sizes
index|[
literal|0
index|]
operator|>
literal|4
operator|||
name|mips_macro_warning
operator|.
name|sizes
index|[
literal|1
index|]
operator|>
literal|4
condition|)
block|{
name|relax_substateT
name|subtype
decl_stmt|;
comment|/* Set up the relaxation warning flags.  */
name|subtype
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|mips_macro_warning
operator|.
name|sizes
index|[
literal|1
index|]
operator|>
name|mips_macro_warning
operator|.
name|sizes
index|[
literal|0
index|]
condition|)
name|subtype
operator||=
name|RELAX_SECOND_LONGER
expr_stmt|;
if|if
condition|(
name|mips_opts
operator|.
name|warn_about_macros
condition|)
name|subtype
operator||=
name|RELAX_NOMACRO
expr_stmt|;
if|if
condition|(
name|mips_macro_warning
operator|.
name|delay_slot_p
condition|)
name|subtype
operator||=
name|RELAX_DELAY_SLOT
expr_stmt|;
if|if
condition|(
name|mips_macro_warning
operator|.
name|sizes
index|[
literal|0
index|]
operator|>
literal|4
operator|&&
name|mips_macro_warning
operator|.
name|sizes
index|[
literal|1
index|]
operator|>
literal|4
condition|)
block|{
comment|/* Either the macro has a single implementation or both 	     implementations are longer than 4 bytes.  Emit the 	     warning now.  */
specifier|const
name|char
modifier|*
name|msg
init|=
name|macro_warning
argument_list|(
name|subtype
argument_list|)
decl_stmt|;
if|if
condition|(
name|msg
operator|!=
literal|0
condition|)
name|as_warn
argument_list|(
name|msg
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* One implementation might need a warning but the other 	     definitely doesn't.  */
name|mips_macro_warning
operator|.
name|first_frag
operator|->
name|fr_subtype
operator||=
name|subtype
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Read a macro's relocation codes from *ARGS and store them in *R.    The first argument in *ARGS will be either the code for a single    relocation or -1 followed by the three codes that make up a    composite relocation.  */
end_comment

begin_function
specifier|static
name|void
name|macro_read_relocs
parameter_list|(
name|va_list
modifier|*
name|args
parameter_list|,
name|bfd_reloc_code_real_type
modifier|*
name|r
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|next
decl_stmt|;
name|next
operator|=
name|va_arg
argument_list|(
operator|*
name|args
argument_list|,
name|int
argument_list|)
expr_stmt|;
if|if
condition|(
name|next
operator|>=
literal|0
condition|)
name|r
index|[
literal|0
index|]
operator|=
operator|(
name|bfd_reloc_code_real_type
operator|)
name|next
expr_stmt|;
else|else
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
name|i
operator|++
control|)
name|r
index|[
name|i
index|]
operator|=
operator|(
name|bfd_reloc_code_real_type
operator|)
name|va_arg
argument_list|(
operator|*
name|args
argument_list|,
name|int
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Build an instruction created by a macro expansion.  This is passed    a pointer to the count of instructions created so far, an    expression, the name of the instruction to build, an operand format    string, and corresponding arguments.  */
end_comment

begin_function
specifier|static
name|void
name|macro_build
parameter_list|(
name|expressionS
modifier|*
name|ep
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
specifier|const
name|struct
name|mips_opcode
modifier|*
name|mo
decl_stmt|;
name|struct
name|mips_cl_insn
name|insn
decl_stmt|;
name|bfd_reloc_code_real_type
name|r
index|[
literal|3
index|]
decl_stmt|;
name|va_list
name|args
decl_stmt|;
name|va_start
argument_list|(
name|args
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|mips_opts
operator|.
name|mips16
condition|)
block|{
name|mips16_macro_build
argument_list|(
name|ep
argument_list|,
name|name
argument_list|,
name|fmt
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
return|return;
block|}
name|r
index|[
literal|0
index|]
operator|=
name|BFD_RELOC_UNUSED
expr_stmt|;
name|r
index|[
literal|1
index|]
operator|=
name|BFD_RELOC_UNUSED
expr_stmt|;
name|r
index|[
literal|2
index|]
operator|=
name|BFD_RELOC_UNUSED
expr_stmt|;
name|mo
operator|=
operator|(
expr|struct
name|mips_opcode
operator|*
operator|)
name|hash_find
argument_list|(
name|op_hash
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|mo
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|mo
operator|->
name|name
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
comment|/* Search until we get a match for NAME.  It is assumed here that 	 macros will never generate MDMX, MIPS-3D, or MT instructions.  */
if|if
condition|(
name|strcmp
argument_list|(
name|fmt
argument_list|,
name|mo
operator|->
name|args
argument_list|)
operator|==
literal|0
operator|&&
name|mo
operator|->
name|pinfo
operator|!=
name|INSN_MACRO
operator|&&
name|OPCODE_IS_MEMBER
argument_list|(
name|mo
argument_list|,
operator|(
name|mips_opts
operator|.
name|isa
operator||
operator|(
name|mips_opts
operator|.
name|mips16
condition|?
name|INSN_MIPS16
else|:
literal|0
operator|)
operator||
operator|(
name|mips_opts
operator|.
name|ase_dsp
condition|?
name|INSN_DSP
else|:
literal|0
operator|)
operator||
operator|(
operator|(
name|mips_opts
operator|.
name|ase_dsp
operator|&&
name|ISA_SUPPORTS_DSP64_ASE
operator|)
condition|?
name|INSN_DSP64
else|:
literal|0
operator|)
operator||
operator|(
name|mips_opts
operator|.
name|ase_dspr2
condition|?
name|INSN_DSPR2
else|:
literal|0
operator|)
operator||
operator|(
name|mips_opts
operator|.
name|ase_smartmips
condition|?
name|INSN_SMARTMIPS
else|:
literal|0
operator|)
operator|)
argument_list|,
name|mips_opts
operator|.
name|arch
argument_list|)
operator|&&
operator|(
name|mips_opts
operator|.
name|arch
operator|!=
name|CPU_R4650
operator|||
operator|(
name|mo
operator|->
name|pinfo
operator|&
name|FP_D
operator|)
operator|==
literal|0
operator|)
condition|)
break|break;
operator|++
name|mo
expr_stmt|;
name|assert
argument_list|(
name|mo
operator|->
name|name
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|mo
operator|->
name|name
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
name|create_insn
argument_list|(
operator|&
name|insn
argument_list|,
name|mo
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
switch|switch
condition|(
operator|*
name|fmt
operator|++
condition|)
block|{
case|case
literal|'\0'
case|:
break|break;
case|case
literal|','
case|:
case|case
literal|'('
case|:
case|case
literal|')'
case|:
continue|continue;
case|case
literal|'+'
case|:
switch|switch
condition|(
operator|*
name|fmt
operator|++
condition|)
block|{
case|case
literal|'A'
case|:
case|case
literal|'E'
case|:
name|INSERT_OPERAND
argument_list|(
name|SHAMT
argument_list|,
name|insn
argument_list|,
name|va_arg
argument_list|(
name|args
argument_list|,
name|int
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
case|case
literal|'B'
case|:
case|case
literal|'F'
case|:
comment|/* Note that in the macro case, these arguments are already 		 in MSB form.  (When handling the instruction in the 		 non-macro case, these arguments are sizes from which 		 MSB values must be calculated.)  */
name|INSERT_OPERAND
argument_list|(
name|INSMSB
argument_list|,
name|insn
argument_list|,
name|va_arg
argument_list|(
name|args
argument_list|,
name|int
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
case|case
literal|'C'
case|:
case|case
literal|'G'
case|:
case|case
literal|'H'
case|:
comment|/* Note that in the macro case, these arguments are already 		 in MSBD form.  (When handling the instruction in the 		 non-macro case, these arguments are sizes from which 		 MSBD values must be calculated.)  */
name|INSERT_OPERAND
argument_list|(
name|EXTMSBD
argument_list|,
name|insn
argument_list|,
name|va_arg
argument_list|(
name|args
argument_list|,
name|int
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
default|default:
name|internalError
argument_list|()
expr_stmt|;
block|}
continue|continue;
case|case
literal|'2'
case|:
name|INSERT_OPERAND
argument_list|(
name|BP
argument_list|,
name|insn
argument_list|,
name|va_arg
argument_list|(
name|args
argument_list|,
name|int
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
case|case
literal|'t'
case|:
case|case
literal|'w'
case|:
case|case
literal|'E'
case|:
name|INSERT_OPERAND
argument_list|(
name|RT
argument_list|,
name|insn
argument_list|,
name|va_arg
argument_list|(
name|args
argument_list|,
name|int
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
case|case
literal|'c'
case|:
name|INSERT_OPERAND
argument_list|(
name|CODE
argument_list|,
name|insn
argument_list|,
name|va_arg
argument_list|(
name|args
argument_list|,
name|int
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
case|case
literal|'T'
case|:
case|case
literal|'W'
case|:
name|INSERT_OPERAND
argument_list|(
name|FT
argument_list|,
name|insn
argument_list|,
name|va_arg
argument_list|(
name|args
argument_list|,
name|int
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
case|case
literal|'d'
case|:
case|case
literal|'G'
case|:
case|case
literal|'K'
case|:
name|INSERT_OPERAND
argument_list|(
name|RD
argument_list|,
name|insn
argument_list|,
name|va_arg
argument_list|(
name|args
argument_list|,
name|int
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
case|case
literal|'U'
case|:
block|{
name|int
name|tmp
init|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|int
argument_list|)
decl_stmt|;
name|INSERT_OPERAND
argument_list|(
name|RT
argument_list|,
name|insn
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|INSERT_OPERAND
argument_list|(
name|RD
argument_list|,
name|insn
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
continue|continue;
block|}
case|case
literal|'V'
case|:
case|case
literal|'S'
case|:
name|INSERT_OPERAND
argument_list|(
name|FS
argument_list|,
name|insn
argument_list|,
name|va_arg
argument_list|(
name|args
argument_list|,
name|int
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
case|case
literal|'z'
case|:
continue|continue;
case|case
literal|'<'
case|:
name|INSERT_OPERAND
argument_list|(
name|SHAMT
argument_list|,
name|insn
argument_list|,
name|va_arg
argument_list|(
name|args
argument_list|,
name|int
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
case|case
literal|'D'
case|:
name|INSERT_OPERAND
argument_list|(
name|FD
argument_list|,
name|insn
argument_list|,
name|va_arg
argument_list|(
name|args
argument_list|,
name|int
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
case|case
literal|'B'
case|:
name|INSERT_OPERAND
argument_list|(
name|CODE20
argument_list|,
name|insn
argument_list|,
name|va_arg
argument_list|(
name|args
argument_list|,
name|int
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
case|case
literal|'J'
case|:
name|INSERT_OPERAND
argument_list|(
name|CODE19
argument_list|,
name|insn
argument_list|,
name|va_arg
argument_list|(
name|args
argument_list|,
name|int
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
case|case
literal|'q'
case|:
name|INSERT_OPERAND
argument_list|(
name|CODE2
argument_list|,
name|insn
argument_list|,
name|va_arg
argument_list|(
name|args
argument_list|,
name|int
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
case|case
literal|'b'
case|:
case|case
literal|'s'
case|:
case|case
literal|'r'
case|:
case|case
literal|'v'
case|:
name|INSERT_OPERAND
argument_list|(
name|RS
argument_list|,
name|insn
argument_list|,
name|va_arg
argument_list|(
name|args
argument_list|,
name|int
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
case|case
literal|'i'
case|:
case|case
literal|'j'
case|:
case|case
literal|'o'
case|:
name|macro_read_relocs
argument_list|(
operator|&
name|args
argument_list|,
name|r
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|*
name|r
operator|==
name|BFD_RELOC_GPREL16
operator|||
operator|*
name|r
operator|==
name|BFD_RELOC_MIPS_LITERAL
operator|||
operator|*
name|r
operator|==
name|BFD_RELOC_MIPS_HIGHER
operator|||
operator|*
name|r
operator|==
name|BFD_RELOC_HI16_S
operator|||
operator|*
name|r
operator|==
name|BFD_RELOC_LO16
operator|||
operator|*
name|r
operator|==
name|BFD_RELOC_MIPS_GOT16
operator|||
operator|*
name|r
operator|==
name|BFD_RELOC_MIPS_CALL16
operator|||
operator|*
name|r
operator|==
name|BFD_RELOC_MIPS_GOT_DISP
operator|||
operator|*
name|r
operator|==
name|BFD_RELOC_MIPS_GOT_PAGE
operator|||
operator|*
name|r
operator|==
name|BFD_RELOC_MIPS_GOT_OFST
operator|||
operator|*
name|r
operator|==
name|BFD_RELOC_MIPS_GOT_LO16
operator|||
operator|*
name|r
operator|==
name|BFD_RELOC_MIPS_CALL_LO16
argument_list|)
expr_stmt|;
continue|continue;
case|case
literal|'u'
case|:
name|macro_read_relocs
argument_list|(
operator|&
name|args
argument_list|,
name|r
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ep
operator|!=
name|NULL
operator|&&
operator|(
name|ep
operator|->
name|X_op
operator|==
name|O_constant
operator|||
operator|(
name|ep
operator|->
name|X_op
operator|==
name|O_symbol
operator|&&
operator|(
operator|*
name|r
operator|==
name|BFD_RELOC_MIPS_HIGHEST
operator|||
operator|*
name|r
operator|==
name|BFD_RELOC_HI16_S
operator|||
operator|*
name|r
operator|==
name|BFD_RELOC_HI16
operator|||
operator|*
name|r
operator|==
name|BFD_RELOC_GPREL16
operator|||
operator|*
name|r
operator|==
name|BFD_RELOC_MIPS_GOT_HI16
operator|||
operator|*
name|r
operator|==
name|BFD_RELOC_MIPS_CALL_HI16
operator|)
operator|)
operator|)
argument_list|)
expr_stmt|;
continue|continue;
case|case
literal|'p'
case|:
name|assert
argument_list|(
name|ep
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* 	   * This allows macro() to pass an immediate expression for 	   * creating short branches without creating a symbol. 	   * 	   * We don't allow branch relaxation for these branches, as 	   * they should only appear in ".set nomacro" anyway. 	   */
if|if
condition|(
name|ep
operator|->
name|X_op
operator|==
name|O_constant
condition|)
block|{
if|if
condition|(
operator|(
name|ep
operator|->
name|X_add_number
operator|&
literal|3
operator|)
operator|!=
literal|0
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"branch to misaligned address (0x%lx)"
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|ep
operator|->
name|X_add_number
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ep
operator|->
name|X_add_number
operator|+
literal|0x20000
operator|)
operator|&
operator|~
literal|0x3ffff
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"branch address range overflow (0x%lx)"
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|ep
operator|->
name|X_add_number
argument_list|)
expr_stmt|;
name|insn
operator|.
name|insn_opcode
operator||=
operator|(
name|ep
operator|->
name|X_add_number
operator|>>
literal|2
operator|)
operator|&
literal|0xffff
expr_stmt|;
name|ep
operator|=
name|NULL
expr_stmt|;
block|}
else|else
operator|*
name|r
operator|=
name|BFD_RELOC_16_PCREL_S2
expr_stmt|;
continue|continue;
case|case
literal|'a'
case|:
name|assert
argument_list|(
name|ep
operator|!=
name|NULL
argument_list|)
expr_stmt|;
operator|*
name|r
operator|=
name|BFD_RELOC_MIPS_JMP
expr_stmt|;
continue|continue;
case|case
literal|'C'
case|:
name|INSERT_OPERAND
argument_list|(
name|COPZ
argument_list|,
name|insn
argument_list|,
name|va_arg
argument_list|(
argument|args
argument_list|,
argument|unsigned long
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
case|case
literal|'k'
case|:
name|INSERT_OPERAND
argument_list|(
name|CACHE
argument_list|,
name|insn
argument_list|,
name|va_arg
argument_list|(
argument|args
argument_list|,
argument|unsigned long
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
default|default:
name|internalError
argument_list|()
expr_stmt|;
block|}
break|break;
block|}
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|*
name|r
operator|==
name|BFD_RELOC_UNUSED
condition|?
name|ep
operator|==
name|NULL
else|:
name|ep
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|append_insn
argument_list|(
operator|&
name|insn
argument_list|,
name|ep
argument_list|,
name|r
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|mips16_macro_build
parameter_list|(
name|expressionS
modifier|*
name|ep
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
name|va_list
name|args
parameter_list|)
block|{
name|struct
name|mips_opcode
modifier|*
name|mo
decl_stmt|;
name|struct
name|mips_cl_insn
name|insn
decl_stmt|;
name|bfd_reloc_code_real_type
name|r
index|[
literal|3
index|]
init|=
block|{
name|BFD_RELOC_UNUSED
block|,
name|BFD_RELOC_UNUSED
block|,
name|BFD_RELOC_UNUSED
block|}
decl_stmt|;
name|mo
operator|=
operator|(
expr|struct
name|mips_opcode
operator|*
operator|)
name|hash_find
argument_list|(
name|mips16_op_hash
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|mo
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|mo
operator|->
name|name
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
name|strcmp
argument_list|(
name|fmt
argument_list|,
name|mo
operator|->
name|args
argument_list|)
operator|!=
literal|0
operator|||
name|mo
operator|->
name|pinfo
operator|==
name|INSN_MACRO
condition|)
block|{
operator|++
name|mo
expr_stmt|;
name|assert
argument_list|(
name|mo
operator|->
name|name
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|mo
operator|->
name|name
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
name|create_insn
argument_list|(
operator|&
name|insn
argument_list|,
name|mo
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|int
name|c
decl_stmt|;
name|c
operator|=
operator|*
name|fmt
operator|++
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\0'
case|:
break|break;
case|case
literal|','
case|:
case|case
literal|'('
case|:
case|case
literal|')'
case|:
continue|continue;
case|case
literal|'y'
case|:
case|case
literal|'w'
case|:
name|MIPS16_INSERT_OPERAND
argument_list|(
name|RY
argument_list|,
name|insn
argument_list|,
name|va_arg
argument_list|(
name|args
argument_list|,
name|int
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
case|case
literal|'x'
case|:
case|case
literal|'v'
case|:
name|MIPS16_INSERT_OPERAND
argument_list|(
name|RX
argument_list|,
name|insn
argument_list|,
name|va_arg
argument_list|(
name|args
argument_list|,
name|int
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
case|case
literal|'z'
case|:
name|MIPS16_INSERT_OPERAND
argument_list|(
name|RZ
argument_list|,
name|insn
argument_list|,
name|va_arg
argument_list|(
name|args
argument_list|,
name|int
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
case|case
literal|'Z'
case|:
name|MIPS16_INSERT_OPERAND
argument_list|(
name|MOVE32Z
argument_list|,
name|insn
argument_list|,
name|va_arg
argument_list|(
name|args
argument_list|,
name|int
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
case|case
literal|'0'
case|:
case|case
literal|'S'
case|:
case|case
literal|'P'
case|:
case|case
literal|'R'
case|:
continue|continue;
case|case
literal|'X'
case|:
name|MIPS16_INSERT_OPERAND
argument_list|(
name|REGR32
argument_list|,
name|insn
argument_list|,
name|va_arg
argument_list|(
name|args
argument_list|,
name|int
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
case|case
literal|'Y'
case|:
block|{
name|int
name|regno
decl_stmt|;
name|regno
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|int
argument_list|)
expr_stmt|;
name|regno
operator|=
operator|(
operator|(
name|regno
operator|&
literal|7
operator|)
operator|<<
literal|2
operator|)
operator||
operator|(
operator|(
name|regno
operator|&
literal|0x18
operator|)
operator|>>
literal|3
operator|)
expr_stmt|;
name|MIPS16_INSERT_OPERAND
argument_list|(
name|REG32R
argument_list|,
name|insn
argument_list|,
name|regno
argument_list|)
expr_stmt|;
block|}
continue|continue;
case|case
literal|'<'
case|:
case|case
literal|'>'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'H'
case|:
case|case
literal|'W'
case|:
case|case
literal|'D'
case|:
case|case
literal|'j'
case|:
case|case
literal|'8'
case|:
case|case
literal|'V'
case|:
case|case
literal|'C'
case|:
case|case
literal|'U'
case|:
case|case
literal|'k'
case|:
case|case
literal|'K'
case|:
case|case
literal|'p'
case|:
case|case
literal|'q'
case|:
block|{
name|assert
argument_list|(
name|ep
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ep
operator|->
name|X_op
operator|!=
name|O_constant
condition|)
operator|*
name|r
operator|=
operator|(
name|int
operator|)
name|BFD_RELOC_UNUSED
operator|+
name|c
expr_stmt|;
else|else
block|{
name|mips16_immed
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|,
name|c
argument_list|,
name|ep
operator|->
name|X_add_number
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
operator|&
name|insn
operator|.
name|insn_opcode
argument_list|,
operator|&
name|insn
operator|.
name|use_extend
argument_list|,
operator|&
name|insn
operator|.
name|extend
argument_list|)
expr_stmt|;
name|ep
operator|=
name|NULL
expr_stmt|;
operator|*
name|r
operator|=
name|BFD_RELOC_UNUSED
expr_stmt|;
block|}
block|}
continue|continue;
case|case
literal|'6'
case|:
name|MIPS16_INSERT_OPERAND
argument_list|(
name|IMM6
argument_list|,
name|insn
argument_list|,
name|va_arg
argument_list|(
name|args
argument_list|,
name|int
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
break|break;
block|}
name|assert
argument_list|(
operator|*
name|r
operator|==
name|BFD_RELOC_UNUSED
condition|?
name|ep
operator|==
name|NULL
else|:
name|ep
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|append_insn
argument_list|(
operator|&
name|insn
argument_list|,
name|ep
argument_list|,
name|r
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Sign-extend 32-bit mode constants that have bit 31 set and all  * higher bits unset.  */
end_comment

begin_function
specifier|static
name|void
name|normalize_constant_expr
parameter_list|(
name|expressionS
modifier|*
name|ex
parameter_list|)
block|{
if|if
condition|(
name|ex
operator|->
name|X_op
operator|==
name|O_constant
operator|&&
name|IS_ZEXT_32BIT_NUM
argument_list|(
name|ex
operator|->
name|X_add_number
argument_list|)
condition|)
name|ex
operator|->
name|X_add_number
operator|=
operator|(
operator|(
operator|(
name|ex
operator|->
name|X_add_number
operator|&
literal|0xffffffff
operator|)
operator|^
literal|0x80000000
operator|)
operator|-
literal|0x80000000
operator|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Sign-extend 32-bit mode address offsets that have bit 31 set and  * all higher bits unset.  */
end_comment

begin_function
specifier|static
name|void
name|normalize_address_expr
parameter_list|(
name|expressionS
modifier|*
name|ex
parameter_list|)
block|{
if|if
condition|(
operator|(
operator|(
name|ex
operator|->
name|X_op
operator|==
name|O_constant
operator|&&
name|HAVE_32BIT_ADDRESSES
operator|)
operator|||
operator|(
name|ex
operator|->
name|X_op
operator|==
name|O_symbol
operator|&&
name|HAVE_32BIT_SYMBOLS
operator|)
operator|)
operator|&&
name|IS_ZEXT_32BIT_NUM
argument_list|(
name|ex
operator|->
name|X_add_number
argument_list|)
condition|)
name|ex
operator|->
name|X_add_number
operator|=
operator|(
operator|(
operator|(
name|ex
operator|->
name|X_add_number
operator|&
literal|0xffffffff
operator|)
operator|^
literal|0x80000000
operator|)
operator|-
literal|0x80000000
operator|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Generate a "jalr" instruction with a relocation hint to the called  * function.  This occurs in NewABI PIC code.  */
end_comment

begin_function
specifier|static
name|void
name|macro_build_jalr
parameter_list|(
name|expressionS
modifier|*
name|ep
parameter_list|)
block|{
name|char
modifier|*
name|f
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|HAVE_NEWABI
condition|)
block|{
name|frag_grow
argument_list|(
literal|8
argument_list|)
expr_stmt|;
name|f
operator|=
name|frag_more
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"jalr"
argument_list|,
literal|"d,s"
argument_list|,
name|RA
argument_list|,
name|PIC_CALL_REG
argument_list|)
expr_stmt|;
if|if
condition|(
name|HAVE_NEWABI
condition|)
name|fix_new_exp
argument_list|(
name|frag_now
argument_list|,
name|f
operator|-
name|frag_now
operator|->
name|fr_literal
argument_list|,
literal|4
argument_list|,
name|ep
argument_list|,
name|FALSE
argument_list|,
name|BFD_RELOC_MIPS_JALR
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Generate a "lui" instruction.  */
end_comment

begin_function
specifier|static
name|void
name|macro_build_lui
parameter_list|(
name|expressionS
modifier|*
name|ep
parameter_list|,
name|int
name|regnum
parameter_list|)
block|{
name|expressionS
name|high_expr
decl_stmt|;
specifier|const
name|struct
name|mips_opcode
modifier|*
name|mo
decl_stmt|;
name|struct
name|mips_cl_insn
name|insn
decl_stmt|;
name|bfd_reloc_code_real_type
name|r
index|[
literal|3
index|]
init|=
block|{
name|BFD_RELOC_UNUSED
block|,
name|BFD_RELOC_UNUSED
block|,
name|BFD_RELOC_UNUSED
block|}
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
init|=
literal|"lui"
decl_stmt|;
specifier|const
name|char
modifier|*
name|fmt
init|=
literal|"t,u"
decl_stmt|;
name|assert
argument_list|(
operator|!
name|mips_opts
operator|.
name|mips16
argument_list|)
expr_stmt|;
name|high_expr
operator|=
operator|*
name|ep
expr_stmt|;
if|if
condition|(
name|high_expr
operator|.
name|X_op
operator|==
name|O_constant
condition|)
block|{
comment|/* We can compute the instruction now without a relocation entry.  */
name|high_expr
operator|.
name|X_add_number
operator|=
operator|(
operator|(
name|high_expr
operator|.
name|X_add_number
operator|+
literal|0x8000
operator|)
operator|>>
literal|16
operator|)
operator|&
literal|0xffff
expr_stmt|;
operator|*
name|r
operator|=
name|BFD_RELOC_UNUSED
expr_stmt|;
block|}
else|else
block|{
name|assert
argument_list|(
name|ep
operator|->
name|X_op
operator|==
name|O_symbol
argument_list|)
expr_stmt|;
comment|/* _gp_disp is a special case, used from s_cpload. 	 __gnu_local_gp is used if mips_no_shared.  */
name|assert
argument_list|(
name|mips_pic
operator|==
name|NO_PIC
operator|||
operator|(
operator|!
name|HAVE_NEWABI
operator|&&
name|strcmp
argument_list|(
name|S_GET_NAME
argument_list|(
name|ep
operator|->
name|X_add_symbol
argument_list|)
argument_list|,
literal|"_gp_disp"
argument_list|)
operator|==
literal|0
operator|)
operator|||
operator|(
operator|!
name|mips_in_shared
operator|&&
name|strcmp
argument_list|(
name|S_GET_NAME
argument_list|(
name|ep
operator|->
name|X_add_symbol
argument_list|)
argument_list|,
literal|"__gnu_local_gp"
argument_list|)
operator|==
literal|0
operator|)
argument_list|)
expr_stmt|;
operator|*
name|r
operator|=
name|BFD_RELOC_HI16_S
expr_stmt|;
block|}
name|mo
operator|=
name|hash_find
argument_list|(
name|op_hash
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|mo
operator|->
name|name
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|strcmp
argument_list|(
name|fmt
argument_list|,
name|mo
operator|->
name|args
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|create_insn
argument_list|(
operator|&
name|insn
argument_list|,
name|mo
argument_list|)
expr_stmt|;
name|insn
operator|.
name|insn_opcode
operator|=
name|insn
operator|.
name|insn_mo
operator|->
name|match
expr_stmt|;
name|INSERT_OPERAND
argument_list|(
name|RT
argument_list|,
name|insn
argument_list|,
name|regnum
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|r
operator|==
name|BFD_RELOC_UNUSED
condition|)
block|{
name|insn
operator|.
name|insn_opcode
operator||=
name|high_expr
operator|.
name|X_add_number
expr_stmt|;
name|append_insn
argument_list|(
operator|&
name|insn
argument_list|,
name|NULL
argument_list|,
name|r
argument_list|)
expr_stmt|;
block|}
else|else
name|append_insn
argument_list|(
operator|&
name|insn
argument_list|,
operator|&
name|high_expr
argument_list|,
name|r
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate a sequence of instructions to do a load or store from a constant    offset off of a base register (breg) into/from a target register (treg),    using AT if necessary.  */
end_comment

begin_function
specifier|static
name|void
name|macro_build_ldst_constoffset
parameter_list|(
name|expressionS
modifier|*
name|ep
parameter_list|,
specifier|const
name|char
modifier|*
name|op
parameter_list|,
name|int
name|treg
parameter_list|,
name|int
name|breg
parameter_list|,
name|int
name|dbl
parameter_list|)
block|{
name|assert
argument_list|(
name|ep
operator|->
name|X_op
operator|==
name|O_constant
argument_list|)
expr_stmt|;
comment|/* Sign-extending 32-bit constants makes their handling easier.  */
if|if
condition|(
operator|!
name|dbl
condition|)
name|normalize_constant_expr
argument_list|(
name|ep
argument_list|)
expr_stmt|;
comment|/* Right now, this routine can only handle signed 32-bit constants.  */
if|if
condition|(
operator|!
name|IS_SEXT_32BIT_NUM
argument_list|(
name|ep
operator|->
name|X_add_number
operator|+
literal|0x8000
argument_list|)
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"operand overflow"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_SEXT_16BIT_NUM
argument_list|(
name|ep
operator|->
name|X_add_number
argument_list|)
condition|)
block|{
comment|/* Signed 16-bit offset will fit in the op.  Easy!  */
name|macro_build
argument_list|(
name|ep
argument_list|,
name|op
argument_list|,
literal|"t,o(b)"
argument_list|,
name|treg
argument_list|,
name|BFD_RELOC_LO16
argument_list|,
name|breg
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 32-bit offset, need multiple instructions and AT, like: 	   lui      $tempreg,const_hi       (BFD_RELOC_HI16_S) 	   addu     $tempreg,$tempreg,$breg<op>     $treg,const_lo($tempreg)   (BFD_RELOC_LO16)          to handle the complete offset.  */
name|macro_build_lui
argument_list|(
name|ep
argument_list|,
name|AT
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
name|ADDRESS_ADD_INSN
argument_list|,
literal|"d,v,t"
argument_list|,
name|AT
argument_list|,
name|AT
argument_list|,
name|breg
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|ep
argument_list|,
name|op
argument_list|,
literal|"t,o(b)"
argument_list|,
name|treg
argument_list|,
name|BFD_RELOC_LO16
argument_list|,
name|AT
argument_list|)
expr_stmt|;
if|if
condition|(
name|mips_opts
operator|.
name|noat
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Macro used $at after \".set noat\""
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*			set_at()  * Generates code to set the $at register to true (one)  * if reg is less than the immediate expression.  */
end_comment

begin_function
specifier|static
name|void
name|set_at
parameter_list|(
name|int
name|reg
parameter_list|,
name|int
name|unsignedp
parameter_list|)
block|{
if|if
condition|(
name|imm_expr
operator|.
name|X_op
operator|==
name|O_constant
operator|&&
name|imm_expr
operator|.
name|X_add_number
operator|>=
operator|-
literal|0x8000
operator|&&
name|imm_expr
operator|.
name|X_add_number
operator|<
literal|0x8000
condition|)
name|macro_build
argument_list|(
operator|&
name|imm_expr
argument_list|,
name|unsignedp
condition|?
literal|"sltiu"
else|:
literal|"slti"
argument_list|,
literal|"t,r,j"
argument_list|,
name|AT
argument_list|,
name|reg
argument_list|,
name|BFD_RELOC_LO16
argument_list|)
expr_stmt|;
else|else
block|{
name|load_register
argument_list|(
name|AT
argument_list|,
operator|&
name|imm_expr
argument_list|,
name|HAVE_64BIT_GPRS
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
name|unsignedp
condition|?
literal|"sltu"
else|:
literal|"slt"
argument_list|,
literal|"d,v,t"
argument_list|,
name|AT
argument_list|,
name|reg
argument_list|,
name|AT
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Warn if an expression is not a constant.  */
end_comment

begin_function
specifier|static
name|void
name|check_absolute_expr
parameter_list|(
name|struct
name|mips_cl_insn
modifier|*
name|ip
parameter_list|,
name|expressionS
modifier|*
name|ex
parameter_list|)
block|{
if|if
condition|(
name|ex
operator|->
name|X_op
operator|==
name|O_big
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"unsupported large constant"
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ex
operator|->
name|X_op
operator|!=
name|O_constant
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Instruction %s requires absolute expression"
argument_list|)
argument_list|,
name|ip
operator|->
name|insn_mo
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|HAVE_32BIT_GPRS
condition|)
name|normalize_constant_expr
argument_list|(
name|ex
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Count the leading zeroes by performing a binary chop. This is a    bulky bit of source, but performance is a LOT better for the    majority of values than a simple loop to count the bits:        for (lcnt = 0; (lcnt< 32); lcnt++)          if ((v)& (1<< (31 - lcnt)))            break;   However it is not code size friendly, and the gain will drop a bit   on certain cached systems. */
end_comment

begin_define
define|#
directive|define
name|COUNT_TOP_ZEROES
parameter_list|(
name|v
parameter_list|)
define|\
value|(((v)& ~0xffff) == 0                 \    ? ((v)& ~0xff) == 0                 \      ? ((v)& ~0xf) == 0                \        ? ((v)& ~0x3) == 0              \          ? ((v)& ~0x1) == 0            \            ? !(v)                       \              ? 32                       \              : 31                       \            : 30                         \          : ((v)& ~0x7) == 0            \            ? 29                         \            : 28                         \        : ((v)& ~0x3f) == 0             \          ? ((v)& ~0x1f) == 0           \            ? 27                         \            : 26                         \          : ((v)& ~0x7f) == 0           \            ? 25                         \            : 24                         \      : ((v)& ~0xfff) == 0              \        ? ((v)& ~0x3ff) == 0            \          ? ((v)& ~0x1ff) == 0          \            ? 23                         \            : 22                         \          : ((v)& ~0x7ff) == 0          \            ? 21                         \            : 20                         \        : ((v)& ~0x3fff) == 0           \          ? ((v)& ~0x1fff) == 0         \            ? 19                         \            : 18                         \          : ((v)& ~0x7fff) == 0         \            ? 17                         \            : 16                         \    : ((v)& ~0xffffff) == 0             \      ? ((v)& ~0xfffff) == 0            \        ? ((v)& ~0x3ffff) == 0          \          ? ((v)& ~0x1ffff) == 0        \            ? 15                         \            : 14                         \          : ((v)& ~0x7ffff) == 0        \            ? 13                         \            : 12                         \        : ((v)& ~0x3fffff) == 0         \          ? ((v)& ~0x1fffff) == 0       \            ? 11                         \            : 10                         \          : ((v)& ~0x7fffff) == 0       \            ? 9                          \            : 8                          \      : ((v)& ~0xfffffff) == 0          \        ? ((v)& ~0x3ffffff) == 0        \          ? ((v)& ~0x1ffffff) == 0      \            ? 7                          \            : 6                          \          : ((v)& ~0x7ffffff) == 0      \            ? 5                          \            : 4                          \        : ((v)& ~0x3fffffff) == 0       \          ? ((v)& ~0x1fffffff) == 0     \            ? 3                          \            : 2                          \          : ((v)& ~0x7fffffff) == 0     \            ? 1                          \            : 0)
end_define

begin_comment
comment|/*			load_register()  *  This routine generates the least number of instructions necessary to load  *  an absolute expression value into a register.  */
end_comment

begin_function
specifier|static
name|void
name|load_register
parameter_list|(
name|int
name|reg
parameter_list|,
name|expressionS
modifier|*
name|ep
parameter_list|,
name|int
name|dbl
parameter_list|)
block|{
name|int
name|freg
decl_stmt|;
name|expressionS
name|hi32
decl_stmt|,
name|lo32
decl_stmt|;
if|if
condition|(
name|ep
operator|->
name|X_op
operator|!=
name|O_big
condition|)
block|{
name|assert
argument_list|(
name|ep
operator|->
name|X_op
operator|==
name|O_constant
argument_list|)
expr_stmt|;
comment|/* Sign-extending 32-bit constants makes their handling easier.  */
if|if
condition|(
operator|!
name|dbl
condition|)
name|normalize_constant_expr
argument_list|(
name|ep
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_SEXT_16BIT_NUM
argument_list|(
name|ep
operator|->
name|X_add_number
argument_list|)
condition|)
block|{
comment|/* We can handle 16 bit signed values with an addiu to 	     $zero.  No need to ever use daddiu here, since $zero and 	     the result are always correct in 32 bit mode.  */
name|macro_build
argument_list|(
name|ep
argument_list|,
literal|"addiu"
argument_list|,
literal|"t,r,j"
argument_list|,
name|reg
argument_list|,
literal|0
argument_list|,
name|BFD_RELOC_LO16
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|ep
operator|->
name|X_add_number
operator|>=
literal|0
operator|&&
name|ep
operator|->
name|X_add_number
operator|<
literal|0x10000
condition|)
block|{
comment|/* We can handle 16 bit unsigned values with an ori to              $zero.  */
name|macro_build
argument_list|(
name|ep
argument_list|,
literal|"ori"
argument_list|,
literal|"t,r,i"
argument_list|,
name|reg
argument_list|,
literal|0
argument_list|,
name|BFD_RELOC_LO16
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
operator|(
name|IS_SEXT_32BIT_NUM
argument_list|(
name|ep
operator|->
name|X_add_number
argument_list|)
operator|)
condition|)
block|{
comment|/* 32 bit values require an lui.  */
name|macro_build
argument_list|(
name|ep
argument_list|,
literal|"lui"
argument_list|,
literal|"t,u"
argument_list|,
name|reg
argument_list|,
name|BFD_RELOC_HI16
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ep
operator|->
name|X_add_number
operator|&
literal|0xffff
operator|)
operator|!=
literal|0
condition|)
name|macro_build
argument_list|(
name|ep
argument_list|,
literal|"ori"
argument_list|,
literal|"t,r,i"
argument_list|,
name|reg
argument_list|,
name|reg
argument_list|,
name|BFD_RELOC_LO16
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* The value is larger than 32 bits.  */
if|if
condition|(
operator|!
name|dbl
operator|||
name|HAVE_32BIT_GPRS
condition|)
block|{
name|char
name|value
index|[
literal|32
index|]
decl_stmt|;
name|sprintf_vma
argument_list|(
name|value
argument_list|,
name|ep
operator|->
name|X_add_number
argument_list|)
expr_stmt|;
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Number (0x%s) larger than 32 bits"
argument_list|)
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|ep
argument_list|,
literal|"addiu"
argument_list|,
literal|"t,r,j"
argument_list|,
name|reg
argument_list|,
literal|0
argument_list|,
name|BFD_RELOC_LO16
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|ep
operator|->
name|X_op
operator|!=
name|O_big
condition|)
block|{
name|hi32
operator|=
operator|*
name|ep
expr_stmt|;
name|hi32
operator|.
name|X_add_number
operator|=
operator|(
name|valueT
operator|)
name|hi32
operator|.
name|X_add_number
operator|>>
literal|16
expr_stmt|;
name|hi32
operator|.
name|X_add_number
operator|=
operator|(
name|valueT
operator|)
name|hi32
operator|.
name|X_add_number
operator|>>
literal|16
expr_stmt|;
name|hi32
operator|.
name|X_add_number
operator|&=
literal|0xffffffff
expr_stmt|;
name|lo32
operator|=
operator|*
name|ep
expr_stmt|;
name|lo32
operator|.
name|X_add_number
operator|&=
literal|0xffffffff
expr_stmt|;
block|}
else|else
block|{
name|assert
argument_list|(
name|ep
operator|->
name|X_add_number
operator|>
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|ep
operator|->
name|X_add_number
operator|==
literal|3
condition|)
name|generic_bignum
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|ep
operator|->
name|X_add_number
operator|>
literal|4
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Number larger than 64 bits"
argument_list|)
argument_list|)
expr_stmt|;
name|lo32
operator|.
name|X_op
operator|=
name|O_constant
expr_stmt|;
name|lo32
operator|.
name|X_add_number
operator|=
name|generic_bignum
index|[
literal|0
index|]
operator|+
operator|(
name|generic_bignum
index|[
literal|1
index|]
operator|<<
literal|16
operator|)
expr_stmt|;
name|hi32
operator|.
name|X_op
operator|=
name|O_constant
expr_stmt|;
name|hi32
operator|.
name|X_add_number
operator|=
name|generic_bignum
index|[
literal|2
index|]
operator|+
operator|(
name|generic_bignum
index|[
literal|3
index|]
operator|<<
literal|16
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|hi32
operator|.
name|X_add_number
operator|==
literal|0
condition|)
name|freg
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|int
name|shift
decl_stmt|,
name|bit
decl_stmt|;
name|unsigned
name|long
name|hi
decl_stmt|,
name|lo
decl_stmt|;
if|if
condition|(
name|hi32
operator|.
name|X_add_number
operator|==
operator|(
name|offsetT
operator|)
literal|0xffffffff
condition|)
block|{
if|if
condition|(
operator|(
name|lo32
operator|.
name|X_add_number
operator|&
literal|0xffff8000
operator|)
operator|==
literal|0xffff8000
condition|)
block|{
name|macro_build
argument_list|(
operator|&
name|lo32
argument_list|,
literal|"addiu"
argument_list|,
literal|"t,r,j"
argument_list|,
name|reg
argument_list|,
literal|0
argument_list|,
name|BFD_RELOC_LO16
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|lo32
operator|.
name|X_add_number
operator|&
literal|0x80000000
condition|)
block|{
name|macro_build
argument_list|(
operator|&
name|lo32
argument_list|,
literal|"lui"
argument_list|,
literal|"t,u"
argument_list|,
name|reg
argument_list|,
name|BFD_RELOC_HI16
argument_list|)
expr_stmt|;
if|if
condition|(
name|lo32
operator|.
name|X_add_number
operator|&
literal|0xffff
condition|)
name|macro_build
argument_list|(
operator|&
name|lo32
argument_list|,
literal|"ori"
argument_list|,
literal|"t,r,i"
argument_list|,
name|reg
argument_list|,
name|reg
argument_list|,
name|BFD_RELOC_LO16
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* Check for 16bit shifted constant.  We know that hi32 is          non-zero, so start the mask on the first bit of the hi32          value.  */
name|shift
operator|=
literal|17
expr_stmt|;
do|do
block|{
name|unsigned
name|long
name|himask
decl_stmt|,
name|lomask
decl_stmt|;
if|if
condition|(
name|shift
operator|<
literal|32
condition|)
block|{
name|himask
operator|=
literal|0xffff
operator|>>
operator|(
literal|32
operator|-
name|shift
operator|)
expr_stmt|;
name|lomask
operator|=
operator|(
literal|0xffff
operator|<<
name|shift
operator|)
operator|&
literal|0xffffffff
expr_stmt|;
block|}
else|else
block|{
name|himask
operator|=
literal|0xffff
operator|<<
operator|(
name|shift
operator|-
literal|32
operator|)
expr_stmt|;
name|lomask
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|hi32
operator|.
name|X_add_number
operator|&
operator|~
operator|(
name|offsetT
operator|)
name|himask
operator|)
operator|==
literal|0
operator|&&
operator|(
name|lo32
operator|.
name|X_add_number
operator|&
operator|~
operator|(
name|offsetT
operator|)
name|lomask
operator|)
operator|==
literal|0
condition|)
block|{
name|expressionS
name|tmp
decl_stmt|;
name|tmp
operator|.
name|X_op
operator|=
name|O_constant
expr_stmt|;
if|if
condition|(
name|shift
operator|<
literal|32
condition|)
name|tmp
operator|.
name|X_add_number
operator|=
operator|(
operator|(
name|hi32
operator|.
name|X_add_number
operator|<<
operator|(
literal|32
operator|-
name|shift
operator|)
operator|)
operator||
operator|(
name|lo32
operator|.
name|X_add_number
operator|>>
name|shift
operator|)
operator|)
expr_stmt|;
else|else
name|tmp
operator|.
name|X_add_number
operator|=
name|hi32
operator|.
name|X_add_number
operator|>>
operator|(
name|shift
operator|-
literal|32
operator|)
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|tmp
argument_list|,
literal|"ori"
argument_list|,
literal|"t,r,i"
argument_list|,
name|reg
argument_list|,
literal|0
argument_list|,
name|BFD_RELOC_LO16
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
operator|(
name|shift
operator|>=
literal|32
operator|)
condition|?
literal|"dsll32"
else|:
literal|"dsll"
argument_list|,
literal|"d,w,<"
argument_list|,
name|reg
argument_list|,
name|reg
argument_list|,
operator|(
name|shift
operator|>=
literal|32
operator|)
condition|?
name|shift
operator|-
literal|32
else|:
name|shift
argument_list|)
expr_stmt|;
return|return;
block|}
operator|++
name|shift
expr_stmt|;
block|}
do|while
condition|(
name|shift
operator|<=
operator|(
literal|64
operator|-
literal|16
operator|)
condition|)
do|;
comment|/* Find the bit number of the lowest one bit, and store the          shifted value in hi/lo.  */
name|hi
operator|=
call|(
name|unsigned
name|long
call|)
argument_list|(
name|hi32
operator|.
name|X_add_number
operator|&
literal|0xffffffff
argument_list|)
expr_stmt|;
name|lo
operator|=
call|(
name|unsigned
name|long
call|)
argument_list|(
name|lo32
operator|.
name|X_add_number
operator|&
literal|0xffffffff
argument_list|)
expr_stmt|;
if|if
condition|(
name|lo
operator|!=
literal|0
condition|)
block|{
name|bit
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|lo
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
block|{
name|lo
operator|>>=
literal|1
expr_stmt|;
operator|++
name|bit
expr_stmt|;
block|}
name|lo
operator||=
operator|(
name|hi
operator|&
operator|(
operator|(
operator|(
name|unsigned
name|long
operator|)
literal|1
operator|<<
name|bit
operator|)
operator|-
literal|1
operator|)
operator|)
operator|<<
operator|(
literal|32
operator|-
name|bit
operator|)
expr_stmt|;
name|hi
operator|>>=
name|bit
expr_stmt|;
block|}
else|else
block|{
name|bit
operator|=
literal|32
expr_stmt|;
while|while
condition|(
operator|(
name|hi
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
block|{
name|hi
operator|>>=
literal|1
expr_stmt|;
operator|++
name|bit
expr_stmt|;
block|}
name|lo
operator|=
name|hi
expr_stmt|;
name|hi
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Optimize if the shifted value is a (power of 2) - 1.  */
if|if
condition|(
operator|(
name|hi
operator|==
literal|0
operator|&&
operator|(
operator|(
name|lo
operator|+
literal|1
operator|)
operator|&
name|lo
operator|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|lo
operator|==
literal|0xffffffff
operator|&&
operator|(
operator|(
name|hi
operator|+
literal|1
operator|)
operator|&
name|hi
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|shift
operator|=
name|COUNT_TOP_ZEROES
argument_list|(
operator|(
name|unsigned
name|int
operator|)
name|hi32
operator|.
name|X_add_number
argument_list|)
expr_stmt|;
if|if
condition|(
name|shift
operator|!=
literal|0
condition|)
block|{
name|expressionS
name|tmp
decl_stmt|;
comment|/* This instruction will set the register to be all                  ones.  */
name|tmp
operator|.
name|X_op
operator|=
name|O_constant
expr_stmt|;
name|tmp
operator|.
name|X_add_number
operator|=
operator|(
name|offsetT
operator|)
operator|-
literal|1
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|tmp
argument_list|,
literal|"addiu"
argument_list|,
literal|"t,r,j"
argument_list|,
name|reg
argument_list|,
literal|0
argument_list|,
name|BFD_RELOC_LO16
argument_list|)
expr_stmt|;
if|if
condition|(
name|bit
operator|!=
literal|0
condition|)
block|{
name|bit
operator|+=
name|shift
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
operator|(
name|bit
operator|>=
literal|32
operator|)
condition|?
literal|"dsll32"
else|:
literal|"dsll"
argument_list|,
literal|"d,w,<"
argument_list|,
name|reg
argument_list|,
name|reg
argument_list|,
operator|(
name|bit
operator|>=
literal|32
operator|)
condition|?
name|bit
operator|-
literal|32
else|:
name|bit
argument_list|)
expr_stmt|;
block|}
name|macro_build
argument_list|(
name|NULL
argument_list|,
operator|(
name|shift
operator|>=
literal|32
operator|)
condition|?
literal|"dsrl32"
else|:
literal|"dsrl"
argument_list|,
literal|"d,w,<"
argument_list|,
name|reg
argument_list|,
name|reg
argument_list|,
operator|(
name|shift
operator|>=
literal|32
operator|)
condition|?
name|shift
operator|-
literal|32
else|:
name|shift
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* Sign extend hi32 before calling load_register, because we can          generally get better code when we load a sign extended value.  */
if|if
condition|(
operator|(
name|hi32
operator|.
name|X_add_number
operator|&
literal|0x80000000
operator|)
operator|!=
literal|0
condition|)
name|hi32
operator|.
name|X_add_number
operator||=
operator|~
operator|(
name|offsetT
operator|)
literal|0xffffffff
expr_stmt|;
name|load_register
argument_list|(
name|reg
argument_list|,
operator|&
name|hi32
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|freg
operator|=
name|reg
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|lo32
operator|.
name|X_add_number
operator|&
literal|0xffff0000
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|freg
operator|!=
literal|0
condition|)
block|{
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"dsll32"
argument_list|,
literal|"d,w,<"
argument_list|,
name|reg
argument_list|,
name|freg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|freg
operator|=
name|reg
expr_stmt|;
block|}
block|}
else|else
block|{
name|expressionS
name|mid16
decl_stmt|;
if|if
condition|(
operator|(
name|freg
operator|==
literal|0
operator|)
operator|&&
operator|(
name|lo32
operator|.
name|X_add_number
operator|==
operator|(
name|offsetT
operator|)
literal|0xffffffff
operator|)
condition|)
block|{
name|macro_build
argument_list|(
operator|&
name|lo32
argument_list|,
literal|"lui"
argument_list|,
literal|"t,u"
argument_list|,
name|reg
argument_list|,
name|BFD_RELOC_HI16
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"dsrl32"
argument_list|,
literal|"d,w,<"
argument_list|,
name|reg
argument_list|,
name|reg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|freg
operator|!=
literal|0
condition|)
block|{
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"dsll"
argument_list|,
literal|"d,w,<"
argument_list|,
name|reg
argument_list|,
name|freg
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|freg
operator|=
name|reg
expr_stmt|;
block|}
name|mid16
operator|=
name|lo32
expr_stmt|;
name|mid16
operator|.
name|X_add_number
operator|>>=
literal|16
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|mid16
argument_list|,
literal|"ori"
argument_list|,
literal|"t,r,i"
argument_list|,
name|reg
argument_list|,
name|freg
argument_list|,
name|BFD_RELOC_LO16
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"dsll"
argument_list|,
literal|"d,w,<"
argument_list|,
name|reg
argument_list|,
name|reg
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|freg
operator|=
name|reg
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|lo32
operator|.
name|X_add_number
operator|&
literal|0xffff
operator|)
operator|!=
literal|0
condition|)
name|macro_build
argument_list|(
operator|&
name|lo32
argument_list|,
literal|"ori"
argument_list|,
literal|"t,r,i"
argument_list|,
name|reg
argument_list|,
name|freg
argument_list|,
name|BFD_RELOC_LO16
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|load_delay_nop
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
name|gpr_interlocks
condition|)
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"nop"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Load an address into a register.  */
end_comment

begin_function
specifier|static
name|void
name|load_address
parameter_list|(
name|int
name|reg
parameter_list|,
name|expressionS
modifier|*
name|ep
parameter_list|,
name|int
modifier|*
name|used_at
parameter_list|)
block|{
if|if
condition|(
name|ep
operator|->
name|X_op
operator|!=
name|O_constant
operator|&&
name|ep
operator|->
name|X_op
operator|!=
name|O_symbol
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"expression too complex"
argument_list|)
argument_list|)
expr_stmt|;
name|ep
operator|->
name|X_op
operator|=
name|O_constant
expr_stmt|;
block|}
if|if
condition|(
name|ep
operator|->
name|X_op
operator|==
name|O_constant
condition|)
block|{
name|load_register
argument_list|(
name|reg
argument_list|,
name|ep
argument_list|,
name|HAVE_64BIT_ADDRESSES
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|mips_pic
operator|==
name|NO_PIC
condition|)
block|{
comment|/* If this is a reference to a GP relative symbol, we want 	   addiu	$reg,$gp,<sym>		(BFD_RELOC_GPREL16) 	 Otherwise we want 	   lui		$reg,<sym>		(BFD_RELOC_HI16_S) 	   addiu	$reg,$reg,<sym>		(BFD_RELOC_LO16) 	 If we have an addend, we always use the latter form.  	 With 64bit address space and a usable $at we want 	   lui		$reg,<sym>		(BFD_RELOC_MIPS_HIGHEST) 	   lui		$at,<sym>		(BFD_RELOC_HI16_S) 	   daddiu	$reg,<sym>		(BFD_RELOC_MIPS_HIGHER) 	   daddiu	$at,<sym>		(BFD_RELOC_LO16) 	   dsll32	$reg,0 	   daddu	$reg,$reg,$at  	 If $at is already in use, we use a path which is suboptimal 	 on superscalar processors. 	   lui		$reg,<sym>		(BFD_RELOC_MIPS_HIGHEST) 	   daddiu	$reg,<sym>		(BFD_RELOC_MIPS_HIGHER) 	   dsll		$reg,16 	   daddiu	$reg,<sym>		(BFD_RELOC_HI16_S) 	   dsll		$reg,16 	   daddiu	$reg,<sym>		(BFD_RELOC_LO16)  	 For GP relative symbols in 64bit address space we can use 	 the same sequence as in 32bit address space.  */
if|if
condition|(
name|HAVE_64BIT_SYMBOLS
condition|)
block|{
if|if
condition|(
operator|(
name|valueT
operator|)
name|ep
operator|->
name|X_add_number
operator|<=
name|MAX_GPREL_OFFSET
operator|&&
operator|!
name|nopic_need_relax
argument_list|(
name|ep
operator|->
name|X_add_symbol
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|relax_start
argument_list|(
name|ep
operator|->
name|X_add_symbol
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|ep
argument_list|,
name|ADDRESS_ADDI_INSN
argument_list|,
literal|"t,r,j"
argument_list|,
name|reg
argument_list|,
name|mips_gp_register
argument_list|,
name|BFD_RELOC_GPREL16
argument_list|)
expr_stmt|;
name|relax_switch
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|used_at
operator|==
literal|0
operator|&&
operator|!
name|mips_opts
operator|.
name|noat
condition|)
block|{
name|macro_build
argument_list|(
name|ep
argument_list|,
literal|"lui"
argument_list|,
literal|"t,u"
argument_list|,
name|reg
argument_list|,
name|BFD_RELOC_MIPS_HIGHEST
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|ep
argument_list|,
literal|"lui"
argument_list|,
literal|"t,u"
argument_list|,
name|AT
argument_list|,
name|BFD_RELOC_HI16_S
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|ep
argument_list|,
literal|"daddiu"
argument_list|,
literal|"t,r,j"
argument_list|,
name|reg
argument_list|,
name|reg
argument_list|,
name|BFD_RELOC_MIPS_HIGHER
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|ep
argument_list|,
literal|"daddiu"
argument_list|,
literal|"t,r,j"
argument_list|,
name|AT
argument_list|,
name|AT
argument_list|,
name|BFD_RELOC_LO16
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"dsll32"
argument_list|,
literal|"d,w,<"
argument_list|,
name|reg
argument_list|,
name|reg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"daddu"
argument_list|,
literal|"d,v,t"
argument_list|,
name|reg
argument_list|,
name|reg
argument_list|,
name|AT
argument_list|)
expr_stmt|;
operator|*
name|used_at
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|macro_build
argument_list|(
name|ep
argument_list|,
literal|"lui"
argument_list|,
literal|"t,u"
argument_list|,
name|reg
argument_list|,
name|BFD_RELOC_MIPS_HIGHEST
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|ep
argument_list|,
literal|"daddiu"
argument_list|,
literal|"t,r,j"
argument_list|,
name|reg
argument_list|,
name|reg
argument_list|,
name|BFD_RELOC_MIPS_HIGHER
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"dsll"
argument_list|,
literal|"d,w,<"
argument_list|,
name|reg
argument_list|,
name|reg
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|ep
argument_list|,
literal|"daddiu"
argument_list|,
literal|"t,r,j"
argument_list|,
name|reg
argument_list|,
name|reg
argument_list|,
name|BFD_RELOC_HI16_S
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"dsll"
argument_list|,
literal|"d,w,<"
argument_list|,
name|reg
argument_list|,
name|reg
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|ep
argument_list|,
literal|"daddiu"
argument_list|,
literal|"t,r,j"
argument_list|,
name|reg
argument_list|,
name|reg
argument_list|,
name|BFD_RELOC_LO16
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mips_relax
operator|.
name|sequence
condition|)
name|relax_end
argument_list|()
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|valueT
operator|)
name|ep
operator|->
name|X_add_number
operator|<=
name|MAX_GPREL_OFFSET
operator|&&
operator|!
name|nopic_need_relax
argument_list|(
name|ep
operator|->
name|X_add_symbol
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|relax_start
argument_list|(
name|ep
operator|->
name|X_add_symbol
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|ep
argument_list|,
name|ADDRESS_ADDI_INSN
argument_list|,
literal|"t,r,j"
argument_list|,
name|reg
argument_list|,
name|mips_gp_register
argument_list|,
name|BFD_RELOC_GPREL16
argument_list|)
expr_stmt|;
name|relax_switch
argument_list|()
expr_stmt|;
block|}
name|macro_build_lui
argument_list|(
name|ep
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|ep
argument_list|,
name|ADDRESS_ADDI_INSN
argument_list|,
literal|"t,r,j"
argument_list|,
name|reg
argument_list|,
name|reg
argument_list|,
name|BFD_RELOC_LO16
argument_list|)
expr_stmt|;
if|if
condition|(
name|mips_relax
operator|.
name|sequence
condition|)
name|relax_end
argument_list|()
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|mips_big_got
condition|)
block|{
name|expressionS
name|ex
decl_stmt|;
comment|/* If this is a reference to an external symbol, we want 	   lw		$reg,<sym>($gp)		(BFD_RELOC_MIPS_GOT16) 	 Otherwise we want 	   lw		$reg,<sym>($gp)		(BFD_RELOC_MIPS_GOT16) 	   nop 	   addiu	$reg,$reg,<sym>		(BFD_RELOC_LO16) 	 If there is a constant, it must be added in after.  	 If we have NewABI, we want 	   lw		$reg,<sym+cst>($gp)	(BFD_RELOC_MIPS_GOT_DISP)          unless we're referencing a global symbol with a non-zero          offset, in which case cst must be added separately.  */
if|if
condition|(
name|HAVE_NEWABI
condition|)
block|{
if|if
condition|(
name|ep
operator|->
name|X_add_number
condition|)
block|{
name|ex
operator|.
name|X_add_number
operator|=
name|ep
operator|->
name|X_add_number
expr_stmt|;
name|ep
operator|->
name|X_add_number
operator|=
literal|0
expr_stmt|;
name|relax_start
argument_list|(
name|ep
operator|->
name|X_add_symbol
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|ep
argument_list|,
name|ADDRESS_LOAD_INSN
argument_list|,
literal|"t,o(b)"
argument_list|,
name|reg
argument_list|,
name|BFD_RELOC_MIPS_GOT_DISP
argument_list|,
name|mips_gp_register
argument_list|)
expr_stmt|;
if|if
condition|(
name|ex
operator|.
name|X_add_number
operator|<
operator|-
literal|0x8000
operator|||
name|ex
operator|.
name|X_add_number
operator|>=
literal|0x8000
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"PIC code offset overflow (max 16 signed bits)"
argument_list|)
argument_list|)
expr_stmt|;
name|ex
operator|.
name|X_op
operator|=
name|O_constant
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|ex
argument_list|,
name|ADDRESS_ADDI_INSN
argument_list|,
literal|"t,r,j"
argument_list|,
name|reg
argument_list|,
name|reg
argument_list|,
name|BFD_RELOC_LO16
argument_list|)
expr_stmt|;
name|ep
operator|->
name|X_add_number
operator|=
name|ex
operator|.
name|X_add_number
expr_stmt|;
name|relax_switch
argument_list|()
expr_stmt|;
block|}
name|macro_build
argument_list|(
name|ep
argument_list|,
name|ADDRESS_LOAD_INSN
argument_list|,
literal|"t,o(b)"
argument_list|,
name|reg
argument_list|,
name|BFD_RELOC_MIPS_GOT_DISP
argument_list|,
name|mips_gp_register
argument_list|)
expr_stmt|;
if|if
condition|(
name|mips_relax
operator|.
name|sequence
condition|)
name|relax_end
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|ex
operator|.
name|X_add_number
operator|=
name|ep
operator|->
name|X_add_number
expr_stmt|;
name|ep
operator|->
name|X_add_number
operator|=
literal|0
expr_stmt|;
name|macro_build
argument_list|(
name|ep
argument_list|,
name|ADDRESS_LOAD_INSN
argument_list|,
literal|"t,o(b)"
argument_list|,
name|reg
argument_list|,
name|BFD_RELOC_MIPS_GOT16
argument_list|,
name|mips_gp_register
argument_list|)
expr_stmt|;
name|load_delay_nop
argument_list|()
expr_stmt|;
name|relax_start
argument_list|(
name|ep
operator|->
name|X_add_symbol
argument_list|)
expr_stmt|;
name|relax_switch
argument_list|()
expr_stmt|;
name|macro_build
argument_list|(
name|ep
argument_list|,
name|ADDRESS_ADDI_INSN
argument_list|,
literal|"t,r,j"
argument_list|,
name|reg
argument_list|,
name|reg
argument_list|,
name|BFD_RELOC_LO16
argument_list|)
expr_stmt|;
name|relax_end
argument_list|()
expr_stmt|;
if|if
condition|(
name|ex
operator|.
name|X_add_number
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|ex
operator|.
name|X_add_number
operator|<
operator|-
literal|0x8000
operator|||
name|ex
operator|.
name|X_add_number
operator|>=
literal|0x8000
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"PIC code offset overflow (max 16 signed bits)"
argument_list|)
argument_list|)
expr_stmt|;
name|ex
operator|.
name|X_op
operator|=
name|O_constant
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|ex
argument_list|,
name|ADDRESS_ADDI_INSN
argument_list|,
literal|"t,r,j"
argument_list|,
name|reg
argument_list|,
name|reg
argument_list|,
name|BFD_RELOC_LO16
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|mips_big_got
condition|)
block|{
name|expressionS
name|ex
decl_stmt|;
comment|/* This is the large GOT case.  If this is a reference to an 	 external symbol, we want 	   lui		$reg,<sym>		(BFD_RELOC_MIPS_GOT_HI16) 	   addu		$reg,$reg,$gp 	   lw		$reg,<sym>($reg)	(BFD_RELOC_MIPS_GOT_LO16)  	 Otherwise, for a reference to a local symbol in old ABI, we want 	   lw		$reg,<sym>($gp)		(BFD_RELOC_MIPS_GOT16) 	   nop 	   addiu	$reg,$reg,<sym>		(BFD_RELOC_LO16) 	 If there is a constant, it must be added in after.  	 In the NewABI, for local symbols, with or without offsets, we want: 	   lw		$reg,<sym>($gp)		(BFD_RELOC_MIPS_GOT_PAGE) 	   addiu	$reg,$reg,<sym>		(BFD_RELOC_MIPS_GOT_OFST)       */
if|if
condition|(
name|HAVE_NEWABI
condition|)
block|{
name|ex
operator|.
name|X_add_number
operator|=
name|ep
operator|->
name|X_add_number
expr_stmt|;
name|ep
operator|->
name|X_add_number
operator|=
literal|0
expr_stmt|;
name|relax_start
argument_list|(
name|ep
operator|->
name|X_add_symbol
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|ep
argument_list|,
literal|"lui"
argument_list|,
literal|"t,u"
argument_list|,
name|reg
argument_list|,
name|BFD_RELOC_MIPS_GOT_HI16
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
name|ADDRESS_ADD_INSN
argument_list|,
literal|"d,v,t"
argument_list|,
name|reg
argument_list|,
name|reg
argument_list|,
name|mips_gp_register
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|ep
argument_list|,
name|ADDRESS_LOAD_INSN
argument_list|,
literal|"t,o(b)"
argument_list|,
name|reg
argument_list|,
name|BFD_RELOC_MIPS_GOT_LO16
argument_list|,
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|ex
operator|.
name|X_add_number
operator|<
operator|-
literal|0x8000
operator|||
name|ex
operator|.
name|X_add_number
operator|>=
literal|0x8000
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"PIC code offset overflow (max 16 signed bits)"
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ex
operator|.
name|X_add_number
condition|)
block|{
name|ex
operator|.
name|X_op
operator|=
name|O_constant
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|ex
argument_list|,
name|ADDRESS_ADDI_INSN
argument_list|,
literal|"t,r,j"
argument_list|,
name|reg
argument_list|,
name|reg
argument_list|,
name|BFD_RELOC_LO16
argument_list|)
expr_stmt|;
block|}
name|ep
operator|->
name|X_add_number
operator|=
name|ex
operator|.
name|X_add_number
expr_stmt|;
name|relax_switch
argument_list|()
expr_stmt|;
name|macro_build
argument_list|(
name|ep
argument_list|,
name|ADDRESS_LOAD_INSN
argument_list|,
literal|"t,o(b)"
argument_list|,
name|reg
argument_list|,
name|BFD_RELOC_MIPS_GOT_PAGE
argument_list|,
name|mips_gp_register
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|ep
argument_list|,
name|ADDRESS_ADDI_INSN
argument_list|,
literal|"t,r,j"
argument_list|,
name|reg
argument_list|,
name|reg
argument_list|,
name|BFD_RELOC_MIPS_GOT_OFST
argument_list|)
expr_stmt|;
name|relax_end
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|ex
operator|.
name|X_add_number
operator|=
name|ep
operator|->
name|X_add_number
expr_stmt|;
name|ep
operator|->
name|X_add_number
operator|=
literal|0
expr_stmt|;
name|relax_start
argument_list|(
name|ep
operator|->
name|X_add_symbol
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|ep
argument_list|,
literal|"lui"
argument_list|,
literal|"t,u"
argument_list|,
name|reg
argument_list|,
name|BFD_RELOC_MIPS_GOT_HI16
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
name|ADDRESS_ADD_INSN
argument_list|,
literal|"d,v,t"
argument_list|,
name|reg
argument_list|,
name|reg
argument_list|,
name|mips_gp_register
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|ep
argument_list|,
name|ADDRESS_LOAD_INSN
argument_list|,
literal|"t,o(b)"
argument_list|,
name|reg
argument_list|,
name|BFD_RELOC_MIPS_GOT_LO16
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|relax_switch
argument_list|()
expr_stmt|;
if|if
condition|(
name|reg_needs_delay
argument_list|(
name|mips_gp_register
argument_list|)
condition|)
block|{
comment|/* We need a nop before loading from $gp.  This special 		 check is required because the lui which starts the main 		 instruction stream does not refer to $gp, and so will not 		 insert the nop which may be required.  */
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"nop"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
name|macro_build
argument_list|(
name|ep
argument_list|,
name|ADDRESS_LOAD_INSN
argument_list|,
literal|"t,o(b)"
argument_list|,
name|reg
argument_list|,
name|BFD_RELOC_MIPS_GOT16
argument_list|,
name|mips_gp_register
argument_list|)
expr_stmt|;
name|load_delay_nop
argument_list|()
expr_stmt|;
name|macro_build
argument_list|(
name|ep
argument_list|,
name|ADDRESS_ADDI_INSN
argument_list|,
literal|"t,r,j"
argument_list|,
name|reg
argument_list|,
name|reg
argument_list|,
name|BFD_RELOC_LO16
argument_list|)
expr_stmt|;
name|relax_end
argument_list|()
expr_stmt|;
if|if
condition|(
name|ex
operator|.
name|X_add_number
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|ex
operator|.
name|X_add_number
operator|<
operator|-
literal|0x8000
operator|||
name|ex
operator|.
name|X_add_number
operator|>=
literal|0x8000
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"PIC code offset overflow (max 16 signed bits)"
argument_list|)
argument_list|)
expr_stmt|;
name|ex
operator|.
name|X_op
operator|=
name|O_constant
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|ex
argument_list|,
name|ADDRESS_ADDI_INSN
argument_list|,
literal|"t,r,j"
argument_list|,
name|reg
argument_list|,
name|reg
argument_list|,
name|BFD_RELOC_LO16
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|mips_opts
operator|.
name|noat
operator|&&
operator|*
name|used_at
operator|==
literal|1
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Macro used $at after \".set noat\""
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Move the contents of register SOURCE into register DEST.  */
end_comment

begin_function
specifier|static
name|void
name|move_register
parameter_list|(
name|int
name|dest
parameter_list|,
name|int
name|source
parameter_list|)
block|{
name|macro_build
argument_list|(
name|NULL
argument_list|,
name|HAVE_32BIT_GPRS
condition|?
literal|"addu"
else|:
literal|"daddu"
argument_list|,
literal|"d,v,t"
argument_list|,
name|dest
argument_list|,
name|source
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Emit an SVR4 PIC sequence to load address LOCAL into DEST, where    LOCAL is the sum of a symbol and a 16-bit or 32-bit displacement.    The two alternatives are:     Global symbol		Local sybmol    -------------		------------    lw DEST,%got(SYMBOL)		lw DEST,%got(SYMBOL + OFFSET)    ...				...    addiu DEST,DEST,OFFSET	addiu DEST,DEST,%lo(SYMBOL + OFFSET)     load_got_offset emits the first instruction and add_got_offset    emits the second for a 16-bit offset or add_got_offset_hilo emits    a sequence to add a 32-bit offset using a scratch register.  */
end_comment

begin_function
specifier|static
name|void
name|load_got_offset
parameter_list|(
name|int
name|dest
parameter_list|,
name|expressionS
modifier|*
name|local
parameter_list|)
block|{
name|expressionS
name|global
decl_stmt|;
name|global
operator|=
operator|*
name|local
expr_stmt|;
name|global
operator|.
name|X_add_number
operator|=
literal|0
expr_stmt|;
name|relax_start
argument_list|(
name|local
operator|->
name|X_add_symbol
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|global
argument_list|,
name|ADDRESS_LOAD_INSN
argument_list|,
literal|"t,o(b)"
argument_list|,
name|dest
argument_list|,
name|BFD_RELOC_MIPS_GOT16
argument_list|,
name|mips_gp_register
argument_list|)
expr_stmt|;
name|relax_switch
argument_list|()
expr_stmt|;
name|macro_build
argument_list|(
name|local
argument_list|,
name|ADDRESS_LOAD_INSN
argument_list|,
literal|"t,o(b)"
argument_list|,
name|dest
argument_list|,
name|BFD_RELOC_MIPS_GOT16
argument_list|,
name|mips_gp_register
argument_list|)
expr_stmt|;
name|relax_end
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|add_got_offset
parameter_list|(
name|int
name|dest
parameter_list|,
name|expressionS
modifier|*
name|local
parameter_list|)
block|{
name|expressionS
name|global
decl_stmt|;
name|global
operator|.
name|X_op
operator|=
name|O_constant
expr_stmt|;
name|global
operator|.
name|X_op_symbol
operator|=
name|NULL
expr_stmt|;
name|global
operator|.
name|X_add_symbol
operator|=
name|NULL
expr_stmt|;
name|global
operator|.
name|X_add_number
operator|=
name|local
operator|->
name|X_add_number
expr_stmt|;
name|relax_start
argument_list|(
name|local
operator|->
name|X_add_symbol
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|global
argument_list|,
name|ADDRESS_ADDI_INSN
argument_list|,
literal|"t,r,j"
argument_list|,
name|dest
argument_list|,
name|dest
argument_list|,
name|BFD_RELOC_LO16
argument_list|)
expr_stmt|;
name|relax_switch
argument_list|()
expr_stmt|;
name|macro_build
argument_list|(
name|local
argument_list|,
name|ADDRESS_ADDI_INSN
argument_list|,
literal|"t,r,j"
argument_list|,
name|dest
argument_list|,
name|dest
argument_list|,
name|BFD_RELOC_LO16
argument_list|)
expr_stmt|;
name|relax_end
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|add_got_offset_hilo
parameter_list|(
name|int
name|dest
parameter_list|,
name|expressionS
modifier|*
name|local
parameter_list|,
name|int
name|tmp
parameter_list|)
block|{
name|expressionS
name|global
decl_stmt|;
name|int
name|hold_mips_optimize
decl_stmt|;
name|global
operator|.
name|X_op
operator|=
name|O_constant
expr_stmt|;
name|global
operator|.
name|X_op_symbol
operator|=
name|NULL
expr_stmt|;
name|global
operator|.
name|X_add_symbol
operator|=
name|NULL
expr_stmt|;
name|global
operator|.
name|X_add_number
operator|=
name|local
operator|->
name|X_add_number
expr_stmt|;
name|relax_start
argument_list|(
name|local
operator|->
name|X_add_symbol
argument_list|)
expr_stmt|;
name|load_register
argument_list|(
name|tmp
argument_list|,
operator|&
name|global
argument_list|,
name|HAVE_64BIT_ADDRESSES
argument_list|)
expr_stmt|;
name|relax_switch
argument_list|()
expr_stmt|;
comment|/* Set mips_optimize around the lui instruction to avoid      inserting an unnecessary nop after the lw.  */
name|hold_mips_optimize
operator|=
name|mips_optimize
expr_stmt|;
name|mips_optimize
operator|=
literal|2
expr_stmt|;
name|macro_build_lui
argument_list|(
operator|&
name|global
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|mips_optimize
operator|=
name|hold_mips_optimize
expr_stmt|;
name|macro_build
argument_list|(
name|local
argument_list|,
name|ADDRESS_ADDI_INSN
argument_list|,
literal|"t,r,j"
argument_list|,
name|tmp
argument_list|,
name|tmp
argument_list|,
name|BFD_RELOC_LO16
argument_list|)
expr_stmt|;
name|relax_end
argument_list|()
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
name|ADDRESS_ADD_INSN
argument_list|,
literal|"d,v,t"
argument_list|,
name|dest
argument_list|,
name|dest
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *			Build macros  *   This routine implements the seemingly endless macro or synthesized  * instructions and addressing modes in the mips assembly language. Many  * of these macros are simple and are similar to each other. These could  * probably be handled by some kind of table or grammar approach instead of  * this verbose method. Others are not simple macros but are more like  * optimizing code generation.  *   One interesting optimization is when several store macros appear  * consecutively that would load AT with the upper half of the same address.  * The ensuing load upper instructions are ommited. This implies some kind  * of global optimization. We currently only optimize within a single macro.  *   For many of the load and store macros if the address is specified as a  * constant expression in the first 64k of memory (ie ld $2,0x4000c) we  * first load register 'at' with zero and use it as the base register. The  * mips assembler simply uses register $zero. Just one tiny optimization  * we're missing.  */
end_comment

begin_function
specifier|static
name|void
name|macro
parameter_list|(
name|struct
name|mips_cl_insn
modifier|*
name|ip
parameter_list|)
block|{
name|int
name|treg
decl_stmt|,
name|sreg
decl_stmt|,
name|dreg
decl_stmt|,
name|breg
decl_stmt|;
name|int
name|tempreg
decl_stmt|;
name|int
name|mask
decl_stmt|;
name|int
name|used_at
init|=
literal|0
decl_stmt|;
name|expressionS
name|expr1
decl_stmt|;
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
specifier|const
name|char
modifier|*
name|s2
decl_stmt|;
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
name|int
name|likely
init|=
literal|0
decl_stmt|;
name|int
name|dbl
init|=
literal|0
decl_stmt|;
name|int
name|coproc
init|=
literal|0
decl_stmt|;
name|int
name|lr
init|=
literal|0
decl_stmt|;
name|int
name|imm
init|=
literal|0
decl_stmt|;
name|int
name|call
init|=
literal|0
decl_stmt|;
name|int
name|off
decl_stmt|;
name|offsetT
name|maxnum
decl_stmt|;
name|bfd_reloc_code_real_type
name|r
decl_stmt|;
name|int
name|hold_mips_optimize
decl_stmt|;
name|assert
argument_list|(
operator|!
name|mips_opts
operator|.
name|mips16
argument_list|)
expr_stmt|;
name|treg
operator|=
operator|(
name|ip
operator|->
name|insn_opcode
operator|>>
literal|16
operator|)
operator|&
literal|0x1f
expr_stmt|;
name|dreg
operator|=
operator|(
name|ip
operator|->
name|insn_opcode
operator|>>
literal|11
operator|)
operator|&
literal|0x1f
expr_stmt|;
name|sreg
operator|=
name|breg
operator|=
operator|(
name|ip
operator|->
name|insn_opcode
operator|>>
literal|21
operator|)
operator|&
literal|0x1f
expr_stmt|;
name|mask
operator|=
name|ip
operator|->
name|insn_mo
operator|->
name|mask
expr_stmt|;
name|expr1
operator|.
name|X_op
operator|=
name|O_constant
expr_stmt|;
name|expr1
operator|.
name|X_op_symbol
operator|=
name|NULL
expr_stmt|;
name|expr1
operator|.
name|X_add_symbol
operator|=
name|NULL
expr_stmt|;
name|expr1
operator|.
name|X_add_number
operator|=
literal|1
expr_stmt|;
switch|switch
condition|(
name|mask
condition|)
block|{
case|case
name|M_DABS
case|:
name|dbl
operator|=
literal|1
expr_stmt|;
case|case
name|M_ABS
case|:
comment|/* bgez $a0,.+12 	 move v0,$a0 	 sub v0,$zero,$a0 	 */
name|start_noreorder
argument_list|()
expr_stmt|;
name|expr1
operator|.
name|X_add_number
operator|=
literal|8
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|expr1
argument_list|,
literal|"bgez"
argument_list|,
literal|"s,p"
argument_list|,
name|sreg
argument_list|)
expr_stmt|;
if|if
condition|(
name|dreg
operator|==
name|sreg
condition|)
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"nop"
argument_list|,
literal|""
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|move_register
argument_list|(
name|dreg
argument_list|,
name|sreg
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
name|dbl
condition|?
literal|"dsub"
else|:
literal|"sub"
argument_list|,
literal|"d,v,t"
argument_list|,
name|dreg
argument_list|,
literal|0
argument_list|,
name|sreg
argument_list|)
expr_stmt|;
name|end_noreorder
argument_list|()
expr_stmt|;
break|break;
case|case
name|M_ADD_I
case|:
name|s
operator|=
literal|"addi"
expr_stmt|;
name|s2
operator|=
literal|"add"
expr_stmt|;
goto|goto
name|do_addi
goto|;
case|case
name|M_ADDU_I
case|:
name|s
operator|=
literal|"addiu"
expr_stmt|;
name|s2
operator|=
literal|"addu"
expr_stmt|;
goto|goto
name|do_addi
goto|;
case|case
name|M_DADD_I
case|:
name|dbl
operator|=
literal|1
expr_stmt|;
name|s
operator|=
literal|"daddi"
expr_stmt|;
name|s2
operator|=
literal|"dadd"
expr_stmt|;
goto|goto
name|do_addi
goto|;
case|case
name|M_DADDU_I
case|:
name|dbl
operator|=
literal|1
expr_stmt|;
name|s
operator|=
literal|"daddiu"
expr_stmt|;
name|s2
operator|=
literal|"daddu"
expr_stmt|;
name|do_addi
label|:
if|if
condition|(
name|imm_expr
operator|.
name|X_op
operator|==
name|O_constant
operator|&&
name|imm_expr
operator|.
name|X_add_number
operator|>=
operator|-
literal|0x8000
operator|&&
name|imm_expr
operator|.
name|X_add_number
operator|<
literal|0x8000
condition|)
block|{
name|macro_build
argument_list|(
operator|&
name|imm_expr
argument_list|,
name|s
argument_list|,
literal|"t,r,j"
argument_list|,
name|treg
argument_list|,
name|sreg
argument_list|,
name|BFD_RELOC_LO16
argument_list|)
expr_stmt|;
break|break;
block|}
name|used_at
operator|=
literal|1
expr_stmt|;
name|load_register
argument_list|(
name|AT
argument_list|,
operator|&
name|imm_expr
argument_list|,
name|dbl
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
name|s2
argument_list|,
literal|"d,v,t"
argument_list|,
name|treg
argument_list|,
name|sreg
argument_list|,
name|AT
argument_list|)
expr_stmt|;
break|break;
case|case
name|M_AND_I
case|:
name|s
operator|=
literal|"andi"
expr_stmt|;
name|s2
operator|=
literal|"and"
expr_stmt|;
goto|goto
name|do_bit
goto|;
case|case
name|M_OR_I
case|:
name|s
operator|=
literal|"ori"
expr_stmt|;
name|s2
operator|=
literal|"or"
expr_stmt|;
goto|goto
name|do_bit
goto|;
case|case
name|M_NOR_I
case|:
name|s
operator|=
literal|""
expr_stmt|;
name|s2
operator|=
literal|"nor"
expr_stmt|;
goto|goto
name|do_bit
goto|;
case|case
name|M_XOR_I
case|:
name|s
operator|=
literal|"xori"
expr_stmt|;
name|s2
operator|=
literal|"xor"
expr_stmt|;
name|do_bit
label|:
if|if
condition|(
name|imm_expr
operator|.
name|X_op
operator|==
name|O_constant
operator|&&
name|imm_expr
operator|.
name|X_add_number
operator|>=
literal|0
operator|&&
name|imm_expr
operator|.
name|X_add_number
operator|<
literal|0x10000
condition|)
block|{
if|if
condition|(
name|mask
operator|!=
name|M_NOR_I
condition|)
name|macro_build
argument_list|(
operator|&
name|imm_expr
argument_list|,
name|s
argument_list|,
literal|"t,r,i"
argument_list|,
name|treg
argument_list|,
name|sreg
argument_list|,
name|BFD_RELOC_LO16
argument_list|)
expr_stmt|;
else|else
block|{
name|macro_build
argument_list|(
operator|&
name|imm_expr
argument_list|,
literal|"ori"
argument_list|,
literal|"t,r,i"
argument_list|,
name|treg
argument_list|,
name|sreg
argument_list|,
name|BFD_RELOC_LO16
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"nor"
argument_list|,
literal|"d,v,t"
argument_list|,
name|treg
argument_list|,
name|treg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
name|used_at
operator|=
literal|1
expr_stmt|;
name|load_register
argument_list|(
name|AT
argument_list|,
operator|&
name|imm_expr
argument_list|,
name|HAVE_64BIT_GPRS
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
name|s2
argument_list|,
literal|"d,v,t"
argument_list|,
name|treg
argument_list|,
name|sreg
argument_list|,
name|AT
argument_list|)
expr_stmt|;
break|break;
case|case
name|M_BALIGN
case|:
switch|switch
condition|(
name|imm_expr
operator|.
name|X_add_number
condition|)
block|{
case|case
literal|0
case|:
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"nop"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"packrl.ph"
argument_list|,
literal|"d,s,t"
argument_list|,
name|treg
argument_list|,
name|treg
argument_list|,
name|sreg
argument_list|)
expr_stmt|;
break|break;
default|default:
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"balign"
argument_list|,
literal|"t,s,2"
argument_list|,
name|treg
argument_list|,
name|sreg
argument_list|,
operator|(
name|int
operator|)
name|imm_expr
operator|.
name|X_add_number
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|M_BEQ_I
case|:
name|s
operator|=
literal|"beq"
expr_stmt|;
goto|goto
name|beq_i
goto|;
case|case
name|M_BEQL_I
case|:
name|s
operator|=
literal|"beql"
expr_stmt|;
name|likely
operator|=
literal|1
expr_stmt|;
goto|goto
name|beq_i
goto|;
case|case
name|M_BNE_I
case|:
name|s
operator|=
literal|"bne"
expr_stmt|;
goto|goto
name|beq_i
goto|;
case|case
name|M_BNEL_I
case|:
name|s
operator|=
literal|"bnel"
expr_stmt|;
name|likely
operator|=
literal|1
expr_stmt|;
name|beq_i
label|:
if|if
condition|(
name|imm_expr
operator|.
name|X_op
operator|==
name|O_constant
operator|&&
name|imm_expr
operator|.
name|X_add_number
operator|==
literal|0
condition|)
block|{
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|s
argument_list|,
literal|"s,t,p"
argument_list|,
name|sreg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
name|used_at
operator|=
literal|1
expr_stmt|;
name|load_register
argument_list|(
name|AT
argument_list|,
operator|&
name|imm_expr
argument_list|,
name|HAVE_64BIT_GPRS
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|s
argument_list|,
literal|"s,t,p"
argument_list|,
name|sreg
argument_list|,
name|AT
argument_list|)
expr_stmt|;
break|break;
case|case
name|M_BGEL
case|:
name|likely
operator|=
literal|1
expr_stmt|;
case|case
name|M_BGE
case|:
if|if
condition|(
name|treg
operator|==
literal|0
condition|)
block|{
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|likely
condition|?
literal|"bgezl"
else|:
literal|"bgez"
argument_list|,
literal|"s,p"
argument_list|,
name|sreg
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|sreg
operator|==
literal|0
condition|)
block|{
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|likely
condition|?
literal|"blezl"
else|:
literal|"blez"
argument_list|,
literal|"s,p"
argument_list|,
name|treg
argument_list|)
expr_stmt|;
break|break;
block|}
name|used_at
operator|=
literal|1
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"slt"
argument_list|,
literal|"d,v,t"
argument_list|,
name|AT
argument_list|,
name|sreg
argument_list|,
name|treg
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|likely
condition|?
literal|"beql"
else|:
literal|"beq"
argument_list|,
literal|"s,t,p"
argument_list|,
name|AT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|M_BGTL_I
case|:
name|likely
operator|=
literal|1
expr_stmt|;
case|case
name|M_BGT_I
case|:
comment|/* check for> max integer */
name|maxnum
operator|=
literal|0x7fffffff
expr_stmt|;
if|if
condition|(
name|HAVE_64BIT_GPRS
operator|&&
sizeof|sizeof
argument_list|(
name|maxnum
argument_list|)
operator|>
literal|4
condition|)
block|{
name|maxnum
operator|<<=
literal|16
expr_stmt|;
name|maxnum
operator||=
literal|0xffff
expr_stmt|;
name|maxnum
operator|<<=
literal|16
expr_stmt|;
name|maxnum
operator||=
literal|0xffff
expr_stmt|;
block|}
if|if
condition|(
name|imm_expr
operator|.
name|X_op
operator|==
name|O_constant
operator|&&
name|imm_expr
operator|.
name|X_add_number
operator|>=
name|maxnum
operator|&&
operator|(
name|HAVE_32BIT_GPRS
operator|||
sizeof|sizeof
argument_list|(
name|maxnum
argument_list|)
operator|>
literal|4
operator|)
condition|)
block|{
name|do_false
label|:
comment|/* result is always false */
if|if
condition|(
operator|!
name|likely
condition|)
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"nop"
argument_list|,
literal|""
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
literal|"bnel"
argument_list|,
literal|"s,t,p"
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|imm_expr
operator|.
name|X_op
operator|!=
name|O_constant
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Unsupported large constant"
argument_list|)
argument_list|)
expr_stmt|;
operator|++
name|imm_expr
operator|.
name|X_add_number
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
name|M_BGE_I
case|:
case|case
name|M_BGEL_I
case|:
if|if
condition|(
name|mask
operator|==
name|M_BGEL_I
condition|)
name|likely
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|imm_expr
operator|.
name|X_op
operator|==
name|O_constant
operator|&&
name|imm_expr
operator|.
name|X_add_number
operator|==
literal|0
condition|)
block|{
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|likely
condition|?
literal|"bgezl"
else|:
literal|"bgez"
argument_list|,
literal|"s,p"
argument_list|,
name|sreg
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|imm_expr
operator|.
name|X_op
operator|==
name|O_constant
operator|&&
name|imm_expr
operator|.
name|X_add_number
operator|==
literal|1
condition|)
block|{
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|likely
condition|?
literal|"bgtzl"
else|:
literal|"bgtz"
argument_list|,
literal|"s,p"
argument_list|,
name|sreg
argument_list|)
expr_stmt|;
break|break;
block|}
name|maxnum
operator|=
literal|0x7fffffff
expr_stmt|;
if|if
condition|(
name|HAVE_64BIT_GPRS
operator|&&
sizeof|sizeof
argument_list|(
name|maxnum
argument_list|)
operator|>
literal|4
condition|)
block|{
name|maxnum
operator|<<=
literal|16
expr_stmt|;
name|maxnum
operator||=
literal|0xffff
expr_stmt|;
name|maxnum
operator|<<=
literal|16
expr_stmt|;
name|maxnum
operator||=
literal|0xffff
expr_stmt|;
block|}
name|maxnum
operator|=
operator|-
name|maxnum
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|imm_expr
operator|.
name|X_op
operator|==
name|O_constant
operator|&&
name|imm_expr
operator|.
name|X_add_number
operator|<=
name|maxnum
operator|&&
operator|(
name|HAVE_32BIT_GPRS
operator|||
sizeof|sizeof
argument_list|(
name|maxnum
argument_list|)
operator|>
literal|4
operator|)
condition|)
block|{
name|do_true
label|:
comment|/* result is always true */
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"Branch %s is always true"
argument_list|)
argument_list|,
name|ip
operator|->
name|insn_mo
operator|->
name|name
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
literal|"b"
argument_list|,
literal|"p"
argument_list|)
expr_stmt|;
break|break;
block|}
name|used_at
operator|=
literal|1
expr_stmt|;
name|set_at
argument_list|(
name|sreg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|likely
condition|?
literal|"beql"
else|:
literal|"beq"
argument_list|,
literal|"s,t,p"
argument_list|,
name|AT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|M_BGEUL
case|:
name|likely
operator|=
literal|1
expr_stmt|;
case|case
name|M_BGEU
case|:
if|if
condition|(
name|treg
operator|==
literal|0
condition|)
goto|goto
name|do_true
goto|;
if|if
condition|(
name|sreg
operator|==
literal|0
condition|)
block|{
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|likely
condition|?
literal|"beql"
else|:
literal|"beq"
argument_list|,
literal|"s,t,p"
argument_list|,
literal|0
argument_list|,
name|treg
argument_list|)
expr_stmt|;
break|break;
block|}
name|used_at
operator|=
literal|1
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"sltu"
argument_list|,
literal|"d,v,t"
argument_list|,
name|AT
argument_list|,
name|sreg
argument_list|,
name|treg
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|likely
condition|?
literal|"beql"
else|:
literal|"beq"
argument_list|,
literal|"s,t,p"
argument_list|,
name|AT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|M_BGTUL_I
case|:
name|likely
operator|=
literal|1
expr_stmt|;
case|case
name|M_BGTU_I
case|:
if|if
condition|(
name|sreg
operator|==
literal|0
operator|||
operator|(
name|HAVE_32BIT_GPRS
operator|&&
name|imm_expr
operator|.
name|X_op
operator|==
name|O_constant
operator|&&
name|imm_expr
operator|.
name|X_add_number
operator|==
operator|(
name|offsetT
operator|)
literal|0xffffffff
operator|)
condition|)
goto|goto
name|do_false
goto|;
if|if
condition|(
name|imm_expr
operator|.
name|X_op
operator|!=
name|O_constant
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Unsupported large constant"
argument_list|)
argument_list|)
expr_stmt|;
operator|++
name|imm_expr
operator|.
name|X_add_number
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
name|M_BGEU_I
case|:
case|case
name|M_BGEUL_I
case|:
if|if
condition|(
name|mask
operator|==
name|M_BGEUL_I
condition|)
name|likely
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|imm_expr
operator|.
name|X_op
operator|==
name|O_constant
operator|&&
name|imm_expr
operator|.
name|X_add_number
operator|==
literal|0
condition|)
goto|goto
name|do_true
goto|;
if|if
condition|(
name|imm_expr
operator|.
name|X_op
operator|==
name|O_constant
operator|&&
name|imm_expr
operator|.
name|X_add_number
operator|==
literal|1
condition|)
block|{
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|likely
condition|?
literal|"bnel"
else|:
literal|"bne"
argument_list|,
literal|"s,t,p"
argument_list|,
name|sreg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
name|used_at
operator|=
literal|1
expr_stmt|;
name|set_at
argument_list|(
name|sreg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|likely
condition|?
literal|"beql"
else|:
literal|"beq"
argument_list|,
literal|"s,t,p"
argument_list|,
name|AT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|M_BGTL
case|:
name|likely
operator|=
literal|1
expr_stmt|;
case|case
name|M_BGT
case|:
if|if
condition|(
name|treg
operator|==
literal|0
condition|)
block|{
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|likely
condition|?
literal|"bgtzl"
else|:
literal|"bgtz"
argument_list|,
literal|"s,p"
argument_list|,
name|sreg
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|sreg
operator|==
literal|0
condition|)
block|{
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|likely
condition|?
literal|"bltzl"
else|:
literal|"bltz"
argument_list|,
literal|"s,p"
argument_list|,
name|treg
argument_list|)
expr_stmt|;
break|break;
block|}
name|used_at
operator|=
literal|1
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"slt"
argument_list|,
literal|"d,v,t"
argument_list|,
name|AT
argument_list|,
name|treg
argument_list|,
name|sreg
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|likely
condition|?
literal|"bnel"
else|:
literal|"bne"
argument_list|,
literal|"s,t,p"
argument_list|,
name|AT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|M_BGTUL
case|:
name|likely
operator|=
literal|1
expr_stmt|;
case|case
name|M_BGTU
case|:
if|if
condition|(
name|treg
operator|==
literal|0
condition|)
block|{
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|likely
condition|?
literal|"bnel"
else|:
literal|"bne"
argument_list|,
literal|"s,t,p"
argument_list|,
name|sreg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|sreg
operator|==
literal|0
condition|)
goto|goto
name|do_false
goto|;
name|used_at
operator|=
literal|1
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"sltu"
argument_list|,
literal|"d,v,t"
argument_list|,
name|AT
argument_list|,
name|treg
argument_list|,
name|sreg
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|likely
condition|?
literal|"bnel"
else|:
literal|"bne"
argument_list|,
literal|"s,t,p"
argument_list|,
name|AT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|M_BLEL
case|:
name|likely
operator|=
literal|1
expr_stmt|;
case|case
name|M_BLE
case|:
if|if
condition|(
name|treg
operator|==
literal|0
condition|)
block|{
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|likely
condition|?
literal|"blezl"
else|:
literal|"blez"
argument_list|,
literal|"s,p"
argument_list|,
name|sreg
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|sreg
operator|==
literal|0
condition|)
block|{
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|likely
condition|?
literal|"bgezl"
else|:
literal|"bgez"
argument_list|,
literal|"s,p"
argument_list|,
name|treg
argument_list|)
expr_stmt|;
break|break;
block|}
name|used_at
operator|=
literal|1
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"slt"
argument_list|,
literal|"d,v,t"
argument_list|,
name|AT
argument_list|,
name|treg
argument_list|,
name|sreg
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|likely
condition|?
literal|"beql"
else|:
literal|"beq"
argument_list|,
literal|"s,t,p"
argument_list|,
name|AT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|M_BLEL_I
case|:
name|likely
operator|=
literal|1
expr_stmt|;
case|case
name|M_BLE_I
case|:
name|maxnum
operator|=
literal|0x7fffffff
expr_stmt|;
if|if
condition|(
name|HAVE_64BIT_GPRS
operator|&&
sizeof|sizeof
argument_list|(
name|maxnum
argument_list|)
operator|>
literal|4
condition|)
block|{
name|maxnum
operator|<<=
literal|16
expr_stmt|;
name|maxnum
operator||=
literal|0xffff
expr_stmt|;
name|maxnum
operator|<<=
literal|16
expr_stmt|;
name|maxnum
operator||=
literal|0xffff
expr_stmt|;
block|}
if|if
condition|(
name|imm_expr
operator|.
name|X_op
operator|==
name|O_constant
operator|&&
name|imm_expr
operator|.
name|X_add_number
operator|>=
name|maxnum
operator|&&
operator|(
name|HAVE_32BIT_GPRS
operator|||
sizeof|sizeof
argument_list|(
name|maxnum
argument_list|)
operator|>
literal|4
operator|)
condition|)
goto|goto
name|do_true
goto|;
if|if
condition|(
name|imm_expr
operator|.
name|X_op
operator|!=
name|O_constant
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Unsupported large constant"
argument_list|)
argument_list|)
expr_stmt|;
operator|++
name|imm_expr
operator|.
name|X_add_number
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
name|M_BLT_I
case|:
case|case
name|M_BLTL_I
case|:
if|if
condition|(
name|mask
operator|==
name|M_BLTL_I
condition|)
name|likely
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|imm_expr
operator|.
name|X_op
operator|==
name|O_constant
operator|&&
name|imm_expr
operator|.
name|X_add_number
operator|==
literal|0
condition|)
block|{
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|likely
condition|?
literal|"bltzl"
else|:
literal|"bltz"
argument_list|,
literal|"s,p"
argument_list|,
name|sreg
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|imm_expr
operator|.
name|X_op
operator|==
name|O_constant
operator|&&
name|imm_expr
operator|.
name|X_add_number
operator|==
literal|1
condition|)
block|{
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|likely
condition|?
literal|"blezl"
else|:
literal|"blez"
argument_list|,
literal|"s,p"
argument_list|,
name|sreg
argument_list|)
expr_stmt|;
break|break;
block|}
name|used_at
operator|=
literal|1
expr_stmt|;
name|set_at
argument_list|(
name|sreg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|likely
condition|?
literal|"bnel"
else|:
literal|"bne"
argument_list|,
literal|"s,t,p"
argument_list|,
name|AT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|M_BLEUL
case|:
name|likely
operator|=
literal|1
expr_stmt|;
case|case
name|M_BLEU
case|:
if|if
condition|(
name|treg
operator|==
literal|0
condition|)
block|{
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|likely
condition|?
literal|"beql"
else|:
literal|"beq"
argument_list|,
literal|"s,t,p"
argument_list|,
name|sreg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|sreg
operator|==
literal|0
condition|)
goto|goto
name|do_true
goto|;
name|used_at
operator|=
literal|1
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"sltu"
argument_list|,
literal|"d,v,t"
argument_list|,
name|AT
argument_list|,
name|treg
argument_list|,
name|sreg
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|likely
condition|?
literal|"beql"
else|:
literal|"beq"
argument_list|,
literal|"s,t,p"
argument_list|,
name|AT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|M_BLEUL_I
case|:
name|likely
operator|=
literal|1
expr_stmt|;
case|case
name|M_BLEU_I
case|:
if|if
condition|(
name|sreg
operator|==
literal|0
operator|||
operator|(
name|HAVE_32BIT_GPRS
operator|&&
name|imm_expr
operator|.
name|X_op
operator|==
name|O_constant
operator|&&
name|imm_expr
operator|.
name|X_add_number
operator|==
operator|(
name|offsetT
operator|)
literal|0xffffffff
operator|)
condition|)
goto|goto
name|do_true
goto|;
if|if
condition|(
name|imm_expr
operator|.
name|X_op
operator|!=
name|O_constant
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Unsupported large constant"
argument_list|)
argument_list|)
expr_stmt|;
operator|++
name|imm_expr
operator|.
name|X_add_number
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
name|M_BLTU_I
case|:
case|case
name|M_BLTUL_I
case|:
if|if
condition|(
name|mask
operator|==
name|M_BLTUL_I
condition|)
name|likely
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|imm_expr
operator|.
name|X_op
operator|==
name|O_constant
operator|&&
name|imm_expr
operator|.
name|X_add_number
operator|==
literal|0
condition|)
goto|goto
name|do_false
goto|;
if|if
condition|(
name|imm_expr
operator|.
name|X_op
operator|==
name|O_constant
operator|&&
name|imm_expr
operator|.
name|X_add_number
operator|==
literal|1
condition|)
block|{
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|likely
condition|?
literal|"beql"
else|:
literal|"beq"
argument_list|,
literal|"s,t,p"
argument_list|,
name|sreg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
name|used_at
operator|=
literal|1
expr_stmt|;
name|set_at
argument_list|(
name|sreg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|likely
condition|?
literal|"bnel"
else|:
literal|"bne"
argument_list|,
literal|"s,t,p"
argument_list|,
name|AT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|M_BLTL
case|:
name|likely
operator|=
literal|1
expr_stmt|;
case|case
name|M_BLT
case|:
if|if
condition|(
name|treg
operator|==
literal|0
condition|)
block|{
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|likely
condition|?
literal|"bltzl"
else|:
literal|"bltz"
argument_list|,
literal|"s,p"
argument_list|,
name|sreg
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|sreg
operator|==
literal|0
condition|)
block|{
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|likely
condition|?
literal|"bgtzl"
else|:
literal|"bgtz"
argument_list|,
literal|"s,p"
argument_list|,
name|treg
argument_list|)
expr_stmt|;
break|break;
block|}
name|used_at
operator|=
literal|1
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"slt"
argument_list|,
literal|"d,v,t"
argument_list|,
name|AT
argument_list|,
name|sreg
argument_list|,
name|treg
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|likely
condition|?
literal|"bnel"
else|:
literal|"bne"
argument_list|,
literal|"s,t,p"
argument_list|,
name|AT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|M_BLTUL
case|:
name|likely
operator|=
literal|1
expr_stmt|;
case|case
name|M_BLTU
case|:
if|if
condition|(
name|treg
operator|==
literal|0
condition|)
goto|goto
name|do_false
goto|;
if|if
condition|(
name|sreg
operator|==
literal|0
condition|)
block|{
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|likely
condition|?
literal|"bnel"
else|:
literal|"bne"
argument_list|,
literal|"s,t,p"
argument_list|,
literal|0
argument_list|,
name|treg
argument_list|)
expr_stmt|;
break|break;
block|}
name|used_at
operator|=
literal|1
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"sltu"
argument_list|,
literal|"d,v,t"
argument_list|,
name|AT
argument_list|,
name|sreg
argument_list|,
name|treg
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|likely
condition|?
literal|"bnel"
else|:
literal|"bne"
argument_list|,
literal|"s,t,p"
argument_list|,
name|AT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|M_DEXT
case|:
block|{
name|unsigned
name|long
name|pos
decl_stmt|;
name|unsigned
name|long
name|size
decl_stmt|;
if|if
condition|(
name|imm_expr
operator|.
name|X_op
operator|!=
name|O_constant
operator|||
name|imm2_expr
operator|.
name|X_op
operator|!=
name|O_constant
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Unsupported large constant"
argument_list|)
argument_list|)
expr_stmt|;
name|pos
operator|=
name|size
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|pos
operator|=
operator|(
name|unsigned
name|long
operator|)
name|imm_expr
operator|.
name|X_add_number
expr_stmt|;
name|size
operator|=
operator|(
name|unsigned
name|long
operator|)
name|imm2_expr
operator|.
name|X_add_number
expr_stmt|;
block|}
if|if
condition|(
name|pos
operator|>
literal|63
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Improper position (%lu)"
argument_list|)
argument_list|,
name|pos
argument_list|)
expr_stmt|;
name|pos
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|size
operator|==
literal|0
operator|||
name|size
operator|>
literal|64
operator|||
operator|(
name|pos
operator|+
name|size
operator|-
literal|1
operator|)
operator|>
literal|63
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Improper extract size (%lu, position %lu)"
argument_list|)
argument_list|,
name|size
argument_list|,
name|pos
argument_list|)
expr_stmt|;
name|size
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|size
operator|<=
literal|32
operator|&&
name|pos
operator|<
literal|32
condition|)
block|{
name|s
operator|=
literal|"dext"
expr_stmt|;
name|fmt
operator|=
literal|"t,r,+A,+C"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|size
operator|<=
literal|32
condition|)
block|{
name|s
operator|=
literal|"dextu"
expr_stmt|;
name|fmt
operator|=
literal|"t,r,+E,+H"
expr_stmt|;
block|}
else|else
block|{
name|s
operator|=
literal|"dextm"
expr_stmt|;
name|fmt
operator|=
literal|"t,r,+A,+G"
expr_stmt|;
block|}
name|macro_build
argument_list|(
operator|(
name|expressionS
operator|*
operator|)
name|NULL
argument_list|,
name|s
argument_list|,
name|fmt
argument_list|,
name|treg
argument_list|,
name|sreg
argument_list|,
name|pos
argument_list|,
name|size
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|M_DINS
case|:
block|{
name|unsigned
name|long
name|pos
decl_stmt|;
name|unsigned
name|long
name|size
decl_stmt|;
if|if
condition|(
name|imm_expr
operator|.
name|X_op
operator|!=
name|O_constant
operator|||
name|imm2_expr
operator|.
name|X_op
operator|!=
name|O_constant
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Unsupported large constant"
argument_list|)
argument_list|)
expr_stmt|;
name|pos
operator|=
name|size
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|pos
operator|=
operator|(
name|unsigned
name|long
operator|)
name|imm_expr
operator|.
name|X_add_number
expr_stmt|;
name|size
operator|=
operator|(
name|unsigned
name|long
operator|)
name|imm2_expr
operator|.
name|X_add_number
expr_stmt|;
block|}
if|if
condition|(
name|pos
operator|>
literal|63
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Improper position (%lu)"
argument_list|)
argument_list|,
name|pos
argument_list|)
expr_stmt|;
name|pos
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|size
operator|==
literal|0
operator|||
name|size
operator|>
literal|64
operator|||
operator|(
name|pos
operator|+
name|size
operator|-
literal|1
operator|)
operator|>
literal|63
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Improper insert size (%lu, position %lu)"
argument_list|)
argument_list|,
name|size
argument_list|,
name|pos
argument_list|)
expr_stmt|;
name|size
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|pos
operator|<
literal|32
operator|&&
operator|(
name|pos
operator|+
name|size
operator|-
literal|1
operator|)
operator|<
literal|32
condition|)
block|{
name|s
operator|=
literal|"dins"
expr_stmt|;
name|fmt
operator|=
literal|"t,r,+A,+B"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pos
operator|>=
literal|32
condition|)
block|{
name|s
operator|=
literal|"dinsu"
expr_stmt|;
name|fmt
operator|=
literal|"t,r,+E,+F"
expr_stmt|;
block|}
else|else
block|{
name|s
operator|=
literal|"dinsm"
expr_stmt|;
name|fmt
operator|=
literal|"t,r,+A,+F"
expr_stmt|;
block|}
name|macro_build
argument_list|(
operator|(
name|expressionS
operator|*
operator|)
name|NULL
argument_list|,
name|s
argument_list|,
name|fmt
argument_list|,
name|treg
argument_list|,
name|sreg
argument_list|,
name|pos
argument_list|,
name|pos
operator|+
name|size
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|M_DDIV_3
case|:
name|dbl
operator|=
literal|1
expr_stmt|;
case|case
name|M_DIV_3
case|:
name|s
operator|=
literal|"mflo"
expr_stmt|;
goto|goto
name|do_div3
goto|;
case|case
name|M_DREM_3
case|:
name|dbl
operator|=
literal|1
expr_stmt|;
case|case
name|M_REM_3
case|:
name|s
operator|=
literal|"mfhi"
expr_stmt|;
name|do_div3
label|:
if|if
condition|(
name|treg
operator|==
literal|0
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"Divide by zero."
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mips_trap
condition|)
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"teq"
argument_list|,
literal|"s,t,q"
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|7
argument_list|)
expr_stmt|;
else|else
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"break"
argument_list|,
literal|"c"
argument_list|,
literal|7
argument_list|)
expr_stmt|;
break|break;
block|}
name|start_noreorder
argument_list|()
expr_stmt|;
if|if
condition|(
name|mips_trap
condition|)
block|{
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"teq"
argument_list|,
literal|"s,t,q"
argument_list|,
name|treg
argument_list|,
literal|0
argument_list|,
literal|7
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
name|dbl
condition|?
literal|"ddiv"
else|:
literal|"div"
argument_list|,
literal|"z,s,t"
argument_list|,
name|sreg
argument_list|,
name|treg
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|expr1
operator|.
name|X_add_number
operator|=
literal|8
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|expr1
argument_list|,
literal|"bne"
argument_list|,
literal|"s,t,p"
argument_list|,
name|treg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
name|dbl
condition|?
literal|"ddiv"
else|:
literal|"div"
argument_list|,
literal|"z,s,t"
argument_list|,
name|sreg
argument_list|,
name|treg
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"break"
argument_list|,
literal|"c"
argument_list|,
literal|7
argument_list|)
expr_stmt|;
block|}
name|expr1
operator|.
name|X_add_number
operator|=
operator|-
literal|1
expr_stmt|;
name|used_at
operator|=
literal|1
expr_stmt|;
name|load_register
argument_list|(
name|AT
argument_list|,
operator|&
name|expr1
argument_list|,
name|dbl
argument_list|)
expr_stmt|;
name|expr1
operator|.
name|X_add_number
operator|=
name|mips_trap
condition|?
operator|(
name|dbl
condition|?
literal|12
else|:
literal|8
operator|)
else|:
operator|(
name|dbl
condition|?
literal|20
else|:
literal|16
operator|)
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|expr1
argument_list|,
literal|"bne"
argument_list|,
literal|"s,t,p"
argument_list|,
name|treg
argument_list|,
name|AT
argument_list|)
expr_stmt|;
if|if
condition|(
name|dbl
condition|)
block|{
name|expr1
operator|.
name|X_add_number
operator|=
literal|1
expr_stmt|;
name|load_register
argument_list|(
name|AT
argument_list|,
operator|&
name|expr1
argument_list|,
name|dbl
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"dsll32"
argument_list|,
literal|"d,w,<"
argument_list|,
name|AT
argument_list|,
name|AT
argument_list|,
literal|31
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|expr1
operator|.
name|X_add_number
operator|=
literal|0x80000000
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|expr1
argument_list|,
literal|"lui"
argument_list|,
literal|"t,u"
argument_list|,
name|AT
argument_list|,
name|BFD_RELOC_HI16
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mips_trap
condition|)
block|{
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"teq"
argument_list|,
literal|"s,t,q"
argument_list|,
name|sreg
argument_list|,
name|AT
argument_list|,
literal|6
argument_list|)
expr_stmt|;
comment|/* We want to close the noreorder block as soon as possible, so 	     that later insns are available for delay slot filling.  */
name|end_noreorder
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|expr1
operator|.
name|X_add_number
operator|=
literal|8
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|expr1
argument_list|,
literal|"bne"
argument_list|,
literal|"s,t,p"
argument_list|,
name|sreg
argument_list|,
name|AT
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"nop"
argument_list|,
literal|""
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* We want to close the noreorder block as soon as possible, so 	     that later insns are available for delay slot filling.  */
name|end_noreorder
argument_list|()
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"break"
argument_list|,
literal|"c"
argument_list|,
literal|6
argument_list|)
expr_stmt|;
block|}
name|macro_build
argument_list|(
name|NULL
argument_list|,
name|s
argument_list|,
literal|"d"
argument_list|,
name|dreg
argument_list|)
expr_stmt|;
break|break;
case|case
name|M_DIV_3I
case|:
name|s
operator|=
literal|"div"
expr_stmt|;
name|s2
operator|=
literal|"mflo"
expr_stmt|;
goto|goto
name|do_divi
goto|;
case|case
name|M_DIVU_3I
case|:
name|s
operator|=
literal|"divu"
expr_stmt|;
name|s2
operator|=
literal|"mflo"
expr_stmt|;
goto|goto
name|do_divi
goto|;
case|case
name|M_REM_3I
case|:
name|s
operator|=
literal|"div"
expr_stmt|;
name|s2
operator|=
literal|"mfhi"
expr_stmt|;
goto|goto
name|do_divi
goto|;
case|case
name|M_REMU_3I
case|:
name|s
operator|=
literal|"divu"
expr_stmt|;
name|s2
operator|=
literal|"mfhi"
expr_stmt|;
goto|goto
name|do_divi
goto|;
case|case
name|M_DDIV_3I
case|:
name|dbl
operator|=
literal|1
expr_stmt|;
name|s
operator|=
literal|"ddiv"
expr_stmt|;
name|s2
operator|=
literal|"mflo"
expr_stmt|;
goto|goto
name|do_divi
goto|;
case|case
name|M_DDIVU_3I
case|:
name|dbl
operator|=
literal|1
expr_stmt|;
name|s
operator|=
literal|"ddivu"
expr_stmt|;
name|s2
operator|=
literal|"mflo"
expr_stmt|;
goto|goto
name|do_divi
goto|;
case|case
name|M_DREM_3I
case|:
name|dbl
operator|=
literal|1
expr_stmt|;
name|s
operator|=
literal|"ddiv"
expr_stmt|;
name|s2
operator|=
literal|"mfhi"
expr_stmt|;
goto|goto
name|do_divi
goto|;
case|case
name|M_DREMU_3I
case|:
name|dbl
operator|=
literal|1
expr_stmt|;
name|s
operator|=
literal|"ddivu"
expr_stmt|;
name|s2
operator|=
literal|"mfhi"
expr_stmt|;
name|do_divi
label|:
if|if
condition|(
name|imm_expr
operator|.
name|X_op
operator|==
name|O_constant
operator|&&
name|imm_expr
operator|.
name|X_add_number
operator|==
literal|0
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"Divide by zero."
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mips_trap
condition|)
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"teq"
argument_list|,
literal|"s,t,q"
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|7
argument_list|)
expr_stmt|;
else|else
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"break"
argument_list|,
literal|"c"
argument_list|,
literal|7
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|imm_expr
operator|.
name|X_op
operator|==
name|O_constant
operator|&&
name|imm_expr
operator|.
name|X_add_number
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|s2
argument_list|,
literal|"mflo"
argument_list|)
operator|==
literal|0
condition|)
name|move_register
argument_list|(
name|dreg
argument_list|,
name|sreg
argument_list|)
expr_stmt|;
else|else
name|move_register
argument_list|(
name|dreg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|imm_expr
operator|.
name|X_op
operator|==
name|O_constant
operator|&&
name|imm_expr
operator|.
name|X_add_number
operator|==
operator|-
literal|1
operator|&&
name|s
index|[
name|strlen
argument_list|(
name|s
argument_list|)
operator|-
literal|1
index|]
operator|!=
literal|'u'
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|s2
argument_list|,
literal|"mflo"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|macro_build
argument_list|(
name|NULL
argument_list|,
name|dbl
condition|?
literal|"dneg"
else|:
literal|"neg"
argument_list|,
literal|"d,w"
argument_list|,
name|dreg
argument_list|,
name|sreg
argument_list|)
expr_stmt|;
block|}
else|else
name|move_register
argument_list|(
name|dreg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
name|used_at
operator|=
literal|1
expr_stmt|;
name|load_register
argument_list|(
name|AT
argument_list|,
operator|&
name|imm_expr
argument_list|,
name|dbl
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
name|s
argument_list|,
literal|"z,s,t"
argument_list|,
name|sreg
argument_list|,
name|AT
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
name|s2
argument_list|,
literal|"d"
argument_list|,
name|dreg
argument_list|)
expr_stmt|;
break|break;
case|case
name|M_DIVU_3
case|:
name|s
operator|=
literal|"divu"
expr_stmt|;
name|s2
operator|=
literal|"mflo"
expr_stmt|;
goto|goto
name|do_divu3
goto|;
case|case
name|M_REMU_3
case|:
name|s
operator|=
literal|"divu"
expr_stmt|;
name|s2
operator|=
literal|"mfhi"
expr_stmt|;
goto|goto
name|do_divu3
goto|;
case|case
name|M_DDIVU_3
case|:
name|s
operator|=
literal|"ddivu"
expr_stmt|;
name|s2
operator|=
literal|"mflo"
expr_stmt|;
goto|goto
name|do_divu3
goto|;
case|case
name|M_DREMU_3
case|:
name|s
operator|=
literal|"ddivu"
expr_stmt|;
name|s2
operator|=
literal|"mfhi"
expr_stmt|;
name|do_divu3
label|:
name|start_noreorder
argument_list|()
expr_stmt|;
if|if
condition|(
name|mips_trap
condition|)
block|{
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"teq"
argument_list|,
literal|"s,t,q"
argument_list|,
name|treg
argument_list|,
literal|0
argument_list|,
literal|7
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
name|s
argument_list|,
literal|"z,s,t"
argument_list|,
name|sreg
argument_list|,
name|treg
argument_list|)
expr_stmt|;
comment|/* We want to close the noreorder block as soon as possible, so 	     that later insns are available for delay slot filling.  */
name|end_noreorder
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|expr1
operator|.
name|X_add_number
operator|=
literal|8
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|expr1
argument_list|,
literal|"bne"
argument_list|,
literal|"s,t,p"
argument_list|,
name|treg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
name|s
argument_list|,
literal|"z,s,t"
argument_list|,
name|sreg
argument_list|,
name|treg
argument_list|)
expr_stmt|;
comment|/* We want to close the noreorder block as soon as possible, so 	     that later insns are available for delay slot filling.  */
name|end_noreorder
argument_list|()
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"break"
argument_list|,
literal|"c"
argument_list|,
literal|7
argument_list|)
expr_stmt|;
block|}
name|macro_build
argument_list|(
name|NULL
argument_list|,
name|s2
argument_list|,
literal|"d"
argument_list|,
name|dreg
argument_list|)
expr_stmt|;
break|break;
case|case
name|M_DLCA_AB
case|:
name|dbl
operator|=
literal|1
expr_stmt|;
case|case
name|M_LCA_AB
case|:
name|call
operator|=
literal|1
expr_stmt|;
goto|goto
name|do_la
goto|;
case|case
name|M_DLA_AB
case|:
name|dbl
operator|=
literal|1
expr_stmt|;
case|case
name|M_LA_AB
case|:
name|do_la
label|:
comment|/* Load the address of a symbol into a register.  If breg is not 	 zero, we then add a base register to it.  */
if|if
condition|(
name|dbl
operator|&&
name|HAVE_32BIT_GPRS
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"dla used to load 32-bit register"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dbl
operator|&&
name|HAVE_64BIT_OBJECTS
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"la used to load 64-bit address"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset_expr
operator|.
name|X_op
operator|==
name|O_constant
operator|&&
name|offset_expr
operator|.
name|X_add_number
operator|>=
operator|-
literal|0x8000
operator|&&
name|offset_expr
operator|.
name|X_add_number
operator|<
literal|0x8000
condition|)
block|{
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|ADDRESS_ADDI_INSN
argument_list|,
literal|"t,r,j"
argument_list|,
name|treg
argument_list|,
name|sreg
argument_list|,
name|BFD_RELOC_LO16
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|mips_opts
operator|.
name|noat
operator|&&
operator|(
name|treg
operator|==
name|breg
operator|)
condition|)
block|{
name|tempreg
operator|=
name|AT
expr_stmt|;
name|used_at
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|tempreg
operator|=
name|treg
expr_stmt|;
block|}
if|if
condition|(
name|offset_expr
operator|.
name|X_op
operator|!=
name|O_symbol
operator|&&
name|offset_expr
operator|.
name|X_op
operator|!=
name|O_constant
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"expression too complex"
argument_list|)
argument_list|)
expr_stmt|;
name|offset_expr
operator|.
name|X_op
operator|=
name|O_constant
expr_stmt|;
block|}
if|if
condition|(
name|offset_expr
operator|.
name|X_op
operator|==
name|O_constant
condition|)
name|load_register
argument_list|(
name|tempreg
argument_list|,
operator|&
name|offset_expr
argument_list|,
name|HAVE_64BIT_ADDRESSES
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|mips_pic
operator|==
name|NO_PIC
condition|)
block|{
comment|/* If this is a reference to a GP relative symbol, we want 	       addiu	$tempreg,$gp,<sym>	(BFD_RELOC_GPREL16) 	     Otherwise we want 	       lui	$tempreg,<sym>		(BFD_RELOC_HI16_S) 	       addiu	$tempreg,$tempreg,<sym>	(BFD_RELOC_LO16) 	     If we have a constant, we need two instructions anyhow, 	     so we may as well always use the latter form.  	     With 64bit address space and a usable $at we want 	       lui	$tempreg,<sym>		(BFD_RELOC_MIPS_HIGHEST) 	       lui	$at,<sym>		(BFD_RELOC_HI16_S) 	       daddiu	$tempreg,<sym>		(BFD_RELOC_MIPS_HIGHER) 	       daddiu	$at,<sym>		(BFD_RELOC_LO16) 	       dsll32	$tempreg,0 	       daddu	$tempreg,$tempreg,$at  	     If $at is already in use, we use a path which is suboptimal 	     on superscalar processors. 	       lui	$tempreg,<sym>		(BFD_RELOC_MIPS_HIGHEST) 	       daddiu	$tempreg,<sym>		(BFD_RELOC_MIPS_HIGHER) 	       dsll	$tempreg,16 	       daddiu	$tempreg,<sym>		(BFD_RELOC_HI16_S) 	       dsll	$tempreg,16 	       daddiu	$tempreg,<sym>		(BFD_RELOC_LO16)  	     For GP relative symbols in 64bit address space we can use 	     the same sequence as in 32bit address space.  */
if|if
condition|(
name|HAVE_64BIT_SYMBOLS
condition|)
block|{
if|if
condition|(
operator|(
name|valueT
operator|)
name|offset_expr
operator|.
name|X_add_number
operator|<=
name|MAX_GPREL_OFFSET
operator|&&
operator|!
name|nopic_need_relax
argument_list|(
name|offset_expr
operator|.
name|X_add_symbol
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|relax_start
argument_list|(
name|offset_expr
operator|.
name|X_add_symbol
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|ADDRESS_ADDI_INSN
argument_list|,
literal|"t,r,j"
argument_list|,
name|tempreg
argument_list|,
name|mips_gp_register
argument_list|,
name|BFD_RELOC_GPREL16
argument_list|)
expr_stmt|;
name|relax_switch
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|used_at
operator|==
literal|0
operator|&&
operator|!
name|mips_opts
operator|.
name|noat
condition|)
block|{
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
literal|"lui"
argument_list|,
literal|"t,u"
argument_list|,
name|tempreg
argument_list|,
name|BFD_RELOC_MIPS_HIGHEST
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
literal|"lui"
argument_list|,
literal|"t,u"
argument_list|,
name|AT
argument_list|,
name|BFD_RELOC_HI16_S
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
literal|"daddiu"
argument_list|,
literal|"t,r,j"
argument_list|,
name|tempreg
argument_list|,
name|tempreg
argument_list|,
name|BFD_RELOC_MIPS_HIGHER
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
literal|"daddiu"
argument_list|,
literal|"t,r,j"
argument_list|,
name|AT
argument_list|,
name|AT
argument_list|,
name|BFD_RELOC_LO16
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"dsll32"
argument_list|,
literal|"d,w,<"
argument_list|,
name|tempreg
argument_list|,
name|tempreg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"daddu"
argument_list|,
literal|"d,v,t"
argument_list|,
name|tempreg
argument_list|,
name|tempreg
argument_list|,
name|AT
argument_list|)
expr_stmt|;
name|used_at
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
literal|"lui"
argument_list|,
literal|"t,u"
argument_list|,
name|tempreg
argument_list|,
name|BFD_RELOC_MIPS_HIGHEST
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
literal|"daddiu"
argument_list|,
literal|"t,r,j"
argument_list|,
name|tempreg
argument_list|,
name|tempreg
argument_list|,
name|BFD_RELOC_MIPS_HIGHER
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"dsll"
argument_list|,
literal|"d,w,<"
argument_list|,
name|tempreg
argument_list|,
name|tempreg
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
literal|"daddiu"
argument_list|,
literal|"t,r,j"
argument_list|,
name|tempreg
argument_list|,
name|tempreg
argument_list|,
name|BFD_RELOC_HI16_S
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"dsll"
argument_list|,
literal|"d,w,<"
argument_list|,
name|tempreg
argument_list|,
name|tempreg
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
literal|"daddiu"
argument_list|,
literal|"t,r,j"
argument_list|,
name|tempreg
argument_list|,
name|tempreg
argument_list|,
name|BFD_RELOC_LO16
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mips_relax
operator|.
name|sequence
condition|)
name|relax_end
argument_list|()
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|valueT
operator|)
name|offset_expr
operator|.
name|X_add_number
operator|<=
name|MAX_GPREL_OFFSET
operator|&&
operator|!
name|nopic_need_relax
argument_list|(
name|offset_expr
operator|.
name|X_add_symbol
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|relax_start
argument_list|(
name|offset_expr
operator|.
name|X_add_symbol
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|ADDRESS_ADDI_INSN
argument_list|,
literal|"t,r,j"
argument_list|,
name|tempreg
argument_list|,
name|mips_gp_register
argument_list|,
name|BFD_RELOC_GPREL16
argument_list|)
expr_stmt|;
name|relax_switch
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|IS_SEXT_32BIT_NUM
argument_list|(
name|offset_expr
operator|.
name|X_add_number
argument_list|)
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"offset too large"
argument_list|)
argument_list|)
expr_stmt|;
name|macro_build_lui
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|tempreg
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|ADDRESS_ADDI_INSN
argument_list|,
literal|"t,r,j"
argument_list|,
name|tempreg
argument_list|,
name|tempreg
argument_list|,
name|BFD_RELOC_LO16
argument_list|)
expr_stmt|;
if|if
condition|(
name|mips_relax
operator|.
name|sequence
condition|)
name|relax_end
argument_list|()
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|mips_big_got
operator|&&
operator|!
name|HAVE_NEWABI
condition|)
block|{
name|int
name|lw_reloc_type
init|=
operator|(
name|int
operator|)
name|BFD_RELOC_MIPS_GOT16
decl_stmt|;
comment|/* If this is a reference to an external symbol, and there 	     is no constant, we want 	       lw	$tempreg,<sym>($gp)	(BFD_RELOC_MIPS_GOT16) 	     or for lca or if tempreg is PIC_CALL_REG 	       lw	$tempreg,<sym>($gp)	(BFD_RELOC_MIPS_CALL16) 	     For a local symbol, we want 	       lw	$tempreg,<sym>($gp)	(BFD_RELOC_MIPS_GOT16) 	       nop 	       addiu	$tempreg,$tempreg,<sym>	(BFD_RELOC_LO16)  	     If we have a small constant, and this is a reference to 	     an external symbol, we want 	       lw	$tempreg,<sym>($gp)	(BFD_RELOC_MIPS_GOT16) 	       nop 	       addiu	$tempreg,$tempreg,<constant> 	     For a local symbol, we want the same instruction 	     sequence, but we output a BFD_RELOC_LO16 reloc on the 	     addiu instruction.  	     If we have a large constant, and this is a reference to 	     an external symbol, we want 	       lw	$tempreg,<sym>($gp)	(BFD_RELOC_MIPS_GOT16) 	       lui	$at,<hiconstant> 	       addiu	$at,$at,<loconstant> 	       addu	$tempreg,$tempreg,$at 	     For a local symbol, we want the same instruction 	     sequence, but we output a BFD_RELOC_LO16 reloc on the 	     addiu instruction. 	   */
if|if
condition|(
name|offset_expr
operator|.
name|X_add_number
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|mips_pic
operator|==
name|SVR4_PIC
operator|&&
name|breg
operator|==
literal|0
operator|&&
operator|(
name|call
operator|||
name|tempreg
operator|==
name|PIC_CALL_REG
operator|)
condition|)
name|lw_reloc_type
operator|=
operator|(
name|int
operator|)
name|BFD_RELOC_MIPS_CALL16
expr_stmt|;
name|relax_start
argument_list|(
name|offset_expr
operator|.
name|X_add_symbol
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|ADDRESS_LOAD_INSN
argument_list|,
literal|"t,o(b)"
argument_list|,
name|tempreg
argument_list|,
name|lw_reloc_type
argument_list|,
name|mips_gp_register
argument_list|)
expr_stmt|;
if|if
condition|(
name|breg
operator|!=
literal|0
condition|)
block|{
comment|/* We're going to put in an addu instruction using 		     tempreg, so we may as well insert the nop right 		     now.  */
name|load_delay_nop
argument_list|()
expr_stmt|;
block|}
name|relax_switch
argument_list|()
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|ADDRESS_LOAD_INSN
argument_list|,
literal|"t,o(b)"
argument_list|,
name|tempreg
argument_list|,
name|BFD_RELOC_MIPS_GOT16
argument_list|,
name|mips_gp_register
argument_list|)
expr_stmt|;
name|load_delay_nop
argument_list|()
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|ADDRESS_ADDI_INSN
argument_list|,
literal|"t,r,j"
argument_list|,
name|tempreg
argument_list|,
name|tempreg
argument_list|,
name|BFD_RELOC_LO16
argument_list|)
expr_stmt|;
name|relax_end
argument_list|()
expr_stmt|;
comment|/* FIXME: If breg == 0, and the next instruction uses 		 $tempreg, then if this variant case is used an extra 		 nop will be generated.  */
block|}
elseif|else
if|if
condition|(
name|offset_expr
operator|.
name|X_add_number
operator|>=
operator|-
literal|0x8000
operator|&&
name|offset_expr
operator|.
name|X_add_number
operator|<
literal|0x8000
condition|)
block|{
name|load_got_offset
argument_list|(
name|tempreg
argument_list|,
operator|&
name|offset_expr
argument_list|)
expr_stmt|;
name|load_delay_nop
argument_list|()
expr_stmt|;
name|add_got_offset
argument_list|(
name|tempreg
argument_list|,
operator|&
name|offset_expr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|expr1
operator|.
name|X_add_number
operator|=
name|offset_expr
operator|.
name|X_add_number
expr_stmt|;
name|offset_expr
operator|.
name|X_add_number
operator|=
operator|(
operator|(
name|offset_expr
operator|.
name|X_add_number
operator|+
literal|0x8000
operator|)
operator|&
literal|0xffff
operator|)
operator|-
literal|0x8000
expr_stmt|;
name|load_got_offset
argument_list|(
name|tempreg
argument_list|,
operator|&
name|offset_expr
argument_list|)
expr_stmt|;
name|offset_expr
operator|.
name|X_add_number
operator|=
name|expr1
operator|.
name|X_add_number
expr_stmt|;
comment|/* If we are going to add in a base register, and the 		 target register and the base register are the same, 		 then we are using AT as a temporary register.  Since 		 we want to load the constant into AT, we add our 		 current AT (from the global offset table) and the 		 register into the register now, and pretend we were 		 not using a base register.  */
if|if
condition|(
name|breg
operator|==
name|treg
condition|)
block|{
name|load_delay_nop
argument_list|()
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
name|ADDRESS_ADD_INSN
argument_list|,
literal|"d,v,t"
argument_list|,
name|treg
argument_list|,
name|AT
argument_list|,
name|breg
argument_list|)
expr_stmt|;
name|breg
operator|=
literal|0
expr_stmt|;
name|tempreg
operator|=
name|treg
expr_stmt|;
block|}
name|add_got_offset_hilo
argument_list|(
name|tempreg
argument_list|,
operator|&
name|offset_expr
argument_list|,
name|AT
argument_list|)
expr_stmt|;
name|used_at
operator|=
literal|1
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|mips_big_got
operator|&&
name|HAVE_NEWABI
condition|)
block|{
name|int
name|add_breg_early
init|=
literal|0
decl_stmt|;
comment|/* If this is a reference to an external, and there is no 	     constant, or local symbol (*), with or without a 	     constant, we want 	       lw	$tempreg,<sym>($gp)	(BFD_RELOC_MIPS_GOT_DISP) 	     or for lca or if tempreg is PIC_CALL_REG 	       lw	$tempreg,<sym>($gp)	(BFD_RELOC_MIPS_CALL16)  	     If we have a small constant, and this is a reference to 	     an external symbol, we want 	       lw	$tempreg,<sym>($gp)	(BFD_RELOC_MIPS_GOT_DISP) 	       addiu	$tempreg,$tempreg,<constant>  	     If we have a large constant, and this is a reference to 	     an external symbol, we want 	       lw	$tempreg,<sym>($gp)	(BFD_RELOC_MIPS_GOT_DISP) 	       lui	$at,<hiconstant> 	       addiu	$at,$at,<loconstant> 	       addu	$tempreg,$tempreg,$at  	     (*) Other assemblers seem to prefer GOT_PAGE/GOT_OFST for 	     local symbols, even though it introduces an additional 	     instruction.  */
if|if
condition|(
name|offset_expr
operator|.
name|X_add_number
condition|)
block|{
name|expr1
operator|.
name|X_add_number
operator|=
name|offset_expr
operator|.
name|X_add_number
expr_stmt|;
name|offset_expr
operator|.
name|X_add_number
operator|=
literal|0
expr_stmt|;
name|relax_start
argument_list|(
name|offset_expr
operator|.
name|X_add_symbol
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|ADDRESS_LOAD_INSN
argument_list|,
literal|"t,o(b)"
argument_list|,
name|tempreg
argument_list|,
name|BFD_RELOC_MIPS_GOT_DISP
argument_list|,
name|mips_gp_register
argument_list|)
expr_stmt|;
if|if
condition|(
name|expr1
operator|.
name|X_add_number
operator|>=
operator|-
literal|0x8000
operator|&&
name|expr1
operator|.
name|X_add_number
operator|<
literal|0x8000
condition|)
block|{
name|macro_build
argument_list|(
operator|&
name|expr1
argument_list|,
name|ADDRESS_ADDI_INSN
argument_list|,
literal|"t,r,j"
argument_list|,
name|tempreg
argument_list|,
name|tempreg
argument_list|,
name|BFD_RELOC_LO16
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IS_SEXT_32BIT_NUM
argument_list|(
name|expr1
operator|.
name|X_add_number
operator|+
literal|0x8000
argument_list|)
condition|)
block|{
name|int
name|dreg
decl_stmt|;
comment|/* If we are going to add in a base register, and the 		     target register and the base register are the same, 		     then we are using AT as a temporary register.  Since 		     we want to load the constant into AT, we add our 		     current AT (from the global offset table) and the 		     register into the register now, and pretend we were 		     not using a base register.  */
if|if
condition|(
name|breg
operator|!=
name|treg
condition|)
name|dreg
operator|=
name|tempreg
expr_stmt|;
else|else
block|{
name|assert
argument_list|(
name|tempreg
operator|==
name|AT
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
name|ADDRESS_ADD_INSN
argument_list|,
literal|"d,v,t"
argument_list|,
name|treg
argument_list|,
name|AT
argument_list|,
name|breg
argument_list|)
expr_stmt|;
name|dreg
operator|=
name|treg
expr_stmt|;
name|add_breg_early
operator|=
literal|1
expr_stmt|;
block|}
name|load_register
argument_list|(
name|AT
argument_list|,
operator|&
name|expr1
argument_list|,
name|HAVE_64BIT_ADDRESSES
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
name|ADDRESS_ADD_INSN
argument_list|,
literal|"d,v,t"
argument_list|,
name|dreg
argument_list|,
name|dreg
argument_list|,
name|AT
argument_list|)
expr_stmt|;
name|used_at
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"PIC code offset overflow (max 32 signed bits)"
argument_list|)
argument_list|)
expr_stmt|;
name|relax_switch
argument_list|()
expr_stmt|;
name|offset_expr
operator|.
name|X_add_number
operator|=
name|expr1
operator|.
name|X_add_number
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|ADDRESS_LOAD_INSN
argument_list|,
literal|"t,o(b)"
argument_list|,
name|tempreg
argument_list|,
name|BFD_RELOC_MIPS_GOT_DISP
argument_list|,
name|mips_gp_register
argument_list|)
expr_stmt|;
if|if
condition|(
name|add_breg_early
condition|)
block|{
name|macro_build
argument_list|(
name|NULL
argument_list|,
name|ADDRESS_ADD_INSN
argument_list|,
literal|"d,v,t"
argument_list|,
name|treg
argument_list|,
name|tempreg
argument_list|,
name|breg
argument_list|)
expr_stmt|;
name|breg
operator|=
literal|0
expr_stmt|;
name|tempreg
operator|=
name|treg
expr_stmt|;
block|}
name|relax_end
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|breg
operator|==
literal|0
operator|&&
operator|(
name|call
operator|||
name|tempreg
operator|==
name|PIC_CALL_REG
operator|)
condition|)
block|{
name|relax_start
argument_list|(
name|offset_expr
operator|.
name|X_add_symbol
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|ADDRESS_LOAD_INSN
argument_list|,
literal|"t,o(b)"
argument_list|,
name|tempreg
argument_list|,
name|BFD_RELOC_MIPS_CALL16
argument_list|,
name|mips_gp_register
argument_list|)
expr_stmt|;
name|relax_switch
argument_list|()
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|ADDRESS_LOAD_INSN
argument_list|,
literal|"t,o(b)"
argument_list|,
name|tempreg
argument_list|,
name|BFD_RELOC_MIPS_GOT_DISP
argument_list|,
name|mips_gp_register
argument_list|)
expr_stmt|;
name|relax_end
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|ADDRESS_LOAD_INSN
argument_list|,
literal|"t,o(b)"
argument_list|,
name|tempreg
argument_list|,
name|BFD_RELOC_MIPS_GOT_DISP
argument_list|,
name|mips_gp_register
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|mips_big_got
operator|&&
operator|!
name|HAVE_NEWABI
condition|)
block|{
name|int
name|gpdelay
decl_stmt|;
name|int
name|lui_reloc_type
init|=
operator|(
name|int
operator|)
name|BFD_RELOC_MIPS_GOT_HI16
decl_stmt|;
name|int
name|lw_reloc_type
init|=
operator|(
name|int
operator|)
name|BFD_RELOC_MIPS_GOT_LO16
decl_stmt|;
name|int
name|local_reloc_type
init|=
operator|(
name|int
operator|)
name|BFD_RELOC_MIPS_GOT16
decl_stmt|;
comment|/* This is the large GOT case.  If this is a reference to an 	     external symbol, and there is no constant, we want 	       lui	$tempreg,<sym>		(BFD_RELOC_MIPS_GOT_HI16) 	       addu	$tempreg,$tempreg,$gp 	       lw	$tempreg,<sym>($tempreg) (BFD_RELOC_MIPS_GOT_LO16) 	     or for lca or if tempreg is PIC_CALL_REG 	       lui	$tempreg,<sym>		(BFD_RELOC_MIPS_CALL_HI16) 	       addu	$tempreg,$tempreg,$gp 	       lw	$tempreg,<sym>($tempreg) (BFD_RELOC_MIPS_CALL_LO16) 	     For a local symbol, we want 	       lw	$tempreg,<sym>($gp)	(BFD_RELOC_MIPS_GOT16) 	       nop 	       addiu	$tempreg,$tempreg,<sym>	(BFD_RELOC_LO16)  	     If we have a small constant, and this is a reference to 	     an external symbol, we want 	       lui	$tempreg,<sym>		(BFD_RELOC_MIPS_GOT_HI16) 	       addu	$tempreg,$tempreg,$gp 	       lw	$tempreg,<sym>($tempreg) (BFD_RELOC_MIPS_GOT_LO16) 	       nop 	       addiu	$tempreg,$tempreg,<constant> 	     For a local symbol, we want 	       lw	$tempreg,<sym>($gp)	(BFD_RELOC_MIPS_GOT16) 	       nop 	       addiu	$tempreg,$tempreg,<constant> (BFD_RELOC_LO16)  	     If we have a large constant, and this is a reference to 	     an external symbol, we want 	       lui	$tempreg,<sym>		(BFD_RELOC_MIPS_GOT_HI16) 	       addu	$tempreg,$tempreg,$gp 	       lw	$tempreg,<sym>($tempreg) (BFD_RELOC_MIPS_GOT_LO16) 	       lui	$at,<hiconstant> 	       addiu	$at,$at,<loconstant> 	       addu	$tempreg,$tempreg,$at 	     For a local symbol, we want 	       lw	$tempreg,<sym>($gp)	(BFD_RELOC_MIPS_GOT16) 	       lui	$at,<hiconstant> 	       addiu	$at,$at,<loconstant>	(BFD_RELOC_LO16) 	       addu	$tempreg,$tempreg,$at 	  */
name|expr1
operator|.
name|X_add_number
operator|=
name|offset_expr
operator|.
name|X_add_number
expr_stmt|;
name|offset_expr
operator|.
name|X_add_number
operator|=
literal|0
expr_stmt|;
name|relax_start
argument_list|(
name|offset_expr
operator|.
name|X_add_symbol
argument_list|)
expr_stmt|;
name|gpdelay
operator|=
name|reg_needs_delay
argument_list|(
name|mips_gp_register
argument_list|)
expr_stmt|;
if|if
condition|(
name|expr1
operator|.
name|X_add_number
operator|==
literal|0
operator|&&
name|breg
operator|==
literal|0
operator|&&
operator|(
name|call
operator|||
name|tempreg
operator|==
name|PIC_CALL_REG
operator|)
condition|)
block|{
name|lui_reloc_type
operator|=
operator|(
name|int
operator|)
name|BFD_RELOC_MIPS_CALL_HI16
expr_stmt|;
name|lw_reloc_type
operator|=
operator|(
name|int
operator|)
name|BFD_RELOC_MIPS_CALL_LO16
expr_stmt|;
block|}
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
literal|"lui"
argument_list|,
literal|"t,u"
argument_list|,
name|tempreg
argument_list|,
name|lui_reloc_type
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
name|ADDRESS_ADD_INSN
argument_list|,
literal|"d,v,t"
argument_list|,
name|tempreg
argument_list|,
name|tempreg
argument_list|,
name|mips_gp_register
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|ADDRESS_LOAD_INSN
argument_list|,
literal|"t,o(b)"
argument_list|,
name|tempreg
argument_list|,
name|lw_reloc_type
argument_list|,
name|tempreg
argument_list|)
expr_stmt|;
if|if
condition|(
name|expr1
operator|.
name|X_add_number
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|breg
operator|!=
literal|0
condition|)
block|{
comment|/* We're going to put in an addu instruction using 		     tempreg, so we may as well insert the nop right 		     now.  */
name|load_delay_nop
argument_list|()
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|expr1
operator|.
name|X_add_number
operator|>=
operator|-
literal|0x8000
operator|&&
name|expr1
operator|.
name|X_add_number
operator|<
literal|0x8000
condition|)
block|{
name|load_delay_nop
argument_list|()
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|expr1
argument_list|,
name|ADDRESS_ADDI_INSN
argument_list|,
literal|"t,r,j"
argument_list|,
name|tempreg
argument_list|,
name|tempreg
argument_list|,
name|BFD_RELOC_LO16
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|dreg
decl_stmt|;
comment|/* If we are going to add in a base register, and the 		 target register and the base register are the same, 		 then we are using AT as a temporary register.  Since 		 we want to load the constant into AT, we add our 		 current AT (from the global offset table) and the 		 register into the register now, and pretend we were 		 not using a base register.  */
if|if
condition|(
name|breg
operator|!=
name|treg
condition|)
name|dreg
operator|=
name|tempreg
expr_stmt|;
else|else
block|{
name|assert
argument_list|(
name|tempreg
operator|==
name|AT
argument_list|)
expr_stmt|;
name|load_delay_nop
argument_list|()
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
name|ADDRESS_ADD_INSN
argument_list|,
literal|"d,v,t"
argument_list|,
name|treg
argument_list|,
name|AT
argument_list|,
name|breg
argument_list|)
expr_stmt|;
name|dreg
operator|=
name|treg
expr_stmt|;
block|}
name|load_register
argument_list|(
name|AT
argument_list|,
operator|&
name|expr1
argument_list|,
name|HAVE_64BIT_ADDRESSES
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
name|ADDRESS_ADD_INSN
argument_list|,
literal|"d,v,t"
argument_list|,
name|dreg
argument_list|,
name|dreg
argument_list|,
name|AT
argument_list|)
expr_stmt|;
name|used_at
operator|=
literal|1
expr_stmt|;
block|}
name|offset_expr
operator|.
name|X_add_number
operator|=
operator|(
operator|(
name|expr1
operator|.
name|X_add_number
operator|+
literal|0x8000
operator|)
operator|&
literal|0xffff
operator|)
operator|-
literal|0x8000
expr_stmt|;
name|relax_switch
argument_list|()
expr_stmt|;
if|if
condition|(
name|gpdelay
condition|)
block|{
comment|/* This is needed because this instruction uses $gp, but 		 the first instruction on the main stream does not.  */
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"nop"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|ADDRESS_LOAD_INSN
argument_list|,
literal|"t,o(b)"
argument_list|,
name|tempreg
argument_list|,
name|local_reloc_type
argument_list|,
name|mips_gp_register
argument_list|)
expr_stmt|;
if|if
condition|(
name|expr1
operator|.
name|X_add_number
operator|>=
operator|-
literal|0x8000
operator|&&
name|expr1
operator|.
name|X_add_number
operator|<
literal|0x8000
condition|)
block|{
name|load_delay_nop
argument_list|()
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|ADDRESS_ADDI_INSN
argument_list|,
literal|"t,r,j"
argument_list|,
name|tempreg
argument_list|,
name|tempreg
argument_list|,
name|BFD_RELOC_LO16
argument_list|)
expr_stmt|;
comment|/* FIXME: If add_number is 0, and there was no base 		 register, the external symbol case ended with a load, 		 so if the symbol turns out to not be external, and 		 the next instruction uses tempreg, an unnecessary nop 		 will be inserted.  */
block|}
else|else
block|{
if|if
condition|(
name|breg
operator|==
name|treg
condition|)
block|{
comment|/* We must add in the base register now, as in the 		     external symbol case.  */
name|assert
argument_list|(
name|tempreg
operator|==
name|AT
argument_list|)
expr_stmt|;
name|load_delay_nop
argument_list|()
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
name|ADDRESS_ADD_INSN
argument_list|,
literal|"d,v,t"
argument_list|,
name|treg
argument_list|,
name|AT
argument_list|,
name|breg
argument_list|)
expr_stmt|;
name|tempreg
operator|=
name|treg
expr_stmt|;
comment|/* We set breg to 0 because we have arranged to add 		     it in in both cases.  */
name|breg
operator|=
literal|0
expr_stmt|;
block|}
name|macro_build_lui
argument_list|(
operator|&
name|expr1
argument_list|,
name|AT
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|ADDRESS_ADDI_INSN
argument_list|,
literal|"t,r,j"
argument_list|,
name|AT
argument_list|,
name|AT
argument_list|,
name|BFD_RELOC_LO16
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
name|ADDRESS_ADD_INSN
argument_list|,
literal|"d,v,t"
argument_list|,
name|tempreg
argument_list|,
name|tempreg
argument_list|,
name|AT
argument_list|)
expr_stmt|;
name|used_at
operator|=
literal|1
expr_stmt|;
block|}
name|relax_end
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mips_big_got
operator|&&
name|HAVE_NEWABI
condition|)
block|{
name|int
name|lui_reloc_type
init|=
operator|(
name|int
operator|)
name|BFD_RELOC_MIPS_GOT_HI16
decl_stmt|;
name|int
name|lw_reloc_type
init|=
operator|(
name|int
operator|)
name|BFD_RELOC_MIPS_GOT_LO16
decl_stmt|;
name|int
name|add_breg_early
init|=
literal|0
decl_stmt|;
comment|/* This is the large GOT case.  If this is a reference to an 	     external symbol, and there is no constant, we want 	       lui	$tempreg,<sym>		(BFD_RELOC_MIPS_GOT_HI16) 	       add	$tempreg,$tempreg,$gp 	       lw	$tempreg,<sym>($tempreg) (BFD_RELOC_MIPS_GOT_LO16) 	     or for lca or if tempreg is PIC_CALL_REG 	       lui	$tempreg,<sym>		(BFD_RELOC_MIPS_CALL_HI16) 	       add	$tempreg,$tempreg,$gp 	       lw	$tempreg,<sym>($tempreg) (BFD_RELOC_MIPS_CALL_LO16)  	     If we have a small constant, and this is a reference to 	     an external symbol, we want 	       lui	$tempreg,<sym>		(BFD_RELOC_MIPS_GOT_HI16) 	       add	$tempreg,$tempreg,$gp 	       lw	$tempreg,<sym>($tempreg) (BFD_RELOC_MIPS_GOT_LO16) 	       addi	$tempreg,$tempreg,<constant>  	     If we have a large constant, and this is a reference to 	     an external symbol, we want 	       lui	$tempreg,<sym>		(BFD_RELOC_MIPS_GOT_HI16) 	       addu	$tempreg,$tempreg,$gp 	       lw	$tempreg,<sym>($tempreg) (BFD_RELOC_MIPS_GOT_LO16) 	       lui	$at,<hiconstant> 	       addi	$at,$at,<loconstant> 	       add	$tempreg,$tempreg,$at  	     If we have NewABI, and we know it's a local symbol, we want 	       lw	$reg,<sym>($gp)		(BFD_RELOC_MIPS_GOT_PAGE) 	       addiu	$reg,$reg,<sym>		(BFD_RELOC_MIPS_GOT_OFST) 	     otherwise we have to resort to GOT_HI16/GOT_LO16.  */
name|relax_start
argument_list|(
name|offset_expr
operator|.
name|X_add_symbol
argument_list|)
expr_stmt|;
name|expr1
operator|.
name|X_add_number
operator|=
name|offset_expr
operator|.
name|X_add_number
expr_stmt|;
name|offset_expr
operator|.
name|X_add_number
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|expr1
operator|.
name|X_add_number
operator|==
literal|0
operator|&&
name|breg
operator|==
literal|0
operator|&&
operator|(
name|call
operator|||
name|tempreg
operator|==
name|PIC_CALL_REG
operator|)
condition|)
block|{
name|lui_reloc_type
operator|=
operator|(
name|int
operator|)
name|BFD_RELOC_MIPS_CALL_HI16
expr_stmt|;
name|lw_reloc_type
operator|=
operator|(
name|int
operator|)
name|BFD_RELOC_MIPS_CALL_LO16
expr_stmt|;
block|}
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
literal|"lui"
argument_list|,
literal|"t,u"
argument_list|,
name|tempreg
argument_list|,
name|lui_reloc_type
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
name|ADDRESS_ADD_INSN
argument_list|,
literal|"d,v,t"
argument_list|,
name|tempreg
argument_list|,
name|tempreg
argument_list|,
name|mips_gp_register
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|ADDRESS_LOAD_INSN
argument_list|,
literal|"t,o(b)"
argument_list|,
name|tempreg
argument_list|,
name|lw_reloc_type
argument_list|,
name|tempreg
argument_list|)
expr_stmt|;
if|if
condition|(
name|expr1
operator|.
name|X_add_number
operator|==
literal|0
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|expr1
operator|.
name|X_add_number
operator|>=
operator|-
literal|0x8000
operator|&&
name|expr1
operator|.
name|X_add_number
operator|<
literal|0x8000
condition|)
block|{
name|macro_build
argument_list|(
operator|&
name|expr1
argument_list|,
name|ADDRESS_ADDI_INSN
argument_list|,
literal|"t,r,j"
argument_list|,
name|tempreg
argument_list|,
name|tempreg
argument_list|,
name|BFD_RELOC_LO16
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IS_SEXT_32BIT_NUM
argument_list|(
name|expr1
operator|.
name|X_add_number
operator|+
literal|0x8000
argument_list|)
condition|)
block|{
name|int
name|dreg
decl_stmt|;
comment|/* If we are going to add in a base register, and the 		 target register and the base register are the same, 		 then we are using AT as a temporary register.  Since 		 we want to load the constant into AT, we add our 		 current AT (from the global offset table) and the 		 register into the register now, and pretend we were 		 not using a base register.  */
if|if
condition|(
name|breg
operator|!=
name|treg
condition|)
name|dreg
operator|=
name|tempreg
expr_stmt|;
else|else
block|{
name|assert
argument_list|(
name|tempreg
operator|==
name|AT
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
name|ADDRESS_ADD_INSN
argument_list|,
literal|"d,v,t"
argument_list|,
name|treg
argument_list|,
name|AT
argument_list|,
name|breg
argument_list|)
expr_stmt|;
name|dreg
operator|=
name|treg
expr_stmt|;
name|add_breg_early
operator|=
literal|1
expr_stmt|;
block|}
name|load_register
argument_list|(
name|AT
argument_list|,
operator|&
name|expr1
argument_list|,
name|HAVE_64BIT_ADDRESSES
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
name|ADDRESS_ADD_INSN
argument_list|,
literal|"d,v,t"
argument_list|,
name|dreg
argument_list|,
name|dreg
argument_list|,
name|AT
argument_list|)
expr_stmt|;
name|used_at
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"PIC code offset overflow (max 32 signed bits)"
argument_list|)
argument_list|)
expr_stmt|;
name|relax_switch
argument_list|()
expr_stmt|;
name|offset_expr
operator|.
name|X_add_number
operator|=
name|expr1
operator|.
name|X_add_number
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|ADDRESS_LOAD_INSN
argument_list|,
literal|"t,o(b)"
argument_list|,
name|tempreg
argument_list|,
name|BFD_RELOC_MIPS_GOT_PAGE
argument_list|,
name|mips_gp_register
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|ADDRESS_ADDI_INSN
argument_list|,
literal|"t,r,j"
argument_list|,
name|tempreg
argument_list|,
name|tempreg
argument_list|,
name|BFD_RELOC_MIPS_GOT_OFST
argument_list|)
expr_stmt|;
if|if
condition|(
name|add_breg_early
condition|)
block|{
name|macro_build
argument_list|(
name|NULL
argument_list|,
name|ADDRESS_ADD_INSN
argument_list|,
literal|"d,v,t"
argument_list|,
name|treg
argument_list|,
name|tempreg
argument_list|,
name|breg
argument_list|)
expr_stmt|;
name|breg
operator|=
literal|0
expr_stmt|;
name|tempreg
operator|=
name|treg
expr_stmt|;
block|}
name|relax_end
argument_list|()
expr_stmt|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|breg
operator|!=
literal|0
condition|)
name|macro_build
argument_list|(
name|NULL
argument_list|,
name|ADDRESS_ADD_INSN
argument_list|,
literal|"d,v,t"
argument_list|,
name|treg
argument_list|,
name|tempreg
argument_list|,
name|breg
argument_list|)
expr_stmt|;
break|break;
case|case
name|M_J_A
case|:
comment|/* The j instruction may not be used in PIC code, since it 	 requires an absolute address.  We convert it to a b 	 instruction.  */
if|if
condition|(
name|mips_pic
operator|==
name|NO_PIC
condition|)
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
literal|"j"
argument_list|,
literal|"a"
argument_list|)
expr_stmt|;
else|else
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
literal|"b"
argument_list|,
literal|"p"
argument_list|)
expr_stmt|;
break|break;
comment|/* The jal instructions must be handled as macros because when 	 generating PIC code they expand to multi-instruction 	 sequences.  Normally they are simple instructions.  */
case|case
name|M_JAL_1
case|:
name|dreg
operator|=
name|RA
expr_stmt|;
comment|/* Fall through.  */
case|case
name|M_JAL_2
case|:
if|if
condition|(
name|mips_pic
operator|==
name|NO_PIC
condition|)
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"jalr"
argument_list|,
literal|"d,s"
argument_list|,
name|dreg
argument_list|,
name|sreg
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|sreg
operator|!=
name|PIC_CALL_REG
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"MIPS PIC call to register other than $25"
argument_list|)
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"jalr"
argument_list|,
literal|"d,s"
argument_list|,
name|dreg
argument_list|,
name|sreg
argument_list|)
expr_stmt|;
if|if
condition|(
name|mips_pic
operator|==
name|SVR4_PIC
operator|&&
operator|!
name|HAVE_NEWABI
condition|)
block|{
if|if
condition|(
name|mips_cprestore_offset
operator|<
literal|0
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"No .cprestore pseudo-op used in PIC code"
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|!
name|mips_frame_reg_valid
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"No .frame pseudo-op used in PIC code"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Quiet this warning.  */
name|mips_frame_reg_valid
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|mips_cprestore_valid
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"No .cprestore pseudo-op used in PIC code"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Quiet this warning.  */
name|mips_cprestore_valid
operator|=
literal|1
expr_stmt|;
block|}
name|expr1
operator|.
name|X_add_number
operator|=
name|mips_cprestore_offset
expr_stmt|;
name|macro_build_ldst_constoffset
argument_list|(
operator|&
name|expr1
argument_list|,
name|ADDRESS_LOAD_INSN
argument_list|,
name|mips_gp_register
argument_list|,
name|mips_frame_reg
argument_list|,
name|HAVE_64BIT_ADDRESSES
argument_list|)
expr_stmt|;
block|}
block|}
block|}
break|break;
case|case
name|M_JAL_A
case|:
if|if
condition|(
name|mips_pic
operator|==
name|NO_PIC
condition|)
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
literal|"jal"
argument_list|,
literal|"a"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|mips_pic
operator|==
name|SVR4_PIC
condition|)
block|{
comment|/* If this is a reference to an external symbol, and we are 	     using a small GOT, we want 	       lw	$25,<sym>($gp)		(BFD_RELOC_MIPS_CALL16) 	       nop 	       jalr	$ra,$25 	       nop 	       lw	$gp,cprestore($sp) 	     The cprestore value is set using the .cprestore 	     pseudo-op.  If we are using a big GOT, we want 	       lui	$25,<sym>		(BFD_RELOC_MIPS_CALL_HI16) 	       addu	$25,$25,$gp 	       lw	$25,<sym>($25)		(BFD_RELOC_MIPS_CALL_LO16) 	       nop 	       jalr	$ra,$25 	       nop 	       lw	$gp,cprestore($sp) 	     If the symbol is not external, we want 	       lw	$25,<sym>($gp)		(BFD_RELOC_MIPS_GOT16) 	       nop 	       addiu	$25,$25,<sym>		(BFD_RELOC_LO16) 	       jalr	$ra,$25 	       nop 	       lw $gp,cprestore($sp)  	     For NewABI, we use the same CALL16 or CALL_HI16/CALL_LO16 	     sequences above, minus nops, unless the symbol is local, 	     which enables us to use GOT_PAGE/GOT_OFST (big got) or 	     GOT_DISP.  */
if|if
condition|(
name|HAVE_NEWABI
condition|)
block|{
if|if
condition|(
operator|!
name|mips_big_got
condition|)
block|{
name|relax_start
argument_list|(
name|offset_expr
operator|.
name|X_add_symbol
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|ADDRESS_LOAD_INSN
argument_list|,
literal|"t,o(b)"
argument_list|,
name|PIC_CALL_REG
argument_list|,
name|BFD_RELOC_MIPS_CALL16
argument_list|,
name|mips_gp_register
argument_list|)
expr_stmt|;
name|relax_switch
argument_list|()
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|ADDRESS_LOAD_INSN
argument_list|,
literal|"t,o(b)"
argument_list|,
name|PIC_CALL_REG
argument_list|,
name|BFD_RELOC_MIPS_GOT_DISP
argument_list|,
name|mips_gp_register
argument_list|)
expr_stmt|;
name|relax_end
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|relax_start
argument_list|(
name|offset_expr
operator|.
name|X_add_symbol
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
literal|"lui"
argument_list|,
literal|"t,u"
argument_list|,
name|PIC_CALL_REG
argument_list|,
name|BFD_RELOC_MIPS_CALL_HI16
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
name|ADDRESS_ADD_INSN
argument_list|,
literal|"d,v,t"
argument_list|,
name|PIC_CALL_REG
argument_list|,
name|PIC_CALL_REG
argument_list|,
name|mips_gp_register
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|ADDRESS_LOAD_INSN
argument_list|,
literal|"t,o(b)"
argument_list|,
name|PIC_CALL_REG
argument_list|,
name|BFD_RELOC_MIPS_CALL_LO16
argument_list|,
name|PIC_CALL_REG
argument_list|)
expr_stmt|;
name|relax_switch
argument_list|()
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|ADDRESS_LOAD_INSN
argument_list|,
literal|"t,o(b)"
argument_list|,
name|PIC_CALL_REG
argument_list|,
name|BFD_RELOC_MIPS_GOT_PAGE
argument_list|,
name|mips_gp_register
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|ADDRESS_ADDI_INSN
argument_list|,
literal|"t,r,j"
argument_list|,
name|PIC_CALL_REG
argument_list|,
name|PIC_CALL_REG
argument_list|,
name|BFD_RELOC_MIPS_GOT_OFST
argument_list|)
expr_stmt|;
name|relax_end
argument_list|()
expr_stmt|;
block|}
name|macro_build_jalr
argument_list|(
operator|&
name|offset_expr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|relax_start
argument_list|(
name|offset_expr
operator|.
name|X_add_symbol
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mips_big_got
condition|)
block|{
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|ADDRESS_LOAD_INSN
argument_list|,
literal|"t,o(b)"
argument_list|,
name|PIC_CALL_REG
argument_list|,
name|BFD_RELOC_MIPS_CALL16
argument_list|,
name|mips_gp_register
argument_list|)
expr_stmt|;
name|load_delay_nop
argument_list|()
expr_stmt|;
name|relax_switch
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|int
name|gpdelay
decl_stmt|;
name|gpdelay
operator|=
name|reg_needs_delay
argument_list|(
name|mips_gp_register
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
literal|"lui"
argument_list|,
literal|"t,u"
argument_list|,
name|PIC_CALL_REG
argument_list|,
name|BFD_RELOC_MIPS_CALL_HI16
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
name|ADDRESS_ADD_INSN
argument_list|,
literal|"d,v,t"
argument_list|,
name|PIC_CALL_REG
argument_list|,
name|PIC_CALL_REG
argument_list|,
name|mips_gp_register
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|ADDRESS_LOAD_INSN
argument_list|,
literal|"t,o(b)"
argument_list|,
name|PIC_CALL_REG
argument_list|,
name|BFD_RELOC_MIPS_CALL_LO16
argument_list|,
name|PIC_CALL_REG
argument_list|)
expr_stmt|;
name|load_delay_nop
argument_list|()
expr_stmt|;
name|relax_switch
argument_list|()
expr_stmt|;
if|if
condition|(
name|gpdelay
condition|)
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"nop"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|ADDRESS_LOAD_INSN
argument_list|,
literal|"t,o(b)"
argument_list|,
name|PIC_CALL_REG
argument_list|,
name|BFD_RELOC_MIPS_GOT16
argument_list|,
name|mips_gp_register
argument_list|)
expr_stmt|;
name|load_delay_nop
argument_list|()
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|ADDRESS_ADDI_INSN
argument_list|,
literal|"t,r,j"
argument_list|,
name|PIC_CALL_REG
argument_list|,
name|PIC_CALL_REG
argument_list|,
name|BFD_RELOC_LO16
argument_list|)
expr_stmt|;
name|relax_end
argument_list|()
expr_stmt|;
name|macro_build_jalr
argument_list|(
operator|&
name|offset_expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|mips_cprestore_offset
operator|<
literal|0
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"No .cprestore pseudo-op used in PIC code"
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|!
name|mips_frame_reg_valid
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"No .frame pseudo-op used in PIC code"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Quiet this warning.  */
name|mips_frame_reg_valid
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|mips_cprestore_valid
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"No .cprestore pseudo-op used in PIC code"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Quiet this warning.  */
name|mips_cprestore_valid
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|mips_opts
operator|.
name|noreorder
condition|)
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"nop"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|expr1
operator|.
name|X_add_number
operator|=
name|mips_cprestore_offset
expr_stmt|;
name|macro_build_ldst_constoffset
argument_list|(
operator|&
name|expr1
argument_list|,
name|ADDRESS_LOAD_INSN
argument_list|,
name|mips_gp_register
argument_list|,
name|mips_frame_reg
argument_list|,
name|HAVE_64BIT_ADDRESSES
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|mips_pic
operator|==
name|VXWORKS_PIC
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Non-PIC jump used in PIC library"
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
break|break;
case|case
name|M_LB_AB
case|:
name|s
operator|=
literal|"lb"
expr_stmt|;
goto|goto
name|ld
goto|;
case|case
name|M_LBU_AB
case|:
name|s
operator|=
literal|"lbu"
expr_stmt|;
goto|goto
name|ld
goto|;
case|case
name|M_LH_AB
case|:
name|s
operator|=
literal|"lh"
expr_stmt|;
goto|goto
name|ld
goto|;
case|case
name|M_LHU_AB
case|:
name|s
operator|=
literal|"lhu"
expr_stmt|;
goto|goto
name|ld
goto|;
case|case
name|M_LW_AB
case|:
name|s
operator|=
literal|"lw"
expr_stmt|;
goto|goto
name|ld
goto|;
case|case
name|M_LWC0_AB
case|:
name|s
operator|=
literal|"lwc0"
expr_stmt|;
comment|/* Itbl support may require additional care here.  */
name|coproc
operator|=
literal|1
expr_stmt|;
goto|goto
name|ld
goto|;
case|case
name|M_LWC1_AB
case|:
name|s
operator|=
literal|"lwc1"
expr_stmt|;
comment|/* Itbl support may require additional care here.  */
name|coproc
operator|=
literal|1
expr_stmt|;
goto|goto
name|ld
goto|;
case|case
name|M_LWC2_AB
case|:
name|s
operator|=
literal|"lwc2"
expr_stmt|;
comment|/* Itbl support may require additional care here.  */
name|coproc
operator|=
literal|1
expr_stmt|;
goto|goto
name|ld
goto|;
case|case
name|M_LWC3_AB
case|:
name|s
operator|=
literal|"lwc3"
expr_stmt|;
comment|/* Itbl support may require additional care here.  */
name|coproc
operator|=
literal|1
expr_stmt|;
goto|goto
name|ld
goto|;
case|case
name|M_LWL_AB
case|:
name|s
operator|=
literal|"lwl"
expr_stmt|;
name|lr
operator|=
literal|1
expr_stmt|;
goto|goto
name|ld
goto|;
case|case
name|M_LWR_AB
case|:
name|s
operator|=
literal|"lwr"
expr_stmt|;
name|lr
operator|=
literal|1
expr_stmt|;
goto|goto
name|ld
goto|;
case|case
name|M_LDC1_AB
case|:
if|if
condition|(
name|mips_opts
operator|.
name|arch
operator|==
name|CPU_R4650
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"opcode not supported on this processor"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|s
operator|=
literal|"ldc1"
expr_stmt|;
comment|/* Itbl support may require additional care here.  */
name|coproc
operator|=
literal|1
expr_stmt|;
goto|goto
name|ld
goto|;
case|case
name|M_LDC2_AB
case|:
name|s
operator|=
literal|"ldc2"
expr_stmt|;
comment|/* Itbl support may require additional care here.  */
name|coproc
operator|=
literal|1
expr_stmt|;
goto|goto
name|ld
goto|;
case|case
name|M_LDC3_AB
case|:
name|s
operator|=
literal|"ldc3"
expr_stmt|;
comment|/* Itbl support may require additional care here.  */
name|coproc
operator|=
literal|1
expr_stmt|;
goto|goto
name|ld
goto|;
case|case
name|M_LDL_AB
case|:
name|s
operator|=
literal|"ldl"
expr_stmt|;
name|lr
operator|=
literal|1
expr_stmt|;
goto|goto
name|ld
goto|;
case|case
name|M_LDR_AB
case|:
name|s
operator|=
literal|"ldr"
expr_stmt|;
name|lr
operator|=
literal|1
expr_stmt|;
goto|goto
name|ld
goto|;
case|case
name|M_LL_AB
case|:
name|s
operator|=
literal|"ll"
expr_stmt|;
goto|goto
name|ld
goto|;
case|case
name|M_LLD_AB
case|:
name|s
operator|=
literal|"lld"
expr_stmt|;
goto|goto
name|ld
goto|;
case|case
name|M_LWU_AB
case|:
name|s
operator|=
literal|"lwu"
expr_stmt|;
name|ld
label|:
if|if
condition|(
name|mips_opts
operator|.
name|arch
operator|==
name|CPU_OCTEON
operator|&&
name|octeon_error_on_unsupported
operator|&&
operator|(
name|mask
operator|==
name|M_LDC1_AB
operator|||
name|mask
operator|==
name|M_LDC2_AB
operator|||
name|mask
operator|==
name|M_LDC3_AB
operator|||
name|mask
operator|==
name|M_L_DOB
operator|||
name|mask
operator|==
name|M_L_DAB
operator|||
name|mask
operator|==
name|M_LI_D
operator|||
name|mask
operator|==
name|M_LI_DD
operator|||
name|mask
operator|==
name|M_LI_S
operator|||
name|mask
operator|==
name|M_LI_SS
operator|)
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"opcode not implemented in Octeon `%s'"
argument_list|)
argument_list|,
name|ip
operator|->
name|insn_mo
operator|->
name|name
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|breg
operator|==
name|treg
operator|||
name|coproc
operator|||
name|lr
condition|)
block|{
name|tempreg
operator|=
name|AT
expr_stmt|;
name|used_at
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|tempreg
operator|=
name|treg
expr_stmt|;
block|}
goto|goto
name|ld_st
goto|;
case|case
name|M_SB_AB
case|:
name|s
operator|=
literal|"sb"
expr_stmt|;
goto|goto
name|st
goto|;
case|case
name|M_SH_AB
case|:
name|s
operator|=
literal|"sh"
expr_stmt|;
goto|goto
name|st
goto|;
case|case
name|M_SW_AB
case|:
name|s
operator|=
literal|"sw"
expr_stmt|;
goto|goto
name|st
goto|;
case|case
name|M_SWC0_AB
case|:
name|s
operator|=
literal|"swc0"
expr_stmt|;
comment|/* Itbl support may require additional care here.  */
name|coproc
operator|=
literal|1
expr_stmt|;
goto|goto
name|st
goto|;
case|case
name|M_SWC1_AB
case|:
name|s
operator|=
literal|"swc1"
expr_stmt|;
comment|/* Itbl support may require additional care here.  */
name|coproc
operator|=
literal|1
expr_stmt|;
goto|goto
name|st
goto|;
case|case
name|M_SWC2_AB
case|:
name|s
operator|=
literal|"swc2"
expr_stmt|;
comment|/* Itbl support may require additional care here.  */
name|coproc
operator|=
literal|1
expr_stmt|;
goto|goto
name|st
goto|;
case|case
name|M_SWC3_AB
case|:
name|s
operator|=
literal|"swc3"
expr_stmt|;
comment|/* Itbl support may require additional care here.  */
name|coproc
operator|=
literal|1
expr_stmt|;
goto|goto
name|st
goto|;
case|case
name|M_SWL_AB
case|:
name|s
operator|=
literal|"swl"
expr_stmt|;
goto|goto
name|st
goto|;
case|case
name|M_SWR_AB
case|:
name|s
operator|=
literal|"swr"
expr_stmt|;
goto|goto
name|st
goto|;
case|case
name|M_SC_AB
case|:
name|s
operator|=
literal|"sc"
expr_stmt|;
goto|goto
name|st
goto|;
case|case
name|M_SCD_AB
case|:
name|s
operator|=
literal|"scd"
expr_stmt|;
goto|goto
name|st
goto|;
case|case
name|M_CACHE_AB
case|:
name|s
operator|=
literal|"cache"
expr_stmt|;
goto|goto
name|st
goto|;
case|case
name|M_SDC1_AB
case|:
if|if
condition|(
name|mips_opts
operator|.
name|arch
operator|==
name|CPU_R4650
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"opcode not supported on this processor"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|s
operator|=
literal|"sdc1"
expr_stmt|;
name|coproc
operator|=
literal|1
expr_stmt|;
comment|/* Itbl support may require additional care here.  */
goto|goto
name|st
goto|;
case|case
name|M_SDC2_AB
case|:
name|s
operator|=
literal|"sdc2"
expr_stmt|;
comment|/* Itbl support may require additional care here.  */
name|coproc
operator|=
literal|1
expr_stmt|;
goto|goto
name|st
goto|;
case|case
name|M_SDC3_AB
case|:
name|s
operator|=
literal|"sdc3"
expr_stmt|;
comment|/* Itbl support may require additional care here.  */
name|coproc
operator|=
literal|1
expr_stmt|;
goto|goto
name|st
goto|;
case|case
name|M_SDL_AB
case|:
name|s
operator|=
literal|"sdl"
expr_stmt|;
goto|goto
name|st
goto|;
case|case
name|M_SDR_AB
case|:
name|s
operator|=
literal|"sdr"
expr_stmt|;
name|st
label|:
if|if
condition|(
name|mips_opts
operator|.
name|arch
operator|==
name|CPU_OCTEON
operator|&&
name|octeon_error_on_unsupported
operator|&&
operator|(
name|mask
operator|==
name|M_SWC0_AB
operator|||
name|mask
operator|==
name|M_SWC1_AB
operator|||
name|mask
operator|==
name|M_SWC2_AB
operator|||
name|mask
operator|==
name|M_SDC1_AB
operator|||
name|mask
operator|==
name|M_SDC2_AB
operator|||
name|mask
operator|==
name|M_SDC3_AB
operator|||
name|mask
operator|==
name|M_S_DAB
operator|||
name|mask
operator|==
name|M_S_DOB
operator|)
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"opcode not implemented in Octeon `%s'"
argument_list|)
argument_list|,
name|ip
operator|->
name|insn_mo
operator|->
name|name
argument_list|)
expr_stmt|;
return|return;
block|}
name|tempreg
operator|=
name|AT
expr_stmt|;
name|used_at
operator|=
literal|1
expr_stmt|;
name|ld_st
label|:
comment|/* Itbl support may require additional care here.  */
if|if
condition|(
name|mask
operator|==
name|M_LWC1_AB
operator|||
name|mask
operator|==
name|M_SWC1_AB
operator|||
name|mask
operator|==
name|M_LDC1_AB
operator|||
name|mask
operator|==
name|M_SDC1_AB
operator|||
name|mask
operator|==
name|M_L_DAB
operator|||
name|mask
operator|==
name|M_S_DAB
condition|)
name|fmt
operator|=
literal|"T,o(b)"
expr_stmt|;
elseif|else
if|if
condition|(
name|mask
operator|==
name|M_CACHE_AB
condition|)
name|fmt
operator|=
literal|"k,o(b)"
expr_stmt|;
elseif|else
if|if
condition|(
name|coproc
condition|)
name|fmt
operator|=
literal|"E,o(b)"
expr_stmt|;
else|else
name|fmt
operator|=
literal|"t,o(b)"
expr_stmt|;
if|if
condition|(
name|offset_expr
operator|.
name|X_op
operator|!=
name|O_constant
operator|&&
name|offset_expr
operator|.
name|X_op
operator|!=
name|O_symbol
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"expression too complex"
argument_list|)
argument_list|)
expr_stmt|;
name|offset_expr
operator|.
name|X_op
operator|=
name|O_constant
expr_stmt|;
block|}
if|if
condition|(
name|HAVE_32BIT_ADDRESSES
operator|&&
operator|!
name|IS_SEXT_32BIT_NUM
argument_list|(
name|offset_expr
operator|.
name|X_add_number
argument_list|)
condition|)
block|{
name|char
name|value
index|[
literal|32
index|]
decl_stmt|;
name|sprintf_vma
argument_list|(
name|value
argument_list|,
name|offset_expr
operator|.
name|X_add_number
argument_list|)
expr_stmt|;
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Number (0x%s) larger than 32 bits"
argument_list|)
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
comment|/* A constant expression in PIC code can be handled just as it 	 is in non PIC code.  */
if|if
condition|(
name|offset_expr
operator|.
name|X_op
operator|==
name|O_constant
condition|)
block|{
name|expr1
operator|.
name|X_add_number
operator|=
operator|(
operator|(
name|offset_expr
operator|.
name|X_add_number
operator|+
literal|0x8000
operator|)
operator|&
operator|~
operator|(
name|bfd_vma
operator|)
literal|0xffff
operator|)
expr_stmt|;
name|normalize_address_expr
argument_list|(
operator|&
name|expr1
argument_list|)
expr_stmt|;
name|load_register
argument_list|(
name|tempreg
argument_list|,
operator|&
name|expr1
argument_list|,
name|HAVE_64BIT_ADDRESSES
argument_list|)
expr_stmt|;
if|if
condition|(
name|breg
operator|!=
literal|0
condition|)
name|macro_build
argument_list|(
name|NULL
argument_list|,
name|ADDRESS_ADD_INSN
argument_list|,
literal|"d,v,t"
argument_list|,
name|tempreg
argument_list|,
name|tempreg
argument_list|,
name|breg
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|s
argument_list|,
name|fmt
argument_list|,
name|treg
argument_list|,
name|BFD_RELOC_LO16
argument_list|,
name|tempreg
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mips_pic
operator|==
name|NO_PIC
condition|)
block|{
comment|/* If this is a reference to a GP relative symbol, and there 	     is no base register, we want<op>	$treg,<sym>($gp)	(BFD_RELOC_GPREL16) 	     Otherwise, if there is no base register, we want 	       lui	$tempreg,<sym>		(BFD_RELOC_HI16_S)<op>	$treg,<sym>($tempreg)	(BFD_RELOC_LO16) 	     If we have a constant, we need two instructions anyhow, 	     so we always use the latter form.  	     If we have a base register, and this is a reference to a 	     GP relative symbol, we want 	       addu	$tempreg,$breg,$gp<op>	$treg,<sym>($tempreg)	(BFD_RELOC_GPREL16) 	     Otherwise we want 	       lui	$tempreg,<sym>		(BFD_RELOC_HI16_S) 	       addu	$tempreg,$tempreg,$breg<op>	$treg,<sym>($tempreg)	(BFD_RELOC_LO16) 	     With a constant we always use the latter case.  	     With 64bit address space and no base register and $at usable, 	     we want 	       lui	$tempreg,<sym>		(BFD_RELOC_MIPS_HIGHEST) 	       lui	$at,<sym>		(BFD_RELOC_HI16_S) 	       daddiu	$tempreg,<sym>		(BFD_RELOC_MIPS_HIGHER) 	       dsll32	$tempreg,0 	       daddu	$tempreg,$at<op>	$treg,<sym>($tempreg)	(BFD_RELOC_LO16) 	     If we have a base register, we want 	       lui	$tempreg,<sym>		(BFD_RELOC_MIPS_HIGHEST) 	       lui	$at,<sym>		(BFD_RELOC_HI16_S) 	       daddiu	$tempreg,<sym>		(BFD_RELOC_MIPS_HIGHER) 	       daddu	$at,$breg 	       dsll32	$tempreg,0 	       daddu	$tempreg,$at<op>	$treg,<sym>($tempreg)	(BFD_RELOC_LO16)  	     Without $at we can't generate the optimal path for superscalar 	     processors here since this would require two temporary registers. 	       lui	$tempreg,<sym>		(BFD_RELOC_MIPS_HIGHEST) 	       daddiu	$tempreg,<sym>		(BFD_RELOC_MIPS_HIGHER) 	       dsll	$tempreg,16 	       daddiu	$tempreg,<sym>		(BFD_RELOC_HI16_S) 	       dsll	$tempreg,16<op>	$treg,<sym>($tempreg)	(BFD_RELOC_LO16) 	     If we have a base register, we want 	       lui	$tempreg,<sym>		(BFD_RELOC_MIPS_HIGHEST) 	       daddiu	$tempreg,<sym>		(BFD_RELOC_MIPS_HIGHER) 	       dsll	$tempreg,16 	       daddiu	$tempreg,<sym>		(BFD_RELOC_HI16_S) 	       dsll	$tempreg,16 	       daddu	$tempreg,$tempreg,$breg<op>	$treg,<sym>($tempreg)	(BFD_RELOC_LO16)  	     For GP relative symbols in 64bit address space we can use 	     the same sequence as in 32bit address space.  */
if|if
condition|(
name|HAVE_64BIT_SYMBOLS
condition|)
block|{
if|if
condition|(
operator|(
name|valueT
operator|)
name|offset_expr
operator|.
name|X_add_number
operator|<=
name|MAX_GPREL_OFFSET
operator|&&
operator|!
name|nopic_need_relax
argument_list|(
name|offset_expr
operator|.
name|X_add_symbol
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|relax_start
argument_list|(
name|offset_expr
operator|.
name|X_add_symbol
argument_list|)
expr_stmt|;
if|if
condition|(
name|breg
operator|==
literal|0
condition|)
block|{
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|s
argument_list|,
name|fmt
argument_list|,
name|treg
argument_list|,
name|BFD_RELOC_GPREL16
argument_list|,
name|mips_gp_register
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|macro_build
argument_list|(
name|NULL
argument_list|,
name|ADDRESS_ADD_INSN
argument_list|,
literal|"d,v,t"
argument_list|,
name|tempreg
argument_list|,
name|breg
argument_list|,
name|mips_gp_register
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|s
argument_list|,
name|fmt
argument_list|,
name|treg
argument_list|,
name|BFD_RELOC_GPREL16
argument_list|,
name|tempreg
argument_list|)
expr_stmt|;
block|}
name|relax_switch
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|used_at
operator|==
literal|0
operator|&&
operator|!
name|mips_opts
operator|.
name|noat
condition|)
block|{
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
literal|"lui"
argument_list|,
literal|"t,u"
argument_list|,
name|tempreg
argument_list|,
name|BFD_RELOC_MIPS_HIGHEST
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
literal|"lui"
argument_list|,
literal|"t,u"
argument_list|,
name|AT
argument_list|,
name|BFD_RELOC_HI16_S
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
literal|"daddiu"
argument_list|,
literal|"t,r,j"
argument_list|,
name|tempreg
argument_list|,
name|tempreg
argument_list|,
name|BFD_RELOC_MIPS_HIGHER
argument_list|)
expr_stmt|;
if|if
condition|(
name|breg
operator|!=
literal|0
condition|)
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"daddu"
argument_list|,
literal|"d,v,t"
argument_list|,
name|AT
argument_list|,
name|AT
argument_list|,
name|breg
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"dsll32"
argument_list|,
literal|"d,w,<"
argument_list|,
name|tempreg
argument_list|,
name|tempreg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"daddu"
argument_list|,
literal|"d,v,t"
argument_list|,
name|tempreg
argument_list|,
name|tempreg
argument_list|,
name|AT
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|s
argument_list|,
name|fmt
argument_list|,
name|treg
argument_list|,
name|BFD_RELOC_LO16
argument_list|,
name|tempreg
argument_list|)
expr_stmt|;
name|used_at
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
literal|"lui"
argument_list|,
literal|"t,u"
argument_list|,
name|tempreg
argument_list|,
name|BFD_RELOC_MIPS_HIGHEST
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
literal|"daddiu"
argument_list|,
literal|"t,r,j"
argument_list|,
name|tempreg
argument_list|,
name|tempreg
argument_list|,
name|BFD_RELOC_MIPS_HIGHER
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"dsll"
argument_list|,
literal|"d,w,<"
argument_list|,
name|tempreg
argument_list|,
name|tempreg
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
literal|"daddiu"
argument_list|,
literal|"t,r,j"
argument_list|,
name|tempreg
argument_list|,
name|tempreg
argument_list|,
name|BFD_RELOC_HI16_S
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"dsll"
argument_list|,
literal|"d,w,<"
argument_list|,
name|tempreg
argument_list|,
name|tempreg
argument_list|,
literal|16
argument_list|)
expr_stmt|;
if|if
condition|(
name|breg
operator|!=
literal|0
condition|)
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"daddu"
argument_list|,
literal|"d,v,t"
argument_list|,
name|tempreg
argument_list|,
name|tempreg
argument_list|,
name|breg
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|s
argument_list|,
name|fmt
argument_list|,
name|treg
argument_list|,
name|BFD_RELOC_LO16
argument_list|,
name|tempreg
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mips_relax
operator|.
name|sequence
condition|)
name|relax_end
argument_list|()
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|breg
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|valueT
operator|)
name|offset_expr
operator|.
name|X_add_number
operator|<=
name|MAX_GPREL_OFFSET
operator|&&
operator|!
name|nopic_need_relax
argument_list|(
name|offset_expr
operator|.
name|X_add_symbol
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|relax_start
argument_list|(
name|offset_expr
operator|.
name|X_add_symbol
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|s
argument_list|,
name|fmt
argument_list|,
name|treg
argument_list|,
name|BFD_RELOC_GPREL16
argument_list|,
name|mips_gp_register
argument_list|)
expr_stmt|;
name|relax_switch
argument_list|()
expr_stmt|;
block|}
name|macro_build_lui
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|tempreg
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|s
argument_list|,
name|fmt
argument_list|,
name|treg
argument_list|,
name|BFD_RELOC_LO16
argument_list|,
name|tempreg
argument_list|)
expr_stmt|;
if|if
condition|(
name|mips_relax
operator|.
name|sequence
condition|)
name|relax_end
argument_list|()
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|valueT
operator|)
name|offset_expr
operator|.
name|X_add_number
operator|<=
name|MAX_GPREL_OFFSET
operator|&&
operator|!
name|nopic_need_relax
argument_list|(
name|offset_expr
operator|.
name|X_add_symbol
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|relax_start
argument_list|(
name|offset_expr
operator|.
name|X_add_symbol
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
name|ADDRESS_ADD_INSN
argument_list|,
literal|"d,v,t"
argument_list|,
name|tempreg
argument_list|,
name|breg
argument_list|,
name|mips_gp_register
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|s
argument_list|,
name|fmt
argument_list|,
name|treg
argument_list|,
name|BFD_RELOC_GPREL16
argument_list|,
name|tempreg
argument_list|)
expr_stmt|;
name|relax_switch
argument_list|()
expr_stmt|;
block|}
name|macro_build_lui
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|tempreg
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
name|ADDRESS_ADD_INSN
argument_list|,
literal|"d,v,t"
argument_list|,
name|tempreg
argument_list|,
name|tempreg
argument_list|,
name|breg
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|s
argument_list|,
name|fmt
argument_list|,
name|treg
argument_list|,
name|BFD_RELOC_LO16
argument_list|,
name|tempreg
argument_list|)
expr_stmt|;
if|if
condition|(
name|mips_relax
operator|.
name|sequence
condition|)
name|relax_end
argument_list|()
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|mips_big_got
condition|)
block|{
name|int
name|lw_reloc_type
init|=
operator|(
name|int
operator|)
name|BFD_RELOC_MIPS_GOT16
decl_stmt|;
comment|/* If this is a reference to an external symbol, we want 	       lw	$tempreg,<sym>($gp)	(BFD_RELOC_MIPS_GOT16) 	       nop<op>	$treg,0($tempreg) 	     Otherwise we want 	       lw	$tempreg,<sym>($gp)	(BFD_RELOC_MIPS_GOT16) 	       nop 	       addiu	$tempreg,$tempreg,<sym>	(BFD_RELOC_LO16)<op>	$treg,0($tempreg)  	     For NewABI, we want 	       lw	$tempreg,<sym>($gp)	(BFD_RELOC_MIPS_GOT_PAGE)<op>	$treg,<sym>($tempreg)   (BFD_RELOC_MIPS_GOT_OFST)  	     If there is a base register, we add it to $tempreg before 	     the<op>.  If there is a constant, we stick it in the<op> instruction.  We don't handle constants larger than 	     16 bits, because we have no way to load the upper 16 bits 	     (actually, we could handle them for the subset of cases 	     in which we are not using $at).  */
name|assert
argument_list|(
name|offset_expr
operator|.
name|X_op
operator|==
name|O_symbol
argument_list|)
expr_stmt|;
if|if
condition|(
name|HAVE_NEWABI
condition|)
block|{
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|ADDRESS_LOAD_INSN
argument_list|,
literal|"t,o(b)"
argument_list|,
name|tempreg
argument_list|,
name|BFD_RELOC_MIPS_GOT_PAGE
argument_list|,
name|mips_gp_register
argument_list|)
expr_stmt|;
if|if
condition|(
name|breg
operator|!=
literal|0
condition|)
name|macro_build
argument_list|(
name|NULL
argument_list|,
name|ADDRESS_ADD_INSN
argument_list|,
literal|"d,v,t"
argument_list|,
name|tempreg
argument_list|,
name|tempreg
argument_list|,
name|breg
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|s
argument_list|,
name|fmt
argument_list|,
name|treg
argument_list|,
name|BFD_RELOC_MIPS_GOT_OFST
argument_list|,
name|tempreg
argument_list|)
expr_stmt|;
break|break;
block|}
name|expr1
operator|.
name|X_add_number
operator|=
name|offset_expr
operator|.
name|X_add_number
expr_stmt|;
name|offset_expr
operator|.
name|X_add_number
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|expr1
operator|.
name|X_add_number
operator|<
operator|-
literal|0x8000
operator|||
name|expr1
operator|.
name|X_add_number
operator|>=
literal|0x8000
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"PIC code offset overflow (max 16 signed bits)"
argument_list|)
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|ADDRESS_LOAD_INSN
argument_list|,
literal|"t,o(b)"
argument_list|,
name|tempreg
argument_list|,
name|lw_reloc_type
argument_list|,
name|mips_gp_register
argument_list|)
expr_stmt|;
name|load_delay_nop
argument_list|()
expr_stmt|;
name|relax_start
argument_list|(
name|offset_expr
operator|.
name|X_add_symbol
argument_list|)
expr_stmt|;
name|relax_switch
argument_list|()
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|ADDRESS_ADDI_INSN
argument_list|,
literal|"t,r,j"
argument_list|,
name|tempreg
argument_list|,
name|tempreg
argument_list|,
name|BFD_RELOC_LO16
argument_list|)
expr_stmt|;
name|relax_end
argument_list|()
expr_stmt|;
if|if
condition|(
name|breg
operator|!=
literal|0
condition|)
name|macro_build
argument_list|(
name|NULL
argument_list|,
name|ADDRESS_ADD_INSN
argument_list|,
literal|"d,v,t"
argument_list|,
name|tempreg
argument_list|,
name|tempreg
argument_list|,
name|breg
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|expr1
argument_list|,
name|s
argument_list|,
name|fmt
argument_list|,
name|treg
argument_list|,
name|BFD_RELOC_LO16
argument_list|,
name|tempreg
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mips_big_got
operator|&&
operator|!
name|HAVE_NEWABI
condition|)
block|{
name|int
name|gpdelay
decl_stmt|;
comment|/* If this is a reference to an external symbol, we want 	       lui	$tempreg,<sym>		(BFD_RELOC_MIPS_GOT_HI16) 	       addu	$tempreg,$tempreg,$gp 	       lw	$tempreg,<sym>($tempreg) (BFD_RELOC_MIPS_GOT_LO16)<op>	$treg,0($tempreg) 	     Otherwise we want 	       lw	$tempreg,<sym>($gp)	(BFD_RELOC_MIPS_GOT16) 	       nop 	       addiu	$tempreg,$tempreg,<sym>	(BFD_RELOC_LO16)<op>	$treg,0($tempreg) 	     If there is a base register, we add it to $tempreg before 	     the<op>.  If there is a constant, we stick it in the<op> instruction.  We don't handle constants larger than 	     16 bits, because we have no way to load the upper 16 bits 	     (actually, we could handle them for the subset of cases 	     in which we are not using $at).  */
name|assert
argument_list|(
name|offset_expr
operator|.
name|X_op
operator|==
name|O_symbol
argument_list|)
expr_stmt|;
name|expr1
operator|.
name|X_add_number
operator|=
name|offset_expr
operator|.
name|X_add_number
expr_stmt|;
name|offset_expr
operator|.
name|X_add_number
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|expr1
operator|.
name|X_add_number
operator|<
operator|-
literal|0x8000
operator|||
name|expr1
operator|.
name|X_add_number
operator|>=
literal|0x8000
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"PIC code offset overflow (max 16 signed bits)"
argument_list|)
argument_list|)
expr_stmt|;
name|gpdelay
operator|=
name|reg_needs_delay
argument_list|(
name|mips_gp_register
argument_list|)
expr_stmt|;
name|relax_start
argument_list|(
name|offset_expr
operator|.
name|X_add_symbol
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
literal|"lui"
argument_list|,
literal|"t,u"
argument_list|,
name|tempreg
argument_list|,
name|BFD_RELOC_MIPS_GOT_HI16
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
name|ADDRESS_ADD_INSN
argument_list|,
literal|"d,v,t"
argument_list|,
name|tempreg
argument_list|,
name|tempreg
argument_list|,
name|mips_gp_register
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|ADDRESS_LOAD_INSN
argument_list|,
literal|"t,o(b)"
argument_list|,
name|tempreg
argument_list|,
name|BFD_RELOC_MIPS_GOT_LO16
argument_list|,
name|tempreg
argument_list|)
expr_stmt|;
name|relax_switch
argument_list|()
expr_stmt|;
if|if
condition|(
name|gpdelay
condition|)
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"nop"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|ADDRESS_LOAD_INSN
argument_list|,
literal|"t,o(b)"
argument_list|,
name|tempreg
argument_list|,
name|BFD_RELOC_MIPS_GOT16
argument_list|,
name|mips_gp_register
argument_list|)
expr_stmt|;
name|load_delay_nop
argument_list|()
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|ADDRESS_ADDI_INSN
argument_list|,
literal|"t,r,j"
argument_list|,
name|tempreg
argument_list|,
name|tempreg
argument_list|,
name|BFD_RELOC_LO16
argument_list|)
expr_stmt|;
name|relax_end
argument_list|()
expr_stmt|;
if|if
condition|(
name|breg
operator|!=
literal|0
condition|)
name|macro_build
argument_list|(
name|NULL
argument_list|,
name|ADDRESS_ADD_INSN
argument_list|,
literal|"d,v,t"
argument_list|,
name|tempreg
argument_list|,
name|tempreg
argument_list|,
name|breg
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|expr1
argument_list|,
name|s
argument_list|,
name|fmt
argument_list|,
name|treg
argument_list|,
name|BFD_RELOC_LO16
argument_list|,
name|tempreg
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mips_big_got
operator|&&
name|HAVE_NEWABI
condition|)
block|{
comment|/* If this is a reference to an external symbol, we want 	       lui	$tempreg,<sym>		(BFD_RELOC_MIPS_GOT_HI16) 	       add	$tempreg,$tempreg,$gp 	       lw	$tempreg,<sym>($tempreg) (BFD_RELOC_MIPS_GOT_LO16)<op>	$treg,<ofst>($tempreg) 	     Otherwise, for local symbols, we want: 	       lw	$tempreg,<sym>($gp)	(BFD_RELOC_MIPS_GOT_PAGE)<op>	$treg,<sym>($tempreg)   (BFD_RELOC_MIPS_GOT_OFST)  */
name|assert
argument_list|(
name|offset_expr
operator|.
name|X_op
operator|==
name|O_symbol
argument_list|)
expr_stmt|;
name|expr1
operator|.
name|X_add_number
operator|=
name|offset_expr
operator|.
name|X_add_number
expr_stmt|;
name|offset_expr
operator|.
name|X_add_number
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|expr1
operator|.
name|X_add_number
operator|<
operator|-
literal|0x8000
operator|||
name|expr1
operator|.
name|X_add_number
operator|>=
literal|0x8000
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"PIC code offset overflow (max 16 signed bits)"
argument_list|)
argument_list|)
expr_stmt|;
name|relax_start
argument_list|(
name|offset_expr
operator|.
name|X_add_symbol
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
literal|"lui"
argument_list|,
literal|"t,u"
argument_list|,
name|tempreg
argument_list|,
name|BFD_RELOC_MIPS_GOT_HI16
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
name|ADDRESS_ADD_INSN
argument_list|,
literal|"d,v,t"
argument_list|,
name|tempreg
argument_list|,
name|tempreg
argument_list|,
name|mips_gp_register
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|ADDRESS_LOAD_INSN
argument_list|,
literal|"t,o(b)"
argument_list|,
name|tempreg
argument_list|,
name|BFD_RELOC_MIPS_GOT_LO16
argument_list|,
name|tempreg
argument_list|)
expr_stmt|;
if|if
condition|(
name|breg
operator|!=
literal|0
condition|)
name|macro_build
argument_list|(
name|NULL
argument_list|,
name|ADDRESS_ADD_INSN
argument_list|,
literal|"d,v,t"
argument_list|,
name|tempreg
argument_list|,
name|tempreg
argument_list|,
name|breg
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|expr1
argument_list|,
name|s
argument_list|,
name|fmt
argument_list|,
name|treg
argument_list|,
name|BFD_RELOC_LO16
argument_list|,
name|tempreg
argument_list|)
expr_stmt|;
name|relax_switch
argument_list|()
expr_stmt|;
name|offset_expr
operator|.
name|X_add_number
operator|=
name|expr1
operator|.
name|X_add_number
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|ADDRESS_LOAD_INSN
argument_list|,
literal|"t,o(b)"
argument_list|,
name|tempreg
argument_list|,
name|BFD_RELOC_MIPS_GOT_PAGE
argument_list|,
name|mips_gp_register
argument_list|)
expr_stmt|;
if|if
condition|(
name|breg
operator|!=
literal|0
condition|)
name|macro_build
argument_list|(
name|NULL
argument_list|,
name|ADDRESS_ADD_INSN
argument_list|,
literal|"d,v,t"
argument_list|,
name|tempreg
argument_list|,
name|tempreg
argument_list|,
name|breg
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|s
argument_list|,
name|fmt
argument_list|,
name|treg
argument_list|,
name|BFD_RELOC_MIPS_GOT_OFST
argument_list|,
name|tempreg
argument_list|)
expr_stmt|;
name|relax_end
argument_list|()
expr_stmt|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
break|break;
case|case
name|M_LI
case|:
case|case
name|M_LI_S
case|:
name|load_register
argument_list|(
name|treg
argument_list|,
operator|&
name|imm_expr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|M_DLI
case|:
name|load_register
argument_list|(
name|treg
argument_list|,
operator|&
name|imm_expr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|M_LI_SS
case|:
if|if
condition|(
name|imm_expr
operator|.
name|X_op
operator|==
name|O_constant
condition|)
block|{
name|used_at
operator|=
literal|1
expr_stmt|;
name|load_register
argument_list|(
name|AT
argument_list|,
operator|&
name|imm_expr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"mtc1"
argument_list|,
literal|"t,G"
argument_list|,
name|AT
argument_list|,
name|treg
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
block|{
name|assert
argument_list|(
name|offset_expr
operator|.
name|X_op
operator|==
name|O_symbol
operator|&&
name|strcmp
argument_list|(
name|segment_name
argument_list|(
name|S_GET_SEGMENT
argument_list|(
name|offset_expr
operator|.
name|X_add_symbol
argument_list|)
argument_list|)
argument_list|,
literal|".lit4"
argument_list|)
operator|==
literal|0
operator|&&
name|offset_expr
operator|.
name|X_add_number
operator|==
literal|0
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
literal|"lwc1"
argument_list|,
literal|"T,o(b)"
argument_list|,
name|treg
argument_list|,
name|BFD_RELOC_MIPS_LITERAL
argument_list|,
name|mips_gp_register
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|M_LI_D
case|:
comment|/* Check if we have a constant in IMM_EXPR.  If the GPRs are 64 bits          wide, IMM_EXPR is the entire value.  Otherwise IMM_EXPR is the high          order 32 bits of the value and the low order 32 bits are either          zero or in OFFSET_EXPR.  */
if|if
condition|(
name|imm_expr
operator|.
name|X_op
operator|==
name|O_constant
operator|||
name|imm_expr
operator|.
name|X_op
operator|==
name|O_big
condition|)
block|{
if|if
condition|(
name|HAVE_64BIT_GPRS
condition|)
name|load_register
argument_list|(
name|treg
argument_list|,
operator|&
name|imm_expr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
block|{
name|int
name|hreg
decl_stmt|,
name|lreg
decl_stmt|;
if|if
condition|(
name|target_big_endian
condition|)
block|{
name|hreg
operator|=
name|treg
expr_stmt|;
name|lreg
operator|=
name|treg
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
name|hreg
operator|=
name|treg
operator|+
literal|1
expr_stmt|;
name|lreg
operator|=
name|treg
expr_stmt|;
block|}
if|if
condition|(
name|hreg
operator|<=
literal|31
condition|)
name|load_register
argument_list|(
name|hreg
argument_list|,
operator|&
name|imm_expr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|lreg
operator|<=
literal|31
condition|)
block|{
if|if
condition|(
name|offset_expr
operator|.
name|X_op
operator|==
name|O_absent
condition|)
name|move_register
argument_list|(
name|lreg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
block|{
name|assert
argument_list|(
name|offset_expr
operator|.
name|X_op
operator|==
name|O_constant
argument_list|)
expr_stmt|;
name|load_register
argument_list|(
name|lreg
argument_list|,
operator|&
name|offset_expr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
break|break;
block|}
comment|/* We know that sym is in the .rdata section.  First we get the 	 upper 16 bits of the address.  */
if|if
condition|(
name|mips_pic
operator|==
name|NO_PIC
condition|)
block|{
name|macro_build_lui
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|AT
argument_list|)
expr_stmt|;
name|used_at
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|ADDRESS_LOAD_INSN
argument_list|,
literal|"t,o(b)"
argument_list|,
name|AT
argument_list|,
name|BFD_RELOC_MIPS_GOT16
argument_list|,
name|mips_gp_register
argument_list|)
expr_stmt|;
name|used_at
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Now we load the register(s).  */
if|if
condition|(
name|HAVE_64BIT_GPRS
condition|)
block|{
name|used_at
operator|=
literal|1
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
literal|"ld"
argument_list|,
literal|"t,o(b)"
argument_list|,
name|treg
argument_list|,
name|BFD_RELOC_LO16
argument_list|,
name|AT
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|used_at
operator|=
literal|1
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
literal|"lw"
argument_list|,
literal|"t,o(b)"
argument_list|,
name|treg
argument_list|,
name|BFD_RELOC_LO16
argument_list|,
name|AT
argument_list|)
expr_stmt|;
if|if
condition|(
name|treg
operator|!=
name|RA
condition|)
block|{
comment|/* FIXME: How in the world do we deal with the possible 		 overflow here?  */
name|offset_expr
operator|.
name|X_add_number
operator|+=
literal|4
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
literal|"lw"
argument_list|,
literal|"t,o(b)"
argument_list|,
name|treg
operator|+
literal|1
argument_list|,
name|BFD_RELOC_LO16
argument_list|,
name|AT
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|M_LI_DD
case|:
comment|/* Check if we have a constant in IMM_EXPR.  If the FPRs are 64 bits          wide, IMM_EXPR is the entire value and the GPRs are known to be 64          bits wide as well.  Otherwise IMM_EXPR is the high order 32 bits of          the value and the low order 32 bits are either zero or in          OFFSET_EXPR.  */
if|if
condition|(
name|imm_expr
operator|.
name|X_op
operator|==
name|O_constant
operator|||
name|imm_expr
operator|.
name|X_op
operator|==
name|O_big
condition|)
block|{
name|used_at
operator|=
literal|1
expr_stmt|;
name|load_register
argument_list|(
name|AT
argument_list|,
operator|&
name|imm_expr
argument_list|,
name|HAVE_64BIT_FPRS
argument_list|)
expr_stmt|;
if|if
condition|(
name|HAVE_64BIT_FPRS
condition|)
block|{
name|assert
argument_list|(
name|HAVE_64BIT_GPRS
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"dmtc1"
argument_list|,
literal|"t,S"
argument_list|,
name|AT
argument_list|,
name|treg
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"mtc1"
argument_list|,
literal|"t,G"
argument_list|,
name|AT
argument_list|,
name|treg
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset_expr
operator|.
name|X_op
operator|==
name|O_absent
condition|)
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"mtc1"
argument_list|,
literal|"t,G"
argument_list|,
literal|0
argument_list|,
name|treg
argument_list|)
expr_stmt|;
else|else
block|{
name|assert
argument_list|(
name|offset_expr
operator|.
name|X_op
operator|==
name|O_constant
argument_list|)
expr_stmt|;
name|load_register
argument_list|(
name|AT
argument_list|,
operator|&
name|offset_expr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"mtc1"
argument_list|,
literal|"t,G"
argument_list|,
name|AT
argument_list|,
name|treg
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
block|}
name|assert
argument_list|(
name|offset_expr
operator|.
name|X_op
operator|==
name|O_symbol
operator|&&
name|offset_expr
operator|.
name|X_add_number
operator|==
literal|0
argument_list|)
expr_stmt|;
name|s
operator|=
name|segment_name
argument_list|(
name|S_GET_SEGMENT
argument_list|(
name|offset_expr
operator|.
name|X_add_symbol
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|s
argument_list|,
literal|".lit8"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|mips_opts
operator|.
name|isa
operator|!=
name|ISA_MIPS1
condition|)
block|{
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
literal|"ldc1"
argument_list|,
literal|"T,o(b)"
argument_list|,
name|treg
argument_list|,
name|BFD_RELOC_MIPS_LITERAL
argument_list|,
name|mips_gp_register
argument_list|)
expr_stmt|;
break|break;
block|}
name|breg
operator|=
name|mips_gp_register
expr_stmt|;
name|r
operator|=
name|BFD_RELOC_MIPS_LITERAL
expr_stmt|;
goto|goto
name|dob
goto|;
block|}
else|else
block|{
name|assert
argument_list|(
name|strcmp
argument_list|(
name|s
argument_list|,
name|RDATA_SECTION_NAME
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|used_at
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|mips_pic
operator|!=
name|NO_PIC
condition|)
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|ADDRESS_LOAD_INSN
argument_list|,
literal|"t,o(b)"
argument_list|,
name|AT
argument_list|,
name|BFD_RELOC_MIPS_GOT16
argument_list|,
name|mips_gp_register
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* FIXME: This won't work for a 64 bit address.  */
name|macro_build_lui
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|AT
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mips_opts
operator|.
name|isa
operator|!=
name|ISA_MIPS1
condition|)
block|{
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
literal|"ldc1"
argument_list|,
literal|"T,o(b)"
argument_list|,
name|treg
argument_list|,
name|BFD_RELOC_LO16
argument_list|,
name|AT
argument_list|)
expr_stmt|;
break|break;
block|}
name|breg
operator|=
name|AT
expr_stmt|;
name|r
operator|=
name|BFD_RELOC_LO16
expr_stmt|;
goto|goto
name|dob
goto|;
block|}
case|case
name|M_L_DOB
case|:
if|if
condition|(
name|mips_opts
operator|.
name|arch
operator|==
name|CPU_R4650
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"opcode not supported on this processor"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Even on a big endian machine $fn comes before $fn+1.  We have 	 to adjust when loading from memory.  */
name|r
operator|=
name|BFD_RELOC_LO16
expr_stmt|;
name|dob
label|:
name|assert
argument_list|(
name|mips_opts
operator|.
name|isa
operator|==
name|ISA_MIPS1
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
literal|"lwc1"
argument_list|,
literal|"T,o(b)"
argument_list|,
name|target_big_endian
condition|?
name|treg
operator|+
literal|1
else|:
name|treg
argument_list|,
name|r
argument_list|,
name|breg
argument_list|)
expr_stmt|;
comment|/* FIXME: A possible overflow which I don't know how to deal 	 with.  */
name|offset_expr
operator|.
name|X_add_number
operator|+=
literal|4
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
literal|"lwc1"
argument_list|,
literal|"T,o(b)"
argument_list|,
name|target_big_endian
condition|?
name|treg
else|:
name|treg
operator|+
literal|1
argument_list|,
name|r
argument_list|,
name|breg
argument_list|)
expr_stmt|;
break|break;
case|case
name|M_L_DAB
case|:
comment|/*        * The MIPS assembler seems to check for X_add_number not        * being double aligned and generating:        *	lui	at,%hi(foo+1)        *	addu	at,at,v1        *	addiu	at,at,%lo(foo+1)        *	lwc1	f2,0(at)        *	lwc1	f3,4(at)        * But, the resulting address is the same after relocation so why        * generate the extra instruction?        */
if|if
condition|(
name|mips_opts
operator|.
name|arch
operator|==
name|CPU_R4650
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"opcode not supported on this processor"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Itbl support may require additional care here.  */
name|coproc
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|mips_opts
operator|.
name|isa
operator|!=
name|ISA_MIPS1
condition|)
block|{
name|s
operator|=
literal|"ldc1"
expr_stmt|;
goto|goto
name|ld
goto|;
block|}
name|s
operator|=
literal|"lwc1"
expr_stmt|;
name|fmt
operator|=
literal|"T,o(b)"
expr_stmt|;
goto|goto
name|ldd_std
goto|;
case|case
name|M_S_DAB
case|:
if|if
condition|(
name|mips_opts
operator|.
name|arch
operator|==
name|CPU_R4650
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"opcode not supported on this processor"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|mips_opts
operator|.
name|isa
operator|!=
name|ISA_MIPS1
condition|)
block|{
name|s
operator|=
literal|"sdc1"
expr_stmt|;
goto|goto
name|st
goto|;
block|}
name|s
operator|=
literal|"swc1"
expr_stmt|;
name|fmt
operator|=
literal|"T,o(b)"
expr_stmt|;
comment|/* Itbl support may require additional care here.  */
name|coproc
operator|=
literal|1
expr_stmt|;
goto|goto
name|ldd_std
goto|;
case|case
name|M_LD_AB
case|:
if|if
condition|(
name|HAVE_64BIT_GPRS
condition|)
block|{
name|s
operator|=
literal|"ld"
expr_stmt|;
goto|goto
name|ld
goto|;
block|}
name|s
operator|=
literal|"lw"
expr_stmt|;
name|fmt
operator|=
literal|"t,o(b)"
expr_stmt|;
goto|goto
name|ldd_std
goto|;
case|case
name|M_SD_AB
case|:
if|if
condition|(
name|HAVE_64BIT_GPRS
condition|)
block|{
name|s
operator|=
literal|"sd"
expr_stmt|;
goto|goto
name|st
goto|;
block|}
name|s
operator|=
literal|"sw"
expr_stmt|;
name|fmt
operator|=
literal|"t,o(b)"
expr_stmt|;
name|ldd_std
label|:
if|if
condition|(
name|offset_expr
operator|.
name|X_op
operator|!=
name|O_symbol
operator|&&
name|offset_expr
operator|.
name|X_op
operator|!=
name|O_constant
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"expression too complex"
argument_list|)
argument_list|)
expr_stmt|;
name|offset_expr
operator|.
name|X_op
operator|=
name|O_constant
expr_stmt|;
block|}
if|if
condition|(
name|HAVE_32BIT_ADDRESSES
operator|&&
operator|!
name|IS_SEXT_32BIT_NUM
argument_list|(
name|offset_expr
operator|.
name|X_add_number
argument_list|)
condition|)
block|{
name|char
name|value
index|[
literal|32
index|]
decl_stmt|;
name|sprintf_vma
argument_list|(
name|value
argument_list|,
name|offset_expr
operator|.
name|X_add_number
argument_list|)
expr_stmt|;
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Number (0x%s) larger than 32 bits"
argument_list|)
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
comment|/* Even on a big endian machine $fn comes before $fn+1.  We have 	 to adjust when loading from memory.  We set coproc if we must 	 load $fn+1 first.  */
comment|/* Itbl support may require additional care here.  */
if|if
condition|(
operator|!
name|target_big_endian
condition|)
name|coproc
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|mips_pic
operator|==
name|NO_PIC
operator|||
name|offset_expr
operator|.
name|X_op
operator|==
name|O_constant
condition|)
block|{
comment|/* If this is a reference to a GP relative symbol, we want<op>	$treg,<sym>($gp)	(BFD_RELOC_GPREL16)<op>	$treg+1,<sym>+4($gp)	(BFD_RELOC_GPREL16) 	     If we have a base register, we use this 	       addu	$at,$breg,$gp<op>	$treg,<sym>($at)	(BFD_RELOC_GPREL16)<op>	$treg+1,<sym>+4($at)	(BFD_RELOC_GPREL16) 	     If this is not a GP relative symbol, we want 	       lui	$at,<sym>		(BFD_RELOC_HI16_S)<op>	$treg,<sym>($at)	(BFD_RELOC_LO16)<op>	$treg+1,<sym>+4($at)	(BFD_RELOC_LO16) 	     If there is a base register, we add it to $at after the 	     lui instruction.  If there is a constant, we always use 	     the last case.  */
if|if
condition|(
name|offset_expr
operator|.
name|X_op
operator|==
name|O_symbol
operator|&&
operator|(
name|valueT
operator|)
name|offset_expr
operator|.
name|X_add_number
operator|<=
name|MAX_GPREL_OFFSET
operator|&&
operator|!
name|nopic_need_relax
argument_list|(
name|offset_expr
operator|.
name|X_add_symbol
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|relax_start
argument_list|(
name|offset_expr
operator|.
name|X_add_symbol
argument_list|)
expr_stmt|;
if|if
condition|(
name|breg
operator|==
literal|0
condition|)
block|{
name|tempreg
operator|=
name|mips_gp_register
expr_stmt|;
block|}
else|else
block|{
name|macro_build
argument_list|(
name|NULL
argument_list|,
name|ADDRESS_ADD_INSN
argument_list|,
literal|"d,v,t"
argument_list|,
name|AT
argument_list|,
name|breg
argument_list|,
name|mips_gp_register
argument_list|)
expr_stmt|;
name|tempreg
operator|=
name|AT
expr_stmt|;
name|used_at
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Itbl support may require additional care here.  */
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|s
argument_list|,
name|fmt
argument_list|,
name|coproc
condition|?
name|treg
operator|+
literal|1
else|:
name|treg
argument_list|,
name|BFD_RELOC_GPREL16
argument_list|,
name|tempreg
argument_list|)
expr_stmt|;
name|offset_expr
operator|.
name|X_add_number
operator|+=
literal|4
expr_stmt|;
comment|/* Set mips_optimize to 2 to avoid inserting an                  undesired nop.  */
name|hold_mips_optimize
operator|=
name|mips_optimize
expr_stmt|;
name|mips_optimize
operator|=
literal|2
expr_stmt|;
comment|/* Itbl support may require additional care here.  */
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|s
argument_list|,
name|fmt
argument_list|,
name|coproc
condition|?
name|treg
else|:
name|treg
operator|+
literal|1
argument_list|,
name|BFD_RELOC_GPREL16
argument_list|,
name|tempreg
argument_list|)
expr_stmt|;
name|mips_optimize
operator|=
name|hold_mips_optimize
expr_stmt|;
name|relax_switch
argument_list|()
expr_stmt|;
comment|/* We just generated two relocs.  When tc_gen_reloc 		 handles this case, it will skip the first reloc and 		 handle the second.  The second reloc already has an 		 extra addend of 4, which we added above.  We must 		 subtract it out, and then subtract another 4 to make 		 the first reloc come out right.  The second reloc 		 will come out right because we are going to add 4 to 		 offset_expr when we build its instruction below.  		 If we have a symbol, then we don't want to include 		 the offset, because it will wind up being included 		 when we generate the reloc.  */
if|if
condition|(
name|offset_expr
operator|.
name|X_op
operator|==
name|O_constant
condition|)
name|offset_expr
operator|.
name|X_add_number
operator|-=
literal|8
expr_stmt|;
else|else
block|{
name|offset_expr
operator|.
name|X_add_number
operator|=
operator|-
literal|4
expr_stmt|;
name|offset_expr
operator|.
name|X_op
operator|=
name|O_constant
expr_stmt|;
block|}
block|}
name|used_at
operator|=
literal|1
expr_stmt|;
name|macro_build_lui
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|AT
argument_list|)
expr_stmt|;
if|if
condition|(
name|breg
operator|!=
literal|0
condition|)
name|macro_build
argument_list|(
name|NULL
argument_list|,
name|ADDRESS_ADD_INSN
argument_list|,
literal|"d,v,t"
argument_list|,
name|AT
argument_list|,
name|breg
argument_list|,
name|AT
argument_list|)
expr_stmt|;
comment|/* Itbl support may require additional care here.  */
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|s
argument_list|,
name|fmt
argument_list|,
name|coproc
condition|?
name|treg
operator|+
literal|1
else|:
name|treg
argument_list|,
name|BFD_RELOC_LO16
argument_list|,
name|AT
argument_list|)
expr_stmt|;
comment|/* FIXME: How do we handle overflow here?  */
name|offset_expr
operator|.
name|X_add_number
operator|+=
literal|4
expr_stmt|;
comment|/* Itbl support may require additional care here.  */
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|s
argument_list|,
name|fmt
argument_list|,
name|coproc
condition|?
name|treg
else|:
name|treg
operator|+
literal|1
argument_list|,
name|BFD_RELOC_LO16
argument_list|,
name|AT
argument_list|)
expr_stmt|;
if|if
condition|(
name|mips_relax
operator|.
name|sequence
condition|)
name|relax_end
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|mips_big_got
condition|)
block|{
comment|/* If this is a reference to an external symbol, we want 	       lw	$at,<sym>($gp)		(BFD_RELOC_MIPS_GOT16) 	       nop<op>	$treg,0($at)<op>	$treg+1,4($at) 	     Otherwise we want 	       lw	$at,<sym>($gp)		(BFD_RELOC_MIPS_GOT16) 	       nop<op>	$treg,<sym>($at)	(BFD_RELOC_LO16)<op>	$treg+1,<sym>+4($at)	(BFD_RELOC_LO16) 	     If there is a base register we add it to $at before the 	     lwc1 instructions.  If there is a constant we include it 	     in the lwc1 instructions.  */
name|used_at
operator|=
literal|1
expr_stmt|;
name|expr1
operator|.
name|X_add_number
operator|=
name|offset_expr
operator|.
name|X_add_number
expr_stmt|;
if|if
condition|(
name|expr1
operator|.
name|X_add_number
operator|<
operator|-
literal|0x8000
operator|||
name|expr1
operator|.
name|X_add_number
operator|>=
literal|0x8000
operator|-
literal|4
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"PIC code offset overflow (max 16 signed bits)"
argument_list|)
argument_list|)
expr_stmt|;
name|load_got_offset
argument_list|(
name|AT
argument_list|,
operator|&
name|offset_expr
argument_list|)
expr_stmt|;
name|load_delay_nop
argument_list|()
expr_stmt|;
if|if
condition|(
name|breg
operator|!=
literal|0
condition|)
name|macro_build
argument_list|(
name|NULL
argument_list|,
name|ADDRESS_ADD_INSN
argument_list|,
literal|"d,v,t"
argument_list|,
name|AT
argument_list|,
name|breg
argument_list|,
name|AT
argument_list|)
expr_stmt|;
comment|/* Set mips_optimize to 2 to avoid inserting an undesired              nop.  */
name|hold_mips_optimize
operator|=
name|mips_optimize
expr_stmt|;
name|mips_optimize
operator|=
literal|2
expr_stmt|;
comment|/* Itbl support may require additional care here.  */
name|relax_start
argument_list|(
name|offset_expr
operator|.
name|X_add_symbol
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|expr1
argument_list|,
name|s
argument_list|,
name|fmt
argument_list|,
name|coproc
condition|?
name|treg
operator|+
literal|1
else|:
name|treg
argument_list|,
name|BFD_RELOC_LO16
argument_list|,
name|AT
argument_list|)
expr_stmt|;
name|expr1
operator|.
name|X_add_number
operator|+=
literal|4
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|expr1
argument_list|,
name|s
argument_list|,
name|fmt
argument_list|,
name|coproc
condition|?
name|treg
else|:
name|treg
operator|+
literal|1
argument_list|,
name|BFD_RELOC_LO16
argument_list|,
name|AT
argument_list|)
expr_stmt|;
name|relax_switch
argument_list|()
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|s
argument_list|,
name|fmt
argument_list|,
name|coproc
condition|?
name|treg
operator|+
literal|1
else|:
name|treg
argument_list|,
name|BFD_RELOC_LO16
argument_list|,
name|AT
argument_list|)
expr_stmt|;
name|offset_expr
operator|.
name|X_add_number
operator|+=
literal|4
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|s
argument_list|,
name|fmt
argument_list|,
name|coproc
condition|?
name|treg
else|:
name|treg
operator|+
literal|1
argument_list|,
name|BFD_RELOC_LO16
argument_list|,
name|AT
argument_list|)
expr_stmt|;
name|relax_end
argument_list|()
expr_stmt|;
name|mips_optimize
operator|=
name|hold_mips_optimize
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mips_big_got
condition|)
block|{
name|int
name|gpdelay
decl_stmt|;
comment|/* If this is a reference to an external symbol, we want 	       lui	$at,<sym>		(BFD_RELOC_MIPS_GOT_HI16) 	       addu	$at,$at,$gp 	       lw	$at,<sym>($at)		(BFD_RELOC_MIPS_GOT_LO16) 	       nop<op>	$treg,0($at)<op>	$treg+1,4($at) 	     Otherwise we want 	       lw	$at,<sym>($gp)		(BFD_RELOC_MIPS_GOT16) 	       nop<op>	$treg,<sym>($at)	(BFD_RELOC_LO16)<op>	$treg+1,<sym>+4($at)	(BFD_RELOC_LO16) 	     If there is a base register we add it to $at before the 	     lwc1 instructions.  If there is a constant we include it 	     in the lwc1 instructions.  */
name|used_at
operator|=
literal|1
expr_stmt|;
name|expr1
operator|.
name|X_add_number
operator|=
name|offset_expr
operator|.
name|X_add_number
expr_stmt|;
name|offset_expr
operator|.
name|X_add_number
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|expr1
operator|.
name|X_add_number
operator|<
operator|-
literal|0x8000
operator|||
name|expr1
operator|.
name|X_add_number
operator|>=
literal|0x8000
operator|-
literal|4
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"PIC code offset overflow (max 16 signed bits)"
argument_list|)
argument_list|)
expr_stmt|;
name|gpdelay
operator|=
name|reg_needs_delay
argument_list|(
name|mips_gp_register
argument_list|)
expr_stmt|;
name|relax_start
argument_list|(
name|offset_expr
operator|.
name|X_add_symbol
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
literal|"lui"
argument_list|,
literal|"t,u"
argument_list|,
name|AT
argument_list|,
name|BFD_RELOC_MIPS_GOT_HI16
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
name|ADDRESS_ADD_INSN
argument_list|,
literal|"d,v,t"
argument_list|,
name|AT
argument_list|,
name|AT
argument_list|,
name|mips_gp_register
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|ADDRESS_LOAD_INSN
argument_list|,
literal|"t,o(b)"
argument_list|,
name|AT
argument_list|,
name|BFD_RELOC_MIPS_GOT_LO16
argument_list|,
name|AT
argument_list|)
expr_stmt|;
name|load_delay_nop
argument_list|()
expr_stmt|;
if|if
condition|(
name|breg
operator|!=
literal|0
condition|)
name|macro_build
argument_list|(
name|NULL
argument_list|,
name|ADDRESS_ADD_INSN
argument_list|,
literal|"d,v,t"
argument_list|,
name|AT
argument_list|,
name|breg
argument_list|,
name|AT
argument_list|)
expr_stmt|;
comment|/* Itbl support may require additional care here.  */
name|macro_build
argument_list|(
operator|&
name|expr1
argument_list|,
name|s
argument_list|,
name|fmt
argument_list|,
name|coproc
condition|?
name|treg
operator|+
literal|1
else|:
name|treg
argument_list|,
name|BFD_RELOC_LO16
argument_list|,
name|AT
argument_list|)
expr_stmt|;
name|expr1
operator|.
name|X_add_number
operator|+=
literal|4
expr_stmt|;
comment|/* Set mips_optimize to 2 to avoid inserting an undesired              nop.  */
name|hold_mips_optimize
operator|=
name|mips_optimize
expr_stmt|;
name|mips_optimize
operator|=
literal|2
expr_stmt|;
comment|/* Itbl support may require additional care here.  */
name|macro_build
argument_list|(
operator|&
name|expr1
argument_list|,
name|s
argument_list|,
name|fmt
argument_list|,
name|coproc
condition|?
name|treg
else|:
name|treg
operator|+
literal|1
argument_list|,
name|BFD_RELOC_LO16
argument_list|,
name|AT
argument_list|)
expr_stmt|;
name|mips_optimize
operator|=
name|hold_mips_optimize
expr_stmt|;
name|expr1
operator|.
name|X_add_number
operator|-=
literal|4
expr_stmt|;
name|relax_switch
argument_list|()
expr_stmt|;
name|offset_expr
operator|.
name|X_add_number
operator|=
name|expr1
operator|.
name|X_add_number
expr_stmt|;
if|if
condition|(
name|gpdelay
condition|)
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"nop"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|ADDRESS_LOAD_INSN
argument_list|,
literal|"t,o(b)"
argument_list|,
name|AT
argument_list|,
name|BFD_RELOC_MIPS_GOT16
argument_list|,
name|mips_gp_register
argument_list|)
expr_stmt|;
name|load_delay_nop
argument_list|()
expr_stmt|;
if|if
condition|(
name|breg
operator|!=
literal|0
condition|)
name|macro_build
argument_list|(
name|NULL
argument_list|,
name|ADDRESS_ADD_INSN
argument_list|,
literal|"d,v,t"
argument_list|,
name|AT
argument_list|,
name|breg
argument_list|,
name|AT
argument_list|)
expr_stmt|;
comment|/* Itbl support may require additional care here.  */
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|s
argument_list|,
name|fmt
argument_list|,
name|coproc
condition|?
name|treg
operator|+
literal|1
else|:
name|treg
argument_list|,
name|BFD_RELOC_LO16
argument_list|,
name|AT
argument_list|)
expr_stmt|;
name|offset_expr
operator|.
name|X_add_number
operator|+=
literal|4
expr_stmt|;
comment|/* Set mips_optimize to 2 to avoid inserting an undesired              nop.  */
name|hold_mips_optimize
operator|=
name|mips_optimize
expr_stmt|;
name|mips_optimize
operator|=
literal|2
expr_stmt|;
comment|/* Itbl support may require additional care here.  */
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|s
argument_list|,
name|fmt
argument_list|,
name|coproc
condition|?
name|treg
else|:
name|treg
operator|+
literal|1
argument_list|,
name|BFD_RELOC_LO16
argument_list|,
name|AT
argument_list|)
expr_stmt|;
name|mips_optimize
operator|=
name|hold_mips_optimize
expr_stmt|;
name|relax_end
argument_list|()
expr_stmt|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
break|break;
case|case
name|M_LD_OB
case|:
name|s
operator|=
literal|"lw"
expr_stmt|;
goto|goto
name|sd_ob
goto|;
case|case
name|M_SD_OB
case|:
name|s
operator|=
literal|"sw"
expr_stmt|;
name|sd_ob
label|:
name|assert
argument_list|(
name|HAVE_32BIT_ADDRESSES
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|s
argument_list|,
literal|"t,o(b)"
argument_list|,
name|treg
argument_list|,
name|BFD_RELOC_LO16
argument_list|,
name|breg
argument_list|)
expr_stmt|;
name|offset_expr
operator|.
name|X_add_number
operator|+=
literal|4
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|s
argument_list|,
literal|"t,o(b)"
argument_list|,
name|treg
operator|+
literal|1
argument_list|,
name|BFD_RELOC_LO16
argument_list|,
name|breg
argument_list|)
expr_stmt|;
break|break;
case|case
name|M_SAA_AB
case|:
name|s
operator|=
literal|"saa"
expr_stmt|;
goto|goto
name|saa_saad
goto|;
case|case
name|M_SAAD_AB
case|:
name|s
operator|=
literal|"saad"
expr_stmt|;
name|saa_saad
label|:
comment|/* The "saa/saad" instructions are new in CN58XX. These instructions 	 do not specify offset. When invoked with address or symbol, then 	 load the address or value of symbol in a register using the dla macro 	 into AT, and pass the register for emitting "saa/saad" instruction.  	 This will get expanded to  	    dla AT, constant/label 	    saa/saad $treg,(AT)  */
block|{
name|char
modifier|*
name|name
init|=
literal|"dla"
decl_stmt|;
name|char
modifier|*
name|fmt
init|=
literal|"t,A(b)"
decl_stmt|;
specifier|const
name|struct
name|mips_opcode
modifier|*
name|mo
decl_stmt|;
name|struct
name|mips_cl_insn
name|insn
decl_stmt|;
name|mo
operator|=
name|hash_find
argument_list|(
name|op_hash
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|mo
operator|->
name|name
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|strcmp
argument_list|(
name|fmt
argument_list|,
name|mo
operator|->
name|args
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|create_insn
argument_list|(
operator|&
name|insn
argument_list|,
name|mo
argument_list|)
expr_stmt|;
name|insn
operator|.
name|insn_opcode
operator|=
name|insn
operator|.
name|insn_mo
operator|->
name|match
expr_stmt|;
name|used_at
operator|=
literal|1
expr_stmt|;
name|INSERT_OPERAND
argument_list|(
name|RT
argument_list|,
name|insn
argument_list|,
name|AT
argument_list|)
expr_stmt|;
if|if
condition|(
name|breg
condition|)
name|INSERT_OPERAND
argument_list|(
name|RS
argument_list|,
name|insn
argument_list|,
name|breg
argument_list|)
expr_stmt|;
comment|/* The address part is forwarded through the global offset_expr. */
name|macro
argument_list|(
operator|&
name|insn
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
name|s
argument_list|,
literal|"t,(b)"
argument_list|,
name|treg
argument_list|,
name|AT
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* New code added to support COPZ instructions.       This code builds table entries out of the macros in mip_opcodes.       R4000 uses interlocks to handle coproc delays.       Other chips (like the R3000) require nops to be inserted for delays.        FIXME: Currently, we require that the user handle delays.       In order to fill delay slots for non-interlocked chips,       we must have a way to specify delays based on the coprocessor.       Eg. 4 cycles if load coproc reg from memory, 1 if in cache, etc.       What are the side-effects of the cop instruction?       What cache support might we have and what are its effects?       Both coprocessor& memory require delays. how long???       What registers are read/set/modified?        If an itbl is provided to interpret cop instructions,       this knowledge can be encoded in the itbl spec.  */
case|case
name|M_COP0
case|:
name|s
operator|=
literal|"c0"
expr_stmt|;
goto|goto
name|copz
goto|;
case|case
name|M_COP1
case|:
name|s
operator|=
literal|"c1"
expr_stmt|;
goto|goto
name|copz
goto|;
case|case
name|M_COP2
case|:
name|s
operator|=
literal|"c2"
expr_stmt|;
goto|goto
name|copz
goto|;
case|case
name|M_COP3
case|:
name|s
operator|=
literal|"c3"
expr_stmt|;
name|copz
label|:
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|s
argument_list|,
literal|"c2"
argument_list|)
operator|&&
name|mips_opts
operator|.
name|arch
operator|==
name|CPU_OCTEON
operator|&&
name|octeon_error_on_unsupported
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"opcode not implemented in Octeon `%s'"
argument_list|)
argument_list|,
name|ip
operator|->
name|insn_mo
operator|->
name|name
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* For now we just do C (same as Cz).  The parameter will be          stored in insn_opcode by mips_ip.  */
name|macro_build
argument_list|(
name|NULL
argument_list|,
name|s
argument_list|,
literal|"C"
argument_list|,
name|ip
operator|->
name|insn_opcode
argument_list|)
expr_stmt|;
break|break;
case|case
name|M_MOVE
case|:
name|move_register
argument_list|(
name|dreg
argument_list|,
name|sreg
argument_list|)
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|LOSING_COMPILER
default|default:
comment|/* Try and see if this is a new itbl instruction.          This code builds table entries out of the macros in mip_opcodes.          FIXME: For now we just assemble the expression and pass it's          value along as a 32-bit immediate.          We may want to have the assembler assemble this value,          so that we gain the assembler's knowledge of delay slots,          symbols, etc.          Would it be more efficient to use mask (id) here? */
if|if
condition|(
name|itbl_have_entries
operator|&&
operator|(
name|immed_expr
operator|=
name|itbl_assemble
argument_list|(
name|ip
operator|->
name|insn_mo
operator|->
name|name
argument_list|,
literal|""
argument_list|)
operator|)
condition|)
block|{
name|s
operator|=
name|ip
operator|->
name|insn_mo
operator|->
name|name
expr_stmt|;
name|s2
operator|=
literal|"cop3"
expr_stmt|;
name|coproc
operator|=
name|ITBL_DECODE_PNUM
argument_list|(
name|immed_expr
argument_list|)
expr_stmt|;
empty_stmt|;
name|macro_build
argument_list|(
operator|&
name|immed_expr
argument_list|,
name|s
argument_list|,
literal|"C"
argument_list|)
expr_stmt|;
break|break;
block|}
name|macro2
argument_list|(
name|ip
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|mips_opts
operator|.
name|noat
operator|&&
name|used_at
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Macro used $at after \".set noat\""
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|macro2
parameter_list|(
name|struct
name|mips_cl_insn
modifier|*
name|ip
parameter_list|)
block|{
name|int
name|treg
decl_stmt|,
name|sreg
decl_stmt|,
name|dreg
decl_stmt|,
name|breg
decl_stmt|;
name|int
name|tempreg
decl_stmt|;
name|int
name|mask
decl_stmt|;
name|int
name|used_at
decl_stmt|;
name|expressionS
name|expr1
decl_stmt|;
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
specifier|const
name|char
modifier|*
name|s2
decl_stmt|;
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
name|int
name|likely
init|=
literal|0
decl_stmt|;
name|int
name|dbl
init|=
literal|0
decl_stmt|;
name|int
name|coproc
init|=
literal|0
decl_stmt|;
name|int
name|lr
init|=
literal|0
decl_stmt|;
name|int
name|imm
init|=
literal|0
decl_stmt|;
name|int
name|off
decl_stmt|;
name|offsetT
name|maxnum
decl_stmt|;
name|bfd_reloc_code_real_type
name|r
decl_stmt|;
name|treg
operator|=
operator|(
name|ip
operator|->
name|insn_opcode
operator|>>
literal|16
operator|)
operator|&
literal|0x1f
expr_stmt|;
name|dreg
operator|=
operator|(
name|ip
operator|->
name|insn_opcode
operator|>>
literal|11
operator|)
operator|&
literal|0x1f
expr_stmt|;
name|sreg
operator|=
name|breg
operator|=
operator|(
name|ip
operator|->
name|insn_opcode
operator|>>
literal|21
operator|)
operator|&
literal|0x1f
expr_stmt|;
name|mask
operator|=
name|ip
operator|->
name|insn_mo
operator|->
name|mask
expr_stmt|;
name|expr1
operator|.
name|X_op
operator|=
name|O_constant
expr_stmt|;
name|expr1
operator|.
name|X_op_symbol
operator|=
name|NULL
expr_stmt|;
name|expr1
operator|.
name|X_add_symbol
operator|=
name|NULL
expr_stmt|;
name|expr1
operator|.
name|X_add_number
operator|=
literal|1
expr_stmt|;
switch|switch
condition|(
name|mask
condition|)
block|{
endif|#
directive|endif
comment|/* LOSING_COMPILER */
case|case
name|M_DMUL
case|:
name|dbl
operator|=
literal|1
expr_stmt|;
case|case
name|M_MUL
case|:
name|macro_build
argument_list|(
name|NULL
argument_list|,
name|dbl
condition|?
literal|"dmultu"
else|:
literal|"multu"
argument_list|,
literal|"s,t"
argument_list|,
name|sreg
argument_list|,
name|treg
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"mflo"
argument_list|,
literal|"d"
argument_list|,
name|dreg
argument_list|)
expr_stmt|;
break|break;
case|case
name|M_DMUL_I
case|:
name|dbl
operator|=
literal|1
expr_stmt|;
case|case
name|M_MUL_I
case|:
comment|/* The MIPS assembler some times generates shifts and adds.  I'm 	 not trying to be that fancy. GCC should do this for us 	 anyway.  */
name|used_at
operator|=
literal|1
expr_stmt|;
name|load_register
argument_list|(
name|AT
argument_list|,
operator|&
name|imm_expr
argument_list|,
name|dbl
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
name|dbl
condition|?
literal|"dmult"
else|:
literal|"mult"
argument_list|,
literal|"s,t"
argument_list|,
name|sreg
argument_list|,
name|AT
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"mflo"
argument_list|,
literal|"d"
argument_list|,
name|dreg
argument_list|)
expr_stmt|;
break|break;
case|case
name|M_DMULO_I
case|:
name|dbl
operator|=
literal|1
expr_stmt|;
case|case
name|M_MULO_I
case|:
name|imm
operator|=
literal|1
expr_stmt|;
goto|goto
name|do_mulo
goto|;
case|case
name|M_DMULO
case|:
name|dbl
operator|=
literal|1
expr_stmt|;
case|case
name|M_MULO
case|:
name|do_mulo
label|:
name|start_noreorder
argument_list|()
expr_stmt|;
name|used_at
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|imm
condition|)
name|load_register
argument_list|(
name|AT
argument_list|,
operator|&
name|imm_expr
argument_list|,
name|dbl
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
name|dbl
condition|?
literal|"dmult"
else|:
literal|"mult"
argument_list|,
literal|"s,t"
argument_list|,
name|sreg
argument_list|,
name|imm
condition|?
name|AT
else|:
name|treg
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"mflo"
argument_list|,
literal|"d"
argument_list|,
name|dreg
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
name|dbl
condition|?
literal|"dsra32"
else|:
literal|"sra"
argument_list|,
literal|"d,w,<"
argument_list|,
name|dreg
argument_list|,
name|dreg
argument_list|,
name|RA
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"mfhi"
argument_list|,
literal|"d"
argument_list|,
name|AT
argument_list|)
expr_stmt|;
if|if
condition|(
name|mips_trap
condition|)
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"tne"
argument_list|,
literal|"s,t,q"
argument_list|,
name|dreg
argument_list|,
name|AT
argument_list|,
literal|6
argument_list|)
expr_stmt|;
else|else
block|{
name|expr1
operator|.
name|X_add_number
operator|=
literal|8
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|expr1
argument_list|,
literal|"beq"
argument_list|,
literal|"s,t,p"
argument_list|,
name|dreg
argument_list|,
name|AT
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"nop"
argument_list|,
literal|""
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"break"
argument_list|,
literal|"c"
argument_list|,
literal|6
argument_list|)
expr_stmt|;
block|}
name|end_noreorder
argument_list|()
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"mflo"
argument_list|,
literal|"d"
argument_list|,
name|dreg
argument_list|)
expr_stmt|;
break|break;
case|case
name|M_DMULOU_I
case|:
name|dbl
operator|=
literal|1
expr_stmt|;
case|case
name|M_MULOU_I
case|:
name|imm
operator|=
literal|1
expr_stmt|;
goto|goto
name|do_mulou
goto|;
case|case
name|M_DMULOU
case|:
name|dbl
operator|=
literal|1
expr_stmt|;
case|case
name|M_MULOU
case|:
name|do_mulou
label|:
name|start_noreorder
argument_list|()
expr_stmt|;
name|used_at
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|imm
condition|)
name|load_register
argument_list|(
name|AT
argument_list|,
operator|&
name|imm_expr
argument_list|,
name|dbl
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
name|dbl
condition|?
literal|"dmultu"
else|:
literal|"multu"
argument_list|,
literal|"s,t"
argument_list|,
name|sreg
argument_list|,
name|imm
condition|?
name|AT
else|:
name|treg
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"mfhi"
argument_list|,
literal|"d"
argument_list|,
name|AT
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"mflo"
argument_list|,
literal|"d"
argument_list|,
name|dreg
argument_list|)
expr_stmt|;
if|if
condition|(
name|mips_trap
condition|)
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"tne"
argument_list|,
literal|"s,t,q"
argument_list|,
name|AT
argument_list|,
literal|0
argument_list|,
literal|6
argument_list|)
expr_stmt|;
else|else
block|{
name|expr1
operator|.
name|X_add_number
operator|=
literal|8
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|expr1
argument_list|,
literal|"beq"
argument_list|,
literal|"s,t,p"
argument_list|,
name|AT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"nop"
argument_list|,
literal|""
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"break"
argument_list|,
literal|"c"
argument_list|,
literal|6
argument_list|)
expr_stmt|;
block|}
name|end_noreorder
argument_list|()
expr_stmt|;
break|break;
case|case
name|M_DROL
case|:
if|if
condition|(
name|ISA_HAS_DROR
argument_list|(
name|mips_opts
operator|.
name|isa
argument_list|)
operator|||
name|CPU_HAS_DROR
argument_list|(
name|mips_opts
operator|.
name|arch
argument_list|)
condition|)
block|{
if|if
condition|(
name|dreg
operator|==
name|sreg
condition|)
block|{
name|tempreg
operator|=
name|AT
expr_stmt|;
name|used_at
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|tempreg
operator|=
name|dreg
expr_stmt|;
block|}
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"dnegu"
argument_list|,
literal|"d,w"
argument_list|,
name|tempreg
argument_list|,
name|treg
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"drorv"
argument_list|,
literal|"d,t,s"
argument_list|,
name|dreg
argument_list|,
name|sreg
argument_list|,
name|tempreg
argument_list|)
expr_stmt|;
break|break;
block|}
name|used_at
operator|=
literal|1
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"dsubu"
argument_list|,
literal|"d,v,t"
argument_list|,
name|AT
argument_list|,
literal|0
argument_list|,
name|treg
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"dsrlv"
argument_list|,
literal|"d,t,s"
argument_list|,
name|AT
argument_list|,
name|sreg
argument_list|,
name|AT
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"dsllv"
argument_list|,
literal|"d,t,s"
argument_list|,
name|dreg
argument_list|,
name|sreg
argument_list|,
name|treg
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"or"
argument_list|,
literal|"d,v,t"
argument_list|,
name|dreg
argument_list|,
name|dreg
argument_list|,
name|AT
argument_list|)
expr_stmt|;
break|break;
case|case
name|M_ROL
case|:
if|if
condition|(
name|ISA_HAS_ROR
argument_list|(
name|mips_opts
operator|.
name|isa
argument_list|)
operator|||
name|CPU_HAS_ROR
argument_list|(
name|mips_opts
operator|.
name|arch
argument_list|)
condition|)
block|{
if|if
condition|(
name|dreg
operator|==
name|sreg
condition|)
block|{
name|tempreg
operator|=
name|AT
expr_stmt|;
name|used_at
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|tempreg
operator|=
name|dreg
expr_stmt|;
block|}
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"negu"
argument_list|,
literal|"d,w"
argument_list|,
name|tempreg
argument_list|,
name|treg
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"rorv"
argument_list|,
literal|"d,t,s"
argument_list|,
name|dreg
argument_list|,
name|sreg
argument_list|,
name|tempreg
argument_list|)
expr_stmt|;
break|break;
block|}
name|used_at
operator|=
literal|1
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"subu"
argument_list|,
literal|"d,v,t"
argument_list|,
name|AT
argument_list|,
literal|0
argument_list|,
name|treg
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"srlv"
argument_list|,
literal|"d,t,s"
argument_list|,
name|AT
argument_list|,
name|sreg
argument_list|,
name|AT
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"sllv"
argument_list|,
literal|"d,t,s"
argument_list|,
name|dreg
argument_list|,
name|sreg
argument_list|,
name|treg
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"or"
argument_list|,
literal|"d,v,t"
argument_list|,
name|dreg
argument_list|,
name|dreg
argument_list|,
name|AT
argument_list|)
expr_stmt|;
break|break;
case|case
name|M_DROL_I
case|:
block|{
name|unsigned
name|int
name|rot
decl_stmt|;
name|char
modifier|*
name|l
decl_stmt|,
modifier|*
name|r
decl_stmt|;
if|if
condition|(
name|imm_expr
operator|.
name|X_op
operator|!=
name|O_constant
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Improper rotate count"
argument_list|)
argument_list|)
expr_stmt|;
name|rot
operator|=
name|imm_expr
operator|.
name|X_add_number
operator|&
literal|0x3f
expr_stmt|;
if|if
condition|(
name|ISA_HAS_DROR
argument_list|(
name|mips_opts
operator|.
name|isa
argument_list|)
operator|||
name|CPU_HAS_DROR
argument_list|(
name|mips_opts
operator|.
name|arch
argument_list|)
condition|)
block|{
name|rot
operator|=
operator|(
literal|64
operator|-
name|rot
operator|)
operator|&
literal|0x3f
expr_stmt|;
if|if
condition|(
name|rot
operator|>=
literal|32
condition|)
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"dror32"
argument_list|,
literal|"d,w,<"
argument_list|,
name|dreg
argument_list|,
name|sreg
argument_list|,
name|rot
operator|-
literal|32
argument_list|)
expr_stmt|;
else|else
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"dror"
argument_list|,
literal|"d,w,<"
argument_list|,
name|dreg
argument_list|,
name|sreg
argument_list|,
name|rot
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|rot
operator|==
literal|0
condition|)
block|{
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"dsrl"
argument_list|,
literal|"d,w,<"
argument_list|,
name|dreg
argument_list|,
name|sreg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
name|l
operator|=
operator|(
name|rot
operator|<
literal|0x20
operator|)
condition|?
literal|"dsll"
else|:
literal|"dsll32"
expr_stmt|;
name|r
operator|=
operator|(
operator|(
literal|0x40
operator|-
name|rot
operator|)
operator|<
literal|0x20
operator|)
condition|?
literal|"dsrl"
else|:
literal|"dsrl32"
expr_stmt|;
name|rot
operator|&=
literal|0x1f
expr_stmt|;
name|used_at
operator|=
literal|1
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
name|l
argument_list|,
literal|"d,w,<"
argument_list|,
name|AT
argument_list|,
name|sreg
argument_list|,
name|rot
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
name|r
argument_list|,
literal|"d,w,<"
argument_list|,
name|dreg
argument_list|,
name|sreg
argument_list|,
operator|(
literal|0x20
operator|-
name|rot
operator|)
operator|&
literal|0x1f
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"or"
argument_list|,
literal|"d,v,t"
argument_list|,
name|dreg
argument_list|,
name|dreg
argument_list|,
name|AT
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|M_ROL_I
case|:
block|{
name|unsigned
name|int
name|rot
decl_stmt|;
if|if
condition|(
name|imm_expr
operator|.
name|X_op
operator|!=
name|O_constant
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Improper rotate count"
argument_list|)
argument_list|)
expr_stmt|;
name|rot
operator|=
name|imm_expr
operator|.
name|X_add_number
operator|&
literal|0x1f
expr_stmt|;
if|if
condition|(
name|ISA_HAS_ROR
argument_list|(
name|mips_opts
operator|.
name|isa
argument_list|)
operator|||
name|CPU_HAS_ROR
argument_list|(
name|mips_opts
operator|.
name|arch
argument_list|)
condition|)
block|{
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"ror"
argument_list|,
literal|"d,w,<"
argument_list|,
name|dreg
argument_list|,
name|sreg
argument_list|,
operator|(
literal|32
operator|-
name|rot
operator|)
operator|&
literal|0x1f
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|rot
operator|==
literal|0
condition|)
block|{
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"srl"
argument_list|,
literal|"d,w,<"
argument_list|,
name|dreg
argument_list|,
name|sreg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
name|used_at
operator|=
literal|1
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"sll"
argument_list|,
literal|"d,w,<"
argument_list|,
name|AT
argument_list|,
name|sreg
argument_list|,
name|rot
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"srl"
argument_list|,
literal|"d,w,<"
argument_list|,
name|dreg
argument_list|,
name|sreg
argument_list|,
operator|(
literal|0x20
operator|-
name|rot
operator|)
operator|&
literal|0x1f
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"or"
argument_list|,
literal|"d,v,t"
argument_list|,
name|dreg
argument_list|,
name|dreg
argument_list|,
name|AT
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|M_DROR
case|:
if|if
condition|(
name|ISA_HAS_DROR
argument_list|(
name|mips_opts
operator|.
name|isa
argument_list|)
operator|||
name|CPU_HAS_DROR
argument_list|(
name|mips_opts
operator|.
name|arch
argument_list|)
condition|)
block|{
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"drorv"
argument_list|,
literal|"d,t,s"
argument_list|,
name|dreg
argument_list|,
name|sreg
argument_list|,
name|treg
argument_list|)
expr_stmt|;
break|break;
block|}
name|used_at
operator|=
literal|1
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"dsubu"
argument_list|,
literal|"d,v,t"
argument_list|,
name|AT
argument_list|,
literal|0
argument_list|,
name|treg
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"dsllv"
argument_list|,
literal|"d,t,s"
argument_list|,
name|AT
argument_list|,
name|sreg
argument_list|,
name|AT
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"dsrlv"
argument_list|,
literal|"d,t,s"
argument_list|,
name|dreg
argument_list|,
name|sreg
argument_list|,
name|treg
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"or"
argument_list|,
literal|"d,v,t"
argument_list|,
name|dreg
argument_list|,
name|dreg
argument_list|,
name|AT
argument_list|)
expr_stmt|;
break|break;
case|case
name|M_ROR
case|:
if|if
condition|(
name|ISA_HAS_ROR
argument_list|(
name|mips_opts
operator|.
name|isa
argument_list|)
operator|||
name|CPU_HAS_ROR
argument_list|(
name|mips_opts
operator|.
name|arch
argument_list|)
condition|)
block|{
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"rorv"
argument_list|,
literal|"d,t,s"
argument_list|,
name|dreg
argument_list|,
name|sreg
argument_list|,
name|treg
argument_list|)
expr_stmt|;
break|break;
block|}
name|used_at
operator|=
literal|1
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"subu"
argument_list|,
literal|"d,v,t"
argument_list|,
name|AT
argument_list|,
literal|0
argument_list|,
name|treg
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"sllv"
argument_list|,
literal|"d,t,s"
argument_list|,
name|AT
argument_list|,
name|sreg
argument_list|,
name|AT
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"srlv"
argument_list|,
literal|"d,t,s"
argument_list|,
name|dreg
argument_list|,
name|sreg
argument_list|,
name|treg
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"or"
argument_list|,
literal|"d,v,t"
argument_list|,
name|dreg
argument_list|,
name|dreg
argument_list|,
name|AT
argument_list|)
expr_stmt|;
break|break;
case|case
name|M_DROR_I
case|:
block|{
name|unsigned
name|int
name|rot
decl_stmt|;
name|char
modifier|*
name|l
decl_stmt|,
modifier|*
name|r
decl_stmt|;
if|if
condition|(
name|imm_expr
operator|.
name|X_op
operator|!=
name|O_constant
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Improper rotate count"
argument_list|)
argument_list|)
expr_stmt|;
name|rot
operator|=
name|imm_expr
operator|.
name|X_add_number
operator|&
literal|0x3f
expr_stmt|;
if|if
condition|(
name|ISA_HAS_DROR
argument_list|(
name|mips_opts
operator|.
name|isa
argument_list|)
operator|||
name|CPU_HAS_DROR
argument_list|(
name|mips_opts
operator|.
name|arch
argument_list|)
condition|)
block|{
if|if
condition|(
name|rot
operator|>=
literal|32
condition|)
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"dror32"
argument_list|,
literal|"d,w,<"
argument_list|,
name|dreg
argument_list|,
name|sreg
argument_list|,
name|rot
operator|-
literal|32
argument_list|)
expr_stmt|;
else|else
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"dror"
argument_list|,
literal|"d,w,<"
argument_list|,
name|dreg
argument_list|,
name|sreg
argument_list|,
name|rot
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|rot
operator|==
literal|0
condition|)
block|{
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"dsrl"
argument_list|,
literal|"d,w,<"
argument_list|,
name|dreg
argument_list|,
name|sreg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
name|r
operator|=
operator|(
name|rot
operator|<
literal|0x20
operator|)
condition|?
literal|"dsrl"
else|:
literal|"dsrl32"
expr_stmt|;
name|l
operator|=
operator|(
operator|(
literal|0x40
operator|-
name|rot
operator|)
operator|<
literal|0x20
operator|)
condition|?
literal|"dsll"
else|:
literal|"dsll32"
expr_stmt|;
name|rot
operator|&=
literal|0x1f
expr_stmt|;
name|used_at
operator|=
literal|1
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
name|r
argument_list|,
literal|"d,w,<"
argument_list|,
name|AT
argument_list|,
name|sreg
argument_list|,
name|rot
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
name|l
argument_list|,
literal|"d,w,<"
argument_list|,
name|dreg
argument_list|,
name|sreg
argument_list|,
operator|(
literal|0x20
operator|-
name|rot
operator|)
operator|&
literal|0x1f
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"or"
argument_list|,
literal|"d,v,t"
argument_list|,
name|dreg
argument_list|,
name|dreg
argument_list|,
name|AT
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|M_ROR_I
case|:
block|{
name|unsigned
name|int
name|rot
decl_stmt|;
if|if
condition|(
name|imm_expr
operator|.
name|X_op
operator|!=
name|O_constant
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Improper rotate count"
argument_list|)
argument_list|)
expr_stmt|;
name|rot
operator|=
name|imm_expr
operator|.
name|X_add_number
operator|&
literal|0x1f
expr_stmt|;
if|if
condition|(
name|ISA_HAS_ROR
argument_list|(
name|mips_opts
operator|.
name|isa
argument_list|)
operator|||
name|CPU_HAS_ROR
argument_list|(
name|mips_opts
operator|.
name|arch
argument_list|)
condition|)
block|{
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"ror"
argument_list|,
literal|"d,w,<"
argument_list|,
name|dreg
argument_list|,
name|sreg
argument_list|,
name|rot
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|rot
operator|==
literal|0
condition|)
block|{
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"srl"
argument_list|,
literal|"d,w,<"
argument_list|,
name|dreg
argument_list|,
name|sreg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
name|used_at
operator|=
literal|1
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"srl"
argument_list|,
literal|"d,w,<"
argument_list|,
name|AT
argument_list|,
name|sreg
argument_list|,
name|rot
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"sll"
argument_list|,
literal|"d,w,<"
argument_list|,
name|dreg
argument_list|,
name|sreg
argument_list|,
operator|(
literal|0x20
operator|-
name|rot
operator|)
operator|&
literal|0x1f
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"or"
argument_list|,
literal|"d,v,t"
argument_list|,
name|dreg
argument_list|,
name|dreg
argument_list|,
name|AT
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|M_S_DOB
case|:
if|if
condition|(
name|mips_opts
operator|.
name|arch
operator|==
name|CPU_R4650
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"opcode not supported on this processor"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|assert
argument_list|(
name|mips_opts
operator|.
name|isa
operator|==
name|ISA_MIPS1
argument_list|)
expr_stmt|;
comment|/* Even on a big endian machine $fn comes before $fn+1.  We have 	 to adjust when storing to memory.  */
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
literal|"swc1"
argument_list|,
literal|"T,o(b)"
argument_list|,
name|target_big_endian
condition|?
name|treg
operator|+
literal|1
else|:
name|treg
argument_list|,
name|BFD_RELOC_LO16
argument_list|,
name|breg
argument_list|)
expr_stmt|;
name|offset_expr
operator|.
name|X_add_number
operator|+=
literal|4
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
literal|"swc1"
argument_list|,
literal|"T,o(b)"
argument_list|,
name|target_big_endian
condition|?
name|treg
else|:
name|treg
operator|+
literal|1
argument_list|,
name|BFD_RELOC_LO16
argument_list|,
name|breg
argument_list|)
expr_stmt|;
break|break;
case|case
name|M_SEQ
case|:
if|if
condition|(
name|sreg
operator|==
literal|0
condition|)
name|macro_build
argument_list|(
operator|&
name|expr1
argument_list|,
literal|"sltiu"
argument_list|,
literal|"t,r,j"
argument_list|,
name|dreg
argument_list|,
name|treg
argument_list|,
name|BFD_RELOC_LO16
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|treg
operator|==
literal|0
condition|)
name|macro_build
argument_list|(
operator|&
name|expr1
argument_list|,
literal|"sltiu"
argument_list|,
literal|"t,r,j"
argument_list|,
name|dreg
argument_list|,
name|sreg
argument_list|,
name|BFD_RELOC_LO16
argument_list|)
expr_stmt|;
else|else
block|{
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"xor"
argument_list|,
literal|"d,v,t"
argument_list|,
name|dreg
argument_list|,
name|sreg
argument_list|,
name|treg
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|expr1
argument_list|,
literal|"sltiu"
argument_list|,
literal|"t,r,j"
argument_list|,
name|dreg
argument_list|,
name|dreg
argument_list|,
name|BFD_RELOC_LO16
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|M_SEQ_I
case|:
if|if
condition|(
name|imm_expr
operator|.
name|X_op
operator|==
name|O_constant
operator|&&
name|imm_expr
operator|.
name|X_add_number
operator|==
literal|0
condition|)
block|{
name|macro_build
argument_list|(
operator|&
name|expr1
argument_list|,
literal|"sltiu"
argument_list|,
literal|"t,r,j"
argument_list|,
name|dreg
argument_list|,
name|sreg
argument_list|,
name|BFD_RELOC_LO16
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|sreg
operator|==
literal|0
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"Instruction %s: result is always false"
argument_list|)
argument_list|,
name|ip
operator|->
name|insn_mo
operator|->
name|name
argument_list|)
expr_stmt|;
name|move_register
argument_list|(
name|dreg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|imm_expr
operator|.
name|X_op
operator|==
name|O_constant
operator|&&
name|imm_expr
operator|.
name|X_add_number
operator|>=
literal|0
operator|&&
name|imm_expr
operator|.
name|X_add_number
operator|<
literal|0x10000
condition|)
block|{
name|macro_build
argument_list|(
operator|&
name|imm_expr
argument_list|,
literal|"xori"
argument_list|,
literal|"t,r,i"
argument_list|,
name|dreg
argument_list|,
name|sreg
argument_list|,
name|BFD_RELOC_LO16
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|imm_expr
operator|.
name|X_op
operator|==
name|O_constant
operator|&&
name|imm_expr
operator|.
name|X_add_number
operator|>
operator|-
literal|0x8000
operator|&&
name|imm_expr
operator|.
name|X_add_number
operator|<
literal|0
condition|)
block|{
name|imm_expr
operator|.
name|X_add_number
operator|=
operator|-
name|imm_expr
operator|.
name|X_add_number
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|imm_expr
argument_list|,
name|HAVE_32BIT_GPRS
condition|?
literal|"addiu"
else|:
literal|"daddiu"
argument_list|,
literal|"t,r,j"
argument_list|,
name|dreg
argument_list|,
name|sreg
argument_list|,
name|BFD_RELOC_LO16
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|load_register
argument_list|(
name|AT
argument_list|,
operator|&
name|imm_expr
argument_list|,
name|HAVE_64BIT_GPRS
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"xor"
argument_list|,
literal|"d,v,t"
argument_list|,
name|dreg
argument_list|,
name|sreg
argument_list|,
name|AT
argument_list|)
expr_stmt|;
name|used_at
operator|=
literal|1
expr_stmt|;
block|}
name|macro_build
argument_list|(
operator|&
name|expr1
argument_list|,
literal|"sltiu"
argument_list|,
literal|"t,r,j"
argument_list|,
name|dreg
argument_list|,
name|dreg
argument_list|,
name|BFD_RELOC_LO16
argument_list|)
expr_stmt|;
break|break;
case|case
name|M_SGE
case|:
comment|/* sreg>= treg<==> not (sreg< treg) */
name|s
operator|=
literal|"slt"
expr_stmt|;
goto|goto
name|sge
goto|;
case|case
name|M_SGEU
case|:
name|s
operator|=
literal|"sltu"
expr_stmt|;
name|sge
label|:
name|macro_build
argument_list|(
name|NULL
argument_list|,
name|s
argument_list|,
literal|"d,v,t"
argument_list|,
name|dreg
argument_list|,
name|sreg
argument_list|,
name|treg
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|expr1
argument_list|,
literal|"xori"
argument_list|,
literal|"t,r,i"
argument_list|,
name|dreg
argument_list|,
name|dreg
argument_list|,
name|BFD_RELOC_LO16
argument_list|)
expr_stmt|;
break|break;
case|case
name|M_SGE_I
case|:
comment|/* sreg>= I<==> not (sreg< I) */
case|case
name|M_SGEU_I
case|:
if|if
condition|(
name|imm_expr
operator|.
name|X_op
operator|==
name|O_constant
operator|&&
name|imm_expr
operator|.
name|X_add_number
operator|>=
operator|-
literal|0x8000
operator|&&
name|imm_expr
operator|.
name|X_add_number
operator|<
literal|0x8000
condition|)
block|{
name|macro_build
argument_list|(
operator|&
name|imm_expr
argument_list|,
name|mask
operator|==
name|M_SGE_I
condition|?
literal|"slti"
else|:
literal|"sltiu"
argument_list|,
literal|"t,r,j"
argument_list|,
name|dreg
argument_list|,
name|sreg
argument_list|,
name|BFD_RELOC_LO16
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|load_register
argument_list|(
name|AT
argument_list|,
operator|&
name|imm_expr
argument_list|,
name|HAVE_64BIT_GPRS
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
name|mask
operator|==
name|M_SGE_I
condition|?
literal|"slt"
else|:
literal|"sltu"
argument_list|,
literal|"d,v,t"
argument_list|,
name|dreg
argument_list|,
name|sreg
argument_list|,
name|AT
argument_list|)
expr_stmt|;
name|used_at
operator|=
literal|1
expr_stmt|;
block|}
name|macro_build
argument_list|(
operator|&
name|expr1
argument_list|,
literal|"xori"
argument_list|,
literal|"t,r,i"
argument_list|,
name|dreg
argument_list|,
name|dreg
argument_list|,
name|BFD_RELOC_LO16
argument_list|)
expr_stmt|;
break|break;
case|case
name|M_SGT
case|:
comment|/* sreg> treg<==>  treg< sreg */
name|s
operator|=
literal|"slt"
expr_stmt|;
goto|goto
name|sgt
goto|;
case|case
name|M_SGTU
case|:
name|s
operator|=
literal|"sltu"
expr_stmt|;
name|sgt
label|:
name|macro_build
argument_list|(
name|NULL
argument_list|,
name|s
argument_list|,
literal|"d,v,t"
argument_list|,
name|dreg
argument_list|,
name|treg
argument_list|,
name|sreg
argument_list|)
expr_stmt|;
break|break;
case|case
name|M_SGT_I
case|:
comment|/* sreg> I<==>  I< sreg */
name|s
operator|=
literal|"slt"
expr_stmt|;
goto|goto
name|sgti
goto|;
case|case
name|M_SGTU_I
case|:
name|s
operator|=
literal|"sltu"
expr_stmt|;
name|sgti
label|:
name|used_at
operator|=
literal|1
expr_stmt|;
name|load_register
argument_list|(
name|AT
argument_list|,
operator|&
name|imm_expr
argument_list|,
name|HAVE_64BIT_GPRS
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
name|s
argument_list|,
literal|"d,v,t"
argument_list|,
name|dreg
argument_list|,
name|AT
argument_list|,
name|sreg
argument_list|)
expr_stmt|;
break|break;
case|case
name|M_SLE
case|:
comment|/* sreg<= treg<==>  treg>= sreg<==>  not (treg< sreg) */
name|s
operator|=
literal|"slt"
expr_stmt|;
goto|goto
name|sle
goto|;
case|case
name|M_SLEU
case|:
name|s
operator|=
literal|"sltu"
expr_stmt|;
name|sle
label|:
name|macro_build
argument_list|(
name|NULL
argument_list|,
name|s
argument_list|,
literal|"d,v,t"
argument_list|,
name|dreg
argument_list|,
name|treg
argument_list|,
name|sreg
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|expr1
argument_list|,
literal|"xori"
argument_list|,
literal|"t,r,i"
argument_list|,
name|dreg
argument_list|,
name|dreg
argument_list|,
name|BFD_RELOC_LO16
argument_list|)
expr_stmt|;
break|break;
case|case
name|M_SLE_I
case|:
comment|/* sreg<= I<==> I>= sreg<==> not (I< sreg) */
name|s
operator|=
literal|"slt"
expr_stmt|;
goto|goto
name|slei
goto|;
case|case
name|M_SLEU_I
case|:
name|s
operator|=
literal|"sltu"
expr_stmt|;
name|slei
label|:
name|used_at
operator|=
literal|1
expr_stmt|;
name|load_register
argument_list|(
name|AT
argument_list|,
operator|&
name|imm_expr
argument_list|,
name|HAVE_64BIT_GPRS
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
name|s
argument_list|,
literal|"d,v,t"
argument_list|,
name|dreg
argument_list|,
name|AT
argument_list|,
name|sreg
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|expr1
argument_list|,
literal|"xori"
argument_list|,
literal|"t,r,i"
argument_list|,
name|dreg
argument_list|,
name|dreg
argument_list|,
name|BFD_RELOC_LO16
argument_list|)
expr_stmt|;
break|break;
case|case
name|M_SLT_I
case|:
if|if
condition|(
name|imm_expr
operator|.
name|X_op
operator|==
name|O_constant
operator|&&
name|imm_expr
operator|.
name|X_add_number
operator|>=
operator|-
literal|0x8000
operator|&&
name|imm_expr
operator|.
name|X_add_number
operator|<
literal|0x8000
condition|)
block|{
name|macro_build
argument_list|(
operator|&
name|imm_expr
argument_list|,
literal|"slti"
argument_list|,
literal|"t,r,j"
argument_list|,
name|dreg
argument_list|,
name|sreg
argument_list|,
name|BFD_RELOC_LO16
argument_list|)
expr_stmt|;
break|break;
block|}
name|used_at
operator|=
literal|1
expr_stmt|;
name|load_register
argument_list|(
name|AT
argument_list|,
operator|&
name|imm_expr
argument_list|,
name|HAVE_64BIT_GPRS
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"slt"
argument_list|,
literal|"d,v,t"
argument_list|,
name|dreg
argument_list|,
name|sreg
argument_list|,
name|AT
argument_list|)
expr_stmt|;
break|break;
case|case
name|M_SLTU_I
case|:
if|if
condition|(
name|imm_expr
operator|.
name|X_op
operator|==
name|O_constant
operator|&&
name|imm_expr
operator|.
name|X_add_number
operator|>=
operator|-
literal|0x8000
operator|&&
name|imm_expr
operator|.
name|X_add_number
operator|<
literal|0x8000
condition|)
block|{
name|macro_build
argument_list|(
operator|&
name|imm_expr
argument_list|,
literal|"sltiu"
argument_list|,
literal|"t,r,j"
argument_list|,
name|dreg
argument_list|,
name|sreg
argument_list|,
name|BFD_RELOC_LO16
argument_list|)
expr_stmt|;
break|break;
block|}
name|used_at
operator|=
literal|1
expr_stmt|;
name|load_register
argument_list|(
name|AT
argument_list|,
operator|&
name|imm_expr
argument_list|,
name|HAVE_64BIT_GPRS
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"sltu"
argument_list|,
literal|"d,v,t"
argument_list|,
name|dreg
argument_list|,
name|sreg
argument_list|,
name|AT
argument_list|)
expr_stmt|;
break|break;
case|case
name|M_SNE
case|:
if|if
condition|(
name|sreg
operator|==
literal|0
condition|)
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"sltu"
argument_list|,
literal|"d,v,t"
argument_list|,
name|dreg
argument_list|,
literal|0
argument_list|,
name|treg
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|treg
operator|==
literal|0
condition|)
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"sltu"
argument_list|,
literal|"d,v,t"
argument_list|,
name|dreg
argument_list|,
literal|0
argument_list|,
name|sreg
argument_list|)
expr_stmt|;
else|else
block|{
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"xor"
argument_list|,
literal|"d,v,t"
argument_list|,
name|dreg
argument_list|,
name|sreg
argument_list|,
name|treg
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"sltu"
argument_list|,
literal|"d,v,t"
argument_list|,
name|dreg
argument_list|,
literal|0
argument_list|,
name|dreg
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|M_SNE_I
case|:
if|if
condition|(
name|imm_expr
operator|.
name|X_op
operator|==
name|O_constant
operator|&&
name|imm_expr
operator|.
name|X_add_number
operator|==
literal|0
condition|)
block|{
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"sltu"
argument_list|,
literal|"d,v,t"
argument_list|,
name|dreg
argument_list|,
literal|0
argument_list|,
name|sreg
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|sreg
operator|==
literal|0
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"Instruction %s: result is always true"
argument_list|)
argument_list|,
name|ip
operator|->
name|insn_mo
operator|->
name|name
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|expr1
argument_list|,
name|HAVE_32BIT_GPRS
condition|?
literal|"addiu"
else|:
literal|"daddiu"
argument_list|,
literal|"t,r,j"
argument_list|,
name|dreg
argument_list|,
literal|0
argument_list|,
name|BFD_RELOC_LO16
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|imm_expr
operator|.
name|X_op
operator|==
name|O_constant
operator|&&
name|imm_expr
operator|.
name|X_add_number
operator|>=
literal|0
operator|&&
name|imm_expr
operator|.
name|X_add_number
operator|<
literal|0x10000
condition|)
block|{
name|macro_build
argument_list|(
operator|&
name|imm_expr
argument_list|,
literal|"xori"
argument_list|,
literal|"t,r,i"
argument_list|,
name|dreg
argument_list|,
name|sreg
argument_list|,
name|BFD_RELOC_LO16
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|imm_expr
operator|.
name|X_op
operator|==
name|O_constant
operator|&&
name|imm_expr
operator|.
name|X_add_number
operator|>
operator|-
literal|0x8000
operator|&&
name|imm_expr
operator|.
name|X_add_number
operator|<
literal|0
condition|)
block|{
name|imm_expr
operator|.
name|X_add_number
operator|=
operator|-
name|imm_expr
operator|.
name|X_add_number
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|imm_expr
argument_list|,
name|HAVE_32BIT_GPRS
condition|?
literal|"addiu"
else|:
literal|"daddiu"
argument_list|,
literal|"t,r,j"
argument_list|,
name|dreg
argument_list|,
name|sreg
argument_list|,
name|BFD_RELOC_LO16
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|load_register
argument_list|(
name|AT
argument_list|,
operator|&
name|imm_expr
argument_list|,
name|HAVE_64BIT_GPRS
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"xor"
argument_list|,
literal|"d,v,t"
argument_list|,
name|dreg
argument_list|,
name|sreg
argument_list|,
name|AT
argument_list|)
expr_stmt|;
name|used_at
operator|=
literal|1
expr_stmt|;
block|}
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"sltu"
argument_list|,
literal|"d,v,t"
argument_list|,
name|dreg
argument_list|,
literal|0
argument_list|,
name|dreg
argument_list|)
expr_stmt|;
break|break;
case|case
name|M_DSUB_I
case|:
name|dbl
operator|=
literal|1
expr_stmt|;
case|case
name|M_SUB_I
case|:
if|if
condition|(
name|imm_expr
operator|.
name|X_op
operator|==
name|O_constant
operator|&&
name|imm_expr
operator|.
name|X_add_number
operator|>
operator|-
literal|0x8000
operator|&&
name|imm_expr
operator|.
name|X_add_number
operator|<=
literal|0x8000
condition|)
block|{
name|imm_expr
operator|.
name|X_add_number
operator|=
operator|-
name|imm_expr
operator|.
name|X_add_number
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|imm_expr
argument_list|,
name|dbl
condition|?
literal|"daddi"
else|:
literal|"addi"
argument_list|,
literal|"t,r,j"
argument_list|,
name|dreg
argument_list|,
name|sreg
argument_list|,
name|BFD_RELOC_LO16
argument_list|)
expr_stmt|;
break|break;
block|}
name|used_at
operator|=
literal|1
expr_stmt|;
name|load_register
argument_list|(
name|AT
argument_list|,
operator|&
name|imm_expr
argument_list|,
name|dbl
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
name|dbl
condition|?
literal|"dsub"
else|:
literal|"sub"
argument_list|,
literal|"d,v,t"
argument_list|,
name|dreg
argument_list|,
name|sreg
argument_list|,
name|AT
argument_list|)
expr_stmt|;
break|break;
case|case
name|M_DSUBU_I
case|:
name|dbl
operator|=
literal|1
expr_stmt|;
case|case
name|M_SUBU_I
case|:
if|if
condition|(
name|imm_expr
operator|.
name|X_op
operator|==
name|O_constant
operator|&&
name|imm_expr
operator|.
name|X_add_number
operator|>
operator|-
literal|0x8000
operator|&&
name|imm_expr
operator|.
name|X_add_number
operator|<=
literal|0x8000
condition|)
block|{
name|imm_expr
operator|.
name|X_add_number
operator|=
operator|-
name|imm_expr
operator|.
name|X_add_number
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|imm_expr
argument_list|,
name|dbl
condition|?
literal|"daddiu"
else|:
literal|"addiu"
argument_list|,
literal|"t,r,j"
argument_list|,
name|dreg
argument_list|,
name|sreg
argument_list|,
name|BFD_RELOC_LO16
argument_list|)
expr_stmt|;
break|break;
block|}
name|used_at
operator|=
literal|1
expr_stmt|;
name|load_register
argument_list|(
name|AT
argument_list|,
operator|&
name|imm_expr
argument_list|,
name|dbl
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
name|dbl
condition|?
literal|"dsubu"
else|:
literal|"subu"
argument_list|,
literal|"d,v,t"
argument_list|,
name|dreg
argument_list|,
name|sreg
argument_list|,
name|AT
argument_list|)
expr_stmt|;
break|break;
case|case
name|M_TEQ_I
case|:
name|s
operator|=
literal|"teq"
expr_stmt|;
goto|goto
name|trap
goto|;
case|case
name|M_TGE_I
case|:
name|s
operator|=
literal|"tge"
expr_stmt|;
goto|goto
name|trap
goto|;
case|case
name|M_TGEU_I
case|:
name|s
operator|=
literal|"tgeu"
expr_stmt|;
goto|goto
name|trap
goto|;
case|case
name|M_TLT_I
case|:
name|s
operator|=
literal|"tlt"
expr_stmt|;
goto|goto
name|trap
goto|;
case|case
name|M_TLTU_I
case|:
name|s
operator|=
literal|"tltu"
expr_stmt|;
goto|goto
name|trap
goto|;
case|case
name|M_TNE_I
case|:
name|s
operator|=
literal|"tne"
expr_stmt|;
name|trap
label|:
name|used_at
operator|=
literal|1
expr_stmt|;
name|load_register
argument_list|(
name|AT
argument_list|,
operator|&
name|imm_expr
argument_list|,
name|HAVE_64BIT_GPRS
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
name|s
argument_list|,
literal|"s,t"
argument_list|,
name|sreg
argument_list|,
name|AT
argument_list|)
expr_stmt|;
break|break;
case|case
name|M_TRUNCWS
case|:
case|case
name|M_TRUNCWD
case|:
if|if
condition|(
name|mips_opts
operator|.
name|arch
operator|==
name|CPU_OCTEON
operator|&&
name|octeon_error_on_unsupported
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"opcode not implemented in Octeon `%s'"
argument_list|)
argument_list|,
name|ip
operator|->
name|insn_mo
operator|->
name|name
argument_list|)
expr_stmt|;
return|return;
block|}
name|assert
argument_list|(
name|mips_opts
operator|.
name|isa
operator|==
name|ISA_MIPS1
argument_list|)
expr_stmt|;
name|used_at
operator|=
literal|1
expr_stmt|;
name|sreg
operator|=
operator|(
name|ip
operator|->
name|insn_opcode
operator|>>
literal|11
operator|)
operator|&
literal|0x1f
expr_stmt|;
comment|/* floating reg */
name|dreg
operator|=
operator|(
name|ip
operator|->
name|insn_opcode
operator|>>
literal|06
operator|)
operator|&
literal|0x1f
expr_stmt|;
comment|/* floating reg */
comment|/*        * Is the double cfc1 instruction a bug in the mips assembler;        * or is there a reason for it?        */
name|start_noreorder
argument_list|()
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"cfc1"
argument_list|,
literal|"t,G"
argument_list|,
name|treg
argument_list|,
name|RA
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"cfc1"
argument_list|,
literal|"t,G"
argument_list|,
name|treg
argument_list|,
name|RA
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"nop"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|expr1
operator|.
name|X_add_number
operator|=
literal|3
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|expr1
argument_list|,
literal|"ori"
argument_list|,
literal|"t,r,i"
argument_list|,
name|AT
argument_list|,
name|treg
argument_list|,
name|BFD_RELOC_LO16
argument_list|)
expr_stmt|;
name|expr1
operator|.
name|X_add_number
operator|=
literal|2
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|expr1
argument_list|,
literal|"xori"
argument_list|,
literal|"t,r,i"
argument_list|,
name|AT
argument_list|,
name|AT
argument_list|,
name|BFD_RELOC_LO16
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"ctc1"
argument_list|,
literal|"t,G"
argument_list|,
name|AT
argument_list|,
name|RA
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"nop"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
name|mask
operator|==
name|M_TRUNCWD
condition|?
literal|"cvt.w.d"
else|:
literal|"cvt.w.s"
argument_list|,
literal|"D,S"
argument_list|,
name|dreg
argument_list|,
name|sreg
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"ctc1"
argument_list|,
literal|"t,G"
argument_list|,
name|treg
argument_list|,
name|RA
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"nop"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|end_noreorder
argument_list|()
expr_stmt|;
break|break;
case|case
name|M_ULH
case|:
name|s
operator|=
literal|"lb"
expr_stmt|;
goto|goto
name|ulh
goto|;
case|case
name|M_ULHU
case|:
name|s
operator|=
literal|"lbu"
expr_stmt|;
name|ulh
label|:
name|used_at
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|offset_expr
operator|.
name|X_add_number
operator|>=
literal|0x7fff
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"operand overflow"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Expand the ulh to "lb, lbu, ins" instead of "lb, lbu, sll, ori". */
if|if
condition|(
operator|!
name|target_big_endian
condition|)
operator|++
name|offset_expr
operator|.
name|X_add_number
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|s
argument_list|,
literal|"t,o(b)"
argument_list|,
name|AT
argument_list|,
name|BFD_RELOC_LO16
argument_list|,
name|breg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|target_big_endian
condition|)
operator|--
name|offset_expr
operator|.
name|X_add_number
expr_stmt|;
else|else
operator|++
name|offset_expr
operator|.
name|X_add_number
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
literal|"lbu"
argument_list|,
literal|"t,o(b)"
argument_list|,
name|treg
argument_list|,
name|BFD_RELOC_LO16
argument_list|,
name|breg
argument_list|)
expr_stmt|;
if|if
condition|(
name|ISA_HAS_INS
argument_list|(
name|mips_opts
operator|.
name|isa
argument_list|)
condition|)
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"ins"
argument_list|,
literal|"t,r,+A,+B"
argument_list|,
name|treg
argument_list|,
name|AT
argument_list|,
literal|8
argument_list|,
literal|31
argument_list|)
expr_stmt|;
else|else
block|{
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"sll"
argument_list|,
literal|"d,w,<"
argument_list|,
name|AT
argument_list|,
name|AT
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"or"
argument_list|,
literal|"d,v,t"
argument_list|,
name|treg
argument_list|,
name|treg
argument_list|,
name|AT
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|M_ULD
case|:
name|s
operator|=
literal|"ldl"
expr_stmt|;
name|s2
operator|=
literal|"ldr"
expr_stmt|;
name|off
operator|=
literal|7
expr_stmt|;
goto|goto
name|ulw
goto|;
case|case
name|M_ULW
case|:
name|s
operator|=
literal|"lwl"
expr_stmt|;
name|s2
operator|=
literal|"lwr"
expr_stmt|;
name|off
operator|=
literal|3
expr_stmt|;
name|ulw
label|:
if|if
condition|(
name|offset_expr
operator|.
name|X_add_number
operator|>=
literal|0x8000
operator|-
name|off
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"operand overflow"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|treg
operator|!=
name|breg
condition|)
name|tempreg
operator|=
name|treg
expr_stmt|;
else|else
block|{
name|used_at
operator|=
literal|1
expr_stmt|;
name|tempreg
operator|=
name|AT
expr_stmt|;
block|}
comment|/* For small variables the compiler uses gp_rel to load the value of 	 the variables. While parsing instructions "uld $2,%gp_rel(var)($28)" 	 the offset_reloc[0] is set to BFD_RELOC_GPREL16. Use this relocation 	 type while emitting instructions otherwise use BFD_RELOC_LO16.  */
if|if
condition|(
name|offset_reloc
index|[
literal|0
index|]
operator|==
name|BFD_RELOC_UNUSED
condition|)
name|offset_reloc
index|[
literal|0
index|]
operator|=
name|BFD_RELOC_LO16
expr_stmt|;
if|if
condition|(
name|octeon_use_unalign
operator|&&
name|mips_opts
operator|.
name|arch
operator|==
name|CPU_OCTEON
condition|)
block|{
comment|/* Reset used_at as tempreg is not used while generating Octeon  	     unaligned load/store.  */
name|used_at
operator|=
literal|0
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
operator|(
name|mask
operator|==
name|M_ULW
condition|?
literal|"ulw"
else|:
literal|"uld"
operator|)
argument_list|,
literal|"t,o(b)"
argument_list|,
name|treg
argument_list|,
name|offset_reloc
index|[
literal|0
index|]
argument_list|,
name|breg
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|target_big_endian
condition|)
name|offset_expr
operator|.
name|X_add_number
operator|+=
name|off
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|s
argument_list|,
literal|"t,o(b)"
argument_list|,
name|tempreg
argument_list|,
name|offset_reloc
index|[
literal|0
index|]
argument_list|,
name|breg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|target_big_endian
condition|)
name|offset_expr
operator|.
name|X_add_number
operator|-=
name|off
expr_stmt|;
else|else
name|offset_expr
operator|.
name|X_add_number
operator|+=
name|off
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|s2
argument_list|,
literal|"t,o(b)"
argument_list|,
name|tempreg
argument_list|,
name|offset_reloc
index|[
literal|0
index|]
argument_list|,
name|breg
argument_list|)
expr_stmt|;
comment|/* If necessary, move the result in tempreg the final destination.  */
if|if
condition|(
name|treg
operator|==
name|tempreg
condition|)
break|break;
comment|/* Protect second load's delay slot.  */
name|load_delay_nop
argument_list|()
expr_stmt|;
name|move_register
argument_list|(
name|treg
argument_list|,
name|tempreg
argument_list|)
expr_stmt|;
break|break;
case|case
name|M_ULD_A
case|:
name|s
operator|=
literal|"ldl"
expr_stmt|;
name|s2
operator|=
literal|"ldr"
expr_stmt|;
name|off
operator|=
literal|7
expr_stmt|;
goto|goto
name|ulwa
goto|;
case|case
name|M_ULW_A
case|:
name|s
operator|=
literal|"lwl"
expr_stmt|;
name|s2
operator|=
literal|"lwr"
expr_stmt|;
name|off
operator|=
literal|3
expr_stmt|;
name|ulwa
label|:
name|used_at
operator|=
literal|1
expr_stmt|;
name|load_address
argument_list|(
name|AT
argument_list|,
operator|&
name|offset_expr
argument_list|,
operator|&
name|used_at
argument_list|)
expr_stmt|;
if|if
condition|(
name|breg
operator|!=
literal|0
condition|)
name|macro_build
argument_list|(
name|NULL
argument_list|,
name|ADDRESS_ADD_INSN
argument_list|,
literal|"d,v,t"
argument_list|,
name|AT
argument_list|,
name|AT
argument_list|,
name|breg
argument_list|)
expr_stmt|;
comment|/* For small variables the compiler uses gp_rel to load the value of 	 the variables. While parsing instructions "uld $2,%gp_rel(var)($28)" 	 the offset_reloc[0] is set to BFD_RELOC_GPREL16. Use this relocation 	 type while emitting instructions otherwise use BFD_RELOC_LO16.  */
if|if
condition|(
name|offset_reloc
index|[
literal|0
index|]
operator|==
name|BFD_RELOC_UNUSED
condition|)
name|offset_reloc
index|[
literal|0
index|]
operator|=
name|BFD_RELOC_LO16
expr_stmt|;
if|if
condition|(
name|octeon_use_unalign
operator|&&
name|mips_opts
operator|.
name|arch
operator|==
name|CPU_OCTEON
condition|)
block|{
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
operator|(
name|mask
operator|==
name|M_ULW_A
condition|?
literal|"ulw"
else|:
literal|"uld"
operator|)
argument_list|,
literal|"t,o(b)"
argument_list|,
name|treg
argument_list|,
name|offset_reloc
index|[
literal|0
index|]
argument_list|,
name|AT
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|target_big_endian
condition|)
name|expr1
operator|.
name|X_add_number
operator|=
name|off
expr_stmt|;
else|else
name|expr1
operator|.
name|X_add_number
operator|=
literal|0
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|expr1
argument_list|,
name|s
argument_list|,
literal|"t,o(b)"
argument_list|,
name|treg
argument_list|,
name|offset_reloc
index|[
literal|0
index|]
argument_list|,
name|AT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|target_big_endian
condition|)
name|expr1
operator|.
name|X_add_number
operator|=
literal|0
expr_stmt|;
else|else
name|expr1
operator|.
name|X_add_number
operator|=
name|off
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|expr1
argument_list|,
name|s2
argument_list|,
literal|"t,o(b)"
argument_list|,
name|treg
argument_list|,
name|offset_reloc
index|[
literal|0
index|]
argument_list|,
name|AT
argument_list|)
expr_stmt|;
break|break;
case|case
name|M_ULH_A
case|:
case|case
name|M_ULHU_A
case|:
name|used_at
operator|=
literal|1
expr_stmt|;
name|load_address
argument_list|(
name|AT
argument_list|,
operator|&
name|offset_expr
argument_list|,
operator|&
name|used_at
argument_list|)
expr_stmt|;
if|if
condition|(
name|breg
operator|!=
literal|0
condition|)
name|macro_build
argument_list|(
name|NULL
argument_list|,
name|ADDRESS_ADD_INSN
argument_list|,
literal|"d,v,t"
argument_list|,
name|AT
argument_list|,
name|AT
argument_list|,
name|breg
argument_list|)
expr_stmt|;
if|if
condition|(
name|ISA_HAS_INS
argument_list|(
name|mips_opts
operator|.
name|isa
argument_list|)
condition|)
block|{
if|if
condition|(
name|target_big_endian
condition|)
name|expr1
operator|.
name|X_add_number
operator|=
literal|1
expr_stmt|;
else|else
name|expr1
operator|.
name|X_add_number
operator|=
literal|0
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|expr1
argument_list|,
literal|"lbu"
argument_list|,
literal|"t,o(b)"
argument_list|,
name|treg
argument_list|,
name|BFD_RELOC_LO16
argument_list|,
name|AT
argument_list|)
expr_stmt|;
if|if
condition|(
name|target_big_endian
condition|)
name|expr1
operator|.
name|X_add_number
operator|=
literal|0
expr_stmt|;
else|else
name|expr1
operator|.
name|X_add_number
operator|=
literal|1
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|expr1
argument_list|,
name|mask
operator|==
name|M_ULH_A
condition|?
literal|"lb"
else|:
literal|"lbu"
argument_list|,
literal|"t,o(b)"
argument_list|,
name|AT
argument_list|,
name|BFD_RELOC_LO16
argument_list|,
name|AT
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"ins"
argument_list|,
literal|"t,r,+A,+B"
argument_list|,
name|treg
argument_list|,
name|AT
argument_list|,
literal|8
argument_list|,
literal|31
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|target_big_endian
condition|)
name|expr1
operator|.
name|X_add_number
operator|=
literal|0
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|expr1
argument_list|,
name|mask
operator|==
name|M_ULH_A
condition|?
literal|"lb"
else|:
literal|"lbu"
argument_list|,
literal|"t,o(b)"
argument_list|,
name|treg
argument_list|,
name|BFD_RELOC_LO16
argument_list|,
name|AT
argument_list|)
expr_stmt|;
if|if
condition|(
name|target_big_endian
condition|)
name|expr1
operator|.
name|X_add_number
operator|=
literal|1
expr_stmt|;
else|else
name|expr1
operator|.
name|X_add_number
operator|=
literal|0
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|expr1
argument_list|,
literal|"lbu"
argument_list|,
literal|"t,o(b)"
argument_list|,
name|AT
argument_list|,
name|BFD_RELOC_LO16
argument_list|,
name|AT
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"sll"
argument_list|,
literal|"d,w,<"
argument_list|,
name|treg
argument_list|,
name|treg
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"or"
argument_list|,
literal|"d,v,t"
argument_list|,
name|treg
argument_list|,
name|treg
argument_list|,
name|AT
argument_list|)
expr_stmt|;
break|break;
case|case
name|M_USH
case|:
name|used_at
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|offset_expr
operator|.
name|X_add_number
operator|>=
literal|0x7fff
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"operand overflow"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|target_big_endian
condition|)
operator|++
name|offset_expr
operator|.
name|X_add_number
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
literal|"sb"
argument_list|,
literal|"t,o(b)"
argument_list|,
name|treg
argument_list|,
name|BFD_RELOC_LO16
argument_list|,
name|breg
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"srl"
argument_list|,
literal|"d,w,<"
argument_list|,
name|AT
argument_list|,
name|treg
argument_list|,
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
name|target_big_endian
condition|)
operator|--
name|offset_expr
operator|.
name|X_add_number
expr_stmt|;
else|else
operator|++
name|offset_expr
operator|.
name|X_add_number
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
literal|"sb"
argument_list|,
literal|"t,o(b)"
argument_list|,
name|AT
argument_list|,
name|BFD_RELOC_LO16
argument_list|,
name|breg
argument_list|)
expr_stmt|;
break|break;
case|case
name|M_USD
case|:
name|s
operator|=
literal|"sdl"
expr_stmt|;
name|s2
operator|=
literal|"sdr"
expr_stmt|;
name|off
operator|=
literal|7
expr_stmt|;
goto|goto
name|usw
goto|;
case|case
name|M_USW
case|:
name|s
operator|=
literal|"swl"
expr_stmt|;
name|s2
operator|=
literal|"swr"
expr_stmt|;
name|off
operator|=
literal|3
expr_stmt|;
name|usw
label|:
if|if
condition|(
name|offset_expr
operator|.
name|X_add_number
operator|>=
literal|0x8000
operator|-
name|off
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"operand overflow"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* For small variables the compiler uses gp_rel to load the value of 	 the variables. While parsing instructions "uld $2,%gp_rel(var)($28)" 	 the offset_reloc[0] is set to BFD_RELOC_GPREL16. Use this relocation 	 type while emitting instructions otherwise use BFD_RELOC_LO16.  */
if|if
condition|(
name|offset_reloc
index|[
literal|0
index|]
operator|==
name|BFD_RELOC_UNUSED
condition|)
name|offset_reloc
index|[
literal|0
index|]
operator|=
name|BFD_RELOC_LO16
expr_stmt|;
if|if
condition|(
name|octeon_use_unalign
operator|&&
name|mips_opts
operator|.
name|arch
operator|==
name|CPU_OCTEON
condition|)
block|{
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
operator|(
name|mask
operator|==
name|M_USD
condition|?
literal|"usd"
else|:
literal|"usw"
operator|)
argument_list|,
literal|"t,o(b)"
argument_list|,
name|treg
argument_list|,
name|offset_reloc
index|[
literal|0
index|]
argument_list|,
name|breg
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|target_big_endian
condition|)
name|offset_expr
operator|.
name|X_add_number
operator|+=
name|off
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|s
argument_list|,
literal|"t,o(b)"
argument_list|,
name|treg
argument_list|,
name|offset_reloc
index|[
literal|0
index|]
argument_list|,
name|breg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|target_big_endian
condition|)
name|offset_expr
operator|.
name|X_add_number
operator|-=
name|off
expr_stmt|;
else|else
name|offset_expr
operator|.
name|X_add_number
operator|+=
name|off
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|s2
argument_list|,
literal|"t,o(b)"
argument_list|,
name|treg
argument_list|,
name|offset_reloc
index|[
literal|0
index|]
argument_list|,
name|breg
argument_list|)
expr_stmt|;
break|break;
case|case
name|M_USD_A
case|:
name|s
operator|=
literal|"sdl"
expr_stmt|;
name|s2
operator|=
literal|"sdr"
expr_stmt|;
name|off
operator|=
literal|7
expr_stmt|;
goto|goto
name|uswa
goto|;
case|case
name|M_USW_A
case|:
name|s
operator|=
literal|"swl"
expr_stmt|;
name|s2
operator|=
literal|"swr"
expr_stmt|;
name|off
operator|=
literal|3
expr_stmt|;
name|uswa
label|:
name|used_at
operator|=
literal|1
expr_stmt|;
name|load_address
argument_list|(
name|AT
argument_list|,
operator|&
name|offset_expr
argument_list|,
operator|&
name|used_at
argument_list|)
expr_stmt|;
if|if
condition|(
name|breg
operator|!=
literal|0
condition|)
name|macro_build
argument_list|(
name|NULL
argument_list|,
name|ADDRESS_ADD_INSN
argument_list|,
literal|"d,v,t"
argument_list|,
name|AT
argument_list|,
name|AT
argument_list|,
name|breg
argument_list|)
expr_stmt|;
comment|/* For small variables the compiler uses gp_rel to load the value of 	 the variables. While parsing instructions "uld $2,%gp_rel(var)($28)" 	 the offset_reloc[0] is set to BFD_RELOC_GPREL16. Use this relocation 	 type while emitting instructions otherwise use BFD_RELOC_LO16.  */
if|if
condition|(
name|offset_reloc
index|[
literal|0
index|]
operator|==
name|BFD_RELOC_UNUSED
condition|)
name|offset_reloc
index|[
literal|0
index|]
operator|=
name|BFD_RELOC_LO16
expr_stmt|;
if|if
condition|(
name|octeon_use_unalign
operator|&&
name|mips_opts
operator|.
name|arch
operator|==
name|CPU_OCTEON
condition|)
block|{
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
operator|(
name|mask
operator|==
name|M_USW_A
condition|?
literal|"usw"
else|:
literal|"usd"
operator|)
argument_list|,
literal|"t,o(b)"
argument_list|,
name|treg
argument_list|,
name|offset_reloc
index|[
literal|0
index|]
argument_list|,
name|AT
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|target_big_endian
condition|)
name|expr1
operator|.
name|X_add_number
operator|=
name|off
expr_stmt|;
else|else
name|expr1
operator|.
name|X_add_number
operator|=
literal|0
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|expr1
argument_list|,
name|s
argument_list|,
literal|"t,o(b)"
argument_list|,
name|treg
argument_list|,
name|offset_reloc
index|[
literal|0
index|]
argument_list|,
name|AT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|target_big_endian
condition|)
name|expr1
operator|.
name|X_add_number
operator|=
literal|0
expr_stmt|;
else|else
name|expr1
operator|.
name|X_add_number
operator|=
name|off
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|expr1
argument_list|,
name|s2
argument_list|,
literal|"t,o(b)"
argument_list|,
name|treg
argument_list|,
name|offset_reloc
index|[
literal|0
index|]
argument_list|,
name|AT
argument_list|)
expr_stmt|;
break|break;
case|case
name|M_USH_A
case|:
name|used_at
operator|=
literal|1
expr_stmt|;
name|load_address
argument_list|(
name|AT
argument_list|,
operator|&
name|offset_expr
argument_list|,
operator|&
name|used_at
argument_list|)
expr_stmt|;
if|if
condition|(
name|breg
operator|!=
literal|0
condition|)
name|macro_build
argument_list|(
name|NULL
argument_list|,
name|ADDRESS_ADD_INSN
argument_list|,
literal|"d,v,t"
argument_list|,
name|AT
argument_list|,
name|AT
argument_list|,
name|breg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|target_big_endian
condition|)
name|expr1
operator|.
name|X_add_number
operator|=
literal|0
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|expr1
argument_list|,
literal|"sb"
argument_list|,
literal|"t,o(b)"
argument_list|,
name|treg
argument_list|,
name|BFD_RELOC_LO16
argument_list|,
name|AT
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"srl"
argument_list|,
literal|"d,w,<"
argument_list|,
name|treg
argument_list|,
name|treg
argument_list|,
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|target_big_endian
condition|)
name|expr1
operator|.
name|X_add_number
operator|=
literal|1
expr_stmt|;
else|else
name|expr1
operator|.
name|X_add_number
operator|=
literal|0
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|expr1
argument_list|,
literal|"sb"
argument_list|,
literal|"t,o(b)"
argument_list|,
name|treg
argument_list|,
name|BFD_RELOC_LO16
argument_list|,
name|AT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|target_big_endian
condition|)
name|expr1
operator|.
name|X_add_number
operator|=
literal|0
expr_stmt|;
else|else
name|expr1
operator|.
name|X_add_number
operator|=
literal|1
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|expr1
argument_list|,
literal|"lbu"
argument_list|,
literal|"t,o(b)"
argument_list|,
name|AT
argument_list|,
name|BFD_RELOC_LO16
argument_list|,
name|AT
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"sll"
argument_list|,
literal|"d,w,<"
argument_list|,
name|treg
argument_list|,
name|treg
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"or"
argument_list|,
literal|"d,v,t"
argument_list|,
name|treg
argument_list|,
name|treg
argument_list|,
name|AT
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* FIXME: Check if this is one of the itbl macros, since they 	 are added dynamically.  */
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Macro %s not implemented yet"
argument_list|)
argument_list|,
name|ip
operator|->
name|insn_mo
operator|->
name|name
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|mips_opts
operator|.
name|noat
operator|&&
name|used_at
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Macro used $at after \".set noat\""
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Implement macros in mips16 mode.  */
end_comment

begin_function
specifier|static
name|void
name|mips16_macro
parameter_list|(
name|struct
name|mips_cl_insn
modifier|*
name|ip
parameter_list|)
block|{
name|int
name|mask
decl_stmt|;
name|int
name|xreg
decl_stmt|,
name|yreg
decl_stmt|,
name|zreg
decl_stmt|,
name|tmp
decl_stmt|;
name|expressionS
name|expr1
decl_stmt|;
name|int
name|dbl
decl_stmt|;
specifier|const
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|s2
decl_stmt|,
modifier|*
name|s3
decl_stmt|;
name|mask
operator|=
name|ip
operator|->
name|insn_mo
operator|->
name|mask
expr_stmt|;
name|xreg
operator|=
name|MIPS16_EXTRACT_OPERAND
argument_list|(
name|RX
argument_list|,
operator|*
name|ip
argument_list|)
expr_stmt|;
name|yreg
operator|=
name|MIPS16_EXTRACT_OPERAND
argument_list|(
name|RY
argument_list|,
operator|*
name|ip
argument_list|)
expr_stmt|;
name|zreg
operator|=
name|MIPS16_EXTRACT_OPERAND
argument_list|(
name|RZ
argument_list|,
operator|*
name|ip
argument_list|)
expr_stmt|;
name|expr1
operator|.
name|X_op
operator|=
name|O_constant
expr_stmt|;
name|expr1
operator|.
name|X_op_symbol
operator|=
name|NULL
expr_stmt|;
name|expr1
operator|.
name|X_add_symbol
operator|=
name|NULL
expr_stmt|;
name|expr1
operator|.
name|X_add_number
operator|=
literal|1
expr_stmt|;
name|dbl
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|mask
condition|)
block|{
default|default:
name|internalError
argument_list|()
expr_stmt|;
case|case
name|M_DDIV_3
case|:
name|dbl
operator|=
literal|1
expr_stmt|;
case|case
name|M_DIV_3
case|:
name|s
operator|=
literal|"mflo"
expr_stmt|;
goto|goto
name|do_div3
goto|;
case|case
name|M_DREM_3
case|:
name|dbl
operator|=
literal|1
expr_stmt|;
case|case
name|M_REM_3
case|:
name|s
operator|=
literal|"mfhi"
expr_stmt|;
name|do_div3
label|:
name|start_noreorder
argument_list|()
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
name|dbl
condition|?
literal|"ddiv"
else|:
literal|"div"
argument_list|,
literal|"0,x,y"
argument_list|,
name|xreg
argument_list|,
name|yreg
argument_list|)
expr_stmt|;
name|expr1
operator|.
name|X_add_number
operator|=
literal|2
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|expr1
argument_list|,
literal|"bnez"
argument_list|,
literal|"x,p"
argument_list|,
name|yreg
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"break"
argument_list|,
literal|"6"
argument_list|,
literal|7
argument_list|)
expr_stmt|;
comment|/* FIXME: The normal code checks for of -1 / -0x80000000 here,          since that causes an overflow.  We should do that as well,          but I don't see how to do the comparisons without a temporary          register.  */
name|end_noreorder
argument_list|()
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
name|s
argument_list|,
literal|"x"
argument_list|,
name|zreg
argument_list|)
expr_stmt|;
break|break;
case|case
name|M_DIVU_3
case|:
name|s
operator|=
literal|"divu"
expr_stmt|;
name|s2
operator|=
literal|"mflo"
expr_stmt|;
goto|goto
name|do_divu3
goto|;
case|case
name|M_REMU_3
case|:
name|s
operator|=
literal|"divu"
expr_stmt|;
name|s2
operator|=
literal|"mfhi"
expr_stmt|;
goto|goto
name|do_divu3
goto|;
case|case
name|M_DDIVU_3
case|:
name|s
operator|=
literal|"ddivu"
expr_stmt|;
name|s2
operator|=
literal|"mflo"
expr_stmt|;
goto|goto
name|do_divu3
goto|;
case|case
name|M_DREMU_3
case|:
name|s
operator|=
literal|"ddivu"
expr_stmt|;
name|s2
operator|=
literal|"mfhi"
expr_stmt|;
name|do_divu3
label|:
name|start_noreorder
argument_list|()
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
name|s
argument_list|,
literal|"0,x,y"
argument_list|,
name|xreg
argument_list|,
name|yreg
argument_list|)
expr_stmt|;
name|expr1
operator|.
name|X_add_number
operator|=
literal|2
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|expr1
argument_list|,
literal|"bnez"
argument_list|,
literal|"x,p"
argument_list|,
name|yreg
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"break"
argument_list|,
literal|"6"
argument_list|,
literal|7
argument_list|)
expr_stmt|;
name|end_noreorder
argument_list|()
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
name|s2
argument_list|,
literal|"x"
argument_list|,
name|zreg
argument_list|)
expr_stmt|;
break|break;
case|case
name|M_DMUL
case|:
name|dbl
operator|=
literal|1
expr_stmt|;
case|case
name|M_MUL
case|:
name|macro_build
argument_list|(
name|NULL
argument_list|,
name|dbl
condition|?
literal|"dmultu"
else|:
literal|"multu"
argument_list|,
literal|"x,y"
argument_list|,
name|xreg
argument_list|,
name|yreg
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"mflo"
argument_list|,
literal|"x"
argument_list|,
name|zreg
argument_list|)
expr_stmt|;
break|break;
case|case
name|M_DSUBU_I
case|:
name|dbl
operator|=
literal|1
expr_stmt|;
goto|goto
name|do_subu
goto|;
case|case
name|M_SUBU_I
case|:
name|do_subu
label|:
if|if
condition|(
name|imm_expr
operator|.
name|X_op
operator|!=
name|O_constant
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Unsupported large constant"
argument_list|)
argument_list|)
expr_stmt|;
name|imm_expr
operator|.
name|X_add_number
operator|=
operator|-
name|imm_expr
operator|.
name|X_add_number
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|imm_expr
argument_list|,
name|dbl
condition|?
literal|"daddiu"
else|:
literal|"addiu"
argument_list|,
literal|"y,x,4"
argument_list|,
name|yreg
argument_list|,
name|xreg
argument_list|)
expr_stmt|;
break|break;
case|case
name|M_SUBU_I_2
case|:
if|if
condition|(
name|imm_expr
operator|.
name|X_op
operator|!=
name|O_constant
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Unsupported large constant"
argument_list|)
argument_list|)
expr_stmt|;
name|imm_expr
operator|.
name|X_add_number
operator|=
operator|-
name|imm_expr
operator|.
name|X_add_number
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|imm_expr
argument_list|,
literal|"addiu"
argument_list|,
literal|"x,k"
argument_list|,
name|xreg
argument_list|)
expr_stmt|;
break|break;
case|case
name|M_DSUBU_I_2
case|:
if|if
condition|(
name|imm_expr
operator|.
name|X_op
operator|!=
name|O_constant
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Unsupported large constant"
argument_list|)
argument_list|)
expr_stmt|;
name|imm_expr
operator|.
name|X_add_number
operator|=
operator|-
name|imm_expr
operator|.
name|X_add_number
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|imm_expr
argument_list|,
literal|"daddiu"
argument_list|,
literal|"y,j"
argument_list|,
name|yreg
argument_list|)
expr_stmt|;
break|break;
case|case
name|M_BEQ
case|:
name|s
operator|=
literal|"cmp"
expr_stmt|;
name|s2
operator|=
literal|"bteqz"
expr_stmt|;
goto|goto
name|do_branch
goto|;
case|case
name|M_BNE
case|:
name|s
operator|=
literal|"cmp"
expr_stmt|;
name|s2
operator|=
literal|"btnez"
expr_stmt|;
goto|goto
name|do_branch
goto|;
case|case
name|M_BLT
case|:
name|s
operator|=
literal|"slt"
expr_stmt|;
name|s2
operator|=
literal|"btnez"
expr_stmt|;
goto|goto
name|do_branch
goto|;
case|case
name|M_BLTU
case|:
name|s
operator|=
literal|"sltu"
expr_stmt|;
name|s2
operator|=
literal|"btnez"
expr_stmt|;
goto|goto
name|do_branch
goto|;
case|case
name|M_BLE
case|:
name|s
operator|=
literal|"slt"
expr_stmt|;
name|s2
operator|=
literal|"bteqz"
expr_stmt|;
goto|goto
name|do_reverse_branch
goto|;
case|case
name|M_BLEU
case|:
name|s
operator|=
literal|"sltu"
expr_stmt|;
name|s2
operator|=
literal|"bteqz"
expr_stmt|;
goto|goto
name|do_reverse_branch
goto|;
case|case
name|M_BGE
case|:
name|s
operator|=
literal|"slt"
expr_stmt|;
name|s2
operator|=
literal|"bteqz"
expr_stmt|;
goto|goto
name|do_branch
goto|;
case|case
name|M_BGEU
case|:
name|s
operator|=
literal|"sltu"
expr_stmt|;
name|s2
operator|=
literal|"bteqz"
expr_stmt|;
goto|goto
name|do_branch
goto|;
case|case
name|M_BGT
case|:
name|s
operator|=
literal|"slt"
expr_stmt|;
name|s2
operator|=
literal|"btnez"
expr_stmt|;
goto|goto
name|do_reverse_branch
goto|;
case|case
name|M_BGTU
case|:
name|s
operator|=
literal|"sltu"
expr_stmt|;
name|s2
operator|=
literal|"btnez"
expr_stmt|;
name|do_reverse_branch
label|:
name|tmp
operator|=
name|xreg
expr_stmt|;
name|xreg
operator|=
name|yreg
expr_stmt|;
name|yreg
operator|=
name|tmp
expr_stmt|;
name|do_branch
label|:
name|macro_build
argument_list|(
name|NULL
argument_list|,
name|s
argument_list|,
literal|"x,y"
argument_list|,
name|xreg
argument_list|,
name|yreg
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|s2
argument_list|,
literal|"p"
argument_list|)
expr_stmt|;
break|break;
case|case
name|M_BEQ_I
case|:
name|s
operator|=
literal|"cmpi"
expr_stmt|;
name|s2
operator|=
literal|"bteqz"
expr_stmt|;
name|s3
operator|=
literal|"x,U"
expr_stmt|;
goto|goto
name|do_branch_i
goto|;
case|case
name|M_BNE_I
case|:
name|s
operator|=
literal|"cmpi"
expr_stmt|;
name|s2
operator|=
literal|"btnez"
expr_stmt|;
name|s3
operator|=
literal|"x,U"
expr_stmt|;
goto|goto
name|do_branch_i
goto|;
case|case
name|M_BLT_I
case|:
name|s
operator|=
literal|"slti"
expr_stmt|;
name|s2
operator|=
literal|"btnez"
expr_stmt|;
name|s3
operator|=
literal|"x,8"
expr_stmt|;
goto|goto
name|do_branch_i
goto|;
case|case
name|M_BLTU_I
case|:
name|s
operator|=
literal|"sltiu"
expr_stmt|;
name|s2
operator|=
literal|"btnez"
expr_stmt|;
name|s3
operator|=
literal|"x,8"
expr_stmt|;
goto|goto
name|do_branch_i
goto|;
case|case
name|M_BLE_I
case|:
name|s
operator|=
literal|"slti"
expr_stmt|;
name|s2
operator|=
literal|"btnez"
expr_stmt|;
name|s3
operator|=
literal|"x,8"
expr_stmt|;
goto|goto
name|do_addone_branch_i
goto|;
case|case
name|M_BLEU_I
case|:
name|s
operator|=
literal|"sltiu"
expr_stmt|;
name|s2
operator|=
literal|"btnez"
expr_stmt|;
name|s3
operator|=
literal|"x,8"
expr_stmt|;
goto|goto
name|do_addone_branch_i
goto|;
case|case
name|M_BGE_I
case|:
name|s
operator|=
literal|"slti"
expr_stmt|;
name|s2
operator|=
literal|"bteqz"
expr_stmt|;
name|s3
operator|=
literal|"x,8"
expr_stmt|;
goto|goto
name|do_branch_i
goto|;
case|case
name|M_BGEU_I
case|:
name|s
operator|=
literal|"sltiu"
expr_stmt|;
name|s2
operator|=
literal|"bteqz"
expr_stmt|;
name|s3
operator|=
literal|"x,8"
expr_stmt|;
goto|goto
name|do_branch_i
goto|;
case|case
name|M_BGT_I
case|:
name|s
operator|=
literal|"slti"
expr_stmt|;
name|s2
operator|=
literal|"bteqz"
expr_stmt|;
name|s3
operator|=
literal|"x,8"
expr_stmt|;
goto|goto
name|do_addone_branch_i
goto|;
case|case
name|M_BGTU_I
case|:
name|s
operator|=
literal|"sltiu"
expr_stmt|;
name|s2
operator|=
literal|"bteqz"
expr_stmt|;
name|s3
operator|=
literal|"x,8"
expr_stmt|;
name|do_addone_branch_i
label|:
if|if
condition|(
name|imm_expr
operator|.
name|X_op
operator|!=
name|O_constant
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Unsupported large constant"
argument_list|)
argument_list|)
expr_stmt|;
operator|++
name|imm_expr
operator|.
name|X_add_number
expr_stmt|;
name|do_branch_i
label|:
name|macro_build
argument_list|(
operator|&
name|imm_expr
argument_list|,
name|s
argument_list|,
name|s3
argument_list|,
name|xreg
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|s2
argument_list|,
literal|"p"
argument_list|)
expr_stmt|;
break|break;
case|case
name|M_ABS
case|:
name|expr1
operator|.
name|X_add_number
operator|=
literal|0
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|expr1
argument_list|,
literal|"slti"
argument_list|,
literal|"x,8"
argument_list|,
name|yreg
argument_list|)
expr_stmt|;
if|if
condition|(
name|xreg
operator|!=
name|yreg
condition|)
name|move_register
argument_list|(
name|xreg
argument_list|,
name|yreg
argument_list|)
expr_stmt|;
name|expr1
operator|.
name|X_add_number
operator|=
literal|2
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|expr1
argument_list|,
literal|"bteqz"
argument_list|,
literal|"p"
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"neg"
argument_list|,
literal|"x,w"
argument_list|,
name|xreg
argument_list|,
name|xreg
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* For consistency checking, verify that all bits are specified either    by the match/mask part of the instruction definition, or by the    operand list.  */
end_comment

begin_function
specifier|static
name|int
name|validate_mips_insn
parameter_list|(
specifier|const
name|struct
name|mips_opcode
modifier|*
name|opc
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|p
init|=
name|opc
operator|->
name|args
decl_stmt|;
name|char
name|c
decl_stmt|;
name|unsigned
name|long
name|used_bits
init|=
name|opc
operator|->
name|mask
decl_stmt|;
if|if
condition|(
operator|(
name|used_bits
operator|&
name|opc
operator|->
name|match
operator|)
operator|!=
name|opc
operator|->
name|match
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"internal: bad mips opcode (mask error): %s %s"
argument_list|)
argument_list|,
name|opc
operator|->
name|name
argument_list|,
name|opc
operator|->
name|args
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
define|#
directive|define
name|USE_BITS
parameter_list|(
name|mask
parameter_list|,
name|shift
parameter_list|)
value|(used_bits |= ((mask)<< (shift)))
while|while
condition|(
operator|*
name|p
condition|)
switch|switch
condition|(
name|c
operator|=
operator|*
name|p
operator|++
condition|)
block|{
case|case
literal|','
case|:
break|break;
case|case
literal|'('
case|:
break|break;
case|case
literal|')'
case|:
break|break;
case|case
literal|'^'
case|:
name|USE_BITS
argument_list|(
name|OP_MASK_BITIND
argument_list|,
name|OP_SH_BITIND
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'~'
case|:
name|USE_BITS
argument_list|(
name|OP_MASK_BITIND
argument_list|,
name|OP_SH_BITIND
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'+'
case|:
switch|switch
condition|(
name|c
operator|=
operator|*
name|p
operator|++
condition|)
block|{
case|case
literal|'1'
case|:
name|USE_BITS
argument_list|(
name|OP_MASK_UDI1
argument_list|,
name|OP_SH_UDI1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'2'
case|:
name|USE_BITS
argument_list|(
name|OP_MASK_UDI2
argument_list|,
name|OP_SH_UDI2
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'3'
case|:
name|USE_BITS
argument_list|(
name|OP_MASK_UDI3
argument_list|,
name|OP_SH_UDI3
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'4'
case|:
name|USE_BITS
argument_list|(
name|OP_MASK_UDI4
argument_list|,
name|OP_SH_UDI4
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'A'
case|:
name|USE_BITS
argument_list|(
name|OP_MASK_SHAMT
argument_list|,
name|OP_SH_SHAMT
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'B'
case|:
name|USE_BITS
argument_list|(
name|OP_MASK_INSMSB
argument_list|,
name|OP_SH_INSMSB
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'C'
case|:
name|USE_BITS
argument_list|(
name|OP_MASK_EXTMSBD
argument_list|,
name|OP_SH_EXTMSBD
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
name|USE_BITS
argument_list|(
name|OP_MASK_RD
argument_list|,
name|OP_SH_RD
argument_list|)
expr_stmt|;
name|USE_BITS
argument_list|(
name|OP_MASK_SEL
argument_list|,
name|OP_SH_SEL
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'E'
case|:
name|USE_BITS
argument_list|(
name|OP_MASK_SHAMT
argument_list|,
name|OP_SH_SHAMT
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'F'
case|:
name|USE_BITS
argument_list|(
name|OP_MASK_INSMSB
argument_list|,
name|OP_SH_INSMSB
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'G'
case|:
name|USE_BITS
argument_list|(
name|OP_MASK_EXTMSBD
argument_list|,
name|OP_SH_EXTMSBD
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'H'
case|:
name|USE_BITS
argument_list|(
name|OP_MASK_EXTMSBD
argument_list|,
name|OP_SH_EXTMSBD
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'I'
case|:
break|break;
case|case
literal|'t'
case|:
name|USE_BITS
argument_list|(
name|OP_MASK_RT
argument_list|,
name|OP_SH_RT
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'T'
case|:
name|USE_BITS
argument_list|(
name|OP_MASK_RT
argument_list|,
name|OP_SH_RT
argument_list|)
expr_stmt|;
name|USE_BITS
argument_list|(
name|OP_MASK_SEL
argument_list|,
name|OP_SH_SEL
argument_list|)
expr_stmt|;
break|break;
default|default:
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"internal: bad mips opcode (unknown extension operand type `+%c'): %s %s"
argument_list|)
argument_list|,
name|c
argument_list|,
name|opc
operator|->
name|name
argument_list|,
name|opc
operator|->
name|args
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
break|break;
case|case
literal|'<'
case|:
name|USE_BITS
argument_list|(
name|OP_MASK_SHAMT
argument_list|,
name|OP_SH_SHAMT
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'>'
case|:
name|USE_BITS
argument_list|(
name|OP_MASK_SHAMT
argument_list|,
name|OP_SH_SHAMT
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'A'
case|:
break|break;
case|case
literal|'B'
case|:
name|USE_BITS
argument_list|(
name|OP_MASK_CODE20
argument_list|,
name|OP_SH_CODE20
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'C'
case|:
name|USE_BITS
argument_list|(
name|OP_MASK_COPZ
argument_list|,
name|OP_SH_COPZ
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
name|USE_BITS
argument_list|(
name|OP_MASK_FD
argument_list|,
name|OP_SH_FD
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'E'
case|:
name|USE_BITS
argument_list|(
name|OP_MASK_RT
argument_list|,
name|OP_SH_RT
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'F'
case|:
break|break;
case|case
literal|'G'
case|:
name|USE_BITS
argument_list|(
name|OP_MASK_RD
argument_list|,
name|OP_SH_RD
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'H'
case|:
name|USE_BITS
argument_list|(
name|OP_MASK_SEL
argument_list|,
name|OP_SH_SEL
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'I'
case|:
break|break;
case|case
literal|'J'
case|:
name|USE_BITS
argument_list|(
name|OP_MASK_CODE19
argument_list|,
name|OP_SH_CODE19
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'K'
case|:
name|USE_BITS
argument_list|(
name|OP_MASK_RD
argument_list|,
name|OP_SH_RD
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'L'
case|:
break|break;
case|case
literal|'M'
case|:
name|USE_BITS
argument_list|(
name|OP_MASK_CCC
argument_list|,
name|OP_SH_CCC
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'N'
case|:
name|USE_BITS
argument_list|(
name|OP_MASK_BCC
argument_list|,
name|OP_SH_BCC
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'O'
case|:
name|USE_BITS
argument_list|(
name|OP_MASK_ALN
argument_list|,
name|OP_SH_ALN
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'Q'
case|:
name|USE_BITS
argument_list|(
name|OP_MASK_VSEL
argument_list|,
name|OP_SH_VSEL
argument_list|)
expr_stmt|;
name|USE_BITS
argument_list|(
name|OP_MASK_FT
argument_list|,
name|OP_SH_FT
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'R'
case|:
name|USE_BITS
argument_list|(
name|OP_MASK_FR
argument_list|,
name|OP_SH_FR
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
name|USE_BITS
argument_list|(
name|OP_MASK_FS
argument_list|,
name|OP_SH_FS
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'T'
case|:
name|USE_BITS
argument_list|(
name|OP_MASK_FT
argument_list|,
name|OP_SH_FT
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'V'
case|:
name|USE_BITS
argument_list|(
name|OP_MASK_FS
argument_list|,
name|OP_SH_FS
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'W'
case|:
name|USE_BITS
argument_list|(
name|OP_MASK_FT
argument_list|,
name|OP_SH_FT
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'X'
case|:
name|USE_BITS
argument_list|(
name|OP_MASK_FD
argument_list|,
name|OP_SH_FD
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'Y'
case|:
name|USE_BITS
argument_list|(
name|OP_MASK_FS
argument_list|,
name|OP_SH_FS
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'Z'
case|:
name|USE_BITS
argument_list|(
name|OP_MASK_FT
argument_list|,
name|OP_SH_FT
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
name|USE_BITS
argument_list|(
name|OP_MASK_TARGET
argument_list|,
name|OP_SH_TARGET
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
name|USE_BITS
argument_list|(
name|OP_MASK_RS
argument_list|,
name|OP_SH_RS
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|USE_BITS
argument_list|(
name|OP_MASK_CODE
argument_list|,
name|OP_SH_CODE
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|USE_BITS
argument_list|(
name|OP_MASK_RD
argument_list|,
name|OP_SH_RD
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
break|break;
case|case
literal|'h'
case|:
name|USE_BITS
argument_list|(
name|OP_MASK_PREFX
argument_list|,
name|OP_SH_PREFX
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
name|USE_BITS
argument_list|(
name|OP_MASK_IMMEDIATE
argument_list|,
name|OP_SH_IMMEDIATE
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'j'
case|:
name|USE_BITS
argument_list|(
name|OP_MASK_DELTA
argument_list|,
name|OP_SH_DELTA
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'k'
case|:
name|USE_BITS
argument_list|(
name|OP_MASK_CACHE
argument_list|,
name|OP_SH_CACHE
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
break|break;
case|case
literal|'o'
case|:
name|USE_BITS
argument_list|(
name|OP_MASK_DELTA
argument_list|,
name|OP_SH_DELTA
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|USE_BITS
argument_list|(
name|OP_MASK_DELTA
argument_list|,
name|OP_SH_DELTA
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'q'
case|:
name|USE_BITS
argument_list|(
name|OP_MASK_CODE2
argument_list|,
name|OP_SH_CODE2
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|USE_BITS
argument_list|(
name|OP_MASK_RS
argument_list|,
name|OP_SH_RS
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|USE_BITS
argument_list|(
name|OP_MASK_RS
argument_list|,
name|OP_SH_RS
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|USE_BITS
argument_list|(
name|OP_MASK_RT
argument_list|,
name|OP_SH_RT
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
name|USE_BITS
argument_list|(
name|OP_MASK_IMMEDIATE
argument_list|,
name|OP_SH_IMMEDIATE
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
name|USE_BITS
argument_list|(
name|OP_MASK_RS
argument_list|,
name|OP_SH_RS
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
name|USE_BITS
argument_list|(
name|OP_MASK_RT
argument_list|,
name|OP_SH_RT
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
break|break;
case|case
literal|'y'
case|:
name|USE_BITS
argument_list|(
name|OP_MASK_CODE2
argument_list|,
name|OP_SH_CODE2
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'z'
case|:
break|break;
case|case
literal|'P'
case|:
name|USE_BITS
argument_list|(
name|OP_MASK_PERFREG
argument_list|,
name|OP_SH_PERFREG
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'U'
case|:
name|USE_BITS
argument_list|(
name|OP_MASK_RD
argument_list|,
name|OP_SH_RD
argument_list|)
expr_stmt|;
name|USE_BITS
argument_list|(
name|OP_MASK_RT
argument_list|,
name|OP_SH_RT
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
name|USE_BITS
argument_list|(
name|OP_MASK_VECBYTE
argument_list|,
name|OP_SH_VECBYTE
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'%'
case|:
name|USE_BITS
argument_list|(
name|OP_MASK_VECALIGN
argument_list|,
name|OP_SH_VECALIGN
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'['
case|:
break|break;
case|case
literal|']'
case|:
break|break;
case|case
literal|'2'
case|:
name|USE_BITS
argument_list|(
name|OP_MASK_BP
argument_list|,
name|OP_SH_BP
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'3'
case|:
name|USE_BITS
argument_list|(
name|OP_MASK_SA3
argument_list|,
name|OP_SH_SA3
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'4'
case|:
name|USE_BITS
argument_list|(
name|OP_MASK_SA4
argument_list|,
name|OP_SH_SA4
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'5'
case|:
name|USE_BITS
argument_list|(
name|OP_MASK_IMM8
argument_list|,
name|OP_SH_IMM8
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'6'
case|:
name|USE_BITS
argument_list|(
name|OP_MASK_RS
argument_list|,
name|OP_SH_RS
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'7'
case|:
name|USE_BITS
argument_list|(
name|OP_MASK_DSPACC
argument_list|,
name|OP_SH_DSPACC
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'8'
case|:
name|USE_BITS
argument_list|(
name|OP_MASK_WRDSP
argument_list|,
name|OP_SH_WRDSP
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'9'
case|:
name|USE_BITS
argument_list|(
name|OP_MASK_DSPACC_S
argument_list|,
name|OP_SH_DSPACC_S
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'0'
case|:
name|USE_BITS
argument_list|(
name|OP_MASK_DSPSFT
argument_list|,
name|OP_SH_DSPSFT
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\''
case|:
name|USE_BITS
argument_list|(
name|OP_MASK_RDDSP
argument_list|,
name|OP_SH_RDDSP
argument_list|)
expr_stmt|;
break|break;
case|case
literal|':'
case|:
name|USE_BITS
argument_list|(
name|OP_MASK_DSPSFT_7
argument_list|,
name|OP_SH_DSPSFT_7
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'@'
case|:
name|USE_BITS
argument_list|(
name|OP_MASK_IMM10
argument_list|,
name|OP_SH_IMM10
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'!'
case|:
name|USE_BITS
argument_list|(
name|OP_MASK_MT_U
argument_list|,
name|OP_SH_MT_U
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'$'
case|:
name|USE_BITS
argument_list|(
name|OP_MASK_MT_H
argument_list|,
name|OP_SH_MT_H
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'*'
case|:
name|USE_BITS
argument_list|(
name|OP_MASK_MTACC_T
argument_list|,
name|OP_SH_MTACC_T
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'&'
case|:
name|USE_BITS
argument_list|(
name|OP_MASK_MTACC_D
argument_list|,
name|OP_SH_MTACC_D
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'g'
case|:
name|USE_BITS
argument_list|(
name|OP_MASK_RD
argument_list|,
name|OP_SH_RD
argument_list|)
expr_stmt|;
break|break;
default|default:
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"internal: bad mips opcode (unknown operand type `%c'): %s %s"
argument_list|)
argument_list|,
name|c
argument_list|,
name|opc
operator|->
name|name
argument_list|,
name|opc
operator|->
name|args
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
undef|#
directive|undef
name|USE_BITS
if|if
condition|(
name|used_bits
operator|!=
literal|0xffffffff
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"internal: bad mips opcode (bits 0x%lx undefined): %s %s"
argument_list|)
argument_list|,
operator|~
name|used_bits
operator|&
literal|0xffffffff
argument_list|,
name|opc
operator|->
name|name
argument_list|,
name|opc
operator|->
name|args
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* UDI immediates.  */
end_comment

begin_struct
struct|struct
name|mips_immed
block|{
name|char
name|type
decl_stmt|;
name|unsigned
name|int
name|shift
decl_stmt|;
name|unsigned
name|long
name|mask
decl_stmt|;
specifier|const
name|char
modifier|*
name|desc
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|mips_immed
name|mips_immed
index|[]
init|=
block|{
block|{
literal|'1'
block|,
name|OP_SH_UDI1
block|,
name|OP_MASK_UDI1
block|,
literal|0
block|}
block|,
block|{
literal|'2'
block|,
name|OP_SH_UDI2
block|,
name|OP_MASK_UDI2
block|,
literal|0
block|}
block|,
block|{
literal|'3'
block|,
name|OP_SH_UDI3
block|,
name|OP_MASK_UDI3
block|,
literal|0
block|}
block|,
block|{
literal|'4'
block|,
name|OP_SH_UDI4
block|,
name|OP_MASK_UDI4
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Check whether an odd floating-point register is allowed.  */
end_comment

begin_function
specifier|static
name|int
name|mips_oddfpreg_ok
parameter_list|(
specifier|const
name|struct
name|mips_opcode
modifier|*
name|insn
parameter_list|,
name|int
name|argnum
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|s
init|=
name|insn
operator|->
name|name
decl_stmt|;
if|if
condition|(
name|insn
operator|->
name|pinfo
operator|==
name|INSN_MACRO
condition|)
comment|/* Let a macro pass, we'll catch it later when it is expanded.  */
return|return
literal|1
return|;
if|if
condition|(
name|ISA_HAS_ODD_SINGLE_FPR
argument_list|(
name|mips_opts
operator|.
name|isa
argument_list|)
condition|)
block|{
comment|/* Allow odd registers for single-precision ops.  */
switch|switch
condition|(
name|insn
operator|->
name|pinfo
operator|&
operator|(
name|FP_S
operator||
name|FP_D
operator|)
condition|)
block|{
case|case
name|FP_S
case|:
case|case
literal|0
case|:
return|return
literal|1
return|;
comment|/* both single precision - ok */
case|case
name|FP_D
case|:
return|return
literal|0
return|;
comment|/* both double precision - fail */
default|default:
break|break;
block|}
comment|/* Cvt.w.x and cvt.x.w allow an odd register for a 'w' or 's' operand.  */
name|s
operator|=
name|strchr
argument_list|(
name|insn
operator|->
name|name
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
if|if
condition|(
name|argnum
operator|==
literal|2
condition|)
name|s
operator|=
name|s
operator|!=
name|NULL
condition|?
name|strchr
argument_list|(
name|s
operator|+
literal|1
argument_list|,
literal|'.'
argument_list|)
else|:
name|NULL
expr_stmt|;
return|return
operator|(
name|s
operator|!=
name|NULL
operator|&&
operator|(
name|s
index|[
literal|1
index|]
operator|==
literal|'w'
operator|||
name|s
index|[
literal|1
index|]
operator|==
literal|'s'
operator|)
operator|)
return|;
block|}
comment|/* Single-precision coprocessor loads and moves are OK too.  */
if|if
condition|(
operator|(
name|insn
operator|->
name|pinfo
operator|&
name|FP_S
operator|)
operator|&&
operator|(
name|insn
operator|->
name|pinfo
operator|&
operator|(
name|INSN_COPROC_MEMORY_DELAY
operator||
name|INSN_STORE_MEMORY
operator||
name|INSN_LOAD_COPROC_DELAY
operator||
name|INSN_COPROC_MOVE_DELAY
operator|)
operator|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* This routine assembles an instruction into its binary format.  As a    side effect, it sets one of the global variables imm_reloc or    offset_reloc to the type of relocation to do if one of the operands    is an address expression.  */
end_comment

begin_function
specifier|static
name|void
name|mips_ip
parameter_list|(
name|char
modifier|*
name|str
parameter_list|,
name|struct
name|mips_cl_insn
modifier|*
name|ip
parameter_list|)
block|{
name|char
modifier|*
name|s
decl_stmt|;
specifier|const
name|char
modifier|*
name|args
decl_stmt|;
name|char
name|c
init|=
literal|0
decl_stmt|;
name|struct
name|mips_opcode
modifier|*
name|insn
decl_stmt|;
name|char
modifier|*
name|argsStart
decl_stmt|;
name|unsigned
name|int
name|regno
decl_stmt|;
name|unsigned
name|int
name|lastregno
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|lastpos
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|limlo
decl_stmt|,
name|limhi
decl_stmt|;
name|char
modifier|*
name|s_reset
decl_stmt|;
name|char
name|save_c
init|=
literal|0
decl_stmt|;
name|offsetT
name|min_range
decl_stmt|,
name|max_range
decl_stmt|;
name|int
name|argnum
decl_stmt|;
name|unsigned
name|int
name|rtype
decl_stmt|;
name|insn_error
operator|=
name|NULL
expr_stmt|;
comment|/* If the instruction contains a '.', we first try to match an instruction      including the '.'.  Then we try again without the '.'.  */
name|insn
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|s
operator|=
name|str
init|;
operator|*
name|s
operator|!=
literal|'\0'
operator|&&
operator|!
name|ISSPACE
argument_list|(
operator|*
name|s
argument_list|)
condition|;
operator|++
name|s
control|)
continue|continue;
comment|/* If we stopped on whitespace, then replace the whitespace with null for      the call to hash_find.  Save the character we replaced just in case we      have to re-parse the instruction.  */
if|if
condition|(
name|ISSPACE
argument_list|(
operator|*
name|s
argument_list|)
condition|)
block|{
name|save_c
operator|=
operator|*
name|s
expr_stmt|;
operator|*
name|s
operator|++
operator|=
literal|'\0'
expr_stmt|;
block|}
name|insn
operator|=
operator|(
expr|struct
name|mips_opcode
operator|*
operator|)
name|hash_find
argument_list|(
name|op_hash
argument_list|,
name|str
argument_list|)
expr_stmt|;
comment|/* If we didn't find the instruction in the opcode table, try again, but      this time with just the instruction up to, but not including the      first '.'.  */
if|if
condition|(
name|insn
operator|==
name|NULL
condition|)
block|{
comment|/* Restore the character we overwrite above (if any).  */
if|if
condition|(
name|save_c
condition|)
operator|*
operator|(
operator|--
name|s
operator|)
operator|=
name|save_c
expr_stmt|;
comment|/* Scan up to the first '.' or whitespace.  */
for|for
control|(
name|s
operator|=
name|str
init|;
operator|*
name|s
operator|!=
literal|'\0'
operator|&&
operator|*
name|s
operator|!=
literal|'.'
operator|&&
operator|!
name|ISSPACE
argument_list|(
operator|*
name|s
argument_list|)
condition|;
operator|++
name|s
control|)
continue|continue;
comment|/* If we did not find a '.', then we can quit now.  */
if|if
condition|(
operator|*
name|s
operator|!=
literal|'.'
condition|)
block|{
name|insn_error
operator|=
literal|"unrecognized opcode"
expr_stmt|;
return|return;
block|}
comment|/* Lookup the instruction in the hash table.  */
operator|*
name|s
operator|++
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|(
name|insn
operator|=
operator|(
expr|struct
name|mips_opcode
operator|*
operator|)
name|hash_find
argument_list|(
name|op_hash
argument_list|,
name|str
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|insn_error
operator|=
literal|"unrecognized opcode"
expr_stmt|;
return|return;
block|}
block|}
name|argsStart
operator|=
name|s
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|bfd_boolean
name|ok
decl_stmt|;
name|assert
argument_list|(
name|strcmp
argument_list|(
name|insn
operator|->
name|name
argument_list|,
name|str
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|OPCODE_IS_MEMBER
argument_list|(
name|insn
argument_list|,
operator|(
name|mips_opts
operator|.
name|isa
comment|/* We don't check for mips_opts.mips16 here since 			        we want to allow jalx if -mips16 was specified 			        on the command line.  */
operator||
operator|(
name|file_ase_mips16
condition|?
name|INSN_MIPS16
else|:
literal|0
operator|)
operator||
operator|(
name|mips_opts
operator|.
name|ase_mdmx
condition|?
name|INSN_MDMX
else|:
literal|0
operator|)
operator||
operator|(
name|mips_opts
operator|.
name|ase_dsp
condition|?
name|INSN_DSP
else|:
literal|0
operator|)
operator||
operator|(
operator|(
name|mips_opts
operator|.
name|ase_dsp
operator|&&
name|ISA_SUPPORTS_DSP64_ASE
operator|)
condition|?
name|INSN_DSP64
else|:
literal|0
operator|)
operator||
operator|(
name|mips_opts
operator|.
name|ase_dspr2
condition|?
name|INSN_DSPR2
else|:
literal|0
operator|)
operator||
operator|(
name|mips_opts
operator|.
name|ase_mt
condition|?
name|INSN_MT
else|:
literal|0
operator|)
operator||
operator|(
name|mips_opts
operator|.
name|ase_mips3d
condition|?
name|INSN_MIPS3D
else|:
literal|0
operator|)
operator||
operator|(
name|mips_opts
operator|.
name|ase_smartmips
condition|?
name|INSN_SMARTMIPS
else|:
literal|0
operator|)
operator|)
argument_list|,
name|mips_opts
operator|.
name|arch
argument_list|)
condition|)
name|ok
operator|=
name|TRUE
expr_stmt|;
else|else
name|ok
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|insn
operator|->
name|pinfo
operator|!=
name|INSN_MACRO
condition|)
block|{
if|if
condition|(
name|mips_opts
operator|.
name|arch
operator|==
name|CPU_R4650
operator|&&
operator|(
name|insn
operator|->
name|pinfo
operator|&
name|FP_D
operator|)
operator|!=
literal|0
condition|)
name|ok
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|mips_opts
operator|.
name|arch
operator|==
name|CPU_OCTEON
operator|&&
name|octeon_error_on_unsupported
operator|&&
operator|(
operator|(
name|insn
operator|->
name|pinfo
operator|&
name|FP_D
operator|)
operator|!=
literal|0
operator|||
operator|(
name|insn
operator|->
name|pinfo
operator|&
name|FP_S
operator|)
operator|!=
literal|0
operator|||
name|strcmp
argument_list|(
name|insn
operator|->
name|name
argument_list|,
literal|"prefx"
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|insn_error
operator|=
literal|"opcode not implemented in Octeon"
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|mips_opts
operator|.
name|arch
operator|==
name|CPU_OCTEON
operator|&&
name|octeon_error_on_unsupported
operator|&&
operator|(
name|strcmp
argument_list|(
name|insn
operator|->
name|name
argument_list|,
literal|"swc2"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|insn
operator|->
name|name
argument_list|,
literal|"lwc2"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|insn
operator|->
name|name
argument_list|,
literal|"sdc2"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|insn
operator|->
name|name
argument_list|,
literal|"ldc2"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|insn
operator|->
name|name
argument_list|,
literal|"bc2f"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|insn
operator|->
name|name
argument_list|,
literal|"bc2t"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|insn
operator|->
name|name
argument_list|,
literal|"mfc2"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|insn
operator|->
name|name
argument_list|,
literal|"mtc2"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|insn
operator|->
name|name
argument_list|,
literal|"ctc2"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|insn
operator|->
name|name
argument_list|,
literal|"cfc2"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|insn
operator|->
name|name
argument_list|,
literal|"mfhc2"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|insn
operator|->
name|name
argument_list|,
literal|"mthc2"
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|insn_error
operator|=
literal|"opcode not implemented in Octeon"
expr_stmt|;
return|return;
block|}
comment|/* Issue a warning message for Octeon unaligned load/store  	     instructions used when octeon_use_unalign is not set.  */
if|if
condition|(
name|mips_opts
operator|.
name|arch
operator|==
name|CPU_OCTEON
operator|&&
operator|!
name|octeon_use_unalign
operator|&&
operator|(
name|strcmp
argument_list|(
name|insn
operator|->
name|name
argument_list|,
literal|"ulw"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|insn
operator|->
name|name
argument_list|,
literal|"uld"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|insn
operator|->
name|name
argument_list|,
literal|"usw"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|insn
operator|->
name|name
argument_list|,
literal|"usd"
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
specifier|static
name|char
name|buf
index|[
literal|120
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
name|_
argument_list|(
literal|"Octeon specific unaligned load/store instructions are not allowed with -mno-octeon-useun"
argument_list|)
argument_list|)
expr_stmt|;
name|insn_error
operator|=
name|buf
expr_stmt|;
return|return;
block|}
comment|/* Issue a warning message for MIPS unaligned load/store  	     instructions used when octeon_use_unalign is set.  */
if|if
condition|(
name|mips_opts
operator|.
name|arch
operator|==
name|CPU_OCTEON
operator|&&
name|octeon_use_unalign
operator|&&
operator|(
name|strcmp
argument_list|(
name|insn
operator|->
name|name
argument_list|,
literal|"lwl"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|insn
operator|->
name|name
argument_list|,
literal|"lwr"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|insn
operator|->
name|name
argument_list|,
literal|"ldl"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|insn
operator|->
name|name
argument_list|,
literal|"ldr"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|insn
operator|->
name|name
argument_list|,
literal|"sdl"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|insn
operator|->
name|name
argument_list|,
literal|"sdr"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|insn
operator|->
name|name
argument_list|,
literal|"swr"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|insn
operator|->
name|name
argument_list|,
literal|"swl"
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
specifier|static
name|char
name|buf
index|[
literal|100
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
name|_
argument_list|(
literal|"Unaligned load/store instructions are not allowed with -mocteon-useun"
argument_list|)
argument_list|)
expr_stmt|;
name|insn_error
operator|=
name|buf
expr_stmt|;
return|return;
block|}
block|}
comment|/* Octeon has its own version of dmtc2/dmfc2 instructions, error on  	 other formats.  */
if|if
condition|(
name|mips_opts
operator|.
name|arch
operator|==
name|CPU_OCTEON
operator|&&
operator|(
name|strcmp
argument_list|(
name|insn
operator|->
name|name
argument_list|,
literal|"dmtc2"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|insn
operator|->
name|name
argument_list|,
literal|"dmfc2"
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|insn
operator|->
name|membership
operator|&
name|INSN_OCTEON
operator|)
operator|!=
name|INSN_OCTEON
condition|)
block|{
specifier|static
name|char
name|buf
index|[
literal|100
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
name|_
argument_list|(
literal|"opcode not supported in %s"
argument_list|)
argument_list|,
name|mips_cpu_info_from_arch
argument_list|(
name|mips_opts
operator|.
name|arch
argument_list|)
operator|->
name|name
argument_list|)
expr_stmt|;
name|insn_error
operator|=
name|buf
expr_stmt|;
name|ok
operator|=
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|ok
condition|)
block|{
if|if
condition|(
name|insn
operator|+
literal|1
operator|<
operator|&
name|mips_opcodes
index|[
name|NUMOPCODES
index|]
operator|&&
name|strcmp
argument_list|(
name|insn
operator|->
name|name
argument_list|,
name|insn
index|[
literal|1
index|]
operator|.
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|++
name|insn
expr_stmt|;
continue|continue;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|insn_error
condition|)
block|{
specifier|static
name|char
name|buf
index|[
literal|100
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
name|_
argument_list|(
literal|"opcode not supported on this processor: %s (%s)"
argument_list|)
argument_list|,
name|mips_cpu_info_from_arch
argument_list|(
name|mips_opts
operator|.
name|arch
argument_list|)
operator|->
name|name
argument_list|,
name|mips_cpu_info_from_isa
argument_list|(
name|mips_opts
operator|.
name|isa
argument_list|)
operator|->
name|name
argument_list|)
expr_stmt|;
name|insn_error
operator|=
name|buf
expr_stmt|;
block|}
if|if
condition|(
name|save_c
condition|)
operator|*
operator|(
operator|--
name|s
operator|)
operator|=
name|save_c
expr_stmt|;
return|return;
block|}
block|}
name|create_insn
argument_list|(
name|ip
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|insn_error
operator|=
name|NULL
expr_stmt|;
name|argnum
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|args
operator|=
name|insn
operator|->
name|args
init|;
condition|;
operator|++
name|args
control|)
block|{
name|int
name|is_mdmx
decl_stmt|;
name|s
operator|+=
name|strspn
argument_list|(
name|s
argument_list|,
literal|" \t"
argument_list|)
expr_stmt|;
name|is_mdmx
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
operator|*
name|args
condition|)
block|{
case|case
literal|'\0'
case|:
comment|/* end of args */
if|if
condition|(
operator|*
name|s
operator|==
literal|'\0'
condition|)
return|return;
break|break;
case|case
literal|'2'
case|:
comment|/* dsp 2-bit unsigned immediate in bit 11 */
name|my_getExpression
argument_list|(
operator|&
name|imm_expr
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|check_absolute_expr
argument_list|(
name|ip
argument_list|,
operator|&
name|imm_expr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|unsigned
name|long
operator|)
name|imm_expr
operator|.
name|X_add_number
operator|!=
literal|1
operator|&&
operator|(
name|unsigned
name|long
operator|)
name|imm_expr
operator|.
name|X_add_number
operator|!=
literal|3
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"BALIGN immediate not 1 or 3 (%lu)"
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|imm_expr
operator|.
name|X_add_number
argument_list|)
expr_stmt|;
block|}
name|INSERT_OPERAND
argument_list|(
name|BP
argument_list|,
operator|*
name|ip
argument_list|,
name|imm_expr
operator|.
name|X_add_number
argument_list|)
expr_stmt|;
name|imm_expr
operator|.
name|X_op
operator|=
name|O_absent
expr_stmt|;
name|s
operator|=
name|expr_end
expr_stmt|;
continue|continue;
case|case
literal|'3'
case|:
comment|/* dsp 3-bit unsigned immediate in bit 21 */
name|my_getExpression
argument_list|(
operator|&
name|imm_expr
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|check_absolute_expr
argument_list|(
name|ip
argument_list|,
operator|&
name|imm_expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|imm_expr
operator|.
name|X_add_number
operator|&
operator|~
name|OP_MASK_SA3
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"DSP immediate not in range 0..%d (%lu)"
argument_list|)
argument_list|,
name|OP_MASK_SA3
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|imm_expr
operator|.
name|X_add_number
argument_list|)
expr_stmt|;
block|}
name|INSERT_OPERAND
argument_list|(
name|SA3
argument_list|,
operator|*
name|ip
argument_list|,
name|imm_expr
operator|.
name|X_add_number
argument_list|)
expr_stmt|;
name|imm_expr
operator|.
name|X_op
operator|=
name|O_absent
expr_stmt|;
name|s
operator|=
name|expr_end
expr_stmt|;
continue|continue;
case|case
literal|'4'
case|:
comment|/* dsp 4-bit unsigned immediate in bit 21 */
name|my_getExpression
argument_list|(
operator|&
name|imm_expr
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|check_absolute_expr
argument_list|(
name|ip
argument_list|,
operator|&
name|imm_expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|imm_expr
operator|.
name|X_add_number
operator|&
operator|~
name|OP_MASK_SA4
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"DSP immediate not in range 0..%d (%lu)"
argument_list|)
argument_list|,
name|OP_MASK_SA4
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|imm_expr
operator|.
name|X_add_number
argument_list|)
expr_stmt|;
block|}
name|INSERT_OPERAND
argument_list|(
name|SA4
argument_list|,
operator|*
name|ip
argument_list|,
name|imm_expr
operator|.
name|X_add_number
argument_list|)
expr_stmt|;
name|imm_expr
operator|.
name|X_op
operator|=
name|O_absent
expr_stmt|;
name|s
operator|=
name|expr_end
expr_stmt|;
continue|continue;
case|case
literal|'5'
case|:
comment|/* dsp 8-bit unsigned immediate in bit 16 */
name|my_getExpression
argument_list|(
operator|&
name|imm_expr
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|check_absolute_expr
argument_list|(
name|ip
argument_list|,
operator|&
name|imm_expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|imm_expr
operator|.
name|X_add_number
operator|&
operator|~
name|OP_MASK_IMM8
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"DSP immediate not in range 0..%d (%lu)"
argument_list|)
argument_list|,
name|OP_MASK_IMM8
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|imm_expr
operator|.
name|X_add_number
argument_list|)
expr_stmt|;
block|}
name|INSERT_OPERAND
argument_list|(
name|IMM8
argument_list|,
operator|*
name|ip
argument_list|,
name|imm_expr
operator|.
name|X_add_number
argument_list|)
expr_stmt|;
name|imm_expr
operator|.
name|X_op
operator|=
name|O_absent
expr_stmt|;
name|s
operator|=
name|expr_end
expr_stmt|;
continue|continue;
case|case
literal|'6'
case|:
comment|/* dsp 5-bit unsigned immediate in bit 21 */
name|my_getExpression
argument_list|(
operator|&
name|imm_expr
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|check_absolute_expr
argument_list|(
name|ip
argument_list|,
operator|&
name|imm_expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|imm_expr
operator|.
name|X_add_number
operator|&
operator|~
name|OP_MASK_RS
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"DSP immediate not in range 0..%d (%lu)"
argument_list|)
argument_list|,
name|OP_MASK_RS
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|imm_expr
operator|.
name|X_add_number
argument_list|)
expr_stmt|;
block|}
name|INSERT_OPERAND
argument_list|(
name|RS
argument_list|,
operator|*
name|ip
argument_list|,
name|imm_expr
operator|.
name|X_add_number
argument_list|)
expr_stmt|;
name|imm_expr
operator|.
name|X_op
operator|=
name|O_absent
expr_stmt|;
name|s
operator|=
name|expr_end
expr_stmt|;
continue|continue;
case|case
literal|'7'
case|:
comment|/* four dsp accumulators in bits 11,12 */
if|if
condition|(
name|s
index|[
literal|0
index|]
operator|==
literal|'$'
operator|&&
name|s
index|[
literal|1
index|]
operator|==
literal|'a'
operator|&&
name|s
index|[
literal|2
index|]
operator|==
literal|'c'
operator|&&
name|s
index|[
literal|3
index|]
operator|>=
literal|'0'
operator|&&
name|s
index|[
literal|3
index|]
operator|<=
literal|'3'
condition|)
block|{
name|regno
operator|=
name|s
index|[
literal|3
index|]
operator|-
literal|'0'
expr_stmt|;
name|s
operator|+=
literal|4
expr_stmt|;
name|INSERT_OPERAND
argument_list|(
name|DSPACC
argument_list|,
operator|*
name|ip
argument_list|,
name|regno
argument_list|)
expr_stmt|;
continue|continue;
block|}
else|else
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Invalid dsp acc register"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'8'
case|:
comment|/* dsp 6-bit unsigned immediate in bit 11 */
name|my_getExpression
argument_list|(
operator|&
name|imm_expr
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|check_absolute_expr
argument_list|(
name|ip
argument_list|,
operator|&
name|imm_expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|imm_expr
operator|.
name|X_add_number
operator|&
operator|~
name|OP_MASK_WRDSP
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"DSP immediate not in range 0..%d (%lu)"
argument_list|)
argument_list|,
name|OP_MASK_WRDSP
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|imm_expr
operator|.
name|X_add_number
argument_list|)
expr_stmt|;
block|}
name|INSERT_OPERAND
argument_list|(
name|WRDSP
argument_list|,
operator|*
name|ip
argument_list|,
name|imm_expr
operator|.
name|X_add_number
argument_list|)
expr_stmt|;
name|imm_expr
operator|.
name|X_op
operator|=
name|O_absent
expr_stmt|;
name|s
operator|=
name|expr_end
expr_stmt|;
continue|continue;
case|case
literal|'9'
case|:
comment|/* four dsp accumulators in bits 21,22 */
if|if
condition|(
name|s
index|[
literal|0
index|]
operator|==
literal|'$'
operator|&&
name|s
index|[
literal|1
index|]
operator|==
literal|'a'
operator|&&
name|s
index|[
literal|2
index|]
operator|==
literal|'c'
operator|&&
name|s
index|[
literal|3
index|]
operator|>=
literal|'0'
operator|&&
name|s
index|[
literal|3
index|]
operator|<=
literal|'3'
condition|)
block|{
name|regno
operator|=
name|s
index|[
literal|3
index|]
operator|-
literal|'0'
expr_stmt|;
name|s
operator|+=
literal|4
expr_stmt|;
name|INSERT_OPERAND
argument_list|(
name|DSPACC_S
argument_list|,
operator|*
name|ip
argument_list|,
name|regno
argument_list|)
expr_stmt|;
continue|continue;
block|}
else|else
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Invalid dsp acc register"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'0'
case|:
comment|/* dsp 6-bit signed immediate in bit 20 */
name|my_getExpression
argument_list|(
operator|&
name|imm_expr
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|check_absolute_expr
argument_list|(
name|ip
argument_list|,
operator|&
name|imm_expr
argument_list|)
expr_stmt|;
name|min_range
operator|=
operator|-
operator|(
operator|(
name|OP_MASK_DSPSFT
operator|+
literal|1
operator|)
operator|>>
literal|1
operator|)
expr_stmt|;
name|max_range
operator|=
operator|(
operator|(
name|OP_MASK_DSPSFT
operator|+
literal|1
operator|)
operator|>>
literal|1
operator|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|imm_expr
operator|.
name|X_add_number
operator|<
name|min_range
operator|||
name|imm_expr
operator|.
name|X_add_number
operator|>
name|max_range
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"DSP immediate not in range %ld..%ld (%ld)"
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|min_range
argument_list|,
operator|(
name|long
operator|)
name|max_range
argument_list|,
operator|(
name|long
operator|)
name|imm_expr
operator|.
name|X_add_number
argument_list|)
expr_stmt|;
block|}
name|INSERT_OPERAND
argument_list|(
name|DSPSFT
argument_list|,
operator|*
name|ip
argument_list|,
name|imm_expr
operator|.
name|X_add_number
argument_list|)
expr_stmt|;
name|imm_expr
operator|.
name|X_op
operator|=
name|O_absent
expr_stmt|;
name|s
operator|=
name|expr_end
expr_stmt|;
continue|continue;
case|case
literal|'\''
case|:
comment|/* dsp 6-bit unsigned immediate in bit 16 */
name|my_getExpression
argument_list|(
operator|&
name|imm_expr
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|check_absolute_expr
argument_list|(
name|ip
argument_list|,
operator|&
name|imm_expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|imm_expr
operator|.
name|X_add_number
operator|&
operator|~
name|OP_MASK_RDDSP
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"DSP immediate not in range 0..%d (%lu)"
argument_list|)
argument_list|,
name|OP_MASK_RDDSP
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|imm_expr
operator|.
name|X_add_number
argument_list|)
expr_stmt|;
block|}
name|INSERT_OPERAND
argument_list|(
name|RDDSP
argument_list|,
operator|*
name|ip
argument_list|,
name|imm_expr
operator|.
name|X_add_number
argument_list|)
expr_stmt|;
name|imm_expr
operator|.
name|X_op
operator|=
name|O_absent
expr_stmt|;
name|s
operator|=
name|expr_end
expr_stmt|;
continue|continue;
case|case
literal|':'
case|:
comment|/* dsp 7-bit signed immediate in bit 19 */
name|my_getExpression
argument_list|(
operator|&
name|imm_expr
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|check_absolute_expr
argument_list|(
name|ip
argument_list|,
operator|&
name|imm_expr
argument_list|)
expr_stmt|;
name|min_range
operator|=
operator|-
operator|(
operator|(
name|OP_MASK_DSPSFT_7
operator|+
literal|1
operator|)
operator|>>
literal|1
operator|)
expr_stmt|;
name|max_range
operator|=
operator|(
operator|(
name|OP_MASK_DSPSFT_7
operator|+
literal|1
operator|)
operator|>>
literal|1
operator|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|imm_expr
operator|.
name|X_add_number
operator|<
name|min_range
operator|||
name|imm_expr
operator|.
name|X_add_number
operator|>
name|max_range
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"DSP immediate not in range %ld..%ld (%ld)"
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|min_range
argument_list|,
operator|(
name|long
operator|)
name|max_range
argument_list|,
operator|(
name|long
operator|)
name|imm_expr
operator|.
name|X_add_number
argument_list|)
expr_stmt|;
block|}
name|INSERT_OPERAND
argument_list|(
name|DSPSFT_7
argument_list|,
operator|*
name|ip
argument_list|,
name|imm_expr
operator|.
name|X_add_number
argument_list|)
expr_stmt|;
name|imm_expr
operator|.
name|X_op
operator|=
name|O_absent
expr_stmt|;
name|s
operator|=
name|expr_end
expr_stmt|;
continue|continue;
case|case
literal|'@'
case|:
comment|/* dsp 10-bit signed immediate in bit 16 */
name|my_getExpression
argument_list|(
operator|&
name|imm_expr
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|check_absolute_expr
argument_list|(
name|ip
argument_list|,
operator|&
name|imm_expr
argument_list|)
expr_stmt|;
name|min_range
operator|=
operator|-
operator|(
operator|(
name|OP_MASK_IMM10
operator|+
literal|1
operator|)
operator|>>
literal|1
operator|)
expr_stmt|;
name|max_range
operator|=
operator|(
operator|(
name|OP_MASK_IMM10
operator|+
literal|1
operator|)
operator|>>
literal|1
operator|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|imm_expr
operator|.
name|X_add_number
operator|<
name|min_range
operator|||
name|imm_expr
operator|.
name|X_add_number
operator|>
name|max_range
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"DSP immediate not in range %ld..%ld (%ld)"
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|min_range
argument_list|,
operator|(
name|long
operator|)
name|max_range
argument_list|,
operator|(
name|long
operator|)
name|imm_expr
operator|.
name|X_add_number
argument_list|)
expr_stmt|;
block|}
name|INSERT_OPERAND
argument_list|(
name|IMM10
argument_list|,
operator|*
name|ip
argument_list|,
name|imm_expr
operator|.
name|X_add_number
argument_list|)
expr_stmt|;
name|imm_expr
operator|.
name|X_op
operator|=
name|O_absent
expr_stmt|;
name|s
operator|=
name|expr_end
expr_stmt|;
continue|continue;
case|case
literal|'!'
case|:
comment|/* MT usermode flag bit.  */
name|my_getExpression
argument_list|(
operator|&
name|imm_expr
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|check_absolute_expr
argument_list|(
name|ip
argument_list|,
operator|&
name|imm_expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|imm_expr
operator|.
name|X_add_number
operator|&
operator|~
name|OP_MASK_MT_U
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"MT usermode bit not 0 or 1 (%lu)"
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|imm_expr
operator|.
name|X_add_number
argument_list|)
expr_stmt|;
name|INSERT_OPERAND
argument_list|(
name|MT_U
argument_list|,
operator|*
name|ip
argument_list|,
name|imm_expr
operator|.
name|X_add_number
argument_list|)
expr_stmt|;
name|imm_expr
operator|.
name|X_op
operator|=
name|O_absent
expr_stmt|;
name|s
operator|=
name|expr_end
expr_stmt|;
continue|continue;
case|case
literal|'$'
case|:
comment|/* MT load high flag bit.  */
name|my_getExpression
argument_list|(
operator|&
name|imm_expr
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|check_absolute_expr
argument_list|(
name|ip
argument_list|,
operator|&
name|imm_expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|imm_expr
operator|.
name|X_add_number
operator|&
operator|~
name|OP_MASK_MT_H
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"MT load high bit not 0 or 1 (%lu)"
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|imm_expr
operator|.
name|X_add_number
argument_list|)
expr_stmt|;
name|INSERT_OPERAND
argument_list|(
name|MT_H
argument_list|,
operator|*
name|ip
argument_list|,
name|imm_expr
operator|.
name|X_add_number
argument_list|)
expr_stmt|;
name|imm_expr
operator|.
name|X_op
operator|=
name|O_absent
expr_stmt|;
name|s
operator|=
name|expr_end
expr_stmt|;
continue|continue;
case|case
literal|'*'
case|:
comment|/* four dsp accumulators in bits 18,19 */
if|if
condition|(
name|s
index|[
literal|0
index|]
operator|==
literal|'$'
operator|&&
name|s
index|[
literal|1
index|]
operator|==
literal|'a'
operator|&&
name|s
index|[
literal|2
index|]
operator|==
literal|'c'
operator|&&
name|s
index|[
literal|3
index|]
operator|>=
literal|'0'
operator|&&
name|s
index|[
literal|3
index|]
operator|<=
literal|'3'
condition|)
block|{
name|regno
operator|=
name|s
index|[
literal|3
index|]
operator|-
literal|'0'
expr_stmt|;
name|s
operator|+=
literal|4
expr_stmt|;
name|INSERT_OPERAND
argument_list|(
name|MTACC_T
argument_list|,
operator|*
name|ip
argument_list|,
name|regno
argument_list|)
expr_stmt|;
continue|continue;
block|}
else|else
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Invalid dsp/smartmips acc register"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'&'
case|:
comment|/* four dsp accumulators in bits 13,14 */
if|if
condition|(
name|s
index|[
literal|0
index|]
operator|==
literal|'$'
operator|&&
name|s
index|[
literal|1
index|]
operator|==
literal|'a'
operator|&&
name|s
index|[
literal|2
index|]
operator|==
literal|'c'
operator|&&
name|s
index|[
literal|3
index|]
operator|>=
literal|'0'
operator|&&
name|s
index|[
literal|3
index|]
operator|<=
literal|'3'
condition|)
block|{
name|regno
operator|=
name|s
index|[
literal|3
index|]
operator|-
literal|'0'
expr_stmt|;
name|s
operator|+=
literal|4
expr_stmt|;
name|INSERT_OPERAND
argument_list|(
name|MTACC_D
argument_list|,
operator|*
name|ip
argument_list|,
name|regno
argument_list|)
expr_stmt|;
continue|continue;
block|}
else|else
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Invalid dsp/smartmips acc register"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|','
case|:
operator|++
name|argnum
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|++
operator|==
operator|*
name|args
condition|)
continue|continue;
name|s
operator|--
expr_stmt|;
switch|switch
condition|(
operator|*
operator|++
name|args
condition|)
block|{
case|case
literal|'r'
case|:
case|case
literal|'v'
case|:
name|INSERT_OPERAND
argument_list|(
name|RS
argument_list|,
operator|*
name|ip
argument_list|,
name|lastregno
argument_list|)
expr_stmt|;
continue|continue;
case|case
literal|'w'
case|:
name|INSERT_OPERAND
argument_list|(
name|RT
argument_list|,
operator|*
name|ip
argument_list|,
name|lastregno
argument_list|)
expr_stmt|;
continue|continue;
case|case
literal|'W'
case|:
name|INSERT_OPERAND
argument_list|(
name|FT
argument_list|,
operator|*
name|ip
argument_list|,
name|lastregno
argument_list|)
expr_stmt|;
continue|continue;
case|case
literal|'V'
case|:
name|INSERT_OPERAND
argument_list|(
name|FS
argument_list|,
operator|*
name|ip
argument_list|,
name|lastregno
argument_list|)
expr_stmt|;
continue|continue;
block|}
break|break;
case|case
literal|'('
case|:
comment|/* Handle optional base register. 		 Either the base register is omitted or 		 we must have a left paren.  */
comment|/* This is dependent on the next operand specifier 		 is a base register specification.  */
name|assert
argument_list|(
name|args
index|[
literal|1
index|]
operator|==
literal|'b'
operator|||
name|args
index|[
literal|1
index|]
operator|==
literal|'5'
operator|||
name|args
index|[
literal|1
index|]
operator|==
literal|'-'
operator|||
name|args
index|[
literal|1
index|]
operator|==
literal|'4'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'\0'
condition|)
return|return;
case|case
literal|')'
case|:
comment|/* these must match exactly */
case|case
literal|'['
case|:
case|case
literal|']'
case|:
if|if
condition|(
operator|*
name|s
operator|++
operator|==
operator|*
name|args
condition|)
continue|continue;
break|break;
case|case
literal|'+'
case|:
comment|/* Opcode extension character.  */
switch|switch
condition|(
operator|*
operator|++
name|args
condition|)
block|{
case|case
literal|'1'
case|:
comment|/* UDI immediates.  */
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
block|{
specifier|const
name|struct
name|mips_immed
modifier|*
name|imm
init|=
name|mips_immed
decl_stmt|;
while|while
condition|(
name|imm
operator|->
name|type
operator|&&
name|imm
operator|->
name|type
operator|!=
operator|*
name|args
condition|)
operator|++
name|imm
expr_stmt|;
if|if
condition|(
operator|!
name|imm
operator|->
name|type
condition|)
name|internalError
argument_list|()
expr_stmt|;
name|my_getExpression
argument_list|(
operator|&
name|imm_expr
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|check_absolute_expr
argument_list|(
name|ip
argument_list|,
operator|&
name|imm_expr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|unsigned
name|long
operator|)
name|imm_expr
operator|.
name|X_add_number
operator|&
operator|~
name|imm
operator|->
name|mask
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"Illegal %s number (%lu, 0x%lx)"
argument_list|)
argument_list|,
name|imm
operator|->
name|desc
condition|?
name|imm
operator|->
name|desc
else|:
name|ip
operator|->
name|insn_mo
operator|->
name|name
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|imm_expr
operator|.
name|X_add_number
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|imm_expr
operator|.
name|X_add_number
argument_list|)
expr_stmt|;
name|imm_expr
operator|.
name|X_add_number
operator|&=
name|imm
operator|->
name|mask
expr_stmt|;
block|}
name|ip
operator|->
name|insn_opcode
operator||=
operator|(
operator|(
name|unsigned
name|long
operator|)
name|imm_expr
operator|.
name|X_add_number
operator|<<
name|imm
operator|->
name|shift
operator|)
expr_stmt|;
name|imm_expr
operator|.
name|X_op
operator|=
name|O_absent
expr_stmt|;
name|s
operator|=
name|expr_end
expr_stmt|;
block|}
continue|continue;
case|case
literal|'A'
case|:
comment|/* ins/ext position, becomes LSB.  */
name|limlo
operator|=
literal|0
expr_stmt|;
name|limhi
operator|=
literal|31
expr_stmt|;
goto|goto
name|do_lsb
goto|;
case|case
literal|'E'
case|:
name|limlo
operator|=
literal|32
expr_stmt|;
name|limhi
operator|=
literal|63
expr_stmt|;
goto|goto
name|do_lsb
goto|;
name|do_lsb
label|:
name|my_getExpression
argument_list|(
operator|&
name|imm_expr
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|check_absolute_expr
argument_list|(
name|ip
argument_list|,
operator|&
name|imm_expr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|unsigned
name|long
operator|)
name|imm_expr
operator|.
name|X_add_number
operator|<
name|limlo
operator|||
operator|(
name|unsigned
name|long
operator|)
name|imm_expr
operator|.
name|X_add_number
operator|>
name|limhi
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Improper position (%lu)"
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|imm_expr
operator|.
name|X_add_number
argument_list|)
expr_stmt|;
name|imm_expr
operator|.
name|X_add_number
operator|=
name|limlo
expr_stmt|;
block|}
name|lastpos
operator|=
name|imm_expr
operator|.
name|X_add_number
expr_stmt|;
name|INSERT_OPERAND
argument_list|(
name|SHAMT
argument_list|,
operator|*
name|ip
argument_list|,
name|imm_expr
operator|.
name|X_add_number
argument_list|)
expr_stmt|;
name|imm_expr
operator|.
name|X_op
operator|=
name|O_absent
expr_stmt|;
name|s
operator|=
name|expr_end
expr_stmt|;
continue|continue;
case|case
literal|'B'
case|:
comment|/* ins size, becomes MSB.  */
name|limlo
operator|=
literal|1
expr_stmt|;
name|limhi
operator|=
literal|32
expr_stmt|;
goto|goto
name|do_msb
goto|;
case|case
literal|'F'
case|:
name|limlo
operator|=
literal|33
expr_stmt|;
name|limhi
operator|=
literal|64
expr_stmt|;
goto|goto
name|do_msb
goto|;
name|do_msb
label|:
name|my_getExpression
argument_list|(
operator|&
name|imm_expr
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|check_absolute_expr
argument_list|(
name|ip
argument_list|,
operator|&
name|imm_expr
argument_list|)
expr_stmt|;
comment|/* Check for negative input so that small negative numbers 		     will not succeed incorrectly.  The checks against 		     (pos+size) transitively check "size" itself, 		     assuming that "pos" is reasonable.  */
if|if
condition|(
operator|(
name|long
operator|)
name|imm_expr
operator|.
name|X_add_number
operator|<
literal|0
operator|||
operator|(
operator|(
name|unsigned
name|long
operator|)
name|imm_expr
operator|.
name|X_add_number
operator|+
name|lastpos
operator|)
operator|<
name|limlo
operator|||
operator|(
operator|(
name|unsigned
name|long
operator|)
name|imm_expr
operator|.
name|X_add_number
operator|+
name|lastpos
operator|)
operator|>
name|limhi
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Improper insert size (%lu, position %lu)"
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|imm_expr
operator|.
name|X_add_number
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|lastpos
argument_list|)
expr_stmt|;
name|imm_expr
operator|.
name|X_add_number
operator|=
name|limlo
operator|-
name|lastpos
expr_stmt|;
block|}
name|INSERT_OPERAND
argument_list|(
name|INSMSB
argument_list|,
operator|*
name|ip
argument_list|,
name|lastpos
operator|+
name|imm_expr
operator|.
name|X_add_number
operator|-
literal|1
argument_list|)
expr_stmt|;
name|imm_expr
operator|.
name|X_op
operator|=
name|O_absent
expr_stmt|;
name|s
operator|=
name|expr_end
expr_stmt|;
continue|continue;
case|case
literal|'C'
case|:
comment|/* ext size, becomes MSBD.  */
name|limlo
operator|=
literal|1
expr_stmt|;
name|limhi
operator|=
literal|32
expr_stmt|;
goto|goto
name|do_msbd
goto|;
case|case
literal|'G'
case|:
name|limlo
operator|=
literal|33
expr_stmt|;
name|limhi
operator|=
literal|64
expr_stmt|;
goto|goto
name|do_msbd
goto|;
case|case
literal|'H'
case|:
name|limlo
operator|=
literal|33
expr_stmt|;
name|limhi
operator|=
literal|64
expr_stmt|;
goto|goto
name|do_msbd
goto|;
name|do_msbd
label|:
name|my_getExpression
argument_list|(
operator|&
name|imm_expr
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|check_absolute_expr
argument_list|(
name|ip
argument_list|,
operator|&
name|imm_expr
argument_list|)
expr_stmt|;
comment|/* Check for negative input so that small negative numbers 		     will not succeed incorrectly.  The checks against 		     (pos+size) transitively check "size" itself, 		     assuming that "pos" is reasonable.  */
if|if
condition|(
operator|(
name|long
operator|)
name|imm_expr
operator|.
name|X_add_number
operator|<
literal|0
operator|||
operator|(
operator|(
name|unsigned
name|long
operator|)
name|imm_expr
operator|.
name|X_add_number
operator|+
name|lastpos
operator|)
operator|<
name|limlo
operator|||
operator|(
operator|(
name|unsigned
name|long
operator|)
name|imm_expr
operator|.
name|X_add_number
operator|+
name|lastpos
operator|)
operator|>
name|limhi
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Improper extract size (%lu, position %lu)"
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|imm_expr
operator|.
name|X_add_number
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|lastpos
argument_list|)
expr_stmt|;
name|imm_expr
operator|.
name|X_add_number
operator|=
name|limlo
operator|-
name|lastpos
expr_stmt|;
block|}
name|INSERT_OPERAND
argument_list|(
name|EXTMSBD
argument_list|,
operator|*
name|ip
argument_list|,
name|imm_expr
operator|.
name|X_add_number
operator|-
literal|1
argument_list|)
expr_stmt|;
name|imm_expr
operator|.
name|X_op
operator|=
name|O_absent
expr_stmt|;
name|s
operator|=
name|expr_end
expr_stmt|;
continue|continue;
case|case
literal|'D'
case|:
comment|/* +D is for disassembly only; never match.  */
break|break;
case|case
literal|'I'
case|:
comment|/* "+I" is like "I", except that imm2_expr is used.  */
name|my_getExpression
argument_list|(
operator|&
name|imm2_expr
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|imm2_expr
operator|.
name|X_op
operator|!=
name|O_big
operator|&&
name|imm2_expr
operator|.
name|X_op
operator|!=
name|O_constant
condition|)
name|insn_error
operator|=
name|_
argument_list|(
literal|"absolute expression required"
argument_list|)
expr_stmt|;
if|if
condition|(
name|HAVE_32BIT_GPRS
condition|)
name|normalize_constant_expr
argument_list|(
operator|&
name|imm2_expr
argument_list|)
expr_stmt|;
name|s
operator|=
name|expr_end
expr_stmt|;
continue|continue;
case|case
literal|'T'
case|:
comment|/* Coprocessor register.  */
comment|/* +T is for disassembly only; never match.  */
break|break;
case|case
literal|'t'
case|:
comment|/* Coprocessor register number.  */
if|if
condition|(
name|s
index|[
literal|0
index|]
operator|==
literal|'$'
operator|&&
name|ISDIGIT
argument_list|(
name|s
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
operator|++
name|s
expr_stmt|;
name|regno
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|regno
operator|*=
literal|10
expr_stmt|;
name|regno
operator|+=
operator|*
name|s
operator|-
literal|'0'
expr_stmt|;
operator|++
name|s
expr_stmt|;
block|}
do|while
condition|(
name|ISDIGIT
argument_list|(
operator|*
name|s
argument_list|)
condition|)
do|;
if|if
condition|(
name|regno
operator|>
literal|31
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Invalid register number (%d)"
argument_list|)
argument_list|,
name|regno
argument_list|)
expr_stmt|;
else|else
block|{
name|INSERT_OPERAND
argument_list|(
name|RT
argument_list|,
operator|*
name|ip
argument_list|,
name|regno
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
else|else
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Invalid coprocessor 0 register number"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"internal: bad mips opcode (unknown extension operand type `+%c'): %s %s"
argument_list|)
argument_list|,
operator|*
name|args
argument_list|,
name|insn
operator|->
name|name
argument_list|,
name|insn
operator|->
name|args
argument_list|)
expr_stmt|;
comment|/* Further processing is fruitless.  */
return|return;
block|}
break|break;
case|case
literal|'<'
case|:
comment|/* must be at least one digit */
comment|/* 	       * According to the manual, if the shift amount is greater 	       * than 31 or less than 0, then the shift amount should be 	       * mod 32.  In reality the mips assembler issues an error. 	       * We issue a warning and mask out all but the low 5 bits. 	       */
name|my_getExpression
argument_list|(
operator|&
name|imm_expr
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|check_absolute_expr
argument_list|(
name|ip
argument_list|,
operator|&
name|imm_expr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|unsigned
name|long
operator|)
name|imm_expr
operator|.
name|X_add_number
operator|>
literal|31
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"Improper shift amount (%lu)"
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|imm_expr
operator|.
name|X_add_number
argument_list|)
expr_stmt|;
name|INSERT_OPERAND
argument_list|(
name|SHAMT
argument_list|,
operator|*
name|ip
argument_list|,
name|imm_expr
operator|.
name|X_add_number
argument_list|)
expr_stmt|;
name|imm_expr
operator|.
name|X_op
operator|=
name|O_absent
expr_stmt|;
name|s
operator|=
name|expr_end
expr_stmt|;
continue|continue;
case|case
literal|'>'
case|:
comment|/* shift amount minus 32 */
name|my_getExpression
argument_list|(
operator|&
name|imm_expr
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|check_absolute_expr
argument_list|(
name|ip
argument_list|,
operator|&
name|imm_expr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|unsigned
name|long
operator|)
name|imm_expr
operator|.
name|X_add_number
operator|<
literal|32
operator|||
operator|(
name|unsigned
name|long
operator|)
name|imm_expr
operator|.
name|X_add_number
operator|>
literal|63
condition|)
break|break;
name|INSERT_OPERAND
argument_list|(
name|SHAMT
argument_list|,
operator|*
name|ip
argument_list|,
name|imm_expr
operator|.
name|X_add_number
operator|-
literal|32
argument_list|)
expr_stmt|;
name|imm_expr
operator|.
name|X_op
operator|=
name|O_absent
expr_stmt|;
name|s
operator|=
name|expr_end
expr_stmt|;
continue|continue;
case|case
literal|'^'
case|:
comment|/* must be at least one digit */
comment|/* Decode 5-bits of bbit0/1's bit index amount. If the value is  		 greater than 31, issue a warning and mask out all but the low  		 5 bits.  */
name|my_getExpression
argument_list|(
operator|&
name|imm_expr
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|check_absolute_expr
argument_list|(
name|ip
argument_list|,
operator|&
name|imm_expr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|unsigned
name|long
operator|)
name|imm_expr
operator|.
name|X_add_number
operator|>
literal|31
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"Improper bit index amount (%lu)"
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|imm_expr
operator|.
name|X_add_number
argument_list|)
expr_stmt|;
name|imm_expr
operator|.
name|X_add_number
operator|&=
name|OP_MASK_BITIND
expr_stmt|;
block|}
name|ip
operator|->
name|insn_opcode
operator||=
name|imm_expr
operator|.
name|X_add_number
operator|<<
name|OP_SH_BITIND
expr_stmt|;
name|imm_expr
operator|.
name|X_op
operator|=
name|O_absent
expr_stmt|;
name|s
operator|=
name|expr_end
expr_stmt|;
continue|continue;
case|case
literal|'~'
case|:
comment|/* bit index minus 32 */
name|my_getExpression
argument_list|(
operator|&
name|imm_expr
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|check_absolute_expr
argument_list|(
name|ip
argument_list|,
operator|&
name|imm_expr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|unsigned
name|long
operator|)
name|imm_expr
operator|.
name|X_add_number
operator|<
literal|32
operator|||
operator|(
name|unsigned
name|long
operator|)
name|imm_expr
operator|.
name|X_add_number
operator|>
literal|63
condition|)
break|break;
name|ip
operator|->
name|insn_opcode
operator||=
operator|(
name|imm_expr
operator|.
name|X_add_number
operator|-
literal|32
operator|)
operator|<<
name|OP_SH_BITIND
expr_stmt|;
name|imm_expr
operator|.
name|X_op
operator|=
name|O_absent
expr_stmt|;
name|s
operator|=
name|expr_end
expr_stmt|;
continue|continue;
case|case
literal|'k'
case|:
comment|/* cache code */
case|case
literal|'h'
case|:
comment|/* prefx code */
name|my_getExpression
argument_list|(
operator|&
name|imm_expr
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|check_absolute_expr
argument_list|(
name|ip
argument_list|,
operator|&
name|imm_expr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|unsigned
name|long
operator|)
name|imm_expr
operator|.
name|X_add_number
operator|>
literal|31
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"Invalid value for `%s' (%lu)"
argument_list|)
argument_list|,
name|ip
operator|->
name|insn_mo
operator|->
name|name
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|imm_expr
operator|.
name|X_add_number
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|args
operator|==
literal|'k'
condition|)
name|INSERT_OPERAND
argument_list|(
name|CACHE
argument_list|,
operator|*
name|ip
argument_list|,
name|imm_expr
operator|.
name|X_add_number
argument_list|)
expr_stmt|;
else|else
name|INSERT_OPERAND
argument_list|(
name|PREFX
argument_list|,
operator|*
name|ip
argument_list|,
name|imm_expr
operator|.
name|X_add_number
argument_list|)
expr_stmt|;
name|imm_expr
operator|.
name|X_op
operator|=
name|O_absent
expr_stmt|;
name|s
operator|=
name|expr_end
expr_stmt|;
continue|continue;
case|case
literal|'c'
case|:
comment|/* break code */
name|my_getExpression
argument_list|(
operator|&
name|imm_expr
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|check_absolute_expr
argument_list|(
name|ip
argument_list|,
operator|&
name|imm_expr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|unsigned
name|long
operator|)
name|imm_expr
operator|.
name|X_add_number
operator|>
name|OP_MASK_CODE
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"Code for %s not in range 0..1023 (%lu)"
argument_list|)
argument_list|,
name|ip
operator|->
name|insn_mo
operator|->
name|name
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|imm_expr
operator|.
name|X_add_number
argument_list|)
expr_stmt|;
name|INSERT_OPERAND
argument_list|(
name|CODE
argument_list|,
operator|*
name|ip
argument_list|,
name|imm_expr
operator|.
name|X_add_number
argument_list|)
expr_stmt|;
name|imm_expr
operator|.
name|X_op
operator|=
name|O_absent
expr_stmt|;
name|s
operator|=
name|expr_end
expr_stmt|;
continue|continue;
case|case
literal|'q'
case|:
comment|/* lower break code */
name|my_getExpression
argument_list|(
operator|&
name|imm_expr
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|check_absolute_expr
argument_list|(
name|ip
argument_list|,
operator|&
name|imm_expr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|unsigned
name|long
operator|)
name|imm_expr
operator|.
name|X_add_number
operator|>
name|OP_MASK_CODE2
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"Lower code for %s not in range 0..1023 (%lu)"
argument_list|)
argument_list|,
name|ip
operator|->
name|insn_mo
operator|->
name|name
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|imm_expr
operator|.
name|X_add_number
argument_list|)
expr_stmt|;
name|INSERT_OPERAND
argument_list|(
name|CODE2
argument_list|,
operator|*
name|ip
argument_list|,
name|imm_expr
operator|.
name|X_add_number
argument_list|)
expr_stmt|;
name|imm_expr
operator|.
name|X_op
operator|=
name|O_absent
expr_stmt|;
name|s
operator|=
name|expr_end
expr_stmt|;
continue|continue;
case|case
literal|'y'
case|:
comment|/* Decode 10-bits of seqi/snei's signed constant offset. Issue  		 a warning message if the value is not within the range.  */
name|my_getExpression
argument_list|(
operator|&
name|imm_expr
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|check_absolute_expr
argument_list|(
name|ip
argument_list|,
operator|&
name|imm_expr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|unsigned
name|long
operator|)
name|imm_expr
operator|.
name|X_add_number
operator|+
literal|0x200
operator|)
operator|>
literal|1023
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"Illegal 10-bit signed constant (%lu)"
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|imm_expr
operator|.
name|X_add_number
argument_list|)
expr_stmt|;
name|imm_expr
operator|.
name|X_add_number
operator|&=
name|OP_MASK_CODE2
expr_stmt|;
block|}
name|ip
operator|->
name|insn_opcode
operator||=
operator|(
name|imm_expr
operator|.
name|X_add_number
operator|&
name|OP_MASK_CODE2
operator|)
operator|<<
name|OP_SH_CODE2
expr_stmt|;
name|imm_expr
operator|.
name|X_op
operator|=
name|O_absent
expr_stmt|;
name|s
operator|=
name|expr_end
expr_stmt|;
continue|continue;
case|case
literal|'B'
case|:
comment|/* 20-bit syscall/break code.  */
name|my_getExpression
argument_list|(
operator|&
name|imm_expr
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|check_absolute_expr
argument_list|(
name|ip
argument_list|,
operator|&
name|imm_expr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|unsigned
name|long
operator|)
name|imm_expr
operator|.
name|X_add_number
operator|>
name|OP_MASK_CODE20
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"Code for %s not in range 0..1048575 (%lu)"
argument_list|)
argument_list|,
name|ip
operator|->
name|insn_mo
operator|->
name|name
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|imm_expr
operator|.
name|X_add_number
argument_list|)
expr_stmt|;
name|INSERT_OPERAND
argument_list|(
name|CODE20
argument_list|,
operator|*
name|ip
argument_list|,
name|imm_expr
operator|.
name|X_add_number
argument_list|)
expr_stmt|;
name|imm_expr
operator|.
name|X_op
operator|=
name|O_absent
expr_stmt|;
name|s
operator|=
name|expr_end
expr_stmt|;
continue|continue;
case|case
literal|'C'
case|:
comment|/* Coprocessor code */
name|my_getExpression
argument_list|(
operator|&
name|imm_expr
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|check_absolute_expr
argument_list|(
name|ip
argument_list|,
operator|&
name|imm_expr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|unsigned
name|long
operator|)
name|imm_expr
operator|.
name|X_add_number
operator|>
name|OP_MASK_COPZ
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"Coproccesor code> 25 bits (%lu)"
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|imm_expr
operator|.
name|X_add_number
argument_list|)
expr_stmt|;
name|imm_expr
operator|.
name|X_add_number
operator|&=
name|OP_MASK_COPZ
expr_stmt|;
block|}
name|INSERT_OPERAND
argument_list|(
name|COPZ
argument_list|,
operator|*
name|ip
argument_list|,
name|imm_expr
operator|.
name|X_add_number
argument_list|)
expr_stmt|;
name|imm_expr
operator|.
name|X_op
operator|=
name|O_absent
expr_stmt|;
name|s
operator|=
name|expr_end
expr_stmt|;
continue|continue;
case|case
literal|'J'
case|:
comment|/* 19-bit wait code.  */
name|my_getExpression
argument_list|(
operator|&
name|imm_expr
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|check_absolute_expr
argument_list|(
name|ip
argument_list|,
operator|&
name|imm_expr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|unsigned
name|long
operator|)
name|imm_expr
operator|.
name|X_add_number
operator|>
name|OP_MASK_CODE19
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"Illegal 19-bit code (%lu)"
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|imm_expr
operator|.
name|X_add_number
argument_list|)
expr_stmt|;
name|imm_expr
operator|.
name|X_add_number
operator|&=
name|OP_MASK_CODE19
expr_stmt|;
block|}
name|INSERT_OPERAND
argument_list|(
name|CODE19
argument_list|,
operator|*
name|ip
argument_list|,
name|imm_expr
operator|.
name|X_add_number
argument_list|)
expr_stmt|;
name|imm_expr
operator|.
name|X_op
operator|=
name|O_absent
expr_stmt|;
name|s
operator|=
name|expr_end
expr_stmt|;
continue|continue;
case|case
literal|'P'
case|:
comment|/* Performance register.  */
name|my_getExpression
argument_list|(
operator|&
name|imm_expr
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|check_absolute_expr
argument_list|(
name|ip
argument_list|,
operator|&
name|imm_expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|imm_expr
operator|.
name|X_add_number
operator|!=
literal|0
operator|&&
name|imm_expr
operator|.
name|X_add_number
operator|!=
literal|1
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"Invalid performance register (%lu)"
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|imm_expr
operator|.
name|X_add_number
argument_list|)
expr_stmt|;
name|INSERT_OPERAND
argument_list|(
name|PERFREG
argument_list|,
operator|*
name|ip
argument_list|,
name|imm_expr
operator|.
name|X_add_number
argument_list|)
expr_stmt|;
name|imm_expr
operator|.
name|X_op
operator|=
name|O_absent
expr_stmt|;
name|s
operator|=
name|expr_end
expr_stmt|;
continue|continue;
case|case
literal|'G'
case|:
comment|/* Coprocessor destination register.  */
if|if
condition|(
operator|(
operator|(
name|ip
operator|->
name|insn_opcode
operator|>>
name|OP_SH_OP
operator|)
operator|&
name|OP_MASK_OP
operator|)
operator|==
name|OP_OP_COP0
condition|)
name|ok
operator|=
name|reg_lookup
argument_list|(
operator|&
name|s
argument_list|,
name|RTYPE_NUM
operator||
name|RTYPE_CP0
argument_list|,
operator|&
name|regno
argument_list|)
expr_stmt|;
else|else
name|ok
operator|=
name|reg_lookup
argument_list|(
operator|&
name|s
argument_list|,
name|RTYPE_NUM
operator||
name|RTYPE_GP
argument_list|,
operator|&
name|regno
argument_list|)
expr_stmt|;
name|INSERT_OPERAND
argument_list|(
name|RD
argument_list|,
operator|*
name|ip
argument_list|,
name|regno
argument_list|)
expr_stmt|;
if|if
condition|(
name|ok
condition|)
block|{
name|lastregno
operator|=
name|regno
expr_stmt|;
continue|continue;
block|}
else|else
break|break;
case|case
literal|'b'
case|:
comment|/* base register */
case|case
literal|'d'
case|:
comment|/* destination register */
case|case
literal|'s'
case|:
comment|/* source register */
case|case
literal|'t'
case|:
comment|/* target register */
case|case
literal|'r'
case|:
comment|/* both target and source */
case|case
literal|'v'
case|:
comment|/* both dest and source */
case|case
literal|'w'
case|:
comment|/* both dest and target */
case|case
literal|'E'
case|:
comment|/* coprocessor target register */
case|case
literal|'K'
case|:
comment|/* 'rdhwr' destination register */
case|case
literal|'x'
case|:
comment|/* ignore register name */
case|case
literal|'z'
case|:
comment|/* must be zero register */
case|case
literal|'U'
case|:
comment|/* destination register (clo/clz).  */
case|case
literal|'g'
case|:
comment|/* coprocessor destination register */
name|s_reset
operator|=
name|s
expr_stmt|;
if|if
condition|(
operator|*
name|args
operator|==
literal|'E'
operator|||
operator|*
name|args
operator|==
literal|'K'
condition|)
name|ok
operator|=
name|reg_lookup
argument_list|(
operator|&
name|s
argument_list|,
name|RTYPE_NUM
argument_list|,
operator|&
name|regno
argument_list|)
expr_stmt|;
else|else
block|{
name|ok
operator|=
name|reg_lookup
argument_list|(
operator|&
name|s
argument_list|,
name|RTYPE_NUM
operator||
name|RTYPE_GP
argument_list|,
operator|&
name|regno
argument_list|)
expr_stmt|;
if|if
condition|(
name|regno
operator|==
name|AT
operator|&&
operator|!
name|mips_opts
operator|.
name|noat
condition|)
name|as_warn
argument_list|(
literal|"Used $at without \".set noat\""
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ok
condition|)
block|{
name|c
operator|=
operator|*
name|args
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|' '
condition|)
operator|++
name|s
expr_stmt|;
if|if
condition|(
name|args
index|[
literal|1
index|]
operator|!=
operator|*
name|s
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'r'
operator|||
name|c
operator|==
literal|'v'
operator|||
name|c
operator|==
literal|'w'
condition|)
block|{
name|regno
operator|=
name|lastregno
expr_stmt|;
name|s
operator|=
name|s_reset
expr_stmt|;
operator|++
name|args
expr_stmt|;
block|}
block|}
comment|/* 'z' only matches $0.  */
if|if
condition|(
name|c
operator|==
literal|'z'
operator|&&
name|regno
operator|!=
literal|0
condition|)
break|break;
comment|/* Now that we have assembled one operand, we use the args string 	 * to figure out where it goes in the instruction.  */
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'r'
case|:
case|case
literal|'s'
case|:
case|case
literal|'v'
case|:
case|case
literal|'b'
case|:
name|INSERT_OPERAND
argument_list|(
name|RS
argument_list|,
operator|*
name|ip
argument_list|,
name|regno
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
case|case
literal|'G'
case|:
case|case
literal|'K'
case|:
case|case
literal|'g'
case|:
name|INSERT_OPERAND
argument_list|(
name|RD
argument_list|,
operator|*
name|ip
argument_list|,
name|regno
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'U'
case|:
name|INSERT_OPERAND
argument_list|(
name|RD
argument_list|,
operator|*
name|ip
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|INSERT_OPERAND
argument_list|(
name|RT
argument_list|,
operator|*
name|ip
argument_list|,
name|regno
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
case|case
literal|'t'
case|:
case|case
literal|'E'
case|:
name|INSERT_OPERAND
argument_list|(
name|RT
argument_list|,
operator|*
name|ip
argument_list|,
name|regno
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
comment|/* This case exists because on the r3000 trunc 			 expands into a macro which requires a gp 			 register.  On the r6000 or r4000 it is 			 assembled into a single instruction which 			 ignores the register.  Thus the insn version 			 is MIPS_ISA2 and uses 'x', and the macro 			 version is MIPS_ISA1 and uses 't'.  */
break|break;
case|case
literal|'z'
case|:
comment|/* This case is for the div instruction, which 			 acts differently if the destination argument 			 is $0.  This only matches $0, and is checked 			 outside the switch.  */
break|break;
case|case
literal|'D'
case|:
comment|/* Itbl operand; not yet implemented. FIXME ?? */
break|break;
comment|/* What about all other operands like 'i', which 			 can be specified in the opcode table? */
block|}
name|lastregno
operator|=
name|regno
expr_stmt|;
continue|continue;
block|}
switch|switch
condition|(
operator|*
name|args
operator|++
condition|)
block|{
case|case
literal|'r'
case|:
case|case
literal|'v'
case|:
name|INSERT_OPERAND
argument_list|(
name|RS
argument_list|,
operator|*
name|ip
argument_list|,
name|lastregno
argument_list|)
expr_stmt|;
continue|continue;
case|case
literal|'w'
case|:
name|INSERT_OPERAND
argument_list|(
name|RT
argument_list|,
operator|*
name|ip
argument_list|,
name|lastregno
argument_list|)
expr_stmt|;
continue|continue;
block|}
break|break;
case|case
literal|'O'
case|:
comment|/* MDMX alignment immediate constant.  */
name|my_getExpression
argument_list|(
operator|&
name|imm_expr
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|check_absolute_expr
argument_list|(
name|ip
argument_list|,
operator|&
name|imm_expr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|unsigned
name|long
operator|)
name|imm_expr
operator|.
name|X_add_number
operator|>
name|OP_MASK_ALN
condition|)
name|as_warn
argument_list|(
literal|"Improper align amount (%ld), using low bits"
argument_list|,
operator|(
name|long
operator|)
name|imm_expr
operator|.
name|X_add_number
argument_list|)
expr_stmt|;
name|INSERT_OPERAND
argument_list|(
name|ALN
argument_list|,
operator|*
name|ip
argument_list|,
name|imm_expr
operator|.
name|X_add_number
argument_list|)
expr_stmt|;
name|imm_expr
operator|.
name|X_op
operator|=
name|O_absent
expr_stmt|;
name|s
operator|=
name|expr_end
expr_stmt|;
continue|continue;
case|case
literal|'Q'
case|:
comment|/* MDMX vector, element sel, or const.  */
if|if
condition|(
name|s
index|[
literal|0
index|]
operator|!=
literal|'$'
condition|)
block|{
comment|/* MDMX Immediate.  */
name|my_getExpression
argument_list|(
operator|&
name|imm_expr
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|check_absolute_expr
argument_list|(
name|ip
argument_list|,
operator|&
name|imm_expr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|unsigned
name|long
operator|)
name|imm_expr
operator|.
name|X_add_number
operator|>
name|OP_MASK_FT
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"Invalid MDMX Immediate (%ld)"
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|imm_expr
operator|.
name|X_add_number
argument_list|)
expr_stmt|;
name|INSERT_OPERAND
argument_list|(
name|FT
argument_list|,
operator|*
name|ip
argument_list|,
name|imm_expr
operator|.
name|X_add_number
argument_list|)
expr_stmt|;
if|if
condition|(
name|ip
operator|->
name|insn_opcode
operator|&
operator|(
name|OP_MASK_VSEL
operator|<<
name|OP_SH_VSEL
operator|)
condition|)
name|ip
operator|->
name|insn_opcode
operator||=
name|MDMX_FMTSEL_IMM_QH
operator|<<
name|OP_SH_VSEL
expr_stmt|;
else|else
name|ip
operator|->
name|insn_opcode
operator||=
name|MDMX_FMTSEL_IMM_OB
operator|<<
name|OP_SH_VSEL
expr_stmt|;
name|imm_expr
operator|.
name|X_op
operator|=
name|O_absent
expr_stmt|;
name|s
operator|=
name|expr_end
expr_stmt|;
continue|continue;
block|}
comment|/* Not MDMX Immediate.  Fall through.  */
case|case
literal|'X'
case|:
comment|/* MDMX destination register.  */
case|case
literal|'Y'
case|:
comment|/* MDMX source register.  */
case|case
literal|'Z'
case|:
comment|/* MDMX target register.  */
name|is_mdmx
operator|=
literal|1
expr_stmt|;
case|case
literal|'D'
case|:
comment|/* floating point destination register */
case|case
literal|'S'
case|:
comment|/* floating point source register */
case|case
literal|'T'
case|:
comment|/* floating point target register */
case|case
literal|'R'
case|:
comment|/* floating point source register */
case|case
literal|'V'
case|:
case|case
literal|'W'
case|:
name|rtype
operator|=
name|RTYPE_FPU
expr_stmt|;
if|if
condition|(
name|is_mdmx
operator|||
operator|(
name|mips_opts
operator|.
name|ase_mdmx
operator|&&
operator|(
name|ip
operator|->
name|insn_mo
operator|->
name|pinfo
operator|&
name|FP_D
operator|)
operator|&&
operator|(
name|ip
operator|->
name|insn_mo
operator|->
name|pinfo
operator|&
operator|(
name|INSN_COPROC_MOVE_DELAY
operator||
name|INSN_COPROC_MEMORY_DELAY
operator||
name|INSN_LOAD_COPROC_DELAY
operator||
name|INSN_LOAD_MEMORY_DELAY
operator||
name|INSN_STORE_MEMORY
operator|)
operator|)
operator|)
condition|)
name|rtype
operator||=
name|RTYPE_VEC
expr_stmt|;
name|s_reset
operator|=
name|s
expr_stmt|;
if|if
condition|(
name|mips_opts
operator|.
name|arch
operator|==
name|CPU_OCTEON
operator|&&
name|octeon_error_on_unsupported
condition|)
block|{
name|insn_error
operator|=
literal|"opcode not implemented in Octeon"
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|reg_lookup
argument_list|(
operator|&
name|s
argument_list|,
name|rtype
argument_list|,
operator|&
name|regno
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|regno
operator|&
literal|1
operator|)
operator|!=
literal|0
operator|&&
name|HAVE_32BIT_FPRS
operator|&&
operator|!
name|mips_oddfpreg_ok
argument_list|(
name|ip
operator|->
name|insn_mo
argument_list|,
name|argnum
argument_list|)
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"Float register should be even, was %d"
argument_list|)
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|c
operator|=
operator|*
name|args
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|' '
condition|)
operator|++
name|s
expr_stmt|;
if|if
condition|(
name|args
index|[
literal|1
index|]
operator|!=
operator|*
name|s
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'V'
operator|||
name|c
operator|==
literal|'W'
condition|)
block|{
name|regno
operator|=
name|lastregno
expr_stmt|;
name|s
operator|=
name|s_reset
expr_stmt|;
operator|++
name|args
expr_stmt|;
block|}
block|}
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'D'
case|:
case|case
literal|'X'
case|:
name|INSERT_OPERAND
argument_list|(
name|FD
argument_list|,
operator|*
name|ip
argument_list|,
name|regno
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'V'
case|:
case|case
literal|'S'
case|:
case|case
literal|'Y'
case|:
name|INSERT_OPERAND
argument_list|(
name|FS
argument_list|,
operator|*
name|ip
argument_list|,
name|regno
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'Q'
case|:
comment|/* This is like 'Z', but also needs to fix the MDMX 			 vector/scalar select bits.  Note that the 			 scalar immediate case is handled above.  */
if|if
condition|(
operator|*
name|s
operator|==
literal|'['
condition|)
block|{
name|int
name|is_qh
init|=
operator|(
name|ip
operator|->
name|insn_opcode
operator|&
operator|(
literal|1
operator|<<
name|OP_SH_VSEL
operator|)
operator|)
decl_stmt|;
name|int
name|max_el
init|=
operator|(
name|is_qh
condition|?
literal|3
else|:
literal|7
operator|)
decl_stmt|;
name|s
operator|++
expr_stmt|;
name|my_getExpression
argument_list|(
operator|&
name|imm_expr
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|check_absolute_expr
argument_list|(
name|ip
argument_list|,
operator|&
name|imm_expr
argument_list|)
expr_stmt|;
name|s
operator|=
name|expr_end
expr_stmt|;
if|if
condition|(
name|imm_expr
operator|.
name|X_add_number
operator|>
name|max_el
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Bad element selector %ld"
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|imm_expr
operator|.
name|X_add_number
argument_list|)
expr_stmt|;
name|imm_expr
operator|.
name|X_add_number
operator|&=
name|max_el
expr_stmt|;
name|ip
operator|->
name|insn_opcode
operator||=
operator|(
name|imm_expr
operator|.
name|X_add_number
operator|<<
operator|(
name|OP_SH_VSEL
operator|+
operator|(
name|is_qh
condition|?
literal|2
else|:
literal|1
operator|)
operator|)
operator|)
expr_stmt|;
name|imm_expr
operator|.
name|X_op
operator|=
name|O_absent
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|!=
literal|']'
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"Expecting ']' found '%s'"
argument_list|)
argument_list|,
name|s
argument_list|)
expr_stmt|;
else|else
name|s
operator|++
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ip
operator|->
name|insn_opcode
operator|&
operator|(
name|OP_MASK_VSEL
operator|<<
name|OP_SH_VSEL
operator|)
condition|)
name|ip
operator|->
name|insn_opcode
operator||=
operator|(
name|MDMX_FMTSEL_VEC_QH
operator|<<
name|OP_SH_VSEL
operator|)
expr_stmt|;
else|else
name|ip
operator|->
name|insn_opcode
operator||=
operator|(
name|MDMX_FMTSEL_VEC_OB
operator|<<
name|OP_SH_VSEL
operator|)
expr_stmt|;
block|}
comment|/* Fall through */
case|case
literal|'W'
case|:
case|case
literal|'T'
case|:
case|case
literal|'Z'
case|:
name|INSERT_OPERAND
argument_list|(
name|FT
argument_list|,
operator|*
name|ip
argument_list|,
name|regno
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'R'
case|:
name|INSERT_OPERAND
argument_list|(
name|FR
argument_list|,
operator|*
name|ip
argument_list|,
name|regno
argument_list|)
expr_stmt|;
break|break;
block|}
name|lastregno
operator|=
name|regno
expr_stmt|;
continue|continue;
block|}
switch|switch
condition|(
operator|*
name|args
operator|++
condition|)
block|{
case|case
literal|'V'
case|:
name|INSERT_OPERAND
argument_list|(
name|FS
argument_list|,
operator|*
name|ip
argument_list|,
name|lastregno
argument_list|)
expr_stmt|;
continue|continue;
case|case
literal|'W'
case|:
name|INSERT_OPERAND
argument_list|(
name|FT
argument_list|,
operator|*
name|ip
argument_list|,
name|lastregno
argument_list|)
expr_stmt|;
continue|continue;
block|}
break|break;
case|case
literal|'I'
case|:
name|my_getExpression
argument_list|(
operator|&
name|imm_expr
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|imm_expr
operator|.
name|X_op
operator|!=
name|O_big
operator|&&
name|imm_expr
operator|.
name|X_op
operator|!=
name|O_constant
condition|)
name|insn_error
operator|=
name|_
argument_list|(
literal|"absolute expression required"
argument_list|)
expr_stmt|;
if|if
condition|(
name|HAVE_32BIT_GPRS
condition|)
name|normalize_constant_expr
argument_list|(
operator|&
name|imm_expr
argument_list|)
expr_stmt|;
name|s
operator|=
name|expr_end
expr_stmt|;
continue|continue;
case|case
literal|'A'
case|:
name|my_getExpression
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|normalize_address_expr
argument_list|(
operator|&
name|offset_expr
argument_list|)
expr_stmt|;
operator|*
name|imm_reloc
operator|=
name|BFD_RELOC_32
expr_stmt|;
name|s
operator|=
name|expr_end
expr_stmt|;
continue|continue;
case|case
literal|'F'
case|:
case|case
literal|'L'
case|:
case|case
literal|'f'
case|:
case|case
literal|'l'
case|:
block|{
name|int
name|f64
decl_stmt|;
name|int
name|using_gprs
decl_stmt|;
name|char
modifier|*
name|save_in
decl_stmt|;
name|char
modifier|*
name|err
decl_stmt|;
name|unsigned
name|char
name|temp
index|[
literal|8
index|]
decl_stmt|;
name|int
name|len
decl_stmt|;
name|unsigned
name|int
name|length
decl_stmt|;
name|segT
name|seg
decl_stmt|;
name|subsegT
name|subseg
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
comment|/* These only appear as the last operand in an 		   instruction, and every instruction that accepts 		   them in any variant accepts them in all variants. 		   This means we don't have to worry about backing out 		   any changes if the instruction does not match.  		   The difference between them is the size of the 		   floating point constant and where it goes.  For 'F' 		   and 'L' the constant is 64 bits; for 'f' and 'l' it 		   is 32 bits.  Where the constant is placed is based 		   on how the MIPS assembler does things: 		    F -- .rdata 		    L -- .lit8 		    f -- immediate value 		    l -- .lit4  		    The .lit4 and .lit8 sections are only used if 		    permitted by the -G argument.  		    The code below needs to know whether the target register 		    is 32 or 64 bits wide.  It relies on the fact 'f' and 		    'F' are used with GPR-based instructions and 'l' and 		    'L' are used with FPR-based instructions.  */
name|f64
operator|=
operator|*
name|args
operator|==
literal|'F'
operator|||
operator|*
name|args
operator|==
literal|'L'
expr_stmt|;
name|using_gprs
operator|=
operator|*
name|args
operator|==
literal|'F'
operator|||
operator|*
name|args
operator|==
literal|'f'
expr_stmt|;
name|save_in
operator|=
name|input_line_pointer
expr_stmt|;
name|input_line_pointer
operator|=
name|s
expr_stmt|;
name|err
operator|=
name|md_atof
argument_list|(
name|f64
condition|?
literal|'d'
else|:
literal|'f'
argument_list|,
operator|(
name|char
operator|*
operator|)
name|temp
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
name|length
operator|=
name|len
expr_stmt|;
name|s
operator|=
name|input_line_pointer
expr_stmt|;
name|input_line_pointer
operator|=
name|save_in
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|NULL
operator|&&
operator|*
name|err
operator|!=
literal|'\0'
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Bad floating point constant: %s"
argument_list|)
argument_list|,
name|err
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|temp
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
name|temp
argument_list|)
expr_stmt|;
name|length
operator|=
name|f64
condition|?
literal|8
else|:
literal|4
expr_stmt|;
block|}
name|assert
argument_list|(
name|length
operator|==
call|(
name|unsigned
call|)
argument_list|(
name|f64
condition|?
literal|8
else|:
literal|4
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|args
operator|==
literal|'f'
operator|||
operator|(
operator|*
name|args
operator|==
literal|'l'
operator|&&
operator|(
name|g_switch_value
operator|<
literal|4
operator|||
operator|(
name|temp
index|[
literal|0
index|]
operator|==
literal|0
operator|&&
name|temp
index|[
literal|1
index|]
operator|==
literal|0
operator|)
operator|||
operator|(
name|temp
index|[
literal|2
index|]
operator|==
literal|0
operator|&&
name|temp
index|[
literal|3
index|]
operator|==
literal|0
operator|)
operator|)
operator|)
condition|)
block|{
name|imm_expr
operator|.
name|X_op
operator|=
name|O_constant
expr_stmt|;
if|if
condition|(
operator|!
name|target_big_endian
condition|)
name|imm_expr
operator|.
name|X_add_number
operator|=
name|bfd_getl32
argument_list|(
name|temp
argument_list|)
expr_stmt|;
else|else
name|imm_expr
operator|.
name|X_add_number
operator|=
name|bfd_getb32
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|length
operator|>
literal|4
operator|&&
operator|!
name|mips_disable_float_construction
comment|/* Constants can only be constructed in GPRs and 			    copied to FPRs if the GPRs are at least as wide 			    as the FPRs.  Force the constant into memory if 			    we are using 64-bit FPRs but the GPRs are only 			    32 bits wide.  */
operator|&&
operator|(
name|using_gprs
operator|||
operator|!
operator|(
name|HAVE_64BIT_FPRS
operator|&&
name|HAVE_32BIT_GPRS
operator|)
operator|)
operator|&&
operator|(
operator|(
name|temp
index|[
literal|0
index|]
operator|==
literal|0
operator|&&
name|temp
index|[
literal|1
index|]
operator|==
literal|0
operator|)
operator|||
operator|(
name|temp
index|[
literal|2
index|]
operator|==
literal|0
operator|&&
name|temp
index|[
literal|3
index|]
operator|==
literal|0
operator|)
operator|)
operator|&&
operator|(
operator|(
name|temp
index|[
literal|4
index|]
operator|==
literal|0
operator|&&
name|temp
index|[
literal|5
index|]
operator|==
literal|0
operator|)
operator|||
operator|(
name|temp
index|[
literal|6
index|]
operator|==
literal|0
operator|&&
name|temp
index|[
literal|7
index|]
operator|==
literal|0
operator|)
operator|)
condition|)
block|{
comment|/* The value is simple enough to load with a couple of                        instructions.  If using 32-bit registers, set                        imm_expr to the high order 32 bits and offset_expr to                        the low order 32 bits.  Otherwise, set imm_expr to                        the entire 64 bit constant.  */
if|if
condition|(
name|using_gprs
condition|?
name|HAVE_32BIT_GPRS
else|:
name|HAVE_32BIT_FPRS
condition|)
block|{
name|imm_expr
operator|.
name|X_op
operator|=
name|O_constant
expr_stmt|;
name|offset_expr
operator|.
name|X_op
operator|=
name|O_constant
expr_stmt|;
if|if
condition|(
operator|!
name|target_big_endian
condition|)
block|{
name|imm_expr
operator|.
name|X_add_number
operator|=
name|bfd_getl32
argument_list|(
name|temp
operator|+
literal|4
argument_list|)
expr_stmt|;
name|offset_expr
operator|.
name|X_add_number
operator|=
name|bfd_getl32
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|imm_expr
operator|.
name|X_add_number
operator|=
name|bfd_getb32
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|offset_expr
operator|.
name|X_add_number
operator|=
name|bfd_getb32
argument_list|(
name|temp
operator|+
literal|4
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|offset_expr
operator|.
name|X_add_number
operator|==
literal|0
condition|)
name|offset_expr
operator|.
name|X_op
operator|=
name|O_absent
expr_stmt|;
block|}
elseif|else
if|if
condition|(
sizeof|sizeof
argument_list|(
name|imm_expr
operator|.
name|X_add_number
argument_list|)
operator|>
literal|4
condition|)
block|{
name|imm_expr
operator|.
name|X_op
operator|=
name|O_constant
expr_stmt|;
if|if
condition|(
operator|!
name|target_big_endian
condition|)
name|imm_expr
operator|.
name|X_add_number
operator|=
name|bfd_getl64
argument_list|(
name|temp
argument_list|)
expr_stmt|;
else|else
name|imm_expr
operator|.
name|X_add_number
operator|=
name|bfd_getb64
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|imm_expr
operator|.
name|X_op
operator|=
name|O_big
expr_stmt|;
name|imm_expr
operator|.
name|X_add_number
operator|=
literal|4
expr_stmt|;
if|if
condition|(
operator|!
name|target_big_endian
condition|)
block|{
name|generic_bignum
index|[
literal|0
index|]
operator|=
name|bfd_getl16
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|generic_bignum
index|[
literal|1
index|]
operator|=
name|bfd_getl16
argument_list|(
name|temp
operator|+
literal|2
argument_list|)
expr_stmt|;
name|generic_bignum
index|[
literal|2
index|]
operator|=
name|bfd_getl16
argument_list|(
name|temp
operator|+
literal|4
argument_list|)
expr_stmt|;
name|generic_bignum
index|[
literal|3
index|]
operator|=
name|bfd_getl16
argument_list|(
name|temp
operator|+
literal|6
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|generic_bignum
index|[
literal|0
index|]
operator|=
name|bfd_getb16
argument_list|(
name|temp
operator|+
literal|6
argument_list|)
expr_stmt|;
name|generic_bignum
index|[
literal|1
index|]
operator|=
name|bfd_getb16
argument_list|(
name|temp
operator|+
literal|4
argument_list|)
expr_stmt|;
name|generic_bignum
index|[
literal|2
index|]
operator|=
name|bfd_getb16
argument_list|(
name|temp
operator|+
literal|2
argument_list|)
expr_stmt|;
name|generic_bignum
index|[
literal|3
index|]
operator|=
name|bfd_getb16
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
specifier|const
name|char
modifier|*
name|newname
decl_stmt|;
name|segT
name|new_seg
decl_stmt|;
comment|/* Switch to the right section.  */
name|seg
operator|=
name|now_seg
expr_stmt|;
name|subseg
operator|=
name|now_subseg
expr_stmt|;
switch|switch
condition|(
operator|*
name|args
condition|)
block|{
default|default:
comment|/* unused default case avoids warnings.  */
case|case
literal|'L'
case|:
name|newname
operator|=
name|RDATA_SECTION_NAME
expr_stmt|;
if|if
condition|(
name|g_switch_value
operator|>=
literal|8
condition|)
name|newname
operator|=
literal|".lit8"
expr_stmt|;
break|break;
case|case
literal|'F'
case|:
name|newname
operator|=
name|RDATA_SECTION_NAME
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|assert
argument_list|(
name|g_switch_value
operator|>=
literal|4
argument_list|)
expr_stmt|;
name|newname
operator|=
literal|".lit4"
expr_stmt|;
break|break;
block|}
name|new_seg
operator|=
name|subseg_new
argument_list|(
name|newname
argument_list|,
operator|(
name|subsegT
operator|)
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_ELF
condition|)
name|bfd_set_section_flags
argument_list|(
name|stdoutput
argument_list|,
name|new_seg
argument_list|,
operator|(
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_READONLY
operator||
name|SEC_DATA
operator|)
argument_list|)
expr_stmt|;
name|frag_align
argument_list|(
operator|*
name|args
operator|==
literal|'l'
condition|?
literal|2
else|:
literal|3
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_ELF
operator|&&
name|strcmp
argument_list|(
name|TARGET_OS
argument_list|,
literal|"elf"
argument_list|)
operator|!=
literal|0
condition|)
name|record_alignment
argument_list|(
name|new_seg
argument_list|,
literal|4
argument_list|)
expr_stmt|;
else|else
name|record_alignment
argument_list|(
name|new_seg
argument_list|,
operator|*
name|args
operator|==
literal|'l'
condition|?
literal|2
else|:
literal|3
argument_list|)
expr_stmt|;
if|if
condition|(
name|seg
operator|==
name|now_seg
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Can't use floating point insn in this section"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Set the argument to the current address in the 		       section.  */
name|offset_expr
operator|.
name|X_op
operator|=
name|O_symbol
expr_stmt|;
name|offset_expr
operator|.
name|X_add_symbol
operator|=
name|symbol_new
argument_list|(
literal|"L0\001"
argument_list|,
name|now_seg
argument_list|,
operator|(
name|valueT
operator|)
name|frag_now_fix
argument_list|()
argument_list|,
name|frag_now
argument_list|)
expr_stmt|;
name|offset_expr
operator|.
name|X_add_number
operator|=
literal|0
expr_stmt|;
comment|/* Put the floating point number into the section.  */
name|p
operator|=
name|frag_more
argument_list|(
operator|(
name|int
operator|)
name|length
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|p
argument_list|,
name|temp
argument_list|,
name|length
argument_list|)
expr_stmt|;
comment|/* Switch back to the original section.  */
name|subseg_set
argument_list|(
name|seg
argument_list|,
name|subseg
argument_list|)
expr_stmt|;
block|}
block|}
continue|continue;
case|case
literal|'i'
case|:
comment|/* 16 bit unsigned immediate */
case|case
literal|'j'
case|:
comment|/* 16 bit signed immediate */
operator|*
name|imm_reloc
operator|=
name|BFD_RELOC_LO16
expr_stmt|;
if|if
condition|(
name|my_getSmallExpression
argument_list|(
operator|&
name|imm_expr
argument_list|,
name|imm_reloc
argument_list|,
name|s
argument_list|)
operator|==
literal|0
condition|)
block|{
name|int
name|more
decl_stmt|;
name|offsetT
name|minval
decl_stmt|,
name|maxval
decl_stmt|;
name|more
operator|=
operator|(
name|insn
operator|+
literal|1
operator|<
operator|&
name|mips_opcodes
index|[
name|NUMOPCODES
index|]
operator|&&
name|strcmp
argument_list|(
name|insn
operator|->
name|name
argument_list|,
name|insn
index|[
literal|1
index|]
operator|.
name|name
argument_list|)
operator|==
literal|0
operator|)
expr_stmt|;
comment|/* If the expression was written as an unsigned number, 		     only treat it as signed if there are no more 		     alternatives.  */
if|if
condition|(
name|more
operator|&&
operator|*
name|args
operator|==
literal|'j'
operator|&&
sizeof|sizeof
argument_list|(
name|imm_expr
operator|.
name|X_add_number
argument_list|)
operator|<=
literal|4
operator|&&
name|imm_expr
operator|.
name|X_op
operator|==
name|O_constant
operator|&&
name|imm_expr
operator|.
name|X_add_number
operator|<
literal|0
operator|&&
name|imm_expr
operator|.
name|X_unsigned
operator|&&
name|HAVE_64BIT_GPRS
condition|)
break|break;
comment|/* For compatibility with older assemblers, we accept 		     0x8000-0xffff as signed 16-bit numbers when only 		     signed numbers are allowed.  */
if|if
condition|(
operator|*
name|args
operator|==
literal|'i'
condition|)
name|minval
operator|=
literal|0
operator|,
name|maxval
operator|=
literal|0xffff
expr_stmt|;
elseif|else
if|if
condition|(
name|more
condition|)
name|minval
operator|=
operator|-
literal|0x8000
operator|,
name|maxval
operator|=
literal|0x7fff
expr_stmt|;
else|else
name|minval
operator|=
operator|-
literal|0x8000
operator|,
name|maxval
operator|=
literal|0xffff
expr_stmt|;
if|if
condition|(
name|imm_expr
operator|.
name|X_op
operator|!=
name|O_constant
operator|||
name|imm_expr
operator|.
name|X_add_number
operator|<
name|minval
operator|||
name|imm_expr
operator|.
name|X_add_number
operator|>
name|maxval
condition|)
block|{
if|if
condition|(
name|more
condition|)
break|break;
if|if
condition|(
name|imm_expr
operator|.
name|X_op
operator|==
name|O_constant
operator|||
name|imm_expr
operator|.
name|X_op
operator|==
name|O_big
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"expression out of range"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|s
operator|=
name|expr_end
expr_stmt|;
continue|continue;
case|case
literal|'o'
case|:
comment|/* 16 bit offset */
comment|/* Check whether there is only a single bracketed expression 		 left.  If so, it must be the base register and the 		 constant must be zero.  */
if|if
condition|(
operator|*
name|s
operator|==
literal|'('
operator|&&
name|strchr
argument_list|(
name|s
operator|+
literal|1
argument_list|,
literal|'('
argument_list|)
operator|==
literal|0
condition|)
block|{
name|offset_expr
operator|.
name|X_op
operator|=
name|O_constant
expr_stmt|;
name|offset_expr
operator|.
name|X_add_number
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
comment|/* If this value won't fit into a 16 bit offset, then go 		 find a macro that will generate the 32 bit offset 		 code pattern.  */
if|if
condition|(
name|my_getSmallExpression
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|offset_reloc
argument_list|,
name|s
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|offset_expr
operator|.
name|X_op
operator|!=
name|O_constant
operator|||
name|offset_expr
operator|.
name|X_add_number
operator|>=
literal|0x8000
operator|||
name|offset_expr
operator|.
name|X_add_number
operator|<
operator|-
literal|0x8000
operator|)
condition|)
break|break;
name|s
operator|=
name|expr_end
expr_stmt|;
continue|continue;
case|case
literal|'p'
case|:
comment|/* pc relative offset */
operator|*
name|offset_reloc
operator|=
name|BFD_RELOC_16_PCREL_S2
expr_stmt|;
name|my_getExpression
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|s
operator|=
name|expr_end
expr_stmt|;
continue|continue;
case|case
literal|'u'
case|:
comment|/* upper 16 bits */
if|if
condition|(
name|my_getSmallExpression
argument_list|(
operator|&
name|imm_expr
argument_list|,
name|imm_reloc
argument_list|,
name|s
argument_list|)
operator|==
literal|0
operator|&&
name|imm_expr
operator|.
name|X_op
operator|==
name|O_constant
operator|&&
operator|(
name|imm_expr
operator|.
name|X_add_number
operator|<
literal|0
operator|||
name|imm_expr
operator|.
name|X_add_number
operator|>=
literal|0x10000
operator|)
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"lui expression not in range 0..65535"
argument_list|)
argument_list|)
expr_stmt|;
name|s
operator|=
name|expr_end
expr_stmt|;
continue|continue;
case|case
literal|'a'
case|:
comment|/* 26 bit address */
name|my_getExpression
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|s
operator|=
name|expr_end
expr_stmt|;
operator|*
name|offset_reloc
operator|=
name|BFD_RELOC_MIPS_JMP
expr_stmt|;
continue|continue;
case|case
literal|'N'
case|:
comment|/* 3 bit branch condition code */
case|case
literal|'M'
case|:
comment|/* 3 bit compare condition code */
name|rtype
operator|=
name|RTYPE_CCC
expr_stmt|;
if|if
condition|(
name|ip
operator|->
name|insn_mo
operator|->
name|pinfo
operator|&
operator|(
name|FP_D
operator||
name|FP_S
operator|)
condition|)
name|rtype
operator||=
name|RTYPE_FCC
expr_stmt|;
if|if
condition|(
operator|!
name|reg_lookup
argument_list|(
operator|&
name|s
argument_list|,
name|rtype
argument_list|,
operator|&
name|regno
argument_list|)
condition|)
break|break;
if|if
condition|(
operator|(
name|strcmp
argument_list|(
name|str
operator|+
name|strlen
argument_list|(
name|str
argument_list|)
operator|-
literal|3
argument_list|,
literal|".ps"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|str
operator|+
name|strlen
argument_list|(
name|str
argument_list|)
operator|-
literal|5
argument_list|,
literal|"any2f"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|str
operator|+
name|strlen
argument_list|(
name|str
argument_list|)
operator|-
literal|5
argument_list|,
literal|"any2t"
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|regno
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"Condition code register should be even for %s, was %d"
argument_list|)
argument_list|,
name|str
argument_list|,
name|regno
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|strcmp
argument_list|(
name|str
operator|+
name|strlen
argument_list|(
name|str
argument_list|)
operator|-
literal|5
argument_list|,
literal|"any4f"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|str
operator|+
name|strlen
argument_list|(
name|str
argument_list|)
operator|-
literal|5
argument_list|,
literal|"any4t"
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|regno
operator|&
literal|3
operator|)
operator|!=
literal|0
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"Condition code register should be 0 or 4 for %s, was %d"
argument_list|)
argument_list|,
name|str
argument_list|,
name|regno
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|args
operator|==
literal|'N'
condition|)
name|INSERT_OPERAND
argument_list|(
name|BCC
argument_list|,
operator|*
name|ip
argument_list|,
name|regno
argument_list|)
expr_stmt|;
else|else
name|INSERT_OPERAND
argument_list|(
name|CCC
argument_list|,
operator|*
name|ip
argument_list|,
name|regno
argument_list|)
expr_stmt|;
continue|continue;
case|case
literal|'H'
case|:
if|if
condition|(
name|s
index|[
literal|0
index|]
operator|==
literal|'0'
operator|&&
operator|(
name|s
index|[
literal|1
index|]
operator|==
literal|'x'
operator|||
name|s
index|[
literal|1
index|]
operator|==
literal|'X'
operator|)
condition|)
name|s
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|ISDIGIT
argument_list|(
operator|*
name|s
argument_list|)
condition|)
block|{
name|c
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|c
operator|*=
literal|10
expr_stmt|;
name|c
operator|+=
operator|*
name|s
operator|-
literal|'0'
expr_stmt|;
operator|++
name|s
expr_stmt|;
block|}
do|while
condition|(
name|ISDIGIT
argument_list|(
operator|*
name|s
argument_list|)
condition|)
do|;
block|}
else|else
name|c
operator|=
literal|8
expr_stmt|;
comment|/* Invalid sel value.  */
if|if
condition|(
name|c
operator|>
literal|7
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"invalid coprocessor sub-selection value (0-7)"
argument_list|)
argument_list|)
expr_stmt|;
name|ip
operator|->
name|insn_opcode
operator||=
name|c
expr_stmt|;
continue|continue;
case|case
literal|'e'
case|:
comment|/* Must be at least one digit.  */
name|my_getExpression
argument_list|(
operator|&
name|imm_expr
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|check_absolute_expr
argument_list|(
name|ip
argument_list|,
operator|&
name|imm_expr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|unsigned
name|long
operator|)
name|imm_expr
operator|.
name|X_add_number
operator|>
operator|(
name|unsigned
name|long
operator|)
name|OP_MASK_VECBYTE
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"bad byte vector index (%ld)"
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|imm_expr
operator|.
name|X_add_number
argument_list|)
expr_stmt|;
name|imm_expr
operator|.
name|X_add_number
operator|=
literal|0
expr_stmt|;
block|}
name|INSERT_OPERAND
argument_list|(
name|VECBYTE
argument_list|,
operator|*
name|ip
argument_list|,
name|imm_expr
operator|.
name|X_add_number
argument_list|)
expr_stmt|;
name|imm_expr
operator|.
name|X_op
operator|=
name|O_absent
expr_stmt|;
name|s
operator|=
name|expr_end
expr_stmt|;
continue|continue;
case|case
literal|'%'
case|:
name|my_getExpression
argument_list|(
operator|&
name|imm_expr
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|check_absolute_expr
argument_list|(
name|ip
argument_list|,
operator|&
name|imm_expr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|unsigned
name|long
operator|)
name|imm_expr
operator|.
name|X_add_number
operator|>
operator|(
name|unsigned
name|long
operator|)
name|OP_MASK_VECALIGN
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"bad byte vector index (%ld)"
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|imm_expr
operator|.
name|X_add_number
argument_list|)
expr_stmt|;
name|imm_expr
operator|.
name|X_add_number
operator|=
literal|0
expr_stmt|;
block|}
name|INSERT_OPERAND
argument_list|(
name|VECALIGN
argument_list|,
operator|*
name|ip
argument_list|,
name|imm_expr
operator|.
name|X_add_number
argument_list|)
expr_stmt|;
name|imm_expr
operator|.
name|X_op
operator|=
name|O_absent
expr_stmt|;
name|s
operator|=
name|expr_end
expr_stmt|;
continue|continue;
default|default:
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"bad char = '%c'\n"
argument_list|)
argument_list|,
operator|*
name|args
argument_list|)
expr_stmt|;
name|internalError
argument_list|()
expr_stmt|;
block|}
break|break;
block|}
comment|/* Args don't match.  */
if|if
condition|(
name|insn
operator|+
literal|1
operator|<
operator|&
name|mips_opcodes
index|[
name|NUMOPCODES
index|]
operator|&&
operator|!
name|strcmp
argument_list|(
name|insn
operator|->
name|name
argument_list|,
name|insn
index|[
literal|1
index|]
operator|.
name|name
argument_list|)
condition|)
block|{
operator|++
name|insn
expr_stmt|;
name|s
operator|=
name|argsStart
expr_stmt|;
name|insn_error
operator|=
name|_
argument_list|(
literal|"illegal operands"
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|save_c
condition|)
operator|*
operator|(
operator|--
name|s
operator|)
operator|=
name|save_c
expr_stmt|;
name|insn_error
operator|=
name|_
argument_list|(
literal|"illegal operands"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
end_function

begin_define
define|#
directive|define
name|SKIP_SPACE_TABS
parameter_list|(
name|S
parameter_list|)
value|{ while (*(S) == ' ' || *(S) == '\t') ++(S); }
end_define

begin_comment
comment|/* This routine assembles an instruction into its binary format when    assembling for the mips16.  As a side effect, it sets one of the    global variables imm_reloc or offset_reloc to the type of    relocation to do if one of the operands is an address expression.    It also sets mips16_small and mips16_ext if the user explicitly    requested a small or extended instruction.  */
end_comment

begin_function
specifier|static
name|void
name|mips16_ip
parameter_list|(
name|char
modifier|*
name|str
parameter_list|,
name|struct
name|mips_cl_insn
modifier|*
name|ip
parameter_list|)
block|{
name|char
modifier|*
name|s
decl_stmt|;
specifier|const
name|char
modifier|*
name|args
decl_stmt|;
name|struct
name|mips_opcode
modifier|*
name|insn
decl_stmt|;
name|char
modifier|*
name|argsstart
decl_stmt|;
name|unsigned
name|int
name|regno
decl_stmt|;
name|unsigned
name|int
name|lastregno
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|s_reset
decl_stmt|;
name|size_t
name|i
decl_stmt|;
name|insn_error
operator|=
name|NULL
expr_stmt|;
name|mips16_small
operator|=
name|FALSE
expr_stmt|;
name|mips16_ext
operator|=
name|FALSE
expr_stmt|;
for|for
control|(
name|s
operator|=
name|str
init|;
name|ISLOWER
argument_list|(
operator|*
name|s
argument_list|)
condition|;
operator|++
name|s
control|)
empty_stmt|;
switch|switch
condition|(
operator|*
name|s
condition|)
block|{
case|case
literal|'\0'
case|:
break|break;
case|case
literal|' '
case|:
operator|*
name|s
operator|++
operator|=
literal|'\0'
expr_stmt|;
break|break;
case|case
literal|'.'
case|:
if|if
condition|(
name|s
index|[
literal|1
index|]
operator|==
literal|'t'
operator|&&
name|s
index|[
literal|2
index|]
operator|==
literal|' '
condition|)
block|{
operator|*
name|s
operator|=
literal|'\0'
expr_stmt|;
name|mips16_small
operator|=
name|TRUE
expr_stmt|;
name|s
operator|+=
literal|3
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|s
index|[
literal|1
index|]
operator|==
literal|'e'
operator|&&
name|s
index|[
literal|2
index|]
operator|==
literal|' '
condition|)
block|{
operator|*
name|s
operator|=
literal|'\0'
expr_stmt|;
name|mips16_ext
operator|=
name|TRUE
expr_stmt|;
name|s
operator|+=
literal|3
expr_stmt|;
break|break;
block|}
comment|/* Fall through.  */
default|default:
name|insn_error
operator|=
name|_
argument_list|(
literal|"unknown opcode"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|mips_opts
operator|.
name|noautoextend
operator|&&
operator|!
name|mips16_ext
condition|)
name|mips16_small
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
operator|(
name|insn
operator|=
operator|(
expr|struct
name|mips_opcode
operator|*
operator|)
name|hash_find
argument_list|(
name|mips16_op_hash
argument_list|,
name|str
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|insn_error
operator|=
name|_
argument_list|(
literal|"unrecognized opcode"
argument_list|)
expr_stmt|;
return|return;
block|}
name|argsstart
operator|=
name|s
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|bfd_boolean
name|ok
decl_stmt|;
name|assert
argument_list|(
name|strcmp
argument_list|(
name|insn
operator|->
name|name
argument_list|,
name|str
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|OPCODE_IS_MEMBER
argument_list|(
name|insn
argument_list|,
name|mips_opts
operator|.
name|isa
argument_list|,
name|mips_opts
operator|.
name|arch
argument_list|)
condition|)
name|ok
operator|=
name|TRUE
expr_stmt|;
else|else
name|ok
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
operator|!
name|ok
condition|)
block|{
if|if
condition|(
name|insn
operator|+
literal|1
operator|<
operator|&
name|mips16_opcodes
index|[
name|bfd_mips16_num_opcodes
index|]
operator|&&
name|strcmp
argument_list|(
name|insn
operator|->
name|name
argument_list|,
name|insn
index|[
literal|1
index|]
operator|.
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|++
name|insn
expr_stmt|;
continue|continue;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|insn_error
condition|)
block|{
specifier|static
name|char
name|buf
index|[
literal|100
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
name|_
argument_list|(
literal|"opcode not supported on this processor: %s (%s)"
argument_list|)
argument_list|,
name|mips_cpu_info_from_arch
argument_list|(
name|mips_opts
operator|.
name|arch
argument_list|)
operator|->
name|name
argument_list|,
name|mips_cpu_info_from_isa
argument_list|(
name|mips_opts
operator|.
name|isa
argument_list|)
operator|->
name|name
argument_list|)
expr_stmt|;
name|insn_error
operator|=
name|buf
expr_stmt|;
block|}
return|return;
block|}
block|}
name|create_insn
argument_list|(
name|ip
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|imm_expr
operator|.
name|X_op
operator|=
name|O_absent
expr_stmt|;
name|imm_reloc
index|[
literal|0
index|]
operator|=
name|BFD_RELOC_UNUSED
expr_stmt|;
name|imm_reloc
index|[
literal|1
index|]
operator|=
name|BFD_RELOC_UNUSED
expr_stmt|;
name|imm_reloc
index|[
literal|2
index|]
operator|=
name|BFD_RELOC_UNUSED
expr_stmt|;
name|imm2_expr
operator|.
name|X_op
operator|=
name|O_absent
expr_stmt|;
name|offset_expr
operator|.
name|X_op
operator|=
name|O_absent
expr_stmt|;
name|offset_reloc
index|[
literal|0
index|]
operator|=
name|BFD_RELOC_UNUSED
expr_stmt|;
name|offset_reloc
index|[
literal|1
index|]
operator|=
name|BFD_RELOC_UNUSED
expr_stmt|;
name|offset_reloc
index|[
literal|2
index|]
operator|=
name|BFD_RELOC_UNUSED
expr_stmt|;
for|for
control|(
name|args
operator|=
name|insn
operator|->
name|args
init|;
literal|1
condition|;
operator|++
name|args
control|)
block|{
name|int
name|c
decl_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|' '
condition|)
operator|++
name|s
expr_stmt|;
comment|/* In this switch statement we call break if we did not find              a match, continue if we did find a match, or return if we              are done.  */
name|c
operator|=
operator|*
name|args
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\0'
case|:
if|if
condition|(
operator|*
name|s
operator|==
literal|'\0'
condition|)
block|{
comment|/* Stuff the immediate value in now, if we can.  */
if|if
condition|(
name|imm_expr
operator|.
name|X_op
operator|==
name|O_constant
operator|&&
operator|*
name|imm_reloc
operator|>
name|BFD_RELOC_UNUSED
operator|&&
name|insn
operator|->
name|pinfo
operator|!=
name|INSN_MACRO
condition|)
block|{
name|valueT
name|tmp
decl_stmt|;
switch|switch
condition|(
operator|*
name|offset_reloc
condition|)
block|{
case|case
name|BFD_RELOC_MIPS16_HI16_S
case|:
name|tmp
operator|=
operator|(
name|imm_expr
operator|.
name|X_add_number
operator|+
literal|0x8000
operator|)
operator|>>
literal|16
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_MIPS16_HI16
case|:
name|tmp
operator|=
name|imm_expr
operator|.
name|X_add_number
operator|>>
literal|16
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_MIPS16_LO16
case|:
name|tmp
operator|=
operator|(
operator|(
name|imm_expr
operator|.
name|X_add_number
operator|+
literal|0x8000
operator|)
operator|&
literal|0xffff
operator|)
operator|-
literal|0x8000
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_UNUSED
case|:
name|tmp
operator|=
name|imm_expr
operator|.
name|X_add_number
expr_stmt|;
break|break;
default|default:
name|internalError
argument_list|()
expr_stmt|;
block|}
operator|*
name|offset_reloc
operator|=
name|BFD_RELOC_UNUSED
expr_stmt|;
name|mips16_immed
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|,
operator|*
name|imm_reloc
operator|-
name|BFD_RELOC_UNUSED
argument_list|,
name|tmp
argument_list|,
name|TRUE
argument_list|,
name|mips16_small
argument_list|,
name|mips16_ext
argument_list|,
operator|&
name|ip
operator|->
name|insn_opcode
argument_list|,
operator|&
name|ip
operator|->
name|use_extend
argument_list|,
operator|&
name|ip
operator|->
name|extend
argument_list|)
expr_stmt|;
name|imm_expr
operator|.
name|X_op
operator|=
name|O_absent
expr_stmt|;
operator|*
name|imm_reloc
operator|=
name|BFD_RELOC_UNUSED
expr_stmt|;
block|}
return|return;
block|}
break|break;
case|case
literal|','
case|:
if|if
condition|(
operator|*
name|s
operator|++
operator|==
name|c
condition|)
continue|continue;
name|s
operator|--
expr_stmt|;
switch|switch
condition|(
operator|*
operator|++
name|args
condition|)
block|{
case|case
literal|'v'
case|:
name|MIPS16_INSERT_OPERAND
argument_list|(
name|RX
argument_list|,
operator|*
name|ip
argument_list|,
name|lastregno
argument_list|)
expr_stmt|;
continue|continue;
case|case
literal|'w'
case|:
name|MIPS16_INSERT_OPERAND
argument_list|(
name|RY
argument_list|,
operator|*
name|ip
argument_list|,
name|lastregno
argument_list|)
expr_stmt|;
continue|continue;
block|}
break|break;
case|case
literal|'('
case|:
case|case
literal|')'
case|:
if|if
condition|(
operator|*
name|s
operator|++
operator|==
name|c
condition|)
continue|continue;
break|break;
case|case
literal|'v'
case|:
case|case
literal|'w'
case|:
if|if
condition|(
name|s
index|[
literal|0
index|]
operator|!=
literal|'$'
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'v'
condition|)
name|MIPS16_INSERT_OPERAND
argument_list|(
name|RX
argument_list|,
operator|*
name|ip
argument_list|,
name|lastregno
argument_list|)
expr_stmt|;
else|else
name|MIPS16_INSERT_OPERAND
argument_list|(
name|RY
argument_list|,
operator|*
name|ip
argument_list|,
name|lastregno
argument_list|)
expr_stmt|;
operator|++
name|args
expr_stmt|;
continue|continue;
block|}
comment|/* Fall through.  */
case|case
literal|'x'
case|:
case|case
literal|'y'
case|:
case|case
literal|'z'
case|:
case|case
literal|'Z'
case|:
case|case
literal|'0'
case|:
case|case
literal|'S'
case|:
case|case
literal|'R'
case|:
case|case
literal|'X'
case|:
case|case
literal|'Y'
case|:
name|s_reset
operator|=
name|s
expr_stmt|;
if|if
condition|(
operator|!
name|reg_lookup
argument_list|(
operator|&
name|s
argument_list|,
name|RTYPE_NUM
operator||
name|RTYPE_GP
argument_list|,
operator|&
name|regno
argument_list|)
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'v'
operator|||
name|c
operator|==
literal|'w'
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'v'
condition|)
name|MIPS16_INSERT_OPERAND
argument_list|(
name|RX
argument_list|,
operator|*
name|ip
argument_list|,
name|lastregno
argument_list|)
expr_stmt|;
else|else
name|MIPS16_INSERT_OPERAND
argument_list|(
name|RY
argument_list|,
operator|*
name|ip
argument_list|,
name|lastregno
argument_list|)
expr_stmt|;
operator|++
name|args
expr_stmt|;
continue|continue;
block|}
break|break;
block|}
if|if
condition|(
operator|*
name|s
operator|==
literal|' '
condition|)
operator|++
name|s
expr_stmt|;
if|if
condition|(
name|args
index|[
literal|1
index|]
operator|!=
operator|*
name|s
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'v'
operator|||
name|c
operator|==
literal|'w'
condition|)
block|{
name|regno
operator|=
name|mips16_to_32_reg_map
index|[
name|lastregno
index|]
expr_stmt|;
name|s
operator|=
name|s_reset
expr_stmt|;
operator|++
name|args
expr_stmt|;
block|}
block|}
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'x'
case|:
case|case
literal|'y'
case|:
case|case
literal|'z'
case|:
case|case
literal|'v'
case|:
case|case
literal|'w'
case|:
case|case
literal|'Z'
case|:
name|regno
operator|=
name|mips32_to_16_reg_map
index|[
name|regno
index|]
expr_stmt|;
break|break;
case|case
literal|'0'
case|:
if|if
condition|(
name|regno
operator|!=
literal|0
condition|)
name|regno
operator|=
name|ILLEGAL_REG
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
if|if
condition|(
name|regno
operator|!=
name|SP
condition|)
name|regno
operator|=
name|ILLEGAL_REG
expr_stmt|;
break|break;
case|case
literal|'R'
case|:
if|if
condition|(
name|regno
operator|!=
name|RA
condition|)
name|regno
operator|=
name|ILLEGAL_REG
expr_stmt|;
break|break;
case|case
literal|'X'
case|:
case|case
literal|'Y'
case|:
if|if
condition|(
name|regno
operator|==
name|AT
operator|&&
operator|!
name|mips_opts
operator|.
name|noat
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"used $at without \".set noat\""
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|internalError
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|regno
operator|==
name|ILLEGAL_REG
condition|)
break|break;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'x'
case|:
case|case
literal|'v'
case|:
name|MIPS16_INSERT_OPERAND
argument_list|(
name|RX
argument_list|,
operator|*
name|ip
argument_list|,
name|regno
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'y'
case|:
case|case
literal|'w'
case|:
name|MIPS16_INSERT_OPERAND
argument_list|(
name|RY
argument_list|,
operator|*
name|ip
argument_list|,
name|regno
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'z'
case|:
name|MIPS16_INSERT_OPERAND
argument_list|(
name|RZ
argument_list|,
operator|*
name|ip
argument_list|,
name|regno
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'Z'
case|:
name|MIPS16_INSERT_OPERAND
argument_list|(
name|MOVE32Z
argument_list|,
operator|*
name|ip
argument_list|,
name|regno
argument_list|)
expr_stmt|;
case|case
literal|'0'
case|:
case|case
literal|'S'
case|:
case|case
literal|'R'
case|:
break|break;
case|case
literal|'X'
case|:
name|MIPS16_INSERT_OPERAND
argument_list|(
name|REGR32
argument_list|,
operator|*
name|ip
argument_list|,
name|regno
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'Y'
case|:
name|regno
operator|=
operator|(
operator|(
name|regno
operator|&
literal|7
operator|)
operator|<<
literal|2
operator|)
operator||
operator|(
operator|(
name|regno
operator|&
literal|0x18
operator|)
operator|>>
literal|3
operator|)
expr_stmt|;
name|MIPS16_INSERT_OPERAND
argument_list|(
name|REG32R
argument_list|,
operator|*
name|ip
argument_list|,
name|regno
argument_list|)
expr_stmt|;
break|break;
default|default:
name|internalError
argument_list|()
expr_stmt|;
block|}
name|lastregno
operator|=
name|regno
expr_stmt|;
continue|continue;
case|case
literal|'P'
case|:
if|if
condition|(
name|strncmp
argument_list|(
name|s
argument_list|,
literal|"$pc"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
block|{
name|s
operator|+=
literal|3
expr_stmt|;
continue|continue;
block|}
break|break;
case|case
literal|'5'
case|:
case|case
literal|'H'
case|:
case|case
literal|'W'
case|:
case|case
literal|'D'
case|:
case|case
literal|'j'
case|:
case|case
literal|'V'
case|:
case|case
literal|'C'
case|:
case|case
literal|'U'
case|:
case|case
literal|'k'
case|:
case|case
literal|'K'
case|:
name|i
operator|=
name|my_getSmallExpression
argument_list|(
operator|&
name|imm_expr
argument_list|,
name|imm_reloc
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|imm_expr
operator|.
name|X_op
operator|!=
name|O_constant
condition|)
block|{
name|mips16_ext
operator|=
name|TRUE
expr_stmt|;
name|ip
operator|->
name|use_extend
operator|=
name|TRUE
expr_stmt|;
name|ip
operator|->
name|extend
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* We need to relax this instruction.  */
operator|*
name|offset_reloc
operator|=
operator|*
name|imm_reloc
expr_stmt|;
operator|*
name|imm_reloc
operator|=
operator|(
name|int
operator|)
name|BFD_RELOC_UNUSED
operator|+
name|c
expr_stmt|;
block|}
name|s
operator|=
name|expr_end
expr_stmt|;
continue|continue;
block|}
operator|*
name|imm_reloc
operator|=
name|BFD_RELOC_UNUSED
expr_stmt|;
comment|/* Fall through.  */
case|case
literal|'<'
case|:
case|case
literal|'>'
case|:
case|case
literal|'['
case|:
case|case
literal|']'
case|:
case|case
literal|'4'
case|:
case|case
literal|'8'
case|:
name|my_getExpression
argument_list|(
operator|&
name|imm_expr
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|imm_expr
operator|.
name|X_op
operator|==
name|O_register
condition|)
block|{
comment|/* What we thought was an expression turned out to                      be a register.  */
if|if
condition|(
name|s
index|[
literal|0
index|]
operator|==
literal|'('
operator|&&
name|args
index|[
literal|1
index|]
operator|==
literal|'('
condition|)
block|{
comment|/* It looks like the expression was omitted 			 before a register indirection, which means 			 that the expression is implicitly zero.  We 			 still set up imm_expr, so that we handle 			 explicit extensions correctly.  */
name|imm_expr
operator|.
name|X_op
operator|=
name|O_constant
expr_stmt|;
name|imm_expr
operator|.
name|X_add_number
operator|=
literal|0
expr_stmt|;
operator|*
name|imm_reloc
operator|=
operator|(
name|int
operator|)
name|BFD_RELOC_UNUSED
operator|+
name|c
expr_stmt|;
continue|continue;
block|}
break|break;
block|}
comment|/* We need to relax this instruction.  */
operator|*
name|imm_reloc
operator|=
operator|(
name|int
operator|)
name|BFD_RELOC_UNUSED
operator|+
name|c
expr_stmt|;
name|s
operator|=
name|expr_end
expr_stmt|;
continue|continue;
case|case
literal|'p'
case|:
case|case
literal|'q'
case|:
case|case
literal|'A'
case|:
case|case
literal|'B'
case|:
case|case
literal|'E'
case|:
comment|/* We use offset_reloc rather than imm_reloc for the PC                  relative operands.  This lets macros with both                  immediate and address operands work correctly.  */
name|my_getExpression
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset_expr
operator|.
name|X_op
operator|==
name|O_register
condition|)
break|break;
comment|/* We need to relax this instruction.  */
operator|*
name|offset_reloc
operator|=
operator|(
name|int
operator|)
name|BFD_RELOC_UNUSED
operator|+
name|c
expr_stmt|;
name|s
operator|=
name|expr_end
expr_stmt|;
continue|continue;
case|case
literal|'6'
case|:
comment|/* break code */
name|my_getExpression
argument_list|(
operator|&
name|imm_expr
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|check_absolute_expr
argument_list|(
name|ip
argument_list|,
operator|&
name|imm_expr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|unsigned
name|long
operator|)
name|imm_expr
operator|.
name|X_add_number
operator|>
literal|63
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"Invalid value for `%s' (%lu)"
argument_list|)
argument_list|,
name|ip
operator|->
name|insn_mo
operator|->
name|name
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|imm_expr
operator|.
name|X_add_number
argument_list|)
expr_stmt|;
name|MIPS16_INSERT_OPERAND
argument_list|(
name|IMM6
argument_list|,
operator|*
name|ip
argument_list|,
name|imm_expr
operator|.
name|X_add_number
argument_list|)
expr_stmt|;
name|imm_expr
operator|.
name|X_op
operator|=
name|O_absent
expr_stmt|;
name|s
operator|=
name|expr_end
expr_stmt|;
continue|continue;
case|case
literal|'a'
case|:
comment|/* 26 bit address */
name|my_getExpression
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|s
operator|=
name|expr_end
expr_stmt|;
operator|*
name|offset_reloc
operator|=
name|BFD_RELOC_MIPS16_JMP
expr_stmt|;
name|ip
operator|->
name|insn_opcode
operator|<<=
literal|16
expr_stmt|;
continue|continue;
case|case
literal|'l'
case|:
comment|/* register list for entry macro */
case|case
literal|'L'
case|:
comment|/* register list for exit macro */
block|{
name|int
name|mask
decl_stmt|;
if|if
condition|(
name|c
operator|==
literal|'l'
condition|)
name|mask
operator|=
literal|0
expr_stmt|;
else|else
name|mask
operator|=
literal|7
operator|<<
literal|3
expr_stmt|;
while|while
condition|(
operator|*
name|s
operator|!=
literal|'\0'
condition|)
block|{
name|unsigned
name|int
name|freg
decl_stmt|,
name|reg1
decl_stmt|,
name|reg2
decl_stmt|;
while|while
condition|(
operator|*
name|s
operator|==
literal|' '
operator|||
operator|*
name|s
operator|==
literal|','
condition|)
operator|++
name|s
expr_stmt|;
if|if
condition|(
name|reg_lookup
argument_list|(
operator|&
name|s
argument_list|,
name|RTYPE_GP
operator||
name|RTYPE_NUM
argument_list|,
operator|&
name|reg1
argument_list|)
condition|)
name|freg
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|reg_lookup
argument_list|(
operator|&
name|s
argument_list|,
name|RTYPE_FPU
argument_list|,
operator|&
name|reg1
argument_list|)
condition|)
name|freg
operator|=
literal|1
expr_stmt|;
else|else
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"can't parse register list"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|*
name|s
operator|==
literal|' '
condition|)
operator|++
name|s
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|!=
literal|'-'
condition|)
name|reg2
operator|=
name|reg1
expr_stmt|;
else|else
block|{
operator|++
name|s
expr_stmt|;
if|if
condition|(
operator|!
name|reg_lookup
argument_list|(
operator|&
name|s
argument_list|,
name|freg
condition|?
name|RTYPE_FPU
else|:
operator|(
name|RTYPE_GP
operator||
name|RTYPE_NUM
operator|)
argument_list|,
operator|&
name|reg2
argument_list|)
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"invalid register list"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|freg
operator|&&
name|reg1
operator|==
literal|0
operator|&&
name|reg2
operator|==
literal|0
operator|&&
name|c
operator|==
literal|'L'
condition|)
block|{
name|mask
operator|&=
operator|~
operator|(
literal|7
operator|<<
literal|3
operator|)
expr_stmt|;
name|mask
operator||=
literal|5
operator|<<
literal|3
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|freg
operator|&&
name|reg1
operator|==
literal|0
operator|&&
name|reg2
operator|==
literal|1
operator|&&
name|c
operator|==
literal|'L'
condition|)
block|{
name|mask
operator|&=
operator|~
operator|(
literal|7
operator|<<
literal|3
operator|)
expr_stmt|;
name|mask
operator||=
literal|6
operator|<<
literal|3
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|reg1
operator|==
literal|4
operator|&&
name|reg2
operator|>=
literal|4
operator|&&
name|reg2
operator|<=
literal|7
operator|&&
name|c
operator|!=
literal|'L'
condition|)
name|mask
operator||=
operator|(
name|reg2
operator|-
literal|3
operator|)
operator|<<
literal|3
expr_stmt|;
elseif|else
if|if
condition|(
name|reg1
operator|==
literal|16
operator|&&
name|reg2
operator|>=
literal|16
operator|&&
name|reg2
operator|<=
literal|17
condition|)
name|mask
operator||=
operator|(
name|reg2
operator|-
literal|15
operator|)
operator|<<
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|reg1
operator|==
name|RA
operator|&&
name|reg2
operator|==
name|RA
condition|)
name|mask
operator||=
literal|1
expr_stmt|;
else|else
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"invalid register list"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|/* The mask is filled in in the opcode table for the                    benefit of the disassembler.  We remove it before                    applying the actual mask.  */
name|ip
operator|->
name|insn_opcode
operator|&=
operator|~
operator|(
operator|(
literal|7
operator|<<
literal|3
operator|)
operator|<<
name|MIPS16OP_SH_IMM6
operator|)
expr_stmt|;
name|ip
operator|->
name|insn_opcode
operator||=
name|mask
operator|<<
name|MIPS16OP_SH_IMM6
expr_stmt|;
block|}
continue|continue;
case|case
literal|'m'
case|:
comment|/* Register list for save insn.  */
case|case
literal|'M'
case|:
comment|/* Register list for restore insn.  */
block|{
name|int
name|opcode
init|=
literal|0
decl_stmt|;
name|int
name|framesz
init|=
literal|0
decl_stmt|,
name|seen_framesz
init|=
literal|0
decl_stmt|;
name|int
name|args
init|=
literal|0
decl_stmt|,
name|statics
init|=
literal|0
decl_stmt|,
name|sregs
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|*
name|s
operator|!=
literal|'\0'
condition|)
block|{
name|unsigned
name|int
name|reg1
decl_stmt|,
name|reg2
decl_stmt|;
name|SKIP_SPACE_TABS
argument_list|(
name|s
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|s
operator|==
literal|','
condition|)
operator|++
name|s
expr_stmt|;
name|SKIP_SPACE_TABS
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|my_getExpression
argument_list|(
operator|&
name|imm_expr
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|imm_expr
operator|.
name|X_op
operator|==
name|O_constant
condition|)
block|{
comment|/* Handle the frame size.  */
if|if
condition|(
name|seen_framesz
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"more than one frame size in list"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|seen_framesz
operator|=
literal|1
expr_stmt|;
name|framesz
operator|=
name|imm_expr
operator|.
name|X_add_number
expr_stmt|;
name|imm_expr
operator|.
name|X_op
operator|=
name|O_absent
expr_stmt|;
name|s
operator|=
name|expr_end
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|reg_lookup
argument_list|(
operator|&
name|s
argument_list|,
name|RTYPE_GP
operator||
name|RTYPE_NUM
argument_list|,
operator|&
name|reg1
argument_list|)
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"can't parse register list"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
while|while
condition|(
operator|*
name|s
operator|==
literal|' '
condition|)
operator|++
name|s
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|!=
literal|'-'
condition|)
name|reg2
operator|=
name|reg1
expr_stmt|;
else|else
block|{
operator|++
name|s
expr_stmt|;
if|if
condition|(
operator|!
name|reg_lookup
argument_list|(
operator|&
name|s
argument_list|,
name|RTYPE_GP
operator||
name|RTYPE_NUM
argument_list|,
operator|&
name|reg2
argument_list|)
operator|||
name|reg2
operator|<
name|reg1
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"can't parse register list"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
while|while
condition|(
name|reg1
operator|<=
name|reg2
condition|)
block|{
if|if
condition|(
name|reg1
operator|>=
literal|4
operator|&&
name|reg1
operator|<=
literal|7
condition|)
block|{
if|if
condition|(
operator|!
name|seen_framesz
condition|)
comment|/* args $a0-$a3 */
name|args
operator||=
literal|1
operator|<<
operator|(
name|reg1
operator|-
literal|4
operator|)
expr_stmt|;
else|else
comment|/* statics $a0-$a3 */
name|statics
operator||=
literal|1
operator|<<
operator|(
name|reg1
operator|-
literal|4
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|reg1
operator|>=
literal|16
operator|&&
name|reg1
operator|<=
literal|23
operator|)
operator|||
name|reg1
operator|==
literal|30
condition|)
block|{
comment|/* $s0-$s8 */
name|sregs
operator||=
literal|1
operator|<<
operator|(
operator|(
name|reg1
operator|==
literal|30
operator|)
condition|?
literal|8
else|:
operator|(
name|reg1
operator|-
literal|16
operator|)
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|reg1
operator|==
literal|31
condition|)
block|{
comment|/* Add $ra to insn.  */
name|opcode
operator||=
literal|0x40
expr_stmt|;
block|}
else|else
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"unexpected register in list"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|++
name|reg1
operator|==
literal|24
condition|)
name|reg1
operator|=
literal|30
expr_stmt|;
block|}
block|}
comment|/* Encode args/statics combination.  */
if|if
condition|(
name|args
operator|&
name|statics
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"arg/static registers overlap"
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|args
operator|==
literal|0xf
condition|)
comment|/* All $a0-$a3 are args.  */
name|opcode
operator||=
name|MIPS16_ALL_ARGS
operator|<<
literal|16
expr_stmt|;
elseif|else
if|if
condition|(
name|statics
operator|==
literal|0xf
condition|)
comment|/* All $a0-$a3 are statics.  */
name|opcode
operator||=
name|MIPS16_ALL_STATICS
operator|<<
literal|16
expr_stmt|;
else|else
block|{
name|int
name|narg
init|=
literal|0
decl_stmt|,
name|nstat
init|=
literal|0
decl_stmt|;
comment|/* Count arg registers.  */
while|while
condition|(
name|args
operator|&
literal|0x1
condition|)
block|{
name|args
operator|>>=
literal|1
expr_stmt|;
name|narg
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|args
operator|!=
literal|0
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"invalid arg register list"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Count static registers.  */
while|while
condition|(
name|statics
operator|&
literal|0x8
condition|)
block|{
name|statics
operator|=
operator|(
name|statics
operator|<<
literal|1
operator|)
operator|&
literal|0xf
expr_stmt|;
name|nstat
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|statics
operator|!=
literal|0
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"invalid static register list"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Encode args/statics.  */
name|opcode
operator||=
operator|(
operator|(
name|narg
operator|<<
literal|2
operator|)
operator||
name|nstat
operator|)
operator|<<
literal|16
expr_stmt|;
block|}
comment|/* Encode $s0/$s1.  */
if|if
condition|(
name|sregs
operator|&
operator|(
literal|1
operator|<<
literal|0
operator|)
condition|)
comment|/* $s0 */
name|opcode
operator||=
literal|0x20
expr_stmt|;
if|if
condition|(
name|sregs
operator|&
operator|(
literal|1
operator|<<
literal|1
operator|)
condition|)
comment|/* $s1 */
name|opcode
operator||=
literal|0x10
expr_stmt|;
name|sregs
operator|>>=
literal|2
expr_stmt|;
if|if
condition|(
name|sregs
operator|!=
literal|0
condition|)
block|{
comment|/* Count regs $s2-$s8.  */
name|int
name|nsreg
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|sregs
operator|&
literal|1
condition|)
block|{
name|sregs
operator|>>=
literal|1
expr_stmt|;
name|nsreg
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|sregs
operator|!=
literal|0
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"invalid static register list"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Encode $s2-$s8. */
name|opcode
operator||=
name|nsreg
operator|<<
literal|24
expr_stmt|;
block|}
comment|/* Encode frame size.  */
if|if
condition|(
operator|!
name|seen_framesz
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"missing frame size"
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|framesz
operator|&
literal|7
operator|)
operator|!=
literal|0
operator|||
name|framesz
operator|<
literal|0
operator|||
name|framesz
operator|>
literal|0xff
operator|*
literal|8
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"invalid frame size"
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|framesz
operator|!=
literal|128
operator|||
operator|(
name|opcode
operator|>>
literal|16
operator|)
operator|!=
literal|0
condition|)
block|{
name|framesz
operator|/=
literal|8
expr_stmt|;
name|opcode
operator||=
operator|(
operator|(
operator|(
name|framesz
operator|&
literal|0xf0
operator|)
operator|<<
literal|16
operator|)
operator||
operator|(
name|framesz
operator|&
literal|0x0f
operator|)
operator|)
expr_stmt|;
block|}
comment|/* Finally build the instruction.  */
if|if
condition|(
operator|(
name|opcode
operator|>>
literal|16
operator|)
operator|!=
literal|0
operator|||
name|framesz
operator|==
literal|0
condition|)
block|{
name|ip
operator|->
name|use_extend
operator|=
name|TRUE
expr_stmt|;
name|ip
operator|->
name|extend
operator|=
name|opcode
operator|>>
literal|16
expr_stmt|;
block|}
name|ip
operator|->
name|insn_opcode
operator||=
name|opcode
operator|&
literal|0x7f
expr_stmt|;
block|}
continue|continue;
case|case
literal|'e'
case|:
comment|/* extend code */
name|my_getExpression
argument_list|(
operator|&
name|imm_expr
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|check_absolute_expr
argument_list|(
name|ip
argument_list|,
operator|&
name|imm_expr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|unsigned
name|long
operator|)
name|imm_expr
operator|.
name|X_add_number
operator|>
literal|0x7ff
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"Invalid value for `%s' (%lu)"
argument_list|)
argument_list|,
name|ip
operator|->
name|insn_mo
operator|->
name|name
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|imm_expr
operator|.
name|X_add_number
argument_list|)
expr_stmt|;
name|imm_expr
operator|.
name|X_add_number
operator|&=
literal|0x7ff
expr_stmt|;
block|}
name|ip
operator|->
name|insn_opcode
operator||=
name|imm_expr
operator|.
name|X_add_number
expr_stmt|;
name|imm_expr
operator|.
name|X_op
operator|=
name|O_absent
expr_stmt|;
name|s
operator|=
name|expr_end
expr_stmt|;
continue|continue;
default|default:
name|internalError
argument_list|()
expr_stmt|;
block|}
break|break;
block|}
comment|/* Args don't match.  */
if|if
condition|(
name|insn
operator|+
literal|1
operator|<
operator|&
name|mips16_opcodes
index|[
name|bfd_mips16_num_opcodes
index|]
operator|&&
name|strcmp
argument_list|(
name|insn
operator|->
name|name
argument_list|,
name|insn
index|[
literal|1
index|]
operator|.
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|++
name|insn
expr_stmt|;
name|s
operator|=
name|argsstart
expr_stmt|;
continue|continue;
block|}
name|insn_error
operator|=
name|_
argument_list|(
literal|"illegal operands"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
end_function

begin_comment
comment|/* This structure holds information we know about a mips16 immediate    argument type.  */
end_comment

begin_struct
struct|struct
name|mips16_immed_operand
block|{
comment|/* The type code used in the argument string in the opcode table.  */
name|int
name|type
decl_stmt|;
comment|/* The number of bits in the short form of the opcode.  */
name|int
name|nbits
decl_stmt|;
comment|/* The number of bits in the extended form of the opcode.  */
name|int
name|extbits
decl_stmt|;
comment|/* The amount by which the short form is shifted when it is used;      for example, the sw instruction has a shift count of 2.  */
name|int
name|shift
decl_stmt|;
comment|/* The amount by which the short form is shifted when it is stored      into the instruction code.  */
name|int
name|op_shift
decl_stmt|;
comment|/* Non-zero if the short form is unsigned.  */
name|int
name|unsp
decl_stmt|;
comment|/* Non-zero if the extended form is unsigned.  */
name|int
name|extu
decl_stmt|;
comment|/* Non-zero if the value is PC relative.  */
name|int
name|pcrel
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* The mips16 immediate operand types.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|mips16_immed_operand
name|mips16_immed_operands
index|[]
init|=
block|{
block|{
literal|'<'
block|,
literal|3
block|,
literal|5
block|,
literal|0
block|,
name|MIPS16OP_SH_RZ
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|}
block|,
block|{
literal|'>'
block|,
literal|3
block|,
literal|5
block|,
literal|0
block|,
name|MIPS16OP_SH_RX
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|}
block|,
block|{
literal|'['
block|,
literal|3
block|,
literal|6
block|,
literal|0
block|,
name|MIPS16OP_SH_RZ
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|}
block|,
block|{
literal|']'
block|,
literal|3
block|,
literal|6
block|,
literal|0
block|,
name|MIPS16OP_SH_RX
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|}
block|,
block|{
literal|'4'
block|,
literal|4
block|,
literal|15
block|,
literal|0
block|,
name|MIPS16OP_SH_IMM4
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|'5'
block|,
literal|5
block|,
literal|16
block|,
literal|0
block|,
name|MIPS16OP_SH_IMM5
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|'H'
block|,
literal|5
block|,
literal|16
block|,
literal|1
block|,
name|MIPS16OP_SH_IMM5
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|'W'
block|,
literal|5
block|,
literal|16
block|,
literal|2
block|,
name|MIPS16OP_SH_IMM5
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|'D'
block|,
literal|5
block|,
literal|16
block|,
literal|3
block|,
name|MIPS16OP_SH_IMM5
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|'j'
block|,
literal|5
block|,
literal|16
block|,
literal|0
block|,
name|MIPS16OP_SH_IMM5
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|'8'
block|,
literal|8
block|,
literal|16
block|,
literal|0
block|,
name|MIPS16OP_SH_IMM8
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|'V'
block|,
literal|8
block|,
literal|16
block|,
literal|2
block|,
name|MIPS16OP_SH_IMM8
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|'C'
block|,
literal|8
block|,
literal|16
block|,
literal|3
block|,
name|MIPS16OP_SH_IMM8
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|'U'
block|,
literal|8
block|,
literal|16
block|,
literal|0
block|,
name|MIPS16OP_SH_IMM8
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|}
block|,
block|{
literal|'k'
block|,
literal|8
block|,
literal|16
block|,
literal|0
block|,
name|MIPS16OP_SH_IMM8
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|'K'
block|,
literal|8
block|,
literal|16
block|,
literal|3
block|,
name|MIPS16OP_SH_IMM8
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|'p'
block|,
literal|8
block|,
literal|16
block|,
literal|0
block|,
name|MIPS16OP_SH_IMM8
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|}
block|,
block|{
literal|'q'
block|,
literal|11
block|,
literal|16
block|,
literal|0
block|,
name|MIPS16OP_SH_IMM8
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|}
block|,
block|{
literal|'A'
block|,
literal|8
block|,
literal|16
block|,
literal|2
block|,
name|MIPS16OP_SH_IMM8
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|}
block|,
block|{
literal|'B'
block|,
literal|5
block|,
literal|16
block|,
literal|3
block|,
name|MIPS16OP_SH_IMM5
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|}
block|,
block|{
literal|'E'
block|,
literal|5
block|,
literal|16
block|,
literal|2
block|,
name|MIPS16OP_SH_IMM5
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|MIPS16_NUM_IMMED
define|\
value|(sizeof mips16_immed_operands / sizeof mips16_immed_operands[0])
end_define

begin_comment
comment|/* Handle a mips16 instruction with an immediate value.  This or's the    small immediate value into *INSN.  It sets *USE_EXTEND to indicate    whether an extended value is needed; if one is needed, it sets    *EXTEND to the value.  The argument type is TYPE.  The value is VAL.    If SMALL is true, an unextended opcode was explicitly requested.    If EXT is true, an extended opcode was explicitly requested.  If    WARN is true, warn if EXT does not match reality.  */
end_comment

begin_function
specifier|static
name|void
name|mips16_immed
parameter_list|(
name|char
modifier|*
name|file
parameter_list|,
name|unsigned
name|int
name|line
parameter_list|,
name|int
name|type
parameter_list|,
name|offsetT
name|val
parameter_list|,
name|bfd_boolean
name|warn
parameter_list|,
name|bfd_boolean
name|small
parameter_list|,
name|bfd_boolean
name|ext
parameter_list|,
name|unsigned
name|long
modifier|*
name|insn
parameter_list|,
name|bfd_boolean
modifier|*
name|use_extend
parameter_list|,
name|unsigned
name|short
modifier|*
name|extend
parameter_list|)
block|{
specifier|const
name|struct
name|mips16_immed_operand
modifier|*
name|op
decl_stmt|;
name|int
name|mintiny
decl_stmt|,
name|maxtiny
decl_stmt|;
name|bfd_boolean
name|needext
decl_stmt|;
name|op
operator|=
name|mips16_immed_operands
expr_stmt|;
while|while
condition|(
name|op
operator|->
name|type
operator|!=
name|type
condition|)
block|{
operator|++
name|op
expr_stmt|;
name|assert
argument_list|(
name|op
operator|<
name|mips16_immed_operands
operator|+
name|MIPS16_NUM_IMMED
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|op
operator|->
name|unsp
condition|)
block|{
if|if
condition|(
name|type
operator|==
literal|'<'
operator|||
name|type
operator|==
literal|'>'
operator|||
name|type
operator|==
literal|'['
operator|||
name|type
operator|==
literal|']'
condition|)
block|{
name|mintiny
operator|=
literal|1
expr_stmt|;
name|maxtiny
operator|=
literal|1
operator|<<
name|op
operator|->
name|nbits
expr_stmt|;
block|}
else|else
block|{
name|mintiny
operator|=
literal|0
expr_stmt|;
name|maxtiny
operator|=
operator|(
literal|1
operator|<<
name|op
operator|->
name|nbits
operator|)
operator|-
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
name|mintiny
operator|=
operator|-
operator|(
literal|1
operator|<<
operator|(
name|op
operator|->
name|nbits
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
name|maxtiny
operator|=
operator|(
literal|1
operator|<<
operator|(
name|op
operator|->
name|nbits
operator|-
literal|1
operator|)
operator|)
operator|-
literal|1
expr_stmt|;
block|}
comment|/* Branch offsets have an implicit 0 in the lowest bit.  */
if|if
condition|(
name|type
operator|==
literal|'p'
operator|||
name|type
operator|==
literal|'q'
condition|)
name|val
operator|/=
literal|2
expr_stmt|;
if|if
condition|(
operator|(
name|val
operator|&
operator|(
operator|(
literal|1
operator|<<
name|op
operator|->
name|shift
operator|)
operator|-
literal|1
operator|)
operator|)
operator|!=
literal|0
operator|||
name|val
operator|<
operator|(
name|mintiny
operator|<<
name|op
operator|->
name|shift
operator|)
operator|||
name|val
operator|>
operator|(
name|maxtiny
operator|<<
name|op
operator|->
name|shift
operator|)
condition|)
name|needext
operator|=
name|TRUE
expr_stmt|;
else|else
name|needext
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|warn
operator|&&
name|ext
operator|&&
operator|!
name|needext
condition|)
name|as_warn_where
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
name|_
argument_list|(
literal|"extended operand requested but not required"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|small
operator|&&
name|needext
condition|)
name|as_bad_where
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
name|_
argument_list|(
literal|"invalid unextended operand value"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|small
operator|||
operator|(
operator|!
name|ext
operator|&&
operator|!
name|needext
operator|)
condition|)
block|{
name|int
name|insnval
decl_stmt|;
operator|*
name|use_extend
operator|=
name|FALSE
expr_stmt|;
name|insnval
operator|=
operator|(
operator|(
name|val
operator|>>
name|op
operator|->
name|shift
operator|)
operator|&
operator|(
operator|(
literal|1
operator|<<
name|op
operator|->
name|nbits
operator|)
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
name|insnval
operator|<<=
name|op
operator|->
name|op_shift
expr_stmt|;
operator|*
name|insn
operator||=
name|insnval
expr_stmt|;
block|}
else|else
block|{
name|long
name|minext
decl_stmt|,
name|maxext
decl_stmt|;
name|int
name|extval
decl_stmt|;
if|if
condition|(
name|op
operator|->
name|extu
condition|)
block|{
name|minext
operator|=
literal|0
expr_stmt|;
name|maxext
operator|=
operator|(
literal|1
operator|<<
name|op
operator|->
name|extbits
operator|)
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|minext
operator|=
operator|-
operator|(
literal|1
operator|<<
operator|(
name|op
operator|->
name|extbits
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
name|maxext
operator|=
operator|(
literal|1
operator|<<
operator|(
name|op
operator|->
name|extbits
operator|-
literal|1
operator|)
operator|)
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|val
operator|<
name|minext
operator|||
name|val
operator|>
name|maxext
condition|)
name|as_bad_where
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
name|_
argument_list|(
literal|"operand value out of range for instruction"
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|use_extend
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|op
operator|->
name|extbits
operator|==
literal|16
condition|)
block|{
name|extval
operator|=
operator|(
operator|(
name|val
operator|>>
literal|11
operator|)
operator|&
literal|0x1f
operator|)
operator||
operator|(
name|val
operator|&
literal|0x7e0
operator|)
expr_stmt|;
name|val
operator|&=
literal|0x1f
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|op
operator|->
name|extbits
operator|==
literal|15
condition|)
block|{
name|extval
operator|=
operator|(
operator|(
name|val
operator|>>
literal|11
operator|)
operator|&
literal|0xf
operator|)
operator||
operator|(
name|val
operator|&
literal|0x7f0
operator|)
expr_stmt|;
name|val
operator|&=
literal|0xf
expr_stmt|;
block|}
else|else
block|{
name|extval
operator|=
operator|(
operator|(
name|val
operator|&
literal|0x1f
operator|)
operator|<<
literal|6
operator|)
operator||
operator|(
name|val
operator|&
literal|0x20
operator|)
expr_stmt|;
name|val
operator|=
literal|0
expr_stmt|;
block|}
operator|*
name|extend
operator|=
operator|(
name|unsigned
name|short
operator|)
name|extval
expr_stmt|;
operator|*
name|insn
operator||=
name|val
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_struct
struct|struct
name|percent_op_match
block|{
specifier|const
name|char
modifier|*
name|str
decl_stmt|;
name|bfd_reloc_code_real_type
name|reloc
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|percent_op_match
name|mips_percent_op
index|[]
init|=
block|{
block|{
literal|"%lo"
block|,
name|BFD_RELOC_LO16
block|}
block|,
ifdef|#
directive|ifdef
name|OBJ_ELF
block|{
literal|"%call_hi"
block|,
name|BFD_RELOC_MIPS_CALL_HI16
block|}
block|,
block|{
literal|"%call_lo"
block|,
name|BFD_RELOC_MIPS_CALL_LO16
block|}
block|,
block|{
literal|"%call16"
block|,
name|BFD_RELOC_MIPS_CALL16
block|}
block|,
block|{
literal|"%got_disp"
block|,
name|BFD_RELOC_MIPS_GOT_DISP
block|}
block|,
block|{
literal|"%got_page"
block|,
name|BFD_RELOC_MIPS_GOT_PAGE
block|}
block|,
block|{
literal|"%got_ofst"
block|,
name|BFD_RELOC_MIPS_GOT_OFST
block|}
block|,
block|{
literal|"%got_hi"
block|,
name|BFD_RELOC_MIPS_GOT_HI16
block|}
block|,
block|{
literal|"%got_lo"
block|,
name|BFD_RELOC_MIPS_GOT_LO16
block|}
block|,
block|{
literal|"%got"
block|,
name|BFD_RELOC_MIPS_GOT16
block|}
block|,
block|{
literal|"%gp_rel"
block|,
name|BFD_RELOC_GPREL16
block|}
block|,
block|{
literal|"%half"
block|,
name|BFD_RELOC_16
block|}
block|,
block|{
literal|"%highest"
block|,
name|BFD_RELOC_MIPS_HIGHEST
block|}
block|,
block|{
literal|"%higher"
block|,
name|BFD_RELOC_MIPS_HIGHER
block|}
block|,
block|{
literal|"%neg"
block|,
name|BFD_RELOC_MIPS_SUB
block|}
block|,
block|{
literal|"%tlsgd"
block|,
name|BFD_RELOC_MIPS_TLS_GD
block|}
block|,
block|{
literal|"%tlsldm"
block|,
name|BFD_RELOC_MIPS_TLS_LDM
block|}
block|,
block|{
literal|"%dtprel_hi"
block|,
name|BFD_RELOC_MIPS_TLS_DTPREL_HI16
block|}
block|,
block|{
literal|"%dtprel_lo"
block|,
name|BFD_RELOC_MIPS_TLS_DTPREL_LO16
block|}
block|,
block|{
literal|"%tprel_hi"
block|,
name|BFD_RELOC_MIPS_TLS_TPREL_HI16
block|}
block|,
block|{
literal|"%tprel_lo"
block|,
name|BFD_RELOC_MIPS_TLS_TPREL_LO16
block|}
block|,
block|{
literal|"%gottprel"
block|,
name|BFD_RELOC_MIPS_TLS_GOTTPREL
block|}
block|,
endif|#
directive|endif
block|{
literal|"%hi"
block|,
name|BFD_RELOC_HI16_S
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|percent_op_match
name|mips16_percent_op
index|[]
init|=
block|{
block|{
literal|"%lo"
block|,
name|BFD_RELOC_MIPS16_LO16
block|}
block|,
block|{
literal|"%gprel"
block|,
name|BFD_RELOC_MIPS16_GPREL
block|}
block|,
block|{
literal|"%hi"
block|,
name|BFD_RELOC_MIPS16_HI16_S
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Return true if *STR points to a relocation operator.  When returning true,    move *STR over the operator and store its relocation code in *RELOC.    Leave both *STR and *RELOC alone when returning false.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|parse_relocation
parameter_list|(
name|char
modifier|*
modifier|*
name|str
parameter_list|,
name|bfd_reloc_code_real_type
modifier|*
name|reloc
parameter_list|)
block|{
specifier|const
name|struct
name|percent_op_match
modifier|*
name|percent_op
decl_stmt|;
name|size_t
name|limit
decl_stmt|,
name|i
decl_stmt|;
if|if
condition|(
name|mips_opts
operator|.
name|mips16
condition|)
block|{
name|percent_op
operator|=
name|mips16_percent_op
expr_stmt|;
name|limit
operator|=
name|ARRAY_SIZE
argument_list|(
name|mips16_percent_op
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|percent_op
operator|=
name|mips_percent_op
expr_stmt|;
name|limit
operator|=
name|ARRAY_SIZE
argument_list|(
name|mips_percent_op
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|limit
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|strncasecmp
argument_list|(
operator|*
name|str
argument_list|,
name|percent_op
index|[
name|i
index|]
operator|.
name|str
argument_list|,
name|strlen
argument_list|(
name|percent_op
index|[
name|i
index|]
operator|.
name|str
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|int
name|len
init|=
name|strlen
argument_list|(
name|percent_op
index|[
name|i
index|]
operator|.
name|str
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|ISSPACE
argument_list|(
operator|(
operator|*
name|str
operator|)
index|[
name|len
index|]
argument_list|)
operator|&&
operator|(
operator|*
name|str
operator|)
index|[
name|len
index|]
operator|!=
literal|'('
condition|)
continue|continue;
operator|*
name|str
operator|+=
name|strlen
argument_list|(
name|percent_op
index|[
name|i
index|]
operator|.
name|str
argument_list|)
expr_stmt|;
operator|*
name|reloc
operator|=
name|percent_op
index|[
name|i
index|]
operator|.
name|reloc
expr_stmt|;
comment|/* Check whether the output BFD supports this relocation. 	   If not, issue an error and fall back on something safe.  */
if|if
condition|(
operator|!
name|bfd_reloc_type_lookup
argument_list|(
name|stdoutput
argument_list|,
name|percent_op
index|[
name|i
index|]
operator|.
name|reloc
argument_list|)
condition|)
block|{
name|as_bad
argument_list|(
literal|"relocation %s isn't supported by the current ABI"
argument_list|,
name|percent_op
index|[
name|i
index|]
operator|.
name|str
argument_list|)
expr_stmt|;
operator|*
name|reloc
operator|=
name|BFD_RELOC_UNUSED
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* Parse string STR as a 16-bit relocatable operand.  Store the    expression in *EP and the relocations in the array starting    at RELOC.  Return the number of relocation operators used.     On exit, EXPR_END points to the first character after the expression.  */
end_comment

begin_function
specifier|static
name|size_t
name|my_getSmallExpression
parameter_list|(
name|expressionS
modifier|*
name|ep
parameter_list|,
name|bfd_reloc_code_real_type
modifier|*
name|reloc
parameter_list|,
name|char
modifier|*
name|str
parameter_list|)
block|{
name|bfd_reloc_code_real_type
name|reversed_reloc
index|[
literal|3
index|]
decl_stmt|;
name|size_t
name|reloc_index
decl_stmt|,
name|i
decl_stmt|;
name|int
name|crux_depth
decl_stmt|,
name|str_depth
decl_stmt|;
name|char
modifier|*
name|crux
decl_stmt|;
comment|/* Search for the start of the main expression, recoding relocations      in REVERSED_RELOC.  End the loop with CRUX pointing to the start      of the main expression and with CRUX_DEPTH containing the number      of open brackets at that point.  */
name|reloc_index
operator|=
operator|-
literal|1
expr_stmt|;
name|str_depth
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|reloc_index
operator|++
expr_stmt|;
name|crux
operator|=
name|str
expr_stmt|;
name|crux_depth
operator|=
name|str_depth
expr_stmt|;
comment|/* Skip over whitespace and brackets, keeping count of the number 	 of brackets.  */
while|while
condition|(
operator|*
name|str
operator|==
literal|' '
operator|||
operator|*
name|str
operator|==
literal|'\t'
operator|||
operator|*
name|str
operator|==
literal|'('
condition|)
if|if
condition|(
operator|*
name|str
operator|++
operator|==
literal|'('
condition|)
name|str_depth
operator|++
expr_stmt|;
block|}
do|while
condition|(
operator|*
name|str
operator|==
literal|'%'
operator|&&
name|reloc_index
operator|<
operator|(
name|HAVE_NEWABI
condition|?
literal|3
else|:
literal|1
operator|)
operator|&&
name|parse_relocation
argument_list|(
operator|&
name|str
argument_list|,
operator|&
name|reversed_reloc
index|[
name|reloc_index
index|]
argument_list|)
condition|)
do|;
name|my_getExpression
argument_list|(
name|ep
argument_list|,
name|crux
argument_list|)
expr_stmt|;
name|str
operator|=
name|expr_end
expr_stmt|;
comment|/* Match every open bracket.  */
while|while
condition|(
name|crux_depth
operator|>
literal|0
operator|&&
operator|(
operator|*
name|str
operator|==
literal|')'
operator|||
operator|*
name|str
operator|==
literal|' '
operator|||
operator|*
name|str
operator|==
literal|'\t'
operator|)
condition|)
if|if
condition|(
operator|*
name|str
operator|++
operator|==
literal|')'
condition|)
name|crux_depth
operator|--
expr_stmt|;
if|if
condition|(
name|crux_depth
operator|>
literal|0
condition|)
name|as_bad
argument_list|(
literal|"unclosed '('"
argument_list|)
expr_stmt|;
name|expr_end
operator|=
name|str
expr_stmt|;
if|if
condition|(
name|reloc_index
operator|!=
literal|0
condition|)
block|{
name|prev_reloc_op_frag
operator|=
name|frag_now
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|reloc_index
condition|;
name|i
operator|++
control|)
name|reloc
index|[
name|i
index|]
operator|=
name|reversed_reloc
index|[
name|reloc_index
operator|-
literal|1
operator|-
name|i
index|]
expr_stmt|;
block|}
return|return
name|reloc_index
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|my_getExpression
parameter_list|(
name|expressionS
modifier|*
name|ep
parameter_list|,
name|char
modifier|*
name|str
parameter_list|)
block|{
name|char
modifier|*
name|save_in
decl_stmt|;
name|valueT
name|val
decl_stmt|;
name|save_in
operator|=
name|input_line_pointer
expr_stmt|;
name|input_line_pointer
operator|=
name|str
expr_stmt|;
name|expression
argument_list|(
name|ep
argument_list|)
expr_stmt|;
name|expr_end
operator|=
name|input_line_pointer
expr_stmt|;
name|input_line_pointer
operator|=
name|save_in
expr_stmt|;
comment|/* If we are in mips16 mode, and this is an expression based on `.',      then we bump the value of the symbol by 1 since that is how other      text symbols are handled.  We don't bother to handle complex      expressions, just `.' plus or minus a constant.  */
if|if
condition|(
name|mips_opts
operator|.
name|mips16
operator|&&
name|ep
operator|->
name|X_op
operator|==
name|O_symbol
operator|&&
name|strcmp
argument_list|(
name|S_GET_NAME
argument_list|(
name|ep
operator|->
name|X_add_symbol
argument_list|)
argument_list|,
name|FAKE_LABEL_NAME
argument_list|)
operator|==
literal|0
operator|&&
name|S_GET_SEGMENT
argument_list|(
name|ep
operator|->
name|X_add_symbol
argument_list|)
operator|==
name|now_seg
operator|&&
name|symbol_get_frag
argument_list|(
name|ep
operator|->
name|X_add_symbol
argument_list|)
operator|==
name|frag_now
operator|&&
name|symbol_constant_p
argument_list|(
name|ep
operator|->
name|X_add_symbol
argument_list|)
operator|&&
operator|(
name|val
operator|=
name|S_GET_VALUE
argument_list|(
name|ep
operator|->
name|X_add_symbol
argument_list|)
operator|)
operator|==
name|frag_now_fix
argument_list|()
condition|)
name|S_SET_VALUE
argument_list|(
name|ep
operator|->
name|X_add_symbol
argument_list|,
name|val
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Turn a string in input_line_pointer into a floating point constant    of type TYPE, and store the appropriate bytes in *LITP.  The number    of LITTLENUMS emitted is stored in *SIZEP.  An error message is    returned, or NULL on OK.  */
end_comment

begin_function
name|char
modifier|*
name|md_atof
parameter_list|(
name|int
name|type
parameter_list|,
name|char
modifier|*
name|litP
parameter_list|,
name|int
modifier|*
name|sizeP
parameter_list|)
block|{
name|int
name|prec
decl_stmt|;
name|LITTLENUM_TYPE
name|words
index|[
literal|4
index|]
decl_stmt|;
name|char
modifier|*
name|t
decl_stmt|;
name|int
name|i
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
literal|'f'
case|:
name|prec
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|prec
operator|=
literal|4
expr_stmt|;
break|break;
default|default:
operator|*
name|sizeP
operator|=
literal|0
expr_stmt|;
return|return
name|_
argument_list|(
literal|"bad call to md_atof"
argument_list|)
return|;
block|}
name|t
operator|=
name|atof_ieee
argument_list|(
name|input_line_pointer
argument_list|,
name|type
argument_list|,
name|words
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
condition|)
name|input_line_pointer
operator|=
name|t
expr_stmt|;
operator|*
name|sizeP
operator|=
name|prec
operator|*
literal|2
expr_stmt|;
if|if
condition|(
operator|!
name|target_big_endian
condition|)
block|{
for|for
control|(
name|i
operator|=
name|prec
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|md_number_to_chars
argument_list|(
name|litP
argument_list|,
name|words
index|[
name|i
index|]
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|litP
operator|+=
literal|2
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|prec
condition|;
name|i
operator|++
control|)
block|{
name|md_number_to_chars
argument_list|(
name|litP
argument_list|,
name|words
index|[
name|i
index|]
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|litP
operator|+=
literal|2
expr_stmt|;
block|}
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|void
name|md_number_to_chars
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|valueT
name|val
parameter_list|,
name|int
name|n
parameter_list|)
block|{
if|if
condition|(
name|target_big_endian
condition|)
name|number_to_chars_bigendian
argument_list|(
name|buf
argument_list|,
name|val
argument_list|,
name|n
argument_list|)
expr_stmt|;
else|else
name|number_to_chars_littleendian
argument_list|(
name|buf
argument_list|,
name|val
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|OBJ_ELF
end_ifdef

begin_function
specifier|static
name|int
name|support_64bit_objects
parameter_list|(
name|void
parameter_list|)
block|{
specifier|const
name|char
modifier|*
modifier|*
name|list
decl_stmt|,
modifier|*
modifier|*
name|l
decl_stmt|;
name|int
name|yes
decl_stmt|;
name|list
operator|=
name|bfd_target_list
argument_list|()
expr_stmt|;
for|for
control|(
name|l
operator|=
name|list
init|;
operator|*
name|l
operator|!=
name|NULL
condition|;
name|l
operator|++
control|)
ifdef|#
directive|ifdef
name|TE_TMIPS
comment|/* This is traditional mips */
if|if
condition|(
name|strcmp
argument_list|(
operator|*
name|l
argument_list|,
literal|"elf64-tradbigmips"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
operator|*
name|l
argument_list|,
literal|"elf64-tradlittlemips"
argument_list|)
operator|==
literal|0
condition|)
else|#
directive|else
if|if
condition|(
name|strcmp
argument_list|(
operator|*
name|l
argument_list|,
literal|"elf64-bigmips"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
operator|*
name|l
argument_list|,
literal|"elf64-littlemips"
argument_list|)
operator|==
literal|0
condition|)
endif|#
directive|endif
break|break;
name|yes
operator|=
operator|(
operator|*
name|l
operator|!=
name|NULL
operator|)
expr_stmt|;
name|free
argument_list|(
name|list
argument_list|)
expr_stmt|;
return|return
name|yes
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* OBJ_ELF */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|md_shortopts
init|=
literal|"O::g::G:"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|option
name|md_longopts
index|[]
init|=
block|{
comment|/* Options which specify architecture.  */
define|#
directive|define
name|OPTION_ARCH_BASE
value|(OPTION_MD_BASE)
define|#
directive|define
name|OPTION_MARCH
value|(OPTION_ARCH_BASE + 0)
block|{
literal|"march"
block|,
name|required_argument
block|,
name|NULL
block|,
name|OPTION_MARCH
block|}
block|,
define|#
directive|define
name|OPTION_MTUNE
value|(OPTION_ARCH_BASE + 1)
block|{
literal|"mtune"
block|,
name|required_argument
block|,
name|NULL
block|,
name|OPTION_MTUNE
block|}
block|,
define|#
directive|define
name|OPTION_MIPS1
value|(OPTION_ARCH_BASE + 2)
block|{
literal|"mips0"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_MIPS1
block|}
block|,
block|{
literal|"mips1"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_MIPS1
block|}
block|,
define|#
directive|define
name|OPTION_MIPS2
value|(OPTION_ARCH_BASE + 3)
block|{
literal|"mips2"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_MIPS2
block|}
block|,
define|#
directive|define
name|OPTION_MIPS3
value|(OPTION_ARCH_BASE + 4)
block|{
literal|"mips3"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_MIPS3
block|}
block|,
define|#
directive|define
name|OPTION_MIPS4
value|(OPTION_ARCH_BASE + 5)
block|{
literal|"mips4"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_MIPS4
block|}
block|,
define|#
directive|define
name|OPTION_MIPS5
value|(OPTION_ARCH_BASE + 6)
block|{
literal|"mips5"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_MIPS5
block|}
block|,
define|#
directive|define
name|OPTION_MIPS32
value|(OPTION_ARCH_BASE + 7)
block|{
literal|"mips32"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_MIPS32
block|}
block|,
define|#
directive|define
name|OPTION_MIPS64
value|(OPTION_ARCH_BASE + 8)
block|{
literal|"mips64"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_MIPS64
block|}
block|,
define|#
directive|define
name|OPTION_MIPS32R2
value|(OPTION_ARCH_BASE + 9)
block|{
literal|"mips32r2"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_MIPS32R2
block|}
block|,
define|#
directive|define
name|OPTION_MIPS64R2
value|(OPTION_ARCH_BASE + 10)
block|{
literal|"mips64r2"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_MIPS64R2
block|}
block|,
comment|/* Options which specify Application Specific Extensions (ASEs).  */
define|#
directive|define
name|OPTION_ASE_BASE
value|(OPTION_ARCH_BASE + 11)
define|#
directive|define
name|OPTION_MIPS16
value|(OPTION_ASE_BASE + 0)
block|{
literal|"mips16"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_MIPS16
block|}
block|,
define|#
directive|define
name|OPTION_NO_MIPS16
value|(OPTION_ASE_BASE + 1)
block|{
literal|"no-mips16"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_NO_MIPS16
block|}
block|,
define|#
directive|define
name|OPTION_MIPS3D
value|(OPTION_ASE_BASE + 2)
block|{
literal|"mips3d"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_MIPS3D
block|}
block|,
define|#
directive|define
name|OPTION_NO_MIPS3D
value|(OPTION_ASE_BASE + 3)
block|{
literal|"no-mips3d"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_NO_MIPS3D
block|}
block|,
define|#
directive|define
name|OPTION_MDMX
value|(OPTION_ASE_BASE + 4)
block|{
literal|"mdmx"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_MDMX
block|}
block|,
define|#
directive|define
name|OPTION_NO_MDMX
value|(OPTION_ASE_BASE + 5)
block|{
literal|"no-mdmx"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_NO_MDMX
block|}
block|,
define|#
directive|define
name|OPTION_DSP
value|(OPTION_ASE_BASE + 6)
block|{
literal|"mdsp"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_DSP
block|}
block|,
define|#
directive|define
name|OPTION_NO_DSP
value|(OPTION_ASE_BASE + 7)
block|{
literal|"mno-dsp"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_NO_DSP
block|}
block|,
define|#
directive|define
name|OPTION_MT
value|(OPTION_ASE_BASE + 8)
block|{
literal|"mmt"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_MT
block|}
block|,
define|#
directive|define
name|OPTION_NO_MT
value|(OPTION_ASE_BASE + 9)
block|{
literal|"mno-mt"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_NO_MT
block|}
block|,
define|#
directive|define
name|OPTION_SMARTMIPS
value|(OPTION_ASE_BASE + 10)
block|{
literal|"msmartmips"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_SMARTMIPS
block|}
block|,
define|#
directive|define
name|OPTION_NO_SMARTMIPS
value|(OPTION_ASE_BASE + 11)
block|{
literal|"mno-smartmips"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_NO_SMARTMIPS
block|}
block|,
define|#
directive|define
name|OPTION_DSPR2
value|(OPTION_ASE_BASE + 12)
block|{
literal|"mdspr2"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_DSPR2
block|}
block|,
define|#
directive|define
name|OPTION_NO_DSPR2
value|(OPTION_ASE_BASE + 13)
block|{
literal|"mno-dspr2"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_NO_DSPR2
block|}
block|,
comment|/* Old-style architecture options.  Don't add more of these.  */
define|#
directive|define
name|OPTION_COMPAT_ARCH_BASE
value|(OPTION_ASE_BASE + 14)
define|#
directive|define
name|OPTION_M4650
value|(OPTION_COMPAT_ARCH_BASE + 0)
block|{
literal|"m4650"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_M4650
block|}
block|,
define|#
directive|define
name|OPTION_NO_M4650
value|(OPTION_COMPAT_ARCH_BASE + 1)
block|{
literal|"no-m4650"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_NO_M4650
block|}
block|,
define|#
directive|define
name|OPTION_M4010
value|(OPTION_COMPAT_ARCH_BASE + 2)
block|{
literal|"m4010"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_M4010
block|}
block|,
define|#
directive|define
name|OPTION_NO_M4010
value|(OPTION_COMPAT_ARCH_BASE + 3)
block|{
literal|"no-m4010"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_NO_M4010
block|}
block|,
define|#
directive|define
name|OPTION_M4100
value|(OPTION_COMPAT_ARCH_BASE + 4)
block|{
literal|"m4100"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_M4100
block|}
block|,
define|#
directive|define
name|OPTION_NO_M4100
value|(OPTION_COMPAT_ARCH_BASE + 5)
block|{
literal|"no-m4100"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_NO_M4100
block|}
block|,
define|#
directive|define
name|OPTION_M3900
value|(OPTION_COMPAT_ARCH_BASE + 6)
block|{
literal|"m3900"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_M3900
block|}
block|,
define|#
directive|define
name|OPTION_NO_M3900
value|(OPTION_COMPAT_ARCH_BASE + 7)
block|{
literal|"no-m3900"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_NO_M3900
block|}
block|,
comment|/* Options which enable bug fixes.  */
define|#
directive|define
name|OPTION_FIX_BASE
value|(OPTION_COMPAT_ARCH_BASE + 8)
define|#
directive|define
name|OPTION_M7000_HILO_FIX
value|(OPTION_FIX_BASE + 0)
block|{
literal|"mfix7000"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_M7000_HILO_FIX
block|}
block|,
define|#
directive|define
name|OPTION_MNO_7000_HILO_FIX
value|(OPTION_FIX_BASE + 1)
block|{
literal|"no-fix-7000"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_MNO_7000_HILO_FIX
block|}
block|,
block|{
literal|"mno-fix7000"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_MNO_7000_HILO_FIX
block|}
block|,
define|#
directive|define
name|OPTION_FIX_VR4120
value|(OPTION_FIX_BASE + 2)
define|#
directive|define
name|OPTION_NO_FIX_VR4120
value|(OPTION_FIX_BASE + 3)
block|{
literal|"mfix-vr4120"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_FIX_VR4120
block|}
block|,
block|{
literal|"mno-fix-vr4120"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_NO_FIX_VR4120
block|}
block|,
define|#
directive|define
name|OPTION_FIX_VR4130
value|(OPTION_FIX_BASE + 4)
define|#
directive|define
name|OPTION_NO_FIX_VR4130
value|(OPTION_FIX_BASE + 5)
block|{
literal|"mfix-vr4130"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_FIX_VR4130
block|}
block|,
block|{
literal|"mno-fix-vr4130"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_NO_FIX_VR4130
block|}
block|,
comment|/* Miscellaneous options.  */
define|#
directive|define
name|OPTION_MISC_BASE
value|(OPTION_FIX_BASE + 6)
define|#
directive|define
name|OPTION_TRAP
value|(OPTION_MISC_BASE + 0)
block|{
literal|"trap"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_TRAP
block|}
block|,
block|{
literal|"no-break"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_TRAP
block|}
block|,
define|#
directive|define
name|OPTION_BREAK
value|(OPTION_MISC_BASE + 1)
block|{
literal|"break"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_BREAK
block|}
block|,
block|{
literal|"no-trap"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_BREAK
block|}
block|,
define|#
directive|define
name|OPTION_EB
value|(OPTION_MISC_BASE + 2)
block|{
literal|"EB"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_EB
block|}
block|,
define|#
directive|define
name|OPTION_EL
value|(OPTION_MISC_BASE + 3)
block|{
literal|"EL"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_EL
block|}
block|,
define|#
directive|define
name|OPTION_FP32
value|(OPTION_MISC_BASE + 4)
block|{
literal|"mfp32"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_FP32
block|}
block|,
define|#
directive|define
name|OPTION_GP32
value|(OPTION_MISC_BASE + 5)
block|{
literal|"mgp32"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_GP32
block|}
block|,
define|#
directive|define
name|OPTION_CONSTRUCT_FLOATS
value|(OPTION_MISC_BASE + 6)
block|{
literal|"construct-floats"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_CONSTRUCT_FLOATS
block|}
block|,
define|#
directive|define
name|OPTION_NO_CONSTRUCT_FLOATS
value|(OPTION_MISC_BASE + 7)
block|{
literal|"no-construct-floats"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_NO_CONSTRUCT_FLOATS
block|}
block|,
define|#
directive|define
name|OPTION_FP64
value|(OPTION_MISC_BASE + 8)
block|{
literal|"mfp64"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_FP64
block|}
block|,
define|#
directive|define
name|OPTION_GP64
value|(OPTION_MISC_BASE + 9)
block|{
literal|"mgp64"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_GP64
block|}
block|,
define|#
directive|define
name|OPTION_RELAX_BRANCH
value|(OPTION_MISC_BASE + 10)
define|#
directive|define
name|OPTION_NO_RELAX_BRANCH
value|(OPTION_MISC_BASE + 11)
block|{
literal|"relax-branch"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_RELAX_BRANCH
block|}
block|,
block|{
literal|"no-relax-branch"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_NO_RELAX_BRANCH
block|}
block|,
define|#
directive|define
name|OPTION_MSHARED
value|(OPTION_MISC_BASE + 12)
define|#
directive|define
name|OPTION_MNO_SHARED
value|(OPTION_MISC_BASE + 13)
block|{
literal|"mshared"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_MSHARED
block|}
block|,
block|{
literal|"mno-shared"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_MNO_SHARED
block|}
block|,
define|#
directive|define
name|OPTION_MSYM32
value|(OPTION_MISC_BASE + 14)
define|#
directive|define
name|OPTION_MNO_SYM32
value|(OPTION_MISC_BASE + 15)
block|{
literal|"msym32"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_MSYM32
block|}
block|,
block|{
literal|"mno-sym32"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_MNO_SYM32
block|}
block|,
comment|/* ELF-specific options.  */
ifdef|#
directive|ifdef
name|OBJ_ELF
define|#
directive|define
name|OPTION_ELF_BASE
value|(OPTION_MISC_BASE + 16)
define|#
directive|define
name|OPTION_CALL_SHARED
value|(OPTION_ELF_BASE + 0)
block|{
literal|"KPIC"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_CALL_SHARED
block|}
block|,
block|{
literal|"call_shared"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_CALL_SHARED
block|}
block|,
define|#
directive|define
name|OPTION_NON_SHARED
value|(OPTION_ELF_BASE + 1)
block|{
literal|"non_shared"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_NON_SHARED
block|}
block|,
define|#
directive|define
name|OPTION_XGOT
value|(OPTION_ELF_BASE + 2)
block|{
literal|"xgot"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_XGOT
block|}
block|,
define|#
directive|define
name|OPTION_MABI
value|(OPTION_ELF_BASE + 3)
block|{
literal|"mabi"
block|,
name|required_argument
block|,
name|NULL
block|,
name|OPTION_MABI
block|}
block|,
define|#
directive|define
name|OPTION_32
value|(OPTION_ELF_BASE + 4)
block|{
literal|"32"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_32
block|}
block|,
define|#
directive|define
name|OPTION_N32
value|(OPTION_ELF_BASE + 5)
block|{
literal|"n32"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_N32
block|}
block|,
define|#
directive|define
name|OPTION_64
value|(OPTION_ELF_BASE + 6)
block|{
literal|"64"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_64
block|}
block|,
define|#
directive|define
name|OPTION_MDEBUG
value|(OPTION_ELF_BASE + 7)
block|{
literal|"mdebug"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_MDEBUG
block|}
block|,
define|#
directive|define
name|OPTION_NO_MDEBUG
value|(OPTION_ELF_BASE + 8)
block|{
literal|"no-mdebug"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_NO_MDEBUG
block|}
block|,
define|#
directive|define
name|OPTION_PDR
value|(OPTION_ELF_BASE + 9)
block|{
literal|"mpdr"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_PDR
block|}
block|,
define|#
directive|define
name|OPTION_NO_PDR
value|(OPTION_ELF_BASE + 10)
block|{
literal|"mno-pdr"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_NO_PDR
block|}
block|,
define|#
directive|define
name|OPTION_MVXWORKS_PIC
value|(OPTION_ELF_BASE + 11)
block|{
literal|"mvxworks-pic"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_MVXWORKS_PIC
block|}
block|,
endif|#
directive|endif
comment|/* OBJ_ELF */
define|#
directive|define
name|OPTION_MOCTEON_UNSUPPORTED
value|(OPTION_MISC_BASE + 28)
define|#
directive|define
name|OPTION_NO_MOCTEON_UNSUPPORTED
value|(OPTION_MISC_BASE + 29)
block|{
literal|"mocteon-unsupported"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_MOCTEON_UNSUPPORTED
block|}
block|,
block|{
literal|"mno-octeon-unsupported"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_NO_MOCTEON_UNSUPPORTED
block|}
block|,
define|#
directive|define
name|OPTION_MOCTEON_USEUN
value|(OPTION_MISC_BASE + 30)
define|#
directive|define
name|OPTION_NO_MOCTEON_USEUN
value|(OPTION_MISC_BASE + 31)
block|{
literal|"mocteon-useun"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_MOCTEON_USEUN
block|}
block|,
block|{
literal|"mno-octeon-useun"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_NO_MOCTEON_USEUN
block|}
block|,
block|{
name|NULL
block|,
name|no_argument
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|size_t
name|md_longopts_size
init|=
sizeof|sizeof
argument_list|(
name|md_longopts
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set STRING_PTR (either&mips_arch_string or&mips_tune_string) to    NEW_VALUE.  Warn if another value was already specified.  Note:    we have to defer parsing the -march and -mtune arguments in order    to handle 'from-abi' correctly, since the ABI might be specified    in a later argument.  */
end_comment

begin_function
specifier|static
name|void
name|mips_set_option_string
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|string_ptr
parameter_list|,
specifier|const
name|char
modifier|*
name|new_value
parameter_list|)
block|{
if|if
condition|(
operator|*
name|string_ptr
operator|!=
literal|0
operator|&&
name|strcasecmp
argument_list|(
operator|*
name|string_ptr
argument_list|,
name|new_value
argument_list|)
operator|!=
literal|0
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"A different %s was already specified, is now %s"
argument_list|)
argument_list|,
name|string_ptr
operator|==
operator|&
name|mips_arch_string
condition|?
literal|"-march"
else|:
literal|"-mtune"
argument_list|,
name|new_value
argument_list|)
expr_stmt|;
operator|*
name|string_ptr
operator|=
name|new_value
expr_stmt|;
block|}
end_function

begin_function
name|int
name|md_parse_option
parameter_list|(
name|int
name|c
parameter_list|,
name|char
modifier|*
name|arg
parameter_list|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
name|OPTION_CONSTRUCT_FLOATS
case|:
name|mips_disable_float_construction
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|OPTION_NO_CONSTRUCT_FLOATS
case|:
name|mips_disable_float_construction
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|OPTION_TRAP
case|:
name|mips_trap
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|OPTION_BREAK
case|:
name|mips_trap
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|OPTION_EB
case|:
name|target_big_endian
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|OPTION_EL
case|:
name|target_big_endian
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|OPTION_MOCTEON_UNSUPPORTED
case|:
name|octeon_error_on_unsupported
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|OPTION_NO_MOCTEON_UNSUPPORTED
case|:
name|octeon_error_on_unsupported
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|OPTION_MOCTEON_USEUN
case|:
name|octeon_use_unalign
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|OPTION_NO_MOCTEON_USEUN
case|:
name|octeon_use_unalign
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'O'
case|:
if|if
condition|(
name|arg
operator|&&
name|arg
index|[
literal|0
index|]
operator|==
literal|'0'
condition|)
name|mips_optimize
operator|=
literal|1
expr_stmt|;
else|else
name|mips_optimize
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|'g'
case|:
if|if
condition|(
name|arg
operator|==
name|NULL
condition|)
name|mips_debug
operator|=
literal|2
expr_stmt|;
else|else
name|mips_debug
operator|=
name|atoi
argument_list|(
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPTION_MIPS1
case|:
name|file_mips_isa
operator|=
name|ISA_MIPS1
expr_stmt|;
break|break;
case|case
name|OPTION_MIPS2
case|:
name|file_mips_isa
operator|=
name|ISA_MIPS2
expr_stmt|;
break|break;
case|case
name|OPTION_MIPS3
case|:
name|file_mips_isa
operator|=
name|ISA_MIPS3
expr_stmt|;
break|break;
case|case
name|OPTION_MIPS4
case|:
name|file_mips_isa
operator|=
name|ISA_MIPS4
expr_stmt|;
break|break;
case|case
name|OPTION_MIPS5
case|:
name|file_mips_isa
operator|=
name|ISA_MIPS5
expr_stmt|;
break|break;
case|case
name|OPTION_MIPS32
case|:
name|file_mips_isa
operator|=
name|ISA_MIPS32
expr_stmt|;
break|break;
case|case
name|OPTION_MIPS32R2
case|:
name|file_mips_isa
operator|=
name|ISA_MIPS32R2
expr_stmt|;
break|break;
case|case
name|OPTION_MIPS64R2
case|:
name|file_mips_isa
operator|=
name|ISA_MIPS64R2
expr_stmt|;
break|break;
case|case
name|OPTION_MIPS64
case|:
name|file_mips_isa
operator|=
name|ISA_MIPS64
expr_stmt|;
break|break;
case|case
name|OPTION_MTUNE
case|:
name|mips_set_option_string
argument_list|(
operator|&
name|mips_tune_string
argument_list|,
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPTION_MARCH
case|:
name|mips_set_option_string
argument_list|(
operator|&
name|mips_arch_string
argument_list|,
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPTION_M4650
case|:
name|mips_set_option_string
argument_list|(
operator|&
name|mips_arch_string
argument_list|,
literal|"4650"
argument_list|)
expr_stmt|;
name|mips_set_option_string
argument_list|(
operator|&
name|mips_tune_string
argument_list|,
literal|"4650"
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPTION_NO_M4650
case|:
break|break;
case|case
name|OPTION_M4010
case|:
name|mips_set_option_string
argument_list|(
operator|&
name|mips_arch_string
argument_list|,
literal|"4010"
argument_list|)
expr_stmt|;
name|mips_set_option_string
argument_list|(
operator|&
name|mips_tune_string
argument_list|,
literal|"4010"
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPTION_NO_M4010
case|:
break|break;
case|case
name|OPTION_M4100
case|:
name|mips_set_option_string
argument_list|(
operator|&
name|mips_arch_string
argument_list|,
literal|"4100"
argument_list|)
expr_stmt|;
name|mips_set_option_string
argument_list|(
operator|&
name|mips_tune_string
argument_list|,
literal|"4100"
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPTION_NO_M4100
case|:
break|break;
case|case
name|OPTION_M3900
case|:
name|mips_set_option_string
argument_list|(
operator|&
name|mips_arch_string
argument_list|,
literal|"3900"
argument_list|)
expr_stmt|;
name|mips_set_option_string
argument_list|(
operator|&
name|mips_tune_string
argument_list|,
literal|"3900"
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPTION_NO_M3900
case|:
break|break;
case|case
name|OPTION_MDMX
case|:
name|mips_opts
operator|.
name|ase_mdmx
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|OPTION_NO_MDMX
case|:
name|mips_opts
operator|.
name|ase_mdmx
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|OPTION_DSP
case|:
name|mips_opts
operator|.
name|ase_dsp
operator|=
literal|1
expr_stmt|;
name|mips_opts
operator|.
name|ase_dspr2
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|OPTION_NO_DSP
case|:
name|mips_opts
operator|.
name|ase_dsp
operator|=
literal|0
expr_stmt|;
name|mips_opts
operator|.
name|ase_dspr2
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|OPTION_DSPR2
case|:
name|mips_opts
operator|.
name|ase_dspr2
operator|=
literal|1
expr_stmt|;
name|mips_opts
operator|.
name|ase_dsp
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|OPTION_NO_DSPR2
case|:
name|mips_opts
operator|.
name|ase_dspr2
operator|=
literal|0
expr_stmt|;
name|mips_opts
operator|.
name|ase_dsp
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|OPTION_MT
case|:
name|mips_opts
operator|.
name|ase_mt
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|OPTION_NO_MT
case|:
name|mips_opts
operator|.
name|ase_mt
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|OPTION_MIPS16
case|:
name|mips_opts
operator|.
name|mips16
operator|=
literal|1
expr_stmt|;
name|mips_no_prev_insn
argument_list|()
expr_stmt|;
break|break;
case|case
name|OPTION_NO_MIPS16
case|:
name|mips_opts
operator|.
name|mips16
operator|=
literal|0
expr_stmt|;
name|mips_no_prev_insn
argument_list|()
expr_stmt|;
break|break;
case|case
name|OPTION_MIPS3D
case|:
name|mips_opts
operator|.
name|ase_mips3d
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|OPTION_NO_MIPS3D
case|:
name|mips_opts
operator|.
name|ase_mips3d
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|OPTION_SMARTMIPS
case|:
name|mips_opts
operator|.
name|ase_smartmips
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|OPTION_NO_SMARTMIPS
case|:
name|mips_opts
operator|.
name|ase_smartmips
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|OPTION_FIX_VR4120
case|:
name|mips_fix_vr4120
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|OPTION_NO_FIX_VR4120
case|:
name|mips_fix_vr4120
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|OPTION_FIX_VR4130
case|:
name|mips_fix_vr4130
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|OPTION_NO_FIX_VR4130
case|:
name|mips_fix_vr4130
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|OPTION_RELAX_BRANCH
case|:
name|mips_relax_branch
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|OPTION_NO_RELAX_BRANCH
case|:
name|mips_relax_branch
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|OPTION_MSHARED
case|:
name|mips_in_shared
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|OPTION_MNO_SHARED
case|:
name|mips_in_shared
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
name|OPTION_MSYM32
case|:
name|mips_opts
operator|.
name|sym32
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|OPTION_MNO_SYM32
case|:
name|mips_opts
operator|.
name|sym32
operator|=
name|FALSE
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|OBJ_ELF
comment|/* When generating ELF code, we permit -KPIC and -call_shared to 	 select SVR4_PIC, and -non_shared to select no PIC.  This is 	 intended to be compatible with Irix 5.  */
case|case
name|OPTION_CALL_SHARED
case|:
if|if
condition|(
operator|!
name|IS_ELF
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"-call_shared is supported only for ELF format"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|mips_pic
operator|=
name|SVR4_PIC
expr_stmt|;
name|mips_abicalls
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|OPTION_NON_SHARED
case|:
if|if
condition|(
operator|!
name|IS_ELF
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"-non_shared is supported only for ELF format"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|mips_pic
operator|=
name|NO_PIC
expr_stmt|;
name|mips_abicalls
operator|=
name|FALSE
expr_stmt|;
break|break;
comment|/* The -xgot option tells the assembler to use 32 bit offsets          when accessing the got in SVR4_PIC mode.  It is for Irix          compatibility.  */
case|case
name|OPTION_XGOT
case|:
name|mips_big_got
operator|=
literal|1
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* OBJ_ELF */
case|case
literal|'G'
case|:
name|g_switch_value
operator|=
name|atoi
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|g_switch_seen
operator|=
literal|1
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|OBJ_ELF
comment|/* The -32, -n32 and -64 options are shortcuts for -mabi=32, -mabi=n32 	 and -mabi=64.  */
case|case
name|OPTION_32
case|:
if|if
condition|(
operator|!
name|IS_ELF
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"-32 is supported for ELF format only"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|mips_abi
operator|=
name|O32_ABI
expr_stmt|;
break|break;
case|case
name|OPTION_N32
case|:
if|if
condition|(
operator|!
name|IS_ELF
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"-n32 is supported for ELF format only"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|mips_abi
operator|=
name|N32_ABI
expr_stmt|;
break|break;
case|case
name|OPTION_64
case|:
if|if
condition|(
operator|!
name|IS_ELF
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"-64 is supported for ELF format only"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|mips_abi
operator|=
name|N64_ABI
expr_stmt|;
if|if
condition|(
operator|!
name|support_64bit_objects
argument_list|()
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"No compiled in support for 64 bit object file format"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* OBJ_ELF */
case|case
name|OPTION_GP32
case|:
name|file_mips_gp32
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|OPTION_GP64
case|:
name|file_mips_gp32
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|OPTION_FP32
case|:
name|file_mips_fp32
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|OPTION_FP64
case|:
name|file_mips_fp32
operator|=
literal|0
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|OBJ_ELF
case|case
name|OPTION_MABI
case|:
if|if
condition|(
operator|!
name|IS_ELF
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"-mabi is supported for ELF format only"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"32"
argument_list|)
operator|==
literal|0
condition|)
name|mips_abi
operator|=
name|O32_ABI
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"o64"
argument_list|)
operator|==
literal|0
condition|)
name|mips_abi
operator|=
name|O64_ABI
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"n32"
argument_list|)
operator|==
literal|0
condition|)
name|mips_abi
operator|=
name|N32_ABI
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"64"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|mips_abi
operator|=
name|N64_ABI
expr_stmt|;
if|if
condition|(
operator|!
name|support_64bit_objects
argument_list|()
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"No compiled in support for 64 bit object file "
literal|"format"
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"eabi"
argument_list|)
operator|==
literal|0
condition|)
name|mips_abi
operator|=
name|EABI_ABI
expr_stmt|;
else|else
block|{
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"invalid abi -mabi=%s"
argument_list|)
argument_list|,
name|arg
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
break|break;
endif|#
directive|endif
comment|/* OBJ_ELF */
case|case
name|OPTION_M7000_HILO_FIX
case|:
name|mips_7000_hilo_fix
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|OPTION_MNO_7000_HILO_FIX
case|:
name|mips_7000_hilo_fix
operator|=
name|FALSE
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|OBJ_ELF
case|case
name|OPTION_MDEBUG
case|:
name|mips_flag_mdebug
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|OPTION_NO_MDEBUG
case|:
name|mips_flag_mdebug
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
name|OPTION_PDR
case|:
name|mips_flag_pdr
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|OPTION_NO_PDR
case|:
name|mips_flag_pdr
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
name|OPTION_MVXWORKS_PIC
case|:
name|mips_pic
operator|=
name|VXWORKS_PIC
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* OBJ_ELF */
default|default:
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Set up globals to generate code for the ISA or processor    described by INFO.  */
end_comment

begin_function
specifier|static
name|void
name|mips_set_architecture
parameter_list|(
specifier|const
name|struct
name|mips_cpu_info
modifier|*
name|info
parameter_list|)
block|{
if|if
condition|(
name|info
operator|!=
literal|0
condition|)
block|{
name|file_mips_arch
operator|=
name|info
operator|->
name|cpu
expr_stmt|;
name|mips_opts
operator|.
name|arch
operator|=
name|info
operator|->
name|cpu
expr_stmt|;
name|mips_opts
operator|.
name|isa
operator|=
name|info
operator|->
name|isa
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Likewise for tuning.  */
end_comment

begin_function
specifier|static
name|void
name|mips_set_tune
parameter_list|(
specifier|const
name|struct
name|mips_cpu_info
modifier|*
name|info
parameter_list|)
block|{
if|if
condition|(
name|info
operator|!=
literal|0
condition|)
name|mips_tune
operator|=
name|info
operator|->
name|cpu
expr_stmt|;
block|}
end_function

begin_function
name|void
name|mips_after_parse_args
parameter_list|(
name|void
parameter_list|)
block|{
specifier|const
name|struct
name|mips_cpu_info
modifier|*
name|arch_info
init|=
literal|0
decl_stmt|;
specifier|const
name|struct
name|mips_cpu_info
modifier|*
name|tune_info
init|=
literal|0
decl_stmt|;
comment|/* GP relative stuff not working for PE */
if|if
condition|(
name|strncmp
argument_list|(
name|TARGET_OS
argument_list|,
literal|"pe"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|g_switch_seen
operator|&&
name|g_switch_value
operator|!=
literal|0
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"-G not supported in this configuration."
argument_list|)
argument_list|)
expr_stmt|;
name|g_switch_value
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|mips_abi
operator|==
name|NO_ABI
condition|)
name|mips_abi
operator|=
name|MIPS_DEFAULT_ABI
expr_stmt|;
comment|/* The following code determines the architecture and register size.      Similar code was added to GCC 3.3 (see override_options() in      config/mips/mips.c).  The GAS and GCC code should be kept in sync      as much as possible.  */
if|if
condition|(
name|mips_arch_string
operator|!=
literal|0
condition|)
name|arch_info
operator|=
name|mips_parse_cpu
argument_list|(
literal|"-march"
argument_list|,
name|mips_arch_string
argument_list|)
expr_stmt|;
if|if
condition|(
name|file_mips_isa
operator|!=
name|ISA_UNKNOWN
condition|)
block|{
comment|/* Handle -mipsN.  At this point, file_mips_isa contains the 	 ISA level specified by -mipsN, while arch_info->isa contains 	 the -march selection (if any).  */
if|if
condition|(
name|arch_info
operator|!=
literal|0
condition|)
block|{
comment|/* -march takes precedence over -mipsN, since it is more descriptive. 	     There's no harm in specifying both as long as the ISA levels 	     are the same.  */
if|if
condition|(
name|file_mips_isa
operator|!=
name|arch_info
operator|->
name|isa
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"-%s conflicts with the other architecture options, which imply -%s"
argument_list|)
argument_list|,
name|mips_cpu_info_from_isa
argument_list|(
name|file_mips_isa
argument_list|)
operator|->
name|name
argument_list|,
name|mips_cpu_info_from_isa
argument_list|(
name|arch_info
operator|->
name|isa
argument_list|)
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
else|else
name|arch_info
operator|=
name|mips_cpu_info_from_isa
argument_list|(
name|file_mips_isa
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|arch_info
operator|==
literal|0
condition|)
name|arch_info
operator|=
name|mips_parse_cpu
argument_list|(
literal|"default CPU"
argument_list|,
name|MIPS_CPU_STRING_DEFAULT
argument_list|)
expr_stmt|;
if|if
condition|(
name|ABI_NEEDS_64BIT_REGS
argument_list|(
name|mips_abi
argument_list|)
operator|&&
operator|!
name|ISA_HAS_64BIT_REGS
argument_list|(
name|arch_info
operator|->
name|isa
argument_list|)
condition|)
name|as_bad
argument_list|(
literal|"-march=%s is not compatible with the selected ABI"
argument_list|,
name|arch_info
operator|->
name|name
argument_list|)
expr_stmt|;
name|mips_set_architecture
argument_list|(
name|arch_info
argument_list|)
expr_stmt|;
comment|/* Optimize for file_mips_arch, unless -mtune selects a different processor.  */
if|if
condition|(
name|mips_tune_string
operator|!=
literal|0
condition|)
name|tune_info
operator|=
name|mips_parse_cpu
argument_list|(
literal|"-mtune"
argument_list|,
name|mips_tune_string
argument_list|)
expr_stmt|;
if|if
condition|(
name|tune_info
operator|==
literal|0
condition|)
name|mips_set_tune
argument_list|(
name|arch_info
argument_list|)
expr_stmt|;
else|else
name|mips_set_tune
argument_list|(
name|tune_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|file_mips_gp32
operator|>=
literal|0
condition|)
block|{
comment|/* The user specified the size of the integer registers.  Make sure 	 it agrees with the ABI and ISA.  */
if|if
condition|(
name|file_mips_gp32
operator|==
literal|0
operator|&&
operator|!
name|ISA_HAS_64BIT_REGS
argument_list|(
name|mips_opts
operator|.
name|isa
argument_list|)
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"-mgp64 used with a 32-bit processor"
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|file_mips_gp32
operator|==
literal|1
operator|&&
name|ABI_NEEDS_64BIT_REGS
argument_list|(
name|mips_abi
argument_list|)
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"-mgp32 used with a 64-bit ABI"
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|file_mips_gp32
operator|==
literal|0
operator|&&
name|ABI_NEEDS_32BIT_REGS
argument_list|(
name|mips_abi
argument_list|)
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"-mgp64 used with a 32-bit ABI"
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Infer the integer register size from the ABI and processor. 	 Restrict ourselves to 32-bit registers if that's all the 	 processor has, or if the ABI cannot handle 64-bit registers.  */
name|file_mips_gp32
operator|=
operator|(
name|ABI_NEEDS_32BIT_REGS
argument_list|(
name|mips_abi
argument_list|)
operator|||
operator|!
name|ISA_HAS_64BIT_REGS
argument_list|(
name|mips_opts
operator|.
name|isa
argument_list|)
operator|)
expr_stmt|;
block|}
switch|switch
condition|(
name|file_mips_fp32
condition|)
block|{
default|default:
case|case
operator|-
literal|1
case|:
comment|/* No user specified float register size. 	 ??? GAS treats single-float processors as though they had 64-bit 	 float registers (although it complains when double-precision 	 instructions are used).  As things stand, saying they have 32-bit 	 registers would lead to spurious "register must be even" messages. 	 So here we assume float registers are never smaller than the 	 integer ones.  */
if|if
condition|(
name|file_mips_gp32
operator|==
literal|0
condition|)
comment|/* 64-bit integer registers implies 64-bit float registers.  */
name|file_mips_fp32
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|mips_opts
operator|.
name|ase_mips3d
operator|>
literal|0
operator|||
name|mips_opts
operator|.
name|ase_mdmx
operator|>
literal|0
operator|)
operator|&&
name|ISA_HAS_64BIT_FPRS
argument_list|(
name|mips_opts
operator|.
name|isa
argument_list|)
condition|)
comment|/* -mips3d and -mdmx imply 64-bit float registers, if possible.  */
name|file_mips_fp32
operator|=
literal|0
expr_stmt|;
else|else
comment|/* 32-bit float registers.  */
name|file_mips_fp32
operator|=
literal|1
expr_stmt|;
break|break;
comment|/* The user specified the size of the float registers.  Check if it        agrees with the ABI and ISA.  */
case|case
literal|0
case|:
if|if
condition|(
operator|!
name|ISA_HAS_64BIT_FPRS
argument_list|(
name|mips_opts
operator|.
name|isa
argument_list|)
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"-mfp64 used with a 32-bit fpu"
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ABI_NEEDS_32BIT_REGS
argument_list|(
name|mips_abi
argument_list|)
operator|&&
operator|!
name|ISA_HAS_MXHC1
argument_list|(
name|mips_opts
operator|.
name|isa
argument_list|)
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"-mfp64 used with a 32-bit ABI"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
if|if
condition|(
name|ABI_NEEDS_64BIT_REGS
argument_list|(
name|mips_abi
argument_list|)
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"-mfp32 used with a 64-bit ABI"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* End of GCC-shared inference code.  */
comment|/* This flag is set when we have a 64-bit capable CPU but use only      32-bit wide registers.  Note that EABI does not use it.  */
if|if
condition|(
name|ISA_HAS_64BIT_REGS
argument_list|(
name|mips_opts
operator|.
name|isa
argument_list|)
operator|&&
operator|(
operator|(
name|mips_abi
operator|==
name|NO_ABI
operator|&&
name|file_mips_gp32
operator|==
literal|1
operator|)
operator|||
name|mips_abi
operator|==
name|O32_ABI
operator|)
condition|)
name|mips_32bitmode
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|mips_opts
operator|.
name|isa
operator|==
name|ISA_MIPS1
operator|&&
name|mips_trap
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"trap exception not supported at ISA 1"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If the selected architecture includes support for ASEs, enable      generation of code for them.  */
if|if
condition|(
name|mips_opts
operator|.
name|mips16
operator|==
operator|-
literal|1
condition|)
name|mips_opts
operator|.
name|mips16
operator|=
operator|(
name|CPU_HAS_MIPS16
argument_list|(
name|file_mips_arch
argument_list|)
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|mips_opts
operator|.
name|ase_mips3d
operator|==
operator|-
literal|1
condition|)
name|mips_opts
operator|.
name|ase_mips3d
operator|=
operator|(
operator|(
name|arch_info
operator|->
name|flags
operator|&
name|MIPS_CPU_ASE_MIPS3D
operator|)
operator|&&
name|file_mips_fp32
operator|==
literal|0
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|mips_opts
operator|.
name|ase_mips3d
operator|&&
name|file_mips_fp32
operator|==
literal|1
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"-mfp32 used with -mips3d"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mips_opts
operator|.
name|ase_mdmx
operator|==
operator|-
literal|1
condition|)
name|mips_opts
operator|.
name|ase_mdmx
operator|=
operator|(
operator|(
name|arch_info
operator|->
name|flags
operator|&
name|MIPS_CPU_ASE_MDMX
operator|)
operator|&&
name|file_mips_fp32
operator|==
literal|0
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|mips_opts
operator|.
name|ase_mdmx
operator|&&
name|file_mips_fp32
operator|==
literal|1
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"-mfp32 used with -mdmx"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mips_opts
operator|.
name|ase_smartmips
operator|==
operator|-
literal|1
condition|)
name|mips_opts
operator|.
name|ase_smartmips
operator|=
operator|(
name|arch_info
operator|->
name|flags
operator|&
name|MIPS_CPU_ASE_SMARTMIPS
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|mips_opts
operator|.
name|ase_smartmips
operator|&&
operator|!
name|ISA_SUPPORTS_SMARTMIPS
condition|)
name|as_warn
argument_list|(
literal|"%s ISA does not support SmartMIPS"
argument_list|,
name|mips_cpu_info_from_isa
argument_list|(
name|mips_opts
operator|.
name|isa
argument_list|)
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|mips_opts
operator|.
name|ase_dsp
operator|==
operator|-
literal|1
condition|)
name|mips_opts
operator|.
name|ase_dsp
operator|=
operator|(
name|arch_info
operator|->
name|flags
operator|&
name|MIPS_CPU_ASE_DSP
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|mips_opts
operator|.
name|ase_dsp
operator|&&
operator|!
name|ISA_SUPPORTS_DSP_ASE
condition|)
name|as_warn
argument_list|(
literal|"%s ISA does not support DSP ASE"
argument_list|,
name|mips_cpu_info_from_isa
argument_list|(
name|mips_opts
operator|.
name|isa
argument_list|)
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|mips_opts
operator|.
name|ase_dspr2
operator|==
operator|-
literal|1
condition|)
block|{
name|mips_opts
operator|.
name|ase_dspr2
operator|=
operator|(
name|arch_info
operator|->
name|flags
operator|&
name|MIPS_CPU_ASE_DSPR2
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|mips_opts
operator|.
name|ase_dsp
operator|=
operator|(
name|arch_info
operator|->
name|flags
operator|&
name|MIPS_CPU_ASE_DSP
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|mips_opts
operator|.
name|ase_dspr2
operator|&&
operator|!
name|ISA_SUPPORTS_DSPR2_ASE
condition|)
name|as_warn
argument_list|(
literal|"%s ISA does not support DSP R2 ASE"
argument_list|,
name|mips_cpu_info_from_isa
argument_list|(
name|mips_opts
operator|.
name|isa
argument_list|)
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|mips_opts
operator|.
name|ase_mt
operator|==
operator|-
literal|1
condition|)
name|mips_opts
operator|.
name|ase_mt
operator|=
operator|(
name|arch_info
operator|->
name|flags
operator|&
name|MIPS_CPU_ASE_MT
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|mips_opts
operator|.
name|ase_mt
operator|&&
operator|!
name|ISA_SUPPORTS_MT_ASE
condition|)
name|as_warn
argument_list|(
literal|"%s ISA does not support MT ASE"
argument_list|,
name|mips_cpu_info_from_isa
argument_list|(
name|mips_opts
operator|.
name|isa
argument_list|)
operator|->
name|name
argument_list|)
expr_stmt|;
name|file_mips_isa
operator|=
name|mips_opts
operator|.
name|isa
expr_stmt|;
name|file_ase_mips16
operator|=
name|mips_opts
operator|.
name|mips16
expr_stmt|;
name|file_ase_mips3d
operator|=
name|mips_opts
operator|.
name|ase_mips3d
expr_stmt|;
name|file_ase_mdmx
operator|=
name|mips_opts
operator|.
name|ase_mdmx
expr_stmt|;
name|file_ase_smartmips
operator|=
name|mips_opts
operator|.
name|ase_smartmips
expr_stmt|;
name|file_ase_dsp
operator|=
name|mips_opts
operator|.
name|ase_dsp
expr_stmt|;
name|file_ase_dspr2
operator|=
name|mips_opts
operator|.
name|ase_dspr2
expr_stmt|;
name|file_ase_mt
operator|=
name|mips_opts
operator|.
name|ase_mt
expr_stmt|;
name|mips_opts
operator|.
name|gp32
operator|=
name|file_mips_gp32
expr_stmt|;
name|mips_opts
operator|.
name|fp32
operator|=
name|file_mips_fp32
expr_stmt|;
if|if
condition|(
name|mips_flag_mdebug
operator|<
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|OBJ_MAYBE_ECOFF
if|if
condition|(
name|OUTPUT_FLAVOR
operator|==
name|bfd_target_ecoff_flavour
condition|)
name|mips_flag_mdebug
operator|=
literal|1
expr_stmt|;
else|else
endif|#
directive|endif
comment|/* OBJ_MAYBE_ECOFF */
name|mips_flag_mdebug
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_function
name|void
name|mips_init_after_args
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* initialize opcodes */
name|bfd_mips_num_opcodes
operator|=
name|bfd_mips_num_builtin_opcodes
expr_stmt|;
name|mips_opcodes
operator|=
operator|(
expr|struct
name|mips_opcode
operator|*
operator|)
name|mips_builtin_opcodes
expr_stmt|;
block|}
end_function

begin_function
name|long
name|md_pcrel_from
parameter_list|(
name|fixS
modifier|*
name|fixP
parameter_list|)
block|{
name|valueT
name|addr
init|=
name|fixP
operator|->
name|fx_where
operator|+
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_address
decl_stmt|;
switch|switch
condition|(
name|fixP
operator|->
name|fx_r_type
condition|)
block|{
case|case
name|BFD_RELOC_16_PCREL_S2
case|:
case|case
name|BFD_RELOC_MIPS_JMP
case|:
comment|/* Return the address of the delay slot.  */
return|return
name|addr
operator|+
literal|4
return|;
default|default:
comment|/* We have no relocation type for PC relative MIPS16 instructions.  */
if|if
condition|(
name|fixP
operator|->
name|fx_addsy
operator|&&
name|S_GET_SEGMENT
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
operator|!=
name|now_seg
condition|)
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"PC relative MIPS16 instruction references a different section"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|addr
return|;
block|}
block|}
end_function

begin_comment
comment|/* This is called before the symbol table is processed.  In order to    work with gcc when using mips-tfile, we must keep all local labels.    However, in other cases, we want to discard them.  If we were    called with -g, but we didn't see any debugging information, it may    mean that gcc is smuggling debugging information through to    mips-tfile, in which case we must generate all local labels.  */
end_comment

begin_function
name|void
name|mips_frob_file_before_adjust
parameter_list|(
name|void
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|NO_ECOFF_DEBUGGING
if|if
condition|(
name|ECOFF_DEBUGGING
operator|&&
name|mips_debug
operator|!=
literal|0
operator|&&
operator|!
name|ecoff_debugging_seen
condition|)
name|flag_keep_locals
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Sort any unmatched HI16 and GOT16 relocs so that they immediately precede    the corresponding LO16 reloc.  This is called before md_apply_fix and    tc_gen_reloc.  Unmatched relocs can only be generated by use of explicit    relocation operators.     For our purposes, a %lo() expression matches a %got() or %hi()    expression if:        (a) it refers to the same symbol; and       (b) the offset applied in the %lo() expression is no lower than 	  the offset applied in the %got() or %hi().     (b) allows us to cope with code like:  	lui	$4,%hi(foo) 	lh	$4,%lo(foo+2)($4)     ...which is legal on RELA targets, and has a well-defined behaviour    if the user knows that adding 2 to "foo" will not induce a carry to    the high 16 bits.     When several %lo()s match a particular %got() or %hi(), we use the    following rules to distinguish them:       (1) %lo()s with smaller offsets are a better match than %lo()s with          higher offsets.       (2) %lo()s with no matching %got() or %hi() are better than those          that already have a matching %got() or %hi().       (3) later %lo()s are better than earlier %lo()s.     These rules are applied in order.     (1) means, among other things, that %lo()s with identical offsets are    chosen if they exist.     (2) means that we won't associate several high-part relocations with    the same low-part relocation unless there's no alternative.  Having    several high parts for the same low part is a GNU extension; this rule    allows careful users to avoid it.     (3) is purely cosmetic.  mips_hi_fixup_list is is in reverse order,    with the last high-part relocation being at the front of the list.    It therefore makes sense to choose the last matching low-part    relocation, all other things being equal.  It's also easier    to code that way.  */
end_comment

begin_function
name|void
name|mips_frob_file
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|mips_hi_fixup
modifier|*
name|l
decl_stmt|;
for|for
control|(
name|l
operator|=
name|mips_hi_fixup_list
init|;
name|l
operator|!=
name|NULL
condition|;
name|l
operator|=
name|l
operator|->
name|next
control|)
block|{
name|segment_info_type
modifier|*
name|seginfo
decl_stmt|;
name|bfd_boolean
name|matched_lo_p
decl_stmt|;
name|fixS
modifier|*
modifier|*
name|hi_pos
decl_stmt|,
modifier|*
modifier|*
name|lo_pos
decl_stmt|,
modifier|*
modifier|*
name|pos
decl_stmt|;
name|assert
argument_list|(
name|reloc_needs_lo_p
argument_list|(
name|l
operator|->
name|fixp
operator|->
name|fx_r_type
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If a GOT16 relocation turns out to be against a global symbol, 	 there isn't supposed to be a matching LO.  */
if|if
condition|(
name|l
operator|->
name|fixp
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_MIPS_GOT16
operator|&&
operator|!
name|pic_need_relax
argument_list|(
name|l
operator|->
name|fixp
operator|->
name|fx_addsy
argument_list|,
name|l
operator|->
name|seg
argument_list|)
condition|)
continue|continue;
comment|/* Check quickly whether the next fixup happens to be a matching %lo.  */
if|if
condition|(
name|fixup_has_matching_lo_p
argument_list|(
name|l
operator|->
name|fixp
argument_list|)
condition|)
continue|continue;
name|seginfo
operator|=
name|seg_info
argument_list|(
name|l
operator|->
name|seg
argument_list|)
expr_stmt|;
comment|/* Set HI_POS to the position of this relocation in the chain. 	 Set LO_POS to the position of the chosen low-part relocation. 	 MATCHED_LO_P is true on entry to the loop if *POS is a low-part 	 relocation that matches an immediately-preceding high-part 	 relocation.  */
name|hi_pos
operator|=
name|NULL
expr_stmt|;
name|lo_pos
operator|=
name|NULL
expr_stmt|;
name|matched_lo_p
operator|=
name|FALSE
expr_stmt|;
for|for
control|(
name|pos
operator|=
operator|&
name|seginfo
operator|->
name|fix_root
init|;
operator|*
name|pos
operator|!=
name|NULL
condition|;
name|pos
operator|=
operator|&
operator|(
operator|*
name|pos
operator|)
operator|->
name|fx_next
control|)
block|{
if|if
condition|(
operator|*
name|pos
operator|==
name|l
operator|->
name|fixp
condition|)
name|hi_pos
operator|=
name|pos
expr_stmt|;
if|if
condition|(
operator|(
operator|(
operator|*
name|pos
operator|)
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_LO16
operator|||
operator|(
operator|*
name|pos
operator|)
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_MIPS16_LO16
operator|)
operator|&&
operator|(
operator|*
name|pos
operator|)
operator|->
name|fx_addsy
operator|==
name|l
operator|->
name|fixp
operator|->
name|fx_addsy
operator|&&
operator|(
operator|*
name|pos
operator|)
operator|->
name|fx_offset
operator|>=
name|l
operator|->
name|fixp
operator|->
name|fx_offset
operator|&&
operator|(
name|lo_pos
operator|==
name|NULL
operator|||
operator|(
operator|*
name|pos
operator|)
operator|->
name|fx_offset
operator|<
operator|(
operator|*
name|lo_pos
operator|)
operator|->
name|fx_offset
operator|||
operator|(
operator|!
name|matched_lo_p
operator|&&
operator|(
operator|*
name|pos
operator|)
operator|->
name|fx_offset
operator|==
operator|(
operator|*
name|lo_pos
operator|)
operator|->
name|fx_offset
operator|)
operator|)
condition|)
name|lo_pos
operator|=
name|pos
expr_stmt|;
name|matched_lo_p
operator|=
operator|(
name|reloc_needs_lo_p
argument_list|(
operator|(
operator|*
name|pos
operator|)
operator|->
name|fx_r_type
argument_list|)
operator|&&
name|fixup_has_matching_lo_p
argument_list|(
operator|*
name|pos
argument_list|)
operator|)
expr_stmt|;
block|}
comment|/* If we found a match, remove the high-part relocation from its 	 current position and insert it before the low-part relocation. 	 Make the offsets match so that fixup_has_matching_lo_p() 	 will return true.  	 We don't warn about unmatched high-part relocations since some 	 versions of gcc have been known to emit dead "lui ...%hi(...)" 	 instructions.  */
if|if
condition|(
name|lo_pos
operator|!=
name|NULL
condition|)
block|{
name|l
operator|->
name|fixp
operator|->
name|fx_offset
operator|=
operator|(
operator|*
name|lo_pos
operator|)
operator|->
name|fx_offset
expr_stmt|;
if|if
condition|(
name|l
operator|->
name|fixp
operator|->
name|fx_next
operator|!=
operator|*
name|lo_pos
condition|)
block|{
operator|*
name|hi_pos
operator|=
name|l
operator|->
name|fixp
operator|->
name|fx_next
expr_stmt|;
name|l
operator|->
name|fixp
operator|->
name|fx_next
operator|=
operator|*
name|lo_pos
expr_stmt|;
operator|*
name|lo_pos
operator|=
name|l
operator|->
name|fixp
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* We may have combined relocations without symbols in the N32/N64 ABI.    We have to prevent gas from dropping them.  */
end_comment

begin_function
name|int
name|mips_force_relocation
parameter_list|(
name|fixS
modifier|*
name|fixp
parameter_list|)
block|{
if|if
condition|(
name|generic_force_reloc
argument_list|(
name|fixp
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|HAVE_NEWABI
operator|&&
name|S_GET_SEGMENT
argument_list|(
name|fixp
operator|->
name|fx_addsy
argument_list|)
operator|==
name|bfd_abs_section_ptr
operator|&&
operator|(
name|fixp
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_MIPS_SUB
operator|||
name|fixp
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_HI16_S
operator|||
name|fixp
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_LO16
operator|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Apply a fixup to the object file.  */
end_comment

begin_function
name|void
name|md_apply_fix
parameter_list|(
name|fixS
modifier|*
name|fixP
parameter_list|,
name|valueT
modifier|*
name|valP
parameter_list|,
name|segT
name|seg
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|bfd_byte
modifier|*
name|buf
decl_stmt|;
name|long
name|insn
decl_stmt|;
name|reloc_howto_type
modifier|*
name|howto
decl_stmt|;
comment|/* We ignore generic BFD relocations we don't know about.  */
name|howto
operator|=
name|bfd_reloc_type_lookup
argument_list|(
name|stdoutput
argument_list|,
name|fixP
operator|->
name|fx_r_type
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|howto
condition|)
return|return;
name|assert
argument_list|(
name|fixP
operator|->
name|fx_size
operator|==
literal|4
operator|||
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_16
operator|||
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_64
operator|||
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_CTOR
operator|||
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_MIPS_SUB
operator|||
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_VTABLE_INHERIT
operator|||
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_VTABLE_ENTRY
operator|||
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_MIPS_TLS_DTPREL64
argument_list|)
expr_stmt|;
name|buf
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
operator|(
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_literal
operator|+
name|fixP
operator|->
name|fx_where
operator|)
expr_stmt|;
name|assert
argument_list|(
operator|!
name|fixP
operator|->
name|fx_pcrel
operator|||
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_16_PCREL_S2
argument_list|)
expr_stmt|;
comment|/* Don't treat parts of a composite relocation as done.  There are two      reasons for this:       (1) The second and third parts will be against 0 (RSS_UNDEF) but 	 should nevertheless be emitted if the first part is.       (2) In normal usage, composite relocations are never assembly-time 	 constants.  The easiest way of dealing with the pathological 	 exceptions is to generate a relocation against STN_UNDEF and 	 leave everything up to the linker.  */
if|if
condition|(
name|fixP
operator|->
name|fx_addsy
operator|==
name|NULL
operator|&&
operator|!
name|fixP
operator|->
name|fx_pcrel
operator|&&
name|fixP
operator|->
name|fx_tcbit
operator|==
literal|0
condition|)
name|fixP
operator|->
name|fx_done
operator|=
literal|1
expr_stmt|;
switch|switch
condition|(
name|fixP
operator|->
name|fx_r_type
condition|)
block|{
case|case
name|BFD_RELOC_MIPS_TLS_GD
case|:
case|case
name|BFD_RELOC_MIPS_TLS_LDM
case|:
case|case
name|BFD_RELOC_MIPS_TLS_DTPREL32
case|:
case|case
name|BFD_RELOC_MIPS_TLS_DTPREL64
case|:
case|case
name|BFD_RELOC_MIPS_TLS_DTPREL_HI16
case|:
case|case
name|BFD_RELOC_MIPS_TLS_DTPREL_LO16
case|:
case|case
name|BFD_RELOC_MIPS_TLS_GOTTPREL
case|:
case|case
name|BFD_RELOC_MIPS_TLS_TPREL_HI16
case|:
case|case
name|BFD_RELOC_MIPS_TLS_TPREL_LO16
case|:
name|S_SET_THREAD_LOCAL
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
expr_stmt|;
comment|/* fall through */
case|case
name|BFD_RELOC_MIPS_JMP
case|:
case|case
name|BFD_RELOC_MIPS_SHIFT5
case|:
case|case
name|BFD_RELOC_MIPS_SHIFT6
case|:
case|case
name|BFD_RELOC_MIPS_GOT_DISP
case|:
case|case
name|BFD_RELOC_MIPS_GOT_PAGE
case|:
case|case
name|BFD_RELOC_MIPS_GOT_OFST
case|:
case|case
name|BFD_RELOC_MIPS_SUB
case|:
case|case
name|BFD_RELOC_MIPS_INSERT_A
case|:
case|case
name|BFD_RELOC_MIPS_INSERT_B
case|:
case|case
name|BFD_RELOC_MIPS_DELETE
case|:
case|case
name|BFD_RELOC_MIPS_HIGHEST
case|:
case|case
name|BFD_RELOC_MIPS_HIGHER
case|:
case|case
name|BFD_RELOC_MIPS_SCN_DISP
case|:
case|case
name|BFD_RELOC_MIPS_REL16
case|:
case|case
name|BFD_RELOC_MIPS_RELGOT
case|:
case|case
name|BFD_RELOC_MIPS_JALR
case|:
case|case
name|BFD_RELOC_HI16
case|:
case|case
name|BFD_RELOC_HI16_S
case|:
case|case
name|BFD_RELOC_GPREL16
case|:
case|case
name|BFD_RELOC_MIPS_LITERAL
case|:
case|case
name|BFD_RELOC_MIPS_CALL16
case|:
case|case
name|BFD_RELOC_MIPS_GOT16
case|:
case|case
name|BFD_RELOC_GPREL32
case|:
case|case
name|BFD_RELOC_MIPS_GOT_HI16
case|:
case|case
name|BFD_RELOC_MIPS_GOT_LO16
case|:
case|case
name|BFD_RELOC_MIPS_CALL_HI16
case|:
case|case
name|BFD_RELOC_MIPS_CALL_LO16
case|:
case|case
name|BFD_RELOC_MIPS16_GPREL
case|:
case|case
name|BFD_RELOC_MIPS16_HI16
case|:
case|case
name|BFD_RELOC_MIPS16_HI16_S
case|:
case|case
name|BFD_RELOC_MIPS16_JMP
case|:
comment|/* Nothing needed to do.  The value comes from the reloc entry.  */
break|break;
case|case
name|BFD_RELOC_64
case|:
comment|/* This is handled like BFD_RELOC_32, but we output a sign          extended value if we are only 32 bits.  */
if|if
condition|(
name|fixP
operator|->
name|fx_done
condition|)
block|{
if|if
condition|(
literal|8
operator|<=
sizeof|sizeof
argument_list|(
name|valueT
argument_list|)
condition|)
name|md_number_to_chars
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|,
operator|*
name|valP
argument_list|,
literal|8
argument_list|)
expr_stmt|;
else|else
block|{
name|valueT
name|hiv
decl_stmt|;
if|if
condition|(
operator|(
operator|*
name|valP
operator|&
literal|0x80000000
operator|)
operator|!=
literal|0
condition|)
name|hiv
operator|=
literal|0xffffffff
expr_stmt|;
else|else
name|hiv
operator|=
literal|0
expr_stmt|;
name|md_number_to_chars
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|buf
operator|+
operator|(
name|target_big_endian
condition|?
literal|4
else|:
literal|0
operator|)
operator|)
argument_list|,
operator|*
name|valP
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|buf
operator|+
operator|(
name|target_big_endian
condition|?
literal|0
else|:
literal|4
operator|)
operator|)
argument_list|,
name|hiv
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|BFD_RELOC_RVA
case|:
case|case
name|BFD_RELOC_32
case|:
case|case
name|BFD_RELOC_16
case|:
comment|/* If we are deleting this reloc entry, we must fill in the 	 value now.  This can happen if we have a .word which is not 	 resolved when it appears but is later defined.  */
if|if
condition|(
name|fixP
operator|->
name|fx_done
condition|)
name|md_number_to_chars
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|,
operator|*
name|valP
argument_list|,
name|fixP
operator|->
name|fx_size
argument_list|)
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_LO16
case|:
case|case
name|BFD_RELOC_MIPS16_LO16
case|:
comment|/* FIXME: Now that embedded-PIC is gone, some of this code/comment 	 may be safe to remove, but if so it's not obvious.  */
comment|/* When handling an embedded PIC switch statement, we can wind 	 up deleting a LO16 reloc.  See the 'o' case in mips_ip.  */
if|if
condition|(
name|fixP
operator|->
name|fx_done
condition|)
block|{
if|if
condition|(
operator|*
name|valP
operator|+
literal|0x8000
operator|>
literal|0xffff
condition|)
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"relocation overflow"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|target_big_endian
condition|)
name|buf
operator|+=
literal|2
expr_stmt|;
name|md_number_to_chars
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|,
operator|*
name|valP
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|BFD_RELOC_16_PCREL_S2
case|:
if|if
condition|(
operator|(
operator|*
name|valP
operator|&
literal|0x3
operator|)
operator|!=
literal|0
condition|)
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"Branch to misaligned address (%lx)"
argument_list|)
argument_list|,
operator|(
name|long
operator|)
operator|*
name|valP
argument_list|)
expr_stmt|;
comment|/* We need to save the bits in the instruction since fixup_segment() 	 might be deleting the relocation entry (i.e., a branch within 	 the current segment).  */
if|if
condition|(
operator|!
name|fixP
operator|->
name|fx_done
condition|)
break|break;
comment|/* Update old instruction data.  */
if|if
condition|(
name|target_big_endian
condition|)
name|insn
operator|=
operator|(
name|buf
index|[
literal|0
index|]
operator|<<
literal|24
operator|)
operator||
operator|(
name|buf
index|[
literal|1
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|buf
index|[
literal|2
index|]
operator|<<
literal|8
operator|)
operator||
name|buf
index|[
literal|3
index|]
expr_stmt|;
else|else
name|insn
operator|=
operator|(
name|buf
index|[
literal|3
index|]
operator|<<
literal|24
operator|)
operator||
operator|(
name|buf
index|[
literal|2
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|buf
index|[
literal|1
index|]
operator|<<
literal|8
operator|)
operator||
name|buf
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
operator|*
name|valP
operator|+
literal|0x20000
operator|<=
literal|0x3ffff
condition|)
block|{
name|insn
operator||=
operator|(
operator|*
name|valP
operator|>>
literal|2
operator|)
operator|&
literal|0xffff
expr_stmt|;
name|md_number_to_chars
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|,
name|insn
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mips_pic
operator|==
name|NO_PIC
operator|&&
name|fixP
operator|->
name|fx_done
operator|&&
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_address
operator|>=
name|text_section
operator|->
name|vma
operator|&&
operator|(
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_address
operator|<
name|text_section
operator|->
name|vma
operator|+
name|bfd_get_section_size
argument_list|(
name|text_section
argument_list|)
operator|)
operator|&&
operator|(
operator|(
name|insn
operator|&
literal|0xffff0000
operator|)
operator|==
literal|0x10000000
comment|/* beq $0,$0 */
operator|||
operator|(
name|insn
operator|&
literal|0xffff0000
operator|)
operator|==
literal|0x04010000
comment|/* bgez $0 */
operator|||
operator|(
name|insn
operator|&
literal|0xffff0000
operator|)
operator|==
literal|0x04110000
operator|)
condition|)
comment|/* bgezal $0 */
block|{
comment|/* The branch offset is too large.  If this is an              unconditional branch, and we are not generating PIC code,              we can convert it to an absolute jump instruction.  */
if|if
condition|(
operator|(
name|insn
operator|&
literal|0xffff0000
operator|)
operator|==
literal|0x04110000
condition|)
comment|/* bgezal $0 */
name|insn
operator|=
literal|0x0c000000
expr_stmt|;
comment|/* jal */
else|else
name|insn
operator|=
literal|0x08000000
expr_stmt|;
comment|/* j */
name|fixP
operator|->
name|fx_r_type
operator|=
name|BFD_RELOC_MIPS_JMP
expr_stmt|;
name|fixP
operator|->
name|fx_done
operator|=
literal|0
expr_stmt|;
name|fixP
operator|->
name|fx_addsy
operator|=
name|section_symbol
argument_list|(
name|text_section
argument_list|)
expr_stmt|;
operator|*
name|valP
operator|+=
name|md_pcrel_from
argument_list|(
name|fixP
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|,
name|insn
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* If we got here, we have branch-relaxation disabled, 	     and there's nothing we can do to fix this instruction 	     without turning it into a longer sequence.  */
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"Branch out of range"
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|BFD_RELOC_VTABLE_INHERIT
case|:
name|fixP
operator|->
name|fx_done
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|fixP
operator|->
name|fx_addsy
operator|&&
operator|!
name|S_IS_DEFINED
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
operator|&&
operator|!
name|S_IS_WEAK
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
condition|)
name|S_SET_WEAK
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_VTABLE_ENTRY
case|:
name|fixP
operator|->
name|fx_done
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|internalError
argument_list|()
expr_stmt|;
block|}
comment|/* Remember value for tc_gen_reloc.  */
name|fixP
operator|->
name|fx_addnumber
operator|=
operator|*
name|valP
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|symbolS
modifier|*
name|get_symbol
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|symbolS
modifier|*
name|p
decl_stmt|;
name|name
operator|=
name|input_line_pointer
expr_stmt|;
name|c
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
name|p
operator|=
operator|(
name|symbolS
operator|*
operator|)
name|symbol_find_or_make
argument_list|(
name|name
argument_list|)
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_comment
comment|/* Align the current frag to a given power of two.  The MIPS assembler    also automatically adjusts any preceding label.  */
end_comment

begin_function
specifier|static
name|void
name|mips_align
parameter_list|(
name|int
name|to
parameter_list|,
name|int
name|fill
parameter_list|,
name|symbolS
modifier|*
name|label
parameter_list|)
block|{
name|mips_emit_delays
argument_list|()
expr_stmt|;
name|frag_align
argument_list|(
name|to
argument_list|,
name|fill
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|record_alignment
argument_list|(
name|now_seg
argument_list|,
name|to
argument_list|)
expr_stmt|;
if|if
condition|(
name|label
operator|!=
name|NULL
condition|)
block|{
name|assert
argument_list|(
name|S_GET_SEGMENT
argument_list|(
name|label
argument_list|)
operator|==
name|now_seg
argument_list|)
expr_stmt|;
name|symbol_set_frag
argument_list|(
name|label
argument_list|,
name|frag_now
argument_list|)
expr_stmt|;
name|S_SET_VALUE
argument_list|(
name|label
argument_list|,
operator|(
name|valueT
operator|)
name|frag_now_fix
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Align to a given power of two.  .align 0 turns off the automatic    alignment used by the data creating pseudo-ops.  */
end_comment

begin_function
specifier|static
name|void
name|s_align
parameter_list|(
name|int
name|x
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|int
name|temp
decl_stmt|;
name|long
name|temp_fill
decl_stmt|;
name|long
name|max_alignment
init|=
literal|15
decl_stmt|;
comment|/* o Note that the assembler pulls down any immediately preceding label        to the aligned address.      o It's not documented but auto alignment is reinstated by        a .align pseudo instruction.      o Note also that after auto alignment is turned off the mips assembler        issues an error on attempt to assemble an improperly aligned data item.        We don't.  */
name|temp
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
if|if
condition|(
name|temp
operator|>
name|max_alignment
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Alignment too large: %d. assumed."
argument_list|)
argument_list|,
name|temp
operator|=
name|max_alignment
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|temp
operator|<
literal|0
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"Alignment negative: 0 assumed."
argument_list|)
argument_list|)
expr_stmt|;
name|temp
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|','
condition|)
block|{
operator|++
name|input_line_pointer
expr_stmt|;
name|temp_fill
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
block|}
else|else
name|temp_fill
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|temp
condition|)
block|{
name|segment_info_type
modifier|*
name|si
init|=
name|seg_info
argument_list|(
name|now_seg
argument_list|)
decl_stmt|;
name|struct
name|insn_label_list
modifier|*
name|l
init|=
name|si
operator|->
name|label_list
decl_stmt|;
comment|/* Auto alignment should be switched on by next section change.  */
name|auto_align
operator|=
literal|1
expr_stmt|;
name|mips_align
argument_list|(
name|temp
argument_list|,
operator|(
name|int
operator|)
name|temp_fill
argument_list|,
name|l
operator|!=
name|NULL
condition|?
name|l
operator|->
name|label
else|:
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|auto_align
operator|=
literal|0
expr_stmt|;
block|}
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|s_change_sec
parameter_list|(
name|int
name|sec
parameter_list|)
block|{
name|segT
name|seg
decl_stmt|;
ifdef|#
directive|ifdef
name|OBJ_ELF
comment|/* The ELF backend needs to know that we are changing sections, so      that .previous works correctly.  We could do something like check      for an obj_section_change_hook macro, but that might be confusing      as it would not be appropriate to use it in the section changing      functions in read.c, since obj-elf.c intercepts those.  FIXME:      This should be cleaner, somehow.  */
if|if
condition|(
name|IS_ELF
condition|)
name|obj_elf_section_change_hook
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|mips_emit_delays
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|sec
condition|)
block|{
case|case
literal|'t'
case|:
name|s_text
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|s_data
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
name|subseg_set
argument_list|(
name|bss_section
argument_list|,
operator|(
name|subsegT
operator|)
name|get_absolute_expression
argument_list|()
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|seg
operator|=
name|subseg_new
argument_list|(
name|RDATA_SECTION_NAME
argument_list|,
operator|(
name|subsegT
operator|)
name|get_absolute_expression
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_ELF
condition|)
block|{
name|bfd_set_section_flags
argument_list|(
name|stdoutput
argument_list|,
name|seg
argument_list|,
operator|(
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_READONLY
operator||
name|SEC_RELOC
operator||
name|SEC_DATA
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|TARGET_OS
argument_list|,
literal|"elf"
argument_list|)
operator|!=
literal|0
condition|)
name|record_alignment
argument_list|(
name|seg
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|seg
operator|=
name|subseg_new
argument_list|(
literal|".sdata"
argument_list|,
operator|(
name|subsegT
operator|)
name|get_absolute_expression
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_ELF
condition|)
block|{
name|bfd_set_section_flags
argument_list|(
name|stdoutput
argument_list|,
name|seg
argument_list|,
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_RELOC
operator||
name|SEC_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|TARGET_OS
argument_list|,
literal|"elf"
argument_list|)
operator|!=
literal|0
condition|)
name|record_alignment
argument_list|(
name|seg
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
break|break;
block|}
name|auto_align
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
name|void
name|s_change_section
parameter_list|(
name|int
name|ignore
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|OBJ_ELF
name|char
modifier|*
name|section_name
decl_stmt|;
name|char
name|c
decl_stmt|;
name|char
name|next_c
init|=
literal|0
decl_stmt|;
name|int
name|section_type
decl_stmt|;
name|int
name|section_flag
decl_stmt|;
name|int
name|section_entry_size
decl_stmt|;
name|int
name|section_alignment
decl_stmt|;
if|if
condition|(
operator|!
name|IS_ELF
condition|)
return|return;
name|section_name
operator|=
name|input_line_pointer
expr_stmt|;
name|c
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
condition|)
name|next_c
operator|=
operator|*
operator|(
name|input_line_pointer
operator|+
literal|1
operator|)
expr_stmt|;
comment|/* Do we have .section Name<,"flags">?  */
if|if
condition|(
name|c
operator|!=
literal|','
operator|||
operator|(
name|c
operator|==
literal|','
operator|&&
name|next_c
operator|==
literal|'"'
operator|)
condition|)
block|{
comment|/* just after name is now '\0'.  */
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
name|input_line_pointer
operator|=
name|section_name
expr_stmt|;
name|obj_elf_section
argument_list|(
name|ignore
argument_list|)
expr_stmt|;
return|return;
block|}
name|input_line_pointer
operator|++
expr_stmt|;
comment|/* Do we have .section Name<,type><,flag><,entry_size><,alignment>  */
if|if
condition|(
name|c
operator|==
literal|','
condition|)
name|section_type
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
else|else
name|section_type
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|++
operator|==
literal|','
condition|)
name|section_flag
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
else|else
name|section_flag
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|++
operator|==
literal|','
condition|)
name|section_entry_size
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
else|else
name|section_entry_size
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|++
operator|==
literal|','
condition|)
name|section_alignment
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
else|else
name|section_alignment
operator|=
literal|0
expr_stmt|;
name|section_name
operator|=
name|xstrdup
argument_list|(
name|section_name
argument_list|)
expr_stmt|;
comment|/* When using the generic form of .section (as implemented by obj-elf.c),      there's no way to set the section type to SHT_MIPS_DWARF.  Users have      traditionally had to fall back on the more common @progbits instead.       There's nothing really harmful in this, since bfd will correct      SHT_PROGBITS to SHT_MIPS_DWARF before writing out the file.  But it      means that, for backwards compatibility, the special_section entries      for dwarf sections must use SHT_PROGBITS rather than SHT_MIPS_DWARF.       Even so, we shouldn't force users of the MIPS .section syntax to      incorrectly label the sections as SHT_PROGBITS.  The best compromise      seems to be to map SHT_MIPS_DWARF to SHT_PROGBITS before calling the      generic type-checking code.  */
if|if
condition|(
name|section_type
operator|==
name|SHT_MIPS_DWARF
condition|)
name|section_type
operator|=
name|SHT_PROGBITS
expr_stmt|;
name|obj_elf_change_section
argument_list|(
name|section_name
argument_list|,
name|section_type
argument_list|,
name|section_flag
argument_list|,
name|section_entry_size
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|now_seg
operator|->
name|name
operator|!=
name|section_name
condition|)
name|free
argument_list|(
name|section_name
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* OBJ_ELF */
block|}
end_function

begin_function
name|void
name|mips_enable_auto_align
parameter_list|(
name|void
parameter_list|)
block|{
name|auto_align
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|s_cons
parameter_list|(
name|int
name|log_size
parameter_list|)
block|{
name|segment_info_type
modifier|*
name|si
init|=
name|seg_info
argument_list|(
name|now_seg
argument_list|)
decl_stmt|;
name|struct
name|insn_label_list
modifier|*
name|l
init|=
name|si
operator|->
name|label_list
decl_stmt|;
name|symbolS
modifier|*
name|label
decl_stmt|;
name|label
operator|=
name|l
operator|!=
name|NULL
condition|?
name|l
operator|->
name|label
else|:
name|NULL
expr_stmt|;
name|mips_emit_delays
argument_list|()
expr_stmt|;
if|if
condition|(
name|log_size
operator|>
literal|0
operator|&&
name|auto_align
condition|)
name|mips_align
argument_list|(
name|log_size
argument_list|,
literal|0
argument_list|,
name|label
argument_list|)
expr_stmt|;
name|mips_clear_insn_labels
argument_list|()
expr_stmt|;
name|cons
argument_list|(
literal|1
operator|<<
name|log_size
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|s_float_cons
parameter_list|(
name|int
name|type
parameter_list|)
block|{
name|segment_info_type
modifier|*
name|si
init|=
name|seg_info
argument_list|(
name|now_seg
argument_list|)
decl_stmt|;
name|struct
name|insn_label_list
modifier|*
name|l
init|=
name|si
operator|->
name|label_list
decl_stmt|;
name|symbolS
modifier|*
name|label
decl_stmt|;
name|label
operator|=
name|l
operator|!=
name|NULL
condition|?
name|l
operator|->
name|label
else|:
name|NULL
expr_stmt|;
name|mips_emit_delays
argument_list|()
expr_stmt|;
if|if
condition|(
name|auto_align
condition|)
block|{
if|if
condition|(
name|type
operator|==
literal|'d'
condition|)
name|mips_align
argument_list|(
literal|3
argument_list|,
literal|0
argument_list|,
name|label
argument_list|)
expr_stmt|;
else|else
name|mips_align
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|,
name|label
argument_list|)
expr_stmt|;
block|}
name|mips_clear_insn_labels
argument_list|()
expr_stmt|;
name|float_cons
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle .globl.  We need to override it because on Irix 5 you are    permitted to say        .globl foo .text    where foo is an undefined symbol, to mean that foo should be    considered to be the address of a function.  */
end_comment

begin_function
specifier|static
name|void
name|s_mips_globl
parameter_list|(
name|int
name|x
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|c
decl_stmt|;
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
name|flagword
name|flag
decl_stmt|;
do|do
block|{
name|name
operator|=
name|input_line_pointer
expr_stmt|;
name|c
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
name|symbolP
operator|=
name|symbol_find_or_make
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|S_SET_EXTERNAL
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
comment|/* On Irix 5, every global symbol that is not explicitly labelled as          being a function is apparently labelled as being an object.  */
name|flag
operator|=
name|BSF_OBJECT
expr_stmt|;
if|if
condition|(
operator|!
name|is_end_of_line
index|[
operator|(
name|unsigned
name|char
operator|)
operator|*
name|input_line_pointer
index|]
operator|&&
operator|(
operator|*
name|input_line_pointer
operator|!=
literal|','
operator|)
condition|)
block|{
name|char
modifier|*
name|secname
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|secname
operator|=
name|input_line_pointer
expr_stmt|;
name|c
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
name|sec
operator|=
name|bfd_get_section_by_name
argument_list|(
name|stdoutput
argument_list|,
name|secname
argument_list|)
expr_stmt|;
if|if
condition|(
name|sec
operator|==
name|NULL
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"%s: no such section"
argument_list|)
argument_list|,
name|secname
argument_list|)
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|sec
operator|!=
name|NULL
operator|&&
operator|(
name|sec
operator|->
name|flags
operator|&
name|SEC_CODE
operator|)
operator|!=
literal|0
condition|)
name|flag
operator|=
name|BSF_FUNCTION
expr_stmt|;
block|}
name|symbol_get_bfdsym
argument_list|(
name|symbolP
argument_list|)
operator|->
name|flags
operator||=
name|flag
expr_stmt|;
name|c
operator|=
operator|*
name|input_line_pointer
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|','
condition|)
block|{
name|input_line_pointer
operator|++
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
name|is_end_of_line
index|[
operator|(
name|unsigned
name|char
operator|)
operator|*
name|input_line_pointer
index|]
condition|)
name|c
operator|=
literal|'\n'
expr_stmt|;
block|}
block|}
do|while
condition|(
name|c
operator|==
literal|','
condition|)
do|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|s_option
parameter_list|(
name|int
name|x
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|char
modifier|*
name|opt
decl_stmt|;
name|char
name|c
decl_stmt|;
name|opt
operator|=
name|input_line_pointer
expr_stmt|;
name|c
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|opt
operator|==
literal|'O'
condition|)
block|{
comment|/* FIXME: What does this mean?  */
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|opt
argument_list|,
literal|"pic"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
block|{
name|int
name|i
decl_stmt|;
name|i
operator|=
name|atoi
argument_list|(
name|opt
operator|+
literal|3
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
name|mips_pic
operator|=
name|NO_PIC
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|==
literal|2
condition|)
block|{
name|mips_pic
operator|=
name|SVR4_PIC
expr_stmt|;
name|mips_abicalls
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
name|as_bad
argument_list|(
name|_
argument_list|(
literal|".option pic%d not supported"
argument_list|)
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|mips_pic
operator|==
name|SVR4_PIC
condition|)
block|{
if|if
condition|(
name|g_switch_seen
operator|&&
name|g_switch_value
operator|!=
literal|0
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"-G may not be used with SVR4 PIC code"
argument_list|)
argument_list|)
expr_stmt|;
name|g_switch_value
operator|=
literal|0
expr_stmt|;
name|bfd_set_gp_size
argument_list|(
name|stdoutput
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"Unrecognized option \"%s\""
argument_list|)
argument_list|,
name|opt
argument_list|)
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This structure is used to hold a stack of .set values.  */
end_comment

begin_struct
struct|struct
name|mips_option_stack
block|{
name|struct
name|mips_option_stack
modifier|*
name|next
decl_stmt|;
name|struct
name|mips_set_options
name|options
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|mips_option_stack
modifier|*
name|mips_opts_stack
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Handle the .set pseudo-op.  */
end_comment

begin_function
specifier|static
name|void
name|s_mipsset
parameter_list|(
name|int
name|x
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|char
modifier|*
name|name
init|=
name|input_line_pointer
decl_stmt|,
name|ch
decl_stmt|;
while|while
condition|(
operator|!
name|is_end_of_line
index|[
operator|(
name|unsigned
name|char
operator|)
operator|*
name|input_line_pointer
index|]
condition|)
operator|++
name|input_line_pointer
expr_stmt|;
name|ch
operator|=
operator|*
name|input_line_pointer
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"reorder"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|mips_opts
operator|.
name|noreorder
condition|)
name|end_noreorder
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"noreorder"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|mips_opts
operator|.
name|noreorder
condition|)
name|start_noreorder
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"at"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|mips_opts
operator|.
name|noat
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"noat"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|mips_opts
operator|.
name|noat
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"macro"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|mips_opts
operator|.
name|warn_about_macros
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"nomacro"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|mips_opts
operator|.
name|noreorder
operator|==
literal|0
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"`noreorder' must be set before `nomacro'"
argument_list|)
argument_list|)
expr_stmt|;
name|mips_opts
operator|.
name|warn_about_macros
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"move"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"novolatile"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|mips_opts
operator|.
name|nomove
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"nomove"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"volatile"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|mips_opts
operator|.
name|nomove
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"bopt"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|mips_opts
operator|.
name|nobopt
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"nobopt"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|mips_opts
operator|.
name|nobopt
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"gp=default"
argument_list|)
operator|==
literal|0
condition|)
name|mips_opts
operator|.
name|gp32
operator|=
name|file_mips_gp32
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"gp=32"
argument_list|)
operator|==
literal|0
condition|)
name|mips_opts
operator|.
name|gp32
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"gp=64"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|ISA_HAS_64BIT_REGS
argument_list|(
name|mips_opts
operator|.
name|isa
argument_list|)
condition|)
name|as_warn
argument_list|(
literal|"%s isa does not support 64-bit registers"
argument_list|,
name|mips_cpu_info_from_isa
argument_list|(
name|mips_opts
operator|.
name|isa
argument_list|)
operator|->
name|name
argument_list|)
expr_stmt|;
name|mips_opts
operator|.
name|gp32
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"fp=default"
argument_list|)
operator|==
literal|0
condition|)
name|mips_opts
operator|.
name|fp32
operator|=
name|file_mips_fp32
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"fp=32"
argument_list|)
operator|==
literal|0
condition|)
name|mips_opts
operator|.
name|fp32
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"fp=64"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|ISA_HAS_64BIT_FPRS
argument_list|(
name|mips_opts
operator|.
name|isa
argument_list|)
condition|)
name|as_warn
argument_list|(
literal|"%s isa does not support 64-bit floating point registers"
argument_list|,
name|mips_cpu_info_from_isa
argument_list|(
name|mips_opts
operator|.
name|isa
argument_list|)
operator|->
name|name
argument_list|)
expr_stmt|;
name|mips_opts
operator|.
name|fp32
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"mips16"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"MIPS-16"
argument_list|)
operator|==
literal|0
condition|)
name|mips_opts
operator|.
name|mips16
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"nomips16"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"noMIPS-16"
argument_list|)
operator|==
literal|0
condition|)
name|mips_opts
operator|.
name|mips16
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"smartmips"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|ISA_SUPPORTS_SMARTMIPS
condition|)
name|as_warn
argument_list|(
literal|"%s ISA does not support SmartMIPS ASE"
argument_list|,
name|mips_cpu_info_from_isa
argument_list|(
name|mips_opts
operator|.
name|isa
argument_list|)
operator|->
name|name
argument_list|)
expr_stmt|;
name|mips_opts
operator|.
name|ase_smartmips
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"nosmartmips"
argument_list|)
operator|==
literal|0
condition|)
name|mips_opts
operator|.
name|ase_smartmips
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"mips3d"
argument_list|)
operator|==
literal|0
condition|)
name|mips_opts
operator|.
name|ase_mips3d
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"nomips3d"
argument_list|)
operator|==
literal|0
condition|)
name|mips_opts
operator|.
name|ase_mips3d
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"mdmx"
argument_list|)
operator|==
literal|0
condition|)
name|mips_opts
operator|.
name|ase_mdmx
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"nomdmx"
argument_list|)
operator|==
literal|0
condition|)
name|mips_opts
operator|.
name|ase_mdmx
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"dsp"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|ISA_SUPPORTS_DSP_ASE
condition|)
name|as_warn
argument_list|(
literal|"%s ISA does not support DSP ASE"
argument_list|,
name|mips_cpu_info_from_isa
argument_list|(
name|mips_opts
operator|.
name|isa
argument_list|)
operator|->
name|name
argument_list|)
expr_stmt|;
name|mips_opts
operator|.
name|ase_dsp
operator|=
literal|1
expr_stmt|;
name|mips_opts
operator|.
name|ase_dspr2
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"nodsp"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|mips_opts
operator|.
name|ase_dsp
operator|=
literal|0
expr_stmt|;
name|mips_opts
operator|.
name|ase_dspr2
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"dspr2"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|ISA_SUPPORTS_DSPR2_ASE
condition|)
name|as_warn
argument_list|(
literal|"%s ISA does not support DSP R2 ASE"
argument_list|,
name|mips_cpu_info_from_isa
argument_list|(
name|mips_opts
operator|.
name|isa
argument_list|)
operator|->
name|name
argument_list|)
expr_stmt|;
name|mips_opts
operator|.
name|ase_dspr2
operator|=
literal|1
expr_stmt|;
name|mips_opts
operator|.
name|ase_dsp
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"nodspr2"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|mips_opts
operator|.
name|ase_dspr2
operator|=
literal|0
expr_stmt|;
name|mips_opts
operator|.
name|ase_dsp
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"mt"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|ISA_SUPPORTS_MT_ASE
condition|)
name|as_warn
argument_list|(
literal|"%s ISA does not support MT ASE"
argument_list|,
name|mips_cpu_info_from_isa
argument_list|(
name|mips_opts
operator|.
name|isa
argument_list|)
operator|->
name|name
argument_list|)
expr_stmt|;
name|mips_opts
operator|.
name|ase_mt
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"nomt"
argument_list|)
operator|==
literal|0
condition|)
name|mips_opts
operator|.
name|ase_mt
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
literal|"mips"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
operator|||
name|strncmp
argument_list|(
name|name
argument_list|,
literal|"arch="
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
block|{
name|int
name|reset
init|=
literal|0
decl_stmt|;
comment|/* Permit the user to change the ISA and architecture on the fly. 	 Needless to say, misuse can cause serious problems.  */
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"mips0"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"arch=default"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|reset
operator|=
literal|1
expr_stmt|;
name|mips_opts
operator|.
name|isa
operator|=
name|file_mips_isa
expr_stmt|;
name|mips_opts
operator|.
name|arch
operator|=
name|file_mips_arch
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
literal|"arch="
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
block|{
specifier|const
name|struct
name|mips_cpu_info
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|mips_parse_cpu
argument_list|(
literal|"internal use"
argument_list|,
name|name
operator|+
literal|5
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"unknown architecture %s"
argument_list|)
argument_list|,
name|name
operator|+
literal|5
argument_list|)
expr_stmt|;
else|else
block|{
name|mips_opts
operator|.
name|arch
operator|=
name|p
operator|->
name|cpu
expr_stmt|;
name|mips_opts
operator|.
name|isa
operator|=
name|p
operator|->
name|isa
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
literal|"mips"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
block|{
specifier|const
name|struct
name|mips_cpu_info
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|mips_parse_cpu
argument_list|(
literal|"internal use"
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"unknown ISA level %s"
argument_list|)
argument_list|,
name|name
operator|+
literal|4
argument_list|)
expr_stmt|;
else|else
block|{
name|mips_opts
operator|.
name|arch
operator|=
name|p
operator|->
name|cpu
expr_stmt|;
name|mips_opts
operator|.
name|isa
operator|=
name|p
operator|->
name|isa
expr_stmt|;
block|}
block|}
else|else
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"unknown ISA or architecture %s"
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|mips_opts
operator|.
name|isa
condition|)
block|{
case|case
literal|0
case|:
break|break;
case|case
name|ISA_MIPS1
case|:
case|case
name|ISA_MIPS2
case|:
case|case
name|ISA_MIPS32
case|:
case|case
name|ISA_MIPS32R2
case|:
name|mips_opts
operator|.
name|gp32
operator|=
literal|1
expr_stmt|;
name|mips_opts
operator|.
name|fp32
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|ISA_MIPS3
case|:
case|case
name|ISA_MIPS4
case|:
case|case
name|ISA_MIPS5
case|:
case|case
name|ISA_MIPS64
case|:
case|case
name|ISA_MIPS64R2
case|:
name|mips_opts
operator|.
name|gp32
operator|=
literal|0
expr_stmt|;
name|mips_opts
operator|.
name|fp32
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"unknown ISA level %s"
argument_list|)
argument_list|,
name|name
operator|+
literal|4
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|reset
condition|)
block|{
name|mips_opts
operator|.
name|gp32
operator|=
name|file_mips_gp32
expr_stmt|;
name|mips_opts
operator|.
name|fp32
operator|=
name|file_mips_fp32
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"autoextend"
argument_list|)
operator|==
literal|0
condition|)
name|mips_opts
operator|.
name|noautoextend
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"noautoextend"
argument_list|)
operator|==
literal|0
condition|)
name|mips_opts
operator|.
name|noautoextend
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"push"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|struct
name|mips_option_stack
modifier|*
name|s
decl_stmt|;
name|s
operator|=
operator|(
expr|struct
name|mips_option_stack
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
expr|*
name|s
argument_list|)
expr_stmt|;
name|s
operator|->
name|next
operator|=
name|mips_opts_stack
expr_stmt|;
name|s
operator|->
name|options
operator|=
name|mips_opts
expr_stmt|;
name|mips_opts_stack
operator|=
name|s
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"pop"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|struct
name|mips_option_stack
modifier|*
name|s
decl_stmt|;
name|s
operator|=
name|mips_opts_stack
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|".set pop with no .set push"
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* If we're changing the reorder mode we need to handle              delay slots correctly.  */
if|if
condition|(
name|s
operator|->
name|options
operator|.
name|noreorder
operator|&&
operator|!
name|mips_opts
operator|.
name|noreorder
condition|)
name|start_noreorder
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|s
operator|->
name|options
operator|.
name|noreorder
operator|&&
name|mips_opts
operator|.
name|noreorder
condition|)
name|end_noreorder
argument_list|()
expr_stmt|;
name|mips_opts
operator|=
name|s
operator|->
name|options
expr_stmt|;
name|mips_opts_stack
operator|=
name|s
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"sym32"
argument_list|)
operator|==
literal|0
condition|)
name|mips_opts
operator|.
name|sym32
operator|=
name|TRUE
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"nosym32"
argument_list|)
operator|==
literal|0
condition|)
name|mips_opts
operator|.
name|sym32
operator|=
name|FALSE
expr_stmt|;
elseif|else
if|if
condition|(
name|strchr
argument_list|(
name|name
argument_list|,
literal|','
argument_list|)
condition|)
block|{
comment|/* Generic ".set" directive; use the generic handler.  */
operator|*
name|input_line_pointer
operator|=
name|ch
expr_stmt|;
name|input_line_pointer
operator|=
name|name
expr_stmt|;
name|s_set
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"Tried to set unrecognized symbol: %s\n"
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
operator|*
name|input_line_pointer
operator|=
name|ch
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle the .abicalls pseudo-op.  I believe this is equivalent to    .option pic2.  It means to generate SVR4 PIC calls.  */
end_comment

begin_function
specifier|static
name|void
name|s_abicalls
parameter_list|(
name|int
name|ignore
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|mips_pic
operator|=
name|SVR4_PIC
expr_stmt|;
name|mips_abicalls
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|g_switch_seen
operator|&&
name|g_switch_value
operator|!=
literal|0
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"-G may not be used with SVR4 PIC code"
argument_list|)
argument_list|)
expr_stmt|;
name|g_switch_value
operator|=
literal|0
expr_stmt|;
name|bfd_set_gp_size
argument_list|(
name|stdoutput
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle the .cpload pseudo-op.  This is used when generating SVR4    PIC code.  It sets the $gp register for the function based on the    function address, which is in the register named in the argument.    This uses a relocation against _gp_disp, which is handled specially    by the linker.  The result is: 	lui	$gp,%hi(_gp_disp) 	addiu	$gp,$gp,%lo(_gp_disp) 	addu	$gp,$gp,.cpload argument    The .cpload argument is normally $25 == $t9.     The -mno-shared option changes this to: 	lui	$gp,%hi(__gnu_local_gp) 	addiu	$gp,$gp,%lo(__gnu_local_gp)    and the argument is ignored.  This saves an instruction, but the    resulting code is not position independent; it uses an absolute    address for __gnu_local_gp.  Thus code assembled with -mno-shared    can go into an ordinary executable, but not into a shared library.  */
end_comment

begin_function
specifier|static
name|void
name|s_cpload
parameter_list|(
name|int
name|ignore
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|expressionS
name|ex
decl_stmt|;
name|int
name|reg
decl_stmt|;
name|int
name|in_shared
decl_stmt|;
comment|/* If we are not generating SVR4 PIC code, or if this is NewABI code,      .cpload is ignored.  */
if|if
condition|(
name|mips_pic
operator|!=
name|SVR4_PIC
operator|||
name|HAVE_NEWABI
condition|)
block|{
name|s_ignore
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* .cpload should be in a .set noreorder section.  */
if|if
condition|(
name|mips_opts
operator|.
name|noreorder
operator|==
literal|0
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|".cpload not in noreorder section"
argument_list|)
argument_list|)
expr_stmt|;
name|reg
operator|=
name|tc_get_register
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* If we need to produce a 64-bit address, we are better off using      the default instruction sequence.  */
name|in_shared
operator|=
name|mips_in_shared
operator|||
name|HAVE_64BIT_SYMBOLS
expr_stmt|;
name|ex
operator|.
name|X_op
operator|=
name|O_symbol
expr_stmt|;
name|ex
operator|.
name|X_add_symbol
operator|=
name|symbol_find_or_make
argument_list|(
name|in_shared
condition|?
literal|"_gp_disp"
else|:
literal|"__gnu_local_gp"
argument_list|)
expr_stmt|;
name|ex
operator|.
name|X_op_symbol
operator|=
name|NULL
expr_stmt|;
name|ex
operator|.
name|X_add_number
operator|=
literal|0
expr_stmt|;
comment|/* In ELF, this symbol is implicitly an STT_OBJECT symbol.  */
name|symbol_get_bfdsym
argument_list|(
name|ex
operator|.
name|X_add_symbol
argument_list|)
operator|->
name|flags
operator||=
name|BSF_OBJECT
expr_stmt|;
name|macro_start
argument_list|()
expr_stmt|;
name|macro_build_lui
argument_list|(
operator|&
name|ex
argument_list|,
name|mips_gp_register
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|ex
argument_list|,
literal|"addiu"
argument_list|,
literal|"t,r,j"
argument_list|,
name|mips_gp_register
argument_list|,
name|mips_gp_register
argument_list|,
name|BFD_RELOC_LO16
argument_list|)
expr_stmt|;
if|if
condition|(
name|in_shared
condition|)
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"addu"
argument_list|,
literal|"d,v,t"
argument_list|,
name|mips_gp_register
argument_list|,
name|mips_gp_register
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|macro_end
argument_list|()
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle the .cpsetup pseudo-op defined for NewABI PIC code.  The syntax is:      .cpsetup $reg1, offset|$reg2, label     If offset is given, this results in:      sd		$gp, offset($sp)      lui	$gp, %hi(%neg(%gp_rel(label)))      addiu	$gp, $gp, %lo(%neg(%gp_rel(label)))      daddu	$gp, $gp, $reg1     If $reg2 is given, this results in:      daddu	$reg2, $gp, $0      lui	$gp, %hi(%neg(%gp_rel(label)))      addiu	$gp, $gp, %lo(%neg(%gp_rel(label)))      daddu	$gp, $gp, $reg1    $reg1 is normally $25 == $t9.     The -mno-shared option replaces the last three instructions with 	lui	$gp,%hi(_gp) 	addiu	$gp,$gp,%lo(_gp)  */
end_comment

begin_function
specifier|static
name|void
name|s_cpsetup
parameter_list|(
name|int
name|ignore
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|expressionS
name|ex_off
decl_stmt|;
name|expressionS
name|ex_sym
decl_stmt|;
name|int
name|reg1
decl_stmt|;
comment|/* If we are not generating SVR4 PIC code, .cpsetup is ignored.      We also need NewABI support.  */
if|if
condition|(
name|mips_pic
operator|!=
name|SVR4_PIC
operator|||
operator|!
name|HAVE_NEWABI
condition|)
block|{
name|s_ignore
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
name|reg1
operator|=
name|tc_get_register
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|!=
literal|','
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"missing argument separator ',' for .cpsetup"
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
operator|++
name|input_line_pointer
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|'$'
condition|)
block|{
name|mips_cpreturn_register
operator|=
name|tc_get_register
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|mips_cpreturn_offset
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|mips_cpreturn_offset
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
name|mips_cpreturn_register
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|!=
literal|','
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"missing argument separator ',' for .cpsetup"
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
operator|++
name|input_line_pointer
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
name|expression
argument_list|(
operator|&
name|ex_sym
argument_list|)
expr_stmt|;
name|macro_start
argument_list|()
expr_stmt|;
if|if
condition|(
name|mips_cpreturn_register
operator|==
operator|-
literal|1
condition|)
block|{
name|ex_off
operator|.
name|X_op
operator|=
name|O_constant
expr_stmt|;
name|ex_off
operator|.
name|X_add_symbol
operator|=
name|NULL
expr_stmt|;
name|ex_off
operator|.
name|X_op_symbol
operator|=
name|NULL
expr_stmt|;
name|ex_off
operator|.
name|X_add_number
operator|=
name|mips_cpreturn_offset
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|ex_off
argument_list|,
literal|"sd"
argument_list|,
literal|"t,o(b)"
argument_list|,
name|mips_gp_register
argument_list|,
name|BFD_RELOC_LO16
argument_list|,
name|SP
argument_list|)
expr_stmt|;
block|}
else|else
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"daddu"
argument_list|,
literal|"d,v,t"
argument_list|,
name|mips_cpreturn_register
argument_list|,
name|mips_gp_register
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|mips_in_shared
operator|||
name|HAVE_64BIT_SYMBOLS
condition|)
block|{
name|macro_build
argument_list|(
operator|&
name|ex_sym
argument_list|,
literal|"lui"
argument_list|,
literal|"t,u"
argument_list|,
name|mips_gp_register
argument_list|,
operator|-
literal|1
argument_list|,
name|BFD_RELOC_GPREL16
argument_list|,
name|BFD_RELOC_MIPS_SUB
argument_list|,
name|BFD_RELOC_HI16_S
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|ex_sym
argument_list|,
literal|"addiu"
argument_list|,
literal|"t,r,j"
argument_list|,
name|mips_gp_register
argument_list|,
name|mips_gp_register
argument_list|,
operator|-
literal|1
argument_list|,
name|BFD_RELOC_GPREL16
argument_list|,
name|BFD_RELOC_MIPS_SUB
argument_list|,
name|BFD_RELOC_LO16
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
name|ADDRESS_ADD_INSN
argument_list|,
literal|"d,v,t"
argument_list|,
name|mips_gp_register
argument_list|,
name|mips_gp_register
argument_list|,
name|reg1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|expressionS
name|ex
decl_stmt|;
name|ex
operator|.
name|X_op
operator|=
name|O_symbol
expr_stmt|;
name|ex
operator|.
name|X_add_symbol
operator|=
name|symbol_find_or_make
argument_list|(
literal|"__gnu_local_gp"
argument_list|)
expr_stmt|;
name|ex
operator|.
name|X_op_symbol
operator|=
name|NULL
expr_stmt|;
name|ex
operator|.
name|X_add_number
operator|=
literal|0
expr_stmt|;
comment|/* In ELF, this symbol is implicitly an STT_OBJECT symbol.  */
name|symbol_get_bfdsym
argument_list|(
name|ex
operator|.
name|X_add_symbol
argument_list|)
operator|->
name|flags
operator||=
name|BSF_OBJECT
expr_stmt|;
name|macro_build_lui
argument_list|(
operator|&
name|ex
argument_list|,
name|mips_gp_register
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|ex
argument_list|,
literal|"addiu"
argument_list|,
literal|"t,r,j"
argument_list|,
name|mips_gp_register
argument_list|,
name|mips_gp_register
argument_list|,
name|BFD_RELOC_LO16
argument_list|)
expr_stmt|;
block|}
name|macro_end
argument_list|()
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|s_cplocal
parameter_list|(
name|int
name|ignore
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
comment|/* If we are not generating SVR4 PIC code, or if this is not NewABI code,      .cplocal is ignored.  */
if|if
condition|(
name|mips_pic
operator|!=
name|SVR4_PIC
operator|||
operator|!
name|HAVE_NEWABI
condition|)
block|{
name|s_ignore
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
name|mips_gp_register
operator|=
name|tc_get_register
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle the .cprestore pseudo-op.  This stores $gp into a given    offset from $sp.  The offset is remembered, and after making a PIC    call $gp is restored from that location.  */
end_comment

begin_function
specifier|static
name|void
name|s_cprestore
parameter_list|(
name|int
name|ignore
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|expressionS
name|ex
decl_stmt|;
comment|/* If we are not generating SVR4 PIC code, or if this is NewABI code,      .cprestore is ignored.  */
if|if
condition|(
name|mips_pic
operator|!=
name|SVR4_PIC
operator|||
name|HAVE_NEWABI
condition|)
block|{
name|s_ignore
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
name|mips_cprestore_offset
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
name|mips_cprestore_valid
operator|=
literal|1
expr_stmt|;
name|ex
operator|.
name|X_op
operator|=
name|O_constant
expr_stmt|;
name|ex
operator|.
name|X_add_symbol
operator|=
name|NULL
expr_stmt|;
name|ex
operator|.
name|X_op_symbol
operator|=
name|NULL
expr_stmt|;
name|ex
operator|.
name|X_add_number
operator|=
name|mips_cprestore_offset
expr_stmt|;
name|macro_start
argument_list|()
expr_stmt|;
name|macro_build_ldst_constoffset
argument_list|(
operator|&
name|ex
argument_list|,
name|ADDRESS_STORE_INSN
argument_list|,
name|mips_gp_register
argument_list|,
name|SP
argument_list|,
name|HAVE_64BIT_ADDRESSES
argument_list|)
expr_stmt|;
name|macro_end
argument_list|()
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle the .cpreturn pseudo-op defined for NewABI PIC code. If an offset    was given in the preceding .cpsetup, it results in:      ld		$gp, offset($sp)     If a register $reg2 was given there, it results in:      daddu	$gp, $reg2, $0  */
end_comment

begin_function
specifier|static
name|void
name|s_cpreturn
parameter_list|(
name|int
name|ignore
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|expressionS
name|ex
decl_stmt|;
comment|/* If we are not generating SVR4 PIC code, .cpreturn is ignored.      We also need NewABI support.  */
if|if
condition|(
name|mips_pic
operator|!=
name|SVR4_PIC
operator|||
operator|!
name|HAVE_NEWABI
condition|)
block|{
name|s_ignore
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
name|macro_start
argument_list|()
expr_stmt|;
if|if
condition|(
name|mips_cpreturn_register
operator|==
operator|-
literal|1
condition|)
block|{
name|ex
operator|.
name|X_op
operator|=
name|O_constant
expr_stmt|;
name|ex
operator|.
name|X_add_symbol
operator|=
name|NULL
expr_stmt|;
name|ex
operator|.
name|X_op_symbol
operator|=
name|NULL
expr_stmt|;
name|ex
operator|.
name|X_add_number
operator|=
name|mips_cpreturn_offset
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|ex
argument_list|,
literal|"ld"
argument_list|,
literal|"t,o(b)"
argument_list|,
name|mips_gp_register
argument_list|,
name|BFD_RELOC_LO16
argument_list|,
name|SP
argument_list|)
expr_stmt|;
block|}
else|else
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"daddu"
argument_list|,
literal|"d,v,t"
argument_list|,
name|mips_gp_register
argument_list|,
name|mips_cpreturn_register
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|macro_end
argument_list|()
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle the .dtprelword and .dtpreldword pseudo-ops.  They generate    a 32-bit or 64-bit DTP-relative relocation (BYTES says which) for    use in DWARF debug information.  */
end_comment

begin_function
specifier|static
name|void
name|s_dtprel_internal
parameter_list|(
name|size_t
name|bytes
parameter_list|)
block|{
name|expressionS
name|ex
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|expression
argument_list|(
operator|&
name|ex
argument_list|)
expr_stmt|;
if|if
condition|(
name|ex
operator|.
name|X_op
operator|!=
name|O_symbol
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Unsupported use of %s"
argument_list|)
argument_list|,
operator|(
name|bytes
operator|==
literal|8
condition|?
literal|".dtpreldword"
else|:
literal|".dtprelword"
operator|)
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
block|}
name|p
operator|=
name|frag_more
argument_list|(
name|bytes
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|p
argument_list|,
literal|0
argument_list|,
name|bytes
argument_list|)
expr_stmt|;
name|fix_new_exp
argument_list|(
name|frag_now
argument_list|,
name|p
operator|-
name|frag_now
operator|->
name|fr_literal
argument_list|,
name|bytes
argument_list|,
operator|&
name|ex
argument_list|,
name|FALSE
argument_list|,
operator|(
name|bytes
operator|==
literal|8
condition|?
name|BFD_RELOC_MIPS_TLS_DTPREL64
else|:
name|BFD_RELOC_MIPS_TLS_DTPREL32
operator|)
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle .dtprelword.  */
end_comment

begin_function
specifier|static
name|void
name|s_dtprelword
parameter_list|(
name|int
name|ignore
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|s_dtprel_internal
argument_list|(
literal|4
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle .dtpreldword.  */
end_comment

begin_function
specifier|static
name|void
name|s_dtpreldword
parameter_list|(
name|int
name|ignore
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|s_dtprel_internal
argument_list|(
literal|8
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle the .gpvalue pseudo-op.  This is used when generating NewABI PIC    code.  It sets the offset to use in gp_rel relocations.  */
end_comment

begin_function
specifier|static
name|void
name|s_gpvalue
parameter_list|(
name|int
name|ignore
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
comment|/* If we are not generating SVR4 PIC code, .gpvalue is ignored.      We also need NewABI support.  */
if|if
condition|(
name|mips_pic
operator|!=
name|SVR4_PIC
operator|||
operator|!
name|HAVE_NEWABI
condition|)
block|{
name|s_ignore
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
name|mips_gprel_offset
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle the .gpword pseudo-op.  This is used when generating PIC    code.  It generates a 32 bit GP relative reloc.  */
end_comment

begin_function
specifier|static
name|void
name|s_gpword
parameter_list|(
name|int
name|ignore
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|segment_info_type
modifier|*
name|si
decl_stmt|;
name|struct
name|insn_label_list
modifier|*
name|l
decl_stmt|;
name|symbolS
modifier|*
name|label
decl_stmt|;
name|expressionS
name|ex
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
comment|/* When not generating PIC code, this is treated as .word.  */
if|if
condition|(
name|mips_pic
operator|!=
name|SVR4_PIC
condition|)
block|{
name|s_cons
argument_list|(
literal|2
argument_list|)
expr_stmt|;
return|return;
block|}
name|si
operator|=
name|seg_info
argument_list|(
name|now_seg
argument_list|)
expr_stmt|;
name|l
operator|=
name|si
operator|->
name|label_list
expr_stmt|;
name|label
operator|=
name|l
operator|!=
name|NULL
condition|?
name|l
operator|->
name|label
else|:
name|NULL
expr_stmt|;
name|mips_emit_delays
argument_list|()
expr_stmt|;
if|if
condition|(
name|auto_align
condition|)
name|mips_align
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|,
name|label
argument_list|)
expr_stmt|;
name|mips_clear_insn_labels
argument_list|()
expr_stmt|;
name|expression
argument_list|(
operator|&
name|ex
argument_list|)
expr_stmt|;
if|if
condition|(
name|ex
operator|.
name|X_op
operator|!=
name|O_symbol
operator|||
name|ex
operator|.
name|X_add_number
operator|!=
literal|0
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Unsupported use of .gpword"
argument_list|)
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
block|}
name|p
operator|=
name|frag_more
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|p
argument_list|,
literal|0
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|fix_new_exp
argument_list|(
name|frag_now
argument_list|,
name|p
operator|-
name|frag_now
operator|->
name|fr_literal
argument_list|,
literal|4
argument_list|,
operator|&
name|ex
argument_list|,
name|FALSE
argument_list|,
name|BFD_RELOC_GPREL32
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|s_gpdword
parameter_list|(
name|int
name|ignore
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|segment_info_type
modifier|*
name|si
decl_stmt|;
name|struct
name|insn_label_list
modifier|*
name|l
decl_stmt|;
name|symbolS
modifier|*
name|label
decl_stmt|;
name|expressionS
name|ex
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
comment|/* When not generating PIC code, this is treated as .dword.  */
if|if
condition|(
name|mips_pic
operator|!=
name|SVR4_PIC
condition|)
block|{
name|s_cons
argument_list|(
literal|3
argument_list|)
expr_stmt|;
return|return;
block|}
name|si
operator|=
name|seg_info
argument_list|(
name|now_seg
argument_list|)
expr_stmt|;
name|l
operator|=
name|si
operator|->
name|label_list
expr_stmt|;
name|label
operator|=
name|l
operator|!=
name|NULL
condition|?
name|l
operator|->
name|label
else|:
name|NULL
expr_stmt|;
name|mips_emit_delays
argument_list|()
expr_stmt|;
if|if
condition|(
name|auto_align
condition|)
name|mips_align
argument_list|(
literal|3
argument_list|,
literal|0
argument_list|,
name|label
argument_list|)
expr_stmt|;
name|mips_clear_insn_labels
argument_list|()
expr_stmt|;
name|expression
argument_list|(
operator|&
name|ex
argument_list|)
expr_stmt|;
if|if
condition|(
name|ex
operator|.
name|X_op
operator|!=
name|O_symbol
operator|||
name|ex
operator|.
name|X_add_number
operator|!=
literal|0
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Unsupported use of .gpdword"
argument_list|)
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
block|}
name|p
operator|=
name|frag_more
argument_list|(
literal|8
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|p
argument_list|,
literal|0
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|fix_new_exp
argument_list|(
name|frag_now
argument_list|,
name|p
operator|-
name|frag_now
operator|->
name|fr_literal
argument_list|,
literal|4
argument_list|,
operator|&
name|ex
argument_list|,
name|FALSE
argument_list|,
name|BFD_RELOC_GPREL32
argument_list|)
operator|->
name|fx_tcbit
operator|=
literal|1
expr_stmt|;
comment|/* GPREL32 composed with 64 gives a 64-bit GP offset.  */
name|fix_new
argument_list|(
name|frag_now
argument_list|,
name|p
operator|-
name|frag_now
operator|->
name|fr_literal
argument_list|,
literal|8
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|FALSE
argument_list|,
name|BFD_RELOC_64
argument_list|)
operator|->
name|fx_tcbit
operator|=
literal|1
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle the .cpadd pseudo-op.  This is used when dealing with switch    tables in SVR4 PIC code.  */
end_comment

begin_function
specifier|static
name|void
name|s_cpadd
parameter_list|(
name|int
name|ignore
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|int
name|reg
decl_stmt|;
comment|/* This is ignored when not generating SVR4 PIC code.  */
if|if
condition|(
name|mips_pic
operator|!=
name|SVR4_PIC
condition|)
block|{
name|s_ignore
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Add $gp to the register named as an argument.  */
name|macro_start
argument_list|()
expr_stmt|;
name|reg
operator|=
name|tc_get_register
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
name|ADDRESS_ADD_INSN
argument_list|,
literal|"d,v,t"
argument_list|,
name|reg
argument_list|,
name|reg
argument_list|,
name|mips_gp_register
argument_list|)
expr_stmt|;
name|macro_end
argument_list|()
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle the .insn pseudo-op.  This marks instruction labels in    mips16 mode.  This permits the linker to handle them specially,    such as generating jalx instructions when needed.  We also make    them odd for the duration of the assembly, in order to generate the    right sort of code.  We will make them even in the adjust_symtab    routine, while leaving them marked.  This is convenient for the    debugger and the disassembler.  The linker knows to make them odd    again.  */
end_comment

begin_function
specifier|static
name|void
name|s_insn
parameter_list|(
name|int
name|ignore
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|mips16_mark_labels
argument_list|()
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle a .stabn directive.  We need these in order to mark a label    as being a mips16 text label correctly.  Sometimes the compiler    will emit a label, followed by a .stabn, and then switch sections.    If the label and .stabn are in mips16 mode, then the label is    really a mips16 text label.  */
end_comment

begin_function
specifier|static
name|void
name|s_mips_stab
parameter_list|(
name|int
name|type
parameter_list|)
block|{
if|if
condition|(
name|type
operator|==
literal|'n'
condition|)
name|mips16_mark_labels
argument_list|()
expr_stmt|;
name|s_stab
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle the .weakext pseudo-op as defined in Kane and Heinrich.  */
end_comment

begin_function
specifier|static
name|void
name|s_mips_weakext
parameter_list|(
name|int
name|ignore
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|c
decl_stmt|;
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
name|expressionS
name|exp
decl_stmt|;
name|name
operator|=
name|input_line_pointer
expr_stmt|;
name|c
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
name|symbolP
operator|=
name|symbol_find_or_make
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|S_SET_WEAK
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|is_end_of_line
index|[
operator|(
name|unsigned
name|char
operator|)
operator|*
name|input_line_pointer
index|]
condition|)
block|{
if|if
condition|(
name|S_IS_DEFINED
argument_list|(
name|symbolP
argument_list|)
condition|)
block|{
name|as_bad
argument_list|(
literal|"ignoring attempt to redefine symbol %s"
argument_list|,
name|S_GET_NAME
argument_list|(
name|symbolP
argument_list|)
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|','
condition|)
block|{
operator|++
name|input_line_pointer
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
block|}
name|expression
argument_list|(
operator|&
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
name|exp
operator|.
name|X_op
operator|!=
name|O_symbol
condition|)
block|{
name|as_bad
argument_list|(
literal|"bad .weakext directive"
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
name|symbol_set_value_expression
argument_list|(
name|symbolP
argument_list|,
operator|&
name|exp
argument_list|)
expr_stmt|;
block|}
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Parse a register string into a number.  Called from the ECOFF code    to parse .frame.  The argument is non-zero if this is the frame    register, so that we can record it in mips_frame_reg.  */
end_comment

begin_function
name|int
name|tc_get_register
parameter_list|(
name|int
name|frame
parameter_list|)
block|{
name|unsigned
name|int
name|reg
decl_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|reg_lookup
argument_list|(
operator|&
name|input_line_pointer
argument_list|,
name|RWARN
operator||
name|RTYPE_NUM
operator||
name|RTYPE_GP
argument_list|,
operator|&
name|reg
argument_list|)
condition|)
name|reg
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|frame
condition|)
block|{
name|mips_frame_reg
operator|=
name|reg
operator|!=
literal|0
condition|?
name|reg
else|:
name|SP
expr_stmt|;
name|mips_frame_reg_valid
operator|=
literal|1
expr_stmt|;
name|mips_cprestore_valid
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|reg
return|;
block|}
end_function

begin_function
name|valueT
name|md_section_align
parameter_list|(
name|asection
modifier|*
name|seg
parameter_list|,
name|valueT
name|addr
parameter_list|)
block|{
name|int
name|align
init|=
name|bfd_get_section_alignment
argument_list|(
name|stdoutput
argument_list|,
name|seg
argument_list|)
decl_stmt|;
if|if
condition|(
name|IS_ELF
condition|)
block|{
comment|/* We don't need to align ELF sections to the full alignment. 	 However, Irix 5 may prefer that we align them at least to a 16 	 byte boundary.  We don't bother to align the sections if we 	 are targeted for an embedded system.  */
if|if
condition|(
name|strcmp
argument_list|(
name|TARGET_OS
argument_list|,
literal|"elf"
argument_list|)
operator|==
literal|0
condition|)
return|return
name|addr
return|;
if|if
condition|(
name|align
operator|>
literal|4
condition|)
name|align
operator|=
literal|4
expr_stmt|;
block|}
return|return
operator|(
operator|(
name|addr
operator|+
operator|(
literal|1
operator|<<
name|align
operator|)
operator|-
literal|1
operator|)
operator|&
operator|(
operator|-
literal|1
operator|<<
name|align
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Utility routine, called from above as well.  If called while the    input file is still being read, it's only an approximation.  (For    example, a symbol may later become defined which appeared to be    undefined earlier.)  */
end_comment

begin_function
specifier|static
name|int
name|nopic_need_relax
parameter_list|(
name|symbolS
modifier|*
name|sym
parameter_list|,
name|int
name|before_relaxing
parameter_list|)
block|{
if|if
condition|(
name|sym
operator|==
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|g_switch_value
operator|>
literal|0
condition|)
block|{
specifier|const
name|char
modifier|*
name|symname
decl_stmt|;
name|int
name|change
decl_stmt|;
comment|/* Find out whether this symbol can be referenced off the $gp 	 register.  It can be if it is smaller than the -G size or if 	 it is in the .sdata or .sbss section.  Certain symbols can 	 not be referenced off the $gp, although it appears as though 	 they can.  */
name|symname
operator|=
name|S_GET_NAME
argument_list|(
name|sym
argument_list|)
expr_stmt|;
if|if
condition|(
name|symname
operator|!=
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
operator|&&
operator|(
name|strcmp
argument_list|(
name|symname
argument_list|,
literal|"eprol"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|symname
argument_list|,
literal|"etext"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|symname
argument_list|,
literal|"_gp"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|symname
argument_list|,
literal|"edata"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|symname
argument_list|,
literal|"_fbss"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|symname
argument_list|,
literal|"_fdata"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|symname
argument_list|,
literal|"_ftext"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|symname
argument_list|,
literal|"end"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|symname
argument_list|,
literal|"_gp_disp"
argument_list|)
operator|==
literal|0
operator|)
condition|)
name|change
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
operator|!
name|S_IS_DEFINED
argument_list|(
name|sym
argument_list|)
operator|||
name|S_IS_COMMON
argument_list|(
name|sym
argument_list|)
operator|)
operator|&&
operator|(
literal|0
ifndef|#
directive|ifndef
name|NO_ECOFF_DEBUGGING
operator|||
operator|(
name|symbol_get_obj
argument_list|(
name|sym
argument_list|)
operator|->
name|ecoff_extern_size
operator|!=
literal|0
operator|&&
operator|(
name|symbol_get_obj
argument_list|(
name|sym
argument_list|)
operator|->
name|ecoff_extern_size
operator|<=
name|g_switch_value
operator|)
operator|)
endif|#
directive|endif
comment|/* We must defer this decision until after the whole 		      file has been read, since there might be a .extern 		      after the first use of this symbol.  */
operator|||
operator|(
name|before_relaxing
ifndef|#
directive|ifndef
name|NO_ECOFF_DEBUGGING
operator|&&
name|symbol_get_obj
argument_list|(
name|sym
argument_list|)
operator|->
name|ecoff_extern_size
operator|==
literal|0
endif|#
directive|endif
operator|&&
name|S_GET_VALUE
argument_list|(
name|sym
argument_list|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|S_GET_VALUE
argument_list|(
name|sym
argument_list|)
operator|!=
literal|0
operator|&&
name|S_GET_VALUE
argument_list|(
name|sym
argument_list|)
operator|<=
name|g_switch_value
operator|)
operator|)
condition|)
name|change
operator|=
literal|0
expr_stmt|;
else|else
block|{
specifier|const
name|char
modifier|*
name|segname
decl_stmt|;
name|segname
operator|=
name|segment_name
argument_list|(
name|S_GET_SEGMENT
argument_list|(
name|sym
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|strcmp
argument_list|(
name|segname
argument_list|,
literal|".lit8"
argument_list|)
operator|!=
literal|0
operator|&&
name|strcmp
argument_list|(
name|segname
argument_list|,
literal|".lit4"
argument_list|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|change
operator|=
operator|(
name|strcmp
argument_list|(
name|segname
argument_list|,
literal|".sdata"
argument_list|)
operator|!=
literal|0
operator|&&
name|strcmp
argument_list|(
name|segname
argument_list|,
literal|".sbss"
argument_list|)
operator|!=
literal|0
operator|&&
name|strncmp
argument_list|(
name|segname
argument_list|,
literal|".sdata."
argument_list|,
literal|7
argument_list|)
operator|!=
literal|0
operator|&&
name|strncmp
argument_list|(
name|segname
argument_list|,
literal|".sbss."
argument_list|,
literal|6
argument_list|)
operator|!=
literal|0
operator|&&
name|strncmp
argument_list|(
name|segname
argument_list|,
literal|".gnu.linkonce.sb."
argument_list|,
literal|17
argument_list|)
operator|!=
literal|0
operator|&&
name|strncmp
argument_list|(
name|segname
argument_list|,
literal|".gnu.linkonce.s."
argument_list|,
literal|16
argument_list|)
operator|!=
literal|0
operator|)
expr_stmt|;
block|}
return|return
name|change
return|;
block|}
else|else
comment|/* We are not optimizing for the $gp register.  */
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Return true if the given symbol should be considered local for SVR4 PIC.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|pic_need_relax
parameter_list|(
name|symbolS
modifier|*
name|sym
parameter_list|,
name|asection
modifier|*
name|segtype
parameter_list|)
block|{
name|asection
modifier|*
name|symsec
decl_stmt|;
comment|/* Handle the case of a symbol equated to another symbol.  */
while|while
condition|(
name|symbol_equated_reloc_p
argument_list|(
name|sym
argument_list|)
condition|)
block|{
name|symbolS
modifier|*
name|n
decl_stmt|;
comment|/* It's possible to get a loop here in a badly written program.  */
name|n
operator|=
name|symbol_get_value_expression
argument_list|(
name|sym
argument_list|)
operator|->
name|X_add_symbol
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|sym
condition|)
break|break;
name|sym
operator|=
name|n
expr_stmt|;
block|}
if|if
condition|(
name|symbol_section_p
argument_list|(
name|sym
argument_list|)
condition|)
return|return
name|TRUE
return|;
name|symsec
operator|=
name|S_GET_SEGMENT
argument_list|(
name|sym
argument_list|)
expr_stmt|;
comment|/* This must duplicate the test in adjust_reloc_syms.  */
return|return
operator|(
name|symsec
operator|!=
operator|&
name|bfd_und_section
operator|&&
name|symsec
operator|!=
operator|&
name|bfd_abs_section
operator|&&
operator|!
name|bfd_is_com_section
argument_list|(
name|symsec
argument_list|)
operator|&&
operator|!
name|s_is_linkonce
argument_list|(
name|sym
argument_list|,
name|segtype
argument_list|)
ifdef|#
directive|ifdef
name|OBJ_ELF
comment|/* A global or weak symbol is treated as external.  */
operator|&&
operator|(
operator|!
name|IS_ELF
operator|||
operator|(
operator|!
name|S_IS_WEAK
argument_list|(
name|sym
argument_list|)
operator|&&
operator|!
name|S_IS_EXTERNAL
argument_list|(
name|sym
argument_list|)
operator|)
operator|)
endif|#
directive|endif
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Given a mips16 variant frag FRAGP, return non-zero if it needs an    extended opcode.  SEC is the section the frag is in.  */
end_comment

begin_function
specifier|static
name|int
name|mips16_extended_frag
parameter_list|(
name|fragS
modifier|*
name|fragp
parameter_list|,
name|asection
modifier|*
name|sec
parameter_list|,
name|long
name|stretch
parameter_list|)
block|{
name|int
name|type
decl_stmt|;
specifier|const
name|struct
name|mips16_immed_operand
modifier|*
name|op
decl_stmt|;
name|offsetT
name|val
decl_stmt|;
name|int
name|mintiny
decl_stmt|,
name|maxtiny
decl_stmt|;
name|segT
name|symsec
decl_stmt|;
name|fragS
modifier|*
name|sym_frag
decl_stmt|;
if|if
condition|(
name|RELAX_MIPS16_USER_SMALL
argument_list|(
name|fragp
operator|->
name|fr_subtype
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|RELAX_MIPS16_USER_EXT
argument_list|(
name|fragp
operator|->
name|fr_subtype
argument_list|)
condition|)
return|return
literal|1
return|;
name|type
operator|=
name|RELAX_MIPS16_TYPE
argument_list|(
name|fragp
operator|->
name|fr_subtype
argument_list|)
expr_stmt|;
name|op
operator|=
name|mips16_immed_operands
expr_stmt|;
while|while
condition|(
name|op
operator|->
name|type
operator|!=
name|type
condition|)
block|{
operator|++
name|op
expr_stmt|;
name|assert
argument_list|(
name|op
operator|<
name|mips16_immed_operands
operator|+
name|MIPS16_NUM_IMMED
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|op
operator|->
name|unsp
condition|)
block|{
if|if
condition|(
name|type
operator|==
literal|'<'
operator|||
name|type
operator|==
literal|'>'
operator|||
name|type
operator|==
literal|'['
operator|||
name|type
operator|==
literal|']'
condition|)
block|{
name|mintiny
operator|=
literal|1
expr_stmt|;
name|maxtiny
operator|=
literal|1
operator|<<
name|op
operator|->
name|nbits
expr_stmt|;
block|}
else|else
block|{
name|mintiny
operator|=
literal|0
expr_stmt|;
name|maxtiny
operator|=
operator|(
literal|1
operator|<<
name|op
operator|->
name|nbits
operator|)
operator|-
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
name|mintiny
operator|=
operator|-
operator|(
literal|1
operator|<<
operator|(
name|op
operator|->
name|nbits
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
name|maxtiny
operator|=
operator|(
literal|1
operator|<<
operator|(
name|op
operator|->
name|nbits
operator|-
literal|1
operator|)
operator|)
operator|-
literal|1
expr_stmt|;
block|}
name|sym_frag
operator|=
name|symbol_get_frag
argument_list|(
name|fragp
operator|->
name|fr_symbol
argument_list|)
expr_stmt|;
name|val
operator|=
name|S_GET_VALUE
argument_list|(
name|fragp
operator|->
name|fr_symbol
argument_list|)
expr_stmt|;
name|symsec
operator|=
name|S_GET_SEGMENT
argument_list|(
name|fragp
operator|->
name|fr_symbol
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|->
name|pcrel
condition|)
block|{
name|addressT
name|addr
decl_stmt|;
comment|/* We won't have the section when we are called from          mips_relax_frag.  However, we will always have been called          from md_estimate_size_before_relax first.  If this is a          branch to a different section, we mark it as such.  If SEC is          NULL, and the frag is not marked, then it must be a branch to          the same section.  */
if|if
condition|(
name|sec
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|RELAX_MIPS16_LONG_BRANCH
argument_list|(
name|fragp
operator|->
name|fr_subtype
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
else|else
block|{
comment|/* Must have been called from md_estimate_size_before_relax.  */
if|if
condition|(
name|symsec
operator|!=
name|sec
condition|)
block|{
name|fragp
operator|->
name|fr_subtype
operator|=
name|RELAX_MIPS16_MARK_LONG_BRANCH
argument_list|(
name|fragp
operator|->
name|fr_subtype
argument_list|)
expr_stmt|;
comment|/* FIXME: We should support this, and let the linker                  catch branches and loads that are out of range.  */
name|as_bad_where
argument_list|(
name|fragp
operator|->
name|fr_file
argument_list|,
name|fragp
operator|->
name|fr_line
argument_list|,
name|_
argument_list|(
literal|"unsupported PC relative reference to different section"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|fragp
operator|!=
name|sym_frag
operator|&&
name|sym_frag
operator|->
name|fr_address
operator|==
literal|0
condition|)
comment|/* Assume non-extended on the first relaxation pass. 	       The address we have calculated will be bogus if this is 	       a forward branch to another frag, as the forward frag 	       will have fr_address == 0.  */
return|return
literal|0
return|;
block|}
comment|/* In this case, we know for sure that the symbol fragment is in 	 the same section.  If the relax_marker of the symbol fragment 	 differs from the relax_marker of this fragment, we have not 	 yet adjusted the symbol fragment fr_address.  We want to add 	 in STRETCH in order to get a better estimate of the address. 	 This particularly matters because of the shift bits.  */
if|if
condition|(
name|stretch
operator|!=
literal|0
operator|&&
name|sym_frag
operator|->
name|relax_marker
operator|!=
name|fragp
operator|->
name|relax_marker
condition|)
block|{
name|fragS
modifier|*
name|f
decl_stmt|;
comment|/* Adjust stretch for any alignment frag.  Note that if have              been expanding the earlier code, the symbol may be              defined in what appears to be an earlier frag.  FIXME:              This doesn't handle the fr_subtype field, which specifies              a maximum number of bytes to skip when doing an              alignment.  */
for|for
control|(
name|f
operator|=
name|fragp
init|;
name|f
operator|!=
name|NULL
operator|&&
name|f
operator|!=
name|sym_frag
condition|;
name|f
operator|=
name|f
operator|->
name|fr_next
control|)
block|{
if|if
condition|(
name|f
operator|->
name|fr_type
operator|==
name|rs_align
operator|||
name|f
operator|->
name|fr_type
operator|==
name|rs_align_code
condition|)
block|{
if|if
condition|(
name|stretch
operator|<
literal|0
condition|)
name|stretch
operator|=
operator|-
operator|(
operator|(
operator|-
name|stretch
operator|)
operator|&
operator|~
operator|(
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|f
operator|->
name|fr_offset
operator|)
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
else|else
name|stretch
operator|&=
operator|~
operator|(
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|f
operator|->
name|fr_offset
operator|)
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|stretch
operator|==
literal|0
condition|)
break|break;
block|}
block|}
if|if
condition|(
name|f
operator|!=
name|NULL
condition|)
name|val
operator|+=
name|stretch
expr_stmt|;
block|}
name|addr
operator|=
name|fragp
operator|->
name|fr_address
operator|+
name|fragp
operator|->
name|fr_fix
expr_stmt|;
comment|/* The base address rules are complicated.  The base address of          a branch is the following instruction.  The base address of a          PC relative load or add is the instruction itself, but if it          is in a delay slot (in which case it can not be extended) use          the address of the instruction whose delay slot it is in.  */
if|if
condition|(
name|type
operator|==
literal|'p'
operator|||
name|type
operator|==
literal|'q'
condition|)
block|{
name|addr
operator|+=
literal|2
expr_stmt|;
comment|/* If we are currently assuming that this frag should be 	     extended, then, the current address is two bytes 	     higher.  */
if|if
condition|(
name|RELAX_MIPS16_EXTENDED
argument_list|(
name|fragp
operator|->
name|fr_subtype
argument_list|)
condition|)
name|addr
operator|+=
literal|2
expr_stmt|;
comment|/* Ignore the low bit in the target, since it will be set              for a text label.  */
if|if
condition|(
operator|(
name|val
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
operator|--
name|val
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|RELAX_MIPS16_JAL_DSLOT
argument_list|(
name|fragp
operator|->
name|fr_subtype
argument_list|)
condition|)
name|addr
operator|-=
literal|4
expr_stmt|;
elseif|else
if|if
condition|(
name|RELAX_MIPS16_DSLOT
argument_list|(
name|fragp
operator|->
name|fr_subtype
argument_list|)
condition|)
name|addr
operator|-=
literal|2
expr_stmt|;
name|val
operator|-=
name|addr
operator|&
operator|~
operator|(
operator|(
literal|1
operator|<<
name|op
operator|->
name|shift
operator|)
operator|-
literal|1
operator|)
expr_stmt|;
comment|/* Branch offsets have an implicit 0 in the lowest bit.  */
if|if
condition|(
name|type
operator|==
literal|'p'
operator|||
name|type
operator|==
literal|'q'
condition|)
name|val
operator|/=
literal|2
expr_stmt|;
comment|/* If any of the shifted bits are set, we must use an extended          opcode.  If the address depends on the size of this          instruction, this can lead to a loop, so we arrange to always          use an extended opcode.  We only check this when we are in          the main relaxation loop, when SEC is NULL.  */
if|if
condition|(
operator|(
name|val
operator|&
operator|(
operator|(
literal|1
operator|<<
name|op
operator|->
name|shift
operator|)
operator|-
literal|1
operator|)
operator|)
operator|!=
literal|0
operator|&&
name|sec
operator|==
name|NULL
condition|)
block|{
name|fragp
operator|->
name|fr_subtype
operator|=
name|RELAX_MIPS16_MARK_LONG_BRANCH
argument_list|(
name|fragp
operator|->
name|fr_subtype
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* If we are about to mark a frag as extended because the value          is precisely maxtiny + 1, then there is a chance of an          infinite loop as in the following code: 	     la	$4,foo 	     .skip	1020 	     .align	2 	   foo: 	 In this case when the la is extended, foo is 0x3fc bytes 	 away, so the la can be shrunk, but then foo is 0x400 away, so 	 the la must be extended.  To avoid this loop, we mark the 	 frag as extended if it was small, and is about to become 	 extended with a value of maxtiny + 1.  */
if|if
condition|(
name|val
operator|==
operator|(
operator|(
name|maxtiny
operator|+
literal|1
operator|)
operator|<<
name|op
operator|->
name|shift
operator|)
operator|&&
operator|!
name|RELAX_MIPS16_EXTENDED
argument_list|(
name|fragp
operator|->
name|fr_subtype
argument_list|)
operator|&&
name|sec
operator|==
name|NULL
condition|)
block|{
name|fragp
operator|->
name|fr_subtype
operator|=
name|RELAX_MIPS16_MARK_LONG_BRANCH
argument_list|(
name|fragp
operator|->
name|fr_subtype
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|symsec
operator|!=
name|absolute_section
operator|&&
name|sec
operator|!=
name|NULL
condition|)
name|as_bad_where
argument_list|(
name|fragp
operator|->
name|fr_file
argument_list|,
name|fragp
operator|->
name|fr_line
argument_list|,
name|_
argument_list|(
literal|"unsupported relocation"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|val
operator|&
operator|(
operator|(
literal|1
operator|<<
name|op
operator|->
name|shift
operator|)
operator|-
literal|1
operator|)
operator|)
operator|!=
literal|0
operator|||
name|val
operator|<
operator|(
name|mintiny
operator|<<
name|op
operator|->
name|shift
operator|)
operator|||
name|val
operator|>
operator|(
name|maxtiny
operator|<<
name|op
operator|->
name|shift
operator|)
condition|)
return|return
literal|1
return|;
else|else
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Compute the length of a branch sequence, and adjust the    RELAX_BRANCH_TOOFAR bit accordingly.  If FRAGP is NULL, the    worst-case length is computed, with UPDATE being used to indicate    whether an unconditional (-1), branch-likely (+1) or regular (0)    branch is to be computed.  */
end_comment

begin_function
specifier|static
name|int
name|relaxed_branch_length
parameter_list|(
name|fragS
modifier|*
name|fragp
parameter_list|,
name|asection
modifier|*
name|sec
parameter_list|,
name|int
name|update
parameter_list|)
block|{
name|bfd_boolean
name|toofar
decl_stmt|;
name|int
name|length
decl_stmt|;
if|if
condition|(
name|fragp
operator|&&
name|S_IS_DEFINED
argument_list|(
name|fragp
operator|->
name|fr_symbol
argument_list|)
operator|&&
name|sec
operator|==
name|S_GET_SEGMENT
argument_list|(
name|fragp
operator|->
name|fr_symbol
argument_list|)
condition|)
block|{
name|addressT
name|addr
decl_stmt|;
name|offsetT
name|val
decl_stmt|;
name|val
operator|=
name|S_GET_VALUE
argument_list|(
name|fragp
operator|->
name|fr_symbol
argument_list|)
operator|+
name|fragp
operator|->
name|fr_offset
expr_stmt|;
name|addr
operator|=
name|fragp
operator|->
name|fr_address
operator|+
name|fragp
operator|->
name|fr_fix
operator|+
literal|4
expr_stmt|;
name|val
operator|-=
name|addr
expr_stmt|;
name|toofar
operator|=
name|val
operator|<
operator|-
operator|(
literal|0x8000
operator|<<
literal|2
operator|)
operator|||
name|val
operator|>=
operator|(
literal|0x8000
operator|<<
literal|2
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fragp
condition|)
comment|/* If the symbol is not defined or it's in a different segment,        assume the user knows what's going on and emit a short        branch.  */
name|toofar
operator|=
name|FALSE
expr_stmt|;
else|else
name|toofar
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|fragp
operator|&&
name|update
operator|&&
name|toofar
operator|!=
name|RELAX_BRANCH_TOOFAR
argument_list|(
name|fragp
operator|->
name|fr_subtype
argument_list|)
condition|)
name|fragp
operator|->
name|fr_subtype
operator|=
name|RELAX_BRANCH_ENCODE
argument_list|(
name|RELAX_BRANCH_UNCOND
argument_list|(
name|fragp
operator|->
name|fr_subtype
argument_list|)
argument_list|,
name|RELAX_BRANCH_LIKELY
argument_list|(
name|fragp
operator|->
name|fr_subtype
argument_list|)
argument_list|,
name|RELAX_BRANCH_LINK
argument_list|(
name|fragp
operator|->
name|fr_subtype
argument_list|)
argument_list|,
name|toofar
argument_list|)
expr_stmt|;
name|length
operator|=
literal|4
expr_stmt|;
if|if
condition|(
name|toofar
condition|)
block|{
if|if
condition|(
name|fragp
condition|?
name|RELAX_BRANCH_LIKELY
argument_list|(
name|fragp
operator|->
name|fr_subtype
argument_list|)
else|:
operator|(
name|update
operator|>
literal|0
operator|)
condition|)
name|length
operator|+=
literal|8
expr_stmt|;
if|if
condition|(
name|mips_pic
operator|!=
name|NO_PIC
condition|)
block|{
comment|/* Additional space for PIC loading of target address.  */
name|length
operator|+=
literal|8
expr_stmt|;
if|if
condition|(
name|mips_opts
operator|.
name|isa
operator|==
name|ISA_MIPS1
condition|)
comment|/* Additional space for $at-stabilizing nop.  */
name|length
operator|+=
literal|4
expr_stmt|;
block|}
comment|/* If branch is conditional.  */
if|if
condition|(
name|fragp
condition|?
operator|!
name|RELAX_BRANCH_UNCOND
argument_list|(
name|fragp
operator|->
name|fr_subtype
argument_list|)
else|:
operator|(
name|update
operator|>=
literal|0
operator|)
condition|)
name|length
operator|+=
literal|8
expr_stmt|;
block|}
return|return
name|length
return|;
block|}
end_function

begin_comment
comment|/* Estimate the size of a frag before relaxing.  Unless this is the    mips16, we are not really relaxing here, and the final size is    encoded in the subtype information.  For the mips16, we have to    decide whether we are using an extended opcode or not.  */
end_comment

begin_function
name|int
name|md_estimate_size_before_relax
parameter_list|(
name|fragS
modifier|*
name|fragp
parameter_list|,
name|asection
modifier|*
name|segtype
parameter_list|)
block|{
name|int
name|change
decl_stmt|;
if|if
condition|(
name|RELAX_BRANCH_P
argument_list|(
name|fragp
operator|->
name|fr_subtype
argument_list|)
condition|)
block|{
name|fragp
operator|->
name|fr_var
operator|=
name|relaxed_branch_length
argument_list|(
name|fragp
argument_list|,
name|segtype
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
return|return
name|fragp
operator|->
name|fr_var
return|;
block|}
if|if
condition|(
name|RELAX_MIPS16_P
argument_list|(
name|fragp
operator|->
name|fr_subtype
argument_list|)
condition|)
comment|/* We don't want to modify the EXTENDED bit here; it might get us        into infinite loops.  We change it only in mips_relax_frag().  */
return|return
operator|(
name|RELAX_MIPS16_EXTENDED
argument_list|(
name|fragp
operator|->
name|fr_subtype
argument_list|)
condition|?
literal|4
else|:
literal|2
operator|)
return|;
if|if
condition|(
name|mips_pic
operator|==
name|NO_PIC
condition|)
name|change
operator|=
name|nopic_need_relax
argument_list|(
name|fragp
operator|->
name|fr_symbol
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|mips_pic
operator|==
name|SVR4_PIC
condition|)
name|change
operator|=
name|pic_need_relax
argument_list|(
name|fragp
operator|->
name|fr_symbol
argument_list|,
name|segtype
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|mips_pic
operator|==
name|VXWORKS_PIC
condition|)
comment|/* For vxworks, GOT16 relocations never have a corresponding LO16.  */
name|change
operator|=
literal|0
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|change
condition|)
block|{
name|fragp
operator|->
name|fr_subtype
operator||=
name|RELAX_USE_SECOND
expr_stmt|;
return|return
operator|-
name|RELAX_FIRST
argument_list|(
name|fragp
operator|->
name|fr_subtype
argument_list|)
return|;
block|}
else|else
return|return
operator|-
name|RELAX_SECOND
argument_list|(
name|fragp
operator|->
name|fr_subtype
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* This is called to see whether a reloc against a defined symbol    should be converted into a reloc against a section.  */
end_comment

begin_function
name|int
name|mips_fix_adjustable
parameter_list|(
name|fixS
modifier|*
name|fixp
parameter_list|)
block|{
if|if
condition|(
name|fixp
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_VTABLE_INHERIT
operator|||
name|fixp
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_VTABLE_ENTRY
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|fixp
operator|->
name|fx_addsy
operator|==
name|NULL
condition|)
return|return
literal|1
return|;
comment|/* If symbol SYM is in a mergeable section, relocations of the form      SYM + 0 can usually be made section-relative.  The mergeable data      is then identified by the section offset rather than by the symbol.       However, if we're generating REL LO16 relocations, the offset is split      between the LO16 and parterning high part relocation.  The linker will      need to recalculate the complete offset in order to correctly identify      the merge data.       The linker has traditionally not looked for the parterning high part      relocation, and has thus allowed orphaned R_MIPS_LO16 relocations to be      placed anywhere.  Rather than break backwards compatibility by changing      this, it seems better not to force the issue, and instead keep the      original symbol.  This will work with either linker behavior.  */
if|if
condition|(
operator|(
name|fixp
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_LO16
operator|||
name|fixp
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_MIPS16_LO16
operator|||
name|reloc_needs_lo_p
argument_list|(
name|fixp
operator|->
name|fx_r_type
argument_list|)
operator|)
operator|&&
name|HAVE_IN_PLACE_ADDENDS
operator|&&
operator|(
name|S_GET_SEGMENT
argument_list|(
name|fixp
operator|->
name|fx_addsy
argument_list|)
operator|->
name|flags
operator|&
name|SEC_MERGE
operator|)
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
ifdef|#
directive|ifdef
name|OBJ_ELF
comment|/* R_MIPS16_26 relocations against non-MIPS16 functions might resolve      to a floating-point stub.  The same is true for non-R_MIPS16_26      relocations against MIPS16 functions; in this case, the stub becomes      the function's canonical address.       Floating-point stubs are stored in unique .mips16.call.* or      .mips16.fn.* sections.  If a stub T for function F is in section S,      the first relocation in section S must be against F; this is how the      linker determines the target function.  All relocations that might      resolve to T must also be against F.  We therefore have the following      restrictions, which are given in an intentionally-redundant way:         1. We cannot reduce R_MIPS16_26 relocations against non-MIPS16 	  symbols.         2. We cannot reduce a stub's relocations against non-MIPS16 symbols 	  if that stub might be used.         3. We cannot reduce non-R_MIPS16_26 relocations against MIPS16 	  symbols.         4. We cannot reduce a stub's relocations against MIPS16 symbols if 	  that stub might be used.       There is a further restriction:         5. We cannot reduce R_MIPS16_26 relocations against MIPS16 symbols 	  on targets with in-place addends; the relocation field cannot 	  encode the low bit.       For simplicity, we deal with (3)-(5) by not reducing _any_ relocation      against a MIPS16 symbol.       We deal with (1)-(2) by saying that, if there's a R_MIPS16_26      relocation against some symbol R, no relocation against R may be      reduced.  (Note that this deals with (2) as well as (1) because      relocations against global symbols will never be reduced on ELF      targets.)  This approach is a little simpler than trying to detect      stub sections, and gives the "all or nothing" per-symbol consistency      that we have for MIPS16 symbols.  */
if|if
condition|(
name|IS_ELF
operator|&&
name|fixp
operator|->
name|fx_subsy
operator|==
name|NULL
operator|&&
operator|(
name|S_GET_OTHER
argument_list|(
name|fixp
operator|->
name|fx_addsy
argument_list|)
operator|==
name|STO_MIPS16
operator|||
operator|*
name|symbol_get_tc
argument_list|(
name|fixp
operator|->
name|fx_addsy
argument_list|)
operator|)
condition|)
return|return
literal|0
return|;
endif|#
directive|endif
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Translate internal representation of relocation info to BFD target    format.  */
end_comment

begin_function
name|arelent
modifier|*
modifier|*
name|tc_gen_reloc
parameter_list|(
name|asection
modifier|*
name|section
name|ATTRIBUTE_UNUSED
parameter_list|,
name|fixS
modifier|*
name|fixp
parameter_list|)
block|{
specifier|static
name|arelent
modifier|*
name|retval
index|[
literal|4
index|]
decl_stmt|;
name|arelent
modifier|*
name|reloc
decl_stmt|;
name|bfd_reloc_code_real_type
name|code
decl_stmt|;
name|memset
argument_list|(
name|retval
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|retval
argument_list|)
argument_list|)
expr_stmt|;
name|reloc
operator|=
name|retval
index|[
literal|0
index|]
operator|=
operator|(
name|arelent
operator|*
operator|)
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|arelent
argument_list|)
argument_list|)
expr_stmt|;
name|reloc
operator|->
name|sym_ptr_ptr
operator|=
operator|(
name|asymbol
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|asymbol
operator|*
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|reloc
operator|->
name|sym_ptr_ptr
operator|=
name|symbol_get_bfdsym
argument_list|(
name|fixp
operator|->
name|fx_addsy
argument_list|)
expr_stmt|;
name|reloc
operator|->
name|address
operator|=
name|fixp
operator|->
name|fx_frag
operator|->
name|fr_address
operator|+
name|fixp
operator|->
name|fx_where
expr_stmt|;
if|if
condition|(
name|fixp
operator|->
name|fx_pcrel
condition|)
block|{
name|assert
argument_list|(
name|fixp
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_16_PCREL_S2
argument_list|)
expr_stmt|;
comment|/* At this point, fx_addnumber is "symbol offset - pcrel address". 	 Relocations want only the symbol offset.  */
name|reloc
operator|->
name|addend
operator|=
name|fixp
operator|->
name|fx_addnumber
operator|+
name|reloc
operator|->
name|address
expr_stmt|;
if|if
condition|(
operator|!
name|IS_ELF
condition|)
block|{
comment|/* A gruesome hack which is a result of the gruesome gas 	     reloc handling.  What's worse, for COFF (as opposed to 	     ECOFF), we might need yet another copy of reloc->address. 	     See bfd_install_relocation.  */
name|reloc
operator|->
name|addend
operator|+=
name|reloc
operator|->
name|address
expr_stmt|;
block|}
block|}
else|else
name|reloc
operator|->
name|addend
operator|=
name|fixp
operator|->
name|fx_addnumber
expr_stmt|;
comment|/* Since the old MIPS ELF ABI uses Rel instead of Rela, encode the vtable      entry to be used in the relocation's section offset.  */
if|if
condition|(
operator|!
name|HAVE_NEWABI
operator|&&
name|fixp
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_VTABLE_ENTRY
condition|)
block|{
name|reloc
operator|->
name|address
operator|=
name|reloc
operator|->
name|addend
expr_stmt|;
name|reloc
operator|->
name|addend
operator|=
literal|0
expr_stmt|;
block|}
name|code
operator|=
name|fixp
operator|->
name|fx_r_type
expr_stmt|;
name|reloc
operator|->
name|howto
operator|=
name|bfd_reloc_type_lookup
argument_list|(
name|stdoutput
argument_list|,
name|code
argument_list|)
expr_stmt|;
if|if
condition|(
name|reloc
operator|->
name|howto
operator|==
name|NULL
condition|)
block|{
name|as_bad_where
argument_list|(
name|fixp
operator|->
name|fx_file
argument_list|,
name|fixp
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"Can not represent %s relocation in this object file format"
argument_list|)
argument_list|,
name|bfd_get_reloc_code_name
argument_list|(
name|code
argument_list|)
argument_list|)
expr_stmt|;
name|retval
index|[
literal|0
index|]
operator|=
name|NULL
expr_stmt|;
block|}
return|return
name|retval
return|;
block|}
end_function

begin_comment
comment|/* Relax a machine dependent frag.  This returns the amount by which    the current size of the frag should change.  */
end_comment

begin_function
name|int
name|mips_relax_frag
parameter_list|(
name|asection
modifier|*
name|sec
parameter_list|,
name|fragS
modifier|*
name|fragp
parameter_list|,
name|long
name|stretch
parameter_list|)
block|{
if|if
condition|(
name|RELAX_BRANCH_P
argument_list|(
name|fragp
operator|->
name|fr_subtype
argument_list|)
condition|)
block|{
name|offsetT
name|old_var
init|=
name|fragp
operator|->
name|fr_var
decl_stmt|;
name|fragp
operator|->
name|fr_var
operator|=
name|relaxed_branch_length
argument_list|(
name|fragp
argument_list|,
name|sec
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
return|return
name|fragp
operator|->
name|fr_var
operator|-
name|old_var
return|;
block|}
if|if
condition|(
operator|!
name|RELAX_MIPS16_P
argument_list|(
name|fragp
operator|->
name|fr_subtype
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|mips16_extended_frag
argument_list|(
name|fragp
argument_list|,
name|NULL
argument_list|,
name|stretch
argument_list|)
condition|)
block|{
if|if
condition|(
name|RELAX_MIPS16_EXTENDED
argument_list|(
name|fragp
operator|->
name|fr_subtype
argument_list|)
condition|)
return|return
literal|0
return|;
name|fragp
operator|->
name|fr_subtype
operator|=
name|RELAX_MIPS16_MARK_EXTENDED
argument_list|(
name|fragp
operator|->
name|fr_subtype
argument_list|)
expr_stmt|;
return|return
literal|2
return|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|RELAX_MIPS16_EXTENDED
argument_list|(
name|fragp
operator|->
name|fr_subtype
argument_list|)
condition|)
return|return
literal|0
return|;
name|fragp
operator|->
name|fr_subtype
operator|=
name|RELAX_MIPS16_CLEAR_EXTENDED
argument_list|(
name|fragp
operator|->
name|fr_subtype
argument_list|)
expr_stmt|;
return|return
operator|-
literal|2
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Convert a machine dependent frag.  */
end_comment

begin_function
name|void
name|md_convert_frag
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|segT
name|asec
parameter_list|,
name|fragS
modifier|*
name|fragp
parameter_list|)
block|{
if|if
condition|(
name|RELAX_BRANCH_P
argument_list|(
name|fragp
operator|->
name|fr_subtype
argument_list|)
condition|)
block|{
name|bfd_byte
modifier|*
name|buf
decl_stmt|;
name|unsigned
name|long
name|insn
decl_stmt|;
name|expressionS
name|exp
decl_stmt|;
name|fixS
modifier|*
name|fixp
decl_stmt|;
name|buf
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|fragp
operator|->
name|fr_literal
operator|+
name|fragp
operator|->
name|fr_fix
expr_stmt|;
if|if
condition|(
name|target_big_endian
condition|)
name|insn
operator|=
name|bfd_getb32
argument_list|(
name|buf
argument_list|)
expr_stmt|;
else|else
name|insn
operator|=
name|bfd_getl32
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|RELAX_BRANCH_TOOFAR
argument_list|(
name|fragp
operator|->
name|fr_subtype
argument_list|)
condition|)
block|{
comment|/* We generate a fixup instead of applying it right now 	     because, if there are linker relaxations, we're going to 	     need the relocations.  */
name|exp
operator|.
name|X_op
operator|=
name|O_symbol
expr_stmt|;
name|exp
operator|.
name|X_add_symbol
operator|=
name|fragp
operator|->
name|fr_symbol
expr_stmt|;
name|exp
operator|.
name|X_add_number
operator|=
name|fragp
operator|->
name|fr_offset
expr_stmt|;
name|fixp
operator|=
name|fix_new_exp
argument_list|(
name|fragp
argument_list|,
name|buf
operator|-
operator|(
name|bfd_byte
operator|*
operator|)
name|fragp
operator|->
name|fr_literal
argument_list|,
literal|4
argument_list|,
operator|&
name|exp
argument_list|,
name|TRUE
argument_list|,
name|BFD_RELOC_16_PCREL_S2
argument_list|)
expr_stmt|;
name|fixp
operator|->
name|fx_file
operator|=
name|fragp
operator|->
name|fr_file
expr_stmt|;
name|fixp
operator|->
name|fx_line
operator|=
name|fragp
operator|->
name|fr_line
expr_stmt|;
name|md_number_to_chars
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|,
name|insn
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|buf
operator|+=
literal|4
expr_stmt|;
block|}
else|else
block|{
name|int
name|i
decl_stmt|;
name|as_warn_where
argument_list|(
name|fragp
operator|->
name|fr_file
argument_list|,
name|fragp
operator|->
name|fr_line
argument_list|,
name|_
argument_list|(
literal|"relaxed out-of-range branch into a jump"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|RELAX_BRANCH_UNCOND
argument_list|(
name|fragp
operator|->
name|fr_subtype
argument_list|)
condition|)
goto|goto
name|uncond
goto|;
if|if
condition|(
operator|!
name|RELAX_BRANCH_LIKELY
argument_list|(
name|fragp
operator|->
name|fr_subtype
argument_list|)
condition|)
block|{
comment|/* Reverse the branch.  */
switch|switch
condition|(
operator|(
name|insn
operator|>>
literal|28
operator|)
operator|&
literal|0xf
condition|)
block|{
case|case
literal|4
case|:
comment|/* bc[0-3][tf]l? and bc1any[24][ft] instructions can 		     have the condition reversed by tweaking a single 		     bit, and their opcodes all have 0x4???????.  */
name|assert
argument_list|(
operator|(
name|insn
operator|&
literal|0xf1000000
operator|)
operator|==
literal|0x41000000
argument_list|)
expr_stmt|;
name|insn
operator|^=
literal|0x00010000
expr_stmt|;
break|break;
case|case
literal|0
case|:
comment|/* bltz	0x04000000	bgez	0x04010000 		     bltzal	0x04100000	bgezal	0x04110000  */
name|assert
argument_list|(
operator|(
name|insn
operator|&
literal|0xfc0e0000
operator|)
operator|==
literal|0x04000000
argument_list|)
expr_stmt|;
name|insn
operator|^=
literal|0x00010000
expr_stmt|;
break|break;
case|case
literal|1
case|:
comment|/* beq	0x10000000	bne	0x14000000 		     blez	0x18000000	bgtz	0x1c000000  */
name|insn
operator|^=
literal|0x04000000
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|RELAX_BRANCH_LINK
argument_list|(
name|fragp
operator|->
name|fr_subtype
argument_list|)
condition|)
block|{
comment|/* Clear the and-link bit.  */
name|assert
argument_list|(
operator|(
name|insn
operator|&
literal|0xfc1c0000
operator|)
operator|==
literal|0x04100000
argument_list|)
expr_stmt|;
comment|/* bltzal		0x04100000	bgezal	0x04110000 		 bltzall	0x04120000	bgezall	0x04130000  */
name|insn
operator|&=
operator|~
literal|0x00100000
expr_stmt|;
block|}
comment|/* Branch over the branch (if the branch was likely) or the 	     full jump (not likely case).  Compute the offset from the 	     current instruction to branch to.  */
if|if
condition|(
name|RELAX_BRANCH_LIKELY
argument_list|(
name|fragp
operator|->
name|fr_subtype
argument_list|)
condition|)
name|i
operator|=
literal|16
expr_stmt|;
else|else
block|{
comment|/* How many bytes in instructions we've already emitted?  */
name|i
operator|=
name|buf
operator|-
operator|(
name|bfd_byte
operator|*
operator|)
name|fragp
operator|->
name|fr_literal
operator|-
name|fragp
operator|->
name|fr_fix
expr_stmt|;
comment|/* How many bytes in instructions from here to the end?  */
name|i
operator|=
name|fragp
operator|->
name|fr_var
operator|-
name|i
expr_stmt|;
block|}
comment|/* Convert to instruction count.  */
name|i
operator|>>=
literal|2
expr_stmt|;
comment|/* Branch counts from the next instruction.  */
name|i
operator|--
expr_stmt|;
name|insn
operator||=
name|i
expr_stmt|;
comment|/* Branch over the jump.  */
name|md_number_to_chars
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|,
name|insn
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|buf
operator|+=
literal|4
expr_stmt|;
comment|/* nop */
name|md_number_to_chars
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|,
literal|0
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|buf
operator|+=
literal|4
expr_stmt|;
if|if
condition|(
name|RELAX_BRANCH_LIKELY
argument_list|(
name|fragp
operator|->
name|fr_subtype
argument_list|)
condition|)
block|{
comment|/* beql $0, $0, 2f */
name|insn
operator|=
literal|0x50000000
expr_stmt|;
comment|/* Compute the PC offset from the current instruction to 		 the end of the variable frag.  */
comment|/* How many bytes in instructions we've already emitted?  */
name|i
operator|=
name|buf
operator|-
operator|(
name|bfd_byte
operator|*
operator|)
name|fragp
operator|->
name|fr_literal
operator|-
name|fragp
operator|->
name|fr_fix
expr_stmt|;
comment|/* How many bytes in instructions from here to the end?  */
name|i
operator|=
name|fragp
operator|->
name|fr_var
operator|-
name|i
expr_stmt|;
comment|/* Convert to instruction count.  */
name|i
operator|>>=
literal|2
expr_stmt|;
comment|/* Don't decrement i, because we want to branch over the 		 delay slot.  */
name|insn
operator||=
name|i
expr_stmt|;
name|md_number_to_chars
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|,
name|insn
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|buf
operator|+=
literal|4
expr_stmt|;
name|md_number_to_chars
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|,
literal|0
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|buf
operator|+=
literal|4
expr_stmt|;
block|}
name|uncond
label|:
if|if
condition|(
name|mips_pic
operator|==
name|NO_PIC
condition|)
block|{
comment|/* j or jal.  */
name|insn
operator|=
operator|(
name|RELAX_BRANCH_LINK
argument_list|(
name|fragp
operator|->
name|fr_subtype
argument_list|)
condition|?
literal|0x0c000000
else|:
literal|0x08000000
operator|)
expr_stmt|;
name|exp
operator|.
name|X_op
operator|=
name|O_symbol
expr_stmt|;
name|exp
operator|.
name|X_add_symbol
operator|=
name|fragp
operator|->
name|fr_symbol
expr_stmt|;
name|exp
operator|.
name|X_add_number
operator|=
name|fragp
operator|->
name|fr_offset
expr_stmt|;
name|fixp
operator|=
name|fix_new_exp
argument_list|(
name|fragp
argument_list|,
name|buf
operator|-
operator|(
name|bfd_byte
operator|*
operator|)
name|fragp
operator|->
name|fr_literal
argument_list|,
literal|4
argument_list|,
operator|&
name|exp
argument_list|,
name|FALSE
argument_list|,
name|BFD_RELOC_MIPS_JMP
argument_list|)
expr_stmt|;
name|fixp
operator|->
name|fx_file
operator|=
name|fragp
operator|->
name|fr_file
expr_stmt|;
name|fixp
operator|->
name|fx_line
operator|=
name|fragp
operator|->
name|fr_line
expr_stmt|;
name|md_number_to_chars
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|,
name|insn
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|buf
operator|+=
literal|4
expr_stmt|;
block|}
else|else
block|{
comment|/* lw/ld $at,<sym>($gp)  R_MIPS_GOT16 */
name|insn
operator|=
name|HAVE_64BIT_ADDRESSES
condition|?
literal|0xdf810000
else|:
literal|0x8f810000
expr_stmt|;
name|exp
operator|.
name|X_op
operator|=
name|O_symbol
expr_stmt|;
name|exp
operator|.
name|X_add_symbol
operator|=
name|fragp
operator|->
name|fr_symbol
expr_stmt|;
name|exp
operator|.
name|X_add_number
operator|=
name|fragp
operator|->
name|fr_offset
expr_stmt|;
if|if
condition|(
name|fragp
operator|->
name|fr_offset
condition|)
block|{
name|exp
operator|.
name|X_add_symbol
operator|=
name|make_expr_symbol
argument_list|(
operator|&
name|exp
argument_list|)
expr_stmt|;
name|exp
operator|.
name|X_add_number
operator|=
literal|0
expr_stmt|;
block|}
name|fixp
operator|=
name|fix_new_exp
argument_list|(
name|fragp
argument_list|,
name|buf
operator|-
operator|(
name|bfd_byte
operator|*
operator|)
name|fragp
operator|->
name|fr_literal
argument_list|,
literal|4
argument_list|,
operator|&
name|exp
argument_list|,
name|FALSE
argument_list|,
name|BFD_RELOC_MIPS_GOT16
argument_list|)
expr_stmt|;
name|fixp
operator|->
name|fx_file
operator|=
name|fragp
operator|->
name|fr_file
expr_stmt|;
name|fixp
operator|->
name|fx_line
operator|=
name|fragp
operator|->
name|fr_line
expr_stmt|;
name|md_number_to_chars
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|,
name|insn
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|buf
operator|+=
literal|4
expr_stmt|;
if|if
condition|(
name|mips_opts
operator|.
name|isa
operator|==
name|ISA_MIPS1
condition|)
block|{
comment|/* nop */
name|md_number_to_chars
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|,
literal|0
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|buf
operator|+=
literal|4
expr_stmt|;
block|}
comment|/* d/addiu $at, $at,<sym>  R_MIPS_LO16 */
name|insn
operator|=
name|HAVE_64BIT_ADDRESSES
condition|?
literal|0x64210000
else|:
literal|0x24210000
expr_stmt|;
name|fixp
operator|=
name|fix_new_exp
argument_list|(
name|fragp
argument_list|,
name|buf
operator|-
operator|(
name|bfd_byte
operator|*
operator|)
name|fragp
operator|->
name|fr_literal
argument_list|,
literal|4
argument_list|,
operator|&
name|exp
argument_list|,
name|FALSE
argument_list|,
name|BFD_RELOC_LO16
argument_list|)
expr_stmt|;
name|fixp
operator|->
name|fx_file
operator|=
name|fragp
operator|->
name|fr_file
expr_stmt|;
name|fixp
operator|->
name|fx_line
operator|=
name|fragp
operator|->
name|fr_line
expr_stmt|;
name|md_number_to_chars
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|,
name|insn
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|buf
operator|+=
literal|4
expr_stmt|;
comment|/* j(al)r $at.  */
if|if
condition|(
name|RELAX_BRANCH_LINK
argument_list|(
name|fragp
operator|->
name|fr_subtype
argument_list|)
condition|)
name|insn
operator|=
literal|0x0020f809
expr_stmt|;
else|else
name|insn
operator|=
literal|0x00200008
expr_stmt|;
name|md_number_to_chars
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|,
name|insn
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|buf
operator|+=
literal|4
expr_stmt|;
block|}
block|}
name|assert
argument_list|(
name|buf
operator|==
operator|(
name|bfd_byte
operator|*
operator|)
name|fragp
operator|->
name|fr_literal
operator|+
name|fragp
operator|->
name|fr_fix
operator|+
name|fragp
operator|->
name|fr_var
argument_list|)
expr_stmt|;
name|fragp
operator|->
name|fr_fix
operator|+=
name|fragp
operator|->
name|fr_var
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|RELAX_MIPS16_P
argument_list|(
name|fragp
operator|->
name|fr_subtype
argument_list|)
condition|)
block|{
name|int
name|type
decl_stmt|;
specifier|const
name|struct
name|mips16_immed_operand
modifier|*
name|op
decl_stmt|;
name|bfd_boolean
name|small
decl_stmt|,
name|ext
decl_stmt|;
name|offsetT
name|val
decl_stmt|;
name|bfd_byte
modifier|*
name|buf
decl_stmt|;
name|unsigned
name|long
name|insn
decl_stmt|;
name|bfd_boolean
name|use_extend
decl_stmt|;
name|unsigned
name|short
name|extend
decl_stmt|;
name|type
operator|=
name|RELAX_MIPS16_TYPE
argument_list|(
name|fragp
operator|->
name|fr_subtype
argument_list|)
expr_stmt|;
name|op
operator|=
name|mips16_immed_operands
expr_stmt|;
while|while
condition|(
name|op
operator|->
name|type
operator|!=
name|type
condition|)
operator|++
name|op
expr_stmt|;
if|if
condition|(
name|RELAX_MIPS16_EXTENDED
argument_list|(
name|fragp
operator|->
name|fr_subtype
argument_list|)
condition|)
block|{
name|small
operator|=
name|FALSE
expr_stmt|;
name|ext
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
name|small
operator|=
name|TRUE
expr_stmt|;
name|ext
operator|=
name|FALSE
expr_stmt|;
block|}
name|resolve_symbol_value
argument_list|(
name|fragp
operator|->
name|fr_symbol
argument_list|)
expr_stmt|;
name|val
operator|=
name|S_GET_VALUE
argument_list|(
name|fragp
operator|->
name|fr_symbol
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|->
name|pcrel
condition|)
block|{
name|addressT
name|addr
decl_stmt|;
name|addr
operator|=
name|fragp
operator|->
name|fr_address
operator|+
name|fragp
operator|->
name|fr_fix
expr_stmt|;
comment|/* The rules for the base address of a PC relative reloc are              complicated; see mips16_extended_frag.  */
if|if
condition|(
name|type
operator|==
literal|'p'
operator|||
name|type
operator|==
literal|'q'
condition|)
block|{
name|addr
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|ext
condition|)
name|addr
operator|+=
literal|2
expr_stmt|;
comment|/* Ignore the low bit in the target, since it will be                  set for a text label.  */
if|if
condition|(
operator|(
name|val
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
operator|--
name|val
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|RELAX_MIPS16_JAL_DSLOT
argument_list|(
name|fragp
operator|->
name|fr_subtype
argument_list|)
condition|)
name|addr
operator|-=
literal|4
expr_stmt|;
elseif|else
if|if
condition|(
name|RELAX_MIPS16_DSLOT
argument_list|(
name|fragp
operator|->
name|fr_subtype
argument_list|)
condition|)
name|addr
operator|-=
literal|2
expr_stmt|;
name|addr
operator|&=
operator|~
call|(
name|addressT
call|)
argument_list|(
operator|(
literal|1
operator|<<
name|op
operator|->
name|shift
operator|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|val
operator|-=
name|addr
expr_stmt|;
comment|/* Make sure the section winds up with the alignment we have              assumed.  */
if|if
condition|(
name|op
operator|->
name|shift
operator|>
literal|0
condition|)
name|record_alignment
argument_list|(
name|asec
argument_list|,
name|op
operator|->
name|shift
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ext
operator|&&
operator|(
name|RELAX_MIPS16_JAL_DSLOT
argument_list|(
name|fragp
operator|->
name|fr_subtype
argument_list|)
operator|||
name|RELAX_MIPS16_DSLOT
argument_list|(
name|fragp
operator|->
name|fr_subtype
argument_list|)
operator|)
condition|)
name|as_warn_where
argument_list|(
name|fragp
operator|->
name|fr_file
argument_list|,
name|fragp
operator|->
name|fr_line
argument_list|,
name|_
argument_list|(
literal|"extended instruction in delay slot"
argument_list|)
argument_list|)
expr_stmt|;
name|buf
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
operator|(
name|fragp
operator|->
name|fr_literal
operator|+
name|fragp
operator|->
name|fr_fix
operator|)
expr_stmt|;
if|if
condition|(
name|target_big_endian
condition|)
name|insn
operator|=
name|bfd_getb16
argument_list|(
name|buf
argument_list|)
expr_stmt|;
else|else
name|insn
operator|=
name|bfd_getl16
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|mips16_immed
argument_list|(
name|fragp
operator|->
name|fr_file
argument_list|,
name|fragp
operator|->
name|fr_line
argument_list|,
name|type
argument_list|,
name|val
argument_list|,
name|RELAX_MIPS16_USER_EXT
argument_list|(
name|fragp
operator|->
name|fr_subtype
argument_list|)
argument_list|,
name|small
argument_list|,
name|ext
argument_list|,
operator|&
name|insn
argument_list|,
operator|&
name|use_extend
argument_list|,
operator|&
name|extend
argument_list|)
expr_stmt|;
if|if
condition|(
name|use_extend
condition|)
block|{
name|md_number_to_chars
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|,
literal|0xf000
operator||
name|extend
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|fragp
operator|->
name|fr_fix
operator|+=
literal|2
expr_stmt|;
name|buf
operator|+=
literal|2
expr_stmt|;
block|}
name|md_number_to_chars
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|,
name|insn
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|fragp
operator|->
name|fr_fix
operator|+=
literal|2
expr_stmt|;
name|buf
operator|+=
literal|2
expr_stmt|;
block|}
else|else
block|{
name|int
name|first
decl_stmt|,
name|second
decl_stmt|;
name|fixS
modifier|*
name|fixp
decl_stmt|;
name|first
operator|=
name|RELAX_FIRST
argument_list|(
name|fragp
operator|->
name|fr_subtype
argument_list|)
expr_stmt|;
name|second
operator|=
name|RELAX_SECOND
argument_list|(
name|fragp
operator|->
name|fr_subtype
argument_list|)
expr_stmt|;
name|fixp
operator|=
operator|(
name|fixS
operator|*
operator|)
name|fragp
operator|->
name|fr_opcode
expr_stmt|;
comment|/* Possibly emit a warning if we've chosen the longer option.  */
if|if
condition|(
operator|(
operator|(
name|fragp
operator|->
name|fr_subtype
operator|&
name|RELAX_USE_SECOND
operator|)
operator|!=
literal|0
operator|)
operator|==
operator|(
operator|(
name|fragp
operator|->
name|fr_subtype
operator|&
name|RELAX_SECOND_LONGER
operator|)
operator|!=
literal|0
operator|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|msg
init|=
name|macro_warning
argument_list|(
name|fragp
operator|->
name|fr_subtype
argument_list|)
decl_stmt|;
if|if
condition|(
name|msg
operator|!=
literal|0
condition|)
name|as_warn_where
argument_list|(
name|fragp
operator|->
name|fr_file
argument_list|,
name|fragp
operator|->
name|fr_line
argument_list|,
name|msg
argument_list|)
expr_stmt|;
block|}
comment|/* Go through all the fixups for the first sequence.  Disable them 	 (by marking them as done) if we're going to use the second 	 sequence instead.  */
while|while
condition|(
name|fixp
operator|&&
name|fixp
operator|->
name|fx_frag
operator|==
name|fragp
operator|&&
name|fixp
operator|->
name|fx_where
operator|<
name|fragp
operator|->
name|fr_fix
operator|-
name|second
condition|)
block|{
if|if
condition|(
name|fragp
operator|->
name|fr_subtype
operator|&
name|RELAX_USE_SECOND
condition|)
name|fixp
operator|->
name|fx_done
operator|=
literal|1
expr_stmt|;
name|fixp
operator|=
name|fixp
operator|->
name|fx_next
expr_stmt|;
block|}
comment|/* Go through the fixups for the second sequence.  Disable them if 	 we're going to use the first sequence, otherwise adjust their 	 addresses to account for the relaxation.  */
while|while
condition|(
name|fixp
operator|&&
name|fixp
operator|->
name|fx_frag
operator|==
name|fragp
condition|)
block|{
if|if
condition|(
name|fragp
operator|->
name|fr_subtype
operator|&
name|RELAX_USE_SECOND
condition|)
name|fixp
operator|->
name|fx_where
operator|-=
name|first
expr_stmt|;
else|else
name|fixp
operator|->
name|fx_done
operator|=
literal|1
expr_stmt|;
name|fixp
operator|=
name|fixp
operator|->
name|fx_next
expr_stmt|;
block|}
comment|/* Now modify the frag contents.  */
if|if
condition|(
name|fragp
operator|->
name|fr_subtype
operator|&
name|RELAX_USE_SECOND
condition|)
block|{
name|char
modifier|*
name|start
decl_stmt|;
name|start
operator|=
name|fragp
operator|->
name|fr_literal
operator|+
name|fragp
operator|->
name|fr_fix
operator|-
name|first
operator|-
name|second
expr_stmt|;
name|memmove
argument_list|(
name|start
argument_list|,
name|start
operator|+
name|first
argument_list|,
name|second
argument_list|)
expr_stmt|;
name|fragp
operator|->
name|fr_fix
operator|-=
name|first
expr_stmt|;
block|}
else|else
name|fragp
operator|->
name|fr_fix
operator|-=
name|second
expr_stmt|;
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|OBJ_ELF
end_ifdef

begin_comment
comment|/* This function is called after the relocs have been generated.    We've been storing mips16 text labels as odd.  Here we convert them    back to even for the convenience of the debugger.  */
end_comment

begin_function
name|void
name|mips_frob_file_after_relocs
parameter_list|(
name|void
parameter_list|)
block|{
name|asymbol
modifier|*
modifier|*
name|syms
decl_stmt|;
name|unsigned
name|int
name|count
decl_stmt|,
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|IS_ELF
condition|)
return|return;
name|syms
operator|=
name|bfd_get_outsymbols
argument_list|(
name|stdoutput
argument_list|)
expr_stmt|;
name|count
operator|=
name|bfd_get_symcount
argument_list|(
name|stdoutput
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
operator|,
name|syms
operator|++
control|)
block|{
if|if
condition|(
name|elf_symbol
argument_list|(
operator|*
name|syms
argument_list|)
operator|->
name|internal_elf_sym
operator|.
name|st_other
operator|==
name|STO_MIPS16
operator|&&
operator|(
operator|(
operator|*
name|syms
operator|)
operator|->
name|value
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
block|{
operator|(
operator|*
name|syms
operator|)
operator|->
name|value
operator|&=
operator|~
literal|1
expr_stmt|;
comment|/* If the symbol has an odd size, it was probably computed 	     incorrectly, so adjust that as well.  */
if|if
condition|(
operator|(
name|elf_symbol
argument_list|(
operator|*
name|syms
argument_list|)
operator|->
name|internal_elf_sym
operator|.
name|st_size
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
operator|++
name|elf_symbol
argument_list|(
operator|*
name|syms
argument_list|)
operator|->
name|internal_elf_sym
operator|.
name|st_size
expr_stmt|;
block|}
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* This function is called whenever a label is defined.  It is used    when handling branch delays; if a branch has a label, we assume we    can not move it.  */
end_comment

begin_function
name|void
name|mips_define_label
parameter_list|(
name|symbolS
modifier|*
name|sym
parameter_list|)
block|{
name|segment_info_type
modifier|*
name|si
init|=
name|seg_info
argument_list|(
name|now_seg
argument_list|)
decl_stmt|;
name|struct
name|insn_label_list
modifier|*
name|l
decl_stmt|;
if|if
condition|(
name|free_insn_labels
operator|==
name|NULL
condition|)
name|l
operator|=
operator|(
expr|struct
name|insn_label_list
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
expr|*
name|l
argument_list|)
expr_stmt|;
else|else
block|{
name|l
operator|=
name|free_insn_labels
expr_stmt|;
name|free_insn_labels
operator|=
name|l
operator|->
name|next
expr_stmt|;
block|}
name|l
operator|->
name|label
operator|=
name|sym
expr_stmt|;
name|l
operator|->
name|next
operator|=
name|si
operator|->
name|label_list
expr_stmt|;
name|si
operator|->
name|label_list
operator|=
name|l
expr_stmt|;
ifdef|#
directive|ifdef
name|OBJ_ELF
name|dwarf2_emit_label
argument_list|(
name|sym
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_escape
end_escape

begin_if
if|#
directive|if
name|defined
argument_list|(
name|OBJ_ELF
argument_list|)
operator|||
name|defined
argument_list|(
name|OBJ_MAYBE_ELF
argument_list|)
end_if

begin_comment
comment|/* Some special processing for a MIPS ELF file.  */
end_comment

begin_function
name|void
name|mips_elf_final_processing
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* Write out the register information.  */
if|if
condition|(
name|mips_abi
operator|!=
name|N64_ABI
condition|)
block|{
name|Elf32_RegInfo
name|s
decl_stmt|;
name|s
operator|.
name|ri_gprmask
operator|=
name|mips_gprmask
expr_stmt|;
name|s
operator|.
name|ri_cprmask
index|[
literal|0
index|]
operator|=
name|mips_cprmask
index|[
literal|0
index|]
expr_stmt|;
name|s
operator|.
name|ri_cprmask
index|[
literal|1
index|]
operator|=
name|mips_cprmask
index|[
literal|1
index|]
expr_stmt|;
name|s
operator|.
name|ri_cprmask
index|[
literal|2
index|]
operator|=
name|mips_cprmask
index|[
literal|2
index|]
expr_stmt|;
name|s
operator|.
name|ri_cprmask
index|[
literal|3
index|]
operator|=
name|mips_cprmask
index|[
literal|3
index|]
expr_stmt|;
comment|/* The gp_value field is set by the MIPS ELF backend.  */
name|bfd_mips_elf32_swap_reginfo_out
argument_list|(
name|stdoutput
argument_list|,
operator|&
name|s
argument_list|,
operator|(
operator|(
name|Elf32_External_RegInfo
operator|*
operator|)
name|mips_regmask_frag
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Elf64_Internal_RegInfo
name|s
decl_stmt|;
name|s
operator|.
name|ri_gprmask
operator|=
name|mips_gprmask
expr_stmt|;
name|s
operator|.
name|ri_pad
operator|=
literal|0
expr_stmt|;
name|s
operator|.
name|ri_cprmask
index|[
literal|0
index|]
operator|=
name|mips_cprmask
index|[
literal|0
index|]
expr_stmt|;
name|s
operator|.
name|ri_cprmask
index|[
literal|1
index|]
operator|=
name|mips_cprmask
index|[
literal|1
index|]
expr_stmt|;
name|s
operator|.
name|ri_cprmask
index|[
literal|2
index|]
operator|=
name|mips_cprmask
index|[
literal|2
index|]
expr_stmt|;
name|s
operator|.
name|ri_cprmask
index|[
literal|3
index|]
operator|=
name|mips_cprmask
index|[
literal|3
index|]
expr_stmt|;
comment|/* The gp_value field is set by the MIPS ELF backend.  */
name|bfd_mips_elf64_swap_reginfo_out
argument_list|(
name|stdoutput
argument_list|,
operator|&
name|s
argument_list|,
operator|(
operator|(
name|Elf64_External_RegInfo
operator|*
operator|)
name|mips_regmask_frag
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* Set the MIPS ELF flag bits.  FIXME: There should probably be some      sort of BFD interface for this.  */
if|if
condition|(
name|mips_any_noreorder
condition|)
name|elf_elfheader
argument_list|(
name|stdoutput
argument_list|)
operator|->
name|e_flags
operator||=
name|EF_MIPS_NOREORDER
expr_stmt|;
if|if
condition|(
name|mips_pic
operator|!=
name|NO_PIC
condition|)
block|{
name|elf_elfheader
argument_list|(
name|stdoutput
argument_list|)
operator|->
name|e_flags
operator||=
name|EF_MIPS_PIC
expr_stmt|;
name|elf_elfheader
argument_list|(
name|stdoutput
argument_list|)
operator|->
name|e_flags
operator||=
name|EF_MIPS_CPIC
expr_stmt|;
block|}
if|if
condition|(
name|mips_abicalls
condition|)
name|elf_elfheader
argument_list|(
name|stdoutput
argument_list|)
operator|->
name|e_flags
operator||=
name|EF_MIPS_CPIC
expr_stmt|;
comment|/* Set MIPS ELF flags for ASEs.  */
comment|/* We may need to define a new flag for DSP ASE, and set this flag when      file_ase_dsp is true.  */
comment|/* Same for DSP R2.  */
comment|/* We may need to define a new flag for MT ASE, and set this flag when      file_ase_mt is true.  */
if|if
condition|(
name|file_ase_mips16
condition|)
name|elf_elfheader
argument_list|(
name|stdoutput
argument_list|)
operator|->
name|e_flags
operator||=
name|EF_MIPS_ARCH_ASE_M16
expr_stmt|;
if|#
directive|if
literal|0
comment|/* XXX FIXME */
block|if (file_ase_mips3d)     elf_elfheader (stdoutput)->e_flags |= ???;
endif|#
directive|endif
if|if
condition|(
name|file_ase_mdmx
condition|)
name|elf_elfheader
argument_list|(
name|stdoutput
argument_list|)
operator|->
name|e_flags
operator||=
name|EF_MIPS_ARCH_ASE_MDMX
expr_stmt|;
comment|/* Set the MIPS ELF ABI flags.  */
if|if
condition|(
name|mips_abi
operator|==
name|O32_ABI
operator|&&
name|USE_E_MIPS_ABI_O32
condition|)
name|elf_elfheader
argument_list|(
name|stdoutput
argument_list|)
operator|->
name|e_flags
operator||=
name|E_MIPS_ABI_O32
expr_stmt|;
elseif|else
if|if
condition|(
name|mips_abi
operator|==
name|O64_ABI
condition|)
name|elf_elfheader
argument_list|(
name|stdoutput
argument_list|)
operator|->
name|e_flags
operator||=
name|E_MIPS_ABI_O64
expr_stmt|;
elseif|else
if|if
condition|(
name|mips_abi
operator|==
name|EABI_ABI
condition|)
block|{
if|if
condition|(
operator|!
name|file_mips_gp32
condition|)
name|elf_elfheader
argument_list|(
name|stdoutput
argument_list|)
operator|->
name|e_flags
operator||=
name|E_MIPS_ABI_EABI64
expr_stmt|;
else|else
name|elf_elfheader
argument_list|(
name|stdoutput
argument_list|)
operator|->
name|e_flags
operator||=
name|E_MIPS_ABI_EABI32
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mips_abi
operator|==
name|N32_ABI
condition|)
name|elf_elfheader
argument_list|(
name|stdoutput
argument_list|)
operator|->
name|e_flags
operator||=
name|EF_MIPS_ABI2
expr_stmt|;
comment|/* Nothing to do for N64_ABI.  */
if|if
condition|(
name|mips_32bitmode
condition|)
name|elf_elfheader
argument_list|(
name|stdoutput
argument_list|)
operator|->
name|e_flags
operator||=
name|EF_MIPS_32BITMODE
expr_stmt|;
if|#
directive|if
literal|0
comment|/* XXX FIXME */
comment|/* 32 bit code with 64 bit FP registers.  */
block|if (!file_mips_fp32&& ABI_NEEDS_32BIT_REGS (mips_abi))     elf_elfheader (stdoutput)->e_flags |= ???;
endif|#
directive|endif
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* OBJ_ELF || OBJ_MAYBE_ELF */
end_comment

begin_escape
end_escape

begin_typedef
typedef|typedef
struct|struct
name|proc
block|{
name|symbolS
modifier|*
name|func_sym
decl_stmt|;
name|symbolS
modifier|*
name|func_end_sym
decl_stmt|;
name|unsigned
name|long
name|reg_mask
decl_stmt|;
name|unsigned
name|long
name|reg_offset
decl_stmt|;
name|unsigned
name|long
name|fpreg_mask
decl_stmt|;
name|unsigned
name|long
name|fpreg_offset
decl_stmt|;
name|unsigned
name|long
name|frame_offset
decl_stmt|;
name|unsigned
name|long
name|frame_reg
decl_stmt|;
name|unsigned
name|long
name|pc_reg
decl_stmt|;
block|}
name|procS
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|procS
name|cur_proc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|procS
modifier|*
name|cur_proc_ptr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|numprocs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Fill in an rs_align_code fragment.  */
end_comment

begin_function
name|void
name|mips_handle_align
parameter_list|(
name|fragS
modifier|*
name|fragp
parameter_list|)
block|{
if|if
condition|(
name|fragp
operator|->
name|fr_type
operator|!=
name|rs_align_code
condition|)
return|return;
if|if
condition|(
name|mips_opts
operator|.
name|mips16
condition|)
block|{
specifier|static
specifier|const
name|unsigned
name|char
name|be_nop
index|[]
init|=
block|{
literal|0x65
block|,
literal|0x00
block|}
decl_stmt|;
specifier|static
specifier|const
name|unsigned
name|char
name|le_nop
index|[]
init|=
block|{
literal|0x00
block|,
literal|0x65
block|}
decl_stmt|;
name|int
name|bytes
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|bytes
operator|=
name|fragp
operator|->
name|fr_next
operator|->
name|fr_address
operator|-
name|fragp
operator|->
name|fr_address
operator|-
name|fragp
operator|->
name|fr_fix
expr_stmt|;
name|p
operator|=
name|fragp
operator|->
name|fr_literal
operator|+
name|fragp
operator|->
name|fr_fix
expr_stmt|;
if|if
condition|(
name|bytes
operator|&
literal|1
condition|)
block|{
operator|*
name|p
operator|++
operator|=
literal|0
expr_stmt|;
name|fragp
operator|->
name|fr_fix
operator|++
expr_stmt|;
block|}
name|memcpy
argument_list|(
name|p
argument_list|,
operator|(
name|target_big_endian
condition|?
name|be_nop
else|:
name|le_nop
operator|)
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|fragp
operator|->
name|fr_var
operator|=
literal|2
expr_stmt|;
block|}
comment|/* For mips32, a nop is a zero, which we trivially get by doing nothing.  */
block|}
end_function

begin_function
specifier|static
name|void
name|md_obj_begin
parameter_list|(
name|void
parameter_list|)
block|{ }
end_function

begin_function
specifier|static
name|void
name|md_obj_end
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* Check for premature end, nesting errors, etc.  */
if|if
condition|(
name|cur_proc_ptr
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"missing .end at end of assembly"
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|long
name|get_number
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|negative
init|=
literal|0
decl_stmt|;
name|long
name|val
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|'-'
condition|)
block|{
operator|++
name|input_line_pointer
expr_stmt|;
name|negative
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|ISDIGIT
argument_list|(
operator|*
name|input_line_pointer
argument_list|)
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"expected simple number"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|input_line_pointer
index|[
literal|0
index|]
operator|==
literal|'0'
condition|)
block|{
if|if
condition|(
name|input_line_pointer
index|[
literal|1
index|]
operator|==
literal|'x'
condition|)
block|{
name|input_line_pointer
operator|+=
literal|2
expr_stmt|;
while|while
condition|(
name|ISXDIGIT
argument_list|(
operator|*
name|input_line_pointer
argument_list|)
condition|)
block|{
name|val
operator|<<=
literal|4
expr_stmt|;
name|val
operator||=
name|hex_value
argument_list|(
operator|*
name|input_line_pointer
operator|++
argument_list|)
expr_stmt|;
block|}
return|return
name|negative
condition|?
operator|-
name|val
else|:
name|val
return|;
block|}
else|else
block|{
operator|++
name|input_line_pointer
expr_stmt|;
while|while
condition|(
name|ISDIGIT
argument_list|(
operator|*
name|input_line_pointer
argument_list|)
condition|)
block|{
name|val
operator|<<=
literal|3
expr_stmt|;
name|val
operator||=
operator|*
name|input_line_pointer
operator|++
operator|-
literal|'0'
expr_stmt|;
block|}
return|return
name|negative
condition|?
operator|-
name|val
else|:
name|val
return|;
block|}
block|}
if|if
condition|(
operator|!
name|ISDIGIT
argument_list|(
operator|*
name|input_line_pointer
argument_list|)
condition|)
block|{
name|printf
argument_list|(
name|_
argument_list|(
literal|" *input_line_pointer == '%c' 0x%02x\n"
argument_list|)
argument_list|,
operator|*
name|input_line_pointer
argument_list|,
operator|*
name|input_line_pointer
argument_list|)
expr_stmt|;
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"invalid number"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
while|while
condition|(
name|ISDIGIT
argument_list|(
operator|*
name|input_line_pointer
argument_list|)
condition|)
block|{
name|val
operator|*=
literal|10
expr_stmt|;
name|val
operator|+=
operator|*
name|input_line_pointer
operator|++
operator|-
literal|'0'
expr_stmt|;
block|}
return|return
name|negative
condition|?
operator|-
name|val
else|:
name|val
return|;
block|}
end_function

begin_comment
comment|/* The .file directive; just like the usual .file directive, but there    is an initial number which is the ECOFF file index.  In the non-ECOFF    case .file implies DWARF-2.  */
end_comment

begin_function
specifier|static
name|void
name|s_mips_file
parameter_list|(
name|int
name|x
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
specifier|static
name|int
name|first_file_directive
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|ECOFF_DEBUGGING
condition|)
block|{
name|get_number
argument_list|()
expr_stmt|;
name|s_app_file
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|char
modifier|*
name|filename
decl_stmt|;
name|filename
operator|=
name|dwarf2_directive_file
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* Versions of GCC up to 3.1 start files with a ".file" 	 directive even for stabs output.  Make sure that this 	 ".file" is handled.  Note that you need a version of GCC          after 3.1 in order to support DWARF-2 on MIPS.  */
if|if
condition|(
name|filename
operator|!=
name|NULL
operator|&&
operator|!
name|first_file_directive
condition|)
block|{
operator|(
name|void
operator|)
name|new_logical_line
argument_list|(
name|filename
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|s_app_file_string
argument_list|(
name|filename
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|first_file_directive
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* The .loc directive, implying DWARF-2.  */
end_comment

begin_function
specifier|static
name|void
name|s_mips_loc
parameter_list|(
name|int
name|x
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
if|if
condition|(
operator|!
name|ECOFF_DEBUGGING
condition|)
name|dwarf2_directive_loc
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The .end directive.  */
end_comment

begin_function
specifier|static
name|void
name|s_mips_end
parameter_list|(
name|int
name|x
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|symbolS
modifier|*
name|p
decl_stmt|;
comment|/* Following functions need their own .frame and .cprestore directives.  */
name|mips_frame_reg_valid
operator|=
literal|0
expr_stmt|;
name|mips_cprestore_valid
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|is_end_of_line
index|[
operator|(
name|unsigned
name|char
operator|)
operator|*
name|input_line_pointer
index|]
condition|)
block|{
name|p
operator|=
name|get_symbol
argument_list|()
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
else|else
name|p
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|bfd_get_section_flags
argument_list|(
name|stdoutput
argument_list|,
name|now_seg
argument_list|)
operator|&
name|SEC_CODE
operator|)
operator|==
literal|0
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|".end not in text section"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cur_proc_ptr
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|".end directive without a preceding .ent directive."
argument_list|)
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
block|{
name|assert
argument_list|(
name|S_GET_NAME
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|S_GET_NAME
argument_list|(
name|p
argument_list|)
argument_list|,
name|S_GET_NAME
argument_list|(
name|cur_proc_ptr
operator|->
name|func_sym
argument_list|)
argument_list|)
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|".end symbol does not match .ent symbol."
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug_type
operator|==
name|DEBUG_STABS
condition|)
name|stabs_generate_asm_endfunc
argument_list|(
name|S_GET_NAME
argument_list|(
name|p
argument_list|)
argument_list|,
name|S_GET_NAME
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|as_warn
argument_list|(
name|_
argument_list|(
literal|".end directive missing or unknown symbol"
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|OBJ_ELF
comment|/* Create an expression to calculate the size of the function.  */
if|if
condition|(
name|p
operator|&&
name|cur_proc_ptr
condition|)
block|{
name|OBJ_SYMFIELD_TYPE
modifier|*
name|obj
init|=
name|symbol_get_obj
argument_list|(
name|p
argument_list|)
decl_stmt|;
name|expressionS
modifier|*
name|exp
init|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|expressionS
argument_list|)
argument_list|)
decl_stmt|;
name|obj
operator|->
name|size
operator|=
name|exp
expr_stmt|;
name|exp
operator|->
name|X_op
operator|=
name|O_subtract
expr_stmt|;
name|exp
operator|->
name|X_add_symbol
operator|=
name|symbol_temp_new_now
argument_list|()
expr_stmt|;
name|exp
operator|->
name|X_op_symbol
operator|=
name|p
expr_stmt|;
name|exp
operator|->
name|X_add_number
operator|=
literal|0
expr_stmt|;
name|cur_proc_ptr
operator|->
name|func_end_sym
operator|=
name|exp
operator|->
name|X_add_symbol
expr_stmt|;
block|}
comment|/* Generate a .pdr section.  */
if|if
condition|(
name|IS_ELF
operator|&&
operator|!
name|ECOFF_DEBUGGING
operator|&&
name|mips_flag_pdr
condition|)
block|{
name|segT
name|saved_seg
init|=
name|now_seg
decl_stmt|;
name|subsegT
name|saved_subseg
init|=
name|now_subseg
decl_stmt|;
name|valueT
name|dot
decl_stmt|;
name|expressionS
name|exp
decl_stmt|;
name|char
modifier|*
name|fragp
decl_stmt|;
name|dot
operator|=
name|frag_now_fix
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|md_flush_pending_output
name|md_flush_pending_output
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|assert
argument_list|(
name|pdr_seg
argument_list|)
expr_stmt|;
name|subseg_set
argument_list|(
name|pdr_seg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Write the symbol.  */
name|exp
operator|.
name|X_op
operator|=
name|O_symbol
expr_stmt|;
name|exp
operator|.
name|X_add_symbol
operator|=
name|p
expr_stmt|;
name|exp
operator|.
name|X_add_number
operator|=
literal|0
expr_stmt|;
name|emit_expr
argument_list|(
operator|&
name|exp
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|fragp
operator|=
name|frag_more
argument_list|(
literal|7
operator|*
literal|4
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|fragp
argument_list|,
name|cur_proc_ptr
operator|->
name|reg_mask
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|fragp
operator|+
literal|4
argument_list|,
name|cur_proc_ptr
operator|->
name|reg_offset
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|fragp
operator|+
literal|8
argument_list|,
name|cur_proc_ptr
operator|->
name|fpreg_mask
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|fragp
operator|+
literal|12
argument_list|,
name|cur_proc_ptr
operator|->
name|fpreg_offset
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|fragp
operator|+
literal|16
argument_list|,
name|cur_proc_ptr
operator|->
name|frame_offset
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|fragp
operator|+
literal|20
argument_list|,
name|cur_proc_ptr
operator|->
name|frame_reg
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|fragp
operator|+
literal|24
argument_list|,
name|cur_proc_ptr
operator|->
name|pc_reg
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|subseg_set
argument_list|(
name|saved_seg
argument_list|,
name|saved_subseg
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* OBJ_ELF */
name|cur_proc_ptr
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The .aent and .ent directives.  */
end_comment

begin_function
specifier|static
name|void
name|s_mips_ent
parameter_list|(
name|int
name|aent
parameter_list|)
block|{
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
name|symbolP
operator|=
name|get_symbol
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|','
condition|)
operator|++
name|input_line_pointer
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
name|ISDIGIT
argument_list|(
operator|*
name|input_line_pointer
argument_list|)
operator|||
operator|*
name|input_line_pointer
operator|==
literal|'-'
condition|)
name|get_number
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|bfd_get_section_flags
argument_list|(
name|stdoutput
argument_list|,
name|now_seg
argument_list|)
operator|&
name|SEC_CODE
operator|)
operator|==
literal|0
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|".ent or .aent not in text section."
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|aent
operator|&&
name|cur_proc_ptr
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"missing .end"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|aent
condition|)
block|{
comment|/* This function needs its own .frame and .cprestore directives.  */
name|mips_frame_reg_valid
operator|=
literal|0
expr_stmt|;
name|mips_cprestore_valid
operator|=
literal|0
expr_stmt|;
name|cur_proc_ptr
operator|=
operator|&
name|cur_proc
expr_stmt|;
name|memset
argument_list|(
name|cur_proc_ptr
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
name|procS
argument_list|)
argument_list|)
expr_stmt|;
name|cur_proc_ptr
operator|->
name|func_sym
operator|=
name|symbolP
expr_stmt|;
name|symbol_get_bfdsym
argument_list|(
name|symbolP
argument_list|)
operator|->
name|flags
operator||=
name|BSF_FUNCTION
expr_stmt|;
operator|++
name|numprocs
expr_stmt|;
if|if
condition|(
name|debug_type
operator|==
name|DEBUG_STABS
condition|)
name|stabs_generate_asm_func
argument_list|(
name|S_GET_NAME
argument_list|(
name|symbolP
argument_list|)
argument_list|,
name|S_GET_NAME
argument_list|(
name|symbolP
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The .frame directive. If the mdebug section is present (IRIX 5 native)    then ecoff.c (ecoff_directive_frame) is used. For embedded targets,    s_mips_frame is used so that we can set the PDR information correctly.    We can't use the ecoff routines because they make reference to the ecoff    symbol table (in the mdebug section).  */
end_comment

begin_function
specifier|static
name|void
name|s_mips_frame
parameter_list|(
name|int
name|ignore
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|OBJ_ELF
if|if
condition|(
name|IS_ELF
operator|&&
operator|!
name|ECOFF_DEBUGGING
condition|)
block|{
name|long
name|val
decl_stmt|;
if|if
condition|(
name|cur_proc_ptr
operator|==
operator|(
name|procS
operator|*
operator|)
name|NULL
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|".frame outside of .ent"
argument_list|)
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
name|cur_proc_ptr
operator|->
name|frame_reg
operator|=
name|tc_get_register
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|++
operator|!=
literal|','
operator|||
name|get_absolute_expression_and_terminator
argument_list|(
operator|&
name|val
argument_list|)
operator|!=
literal|','
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"Bad .frame directive"
argument_list|)
argument_list|)
expr_stmt|;
operator|--
name|input_line_pointer
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
name|cur_proc_ptr
operator|->
name|frame_offset
operator|=
name|val
expr_stmt|;
name|cur_proc_ptr
operator|->
name|pc_reg
operator|=
name|tc_get_register
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
else|else
endif|#
directive|endif
comment|/* OBJ_ELF */
name|s_ignore
argument_list|(
name|ignore
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The .fmask and .mask directives. If the mdebug section is present    (IRIX 5 native) then ecoff.c (ecoff_directive_mask) is used. For    embedded targets, s_mips_mask is used so that we can set the PDR    information correctly. We can't use the ecoff routines because they    make reference to the ecoff symbol table (in the mdebug section).  */
end_comment

begin_function
specifier|static
name|void
name|s_mips_mask
parameter_list|(
name|int
name|reg_type
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|OBJ_ELF
if|if
condition|(
name|IS_ELF
operator|&&
operator|!
name|ECOFF_DEBUGGING
condition|)
block|{
name|long
name|mask
decl_stmt|,
name|off
decl_stmt|;
if|if
condition|(
name|cur_proc_ptr
operator|==
operator|(
name|procS
operator|*
operator|)
name|NULL
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|".mask/.fmask outside of .ent"
argument_list|)
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|get_absolute_expression_and_terminator
argument_list|(
operator|&
name|mask
argument_list|)
operator|!=
literal|','
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"Bad .mask/.fmask directive"
argument_list|)
argument_list|)
expr_stmt|;
operator|--
name|input_line_pointer
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
name|off
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
if|if
condition|(
name|reg_type
operator|==
literal|'F'
condition|)
block|{
name|cur_proc_ptr
operator|->
name|fpreg_mask
operator|=
name|mask
expr_stmt|;
name|cur_proc_ptr
operator|->
name|fpreg_offset
operator|=
name|off
expr_stmt|;
block|}
else|else
block|{
name|cur_proc_ptr
operator|->
name|reg_mask
operator|=
name|mask
expr_stmt|;
name|cur_proc_ptr
operator|->
name|reg_offset
operator|=
name|off
expr_stmt|;
block|}
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
else|else
endif|#
directive|endif
comment|/* OBJ_ELF */
name|s_ignore
argument_list|(
name|reg_type
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* A table describing all the processors gas knows about.  Names are    matched in the order listed.     To ease comparison, please keep this table in the same order as    gcc's mips_cpu_info_table[].  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|mips_cpu_info
name|mips_cpu_info_table
index|[]
init|=
block|{
comment|/* Entries for generic ISAs */
block|{
literal|"mips1"
block|,
name|MIPS_CPU_IS_ISA
block|,
name|ISA_MIPS1
block|,
name|CPU_R3000
block|}
block|,
block|{
literal|"mips2"
block|,
name|MIPS_CPU_IS_ISA
block|,
name|ISA_MIPS2
block|,
name|CPU_R6000
block|}
block|,
block|{
literal|"mips3"
block|,
name|MIPS_CPU_IS_ISA
block|,
name|ISA_MIPS3
block|,
name|CPU_R4000
block|}
block|,
block|{
literal|"mips4"
block|,
name|MIPS_CPU_IS_ISA
block|,
name|ISA_MIPS4
block|,
name|CPU_R8000
block|}
block|,
block|{
literal|"mips5"
block|,
name|MIPS_CPU_IS_ISA
block|,
name|ISA_MIPS5
block|,
name|CPU_MIPS5
block|}
block|,
block|{
literal|"mips32"
block|,
name|MIPS_CPU_IS_ISA
block|,
name|ISA_MIPS32
block|,
name|CPU_MIPS32
block|}
block|,
block|{
literal|"mips32r2"
block|,
name|MIPS_CPU_IS_ISA
block|,
name|ISA_MIPS32R2
block|,
name|CPU_MIPS32R2
block|}
block|,
block|{
literal|"mips64"
block|,
name|MIPS_CPU_IS_ISA
block|,
name|ISA_MIPS64
block|,
name|CPU_MIPS64
block|}
block|,
block|{
literal|"mips64r2"
block|,
name|MIPS_CPU_IS_ISA
block|,
name|ISA_MIPS64R2
block|,
name|CPU_MIPS64R2
block|}
block|,
comment|/* MIPS I */
block|{
literal|"r3000"
block|,
literal|0
block|,
name|ISA_MIPS1
block|,
name|CPU_R3000
block|}
block|,
block|{
literal|"r2000"
block|,
literal|0
block|,
name|ISA_MIPS1
block|,
name|CPU_R3000
block|}
block|,
block|{
literal|"r3900"
block|,
literal|0
block|,
name|ISA_MIPS1
block|,
name|CPU_R3900
block|}
block|,
comment|/* MIPS II */
block|{
literal|"r6000"
block|,
literal|0
block|,
name|ISA_MIPS2
block|,
name|CPU_R6000
block|}
block|,
comment|/* MIPS III */
block|{
literal|"r4000"
block|,
literal|0
block|,
name|ISA_MIPS3
block|,
name|CPU_R4000
block|}
block|,
block|{
literal|"r4010"
block|,
literal|0
block|,
name|ISA_MIPS2
block|,
name|CPU_R4010
block|}
block|,
block|{
literal|"vr4100"
block|,
literal|0
block|,
name|ISA_MIPS3
block|,
name|CPU_VR4100
block|}
block|,
block|{
literal|"vr4111"
block|,
literal|0
block|,
name|ISA_MIPS3
block|,
name|CPU_R4111
block|}
block|,
block|{
literal|"vr4120"
block|,
literal|0
block|,
name|ISA_MIPS3
block|,
name|CPU_VR4120
block|}
block|,
block|{
literal|"vr4130"
block|,
literal|0
block|,
name|ISA_MIPS3
block|,
name|CPU_VR4120
block|}
block|,
block|{
literal|"vr4181"
block|,
literal|0
block|,
name|ISA_MIPS3
block|,
name|CPU_R4111
block|}
block|,
block|{
literal|"vr4300"
block|,
literal|0
block|,
name|ISA_MIPS3
block|,
name|CPU_R4300
block|}
block|,
block|{
literal|"r4400"
block|,
literal|0
block|,
name|ISA_MIPS3
block|,
name|CPU_R4400
block|}
block|,
block|{
literal|"r4600"
block|,
literal|0
block|,
name|ISA_MIPS3
block|,
name|CPU_R4600
block|}
block|,
block|{
literal|"orion"
block|,
literal|0
block|,
name|ISA_MIPS3
block|,
name|CPU_R4600
block|}
block|,
block|{
literal|"r4650"
block|,
literal|0
block|,
name|ISA_MIPS3
block|,
name|CPU_R4650
block|}
block|,
comment|/* MIPS IV */
block|{
literal|"r8000"
block|,
literal|0
block|,
name|ISA_MIPS4
block|,
name|CPU_R8000
block|}
block|,
block|{
literal|"r10000"
block|,
literal|0
block|,
name|ISA_MIPS4
block|,
name|CPU_R10000
block|}
block|,
block|{
literal|"r12000"
block|,
literal|0
block|,
name|ISA_MIPS4
block|,
name|CPU_R12000
block|}
block|,
block|{
literal|"vr5000"
block|,
literal|0
block|,
name|ISA_MIPS4
block|,
name|CPU_R5000
block|}
block|,
block|{
literal|"vr5400"
block|,
literal|0
block|,
name|ISA_MIPS4
block|,
name|CPU_VR5400
block|}
block|,
block|{
literal|"vr5500"
block|,
literal|0
block|,
name|ISA_MIPS4
block|,
name|CPU_VR5500
block|}
block|,
block|{
literal|"rm5200"
block|,
literal|0
block|,
name|ISA_MIPS4
block|,
name|CPU_R5000
block|}
block|,
block|{
literal|"rm5230"
block|,
literal|0
block|,
name|ISA_MIPS4
block|,
name|CPU_R5000
block|}
block|,
block|{
literal|"rm5231"
block|,
literal|0
block|,
name|ISA_MIPS4
block|,
name|CPU_R5000
block|}
block|,
block|{
literal|"rm5261"
block|,
literal|0
block|,
name|ISA_MIPS4
block|,
name|CPU_R5000
block|}
block|,
block|{
literal|"rm5721"
block|,
literal|0
block|,
name|ISA_MIPS4
block|,
name|CPU_R5000
block|}
block|,
block|{
literal|"rm7000"
block|,
literal|0
block|,
name|ISA_MIPS4
block|,
name|CPU_RM7000
block|}
block|,
block|{
literal|"rm9000"
block|,
literal|0
block|,
name|ISA_MIPS4
block|,
name|CPU_RM9000
block|}
block|,
comment|/* MIPS 32 */
block|{
literal|"4kc"
block|,
literal|0
block|,
name|ISA_MIPS32
block|,
name|CPU_MIPS32
block|}
block|,
block|{
literal|"4km"
block|,
literal|0
block|,
name|ISA_MIPS32
block|,
name|CPU_MIPS32
block|}
block|,
block|{
literal|"4kp"
block|,
literal|0
block|,
name|ISA_MIPS32
block|,
name|CPU_MIPS32
block|}
block|,
block|{
literal|"4ksc"
block|,
name|MIPS_CPU_ASE_SMARTMIPS
block|,
name|ISA_MIPS32
block|,
name|CPU_MIPS32
block|}
block|,
comment|/* MIPS 32 Release 2 */
block|{
literal|"4kec"
block|,
literal|0
block|,
name|ISA_MIPS32R2
block|,
name|CPU_MIPS32R2
block|}
block|,
block|{
literal|"4kem"
block|,
literal|0
block|,
name|ISA_MIPS32R2
block|,
name|CPU_MIPS32R2
block|}
block|,
block|{
literal|"4kep"
block|,
literal|0
block|,
name|ISA_MIPS32R2
block|,
name|CPU_MIPS32R2
block|}
block|,
block|{
literal|"4ksd"
block|,
name|MIPS_CPU_ASE_SMARTMIPS
block|,
name|ISA_MIPS32R2
block|,
name|CPU_MIPS32R2
block|}
block|,
block|{
literal|"m4k"
block|,
literal|0
block|,
name|ISA_MIPS32R2
block|,
name|CPU_MIPS32R2
block|}
block|,
block|{
literal|"m4kp"
block|,
literal|0
block|,
name|ISA_MIPS32R2
block|,
name|CPU_MIPS32R2
block|}
block|,
block|{
literal|"24kc"
block|,
literal|0
block|,
name|ISA_MIPS32R2
block|,
name|CPU_MIPS32R2
block|}
block|,
block|{
literal|"24kf"
block|,
literal|0
block|,
name|ISA_MIPS32R2
block|,
name|CPU_MIPS32R2
block|}
block|,
block|{
literal|"24kx"
block|,
literal|0
block|,
name|ISA_MIPS32R2
block|,
name|CPU_MIPS32R2
block|}
block|,
comment|/* 24KE is a 24K with DSP ASE, other ASEs are optional.  */
block|{
literal|"24kec"
block|,
name|MIPS_CPU_ASE_DSP
block|,
name|ISA_MIPS32R2
block|,
name|CPU_MIPS32R2
block|}
block|,
block|{
literal|"24kef"
block|,
name|MIPS_CPU_ASE_DSP
block|,
name|ISA_MIPS32R2
block|,
name|CPU_MIPS32R2
block|}
block|,
block|{
literal|"24kex"
block|,
name|MIPS_CPU_ASE_DSP
block|,
name|ISA_MIPS32R2
block|,
name|CPU_MIPS32R2
block|}
block|,
comment|/* 34K is a 24K with DSP and MT ASE, other ASEs are optional.  */
block|{
literal|"34kc"
block|,
name|MIPS_CPU_ASE_DSP
operator||
name|MIPS_CPU_ASE_MT
block|,
name|ISA_MIPS32R2
block|,
name|CPU_MIPS32R2
block|}
block|,
block|{
literal|"34kf"
block|,
name|MIPS_CPU_ASE_DSP
operator||
name|MIPS_CPU_ASE_MT
block|,
name|ISA_MIPS32R2
block|,
name|CPU_MIPS32R2
block|}
block|,
block|{
literal|"34kx"
block|,
name|MIPS_CPU_ASE_DSP
operator||
name|MIPS_CPU_ASE_MT
block|,
name|ISA_MIPS32R2
block|,
name|CPU_MIPS32R2
block|}
block|,
comment|/* 74K with DSP and DSPR2 ASE, other ASEs are optional.  */
block|{
literal|"74kc"
block|,
name|MIPS_CPU_ASE_DSP
operator||
name|MIPS_CPU_ASE_DSPR2
block|,
name|ISA_MIPS32R2
block|,
name|CPU_MIPS32R2
block|}
block|,
block|{
literal|"74kf"
block|,
name|MIPS_CPU_ASE_DSP
operator||
name|MIPS_CPU_ASE_DSPR2
block|,
name|ISA_MIPS32R2
block|,
name|CPU_MIPS32R2
block|}
block|,
block|{
literal|"74kx"
block|,
name|MIPS_CPU_ASE_DSP
operator||
name|MIPS_CPU_ASE_DSPR2
block|,
name|ISA_MIPS32R2
block|,
name|CPU_MIPS32R2
block|}
block|,
comment|/* MIPS 64 */
block|{
literal|"5kc"
block|,
literal|0
block|,
name|ISA_MIPS64
block|,
name|CPU_MIPS64
block|}
block|,
block|{
literal|"5kf"
block|,
literal|0
block|,
name|ISA_MIPS64
block|,
name|CPU_MIPS64
block|}
block|,
block|{
literal|"20kc"
block|,
name|MIPS_CPU_ASE_MIPS3D
block|,
name|ISA_MIPS64
block|,
name|CPU_MIPS64
block|}
block|,
block|{
literal|"25kf"
block|,
name|MIPS_CPU_ASE_MIPS3D
block|,
name|ISA_MIPS64
block|,
name|CPU_MIPS64
block|}
block|,
comment|/* MIPS 64 Release 2 */
comment|/* Broadcom SB-1 CPU core */
block|{
literal|"sb1"
block|,
name|MIPS_CPU_ASE_MIPS3D
operator||
name|MIPS_CPU_ASE_MDMX
block|,
name|ISA_MIPS64
block|,
name|CPU_SB1
block|}
block|,
comment|/* Broadcom SB-1A CPU core */
block|{
literal|"sb1a"
block|,
name|MIPS_CPU_ASE_MIPS3D
operator||
name|MIPS_CPU_ASE_MDMX
block|,
name|ISA_MIPS64
block|,
name|CPU_SB1
block|}
block|,
comment|/* Cavium Networks Octeon CPU core */
block|{
literal|"octeon"
block|,
literal|0
block|,
name|ISA_MIPS64R2
block|,
name|CPU_OCTEON
block|}
block|,
comment|/* End marker */
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Return true if GIVEN is the same as CANONICAL, or if it is CANONICAL    with a final "000" replaced by "k".  Ignore case.     Note: this function is shared between GCC and GAS.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|mips_strict_matching_cpu_name_p
parameter_list|(
specifier|const
name|char
modifier|*
name|canonical
parameter_list|,
specifier|const
name|char
modifier|*
name|given
parameter_list|)
block|{
while|while
condition|(
operator|*
name|given
operator|!=
literal|0
operator|&&
name|TOLOWER
argument_list|(
operator|*
name|given
argument_list|)
operator|==
name|TOLOWER
argument_list|(
operator|*
name|canonical
argument_list|)
condition|)
name|given
operator|++
operator|,
name|canonical
operator|++
expr_stmt|;
return|return
operator|(
operator|(
operator|*
name|given
operator|==
literal|0
operator|&&
operator|*
name|canonical
operator|==
literal|0
operator|)
operator|||
operator|(
name|strcmp
argument_list|(
name|canonical
argument_list|,
literal|"000"
argument_list|)
operator|==
literal|0
operator|&&
name|strcasecmp
argument_list|(
name|given
argument_list|,
literal|"k"
argument_list|)
operator|==
literal|0
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return true if GIVEN matches CANONICAL, where GIVEN is a user-supplied    CPU name.  We've traditionally allowed a lot of variation here.     Note: this function is shared between GCC and GAS.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|mips_matching_cpu_name_p
parameter_list|(
specifier|const
name|char
modifier|*
name|canonical
parameter_list|,
specifier|const
name|char
modifier|*
name|given
parameter_list|)
block|{
comment|/* First see if the name matches exactly, or with a final "000"      turned into "k".  */
if|if
condition|(
name|mips_strict_matching_cpu_name_p
argument_list|(
name|canonical
argument_list|,
name|given
argument_list|)
condition|)
return|return
name|TRUE
return|;
comment|/* If not, try comparing based on numerical designation alone.      See if GIVEN is an unadorned number, or 'r' followed by a number.  */
if|if
condition|(
name|TOLOWER
argument_list|(
operator|*
name|given
argument_list|)
operator|==
literal|'r'
condition|)
name|given
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|ISDIGIT
argument_list|(
operator|*
name|given
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* Skip over some well-known prefixes in the canonical name,      hoping to find a number there too.  */
if|if
condition|(
name|TOLOWER
argument_list|(
name|canonical
index|[
literal|0
index|]
argument_list|)
operator|==
literal|'v'
operator|&&
name|TOLOWER
argument_list|(
name|canonical
index|[
literal|1
index|]
argument_list|)
operator|==
literal|'r'
condition|)
name|canonical
operator|+=
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
name|TOLOWER
argument_list|(
name|canonical
index|[
literal|0
index|]
argument_list|)
operator|==
literal|'r'
operator|&&
name|TOLOWER
argument_list|(
name|canonical
index|[
literal|1
index|]
argument_list|)
operator|==
literal|'m'
condition|)
name|canonical
operator|+=
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
name|TOLOWER
argument_list|(
name|canonical
index|[
literal|0
index|]
argument_list|)
operator|==
literal|'r'
condition|)
name|canonical
operator|+=
literal|1
expr_stmt|;
return|return
name|mips_strict_matching_cpu_name_p
argument_list|(
name|canonical
argument_list|,
name|given
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Parse an option that takes the name of a processor as its argument.    OPTION is the name of the option and CPU_STRING is the argument.    Return the corresponding processor enumeration if the CPU_STRING is    recognized, otherwise report an error and return null.     A similar function exists in GCC.  */
end_comment

begin_function
specifier|static
specifier|const
name|struct
name|mips_cpu_info
modifier|*
name|mips_parse_cpu
parameter_list|(
specifier|const
name|char
modifier|*
name|option
parameter_list|,
specifier|const
name|char
modifier|*
name|cpu_string
parameter_list|)
block|{
specifier|const
name|struct
name|mips_cpu_info
modifier|*
name|p
decl_stmt|;
comment|/* 'from-abi' selects the most compatible architecture for the given      ABI: MIPS I for 32-bit ABIs and MIPS III for 64-bit ABIs.  For the      EABIs, we have to decide whether we're using the 32-bit or 64-bit      version.  Look first at the -mgp options, if given, otherwise base      the choice on MIPS_DEFAULT_64BIT.       Treat NO_ABI like the EABIs.  One reason to do this is that the      plain 'mips' and 'mips64' configs have 'from-abi' as their default      architecture.  This code picks MIPS I for 'mips' and MIPS III for      'mips64', just as we did in the days before 'from-abi'.  */
if|if
condition|(
name|strcasecmp
argument_list|(
name|cpu_string
argument_list|,
literal|"from-abi"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|ABI_NEEDS_32BIT_REGS
argument_list|(
name|mips_abi
argument_list|)
condition|)
return|return
name|mips_cpu_info_from_isa
argument_list|(
name|ISA_MIPS1
argument_list|)
return|;
if|if
condition|(
name|ABI_NEEDS_64BIT_REGS
argument_list|(
name|mips_abi
argument_list|)
condition|)
return|return
name|mips_cpu_info_from_isa
argument_list|(
name|ISA_MIPS3
argument_list|)
return|;
if|if
condition|(
name|file_mips_gp32
operator|>=
literal|0
condition|)
return|return
name|mips_cpu_info_from_isa
argument_list|(
name|file_mips_gp32
condition|?
name|ISA_MIPS1
else|:
name|ISA_MIPS3
argument_list|)
return|;
return|return
name|mips_cpu_info_from_isa
argument_list|(
name|MIPS_DEFAULT_64BIT
condition|?
name|ISA_MIPS3
else|:
name|ISA_MIPS1
argument_list|)
return|;
block|}
comment|/* 'default' has traditionally been a no-op.  Probably not very useful.  */
if|if
condition|(
name|strcasecmp
argument_list|(
name|cpu_string
argument_list|,
literal|"default"
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
for|for
control|(
name|p
operator|=
name|mips_cpu_info_table
init|;
name|p
operator|->
name|name
operator|!=
literal|0
condition|;
name|p
operator|++
control|)
if|if
condition|(
name|mips_matching_cpu_name_p
argument_list|(
name|p
operator|->
name|name
argument_list|,
name|cpu_string
argument_list|)
condition|)
return|return
name|p
return|;
name|as_bad
argument_list|(
literal|"Bad value (%s) for %s"
argument_list|,
name|cpu_string
argument_list|,
name|option
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return the canonical processor information for ISA (a member of the    ISA_MIPS* enumeration).  */
end_comment

begin_function
specifier|static
specifier|const
name|struct
name|mips_cpu_info
modifier|*
name|mips_cpu_info_from_isa
parameter_list|(
name|int
name|isa
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|mips_cpu_info_table
index|[
name|i
index|]
operator|.
name|name
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|mips_cpu_info_table
index|[
name|i
index|]
operator|.
name|flags
operator|&
name|MIPS_CPU_IS_ISA
operator|)
operator|&&
name|isa
operator|==
name|mips_cpu_info_table
index|[
name|i
index|]
operator|.
name|isa
condition|)
return|return
operator|(
operator|&
name|mips_cpu_info_table
index|[
name|i
index|]
operator|)
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|struct
name|mips_cpu_info
modifier|*
name|mips_cpu_info_from_arch
parameter_list|(
name|int
name|arch
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|mips_cpu_info_table
index|[
name|i
index|]
operator|.
name|name
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|arch
operator|==
name|mips_cpu_info_table
index|[
name|i
index|]
operator|.
name|cpu
condition|)
return|return
operator|(
operator|&
name|mips_cpu_info_table
index|[
name|i
index|]
operator|)
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|show
parameter_list|(
name|FILE
modifier|*
name|stream
parameter_list|,
specifier|const
name|char
modifier|*
name|string
parameter_list|,
name|int
modifier|*
name|col_p
parameter_list|,
name|int
modifier|*
name|first_p
parameter_list|)
block|{
if|if
condition|(
operator|*
name|first_p
condition|)
block|{
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"%24s"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
operator|*
name|col_p
operator|=
literal|24
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
operator|*
name|col_p
operator|+=
literal|2
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|col_p
operator|+
name|strlen
argument_list|(
name|string
argument_list|)
operator|>
literal|72
condition|)
block|{
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\n%24s"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
operator|*
name|col_p
operator|=
literal|24
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"%s"
argument_list|,
name|string
argument_list|)
expr_stmt|;
operator|*
name|col_p
operator|+=
name|strlen
argument_list|(
name|string
argument_list|)
expr_stmt|;
operator|*
name|first_p
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|void
name|md_show_usage
parameter_list|(
name|FILE
modifier|*
name|stream
parameter_list|)
block|{
name|int
name|column
decl_stmt|,
name|first
decl_stmt|;
name|size_t
name|i
decl_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"\ MIPS options:\n\ -EB			generate big endian output\n\ -EL			generate little endian output\n\ -g, -g2			do not remove unneeded NOPs or swap branches\n\ -G NUM			allow referencing objects up to NUM bytes\n\ 			implicitly with the gp register [default 8]\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"\ -mips1			generate MIPS ISA I instructions\n\ -mips2			generate MIPS ISA II instructions\n\ -mips3			generate MIPS ISA III instructions\n\ -mips4			generate MIPS ISA IV instructions\n\ -mips5                  generate MIPS ISA V instructions\n\ -mips32                 generate MIPS32 ISA instructions\n\ -mips32r2               generate MIPS32 release 2 ISA instructions\n\ -mips64                 generate MIPS64 ISA instructions\n\ -mips64r2               generate MIPS64 release 2 ISA instructions\n\ -march=CPU/-mtune=CPU	generate code/schedule for CPU, where CPU is one of:\n"
argument_list|)
argument_list|)
expr_stmt|;
name|first
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|mips_cpu_info_table
index|[
name|i
index|]
operator|.
name|name
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
name|show
argument_list|(
name|stream
argument_list|,
name|mips_cpu_info_table
index|[
name|i
index|]
operator|.
name|name
argument_list|,
operator|&
name|column
argument_list|,
operator|&
name|first
argument_list|)
expr_stmt|;
name|show
argument_list|(
name|stream
argument_list|,
literal|"from-abi"
argument_list|,
operator|&
name|column
argument_list|,
operator|&
name|first
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"\ -mCPU			equivalent to -march=CPU -mtune=CPU. Deprecated.\n\ -no-mCPU		don't generate code specific to CPU.\n\ 			For -mCPU and -no-mCPU, CPU must be one of:\n"
argument_list|)
argument_list|)
expr_stmt|;
name|first
operator|=
literal|1
expr_stmt|;
name|show
argument_list|(
name|stream
argument_list|,
literal|"3900"
argument_list|,
operator|&
name|column
argument_list|,
operator|&
name|first
argument_list|)
expr_stmt|;
name|show
argument_list|(
name|stream
argument_list|,
literal|"4010"
argument_list|,
operator|&
name|column
argument_list|,
operator|&
name|first
argument_list|)
expr_stmt|;
name|show
argument_list|(
name|stream
argument_list|,
literal|"4100"
argument_list|,
operator|&
name|column
argument_list|,
operator|&
name|first
argument_list|)
expr_stmt|;
name|show
argument_list|(
name|stream
argument_list|,
literal|"4650"
argument_list|,
operator|&
name|column
argument_list|,
operator|&
name|first
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"\ -mips16			generate mips16 instructions\n\ -no-mips16		do not generate mips16 instructions\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"\ -msmartmips		generate smartmips instructions\n\ -mno-smartmips		do not generate smartmips instructions\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"\ -mdsp			generate DSP instructions\n\ -mno-dsp		do not generate DSP instructions\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"\ -mdspr2			generate DSP R2 instructions\n\ -mno-dspr2		do not generate DSP R2 instructions\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"\ -mmt			generate MT instructions\n\ -mno-mt			do not generate MT instructions\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"\ -mfix-vr4120		work around certain VR4120 errata\n\ -mfix-vr4130		work around VR4130 mflo/mfhi errata\n\ -mgp32			use 32-bit GPRs, regardless of the chosen ISA\n\ -mfp32			use 32-bit FPRs, regardless of the chosen ISA\n\ -msym32			assume all symbols have 32-bit values\n\ -O0			remove unneeded NOPs, do not swap branches\n\ -O			remove unneeded NOPs and swap branches\n\ --[no-]construct-floats [dis]allow floating point values to be constructed\n\ --trap, --no-break	trap exception on div by 0 and mult overflow\n\ --break, --no-trap	break exception on div by 0 and mult overflow\n"
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|OBJ_ELF
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"\ -KPIC, -call_shared	generate SVR4 position independent code\n\ -mvxworks-pic		generate VxWorks position independent code\n\ -non_shared		do not generate position independent code\n\ -xgot			assume a 32 bit GOT\n\ -mpdr, -mno-pdr		enable/disable creation of .pdr sections\n\ -mshared, -mno-shared   disable/enable .cpload optimization for\n\                         position dependent (non shared) code\n\ -mabi=ABI		create ABI conformant object file for:\n"
argument_list|)
argument_list|)
expr_stmt|;
name|first
operator|=
literal|1
expr_stmt|;
name|show
argument_list|(
name|stream
argument_list|,
literal|"32"
argument_list|,
operator|&
name|column
argument_list|,
operator|&
name|first
argument_list|)
expr_stmt|;
name|show
argument_list|(
name|stream
argument_list|,
literal|"o64"
argument_list|,
operator|&
name|column
argument_list|,
operator|&
name|first
argument_list|)
expr_stmt|;
name|show
argument_list|(
name|stream
argument_list|,
literal|"n32"
argument_list|,
operator|&
name|column
argument_list|,
operator|&
name|first
argument_list|)
expr_stmt|;
name|show
argument_list|(
name|stream
argument_list|,
literal|"64"
argument_list|,
operator|&
name|column
argument_list|,
operator|&
name|first
argument_list|)
expr_stmt|;
name|show
argument_list|(
name|stream
argument_list|,
literal|"eabi"
argument_list|,
operator|&
name|column
argument_list|,
operator|&
name|first
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"\ -32			create o32 ABI object file (default)\n\ -n32			create n32 ABI object file\n\ -64			create 64 ABI object file\n"
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"\ -mocteon-unsupported    error on unsupported Octeon instructions\n\ -mno-octeon-unsupported do not error on unsupported Octeon instructions\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"\ -mocteon-useun    generate Octeon unaligned load/store instructions\n\ -mno-octeon-useun generate MIPS unaligned load/store instructions\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|mips_dwarf2_addr_size
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|HAVE_64BIT_SYMBOLS
condition|)
return|return
literal|8
return|;
else|else
return|return
literal|4
return|;
block|}
end_function

begin_comment
comment|/* Standard calling conventions leave the CFA at SP on entry.  */
end_comment

begin_function
name|void
name|mips_cfi_frame_initial_instructions
parameter_list|(
name|void
parameter_list|)
block|{
name|cfi_add_CFA_def_cfa_register
argument_list|(
name|SP
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|tc_mips_regname_to_dw2regnum
parameter_list|(
name|char
modifier|*
name|regname
parameter_list|)
block|{
name|unsigned
name|int
name|regnum
init|=
operator|-
literal|1
decl_stmt|;
name|unsigned
name|int
name|reg
decl_stmt|;
if|if
condition|(
name|reg_lookup
argument_list|(
operator|&
name|regname
argument_list|,
name|RTYPE_GP
operator||
name|RTYPE_NUM
argument_list|,
operator|&
name|reg
argument_list|)
condition|)
name|regnum
operator|=
name|reg
expr_stmt|;
return|return
name|regnum
return|;
block|}
end_function

end_unit

