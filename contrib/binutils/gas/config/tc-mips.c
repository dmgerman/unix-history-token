begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* tc-mips.c -- assemble code for a MIPS chip.    Copyright 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,    2003, 2004 Free Software Foundation, Inc.    Contributed by the OSF and Ralph Campbell.    Written by Keith Knowles and Ralph Campbell, working independently.    Modified for ECOFF and R4000 support by Ian Lance Taylor of Cygnus    Support.     This file is part of GAS.     GAS is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     GAS is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with GAS; see the file COPYING.  If not, write to the Free    Software Foundation, 59 Temple Place - Suite 330, Boston, MA    02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"as.h"
end_include

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"subsegs.h"
end_include

begin_include
include|#
directive|include
file|"safe-ctype.h"
end_include

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_include
include|#
directive|include
file|"opcode/mips.h"
end_include

begin_include
include|#
directive|include
file|"itbl-ops.h"
end_include

begin_include
include|#
directive|include
file|"dwarf2dbg.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_define
define|#
directive|define
name|DBG
parameter_list|(
name|x
parameter_list|)
value|printf x
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|DBG
parameter_list|(
name|x
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|OBJ_MAYBE_ELF
end_ifdef

begin_comment
comment|/* Clean up namespace so we can include obj-elf.h too.  */
end_comment

begin_function_decl
specifier|static
name|int
name|mips_output_flavor
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|int
name|mips_output_flavor
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|OUTPUT_FLAVOR
return|;
block|}
end_function

begin_undef
undef|#
directive|undef
name|OBJ_PROCESS_STAB
end_undef

begin_undef
undef|#
directive|undef
name|OUTPUT_FLAVOR
end_undef

begin_undef
undef|#
directive|undef
name|S_GET_ALIGN
end_undef

begin_undef
undef|#
directive|undef
name|S_GET_SIZE
end_undef

begin_undef
undef|#
directive|undef
name|S_SET_ALIGN
end_undef

begin_undef
undef|#
directive|undef
name|S_SET_SIZE
end_undef

begin_undef
undef|#
directive|undef
name|obj_frob_file
end_undef

begin_undef
undef|#
directive|undef
name|obj_frob_file_after_relocs
end_undef

begin_undef
undef|#
directive|undef
name|obj_frob_symbol
end_undef

begin_undef
undef|#
directive|undef
name|obj_pop_insert
end_undef

begin_undef
undef|#
directive|undef
name|obj_sec_sym_ok_for_reloc
end_undef

begin_undef
undef|#
directive|undef
name|OBJ_COPY_SYMBOL_ATTRIBUTES
end_undef

begin_include
include|#
directive|include
file|"obj-elf.h"
end_include

begin_comment
comment|/* Fix any of them that we actually care about.  */
end_comment

begin_undef
undef|#
directive|undef
name|OUTPUT_FLAVOR
end_undef

begin_define
define|#
directive|define
name|OUTPUT_FLAVOR
value|mips_output_flavor()
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|OBJ_ELF
argument_list|)
end_if

begin_include
include|#
directive|include
file|"elf/mips.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|ECOFF_DEBUGGING
end_ifndef

begin_define
define|#
directive|define
name|NO_ECOFF_DEBUGGING
end_define

begin_define
define|#
directive|define
name|ECOFF_DEBUGGING
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|int
name|mips_flag_mdebug
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Control generation of .pdr sections.  Off by default on IRIX: the native    linker doesn't know about and discards them, but relocations against them    remain, leading to rld crashes.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|TE_IRIX
end_ifdef

begin_decl_stmt
name|int
name|mips_flag_pdr
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
name|int
name|mips_flag_pdr
init|=
name|TRUE
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"ecoff.h"
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|OBJ_ELF
argument_list|)
operator|||
name|defined
argument_list|(
name|OBJ_MAYBE_ELF
argument_list|)
end_if

begin_decl_stmt
specifier|static
name|char
modifier|*
name|mips_regmask_frag
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|ZERO
value|0
end_define

begin_define
define|#
directive|define
name|AT
value|1
end_define

begin_define
define|#
directive|define
name|TREG
value|24
end_define

begin_define
define|#
directive|define
name|PIC_CALL_REG
value|25
end_define

begin_define
define|#
directive|define
name|KT0
value|26
end_define

begin_define
define|#
directive|define
name|KT1
value|27
end_define

begin_define
define|#
directive|define
name|GP
value|28
end_define

begin_define
define|#
directive|define
name|SP
value|29
end_define

begin_define
define|#
directive|define
name|FP
value|30
end_define

begin_define
define|#
directive|define
name|RA
value|31
end_define

begin_define
define|#
directive|define
name|ILLEGAL_REG
value|(32)
end_define

begin_comment
comment|/* Allow override of standard little-endian ECOFF format.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|ECOFF_LITTLE_FORMAT
end_ifndef

begin_define
define|#
directive|define
name|ECOFF_LITTLE_FORMAT
value|"ecoff-littlemips"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|extern
name|int
name|target_big_endian
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The name of the readonly data section.  */
end_comment

begin_define
define|#
directive|define
name|RDATA_SECTION_NAME
value|(OUTPUT_FLAVOR == bfd_target_aout_flavour \ 			    ? ".data" \ 			    : OUTPUT_FLAVOR == bfd_target_ecoff_flavour \ 			    ? ".rdata" \ 			    : OUTPUT_FLAVOR == bfd_target_coff_flavour \ 			    ? ".rdata" \ 			    : OUTPUT_FLAVOR == bfd_target_elf_flavour \ 			    ? ".rodata" \ 			    : (abort (), ""))
end_define

begin_comment
comment|/* The ABI to use.  */
end_comment

begin_enum
enum|enum
name|mips_abi_level
block|{
name|NO_ABI
init|=
literal|0
block|,
name|O32_ABI
block|,
name|O64_ABI
block|,
name|N32_ABI
block|,
name|N64_ABI
block|,
name|EABI_ABI
block|}
enum|;
end_enum

begin_comment
comment|/* MIPS ABI we are using for this output file.  */
end_comment

begin_decl_stmt
specifier|static
name|enum
name|mips_abi_level
name|mips_abi
init|=
name|NO_ABI
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Whether or not we have code that can call pic code.  */
end_comment

begin_decl_stmt
name|int
name|mips_abicalls
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This is the set of options which may be modified by the .set    pseudo-op.  We use a struct so that .set push and .set pop are more    reliable.  */
end_comment

begin_struct
struct|struct
name|mips_set_options
block|{
comment|/* MIPS ISA (Instruction Set Architecture) level.  This is set to -1      if it has not been initialized.  Changed by `.set mipsN', and the      -mipsN command line option, and the default CPU.  */
name|int
name|isa
decl_stmt|;
comment|/* Enabled Application Specific Extensions (ASEs).  These are set to -1      if they have not been initialized.  Changed by `.set<asename>', by      command line options, and based on the default architecture.  */
name|int
name|ase_mips3d
decl_stmt|;
name|int
name|ase_mdmx
decl_stmt|;
comment|/* Whether we are assembling for the mips16 processor.  0 if we are      not, 1 if we are, and -1 if the value has not been initialized.      Changed by `.set mips16' and `.set nomips16', and the -mips16 and      -nomips16 command line options, and the default CPU.  */
name|int
name|mips16
decl_stmt|;
comment|/* Non-zero if we should not reorder instructions.  Changed by `.set      reorder' and `.set noreorder'.  */
name|int
name|noreorder
decl_stmt|;
comment|/* Non-zero if we should not permit the $at ($1) register to be used      in instructions.  Changed by `.set at' and `.set noat'.  */
name|int
name|noat
decl_stmt|;
comment|/* Non-zero if we should warn when a macro instruction expands into      more than one machine instruction.  Changed by `.set nomacro' and      `.set macro'.  */
name|int
name|warn_about_macros
decl_stmt|;
comment|/* Non-zero if we should not move instructions.  Changed by `.set      move', `.set volatile', `.set nomove', and `.set novolatile'.  */
name|int
name|nomove
decl_stmt|;
comment|/* Non-zero if we should not optimize branches by moving the target      of the branch into the delay slot.  Actually, we don't perform      this optimization anyhow.  Changed by `.set bopt' and `.set      nobopt'.  */
name|int
name|nobopt
decl_stmt|;
comment|/* Non-zero if we should not autoextend mips16 instructions.      Changed by `.set autoextend' and `.set noautoextend'.  */
name|int
name|noautoextend
decl_stmt|;
comment|/* Restrict general purpose registers and floating point registers      to 32 bit.  This is initially determined when -mgp32 or -mfp32      is passed but can changed if the assembler code uses .set mipsN.  */
name|int
name|gp32
decl_stmt|;
name|int
name|fp32
decl_stmt|;
comment|/* MIPS architecture (CPU) type.  Changed by .set arch=FOO, the -march      command line option, and the default CPU.  */
name|int
name|arch
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* True if -mgp32 was passed.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|file_mips_gp32
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* True if -mfp32 was passed.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|file_mips_fp32
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This is the struct we use to hold the current set of options.  Note    that we must set the isa field to ISA_UNKNOWN and the ASE fields to    -1 to indicate that they have not been initialized.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|mips_set_options
name|mips_opts
init|=
block|{
name|ISA_UNKNOWN
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|CPU_UNKNOWN
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* These variables are filled in with the masks of registers used.    The object format code reads them and puts them in the appropriate    place.  */
end_comment

begin_decl_stmt
name|unsigned
name|long
name|mips_gprmask
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|long
name|mips_cprmask
index|[
literal|4
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* MIPS ISA we are using for this output file.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|file_mips_isa
init|=
name|ISA_UNKNOWN
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* True if -mips16 was passed or implied by arguments passed on the    command line (e.g., by -march).  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|file_ase_mips16
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* True if -mips3d was passed or implied by arguments passed on the    command line (e.g., by -march).  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|file_ase_mips3d
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* True if -mdmx was passed or implied by arguments passed on the    command line (e.g., by -march).  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|file_ase_mdmx
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The argument of the -march= flag.  The architecture we are assembling.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|file_mips_arch
init|=
name|CPU_UNKNOWN
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|mips_arch_string
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The argument of the -mtune= flag.  The architecture for which we    are optimizing.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|mips_tune
init|=
name|CPU_UNKNOWN
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|mips_tune_string
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* True when generating 32-bit code for a 64-bit processor.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|mips_32bitmode
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* True if the given ABI requires 32-bit registers.  */
end_comment

begin_define
define|#
directive|define
name|ABI_NEEDS_32BIT_REGS
parameter_list|(
name|ABI
parameter_list|)
value|((ABI) == O32_ABI)
end_define

begin_comment
comment|/* Likewise 64-bit registers.  */
end_comment

begin_define
define|#
directive|define
name|ABI_NEEDS_64BIT_REGS
parameter_list|(
name|ABI
parameter_list|)
define|\
value|((ABI) == N32_ABI 		  \    || (ABI) == N64_ABI		  \    || (ABI) == O64_ABI)
end_define

begin_comment
comment|/*  Return true if ISA supports 64 bit gp register instructions.  */
end_comment

begin_define
define|#
directive|define
name|ISA_HAS_64BIT_REGS
parameter_list|(
name|ISA
parameter_list|)
value|(    \    (ISA) == ISA_MIPS3                \    || (ISA) == ISA_MIPS4             \    || (ISA) == ISA_MIPS5             \    || (ISA) == ISA_MIPS64            \    || (ISA) == ISA_MIPS64R2          \    )
end_define

begin_comment
comment|/* Return true if ISA supports 64-bit right rotate (dror et al.)    instructions.  */
end_comment

begin_define
define|#
directive|define
name|ISA_HAS_DROR
parameter_list|(
name|ISA
parameter_list|)
value|(	\    (ISA) == ISA_MIPS64R2	\    )
end_define

begin_comment
comment|/* Return true if ISA supports 32-bit right rotate (ror et al.)    instructions.  */
end_comment

begin_define
define|#
directive|define
name|ISA_HAS_ROR
parameter_list|(
name|ISA
parameter_list|)
value|(	\    (ISA) == ISA_MIPS32R2	\    || (ISA) == ISA_MIPS64R2	\    )
end_define

begin_define
define|#
directive|define
name|HAVE_32BIT_GPRS
define|\
value|(mips_opts.gp32 || ! ISA_HAS_64BIT_REGS (mips_opts.isa))
end_define

begin_define
define|#
directive|define
name|HAVE_32BIT_FPRS
define|\
value|(mips_opts.fp32 || ! ISA_HAS_64BIT_REGS (mips_opts.isa))
end_define

begin_define
define|#
directive|define
name|HAVE_64BIT_GPRS
value|(! HAVE_32BIT_GPRS)
end_define

begin_define
define|#
directive|define
name|HAVE_64BIT_FPRS
value|(! HAVE_32BIT_FPRS)
end_define

begin_define
define|#
directive|define
name|HAVE_NEWABI
value|(mips_abi == N32_ABI || mips_abi == N64_ABI)
end_define

begin_define
define|#
directive|define
name|HAVE_64BIT_OBJECTS
value|(mips_abi == N64_ABI)
end_define

begin_comment
comment|/* We can only have 64bit addresses if the object file format    supports it.  */
end_comment

begin_define
define|#
directive|define
name|HAVE_32BIT_ADDRESSES
define|\
value|(HAVE_32BIT_GPRS                                    \     || ((bfd_arch_bits_per_address (stdoutput) == 32   \          || ! HAVE_64BIT_OBJECTS)                      \&& mips_pic != EMBEDDED_PIC))
end_define

begin_define
define|#
directive|define
name|HAVE_64BIT_ADDRESSES
value|(! HAVE_32BIT_ADDRESSES)
end_define

begin_comment
comment|/* Addresses are loaded in different ways, depending on the address size    in use.  The n32 ABI Documentation also mandates the use of additions    with overflow checking, but existing implementations don't follow it.  */
end_comment

begin_define
define|#
directive|define
name|ADDRESS_ADD_INSN
define|\
value|(HAVE_32BIT_ADDRESSES ? "addu" : "daddu")
end_define

begin_define
define|#
directive|define
name|ADDRESS_ADDI_INSN
define|\
value|(HAVE_32BIT_ADDRESSES ? "addiu" : "daddiu")
end_define

begin_define
define|#
directive|define
name|ADDRESS_LOAD_INSN
define|\
value|(HAVE_32BIT_ADDRESSES ? "lw" : "ld")
end_define

begin_define
define|#
directive|define
name|ADDRESS_STORE_INSN
define|\
value|(HAVE_32BIT_ADDRESSES ? "sw" : "sd")
end_define

begin_comment
comment|/* Return true if the given CPU supports the MIPS16 ASE.  */
end_comment

begin_define
define|#
directive|define
name|CPU_HAS_MIPS16
parameter_list|(
name|cpu
parameter_list|)
define|\
value|(strncmp (TARGET_CPU, "mips16", sizeof ("mips16") - 1) == 0		\     || strncmp (TARGET_CANONICAL, "mips-lsi-elf", sizeof ("mips-lsi-elf") - 1) == 0)
end_define

begin_comment
comment|/* Return true if the given CPU supports the MIPS3D ASE.  */
end_comment

begin_define
define|#
directive|define
name|CPU_HAS_MIPS3D
parameter_list|(
name|cpu
parameter_list|)
value|((cpu) == CPU_SB1      \ 				 )
end_define

begin_comment
comment|/* Return true if the given CPU supports the MDMX ASE.  */
end_comment

begin_define
define|#
directive|define
name|CPU_HAS_MDMX
parameter_list|(
name|cpu
parameter_list|)
value|(FALSE                 \ 				 )
end_define

begin_comment
comment|/* True if CPU has a dror instruction.  */
end_comment

begin_define
define|#
directive|define
name|CPU_HAS_DROR
parameter_list|(
name|CPU
parameter_list|)
value|((CPU) == CPU_VR5400 || (CPU) == CPU_VR5500)
end_define

begin_comment
comment|/* True if CPU has a ror instruction.  */
end_comment

begin_define
define|#
directive|define
name|CPU_HAS_ROR
parameter_list|(
name|CPU
parameter_list|)
value|CPU_HAS_DROR (CPU)
end_define

begin_comment
comment|/* True if mflo and mfhi can be immediately followed by instructions    which write to the HI and LO registers.     According to MIPS specifications, MIPS ISAs I, II, and III need    (at least) two instructions between the reads of HI/LO and    instructions which write them, and later ISAs do not.  Contradicting    the MIPS specifications, some MIPS IV processor user manuals (e.g.    the UM for the NEC Vr5000) document needing the instructions between    HI/LO reads and writes, as well.  Therefore, we declare only MIPS32,    MIPS64 and later ISAs to have the interlocks, plus any specific    earlier-ISA CPUs for which CPU documentation declares that the    instructions are really interlocked.  */
end_comment

begin_define
define|#
directive|define
name|hilo_interlocks
define|\
value|(mips_opts.isa == ISA_MIPS32                        \    || mips_opts.isa == ISA_MIPS32R2                   \    || mips_opts.isa == ISA_MIPS64                     \    || mips_opts.isa == ISA_MIPS64R2                   \    || mips_opts.arch == CPU_R4010                     \    || mips_opts.arch == CPU_R10000                    \    || mips_opts.arch == CPU_R12000                    \    || mips_opts.arch == CPU_RM7000                    \    || mips_opts.arch == CPU_SB1                       \    || mips_opts.arch == CPU_VR5500                    \    )
end_define

begin_comment
comment|/* Whether the processor uses hardware interlocks to protect reads    from the GPRs after they are loaded from memory, and thus does not    require nops to be inserted.  This applies to instructions marked    INSN_LOAD_MEMORY_DELAY.  These nops are only required at MIPS ISA    level I.  */
end_comment

begin_define
define|#
directive|define
name|gpr_interlocks
define|\
value|(mips_opts.isa != ISA_MIPS1  \    || mips_opts.arch == CPU_VR5400  \    || mips_opts.arch == CPU_VR5500  \    || mips_opts.arch == CPU_R3900)
end_define

begin_comment
comment|/* Whether the processor uses hardware interlocks to avoid delays    required by coprocessor instructions, and thus does not require    nops to be inserted.  This applies to instructions marked    INSN_LOAD_COPROC_DELAY, INSN_COPROC_MOVE_DELAY, and to delays    between instructions marked INSN_WRITE_COND_CODE and ones marked    INSN_READ_COND_CODE.  These nops are only required at MIPS ISA    levels I, II, and III.  */
end_comment

begin_comment
comment|/* Itbl support may require additional care here.  */
end_comment

begin_define
define|#
directive|define
name|cop_interlocks
define|\
value|((mips_opts.isa != ISA_MIPS1                        \&& mips_opts.isa != ISA_MIPS2                     \&& mips_opts.isa != ISA_MIPS3)                    \    || mips_opts.arch == CPU_R4300                     \    || mips_opts.arch == CPU_VR5400                    \    || mips_opts.arch == CPU_VR5500                    \    || mips_opts.arch == CPU_SB1                       \    )
end_define

begin_comment
comment|/* Whether the processor uses hardware interlocks to protect reads    from coprocessor registers after they are loaded from memory, and    thus does not require nops to be inserted.  This applies to    instructions marked INSN_COPROC_MEMORY_DELAY.  These nops are only    requires at MIPS ISA level I.  */
end_comment

begin_define
define|#
directive|define
name|cop_mem_interlocks
value|(mips_opts.isa != ISA_MIPS1)
end_define

begin_comment
comment|/* Is this a mfhi or mflo instruction?  */
end_comment

begin_define
define|#
directive|define
name|MF_HILO_INSN
parameter_list|(
name|PINFO
parameter_list|)
define|\
value|((PINFO& INSN_READ_HI) || (PINFO& INSN_READ_LO))
end_define

begin_comment
comment|/* MIPS PIC level.  */
end_comment

begin_decl_stmt
name|enum
name|mips_pic_level
name|mips_pic
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 1 if we should generate 32 bit offsets from the $gp register in    SVR4_PIC mode.  Currently has no meaning in other modes.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|mips_big_got
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 1 if trap instructions should used for overflow rather than break    instructions.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|mips_trap
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 1 if double width floating point constants should not be constructed    by assembling two single width halves into two single width floating    point registers which just happen to alias the double width destination    register.  On some architectures this aliasing can be disabled by a bit    in the status register, and the setting of this bit cannot be determined    automatically at assemble time.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|mips_disable_float_construction
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero if any .set noreorder directives were used.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|mips_any_noreorder
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero if nops should be inserted when the register referenced in    an mfhi/mflo instruction is read in the next two instructions.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|mips_7000_hilo_fix
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The size of the small data section.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|g_switch_value
init|=
literal|8
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Whether the -G option was used.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|g_switch_seen
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|N_RMASK
value|0xc4
end_define

begin_define
define|#
directive|define
name|N_VFP
value|0xd4
end_define

begin_comment
comment|/* If we can determine in advance that GP optimization won't be    possible, we can skip the relaxation stuff that tries to produce    GP-relative references.  This makes delay slot optimization work    better.     This function can only provide a guess, but it seems to work for    gcc output.  It needs to guess right for gcc, otherwise gcc    will put what it thinks is a GP-relative instruction in a branch    delay slot.     I don't know if a fix is needed for the SVR4_PIC mode.  I've only    fixed it for the non-PIC mode.  KR 95/04/07  */
end_comment

begin_function_decl
specifier|static
name|int
name|nopic_need_relax
parameter_list|(
name|symbolS
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* handle of the OPCODE hash table */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|hash_control
modifier|*
name|op_hash
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The opcode hash table we use for the mips16.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|hash_control
modifier|*
name|mips16_op_hash
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This array holds the chars that always start a comment.  If the     pre-processor is disabled, these aren't very useful */
end_comment

begin_decl_stmt
specifier|const
name|char
name|comment_chars
index|[]
init|=
literal|"#"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This array holds the chars that only start a comment at the beginning of    a line.  If the line seems to have the form '# 123 filename'    .line and .file directives will appear in the pre-processed output */
end_comment

begin_comment
comment|/* Note that input_file.c hand checks for '#' at the beginning of the    first line of the input file.  This is because the compiler outputs    #NO_APP at the beginning of its output.  */
end_comment

begin_comment
comment|/* Also note that C style comments are always supported.  */
end_comment

begin_decl_stmt
specifier|const
name|char
name|line_comment_chars
index|[]
init|=
literal|"#"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This array holds machine specific line separator characters.  */
end_comment

begin_decl_stmt
specifier|const
name|char
name|line_separator_chars
index|[]
init|=
literal|";"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Chars that can be used to separate mant from exp in floating point nums */
end_comment

begin_decl_stmt
specifier|const
name|char
name|EXP_CHARS
index|[]
init|=
literal|"eE"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Chars that mean this number is a floating point constant */
end_comment

begin_comment
comment|/* As in 0f12.456 */
end_comment

begin_comment
comment|/* or    0d1.2345e12 */
end_comment

begin_decl_stmt
specifier|const
name|char
name|FLT_CHARS
index|[]
init|=
literal|"rRsSfFdDxXpP"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Also be aware that MAXIMUM_NUMBER_OF_CHARS_FOR_FLOAT may have to be    changed in read.c .  Ideally it shouldn't have to know about it at all,    but nothing is ideal around here.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|insn_error
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|auto_align
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* When outputting SVR4 PIC code, the assembler needs to know the    offset in the stack frame from which to restore the $gp register.    This is set by the .cprestore pseudo-op, and saved in this    variable.  */
end_comment

begin_decl_stmt
specifier|static
name|offsetT
name|mips_cprestore_offset
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Similar for NewABI PIC code, where $gp is callee-saved.  NewABI has some    more optimizations, it can use a register value instead of a memory-saved    offset and even an other register than $gp as global pointer.  */
end_comment

begin_decl_stmt
specifier|static
name|offsetT
name|mips_cpreturn_offset
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|mips_cpreturn_register
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|mips_gp_register
init|=
name|GP
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|mips_gprel_offset
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Whether mips_cprestore_offset has been set in the current function    (or whether it has already been warned about, if not).  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|mips_cprestore_valid
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This is the register which holds the stack frame, as set by the    .frame pseudo-op.  This is needed to implement .cprestore.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|mips_frame_reg
init|=
name|SP
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Whether mips_frame_reg has been set in the current function    (or whether it has already been warned about, if not).  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|mips_frame_reg_valid
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* To output NOP instructions correctly, we need to keep information    about the previous two instructions.  */
end_comment

begin_comment
comment|/* Whether we are optimizing.  The default value of 2 means to remove    unneeded NOPs and swap branch instructions when possible.  A value    of 1 means to not swap branches.  A value of 0 means to always    insert NOPs.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|mips_optimize
init|=
literal|2
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Debugging level.  -g sets this to 2.  -gN sets this to N.  -g0 is    equivalent to seeing no -g option at all.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|mips_debug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The previous instruction.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|mips_cl_insn
name|prev_insn
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The instruction before prev_insn.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|mips_cl_insn
name|prev_prev_insn
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If we don't want information for prev_insn or prev_prev_insn, we    point the insn_mo field at this dummy integer.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|mips_opcode
name|dummy_opcode
init|=
block|{
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero if prev_insn is valid.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|prev_insn_valid
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The frag for the previous instruction.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|frag
modifier|*
name|prev_insn_frag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The offset into prev_insn_frag for the previous instruction.  */
end_comment

begin_decl_stmt
specifier|static
name|long
name|prev_insn_where
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The reloc type for the previous instruction, if any.  */
end_comment

begin_decl_stmt
specifier|static
name|bfd_reloc_code_real_type
name|prev_insn_reloc_type
index|[
literal|3
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The reloc for the previous instruction, if any.  */
end_comment

begin_decl_stmt
specifier|static
name|fixS
modifier|*
name|prev_insn_fixp
index|[
literal|3
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero if the previous instruction was in a delay slot.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|prev_insn_is_delay_slot
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero if the previous instruction was in a .set noreorder.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|prev_insn_unreordered
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero if the previous instruction uses an extend opcode (if    mips16).  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|prev_insn_extended
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero if the previous previous instruction was in a .set    noreorder.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|prev_prev_insn_unreordered
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If this is set, it points to a frag holding nop instructions which    were inserted before the start of a noreorder section.  If those    nops turn out to be unnecessary, the size of the frag can be    decreased.  */
end_comment

begin_decl_stmt
specifier|static
name|fragS
modifier|*
name|prev_nop_frag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The number of nop instructions we created in prev_nop_frag.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|prev_nop_frag_holds
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The number of nop instructions that we know we need in    prev_nop_frag.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|prev_nop_frag_required
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The number of instructions we've seen since prev_nop_frag.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|prev_nop_frag_since
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* For ECOFF and ELF, relocations against symbols are done in two    parts, with a HI relocation and a LO relocation.  Each relocation    has only 16 bits of space to store an addend.  This means that in    order for the linker to handle carries correctly, it must be able    to locate both the HI and the LO relocation.  This means that the    relocations must appear in order in the relocation table.     In order to implement this, we keep track of each unmatched HI    relocation.  We then sort them so that they immediately precede the    corresponding LO relocation.  */
end_comment

begin_struct
struct|struct
name|mips_hi_fixup
block|{
comment|/* Next HI fixup.  */
name|struct
name|mips_hi_fixup
modifier|*
name|next
decl_stmt|;
comment|/* This fixup.  */
name|fixS
modifier|*
name|fixp
decl_stmt|;
comment|/* The section this fixup is in.  */
name|segT
name|seg
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* The list of unmatched HI relocs.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|mips_hi_fixup
modifier|*
name|mips_hi_fixup_list
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The frag containing the last explicit relocation operator.    Null if explicit relocations have not been used.  */
end_comment

begin_decl_stmt
specifier|static
name|fragS
modifier|*
name|prev_reloc_op_frag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Map normal MIPS register numbers to mips16 register numbers.  */
end_comment

begin_define
define|#
directive|define
name|X
value|ILLEGAL_REG
end_define

begin_decl_stmt
specifier|static
specifier|const
name|int
name|mips32_to_16_reg_map
index|[]
init|=
block|{
name|X
block|,
name|X
block|,
literal|2
block|,
literal|3
block|,
literal|4
block|,
literal|5
block|,
literal|6
block|,
literal|7
block|,
name|X
block|,
name|X
block|,
name|X
block|,
name|X
block|,
name|X
block|,
name|X
block|,
name|X
block|,
name|X
block|,
literal|0
block|,
literal|1
block|,
name|X
block|,
name|X
block|,
name|X
block|,
name|X
block|,
name|X
block|,
name|X
block|,
name|X
block|,
name|X
block|,
name|X
block|,
name|X
block|,
name|X
block|,
name|X
block|,
name|X
block|,
name|X
block|}
decl_stmt|;
end_decl_stmt

begin_undef
undef|#
directive|undef
name|X
end_undef

begin_comment
comment|/* Map mips16 register numbers to normal MIPS register numbers.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|unsigned
name|int
name|mips16_to_32_reg_map
index|[]
init|=
block|{
literal|16
block|,
literal|17
block|,
literal|2
block|,
literal|3
block|,
literal|4
block|,
literal|5
block|,
literal|6
block|,
literal|7
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|mips_fix_vr4120
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* We don't relax branches by default, since this causes us to expand    `la .l2 - .l1' if there's a branch between .l1 and .l2, because we    fail to compute the offset before expanding the macro to the most    efficient expansion.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|mips_relax_branch
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* The expansion of many macros depends on the type of symbol that    they refer to.  For example, when generating position-dependent code,    a macro that refers to a symbol may have two different expansions,    one which uses GP-relative addresses and one which uses absolute    addresses.  When generating SVR4-style PIC, a macro may have    different expansions for local and global symbols.     We handle these situations by generating both sequences and putting    them in variant frags.  In position-dependent code, the first sequence    will be the GP-relative one and the second sequence will be the    absolute one.  In SVR4 PIC, the first sequence will be for global    symbols and the second will be for local symbols.     The frag's "subtype" is RELAX_ENCODE (FIRST, SECOND), where FIRST and    SECOND are the lengths of the two sequences in bytes.  These fields    can be extracted using RELAX_FIRST() and RELAX_SECOND().  In addition,    the subtype has the following flags:     RELAX_USE_SECOND 	Set if it has been decided that we should use the second 	sequence instead of the first.     RELAX_SECOND_LONGER 	Set in the first variant frag if the macro's second implementation 	is longer than its first.  This refers to the macro as a whole, 	not an individual relaxation.     RELAX_NOMACRO 	Set in the first variant frag if the macro appeared in a .set nomacro 	block and if one alternative requires a warning but the other does not.     RELAX_DELAY_SLOT 	Like RELAX_NOMACRO, but indicates that the macro appears in a branch 	delay slot.     The frag's "opcode" points to the first fixup for relaxable code.     Relaxable macros are generated using a sequence such as:        relax_start (SYMBOL);       ... generate first expansion ...       relax_switch ();       ... generate second expansion ...       relax_end ();     The code and fixups for the unwanted alternative are discarded    by md_convert_frag.  */
end_comment

begin_define
define|#
directive|define
name|RELAX_ENCODE
parameter_list|(
name|FIRST
parameter_list|,
name|SECOND
parameter_list|)
value|(((FIRST)<< 8) | (SECOND))
end_define

begin_define
define|#
directive|define
name|RELAX_FIRST
parameter_list|(
name|X
parameter_list|)
value|(((X)>> 8)& 0xff)
end_define

begin_define
define|#
directive|define
name|RELAX_SECOND
parameter_list|(
name|X
parameter_list|)
value|((X)& 0xff)
end_define

begin_define
define|#
directive|define
name|RELAX_USE_SECOND
value|0x10000
end_define

begin_define
define|#
directive|define
name|RELAX_SECOND_LONGER
value|0x20000
end_define

begin_define
define|#
directive|define
name|RELAX_NOMACRO
value|0x40000
end_define

begin_define
define|#
directive|define
name|RELAX_DELAY_SLOT
value|0x80000
end_define

begin_comment
comment|/* Branch without likely bit.  If label is out of range, we turn:   	beq reg1, reg2, label 	delay slot     into          bne reg1, reg2, 0f         nop         j label      0: delay slot     with the following opcode replacements:  	beq<-> bne 	blez<-> bgtz 	bltz<-> bgez 	bc1f<-> bc1t  	bltzal<-> bgezal  (with jal label instead of j label)     Even though keeping the delay slot instruction in the delay slot of    the branch would be more efficient, it would be very tricky to do    correctly, because we'd have to introduce a variable frag *after*    the delay slot instruction, and expand that instead.  Let's do it    the easy way for now, even if the branch-not-taken case now costs    one additional instruction.  Out-of-range branches are not supposed    to be common, anyway.     Branch likely.  If label is out of range, we turn:  	beql reg1, reg2, label 	delay slot (annulled if branch not taken)     into          beql reg1, reg2, 1f         nop         beql $0, $0, 2f         nop      1: j[al] label         delay slot (executed only if branch taken)      2:     It would be possible to generate a shorter sequence by losing the    likely bit, generating something like:  	bne reg1, reg2, 0f 	nop 	j[al] label 	delay slot (executed only if branch taken)      0:  	beql -> bne 	bnel -> beq 	blezl -> bgtz 	bgtzl -> blez 	bltzl -> bgez 	bgezl -> bltz 	bc1fl -> bc1t 	bc1tl -> bc1f  	bltzall -> bgezal  (with jal label instead of j label) 	bgezall -> bltzal  (ditto)      but it's not clear that it would actually improve performance.  */
end_comment

begin_define
define|#
directive|define
name|RELAX_BRANCH_ENCODE
parameter_list|(
name|uncond
parameter_list|,
name|likely
parameter_list|,
name|link
parameter_list|,
name|toofar
parameter_list|)
define|\
value|((relax_substateT) \    (0xc0000000 \     | ((toofar) ? 1 : 0) \     | ((link) ? 2 : 0) \     | ((likely) ? 4 : 0) \     | ((uncond) ? 8 : 0)))
end_define

begin_define
define|#
directive|define
name|RELAX_BRANCH_P
parameter_list|(
name|i
parameter_list|)
value|(((i)& 0xf0000000) == 0xc0000000)
end_define

begin_define
define|#
directive|define
name|RELAX_BRANCH_UNCOND
parameter_list|(
name|i
parameter_list|)
value|(((i)& 8) != 0)
end_define

begin_define
define|#
directive|define
name|RELAX_BRANCH_LIKELY
parameter_list|(
name|i
parameter_list|)
value|(((i)& 4) != 0)
end_define

begin_define
define|#
directive|define
name|RELAX_BRANCH_LINK
parameter_list|(
name|i
parameter_list|)
value|(((i)& 2) != 0)
end_define

begin_define
define|#
directive|define
name|RELAX_BRANCH_TOOFAR
parameter_list|(
name|i
parameter_list|)
value|(((i)& 1) != 0)
end_define

begin_comment
comment|/* For mips16 code, we use an entirely different form of relaxation.    mips16 supports two versions of most instructions which take    immediate values: a small one which takes some small value, and a    larger one which takes a 16 bit value.  Since branches also follow    this pattern, relaxing these values is required.     We can assemble both mips16 and normal MIPS code in a single    object.  Therefore, we need to support this type of relaxation at    the same time that we support the relaxation described above.  We    use the high bit of the subtype field to distinguish these cases.     The information we store for this type of relaxation is the    argument code found in the opcode file for this relocation, whether    the user explicitly requested a small or extended form, and whether    the relocation is in a jump or jal delay slot.  That tells us the    size of the value, and how it should be stored.  We also store    whether the fragment is considered to be extended or not.  We also    store whether this is known to be a branch to a different section,    whether we have tried to relax this frag yet, and whether we have    ever extended a PC relative fragment because of a shift count.  */
end_comment

begin_define
define|#
directive|define
name|RELAX_MIPS16_ENCODE
parameter_list|(
name|type
parameter_list|,
name|small
parameter_list|,
name|ext
parameter_list|,
name|dslot
parameter_list|,
name|jal_dslot
parameter_list|)
define|\
value|(0x80000000							\    | ((type)& 0xff)						\    | ((small) ? 0x100 : 0)					\    | ((ext) ? 0x200 : 0)					\    | ((dslot) ? 0x400 : 0)					\    | ((jal_dslot) ? 0x800 : 0))
end_define

begin_define
define|#
directive|define
name|RELAX_MIPS16_P
parameter_list|(
name|i
parameter_list|)
value|(((i)& 0xc0000000) == 0x80000000)
end_define

begin_define
define|#
directive|define
name|RELAX_MIPS16_TYPE
parameter_list|(
name|i
parameter_list|)
value|((i)& 0xff)
end_define

begin_define
define|#
directive|define
name|RELAX_MIPS16_USER_SMALL
parameter_list|(
name|i
parameter_list|)
value|(((i)& 0x100) != 0)
end_define

begin_define
define|#
directive|define
name|RELAX_MIPS16_USER_EXT
parameter_list|(
name|i
parameter_list|)
value|(((i)& 0x200) != 0)
end_define

begin_define
define|#
directive|define
name|RELAX_MIPS16_DSLOT
parameter_list|(
name|i
parameter_list|)
value|(((i)& 0x400) != 0)
end_define

begin_define
define|#
directive|define
name|RELAX_MIPS16_JAL_DSLOT
parameter_list|(
name|i
parameter_list|)
value|(((i)& 0x800) != 0)
end_define

begin_define
define|#
directive|define
name|RELAX_MIPS16_EXTENDED
parameter_list|(
name|i
parameter_list|)
value|(((i)& 0x1000) != 0)
end_define

begin_define
define|#
directive|define
name|RELAX_MIPS16_MARK_EXTENDED
parameter_list|(
name|i
parameter_list|)
value|((i) | 0x1000)
end_define

begin_define
define|#
directive|define
name|RELAX_MIPS16_CLEAR_EXTENDED
parameter_list|(
name|i
parameter_list|)
value|((i)&~ 0x1000)
end_define

begin_define
define|#
directive|define
name|RELAX_MIPS16_LONG_BRANCH
parameter_list|(
name|i
parameter_list|)
value|(((i)& 0x2000) != 0)
end_define

begin_define
define|#
directive|define
name|RELAX_MIPS16_MARK_LONG_BRANCH
parameter_list|(
name|i
parameter_list|)
value|((i) | 0x2000)
end_define

begin_define
define|#
directive|define
name|RELAX_MIPS16_CLEAR_LONG_BRANCH
parameter_list|(
name|i
parameter_list|)
value|((i)&~ 0x2000)
end_define

begin_comment
comment|/* Is the given value a sign-extended 32-bit value?  */
end_comment

begin_define
define|#
directive|define
name|IS_SEXT_32BIT_NUM
parameter_list|(
name|x
parameter_list|)
define|\
value|(((x)&~ (offsetT) 0x7fffffff) == 0					\    || (((x)&~ (offsetT) 0x7fffffff) == ~ (offsetT) 0x7fffffff))
end_define

begin_comment
comment|/* Is the given value a sign-extended 16-bit value?  */
end_comment

begin_define
define|#
directive|define
name|IS_SEXT_16BIT_NUM
parameter_list|(
name|x
parameter_list|)
define|\
value|(((x)&~ (offsetT) 0x7fff) == 0					\    || (((x)&~ (offsetT) 0x7fff) == ~ (offsetT) 0x7fff))
end_define

begin_escape
end_escape

begin_comment
comment|/* Global variables used when generating relaxable macros.  See the    comment above RELAX_ENCODE for more details about how relaxation    is used.  */
end_comment

begin_struct
specifier|static
struct|struct
block|{
comment|/* 0 if we're not emitting a relaxable macro.      1 if we're emitting the first of the two relaxation alternatives.      2 if we're emitting the second alternative.  */
name|int
name|sequence
decl_stmt|;
comment|/* The first relaxable fixup in the current frag.  (In other words,      the first fixup that refers to relaxable code.)  */
name|fixS
modifier|*
name|first_fixup
decl_stmt|;
comment|/* sizes[0] says how many bytes of the first alternative are stored in      the current frag.  Likewise sizes[1] for the second alternative.  */
name|unsigned
name|int
name|sizes
index|[
literal|2
index|]
decl_stmt|;
comment|/* The symbol on which the choice of sequence depends.  */
name|symbolS
modifier|*
name|symbol
decl_stmt|;
block|}
name|mips_relax
struct|;
end_struct

begin_escape
end_escape

begin_comment
comment|/* Global variables used to decide whether a macro needs a warning.  */
end_comment

begin_struct
specifier|static
struct|struct
block|{
comment|/* True if the macro is in a branch delay slot.  */
name|bfd_boolean
name|delay_slot_p
decl_stmt|;
comment|/* For relaxable macros, sizes[0] is the length of the first alternative      in bytes and sizes[1] is the length of the second alternative.      For non-relaxable macros, both elements give the length of the      macro in bytes.  */
name|unsigned
name|int
name|sizes
index|[
literal|2
index|]
decl_stmt|;
comment|/* The first variant frag for this macro.  */
name|fragS
modifier|*
name|first_frag
decl_stmt|;
block|}
name|mips_macro_warning
struct|;
end_struct

begin_escape
end_escape

begin_comment
comment|/* Prototypes for static functions.  */
end_comment

begin_define
define|#
directive|define
name|internalError
parameter_list|()
define|\
value|as_fatal (_("internal Error, line %d, %s"), __LINE__, __FILE__)
end_define

begin_enum
enum|enum
name|mips_regclass
block|{
name|MIPS_GR_REG
block|,
name|MIPS_FP_REG
block|,
name|MIPS16_REG
block|}
enum|;
end_enum

begin_function_decl
specifier|static
name|void
name|append_insn
parameter_list|(
name|struct
name|mips_cl_insn
modifier|*
name|ip
parameter_list|,
name|expressionS
modifier|*
name|p
parameter_list|,
name|bfd_reloc_code_real_type
modifier|*
name|r
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mips_no_prev_insn
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mips16_macro_build
parameter_list|(
name|expressionS
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|va_list
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|load_register
parameter_list|(
name|int
parameter_list|,
name|expressionS
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|macro_start
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|macro_end
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|macro
parameter_list|(
name|struct
name|mips_cl_insn
modifier|*
name|ip
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mips16_macro
parameter_list|(
name|struct
name|mips_cl_insn
modifier|*
name|ip
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|LOSING_COMPILER
end_ifdef

begin_function_decl
specifier|static
name|void
name|macro2
parameter_list|(
name|struct
name|mips_cl_insn
modifier|*
name|ip
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|mips_ip
parameter_list|(
name|char
modifier|*
name|str
parameter_list|,
name|struct
name|mips_cl_insn
modifier|*
name|ip
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mips16_ip
parameter_list|(
name|char
modifier|*
name|str
parameter_list|,
name|struct
name|mips_cl_insn
modifier|*
name|ip
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mips16_immed
parameter_list|(
name|char
modifier|*
parameter_list|,
name|unsigned
name|int
parameter_list|,
name|int
parameter_list|,
name|offsetT
parameter_list|,
name|bfd_boolean
parameter_list|,
name|bfd_boolean
parameter_list|,
name|bfd_boolean
parameter_list|,
name|unsigned
name|long
modifier|*
parameter_list|,
name|bfd_boolean
modifier|*
parameter_list|,
name|unsigned
name|short
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|size_t
name|my_getSmallExpression
parameter_list|(
name|expressionS
modifier|*
parameter_list|,
name|bfd_reloc_code_real_type
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|my_getExpression
parameter_list|(
name|expressionS
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|s_align
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|s_change_sec
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|s_change_section
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|s_cons
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|s_float_cons
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|s_mips_globl
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|s_option
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|s_mipsset
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|s_abicalls
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|s_cpload
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|s_cpsetup
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|s_cplocal
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|s_cprestore
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|s_cpreturn
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|s_gpvalue
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|s_gpword
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|s_gpdword
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|s_cpadd
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|s_insn
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|md_obj_begin
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|md_obj_end
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|s_mips_ent
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|s_mips_end
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|s_mips_frame
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|s_mips_mask
parameter_list|(
name|int
name|reg_type
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|s_mips_stab
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|s_mips_weakext
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|s_mips_file
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|s_mips_loc
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bfd_boolean
name|pic_need_relax
parameter_list|(
name|symbolS
modifier|*
parameter_list|,
name|asection
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|relaxed_branch_length
parameter_list|(
name|fragS
modifier|*
parameter_list|,
name|asection
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|validate_mips_insn
parameter_list|(
specifier|const
name|struct
name|mips_opcode
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Table and functions used to map between CPU/ISA names, and    ISA levels, and CPU numbers.  */
end_comment

begin_struct
struct|struct
name|mips_cpu_info
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
comment|/* CPU or ISA name.  */
name|int
name|is_isa
decl_stmt|;
comment|/* Is this an ISA?  (If 0, a CPU.) */
name|int
name|isa
decl_stmt|;
comment|/* ISA level.  */
name|int
name|cpu
decl_stmt|;
comment|/* CPU number (default CPU if ISA).  */
block|}
struct|;
end_struct

begin_function_decl
specifier|static
specifier|const
name|struct
name|mips_cpu_info
modifier|*
name|mips_parse_cpu
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|struct
name|mips_cpu_info
modifier|*
name|mips_cpu_info_from_isa
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|struct
name|mips_cpu_info
modifier|*
name|mips_cpu_info_from_arch
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_escape
end_escape

begin_comment
comment|/* Pseudo-op table.     The following pseudo-ops from the Kane and Heinrich MIPS book    should be defined here, but are currently unsupported: .alias,    .galive, .gjaldef, .gjrlive, .livereg, .noalias.     The following pseudo-ops from the Kane and Heinrich MIPS book are    specific to the type of debugging information being generated, and    should be defined by the object format: .aent, .begin, .bend,    .bgnb, .end, .endb, .ent, .fmask, .frame, .loc, .mask, .verstamp,    .vreg.     The following pseudo-ops from the Kane and Heinrich MIPS book are    not MIPS CPU specific, but are also not specific to the object file    format.  This file is probably the best place to define them, but    they are not currently supported: .asm0, .endr, .lab, .repeat,    .struct.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|pseudo_typeS
name|mips_pseudo_table
index|[]
init|=
block|{
comment|/* MIPS specific pseudo-ops.  */
block|{
literal|"option"
block|,
name|s_option
block|,
literal|0
block|}
block|,
block|{
literal|"set"
block|,
name|s_mipsset
block|,
literal|0
block|}
block|,
block|{
literal|"rdata"
block|,
name|s_change_sec
block|,
literal|'r'
block|}
block|,
block|{
literal|"sdata"
block|,
name|s_change_sec
block|,
literal|'s'
block|}
block|,
block|{
literal|"livereg"
block|,
name|s_ignore
block|,
literal|0
block|}
block|,
block|{
literal|"abicalls"
block|,
name|s_abicalls
block|,
literal|0
block|}
block|,
block|{
literal|"cpload"
block|,
name|s_cpload
block|,
literal|0
block|}
block|,
block|{
literal|"cpsetup"
block|,
name|s_cpsetup
block|,
literal|0
block|}
block|,
block|{
literal|"cplocal"
block|,
name|s_cplocal
block|,
literal|0
block|}
block|,
block|{
literal|"cprestore"
block|,
name|s_cprestore
block|,
literal|0
block|}
block|,
block|{
literal|"cpreturn"
block|,
name|s_cpreturn
block|,
literal|0
block|}
block|,
block|{
literal|"gpvalue"
block|,
name|s_gpvalue
block|,
literal|0
block|}
block|,
block|{
literal|"gpword"
block|,
name|s_gpword
block|,
literal|0
block|}
block|,
block|{
literal|"gpdword"
block|,
name|s_gpdword
block|,
literal|0
block|}
block|,
block|{
literal|"cpadd"
block|,
name|s_cpadd
block|,
literal|0
block|}
block|,
block|{
literal|"insn"
block|,
name|s_insn
block|,
literal|0
block|}
block|,
comment|/* Relatively generic pseudo-ops that happen to be used on MIPS      chips.  */
block|{
literal|"asciiz"
block|,
name|stringer
block|,
literal|1
block|}
block|,
block|{
literal|"bss"
block|,
name|s_change_sec
block|,
literal|'b'
block|}
block|,
block|{
literal|"err"
block|,
name|s_err
block|,
literal|0
block|}
block|,
block|{
literal|"half"
block|,
name|s_cons
block|,
literal|1
block|}
block|,
block|{
literal|"dword"
block|,
name|s_cons
block|,
literal|3
block|}
block|,
block|{
literal|"weakext"
block|,
name|s_mips_weakext
block|,
literal|0
block|}
block|,
comment|/* These pseudo-ops are defined in read.c, but must be overridden      here for one reason or another.  */
block|{
literal|"align"
block|,
name|s_align
block|,
literal|0
block|}
block|,
block|{
literal|"byte"
block|,
name|s_cons
block|,
literal|0
block|}
block|,
block|{
literal|"data"
block|,
name|s_change_sec
block|,
literal|'d'
block|}
block|,
block|{
literal|"double"
block|,
name|s_float_cons
block|,
literal|'d'
block|}
block|,
block|{
literal|"float"
block|,
name|s_float_cons
block|,
literal|'f'
block|}
block|,
block|{
literal|"globl"
block|,
name|s_mips_globl
block|,
literal|0
block|}
block|,
block|{
literal|"global"
block|,
name|s_mips_globl
block|,
literal|0
block|}
block|,
block|{
literal|"hword"
block|,
name|s_cons
block|,
literal|1
block|}
block|,
block|{
literal|"int"
block|,
name|s_cons
block|,
literal|2
block|}
block|,
block|{
literal|"long"
block|,
name|s_cons
block|,
literal|2
block|}
block|,
block|{
literal|"octa"
block|,
name|s_cons
block|,
literal|4
block|}
block|,
block|{
literal|"quad"
block|,
name|s_cons
block|,
literal|3
block|}
block|,
block|{
literal|"section"
block|,
name|s_change_section
block|,
literal|0
block|}
block|,
block|{
literal|"short"
block|,
name|s_cons
block|,
literal|1
block|}
block|,
block|{
literal|"single"
block|,
name|s_float_cons
block|,
literal|'f'
block|}
block|,
block|{
literal|"stabn"
block|,
name|s_mips_stab
block|,
literal|'n'
block|}
block|,
block|{
literal|"text"
block|,
name|s_change_sec
block|,
literal|'t'
block|}
block|,
block|{
literal|"word"
block|,
name|s_cons
block|,
literal|2
block|}
block|,
block|{
literal|"extern"
block|,
name|ecoff_directive_extern
block|,
literal|0
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
literal|0
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|pseudo_typeS
name|mips_nonecoff_pseudo_table
index|[]
init|=
block|{
comment|/* These pseudo-ops should be defined by the object file format.      However, a.out doesn't support them, so we have versions here.  */
block|{
literal|"aent"
block|,
name|s_mips_ent
block|,
literal|1
block|}
block|,
block|{
literal|"bgnb"
block|,
name|s_ignore
block|,
literal|0
block|}
block|,
block|{
literal|"end"
block|,
name|s_mips_end
block|,
literal|0
block|}
block|,
block|{
literal|"endb"
block|,
name|s_ignore
block|,
literal|0
block|}
block|,
block|{
literal|"ent"
block|,
name|s_mips_ent
block|,
literal|0
block|}
block|,
block|{
literal|"file"
block|,
name|s_mips_file
block|,
literal|0
block|}
block|,
block|{
literal|"fmask"
block|,
name|s_mips_mask
block|,
literal|'F'
block|}
block|,
block|{
literal|"frame"
block|,
name|s_mips_frame
block|,
literal|0
block|}
block|,
block|{
literal|"loc"
block|,
name|s_mips_loc
block|,
literal|0
block|}
block|,
block|{
literal|"mask"
block|,
name|s_mips_mask
block|,
literal|'R'
block|}
block|,
block|{
literal|"verstamp"
block|,
name|s_ignore
block|,
literal|0
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
literal|0
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|void
name|pop_insert
parameter_list|(
specifier|const
name|pseudo_typeS
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|void
name|mips_pop_insert
parameter_list|(
name|void
parameter_list|)
block|{
name|pop_insert
argument_list|(
name|mips_pseudo_table
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ECOFF_DEBUGGING
condition|)
name|pop_insert
argument_list|(
name|mips_nonecoff_pseudo_table
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Symbols labelling the current insn.  */
end_comment

begin_struct
struct|struct
name|insn_label_list
block|{
name|struct
name|insn_label_list
modifier|*
name|next
decl_stmt|;
name|symbolS
modifier|*
name|label
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|insn_label_list
modifier|*
name|insn_labels
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|insn_label_list
modifier|*
name|free_insn_labels
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|mips_clear_insn_labels
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
specifier|inline
name|void
name|mips_clear_insn_labels
parameter_list|(
name|void
parameter_list|)
block|{
specifier|register
name|struct
name|insn_label_list
modifier|*
modifier|*
name|pl
decl_stmt|;
for|for
control|(
name|pl
operator|=
operator|&
name|free_insn_labels
init|;
operator|*
name|pl
operator|!=
name|NULL
condition|;
name|pl
operator|=
operator|&
operator|(
operator|*
name|pl
operator|)
operator|->
name|next
control|)
empty_stmt|;
operator|*
name|pl
operator|=
name|insn_labels
expr_stmt|;
name|insn_labels
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_decl_stmt
specifier|static
name|char
modifier|*
name|expr_end
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Expressions which appear in instructions.  These are set by    mips_ip.  */
end_comment

begin_decl_stmt
specifier|static
name|expressionS
name|imm_expr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|expressionS
name|imm2_expr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|expressionS
name|offset_expr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Relocs associated with imm_expr and offset_expr.  */
end_comment

begin_decl_stmt
specifier|static
name|bfd_reloc_code_real_type
name|imm_reloc
index|[
literal|3
index|]
init|=
block|{
name|BFD_RELOC_UNUSED
block|,
name|BFD_RELOC_UNUSED
block|,
name|BFD_RELOC_UNUSED
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_reloc_code_real_type
name|offset_reloc
index|[
literal|3
index|]
init|=
block|{
name|BFD_RELOC_UNUSED
block|,
name|BFD_RELOC_UNUSED
block|,
name|BFD_RELOC_UNUSED
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* These are set by mips16_ip if an explicit extension is used.  */
end_comment

begin_decl_stmt
specifier|static
name|bfd_boolean
name|mips16_small
decl_stmt|,
name|mips16_ext
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|OBJ_ELF
end_ifdef

begin_comment
comment|/* The pdr segment for per procedure frame/regmask info.  Not used for    ECOFF debugging.  */
end_comment

begin_decl_stmt
specifier|static
name|segT
name|pdr_seg
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* The default target format to use.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|mips_target_format
parameter_list|(
name|void
parameter_list|)
block|{
switch|switch
condition|(
name|OUTPUT_FLAVOR
condition|)
block|{
case|case
name|bfd_target_aout_flavour
case|:
return|return
name|target_big_endian
condition|?
literal|"a.out-mips-big"
else|:
literal|"a.out-mips-little"
return|;
case|case
name|bfd_target_ecoff_flavour
case|:
return|return
name|target_big_endian
condition|?
literal|"ecoff-bigmips"
else|:
name|ECOFF_LITTLE_FORMAT
return|;
case|case
name|bfd_target_coff_flavour
case|:
return|return
literal|"pe-mips"
return|;
case|case
name|bfd_target_elf_flavour
case|:
ifdef|#
directive|ifdef
name|TE_TMIPS
comment|/* This is traditional mips.  */
return|return
operator|(
name|target_big_endian
condition|?
operator|(
name|HAVE_64BIT_OBJECTS
condition|?
literal|"elf64-tradbigmips"
else|:
operator|(
name|HAVE_NEWABI
condition|?
literal|"elf32-ntradbigmips"
else|:
literal|"elf32-tradbigmips"
operator|)
operator|)
else|:
operator|(
name|HAVE_64BIT_OBJECTS
condition|?
literal|"elf64-tradlittlemips"
else|:
operator|(
name|HAVE_NEWABI
condition|?
literal|"elf32-ntradlittlemips"
else|:
literal|"elf32-tradlittlemips"
operator|)
operator|)
operator|)
return|;
else|#
directive|else
return|return
operator|(
name|target_big_endian
condition|?
operator|(
name|HAVE_64BIT_OBJECTS
condition|?
literal|"elf64-bigmips"
else|:
operator|(
name|HAVE_NEWABI
condition|?
literal|"elf32-nbigmips"
else|:
literal|"elf32-bigmips"
operator|)
operator|)
else|:
operator|(
name|HAVE_64BIT_OBJECTS
condition|?
literal|"elf64-littlemips"
else|:
operator|(
name|HAVE_NEWABI
condition|?
literal|"elf32-nlittlemips"
else|:
literal|"elf32-littlemips"
operator|)
operator|)
operator|)
return|;
endif|#
directive|endif
default|default:
name|abort
argument_list|()
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
end_function

begin_comment
comment|/* This function is called once, at assembler startup time.  It should    set up all the tables, etc. that the MD part of the assembler will need.  */
end_comment

begin_function
name|void
name|md_begin
parameter_list|(
name|void
parameter_list|)
block|{
specifier|register
specifier|const
name|char
modifier|*
name|retval
init|=
name|NULL
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
name|int
name|broken
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|bfd_set_arch_mach
argument_list|(
name|stdoutput
argument_list|,
name|bfd_arch_mips
argument_list|,
name|file_mips_arch
argument_list|)
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"Could not set architecture and machine"
argument_list|)
argument_list|)
expr_stmt|;
name|op_hash
operator|=
name|hash_new
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUMOPCODES
condition|;
control|)
block|{
specifier|const
name|char
modifier|*
name|name
init|=
name|mips_opcodes
index|[
name|i
index|]
operator|.
name|name
decl_stmt|;
name|retval
operator|=
name|hash_insert
argument_list|(
name|op_hash
argument_list|,
name|name
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|mips_opcodes
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"internal error: can't hash `%s': %s\n"
argument_list|)
argument_list|,
name|mips_opcodes
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|retval
argument_list|)
expr_stmt|;
comment|/* Probably a memory allocation problem?  Give up now.  */
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"Broken assembler.  No assembly attempted."
argument_list|)
argument_list|)
expr_stmt|;
block|}
do|do
block|{
if|if
condition|(
name|mips_opcodes
index|[
name|i
index|]
operator|.
name|pinfo
operator|!=
name|INSN_MACRO
condition|)
block|{
if|if
condition|(
operator|!
name|validate_mips_insn
argument_list|(
operator|&
name|mips_opcodes
index|[
name|i
index|]
argument_list|)
condition|)
name|broken
operator|=
literal|1
expr_stmt|;
block|}
operator|++
name|i
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|i
operator|<
name|NUMOPCODES
operator|)
operator|&&
operator|!
name|strcmp
argument_list|(
name|mips_opcodes
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|name
argument_list|)
condition|)
do|;
block|}
name|mips16_op_hash
operator|=
name|hash_new
argument_list|()
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|bfd_mips16_num_opcodes
condition|)
block|{
specifier|const
name|char
modifier|*
name|name
init|=
name|mips16_opcodes
index|[
name|i
index|]
operator|.
name|name
decl_stmt|;
name|retval
operator|=
name|hash_insert
argument_list|(
name|mips16_op_hash
argument_list|,
name|name
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|mips16_opcodes
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
name|NULL
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"internal: can't hash `%s': %s"
argument_list|)
argument_list|,
name|mips16_opcodes
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|retval
argument_list|)
expr_stmt|;
do|do
block|{
if|if
condition|(
name|mips16_opcodes
index|[
name|i
index|]
operator|.
name|pinfo
operator|!=
name|INSN_MACRO
operator|&&
operator|(
operator|(
name|mips16_opcodes
index|[
name|i
index|]
operator|.
name|match
operator|&
name|mips16_opcodes
index|[
name|i
index|]
operator|.
name|mask
operator|)
operator|!=
name|mips16_opcodes
index|[
name|i
index|]
operator|.
name|match
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"internal error: bad mips16 opcode: %s %s\n"
argument_list|)
argument_list|,
name|mips16_opcodes
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|mips16_opcodes
index|[
name|i
index|]
operator|.
name|args
argument_list|)
expr_stmt|;
name|broken
operator|=
literal|1
expr_stmt|;
block|}
operator|++
name|i
expr_stmt|;
block|}
do|while
condition|(
name|i
operator|<
name|bfd_mips16_num_opcodes
operator|&&
name|strcmp
argument_list|(
name|mips16_opcodes
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
do|;
block|}
if|if
condition|(
name|broken
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"Broken assembler.  No assembly attempted."
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We add all the general register names to the symbol table.  This      helps us detect invalid uses of them.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|++
control|)
block|{
name|char
name|buf
index|[
literal|5
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"$%d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|symbol_table_insert
argument_list|(
name|symbol_new
argument_list|(
name|buf
argument_list|,
name|reg_section
argument_list|,
name|i
argument_list|,
operator|&
name|zero_address_frag
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|symbol_table_insert
argument_list|(
name|symbol_new
argument_list|(
literal|"$ra"
argument_list|,
name|reg_section
argument_list|,
name|RA
argument_list|,
operator|&
name|zero_address_frag
argument_list|)
argument_list|)
expr_stmt|;
name|symbol_table_insert
argument_list|(
name|symbol_new
argument_list|(
literal|"$fp"
argument_list|,
name|reg_section
argument_list|,
name|FP
argument_list|,
operator|&
name|zero_address_frag
argument_list|)
argument_list|)
expr_stmt|;
name|symbol_table_insert
argument_list|(
name|symbol_new
argument_list|(
literal|"$sp"
argument_list|,
name|reg_section
argument_list|,
name|SP
argument_list|,
operator|&
name|zero_address_frag
argument_list|)
argument_list|)
expr_stmt|;
name|symbol_table_insert
argument_list|(
name|symbol_new
argument_list|(
literal|"$gp"
argument_list|,
name|reg_section
argument_list|,
name|GP
argument_list|,
operator|&
name|zero_address_frag
argument_list|)
argument_list|)
expr_stmt|;
name|symbol_table_insert
argument_list|(
name|symbol_new
argument_list|(
literal|"$at"
argument_list|,
name|reg_section
argument_list|,
name|AT
argument_list|,
operator|&
name|zero_address_frag
argument_list|)
argument_list|)
expr_stmt|;
name|symbol_table_insert
argument_list|(
name|symbol_new
argument_list|(
literal|"$kt0"
argument_list|,
name|reg_section
argument_list|,
name|KT0
argument_list|,
operator|&
name|zero_address_frag
argument_list|)
argument_list|)
expr_stmt|;
name|symbol_table_insert
argument_list|(
name|symbol_new
argument_list|(
literal|"$kt1"
argument_list|,
name|reg_section
argument_list|,
name|KT1
argument_list|,
operator|&
name|zero_address_frag
argument_list|)
argument_list|)
expr_stmt|;
name|symbol_table_insert
argument_list|(
name|symbol_new
argument_list|(
literal|"$zero"
argument_list|,
name|reg_section
argument_list|,
name|ZERO
argument_list|,
operator|&
name|zero_address_frag
argument_list|)
argument_list|)
expr_stmt|;
name|symbol_table_insert
argument_list|(
name|symbol_new
argument_list|(
literal|"$pc"
argument_list|,
name|reg_section
argument_list|,
operator|-
literal|1
argument_list|,
operator|&
name|zero_address_frag
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If we don't add these register names to the symbol table, they      may end up being added as regular symbols by operand(), and then      make it to the object file as undefined in case they're not      regarded as local symbols.  They're local in o32, since `$' is a      local symbol prefix, but not in n32 or n64.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
block|{
name|char
name|buf
index|[
literal|6
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"$fcc%i"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|symbol_table_insert
argument_list|(
name|symbol_new
argument_list|(
name|buf
argument_list|,
name|reg_section
argument_list|,
operator|-
literal|1
argument_list|,
operator|&
name|zero_address_frag
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|mips_no_prev_insn
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
name|mips_gprmask
operator|=
literal|0
expr_stmt|;
name|mips_cprmask
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|mips_cprmask
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|mips_cprmask
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|mips_cprmask
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
comment|/* set the default alignment for the text section (2**2) */
name|record_alignment
argument_list|(
name|text_section
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|USE_GLOBAL_POINTER_OPT
condition|)
name|bfd_set_gp_size
argument_list|(
name|stdoutput
argument_list|,
name|g_switch_value
argument_list|)
expr_stmt|;
if|if
condition|(
name|OUTPUT_FLAVOR
operator|==
name|bfd_target_elf_flavour
condition|)
block|{
comment|/* On a native system, sections must be aligned to 16 byte 	 boundaries.  When configured for an embedded ELF target, we 	 don't bother.  */
if|if
condition|(
name|strcmp
argument_list|(
name|TARGET_OS
argument_list|,
literal|"elf"
argument_list|)
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|bfd_set_section_alignment
argument_list|(
name|stdoutput
argument_list|,
name|text_section
argument_list|,
literal|4
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|bfd_set_section_alignment
argument_list|(
name|stdoutput
argument_list|,
name|data_section
argument_list|,
literal|4
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|bfd_set_section_alignment
argument_list|(
name|stdoutput
argument_list|,
name|bss_section
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
comment|/* Create a .reginfo section for register masks and a .mdebug 	 section for debugging information.  */
block|{
name|segT
name|seg
decl_stmt|;
name|subsegT
name|subseg
decl_stmt|;
name|flagword
name|flags
decl_stmt|;
name|segT
name|sec
decl_stmt|;
name|seg
operator|=
name|now_seg
expr_stmt|;
name|subseg
operator|=
name|now_subseg
expr_stmt|;
comment|/* The ABI says this section should be loaded so that the 	   running program can access it.  However, we don't load it 	   if we are configured for an embedded target */
name|flags
operator|=
name|SEC_READONLY
operator||
name|SEC_DATA
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|TARGET_OS
argument_list|,
literal|"elf"
argument_list|)
operator|!=
literal|0
condition|)
name|flags
operator||=
name|SEC_ALLOC
operator||
name|SEC_LOAD
expr_stmt|;
if|if
condition|(
name|mips_abi
operator|!=
name|N64_ABI
condition|)
block|{
name|sec
operator|=
name|subseg_new
argument_list|(
literal|".reginfo"
argument_list|,
operator|(
name|subsegT
operator|)
literal|0
argument_list|)
expr_stmt|;
name|bfd_set_section_flags
argument_list|(
name|stdoutput
argument_list|,
name|sec
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|bfd_set_section_alignment
argument_list|(
name|stdoutput
argument_list|,
name|sec
argument_list|,
name|HAVE_NEWABI
condition|?
literal|3
else|:
literal|2
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|OBJ_ELF
name|mips_regmask_frag
operator|=
name|frag_more
argument_list|(
sizeof|sizeof
argument_list|(
name|Elf32_External_RegInfo
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
comment|/* The 64-bit ABI uses a .MIPS.options section rather than                .reginfo section.  */
name|sec
operator|=
name|subseg_new
argument_list|(
literal|".MIPS.options"
argument_list|,
operator|(
name|subsegT
operator|)
literal|0
argument_list|)
expr_stmt|;
name|bfd_set_section_flags
argument_list|(
name|stdoutput
argument_list|,
name|sec
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|bfd_set_section_alignment
argument_list|(
name|stdoutput
argument_list|,
name|sec
argument_list|,
literal|3
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|OBJ_ELF
comment|/* Set up the option header.  */
block|{
name|Elf_Internal_Options
name|opthdr
decl_stmt|;
name|char
modifier|*
name|f
decl_stmt|;
name|opthdr
operator|.
name|kind
operator|=
name|ODK_REGINFO
expr_stmt|;
name|opthdr
operator|.
name|size
operator|=
operator|(
sizeof|sizeof
argument_list|(
name|Elf_External_Options
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|Elf64_External_RegInfo
argument_list|)
operator|)
expr_stmt|;
name|opthdr
operator|.
name|section
operator|=
literal|0
expr_stmt|;
name|opthdr
operator|.
name|info
operator|=
literal|0
expr_stmt|;
name|f
operator|=
name|frag_more
argument_list|(
sizeof|sizeof
argument_list|(
name|Elf_External_Options
argument_list|)
argument_list|)
expr_stmt|;
name|bfd_mips_elf_swap_options_out
argument_list|(
name|stdoutput
argument_list|,
operator|&
name|opthdr
argument_list|,
operator|(
name|Elf_External_Options
operator|*
operator|)
name|f
argument_list|)
expr_stmt|;
name|mips_regmask_frag
operator|=
name|frag_more
argument_list|(
sizeof|sizeof
argument_list|(
name|Elf64_External_RegInfo
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
if|if
condition|(
name|ECOFF_DEBUGGING
condition|)
block|{
name|sec
operator|=
name|subseg_new
argument_list|(
literal|".mdebug"
argument_list|,
operator|(
name|subsegT
operator|)
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|bfd_set_section_flags
argument_list|(
name|stdoutput
argument_list|,
name|sec
argument_list|,
name|SEC_HAS_CONTENTS
operator||
name|SEC_READONLY
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|bfd_set_section_alignment
argument_list|(
name|stdoutput
argument_list|,
name|sec
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|OBJ_ELF
elseif|else
if|if
condition|(
name|OUTPUT_FLAVOR
operator|==
name|bfd_target_elf_flavour
operator|&&
name|mips_flag_pdr
condition|)
block|{
name|pdr_seg
operator|=
name|subseg_new
argument_list|(
literal|".pdr"
argument_list|,
operator|(
name|subsegT
operator|)
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|bfd_set_section_flags
argument_list|(
name|stdoutput
argument_list|,
name|pdr_seg
argument_list|,
name|SEC_READONLY
operator||
name|SEC_RELOC
operator||
name|SEC_DEBUGGING
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|bfd_set_section_alignment
argument_list|(
name|stdoutput
argument_list|,
name|pdr_seg
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|subseg_set
argument_list|(
name|seg
argument_list|,
name|subseg
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|ECOFF_DEBUGGING
condition|)
name|md_obj_begin
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|md_mips_end
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
name|ECOFF_DEBUGGING
condition|)
name|md_obj_end
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|md_assemble
parameter_list|(
name|char
modifier|*
name|str
parameter_list|)
block|{
name|struct
name|mips_cl_insn
name|insn
decl_stmt|;
name|bfd_reloc_code_real_type
name|unused_reloc
index|[
literal|3
index|]
init|=
block|{
name|BFD_RELOC_UNUSED
block|,
name|BFD_RELOC_UNUSED
block|,
name|BFD_RELOC_UNUSED
block|}
decl_stmt|;
name|imm_expr
operator|.
name|X_op
operator|=
name|O_absent
expr_stmt|;
name|imm2_expr
operator|.
name|X_op
operator|=
name|O_absent
expr_stmt|;
name|offset_expr
operator|.
name|X_op
operator|=
name|O_absent
expr_stmt|;
name|imm_reloc
index|[
literal|0
index|]
operator|=
name|BFD_RELOC_UNUSED
expr_stmt|;
name|imm_reloc
index|[
literal|1
index|]
operator|=
name|BFD_RELOC_UNUSED
expr_stmt|;
name|imm_reloc
index|[
literal|2
index|]
operator|=
name|BFD_RELOC_UNUSED
expr_stmt|;
name|offset_reloc
index|[
literal|0
index|]
operator|=
name|BFD_RELOC_UNUSED
expr_stmt|;
name|offset_reloc
index|[
literal|1
index|]
operator|=
name|BFD_RELOC_UNUSED
expr_stmt|;
name|offset_reloc
index|[
literal|2
index|]
operator|=
name|BFD_RELOC_UNUSED
expr_stmt|;
if|if
condition|(
name|mips_opts
operator|.
name|mips16
condition|)
name|mips16_ip
argument_list|(
name|str
argument_list|,
operator|&
name|insn
argument_list|)
expr_stmt|;
else|else
block|{
name|mips_ip
argument_list|(
name|str
argument_list|,
operator|&
name|insn
argument_list|)
expr_stmt|;
name|DBG
argument_list|(
operator|(
name|_
argument_list|(
literal|"returned from mips_ip(%s) insn_opcode = 0x%x\n"
argument_list|)
operator|,
name|str
operator|,
name|insn
operator|.
name|insn_opcode
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|insn_error
condition|)
block|{
name|as_bad
argument_list|(
literal|"%s `%s'"
argument_list|,
name|insn_error
argument_list|,
name|str
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|insn
operator|.
name|insn_mo
operator|->
name|pinfo
operator|==
name|INSN_MACRO
condition|)
block|{
name|macro_start
argument_list|()
expr_stmt|;
if|if
condition|(
name|mips_opts
operator|.
name|mips16
condition|)
name|mips16_macro
argument_list|(
operator|&
name|insn
argument_list|)
expr_stmt|;
else|else
name|macro
argument_list|(
operator|&
name|insn
argument_list|)
expr_stmt|;
name|macro_end
argument_list|()
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|imm_expr
operator|.
name|X_op
operator|!=
name|O_absent
condition|)
name|append_insn
argument_list|(
operator|&
name|insn
argument_list|,
operator|&
name|imm_expr
argument_list|,
name|imm_reloc
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|offset_expr
operator|.
name|X_op
operator|!=
name|O_absent
condition|)
name|append_insn
argument_list|(
operator|&
name|insn
argument_list|,
operator|&
name|offset_expr
argument_list|,
name|offset_reloc
argument_list|)
expr_stmt|;
else|else
name|append_insn
argument_list|(
operator|&
name|insn
argument_list|,
name|NULL
argument_list|,
name|unused_reloc
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return true if the given relocation might need a matching %lo().    Note that R_MIPS_GOT16 relocations only need a matching %lo() when    applied to local symbols.  */
end_comment

begin_function
specifier|static
specifier|inline
name|bfd_boolean
name|reloc_needs_lo_p
parameter_list|(
name|bfd_reloc_code_real_type
name|reloc
parameter_list|)
block|{
return|return
operator|(
name|reloc
operator|==
name|BFD_RELOC_HI16_S
operator|||
name|reloc
operator|==
name|BFD_RELOC_MIPS_GOT16
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return true if the given fixup is followed by a matching R_MIPS_LO16    relocation.  */
end_comment

begin_function
specifier|static
specifier|inline
name|bfd_boolean
name|fixup_has_matching_lo_p
parameter_list|(
name|fixS
modifier|*
name|fixp
parameter_list|)
block|{
return|return
operator|(
name|fixp
operator|->
name|fx_next
operator|!=
name|NULL
operator|&&
name|fixp
operator|->
name|fx_next
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_LO16
operator|&&
name|fixp
operator|->
name|fx_addsy
operator|==
name|fixp
operator|->
name|fx_next
operator|->
name|fx_addsy
operator|&&
name|fixp
operator|->
name|fx_offset
operator|==
name|fixp
operator|->
name|fx_next
operator|->
name|fx_offset
operator|)
return|;
block|}
end_function

begin_comment
comment|/* See whether instruction IP reads register REG.  CLASS is the type    of register.  */
end_comment

begin_function
specifier|static
name|int
name|insn_uses_reg
parameter_list|(
name|struct
name|mips_cl_insn
modifier|*
name|ip
parameter_list|,
name|unsigned
name|int
name|reg
parameter_list|,
name|enum
name|mips_regclass
name|class
parameter_list|)
block|{
if|if
condition|(
name|class
operator|==
name|MIPS16_REG
condition|)
block|{
name|assert
argument_list|(
name|mips_opts
operator|.
name|mips16
argument_list|)
expr_stmt|;
name|reg
operator|=
name|mips16_to_32_reg_map
index|[
name|reg
index|]
expr_stmt|;
name|class
operator|=
name|MIPS_GR_REG
expr_stmt|;
block|}
comment|/* Don't report on general register ZERO, since it never changes.  */
if|if
condition|(
name|class
operator|==
name|MIPS_GR_REG
operator|&&
name|reg
operator|==
name|ZERO
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|class
operator|==
name|MIPS_FP_REG
condition|)
block|{
name|assert
argument_list|(
operator|!
name|mips_opts
operator|.
name|mips16
argument_list|)
expr_stmt|;
comment|/* If we are called with either $f0 or $f1, we must check $f0. 	 This is not optimal, because it will introduce an unnecessary 	 NOP between "lwc1 $f0" and "swc1 $f1".  To fix this we would 	 need to distinguish reading both $f0 and $f1 or just one of 	 them.  Note that we don't have to check the other way, 	 because there is no instruction that sets both $f0 and $f1 	 and requires a delay.  */
if|if
condition|(
operator|(
name|ip
operator|->
name|insn_mo
operator|->
name|pinfo
operator|&
name|INSN_READ_FPR_S
operator|)
operator|&&
operator|(
operator|(
operator|(
operator|(
name|ip
operator|->
name|insn_opcode
operator|>>
name|OP_SH_FS
operator|)
operator|&
name|OP_MASK_FS
operator|)
operator|&
operator|~
operator|(
name|unsigned
operator|)
literal|1
operator|)
operator|==
operator|(
name|reg
operator|&
operator|~
operator|(
name|unsigned
operator|)
literal|1
operator|)
operator|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|(
name|ip
operator|->
name|insn_mo
operator|->
name|pinfo
operator|&
name|INSN_READ_FPR_T
operator|)
operator|&&
operator|(
operator|(
operator|(
operator|(
name|ip
operator|->
name|insn_opcode
operator|>>
name|OP_SH_FT
operator|)
operator|&
name|OP_MASK_FT
operator|)
operator|&
operator|~
operator|(
name|unsigned
operator|)
literal|1
operator|)
operator|==
operator|(
name|reg
operator|&
operator|~
operator|(
name|unsigned
operator|)
literal|1
operator|)
operator|)
condition|)
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|mips_opts
operator|.
name|mips16
condition|)
block|{
if|if
condition|(
operator|(
name|ip
operator|->
name|insn_mo
operator|->
name|pinfo
operator|&
name|INSN_READ_GPR_S
operator|)
operator|&&
operator|(
operator|(
name|ip
operator|->
name|insn_opcode
operator|>>
name|OP_SH_RS
operator|)
operator|&
name|OP_MASK_RS
operator|)
operator|==
name|reg
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|(
name|ip
operator|->
name|insn_mo
operator|->
name|pinfo
operator|&
name|INSN_READ_GPR_T
operator|)
operator|&&
operator|(
operator|(
name|ip
operator|->
name|insn_opcode
operator|>>
name|OP_SH_RT
operator|)
operator|&
name|OP_MASK_RT
operator|)
operator|==
name|reg
condition|)
return|return
literal|1
return|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|ip
operator|->
name|insn_mo
operator|->
name|pinfo
operator|&
name|MIPS16_INSN_READ_X
operator|)
operator|&&
operator|(
name|mips16_to_32_reg_map
index|[
operator|(
operator|(
name|ip
operator|->
name|insn_opcode
operator|>>
name|MIPS16OP_SH_RX
operator|)
operator|&
name|MIPS16OP_MASK_RX
operator|)
index|]
operator|==
name|reg
operator|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|(
name|ip
operator|->
name|insn_mo
operator|->
name|pinfo
operator|&
name|MIPS16_INSN_READ_Y
operator|)
operator|&&
operator|(
name|mips16_to_32_reg_map
index|[
operator|(
operator|(
name|ip
operator|->
name|insn_opcode
operator|>>
name|MIPS16OP_SH_RY
operator|)
operator|&
name|MIPS16OP_MASK_RY
operator|)
index|]
operator|==
name|reg
operator|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|(
name|ip
operator|->
name|insn_mo
operator|->
name|pinfo
operator|&
name|MIPS16_INSN_READ_Z
operator|)
operator|&&
operator|(
name|mips16_to_32_reg_map
index|[
operator|(
operator|(
name|ip
operator|->
name|insn_opcode
operator|>>
name|MIPS16OP_SH_MOVE32Z
operator|)
operator|&
name|MIPS16OP_MASK_MOVE32Z
operator|)
index|]
operator|==
name|reg
operator|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|(
name|ip
operator|->
name|insn_mo
operator|->
name|pinfo
operator|&
name|MIPS16_INSN_READ_T
operator|)
operator|&&
name|reg
operator|==
name|TREG
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|(
name|ip
operator|->
name|insn_mo
operator|->
name|pinfo
operator|&
name|MIPS16_INSN_READ_SP
operator|)
operator|&&
name|reg
operator|==
name|SP
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|(
name|ip
operator|->
name|insn_mo
operator|->
name|pinfo
operator|&
name|MIPS16_INSN_READ_31
operator|)
operator|&&
name|reg
operator|==
name|RA
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|(
name|ip
operator|->
name|insn_mo
operator|->
name|pinfo
operator|&
name|MIPS16_INSN_READ_GPR_X
operator|)
operator|&&
operator|(
operator|(
name|ip
operator|->
name|insn_opcode
operator|>>
name|MIPS16OP_SH_REGR32
operator|)
operator|&
name|MIPS16OP_MASK_REGR32
operator|)
operator|==
name|reg
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* This function returns true if modifying a register requires a    delay.  */
end_comment

begin_function
specifier|static
name|int
name|reg_needs_delay
parameter_list|(
name|unsigned
name|int
name|reg
parameter_list|)
block|{
name|unsigned
name|long
name|prev_pinfo
decl_stmt|;
name|prev_pinfo
operator|=
name|prev_insn
operator|.
name|insn_mo
operator|->
name|pinfo
expr_stmt|;
if|if
condition|(
operator|!
name|mips_opts
operator|.
name|noreorder
operator|&&
operator|(
operator|(
operator|(
name|prev_pinfo
operator|&
name|INSN_LOAD_MEMORY_DELAY
operator|)
operator|&&
operator|!
name|gpr_interlocks
operator|)
operator|||
operator|(
operator|(
name|prev_pinfo
operator|&
name|INSN_LOAD_COPROC_DELAY
operator|)
operator|&&
operator|!
name|cop_interlocks
operator|)
operator|)
condition|)
block|{
comment|/* A load from a coprocessor or from memory.  All load delays 	 delay the use of general register rt for one instruction.  */
comment|/* Itbl support may require additional care here.  */
name|know
argument_list|(
name|prev_pinfo
operator|&
name|INSN_WRITE_GPR_T
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
operator|==
operator|(
operator|(
name|prev_insn
operator|.
name|insn_opcode
operator|>>
name|OP_SH_RT
operator|)
operator|&
name|OP_MASK_RT
operator|)
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Mark instruction labels in mips16 mode.  This permits the linker to    handle them specially, such as generating jalx instructions when    needed.  We also make them odd for the duration of the assembly, in    order to generate the right sort of code.  We will make them even    in the adjust_symtab routine, while leaving them marked.  This is    convenient for the debugger and the disassembler.  The linker knows    to make them odd again.  */
end_comment

begin_function
specifier|static
name|void
name|mips16_mark_labels
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|mips_opts
operator|.
name|mips16
condition|)
block|{
name|struct
name|insn_label_list
modifier|*
name|l
decl_stmt|;
name|valueT
name|val
decl_stmt|;
for|for
control|(
name|l
operator|=
name|insn_labels
init|;
name|l
operator|!=
name|NULL
condition|;
name|l
operator|=
name|l
operator|->
name|next
control|)
block|{
ifdef|#
directive|ifdef
name|OBJ_ELF
if|if
condition|(
name|OUTPUT_FLAVOR
operator|==
name|bfd_target_elf_flavour
condition|)
name|S_SET_OTHER
argument_list|(
name|l
operator|->
name|label
argument_list|,
name|STO_MIPS16
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|val
operator|=
name|S_GET_VALUE
argument_list|(
name|l
operator|->
name|label
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|val
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
name|S_SET_VALUE
argument_list|(
name|l
operator|->
name|label
argument_list|,
name|val
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* End the current frag.  Make it a variant frag and record the    relaxation info.  */
end_comment

begin_function
specifier|static
name|void
name|relax_close_frag
parameter_list|(
name|void
parameter_list|)
block|{
name|mips_macro_warning
operator|.
name|first_frag
operator|=
name|frag_now
expr_stmt|;
name|frag_var
argument_list|(
name|rs_machine_dependent
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|RELAX_ENCODE
argument_list|(
name|mips_relax
operator|.
name|sizes
index|[
literal|0
index|]
argument_list|,
name|mips_relax
operator|.
name|sizes
index|[
literal|1
index|]
argument_list|)
argument_list|,
name|mips_relax
operator|.
name|symbol
argument_list|,
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|)
name|mips_relax
operator|.
name|first_fixup
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|mips_relax
operator|.
name|sizes
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|mips_relax
operator|.
name|sizes
argument_list|)
argument_list|)
expr_stmt|;
name|mips_relax
operator|.
name|first_fixup
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Start a new relaxation sequence whose expansion depends on SYMBOL.    See the comment above RELAX_ENCODE for more details.  */
end_comment

begin_function
specifier|static
name|void
name|relax_start
parameter_list|(
name|symbolS
modifier|*
name|symbol
parameter_list|)
block|{
name|assert
argument_list|(
name|mips_relax
operator|.
name|sequence
operator|==
literal|0
argument_list|)
expr_stmt|;
name|mips_relax
operator|.
name|sequence
operator|=
literal|1
expr_stmt|;
name|mips_relax
operator|.
name|symbol
operator|=
name|symbol
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Start generating the second version of a relaxable sequence.    See the comment above RELAX_ENCODE for more details.  */
end_comment

begin_function
specifier|static
name|void
name|relax_switch
parameter_list|(
name|void
parameter_list|)
block|{
name|assert
argument_list|(
name|mips_relax
operator|.
name|sequence
operator|==
literal|1
argument_list|)
expr_stmt|;
name|mips_relax
operator|.
name|sequence
operator|=
literal|2
expr_stmt|;
block|}
end_function

begin_comment
comment|/* End the current relaxable sequence.  */
end_comment

begin_function
specifier|static
name|void
name|relax_end
parameter_list|(
name|void
parameter_list|)
block|{
name|assert
argument_list|(
name|mips_relax
operator|.
name|sequence
operator|==
literal|2
argument_list|)
expr_stmt|;
name|relax_close_frag
argument_list|()
expr_stmt|;
name|mips_relax
operator|.
name|sequence
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output an instruction.  IP is the instruction information.    ADDRESS_EXPR is an operand of the instruction to be used with    RELOC_TYPE.  */
end_comment

begin_function
specifier|static
name|void
name|append_insn
parameter_list|(
name|struct
name|mips_cl_insn
modifier|*
name|ip
parameter_list|,
name|expressionS
modifier|*
name|address_expr
parameter_list|,
name|bfd_reloc_code_real_type
modifier|*
name|reloc_type
parameter_list|)
block|{
specifier|register
name|unsigned
name|long
name|prev_pinfo
decl_stmt|,
name|pinfo
decl_stmt|;
name|char
modifier|*
name|f
decl_stmt|;
name|fixS
modifier|*
name|fixp
index|[
literal|3
index|]
decl_stmt|;
name|int
name|nops
init|=
literal|0
decl_stmt|;
name|relax_stateT
name|prev_insn_frag_type
init|=
literal|0
decl_stmt|;
name|bfd_boolean
name|relaxed_branch
init|=
name|FALSE
decl_stmt|;
name|bfd_boolean
name|force_new_frag
init|=
name|FALSE
decl_stmt|;
comment|/* Mark instruction labels in mips16 mode.  */
name|mips16_mark_labels
argument_list|()
expr_stmt|;
name|prev_pinfo
operator|=
name|prev_insn
operator|.
name|insn_mo
operator|->
name|pinfo
expr_stmt|;
name|pinfo
operator|=
name|ip
operator|->
name|insn_mo
operator|->
name|pinfo
expr_stmt|;
if|if
condition|(
name|mips_relax
operator|.
name|sequence
operator|!=
literal|2
operator|&&
operator|(
operator|!
name|mips_opts
operator|.
name|noreorder
operator|||
name|prev_nop_frag
operator|!=
name|NULL
operator|)
condition|)
block|{
name|int
name|prev_prev_nop
decl_stmt|;
comment|/* If the previous insn required any delay slots, see if we need 	 to insert a NOP or two.  There are eight kinds of possible 	 hazards, of which an instruction can have at most one type. 	 (1) a load from memory delay 	 (2) a load from a coprocessor delay 	 (3) an unconditional branch delay 	 (4) a conditional branch delay 	 (5) a move to coprocessor register delay 	 (6) a load coprocessor register from memory delay 	 (7) a coprocessor condition code delay 	 (8) a HI/LO special register delay  	 There are a lot of optimizations we could do that we don't. 	 In particular, we do not, in general, reorder instructions. 	 If you use gcc with optimization, it will reorder 	 instructions and generally do much more optimization then we 	 do here; repeating all that work in the assembler would only 	 benefit hand written assembly code, and does not seem worth 	 it.  */
comment|/* This is how a NOP is emitted.  */
define|#
directive|define
name|emit_nop
parameter_list|()
define|\
value|(mips_opts.mips16					\    ? md_number_to_chars (frag_more (2), 0x6500, 2)	\    : md_number_to_chars (frag_more (4), 0, 4))
comment|/* The previous insn might require a delay slot, depending upon 	 the contents of the current insn.  */
if|if
condition|(
operator|!
name|mips_opts
operator|.
name|mips16
operator|&&
operator|(
operator|(
operator|(
name|prev_pinfo
operator|&
name|INSN_LOAD_MEMORY_DELAY
operator|)
operator|&&
operator|!
name|gpr_interlocks
operator|)
operator|||
operator|(
operator|(
name|prev_pinfo
operator|&
name|INSN_LOAD_COPROC_DELAY
operator|)
operator|&&
operator|!
name|cop_interlocks
operator|)
operator|)
condition|)
block|{
comment|/* A load from a coprocessor or from memory.  All load 	     delays delay the use of general register rt for one 	     instruction.  */
comment|/* Itbl support may require additional care here.  */
name|know
argument_list|(
name|prev_pinfo
operator|&
name|INSN_WRITE_GPR_T
argument_list|)
expr_stmt|;
if|if
condition|(
name|mips_optimize
operator|==
literal|0
operator|||
name|insn_uses_reg
argument_list|(
name|ip
argument_list|,
operator|(
operator|(
name|prev_insn
operator|.
name|insn_opcode
operator|>>
name|OP_SH_RT
operator|)
operator|&
name|OP_MASK_RT
operator|)
argument_list|,
name|MIPS_GR_REG
argument_list|)
condition|)
operator|++
name|nops
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|mips_opts
operator|.
name|mips16
operator|&&
operator|(
operator|(
operator|(
name|prev_pinfo
operator|&
name|INSN_COPROC_MOVE_DELAY
operator|)
operator|&&
operator|!
name|cop_interlocks
operator|)
operator|||
operator|(
operator|(
name|prev_pinfo
operator|&
name|INSN_COPROC_MEMORY_DELAY
operator|)
operator|&&
operator|!
name|cop_mem_interlocks
operator|)
operator|)
condition|)
block|{
comment|/* A generic coprocessor delay.  The previous instruction 	     modified a coprocessor general or control register.  If 	     it modified a control register, we need to avoid any 	     coprocessor instruction (this is probably not always 	     required, but it sometimes is).  If it modified a general 	     register, we avoid using that register.  	     This case is not handled very well.  There is no special 	     knowledge of CP0 handling, and the coprocessors other 	     than the floating point unit are not distinguished at 	     all.  */
comment|/* Itbl support may require additional care here. FIXME!              Need to modify this to include knowledge about              user specified delays!  */
if|if
condition|(
name|prev_pinfo
operator|&
name|INSN_WRITE_FPR_T
condition|)
block|{
if|if
condition|(
name|mips_optimize
operator|==
literal|0
operator|||
name|insn_uses_reg
argument_list|(
name|ip
argument_list|,
operator|(
operator|(
name|prev_insn
operator|.
name|insn_opcode
operator|>>
name|OP_SH_FT
operator|)
operator|&
name|OP_MASK_FT
operator|)
argument_list|,
name|MIPS_FP_REG
argument_list|)
condition|)
operator|++
name|nops
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|prev_pinfo
operator|&
name|INSN_WRITE_FPR_S
condition|)
block|{
if|if
condition|(
name|mips_optimize
operator|==
literal|0
operator|||
name|insn_uses_reg
argument_list|(
name|ip
argument_list|,
operator|(
operator|(
name|prev_insn
operator|.
name|insn_opcode
operator|>>
name|OP_SH_FS
operator|)
operator|&
name|OP_MASK_FS
operator|)
argument_list|,
name|MIPS_FP_REG
argument_list|)
condition|)
operator|++
name|nops
expr_stmt|;
block|}
else|else
block|{
comment|/* We don't know exactly what the previous instruction 		 does.  If the current instruction uses a coprocessor 		 register, we must insert a NOP.  If previous 		 instruction may set the condition codes, and the 		 current instruction uses them, we must insert two 		 NOPS.  */
comment|/* Itbl support may require additional care here.  */
if|if
condition|(
name|mips_optimize
operator|==
literal|0
operator|||
operator|(
operator|(
name|prev_pinfo
operator|&
name|INSN_WRITE_COND_CODE
operator|)
operator|&&
operator|(
name|pinfo
operator|&
name|INSN_READ_COND_CODE
operator|)
operator|)
condition|)
name|nops
operator|+=
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
name|pinfo
operator|&
name|INSN_COP
condition|)
operator|++
name|nops
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|mips_opts
operator|.
name|mips16
operator|&&
operator|(
name|prev_pinfo
operator|&
name|INSN_WRITE_COND_CODE
operator|)
operator|&&
operator|!
name|cop_interlocks
condition|)
block|{
comment|/* The previous instruction sets the coprocessor condition 	     codes, but does not require a general coprocessor delay 	     (this means it is a floating point comparison 	     instruction).  If this instruction uses the condition 	     codes, we need to insert a single NOP.  */
comment|/* Itbl support may require additional care here.  */
if|if
condition|(
name|mips_optimize
operator|==
literal|0
operator|||
operator|(
name|pinfo
operator|&
name|INSN_READ_COND_CODE
operator|)
condition|)
operator|++
name|nops
expr_stmt|;
block|}
comment|/* If we're fixing up mfhi/mflo for the r7000 and the 	 previous insn was an mfhi/mflo and the current insn 	 reads the register that the mfhi/mflo wrote to, then 	 insert two nops.  */
elseif|else
if|if
condition|(
name|mips_7000_hilo_fix
operator|&&
name|MF_HILO_INSN
argument_list|(
name|prev_pinfo
argument_list|)
operator|&&
name|insn_uses_reg
argument_list|(
name|ip
argument_list|,
operator|(
operator|(
name|prev_insn
operator|.
name|insn_opcode
operator|>>
name|OP_SH_RD
operator|)
operator|&
name|OP_MASK_RD
operator|)
argument_list|,
name|MIPS_GR_REG
argument_list|)
condition|)
block|{
name|nops
operator|+=
literal|2
expr_stmt|;
block|}
comment|/* If we're fixing up mfhi/mflo for the r7000 and the 	 2nd previous insn was an mfhi/mflo and the current insn 	 reads the register that the mfhi/mflo wrote to, then 	 insert one nop.  */
elseif|else
if|if
condition|(
name|mips_7000_hilo_fix
operator|&&
name|MF_HILO_INSN
argument_list|(
name|prev_prev_insn
operator|.
name|insn_opcode
argument_list|)
operator|&&
name|insn_uses_reg
argument_list|(
name|ip
argument_list|,
operator|(
operator|(
name|prev_prev_insn
operator|.
name|insn_opcode
operator|>>
name|OP_SH_RD
operator|)
operator|&
name|OP_MASK_RD
operator|)
argument_list|,
name|MIPS_GR_REG
argument_list|)
condition|)
block|{
operator|++
name|nops
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|prev_pinfo
operator|&
name|INSN_READ_LO
condition|)
block|{
comment|/* The previous instruction reads the LO register; if the 	     current instruction writes to the LO register, we must 	     insert two NOPS.  Some newer processors have interlocks. 	     Also the tx39's multiply instructions can be executed              immediately after a read from HI/LO (without the delay),              though the tx39's divide insns still do require the 	     delay.  */
if|if
condition|(
operator|!
operator|(
name|hilo_interlocks
operator|||
operator|(
name|mips_opts
operator|.
name|arch
operator|==
name|CPU_R3900
operator|&&
operator|(
name|pinfo
operator|&
name|INSN_MULT
operator|)
operator|)
operator|)
operator|&&
operator|(
name|mips_optimize
operator|==
literal|0
operator|||
operator|(
name|pinfo
operator|&
name|INSN_WRITE_LO
operator|)
operator|)
condition|)
name|nops
operator|+=
literal|2
expr_stmt|;
comment|/* Most mips16 branch insns don't have a delay slot. 	     If a read from LO is immediately followed by a branch 	     to a write to LO we have a read followed by a write 	     less than 2 insns away.  We assume the target of 	     a branch might be a write to LO, and insert a nop 	     between a read and an immediately following branch.  */
elseif|else
if|if
condition|(
name|mips_opts
operator|.
name|mips16
operator|&&
operator|(
name|mips_optimize
operator|==
literal|0
operator|||
operator|(
name|pinfo
operator|&
name|MIPS16_INSN_BRANCH
operator|)
operator|)
condition|)
operator|++
name|nops
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|prev_insn
operator|.
name|insn_mo
operator|->
name|pinfo
operator|&
name|INSN_READ_HI
condition|)
block|{
comment|/* The previous instruction reads the HI register; if the 	     current instruction writes to the HI register, we must 	     insert a NOP.  Some newer processors have interlocks. 	     Also the note tx39's multiply above.  */
if|if
condition|(
operator|!
operator|(
name|hilo_interlocks
operator|||
operator|(
name|mips_opts
operator|.
name|arch
operator|==
name|CPU_R3900
operator|&&
operator|(
name|pinfo
operator|&
name|INSN_MULT
operator|)
operator|)
operator|)
operator|&&
operator|(
name|mips_optimize
operator|==
literal|0
operator|||
operator|(
name|pinfo
operator|&
name|INSN_WRITE_HI
operator|)
operator|)
condition|)
name|nops
operator|+=
literal|2
expr_stmt|;
comment|/* Most mips16 branch insns don't have a delay slot. 	     If a read from HI is immediately followed by a branch 	     to a write to HI we have a read followed by a write 	     less than 2 insns away.  We assume the target of 	     a branch might be a write to HI, and insert a nop 	     between a read and an immediately following branch.  */
elseif|else
if|if
condition|(
name|mips_opts
operator|.
name|mips16
operator|&&
operator|(
name|mips_optimize
operator|==
literal|0
operator|||
operator|(
name|pinfo
operator|&
name|MIPS16_INSN_BRANCH
operator|)
operator|)
condition|)
operator|++
name|nops
expr_stmt|;
block|}
comment|/* If the previous instruction was in a noreorder section, then          we don't want to insert the nop after all.  */
comment|/* Itbl support may require additional care here.  */
if|if
condition|(
name|prev_insn_unreordered
condition|)
name|nops
operator|=
literal|0
expr_stmt|;
comment|/* There are two cases which require two intervening 	 instructions: 1) setting the condition codes using a move to 	 coprocessor instruction which requires a general coprocessor 	 delay and then reading the condition codes 2) reading the HI 	 or LO register and then writing to it (except on processors 	 which have interlocks).  If we are not already emitting a NOP 	 instruction, we must check for these cases compared to the 	 instruction previous to the previous instruction.  */
if|if
condition|(
operator|(
operator|!
name|mips_opts
operator|.
name|mips16
operator|&&
operator|(
name|prev_prev_insn
operator|.
name|insn_mo
operator|->
name|pinfo
operator|&
name|INSN_COPROC_MOVE_DELAY
operator|)
operator|&&
operator|(
name|prev_prev_insn
operator|.
name|insn_mo
operator|->
name|pinfo
operator|&
name|INSN_WRITE_COND_CODE
operator|)
operator|&&
operator|(
name|pinfo
operator|&
name|INSN_READ_COND_CODE
operator|)
operator|&&
operator|!
name|cop_interlocks
operator|)
operator|||
operator|(
operator|(
name|prev_prev_insn
operator|.
name|insn_mo
operator|->
name|pinfo
operator|&
name|INSN_READ_LO
operator|)
operator|&&
operator|(
name|pinfo
operator|&
name|INSN_WRITE_LO
operator|)
operator|&&
operator|!
operator|(
name|hilo_interlocks
operator|||
operator|(
name|mips_opts
operator|.
name|arch
operator|==
name|CPU_R3900
operator|&&
operator|(
name|pinfo
operator|&
name|INSN_MULT
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
operator|(
name|prev_prev_insn
operator|.
name|insn_mo
operator|->
name|pinfo
operator|&
name|INSN_READ_HI
operator|)
operator|&&
operator|(
name|pinfo
operator|&
name|INSN_WRITE_HI
operator|)
operator|&&
operator|!
operator|(
name|hilo_interlocks
operator|||
operator|(
name|mips_opts
operator|.
name|arch
operator|==
name|CPU_R3900
operator|&&
operator|(
name|pinfo
operator|&
name|INSN_MULT
operator|)
operator|)
operator|)
operator|)
condition|)
name|prev_prev_nop
operator|=
literal|1
expr_stmt|;
else|else
name|prev_prev_nop
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|prev_prev_insn_unreordered
condition|)
name|prev_prev_nop
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|prev_prev_nop
operator|&&
name|nops
operator|==
literal|0
condition|)
operator|++
name|nops
expr_stmt|;
if|if
condition|(
name|mips_fix_vr4120
operator|&&
name|prev_insn
operator|.
name|insn_mo
operator|->
name|name
condition|)
block|{
comment|/* We're out of bits in pinfo, so we must resort to string 	     ops here.  Shortcuts are selected based on opcodes being 	     limited to the VR4120 instruction set.  */
name|int
name|min_nops
init|=
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
name|pn
init|=
name|prev_insn
operator|.
name|insn_mo
operator|->
name|name
decl_stmt|;
specifier|const
name|char
modifier|*
name|tn
init|=
name|ip
operator|->
name|insn_mo
operator|->
name|name
decl_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|pn
argument_list|,
literal|"macc"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
operator|||
name|strncmp
argument_list|(
name|pn
argument_list|,
literal|"dmacc"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Errata 21 - [D]DIV[U] after [D]MACC */
if|if
condition|(
name|strstr
argument_list|(
name|tn
argument_list|,
literal|"div"
argument_list|)
condition|)
block|{
name|min_nops
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Errata 23 - Continuous DMULT[U]/DMACC instructions */
if|if
condition|(
name|pn
index|[
literal|0
index|]
operator|==
literal|'d'
comment|/* dmacc */
operator|&&
operator|(
name|strncmp
argument_list|(
name|tn
argument_list|,
literal|"dmult"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
operator|||
name|strncmp
argument_list|(
name|tn
argument_list|,
literal|"dmacc"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|min_nops
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Errata 24 - MT{LO,HI} after [D]MACC */
if|if
condition|(
name|strcmp
argument_list|(
name|tn
argument_list|,
literal|"mtlo"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|tn
argument_list|,
literal|"mthi"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|min_nops
operator|=
literal|1
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|pn
argument_list|,
literal|"dmult"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|strncmp
argument_list|(
name|tn
argument_list|,
literal|"dmult"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
operator|||
name|strncmp
argument_list|(
name|tn
argument_list|,
literal|"dmacc"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* Here is the rest of errata 23.  */
name|min_nops
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|nops
operator|<
name|min_nops
condition|)
name|nops
operator|=
name|min_nops
expr_stmt|;
block|}
comment|/* If we are being given a nop instruction, don't bother with 	 one of the nops we would otherwise output.  This will only 	 happen when a nop instruction is used with mips_optimize set 	 to 0.  */
if|if
condition|(
name|nops
operator|>
literal|0
operator|&&
operator|!
name|mips_opts
operator|.
name|noreorder
operator|&&
name|ip
operator|->
name|insn_opcode
operator|==
call|(
name|unsigned
call|)
argument_list|(
name|mips_opts
operator|.
name|mips16
condition|?
literal|0x6500
else|:
literal|0
argument_list|)
condition|)
operator|--
name|nops
expr_stmt|;
comment|/* Now emit the right number of NOP instructions.  */
if|if
condition|(
name|nops
operator|>
literal|0
operator|&&
operator|!
name|mips_opts
operator|.
name|noreorder
condition|)
block|{
name|fragS
modifier|*
name|old_frag
decl_stmt|;
name|unsigned
name|long
name|old_frag_offset
decl_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|insn_label_list
modifier|*
name|l
decl_stmt|;
name|old_frag
operator|=
name|frag_now
expr_stmt|;
name|old_frag_offset
operator|=
name|frag_now_fix
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nops
condition|;
name|i
operator|++
control|)
name|emit_nop
argument_list|()
expr_stmt|;
if|if
condition|(
name|listing
condition|)
block|{
name|listing_prev_line
argument_list|()
expr_stmt|;
comment|/* We may be at the start of a variant frag.  In case we                  are, make sure there is enough space for the frag                  after the frags created by listing_prev_line.  The                  argument to frag_grow here must be at least as large                  as the argument to all other calls to frag_grow in                  this file.  We don't have to worry about being in the                  middle of a variant frag, because the variants insert                  all needed nop instructions themselves.  */
name|frag_grow
argument_list|(
literal|40
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|l
operator|=
name|insn_labels
init|;
name|l
operator|!=
name|NULL
condition|;
name|l
operator|=
name|l
operator|->
name|next
control|)
block|{
name|valueT
name|val
decl_stmt|;
name|assert
argument_list|(
name|S_GET_SEGMENT
argument_list|(
name|l
operator|->
name|label
argument_list|)
operator|==
name|now_seg
argument_list|)
expr_stmt|;
name|symbol_set_frag
argument_list|(
name|l
operator|->
name|label
argument_list|,
name|frag_now
argument_list|)
expr_stmt|;
name|val
operator|=
operator|(
name|valueT
operator|)
name|frag_now_fix
argument_list|()
expr_stmt|;
comment|/* mips16 text labels are stored as odd.  */
if|if
condition|(
name|mips_opts
operator|.
name|mips16
condition|)
operator|++
name|val
expr_stmt|;
name|S_SET_VALUE
argument_list|(
name|l
operator|->
name|label
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|NO_ECOFF_DEBUGGING
if|if
condition|(
name|ECOFF_DEBUGGING
condition|)
name|ecoff_fix_loc
argument_list|(
name|old_frag
argument_list|,
name|old_frag_offset
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|prev_nop_frag
operator|!=
name|NULL
condition|)
block|{
comment|/* We have a frag holding nops we may be able to remove.  If              we don't need any nops, we can decrease the size of              prev_nop_frag by the size of one instruction.  If we do              need some nops, we count them in prev_nops_required.  */
if|if
condition|(
name|prev_nop_frag_since
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|nops
operator|==
literal|0
condition|)
block|{
name|prev_nop_frag
operator|->
name|fr_fix
operator|-=
name|mips_opts
operator|.
name|mips16
condition|?
literal|2
else|:
literal|4
expr_stmt|;
operator|--
name|prev_nop_frag_holds
expr_stmt|;
block|}
else|else
name|prev_nop_frag_required
operator|+=
name|nops
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|prev_prev_nop
operator|==
literal|0
condition|)
block|{
name|prev_nop_frag
operator|->
name|fr_fix
operator|-=
name|mips_opts
operator|.
name|mips16
condition|?
literal|2
else|:
literal|4
expr_stmt|;
operator|--
name|prev_nop_frag_holds
expr_stmt|;
block|}
else|else
operator|++
name|prev_nop_frag_required
expr_stmt|;
block|}
if|if
condition|(
name|prev_nop_frag_holds
operator|<=
name|prev_nop_frag_required
condition|)
name|prev_nop_frag
operator|=
name|NULL
expr_stmt|;
operator|++
name|prev_nop_frag_since
expr_stmt|;
comment|/* Sanity check: by the time we reach the second instruction              after prev_nop_frag, we should have used up all the nops              one way or another.  */
name|assert
argument_list|(
name|prev_nop_frag_since
operator|<=
literal|1
operator|||
name|prev_nop_frag
operator|==
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Record the frag type before frag_var.  */
if|if
condition|(
name|prev_insn_frag
condition|)
name|prev_insn_frag_type
operator|=
name|prev_insn_frag
operator|->
name|fr_type
expr_stmt|;
if|if
condition|(
name|address_expr
operator|&&
operator|*
name|reloc_type
operator|==
name|BFD_RELOC_16_PCREL_S2
operator|&&
operator|(
name|pinfo
operator|&
name|INSN_UNCOND_BRANCH_DELAY
operator|||
name|pinfo
operator|&
name|INSN_COND_BRANCH_DELAY
operator|||
name|pinfo
operator|&
name|INSN_COND_BRANCH_LIKELY
operator|)
operator|&&
name|mips_relax_branch
comment|/* Don't try branch relaxation within .set nomacro, or within 	 .set noat if we use $at for PIC computations.  If it turns 	 out that the branch was out-of-range, we'll get an error.  */
operator|&&
operator|!
name|mips_opts
operator|.
name|warn_about_macros
operator|&&
operator|!
operator|(
name|mips_opts
operator|.
name|noat
operator|&&
name|mips_pic
operator|!=
name|NO_PIC
operator|)
operator|&&
operator|!
name|mips_opts
operator|.
name|mips16
condition|)
block|{
name|relaxed_branch
operator|=
name|TRUE
expr_stmt|;
name|f
operator|=
name|frag_var
argument_list|(
name|rs_machine_dependent
argument_list|,
name|relaxed_branch_length
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|(
name|pinfo
operator|&
name|INSN_UNCOND_BRANCH_DELAY
operator|)
condition|?
operator|-
literal|1
else|:
operator|(
name|pinfo
operator|&
name|INSN_COND_BRANCH_LIKELY
operator|)
condition|?
literal|1
else|:
literal|0
argument_list|)
argument_list|,
literal|4
argument_list|,
name|RELAX_BRANCH_ENCODE
argument_list|(
name|pinfo
operator|&
name|INSN_UNCOND_BRANCH_DELAY
argument_list|,
name|pinfo
operator|&
name|INSN_COND_BRANCH_LIKELY
argument_list|,
name|pinfo
operator|&
name|INSN_WRITE_GPR_31
argument_list|,
literal|0
argument_list|)
argument_list|,
name|address_expr
operator|->
name|X_add_symbol
argument_list|,
name|address_expr
operator|->
name|X_add_number
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|*
name|reloc_type
operator|=
name|BFD_RELOC_UNUSED
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|reloc_type
operator|>
name|BFD_RELOC_UNUSED
condition|)
block|{
comment|/* We need to set up a variant frag.  */
name|assert
argument_list|(
name|mips_opts
operator|.
name|mips16
operator|&&
name|address_expr
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|f
operator|=
name|frag_var
argument_list|(
name|rs_machine_dependent
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|,
name|RELAX_MIPS16_ENCODE
argument_list|(
operator|*
name|reloc_type
operator|-
name|BFD_RELOC_UNUSED
argument_list|,
name|mips16_small
argument_list|,
name|mips16_ext
argument_list|,
operator|(
name|prev_pinfo
operator|&
name|INSN_UNCOND_BRANCH_DELAY
operator|)
argument_list|,
operator|(
operator|*
name|prev_insn_reloc_type
operator|==
name|BFD_RELOC_MIPS16_JMP
operator|)
argument_list|)
argument_list|,
name|make_expr_symbol
argument_list|(
name|address_expr
argument_list|)
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mips_opts
operator|.
name|mips16
operator|&&
operator|!
name|ip
operator|->
name|use_extend
operator|&&
operator|*
name|reloc_type
operator|!=
name|BFD_RELOC_MIPS16_JMP
condition|)
block|{
comment|/* Make sure there is enough room to swap this instruction with          a following jump instruction.  */
name|frag_grow
argument_list|(
literal|6
argument_list|)
expr_stmt|;
name|f
operator|=
name|frag_more
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|mips_opts
operator|.
name|mips16
operator|&&
name|mips_opts
operator|.
name|noreorder
operator|&&
operator|(
name|prev_pinfo
operator|&
name|INSN_UNCOND_BRANCH_DELAY
operator|)
operator|!=
literal|0
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"extended instruction in delay slot"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mips_relax
operator|.
name|sequence
condition|)
block|{
comment|/* If we've reached the end of this frag, turn it into a variant 	     frag and record the information for the instructions we've 	     written so far.  */
if|if
condition|(
name|frag_room
argument_list|()
operator|<
literal|4
condition|)
name|relax_close_frag
argument_list|()
expr_stmt|;
name|mips_relax
operator|.
name|sizes
index|[
name|mips_relax
operator|.
name|sequence
operator|-
literal|1
index|]
operator|+=
literal|4
expr_stmt|;
block|}
if|if
condition|(
name|mips_relax
operator|.
name|sequence
operator|!=
literal|2
condition|)
name|mips_macro_warning
operator|.
name|sizes
index|[
literal|0
index|]
operator|+=
literal|4
expr_stmt|;
if|if
condition|(
name|mips_relax
operator|.
name|sequence
operator|!=
literal|1
condition|)
name|mips_macro_warning
operator|.
name|sizes
index|[
literal|1
index|]
operator|+=
literal|4
expr_stmt|;
name|f
operator|=
name|frag_more
argument_list|(
literal|4
argument_list|)
expr_stmt|;
block|}
name|fixp
index|[
literal|0
index|]
operator|=
name|fixp
index|[
literal|1
index|]
operator|=
name|fixp
index|[
literal|2
index|]
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|address_expr
operator|!=
name|NULL
operator|&&
operator|*
name|reloc_type
operator|<
name|BFD_RELOC_UNUSED
condition|)
block|{
if|if
condition|(
name|address_expr
operator|->
name|X_op
operator|==
name|O_constant
condition|)
block|{
name|valueT
name|tmp
decl_stmt|;
switch|switch
condition|(
operator|*
name|reloc_type
condition|)
block|{
case|case
name|BFD_RELOC_32
case|:
name|ip
operator|->
name|insn_opcode
operator||=
name|address_expr
operator|->
name|X_add_number
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_MIPS_HIGHEST
case|:
name|tmp
operator|=
operator|(
name|address_expr
operator|->
name|X_add_number
operator|+
operator|(
operator|(
name|valueT
operator|)
literal|0x8000
operator|<<
literal|32
operator|)
operator|+
literal|0x80008000
operator|)
operator|>>
literal|16
expr_stmt|;
name|tmp
operator|>>=
literal|16
expr_stmt|;
name|ip
operator|->
name|insn_opcode
operator||=
operator|(
name|tmp
operator|>>
literal|16
operator|)
operator|&
literal|0xffff
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_MIPS_HIGHER
case|:
name|tmp
operator|=
operator|(
name|address_expr
operator|->
name|X_add_number
operator|+
literal|0x80008000
operator|)
operator|>>
literal|16
expr_stmt|;
name|ip
operator|->
name|insn_opcode
operator||=
operator|(
name|tmp
operator|>>
literal|16
operator|)
operator|&
literal|0xffff
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_HI16_S
case|:
name|ip
operator|->
name|insn_opcode
operator||=
operator|(
operator|(
name|address_expr
operator|->
name|X_add_number
operator|+
literal|0x8000
operator|)
operator|>>
literal|16
operator|)
operator|&
literal|0xffff
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_HI16
case|:
name|ip
operator|->
name|insn_opcode
operator||=
operator|(
name|address_expr
operator|->
name|X_add_number
operator|>>
literal|16
operator|)
operator|&
literal|0xffff
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_LO16
case|:
case|case
name|BFD_RELOC_MIPS_GOT_DISP
case|:
name|ip
operator|->
name|insn_opcode
operator||=
name|address_expr
operator|->
name|X_add_number
operator|&
literal|0xffff
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_MIPS_JMP
case|:
if|if
condition|(
operator|(
name|address_expr
operator|->
name|X_add_number
operator|&
literal|3
operator|)
operator|!=
literal|0
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"jump to misaligned address (0x%lx)"
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|address_expr
operator|->
name|X_add_number
argument_list|)
expr_stmt|;
if|if
condition|(
name|address_expr
operator|->
name|X_add_number
operator|&
operator|~
literal|0xfffffff
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"jump address range overflow (0x%lx)"
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|address_expr
operator|->
name|X_add_number
argument_list|)
expr_stmt|;
name|ip
operator|->
name|insn_opcode
operator||=
operator|(
name|address_expr
operator|->
name|X_add_number
operator|>>
literal|2
operator|)
operator|&
literal|0x3ffffff
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_MIPS16_JMP
case|:
if|if
condition|(
operator|(
name|address_expr
operator|->
name|X_add_number
operator|&
literal|3
operator|)
operator|!=
literal|0
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"jump to misaligned address (0x%lx)"
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|address_expr
operator|->
name|X_add_number
argument_list|)
expr_stmt|;
if|if
condition|(
name|address_expr
operator|->
name|X_add_number
operator|&
operator|~
literal|0xfffffff
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"jump address range overflow (0x%lx)"
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|address_expr
operator|->
name|X_add_number
argument_list|)
expr_stmt|;
name|ip
operator|->
name|insn_opcode
operator||=
operator|(
operator|(
operator|(
name|address_expr
operator|->
name|X_add_number
operator|&
literal|0x7c0000
operator|)
operator|<<
literal|3
operator|)
operator||
operator|(
operator|(
name|address_expr
operator|->
name|X_add_number
operator|&
literal|0xf800000
operator|)
operator|>>
literal|7
operator|)
operator||
operator|(
operator|(
name|address_expr
operator|->
name|X_add_number
operator|&
literal|0x3fffc
operator|)
operator|>>
literal|2
operator|)
operator|)
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_16_PCREL_S2
case|:
goto|goto
name|need_reloc
goto|;
default|default:
name|internalError
argument_list|()
expr_stmt|;
block|}
block|}
else|else
name|need_reloc
label|:
block|{
name|reloc_howto_type
modifier|*
name|howto
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* In a compound relocation, it is the final (outermost) 	     operator that determines the relocated field.  */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
literal|3
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|reloc_type
index|[
name|i
index|]
operator|==
name|BFD_RELOC_UNUSED
condition|)
break|break;
name|howto
operator|=
name|bfd_reloc_type_lookup
argument_list|(
name|stdoutput
argument_list|,
name|reloc_type
index|[
name|i
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
name|fixp
index|[
literal|0
index|]
operator|=
name|fix_new_exp
argument_list|(
name|frag_now
argument_list|,
name|f
operator|-
name|frag_now
operator|->
name|fr_literal
argument_list|,
name|bfd_get_reloc_size
argument_list|(
name|howto
argument_list|)
argument_list|,
name|address_expr
argument_list|,
name|reloc_type
index|[
literal|0
index|]
operator|==
name|BFD_RELOC_16_PCREL_S2
argument_list|,
name|reloc_type
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* These relocations can have an addend that won't fit in 	     4 octets for 64bit assembly.  */
if|if
condition|(
name|HAVE_64BIT_GPRS
operator|&&
operator|!
name|howto
operator|->
name|partial_inplace
operator|&&
operator|(
name|reloc_type
index|[
literal|0
index|]
operator|==
name|BFD_RELOC_16
operator|||
name|reloc_type
index|[
literal|0
index|]
operator|==
name|BFD_RELOC_32
operator|||
name|reloc_type
index|[
literal|0
index|]
operator|==
name|BFD_RELOC_MIPS_JMP
operator|||
name|reloc_type
index|[
literal|0
index|]
operator|==
name|BFD_RELOC_HI16_S
operator|||
name|reloc_type
index|[
literal|0
index|]
operator|==
name|BFD_RELOC_LO16
operator|||
name|reloc_type
index|[
literal|0
index|]
operator|==
name|BFD_RELOC_GPREL16
operator|||
name|reloc_type
index|[
literal|0
index|]
operator|==
name|BFD_RELOC_MIPS_LITERAL
operator|||
name|reloc_type
index|[
literal|0
index|]
operator|==
name|BFD_RELOC_GPREL32
operator|||
name|reloc_type
index|[
literal|0
index|]
operator|==
name|BFD_RELOC_64
operator|||
name|reloc_type
index|[
literal|0
index|]
operator|==
name|BFD_RELOC_CTOR
operator|||
name|reloc_type
index|[
literal|0
index|]
operator|==
name|BFD_RELOC_MIPS_SUB
operator|||
name|reloc_type
index|[
literal|0
index|]
operator|==
name|BFD_RELOC_MIPS_HIGHEST
operator|||
name|reloc_type
index|[
literal|0
index|]
operator|==
name|BFD_RELOC_MIPS_HIGHER
operator|||
name|reloc_type
index|[
literal|0
index|]
operator|==
name|BFD_RELOC_MIPS_SCN_DISP
operator|||
name|reloc_type
index|[
literal|0
index|]
operator|==
name|BFD_RELOC_MIPS_REL16
operator|||
name|reloc_type
index|[
literal|0
index|]
operator|==
name|BFD_RELOC_MIPS_RELGOT
operator|)
condition|)
name|fixp
index|[
literal|0
index|]
operator|->
name|fx_no_overflow
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|mips_relax
operator|.
name|sequence
condition|)
block|{
if|if
condition|(
name|mips_relax
operator|.
name|first_fixup
operator|==
literal|0
condition|)
name|mips_relax
operator|.
name|first_fixup
operator|=
name|fixp
index|[
literal|0
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|reloc_needs_lo_p
argument_list|(
operator|*
name|reloc_type
argument_list|)
condition|)
block|{
name|struct
name|mips_hi_fixup
modifier|*
name|hi_fixup
decl_stmt|;
comment|/* Reuse the last entry if it already has a matching %lo.  */
name|hi_fixup
operator|=
name|mips_hi_fixup_list
expr_stmt|;
if|if
condition|(
name|hi_fixup
operator|==
literal|0
operator|||
operator|!
name|fixup_has_matching_lo_p
argument_list|(
name|hi_fixup
operator|->
name|fixp
argument_list|)
condition|)
block|{
name|hi_fixup
operator|=
operator|(
operator|(
expr|struct
name|mips_hi_fixup
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|mips_hi_fixup
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|hi_fixup
operator|->
name|next
operator|=
name|mips_hi_fixup_list
expr_stmt|;
name|mips_hi_fixup_list
operator|=
name|hi_fixup
expr_stmt|;
block|}
name|hi_fixup
operator|->
name|fixp
operator|=
name|fixp
index|[
literal|0
index|]
expr_stmt|;
name|hi_fixup
operator|->
name|seg
operator|=
name|now_seg
expr_stmt|;
block|}
comment|/* Add fixups for the second and third relocations, if given. 	     Note that the ABI allows the second relocation to be 	     against RSS_UNDEF, RSS_GP, RSS_GP0 or RSS_LOC.  At the 	     moment we only use RSS_UNDEF, but we could add support 	     for the others if it ever becomes necessary.  */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
literal|3
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|reloc_type
index|[
name|i
index|]
operator|!=
name|BFD_RELOC_UNUSED
condition|)
block|{
name|address_expr
operator|->
name|X_op
operator|=
name|O_absent
expr_stmt|;
name|address_expr
operator|->
name|X_add_symbol
operator|=
literal|0
expr_stmt|;
name|address_expr
operator|->
name|X_add_number
operator|=
literal|0
expr_stmt|;
name|fixp
index|[
name|i
index|]
operator|=
name|fix_new_exp
argument_list|(
name|frag_now
argument_list|,
name|fixp
index|[
literal|0
index|]
operator|->
name|fx_where
argument_list|,
name|fixp
index|[
literal|0
index|]
operator|->
name|fx_size
argument_list|,
name|address_expr
argument_list|,
name|FALSE
argument_list|,
name|reloc_type
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|mips_opts
operator|.
name|mips16
condition|)
block|{
name|md_number_to_chars
argument_list|(
name|f
argument_list|,
name|ip
operator|->
name|insn_opcode
argument_list|,
literal|4
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|OBJ_ELF
name|dwarf2_emit_insn
argument_list|(
literal|4
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
operator|*
name|reloc_type
operator|==
name|BFD_RELOC_MIPS16_JMP
condition|)
block|{
name|md_number_to_chars
argument_list|(
name|f
argument_list|,
name|ip
operator|->
name|insn_opcode
operator|>>
literal|16
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|f
operator|+
literal|2
argument_list|,
name|ip
operator|->
name|insn_opcode
operator|&
literal|0xffff
argument_list|,
literal|2
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|OBJ_ELF
name|dwarf2_emit_insn
argument_list|(
literal|4
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
if|if
condition|(
name|ip
operator|->
name|use_extend
condition|)
block|{
name|md_number_to_chars
argument_list|(
name|f
argument_list|,
literal|0xf000
operator||
name|ip
operator|->
name|extend
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|f
operator|+=
literal|2
expr_stmt|;
block|}
name|md_number_to_chars
argument_list|(
name|f
argument_list|,
name|ip
operator|->
name|insn_opcode
argument_list|,
literal|2
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|OBJ_ELF
name|dwarf2_emit_insn
argument_list|(
name|ip
operator|->
name|use_extend
condition|?
literal|4
else|:
literal|2
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* Update the register mask information.  */
if|if
condition|(
operator|!
name|mips_opts
operator|.
name|mips16
condition|)
block|{
if|if
condition|(
name|pinfo
operator|&
name|INSN_WRITE_GPR_D
condition|)
name|mips_gprmask
operator||=
literal|1
operator|<<
operator|(
operator|(
name|ip
operator|->
name|insn_opcode
operator|>>
name|OP_SH_RD
operator|)
operator|&
name|OP_MASK_RD
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|pinfo
operator|&
operator|(
name|INSN_WRITE_GPR_T
operator||
name|INSN_READ_GPR_T
operator|)
operator|)
operator|!=
literal|0
condition|)
name|mips_gprmask
operator||=
literal|1
operator|<<
operator|(
operator|(
name|ip
operator|->
name|insn_opcode
operator|>>
name|OP_SH_RT
operator|)
operator|&
name|OP_MASK_RT
operator|)
expr_stmt|;
if|if
condition|(
name|pinfo
operator|&
name|INSN_READ_GPR_S
condition|)
name|mips_gprmask
operator||=
literal|1
operator|<<
operator|(
operator|(
name|ip
operator|->
name|insn_opcode
operator|>>
name|OP_SH_RS
operator|)
operator|&
name|OP_MASK_RS
operator|)
expr_stmt|;
if|if
condition|(
name|pinfo
operator|&
name|INSN_WRITE_GPR_31
condition|)
name|mips_gprmask
operator||=
literal|1
operator|<<
name|RA
expr_stmt|;
if|if
condition|(
name|pinfo
operator|&
name|INSN_WRITE_FPR_D
condition|)
name|mips_cprmask
index|[
literal|1
index|]
operator||=
literal|1
operator|<<
operator|(
operator|(
name|ip
operator|->
name|insn_opcode
operator|>>
name|OP_SH_FD
operator|)
operator|&
name|OP_MASK_FD
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|pinfo
operator|&
operator|(
name|INSN_WRITE_FPR_S
operator||
name|INSN_READ_FPR_S
operator|)
operator|)
operator|!=
literal|0
condition|)
name|mips_cprmask
index|[
literal|1
index|]
operator||=
literal|1
operator|<<
operator|(
operator|(
name|ip
operator|->
name|insn_opcode
operator|>>
name|OP_SH_FS
operator|)
operator|&
name|OP_MASK_FS
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|pinfo
operator|&
operator|(
name|INSN_WRITE_FPR_T
operator||
name|INSN_READ_FPR_T
operator|)
operator|)
operator|!=
literal|0
condition|)
name|mips_cprmask
index|[
literal|1
index|]
operator||=
literal|1
operator|<<
operator|(
operator|(
name|ip
operator|->
name|insn_opcode
operator|>>
name|OP_SH_FT
operator|)
operator|&
name|OP_MASK_FT
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|pinfo
operator|&
name|INSN_READ_FPR_R
operator|)
operator|!=
literal|0
condition|)
name|mips_cprmask
index|[
literal|1
index|]
operator||=
literal|1
operator|<<
operator|(
operator|(
name|ip
operator|->
name|insn_opcode
operator|>>
name|OP_SH_FR
operator|)
operator|&
name|OP_MASK_FR
operator|)
expr_stmt|;
if|if
condition|(
name|pinfo
operator|&
name|INSN_COP
condition|)
block|{
comment|/* We don't keep enough information to sort these cases out. 	     The itbl support does keep this information however, although 	     we currently don't support itbl fprmats as part of the cop 	     instruction.  May want to add this support in the future.  */
block|}
comment|/* Never set the bit for $0, which is always zero.  */
name|mips_gprmask
operator|&=
operator|~
literal|1
operator|<<
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|pinfo
operator|&
operator|(
name|MIPS16_INSN_WRITE_X
operator||
name|MIPS16_INSN_READ_X
operator|)
condition|)
name|mips_gprmask
operator||=
literal|1
operator|<<
operator|(
operator|(
name|ip
operator|->
name|insn_opcode
operator|>>
name|MIPS16OP_SH_RX
operator|)
operator|&
name|MIPS16OP_MASK_RX
operator|)
expr_stmt|;
if|if
condition|(
name|pinfo
operator|&
operator|(
name|MIPS16_INSN_WRITE_Y
operator||
name|MIPS16_INSN_READ_Y
operator|)
condition|)
name|mips_gprmask
operator||=
literal|1
operator|<<
operator|(
operator|(
name|ip
operator|->
name|insn_opcode
operator|>>
name|MIPS16OP_SH_RY
operator|)
operator|&
name|MIPS16OP_MASK_RY
operator|)
expr_stmt|;
if|if
condition|(
name|pinfo
operator|&
name|MIPS16_INSN_WRITE_Z
condition|)
name|mips_gprmask
operator||=
literal|1
operator|<<
operator|(
operator|(
name|ip
operator|->
name|insn_opcode
operator|>>
name|MIPS16OP_SH_RZ
operator|)
operator|&
name|MIPS16OP_MASK_RZ
operator|)
expr_stmt|;
if|if
condition|(
name|pinfo
operator|&
operator|(
name|MIPS16_INSN_WRITE_T
operator||
name|MIPS16_INSN_READ_T
operator|)
condition|)
name|mips_gprmask
operator||=
literal|1
operator|<<
name|TREG
expr_stmt|;
if|if
condition|(
name|pinfo
operator|&
operator|(
name|MIPS16_INSN_WRITE_SP
operator||
name|MIPS16_INSN_READ_SP
operator|)
condition|)
name|mips_gprmask
operator||=
literal|1
operator|<<
name|SP
expr_stmt|;
if|if
condition|(
name|pinfo
operator|&
operator|(
name|MIPS16_INSN_WRITE_31
operator||
name|MIPS16_INSN_READ_31
operator|)
condition|)
name|mips_gprmask
operator||=
literal|1
operator|<<
name|RA
expr_stmt|;
if|if
condition|(
name|pinfo
operator|&
name|MIPS16_INSN_WRITE_GPR_Y
condition|)
name|mips_gprmask
operator||=
literal|1
operator|<<
name|MIPS16OP_EXTRACT_REG32R
argument_list|(
name|ip
operator|->
name|insn_opcode
argument_list|)
expr_stmt|;
if|if
condition|(
name|pinfo
operator|&
name|MIPS16_INSN_READ_Z
condition|)
name|mips_gprmask
operator||=
literal|1
operator|<<
operator|(
operator|(
name|ip
operator|->
name|insn_opcode
operator|>>
name|MIPS16OP_SH_MOVE32Z
operator|)
operator|&
name|MIPS16OP_MASK_MOVE32Z
operator|)
expr_stmt|;
if|if
condition|(
name|pinfo
operator|&
name|MIPS16_INSN_READ_GPR_X
condition|)
name|mips_gprmask
operator||=
literal|1
operator|<<
operator|(
operator|(
name|ip
operator|->
name|insn_opcode
operator|>>
name|MIPS16OP_SH_REGR32
operator|)
operator|&
name|MIPS16OP_MASK_REGR32
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|mips_relax
operator|.
name|sequence
operator|!=
literal|2
operator|&&
operator|!
name|mips_opts
operator|.
name|noreorder
condition|)
block|{
comment|/* Filling the branch delay slot is more complex.  We try to 	 switch the branch with the previous instruction, which we can 	 do if the previous instruction does not set up a condition 	 that the branch tests and if the branch is not itself the 	 target of any branch.  */
if|if
condition|(
operator|(
name|pinfo
operator|&
name|INSN_UNCOND_BRANCH_DELAY
operator|)
operator|||
operator|(
name|pinfo
operator|&
name|INSN_COND_BRANCH_DELAY
operator|)
condition|)
block|{
if|if
condition|(
name|mips_optimize
operator|<
literal|2
comment|/* If we have seen .set volatile or .set nomove, don't 		 optimize.  */
operator|||
name|mips_opts
operator|.
name|nomove
operator|!=
literal|0
comment|/* If we had to emit any NOP instructions, then we 		 already know we can not swap.  */
operator|||
name|nops
operator|!=
literal|0
comment|/* If we don't even know the previous insn, we can not 		 swap.  */
operator|||
operator|!
name|prev_insn_valid
comment|/* If the previous insn is already in a branch delay 		 slot, then we can not swap.  */
operator|||
name|prev_insn_is_delay_slot
comment|/* If the previous previous insn was in a .set 		 noreorder, we can't swap.  Actually, the MIPS 		 assembler will swap in this situation.  However, gcc 		 configured -with-gnu-as will generate code like 		   .set noreorder 		   lw	$4,XXX 		   .set	reorder 		   INSN 		   bne	$4,$0,foo 		 in which we can not swap the bne and INSN.  If gcc is 		 not configured -with-gnu-as, it does not output the 		 .set pseudo-ops.  We don't have to check 		 prev_insn_unreordered, because prev_insn_valid will 		 be 0 in that case.  We don't want to use 		 prev_prev_insn_valid, because we do want to be able 		 to swap at the start of a function.  */
operator|||
name|prev_prev_insn_unreordered
comment|/* If the branch is itself the target of a branch, we 		 can not swap.  We cheat on this; all we check for is 		 whether there is a label on this instruction.  If 		 there are any branches to anything other than a 		 label, users must use .set noreorder.  */
operator|||
name|insn_labels
operator|!=
name|NULL
comment|/* If the previous instruction is in a variant frag 		 other than this branch's one, we cannot do the swap. 		 This does not apply to the mips16, which uses variant 		 frags for different purposes.  */
operator|||
operator|(
operator|!
name|mips_opts
operator|.
name|mips16
operator|&&
name|prev_insn_frag_type
operator|==
name|rs_machine_dependent
operator|)
comment|/* If the branch reads the condition codes, we don't 		 even try to swap, because in the sequence 		   ctc1 $X,$31 		   INSN 		   INSN 		   bc1t LABEL 		 we can not swap, and I don't feel like handling that 		 case.  */
operator|||
operator|(
operator|!
name|mips_opts
operator|.
name|mips16
operator|&&
operator|(
name|pinfo
operator|&
name|INSN_READ_COND_CODE
operator|)
operator|&&
operator|!
name|cop_interlocks
operator|)
comment|/* We can not swap with an instruction that requires a 		 delay slot, because the target of the branch might 		 interfere with that instruction.  */
operator|||
operator|(
operator|!
name|mips_opts
operator|.
name|mips16
operator|&&
operator|(
name|prev_pinfo
comment|/* Itbl support may require additional care here.  */
operator|&
operator|(
name|INSN_LOAD_COPROC_DELAY
operator||
name|INSN_COPROC_MOVE_DELAY
operator||
name|INSN_WRITE_COND_CODE
operator|)
operator|)
operator|&&
operator|!
name|cop_interlocks
operator|)
operator|||
operator|(
operator|!
operator|(
name|hilo_interlocks
operator|||
operator|(
name|mips_opts
operator|.
name|arch
operator|==
name|CPU_R3900
operator|&&
operator|(
name|pinfo
operator|&
name|INSN_MULT
operator|)
operator|)
operator|)
operator|&&
operator|(
name|prev_pinfo
operator|&
operator|(
name|INSN_READ_LO
operator||
name|INSN_READ_HI
operator|)
operator|)
operator|)
operator|||
operator|(
operator|!
name|mips_opts
operator|.
name|mips16
operator|&&
operator|(
name|prev_pinfo
operator|&
name|INSN_LOAD_MEMORY_DELAY
operator|)
operator|&&
operator|!
name|gpr_interlocks
operator|)
operator|||
operator|(
operator|!
name|mips_opts
operator|.
name|mips16
comment|/* Itbl support may require additional care here.  */
operator|&&
operator|(
name|prev_pinfo
operator|&
name|INSN_COPROC_MEMORY_DELAY
operator|)
operator|&&
operator|!
name|cop_mem_interlocks
operator|)
comment|/* We can not swap with a branch instruction.  */
operator|||
operator|(
name|prev_pinfo
operator|&
operator|(
name|INSN_UNCOND_BRANCH_DELAY
operator||
name|INSN_COND_BRANCH_DELAY
operator||
name|INSN_COND_BRANCH_LIKELY
operator|)
operator|)
comment|/* We do not swap with a trap instruction, since it 		 complicates trap handlers to have the trap 		 instruction be in a delay slot.  */
operator|||
operator|(
name|prev_pinfo
operator|&
name|INSN_TRAP
operator|)
comment|/* If the branch reads a register that the previous 		 instruction sets, we can not swap.  */
operator|||
operator|(
operator|!
name|mips_opts
operator|.
name|mips16
operator|&&
operator|(
name|prev_pinfo
operator|&
name|INSN_WRITE_GPR_T
operator|)
operator|&&
name|insn_uses_reg
argument_list|(
name|ip
argument_list|,
operator|(
operator|(
name|prev_insn
operator|.
name|insn_opcode
operator|>>
name|OP_SH_RT
operator|)
operator|&
name|OP_MASK_RT
operator|)
argument_list|,
name|MIPS_GR_REG
argument_list|)
operator|)
operator|||
operator|(
operator|!
name|mips_opts
operator|.
name|mips16
operator|&&
operator|(
name|prev_pinfo
operator|&
name|INSN_WRITE_GPR_D
operator|)
operator|&&
name|insn_uses_reg
argument_list|(
name|ip
argument_list|,
operator|(
operator|(
name|prev_insn
operator|.
name|insn_opcode
operator|>>
name|OP_SH_RD
operator|)
operator|&
name|OP_MASK_RD
operator|)
argument_list|,
name|MIPS_GR_REG
argument_list|)
operator|)
operator|||
operator|(
name|mips_opts
operator|.
name|mips16
operator|&&
operator|(
operator|(
operator|(
name|prev_pinfo
operator|&
name|MIPS16_INSN_WRITE_X
operator|)
operator|&&
name|insn_uses_reg
argument_list|(
name|ip
argument_list|,
operator|(
operator|(
name|prev_insn
operator|.
name|insn_opcode
operator|>>
name|MIPS16OP_SH_RX
operator|)
operator|&
name|MIPS16OP_MASK_RX
operator|)
argument_list|,
name|MIPS16_REG
argument_list|)
operator|)
operator|||
operator|(
operator|(
name|prev_pinfo
operator|&
name|MIPS16_INSN_WRITE_Y
operator|)
operator|&&
name|insn_uses_reg
argument_list|(
name|ip
argument_list|,
operator|(
operator|(
name|prev_insn
operator|.
name|insn_opcode
operator|>>
name|MIPS16OP_SH_RY
operator|)
operator|&
name|MIPS16OP_MASK_RY
operator|)
argument_list|,
name|MIPS16_REG
argument_list|)
operator|)
operator|||
operator|(
operator|(
name|prev_pinfo
operator|&
name|MIPS16_INSN_WRITE_Z
operator|)
operator|&&
name|insn_uses_reg
argument_list|(
name|ip
argument_list|,
operator|(
operator|(
name|prev_insn
operator|.
name|insn_opcode
operator|>>
name|MIPS16OP_SH_RZ
operator|)
operator|&
name|MIPS16OP_MASK_RZ
operator|)
argument_list|,
name|MIPS16_REG
argument_list|)
operator|)
operator|||
operator|(
operator|(
name|prev_pinfo
operator|&
name|MIPS16_INSN_WRITE_T
operator|)
operator|&&
name|insn_uses_reg
argument_list|(
name|ip
argument_list|,
name|TREG
argument_list|,
name|MIPS_GR_REG
argument_list|)
operator|)
operator|||
operator|(
operator|(
name|prev_pinfo
operator|&
name|MIPS16_INSN_WRITE_31
operator|)
operator|&&
name|insn_uses_reg
argument_list|(
name|ip
argument_list|,
name|RA
argument_list|,
name|MIPS_GR_REG
argument_list|)
operator|)
operator|||
operator|(
operator|(
name|prev_pinfo
operator|&
name|MIPS16_INSN_WRITE_GPR_Y
operator|)
operator|&&
name|insn_uses_reg
argument_list|(
name|ip
argument_list|,
name|MIPS16OP_EXTRACT_REG32R
argument_list|(
name|prev_insn
operator|.
name|insn_opcode
argument_list|)
argument_list|,
name|MIPS_GR_REG
argument_list|)
operator|)
operator|)
operator|)
comment|/* If the branch writes a register that the previous 		 instruction sets, we can not swap (we know that 		 branches write only to RD or to $31).  */
operator|||
operator|(
operator|!
name|mips_opts
operator|.
name|mips16
operator|&&
operator|(
name|prev_pinfo
operator|&
name|INSN_WRITE_GPR_T
operator|)
operator|&&
operator|(
operator|(
operator|(
name|pinfo
operator|&
name|INSN_WRITE_GPR_D
operator|)
operator|&&
operator|(
operator|(
operator|(
name|prev_insn
operator|.
name|insn_opcode
operator|>>
name|OP_SH_RT
operator|)
operator|&
name|OP_MASK_RT
operator|)
operator|==
operator|(
operator|(
name|ip
operator|->
name|insn_opcode
operator|>>
name|OP_SH_RD
operator|)
operator|&
name|OP_MASK_RD
operator|)
operator|)
operator|)
operator|||
operator|(
operator|(
name|pinfo
operator|&
name|INSN_WRITE_GPR_31
operator|)
operator|&&
operator|(
operator|(
operator|(
name|prev_insn
operator|.
name|insn_opcode
operator|>>
name|OP_SH_RT
operator|)
operator|&
name|OP_MASK_RT
operator|)
operator|==
name|RA
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
operator|!
name|mips_opts
operator|.
name|mips16
operator|&&
operator|(
name|prev_pinfo
operator|&
name|INSN_WRITE_GPR_D
operator|)
operator|&&
operator|(
operator|(
operator|(
name|pinfo
operator|&
name|INSN_WRITE_GPR_D
operator|)
operator|&&
operator|(
operator|(
operator|(
name|prev_insn
operator|.
name|insn_opcode
operator|>>
name|OP_SH_RD
operator|)
operator|&
name|OP_MASK_RD
operator|)
operator|==
operator|(
operator|(
name|ip
operator|->
name|insn_opcode
operator|>>
name|OP_SH_RD
operator|)
operator|&
name|OP_MASK_RD
operator|)
operator|)
operator|)
operator|||
operator|(
operator|(
name|pinfo
operator|&
name|INSN_WRITE_GPR_31
operator|)
operator|&&
operator|(
operator|(
operator|(
name|prev_insn
operator|.
name|insn_opcode
operator|>>
name|OP_SH_RD
operator|)
operator|&
name|OP_MASK_RD
operator|)
operator|==
name|RA
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|mips_opts
operator|.
name|mips16
operator|&&
operator|(
name|pinfo
operator|&
name|MIPS16_INSN_WRITE_31
operator|)
operator|&&
operator|(
operator|(
name|prev_pinfo
operator|&
name|MIPS16_INSN_WRITE_31
operator|)
operator|||
operator|(
operator|(
name|prev_pinfo
operator|&
name|MIPS16_INSN_WRITE_GPR_Y
operator|)
operator|&&
operator|(
name|MIPS16OP_EXTRACT_REG32R
argument_list|(
name|prev_insn
operator|.
name|insn_opcode
argument_list|)
operator|==
name|RA
operator|)
operator|)
operator|)
operator|)
comment|/* If the branch writes a register that the previous 		 instruction reads, we can not swap (we know that 		 branches only write to RD or to $31).  */
operator|||
operator|(
operator|!
name|mips_opts
operator|.
name|mips16
operator|&&
operator|(
name|pinfo
operator|&
name|INSN_WRITE_GPR_D
operator|)
operator|&&
name|insn_uses_reg
argument_list|(
operator|&
name|prev_insn
argument_list|,
operator|(
operator|(
name|ip
operator|->
name|insn_opcode
operator|>>
name|OP_SH_RD
operator|)
operator|&
name|OP_MASK_RD
operator|)
argument_list|,
name|MIPS_GR_REG
argument_list|)
operator|)
operator|||
operator|(
operator|!
name|mips_opts
operator|.
name|mips16
operator|&&
operator|(
name|pinfo
operator|&
name|INSN_WRITE_GPR_31
operator|)
operator|&&
name|insn_uses_reg
argument_list|(
operator|&
name|prev_insn
argument_list|,
name|RA
argument_list|,
name|MIPS_GR_REG
argument_list|)
operator|)
operator|||
operator|(
name|mips_opts
operator|.
name|mips16
operator|&&
operator|(
name|pinfo
operator|&
name|MIPS16_INSN_WRITE_31
operator|)
operator|&&
name|insn_uses_reg
argument_list|(
operator|&
name|prev_insn
argument_list|,
name|RA
argument_list|,
name|MIPS_GR_REG
argument_list|)
operator|)
comment|/* If we are generating embedded PIC code, the branch 		 might be expanded into a sequence which uses $at, so 		 we can't swap with an instruction which reads it.  */
operator|||
operator|(
name|mips_pic
operator|==
name|EMBEDDED_PIC
operator|&&
name|insn_uses_reg
argument_list|(
operator|&
name|prev_insn
argument_list|,
name|AT
argument_list|,
name|MIPS_GR_REG
argument_list|)
operator|)
comment|/* If the previous previous instruction has a load 		 delay, and sets a register that the branch reads, we 		 can not swap.  */
operator|||
operator|(
operator|!
name|mips_opts
operator|.
name|mips16
comment|/* Itbl support may require additional care here.  */
operator|&&
operator|(
operator|(
operator|(
name|prev_prev_insn
operator|.
name|insn_mo
operator|->
name|pinfo
operator|&
name|INSN_LOAD_COPROC_DELAY
operator|)
operator|&&
operator|!
name|cop_interlocks
operator|)
operator|||
operator|(
operator|(
name|prev_prev_insn
operator|.
name|insn_mo
operator|->
name|pinfo
operator|&
name|INSN_LOAD_MEMORY_DELAY
operator|)
operator|&&
operator|!
name|gpr_interlocks
operator|)
operator|)
operator|&&
name|insn_uses_reg
argument_list|(
name|ip
argument_list|,
operator|(
operator|(
name|prev_prev_insn
operator|.
name|insn_opcode
operator|>>
name|OP_SH_RT
operator|)
operator|&
name|OP_MASK_RT
operator|)
argument_list|,
name|MIPS_GR_REG
argument_list|)
operator|)
comment|/* If one instruction sets a condition code and the                  other one uses a condition code, we can not swap.  */
operator|||
operator|(
operator|(
name|pinfo
operator|&
name|INSN_READ_COND_CODE
operator|)
operator|&&
operator|(
name|prev_pinfo
operator|&
name|INSN_WRITE_COND_CODE
operator|)
operator|)
operator|||
operator|(
operator|(
name|pinfo
operator|&
name|INSN_WRITE_COND_CODE
operator|)
operator|&&
operator|(
name|prev_pinfo
operator|&
name|INSN_READ_COND_CODE
operator|)
operator|)
comment|/* If the previous instruction uses the PC, we can not                  swap.  */
operator|||
operator|(
name|mips_opts
operator|.
name|mips16
operator|&&
operator|(
name|prev_pinfo
operator|&
name|MIPS16_INSN_READ_PC
operator|)
operator|)
comment|/* If the previous instruction was extended, we can not                  swap.  */
operator|||
operator|(
name|mips_opts
operator|.
name|mips16
operator|&&
name|prev_insn_extended
operator|)
comment|/* If the previous instruction had a fixup in mips16                  mode, we can not swap.  This normally means that the                  previous instruction was a 4 byte branch anyhow.  */
operator|||
operator|(
name|mips_opts
operator|.
name|mips16
operator|&&
name|prev_insn_fixp
index|[
literal|0
index|]
operator|)
comment|/* If the previous instruction is a sync, sync.l, or 		 sync.p, we can not swap.  */
operator|||
operator|(
name|prev_pinfo
operator|&
name|INSN_SYNC
operator|)
condition|)
block|{
comment|/* We could do even better for unconditional branches to 		 portions of this object file; we could pick up the 		 instruction at the destination, put it in the delay 		 slot, and bump the destination address.  */
name|emit_nop
argument_list|()
expr_stmt|;
comment|/* Update the previous insn information.  */
name|prev_prev_insn
operator|=
operator|*
name|ip
expr_stmt|;
name|prev_insn
operator|.
name|insn_mo
operator|=
operator|&
name|dummy_opcode
expr_stmt|;
block|}
else|else
block|{
comment|/* It looks like we can actually do the swap.  */
if|if
condition|(
operator|!
name|mips_opts
operator|.
name|mips16
condition|)
block|{
name|char
modifier|*
name|prev_f
decl_stmt|;
name|char
name|temp
index|[
literal|4
index|]
decl_stmt|;
name|prev_f
operator|=
name|prev_insn_frag
operator|->
name|fr_literal
operator|+
name|prev_insn_where
expr_stmt|;
if|if
condition|(
operator|!
name|relaxed_branch
condition|)
block|{
comment|/* If this is not a relaxed branch, then just 			 swap the instructions.  */
name|memcpy
argument_list|(
name|temp
argument_list|,
name|prev_f
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|prev_f
argument_list|,
name|f
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|f
argument_list|,
name|temp
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* If this is a relaxed branch, then we move the 			 instruction to be placed in the delay slot to 			 the current frag, shrinking the fixed part of 			 the originating frag.  If the branch occupies 			 the tail of the latter, we move it backwards, 			 into the space freed by the moved instruction.  */
name|f
operator|=
name|frag_more
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|f
argument_list|,
name|prev_f
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|prev_insn_frag
operator|->
name|fr_fix
operator|-=
literal|4
expr_stmt|;
if|if
condition|(
name|prev_insn_frag
operator|->
name|fr_type
operator|==
name|rs_machine_dependent
condition|)
name|memmove
argument_list|(
name|prev_f
argument_list|,
name|prev_f
operator|+
literal|4
argument_list|,
name|prev_insn_frag
operator|->
name|fr_var
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|prev_insn_fixp
index|[
literal|0
index|]
condition|)
block|{
name|prev_insn_fixp
index|[
literal|0
index|]
operator|->
name|fx_frag
operator|=
name|frag_now
expr_stmt|;
name|prev_insn_fixp
index|[
literal|0
index|]
operator|->
name|fx_where
operator|=
name|f
operator|-
name|frag_now
operator|->
name|fr_literal
expr_stmt|;
block|}
if|if
condition|(
name|prev_insn_fixp
index|[
literal|1
index|]
condition|)
block|{
name|prev_insn_fixp
index|[
literal|1
index|]
operator|->
name|fx_frag
operator|=
name|frag_now
expr_stmt|;
name|prev_insn_fixp
index|[
literal|1
index|]
operator|->
name|fx_where
operator|=
name|f
operator|-
name|frag_now
operator|->
name|fr_literal
expr_stmt|;
block|}
if|if
condition|(
name|prev_insn_fixp
index|[
literal|2
index|]
condition|)
block|{
name|prev_insn_fixp
index|[
literal|2
index|]
operator|->
name|fx_frag
operator|=
name|frag_now
expr_stmt|;
name|prev_insn_fixp
index|[
literal|2
index|]
operator|->
name|fx_where
operator|=
name|f
operator|-
name|frag_now
operator|->
name|fr_literal
expr_stmt|;
block|}
if|if
condition|(
name|prev_insn_fixp
index|[
literal|0
index|]
operator|&&
name|HAVE_NEWABI
operator|&&
name|prev_insn_frag
operator|!=
name|frag_now
operator|&&
operator|(
name|prev_insn_fixp
index|[
literal|0
index|]
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_MIPS_GOT_DISP
operator|||
operator|(
name|prev_insn_fixp
index|[
literal|0
index|]
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_MIPS_CALL16
operator|)
operator|)
condition|)
block|{
comment|/* To avoid confusion in tc_gen_reloc, we must 			 ensure that this does not become a variant 			 frag.  */
name|force_new_frag
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|relaxed_branch
condition|)
block|{
if|if
condition|(
name|fixp
index|[
literal|0
index|]
condition|)
block|{
name|fixp
index|[
literal|0
index|]
operator|->
name|fx_frag
operator|=
name|prev_insn_frag
expr_stmt|;
name|fixp
index|[
literal|0
index|]
operator|->
name|fx_where
operator|=
name|prev_insn_where
expr_stmt|;
block|}
if|if
condition|(
name|fixp
index|[
literal|1
index|]
condition|)
block|{
name|fixp
index|[
literal|1
index|]
operator|->
name|fx_frag
operator|=
name|prev_insn_frag
expr_stmt|;
name|fixp
index|[
literal|1
index|]
operator|->
name|fx_where
operator|=
name|prev_insn_where
expr_stmt|;
block|}
if|if
condition|(
name|fixp
index|[
literal|2
index|]
condition|)
block|{
name|fixp
index|[
literal|2
index|]
operator|->
name|fx_frag
operator|=
name|prev_insn_frag
expr_stmt|;
name|fixp
index|[
literal|2
index|]
operator|->
name|fx_where
operator|=
name|prev_insn_where
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|prev_insn_frag
operator|->
name|fr_type
operator|==
name|rs_machine_dependent
condition|)
block|{
if|if
condition|(
name|fixp
index|[
literal|0
index|]
condition|)
name|fixp
index|[
literal|0
index|]
operator|->
name|fx_where
operator|-=
literal|4
expr_stmt|;
if|if
condition|(
name|fixp
index|[
literal|1
index|]
condition|)
name|fixp
index|[
literal|1
index|]
operator|->
name|fx_where
operator|-=
literal|4
expr_stmt|;
if|if
condition|(
name|fixp
index|[
literal|2
index|]
condition|)
name|fixp
index|[
literal|2
index|]
operator|->
name|fx_where
operator|-=
literal|4
expr_stmt|;
block|}
block|}
else|else
block|{
name|char
modifier|*
name|prev_f
decl_stmt|;
name|char
name|temp
index|[
literal|2
index|]
decl_stmt|;
name|assert
argument_list|(
name|prev_insn_fixp
index|[
literal|0
index|]
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|prev_insn_fixp
index|[
literal|1
index|]
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|prev_insn_fixp
index|[
literal|2
index|]
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|prev_f
operator|=
name|prev_insn_frag
operator|->
name|fr_literal
operator|+
name|prev_insn_where
expr_stmt|;
name|memcpy
argument_list|(
name|temp
argument_list|,
name|prev_f
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|prev_f
argument_list|,
name|f
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|reloc_type
operator|!=
name|BFD_RELOC_MIPS16_JMP
condition|)
block|{
name|assert
argument_list|(
operator|*
name|reloc_type
operator|==
name|BFD_RELOC_UNUSED
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|f
argument_list|,
name|temp
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|memcpy
argument_list|(
name|f
argument_list|,
name|f
operator|+
literal|2
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|f
operator|+
literal|2
argument_list|,
name|temp
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fixp
index|[
literal|0
index|]
condition|)
block|{
name|fixp
index|[
literal|0
index|]
operator|->
name|fx_frag
operator|=
name|prev_insn_frag
expr_stmt|;
name|fixp
index|[
literal|0
index|]
operator|->
name|fx_where
operator|=
name|prev_insn_where
expr_stmt|;
block|}
if|if
condition|(
name|fixp
index|[
literal|1
index|]
condition|)
block|{
name|fixp
index|[
literal|1
index|]
operator|->
name|fx_frag
operator|=
name|prev_insn_frag
expr_stmt|;
name|fixp
index|[
literal|1
index|]
operator|->
name|fx_where
operator|=
name|prev_insn_where
expr_stmt|;
block|}
if|if
condition|(
name|fixp
index|[
literal|2
index|]
condition|)
block|{
name|fixp
index|[
literal|2
index|]
operator|->
name|fx_frag
operator|=
name|prev_insn_frag
expr_stmt|;
name|fixp
index|[
literal|2
index|]
operator|->
name|fx_where
operator|=
name|prev_insn_where
expr_stmt|;
block|}
block|}
comment|/* Update the previous insn information; leave prev_insn 		 unchanged.  */
name|prev_prev_insn
operator|=
operator|*
name|ip
expr_stmt|;
block|}
name|prev_insn_is_delay_slot
operator|=
literal|1
expr_stmt|;
comment|/* If that was an unconditional branch, forget the previous 	     insn information.  */
if|if
condition|(
name|pinfo
operator|&
name|INSN_UNCOND_BRANCH_DELAY
condition|)
block|{
name|prev_prev_insn
operator|.
name|insn_mo
operator|=
operator|&
name|dummy_opcode
expr_stmt|;
name|prev_insn
operator|.
name|insn_mo
operator|=
operator|&
name|dummy_opcode
expr_stmt|;
block|}
name|prev_insn_fixp
index|[
literal|0
index|]
operator|=
name|NULL
expr_stmt|;
name|prev_insn_fixp
index|[
literal|1
index|]
operator|=
name|NULL
expr_stmt|;
name|prev_insn_fixp
index|[
literal|2
index|]
operator|=
name|NULL
expr_stmt|;
name|prev_insn_reloc_type
index|[
literal|0
index|]
operator|=
name|BFD_RELOC_UNUSED
expr_stmt|;
name|prev_insn_reloc_type
index|[
literal|1
index|]
operator|=
name|BFD_RELOC_UNUSED
expr_stmt|;
name|prev_insn_reloc_type
index|[
literal|2
index|]
operator|=
name|BFD_RELOC_UNUSED
expr_stmt|;
name|prev_insn_extended
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pinfo
operator|&
name|INSN_COND_BRANCH_LIKELY
condition|)
block|{
comment|/* We don't yet optimize a branch likely.  What we should do 	     is look at the target, copy the instruction found there 	     into the delay slot, and increment the branch to jump to 	     the next instruction.  */
name|emit_nop
argument_list|()
expr_stmt|;
comment|/* Update the previous insn information.  */
name|prev_prev_insn
operator|=
operator|*
name|ip
expr_stmt|;
name|prev_insn
operator|.
name|insn_mo
operator|=
operator|&
name|dummy_opcode
expr_stmt|;
name|prev_insn_fixp
index|[
literal|0
index|]
operator|=
name|NULL
expr_stmt|;
name|prev_insn_fixp
index|[
literal|1
index|]
operator|=
name|NULL
expr_stmt|;
name|prev_insn_fixp
index|[
literal|2
index|]
operator|=
name|NULL
expr_stmt|;
name|prev_insn_reloc_type
index|[
literal|0
index|]
operator|=
name|BFD_RELOC_UNUSED
expr_stmt|;
name|prev_insn_reloc_type
index|[
literal|1
index|]
operator|=
name|BFD_RELOC_UNUSED
expr_stmt|;
name|prev_insn_reloc_type
index|[
literal|2
index|]
operator|=
name|BFD_RELOC_UNUSED
expr_stmt|;
name|prev_insn_extended
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* Update the previous insn information.  */
if|if
condition|(
name|nops
operator|>
literal|0
condition|)
name|prev_prev_insn
operator|.
name|insn_mo
operator|=
operator|&
name|dummy_opcode
expr_stmt|;
else|else
name|prev_prev_insn
operator|=
name|prev_insn
expr_stmt|;
name|prev_insn
operator|=
operator|*
name|ip
expr_stmt|;
comment|/* Any time we see a branch, we always fill the delay slot 	     immediately; since this insn is not a branch, we know it 	     is not in a delay slot.  */
name|prev_insn_is_delay_slot
operator|=
literal|0
expr_stmt|;
name|prev_insn_fixp
index|[
literal|0
index|]
operator|=
name|fixp
index|[
literal|0
index|]
expr_stmt|;
name|prev_insn_fixp
index|[
literal|1
index|]
operator|=
name|fixp
index|[
literal|1
index|]
expr_stmt|;
name|prev_insn_fixp
index|[
literal|2
index|]
operator|=
name|fixp
index|[
literal|2
index|]
expr_stmt|;
name|prev_insn_reloc_type
index|[
literal|0
index|]
operator|=
name|reloc_type
index|[
literal|0
index|]
expr_stmt|;
name|prev_insn_reloc_type
index|[
literal|1
index|]
operator|=
name|reloc_type
index|[
literal|1
index|]
expr_stmt|;
name|prev_insn_reloc_type
index|[
literal|2
index|]
operator|=
name|reloc_type
index|[
literal|2
index|]
expr_stmt|;
if|if
condition|(
name|mips_opts
operator|.
name|mips16
condition|)
name|prev_insn_extended
operator|=
operator|(
name|ip
operator|->
name|use_extend
operator|||
operator|*
name|reloc_type
operator|>
name|BFD_RELOC_UNUSED
operator|)
expr_stmt|;
block|}
name|prev_prev_insn_unreordered
operator|=
name|prev_insn_unreordered
expr_stmt|;
name|prev_insn_unreordered
operator|=
literal|0
expr_stmt|;
name|prev_insn_frag
operator|=
name|frag_now
expr_stmt|;
name|prev_insn_where
operator|=
name|f
operator|-
name|frag_now
operator|->
name|fr_literal
expr_stmt|;
name|prev_insn_valid
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mips_relax
operator|.
name|sequence
operator|!=
literal|2
condition|)
block|{
comment|/* We need to record a bit of information even when we are not          reordering, in order to determine the base address for mips16          PC relative relocs.  */
name|prev_prev_insn
operator|=
name|prev_insn
expr_stmt|;
name|prev_insn
operator|=
operator|*
name|ip
expr_stmt|;
name|prev_insn_reloc_type
index|[
literal|0
index|]
operator|=
name|reloc_type
index|[
literal|0
index|]
expr_stmt|;
name|prev_insn_reloc_type
index|[
literal|1
index|]
operator|=
name|reloc_type
index|[
literal|1
index|]
expr_stmt|;
name|prev_insn_reloc_type
index|[
literal|2
index|]
operator|=
name|reloc_type
index|[
literal|2
index|]
expr_stmt|;
name|prev_prev_insn_unreordered
operator|=
name|prev_insn_unreordered
expr_stmt|;
name|prev_insn_unreordered
operator|=
literal|1
expr_stmt|;
block|}
comment|/* We just output an insn, so the next one doesn't have a label.  */
name|mips_clear_insn_labels
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This function forgets that there was any previous instruction or    label.  If PRESERVE is non-zero, it remembers enough information to    know whether nops are needed before a noreorder section.  */
end_comment

begin_function
specifier|static
name|void
name|mips_no_prev_insn
parameter_list|(
name|int
name|preserve
parameter_list|)
block|{
if|if
condition|(
operator|!
name|preserve
condition|)
block|{
name|prev_insn
operator|.
name|insn_mo
operator|=
operator|&
name|dummy_opcode
expr_stmt|;
name|prev_prev_insn
operator|.
name|insn_mo
operator|=
operator|&
name|dummy_opcode
expr_stmt|;
name|prev_nop_frag
operator|=
name|NULL
expr_stmt|;
name|prev_nop_frag_holds
operator|=
literal|0
expr_stmt|;
name|prev_nop_frag_required
operator|=
literal|0
expr_stmt|;
name|prev_nop_frag_since
operator|=
literal|0
expr_stmt|;
block|}
name|prev_insn_valid
operator|=
literal|0
expr_stmt|;
name|prev_insn_is_delay_slot
operator|=
literal|0
expr_stmt|;
name|prev_insn_unreordered
operator|=
literal|0
expr_stmt|;
name|prev_insn_extended
operator|=
literal|0
expr_stmt|;
name|prev_insn_reloc_type
index|[
literal|0
index|]
operator|=
name|BFD_RELOC_UNUSED
expr_stmt|;
name|prev_insn_reloc_type
index|[
literal|1
index|]
operator|=
name|BFD_RELOC_UNUSED
expr_stmt|;
name|prev_insn_reloc_type
index|[
literal|2
index|]
operator|=
name|BFD_RELOC_UNUSED
expr_stmt|;
name|prev_prev_insn_unreordered
operator|=
literal|0
expr_stmt|;
name|mips_clear_insn_labels
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This function must be called whenever we turn on noreorder or emit    something other than instructions.  It inserts any NOPS which might    be needed by the previous instruction, and clears the information    kept for the previous instructions.  The INSNS parameter is true if    instructions are to follow.  */
end_comment

begin_function
specifier|static
name|void
name|mips_emit_delays
parameter_list|(
name|bfd_boolean
name|insns
parameter_list|)
block|{
if|if
condition|(
operator|!
name|mips_opts
operator|.
name|noreorder
condition|)
block|{
name|int
name|nops
decl_stmt|;
name|nops
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
operator|!
name|mips_opts
operator|.
name|mips16
operator|&&
operator|(
operator|(
name|prev_insn
operator|.
name|insn_mo
operator|->
name|pinfo
operator|&
operator|(
name|INSN_LOAD_COPROC_DELAY
operator||
name|INSN_COPROC_MOVE_DELAY
operator||
name|INSN_WRITE_COND_CODE
operator|)
operator|)
operator|&&
operator|!
name|cop_interlocks
operator|)
operator|)
operator|||
operator|(
operator|!
name|hilo_interlocks
operator|&&
operator|(
name|prev_insn
operator|.
name|insn_mo
operator|->
name|pinfo
operator|&
operator|(
name|INSN_READ_LO
operator||
name|INSN_READ_HI
operator|)
operator|)
operator|)
operator|||
operator|(
operator|!
name|mips_opts
operator|.
name|mips16
operator|&&
operator|(
name|prev_insn
operator|.
name|insn_mo
operator|->
name|pinfo
operator|&
name|INSN_LOAD_MEMORY_DELAY
operator|)
operator|&&
operator|!
name|gpr_interlocks
operator|)
operator|||
operator|(
operator|!
name|mips_opts
operator|.
name|mips16
operator|&&
operator|(
name|prev_insn
operator|.
name|insn_mo
operator|->
name|pinfo
operator|&
name|INSN_COPROC_MEMORY_DELAY
operator|)
operator|&&
operator|!
name|cop_mem_interlocks
operator|)
condition|)
block|{
comment|/* Itbl support may require additional care here.  */
operator|++
name|nops
expr_stmt|;
if|if
condition|(
operator|(
operator|!
name|mips_opts
operator|.
name|mips16
operator|&&
operator|(
operator|(
name|prev_insn
operator|.
name|insn_mo
operator|->
name|pinfo
operator|&
name|INSN_WRITE_COND_CODE
operator|)
operator|&&
operator|!
name|cop_interlocks
operator|)
operator|)
operator|||
operator|(
operator|!
name|hilo_interlocks
operator|&&
operator|(
operator|(
name|prev_insn
operator|.
name|insn_mo
operator|->
name|pinfo
operator|&
name|INSN_READ_HI
operator|)
operator|||
operator|(
name|prev_insn
operator|.
name|insn_mo
operator|->
name|pinfo
operator|&
name|INSN_READ_LO
operator|)
operator|)
operator|)
condition|)
operator|++
name|nops
expr_stmt|;
if|if
condition|(
name|prev_insn_unreordered
condition|)
name|nops
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|!
name|mips_opts
operator|.
name|mips16
operator|&&
operator|(
operator|(
name|prev_prev_insn
operator|.
name|insn_mo
operator|->
name|pinfo
operator|&
name|INSN_WRITE_COND_CODE
operator|)
operator|&&
operator|!
name|cop_interlocks
operator|)
operator|)
operator|||
operator|(
operator|!
name|hilo_interlocks
operator|&&
operator|(
operator|(
name|prev_prev_insn
operator|.
name|insn_mo
operator|->
name|pinfo
operator|&
name|INSN_READ_HI
operator|)
operator|||
operator|(
name|prev_prev_insn
operator|.
name|insn_mo
operator|->
name|pinfo
operator|&
name|INSN_READ_LO
operator|)
operator|)
operator|)
condition|)
block|{
comment|/* Itbl support may require additional care here.  */
if|if
condition|(
operator|!
name|prev_prev_insn_unreordered
condition|)
operator|++
name|nops
expr_stmt|;
block|}
if|if
condition|(
name|mips_fix_vr4120
operator|&&
name|prev_insn
operator|.
name|insn_mo
operator|->
name|name
condition|)
block|{
name|int
name|min_nops
init|=
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
name|pn
init|=
name|prev_insn
operator|.
name|insn_mo
operator|->
name|name
decl_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|pn
argument_list|,
literal|"macc"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
operator|||
name|strncmp
argument_list|(
name|pn
argument_list|,
literal|"dmacc"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
operator|||
name|strncmp
argument_list|(
name|pn
argument_list|,
literal|"dmult"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
block|{
name|min_nops
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|nops
operator|<
name|min_nops
condition|)
name|nops
operator|=
name|min_nops
expr_stmt|;
block|}
if|if
condition|(
name|nops
operator|>
literal|0
condition|)
block|{
name|struct
name|insn_label_list
modifier|*
name|l
decl_stmt|;
if|if
condition|(
name|insns
condition|)
block|{
comment|/* Record the frag which holds the nop instructions, so                  that we can remove them if we don't need them.  */
name|frag_grow
argument_list|(
name|mips_opts
operator|.
name|mips16
condition|?
name|nops
operator|*
literal|2
else|:
name|nops
operator|*
literal|4
argument_list|)
expr_stmt|;
name|prev_nop_frag
operator|=
name|frag_now
expr_stmt|;
name|prev_nop_frag_holds
operator|=
name|nops
expr_stmt|;
name|prev_nop_frag_required
operator|=
literal|0
expr_stmt|;
name|prev_nop_frag_since
operator|=
literal|0
expr_stmt|;
block|}
for|for
control|(
init|;
name|nops
operator|>
literal|0
condition|;
operator|--
name|nops
control|)
name|emit_nop
argument_list|()
expr_stmt|;
if|if
condition|(
name|insns
condition|)
block|{
comment|/* Move on to a new frag, so that it is safe to simply                  decrease the size of prev_nop_frag.  */
name|frag_wane
argument_list|(
name|frag_now
argument_list|)
expr_stmt|;
name|frag_new
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|l
operator|=
name|insn_labels
init|;
name|l
operator|!=
name|NULL
condition|;
name|l
operator|=
name|l
operator|->
name|next
control|)
block|{
name|valueT
name|val
decl_stmt|;
name|assert
argument_list|(
name|S_GET_SEGMENT
argument_list|(
name|l
operator|->
name|label
argument_list|)
operator|==
name|now_seg
argument_list|)
expr_stmt|;
name|symbol_set_frag
argument_list|(
name|l
operator|->
name|label
argument_list|,
name|frag_now
argument_list|)
expr_stmt|;
name|val
operator|=
operator|(
name|valueT
operator|)
name|frag_now_fix
argument_list|()
expr_stmt|;
comment|/* mips16 text labels are stored as odd.  */
if|if
condition|(
name|mips_opts
operator|.
name|mips16
condition|)
operator|++
name|val
expr_stmt|;
name|S_SET_VALUE
argument_list|(
name|l
operator|->
name|label
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* Mark instruction labels in mips16 mode.  */
if|if
condition|(
name|insns
condition|)
name|mips16_mark_labels
argument_list|()
expr_stmt|;
name|mips_no_prev_insn
argument_list|(
name|insns
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set up global variables for the start of a new macro.  */
end_comment

begin_function
specifier|static
name|void
name|macro_start
parameter_list|(
name|void
parameter_list|)
block|{
name|memset
argument_list|(
operator|&
name|mips_macro_warning
operator|.
name|sizes
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|mips_macro_warning
operator|.
name|sizes
argument_list|)
argument_list|)
expr_stmt|;
name|mips_macro_warning
operator|.
name|delay_slot_p
operator|=
operator|(
name|mips_opts
operator|.
name|noreorder
operator|&&
operator|(
name|prev_insn
operator|.
name|insn_mo
operator|->
name|pinfo
operator|&
operator|(
name|INSN_UNCOND_BRANCH_DELAY
operator||
name|INSN_COND_BRANCH_DELAY
operator||
name|INSN_COND_BRANCH_LIKELY
operator|)
operator|)
operator|!=
literal|0
operator|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Given that a macro is longer than 4 bytes, return the appropriate warning    for it.  Return null if no warning is needed.  SUBTYPE is a bitmask of    RELAX_DELAY_SLOT and RELAX_NOMACRO.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|macro_warning
parameter_list|(
name|relax_substateT
name|subtype
parameter_list|)
block|{
if|if
condition|(
name|subtype
operator|&
name|RELAX_DELAY_SLOT
condition|)
return|return
name|_
argument_list|(
literal|"Macro instruction expanded into multiple instructions"
literal|" in a branch delay slot"
argument_list|)
return|;
elseif|else
if|if
condition|(
name|subtype
operator|&
name|RELAX_NOMACRO
condition|)
return|return
name|_
argument_list|(
literal|"Macro instruction expanded into multiple instructions"
argument_list|)
return|;
else|else
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Finish up a macro.  Emit warnings as appropriate.  */
end_comment

begin_function
specifier|static
name|void
name|macro_end
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|mips_macro_warning
operator|.
name|sizes
index|[
literal|0
index|]
operator|>
literal|4
operator|||
name|mips_macro_warning
operator|.
name|sizes
index|[
literal|1
index|]
operator|>
literal|4
condition|)
block|{
name|relax_substateT
name|subtype
decl_stmt|;
comment|/* Set up the relaxation warning flags.  */
name|subtype
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|mips_macro_warning
operator|.
name|sizes
index|[
literal|1
index|]
operator|>
name|mips_macro_warning
operator|.
name|sizes
index|[
literal|0
index|]
condition|)
name|subtype
operator||=
name|RELAX_SECOND_LONGER
expr_stmt|;
if|if
condition|(
name|mips_opts
operator|.
name|warn_about_macros
condition|)
name|subtype
operator||=
name|RELAX_NOMACRO
expr_stmt|;
if|if
condition|(
name|mips_macro_warning
operator|.
name|delay_slot_p
condition|)
name|subtype
operator||=
name|RELAX_DELAY_SLOT
expr_stmt|;
if|if
condition|(
name|mips_macro_warning
operator|.
name|sizes
index|[
literal|0
index|]
operator|>
literal|4
operator|&&
name|mips_macro_warning
operator|.
name|sizes
index|[
literal|1
index|]
operator|>
literal|4
condition|)
block|{
comment|/* Either the macro has a single implementation or both 	     implementations are longer than 4 bytes.  Emit the 	     warning now.  */
specifier|const
name|char
modifier|*
name|msg
init|=
name|macro_warning
argument_list|(
name|subtype
argument_list|)
decl_stmt|;
if|if
condition|(
name|msg
operator|!=
literal|0
condition|)
name|as_warn
argument_list|(
name|msg
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* One implementation might need a warning but the other 	     definitely doesn't.  */
name|mips_macro_warning
operator|.
name|first_frag
operator|->
name|fr_subtype
operator||=
name|subtype
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Build an instruction created by a macro expansion.  This is passed    a pointer to the count of instructions created so far, an    expression, the name of the instruction to build, an operand format    string, and corresponding arguments.  */
end_comment

begin_function
specifier|static
name|void
name|macro_build
parameter_list|(
name|expressionS
modifier|*
name|ep
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|struct
name|mips_cl_insn
name|insn
decl_stmt|;
name|bfd_reloc_code_real_type
name|r
index|[
literal|3
index|]
decl_stmt|;
name|va_list
name|args
decl_stmt|;
name|va_start
argument_list|(
name|args
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|mips_opts
operator|.
name|mips16
condition|)
block|{
name|mips16_macro_build
argument_list|(
name|ep
argument_list|,
name|name
argument_list|,
name|fmt
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
return|return;
block|}
name|r
index|[
literal|0
index|]
operator|=
name|BFD_RELOC_UNUSED
expr_stmt|;
name|r
index|[
literal|1
index|]
operator|=
name|BFD_RELOC_UNUSED
expr_stmt|;
name|r
index|[
literal|2
index|]
operator|=
name|BFD_RELOC_UNUSED
expr_stmt|;
name|insn
operator|.
name|insn_mo
operator|=
operator|(
expr|struct
name|mips_opcode
operator|*
operator|)
name|hash_find
argument_list|(
name|op_hash
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|insn
operator|.
name|insn_mo
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|insn
operator|.
name|insn_mo
operator|->
name|name
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* Search until we get a match for NAME.  */
while|while
condition|(
literal|1
condition|)
block|{
comment|/* It is assumed here that macros will never generate          MDMX or MIPS-3D instructions.  */
if|if
condition|(
name|strcmp
argument_list|(
name|fmt
argument_list|,
name|insn
operator|.
name|insn_mo
operator|->
name|args
argument_list|)
operator|==
literal|0
operator|&&
name|insn
operator|.
name|insn_mo
operator|->
name|pinfo
operator|!=
name|INSN_MACRO
operator|&&
name|OPCODE_IS_MEMBER
argument_list|(
name|insn
operator|.
name|insn_mo
argument_list|,
operator|(
name|mips_opts
operator|.
name|isa
operator||
operator|(
name|file_ase_mips16
condition|?
name|INSN_MIPS16
else|:
literal|0
operator|)
operator|)
argument_list|,
name|mips_opts
operator|.
name|arch
argument_list|)
operator|&&
operator|(
name|mips_opts
operator|.
name|arch
operator|!=
name|CPU_R4650
operator|||
operator|(
name|insn
operator|.
name|insn_mo
operator|->
name|pinfo
operator|&
name|FP_D
operator|)
operator|==
literal|0
operator|)
condition|)
break|break;
operator|++
name|insn
operator|.
name|insn_mo
expr_stmt|;
name|assert
argument_list|(
name|insn
operator|.
name|insn_mo
operator|->
name|name
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|insn
operator|.
name|insn_mo
operator|->
name|name
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
name|insn
operator|.
name|insn_opcode
operator|=
name|insn
operator|.
name|insn_mo
operator|->
name|match
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
switch|switch
condition|(
operator|*
name|fmt
operator|++
condition|)
block|{
case|case
literal|'\0'
case|:
break|break;
case|case
literal|','
case|:
case|case
literal|'('
case|:
case|case
literal|')'
case|:
continue|continue;
case|case
literal|'+'
case|:
switch|switch
condition|(
operator|*
name|fmt
operator|++
condition|)
block|{
case|case
literal|'A'
case|:
case|case
literal|'E'
case|:
name|insn
operator|.
name|insn_opcode
operator||=
operator|(
name|va_arg
argument_list|(
name|args
argument_list|,
name|int
argument_list|)
operator|&
name|OP_MASK_SHAMT
operator|)
operator|<<
name|OP_SH_SHAMT
expr_stmt|;
continue|continue;
case|case
literal|'B'
case|:
case|case
literal|'F'
case|:
comment|/* Note that in the macro case, these arguments are already 		 in MSB form.  (When handling the instruction in the 		 non-macro case, these arguments are sizes from which 		 MSB values must be calculated.)  */
name|insn
operator|.
name|insn_opcode
operator||=
operator|(
name|va_arg
argument_list|(
name|args
argument_list|,
name|int
argument_list|)
operator|&
name|OP_MASK_INSMSB
operator|)
operator|<<
name|OP_SH_INSMSB
expr_stmt|;
continue|continue;
case|case
literal|'C'
case|:
case|case
literal|'G'
case|:
case|case
literal|'H'
case|:
comment|/* Note that in the macro case, these arguments are already 		 in MSBD form.  (When handling the instruction in the 		 non-macro case, these arguments are sizes from which 		 MSBD values must be calculated.)  */
name|insn
operator|.
name|insn_opcode
operator||=
operator|(
name|va_arg
argument_list|(
name|args
argument_list|,
name|int
argument_list|)
operator|&
name|OP_MASK_EXTMSBD
operator|)
operator|<<
name|OP_SH_EXTMSBD
expr_stmt|;
continue|continue;
default|default:
name|internalError
argument_list|()
expr_stmt|;
block|}
continue|continue;
case|case
literal|'t'
case|:
case|case
literal|'w'
case|:
case|case
literal|'E'
case|:
name|insn
operator|.
name|insn_opcode
operator||=
name|va_arg
argument_list|(
name|args
argument_list|,
name|int
argument_list|)
operator|<<
name|OP_SH_RT
expr_stmt|;
continue|continue;
case|case
literal|'c'
case|:
name|insn
operator|.
name|insn_opcode
operator||=
name|va_arg
argument_list|(
name|args
argument_list|,
name|int
argument_list|)
operator|<<
name|OP_SH_CODE
expr_stmt|;
continue|continue;
case|case
literal|'T'
case|:
case|case
literal|'W'
case|:
name|insn
operator|.
name|insn_opcode
operator||=
name|va_arg
argument_list|(
name|args
argument_list|,
name|int
argument_list|)
operator|<<
name|OP_SH_FT
expr_stmt|;
continue|continue;
case|case
literal|'d'
case|:
case|case
literal|'G'
case|:
case|case
literal|'K'
case|:
name|insn
operator|.
name|insn_opcode
operator||=
name|va_arg
argument_list|(
name|args
argument_list|,
name|int
argument_list|)
operator|<<
name|OP_SH_RD
expr_stmt|;
continue|continue;
case|case
literal|'U'
case|:
block|{
name|int
name|tmp
init|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|int
argument_list|)
decl_stmt|;
name|insn
operator|.
name|insn_opcode
operator||=
name|tmp
operator|<<
name|OP_SH_RT
expr_stmt|;
name|insn
operator|.
name|insn_opcode
operator||=
name|tmp
operator|<<
name|OP_SH_RD
expr_stmt|;
continue|continue;
block|}
case|case
literal|'V'
case|:
case|case
literal|'S'
case|:
name|insn
operator|.
name|insn_opcode
operator||=
name|va_arg
argument_list|(
name|args
argument_list|,
name|int
argument_list|)
operator|<<
name|OP_SH_FS
expr_stmt|;
continue|continue;
case|case
literal|'z'
case|:
continue|continue;
case|case
literal|'<'
case|:
name|insn
operator|.
name|insn_opcode
operator||=
name|va_arg
argument_list|(
name|args
argument_list|,
name|int
argument_list|)
operator|<<
name|OP_SH_SHAMT
expr_stmt|;
continue|continue;
case|case
literal|'D'
case|:
name|insn
operator|.
name|insn_opcode
operator||=
name|va_arg
argument_list|(
name|args
argument_list|,
name|int
argument_list|)
operator|<<
name|OP_SH_FD
expr_stmt|;
continue|continue;
case|case
literal|'B'
case|:
name|insn
operator|.
name|insn_opcode
operator||=
name|va_arg
argument_list|(
name|args
argument_list|,
name|int
argument_list|)
operator|<<
name|OP_SH_CODE20
expr_stmt|;
continue|continue;
case|case
literal|'J'
case|:
name|insn
operator|.
name|insn_opcode
operator||=
name|va_arg
argument_list|(
name|args
argument_list|,
name|int
argument_list|)
operator|<<
name|OP_SH_CODE19
expr_stmt|;
continue|continue;
case|case
literal|'q'
case|:
name|insn
operator|.
name|insn_opcode
operator||=
name|va_arg
argument_list|(
name|args
argument_list|,
name|int
argument_list|)
operator|<<
name|OP_SH_CODE2
expr_stmt|;
continue|continue;
case|case
literal|'b'
case|:
case|case
literal|'s'
case|:
case|case
literal|'r'
case|:
case|case
literal|'v'
case|:
name|insn
operator|.
name|insn_opcode
operator||=
name|va_arg
argument_list|(
name|args
argument_list|,
name|int
argument_list|)
operator|<<
name|OP_SH_RS
expr_stmt|;
continue|continue;
case|case
literal|'i'
case|:
case|case
literal|'j'
case|:
case|case
literal|'o'
case|:
operator|*
name|r
operator|=
operator|(
name|bfd_reloc_code_real_type
operator|)
name|va_arg
argument_list|(
name|args
argument_list|,
name|int
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|*
name|r
operator|==
name|BFD_RELOC_GPREL16
operator|||
operator|*
name|r
operator|==
name|BFD_RELOC_MIPS_LITERAL
operator|||
operator|*
name|r
operator|==
name|BFD_RELOC_MIPS_HIGHER
operator|||
operator|*
name|r
operator|==
name|BFD_RELOC_HI16_S
operator|||
operator|*
name|r
operator|==
name|BFD_RELOC_LO16
operator|||
operator|*
name|r
operator|==
name|BFD_RELOC_MIPS_GOT16
operator|||
operator|*
name|r
operator|==
name|BFD_RELOC_MIPS_CALL16
operator|||
operator|*
name|r
operator|==
name|BFD_RELOC_MIPS_GOT_DISP
operator|||
operator|*
name|r
operator|==
name|BFD_RELOC_MIPS_GOT_PAGE
operator|||
operator|*
name|r
operator|==
name|BFD_RELOC_MIPS_GOT_OFST
operator|||
operator|*
name|r
operator|==
name|BFD_RELOC_MIPS_GOT_LO16
operator|||
operator|*
name|r
operator|==
name|BFD_RELOC_MIPS_CALL_LO16
operator|||
operator|(
name|ep
operator|->
name|X_op
operator|==
name|O_subtract
operator|&&
operator|*
name|r
operator|==
name|BFD_RELOC_PCREL_LO16
operator|)
argument_list|)
expr_stmt|;
continue|continue;
case|case
literal|'u'
case|:
operator|*
name|r
operator|=
operator|(
name|bfd_reloc_code_real_type
operator|)
name|va_arg
argument_list|(
name|args
argument_list|,
name|int
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ep
operator|!=
name|NULL
operator|&&
operator|(
name|ep
operator|->
name|X_op
operator|==
name|O_constant
operator|||
operator|(
name|ep
operator|->
name|X_op
operator|==
name|O_symbol
operator|&&
operator|(
operator|*
name|r
operator|==
name|BFD_RELOC_MIPS_HIGHEST
operator|||
operator|*
name|r
operator|==
name|BFD_RELOC_HI16_S
operator|||
operator|*
name|r
operator|==
name|BFD_RELOC_HI16
operator|||
operator|*
name|r
operator|==
name|BFD_RELOC_GPREL16
operator|||
operator|*
name|r
operator|==
name|BFD_RELOC_MIPS_GOT_HI16
operator|||
operator|*
name|r
operator|==
name|BFD_RELOC_MIPS_CALL_HI16
operator|)
operator|)
operator|||
operator|(
name|ep
operator|->
name|X_op
operator|==
name|O_subtract
operator|&&
operator|*
name|r
operator|==
name|BFD_RELOC_PCREL_HI16_S
operator|)
operator|)
argument_list|)
expr_stmt|;
continue|continue;
case|case
literal|'p'
case|:
name|assert
argument_list|(
name|ep
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* 	   * This allows macro() to pass an immediate expression for 	   * creating short branches without creating a symbol. 	   * Note that the expression still might come from the assembly 	   * input, in which case the value is not checked for range nor 	   * is a relocation entry generated (yuck). 	   */
if|if
condition|(
name|ep
operator|->
name|X_op
operator|==
name|O_constant
condition|)
block|{
name|insn
operator|.
name|insn_opcode
operator||=
operator|(
name|ep
operator|->
name|X_add_number
operator|>>
literal|2
operator|)
operator|&
literal|0xffff
expr_stmt|;
name|ep
operator|=
name|NULL
expr_stmt|;
block|}
else|else
operator|*
name|r
operator|=
name|BFD_RELOC_16_PCREL_S2
expr_stmt|;
continue|continue;
case|case
literal|'a'
case|:
name|assert
argument_list|(
name|ep
operator|!=
name|NULL
argument_list|)
expr_stmt|;
operator|*
name|r
operator|=
name|BFD_RELOC_MIPS_JMP
expr_stmt|;
continue|continue;
case|case
literal|'C'
case|:
name|insn
operator|.
name|insn_opcode
operator||=
name|va_arg
argument_list|(
argument|args
argument_list|,
argument|unsigned long
argument_list|)
expr_stmt|;
continue|continue;
default|default:
name|internalError
argument_list|()
expr_stmt|;
block|}
break|break;
block|}
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|*
name|r
operator|==
name|BFD_RELOC_UNUSED
condition|?
name|ep
operator|==
name|NULL
else|:
name|ep
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|append_insn
argument_list|(
operator|&
name|insn
argument_list|,
name|ep
argument_list|,
name|r
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|mips16_macro_build
parameter_list|(
name|expressionS
modifier|*
name|ep
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
name|va_list
name|args
parameter_list|)
block|{
name|struct
name|mips_cl_insn
name|insn
decl_stmt|;
name|bfd_reloc_code_real_type
name|r
index|[
literal|3
index|]
init|=
block|{
name|BFD_RELOC_UNUSED
block|,
name|BFD_RELOC_UNUSED
block|,
name|BFD_RELOC_UNUSED
block|}
decl_stmt|;
name|insn
operator|.
name|insn_mo
operator|=
operator|(
expr|struct
name|mips_opcode
operator|*
operator|)
name|hash_find
argument_list|(
name|mips16_op_hash
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|insn
operator|.
name|insn_mo
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|insn
operator|.
name|insn_mo
operator|->
name|name
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
name|strcmp
argument_list|(
name|fmt
argument_list|,
name|insn
operator|.
name|insn_mo
operator|->
name|args
argument_list|)
operator|!=
literal|0
operator|||
name|insn
operator|.
name|insn_mo
operator|->
name|pinfo
operator|==
name|INSN_MACRO
condition|)
block|{
operator|++
name|insn
operator|.
name|insn_mo
expr_stmt|;
name|assert
argument_list|(
name|insn
operator|.
name|insn_mo
operator|->
name|name
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|insn
operator|.
name|insn_mo
operator|->
name|name
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
name|insn
operator|.
name|insn_opcode
operator|=
name|insn
operator|.
name|insn_mo
operator|->
name|match
expr_stmt|;
name|insn
operator|.
name|use_extend
operator|=
name|FALSE
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|int
name|c
decl_stmt|;
name|c
operator|=
operator|*
name|fmt
operator|++
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\0'
case|:
break|break;
case|case
literal|','
case|:
case|case
literal|'('
case|:
case|case
literal|')'
case|:
continue|continue;
case|case
literal|'y'
case|:
case|case
literal|'w'
case|:
name|insn
operator|.
name|insn_opcode
operator||=
name|va_arg
argument_list|(
name|args
argument_list|,
name|int
argument_list|)
operator|<<
name|MIPS16OP_SH_RY
expr_stmt|;
continue|continue;
case|case
literal|'x'
case|:
case|case
literal|'v'
case|:
name|insn
operator|.
name|insn_opcode
operator||=
name|va_arg
argument_list|(
name|args
argument_list|,
name|int
argument_list|)
operator|<<
name|MIPS16OP_SH_RX
expr_stmt|;
continue|continue;
case|case
literal|'z'
case|:
name|insn
operator|.
name|insn_opcode
operator||=
name|va_arg
argument_list|(
name|args
argument_list|,
name|int
argument_list|)
operator|<<
name|MIPS16OP_SH_RZ
expr_stmt|;
continue|continue;
case|case
literal|'Z'
case|:
name|insn
operator|.
name|insn_opcode
operator||=
name|va_arg
argument_list|(
name|args
argument_list|,
name|int
argument_list|)
operator|<<
name|MIPS16OP_SH_MOVE32Z
expr_stmt|;
continue|continue;
case|case
literal|'0'
case|:
case|case
literal|'S'
case|:
case|case
literal|'P'
case|:
case|case
literal|'R'
case|:
continue|continue;
case|case
literal|'X'
case|:
name|insn
operator|.
name|insn_opcode
operator||=
name|va_arg
argument_list|(
name|args
argument_list|,
name|int
argument_list|)
operator|<<
name|MIPS16OP_SH_REGR32
expr_stmt|;
continue|continue;
case|case
literal|'Y'
case|:
block|{
name|int
name|regno
decl_stmt|;
name|regno
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|int
argument_list|)
expr_stmt|;
name|regno
operator|=
operator|(
operator|(
name|regno
operator|&
literal|7
operator|)
operator|<<
literal|2
operator|)
operator||
operator|(
operator|(
name|regno
operator|&
literal|0x18
operator|)
operator|>>
literal|3
operator|)
expr_stmt|;
name|insn
operator|.
name|insn_opcode
operator||=
name|regno
operator|<<
name|MIPS16OP_SH_REG32R
expr_stmt|;
block|}
continue|continue;
case|case
literal|'<'
case|:
case|case
literal|'>'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'H'
case|:
case|case
literal|'W'
case|:
case|case
literal|'D'
case|:
case|case
literal|'j'
case|:
case|case
literal|'8'
case|:
case|case
literal|'V'
case|:
case|case
literal|'C'
case|:
case|case
literal|'U'
case|:
case|case
literal|'k'
case|:
case|case
literal|'K'
case|:
case|case
literal|'p'
case|:
case|case
literal|'q'
case|:
block|{
name|assert
argument_list|(
name|ep
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ep
operator|->
name|X_op
operator|!=
name|O_constant
condition|)
operator|*
name|r
operator|=
operator|(
name|int
operator|)
name|BFD_RELOC_UNUSED
operator|+
name|c
expr_stmt|;
else|else
block|{
name|mips16_immed
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|,
name|c
argument_list|,
name|ep
operator|->
name|X_add_number
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
operator|&
name|insn
operator|.
name|insn_opcode
argument_list|,
operator|&
name|insn
operator|.
name|use_extend
argument_list|,
operator|&
name|insn
operator|.
name|extend
argument_list|)
expr_stmt|;
name|ep
operator|=
name|NULL
expr_stmt|;
operator|*
name|r
operator|=
name|BFD_RELOC_UNUSED
expr_stmt|;
block|}
block|}
continue|continue;
case|case
literal|'6'
case|:
name|insn
operator|.
name|insn_opcode
operator||=
name|va_arg
argument_list|(
name|args
argument_list|,
name|int
argument_list|)
operator|<<
name|MIPS16OP_SH_IMM6
expr_stmt|;
continue|continue;
block|}
break|break;
block|}
name|assert
argument_list|(
operator|*
name|r
operator|==
name|BFD_RELOC_UNUSED
condition|?
name|ep
operator|==
name|NULL
else|:
name|ep
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|append_insn
argument_list|(
operator|&
name|insn
argument_list|,
name|ep
argument_list|,
name|r
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Generate a "jalr" instruction with a relocation hint to the called  * function.  This occurs in NewABI PIC code.  */
end_comment

begin_function
specifier|static
name|void
name|macro_build_jalr
parameter_list|(
name|expressionS
modifier|*
name|ep
parameter_list|)
block|{
name|char
modifier|*
name|f
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|HAVE_NEWABI
condition|)
block|{
name|frag_grow
argument_list|(
literal|8
argument_list|)
expr_stmt|;
name|f
operator|=
name|frag_more
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"jalr"
argument_list|,
literal|"d,s"
argument_list|,
name|RA
argument_list|,
name|PIC_CALL_REG
argument_list|)
expr_stmt|;
if|if
condition|(
name|HAVE_NEWABI
condition|)
name|fix_new_exp
argument_list|(
name|frag_now
argument_list|,
name|f
operator|-
name|frag_now
operator|->
name|fr_literal
argument_list|,
literal|4
argument_list|,
name|ep
argument_list|,
name|FALSE
argument_list|,
name|BFD_RELOC_MIPS_JALR
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Generate a "lui" instruction.  */
end_comment

begin_function
specifier|static
name|void
name|macro_build_lui
parameter_list|(
name|expressionS
modifier|*
name|ep
parameter_list|,
name|int
name|regnum
parameter_list|)
block|{
name|expressionS
name|high_expr
decl_stmt|;
name|struct
name|mips_cl_insn
name|insn
decl_stmt|;
name|bfd_reloc_code_real_type
name|r
index|[
literal|3
index|]
init|=
block|{
name|BFD_RELOC_UNUSED
block|,
name|BFD_RELOC_UNUSED
block|,
name|BFD_RELOC_UNUSED
block|}
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
init|=
literal|"lui"
decl_stmt|;
specifier|const
name|char
modifier|*
name|fmt
init|=
literal|"t,u"
decl_stmt|;
name|assert
argument_list|(
operator|!
name|mips_opts
operator|.
name|mips16
argument_list|)
expr_stmt|;
name|high_expr
operator|=
operator|*
name|ep
expr_stmt|;
if|if
condition|(
name|high_expr
operator|.
name|X_op
operator|==
name|O_constant
condition|)
block|{
comment|/* we can compute the instruction now without a relocation entry */
name|high_expr
operator|.
name|X_add_number
operator|=
operator|(
operator|(
name|high_expr
operator|.
name|X_add_number
operator|+
literal|0x8000
operator|)
operator|>>
literal|16
operator|)
operator|&
literal|0xffff
expr_stmt|;
operator|*
name|r
operator|=
name|BFD_RELOC_UNUSED
expr_stmt|;
block|}
else|else
block|{
name|assert
argument_list|(
name|ep
operator|->
name|X_op
operator|==
name|O_symbol
argument_list|)
expr_stmt|;
comment|/* _gp_disp is a special case, used from s_cpload.  */
name|assert
argument_list|(
name|mips_pic
operator|==
name|NO_PIC
operator|||
operator|(
operator|!
name|HAVE_NEWABI
operator|&&
name|strcmp
argument_list|(
name|S_GET_NAME
argument_list|(
name|ep
operator|->
name|X_add_symbol
argument_list|)
argument_list|,
literal|"_gp_disp"
argument_list|)
operator|==
literal|0
operator|)
argument_list|)
expr_stmt|;
operator|*
name|r
operator|=
name|BFD_RELOC_HI16_S
expr_stmt|;
block|}
name|insn
operator|.
name|insn_mo
operator|=
operator|(
expr|struct
name|mips_opcode
operator|*
operator|)
name|hash_find
argument_list|(
name|op_hash
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|insn
operator|.
name|insn_mo
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|insn
operator|.
name|insn_mo
operator|->
name|name
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|strcmp
argument_list|(
name|fmt
argument_list|,
name|insn
operator|.
name|insn_mo
operator|->
name|args
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|insn
operator|.
name|insn_opcode
operator|=
name|insn
operator|.
name|insn_mo
operator|->
name|match
operator||
operator|(
name|regnum
operator|<<
name|OP_SH_RT
operator|)
expr_stmt|;
if|if
condition|(
operator|*
name|r
operator|==
name|BFD_RELOC_UNUSED
condition|)
block|{
name|insn
operator|.
name|insn_opcode
operator||=
name|high_expr
operator|.
name|X_add_number
expr_stmt|;
name|append_insn
argument_list|(
operator|&
name|insn
argument_list|,
name|NULL
argument_list|,
name|r
argument_list|)
expr_stmt|;
block|}
else|else
name|append_insn
argument_list|(
operator|&
name|insn
argument_list|,
operator|&
name|high_expr
argument_list|,
name|r
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate a sequence of instructions to do a load or store from a constant    offset off of a base register (breg) into/from a target register (treg),    using AT if necessary.  */
end_comment

begin_function
specifier|static
name|void
name|macro_build_ldst_constoffset
parameter_list|(
name|expressionS
modifier|*
name|ep
parameter_list|,
specifier|const
name|char
modifier|*
name|op
parameter_list|,
name|int
name|treg
parameter_list|,
name|int
name|breg
parameter_list|,
name|int
name|dbl
parameter_list|)
block|{
name|assert
argument_list|(
name|ep
operator|->
name|X_op
operator|==
name|O_constant
argument_list|)
expr_stmt|;
comment|/* Sign-extending 32-bit constants makes their handling easier.  */
if|if
condition|(
operator|!
name|dbl
operator|&&
operator|!
operator|(
operator|(
name|ep
operator|->
name|X_add_number
operator|&
operator|~
operator|(
operator|(
name|bfd_vma
operator|)
literal|0x7fffffff
operator|)
operator|)
operator|==
operator|~
operator|(
operator|(
name|bfd_vma
operator|)
literal|0x7fffffff
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|ep
operator|->
name|X_add_number
operator|&
operator|~
operator|(
operator|(
name|bfd_vma
operator|)
literal|0xffffffff
operator|)
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"constant too large"
argument_list|)
argument_list|)
expr_stmt|;
name|ep
operator|->
name|X_add_number
operator|=
operator|(
operator|(
operator|(
name|ep
operator|->
name|X_add_number
operator|&
literal|0xffffffff
operator|)
operator|^
literal|0x80000000
operator|)
operator|-
literal|0x80000000
operator|)
expr_stmt|;
block|}
comment|/* Right now, this routine can only handle signed 32-bit constants.  */
if|if
condition|(
operator|!
name|IS_SEXT_32BIT_NUM
argument_list|(
name|ep
operator|->
name|X_add_number
operator|+
literal|0x8000
argument_list|)
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"operand overflow"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_SEXT_16BIT_NUM
argument_list|(
name|ep
operator|->
name|X_add_number
argument_list|)
condition|)
block|{
comment|/* Signed 16-bit offset will fit in the op.  Easy!  */
name|macro_build
argument_list|(
name|ep
argument_list|,
name|op
argument_list|,
literal|"t,o(b)"
argument_list|,
name|treg
argument_list|,
name|BFD_RELOC_LO16
argument_list|,
name|breg
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 32-bit offset, need multiple instructions and AT, like: 	   lui      $tempreg,const_hi       (BFD_RELOC_HI16_S) 	   addu     $tempreg,$tempreg,$breg<op>     $treg,const_lo($tempreg)   (BFD_RELOC_LO16)          to handle the complete offset.  */
name|macro_build_lui
argument_list|(
name|ep
argument_list|,
name|AT
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
name|ADDRESS_ADD_INSN
argument_list|,
literal|"d,v,t"
argument_list|,
name|AT
argument_list|,
name|AT
argument_list|,
name|breg
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|ep
argument_list|,
name|op
argument_list|,
literal|"t,o(b)"
argument_list|,
name|treg
argument_list|,
name|BFD_RELOC_LO16
argument_list|,
name|AT
argument_list|)
expr_stmt|;
if|if
condition|(
name|mips_opts
operator|.
name|noat
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"Macro used $at after \".set noat\""
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*			set_at()  * Generates code to set the $at register to true (one)  * if reg is less than the immediate expression.  */
end_comment

begin_function
specifier|static
name|void
name|set_at
parameter_list|(
name|int
name|reg
parameter_list|,
name|int
name|unsignedp
parameter_list|)
block|{
if|if
condition|(
name|imm_expr
operator|.
name|X_op
operator|==
name|O_constant
operator|&&
name|imm_expr
operator|.
name|X_add_number
operator|>=
operator|-
literal|0x8000
operator|&&
name|imm_expr
operator|.
name|X_add_number
operator|<
literal|0x8000
condition|)
name|macro_build
argument_list|(
operator|&
name|imm_expr
argument_list|,
name|unsignedp
condition|?
literal|"sltiu"
else|:
literal|"slti"
argument_list|,
literal|"t,r,j"
argument_list|,
name|AT
argument_list|,
name|reg
argument_list|,
name|BFD_RELOC_LO16
argument_list|)
expr_stmt|;
else|else
block|{
name|load_register
argument_list|(
name|AT
argument_list|,
operator|&
name|imm_expr
argument_list|,
name|HAVE_64BIT_GPRS
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
name|unsignedp
condition|?
literal|"sltu"
else|:
literal|"slt"
argument_list|,
literal|"d,v,t"
argument_list|,
name|AT
argument_list|,
name|reg
argument_list|,
name|AT
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|normalize_constant_expr
parameter_list|(
name|expressionS
modifier|*
name|ex
parameter_list|)
block|{
if|if
condition|(
name|ex
operator|->
name|X_op
operator|==
name|O_constant
operator|&&
name|HAVE_32BIT_GPRS
condition|)
name|ex
operator|->
name|X_add_number
operator|=
operator|(
operator|(
operator|(
name|ex
operator|->
name|X_add_number
operator|&
literal|0xffffffff
operator|)
operator|^
literal|0x80000000
operator|)
operator|-
literal|0x80000000
operator|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Warn if an expression is not a constant.  */
end_comment

begin_function
specifier|static
name|void
name|check_absolute_expr
parameter_list|(
name|struct
name|mips_cl_insn
modifier|*
name|ip
parameter_list|,
name|expressionS
modifier|*
name|ex
parameter_list|)
block|{
if|if
condition|(
name|ex
operator|->
name|X_op
operator|==
name|O_big
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"unsupported large constant"
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ex
operator|->
name|X_op
operator|!=
name|O_constant
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Instruction %s requires absolute expression"
argument_list|)
argument_list|,
name|ip
operator|->
name|insn_mo
operator|->
name|name
argument_list|)
expr_stmt|;
name|normalize_constant_expr
argument_list|(
name|ex
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Count the leading zeroes by performing a binary chop. This is a    bulky bit of source, but performance is a LOT better for the    majority of values than a simple loop to count the bits:        for (lcnt = 0; (lcnt< 32); lcnt++)          if ((v)& (1<< (31 - lcnt)))            break;   However it is not code size friendly, and the gain will drop a bit   on certain cached systems. */
end_comment

begin_define
define|#
directive|define
name|COUNT_TOP_ZEROES
parameter_list|(
name|v
parameter_list|)
define|\
value|(((v)& ~0xffff) == 0                 \    ? ((v)& ~0xff) == 0                 \      ? ((v)& ~0xf) == 0                \        ? ((v)& ~0x3) == 0              \          ? ((v)& ~0x1) == 0            \            ? !(v)                       \              ? 32                       \              : 31                       \            : 30                         \          : ((v)& ~0x7) == 0            \            ? 29                         \            : 28                         \        : ((v)& ~0x3f) == 0             \          ? ((v)& ~0x1f) == 0           \            ? 27                         \            : 26                         \          : ((v)& ~0x7f) == 0           \            ? 25                         \            : 24                         \      : ((v)& ~0xfff) == 0              \        ? ((v)& ~0x3ff) == 0            \          ? ((v)& ~0x1ff) == 0          \            ? 23                         \            : 22                         \          : ((v)& ~0x7ff) == 0          \            ? 21                         \            : 20                         \        : ((v)& ~0x3fff) == 0           \          ? ((v)& ~0x1fff) == 0         \            ? 19                         \            : 18                         \          : ((v)& ~0x7fff) == 0         \            ? 17                         \            : 16                         \    : ((v)& ~0xffffff) == 0             \      ? ((v)& ~0xfffff) == 0            \        ? ((v)& ~0x3ffff) == 0          \          ? ((v)& ~0x1ffff) == 0        \            ? 15                         \            : 14                         \          : ((v)& ~0x7ffff) == 0        \            ? 13                         \            : 12                         \        : ((v)& ~0x3fffff) == 0         \          ? ((v)& ~0x1fffff) == 0       \            ? 11                         \            : 10                         \          : ((v)& ~0x7fffff) == 0       \            ? 9                          \            : 8                          \      : ((v)& ~0xfffffff) == 0          \        ? ((v)& ~0x3ffffff) == 0        \          ? ((v)& ~0x1ffffff) == 0      \            ? 7                          \            : 6                          \          : ((v)& ~0x7ffffff) == 0      \            ? 5                          \            : 4                          \        : ((v)& ~0x3fffffff) == 0       \          ? ((v)& ~0x1fffffff) == 0     \            ? 3                          \            : 2                          \          : ((v)& ~0x7fffffff) == 0     \            ? 1                          \            : 0)
end_define

begin_comment
comment|/*			load_register()  *  This routine generates the least number of instructions necessary to load  *  an absolute expression value into a register.  */
end_comment

begin_function
specifier|static
name|void
name|load_register
parameter_list|(
name|int
name|reg
parameter_list|,
name|expressionS
modifier|*
name|ep
parameter_list|,
name|int
name|dbl
parameter_list|)
block|{
name|int
name|freg
decl_stmt|;
name|expressionS
name|hi32
decl_stmt|,
name|lo32
decl_stmt|;
if|if
condition|(
name|ep
operator|->
name|X_op
operator|!=
name|O_big
condition|)
block|{
name|assert
argument_list|(
name|ep
operator|->
name|X_op
operator|==
name|O_constant
argument_list|)
expr_stmt|;
comment|/* Sign-extending 32-bit constants makes their handling easier.  */
if|if
condition|(
operator|!
name|dbl
operator|&&
operator|!
operator|(
operator|(
name|ep
operator|->
name|X_add_number
operator|&
operator|~
operator|(
operator|(
name|bfd_vma
operator|)
literal|0x7fffffff
operator|)
operator|)
operator|==
operator|~
operator|(
operator|(
name|bfd_vma
operator|)
literal|0x7fffffff
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|ep
operator|->
name|X_add_number
operator|&
operator|~
operator|(
operator|(
name|bfd_vma
operator|)
literal|0xffffffff
operator|)
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"constant too large"
argument_list|)
argument_list|)
expr_stmt|;
name|ep
operator|->
name|X_add_number
operator|=
operator|(
operator|(
operator|(
name|ep
operator|->
name|X_add_number
operator|&
literal|0xffffffff
operator|)
operator|^
literal|0x80000000
operator|)
operator|-
literal|0x80000000
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|IS_SEXT_16BIT_NUM
argument_list|(
name|ep
operator|->
name|X_add_number
argument_list|)
condition|)
block|{
comment|/* We can handle 16 bit signed values with an addiu to 	     $zero.  No need to ever use daddiu here, since $zero and 	     the result are always correct in 32 bit mode.  */
name|macro_build
argument_list|(
name|ep
argument_list|,
literal|"addiu"
argument_list|,
literal|"t,r,j"
argument_list|,
name|reg
argument_list|,
literal|0
argument_list|,
name|BFD_RELOC_LO16
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|ep
operator|->
name|X_add_number
operator|>=
literal|0
operator|&&
name|ep
operator|->
name|X_add_number
operator|<
literal|0x10000
condition|)
block|{
comment|/* We can handle 16 bit unsigned values with an ori to              $zero.  */
name|macro_build
argument_list|(
name|ep
argument_list|,
literal|"ori"
argument_list|,
literal|"t,r,i"
argument_list|,
name|reg
argument_list|,
literal|0
argument_list|,
name|BFD_RELOC_LO16
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
operator|(
name|IS_SEXT_32BIT_NUM
argument_list|(
name|ep
operator|->
name|X_add_number
argument_list|)
operator|)
condition|)
block|{
comment|/* 32 bit values require an lui.  */
name|macro_build
argument_list|(
name|ep
argument_list|,
literal|"lui"
argument_list|,
literal|"t,u"
argument_list|,
name|reg
argument_list|,
name|BFD_RELOC_HI16
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ep
operator|->
name|X_add_number
operator|&
literal|0xffff
operator|)
operator|!=
literal|0
condition|)
name|macro_build
argument_list|(
name|ep
argument_list|,
literal|"ori"
argument_list|,
literal|"t,r,i"
argument_list|,
name|reg
argument_list|,
name|reg
argument_list|,
name|BFD_RELOC_LO16
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* The value is larger than 32 bits.  */
if|if
condition|(
name|HAVE_32BIT_GPRS
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Number (0x%lx) larger than 32 bits"
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|ep
operator|->
name|X_add_number
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|ep
argument_list|,
literal|"addiu"
argument_list|,
literal|"t,r,j"
argument_list|,
name|reg
argument_list|,
literal|0
argument_list|,
name|BFD_RELOC_LO16
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|ep
operator|->
name|X_op
operator|!=
name|O_big
condition|)
block|{
name|hi32
operator|=
operator|*
name|ep
expr_stmt|;
name|hi32
operator|.
name|X_add_number
operator|=
operator|(
name|valueT
operator|)
name|hi32
operator|.
name|X_add_number
operator|>>
literal|16
expr_stmt|;
name|hi32
operator|.
name|X_add_number
operator|=
operator|(
name|valueT
operator|)
name|hi32
operator|.
name|X_add_number
operator|>>
literal|16
expr_stmt|;
name|hi32
operator|.
name|X_add_number
operator|&=
literal|0xffffffff
expr_stmt|;
name|lo32
operator|=
operator|*
name|ep
expr_stmt|;
name|lo32
operator|.
name|X_add_number
operator|&=
literal|0xffffffff
expr_stmt|;
block|}
else|else
block|{
name|assert
argument_list|(
name|ep
operator|->
name|X_add_number
operator|>
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|ep
operator|->
name|X_add_number
operator|==
literal|3
condition|)
name|generic_bignum
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|ep
operator|->
name|X_add_number
operator|>
literal|4
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Number larger than 64 bits"
argument_list|)
argument_list|)
expr_stmt|;
name|lo32
operator|.
name|X_op
operator|=
name|O_constant
expr_stmt|;
name|lo32
operator|.
name|X_add_number
operator|=
name|generic_bignum
index|[
literal|0
index|]
operator|+
operator|(
name|generic_bignum
index|[
literal|1
index|]
operator|<<
literal|16
operator|)
expr_stmt|;
name|hi32
operator|.
name|X_op
operator|=
name|O_constant
expr_stmt|;
name|hi32
operator|.
name|X_add_number
operator|=
name|generic_bignum
index|[
literal|2
index|]
operator|+
operator|(
name|generic_bignum
index|[
literal|3
index|]
operator|<<
literal|16
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|hi32
operator|.
name|X_add_number
operator|==
literal|0
condition|)
name|freg
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|int
name|shift
decl_stmt|,
name|bit
decl_stmt|;
name|unsigned
name|long
name|hi
decl_stmt|,
name|lo
decl_stmt|;
if|if
condition|(
name|hi32
operator|.
name|X_add_number
operator|==
operator|(
name|offsetT
operator|)
literal|0xffffffff
condition|)
block|{
if|if
condition|(
operator|(
name|lo32
operator|.
name|X_add_number
operator|&
literal|0xffff8000
operator|)
operator|==
literal|0xffff8000
condition|)
block|{
name|macro_build
argument_list|(
operator|&
name|lo32
argument_list|,
literal|"addiu"
argument_list|,
literal|"t,r,j"
argument_list|,
name|reg
argument_list|,
literal|0
argument_list|,
name|BFD_RELOC_LO16
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|lo32
operator|.
name|X_add_number
operator|&
literal|0x80000000
condition|)
block|{
name|macro_build
argument_list|(
operator|&
name|lo32
argument_list|,
literal|"lui"
argument_list|,
literal|"t,u"
argument_list|,
name|reg
argument_list|,
name|BFD_RELOC_HI16
argument_list|)
expr_stmt|;
if|if
condition|(
name|lo32
operator|.
name|X_add_number
operator|&
literal|0xffff
condition|)
name|macro_build
argument_list|(
operator|&
name|lo32
argument_list|,
literal|"ori"
argument_list|,
literal|"t,r,i"
argument_list|,
name|reg
argument_list|,
name|reg
argument_list|,
name|BFD_RELOC_LO16
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* Check for 16bit shifted constant.  We know that hi32 is          non-zero, so start the mask on the first bit of the hi32          value.  */
name|shift
operator|=
literal|17
expr_stmt|;
do|do
block|{
name|unsigned
name|long
name|himask
decl_stmt|,
name|lomask
decl_stmt|;
if|if
condition|(
name|shift
operator|<
literal|32
condition|)
block|{
name|himask
operator|=
literal|0xffff
operator|>>
operator|(
literal|32
operator|-
name|shift
operator|)
expr_stmt|;
name|lomask
operator|=
operator|(
literal|0xffff
operator|<<
name|shift
operator|)
operator|&
literal|0xffffffff
expr_stmt|;
block|}
else|else
block|{
name|himask
operator|=
literal|0xffff
operator|<<
operator|(
name|shift
operator|-
literal|32
operator|)
expr_stmt|;
name|lomask
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|hi32
operator|.
name|X_add_number
operator|&
operator|~
operator|(
name|offsetT
operator|)
name|himask
operator|)
operator|==
literal|0
operator|&&
operator|(
name|lo32
operator|.
name|X_add_number
operator|&
operator|~
operator|(
name|offsetT
operator|)
name|lomask
operator|)
operator|==
literal|0
condition|)
block|{
name|expressionS
name|tmp
decl_stmt|;
name|tmp
operator|.
name|X_op
operator|=
name|O_constant
expr_stmt|;
if|if
condition|(
name|shift
operator|<
literal|32
condition|)
name|tmp
operator|.
name|X_add_number
operator|=
operator|(
operator|(
name|hi32
operator|.
name|X_add_number
operator|<<
operator|(
literal|32
operator|-
name|shift
operator|)
operator|)
operator||
operator|(
name|lo32
operator|.
name|X_add_number
operator|>>
name|shift
operator|)
operator|)
expr_stmt|;
else|else
name|tmp
operator|.
name|X_add_number
operator|=
name|hi32
operator|.
name|X_add_number
operator|>>
operator|(
name|shift
operator|-
literal|32
operator|)
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|tmp
argument_list|,
literal|"ori"
argument_list|,
literal|"t,r,i"
argument_list|,
name|reg
argument_list|,
literal|0
argument_list|,
name|BFD_RELOC_LO16
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
operator|(
name|shift
operator|>=
literal|32
operator|)
condition|?
literal|"dsll32"
else|:
literal|"dsll"
argument_list|,
literal|"d,w,<"
argument_list|,
name|reg
argument_list|,
name|reg
argument_list|,
operator|(
name|shift
operator|>=
literal|32
operator|)
condition|?
name|shift
operator|-
literal|32
else|:
name|shift
argument_list|)
expr_stmt|;
return|return;
block|}
operator|++
name|shift
expr_stmt|;
block|}
do|while
condition|(
name|shift
operator|<=
operator|(
literal|64
operator|-
literal|16
operator|)
condition|)
do|;
comment|/* Find the bit number of the lowest one bit, and store the          shifted value in hi/lo.  */
name|hi
operator|=
call|(
name|unsigned
name|long
call|)
argument_list|(
name|hi32
operator|.
name|X_add_number
operator|&
literal|0xffffffff
argument_list|)
expr_stmt|;
name|lo
operator|=
call|(
name|unsigned
name|long
call|)
argument_list|(
name|lo32
operator|.
name|X_add_number
operator|&
literal|0xffffffff
argument_list|)
expr_stmt|;
if|if
condition|(
name|lo
operator|!=
literal|0
condition|)
block|{
name|bit
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|lo
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
block|{
name|lo
operator|>>=
literal|1
expr_stmt|;
operator|++
name|bit
expr_stmt|;
block|}
name|lo
operator||=
operator|(
name|hi
operator|&
operator|(
operator|(
operator|(
name|unsigned
name|long
operator|)
literal|1
operator|<<
name|bit
operator|)
operator|-
literal|1
operator|)
operator|)
operator|<<
operator|(
literal|32
operator|-
name|bit
operator|)
expr_stmt|;
name|hi
operator|>>=
name|bit
expr_stmt|;
block|}
else|else
block|{
name|bit
operator|=
literal|32
expr_stmt|;
while|while
condition|(
operator|(
name|hi
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
block|{
name|hi
operator|>>=
literal|1
expr_stmt|;
operator|++
name|bit
expr_stmt|;
block|}
name|lo
operator|=
name|hi
expr_stmt|;
name|hi
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Optimize if the shifted value is a (power of 2) - 1.  */
if|if
condition|(
operator|(
name|hi
operator|==
literal|0
operator|&&
operator|(
operator|(
name|lo
operator|+
literal|1
operator|)
operator|&
name|lo
operator|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|lo
operator|==
literal|0xffffffff
operator|&&
operator|(
operator|(
name|hi
operator|+
literal|1
operator|)
operator|&
name|hi
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|shift
operator|=
name|COUNT_TOP_ZEROES
argument_list|(
operator|(
name|unsigned
name|int
operator|)
name|hi32
operator|.
name|X_add_number
argument_list|)
expr_stmt|;
if|if
condition|(
name|shift
operator|!=
literal|0
condition|)
block|{
name|expressionS
name|tmp
decl_stmt|;
comment|/* This instruction will set the register to be all                  ones.  */
name|tmp
operator|.
name|X_op
operator|=
name|O_constant
expr_stmt|;
name|tmp
operator|.
name|X_add_number
operator|=
operator|(
name|offsetT
operator|)
operator|-
literal|1
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|tmp
argument_list|,
literal|"addiu"
argument_list|,
literal|"t,r,j"
argument_list|,
name|reg
argument_list|,
literal|0
argument_list|,
name|BFD_RELOC_LO16
argument_list|)
expr_stmt|;
if|if
condition|(
name|bit
operator|!=
literal|0
condition|)
block|{
name|bit
operator|+=
name|shift
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
operator|(
name|bit
operator|>=
literal|32
operator|)
condition|?
literal|"dsll32"
else|:
literal|"dsll"
argument_list|,
literal|"d,w,<"
argument_list|,
name|reg
argument_list|,
name|reg
argument_list|,
operator|(
name|bit
operator|>=
literal|32
operator|)
condition|?
name|bit
operator|-
literal|32
else|:
name|bit
argument_list|)
expr_stmt|;
block|}
name|macro_build
argument_list|(
name|NULL
argument_list|,
operator|(
name|shift
operator|>=
literal|32
operator|)
condition|?
literal|"dsrl32"
else|:
literal|"dsrl"
argument_list|,
literal|"d,w,<"
argument_list|,
name|reg
argument_list|,
name|reg
argument_list|,
operator|(
name|shift
operator|>=
literal|32
operator|)
condition|?
name|shift
operator|-
literal|32
else|:
name|shift
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* Sign extend hi32 before calling load_register, because we can          generally get better code when we load a sign extended value.  */
if|if
condition|(
operator|(
name|hi32
operator|.
name|X_add_number
operator|&
literal|0x80000000
operator|)
operator|!=
literal|0
condition|)
name|hi32
operator|.
name|X_add_number
operator||=
operator|~
operator|(
name|offsetT
operator|)
literal|0xffffffff
expr_stmt|;
name|load_register
argument_list|(
name|reg
argument_list|,
operator|&
name|hi32
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|freg
operator|=
name|reg
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|lo32
operator|.
name|X_add_number
operator|&
literal|0xffff0000
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|freg
operator|!=
literal|0
condition|)
block|{
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"dsll32"
argument_list|,
literal|"d,w,<"
argument_list|,
name|reg
argument_list|,
name|freg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|freg
operator|=
name|reg
expr_stmt|;
block|}
block|}
else|else
block|{
name|expressionS
name|mid16
decl_stmt|;
if|if
condition|(
operator|(
name|freg
operator|==
literal|0
operator|)
operator|&&
operator|(
name|lo32
operator|.
name|X_add_number
operator|==
operator|(
name|offsetT
operator|)
literal|0xffffffff
operator|)
condition|)
block|{
name|macro_build
argument_list|(
operator|&
name|lo32
argument_list|,
literal|"lui"
argument_list|,
literal|"t,u"
argument_list|,
name|reg
argument_list|,
name|BFD_RELOC_HI16
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"dsrl32"
argument_list|,
literal|"d,w,<"
argument_list|,
name|reg
argument_list|,
name|reg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|freg
operator|!=
literal|0
condition|)
block|{
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"dsll"
argument_list|,
literal|"d,w,<"
argument_list|,
name|reg
argument_list|,
name|freg
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|freg
operator|=
name|reg
expr_stmt|;
block|}
name|mid16
operator|=
name|lo32
expr_stmt|;
name|mid16
operator|.
name|X_add_number
operator|>>=
literal|16
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|mid16
argument_list|,
literal|"ori"
argument_list|,
literal|"t,r,i"
argument_list|,
name|reg
argument_list|,
name|freg
argument_list|,
name|BFD_RELOC_LO16
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"dsll"
argument_list|,
literal|"d,w,<"
argument_list|,
name|reg
argument_list|,
name|reg
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|freg
operator|=
name|reg
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|lo32
operator|.
name|X_add_number
operator|&
literal|0xffff
operator|)
operator|!=
literal|0
condition|)
name|macro_build
argument_list|(
operator|&
name|lo32
argument_list|,
literal|"ori"
argument_list|,
literal|"t,r,i"
argument_list|,
name|reg
argument_list|,
name|freg
argument_list|,
name|BFD_RELOC_LO16
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Load an address into a register.  */
end_comment

begin_function
specifier|static
name|void
name|load_address
parameter_list|(
name|int
name|reg
parameter_list|,
name|expressionS
modifier|*
name|ep
parameter_list|,
name|int
modifier|*
name|used_at
parameter_list|)
block|{
if|if
condition|(
name|ep
operator|->
name|X_op
operator|!=
name|O_constant
operator|&&
name|ep
operator|->
name|X_op
operator|!=
name|O_symbol
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"expression too complex"
argument_list|)
argument_list|)
expr_stmt|;
name|ep
operator|->
name|X_op
operator|=
name|O_constant
expr_stmt|;
block|}
if|if
condition|(
name|ep
operator|->
name|X_op
operator|==
name|O_constant
condition|)
block|{
name|load_register
argument_list|(
name|reg
argument_list|,
name|ep
argument_list|,
name|HAVE_64BIT_ADDRESSES
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|mips_pic
operator|==
name|NO_PIC
condition|)
block|{
comment|/* If this is a reference to a GP relative symbol, we want 	   addiu	$reg,$gp,<sym>		(BFD_RELOC_GPREL16) 	 Otherwise we want 	   lui		$reg,<sym>		(BFD_RELOC_HI16_S) 	   addiu	$reg,$reg,<sym>		(BFD_RELOC_LO16) 	 If we have an addend, we always use the latter form.  	 With 64bit address space and a usable $at we want 	   lui		$reg,<sym>		(BFD_RELOC_MIPS_HIGHEST) 	   lui		$at,<sym>		(BFD_RELOC_HI16_S) 	   daddiu	$reg,<sym>		(BFD_RELOC_MIPS_HIGHER) 	   daddiu	$at,<sym>		(BFD_RELOC_LO16) 	   dsll32	$reg,0 	   daddu	$reg,$reg,$at  	 If $at is already in use, we use a path which is suboptimal 	 on superscalar processors. 	   lui		$reg,<sym>		(BFD_RELOC_MIPS_HIGHEST) 	   daddiu	$reg,<sym>		(BFD_RELOC_MIPS_HIGHER) 	   dsll		$reg,16 	   daddiu	$reg,<sym>		(BFD_RELOC_HI16_S) 	   dsll		$reg,16 	   daddiu	$reg,<sym>		(BFD_RELOC_LO16)        */
if|if
condition|(
name|HAVE_64BIT_ADDRESSES
condition|)
block|{
comment|/* ??? We don't provide a GP-relative alternative for these macros. 	     It used not to be possible with the original relaxation code, 	     but it could be done now.  */
if|if
condition|(
operator|*
name|used_at
operator|==
literal|0
operator|&&
operator|!
name|mips_opts
operator|.
name|noat
condition|)
block|{
name|macro_build
argument_list|(
name|ep
argument_list|,
literal|"lui"
argument_list|,
literal|"t,u"
argument_list|,
name|reg
argument_list|,
name|BFD_RELOC_MIPS_HIGHEST
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|ep
argument_list|,
literal|"lui"
argument_list|,
literal|"t,u"
argument_list|,
name|AT
argument_list|,
name|BFD_RELOC_HI16_S
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|ep
argument_list|,
literal|"daddiu"
argument_list|,
literal|"t,r,j"
argument_list|,
name|reg
argument_list|,
name|reg
argument_list|,
name|BFD_RELOC_MIPS_HIGHER
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|ep
argument_list|,
literal|"daddiu"
argument_list|,
literal|"t,r,j"
argument_list|,
name|AT
argument_list|,
name|AT
argument_list|,
name|BFD_RELOC_LO16
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"dsll32"
argument_list|,
literal|"d,w,<"
argument_list|,
name|reg
argument_list|,
name|reg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"daddu"
argument_list|,
literal|"d,v,t"
argument_list|,
name|reg
argument_list|,
name|reg
argument_list|,
name|AT
argument_list|)
expr_stmt|;
operator|*
name|used_at
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|macro_build
argument_list|(
name|ep
argument_list|,
literal|"lui"
argument_list|,
literal|"t,u"
argument_list|,
name|reg
argument_list|,
name|BFD_RELOC_MIPS_HIGHEST
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|ep
argument_list|,
literal|"daddiu"
argument_list|,
literal|"t,r,j"
argument_list|,
name|reg
argument_list|,
name|reg
argument_list|,
name|BFD_RELOC_MIPS_HIGHER
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"dsll"
argument_list|,
literal|"d,w,<"
argument_list|,
name|reg
argument_list|,
name|reg
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|ep
argument_list|,
literal|"daddiu"
argument_list|,
literal|"t,r,j"
argument_list|,
name|reg
argument_list|,
name|reg
argument_list|,
name|BFD_RELOC_HI16_S
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"dsll"
argument_list|,
literal|"d,w,<"
argument_list|,
name|reg
argument_list|,
name|reg
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|ep
argument_list|,
literal|"daddiu"
argument_list|,
literal|"t,r,j"
argument_list|,
name|reg
argument_list|,
name|reg
argument_list|,
name|BFD_RELOC_LO16
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|(
name|valueT
operator|)
name|ep
operator|->
name|X_add_number
operator|<=
name|MAX_GPREL_OFFSET
operator|&&
operator|!
name|nopic_need_relax
argument_list|(
name|ep
operator|->
name|X_add_symbol
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|relax_start
argument_list|(
name|ep
operator|->
name|X_add_symbol
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|ep
argument_list|,
name|ADDRESS_ADDI_INSN
argument_list|,
literal|"t,r,j"
argument_list|,
name|reg
argument_list|,
name|mips_gp_register
argument_list|,
name|BFD_RELOC_GPREL16
argument_list|)
expr_stmt|;
name|relax_switch
argument_list|()
expr_stmt|;
block|}
name|macro_build_lui
argument_list|(
name|ep
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|ep
argument_list|,
name|ADDRESS_ADDI_INSN
argument_list|,
literal|"t,r,j"
argument_list|,
name|reg
argument_list|,
name|reg
argument_list|,
name|BFD_RELOC_LO16
argument_list|)
expr_stmt|;
if|if
condition|(
name|mips_relax
operator|.
name|sequence
condition|)
name|relax_end
argument_list|()
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|mips_pic
operator|==
name|SVR4_PIC
operator|&&
operator|!
name|mips_big_got
condition|)
block|{
name|expressionS
name|ex
decl_stmt|;
comment|/* If this is a reference to an external symbol, we want 	   lw		$reg,<sym>($gp)		(BFD_RELOC_MIPS_GOT16) 	 Otherwise we want 	   lw		$reg,<sym>($gp)		(BFD_RELOC_MIPS_GOT16) 	   nop 	   addiu	$reg,$reg,<sym>		(BFD_RELOC_LO16) 	 If there is a constant, it must be added in after.  	 If we have NewABI, we want 	   lw		$reg,<sym+cst>($gp)	(BFD_RELOC_MIPS_GOT_DISP)          unless we're referencing a global symbol with a non-zero          offset, in which case cst must be added separately.  */
if|if
condition|(
name|HAVE_NEWABI
condition|)
block|{
if|if
condition|(
name|ep
operator|->
name|X_add_number
condition|)
block|{
name|ex
operator|.
name|X_add_number
operator|=
name|ep
operator|->
name|X_add_number
expr_stmt|;
name|ep
operator|->
name|X_add_number
operator|=
literal|0
expr_stmt|;
name|relax_start
argument_list|(
name|ep
operator|->
name|X_add_symbol
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|ep
argument_list|,
name|ADDRESS_LOAD_INSN
argument_list|,
literal|"t,o(b)"
argument_list|,
name|reg
argument_list|,
name|BFD_RELOC_MIPS_GOT_DISP
argument_list|,
name|mips_gp_register
argument_list|)
expr_stmt|;
if|if
condition|(
name|ex
operator|.
name|X_add_number
operator|<
operator|-
literal|0x8000
operator|||
name|ex
operator|.
name|X_add_number
operator|>=
literal|0x8000
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"PIC code offset overflow (max 16 signed bits)"
argument_list|)
argument_list|)
expr_stmt|;
name|ex
operator|.
name|X_op
operator|=
name|O_constant
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|ex
argument_list|,
name|ADDRESS_ADDI_INSN
argument_list|,
literal|"t,r,j"
argument_list|,
name|reg
argument_list|,
name|reg
argument_list|,
name|BFD_RELOC_LO16
argument_list|)
expr_stmt|;
name|ep
operator|->
name|X_add_number
operator|=
name|ex
operator|.
name|X_add_number
expr_stmt|;
name|relax_switch
argument_list|()
expr_stmt|;
block|}
name|macro_build
argument_list|(
name|ep
argument_list|,
name|ADDRESS_LOAD_INSN
argument_list|,
literal|"t,o(b)"
argument_list|,
name|reg
argument_list|,
name|BFD_RELOC_MIPS_GOT_DISP
argument_list|,
name|mips_gp_register
argument_list|)
expr_stmt|;
if|if
condition|(
name|mips_relax
operator|.
name|sequence
condition|)
name|relax_end
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|ex
operator|.
name|X_add_number
operator|=
name|ep
operator|->
name|X_add_number
expr_stmt|;
name|ep
operator|->
name|X_add_number
operator|=
literal|0
expr_stmt|;
name|macro_build
argument_list|(
name|ep
argument_list|,
name|ADDRESS_LOAD_INSN
argument_list|,
literal|"t,o(b)"
argument_list|,
name|reg
argument_list|,
name|BFD_RELOC_MIPS_GOT16
argument_list|,
name|mips_gp_register
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"nop"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|relax_start
argument_list|(
name|ep
operator|->
name|X_add_symbol
argument_list|)
expr_stmt|;
name|relax_switch
argument_list|()
expr_stmt|;
name|macro_build
argument_list|(
name|ep
argument_list|,
name|ADDRESS_ADDI_INSN
argument_list|,
literal|"t,r,j"
argument_list|,
name|reg
argument_list|,
name|reg
argument_list|,
name|BFD_RELOC_LO16
argument_list|)
expr_stmt|;
name|relax_end
argument_list|()
expr_stmt|;
if|if
condition|(
name|ex
operator|.
name|X_add_number
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|ex
operator|.
name|X_add_number
operator|<
operator|-
literal|0x8000
operator|||
name|ex
operator|.
name|X_add_number
operator|>=
literal|0x8000
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"PIC code offset overflow (max 16 signed bits)"
argument_list|)
argument_list|)
expr_stmt|;
name|ex
operator|.
name|X_op
operator|=
name|O_constant
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|ex
argument_list|,
name|ADDRESS_ADDI_INSN
argument_list|,
literal|"t,r,j"
argument_list|,
name|reg
argument_list|,
name|reg
argument_list|,
name|BFD_RELOC_LO16
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|mips_pic
operator|==
name|SVR4_PIC
condition|)
block|{
name|expressionS
name|ex
decl_stmt|;
comment|/* This is the large GOT case.  If this is a reference to an 	 external symbol, we want 	   lui		$reg,<sym>		(BFD_RELOC_MIPS_GOT_HI16) 	   addu		$reg,$reg,$gp 	   lw		$reg,<sym>($reg)	(BFD_RELOC_MIPS_GOT_LO16)  	 Otherwise, for a reference to a local symbol in old ABI, we want 	   lw		$reg,<sym>($gp)		(BFD_RELOC_MIPS_GOT16) 	   nop 	   addiu	$reg,$reg,<sym>		(BFD_RELOC_LO16) 	 If there is a constant, it must be added in after.  	 In the NewABI, for local symbols, with or without offsets, we want: 	   lw		$reg,<sym>($gp)		(BFD_RELOC_MIPS_GOT_PAGE) 	   addiu	$reg,$reg,<sym>		(BFD_RELOC_MIPS_GOT_OFST)       */
if|if
condition|(
name|HAVE_NEWABI
condition|)
block|{
name|ex
operator|.
name|X_add_number
operator|=
name|ep
operator|->
name|X_add_number
expr_stmt|;
name|ep
operator|->
name|X_add_number
operator|=
literal|0
expr_stmt|;
name|relax_start
argument_list|(
name|ep
operator|->
name|X_add_symbol
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|ep
argument_list|,
literal|"lui"
argument_list|,
literal|"t,u"
argument_list|,
name|reg
argument_list|,
name|BFD_RELOC_MIPS_GOT_HI16
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
name|ADDRESS_ADD_INSN
argument_list|,
literal|"d,v,t"
argument_list|,
name|reg
argument_list|,
name|reg
argument_list|,
name|mips_gp_register
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|ep
argument_list|,
name|ADDRESS_LOAD_INSN
argument_list|,
literal|"t,o(b)"
argument_list|,
name|reg
argument_list|,
name|BFD_RELOC_MIPS_GOT_LO16
argument_list|,
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|ex
operator|.
name|X_add_number
operator|<
operator|-
literal|0x8000
operator|||
name|ex
operator|.
name|X_add_number
operator|>=
literal|0x8000
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"PIC code offset overflow (max 16 signed bits)"
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ex
operator|.
name|X_add_number
condition|)
block|{
name|ex
operator|.
name|X_op
operator|=
name|O_constant
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|ex
argument_list|,
name|ADDRESS_ADDI_INSN
argument_list|,
literal|"t,r,j"
argument_list|,
name|reg
argument_list|,
name|reg
argument_list|,
name|BFD_RELOC_LO16
argument_list|)
expr_stmt|;
block|}
name|ep
operator|->
name|X_add_number
operator|=
name|ex
operator|.
name|X_add_number
expr_stmt|;
name|relax_switch
argument_list|()
expr_stmt|;
name|macro_build
argument_list|(
name|ep
argument_list|,
name|ADDRESS_LOAD_INSN
argument_list|,
literal|"t,o(b)"
argument_list|,
name|reg
argument_list|,
name|BFD_RELOC_MIPS_GOT_PAGE
argument_list|,
name|mips_gp_register
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|ep
argument_list|,
name|ADDRESS_ADDI_INSN
argument_list|,
literal|"t,r,j"
argument_list|,
name|reg
argument_list|,
name|reg
argument_list|,
name|BFD_RELOC_MIPS_GOT_OFST
argument_list|)
expr_stmt|;
name|relax_end
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|ex
operator|.
name|X_add_number
operator|=
name|ep
operator|->
name|X_add_number
expr_stmt|;
name|ep
operator|->
name|X_add_number
operator|=
literal|0
expr_stmt|;
name|relax_start
argument_list|(
name|ep
operator|->
name|X_add_symbol
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|ep
argument_list|,
literal|"lui"
argument_list|,
literal|"t,u"
argument_list|,
name|reg
argument_list|,
name|BFD_RELOC_MIPS_GOT_HI16
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
name|ADDRESS_ADD_INSN
argument_list|,
literal|"d,v,t"
argument_list|,
name|reg
argument_list|,
name|reg
argument_list|,
name|mips_gp_register
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|ep
argument_list|,
name|ADDRESS_LOAD_INSN
argument_list|,
literal|"t,o(b)"
argument_list|,
name|reg
argument_list|,
name|BFD_RELOC_MIPS_GOT_LO16
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|relax_switch
argument_list|()
expr_stmt|;
if|if
condition|(
name|reg_needs_delay
argument_list|(
name|mips_gp_register
argument_list|)
condition|)
block|{
comment|/* We need a nop before loading from $gp.  This special 		 check is required because the lui which starts the main 		 instruction stream does not refer to $gp, and so will not 		 insert the nop which may be required.  */
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"nop"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
name|macro_build
argument_list|(
name|ep
argument_list|,
name|ADDRESS_LOAD_INSN
argument_list|,
literal|"t,o(b)"
argument_list|,
name|reg
argument_list|,
name|BFD_RELOC_MIPS_GOT16
argument_list|,
name|mips_gp_register
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"nop"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|ep
argument_list|,
name|ADDRESS_ADDI_INSN
argument_list|,
literal|"t,r,j"
argument_list|,
name|reg
argument_list|,
name|reg
argument_list|,
name|BFD_RELOC_LO16
argument_list|)
expr_stmt|;
name|relax_end
argument_list|()
expr_stmt|;
if|if
condition|(
name|ex
operator|.
name|X_add_number
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|ex
operator|.
name|X_add_number
operator|<
operator|-
literal|0x8000
operator|||
name|ex
operator|.
name|X_add_number
operator|>=
literal|0x8000
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"PIC code offset overflow (max 16 signed bits)"
argument_list|)
argument_list|)
expr_stmt|;
name|ex
operator|.
name|X_op
operator|=
name|O_constant
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|ex
argument_list|,
name|ADDRESS_ADDI_INSN
argument_list|,
literal|"t,r,j"
argument_list|,
name|reg
argument_list|,
name|reg
argument_list|,
name|BFD_RELOC_LO16
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|mips_pic
operator|==
name|EMBEDDED_PIC
condition|)
block|{
comment|/* We always do 	   addiu	$reg,$gp,<sym>		(BFD_RELOC_GPREL16)        */
name|macro_build
argument_list|(
name|ep
argument_list|,
name|ADDRESS_ADDI_INSN
argument_list|,
literal|"t,r,j"
argument_list|,
name|reg
argument_list|,
name|mips_gp_register
argument_list|,
name|BFD_RELOC_GPREL16
argument_list|)
expr_stmt|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Move the contents of register SOURCE into register DEST.  */
end_comment

begin_function
specifier|static
name|void
name|move_register
parameter_list|(
name|int
name|dest
parameter_list|,
name|int
name|source
parameter_list|)
block|{
name|macro_build
argument_list|(
name|NULL
argument_list|,
name|HAVE_32BIT_GPRS
condition|?
literal|"addu"
else|:
literal|"daddu"
argument_list|,
literal|"d,v,t"
argument_list|,
name|dest
argument_list|,
name|source
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Emit an SVR4 PIC sequence to load address LOCAL into DEST, where    LOCAL is the sum of a symbol and a 16-bit or 32-bit displacement.    The two alternatives are:     Global symbol		Local sybmol    -------------		------------    lw DEST,%got(SYMBOL)		lw DEST,%got(SYMBOL + OFFSET)    ...				...    addiu DEST,DEST,OFFSET	addiu DEST,DEST,%lo(SYMBOL + OFFSET)     load_got_offset emits the first instruction and add_got_offset    emits the second for a 16-bit offset or add_got_offset_hilo emits    a sequence to add a 32-bit offset using a scratch register.  */
end_comment

begin_function
specifier|static
name|void
name|load_got_offset
parameter_list|(
name|int
name|dest
parameter_list|,
name|expressionS
modifier|*
name|local
parameter_list|)
block|{
name|expressionS
name|global
decl_stmt|;
name|global
operator|=
operator|*
name|local
expr_stmt|;
name|global
operator|.
name|X_add_number
operator|=
literal|0
expr_stmt|;
name|relax_start
argument_list|(
name|local
operator|->
name|X_add_symbol
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|global
argument_list|,
name|ADDRESS_LOAD_INSN
argument_list|,
literal|"t,o(b)"
argument_list|,
name|dest
argument_list|,
name|BFD_RELOC_MIPS_GOT16
argument_list|,
name|mips_gp_register
argument_list|)
expr_stmt|;
name|relax_switch
argument_list|()
expr_stmt|;
name|macro_build
argument_list|(
name|local
argument_list|,
name|ADDRESS_LOAD_INSN
argument_list|,
literal|"t,o(b)"
argument_list|,
name|dest
argument_list|,
name|BFD_RELOC_MIPS_GOT16
argument_list|,
name|mips_gp_register
argument_list|)
expr_stmt|;
name|relax_end
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|add_got_offset
parameter_list|(
name|int
name|dest
parameter_list|,
name|expressionS
modifier|*
name|local
parameter_list|)
block|{
name|expressionS
name|global
decl_stmt|;
name|global
operator|.
name|X_op
operator|=
name|O_constant
expr_stmt|;
name|global
operator|.
name|X_op_symbol
operator|=
name|NULL
expr_stmt|;
name|global
operator|.
name|X_add_symbol
operator|=
name|NULL
expr_stmt|;
name|global
operator|.
name|X_add_number
operator|=
name|local
operator|->
name|X_add_number
expr_stmt|;
name|relax_start
argument_list|(
name|local
operator|->
name|X_add_symbol
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|global
argument_list|,
name|ADDRESS_ADDI_INSN
argument_list|,
literal|"t,r,j"
argument_list|,
name|dest
argument_list|,
name|dest
argument_list|,
name|BFD_RELOC_LO16
argument_list|)
expr_stmt|;
name|relax_switch
argument_list|()
expr_stmt|;
name|macro_build
argument_list|(
name|local
argument_list|,
name|ADDRESS_ADDI_INSN
argument_list|,
literal|"t,r,j"
argument_list|,
name|dest
argument_list|,
name|dest
argument_list|,
name|BFD_RELOC_LO16
argument_list|)
expr_stmt|;
name|relax_end
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|add_got_offset_hilo
parameter_list|(
name|int
name|dest
parameter_list|,
name|expressionS
modifier|*
name|local
parameter_list|,
name|int
name|tmp
parameter_list|)
block|{
name|expressionS
name|global
decl_stmt|;
name|int
name|hold_mips_optimize
decl_stmt|;
name|global
operator|.
name|X_op
operator|=
name|O_constant
expr_stmt|;
name|global
operator|.
name|X_op_symbol
operator|=
name|NULL
expr_stmt|;
name|global
operator|.
name|X_add_symbol
operator|=
name|NULL
expr_stmt|;
name|global
operator|.
name|X_add_number
operator|=
name|local
operator|->
name|X_add_number
expr_stmt|;
name|relax_start
argument_list|(
name|local
operator|->
name|X_add_symbol
argument_list|)
expr_stmt|;
name|load_register
argument_list|(
name|tmp
argument_list|,
operator|&
name|global
argument_list|,
name|HAVE_64BIT_ADDRESSES
argument_list|)
expr_stmt|;
name|relax_switch
argument_list|()
expr_stmt|;
comment|/* Set mips_optimize around the lui instruction to avoid      inserting an unnecessary nop after the lw.  */
name|hold_mips_optimize
operator|=
name|mips_optimize
expr_stmt|;
name|mips_optimize
operator|=
literal|2
expr_stmt|;
name|macro_build_lui
argument_list|(
operator|&
name|global
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|mips_optimize
operator|=
name|hold_mips_optimize
expr_stmt|;
name|macro_build
argument_list|(
name|local
argument_list|,
name|ADDRESS_ADDI_INSN
argument_list|,
literal|"t,r,j"
argument_list|,
name|tmp
argument_list|,
name|tmp
argument_list|,
name|BFD_RELOC_LO16
argument_list|)
expr_stmt|;
name|relax_end
argument_list|()
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
name|ADDRESS_ADD_INSN
argument_list|,
literal|"d,v,t"
argument_list|,
name|dest
argument_list|,
name|dest
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *			Build macros  *   This routine implements the seemingly endless macro or synthesized  * instructions and addressing modes in the mips assembly language. Many  * of these macros are simple and are similar to each other. These could  * probably be handled by some kind of table or grammar approach instead of  * this verbose method. Others are not simple macros but are more like  * optimizing code generation.  *   One interesting optimization is when several store macros appear  * consecutively that would load AT with the upper half of the same address.  * The ensuing load upper instructions are ommited. This implies some kind  * of global optimization. We currently only optimize within a single macro.  *   For many of the load and store macros if the address is specified as a  * constant expression in the first 64k of memory (ie ld $2,0x4000c) we  * first load register 'at' with zero and use it as the base register. The  * mips assembler simply uses register $zero. Just one tiny optimization  * we're missing.  */
end_comment

begin_function
specifier|static
name|void
name|macro
parameter_list|(
name|struct
name|mips_cl_insn
modifier|*
name|ip
parameter_list|)
block|{
specifier|register
name|int
name|treg
decl_stmt|,
name|sreg
decl_stmt|,
name|dreg
decl_stmt|,
name|breg
decl_stmt|;
name|int
name|tempreg
decl_stmt|;
name|int
name|mask
decl_stmt|;
name|int
name|used_at
init|=
literal|0
decl_stmt|;
name|expressionS
name|expr1
decl_stmt|;
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
specifier|const
name|char
modifier|*
name|s2
decl_stmt|;
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
name|int
name|likely
init|=
literal|0
decl_stmt|;
name|int
name|dbl
init|=
literal|0
decl_stmt|;
name|int
name|coproc
init|=
literal|0
decl_stmt|;
name|int
name|lr
init|=
literal|0
decl_stmt|;
name|int
name|imm
init|=
literal|0
decl_stmt|;
name|int
name|call
init|=
literal|0
decl_stmt|;
name|int
name|off
decl_stmt|;
name|offsetT
name|maxnum
decl_stmt|;
name|bfd_reloc_code_real_type
name|r
decl_stmt|;
name|int
name|hold_mips_optimize
decl_stmt|;
name|assert
argument_list|(
operator|!
name|mips_opts
operator|.
name|mips16
argument_list|)
expr_stmt|;
name|treg
operator|=
operator|(
name|ip
operator|->
name|insn_opcode
operator|>>
literal|16
operator|)
operator|&
literal|0x1f
expr_stmt|;
name|dreg
operator|=
operator|(
name|ip
operator|->
name|insn_opcode
operator|>>
literal|11
operator|)
operator|&
literal|0x1f
expr_stmt|;
name|sreg
operator|=
name|breg
operator|=
operator|(
name|ip
operator|->
name|insn_opcode
operator|>>
literal|21
operator|)
operator|&
literal|0x1f
expr_stmt|;
name|mask
operator|=
name|ip
operator|->
name|insn_mo
operator|->
name|mask
expr_stmt|;
name|expr1
operator|.
name|X_op
operator|=
name|O_constant
expr_stmt|;
name|expr1
operator|.
name|X_op_symbol
operator|=
name|NULL
expr_stmt|;
name|expr1
operator|.
name|X_add_symbol
operator|=
name|NULL
expr_stmt|;
name|expr1
operator|.
name|X_add_number
operator|=
literal|1
expr_stmt|;
switch|switch
condition|(
name|mask
condition|)
block|{
case|case
name|M_DABS
case|:
name|dbl
operator|=
literal|1
expr_stmt|;
case|case
name|M_ABS
case|:
comment|/* bgez $a0,.+12 	 move v0,$a0 	 sub v0,$zero,$a0 	 */
name|mips_emit_delays
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
operator|++
name|mips_opts
operator|.
name|noreorder
expr_stmt|;
name|mips_any_noreorder
operator|=
literal|1
expr_stmt|;
name|expr1
operator|.
name|X_add_number
operator|=
literal|8
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|expr1
argument_list|,
literal|"bgez"
argument_list|,
literal|"s,p"
argument_list|,
name|sreg
argument_list|)
expr_stmt|;
if|if
condition|(
name|dreg
operator|==
name|sreg
condition|)
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"nop"
argument_list|,
literal|""
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|move_register
argument_list|(
name|dreg
argument_list|,
name|sreg
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
name|dbl
condition|?
literal|"dsub"
else|:
literal|"sub"
argument_list|,
literal|"d,v,t"
argument_list|,
name|dreg
argument_list|,
literal|0
argument_list|,
name|sreg
argument_list|)
expr_stmt|;
operator|--
name|mips_opts
operator|.
name|noreorder
expr_stmt|;
return|return;
case|case
name|M_ADD_I
case|:
name|s
operator|=
literal|"addi"
expr_stmt|;
name|s2
operator|=
literal|"add"
expr_stmt|;
goto|goto
name|do_addi
goto|;
case|case
name|M_ADDU_I
case|:
name|s
operator|=
literal|"addiu"
expr_stmt|;
name|s2
operator|=
literal|"addu"
expr_stmt|;
goto|goto
name|do_addi
goto|;
case|case
name|M_DADD_I
case|:
name|dbl
operator|=
literal|1
expr_stmt|;
name|s
operator|=
literal|"daddi"
expr_stmt|;
name|s2
operator|=
literal|"dadd"
expr_stmt|;
goto|goto
name|do_addi
goto|;
case|case
name|M_DADDU_I
case|:
name|dbl
operator|=
literal|1
expr_stmt|;
name|s
operator|=
literal|"daddiu"
expr_stmt|;
name|s2
operator|=
literal|"daddu"
expr_stmt|;
name|do_addi
label|:
if|if
condition|(
name|imm_expr
operator|.
name|X_op
operator|==
name|O_constant
operator|&&
name|imm_expr
operator|.
name|X_add_number
operator|>=
operator|-
literal|0x8000
operator|&&
name|imm_expr
operator|.
name|X_add_number
operator|<
literal|0x8000
condition|)
block|{
name|macro_build
argument_list|(
operator|&
name|imm_expr
argument_list|,
name|s
argument_list|,
literal|"t,r,j"
argument_list|,
name|treg
argument_list|,
name|sreg
argument_list|,
name|BFD_RELOC_LO16
argument_list|)
expr_stmt|;
return|return;
block|}
name|load_register
argument_list|(
name|AT
argument_list|,
operator|&
name|imm_expr
argument_list|,
name|dbl
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
name|s2
argument_list|,
literal|"d,v,t"
argument_list|,
name|treg
argument_list|,
name|sreg
argument_list|,
name|AT
argument_list|)
expr_stmt|;
break|break;
case|case
name|M_AND_I
case|:
name|s
operator|=
literal|"andi"
expr_stmt|;
name|s2
operator|=
literal|"and"
expr_stmt|;
goto|goto
name|do_bit
goto|;
case|case
name|M_OR_I
case|:
name|s
operator|=
literal|"ori"
expr_stmt|;
name|s2
operator|=
literal|"or"
expr_stmt|;
goto|goto
name|do_bit
goto|;
case|case
name|M_NOR_I
case|:
name|s
operator|=
literal|""
expr_stmt|;
name|s2
operator|=
literal|"nor"
expr_stmt|;
goto|goto
name|do_bit
goto|;
case|case
name|M_XOR_I
case|:
name|s
operator|=
literal|"xori"
expr_stmt|;
name|s2
operator|=
literal|"xor"
expr_stmt|;
name|do_bit
label|:
if|if
condition|(
name|imm_expr
operator|.
name|X_op
operator|==
name|O_constant
operator|&&
name|imm_expr
operator|.
name|X_add_number
operator|>=
literal|0
operator|&&
name|imm_expr
operator|.
name|X_add_number
operator|<
literal|0x10000
condition|)
block|{
if|if
condition|(
name|mask
operator|!=
name|M_NOR_I
condition|)
name|macro_build
argument_list|(
operator|&
name|imm_expr
argument_list|,
name|s
argument_list|,
literal|"t,r,i"
argument_list|,
name|treg
argument_list|,
name|sreg
argument_list|,
name|BFD_RELOC_LO16
argument_list|)
expr_stmt|;
else|else
block|{
name|macro_build
argument_list|(
operator|&
name|imm_expr
argument_list|,
literal|"ori"
argument_list|,
literal|"t,r,i"
argument_list|,
name|treg
argument_list|,
name|sreg
argument_list|,
name|BFD_RELOC_LO16
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"nor"
argument_list|,
literal|"d,v,t"
argument_list|,
name|treg
argument_list|,
name|treg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
name|load_register
argument_list|(
name|AT
argument_list|,
operator|&
name|imm_expr
argument_list|,
name|HAVE_64BIT_GPRS
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
name|s2
argument_list|,
literal|"d,v,t"
argument_list|,
name|treg
argument_list|,
name|sreg
argument_list|,
name|AT
argument_list|)
expr_stmt|;
break|break;
case|case
name|M_BEQ_I
case|:
name|s
operator|=
literal|"beq"
expr_stmt|;
goto|goto
name|beq_i
goto|;
case|case
name|M_BEQL_I
case|:
name|s
operator|=
literal|"beql"
expr_stmt|;
name|likely
operator|=
literal|1
expr_stmt|;
goto|goto
name|beq_i
goto|;
case|case
name|M_BNE_I
case|:
name|s
operator|=
literal|"bne"
expr_stmt|;
goto|goto
name|beq_i
goto|;
case|case
name|M_BNEL_I
case|:
name|s
operator|=
literal|"bnel"
expr_stmt|;
name|likely
operator|=
literal|1
expr_stmt|;
name|beq_i
label|:
if|if
condition|(
name|imm_expr
operator|.
name|X_op
operator|==
name|O_constant
operator|&&
name|imm_expr
operator|.
name|X_add_number
operator|==
literal|0
condition|)
block|{
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|s
argument_list|,
literal|"s,t,p"
argument_list|,
name|sreg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
name|load_register
argument_list|(
name|AT
argument_list|,
operator|&
name|imm_expr
argument_list|,
name|HAVE_64BIT_GPRS
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|s
argument_list|,
literal|"s,t,p"
argument_list|,
name|sreg
argument_list|,
name|AT
argument_list|)
expr_stmt|;
break|break;
case|case
name|M_BGEL
case|:
name|likely
operator|=
literal|1
expr_stmt|;
case|case
name|M_BGE
case|:
if|if
condition|(
name|treg
operator|==
literal|0
condition|)
block|{
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|likely
condition|?
literal|"bgezl"
else|:
literal|"bgez"
argument_list|,
literal|"s,p"
argument_list|,
name|sreg
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|sreg
operator|==
literal|0
condition|)
block|{
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|likely
condition|?
literal|"blezl"
else|:
literal|"blez"
argument_list|,
literal|"s,p"
argument_list|,
name|treg
argument_list|)
expr_stmt|;
return|return;
block|}
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"slt"
argument_list|,
literal|"d,v,t"
argument_list|,
name|AT
argument_list|,
name|sreg
argument_list|,
name|treg
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|likely
condition|?
literal|"beql"
else|:
literal|"beq"
argument_list|,
literal|"s,t,p"
argument_list|,
name|AT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|M_BGTL_I
case|:
name|likely
operator|=
literal|1
expr_stmt|;
case|case
name|M_BGT_I
case|:
comment|/* check for> max integer */
name|maxnum
operator|=
literal|0x7fffffff
expr_stmt|;
if|if
condition|(
name|HAVE_64BIT_GPRS
operator|&&
sizeof|sizeof
argument_list|(
name|maxnum
argument_list|)
operator|>
literal|4
condition|)
block|{
name|maxnum
operator|<<=
literal|16
expr_stmt|;
name|maxnum
operator||=
literal|0xffff
expr_stmt|;
name|maxnum
operator|<<=
literal|16
expr_stmt|;
name|maxnum
operator||=
literal|0xffff
expr_stmt|;
block|}
if|if
condition|(
name|imm_expr
operator|.
name|X_op
operator|==
name|O_constant
operator|&&
name|imm_expr
operator|.
name|X_add_number
operator|>=
name|maxnum
operator|&&
operator|(
name|HAVE_32BIT_GPRS
operator|||
sizeof|sizeof
argument_list|(
name|maxnum
argument_list|)
operator|>
literal|4
operator|)
condition|)
block|{
name|do_false
label|:
comment|/* result is always false */
if|if
condition|(
operator|!
name|likely
condition|)
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"nop"
argument_list|,
literal|""
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
literal|"bnel"
argument_list|,
literal|"s,t,p"
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|imm_expr
operator|.
name|X_op
operator|!=
name|O_constant
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Unsupported large constant"
argument_list|)
argument_list|)
expr_stmt|;
operator|++
name|imm_expr
operator|.
name|X_add_number
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
name|M_BGE_I
case|:
case|case
name|M_BGEL_I
case|:
if|if
condition|(
name|mask
operator|==
name|M_BGEL_I
condition|)
name|likely
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|imm_expr
operator|.
name|X_op
operator|==
name|O_constant
operator|&&
name|imm_expr
operator|.
name|X_add_number
operator|==
literal|0
condition|)
block|{
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|likely
condition|?
literal|"bgezl"
else|:
literal|"bgez"
argument_list|,
literal|"s,p"
argument_list|,
name|sreg
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|imm_expr
operator|.
name|X_op
operator|==
name|O_constant
operator|&&
name|imm_expr
operator|.
name|X_add_number
operator|==
literal|1
condition|)
block|{
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|likely
condition|?
literal|"bgtzl"
else|:
literal|"bgtz"
argument_list|,
literal|"s,p"
argument_list|,
name|sreg
argument_list|)
expr_stmt|;
return|return;
block|}
name|maxnum
operator|=
literal|0x7fffffff
expr_stmt|;
if|if
condition|(
name|HAVE_64BIT_GPRS
operator|&&
sizeof|sizeof
argument_list|(
name|maxnum
argument_list|)
operator|>
literal|4
condition|)
block|{
name|maxnum
operator|<<=
literal|16
expr_stmt|;
name|maxnum
operator||=
literal|0xffff
expr_stmt|;
name|maxnum
operator|<<=
literal|16
expr_stmt|;
name|maxnum
operator||=
literal|0xffff
expr_stmt|;
block|}
name|maxnum
operator|=
operator|-
name|maxnum
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|imm_expr
operator|.
name|X_op
operator|==
name|O_constant
operator|&&
name|imm_expr
operator|.
name|X_add_number
operator|<=
name|maxnum
operator|&&
operator|(
name|HAVE_32BIT_GPRS
operator|||
sizeof|sizeof
argument_list|(
name|maxnum
argument_list|)
operator|>
literal|4
operator|)
condition|)
block|{
name|do_true
label|:
comment|/* result is always true */
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"Branch %s is always true"
argument_list|)
argument_list|,
name|ip
operator|->
name|insn_mo
operator|->
name|name
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
literal|"b"
argument_list|,
literal|"p"
argument_list|)
expr_stmt|;
return|return;
block|}
name|set_at
argument_list|(
name|sreg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|likely
condition|?
literal|"beql"
else|:
literal|"beq"
argument_list|,
literal|"s,t,p"
argument_list|,
name|AT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|M_BGEUL
case|:
name|likely
operator|=
literal|1
expr_stmt|;
case|case
name|M_BGEU
case|:
if|if
condition|(
name|treg
operator|==
literal|0
condition|)
goto|goto
name|do_true
goto|;
if|if
condition|(
name|sreg
operator|==
literal|0
condition|)
block|{
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|likely
condition|?
literal|"beql"
else|:
literal|"beq"
argument_list|,
literal|"s,t,p"
argument_list|,
literal|0
argument_list|,
name|treg
argument_list|)
expr_stmt|;
return|return;
block|}
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"sltu"
argument_list|,
literal|"d,v,t"
argument_list|,
name|AT
argument_list|,
name|sreg
argument_list|,
name|treg
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|likely
condition|?
literal|"beql"
else|:
literal|"beq"
argument_list|,
literal|"s,t,p"
argument_list|,
name|AT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|M_BGTUL_I
case|:
name|likely
operator|=
literal|1
expr_stmt|;
case|case
name|M_BGTU_I
case|:
if|if
condition|(
name|sreg
operator|==
literal|0
operator|||
operator|(
name|HAVE_32BIT_GPRS
operator|&&
name|imm_expr
operator|.
name|X_op
operator|==
name|O_constant
operator|&&
name|imm_expr
operator|.
name|X_add_number
operator|==
operator|(
name|offsetT
operator|)
literal|0xffffffff
operator|)
condition|)
goto|goto
name|do_false
goto|;
if|if
condition|(
name|imm_expr
operator|.
name|X_op
operator|!=
name|O_constant
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Unsupported large constant"
argument_list|)
argument_list|)
expr_stmt|;
operator|++
name|imm_expr
operator|.
name|X_add_number
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
name|M_BGEU_I
case|:
case|case
name|M_BGEUL_I
case|:
if|if
condition|(
name|mask
operator|==
name|M_BGEUL_I
condition|)
name|likely
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|imm_expr
operator|.
name|X_op
operator|==
name|O_constant
operator|&&
name|imm_expr
operator|.
name|X_add_number
operator|==
literal|0
condition|)
goto|goto
name|do_true
goto|;
if|if
condition|(
name|imm_expr
operator|.
name|X_op
operator|==
name|O_constant
operator|&&
name|imm_expr
operator|.
name|X_add_number
operator|==
literal|1
condition|)
block|{
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|likely
condition|?
literal|"bnel"
else|:
literal|"bne"
argument_list|,
literal|"s,t,p"
argument_list|,
name|sreg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
name|set_at
argument_list|(
name|sreg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|likely
condition|?
literal|"beql"
else|:
literal|"beq"
argument_list|,
literal|"s,t,p"
argument_list|,
name|AT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|M_BGTL
case|:
name|likely
operator|=
literal|1
expr_stmt|;
case|case
name|M_BGT
case|:
if|if
condition|(
name|treg
operator|==
literal|0
condition|)
block|{
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|likely
condition|?
literal|"bgtzl"
else|:
literal|"bgtz"
argument_list|,
literal|"s,p"
argument_list|,
name|sreg
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|sreg
operator|==
literal|0
condition|)
block|{
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|likely
condition|?
literal|"bltzl"
else|:
literal|"bltz"
argument_list|,
literal|"s,p"
argument_list|,
name|treg
argument_list|)
expr_stmt|;
return|return;
block|}
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"slt"
argument_list|,
literal|"d,v,t"
argument_list|,
name|AT
argument_list|,
name|treg
argument_list|,
name|sreg
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|likely
condition|?
literal|"bnel"
else|:
literal|"bne"
argument_list|,
literal|"s,t,p"
argument_list|,
name|AT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|M_BGTUL
case|:
name|likely
operator|=
literal|1
expr_stmt|;
case|case
name|M_BGTU
case|:
if|if
condition|(
name|treg
operator|==
literal|0
condition|)
block|{
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|likely
condition|?
literal|"bnel"
else|:
literal|"bne"
argument_list|,
literal|"s,t,p"
argument_list|,
name|sreg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|sreg
operator|==
literal|0
condition|)
goto|goto
name|do_false
goto|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"sltu"
argument_list|,
literal|"d,v,t"
argument_list|,
name|AT
argument_list|,
name|treg
argument_list|,
name|sreg
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|likely
condition|?
literal|"bnel"
else|:
literal|"bne"
argument_list|,
literal|"s,t,p"
argument_list|,
name|AT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|M_BLEL
case|:
name|likely
operator|=
literal|1
expr_stmt|;
case|case
name|M_BLE
case|:
if|if
condition|(
name|treg
operator|==
literal|0
condition|)
block|{
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|likely
condition|?
literal|"blezl"
else|:
literal|"blez"
argument_list|,
literal|"s,p"
argument_list|,
name|sreg
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|sreg
operator|==
literal|0
condition|)
block|{
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|likely
condition|?
literal|"bgezl"
else|:
literal|"bgez"
argument_list|,
literal|"s,p"
argument_list|,
name|treg
argument_list|)
expr_stmt|;
return|return;
block|}
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"slt"
argument_list|,
literal|"d,v,t"
argument_list|,
name|AT
argument_list|,
name|treg
argument_list|,
name|sreg
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|likely
condition|?
literal|"beql"
else|:
literal|"beq"
argument_list|,
literal|"s,t,p"
argument_list|,
name|AT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|M_BLEL_I
case|:
name|likely
operator|=
literal|1
expr_stmt|;
case|case
name|M_BLE_I
case|:
name|maxnum
operator|=
literal|0x7fffffff
expr_stmt|;
if|if
condition|(
name|HAVE_64BIT_GPRS
operator|&&
sizeof|sizeof
argument_list|(
name|maxnum
argument_list|)
operator|>
literal|4
condition|)
block|{
name|maxnum
operator|<<=
literal|16
expr_stmt|;
name|maxnum
operator||=
literal|0xffff
expr_stmt|;
name|maxnum
operator|<<=
literal|16
expr_stmt|;
name|maxnum
operator||=
literal|0xffff
expr_stmt|;
block|}
if|if
condition|(
name|imm_expr
operator|.
name|X_op
operator|==
name|O_constant
operator|&&
name|imm_expr
operator|.
name|X_add_number
operator|>=
name|maxnum
operator|&&
operator|(
name|HAVE_32BIT_GPRS
operator|||
sizeof|sizeof
argument_list|(
name|maxnum
argument_list|)
operator|>
literal|4
operator|)
condition|)
goto|goto
name|do_true
goto|;
if|if
condition|(
name|imm_expr
operator|.
name|X_op
operator|!=
name|O_constant
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Unsupported large constant"
argument_list|)
argument_list|)
expr_stmt|;
operator|++
name|imm_expr
operator|.
name|X_add_number
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
name|M_BLT_I
case|:
case|case
name|M_BLTL_I
case|:
if|if
condition|(
name|mask
operator|==
name|M_BLTL_I
condition|)
name|likely
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|imm_expr
operator|.
name|X_op
operator|==
name|O_constant
operator|&&
name|imm_expr
operator|.
name|X_add_number
operator|==
literal|0
condition|)
block|{
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|likely
condition|?
literal|"bltzl"
else|:
literal|"bltz"
argument_list|,
literal|"s,p"
argument_list|,
name|sreg
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|imm_expr
operator|.
name|X_op
operator|==
name|O_constant
operator|&&
name|imm_expr
operator|.
name|X_add_number
operator|==
literal|1
condition|)
block|{
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|likely
condition|?
literal|"blezl"
else|:
literal|"blez"
argument_list|,
literal|"s,p"
argument_list|,
name|sreg
argument_list|)
expr_stmt|;
return|return;
block|}
name|set_at
argument_list|(
name|sreg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|likely
condition|?
literal|"bnel"
else|:
literal|"bne"
argument_list|,
literal|"s,t,p"
argument_list|,
name|AT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|M_BLEUL
case|:
name|likely
operator|=
literal|1
expr_stmt|;
case|case
name|M_BLEU
case|:
if|if
condition|(
name|treg
operator|==
literal|0
condition|)
block|{
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|likely
condition|?
literal|"beql"
else|:
literal|"beq"
argument_list|,
literal|"s,t,p"
argument_list|,
name|sreg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|sreg
operator|==
literal|0
condition|)
goto|goto
name|do_true
goto|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"sltu"
argument_list|,
literal|"d,v,t"
argument_list|,
name|AT
argument_list|,
name|treg
argument_list|,
name|sreg
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|likely
condition|?
literal|"beql"
else|:
literal|"beq"
argument_list|,
literal|"s,t,p"
argument_list|,
name|AT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|M_BLEUL_I
case|:
name|likely
operator|=
literal|1
expr_stmt|;
case|case
name|M_BLEU_I
case|:
if|if
condition|(
name|sreg
operator|==
literal|0
operator|||
operator|(
name|HAVE_32BIT_GPRS
operator|&&
name|imm_expr
operator|.
name|X_op
operator|==
name|O_constant
operator|&&
name|imm_expr
operator|.
name|X_add_number
operator|==
operator|(
name|offsetT
operator|)
literal|0xffffffff
operator|)
condition|)
goto|goto
name|do_true
goto|;
if|if
condition|(
name|imm_expr
operator|.
name|X_op
operator|!=
name|O_constant
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Unsupported large constant"
argument_list|)
argument_list|)
expr_stmt|;
operator|++
name|imm_expr
operator|.
name|X_add_number
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
name|M_BLTU_I
case|:
case|case
name|M_BLTUL_I
case|:
if|if
condition|(
name|mask
operator|==
name|M_BLTUL_I
condition|)
name|likely
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|imm_expr
operator|.
name|X_op
operator|==
name|O_constant
operator|&&
name|imm_expr
operator|.
name|X_add_number
operator|==
literal|0
condition|)
goto|goto
name|do_false
goto|;
if|if
condition|(
name|imm_expr
operator|.
name|X_op
operator|==
name|O_constant
operator|&&
name|imm_expr
operator|.
name|X_add_number
operator|==
literal|1
condition|)
block|{
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|likely
condition|?
literal|"beql"
else|:
literal|"beq"
argument_list|,
literal|"s,t,p"
argument_list|,
name|sreg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
name|set_at
argument_list|(
name|sreg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|likely
condition|?
literal|"bnel"
else|:
literal|"bne"
argument_list|,
literal|"s,t,p"
argument_list|,
name|AT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|M_BLTL
case|:
name|likely
operator|=
literal|1
expr_stmt|;
case|case
name|M_BLT
case|:
if|if
condition|(
name|treg
operator|==
literal|0
condition|)
block|{
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|likely
condition|?
literal|"bltzl"
else|:
literal|"bltz"
argument_list|,
literal|"s,p"
argument_list|,
name|sreg
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|sreg
operator|==
literal|0
condition|)
block|{
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|likely
condition|?
literal|"bgtzl"
else|:
literal|"bgtz"
argument_list|,
literal|"s,p"
argument_list|,
name|treg
argument_list|)
expr_stmt|;
return|return;
block|}
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"slt"
argument_list|,
literal|"d,v,t"
argument_list|,
name|AT
argument_list|,
name|sreg
argument_list|,
name|treg
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|likely
condition|?
literal|"bnel"
else|:
literal|"bne"
argument_list|,
literal|"s,t,p"
argument_list|,
name|AT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|M_BLTUL
case|:
name|likely
operator|=
literal|1
expr_stmt|;
case|case
name|M_BLTU
case|:
if|if
condition|(
name|treg
operator|==
literal|0
condition|)
goto|goto
name|do_false
goto|;
if|if
condition|(
name|sreg
operator|==
literal|0
condition|)
block|{
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|likely
condition|?
literal|"bnel"
else|:
literal|"bne"
argument_list|,
literal|"s,t,p"
argument_list|,
literal|0
argument_list|,
name|treg
argument_list|)
expr_stmt|;
return|return;
block|}
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"sltu"
argument_list|,
literal|"d,v,t"
argument_list|,
name|AT
argument_list|,
name|sreg
argument_list|,
name|treg
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|likely
condition|?
literal|"bnel"
else|:
literal|"bne"
argument_list|,
literal|"s,t,p"
argument_list|,
name|AT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|M_DEXT
case|:
block|{
name|unsigned
name|long
name|pos
decl_stmt|;
name|unsigned
name|long
name|size
decl_stmt|;
if|if
condition|(
name|imm_expr
operator|.
name|X_op
operator|!=
name|O_constant
operator|||
name|imm2_expr
operator|.
name|X_op
operator|!=
name|O_constant
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Unsupported large constant"
argument_list|)
argument_list|)
expr_stmt|;
name|pos
operator|=
name|size
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|pos
operator|=
operator|(
name|unsigned
name|long
operator|)
name|imm_expr
operator|.
name|X_add_number
expr_stmt|;
name|size
operator|=
operator|(
name|unsigned
name|long
operator|)
name|imm2_expr
operator|.
name|X_add_number
expr_stmt|;
block|}
if|if
condition|(
name|pos
operator|>
literal|63
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Improper position (%lu)"
argument_list|)
argument_list|,
name|pos
argument_list|)
expr_stmt|;
name|pos
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|size
operator|==
literal|0
operator|||
name|size
operator|>
literal|64
operator|||
operator|(
name|pos
operator|+
name|size
operator|-
literal|1
operator|)
operator|>
literal|63
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Improper extract size (%lu, position %lu)"
argument_list|)
argument_list|,
name|size
argument_list|,
name|pos
argument_list|)
expr_stmt|;
name|size
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|size
operator|<=
literal|32
operator|&&
name|pos
operator|<
literal|32
condition|)
block|{
name|s
operator|=
literal|"dext"
expr_stmt|;
name|fmt
operator|=
literal|"t,r,+A,+C"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|size
operator|<=
literal|32
condition|)
block|{
name|s
operator|=
literal|"dextu"
expr_stmt|;
name|fmt
operator|=
literal|"t,r,+E,+H"
expr_stmt|;
block|}
else|else
block|{
name|s
operator|=
literal|"dextm"
expr_stmt|;
name|fmt
operator|=
literal|"t,r,+A,+G"
expr_stmt|;
block|}
name|macro_build
argument_list|(
operator|(
name|expressionS
operator|*
operator|)
name|NULL
argument_list|,
name|s
argument_list|,
name|fmt
argument_list|,
name|treg
argument_list|,
name|sreg
argument_list|,
name|pos
argument_list|,
name|size
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
return|return;
case|case
name|M_DINS
case|:
block|{
name|unsigned
name|long
name|pos
decl_stmt|;
name|unsigned
name|long
name|size
decl_stmt|;
if|if
condition|(
name|imm_expr
operator|.
name|X_op
operator|!=
name|O_constant
operator|||
name|imm2_expr
operator|.
name|X_op
operator|!=
name|O_constant
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Unsupported large constant"
argument_list|)
argument_list|)
expr_stmt|;
name|pos
operator|=
name|size
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|pos
operator|=
operator|(
name|unsigned
name|long
operator|)
name|imm_expr
operator|.
name|X_add_number
expr_stmt|;
name|size
operator|=
operator|(
name|unsigned
name|long
operator|)
name|imm2_expr
operator|.
name|X_add_number
expr_stmt|;
block|}
if|if
condition|(
name|pos
operator|>
literal|63
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Improper position (%lu)"
argument_list|)
argument_list|,
name|pos
argument_list|)
expr_stmt|;
name|pos
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|size
operator|==
literal|0
operator|||
name|size
operator|>
literal|64
operator|||
operator|(
name|pos
operator|+
name|size
operator|-
literal|1
operator|)
operator|>
literal|63
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Improper insert size (%lu, position %lu)"
argument_list|)
argument_list|,
name|size
argument_list|,
name|pos
argument_list|)
expr_stmt|;
name|size
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|pos
operator|<
literal|32
operator|&&
operator|(
name|pos
operator|+
name|size
operator|-
literal|1
operator|)
operator|<
literal|32
condition|)
block|{
name|s
operator|=
literal|"dins"
expr_stmt|;
name|fmt
operator|=
literal|"t,r,+A,+B"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pos
operator|>=
literal|32
condition|)
block|{
name|s
operator|=
literal|"dinsu"
expr_stmt|;
name|fmt
operator|=
literal|"t,r,+E,+F"
expr_stmt|;
block|}
else|else
block|{
name|s
operator|=
literal|"dinsm"
expr_stmt|;
name|fmt
operator|=
literal|"t,r,+A,+F"
expr_stmt|;
block|}
name|macro_build
argument_list|(
operator|(
name|expressionS
operator|*
operator|)
name|NULL
argument_list|,
name|s
argument_list|,
name|fmt
argument_list|,
name|treg
argument_list|,
name|sreg
argument_list|,
name|pos
argument_list|,
name|pos
operator|+
name|size
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
return|return;
case|case
name|M_DDIV_3
case|:
name|dbl
operator|=
literal|1
expr_stmt|;
case|case
name|M_DIV_3
case|:
name|s
operator|=
literal|"mflo"
expr_stmt|;
goto|goto
name|do_div3
goto|;
case|case
name|M_DREM_3
case|:
name|dbl
operator|=
literal|1
expr_stmt|;
case|case
name|M_REM_3
case|:
name|s
operator|=
literal|"mfhi"
expr_stmt|;
name|do_div3
label|:
if|if
condition|(
name|treg
operator|==
literal|0
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"Divide by zero."
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mips_trap
condition|)
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"teq"
argument_list|,
literal|"s,t,q"
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|7
argument_list|)
expr_stmt|;
else|else
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"break"
argument_list|,
literal|"c"
argument_list|,
literal|7
argument_list|)
expr_stmt|;
return|return;
block|}
name|mips_emit_delays
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
operator|++
name|mips_opts
operator|.
name|noreorder
expr_stmt|;
name|mips_any_noreorder
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|mips_trap
condition|)
block|{
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"teq"
argument_list|,
literal|"s,t,q"
argument_list|,
name|treg
argument_list|,
literal|0
argument_list|,
literal|7
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
name|dbl
condition|?
literal|"ddiv"
else|:
literal|"div"
argument_list|,
literal|"z,s,t"
argument_list|,
name|sreg
argument_list|,
name|treg
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|expr1
operator|.
name|X_add_number
operator|=
literal|8
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|expr1
argument_list|,
literal|"bne"
argument_list|,
literal|"s,t,p"
argument_list|,
name|treg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
name|dbl
condition|?
literal|"ddiv"
else|:
literal|"div"
argument_list|,
literal|"z,s,t"
argument_list|,
name|sreg
argument_list|,
name|treg
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"break"
argument_list|,
literal|"c"
argument_list|,
literal|7
argument_list|)
expr_stmt|;
block|}
name|expr1
operator|.
name|X_add_number
operator|=
operator|-
literal|1
expr_stmt|;
name|load_register
argument_list|(
name|AT
argument_list|,
operator|&
name|expr1
argument_list|,
name|dbl
argument_list|)
expr_stmt|;
name|expr1
operator|.
name|X_add_number
operator|=
name|mips_trap
condition|?
operator|(
name|dbl
condition|?
literal|12
else|:
literal|8
operator|)
else|:
operator|(
name|dbl
condition|?
literal|20
else|:
literal|16
operator|)
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|expr1
argument_list|,
literal|"bne"
argument_list|,
literal|"s,t,p"
argument_list|,
name|treg
argument_list|,
name|AT
argument_list|)
expr_stmt|;
if|if
condition|(
name|dbl
condition|)
block|{
name|expr1
operator|.
name|X_add_number
operator|=
literal|1
expr_stmt|;
name|load_register
argument_list|(
name|AT
argument_list|,
operator|&
name|expr1
argument_list|,
name|dbl
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"dsll32"
argument_list|,
literal|"d,w,<"
argument_list|,
name|AT
argument_list|,
name|AT
argument_list|,
literal|31
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|expr1
operator|.
name|X_add_number
operator|=
literal|0x80000000
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|expr1
argument_list|,
literal|"lui"
argument_list|,
literal|"t,u"
argument_list|,
name|AT
argument_list|,
name|BFD_RELOC_HI16
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mips_trap
condition|)
block|{
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"teq"
argument_list|,
literal|"s,t,q"
argument_list|,
name|sreg
argument_list|,
name|AT
argument_list|,
literal|6
argument_list|)
expr_stmt|;
comment|/* We want to close the noreorder block as soon as possible, so 	     that later insns are available for delay slot filling.  */
operator|--
name|mips_opts
operator|.
name|noreorder
expr_stmt|;
block|}
else|else
block|{
name|expr1
operator|.
name|X_add_number
operator|=
literal|8
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|expr1
argument_list|,
literal|"bne"
argument_list|,
literal|"s,t,p"
argument_list|,
name|sreg
argument_list|,
name|AT
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"nop"
argument_list|,
literal|""
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* We want to close the noreorder block as soon as possible, so 	     that later insns are available for delay slot filling.  */
operator|--
name|mips_opts
operator|.
name|noreorder
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"break"
argument_list|,
literal|"c"
argument_list|,
literal|6
argument_list|)
expr_stmt|;
block|}
name|macro_build
argument_list|(
name|NULL
argument_list|,
name|s
argument_list|,
literal|"d"
argument_list|,
name|dreg
argument_list|)
expr_stmt|;
break|break;
case|case
name|M_DIV_3I
case|:
name|s
operator|=
literal|"div"
expr_stmt|;
name|s2
operator|=
literal|"mflo"
expr_stmt|;
goto|goto
name|do_divi
goto|;
case|case
name|M_DIVU_3I
case|:
name|s
operator|=
literal|"divu"
expr_stmt|;
name|s2
operator|=
literal|"mflo"
expr_stmt|;
goto|goto
name|do_divi
goto|;
case|case
name|M_REM_3I
case|:
name|s
operator|=
literal|"div"
expr_stmt|;
name|s2
operator|=
literal|"mfhi"
expr_stmt|;
goto|goto
name|do_divi
goto|;
case|case
name|M_REMU_3I
case|:
name|s
operator|=
literal|"divu"
expr_stmt|;
name|s2
operator|=
literal|"mfhi"
expr_stmt|;
goto|goto
name|do_divi
goto|;
case|case
name|M_DDIV_3I
case|:
name|dbl
operator|=
literal|1
expr_stmt|;
name|s
operator|=
literal|"ddiv"
expr_stmt|;
name|s2
operator|=
literal|"mflo"
expr_stmt|;
goto|goto
name|do_divi
goto|;
case|case
name|M_DDIVU_3I
case|:
name|dbl
operator|=
literal|1
expr_stmt|;
name|s
operator|=
literal|"ddivu"
expr_stmt|;
name|s2
operator|=
literal|"mflo"
expr_stmt|;
goto|goto
name|do_divi
goto|;
case|case
name|M_DREM_3I
case|:
name|dbl
operator|=
literal|1
expr_stmt|;
name|s
operator|=
literal|"ddiv"
expr_stmt|;
name|s2
operator|=
literal|"mfhi"
expr_stmt|;
goto|goto
name|do_divi
goto|;
case|case
name|M_DREMU_3I
case|:
name|dbl
operator|=
literal|1
expr_stmt|;
name|s
operator|=
literal|"ddivu"
expr_stmt|;
name|s2
operator|=
literal|"mfhi"
expr_stmt|;
name|do_divi
label|:
if|if
condition|(
name|imm_expr
operator|.
name|X_op
operator|==
name|O_constant
operator|&&
name|imm_expr
operator|.
name|X_add_number
operator|==
literal|0
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"Divide by zero."
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mips_trap
condition|)
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"teq"
argument_list|,
literal|"s,t,q"
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|7
argument_list|)
expr_stmt|;
else|else
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"break"
argument_list|,
literal|"c"
argument_list|,
literal|7
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|imm_expr
operator|.
name|X_op
operator|==
name|O_constant
operator|&&
name|imm_expr
operator|.
name|X_add_number
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|s2
argument_list|,
literal|"mflo"
argument_list|)
operator|==
literal|0
condition|)
name|move_register
argument_list|(
name|dreg
argument_list|,
name|sreg
argument_list|)
expr_stmt|;
else|else
name|move_register
argument_list|(
name|dreg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|imm_expr
operator|.
name|X_op
operator|==
name|O_constant
operator|&&
name|imm_expr
operator|.
name|X_add_number
operator|==
operator|-
literal|1
operator|&&
name|s
index|[
name|strlen
argument_list|(
name|s
argument_list|)
operator|-
literal|1
index|]
operator|!=
literal|'u'
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|s2
argument_list|,
literal|"mflo"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|macro_build
argument_list|(
name|NULL
argument_list|,
name|dbl
condition|?
literal|"dneg"
else|:
literal|"neg"
argument_list|,
literal|"d,w"
argument_list|,
name|dreg
argument_list|,
name|sreg
argument_list|)
expr_stmt|;
block|}
else|else
name|move_register
argument_list|(
name|dreg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
name|load_register
argument_list|(
name|AT
argument_list|,
operator|&
name|imm_expr
argument_list|,
name|dbl
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
name|s
argument_list|,
literal|"z,s,t"
argument_list|,
name|sreg
argument_list|,
name|AT
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
name|s2
argument_list|,
literal|"d"
argument_list|,
name|dreg
argument_list|)
expr_stmt|;
break|break;
case|case
name|M_DIVU_3
case|:
name|s
operator|=
literal|"divu"
expr_stmt|;
name|s2
operator|=
literal|"mflo"
expr_stmt|;
goto|goto
name|do_divu3
goto|;
case|case
name|M_REMU_3
case|:
name|s
operator|=
literal|"divu"
expr_stmt|;
name|s2
operator|=
literal|"mfhi"
expr_stmt|;
goto|goto
name|do_divu3
goto|;
case|case
name|M_DDIVU_3
case|:
name|s
operator|=
literal|"ddivu"
expr_stmt|;
name|s2
operator|=
literal|"mflo"
expr_stmt|;
goto|goto
name|do_divu3
goto|;
case|case
name|M_DREMU_3
case|:
name|s
operator|=
literal|"ddivu"
expr_stmt|;
name|s2
operator|=
literal|"mfhi"
expr_stmt|;
name|do_divu3
label|:
name|mips_emit_delays
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
operator|++
name|mips_opts
operator|.
name|noreorder
expr_stmt|;
name|mips_any_noreorder
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|mips_trap
condition|)
block|{
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"teq"
argument_list|,
literal|"s,t,q"
argument_list|,
name|treg
argument_list|,
literal|0
argument_list|,
literal|7
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
name|s
argument_list|,
literal|"z,s,t"
argument_list|,
name|sreg
argument_list|,
name|treg
argument_list|)
expr_stmt|;
comment|/* We want to close the noreorder block as soon as possible, so 	     that later insns are available for delay slot filling.  */
operator|--
name|mips_opts
operator|.
name|noreorder
expr_stmt|;
block|}
else|else
block|{
name|expr1
operator|.
name|X_add_number
operator|=
literal|8
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|expr1
argument_list|,
literal|"bne"
argument_list|,
literal|"s,t,p"
argument_list|,
name|treg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
name|s
argument_list|,
literal|"z,s,t"
argument_list|,
name|sreg
argument_list|,
name|treg
argument_list|)
expr_stmt|;
comment|/* We want to close the noreorder block as soon as possible, so 	     that later insns are available for delay slot filling.  */
operator|--
name|mips_opts
operator|.
name|noreorder
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"break"
argument_list|,
literal|"c"
argument_list|,
literal|7
argument_list|)
expr_stmt|;
block|}
name|macro_build
argument_list|(
name|NULL
argument_list|,
name|s2
argument_list|,
literal|"d"
argument_list|,
name|dreg
argument_list|)
expr_stmt|;
return|return;
case|case
name|M_DLCA_AB
case|:
name|dbl
operator|=
literal|1
expr_stmt|;
case|case
name|M_LCA_AB
case|:
name|call
operator|=
literal|1
expr_stmt|;
goto|goto
name|do_la
goto|;
case|case
name|M_DLA_AB
case|:
name|dbl
operator|=
literal|1
expr_stmt|;
case|case
name|M_LA_AB
case|:
name|do_la
label|:
comment|/* Load the address of a symbol into a register.  If breg is not 	 zero, we then add a base register to it.  */
if|if
condition|(
name|dbl
operator|&&
name|HAVE_32BIT_GPRS
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"dla used to load 32-bit register"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dbl
operator|&&
name|HAVE_64BIT_OBJECTS
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"la used to load 64-bit address"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset_expr
operator|.
name|X_op
operator|==
name|O_constant
operator|&&
name|offset_expr
operator|.
name|X_add_number
operator|>=
operator|-
literal|0x8000
operator|&&
name|offset_expr
operator|.
name|X_add_number
operator|<
literal|0x8000
condition|)
block|{
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
operator|(
name|dbl
operator|||
name|HAVE_64BIT_ADDRESSES
operator|)
condition|?
literal|"daddiu"
else|:
literal|"addiu"
argument_list|,
literal|"t,r,j"
argument_list|,
name|treg
argument_list|,
name|sreg
argument_list|,
name|BFD_RELOC_LO16
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|treg
operator|==
name|breg
condition|)
block|{
name|tempreg
operator|=
name|AT
expr_stmt|;
name|used_at
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|tempreg
operator|=
name|treg
expr_stmt|;
name|used_at
operator|=
literal|0
expr_stmt|;
block|}
comment|/* When generating embedded PIC code, we permit expressions of 	 the form 	   la	$treg,foo-bar 	   la	$treg,foo-bar($breg) 	 where bar is an address in the current section.  These are used 	 when getting the addresses of functions.  We don't permit 	 X_add_number to be non-zero, because if the symbol is 	 external the relaxing code needs to know that any addend is 	 purely the offset to X_op_symbol.  */
if|if
condition|(
name|mips_pic
operator|==
name|EMBEDDED_PIC
operator|&&
name|offset_expr
operator|.
name|X_op
operator|==
name|O_subtract
operator|&&
operator|(
name|symbol_constant_p
argument_list|(
name|offset_expr
operator|.
name|X_op_symbol
argument_list|)
condition|?
name|S_GET_SEGMENT
argument_list|(
name|offset_expr
operator|.
name|X_op_symbol
argument_list|)
operator|==
name|now_seg
else|:
operator|(
name|symbol_equated_p
argument_list|(
name|offset_expr
operator|.
name|X_op_symbol
argument_list|)
operator|&&
operator|(
name|S_GET_SEGMENT
argument_list|(
name|symbol_get_value_expression
argument_list|(
name|offset_expr
operator|.
name|X_op_symbol
argument_list|)
operator|->
name|X_add_symbol
argument_list|)
operator|==
name|now_seg
operator|)
operator|)
operator|)
operator|&&
operator|(
name|offset_expr
operator|.
name|X_add_number
operator|==
literal|0
operator|||
name|OUTPUT_FLAVOR
operator|==
name|bfd_target_elf_flavour
operator|)
condition|)
block|{
if|if
condition|(
name|breg
operator|==
literal|0
condition|)
block|{
name|tempreg
operator|=
name|treg
expr_stmt|;
name|used_at
operator|=
literal|0
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
literal|"lui"
argument_list|,
literal|"t,u"
argument_list|,
name|tempreg
argument_list|,
name|BFD_RELOC_PCREL_HI16_S
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
literal|"lui"
argument_list|,
literal|"t,u"
argument_list|,
name|tempreg
argument_list|,
name|BFD_RELOC_PCREL_HI16_S
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
operator|(
name|dbl
operator|||
name|HAVE_64BIT_ADDRESSES
operator|)
condition|?
literal|"daddu"
else|:
literal|"addu"
argument_list|,
literal|"d,v,t"
argument_list|,
name|tempreg
argument_list|,
name|tempreg
argument_list|,
name|breg
argument_list|)
expr_stmt|;
block|}
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
operator|(
name|dbl
operator|||
name|HAVE_64BIT_ADDRESSES
operator|)
condition|?
literal|"daddiu"
else|:
literal|"addiu"
argument_list|,
literal|"t,r,j"
argument_list|,
name|treg
argument_list|,
name|tempreg
argument_list|,
name|BFD_RELOC_PCREL_LO16
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|used_at
condition|)
return|return;
break|break;
block|}
if|if
condition|(
name|offset_expr
operator|.
name|X_op
operator|!=
name|O_symbol
operator|&&
name|offset_expr
operator|.
name|X_op
operator|!=
name|O_constant
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"expression too complex"
argument_list|)
argument_list|)
expr_stmt|;
name|offset_expr
operator|.
name|X_op
operator|=
name|O_constant
expr_stmt|;
block|}
if|if
condition|(
name|offset_expr
operator|.
name|X_op
operator|==
name|O_constant
condition|)
name|load_register
argument_list|(
name|tempreg
argument_list|,
operator|&
name|offset_expr
argument_list|,
operator|(
operator|(
name|mips_pic
operator|==
name|EMBEDDED_PIC
operator|||
name|mips_pic
operator|==
name|NO_PIC
operator|)
condition|?
operator|(
name|dbl
operator|||
name|HAVE_64BIT_ADDRESSES
operator|)
else|:
name|HAVE_64BIT_ADDRESSES
operator|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|mips_pic
operator|==
name|NO_PIC
condition|)
block|{
comment|/* If this is a reference to a GP relative symbol, we want 	       addiu	$tempreg,$gp,<sym>	(BFD_RELOC_GPREL16) 	     Otherwise we want 	       lui	$tempreg,<sym>		(BFD_RELOC_HI16_S) 	       addiu	$tempreg,$tempreg,<sym>	(BFD_RELOC_LO16) 	     If we have a constant, we need two instructions anyhow, 	     so we may as well always use the latter form.  	    With 64bit address space and a usable $at we want 	      lui	$tempreg,<sym>		(BFD_RELOC_MIPS_HIGHEST) 	      lui	$at,<sym>		(BFD_RELOC_HI16_S) 	      daddiu	$tempreg,<sym>		(BFD_RELOC_MIPS_HIGHER) 	      daddiu	$at,<sym>		(BFD_RELOC_LO16) 	      dsll32	$tempreg,0 	      daddu	$tempreg,$tempreg,$at  	    If $at is already in use, we use a path which is suboptimal 	    on superscalar processors. 	      lui	$tempreg,<sym>		(BFD_RELOC_MIPS_HIGHEST) 	      daddiu	$tempreg,<sym>		(BFD_RELOC_MIPS_HIGHER) 	      dsll	$tempreg,16 	      daddiu	$tempreg,<sym>		(BFD_RELOC_HI16_S) 	      dsll	$tempreg,16 	      daddiu	$tempreg,<sym>		(BFD_RELOC_LO16) 	  */
if|if
condition|(
name|HAVE_64BIT_ADDRESSES
condition|)
block|{
comment|/* ??? We don't provide a GP-relative alternative for 		 these macros.  It used not to be possible with the 		 original relaxation code, but it could be done now.  */
if|if
condition|(
name|used_at
operator|==
literal|0
operator|&&
operator|!
name|mips_opts
operator|.
name|noat
condition|)
block|{
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
literal|"lui"
argument_list|,
literal|"t,u"
argument_list|,
name|tempreg
argument_list|,
name|BFD_RELOC_MIPS_HIGHEST
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
literal|"lui"
argument_list|,
literal|"t,u"
argument_list|,
name|AT
argument_list|,
name|BFD_RELOC_HI16_S
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
literal|"daddiu"
argument_list|,
literal|"t,r,j"
argument_list|,
name|tempreg
argument_list|,
name|tempreg
argument_list|,
name|BFD_RELOC_MIPS_HIGHER
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
literal|"daddiu"
argument_list|,
literal|"t,r,j"
argument_list|,
name|AT
argument_list|,
name|AT
argument_list|,
name|BFD_RELOC_LO16
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"dsll32"
argument_list|,
literal|"d,w,<"
argument_list|,
name|tempreg
argument_list|,
name|tempreg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"daddu"
argument_list|,
literal|"d,v,t"
argument_list|,
name|tempreg
argument_list|,
name|tempreg
argument_list|,
name|AT
argument_list|)
expr_stmt|;
name|used_at
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
literal|"lui"
argument_list|,
literal|"t,u"
argument_list|,
name|tempreg
argument_list|,
name|BFD_RELOC_MIPS_HIGHEST
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
literal|"daddiu"
argument_list|,
literal|"t,r,j"
argument_list|,
name|tempreg
argument_list|,
name|tempreg
argument_list|,
name|BFD_RELOC_MIPS_HIGHER
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"dsll"
argument_list|,
literal|"d,w,<"
argument_list|,
name|tempreg
argument_list|,
name|tempreg
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
literal|"daddiu"
argument_list|,
literal|"t,r,j"
argument_list|,
name|tempreg
argument_list|,
name|tempreg
argument_list|,
name|BFD_RELOC_HI16_S
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"dsll"
argument_list|,
literal|"d,w,<"
argument_list|,
name|tempreg
argument_list|,
name|tempreg
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
literal|"daddiu"
argument_list|,
literal|"t,r,j"
argument_list|,
name|tempreg
argument_list|,
name|tempreg
argument_list|,
name|BFD_RELOC_LO16
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|(
name|valueT
operator|)
name|offset_expr
operator|.
name|X_add_number
operator|<=
name|MAX_GPREL_OFFSET
operator|&&
operator|!
name|nopic_need_relax
argument_list|(
name|offset_expr
operator|.
name|X_add_symbol
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|relax_start
argument_list|(
name|offset_expr
operator|.
name|X_add_symbol
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|ADDRESS_ADDI_INSN
argument_list|,
literal|"t,r,j"
argument_list|,
name|tempreg
argument_list|,
name|mips_gp_register
argument_list|,
name|BFD_RELOC_GPREL16
argument_list|)
expr_stmt|;
name|relax_switch
argument_list|()
expr_stmt|;
block|}
name|macro_build_lui
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|tempreg
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|ADDRESS_ADDI_INSN
argument_list|,
literal|"t,r,j"
argument_list|,
name|tempreg
argument_list|,
name|tempreg
argument_list|,
name|BFD_RELOC_LO16
argument_list|)
expr_stmt|;
if|if
condition|(
name|mips_relax
operator|.
name|sequence
condition|)
name|relax_end
argument_list|()
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|mips_pic
operator|==
name|SVR4_PIC
operator|&&
operator|!
name|mips_big_got
operator|&&
operator|!
name|HAVE_NEWABI
condition|)
block|{
name|int
name|lw_reloc_type
init|=
operator|(
name|int
operator|)
name|BFD_RELOC_MIPS_GOT16
decl_stmt|;
comment|/* If this is a reference to an external symbol, and there 	     is no constant, we want 	       lw	$tempreg,<sym>($gp)	(BFD_RELOC_MIPS_GOT16) 	     or for lca or if tempreg is PIC_CALL_REG 	       lw	$tempreg,<sym>($gp)	(BFD_RELOC_MIPS_CALL16) 	     For a local symbol, we want 	       lw	$tempreg,<sym>($gp)	(BFD_RELOC_MIPS_GOT16) 	       nop 	       addiu	$tempreg,$tempreg,<sym>	(BFD_RELOC_LO16)  	     If we have a small constant, and this is a reference to 	     an external symbol, we want 	       lw	$tempreg,<sym>($gp)	(BFD_RELOC_MIPS_GOT16) 	       nop 	       addiu	$tempreg,$tempreg,<constant> 	     For a local symbol, we want the same instruction 	     sequence, but we output a BFD_RELOC_LO16 reloc on the 	     addiu instruction.  	     If we have a large constant, and this is a reference to 	     an external symbol, we want 	       lw	$tempreg,<sym>($gp)	(BFD_RELOC_MIPS_GOT16) 	       lui	$at,<hiconstant> 	       addiu	$at,$at,<loconstant> 	       addu	$tempreg,$tempreg,$at 	     For a local symbol, we want the same instruction 	     sequence, but we output a BFD_RELOC_LO16 reloc on the 	     addiu instruction. 	   */
if|if
condition|(
name|offset_expr
operator|.
name|X_add_number
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|breg
operator|==
literal|0
operator|&&
operator|(
name|call
operator|||
name|tempreg
operator|==
name|PIC_CALL_REG
operator|)
condition|)
name|lw_reloc_type
operator|=
operator|(
name|int
operator|)
name|BFD_RELOC_MIPS_CALL16
expr_stmt|;
name|relax_start
argument_list|(
name|offset_expr
operator|.
name|X_add_symbol
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|ADDRESS_LOAD_INSN
argument_list|,
literal|"t,o(b)"
argument_list|,
name|tempreg
argument_list|,
name|lw_reloc_type
argument_list|,
name|mips_gp_register
argument_list|)
expr_stmt|;
if|if
condition|(
name|breg
operator|!=
literal|0
condition|)
block|{
comment|/* We're going to put in an addu instruction using 		     tempreg, so we may as well insert the nop right 		     now.  */
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"nop"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
name|relax_switch
argument_list|()
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|ADDRESS_LOAD_INSN
argument_list|,
literal|"t,o(b)"
argument_list|,
name|tempreg
argument_list|,
name|BFD_RELOC_MIPS_GOT16
argument_list|,
name|mips_gp_register
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"nop"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|ADDRESS_ADDI_INSN
argument_list|,
literal|"t,r,j"
argument_list|,
name|tempreg
argument_list|,
name|tempreg
argument_list|,
name|BFD_RELOC_LO16
argument_list|)
expr_stmt|;
name|relax_end
argument_list|()
expr_stmt|;
comment|/* FIXME: If breg == 0, and the next instruction uses 		 $tempreg, then if this variant case is used an extra 		 nop will be generated.  */
block|}
elseif|else
if|if
condition|(
name|offset_expr
operator|.
name|X_add_number
operator|>=
operator|-
literal|0x8000
operator|&&
name|offset_expr
operator|.
name|X_add_number
operator|<
literal|0x8000
condition|)
block|{
name|load_got_offset
argument_list|(
name|tempreg
argument_list|,
operator|&
name|offset_expr
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"nop"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|add_got_offset
argument_list|(
name|tempreg
argument_list|,
operator|&
name|offset_expr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|expr1
operator|.
name|X_add_number
operator|=
name|offset_expr
operator|.
name|X_add_number
expr_stmt|;
name|offset_expr
operator|.
name|X_add_number
operator|=
operator|(
operator|(
name|offset_expr
operator|.
name|X_add_number
operator|+
literal|0x8000
operator|)
operator|&
literal|0xffff
operator|)
operator|-
literal|0x8000
expr_stmt|;
name|load_got_offset
argument_list|(
name|tempreg
argument_list|,
operator|&
name|offset_expr
argument_list|)
expr_stmt|;
name|offset_expr
operator|.
name|X_add_number
operator|=
name|expr1
operator|.
name|X_add_number
expr_stmt|;
comment|/* If we are going to add in a base register, and the 		 target register and the base register are the same, 		 then we are using AT as a temporary register.  Since 		 we want to load the constant into AT, we add our 		 current AT (from the global offset table) and the 		 register into the register now, and pretend we were 		 not using a base register.  */
if|if
condition|(
name|breg
operator|==
name|treg
condition|)
block|{
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"nop"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
name|ADDRESS_ADD_INSN
argument_list|,
literal|"d,v,t"
argument_list|,
name|treg
argument_list|,
name|AT
argument_list|,
name|breg
argument_list|)
expr_stmt|;
name|breg
operator|=
literal|0
expr_stmt|;
name|tempreg
operator|=
name|treg
expr_stmt|;
block|}
name|add_got_offset_hilo
argument_list|(
name|tempreg
argument_list|,
operator|&
name|offset_expr
argument_list|,
name|AT
argument_list|)
expr_stmt|;
name|used_at
operator|=
literal|1
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|mips_pic
operator|==
name|SVR4_PIC
operator|&&
operator|!
name|mips_big_got
operator|&&
name|HAVE_NEWABI
condition|)
block|{
name|int
name|add_breg_early
init|=
literal|0
decl_stmt|;
comment|/* If this is a reference to an external, and there is no 	     constant, or local symbol (*), with or without a 	     constant, we want 	       lw	$tempreg,<sym>($gp)	(BFD_RELOC_MIPS_GOT_DISP) 	     or for lca or if tempreg is PIC_CALL_REG 	       lw	$tempreg,<sym>($gp)	(BFD_RELOC_MIPS_CALL16)  	     If we have a small constant, and this is a reference to 	     an external symbol, we want 	       lw	$tempreg,<sym>($gp)	(BFD_RELOC_MIPS_GOT_DISP) 	       addiu	$tempreg,$tempreg,<constant>  	     If we have a large constant, and this is a reference to 	     an external symbol, we want 	       lw	$tempreg,<sym>($gp)	(BFD_RELOC_MIPS_GOT_DISP) 	       lui	$at,<hiconstant> 	       addiu	$at,$at,<loconstant> 	       addu	$tempreg,$tempreg,$at  	     (*) Other assemblers seem to prefer GOT_PAGE/GOT_OFST for 	     local symbols, even though it introduces an additional 	     instruction.  */
if|if
condition|(
name|offset_expr
operator|.
name|X_add_number
condition|)
block|{
name|expr1
operator|.
name|X_add_number
operator|=
name|offset_expr
operator|.
name|X_add_number
expr_stmt|;
name|offset_expr
operator|.
name|X_add_number
operator|=
literal|0
expr_stmt|;
name|relax_start
argument_list|(
name|offset_expr
operator|.
name|X_add_symbol
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|ADDRESS_LOAD_INSN
argument_list|,
literal|"t,o(b)"
argument_list|,
name|tempreg
argument_list|,
name|BFD_RELOC_MIPS_GOT_DISP
argument_list|,
name|mips_gp_register
argument_list|)
expr_stmt|;
if|if
condition|(
name|expr1
operator|.
name|X_add_number
operator|>=
operator|-
literal|0x8000
operator|&&
name|expr1
operator|.
name|X_add_number
operator|<
literal|0x8000
condition|)
block|{
name|macro_build
argument_list|(
operator|&
name|expr1
argument_list|,
name|ADDRESS_ADDI_INSN
argument_list|,
literal|"t,r,j"
argument_list|,
name|tempreg
argument_list|,
name|tempreg
argument_list|,
name|BFD_RELOC_LO16
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IS_SEXT_32BIT_NUM
argument_list|(
name|expr1
operator|.
name|X_add_number
operator|+
literal|0x8000
argument_list|)
condition|)
block|{
name|int
name|dreg
decl_stmt|;
comment|/* If we are going to add in a base register, and the 		     target register and the base register are the same, 		     then we are using AT as a temporary register.  Since 		     we want to load the constant into AT, we add our 		     current AT (from the global offset table) and the 		     register into the register now, and pretend we were 		     not using a base register.  */
if|if
condition|(
name|breg
operator|!=
name|treg
condition|)
name|dreg
operator|=
name|tempreg
expr_stmt|;
else|else
block|{
name|assert
argument_list|(
name|tempreg
operator|==
name|AT
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
name|ADDRESS_ADD_INSN
argument_list|,
literal|"d,v,t"
argument_list|,
name|treg
argument_list|,
name|AT
argument_list|,
name|breg
argument_list|)
expr_stmt|;
name|dreg
operator|=
name|treg
expr_stmt|;
name|add_breg_early
operator|=
literal|1
expr_stmt|;
block|}
name|load_register
argument_list|(
name|AT
argument_list|,
operator|&
name|expr1
argument_list|,
name|HAVE_64BIT_ADDRESSES
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
name|ADDRESS_ADD_INSN
argument_list|,
literal|"d,v,t"
argument_list|,
name|dreg
argument_list|,
name|dreg
argument_list|,
name|AT
argument_list|)
expr_stmt|;
name|used_at
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"PIC code offset overflow (max 32 signed bits)"
argument_list|)
argument_list|)
expr_stmt|;
name|relax_switch
argument_list|()
expr_stmt|;
name|offset_expr
operator|.
name|X_add_number
operator|=
name|expr1
operator|.
name|X_add_number
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|ADDRESS_LOAD_INSN
argument_list|,
literal|"t,o(b)"
argument_list|,
name|tempreg
argument_list|,
name|BFD_RELOC_MIPS_GOT_DISP
argument_list|,
name|mips_gp_register
argument_list|)
expr_stmt|;
if|if
condition|(
name|add_breg_early
condition|)
block|{
name|macro_build
argument_list|(
name|NULL
argument_list|,
name|ADDRESS_ADD_INSN
argument_list|,
literal|"d,v,t"
argument_list|,
name|treg
argument_list|,
name|tempreg
argument_list|,
name|breg
argument_list|)
expr_stmt|;
name|breg
operator|=
literal|0
expr_stmt|;
name|tempreg
operator|=
name|treg
expr_stmt|;
block|}
name|relax_end
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|breg
operator|==
literal|0
operator|&&
operator|(
name|call
operator|||
name|tempreg
operator|==
name|PIC_CALL_REG
operator|)
condition|)
block|{
name|relax_start
argument_list|(
name|offset_expr
operator|.
name|X_add_symbol
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|ADDRESS_LOAD_INSN
argument_list|,
literal|"t,o(b)"
argument_list|,
name|tempreg
argument_list|,
name|BFD_RELOC_MIPS_CALL16
argument_list|,
name|mips_gp_register
argument_list|)
expr_stmt|;
name|relax_switch
argument_list|()
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|ADDRESS_LOAD_INSN
argument_list|,
literal|"t,o(b)"
argument_list|,
name|tempreg
argument_list|,
name|BFD_RELOC_MIPS_GOT_DISP
argument_list|,
name|mips_gp_register
argument_list|)
expr_stmt|;
name|relax_end
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|ADDRESS_LOAD_INSN
argument_list|,
literal|"t,o(b)"
argument_list|,
name|tempreg
argument_list|,
name|BFD_RELOC_MIPS_GOT_DISP
argument_list|,
name|mips_gp_register
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|mips_pic
operator|==
name|SVR4_PIC
operator|&&
operator|!
name|HAVE_NEWABI
condition|)
block|{
name|int
name|gpdelay
decl_stmt|;
name|int
name|lui_reloc_type
init|=
operator|(
name|int
operator|)
name|BFD_RELOC_MIPS_GOT_HI16
decl_stmt|;
name|int
name|lw_reloc_type
init|=
operator|(
name|int
operator|)
name|BFD_RELOC_MIPS_GOT_LO16
decl_stmt|;
name|int
name|local_reloc_type
init|=
operator|(
name|int
operator|)
name|BFD_RELOC_MIPS_GOT16
decl_stmt|;
comment|/* This is the large GOT case.  If this is a reference to an 	     external symbol, and there is no constant, we want 	       lui	$tempreg,<sym>		(BFD_RELOC_MIPS_GOT_HI16) 	       addu	$tempreg,$tempreg,$gp 	       lw	$tempreg,<sym>($tempreg) (BFD_RELOC_MIPS_GOT_LO16) 	     or for lca or if tempreg is PIC_CALL_REG 	       lui	$tempreg,<sym>		(BFD_RELOC_MIPS_CALL_HI16) 	       addu	$tempreg,$tempreg,$gp 	       lw	$tempreg,<sym>($tempreg) (BFD_RELOC_MIPS_CALL_LO16) 	     For a local symbol, we want 	       lw	$tempreg,<sym>($gp)	(BFD_RELOC_MIPS_GOT16) 	       nop 	       addiu	$tempreg,$tempreg,<sym>	(BFD_RELOC_LO16)  	     If we have a small constant, and this is a reference to 	     an external symbol, we want 	       lui	$tempreg,<sym>		(BFD_RELOC_MIPS_GOT_HI16) 	       addu	$tempreg,$tempreg,$gp 	       lw	$tempreg,<sym>($tempreg) (BFD_RELOC_MIPS_GOT_LO16) 	       nop 	       addiu	$tempreg,$tempreg,<constant> 	     For a local symbol, we want 	       lw	$tempreg,<sym>($gp)	(BFD_RELOC_MIPS_GOT16) 	       nop 	       addiu	$tempreg,$tempreg,<constant> (BFD_RELOC_LO16)  	     If we have a large constant, and this is a reference to 	     an external symbol, we want 	       lui	$tempreg,<sym>		(BFD_RELOC_MIPS_GOT_HI16) 	       addu	$tempreg,$tempreg,$gp 	       lw	$tempreg,<sym>($tempreg) (BFD_RELOC_MIPS_GOT_LO16) 	       lui	$at,<hiconstant> 	       addiu	$at,$at,<loconstant> 	       addu	$tempreg,$tempreg,$at 	     For a local symbol, we want 	       lw	$tempreg,<sym>($gp)	(BFD_RELOC_MIPS_GOT16) 	       lui	$at,<hiconstant> 	       addiu	$at,$at,<loconstant>	(BFD_RELOC_LO16) 	       addu	$tempreg,$tempreg,$at 	  */
name|expr1
operator|.
name|X_add_number
operator|=
name|offset_expr
operator|.
name|X_add_number
expr_stmt|;
name|offset_expr
operator|.
name|X_add_number
operator|=
literal|0
expr_stmt|;
name|relax_start
argument_list|(
name|offset_expr
operator|.
name|X_add_symbol
argument_list|)
expr_stmt|;
name|gpdelay
operator|=
name|reg_needs_delay
argument_list|(
name|mips_gp_register
argument_list|)
expr_stmt|;
if|if
condition|(
name|expr1
operator|.
name|X_add_number
operator|==
literal|0
operator|&&
name|breg
operator|==
literal|0
operator|&&
operator|(
name|call
operator|||
name|tempreg
operator|==
name|PIC_CALL_REG
operator|)
condition|)
block|{
name|lui_reloc_type
operator|=
operator|(
name|int
operator|)
name|BFD_RELOC_MIPS_CALL_HI16
expr_stmt|;
name|lw_reloc_type
operator|=
operator|(
name|int
operator|)
name|BFD_RELOC_MIPS_CALL_LO16
expr_stmt|;
block|}
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
literal|"lui"
argument_list|,
literal|"t,u"
argument_list|,
name|tempreg
argument_list|,
name|lui_reloc_type
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
name|ADDRESS_ADD_INSN
argument_list|,
literal|"d,v,t"
argument_list|,
name|tempreg
argument_list|,
name|tempreg
argument_list|,
name|mips_gp_register
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|ADDRESS_LOAD_INSN
argument_list|,
literal|"t,o(b)"
argument_list|,
name|tempreg
argument_list|,
name|lw_reloc_type
argument_list|,
name|tempreg
argument_list|)
expr_stmt|;
if|if
condition|(
name|expr1
operator|.
name|X_add_number
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|breg
operator|!=
literal|0
condition|)
block|{
comment|/* We're going to put in an addu instruction using 		     tempreg, so we may as well insert the nop right 		     now.  */
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"nop"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|expr1
operator|.
name|X_add_number
operator|>=
operator|-
literal|0x8000
operator|&&
name|expr1
operator|.
name|X_add_number
operator|<
literal|0x8000
condition|)
block|{
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"nop"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|expr1
argument_list|,
name|ADDRESS_ADDI_INSN
argument_list|,
literal|"t,r,j"
argument_list|,
name|tempreg
argument_list|,
name|tempreg
argument_list|,
name|BFD_RELOC_LO16
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|dreg
decl_stmt|;
comment|/* If we are going to add in a base register, and the 		 target register and the base register are the same, 		 then we are using AT as a temporary register.  Since 		 we want to load the constant into AT, we add our 		 current AT (from the global offset table) and the 		 register into the register now, and pretend we were 		 not using a base register.  */
if|if
condition|(
name|breg
operator|!=
name|treg
condition|)
name|dreg
operator|=
name|tempreg
expr_stmt|;
else|else
block|{
name|assert
argument_list|(
name|tempreg
operator|==
name|AT
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"nop"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
name|ADDRESS_ADD_INSN
argument_list|,
literal|"d,v,t"
argument_list|,
name|treg
argument_list|,
name|AT
argument_list|,
name|breg
argument_list|)
expr_stmt|;
name|dreg
operator|=
name|treg
expr_stmt|;
block|}
name|load_register
argument_list|(
name|AT
argument_list|,
operator|&
name|expr1
argument_list|,
name|HAVE_64BIT_ADDRESSES
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
name|ADDRESS_ADD_INSN
argument_list|,
literal|"d,v,t"
argument_list|,
name|dreg
argument_list|,
name|dreg
argument_list|,
name|AT
argument_list|)
expr_stmt|;
name|used_at
operator|=
literal|1
expr_stmt|;
block|}
name|offset_expr
operator|.
name|X_add_number
operator|=
operator|(
operator|(
name|expr1
operator|.
name|X_add_number
operator|+
literal|0x8000
operator|)
operator|&
literal|0xffff
operator|)
operator|-
literal|0x8000
expr_stmt|;
name|relax_switch
argument_list|()
expr_stmt|;
if|if
condition|(
name|gpdelay
condition|)
block|{
comment|/* This is needed because this instruction uses $gp, but 		 the first instruction on the main stream does not.  */
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"nop"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|ADDRESS_LOAD_INSN
argument_list|,
literal|"t,o(b)"
argument_list|,
name|tempreg
argument_list|,
name|local_reloc_type
argument_list|,
name|mips_gp_register
argument_list|)
expr_stmt|;
if|if
condition|(
name|expr1
operator|.
name|X_add_number
operator|>=
operator|-
literal|0x8000
operator|&&
name|expr1
operator|.
name|X_add_number
operator|<
literal|0x8000
condition|)
block|{
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"nop"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|ADDRESS_ADDI_INSN
argument_list|,
literal|"t,r,j"
argument_list|,
name|tempreg
argument_list|,
name|tempreg
argument_list|,
name|BFD_RELOC_LO16
argument_list|)
expr_stmt|;
comment|/* FIXME: If add_number is 0, and there was no base 		 register, the external symbol case ended with a load, 		 so if the symbol turns out to not be external, and 		 the next instruction uses tempreg, an unnecessary nop 		 will be inserted.  */
block|}
else|else
block|{
if|if
condition|(
name|breg
operator|==
name|treg
condition|)
block|{
comment|/* We must add in the base register now, as in the 		     external symbol case.  */
name|assert
argument_list|(
name|tempreg
operator|==
name|AT
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"nop"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
name|ADDRESS_ADD_INSN
argument_list|,
literal|"d,v,t"
argument_list|,
name|treg
argument_list|,
name|AT
argument_list|,
name|breg
argument_list|)
expr_stmt|;
name|tempreg
operator|=
name|treg
expr_stmt|;
comment|/* We set breg to 0 because we have arranged to add 		     it in in both cases.  */
name|breg
operator|=
literal|0
expr_stmt|;
block|}
name|macro_build_lui
argument_list|(
operator|&
name|expr1
argument_list|,
name|AT
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|ADDRESS_ADDI_INSN
argument_list|,
literal|"t,r,j"
argument_list|,
name|AT
argument_list|,
name|AT
argument_list|,
name|BFD_RELOC_LO16
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
name|ADDRESS_ADD_INSN
argument_list|,
literal|"d,v,t"
argument_list|,
name|tempreg
argument_list|,
name|tempreg
argument_list|,
name|AT
argument_list|)
expr_stmt|;
block|}
name|relax_end
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mips_pic
operator|==
name|SVR4_PIC
operator|&&
name|HAVE_NEWABI
condition|)
block|{
name|int
name|lui_reloc_type
init|=
operator|(
name|int
operator|)
name|BFD_RELOC_MIPS_GOT_HI16
decl_stmt|;
name|int
name|lw_reloc_type
init|=
operator|(
name|int
operator|)
name|BFD_RELOC_MIPS_GOT_LO16
decl_stmt|;
name|int
name|add_breg_early
init|=
literal|0
decl_stmt|;
comment|/* This is the large GOT case.  If this is a reference to an 	     external symbol, and there is no constant, we want 	       lui	$tempreg,<sym>		(BFD_RELOC_MIPS_GOT_HI16) 	       add	$tempreg,$tempreg,$gp 	       lw	$tempreg,<sym>($tempreg) (BFD_RELOC_MIPS_GOT_LO16) 	     or for lca or if tempreg is PIC_CALL_REG 	       lui	$tempreg,<sym>		(BFD_RELOC_MIPS_CALL_HI16) 	       add	$tempreg,$tempreg,$gp 	       lw	$tempreg,<sym>($tempreg) (BFD_RELOC_MIPS_CALL_LO16)  	     If we have a small constant, and this is a reference to 	     an external symbol, we want 	       lui	$tempreg,<sym>		(BFD_RELOC_MIPS_GOT_HI16) 	       add	$tempreg,$tempreg,$gp 	       lw	$tempreg,<sym>($tempreg) (BFD_RELOC_MIPS_GOT_LO16) 	       addi	$tempreg,$tempreg,<constant>  	     If we have a large constant, and this is a reference to 	     an external symbol, we want 	       lui	$tempreg,<sym>		(BFD_RELOC_MIPS_GOT_HI16) 	       addu	$tempreg,$tempreg,$gp 	       lw	$tempreg,<sym>($tempreg) (BFD_RELOC_MIPS_GOT_LO16) 	       lui	$at,<hiconstant> 	       addi	$at,$at,<loconstant> 	       add	$tempreg,$tempreg,$at  	     If we have NewABI, and we know it's a local symbol, we want 	       lw	$reg,<sym>($gp)		(BFD_RELOC_MIPS_GOT_PAGE) 	       addiu	$reg,$reg,<sym>		(BFD_RELOC_MIPS_GOT_OFST) 	     otherwise we have to resort to GOT_HI16/GOT_LO16.  */
name|relax_start
argument_list|(
name|offset_expr
operator|.
name|X_add_symbol
argument_list|)
expr_stmt|;
name|expr1
operator|.
name|X_add_number
operator|=
name|offset_expr
operator|.
name|X_add_number
expr_stmt|;
name|offset_expr
operator|.
name|X_add_number
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|expr1
operator|.
name|X_add_number
operator|==
literal|0
operator|&&
name|breg
operator|==
literal|0
operator|&&
operator|(
name|call
operator|||
name|tempreg
operator|==
name|PIC_CALL_REG
operator|)
condition|)
block|{
name|lui_reloc_type
operator|=
operator|(
name|int
operator|)
name|BFD_RELOC_MIPS_CALL_HI16
expr_stmt|;
name|lw_reloc_type
operator|=
operator|(
name|int
operator|)
name|BFD_RELOC_MIPS_CALL_LO16
expr_stmt|;
block|}
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
literal|"lui"
argument_list|,
literal|"t,u"
argument_list|,
name|tempreg
argument_list|,
name|lui_reloc_type
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
name|ADDRESS_ADD_INSN
argument_list|,
literal|"d,v,t"
argument_list|,
name|tempreg
argument_list|,
name|tempreg
argument_list|,
name|mips_gp_register
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|ADDRESS_LOAD_INSN
argument_list|,
literal|"t,o(b)"
argument_list|,
name|tempreg
argument_list|,
name|lw_reloc_type
argument_list|,
name|tempreg
argument_list|)
expr_stmt|;
if|if
condition|(
name|expr1
operator|.
name|X_add_number
operator|==
literal|0
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|expr1
operator|.
name|X_add_number
operator|>=
operator|-
literal|0x8000
operator|&&
name|expr1
operator|.
name|X_add_number
operator|<
literal|0x8000
condition|)
block|{
name|macro_build
argument_list|(
operator|&
name|expr1
argument_list|,
name|ADDRESS_ADDI_INSN
argument_list|,
literal|"t,r,j"
argument_list|,
name|tempreg
argument_list|,
name|tempreg
argument_list|,
name|BFD_RELOC_LO16
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IS_SEXT_32BIT_NUM
argument_list|(
name|expr1
operator|.
name|X_add_number
operator|+
literal|0x8000
argument_list|)
condition|)
block|{
name|int
name|dreg
decl_stmt|;
comment|/* If we are going to add in a base register, and the 		 target register and the base register are the same, 		 then we are using AT as a temporary register.  Since 		 we want to load the constant into AT, we add our 		 current AT (from the global offset table) and the 		 register into the register now, and pretend we were 		 not using a base register.  */
if|if
condition|(
name|breg
operator|!=
name|treg
condition|)
name|dreg
operator|=
name|tempreg
expr_stmt|;
else|else
block|{
name|assert
argument_list|(
name|tempreg
operator|==
name|AT
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
name|ADDRESS_ADD_INSN
argument_list|,
literal|"d,v,t"
argument_list|,
name|treg
argument_list|,
name|AT
argument_list|,
name|breg
argument_list|)
expr_stmt|;
name|dreg
operator|=
name|treg
expr_stmt|;
name|add_breg_early
operator|=
literal|1
expr_stmt|;
block|}
name|load_register
argument_list|(
name|AT
argument_list|,
operator|&
name|expr1
argument_list|,
name|HAVE_64BIT_ADDRESSES
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
name|ADDRESS_ADD_INSN
argument_list|,
literal|"d,v,t"
argument_list|,
name|dreg
argument_list|,
name|dreg
argument_list|,
name|AT
argument_list|)
expr_stmt|;
name|used_at
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"PIC code offset overflow (max 32 signed bits)"
argument_list|)
argument_list|)
expr_stmt|;
name|relax_switch
argument_list|()
expr_stmt|;
name|offset_expr
operator|.
name|X_add_number
operator|=
name|expr1
operator|.
name|X_add_number
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|ADDRESS_LOAD_INSN
argument_list|,
literal|"t,o(b)"
argument_list|,
name|tempreg
argument_list|,
name|BFD_RELOC_MIPS_GOT_PAGE
argument_list|,
name|mips_gp_register
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|ADDRESS_ADDI_INSN
argument_list|,
literal|"t,r,j"
argument_list|,
name|tempreg
argument_list|,
name|tempreg
argument_list|,
name|BFD_RELOC_MIPS_GOT_OFST
argument_list|)
expr_stmt|;
if|if
condition|(
name|add_breg_early
condition|)
block|{
name|macro_build
argument_list|(
name|NULL
argument_list|,
name|ADDRESS_ADD_INSN
argument_list|,
literal|"d,v,t"
argument_list|,
name|treg
argument_list|,
name|tempreg
argument_list|,
name|breg
argument_list|)
expr_stmt|;
name|breg
operator|=
literal|0
expr_stmt|;
name|tempreg
operator|=
name|treg
expr_stmt|;
block|}
name|relax_end
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mips_pic
operator|==
name|EMBEDDED_PIC
condition|)
block|{
comment|/* We use 	       addiu	$tempreg,$gp,<sym>	(BFD_RELOC_GPREL16) 	     */
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|ADDRESS_ADDI_INSN
argument_list|,
literal|"t,r,j"
argument_list|,
name|tempreg
argument_list|,
name|mips_gp_register
argument_list|,
name|BFD_RELOC_GPREL16
argument_list|)
expr_stmt|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|breg
operator|!=
literal|0
condition|)
block|{
name|char
modifier|*
name|s
decl_stmt|;
if|if
condition|(
name|mips_pic
operator|==
name|EMBEDDED_PIC
operator|||
name|mips_pic
operator|==
name|NO_PIC
condition|)
name|s
operator|=
operator|(
name|dbl
operator|||
name|HAVE_64BIT_ADDRESSES
operator|)
condition|?
literal|"daddu"
else|:
literal|"addu"
expr_stmt|;
else|else
name|s
operator|=
name|ADDRESS_ADD_INSN
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
name|s
argument_list|,
literal|"d,v,t"
argument_list|,
name|treg
argument_list|,
name|tempreg
argument_list|,
name|breg
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|used_at
condition|)
return|return;
break|break;
case|case
name|M_J_A
case|:
comment|/* The j instruction may not be used in PIC code, since it 	 requires an absolute address.  We convert it to a b 	 instruction.  */
if|if
condition|(
name|mips_pic
operator|==
name|NO_PIC
condition|)
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
literal|"j"
argument_list|,
literal|"a"
argument_list|)
expr_stmt|;
else|else
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
literal|"b"
argument_list|,
literal|"p"
argument_list|)
expr_stmt|;
return|return;
comment|/* The jal instructions must be handled as macros because when 	 generating PIC code they expand to multi-instruction 	 sequences.  Normally they are simple instructions.  */
case|case
name|M_JAL_1
case|:
name|dreg
operator|=
name|RA
expr_stmt|;
comment|/* Fall through.  */
case|case
name|M_JAL_2
case|:
if|if
condition|(
name|mips_pic
operator|==
name|NO_PIC
operator|||
name|mips_pic
operator|==
name|EMBEDDED_PIC
condition|)
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"jalr"
argument_list|,
literal|"d,s"
argument_list|,
name|dreg
argument_list|,
name|sreg
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|mips_pic
operator|==
name|SVR4_PIC
condition|)
block|{
if|if
condition|(
name|sreg
operator|!=
name|PIC_CALL_REG
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"MIPS PIC call to register other than $25"
argument_list|)
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"jalr"
argument_list|,
literal|"d,s"
argument_list|,
name|dreg
argument_list|,
name|sreg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|HAVE_NEWABI
condition|)
block|{
if|if
condition|(
name|mips_cprestore_offset
operator|<
literal|0
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"No .cprestore pseudo-op used in PIC code"
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|!
name|mips_frame_reg_valid
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"No .frame pseudo-op used in PIC code"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Quiet this warning.  */
name|mips_frame_reg_valid
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|mips_cprestore_valid
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"No .cprestore pseudo-op used in PIC code"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Quiet this warning.  */
name|mips_cprestore_valid
operator|=
literal|1
expr_stmt|;
block|}
name|expr1
operator|.
name|X_add_number
operator|=
name|mips_cprestore_offset
expr_stmt|;
name|macro_build_ldst_constoffset
argument_list|(
operator|&
name|expr1
argument_list|,
name|ADDRESS_LOAD_INSN
argument_list|,
name|mips_gp_register
argument_list|,
name|mips_frame_reg
argument_list|,
name|HAVE_64BIT_ADDRESSES
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
return|return;
case|case
name|M_JAL_A
case|:
if|if
condition|(
name|mips_pic
operator|==
name|NO_PIC
condition|)
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
literal|"jal"
argument_list|,
literal|"a"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|mips_pic
operator|==
name|SVR4_PIC
condition|)
block|{
comment|/* If this is a reference to an external symbol, and we are 	     using a small GOT, we want 	       lw	$25,<sym>($gp)		(BFD_RELOC_MIPS_CALL16) 	       nop 	       jalr	$ra,$25 	       nop 	       lw	$gp,cprestore($sp) 	     The cprestore value is set using the .cprestore 	     pseudo-op.  If we are using a big GOT, we want 	       lui	$25,<sym>		(BFD_RELOC_MIPS_CALL_HI16) 	       addu	$25,$25,$gp 	       lw	$25,<sym>($25)		(BFD_RELOC_MIPS_CALL_LO16) 	       nop 	       jalr	$ra,$25 	       nop 	       lw	$gp,cprestore($sp) 	     If the symbol is not external, we want 	       lw	$25,<sym>($gp)		(BFD_RELOC_MIPS_GOT16) 	       nop 	       addiu	$25,$25,<sym>		(BFD_RELOC_LO16) 	       jalr	$ra,$25 	       nop 	       lw $gp,cprestore($sp)  	     For NewABI, we use the same CALL16 or CALL_HI16/CALL_LO16 	     sequences above, minus nops, unless the symbol is local, 	     which enables us to use GOT_PAGE/GOT_OFST (big got) or 	     GOT_DISP.  */
if|if
condition|(
name|HAVE_NEWABI
condition|)
block|{
if|if
condition|(
operator|!
name|mips_big_got
condition|)
block|{
name|relax_start
argument_list|(
name|offset_expr
operator|.
name|X_add_symbol
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|ADDRESS_LOAD_INSN
argument_list|,
literal|"t,o(b)"
argument_list|,
name|PIC_CALL_REG
argument_list|,
name|BFD_RELOC_MIPS_CALL16
argument_list|,
name|mips_gp_register
argument_list|)
expr_stmt|;
name|relax_switch
argument_list|()
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|ADDRESS_LOAD_INSN
argument_list|,
literal|"t,o(b)"
argument_list|,
name|PIC_CALL_REG
argument_list|,
name|BFD_RELOC_MIPS_GOT_DISP
argument_list|,
name|mips_gp_register
argument_list|)
expr_stmt|;
name|relax_end
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|relax_start
argument_list|(
name|offset_expr
operator|.
name|X_add_symbol
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
literal|"lui"
argument_list|,
literal|"t,u"
argument_list|,
name|PIC_CALL_REG
argument_list|,
name|BFD_RELOC_MIPS_CALL_HI16
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
name|ADDRESS_ADD_INSN
argument_list|,
literal|"d,v,t"
argument_list|,
name|PIC_CALL_REG
argument_list|,
name|PIC_CALL_REG
argument_list|,
name|mips_gp_register
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|ADDRESS_LOAD_INSN
argument_list|,
literal|"t,o(b)"
argument_list|,
name|PIC_CALL_REG
argument_list|,
name|BFD_RELOC_MIPS_CALL_LO16
argument_list|,
name|PIC_CALL_REG
argument_list|)
expr_stmt|;
name|relax_switch
argument_list|()
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|ADDRESS_LOAD_INSN
argument_list|,
literal|"t,o(b)"
argument_list|,
name|PIC_CALL_REG
argument_list|,
name|BFD_RELOC_MIPS_GOT_PAGE
argument_list|,
name|mips_gp_register
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|ADDRESS_ADDI_INSN
argument_list|,
literal|"t,r,j"
argument_list|,
name|PIC_CALL_REG
argument_list|,
name|PIC_CALL_REG
argument_list|,
name|BFD_RELOC_MIPS_GOT_OFST
argument_list|)
expr_stmt|;
name|relax_end
argument_list|()
expr_stmt|;
block|}
name|macro_build_jalr
argument_list|(
operator|&
name|offset_expr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|relax_start
argument_list|(
name|offset_expr
operator|.
name|X_add_symbol
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mips_big_got
condition|)
block|{
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|ADDRESS_LOAD_INSN
argument_list|,
literal|"t,o(b)"
argument_list|,
name|PIC_CALL_REG
argument_list|,
name|BFD_RELOC_MIPS_CALL16
argument_list|,
name|mips_gp_register
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"nop"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|relax_switch
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|int
name|gpdelay
decl_stmt|;
name|gpdelay
operator|=
name|reg_needs_delay
argument_list|(
name|mips_gp_register
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
literal|"lui"
argument_list|,
literal|"t,u"
argument_list|,
name|PIC_CALL_REG
argument_list|,
name|BFD_RELOC_MIPS_CALL_HI16
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
name|ADDRESS_ADD_INSN
argument_list|,
literal|"d,v,t"
argument_list|,
name|PIC_CALL_REG
argument_list|,
name|PIC_CALL_REG
argument_list|,
name|mips_gp_register
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|ADDRESS_LOAD_INSN
argument_list|,
literal|"t,o(b)"
argument_list|,
name|PIC_CALL_REG
argument_list|,
name|BFD_RELOC_MIPS_CALL_LO16
argument_list|,
name|PIC_CALL_REG
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"nop"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|relax_switch
argument_list|()
expr_stmt|;
if|if
condition|(
name|gpdelay
condition|)
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"nop"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|ADDRESS_LOAD_INSN
argument_list|,
literal|"t,o(b)"
argument_list|,
name|PIC_CALL_REG
argument_list|,
name|BFD_RELOC_MIPS_GOT16
argument_list|,
name|mips_gp_register
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"nop"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|ADDRESS_ADDI_INSN
argument_list|,
literal|"t,r,j"
argument_list|,
name|PIC_CALL_REG
argument_list|,
name|PIC_CALL_REG
argument_list|,
name|BFD_RELOC_LO16
argument_list|)
expr_stmt|;
name|relax_end
argument_list|()
expr_stmt|;
name|macro_build_jalr
argument_list|(
operator|&
name|offset_expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|mips_cprestore_offset
operator|<
literal|0
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"No .cprestore pseudo-op used in PIC code"
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|!
name|mips_frame_reg_valid
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"No .frame pseudo-op used in PIC code"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Quiet this warning.  */
name|mips_frame_reg_valid
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|mips_cprestore_valid
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"No .cprestore pseudo-op used in PIC code"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Quiet this warning.  */
name|mips_cprestore_valid
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|mips_opts
operator|.
name|noreorder
condition|)
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"nop"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|expr1
operator|.
name|X_add_number
operator|=
name|mips_cprestore_offset
expr_stmt|;
name|macro_build_ldst_constoffset
argument_list|(
operator|&
name|expr1
argument_list|,
name|ADDRESS_LOAD_INSN
argument_list|,
name|mips_gp_register
argument_list|,
name|mips_frame_reg
argument_list|,
name|HAVE_64BIT_ADDRESSES
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|mips_pic
operator|==
name|EMBEDDED_PIC
condition|)
block|{
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
literal|"bal"
argument_list|,
literal|"p"
argument_list|)
expr_stmt|;
comment|/* The linker may expand the call to a longer sequence which 	     uses $at, so we must break rather than return.  */
break|break;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
return|return;
case|case
name|M_LB_AB
case|:
name|s
operator|=
literal|"lb"
expr_stmt|;
goto|goto
name|ld
goto|;
case|case
name|M_LBU_AB
case|:
name|s
operator|=
literal|"lbu"
expr_stmt|;
goto|goto
name|ld
goto|;
case|case
name|M_LH_AB
case|:
name|s
operator|=
literal|"lh"
expr_stmt|;
goto|goto
name|ld
goto|;
case|case
name|M_LHU_AB
case|:
name|s
operator|=
literal|"lhu"
expr_stmt|;
goto|goto
name|ld
goto|;
case|case
name|M_LW_AB
case|:
name|s
operator|=
literal|"lw"
expr_stmt|;
goto|goto
name|ld
goto|;
case|case
name|M_LWC0_AB
case|:
name|s
operator|=
literal|"lwc0"
expr_stmt|;
comment|/* Itbl support may require additional care here.  */
name|coproc
operator|=
literal|1
expr_stmt|;
goto|goto
name|ld
goto|;
case|case
name|M_LWC1_AB
case|:
name|s
operator|=
literal|"lwc1"
expr_stmt|;
comment|/* Itbl support may require additional care here.  */
name|coproc
operator|=
literal|1
expr_stmt|;
goto|goto
name|ld
goto|;
case|case
name|M_LWC2_AB
case|:
name|s
operator|=
literal|"lwc2"
expr_stmt|;
comment|/* Itbl support may require additional care here.  */
name|coproc
operator|=
literal|1
expr_stmt|;
goto|goto
name|ld
goto|;
case|case
name|M_LWC3_AB
case|:
name|s
operator|=
literal|"lwc3"
expr_stmt|;
comment|/* Itbl support may require additional care here.  */
name|coproc
operator|=
literal|1
expr_stmt|;
goto|goto
name|ld
goto|;
case|case
name|M_LWL_AB
case|:
name|s
operator|=
literal|"lwl"
expr_stmt|;
name|lr
operator|=
literal|1
expr_stmt|;
goto|goto
name|ld
goto|;
case|case
name|M_LWR_AB
case|:
name|s
operator|=
literal|"lwr"
expr_stmt|;
name|lr
operator|=
literal|1
expr_stmt|;
goto|goto
name|ld
goto|;
case|case
name|M_LDC1_AB
case|:
if|if
condition|(
name|mips_opts
operator|.
name|arch
operator|==
name|CPU_R4650
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"opcode not supported on this processor"
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|s
operator|=
literal|"ldc1"
expr_stmt|;
comment|/* Itbl support may require additional care here.  */
name|coproc
operator|=
literal|1
expr_stmt|;
goto|goto
name|ld
goto|;
case|case
name|M_LDC2_AB
case|:
name|s
operator|=
literal|"ldc2"
expr_stmt|;
comment|/* Itbl support may require additional care here.  */
name|coproc
operator|=
literal|1
expr_stmt|;
goto|goto
name|ld
goto|;
case|case
name|M_LDC3_AB
case|:
name|s
operator|=
literal|"ldc3"
expr_stmt|;
comment|/* Itbl support may require additional care here.  */
name|coproc
operator|=
literal|1
expr_stmt|;
goto|goto
name|ld
goto|;
case|case
name|M_LDL_AB
case|:
name|s
operator|=
literal|"ldl"
expr_stmt|;
name|lr
operator|=
literal|1
expr_stmt|;
goto|goto
name|ld
goto|;
case|case
name|M_LDR_AB
case|:
name|s
operator|=
literal|"ldr"
expr_stmt|;
name|lr
operator|=
literal|1
expr_stmt|;
goto|goto
name|ld
goto|;
case|case
name|M_LL_AB
case|:
name|s
operator|=
literal|"ll"
expr_stmt|;
goto|goto
name|ld
goto|;
case|case
name|M_LLD_AB
case|:
name|s
operator|=
literal|"lld"
expr_stmt|;
goto|goto
name|ld
goto|;
case|case
name|M_LWU_AB
case|:
name|s
operator|=
literal|"lwu"
expr_stmt|;
name|ld
label|:
if|if
condition|(
name|breg
operator|==
name|treg
operator|||
name|coproc
operator|||
name|lr
condition|)
block|{
name|tempreg
operator|=
name|AT
expr_stmt|;
name|used_at
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|tempreg
operator|=
name|treg
expr_stmt|;
name|used_at
operator|=
literal|0
expr_stmt|;
block|}
goto|goto
name|ld_st
goto|;
case|case
name|M_SB_AB
case|:
name|s
operator|=
literal|"sb"
expr_stmt|;
goto|goto
name|st
goto|;
case|case
name|M_SH_AB
case|:
name|s
operator|=
literal|"sh"
expr_stmt|;
goto|goto
name|st
goto|;
case|case
name|M_SW_AB
case|:
name|s
operator|=
literal|"sw"
expr_stmt|;
goto|goto
name|st
goto|;
case|case
name|M_SWC0_AB
case|:
name|s
operator|=
literal|"swc0"
expr_stmt|;
comment|/* Itbl support may require additional care here.  */
name|coproc
operator|=
literal|1
expr_stmt|;
goto|goto
name|st
goto|;
case|case
name|M_SWC1_AB
case|:
name|s
operator|=
literal|"swc1"
expr_stmt|;
comment|/* Itbl support may require additional care here.  */
name|coproc
operator|=
literal|1
expr_stmt|;
goto|goto
name|st
goto|;
case|case
name|M_SWC2_AB
case|:
name|s
operator|=
literal|"swc2"
expr_stmt|;
comment|/* Itbl support may require additional care here.  */
name|coproc
operator|=
literal|1
expr_stmt|;
goto|goto
name|st
goto|;
case|case
name|M_SWC3_AB
case|:
name|s
operator|=
literal|"swc3"
expr_stmt|;
comment|/* Itbl support may require additional care here.  */
name|coproc
operator|=
literal|1
expr_stmt|;
goto|goto
name|st
goto|;
case|case
name|M_SWL_AB
case|:
name|s
operator|=
literal|"swl"
expr_stmt|;
goto|goto
name|st
goto|;
case|case
name|M_SWR_AB
case|:
name|s
operator|=
literal|"swr"
expr_stmt|;
goto|goto
name|st
goto|;
case|case
name|M_SC_AB
case|:
name|s
operator|=
literal|"sc"
expr_stmt|;
goto|goto
name|st
goto|;
case|case
name|M_SCD_AB
case|:
name|s
operator|=
literal|"scd"
expr_stmt|;
goto|goto
name|st
goto|;
case|case
name|M_SDC1_AB
case|:
if|if
condition|(
name|mips_opts
operator|.
name|arch
operator|==
name|CPU_R4650
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"opcode not supported on this processor"
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|s
operator|=
literal|"sdc1"
expr_stmt|;
name|coproc
operator|=
literal|1
expr_stmt|;
comment|/* Itbl support may require additional care here.  */
goto|goto
name|st
goto|;
case|case
name|M_SDC2_AB
case|:
name|s
operator|=
literal|"sdc2"
expr_stmt|;
comment|/* Itbl support may require additional care here.  */
name|coproc
operator|=
literal|1
expr_stmt|;
goto|goto
name|st
goto|;
case|case
name|M_SDC3_AB
case|:
name|s
operator|=
literal|"sdc3"
expr_stmt|;
comment|/* Itbl support may require additional care here.  */
name|coproc
operator|=
literal|1
expr_stmt|;
goto|goto
name|st
goto|;
case|case
name|M_SDL_AB
case|:
name|s
operator|=
literal|"sdl"
expr_stmt|;
goto|goto
name|st
goto|;
case|case
name|M_SDR_AB
case|:
name|s
operator|=
literal|"sdr"
expr_stmt|;
name|st
label|:
name|tempreg
operator|=
name|AT
expr_stmt|;
name|used_at
operator|=
literal|1
expr_stmt|;
name|ld_st
label|:
comment|/* Itbl support may require additional care here.  */
if|if
condition|(
name|mask
operator|==
name|M_LWC1_AB
operator|||
name|mask
operator|==
name|M_SWC1_AB
operator|||
name|mask
operator|==
name|M_LDC1_AB
operator|||
name|mask
operator|==
name|M_SDC1_AB
operator|||
name|mask
operator|==
name|M_L_DAB
operator|||
name|mask
operator|==
name|M_S_DAB
condition|)
name|fmt
operator|=
literal|"T,o(b)"
expr_stmt|;
elseif|else
if|if
condition|(
name|coproc
condition|)
name|fmt
operator|=
literal|"E,o(b)"
expr_stmt|;
else|else
name|fmt
operator|=
literal|"t,o(b)"
expr_stmt|;
comment|/* Sign-extending 32-bit constants makes their handling easier.          The HAVE_64BIT_GPRS... part is due to the linux kernel hack          described below.  */
if|if
condition|(
operator|(
operator|!
name|HAVE_64BIT_ADDRESSES
operator|&&
operator|(
operator|!
name|HAVE_64BIT_GPRS
operator|&&
name|offset_expr
operator|.
name|X_op
operator|==
name|O_constant
operator|)
operator|)
operator|&&
operator|(
name|offset_expr
operator|.
name|X_op
operator|==
name|O_constant
operator|)
operator|&&
operator|!
operator|(
operator|(
name|offset_expr
operator|.
name|X_add_number
operator|&
operator|~
operator|(
operator|(
name|bfd_vma
operator|)
literal|0x7fffffff
operator|)
operator|)
operator|==
operator|~
operator|(
operator|(
name|bfd_vma
operator|)
literal|0x7fffffff
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|offset_expr
operator|.
name|X_add_number
operator|&
operator|~
operator|(
operator|(
name|bfd_vma
operator|)
literal|0xffffffff
operator|)
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"constant too large"
argument_list|)
argument_list|)
expr_stmt|;
name|offset_expr
operator|.
name|X_add_number
operator|=
operator|(
operator|(
operator|(
name|offset_expr
operator|.
name|X_add_number
operator|&
literal|0xffffffff
operator|)
operator|^
literal|0x80000000
operator|)
operator|-
literal|0x80000000
operator|)
expr_stmt|;
block|}
comment|/* For embedded PIC, we allow loads where the offset is calculated          by subtracting a symbol in the current segment from an unknown          symbol, relative to a base register, e.g.:<op>	$treg,<sym>-<localsym>($breg) 	 This is used by the compiler for switch statements.  */
if|if
condition|(
name|mips_pic
operator|==
name|EMBEDDED_PIC
operator|&&
name|offset_expr
operator|.
name|X_op
operator|==
name|O_subtract
operator|&&
operator|(
name|symbol_constant_p
argument_list|(
name|offset_expr
operator|.
name|X_op_symbol
argument_list|)
condition|?
name|S_GET_SEGMENT
argument_list|(
name|offset_expr
operator|.
name|X_op_symbol
argument_list|)
operator|==
name|now_seg
else|:
operator|(
name|symbol_equated_p
argument_list|(
name|offset_expr
operator|.
name|X_op_symbol
argument_list|)
operator|&&
operator|(
name|S_GET_SEGMENT
argument_list|(
name|symbol_get_value_expression
argument_list|(
name|offset_expr
operator|.
name|X_op_symbol
argument_list|)
operator|->
name|X_add_symbol
argument_list|)
operator|==
name|now_seg
operator|)
operator|)
operator|)
operator|&&
name|breg
operator|!=
literal|0
operator|&&
operator|(
name|offset_expr
operator|.
name|X_add_number
operator|==
literal|0
operator|||
name|OUTPUT_FLAVOR
operator|==
name|bfd_target_elf_flavour
operator|)
condition|)
block|{
comment|/* For this case, we output the instructions:                 lui     $tempreg,<sym>          (BFD_RELOC_PCREL_HI16_S)                 addiu   $tempreg,$tempreg,$breg<op>    $treg,<sym>($tempreg)   (BFD_RELOC_PCREL_LO16)              If the relocation would fit entirely in 16 bits, it would be              nice to emit:<op>    $treg,<sym>($breg)      (BFD_RELOC_PCREL_LO16)              instead, but that seems quite difficult.  */
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
literal|"lui"
argument_list|,
literal|"t,u"
argument_list|,
name|tempreg
argument_list|,
name|BFD_RELOC_PCREL_HI16_S
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
operator|(
operator|(
name|bfd_arch_bits_per_address
argument_list|(
name|stdoutput
argument_list|)
operator|==
literal|32
operator|||
operator|!
name|ISA_HAS_64BIT_REGS
argument_list|(
name|mips_opts
operator|.
name|isa
argument_list|)
operator|)
condition|?
literal|"addu"
else|:
literal|"daddu"
operator|)
argument_list|,
literal|"d,v,t"
argument_list|,
name|tempreg
argument_list|,
name|tempreg
argument_list|,
name|breg
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|s
argument_list|,
name|fmt
argument_list|,
name|treg
argument_list|,
name|BFD_RELOC_PCREL_LO16
argument_list|,
name|tempreg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|used_at
condition|)
return|return;
break|break;
block|}
if|if
condition|(
name|offset_expr
operator|.
name|X_op
operator|!=
name|O_constant
operator|&&
name|offset_expr
operator|.
name|X_op
operator|!=
name|O_symbol
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"expression too complex"
argument_list|)
argument_list|)
expr_stmt|;
name|offset_expr
operator|.
name|X_op
operator|=
name|O_constant
expr_stmt|;
block|}
comment|/* A constant expression in PIC code can be handled just as it 	 is in non PIC code.  */
if|if
condition|(
name|mips_pic
operator|==
name|NO_PIC
operator|||
name|offset_expr
operator|.
name|X_op
operator|==
name|O_constant
condition|)
block|{
comment|/* If this is a reference to a GP relative symbol, and there 	     is no base register, we want<op>	$treg,<sym>($gp)	(BFD_RELOC_GPREL16) 	     Otherwise, if there is no base register, we want 	       lui	$tempreg,<sym>		(BFD_RELOC_HI16_S)<op>	$treg,<sym>($tempreg)	(BFD_RELOC_LO16) 	     If we have a constant, we need two instructions anyhow, 	     so we always use the latter form.  	     If we have a base register, and this is a reference to a 	     GP relative symbol, we want 	       addu	$tempreg,$breg,$gp<op>	$treg,<sym>($tempreg)	(BFD_RELOC_GPREL16) 	     Otherwise we want 	       lui	$tempreg,<sym>		(BFD_RELOC_HI16_S) 	       addu	$tempreg,$tempreg,$breg<op>	$treg,<sym>($tempreg)	(BFD_RELOC_LO16) 	     With a constant we always use the latter case.  	     With 64bit address space and no base register and $at usable, 	     we want 	       lui	$tempreg,<sym>		(BFD_RELOC_MIPS_HIGHEST) 	       lui	$at,<sym>		(BFD_RELOC_HI16_S) 	       daddiu	$tempreg,<sym>		(BFD_RELOC_MIPS_HIGHER) 	       dsll32	$tempreg,0 	       daddu	$tempreg,$at<op>	$treg,<sym>($tempreg)	(BFD_RELOC_LO16) 	     If we have a base register, we want 	       lui	$tempreg,<sym>		(BFD_RELOC_MIPS_HIGHEST) 	       lui	$at,<sym>		(BFD_RELOC_HI16_S) 	       daddiu	$tempreg,<sym>		(BFD_RELOC_MIPS_HIGHER) 	       daddu	$at,$breg 	       dsll32	$tempreg,0 	       daddu	$tempreg,$at<op>	$treg,<sym>($tempreg)	(BFD_RELOC_LO16)  	     Without $at we can't generate the optimal path for superscalar 	     processors here since this would require two temporary registers. 	       lui	$tempreg,<sym>		(BFD_RELOC_MIPS_HIGHEST) 	       daddiu	$tempreg,<sym>		(BFD_RELOC_MIPS_HIGHER) 	       dsll	$tempreg,16 	       daddiu	$tempreg,<sym>		(BFD_RELOC_HI16_S) 	       dsll	$tempreg,16<op>	$treg,<sym>($tempreg)	(BFD_RELOC_LO16) 	     If we have a base register, we want 	       lui	$tempreg,<sym>		(BFD_RELOC_MIPS_HIGHEST) 	       daddiu	$tempreg,<sym>		(BFD_RELOC_MIPS_HIGHER) 	       dsll	$tempreg,16 	       daddiu	$tempreg,<sym>		(BFD_RELOC_HI16_S) 	       dsll	$tempreg,16 	       daddu	$tempreg,$tempreg,$breg<op>	$treg,<sym>($tempreg)	(BFD_RELOC_LO16)  	     If we have 64-bit addresses, as an optimization, for 	     addresses which are 32-bit constants (e.g. kseg0/kseg1 	     addresses) we fall back to the 32-bit address generation 	     mechanism since it is more efficient.  Note that due to 	     the signed offset used by memory operations, the 32-bit 	     range is shifted down by 32768 here.  This code should 	     probably attempt to generate 64-bit constants more 	     efficiently in general.  	     As an extension for architectures with 64-bit registers, 	     we don't truncate 64-bit addresses given as literal 	     constants down to 32 bits, to support existing practice 	     in the mips64 Linux (the kernel), that compiles source 	     files with -mabi=64, assembling them as o32 or n32 (with 	     -Wa,-32 or -Wa,-n32).  This is not beautiful, but since 	     the whole kernel is loaded into a memory region that is 	     addressable with sign-extended 32-bit addresses, it is 	     wasteful to compute the upper 32 bits of every 	     non-literal address, that takes more space and time. 	     Some day this should probably be implemented as an 	     assembler option, such that the kernel doesn't have to 	     use such ugly hacks, even though it will still have to 	     end up converting the binary to ELF32 for a number of 	     platforms whose boot loaders don't support ELF64 	     binaries.  */
if|if
condition|(
operator|(
name|HAVE_64BIT_ADDRESSES
operator|&&
operator|!
operator|(
name|offset_expr
operator|.
name|X_op
operator|==
name|O_constant
operator|&&
name|IS_SEXT_32BIT_NUM
argument_list|(
name|offset_expr
operator|.
name|X_add_number
operator|+
literal|0x8000
argument_list|)
operator|)
operator|)
operator|||
operator|(
name|HAVE_64BIT_GPRS
operator|&&
name|offset_expr
operator|.
name|X_op
operator|==
name|O_constant
operator|&&
operator|!
name|IS_SEXT_32BIT_NUM
argument_list|(
name|offset_expr
operator|.
name|X_add_number
operator|+
literal|0x8000
argument_list|)
operator|)
condition|)
block|{
comment|/* ??? We don't provide a GP-relative alternative for 		 these macros.  It used not to be possible with the 		 original relaxation code, but it could be done now.  */
if|if
condition|(
name|used_at
operator|==
literal|0
operator|&&
operator|!
name|mips_opts
operator|.
name|noat
condition|)
block|{
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
literal|"lui"
argument_list|,
literal|"t,u"
argument_list|,
name|tempreg
argument_list|,
name|BFD_RELOC_MIPS_HIGHEST
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
literal|"lui"
argument_list|,
literal|"t,u"
argument_list|,
name|AT
argument_list|,
name|BFD_RELOC_HI16_S
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
literal|"daddiu"
argument_list|,
literal|"t,r,j"
argument_list|,
name|tempreg
argument_list|,
name|tempreg
argument_list|,
name|BFD_RELOC_MIPS_HIGHER
argument_list|)
expr_stmt|;
if|if
condition|(
name|breg
operator|!=
literal|0
condition|)
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"daddu"
argument_list|,
literal|"d,v,t"
argument_list|,
name|AT
argument_list|,
name|AT
argument_list|,
name|breg
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"dsll32"
argument_list|,
literal|"d,w,<"
argument_list|,
name|tempreg
argument_list|,
name|tempreg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"daddu"
argument_list|,
literal|"d,v,t"
argument_list|,
name|tempreg
argument_list|,
name|tempreg
argument_list|,
name|AT
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|s
argument_list|,
name|fmt
argument_list|,
name|treg
argument_list|,
name|BFD_RELOC_LO16
argument_list|,
name|tempreg
argument_list|)
expr_stmt|;
name|used_at
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
literal|"lui"
argument_list|,
literal|"t,u"
argument_list|,
name|tempreg
argument_list|,
name|BFD_RELOC_MIPS_HIGHEST
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
literal|"daddiu"
argument_list|,
literal|"t,r,j"
argument_list|,
name|tempreg
argument_list|,
name|tempreg
argument_list|,
name|BFD_RELOC_MIPS_HIGHER
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"dsll"
argument_list|,
literal|"d,w,<"
argument_list|,
name|tempreg
argument_list|,
name|tempreg
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
literal|"daddiu"
argument_list|,
literal|"t,r,j"
argument_list|,
name|tempreg
argument_list|,
name|tempreg
argument_list|,
name|BFD_RELOC_HI16_S
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"dsll"
argument_list|,
literal|"d,w,<"
argument_list|,
name|tempreg
argument_list|,
name|tempreg
argument_list|,
literal|16
argument_list|)
expr_stmt|;
if|if
condition|(
name|breg
operator|!=
literal|0
condition|)
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"daddu"
argument_list|,
literal|"d,v,t"
argument_list|,
name|tempreg
argument_list|,
name|tempreg
argument_list|,
name|breg
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|s
argument_list|,
name|fmt
argument_list|,
name|treg
argument_list|,
name|BFD_RELOC_LO16
argument_list|,
name|tempreg
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
if|if
condition|(
name|offset_expr
operator|.
name|X_op
operator|==
name|O_constant
operator|&&
operator|!
name|IS_SEXT_32BIT_NUM
argument_list|(
name|offset_expr
operator|.
name|X_add_number
operator|+
literal|0x8000
argument_list|)
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"load/store address overflow (max 32 bits)"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|breg
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|valueT
operator|)
name|offset_expr
operator|.
name|X_add_number
operator|<=
name|MAX_GPREL_OFFSET
operator|&&
operator|!
name|nopic_need_relax
argument_list|(
name|offset_expr
operator|.
name|X_add_symbol
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|relax_start
argument_list|(
name|offset_expr
operator|.
name|X_add_symbol
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|s
argument_list|,
name|fmt
argument_list|,
name|treg
argument_list|,
name|BFD_RELOC_GPREL16
argument_list|,
name|mips_gp_register
argument_list|)
expr_stmt|;
name|relax_switch
argument_list|()
expr_stmt|;
name|used_at
operator|=
literal|0
expr_stmt|;
block|}
name|macro_build_lui
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|tempreg
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|s
argument_list|,
name|fmt
argument_list|,
name|treg
argument_list|,
name|BFD_RELOC_LO16
argument_list|,
name|tempreg
argument_list|)
expr_stmt|;
if|if
condition|(
name|mips_relax
operator|.
name|sequence
condition|)
name|relax_end
argument_list|()
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|valueT
operator|)
name|offset_expr
operator|.
name|X_add_number
operator|<=
name|MAX_GPREL_OFFSET
operator|&&
operator|!
name|nopic_need_relax
argument_list|(
name|offset_expr
operator|.
name|X_add_symbol
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|relax_start
argument_list|(
name|offset_expr
operator|.
name|X_add_symbol
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
name|ADDRESS_ADD_INSN
argument_list|,
literal|"d,v,t"
argument_list|,
name|tempreg
argument_list|,
name|breg
argument_list|,
name|mips_gp_register
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|s
argument_list|,
name|fmt
argument_list|,
name|treg
argument_list|,
name|BFD_RELOC_GPREL16
argument_list|,
name|tempreg
argument_list|)
expr_stmt|;
name|relax_switch
argument_list|()
expr_stmt|;
block|}
name|macro_build_lui
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|tempreg
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
name|ADDRESS_ADD_INSN
argument_list|,
literal|"d,v,t"
argument_list|,
name|tempreg
argument_list|,
name|tempreg
argument_list|,
name|breg
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|s
argument_list|,
name|fmt
argument_list|,
name|treg
argument_list|,
name|BFD_RELOC_LO16
argument_list|,
name|tempreg
argument_list|)
expr_stmt|;
if|if
condition|(
name|mips_relax
operator|.
name|sequence
condition|)
name|relax_end
argument_list|()
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|mips_pic
operator|==
name|SVR4_PIC
operator|&&
operator|!
name|mips_big_got
condition|)
block|{
name|int
name|lw_reloc_type
init|=
operator|(
name|int
operator|)
name|BFD_RELOC_MIPS_GOT16
decl_stmt|;
comment|/* If this is a reference to an external symbol, we want 	       lw	$tempreg,<sym>($gp)	(BFD_RELOC_MIPS_GOT16) 	       nop<op>	$treg,0($tempreg) 	     Otherwise we want 	       lw	$tempreg,<sym>($gp)	(BFD_RELOC_MIPS_GOT16) 	       nop 	       addiu	$tempreg,$tempreg,<sym>	(BFD_RELOC_LO16)<op>	$treg,0($tempreg)  	     For NewABI, we want 	       lw	$tempreg,<sym>($gp)	(BFD_RELOC_MIPS_GOT_PAGE)<op>	$treg,<sym>($tempreg)   (BFD_RELOC_MIPS_GOT_OFST)  	     If there is a base register, we add it to $tempreg before 	     the<op>.  If there is a constant, we stick it in the<op> instruction.  We don't handle constants larger than 	     16 bits, because we have no way to load the upper 16 bits 	     (actually, we could handle them for the subset of cases 	     in which we are not using $at).  */
name|assert
argument_list|(
name|offset_expr
operator|.
name|X_op
operator|==
name|O_symbol
argument_list|)
expr_stmt|;
if|if
condition|(
name|HAVE_NEWABI
condition|)
block|{
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|ADDRESS_LOAD_INSN
argument_list|,
literal|"t,o(b)"
argument_list|,
name|tempreg
argument_list|,
name|BFD_RELOC_MIPS_GOT_PAGE
argument_list|,
name|mips_gp_register
argument_list|)
expr_stmt|;
if|if
condition|(
name|breg
operator|!=
literal|0
condition|)
name|macro_build
argument_list|(
name|NULL
argument_list|,
name|ADDRESS_ADD_INSN
argument_list|,
literal|"d,v,t"
argument_list|,
name|tempreg
argument_list|,
name|tempreg
argument_list|,
name|breg
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|s
argument_list|,
name|fmt
argument_list|,
name|treg
argument_list|,
name|BFD_RELOC_MIPS_GOT_OFST
argument_list|,
name|tempreg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|used_at
condition|)
return|return;
break|break;
block|}
name|expr1
operator|.
name|X_add_number
operator|=
name|offset_expr
operator|.
name|X_add_number
expr_stmt|;
name|offset_expr
operator|.
name|X_add_number
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|expr1
operator|.
name|X_add_number
operator|<
operator|-
literal|0x8000
operator|||
name|expr1
operator|.
name|X_add_number
operator|>=
literal|0x8000
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"PIC code offset overflow (max 16 signed bits)"
argument_list|)
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|ADDRESS_LOAD_INSN
argument_list|,
literal|"t,o(b)"
argument_list|,
name|tempreg
argument_list|,
name|lw_reloc_type
argument_list|,
name|mips_gp_register
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"nop"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|relax_start
argument_list|(
name|offset_expr
operator|.
name|X_add_symbol
argument_list|)
expr_stmt|;
name|relax_switch
argument_list|()
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|ADDRESS_ADDI_INSN
argument_list|,
literal|"t,r,j"
argument_list|,
name|tempreg
argument_list|,
name|tempreg
argument_list|,
name|BFD_RELOC_LO16
argument_list|)
expr_stmt|;
name|relax_end
argument_list|()
expr_stmt|;
if|if
condition|(
name|breg
operator|!=
literal|0
condition|)
name|macro_build
argument_list|(
name|NULL
argument_list|,
name|ADDRESS_ADD_INSN
argument_list|,
literal|"d,v,t"
argument_list|,
name|tempreg
argument_list|,
name|tempreg
argument_list|,
name|breg
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|expr1
argument_list|,
name|s
argument_list|,
name|fmt
argument_list|,
name|treg
argument_list|,
name|BFD_RELOC_LO16
argument_list|,
name|tempreg
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mips_pic
operator|==
name|SVR4_PIC
operator|&&
operator|!
name|HAVE_NEWABI
condition|)
block|{
name|int
name|gpdelay
decl_stmt|;
comment|/* If this is a reference to an external symbol, we want 	       lui	$tempreg,<sym>		(BFD_RELOC_MIPS_GOT_HI16) 	       addu	$tempreg,$tempreg,$gp 	       lw	$tempreg,<sym>($tempreg) (BFD_RELOC_MIPS_GOT_LO16)<op>	$treg,0($tempreg) 	     Otherwise we want 	       lw	$tempreg,<sym>($gp)	(BFD_RELOC_MIPS_GOT16) 	       nop 	       addiu	$tempreg,$tempreg,<sym>	(BFD_RELOC_LO16)<op>	$treg,0($tempreg) 	     If there is a base register, we add it to $tempreg before 	     the<op>.  If there is a constant, we stick it in the<op> instruction.  We don't handle constants larger than 	     16 bits, because we have no way to load the upper 16 bits 	     (actually, we could handle them for the subset of cases 	     in which we are not using $at).  */
name|assert
argument_list|(
name|offset_expr
operator|.
name|X_op
operator|==
name|O_symbol
argument_list|)
expr_stmt|;
name|expr1
operator|.
name|X_add_number
operator|=
name|offset_expr
operator|.
name|X_add_number
expr_stmt|;
name|offset_expr
operator|.
name|X_add_number
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|expr1
operator|.
name|X_add_number
operator|<
operator|-
literal|0x8000
operator|||
name|expr1
operator|.
name|X_add_number
operator|>=
literal|0x8000
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"PIC code offset overflow (max 16 signed bits)"
argument_list|)
argument_list|)
expr_stmt|;
name|gpdelay
operator|=
name|reg_needs_delay
argument_list|(
name|mips_gp_register
argument_list|)
expr_stmt|;
name|relax_start
argument_list|(
name|offset_expr
operator|.
name|X_add_symbol
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
literal|"lui"
argument_list|,
literal|"t,u"
argument_list|,
name|tempreg
argument_list|,
name|BFD_RELOC_MIPS_GOT_HI16
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
name|ADDRESS_ADD_INSN
argument_list|,
literal|"d,v,t"
argument_list|,
name|tempreg
argument_list|,
name|tempreg
argument_list|,
name|mips_gp_register
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|ADDRESS_LOAD_INSN
argument_list|,
literal|"t,o(b)"
argument_list|,
name|tempreg
argument_list|,
name|BFD_RELOC_MIPS_GOT_LO16
argument_list|,
name|tempreg
argument_list|)
expr_stmt|;
name|relax_switch
argument_list|()
expr_stmt|;
if|if
condition|(
name|gpdelay
condition|)
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"nop"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|ADDRESS_LOAD_INSN
argument_list|,
literal|"t,o(b)"
argument_list|,
name|tempreg
argument_list|,
name|BFD_RELOC_MIPS_GOT16
argument_list|,
name|mips_gp_register
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"nop"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|ADDRESS_ADDI_INSN
argument_list|,
literal|"t,r,j"
argument_list|,
name|tempreg
argument_list|,
name|tempreg
argument_list|,
name|BFD_RELOC_LO16
argument_list|)
expr_stmt|;
name|relax_end
argument_list|()
expr_stmt|;
if|if
condition|(
name|breg
operator|!=
literal|0
condition|)
name|macro_build
argument_list|(
name|NULL
argument_list|,
name|ADDRESS_ADD_INSN
argument_list|,
literal|"d,v,t"
argument_list|,
name|tempreg
argument_list|,
name|tempreg
argument_list|,
name|breg
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|expr1
argument_list|,
name|s
argument_list|,
name|fmt
argument_list|,
name|treg
argument_list|,
name|BFD_RELOC_LO16
argument_list|,
name|tempreg
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mips_pic
operator|==
name|SVR4_PIC
operator|&&
name|HAVE_NEWABI
condition|)
block|{
comment|/* If this is a reference to an external symbol, we want 	       lui	$tempreg,<sym>		(BFD_RELOC_MIPS_GOT_HI16) 	       add	$tempreg,$tempreg,$gp 	       lw	$tempreg,<sym>($tempreg) (BFD_RELOC_MIPS_GOT_LO16)<op>	$treg,<ofst>($tempreg) 	     Otherwise, for local symbols, we want: 	       lw	$tempreg,<sym>($gp)	(BFD_RELOC_MIPS_GOT_PAGE)<op>	$treg,<sym>($tempreg)   (BFD_RELOC_MIPS_GOT_OFST)  */
name|assert
argument_list|(
name|offset_expr
operator|.
name|X_op
operator|==
name|O_symbol
argument_list|)
expr_stmt|;
name|expr1
operator|.
name|X_add_number
operator|=
name|offset_expr
operator|.
name|X_add_number
expr_stmt|;
name|offset_expr
operator|.
name|X_add_number
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|expr1
operator|.
name|X_add_number
operator|<
operator|-
literal|0x8000
operator|||
name|expr1
operator|.
name|X_add_number
operator|>=
literal|0x8000
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"PIC code offset overflow (max 16 signed bits)"
argument_list|)
argument_list|)
expr_stmt|;
name|relax_start
argument_list|(
name|offset_expr
operator|.
name|X_add_symbol
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
literal|"lui"
argument_list|,
literal|"t,u"
argument_list|,
name|tempreg
argument_list|,
name|BFD_RELOC_MIPS_GOT_HI16
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
name|ADDRESS_ADD_INSN
argument_list|,
literal|"d,v,t"
argument_list|,
name|tempreg
argument_list|,
name|tempreg
argument_list|,
name|mips_gp_register
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|ADDRESS_LOAD_INSN
argument_list|,
literal|"t,o(b)"
argument_list|,
name|tempreg
argument_list|,
name|BFD_RELOC_MIPS_GOT_LO16
argument_list|,
name|tempreg
argument_list|)
expr_stmt|;
if|if
condition|(
name|breg
operator|!=
literal|0
condition|)
name|macro_build
argument_list|(
name|NULL
argument_list|,
name|ADDRESS_ADD_INSN
argument_list|,
literal|"d,v,t"
argument_list|,
name|tempreg
argument_list|,
name|tempreg
argument_list|,
name|breg
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|expr1
argument_list|,
name|s
argument_list|,
name|fmt
argument_list|,
name|treg
argument_list|,
name|BFD_RELOC_LO16
argument_list|,
name|tempreg
argument_list|)
expr_stmt|;
name|relax_switch
argument_list|()
expr_stmt|;
name|offset_expr
operator|.
name|X_add_number
operator|=
name|expr1
operator|.
name|X_add_number
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|ADDRESS_LOAD_INSN
argument_list|,
literal|"t,o(b)"
argument_list|,
name|tempreg
argument_list|,
name|BFD_RELOC_MIPS_GOT_PAGE
argument_list|,
name|mips_gp_register
argument_list|)
expr_stmt|;
if|if
condition|(
name|breg
operator|!=
literal|0
condition|)
name|macro_build
argument_list|(
name|NULL
argument_list|,
name|ADDRESS_ADD_INSN
argument_list|,
literal|"d,v,t"
argument_list|,
name|tempreg
argument_list|,
name|tempreg
argument_list|,
name|breg
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|s
argument_list|,
name|fmt
argument_list|,
name|treg
argument_list|,
name|BFD_RELOC_MIPS_GOT_OFST
argument_list|,
name|tempreg
argument_list|)
expr_stmt|;
name|relax_end
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mips_pic
operator|==
name|EMBEDDED_PIC
condition|)
block|{
comment|/* If there is no base register, we want<op>	$treg,<sym>($gp)	(BFD_RELOC_GPREL16) 	     If there is a base register, we want 	       addu	$tempreg,$breg,$gp<op>	$treg,<sym>($tempreg)	(BFD_RELOC_GPREL16) 	     */
name|assert
argument_list|(
name|offset_expr
operator|.
name|X_op
operator|==
name|O_symbol
argument_list|)
expr_stmt|;
if|if
condition|(
name|breg
operator|==
literal|0
condition|)
block|{
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|s
argument_list|,
name|fmt
argument_list|,
name|treg
argument_list|,
name|BFD_RELOC_GPREL16
argument_list|,
name|mips_gp_register
argument_list|)
expr_stmt|;
name|used_at
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|macro_build
argument_list|(
name|NULL
argument_list|,
name|ADDRESS_ADD_INSN
argument_list|,
literal|"d,v,t"
argument_list|,
name|tempreg
argument_list|,
name|breg
argument_list|,
name|mips_gp_register
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|s
argument_list|,
name|fmt
argument_list|,
name|treg
argument_list|,
name|BFD_RELOC_GPREL16
argument_list|,
name|tempreg
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|used_at
condition|)
return|return;
break|break;
case|case
name|M_LI
case|:
case|case
name|M_LI_S
case|:
name|load_register
argument_list|(
name|treg
argument_list|,
operator|&
name|imm_expr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
case|case
name|M_DLI
case|:
name|load_register
argument_list|(
name|treg
argument_list|,
operator|&
name|imm_expr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
case|case
name|M_LI_SS
case|:
if|if
condition|(
name|imm_expr
operator|.
name|X_op
operator|==
name|O_constant
condition|)
block|{
name|load_register
argument_list|(
name|AT
argument_list|,
operator|&
name|imm_expr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"mtc1"
argument_list|,
literal|"t,G"
argument_list|,
name|AT
argument_list|,
name|treg
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
block|{
name|assert
argument_list|(
name|offset_expr
operator|.
name|X_op
operator|==
name|O_symbol
operator|&&
name|strcmp
argument_list|(
name|segment_name
argument_list|(
name|S_GET_SEGMENT
argument_list|(
name|offset_expr
operator|.
name|X_add_symbol
argument_list|)
argument_list|)
argument_list|,
literal|".lit4"
argument_list|)
operator|==
literal|0
operator|&&
name|offset_expr
operator|.
name|X_add_number
operator|==
literal|0
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
literal|"lwc1"
argument_list|,
literal|"T,o(b)"
argument_list|,
name|treg
argument_list|,
name|BFD_RELOC_MIPS_LITERAL
argument_list|,
name|mips_gp_register
argument_list|)
expr_stmt|;
return|return;
block|}
case|case
name|M_LI_D
case|:
comment|/* Check if we have a constant in IMM_EXPR.  If the GPRs are 64 bits          wide, IMM_EXPR is the entire value.  Otherwise IMM_EXPR is the high          order 32 bits of the value and the low order 32 bits are either          zero or in OFFSET_EXPR.  */
if|if
condition|(
name|imm_expr
operator|.
name|X_op
operator|==
name|O_constant
operator|||
name|imm_expr
operator|.
name|X_op
operator|==
name|O_big
condition|)
block|{
if|if
condition|(
name|HAVE_64BIT_GPRS
condition|)
name|load_register
argument_list|(
name|treg
argument_list|,
operator|&
name|imm_expr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
block|{
name|int
name|hreg
decl_stmt|,
name|lreg
decl_stmt|;
if|if
condition|(
name|target_big_endian
condition|)
block|{
name|hreg
operator|=
name|treg
expr_stmt|;
name|lreg
operator|=
name|treg
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
name|hreg
operator|=
name|treg
operator|+
literal|1
expr_stmt|;
name|lreg
operator|=
name|treg
expr_stmt|;
block|}
if|if
condition|(
name|hreg
operator|<=
literal|31
condition|)
name|load_register
argument_list|(
name|hreg
argument_list|,
operator|&
name|imm_expr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|lreg
operator|<=
literal|31
condition|)
block|{
if|if
condition|(
name|offset_expr
operator|.
name|X_op
operator|==
name|O_absent
condition|)
name|move_register
argument_list|(
name|lreg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
block|{
name|assert
argument_list|(
name|offset_expr
operator|.
name|X_op
operator|==
name|O_constant
argument_list|)
expr_stmt|;
name|load_register
argument_list|(
name|lreg
argument_list|,
operator|&
name|offset_expr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return;
block|}
comment|/* We know that sym is in the .rdata section.  First we get the 	 upper 16 bits of the address.  */
if|if
condition|(
name|mips_pic
operator|==
name|NO_PIC
condition|)
block|{
name|macro_build_lui
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|AT
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mips_pic
operator|==
name|SVR4_PIC
condition|)
block|{
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|ADDRESS_LOAD_INSN
argument_list|,
literal|"t,o(b)"
argument_list|,
name|AT
argument_list|,
name|BFD_RELOC_MIPS_GOT16
argument_list|,
name|mips_gp_register
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mips_pic
operator|==
name|EMBEDDED_PIC
condition|)
block|{
comment|/* For embedded PIC we pick up the entire address off $gp in 	     a single instruction.  */
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|ADDRESS_ADDI_INSN
argument_list|,
literal|"t,r,j"
argument_list|,
name|AT
argument_list|,
name|mips_gp_register
argument_list|,
name|BFD_RELOC_GPREL16
argument_list|)
expr_stmt|;
name|offset_expr
operator|.
name|X_op
operator|=
name|O_constant
expr_stmt|;
name|offset_expr
operator|.
name|X_add_number
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
comment|/* Now we load the register(s).  */
if|if
condition|(
name|HAVE_64BIT_GPRS
condition|)
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
literal|"ld"
argument_list|,
literal|"t,o(b)"
argument_list|,
name|treg
argument_list|,
name|BFD_RELOC_LO16
argument_list|,
name|AT
argument_list|)
expr_stmt|;
else|else
block|{
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
literal|"lw"
argument_list|,
literal|"t,o(b)"
argument_list|,
name|treg
argument_list|,
name|BFD_RELOC_LO16
argument_list|,
name|AT
argument_list|)
expr_stmt|;
if|if
condition|(
name|treg
operator|!=
name|RA
condition|)
block|{
comment|/* FIXME: How in the world do we deal with the possible 		 overflow here?  */
name|offset_expr
operator|.
name|X_add_number
operator|+=
literal|4
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
literal|"lw"
argument_list|,
literal|"t,o(b)"
argument_list|,
name|treg
operator|+
literal|1
argument_list|,
name|BFD_RELOC_LO16
argument_list|,
name|AT
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|M_LI_DD
case|:
comment|/* Check if we have a constant in IMM_EXPR.  If the FPRs are 64 bits          wide, IMM_EXPR is the entire value and the GPRs are known to be 64          bits wide as well.  Otherwise IMM_EXPR is the high order 32 bits of          the value and the low order 32 bits are either zero or in          OFFSET_EXPR.  */
if|if
condition|(
name|imm_expr
operator|.
name|X_op
operator|==
name|O_constant
operator|||
name|imm_expr
operator|.
name|X_op
operator|==
name|O_big
condition|)
block|{
name|load_register
argument_list|(
name|AT
argument_list|,
operator|&
name|imm_expr
argument_list|,
name|HAVE_64BIT_FPRS
argument_list|)
expr_stmt|;
if|if
condition|(
name|HAVE_64BIT_FPRS
condition|)
block|{
name|assert
argument_list|(
name|HAVE_64BIT_GPRS
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"dmtc1"
argument_list|,
literal|"t,S"
argument_list|,
name|AT
argument_list|,
name|treg
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"mtc1"
argument_list|,
literal|"t,G"
argument_list|,
name|AT
argument_list|,
name|treg
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset_expr
operator|.
name|X_op
operator|==
name|O_absent
condition|)
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"mtc1"
argument_list|,
literal|"t,G"
argument_list|,
literal|0
argument_list|,
name|treg
argument_list|)
expr_stmt|;
else|else
block|{
name|assert
argument_list|(
name|offset_expr
operator|.
name|X_op
operator|==
name|O_constant
argument_list|)
expr_stmt|;
name|load_register
argument_list|(
name|AT
argument_list|,
operator|&
name|offset_expr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"mtc1"
argument_list|,
literal|"t,G"
argument_list|,
name|AT
argument_list|,
name|treg
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
block|}
name|assert
argument_list|(
name|offset_expr
operator|.
name|X_op
operator|==
name|O_symbol
operator|&&
name|offset_expr
operator|.
name|X_add_number
operator|==
literal|0
argument_list|)
expr_stmt|;
name|s
operator|=
name|segment_name
argument_list|(
name|S_GET_SEGMENT
argument_list|(
name|offset_expr
operator|.
name|X_add_symbol
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|s
argument_list|,
literal|".lit8"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|mips_opts
operator|.
name|isa
operator|!=
name|ISA_MIPS1
condition|)
block|{
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
literal|"ldc1"
argument_list|,
literal|"T,o(b)"
argument_list|,
name|treg
argument_list|,
name|BFD_RELOC_MIPS_LITERAL
argument_list|,
name|mips_gp_register
argument_list|)
expr_stmt|;
return|return;
block|}
name|breg
operator|=
name|mips_gp_register
expr_stmt|;
name|r
operator|=
name|BFD_RELOC_MIPS_LITERAL
expr_stmt|;
goto|goto
name|dob
goto|;
block|}
else|else
block|{
name|assert
argument_list|(
name|strcmp
argument_list|(
name|s
argument_list|,
name|RDATA_SECTION_NAME
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|mips_pic
operator|==
name|SVR4_PIC
condition|)
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|ADDRESS_LOAD_INSN
argument_list|,
literal|"t,o(b)"
argument_list|,
name|AT
argument_list|,
name|BFD_RELOC_MIPS_GOT16
argument_list|,
name|mips_gp_register
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* FIXME: This won't work for a 64 bit address.  */
name|macro_build_lui
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|AT
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mips_opts
operator|.
name|isa
operator|!=
name|ISA_MIPS1
condition|)
block|{
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
literal|"ldc1"
argument_list|,
literal|"T,o(b)"
argument_list|,
name|treg
argument_list|,
name|BFD_RELOC_LO16
argument_list|,
name|AT
argument_list|)
expr_stmt|;
break|break;
block|}
name|breg
operator|=
name|AT
expr_stmt|;
name|r
operator|=
name|BFD_RELOC_LO16
expr_stmt|;
goto|goto
name|dob
goto|;
block|}
case|case
name|M_L_DOB
case|:
if|if
condition|(
name|mips_opts
operator|.
name|arch
operator|==
name|CPU_R4650
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"opcode not supported on this processor"
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Even on a big endian machine $fn comes before $fn+1.  We have 	 to adjust when loading from memory.  */
name|r
operator|=
name|BFD_RELOC_LO16
expr_stmt|;
name|dob
label|:
name|assert
argument_list|(
name|mips_opts
operator|.
name|isa
operator|==
name|ISA_MIPS1
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
literal|"lwc1"
argument_list|,
literal|"T,o(b)"
argument_list|,
name|target_big_endian
condition|?
name|treg
operator|+
literal|1
else|:
name|treg
argument_list|,
name|r
argument_list|,
name|breg
argument_list|)
expr_stmt|;
comment|/* FIXME: A possible overflow which I don't know how to deal 	 with.  */
name|offset_expr
operator|.
name|X_add_number
operator|+=
literal|4
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
literal|"lwc1"
argument_list|,
literal|"T,o(b)"
argument_list|,
name|target_big_endian
condition|?
name|treg
else|:
name|treg
operator|+
literal|1
argument_list|,
name|r
argument_list|,
name|breg
argument_list|)
expr_stmt|;
if|if
condition|(
name|breg
operator|!=
name|AT
condition|)
return|return;
break|break;
case|case
name|M_L_DAB
case|:
comment|/*        * The MIPS assembler seems to check for X_add_number not        * being double aligned and generating:        *	lui	at,%hi(foo+1)        *	addu	at,at,v1        *	addiu	at,at,%lo(foo+1)        *	lwc1	f2,0(at)        *	lwc1	f3,4(at)        * But, the resulting address is the same after relocation so why        * generate the extra instruction?        */
if|if
condition|(
name|mips_opts
operator|.
name|arch
operator|==
name|CPU_R4650
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"opcode not supported on this processor"
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Itbl support may require additional care here.  */
name|coproc
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|mips_opts
operator|.
name|isa
operator|!=
name|ISA_MIPS1
condition|)
block|{
name|s
operator|=
literal|"ldc1"
expr_stmt|;
goto|goto
name|ld
goto|;
block|}
name|s
operator|=
literal|"lwc1"
expr_stmt|;
name|fmt
operator|=
literal|"T,o(b)"
expr_stmt|;
goto|goto
name|ldd_std
goto|;
case|case
name|M_S_DAB
case|:
if|if
condition|(
name|mips_opts
operator|.
name|arch
operator|==
name|CPU_R4650
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"opcode not supported on this processor"
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|mips_opts
operator|.
name|isa
operator|!=
name|ISA_MIPS1
condition|)
block|{
name|s
operator|=
literal|"sdc1"
expr_stmt|;
goto|goto
name|st
goto|;
block|}
name|s
operator|=
literal|"swc1"
expr_stmt|;
name|fmt
operator|=
literal|"T,o(b)"
expr_stmt|;
comment|/* Itbl support may require additional care here.  */
name|coproc
operator|=
literal|1
expr_stmt|;
goto|goto
name|ldd_std
goto|;
case|case
name|M_LD_AB
case|:
if|if
condition|(
name|HAVE_64BIT_GPRS
condition|)
block|{
name|s
operator|=
literal|"ld"
expr_stmt|;
goto|goto
name|ld
goto|;
block|}
name|s
operator|=
literal|"lw"
expr_stmt|;
name|fmt
operator|=
literal|"t,o(b)"
expr_stmt|;
goto|goto
name|ldd_std
goto|;
case|case
name|M_SD_AB
case|:
if|if
condition|(
name|HAVE_64BIT_GPRS
condition|)
block|{
name|s
operator|=
literal|"sd"
expr_stmt|;
goto|goto
name|st
goto|;
block|}
name|s
operator|=
literal|"sw"
expr_stmt|;
name|fmt
operator|=
literal|"t,o(b)"
expr_stmt|;
name|ldd_std
label|:
comment|/* We do _not_ bother to allow embedded PIC (symbol-local_symbol) 	 loads for the case of doing a pair of loads to simulate an 'ld'. 	 This is not currently done by the compiler, and assembly coders 	 writing embedded-pic code can cope.  */
if|if
condition|(
name|offset_expr
operator|.
name|X_op
operator|!=
name|O_symbol
operator|&&
name|offset_expr
operator|.
name|X_op
operator|!=
name|O_constant
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"expression too complex"
argument_list|)
argument_list|)
expr_stmt|;
name|offset_expr
operator|.
name|X_op
operator|=
name|O_constant
expr_stmt|;
block|}
comment|/* Even on a big endian machine $fn comes before $fn+1.  We have 	 to adjust when loading from memory.  We set coproc if we must 	 load $fn+1 first.  */
comment|/* Itbl support may require additional care here.  */
if|if
condition|(
operator|!
name|target_big_endian
condition|)
name|coproc
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|mips_pic
operator|==
name|NO_PIC
operator|||
name|offset_expr
operator|.
name|X_op
operator|==
name|O_constant
condition|)
block|{
comment|/* If this is a reference to a GP relative symbol, we want<op>	$treg,<sym>($gp)	(BFD_RELOC_GPREL16)<op>	$treg+1,<sym>+4($gp)	(BFD_RELOC_GPREL16) 	     If we have a base register, we use this 	       addu	$at,$breg,$gp<op>	$treg,<sym>($at)	(BFD_RELOC_GPREL16)<op>	$treg+1,<sym>+4($at)	(BFD_RELOC_GPREL16) 	     If this is not a GP relative symbol, we want 	       lui	$at,<sym>		(BFD_RELOC_HI16_S)<op>	$treg,<sym>($at)	(BFD_RELOC_LO16)<op>	$treg+1,<sym>+4($at)	(BFD_RELOC_LO16) 	     If there is a base register, we add it to $at after the 	     lui instruction.  If there is a constant, we always use 	     the last case.  */
if|if
condition|(
operator|(
name|valueT
operator|)
name|offset_expr
operator|.
name|X_add_number
operator|>
name|MAX_GPREL_OFFSET
operator|||
name|nopic_need_relax
argument_list|(
name|offset_expr
operator|.
name|X_add_symbol
argument_list|,
literal|1
argument_list|)
condition|)
name|used_at
operator|=
literal|1
expr_stmt|;
else|else
block|{
name|relax_start
argument_list|(
name|offset_expr
operator|.
name|X_add_symbol
argument_list|)
expr_stmt|;
if|if
condition|(
name|breg
operator|==
literal|0
condition|)
block|{
name|tempreg
operator|=
name|mips_gp_register
expr_stmt|;
name|used_at
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|macro_build
argument_list|(
name|NULL
argument_list|,
name|ADDRESS_ADD_INSN
argument_list|,
literal|"d,v,t"
argument_list|,
name|AT
argument_list|,
name|breg
argument_list|,
name|mips_gp_register
argument_list|)
expr_stmt|;
name|tempreg
operator|=
name|AT
expr_stmt|;
name|used_at
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Itbl support may require additional care here.  */
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|s
argument_list|,
name|fmt
argument_list|,
name|coproc
condition|?
name|treg
operator|+
literal|1
else|:
name|treg
argument_list|,
name|BFD_RELOC_GPREL16
argument_list|,
name|tempreg
argument_list|)
expr_stmt|;
name|offset_expr
operator|.
name|X_add_number
operator|+=
literal|4
expr_stmt|;
comment|/* Set mips_optimize to 2 to avoid inserting an                  undesired nop.  */
name|hold_mips_optimize
operator|=
name|mips_optimize
expr_stmt|;
name|mips_optimize
operator|=
literal|2
expr_stmt|;
comment|/* Itbl support may require additional care here.  */
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|s
argument_list|,
name|fmt
argument_list|,
name|coproc
condition|?
name|treg
else|:
name|treg
operator|+
literal|1
argument_list|,
name|BFD_RELOC_GPREL16
argument_list|,
name|tempreg
argument_list|)
expr_stmt|;
name|mips_optimize
operator|=
name|hold_mips_optimize
expr_stmt|;
name|relax_switch
argument_list|()
expr_stmt|;
comment|/* We just generated two relocs.  When tc_gen_reloc 		 handles this case, it will skip the first reloc and 		 handle the second.  The second reloc already has an 		 extra addend of 4, which we added above.  We must 		 subtract it out, and then subtract another 4 to make 		 the first reloc come out right.  The second reloc 		 will come out right because we are going to add 4 to 		 offset_expr when we build its instruction below.  		 If we have a symbol, then we don't want to include 		 the offset, because it will wind up being included 		 when we generate the reloc.  */
if|if
condition|(
name|offset_expr
operator|.
name|X_op
operator|==
name|O_constant
condition|)
name|offset_expr
operator|.
name|X_add_number
operator|-=
literal|8
expr_stmt|;
else|else
block|{
name|offset_expr
operator|.
name|X_add_number
operator|=
operator|-
literal|4
expr_stmt|;
name|offset_expr
operator|.
name|X_op
operator|=
name|O_constant
expr_stmt|;
block|}
block|}
name|macro_build_lui
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|AT
argument_list|)
expr_stmt|;
if|if
condition|(
name|breg
operator|!=
literal|0
condition|)
name|macro_build
argument_list|(
name|NULL
argument_list|,
name|ADDRESS_ADD_INSN
argument_list|,
literal|"d,v,t"
argument_list|,
name|AT
argument_list|,
name|breg
argument_list|,
name|AT
argument_list|)
expr_stmt|;
comment|/* Itbl support may require additional care here.  */
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|s
argument_list|,
name|fmt
argument_list|,
name|coproc
condition|?
name|treg
operator|+
literal|1
else|:
name|treg
argument_list|,
name|BFD_RELOC_LO16
argument_list|,
name|AT
argument_list|)
expr_stmt|;
comment|/* FIXME: How do we handle overflow here?  */
name|offset_expr
operator|.
name|X_add_number
operator|+=
literal|4
expr_stmt|;
comment|/* Itbl support may require additional care here.  */
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|s
argument_list|,
name|fmt
argument_list|,
name|coproc
condition|?
name|treg
else|:
name|treg
operator|+
literal|1
argument_list|,
name|BFD_RELOC_LO16
argument_list|,
name|AT
argument_list|)
expr_stmt|;
if|if
condition|(
name|mips_relax
operator|.
name|sequence
condition|)
name|relax_end
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mips_pic
operator|==
name|SVR4_PIC
operator|&&
operator|!
name|mips_big_got
condition|)
block|{
comment|/* If this is a reference to an external symbol, we want 	       lw	$at,<sym>($gp)		(BFD_RELOC_MIPS_GOT16) 	       nop<op>	$treg,0($at)<op>	$treg+1,4($at) 	     Otherwise we want 	       lw	$at,<sym>($gp)		(BFD_RELOC_MIPS_GOT16) 	       nop<op>	$treg,<sym>($at)	(BFD_RELOC_LO16)<op>	$treg+1,<sym>+4($at)	(BFD_RELOC_LO16) 	     If there is a base register we add it to $at before the 	     lwc1 instructions.  If there is a constant we include it 	     in the lwc1 instructions.  */
name|used_at
operator|=
literal|1
expr_stmt|;
name|expr1
operator|.
name|X_add_number
operator|=
name|offset_expr
operator|.
name|X_add_number
expr_stmt|;
if|if
condition|(
name|expr1
operator|.
name|X_add_number
operator|<
operator|-
literal|0x8000
operator|||
name|expr1
operator|.
name|X_add_number
operator|>=
literal|0x8000
operator|-
literal|4
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"PIC code offset overflow (max 16 signed bits)"
argument_list|)
argument_list|)
expr_stmt|;
name|load_got_offset
argument_list|(
name|AT
argument_list|,
operator|&
name|offset_expr
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"nop"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|breg
operator|!=
literal|0
condition|)
name|macro_build
argument_list|(
name|NULL
argument_list|,
name|ADDRESS_ADD_INSN
argument_list|,
literal|"d,v,t"
argument_list|,
name|AT
argument_list|,
name|breg
argument_list|,
name|AT
argument_list|)
expr_stmt|;
comment|/* Set mips_optimize to 2 to avoid inserting an undesired              nop.  */
name|hold_mips_optimize
operator|=
name|mips_optimize
expr_stmt|;
name|mips_optimize
operator|=
literal|2
expr_stmt|;
comment|/* Itbl support may require additional care here.  */
name|relax_start
argument_list|(
name|offset_expr
operator|.
name|X_add_symbol
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|expr1
argument_list|,
name|s
argument_list|,
name|fmt
argument_list|,
name|coproc
condition|?
name|treg
operator|+
literal|1
else|:
name|treg
argument_list|,
name|BFD_RELOC_LO16
argument_list|,
name|AT
argument_list|)
expr_stmt|;
name|expr1
operator|.
name|X_add_number
operator|+=
literal|4
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|expr1
argument_list|,
name|s
argument_list|,
name|fmt
argument_list|,
name|coproc
condition|?
name|treg
else|:
name|treg
operator|+
literal|1
argument_list|,
name|BFD_RELOC_LO16
argument_list|,
name|AT
argument_list|)
expr_stmt|;
name|relax_switch
argument_list|()
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|s
argument_list|,
name|fmt
argument_list|,
name|coproc
condition|?
name|treg
operator|+
literal|1
else|:
name|treg
argument_list|,
name|BFD_RELOC_LO16
argument_list|,
name|AT
argument_list|)
expr_stmt|;
name|offset_expr
operator|.
name|X_add_number
operator|+=
literal|4
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|s
argument_list|,
name|fmt
argument_list|,
name|coproc
condition|?
name|treg
else|:
name|treg
operator|+
literal|1
argument_list|,
name|BFD_RELOC_LO16
argument_list|,
name|AT
argument_list|)
expr_stmt|;
name|relax_end
argument_list|()
expr_stmt|;
name|mips_optimize
operator|=
name|hold_mips_optimize
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mips_pic
operator|==
name|SVR4_PIC
condition|)
block|{
name|int
name|gpdelay
decl_stmt|;
comment|/* If this is a reference to an external symbol, we want 	       lui	$at,<sym>		(BFD_RELOC_MIPS_GOT_HI16) 	       addu	$at,$at,$gp 	       lw	$at,<sym>($at)		(BFD_RELOC_MIPS_GOT_LO16) 	       nop<op>	$treg,0($at)<op>	$treg+1,4($at) 	     Otherwise we want 	       lw	$at,<sym>($gp)		(BFD_RELOC_MIPS_GOT16) 	       nop<op>	$treg,<sym>($at)	(BFD_RELOC_LO16)<op>	$treg+1,<sym>+4($at)	(BFD_RELOC_LO16) 	     If there is a base register we add it to $at before the 	     lwc1 instructions.  If there is a constant we include it 	     in the lwc1 instructions.  */
name|used_at
operator|=
literal|1
expr_stmt|;
name|expr1
operator|.
name|X_add_number
operator|=
name|offset_expr
operator|.
name|X_add_number
expr_stmt|;
name|offset_expr
operator|.
name|X_add_number
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|expr1
operator|.
name|X_add_number
operator|<
operator|-
literal|0x8000
operator|||
name|expr1
operator|.
name|X_add_number
operator|>=
literal|0x8000
operator|-
literal|4
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"PIC code offset overflow (max 16 signed bits)"
argument_list|)
argument_list|)
expr_stmt|;
name|gpdelay
operator|=
name|reg_needs_delay
argument_list|(
name|mips_gp_register
argument_list|)
expr_stmt|;
name|relax_start
argument_list|(
name|offset_expr
operator|.
name|X_add_symbol
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
literal|"lui"
argument_list|,
literal|"t,u"
argument_list|,
name|AT
argument_list|,
name|BFD_RELOC_MIPS_GOT_HI16
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
name|ADDRESS_ADD_INSN
argument_list|,
literal|"d,v,t"
argument_list|,
name|AT
argument_list|,
name|AT
argument_list|,
name|mips_gp_register
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|ADDRESS_LOAD_INSN
argument_list|,
literal|"t,o(b)"
argument_list|,
name|AT
argument_list|,
name|BFD_RELOC_MIPS_GOT_LO16
argument_list|,
name|AT
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"nop"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|breg
operator|!=
literal|0
condition|)
name|macro_build
argument_list|(
name|NULL
argument_list|,
name|ADDRESS_ADD_INSN
argument_list|,
literal|"d,v,t"
argument_list|,
name|AT
argument_list|,
name|breg
argument_list|,
name|AT
argument_list|)
expr_stmt|;
comment|/* Itbl support may require additional care here.  */
name|macro_build
argument_list|(
operator|&
name|expr1
argument_list|,
name|s
argument_list|,
name|fmt
argument_list|,
name|coproc
condition|?
name|treg
operator|+
literal|1
else|:
name|treg
argument_list|,
name|BFD_RELOC_LO16
argument_list|,
name|AT
argument_list|)
expr_stmt|;
name|expr1
operator|.
name|X_add_number
operator|+=
literal|4
expr_stmt|;
comment|/* Set mips_optimize to 2 to avoid inserting an undesired              nop.  */
name|hold_mips_optimize
operator|=
name|mips_optimize
expr_stmt|;
name|mips_optimize
operator|=
literal|2
expr_stmt|;
comment|/* Itbl support may require additional care here.  */
name|macro_build
argument_list|(
operator|&
name|expr1
argument_list|,
name|s
argument_list|,
name|fmt
argument_list|,
name|coproc
condition|?
name|treg
else|:
name|treg
operator|+
literal|1
argument_list|,
name|BFD_RELOC_LO16
argument_list|,
name|AT
argument_list|)
expr_stmt|;
name|mips_optimize
operator|=
name|hold_mips_optimize
expr_stmt|;
name|expr1
operator|.
name|X_add_number
operator|-=
literal|4
expr_stmt|;
name|relax_switch
argument_list|()
expr_stmt|;
name|offset_expr
operator|.
name|X_add_number
operator|=
name|expr1
operator|.
name|X_add_number
expr_stmt|;
if|if
condition|(
name|gpdelay
condition|)
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"nop"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|ADDRESS_LOAD_INSN
argument_list|,
literal|"t,o(b)"
argument_list|,
name|AT
argument_list|,
name|BFD_RELOC_MIPS_GOT16
argument_list|,
name|mips_gp_register
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"nop"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|breg
operator|!=
literal|0
condition|)
name|macro_build
argument_list|(
name|NULL
argument_list|,
name|ADDRESS_ADD_INSN
argument_list|,
literal|"d,v,t"
argument_list|,
name|AT
argument_list|,
name|breg
argument_list|,
name|AT
argument_list|)
expr_stmt|;
comment|/* Itbl support may require additional care here.  */
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|s
argument_list|,
name|fmt
argument_list|,
name|coproc
condition|?
name|treg
operator|+
literal|1
else|:
name|treg
argument_list|,
name|BFD_RELOC_LO16
argument_list|,
name|AT
argument_list|)
expr_stmt|;
name|offset_expr
operator|.
name|X_add_number
operator|+=
literal|4
expr_stmt|;
comment|/* Set mips_optimize to 2 to avoid inserting an undesired              nop.  */
name|hold_mips_optimize
operator|=
name|mips_optimize
expr_stmt|;
name|mips_optimize
operator|=
literal|2
expr_stmt|;
comment|/* Itbl support may require additional care here.  */
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|s
argument_list|,
name|fmt
argument_list|,
name|coproc
condition|?
name|treg
else|:
name|treg
operator|+
literal|1
argument_list|,
name|BFD_RELOC_LO16
argument_list|,
name|AT
argument_list|)
expr_stmt|;
name|mips_optimize
operator|=
name|hold_mips_optimize
expr_stmt|;
name|relax_end
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mips_pic
operator|==
name|EMBEDDED_PIC
condition|)
block|{
comment|/* If there is no base register, we use<op>	$treg,<sym>($gp)	(BFD_RELOC_GPREL16)<op>	$treg+1,<sym>+4($gp)	(BFD_RELOC_GPREL16) 	     If we have a base register, we use 	       addu	$at,$breg,$gp<op>	$treg,<sym>($at)	(BFD_RELOC_GPREL16)<op>	$treg+1,<sym>+4($at)	(BFD_RELOC_GPREL16) 	     */
if|if
condition|(
name|breg
operator|==
literal|0
condition|)
block|{
name|tempreg
operator|=
name|mips_gp_register
expr_stmt|;
name|used_at
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|macro_build
argument_list|(
name|NULL
argument_list|,
name|ADDRESS_ADD_INSN
argument_list|,
literal|"d,v,t"
argument_list|,
name|AT
argument_list|,
name|breg
argument_list|,
name|mips_gp_register
argument_list|)
expr_stmt|;
name|tempreg
operator|=
name|AT
expr_stmt|;
name|used_at
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Itbl support may require additional care here.  */
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|s
argument_list|,
name|fmt
argument_list|,
name|coproc
condition|?
name|treg
operator|+
literal|1
else|:
name|treg
argument_list|,
name|BFD_RELOC_GPREL16
argument_list|,
name|tempreg
argument_list|)
expr_stmt|;
name|offset_expr
operator|.
name|X_add_number
operator|+=
literal|4
expr_stmt|;
comment|/* Itbl support may require additional care here.  */
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|s
argument_list|,
name|fmt
argument_list|,
name|coproc
condition|?
name|treg
else|:
name|treg
operator|+
literal|1
argument_list|,
name|BFD_RELOC_GPREL16
argument_list|,
name|tempreg
argument_list|)
expr_stmt|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|used_at
condition|)
return|return;
break|break;
case|case
name|M_LD_OB
case|:
name|s
operator|=
literal|"lw"
expr_stmt|;
goto|goto
name|sd_ob
goto|;
case|case
name|M_SD_OB
case|:
name|s
operator|=
literal|"sw"
expr_stmt|;
name|sd_ob
label|:
name|assert
argument_list|(
name|HAVE_32BIT_ADDRESSES
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|s
argument_list|,
literal|"t,o(b)"
argument_list|,
name|treg
argument_list|,
name|BFD_RELOC_LO16
argument_list|,
name|breg
argument_list|)
expr_stmt|;
name|offset_expr
operator|.
name|X_add_number
operator|+=
literal|4
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|s
argument_list|,
literal|"t,o(b)"
argument_list|,
name|treg
operator|+
literal|1
argument_list|,
name|BFD_RELOC_LO16
argument_list|,
name|breg
argument_list|)
expr_stmt|;
return|return;
comment|/* New code added to support COPZ instructions.       This code builds table entries out of the macros in mip_opcodes.       R4000 uses interlocks to handle coproc delays.       Other chips (like the R3000) require nops to be inserted for delays.        FIXME: Currently, we require that the user handle delays.       In order to fill delay slots for non-interlocked chips,       we must have a way to specify delays based on the coprocessor.       Eg. 4 cycles if load coproc reg from memory, 1 if in cache, etc.       What are the side-effects of the cop instruction?       What cache support might we have and what are its effects?       Both coprocessor& memory require delays. how long???       What registers are read/set/modified?        If an itbl is provided to interpret cop instructions,       this knowledge can be encoded in the itbl spec.  */
case|case
name|M_COP0
case|:
name|s
operator|=
literal|"c0"
expr_stmt|;
goto|goto
name|copz
goto|;
case|case
name|M_COP1
case|:
name|s
operator|=
literal|"c1"
expr_stmt|;
goto|goto
name|copz
goto|;
case|case
name|M_COP2
case|:
name|s
operator|=
literal|"c2"
expr_stmt|;
goto|goto
name|copz
goto|;
case|case
name|M_COP3
case|:
name|s
operator|=
literal|"c3"
expr_stmt|;
name|copz
label|:
comment|/* For now we just do C (same as Cz).  The parameter will be          stored in insn_opcode by mips_ip.  */
name|macro_build
argument_list|(
name|NULL
argument_list|,
name|s
argument_list|,
literal|"C"
argument_list|,
name|ip
operator|->
name|insn_opcode
argument_list|)
expr_stmt|;
return|return;
case|case
name|M_MOVE
case|:
name|move_register
argument_list|(
name|dreg
argument_list|,
name|sreg
argument_list|)
expr_stmt|;
return|return;
ifdef|#
directive|ifdef
name|LOSING_COMPILER
default|default:
comment|/* Try and see if this is a new itbl instruction.          This code builds table entries out of the macros in mip_opcodes.          FIXME: For now we just assemble the expression and pass it's          value along as a 32-bit immediate.          We may want to have the assembler assemble this value,          so that we gain the assembler's knowledge of delay slots,          symbols, etc.          Would it be more efficient to use mask (id) here? */
if|if
condition|(
name|itbl_have_entries
operator|&&
operator|(
name|immed_expr
operator|=
name|itbl_assemble
argument_list|(
name|ip
operator|->
name|insn_mo
operator|->
name|name
argument_list|,
literal|""
argument_list|)
operator|)
condition|)
block|{
name|s
operator|=
name|ip
operator|->
name|insn_mo
operator|->
name|name
expr_stmt|;
name|s2
operator|=
literal|"cop3"
expr_stmt|;
name|coproc
operator|=
name|ITBL_DECODE_PNUM
argument_list|(
name|immed_expr
argument_list|)
expr_stmt|;
empty_stmt|;
name|macro_build
argument_list|(
operator|&
name|immed_expr
argument_list|,
name|s
argument_list|,
literal|"C"
argument_list|)
expr_stmt|;
return|return;
block|}
name|macro2
argument_list|(
name|ip
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|mips_opts
operator|.
name|noat
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"Macro used $at after \".set noat\""
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|macro2
parameter_list|(
name|struct
name|mips_cl_insn
modifier|*
name|ip
parameter_list|)
block|{
specifier|register
name|int
name|treg
decl_stmt|,
name|sreg
decl_stmt|,
name|dreg
decl_stmt|,
name|breg
decl_stmt|;
name|int
name|tempreg
decl_stmt|;
name|int
name|mask
decl_stmt|;
name|int
name|used_at
decl_stmt|;
name|expressionS
name|expr1
decl_stmt|;
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
specifier|const
name|char
modifier|*
name|s2
decl_stmt|;
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
name|int
name|likely
init|=
literal|0
decl_stmt|;
name|int
name|dbl
init|=
literal|0
decl_stmt|;
name|int
name|coproc
init|=
literal|0
decl_stmt|;
name|int
name|lr
init|=
literal|0
decl_stmt|;
name|int
name|imm
init|=
literal|0
decl_stmt|;
name|int
name|off
decl_stmt|;
name|offsetT
name|maxnum
decl_stmt|;
name|bfd_reloc_code_real_type
name|r
decl_stmt|;
name|treg
operator|=
operator|(
name|ip
operator|->
name|insn_opcode
operator|>>
literal|16
operator|)
operator|&
literal|0x1f
expr_stmt|;
name|dreg
operator|=
operator|(
name|ip
operator|->
name|insn_opcode
operator|>>
literal|11
operator|)
operator|&
literal|0x1f
expr_stmt|;
name|sreg
operator|=
name|breg
operator|=
operator|(
name|ip
operator|->
name|insn_opcode
operator|>>
literal|21
operator|)
operator|&
literal|0x1f
expr_stmt|;
name|mask
operator|=
name|ip
operator|->
name|insn_mo
operator|->
name|mask
expr_stmt|;
name|expr1
operator|.
name|X_op
operator|=
name|O_constant
expr_stmt|;
name|expr1
operator|.
name|X_op_symbol
operator|=
name|NULL
expr_stmt|;
name|expr1
operator|.
name|X_add_symbol
operator|=
name|NULL
expr_stmt|;
name|expr1
operator|.
name|X_add_number
operator|=
literal|1
expr_stmt|;
switch|switch
condition|(
name|mask
condition|)
block|{
endif|#
directive|endif
comment|/* LOSING_COMPILER */
case|case
name|M_DMUL
case|:
name|dbl
operator|=
literal|1
expr_stmt|;
case|case
name|M_MUL
case|:
name|macro_build
argument_list|(
name|NULL
argument_list|,
name|dbl
condition|?
literal|"dmultu"
else|:
literal|"multu"
argument_list|,
literal|"s,t"
argument_list|,
name|sreg
argument_list|,
name|treg
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"mflo"
argument_list|,
literal|"d"
argument_list|,
name|dreg
argument_list|)
expr_stmt|;
return|return;
case|case
name|M_DMUL_I
case|:
name|dbl
operator|=
literal|1
expr_stmt|;
case|case
name|M_MUL_I
case|:
comment|/* The MIPS assembler some times generates shifts and adds.  I'm 	 not trying to be that fancy. GCC should do this for us 	 anyway.  */
name|load_register
argument_list|(
name|AT
argument_list|,
operator|&
name|imm_expr
argument_list|,
name|dbl
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
name|dbl
condition|?
literal|"dmult"
else|:
literal|"mult"
argument_list|,
literal|"s,t"
argument_list|,
name|sreg
argument_list|,
name|AT
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"mflo"
argument_list|,
literal|"d"
argument_list|,
name|dreg
argument_list|)
expr_stmt|;
break|break;
case|case
name|M_DMULO_I
case|:
name|dbl
operator|=
literal|1
expr_stmt|;
case|case
name|M_MULO_I
case|:
name|imm
operator|=
literal|1
expr_stmt|;
goto|goto
name|do_mulo
goto|;
case|case
name|M_DMULO
case|:
name|dbl
operator|=
literal|1
expr_stmt|;
case|case
name|M_MULO
case|:
name|do_mulo
label|:
name|mips_emit_delays
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
operator|++
name|mips_opts
operator|.
name|noreorder
expr_stmt|;
name|mips_any_noreorder
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|imm
condition|)
name|load_register
argument_list|(
name|AT
argument_list|,
operator|&
name|imm_expr
argument_list|,
name|dbl
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
name|dbl
condition|?
literal|"dmult"
else|:
literal|"mult"
argument_list|,
literal|"s,t"
argument_list|,
name|sreg
argument_list|,
name|imm
condition|?
name|AT
else|:
name|treg
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"mflo"
argument_list|,
literal|"d"
argument_list|,
name|dreg
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
name|dbl
condition|?
literal|"dsra32"
else|:
literal|"sra"
argument_list|,
literal|"d,w,<"
argument_list|,
name|dreg
argument_list|,
name|dreg
argument_list|,
name|RA
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"mfhi"
argument_list|,
literal|"d"
argument_list|,
name|AT
argument_list|)
expr_stmt|;
if|if
condition|(
name|mips_trap
condition|)
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"tne"
argument_list|,
literal|"s,t,q"
argument_list|,
name|dreg
argument_list|,
name|AT
argument_list|,
literal|6
argument_list|)
expr_stmt|;
else|else
block|{
name|expr1
operator|.
name|X_add_number
operator|=
literal|8
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|expr1
argument_list|,
literal|"beq"
argument_list|,
literal|"s,t,p"
argument_list|,
name|dreg
argument_list|,
name|AT
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"nop"
argument_list|,
literal|""
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"break"
argument_list|,
literal|"c"
argument_list|,
literal|6
argument_list|)
expr_stmt|;
block|}
operator|--
name|mips_opts
operator|.
name|noreorder
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"mflo"
argument_list|,
literal|"d"
argument_list|,
name|dreg
argument_list|)
expr_stmt|;
break|break;
case|case
name|M_DMULOU_I
case|:
name|dbl
operator|=
literal|1
expr_stmt|;
case|case
name|M_MULOU_I
case|:
name|imm
operator|=
literal|1
expr_stmt|;
goto|goto
name|do_mulou
goto|;
case|case
name|M_DMULOU
case|:
name|dbl
operator|=
literal|1
expr_stmt|;
case|case
name|M_MULOU
case|:
name|do_mulou
label|:
name|mips_emit_delays
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
operator|++
name|mips_opts
operator|.
name|noreorder
expr_stmt|;
name|mips_any_noreorder
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|imm
condition|)
name|load_register
argument_list|(
name|AT
argument_list|,
operator|&
name|imm_expr
argument_list|,
name|dbl
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
name|dbl
condition|?
literal|"dmultu"
else|:
literal|"multu"
argument_list|,
literal|"s,t"
argument_list|,
name|sreg
argument_list|,
name|imm
condition|?
name|AT
else|:
name|treg
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"mfhi"
argument_list|,
literal|"d"
argument_list|,
name|AT
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"mflo"
argument_list|,
literal|"d"
argument_list|,
name|dreg
argument_list|)
expr_stmt|;
if|if
condition|(
name|mips_trap
condition|)
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"tne"
argument_list|,
literal|"s,t,q"
argument_list|,
name|AT
argument_list|,
literal|0
argument_list|,
literal|6
argument_list|)
expr_stmt|;
else|else
block|{
name|expr1
operator|.
name|X_add_number
operator|=
literal|8
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|expr1
argument_list|,
literal|"beq"
argument_list|,
literal|"s,t,p"
argument_list|,
name|AT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"nop"
argument_list|,
literal|""
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"break"
argument_list|,
literal|"c"
argument_list|,
literal|6
argument_list|)
expr_stmt|;
block|}
operator|--
name|mips_opts
operator|.
name|noreorder
expr_stmt|;
break|break;
case|case
name|M_DROL
case|:
if|if
condition|(
name|ISA_HAS_DROR
argument_list|(
name|mips_opts
operator|.
name|isa
argument_list|)
operator|||
name|CPU_HAS_DROR
argument_list|(
name|mips_opts
operator|.
name|arch
argument_list|)
condition|)
block|{
if|if
condition|(
name|dreg
operator|==
name|sreg
condition|)
block|{
name|tempreg
operator|=
name|AT
expr_stmt|;
name|used_at
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|tempreg
operator|=
name|dreg
expr_stmt|;
name|used_at
operator|=
literal|0
expr_stmt|;
block|}
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"dnegu"
argument_list|,
literal|"d,w"
argument_list|,
name|tempreg
argument_list|,
name|treg
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"drorv"
argument_list|,
literal|"d,t,s"
argument_list|,
name|dreg
argument_list|,
name|sreg
argument_list|,
name|tempreg
argument_list|)
expr_stmt|;
if|if
condition|(
name|used_at
condition|)
break|break;
return|return;
block|}
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"dsubu"
argument_list|,
literal|"d,v,t"
argument_list|,
name|AT
argument_list|,
literal|0
argument_list|,
name|treg
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"dsrlv"
argument_list|,
literal|"d,t,s"
argument_list|,
name|AT
argument_list|,
name|sreg
argument_list|,
name|AT
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"dsllv"
argument_list|,
literal|"d,t,s"
argument_list|,
name|dreg
argument_list|,
name|sreg
argument_list|,
name|treg
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"or"
argument_list|,
literal|"d,v,t"
argument_list|,
name|dreg
argument_list|,
name|dreg
argument_list|,
name|AT
argument_list|)
expr_stmt|;
break|break;
case|case
name|M_ROL
case|:
if|if
condition|(
name|ISA_HAS_ROR
argument_list|(
name|mips_opts
operator|.
name|isa
argument_list|)
operator|||
name|CPU_HAS_ROR
argument_list|(
name|mips_opts
operator|.
name|arch
argument_list|)
condition|)
block|{
if|if
condition|(
name|dreg
operator|==
name|sreg
condition|)
block|{
name|tempreg
operator|=
name|AT
expr_stmt|;
name|used_at
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|tempreg
operator|=
name|dreg
expr_stmt|;
name|used_at
operator|=
literal|0
expr_stmt|;
block|}
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"negu"
argument_list|,
literal|"d,w"
argument_list|,
name|tempreg
argument_list|,
name|treg
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"rorv"
argument_list|,
literal|"d,t,s"
argument_list|,
name|dreg
argument_list|,
name|sreg
argument_list|,
name|tempreg
argument_list|)
expr_stmt|;
if|if
condition|(
name|used_at
condition|)
break|break;
return|return;
block|}
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"subu"
argument_list|,
literal|"d,v,t"
argument_list|,
name|AT
argument_list|,
literal|0
argument_list|,
name|treg
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"srlv"
argument_list|,
literal|"d,t,s"
argument_list|,
name|AT
argument_list|,
name|sreg
argument_list|,
name|AT
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"sllv"
argument_list|,
literal|"d,t,s"
argument_list|,
name|dreg
argument_list|,
name|sreg
argument_list|,
name|treg
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"or"
argument_list|,
literal|"d,v,t"
argument_list|,
name|dreg
argument_list|,
name|dreg
argument_list|,
name|AT
argument_list|)
expr_stmt|;
break|break;
case|case
name|M_DROL_I
case|:
block|{
name|unsigned
name|int
name|rot
decl_stmt|;
name|char
modifier|*
name|l
decl_stmt|,
modifier|*
name|r
decl_stmt|;
if|if
condition|(
name|imm_expr
operator|.
name|X_op
operator|!=
name|O_constant
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Improper rotate count"
argument_list|)
argument_list|)
expr_stmt|;
name|rot
operator|=
name|imm_expr
operator|.
name|X_add_number
operator|&
literal|0x3f
expr_stmt|;
if|if
condition|(
name|ISA_HAS_DROR
argument_list|(
name|mips_opts
operator|.
name|isa
argument_list|)
operator|||
name|CPU_HAS_DROR
argument_list|(
name|mips_opts
operator|.
name|arch
argument_list|)
condition|)
block|{
name|rot
operator|=
operator|(
literal|64
operator|-
name|rot
operator|)
operator|&
literal|0x3f
expr_stmt|;
if|if
condition|(
name|rot
operator|>=
literal|32
condition|)
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"dror32"
argument_list|,
literal|"d,w,<"
argument_list|,
name|dreg
argument_list|,
name|sreg
argument_list|,
name|rot
operator|-
literal|32
argument_list|)
expr_stmt|;
else|else
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"dror"
argument_list|,
literal|"d,w,<"
argument_list|,
name|dreg
argument_list|,
name|sreg
argument_list|,
name|rot
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|rot
operator|==
literal|0
condition|)
block|{
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"dsrl"
argument_list|,
literal|"d,w,<"
argument_list|,
name|dreg
argument_list|,
name|sreg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
name|l
operator|=
operator|(
name|rot
operator|<
literal|0x20
operator|)
condition|?
literal|"dsll"
else|:
literal|"dsll32"
expr_stmt|;
name|r
operator|=
operator|(
operator|(
literal|0x40
operator|-
name|rot
operator|)
operator|<
literal|0x20
operator|)
condition|?
literal|"dsrl"
else|:
literal|"dsrl32"
expr_stmt|;
name|rot
operator|&=
literal|0x1f
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
name|l
argument_list|,
literal|"d,w,<"
argument_list|,
name|AT
argument_list|,
name|sreg
argument_list|,
name|rot
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
name|r
argument_list|,
literal|"d,w,<"
argument_list|,
name|dreg
argument_list|,
name|sreg
argument_list|,
operator|(
literal|0x20
operator|-
name|rot
operator|)
operator|&
literal|0x1f
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"or"
argument_list|,
literal|"d,v,t"
argument_list|,
name|dreg
argument_list|,
name|dreg
argument_list|,
name|AT
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|M_ROL_I
case|:
block|{
name|unsigned
name|int
name|rot
decl_stmt|;
if|if
condition|(
name|imm_expr
operator|.
name|X_op
operator|!=
name|O_constant
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Improper rotate count"
argument_list|)
argument_list|)
expr_stmt|;
name|rot
operator|=
name|imm_expr
operator|.
name|X_add_number
operator|&
literal|0x1f
expr_stmt|;
if|if
condition|(
name|ISA_HAS_ROR
argument_list|(
name|mips_opts
operator|.
name|isa
argument_list|)
operator|||
name|CPU_HAS_ROR
argument_list|(
name|mips_opts
operator|.
name|arch
argument_list|)
condition|)
block|{
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"ror"
argument_list|,
literal|"d,w,<"
argument_list|,
name|dreg
argument_list|,
name|sreg
argument_list|,
operator|(
literal|32
operator|-
name|rot
operator|)
operator|&
literal|0x1f
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|rot
operator|==
literal|0
condition|)
block|{
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"srl"
argument_list|,
literal|"d,w,<"
argument_list|,
name|dreg
argument_list|,
name|sreg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"sll"
argument_list|,
literal|"d,w,<"
argument_list|,
name|AT
argument_list|,
name|sreg
argument_list|,
name|rot
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"srl"
argument_list|,
literal|"d,w,<"
argument_list|,
name|dreg
argument_list|,
name|sreg
argument_list|,
operator|(
literal|0x20
operator|-
name|rot
operator|)
operator|&
literal|0x1f
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"or"
argument_list|,
literal|"d,v,t"
argument_list|,
name|dreg
argument_list|,
name|dreg
argument_list|,
name|AT
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|M_DROR
case|:
if|if
condition|(
name|ISA_HAS_DROR
argument_list|(
name|mips_opts
operator|.
name|isa
argument_list|)
operator|||
name|CPU_HAS_DROR
argument_list|(
name|mips_opts
operator|.
name|arch
argument_list|)
condition|)
block|{
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"drorv"
argument_list|,
literal|"d,t,s"
argument_list|,
name|dreg
argument_list|,
name|sreg
argument_list|,
name|treg
argument_list|)
expr_stmt|;
return|return;
block|}
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"dsubu"
argument_list|,
literal|"d,v,t"
argument_list|,
name|AT
argument_list|,
literal|0
argument_list|,
name|treg
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"dsllv"
argument_list|,
literal|"d,t,s"
argument_list|,
name|AT
argument_list|,
name|sreg
argument_list|,
name|AT
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"dsrlv"
argument_list|,
literal|"d,t,s"
argument_list|,
name|dreg
argument_list|,
name|sreg
argument_list|,
name|treg
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"or"
argument_list|,
literal|"d,v,t"
argument_list|,
name|dreg
argument_list|,
name|dreg
argument_list|,
name|AT
argument_list|)
expr_stmt|;
break|break;
case|case
name|M_ROR
case|:
if|if
condition|(
name|ISA_HAS_ROR
argument_list|(
name|mips_opts
operator|.
name|isa
argument_list|)
operator|||
name|CPU_HAS_ROR
argument_list|(
name|mips_opts
operator|.
name|arch
argument_list|)
condition|)
block|{
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"rorv"
argument_list|,
literal|"d,t,s"
argument_list|,
name|dreg
argument_list|,
name|sreg
argument_list|,
name|treg
argument_list|)
expr_stmt|;
return|return;
block|}
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"subu"
argument_list|,
literal|"d,v,t"
argument_list|,
name|AT
argument_list|,
literal|0
argument_list|,
name|treg
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"sllv"
argument_list|,
literal|"d,t,s"
argument_list|,
name|AT
argument_list|,
name|sreg
argument_list|,
name|AT
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"srlv"
argument_list|,
literal|"d,t,s"
argument_list|,
name|dreg
argument_list|,
name|sreg
argument_list|,
name|treg
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"or"
argument_list|,
literal|"d,v,t"
argument_list|,
name|dreg
argument_list|,
name|dreg
argument_list|,
name|AT
argument_list|)
expr_stmt|;
break|break;
case|case
name|M_DROR_I
case|:
block|{
name|unsigned
name|int
name|rot
decl_stmt|;
name|char
modifier|*
name|l
decl_stmt|,
modifier|*
name|r
decl_stmt|;
if|if
condition|(
name|imm_expr
operator|.
name|X_op
operator|!=
name|O_constant
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Improper rotate count"
argument_list|)
argument_list|)
expr_stmt|;
name|rot
operator|=
name|imm_expr
operator|.
name|X_add_number
operator|&
literal|0x3f
expr_stmt|;
if|if
condition|(
name|ISA_HAS_DROR
argument_list|(
name|mips_opts
operator|.
name|isa
argument_list|)
operator|||
name|CPU_HAS_DROR
argument_list|(
name|mips_opts
operator|.
name|arch
argument_list|)
condition|)
block|{
if|if
condition|(
name|rot
operator|>=
literal|32
condition|)
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"dror32"
argument_list|,
literal|"d,w,<"
argument_list|,
name|dreg
argument_list|,
name|sreg
argument_list|,
name|rot
operator|-
literal|32
argument_list|)
expr_stmt|;
else|else
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"dror"
argument_list|,
literal|"d,w,<"
argument_list|,
name|dreg
argument_list|,
name|sreg
argument_list|,
name|rot
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|rot
operator|==
literal|0
condition|)
block|{
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"dsrl"
argument_list|,
literal|"d,w,<"
argument_list|,
name|dreg
argument_list|,
name|sreg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
name|r
operator|=
operator|(
name|rot
operator|<
literal|0x20
operator|)
condition|?
literal|"dsrl"
else|:
literal|"dsrl32"
expr_stmt|;
name|l
operator|=
operator|(
operator|(
literal|0x40
operator|-
name|rot
operator|)
operator|<
literal|0x20
operator|)
condition|?
literal|"dsll"
else|:
literal|"dsll32"
expr_stmt|;
name|rot
operator|&=
literal|0x1f
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
name|r
argument_list|,
literal|"d,w,<"
argument_list|,
name|AT
argument_list|,
name|sreg
argument_list|,
name|rot
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
name|l
argument_list|,
literal|"d,w,<"
argument_list|,
name|dreg
argument_list|,
name|sreg
argument_list|,
operator|(
literal|0x20
operator|-
name|rot
operator|)
operator|&
literal|0x1f
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"or"
argument_list|,
literal|"d,v,t"
argument_list|,
name|dreg
argument_list|,
name|dreg
argument_list|,
name|AT
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|M_ROR_I
case|:
block|{
name|unsigned
name|int
name|rot
decl_stmt|;
if|if
condition|(
name|imm_expr
operator|.
name|X_op
operator|!=
name|O_constant
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Improper rotate count"
argument_list|)
argument_list|)
expr_stmt|;
name|rot
operator|=
name|imm_expr
operator|.
name|X_add_number
operator|&
literal|0x1f
expr_stmt|;
if|if
condition|(
name|ISA_HAS_ROR
argument_list|(
name|mips_opts
operator|.
name|isa
argument_list|)
operator|||
name|CPU_HAS_ROR
argument_list|(
name|mips_opts
operator|.
name|arch
argument_list|)
condition|)
block|{
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"ror"
argument_list|,
literal|"d,w,<"
argument_list|,
name|dreg
argument_list|,
name|sreg
argument_list|,
name|rot
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|rot
operator|==
literal|0
condition|)
block|{
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"srl"
argument_list|,
literal|"d,w,<"
argument_list|,
name|dreg
argument_list|,
name|sreg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"srl"
argument_list|,
literal|"d,w,<"
argument_list|,
name|AT
argument_list|,
name|sreg
argument_list|,
name|rot
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"sll"
argument_list|,
literal|"d,w,<"
argument_list|,
name|dreg
argument_list|,
name|sreg
argument_list|,
operator|(
literal|0x20
operator|-
name|rot
operator|)
operator|&
literal|0x1f
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"or"
argument_list|,
literal|"d,v,t"
argument_list|,
name|dreg
argument_list|,
name|dreg
argument_list|,
name|AT
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|M_S_DOB
case|:
if|if
condition|(
name|mips_opts
operator|.
name|arch
operator|==
name|CPU_R4650
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"opcode not supported on this processor"
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|assert
argument_list|(
name|mips_opts
operator|.
name|isa
operator|==
name|ISA_MIPS1
argument_list|)
expr_stmt|;
comment|/* Even on a big endian machine $fn comes before $fn+1.  We have 	 to adjust when storing to memory.  */
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
literal|"swc1"
argument_list|,
literal|"T,o(b)"
argument_list|,
name|target_big_endian
condition|?
name|treg
operator|+
literal|1
else|:
name|treg
argument_list|,
name|BFD_RELOC_LO16
argument_list|,
name|breg
argument_list|)
expr_stmt|;
name|offset_expr
operator|.
name|X_add_number
operator|+=
literal|4
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
literal|"swc1"
argument_list|,
literal|"T,o(b)"
argument_list|,
name|target_big_endian
condition|?
name|treg
else|:
name|treg
operator|+
literal|1
argument_list|,
name|BFD_RELOC_LO16
argument_list|,
name|breg
argument_list|)
expr_stmt|;
return|return;
case|case
name|M_SEQ
case|:
if|if
condition|(
name|sreg
operator|==
literal|0
condition|)
name|macro_build
argument_list|(
operator|&
name|expr1
argument_list|,
literal|"sltiu"
argument_list|,
literal|"t,r,j"
argument_list|,
name|dreg
argument_list|,
name|treg
argument_list|,
name|BFD_RELOC_LO16
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|treg
operator|==
literal|0
condition|)
name|macro_build
argument_list|(
operator|&
name|expr1
argument_list|,
literal|"sltiu"
argument_list|,
literal|"t,r,j"
argument_list|,
name|dreg
argument_list|,
name|sreg
argument_list|,
name|BFD_RELOC_LO16
argument_list|)
expr_stmt|;
else|else
block|{
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"xor"
argument_list|,
literal|"d,v,t"
argument_list|,
name|dreg
argument_list|,
name|sreg
argument_list|,
name|treg
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|expr1
argument_list|,
literal|"sltiu"
argument_list|,
literal|"t,r,j"
argument_list|,
name|dreg
argument_list|,
name|dreg
argument_list|,
name|BFD_RELOC_LO16
argument_list|)
expr_stmt|;
block|}
return|return;
case|case
name|M_SEQ_I
case|:
if|if
condition|(
name|imm_expr
operator|.
name|X_op
operator|==
name|O_constant
operator|&&
name|imm_expr
operator|.
name|X_add_number
operator|==
literal|0
condition|)
block|{
name|macro_build
argument_list|(
operator|&
name|expr1
argument_list|,
literal|"sltiu"
argument_list|,
literal|"t,r,j"
argument_list|,
name|dreg
argument_list|,
name|sreg
argument_list|,
name|BFD_RELOC_LO16
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|sreg
operator|==
literal|0
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"Instruction %s: result is always false"
argument_list|)
argument_list|,
name|ip
operator|->
name|insn_mo
operator|->
name|name
argument_list|)
expr_stmt|;
name|move_register
argument_list|(
name|dreg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|imm_expr
operator|.
name|X_op
operator|==
name|O_constant
operator|&&
name|imm_expr
operator|.
name|X_add_number
operator|>=
literal|0
operator|&&
name|imm_expr
operator|.
name|X_add_number
operator|<
literal|0x10000
condition|)
block|{
name|macro_build
argument_list|(
operator|&
name|imm_expr
argument_list|,
literal|"xori"
argument_list|,
literal|"t,r,i"
argument_list|,
name|dreg
argument_list|,
name|sreg
argument_list|,
name|BFD_RELOC_LO16
argument_list|)
expr_stmt|;
name|used_at
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|imm_expr
operator|.
name|X_op
operator|==
name|O_constant
operator|&&
name|imm_expr
operator|.
name|X_add_number
operator|>
operator|-
literal|0x8000
operator|&&
name|imm_expr
operator|.
name|X_add_number
operator|<
literal|0
condition|)
block|{
name|imm_expr
operator|.
name|X_add_number
operator|=
operator|-
name|imm_expr
operator|.
name|X_add_number
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|imm_expr
argument_list|,
name|HAVE_32BIT_GPRS
condition|?
literal|"addiu"
else|:
literal|"daddiu"
argument_list|,
literal|"t,r,j"
argument_list|,
name|dreg
argument_list|,
name|sreg
argument_list|,
name|BFD_RELOC_LO16
argument_list|)
expr_stmt|;
name|used_at
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|load_register
argument_list|(
name|AT
argument_list|,
operator|&
name|imm_expr
argument_list|,
name|HAVE_64BIT_GPRS
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"xor"
argument_list|,
literal|"d,v,t"
argument_list|,
name|dreg
argument_list|,
name|sreg
argument_list|,
name|AT
argument_list|)
expr_stmt|;
name|used_at
operator|=
literal|1
expr_stmt|;
block|}
name|macro_build
argument_list|(
operator|&
name|expr1
argument_list|,
literal|"sltiu"
argument_list|,
literal|"t,r,j"
argument_list|,
name|dreg
argument_list|,
name|dreg
argument_list|,
name|BFD_RELOC_LO16
argument_list|)
expr_stmt|;
if|if
condition|(
name|used_at
condition|)
break|break;
return|return;
case|case
name|M_SGE
case|:
comment|/* sreg>= treg<==> not (sreg< treg) */
name|s
operator|=
literal|"slt"
expr_stmt|;
goto|goto
name|sge
goto|;
case|case
name|M_SGEU
case|:
name|s
operator|=
literal|"sltu"
expr_stmt|;
name|sge
label|:
name|macro_build
argument_list|(
name|NULL
argument_list|,
name|s
argument_list|,
literal|"d,v,t"
argument_list|,
name|dreg
argument_list|,
name|sreg
argument_list|,
name|treg
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|expr1
argument_list|,
literal|"xori"
argument_list|,
literal|"t,r,i"
argument_list|,
name|dreg
argument_list|,
name|dreg
argument_list|,
name|BFD_RELOC_LO16
argument_list|)
expr_stmt|;
return|return;
case|case
name|M_SGE_I
case|:
comment|/* sreg>= I<==> not (sreg< I) */
case|case
name|M_SGEU_I
case|:
if|if
condition|(
name|imm_expr
operator|.
name|X_op
operator|==
name|O_constant
operator|&&
name|imm_expr
operator|.
name|X_add_number
operator|>=
operator|-
literal|0x8000
operator|&&
name|imm_expr
operator|.
name|X_add_number
operator|<
literal|0x8000
condition|)
block|{
name|macro_build
argument_list|(
operator|&
name|imm_expr
argument_list|,
name|mask
operator|==
name|M_SGE_I
condition|?
literal|"slti"
else|:
literal|"sltiu"
argument_list|,
literal|"t,r,j"
argument_list|,
name|dreg
argument_list|,
name|sreg
argument_list|,
name|BFD_RELOC_LO16
argument_list|)
expr_stmt|;
name|used_at
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|load_register
argument_list|(
name|AT
argument_list|,
operator|&
name|imm_expr
argument_list|,
name|HAVE_64BIT_GPRS
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
name|mask
operator|==
name|M_SGE_I
condition|?
literal|"slt"
else|:
literal|"sltu"
argument_list|,
literal|"d,v,t"
argument_list|,
name|dreg
argument_list|,
name|sreg
argument_list|,
name|AT
argument_list|)
expr_stmt|;
name|used_at
operator|=
literal|1
expr_stmt|;
block|}
name|macro_build
argument_list|(
operator|&
name|expr1
argument_list|,
literal|"xori"
argument_list|,
literal|"t,r,i"
argument_list|,
name|dreg
argument_list|,
name|dreg
argument_list|,
name|BFD_RELOC_LO16
argument_list|)
expr_stmt|;
if|if
condition|(
name|used_at
condition|)
break|break;
return|return;
case|case
name|M_SGT
case|:
comment|/* sreg> treg<==>  treg< sreg */
name|s
operator|=
literal|"slt"
expr_stmt|;
goto|goto
name|sgt
goto|;
case|case
name|M_SGTU
case|:
name|s
operator|=
literal|"sltu"
expr_stmt|;
name|sgt
label|:
name|macro_build
argument_list|(
name|NULL
argument_list|,
name|s
argument_list|,
literal|"d,v,t"
argument_list|,
name|dreg
argument_list|,
name|treg
argument_list|,
name|sreg
argument_list|)
expr_stmt|;
return|return;
case|case
name|M_SGT_I
case|:
comment|/* sreg> I<==>  I< sreg */
name|s
operator|=
literal|"slt"
expr_stmt|;
goto|goto
name|sgti
goto|;
case|case
name|M_SGTU_I
case|:
name|s
operator|=
literal|"sltu"
expr_stmt|;
name|sgti
label|:
name|load_register
argument_list|(
name|AT
argument_list|,
operator|&
name|imm_expr
argument_list|,
name|HAVE_64BIT_GPRS
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
name|s
argument_list|,
literal|"d,v,t"
argument_list|,
name|dreg
argument_list|,
name|AT
argument_list|,
name|sreg
argument_list|)
expr_stmt|;
break|break;
case|case
name|M_SLE
case|:
comment|/* sreg<= treg<==>  treg>= sreg<==>  not (treg< sreg) */
name|s
operator|=
literal|"slt"
expr_stmt|;
goto|goto
name|sle
goto|;
case|case
name|M_SLEU
case|:
name|s
operator|=
literal|"sltu"
expr_stmt|;
name|sle
label|:
name|macro_build
argument_list|(
name|NULL
argument_list|,
name|s
argument_list|,
literal|"d,v,t"
argument_list|,
name|dreg
argument_list|,
name|treg
argument_list|,
name|sreg
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|expr1
argument_list|,
literal|"xori"
argument_list|,
literal|"t,r,i"
argument_list|,
name|dreg
argument_list|,
name|dreg
argument_list|,
name|BFD_RELOC_LO16
argument_list|)
expr_stmt|;
return|return;
case|case
name|M_SLE_I
case|:
comment|/* sreg<= I<==> I>= sreg<==> not (I< sreg) */
name|s
operator|=
literal|"slt"
expr_stmt|;
goto|goto
name|slei
goto|;
case|case
name|M_SLEU_I
case|:
name|s
operator|=
literal|"sltu"
expr_stmt|;
name|slei
label|:
name|load_register
argument_list|(
name|AT
argument_list|,
operator|&
name|imm_expr
argument_list|,
name|HAVE_64BIT_GPRS
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
name|s
argument_list|,
literal|"d,v,t"
argument_list|,
name|dreg
argument_list|,
name|AT
argument_list|,
name|sreg
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|expr1
argument_list|,
literal|"xori"
argument_list|,
literal|"t,r,i"
argument_list|,
name|dreg
argument_list|,
name|dreg
argument_list|,
name|BFD_RELOC_LO16
argument_list|)
expr_stmt|;
break|break;
case|case
name|M_SLT_I
case|:
if|if
condition|(
name|imm_expr
operator|.
name|X_op
operator|==
name|O_constant
operator|&&
name|imm_expr
operator|.
name|X_add_number
operator|>=
operator|-
literal|0x8000
operator|&&
name|imm_expr
operator|.
name|X_add_number
operator|<
literal|0x8000
condition|)
block|{
name|macro_build
argument_list|(
operator|&
name|imm_expr
argument_list|,
literal|"slti"
argument_list|,
literal|"t,r,j"
argument_list|,
name|dreg
argument_list|,
name|sreg
argument_list|,
name|BFD_RELOC_LO16
argument_list|)
expr_stmt|;
return|return;
block|}
name|load_register
argument_list|(
name|AT
argument_list|,
operator|&
name|imm_expr
argument_list|,
name|HAVE_64BIT_GPRS
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"slt"
argument_list|,
literal|"d,v,t"
argument_list|,
name|dreg
argument_list|,
name|sreg
argument_list|,
name|AT
argument_list|)
expr_stmt|;
break|break;
case|case
name|M_SLTU_I
case|:
if|if
condition|(
name|imm_expr
operator|.
name|X_op
operator|==
name|O_constant
operator|&&
name|imm_expr
operator|.
name|X_add_number
operator|>=
operator|-
literal|0x8000
operator|&&
name|imm_expr
operator|.
name|X_add_number
operator|<
literal|0x8000
condition|)
block|{
name|macro_build
argument_list|(
operator|&
name|imm_expr
argument_list|,
literal|"sltiu"
argument_list|,
literal|"t,r,j"
argument_list|,
name|dreg
argument_list|,
name|sreg
argument_list|,
name|BFD_RELOC_LO16
argument_list|)
expr_stmt|;
return|return;
block|}
name|load_register
argument_list|(
name|AT
argument_list|,
operator|&
name|imm_expr
argument_list|,
name|HAVE_64BIT_GPRS
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"sltu"
argument_list|,
literal|"d,v,t"
argument_list|,
name|dreg
argument_list|,
name|sreg
argument_list|,
name|AT
argument_list|)
expr_stmt|;
break|break;
case|case
name|M_SNE
case|:
if|if
condition|(
name|sreg
operator|==
literal|0
condition|)
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"sltu"
argument_list|,
literal|"d,v,t"
argument_list|,
name|dreg
argument_list|,
literal|0
argument_list|,
name|treg
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|treg
operator|==
literal|0
condition|)
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"sltu"
argument_list|,
literal|"d,v,t"
argument_list|,
name|dreg
argument_list|,
literal|0
argument_list|,
name|sreg
argument_list|)
expr_stmt|;
else|else
block|{
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"xor"
argument_list|,
literal|"d,v,t"
argument_list|,
name|dreg
argument_list|,
name|sreg
argument_list|,
name|treg
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"sltu"
argument_list|,
literal|"d,v,t"
argument_list|,
name|dreg
argument_list|,
literal|0
argument_list|,
name|dreg
argument_list|)
expr_stmt|;
block|}
return|return;
case|case
name|M_SNE_I
case|:
if|if
condition|(
name|imm_expr
operator|.
name|X_op
operator|==
name|O_constant
operator|&&
name|imm_expr
operator|.
name|X_add_number
operator|==
literal|0
condition|)
block|{
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"sltu"
argument_list|,
literal|"d,v,t"
argument_list|,
name|dreg
argument_list|,
literal|0
argument_list|,
name|sreg
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|sreg
operator|==
literal|0
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"Instruction %s: result is always true"
argument_list|)
argument_list|,
name|ip
operator|->
name|insn_mo
operator|->
name|name
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|expr1
argument_list|,
name|HAVE_32BIT_GPRS
condition|?
literal|"addiu"
else|:
literal|"daddiu"
argument_list|,
literal|"t,r,j"
argument_list|,
name|dreg
argument_list|,
literal|0
argument_list|,
name|BFD_RELOC_LO16
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|imm_expr
operator|.
name|X_op
operator|==
name|O_constant
operator|&&
name|imm_expr
operator|.
name|X_add_number
operator|>=
literal|0
operator|&&
name|imm_expr
operator|.
name|X_add_number
operator|<
literal|0x10000
condition|)
block|{
name|macro_build
argument_list|(
operator|&
name|imm_expr
argument_list|,
literal|"xori"
argument_list|,
literal|"t,r,i"
argument_list|,
name|dreg
argument_list|,
name|sreg
argument_list|,
name|BFD_RELOC_LO16
argument_list|)
expr_stmt|;
name|used_at
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|imm_expr
operator|.
name|X_op
operator|==
name|O_constant
operator|&&
name|imm_expr
operator|.
name|X_add_number
operator|>
operator|-
literal|0x8000
operator|&&
name|imm_expr
operator|.
name|X_add_number
operator|<
literal|0
condition|)
block|{
name|imm_expr
operator|.
name|X_add_number
operator|=
operator|-
name|imm_expr
operator|.
name|X_add_number
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|imm_expr
argument_list|,
name|HAVE_32BIT_GPRS
condition|?
literal|"addiu"
else|:
literal|"daddiu"
argument_list|,
literal|"t,r,j"
argument_list|,
name|dreg
argument_list|,
name|sreg
argument_list|,
name|BFD_RELOC_LO16
argument_list|)
expr_stmt|;
name|used_at
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|load_register
argument_list|(
name|AT
argument_list|,
operator|&
name|imm_expr
argument_list|,
name|HAVE_64BIT_GPRS
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"xor"
argument_list|,
literal|"d,v,t"
argument_list|,
name|dreg
argument_list|,
name|sreg
argument_list|,
name|AT
argument_list|)
expr_stmt|;
name|used_at
operator|=
literal|1
expr_stmt|;
block|}
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"sltu"
argument_list|,
literal|"d,v,t"
argument_list|,
name|dreg
argument_list|,
literal|0
argument_list|,
name|dreg
argument_list|)
expr_stmt|;
if|if
condition|(
name|used_at
condition|)
break|break;
return|return;
case|case
name|M_DSUB_I
case|:
name|dbl
operator|=
literal|1
expr_stmt|;
case|case
name|M_SUB_I
case|:
if|if
condition|(
name|imm_expr
operator|.
name|X_op
operator|==
name|O_constant
operator|&&
name|imm_expr
operator|.
name|X_add_number
operator|>
operator|-
literal|0x8000
operator|&&
name|imm_expr
operator|.
name|X_add_number
operator|<=
literal|0x8000
condition|)
block|{
name|imm_expr
operator|.
name|X_add_number
operator|=
operator|-
name|imm_expr
operator|.
name|X_add_number
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|imm_expr
argument_list|,
name|dbl
condition|?
literal|"daddi"
else|:
literal|"addi"
argument_list|,
literal|"t,r,j"
argument_list|,
name|dreg
argument_list|,
name|sreg
argument_list|,
name|BFD_RELOC_LO16
argument_list|)
expr_stmt|;
return|return;
block|}
name|load_register
argument_list|(
name|AT
argument_list|,
operator|&
name|imm_expr
argument_list|,
name|dbl
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
name|dbl
condition|?
literal|"dsub"
else|:
literal|"sub"
argument_list|,
literal|"d,v,t"
argument_list|,
name|dreg
argument_list|,
name|sreg
argument_list|,
name|AT
argument_list|)
expr_stmt|;
break|break;
case|case
name|M_DSUBU_I
case|:
name|dbl
operator|=
literal|1
expr_stmt|;
case|case
name|M_SUBU_I
case|:
if|if
condition|(
name|imm_expr
operator|.
name|X_op
operator|==
name|O_constant
operator|&&
name|imm_expr
operator|.
name|X_add_number
operator|>
operator|-
literal|0x8000
operator|&&
name|imm_expr
operator|.
name|X_add_number
operator|<=
literal|0x8000
condition|)
block|{
name|imm_expr
operator|.
name|X_add_number
operator|=
operator|-
name|imm_expr
operator|.
name|X_add_number
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|imm_expr
argument_list|,
name|dbl
condition|?
literal|"daddiu"
else|:
literal|"addiu"
argument_list|,
literal|"t,r,j"
argument_list|,
name|dreg
argument_list|,
name|sreg
argument_list|,
name|BFD_RELOC_LO16
argument_list|)
expr_stmt|;
return|return;
block|}
name|load_register
argument_list|(
name|AT
argument_list|,
operator|&
name|imm_expr
argument_list|,
name|dbl
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
name|dbl
condition|?
literal|"dsubu"
else|:
literal|"subu"
argument_list|,
literal|"d,v,t"
argument_list|,
name|dreg
argument_list|,
name|sreg
argument_list|,
name|AT
argument_list|)
expr_stmt|;
break|break;
case|case
name|M_TEQ_I
case|:
name|s
operator|=
literal|"teq"
expr_stmt|;
goto|goto
name|trap
goto|;
case|case
name|M_TGE_I
case|:
name|s
operator|=
literal|"tge"
expr_stmt|;
goto|goto
name|trap
goto|;
case|case
name|M_TGEU_I
case|:
name|s
operator|=
literal|"tgeu"
expr_stmt|;
goto|goto
name|trap
goto|;
case|case
name|M_TLT_I
case|:
name|s
operator|=
literal|"tlt"
expr_stmt|;
goto|goto
name|trap
goto|;
case|case
name|M_TLTU_I
case|:
name|s
operator|=
literal|"tltu"
expr_stmt|;
goto|goto
name|trap
goto|;
case|case
name|M_TNE_I
case|:
name|s
operator|=
literal|"tne"
expr_stmt|;
name|trap
label|:
name|load_register
argument_list|(
name|AT
argument_list|,
operator|&
name|imm_expr
argument_list|,
name|HAVE_64BIT_GPRS
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
name|s
argument_list|,
literal|"s,t"
argument_list|,
name|sreg
argument_list|,
name|AT
argument_list|)
expr_stmt|;
break|break;
case|case
name|M_TRUNCWS
case|:
case|case
name|M_TRUNCWD
case|:
name|assert
argument_list|(
name|mips_opts
operator|.
name|isa
operator|==
name|ISA_MIPS1
argument_list|)
expr_stmt|;
name|sreg
operator|=
operator|(
name|ip
operator|->
name|insn_opcode
operator|>>
literal|11
operator|)
operator|&
literal|0x1f
expr_stmt|;
comment|/* floating reg */
name|dreg
operator|=
operator|(
name|ip
operator|->
name|insn_opcode
operator|>>
literal|06
operator|)
operator|&
literal|0x1f
expr_stmt|;
comment|/* floating reg */
comment|/*        * Is the double cfc1 instruction a bug in the mips assembler;        * or is there a reason for it?        */
name|mips_emit_delays
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
operator|++
name|mips_opts
operator|.
name|noreorder
expr_stmt|;
name|mips_any_noreorder
operator|=
literal|1
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"cfc1"
argument_list|,
literal|"t,G"
argument_list|,
name|treg
argument_list|,
name|RA
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"cfc1"
argument_list|,
literal|"t,G"
argument_list|,
name|treg
argument_list|,
name|RA
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"nop"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|expr1
operator|.
name|X_add_number
operator|=
literal|3
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|expr1
argument_list|,
literal|"ori"
argument_list|,
literal|"t,r,i"
argument_list|,
name|AT
argument_list|,
name|treg
argument_list|,
name|BFD_RELOC_LO16
argument_list|)
expr_stmt|;
name|expr1
operator|.
name|X_add_number
operator|=
literal|2
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|expr1
argument_list|,
literal|"xori"
argument_list|,
literal|"t,r,i"
argument_list|,
name|AT
argument_list|,
name|AT
argument_list|,
name|BFD_RELOC_LO16
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"ctc1"
argument_list|,
literal|"t,G"
argument_list|,
name|AT
argument_list|,
name|RA
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"nop"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
name|mask
operator|==
name|M_TRUNCWD
condition|?
literal|"cvt.w.d"
else|:
literal|"cvt.w.s"
argument_list|,
literal|"D,S"
argument_list|,
name|dreg
argument_list|,
name|sreg
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"ctc1"
argument_list|,
literal|"t,G"
argument_list|,
name|treg
argument_list|,
name|RA
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"nop"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
operator|--
name|mips_opts
operator|.
name|noreorder
expr_stmt|;
break|break;
case|case
name|M_ULH
case|:
name|s
operator|=
literal|"lb"
expr_stmt|;
goto|goto
name|ulh
goto|;
case|case
name|M_ULHU
case|:
name|s
operator|=
literal|"lbu"
expr_stmt|;
name|ulh
label|:
if|if
condition|(
name|offset_expr
operator|.
name|X_add_number
operator|>=
literal|0x7fff
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"operand overflow"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|target_big_endian
condition|)
operator|++
name|offset_expr
operator|.
name|X_add_number
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|s
argument_list|,
literal|"t,o(b)"
argument_list|,
name|AT
argument_list|,
name|BFD_RELOC_LO16
argument_list|,
name|breg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|target_big_endian
condition|)
operator|--
name|offset_expr
operator|.
name|X_add_number
expr_stmt|;
else|else
operator|++
name|offset_expr
operator|.
name|X_add_number
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
literal|"lbu"
argument_list|,
literal|"t,o(b)"
argument_list|,
name|treg
argument_list|,
name|BFD_RELOC_LO16
argument_list|,
name|breg
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"sll"
argument_list|,
literal|"d,w,<"
argument_list|,
name|AT
argument_list|,
name|AT
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"or"
argument_list|,
literal|"d,v,t"
argument_list|,
name|treg
argument_list|,
name|treg
argument_list|,
name|AT
argument_list|)
expr_stmt|;
break|break;
case|case
name|M_ULD
case|:
name|s
operator|=
literal|"ldl"
expr_stmt|;
name|s2
operator|=
literal|"ldr"
expr_stmt|;
name|off
operator|=
literal|7
expr_stmt|;
goto|goto
name|ulw
goto|;
case|case
name|M_ULW
case|:
name|s
operator|=
literal|"lwl"
expr_stmt|;
name|s2
operator|=
literal|"lwr"
expr_stmt|;
name|off
operator|=
literal|3
expr_stmt|;
name|ulw
label|:
if|if
condition|(
name|offset_expr
operator|.
name|X_add_number
operator|>=
literal|0x8000
operator|-
name|off
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"operand overflow"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|treg
operator|!=
name|breg
condition|)
name|tempreg
operator|=
name|treg
expr_stmt|;
else|else
name|tempreg
operator|=
name|AT
expr_stmt|;
if|if
condition|(
operator|!
name|target_big_endian
condition|)
name|offset_expr
operator|.
name|X_add_number
operator|+=
name|off
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|s
argument_list|,
literal|"t,o(b)"
argument_list|,
name|tempreg
argument_list|,
name|BFD_RELOC_LO16
argument_list|,
name|breg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|target_big_endian
condition|)
name|offset_expr
operator|.
name|X_add_number
operator|-=
name|off
expr_stmt|;
else|else
name|offset_expr
operator|.
name|X_add_number
operator|+=
name|off
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|s2
argument_list|,
literal|"t,o(b)"
argument_list|,
name|tempreg
argument_list|,
name|BFD_RELOC_LO16
argument_list|,
name|breg
argument_list|)
expr_stmt|;
comment|/* If necessary, move the result in tempreg the final destination.  */
if|if
condition|(
name|treg
operator|==
name|tempreg
condition|)
return|return;
comment|/* Protect second load's delay slot.  */
if|if
condition|(
operator|!
name|gpr_interlocks
condition|)
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"nop"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|move_register
argument_list|(
name|treg
argument_list|,
name|tempreg
argument_list|)
expr_stmt|;
break|break;
case|case
name|M_ULD_A
case|:
name|s
operator|=
literal|"ldl"
expr_stmt|;
name|s2
operator|=
literal|"ldr"
expr_stmt|;
name|off
operator|=
literal|7
expr_stmt|;
goto|goto
name|ulwa
goto|;
case|case
name|M_ULW_A
case|:
name|s
operator|=
literal|"lwl"
expr_stmt|;
name|s2
operator|=
literal|"lwr"
expr_stmt|;
name|off
operator|=
literal|3
expr_stmt|;
name|ulwa
label|:
name|used_at
operator|=
literal|1
expr_stmt|;
name|load_address
argument_list|(
name|AT
argument_list|,
operator|&
name|offset_expr
argument_list|,
operator|&
name|used_at
argument_list|)
expr_stmt|;
if|if
condition|(
name|breg
operator|!=
literal|0
condition|)
name|macro_build
argument_list|(
name|NULL
argument_list|,
name|ADDRESS_ADD_INSN
argument_list|,
literal|"d,v,t"
argument_list|,
name|AT
argument_list|,
name|AT
argument_list|,
name|breg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|target_big_endian
condition|)
name|expr1
operator|.
name|X_add_number
operator|=
name|off
expr_stmt|;
else|else
name|expr1
operator|.
name|X_add_number
operator|=
literal|0
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|expr1
argument_list|,
name|s
argument_list|,
literal|"t,o(b)"
argument_list|,
name|treg
argument_list|,
name|BFD_RELOC_LO16
argument_list|,
name|AT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|target_big_endian
condition|)
name|expr1
operator|.
name|X_add_number
operator|=
literal|0
expr_stmt|;
else|else
name|expr1
operator|.
name|X_add_number
operator|=
name|off
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|expr1
argument_list|,
name|s2
argument_list|,
literal|"t,o(b)"
argument_list|,
name|treg
argument_list|,
name|BFD_RELOC_LO16
argument_list|,
name|AT
argument_list|)
expr_stmt|;
break|break;
case|case
name|M_ULH_A
case|:
case|case
name|M_ULHU_A
case|:
name|used_at
operator|=
literal|1
expr_stmt|;
name|load_address
argument_list|(
name|AT
argument_list|,
operator|&
name|offset_expr
argument_list|,
operator|&
name|used_at
argument_list|)
expr_stmt|;
if|if
condition|(
name|breg
operator|!=
literal|0
condition|)
name|macro_build
argument_list|(
name|NULL
argument_list|,
name|ADDRESS_ADD_INSN
argument_list|,
literal|"d,v,t"
argument_list|,
name|AT
argument_list|,
name|AT
argument_list|,
name|breg
argument_list|)
expr_stmt|;
if|if
condition|(
name|target_big_endian
condition|)
name|expr1
operator|.
name|X_add_number
operator|=
literal|0
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|expr1
argument_list|,
name|mask
operator|==
name|M_ULH_A
condition|?
literal|"lb"
else|:
literal|"lbu"
argument_list|,
literal|"t,o(b)"
argument_list|,
name|treg
argument_list|,
name|BFD_RELOC_LO16
argument_list|,
name|AT
argument_list|)
expr_stmt|;
if|if
condition|(
name|target_big_endian
condition|)
name|expr1
operator|.
name|X_add_number
operator|=
literal|1
expr_stmt|;
else|else
name|expr1
operator|.
name|X_add_number
operator|=
literal|0
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|expr1
argument_list|,
literal|"lbu"
argument_list|,
literal|"t,o(b)"
argument_list|,
name|AT
argument_list|,
name|BFD_RELOC_LO16
argument_list|,
name|AT
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"sll"
argument_list|,
literal|"d,w,<"
argument_list|,
name|treg
argument_list|,
name|treg
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"or"
argument_list|,
literal|"d,v,t"
argument_list|,
name|treg
argument_list|,
name|treg
argument_list|,
name|AT
argument_list|)
expr_stmt|;
break|break;
case|case
name|M_USH
case|:
if|if
condition|(
name|offset_expr
operator|.
name|X_add_number
operator|>=
literal|0x7fff
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"operand overflow"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|target_big_endian
condition|)
operator|++
name|offset_expr
operator|.
name|X_add_number
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
literal|"sb"
argument_list|,
literal|"t,o(b)"
argument_list|,
name|treg
argument_list|,
name|BFD_RELOC_LO16
argument_list|,
name|breg
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"srl"
argument_list|,
literal|"d,w,<"
argument_list|,
name|AT
argument_list|,
name|treg
argument_list|,
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
name|target_big_endian
condition|)
operator|--
name|offset_expr
operator|.
name|X_add_number
expr_stmt|;
else|else
operator|++
name|offset_expr
operator|.
name|X_add_number
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
literal|"sb"
argument_list|,
literal|"t,o(b)"
argument_list|,
name|AT
argument_list|,
name|BFD_RELOC_LO16
argument_list|,
name|breg
argument_list|)
expr_stmt|;
break|break;
case|case
name|M_USD
case|:
name|s
operator|=
literal|"sdl"
expr_stmt|;
name|s2
operator|=
literal|"sdr"
expr_stmt|;
name|off
operator|=
literal|7
expr_stmt|;
goto|goto
name|usw
goto|;
case|case
name|M_USW
case|:
name|s
operator|=
literal|"swl"
expr_stmt|;
name|s2
operator|=
literal|"swr"
expr_stmt|;
name|off
operator|=
literal|3
expr_stmt|;
name|usw
label|:
if|if
condition|(
name|offset_expr
operator|.
name|X_add_number
operator|>=
literal|0x8000
operator|-
name|off
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"operand overflow"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|target_big_endian
condition|)
name|offset_expr
operator|.
name|X_add_number
operator|+=
name|off
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|s
argument_list|,
literal|"t,o(b)"
argument_list|,
name|treg
argument_list|,
name|BFD_RELOC_LO16
argument_list|,
name|breg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|target_big_endian
condition|)
name|offset_expr
operator|.
name|X_add_number
operator|-=
name|off
expr_stmt|;
else|else
name|offset_expr
operator|.
name|X_add_number
operator|+=
name|off
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|s2
argument_list|,
literal|"t,o(b)"
argument_list|,
name|treg
argument_list|,
name|BFD_RELOC_LO16
argument_list|,
name|breg
argument_list|)
expr_stmt|;
return|return;
case|case
name|M_USD_A
case|:
name|s
operator|=
literal|"sdl"
expr_stmt|;
name|s2
operator|=
literal|"sdr"
expr_stmt|;
name|off
operator|=
literal|7
expr_stmt|;
goto|goto
name|uswa
goto|;
case|case
name|M_USW_A
case|:
name|s
operator|=
literal|"swl"
expr_stmt|;
name|s2
operator|=
literal|"swr"
expr_stmt|;
name|off
operator|=
literal|3
expr_stmt|;
name|uswa
label|:
name|used_at
operator|=
literal|1
expr_stmt|;
name|load_address
argument_list|(
name|AT
argument_list|,
operator|&
name|offset_expr
argument_list|,
operator|&
name|used_at
argument_list|)
expr_stmt|;
if|if
condition|(
name|breg
operator|!=
literal|0
condition|)
name|macro_build
argument_list|(
name|NULL
argument_list|,
name|ADDRESS_ADD_INSN
argument_list|,
literal|"d,v,t"
argument_list|,
name|AT
argument_list|,
name|AT
argument_list|,
name|breg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|target_big_endian
condition|)
name|expr1
operator|.
name|X_add_number
operator|=
name|off
expr_stmt|;
else|else
name|expr1
operator|.
name|X_add_number
operator|=
literal|0
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|expr1
argument_list|,
name|s
argument_list|,
literal|"t,o(b)"
argument_list|,
name|treg
argument_list|,
name|BFD_RELOC_LO16
argument_list|,
name|AT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|target_big_endian
condition|)
name|expr1
operator|.
name|X_add_number
operator|=
literal|0
expr_stmt|;
else|else
name|expr1
operator|.
name|X_add_number
operator|=
name|off
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|expr1
argument_list|,
name|s2
argument_list|,
literal|"t,o(b)"
argument_list|,
name|treg
argument_list|,
name|BFD_RELOC_LO16
argument_list|,
name|AT
argument_list|)
expr_stmt|;
break|break;
case|case
name|M_USH_A
case|:
name|used_at
operator|=
literal|1
expr_stmt|;
name|load_address
argument_list|(
name|AT
argument_list|,
operator|&
name|offset_expr
argument_list|,
operator|&
name|used_at
argument_list|)
expr_stmt|;
if|if
condition|(
name|breg
operator|!=
literal|0
condition|)
name|macro_build
argument_list|(
name|NULL
argument_list|,
name|ADDRESS_ADD_INSN
argument_list|,
literal|"d,v,t"
argument_list|,
name|AT
argument_list|,
name|AT
argument_list|,
name|breg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|target_big_endian
condition|)
name|expr1
operator|.
name|X_add_number
operator|=
literal|0
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|expr1
argument_list|,
literal|"sb"
argument_list|,
literal|"t,o(b)"
argument_list|,
name|treg
argument_list|,
name|BFD_RELOC_LO16
argument_list|,
name|AT
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"srl"
argument_list|,
literal|"d,w,<"
argument_list|,
name|treg
argument_list|,
name|treg
argument_list|,
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|target_big_endian
condition|)
name|expr1
operator|.
name|X_add_number
operator|=
literal|1
expr_stmt|;
else|else
name|expr1
operator|.
name|X_add_number
operator|=
literal|0
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|expr1
argument_list|,
literal|"sb"
argument_list|,
literal|"t,o(b)"
argument_list|,
name|treg
argument_list|,
name|BFD_RELOC_LO16
argument_list|,
name|AT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|target_big_endian
condition|)
name|expr1
operator|.
name|X_add_number
operator|=
literal|0
expr_stmt|;
else|else
name|expr1
operator|.
name|X_add_number
operator|=
literal|1
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|expr1
argument_list|,
literal|"lbu"
argument_list|,
literal|"t,o(b)"
argument_list|,
name|AT
argument_list|,
name|BFD_RELOC_LO16
argument_list|,
name|AT
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"sll"
argument_list|,
literal|"d,w,<"
argument_list|,
name|treg
argument_list|,
name|treg
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"or"
argument_list|,
literal|"d,v,t"
argument_list|,
name|treg
argument_list|,
name|treg
argument_list|,
name|AT
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* FIXME: Check if this is one of the itbl macros, since they 	 are added dynamically.  */
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Macro %s not implemented yet"
argument_list|)
argument_list|,
name|ip
operator|->
name|insn_mo
operator|->
name|name
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|mips_opts
operator|.
name|noat
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"Macro used $at after \".set noat\""
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Implement macros in mips16 mode.  */
end_comment

begin_function
specifier|static
name|void
name|mips16_macro
parameter_list|(
name|struct
name|mips_cl_insn
modifier|*
name|ip
parameter_list|)
block|{
name|int
name|mask
decl_stmt|;
name|int
name|xreg
decl_stmt|,
name|yreg
decl_stmt|,
name|zreg
decl_stmt|,
name|tmp
decl_stmt|;
name|expressionS
name|expr1
decl_stmt|;
name|int
name|dbl
decl_stmt|;
specifier|const
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|s2
decl_stmt|,
modifier|*
name|s3
decl_stmt|;
name|mask
operator|=
name|ip
operator|->
name|insn_mo
operator|->
name|mask
expr_stmt|;
name|xreg
operator|=
operator|(
name|ip
operator|->
name|insn_opcode
operator|>>
name|MIPS16OP_SH_RX
operator|)
operator|&
name|MIPS16OP_MASK_RX
expr_stmt|;
name|yreg
operator|=
operator|(
name|ip
operator|->
name|insn_opcode
operator|>>
name|MIPS16OP_SH_RY
operator|)
operator|&
name|MIPS16OP_MASK_RY
expr_stmt|;
name|zreg
operator|=
operator|(
name|ip
operator|->
name|insn_opcode
operator|>>
name|MIPS16OP_SH_RZ
operator|)
operator|&
name|MIPS16OP_MASK_RZ
expr_stmt|;
name|expr1
operator|.
name|X_op
operator|=
name|O_constant
expr_stmt|;
name|expr1
operator|.
name|X_op_symbol
operator|=
name|NULL
expr_stmt|;
name|expr1
operator|.
name|X_add_symbol
operator|=
name|NULL
expr_stmt|;
name|expr1
operator|.
name|X_add_number
operator|=
literal|1
expr_stmt|;
name|dbl
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|mask
condition|)
block|{
default|default:
name|internalError
argument_list|()
expr_stmt|;
case|case
name|M_DDIV_3
case|:
name|dbl
operator|=
literal|1
expr_stmt|;
case|case
name|M_DIV_3
case|:
name|s
operator|=
literal|"mflo"
expr_stmt|;
goto|goto
name|do_div3
goto|;
case|case
name|M_DREM_3
case|:
name|dbl
operator|=
literal|1
expr_stmt|;
case|case
name|M_REM_3
case|:
name|s
operator|=
literal|"mfhi"
expr_stmt|;
name|do_div3
label|:
name|mips_emit_delays
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
operator|++
name|mips_opts
operator|.
name|noreorder
expr_stmt|;
name|mips_any_noreorder
operator|=
literal|1
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
name|dbl
condition|?
literal|"ddiv"
else|:
literal|"div"
argument_list|,
literal|"0,x,y"
argument_list|,
name|xreg
argument_list|,
name|yreg
argument_list|)
expr_stmt|;
name|expr1
operator|.
name|X_add_number
operator|=
literal|2
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|expr1
argument_list|,
literal|"bnez"
argument_list|,
literal|"x,p"
argument_list|,
name|yreg
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"break"
argument_list|,
literal|"6"
argument_list|,
literal|7
argument_list|)
expr_stmt|;
comment|/* FIXME: The normal code checks for of -1 / -0x80000000 here,          since that causes an overflow.  We should do that as well,          but I don't see how to do the comparisons without a temporary          register.  */
operator|--
name|mips_opts
operator|.
name|noreorder
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
name|s
argument_list|,
literal|"x"
argument_list|,
name|zreg
argument_list|)
expr_stmt|;
break|break;
case|case
name|M_DIVU_3
case|:
name|s
operator|=
literal|"divu"
expr_stmt|;
name|s2
operator|=
literal|"mflo"
expr_stmt|;
goto|goto
name|do_divu3
goto|;
case|case
name|M_REMU_3
case|:
name|s
operator|=
literal|"divu"
expr_stmt|;
name|s2
operator|=
literal|"mfhi"
expr_stmt|;
goto|goto
name|do_divu3
goto|;
case|case
name|M_DDIVU_3
case|:
name|s
operator|=
literal|"ddivu"
expr_stmt|;
name|s2
operator|=
literal|"mflo"
expr_stmt|;
goto|goto
name|do_divu3
goto|;
case|case
name|M_DREMU_3
case|:
name|s
operator|=
literal|"ddivu"
expr_stmt|;
name|s2
operator|=
literal|"mfhi"
expr_stmt|;
name|do_divu3
label|:
name|mips_emit_delays
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
operator|++
name|mips_opts
operator|.
name|noreorder
expr_stmt|;
name|mips_any_noreorder
operator|=
literal|1
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
name|s
argument_list|,
literal|"0,x,y"
argument_list|,
name|xreg
argument_list|,
name|yreg
argument_list|)
expr_stmt|;
name|expr1
operator|.
name|X_add_number
operator|=
literal|2
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|expr1
argument_list|,
literal|"bnez"
argument_list|,
literal|"x,p"
argument_list|,
name|yreg
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"break"
argument_list|,
literal|"6"
argument_list|,
literal|7
argument_list|)
expr_stmt|;
operator|--
name|mips_opts
operator|.
name|noreorder
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
name|s2
argument_list|,
literal|"x"
argument_list|,
name|zreg
argument_list|)
expr_stmt|;
break|break;
case|case
name|M_DMUL
case|:
name|dbl
operator|=
literal|1
expr_stmt|;
case|case
name|M_MUL
case|:
name|macro_build
argument_list|(
name|NULL
argument_list|,
name|dbl
condition|?
literal|"dmultu"
else|:
literal|"multu"
argument_list|,
literal|"x,y"
argument_list|,
name|xreg
argument_list|,
name|yreg
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"mflo"
argument_list|,
literal|"x"
argument_list|,
name|zreg
argument_list|)
expr_stmt|;
return|return;
case|case
name|M_DSUBU_I
case|:
name|dbl
operator|=
literal|1
expr_stmt|;
goto|goto
name|do_subu
goto|;
case|case
name|M_SUBU_I
case|:
name|do_subu
label|:
if|if
condition|(
name|imm_expr
operator|.
name|X_op
operator|!=
name|O_constant
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Unsupported large constant"
argument_list|)
argument_list|)
expr_stmt|;
name|imm_expr
operator|.
name|X_add_number
operator|=
operator|-
name|imm_expr
operator|.
name|X_add_number
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|imm_expr
argument_list|,
name|dbl
condition|?
literal|"daddiu"
else|:
literal|"addiu"
argument_list|,
literal|"y,x,4"
argument_list|,
name|yreg
argument_list|,
name|xreg
argument_list|)
expr_stmt|;
break|break;
case|case
name|M_SUBU_I_2
case|:
if|if
condition|(
name|imm_expr
operator|.
name|X_op
operator|!=
name|O_constant
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Unsupported large constant"
argument_list|)
argument_list|)
expr_stmt|;
name|imm_expr
operator|.
name|X_add_number
operator|=
operator|-
name|imm_expr
operator|.
name|X_add_number
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|imm_expr
argument_list|,
literal|"addiu"
argument_list|,
literal|"x,k"
argument_list|,
name|xreg
argument_list|)
expr_stmt|;
break|break;
case|case
name|M_DSUBU_I_2
case|:
if|if
condition|(
name|imm_expr
operator|.
name|X_op
operator|!=
name|O_constant
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Unsupported large constant"
argument_list|)
argument_list|)
expr_stmt|;
name|imm_expr
operator|.
name|X_add_number
operator|=
operator|-
name|imm_expr
operator|.
name|X_add_number
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|imm_expr
argument_list|,
literal|"daddiu"
argument_list|,
literal|"y,j"
argument_list|,
name|yreg
argument_list|)
expr_stmt|;
break|break;
case|case
name|M_BEQ
case|:
name|s
operator|=
literal|"cmp"
expr_stmt|;
name|s2
operator|=
literal|"bteqz"
expr_stmt|;
goto|goto
name|do_branch
goto|;
case|case
name|M_BNE
case|:
name|s
operator|=
literal|"cmp"
expr_stmt|;
name|s2
operator|=
literal|"btnez"
expr_stmt|;
goto|goto
name|do_branch
goto|;
case|case
name|M_BLT
case|:
name|s
operator|=
literal|"slt"
expr_stmt|;
name|s2
operator|=
literal|"btnez"
expr_stmt|;
goto|goto
name|do_branch
goto|;
case|case
name|M_BLTU
case|:
name|s
operator|=
literal|"sltu"
expr_stmt|;
name|s2
operator|=
literal|"btnez"
expr_stmt|;
goto|goto
name|do_branch
goto|;
case|case
name|M_BLE
case|:
name|s
operator|=
literal|"slt"
expr_stmt|;
name|s2
operator|=
literal|"bteqz"
expr_stmt|;
goto|goto
name|do_reverse_branch
goto|;
case|case
name|M_BLEU
case|:
name|s
operator|=
literal|"sltu"
expr_stmt|;
name|s2
operator|=
literal|"bteqz"
expr_stmt|;
goto|goto
name|do_reverse_branch
goto|;
case|case
name|M_BGE
case|:
name|s
operator|=
literal|"slt"
expr_stmt|;
name|s2
operator|=
literal|"bteqz"
expr_stmt|;
goto|goto
name|do_branch
goto|;
case|case
name|M_BGEU
case|:
name|s
operator|=
literal|"sltu"
expr_stmt|;
name|s2
operator|=
literal|"bteqz"
expr_stmt|;
goto|goto
name|do_branch
goto|;
case|case
name|M_BGT
case|:
name|s
operator|=
literal|"slt"
expr_stmt|;
name|s2
operator|=
literal|"btnez"
expr_stmt|;
goto|goto
name|do_reverse_branch
goto|;
case|case
name|M_BGTU
case|:
name|s
operator|=
literal|"sltu"
expr_stmt|;
name|s2
operator|=
literal|"btnez"
expr_stmt|;
name|do_reverse_branch
label|:
name|tmp
operator|=
name|xreg
expr_stmt|;
name|xreg
operator|=
name|yreg
expr_stmt|;
name|yreg
operator|=
name|tmp
expr_stmt|;
name|do_branch
label|:
name|macro_build
argument_list|(
name|NULL
argument_list|,
name|s
argument_list|,
literal|"x,y"
argument_list|,
name|xreg
argument_list|,
name|yreg
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|s2
argument_list|,
literal|"p"
argument_list|)
expr_stmt|;
break|break;
case|case
name|M_BEQ_I
case|:
name|s
operator|=
literal|"cmpi"
expr_stmt|;
name|s2
operator|=
literal|"bteqz"
expr_stmt|;
name|s3
operator|=
literal|"x,U"
expr_stmt|;
goto|goto
name|do_branch_i
goto|;
case|case
name|M_BNE_I
case|:
name|s
operator|=
literal|"cmpi"
expr_stmt|;
name|s2
operator|=
literal|"btnez"
expr_stmt|;
name|s3
operator|=
literal|"x,U"
expr_stmt|;
goto|goto
name|do_branch_i
goto|;
case|case
name|M_BLT_I
case|:
name|s
operator|=
literal|"slti"
expr_stmt|;
name|s2
operator|=
literal|"btnez"
expr_stmt|;
name|s3
operator|=
literal|"x,8"
expr_stmt|;
goto|goto
name|do_branch_i
goto|;
case|case
name|M_BLTU_I
case|:
name|s
operator|=
literal|"sltiu"
expr_stmt|;
name|s2
operator|=
literal|"btnez"
expr_stmt|;
name|s3
operator|=
literal|"x,8"
expr_stmt|;
goto|goto
name|do_branch_i
goto|;
case|case
name|M_BLE_I
case|:
name|s
operator|=
literal|"slti"
expr_stmt|;
name|s2
operator|=
literal|"btnez"
expr_stmt|;
name|s3
operator|=
literal|"x,8"
expr_stmt|;
goto|goto
name|do_addone_branch_i
goto|;
case|case
name|M_BLEU_I
case|:
name|s
operator|=
literal|"sltiu"
expr_stmt|;
name|s2
operator|=
literal|"btnez"
expr_stmt|;
name|s3
operator|=
literal|"x,8"
expr_stmt|;
goto|goto
name|do_addone_branch_i
goto|;
case|case
name|M_BGE_I
case|:
name|s
operator|=
literal|"slti"
expr_stmt|;
name|s2
operator|=
literal|"bteqz"
expr_stmt|;
name|s3
operator|=
literal|"x,8"
expr_stmt|;
goto|goto
name|do_branch_i
goto|;
case|case
name|M_BGEU_I
case|:
name|s
operator|=
literal|"sltiu"
expr_stmt|;
name|s2
operator|=
literal|"bteqz"
expr_stmt|;
name|s3
operator|=
literal|"x,8"
expr_stmt|;
goto|goto
name|do_branch_i
goto|;
case|case
name|M_BGT_I
case|:
name|s
operator|=
literal|"slti"
expr_stmt|;
name|s2
operator|=
literal|"bteqz"
expr_stmt|;
name|s3
operator|=
literal|"x,8"
expr_stmt|;
goto|goto
name|do_addone_branch_i
goto|;
case|case
name|M_BGTU_I
case|:
name|s
operator|=
literal|"sltiu"
expr_stmt|;
name|s2
operator|=
literal|"bteqz"
expr_stmt|;
name|s3
operator|=
literal|"x,8"
expr_stmt|;
name|do_addone_branch_i
label|:
if|if
condition|(
name|imm_expr
operator|.
name|X_op
operator|!=
name|O_constant
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Unsupported large constant"
argument_list|)
argument_list|)
expr_stmt|;
operator|++
name|imm_expr
operator|.
name|X_add_number
expr_stmt|;
name|do_branch_i
label|:
name|macro_build
argument_list|(
operator|&
name|imm_expr
argument_list|,
name|s
argument_list|,
name|s3
argument_list|,
name|xreg
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|s2
argument_list|,
literal|"p"
argument_list|)
expr_stmt|;
break|break;
case|case
name|M_ABS
case|:
name|expr1
operator|.
name|X_add_number
operator|=
literal|0
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|expr1
argument_list|,
literal|"slti"
argument_list|,
literal|"x,8"
argument_list|,
name|yreg
argument_list|)
expr_stmt|;
if|if
condition|(
name|xreg
operator|!=
name|yreg
condition|)
name|move_register
argument_list|(
name|xreg
argument_list|,
name|yreg
argument_list|)
expr_stmt|;
name|expr1
operator|.
name|X_add_number
operator|=
literal|2
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|expr1
argument_list|,
literal|"bteqz"
argument_list|,
literal|"p"
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"neg"
argument_list|,
literal|"x,w"
argument_list|,
name|xreg
argument_list|,
name|xreg
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* For consistency checking, verify that all bits are specified either    by the match/mask part of the instruction definition, or by the    operand list.  */
end_comment

begin_function
specifier|static
name|int
name|validate_mips_insn
parameter_list|(
specifier|const
name|struct
name|mips_opcode
modifier|*
name|opc
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|p
init|=
name|opc
operator|->
name|args
decl_stmt|;
name|char
name|c
decl_stmt|;
name|unsigned
name|long
name|used_bits
init|=
name|opc
operator|->
name|mask
decl_stmt|;
if|if
condition|(
operator|(
name|used_bits
operator|&
name|opc
operator|->
name|match
operator|)
operator|!=
name|opc
operator|->
name|match
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"internal: bad mips opcode (mask error): %s %s"
argument_list|)
argument_list|,
name|opc
operator|->
name|name
argument_list|,
name|opc
operator|->
name|args
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
define|#
directive|define
name|USE_BITS
parameter_list|(
name|mask
parameter_list|,
name|shift
parameter_list|)
value|(used_bits |= ((mask)<< (shift)))
while|while
condition|(
operator|*
name|p
condition|)
switch|switch
condition|(
name|c
operator|=
operator|*
name|p
operator|++
condition|)
block|{
case|case
literal|','
case|:
break|break;
case|case
literal|'('
case|:
break|break;
case|case
literal|')'
case|:
break|break;
case|case
literal|'+'
case|:
switch|switch
condition|(
name|c
operator|=
operator|*
name|p
operator|++
condition|)
block|{
case|case
literal|'A'
case|:
name|USE_BITS
argument_list|(
name|OP_MASK_SHAMT
argument_list|,
name|OP_SH_SHAMT
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'B'
case|:
name|USE_BITS
argument_list|(
name|OP_MASK_INSMSB
argument_list|,
name|OP_SH_INSMSB
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'C'
case|:
name|USE_BITS
argument_list|(
name|OP_MASK_EXTMSBD
argument_list|,
name|OP_SH_EXTMSBD
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
name|USE_BITS
argument_list|(
name|OP_MASK_RD
argument_list|,
name|OP_SH_RD
argument_list|)
expr_stmt|;
name|USE_BITS
argument_list|(
name|OP_MASK_SEL
argument_list|,
name|OP_SH_SEL
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'E'
case|:
name|USE_BITS
argument_list|(
name|OP_MASK_SHAMT
argument_list|,
name|OP_SH_SHAMT
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'F'
case|:
name|USE_BITS
argument_list|(
name|OP_MASK_INSMSB
argument_list|,
name|OP_SH_INSMSB
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'G'
case|:
name|USE_BITS
argument_list|(
name|OP_MASK_EXTMSBD
argument_list|,
name|OP_SH_EXTMSBD
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'H'
case|:
name|USE_BITS
argument_list|(
name|OP_MASK_EXTMSBD
argument_list|,
name|OP_SH_EXTMSBD
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'I'
case|:
break|break;
default|default:
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"internal: bad mips opcode (unknown extension operand type `+%c'): %s %s"
argument_list|)
argument_list|,
name|c
argument_list|,
name|opc
operator|->
name|name
argument_list|,
name|opc
operator|->
name|args
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
break|break;
case|case
literal|'<'
case|:
name|USE_BITS
argument_list|(
name|OP_MASK_SHAMT
argument_list|,
name|OP_SH_SHAMT
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'>'
case|:
name|USE_BITS
argument_list|(
name|OP_MASK_SHAMT
argument_list|,
name|OP_SH_SHAMT
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'A'
case|:
break|break;
case|case
literal|'B'
case|:
name|USE_BITS
argument_list|(
name|OP_MASK_CODE20
argument_list|,
name|OP_SH_CODE20
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'C'
case|:
name|USE_BITS
argument_list|(
name|OP_MASK_COPZ
argument_list|,
name|OP_SH_COPZ
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
name|USE_BITS
argument_list|(
name|OP_MASK_FD
argument_list|,
name|OP_SH_FD
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'E'
case|:
name|USE_BITS
argument_list|(
name|OP_MASK_RT
argument_list|,
name|OP_SH_RT
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'F'
case|:
break|break;
case|case
literal|'G'
case|:
name|USE_BITS
argument_list|(
name|OP_MASK_RD
argument_list|,
name|OP_SH_RD
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'H'
case|:
name|USE_BITS
argument_list|(
name|OP_MASK_SEL
argument_list|,
name|OP_SH_SEL
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'I'
case|:
break|break;
case|case
literal|'J'
case|:
name|USE_BITS
argument_list|(
name|OP_MASK_CODE19
argument_list|,
name|OP_SH_CODE19
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'K'
case|:
name|USE_BITS
argument_list|(
name|OP_MASK_RD
argument_list|,
name|OP_SH_RD
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'L'
case|:
break|break;
case|case
literal|'M'
case|:
name|USE_BITS
argument_list|(
name|OP_MASK_CCC
argument_list|,
name|OP_SH_CCC
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'N'
case|:
name|USE_BITS
argument_list|(
name|OP_MASK_BCC
argument_list|,
name|OP_SH_BCC
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'O'
case|:
name|USE_BITS
argument_list|(
name|OP_MASK_ALN
argument_list|,
name|OP_SH_ALN
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'Q'
case|:
name|USE_BITS
argument_list|(
name|OP_MASK_VSEL
argument_list|,
name|OP_SH_VSEL
argument_list|)
expr_stmt|;
name|USE_BITS
argument_list|(
name|OP_MASK_FT
argument_list|,
name|OP_SH_FT
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'R'
case|:
name|USE_BITS
argument_list|(
name|OP_MASK_FR
argument_list|,
name|OP_SH_FR
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
name|USE_BITS
argument_list|(
name|OP_MASK_FS
argument_list|,
name|OP_SH_FS
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'T'
case|:
name|USE_BITS
argument_list|(
name|OP_MASK_FT
argument_list|,
name|OP_SH_FT
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'V'
case|:
name|USE_BITS
argument_list|(
name|OP_MASK_FS
argument_list|,
name|OP_SH_FS
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'W'
case|:
name|USE_BITS
argument_list|(
name|OP_MASK_FT
argument_list|,
name|OP_SH_FT
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'X'
case|:
name|USE_BITS
argument_list|(
name|OP_MASK_FD
argument_list|,
name|OP_SH_FD
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'Y'
case|:
name|USE_BITS
argument_list|(
name|OP_MASK_FS
argument_list|,
name|OP_SH_FS
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'Z'
case|:
name|USE_BITS
argument_list|(
name|OP_MASK_FT
argument_list|,
name|OP_SH_FT
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
name|USE_BITS
argument_list|(
name|OP_MASK_TARGET
argument_list|,
name|OP_SH_TARGET
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
name|USE_BITS
argument_list|(
name|OP_MASK_RS
argument_list|,
name|OP_SH_RS
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|USE_BITS
argument_list|(
name|OP_MASK_CODE
argument_list|,
name|OP_SH_CODE
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|USE_BITS
argument_list|(
name|OP_MASK_RD
argument_list|,
name|OP_SH_RD
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
break|break;
case|case
literal|'h'
case|:
name|USE_BITS
argument_list|(
name|OP_MASK_PREFX
argument_list|,
name|OP_SH_PREFX
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
name|USE_BITS
argument_list|(
name|OP_MASK_IMMEDIATE
argument_list|,
name|OP_SH_IMMEDIATE
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'j'
case|:
name|USE_BITS
argument_list|(
name|OP_MASK_DELTA
argument_list|,
name|OP_SH_DELTA
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'k'
case|:
name|USE_BITS
argument_list|(
name|OP_MASK_CACHE
argument_list|,
name|OP_SH_CACHE
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
break|break;
case|case
literal|'o'
case|:
name|USE_BITS
argument_list|(
name|OP_MASK_DELTA
argument_list|,
name|OP_SH_DELTA
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|USE_BITS
argument_list|(
name|OP_MASK_DELTA
argument_list|,
name|OP_SH_DELTA
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'q'
case|:
name|USE_BITS
argument_list|(
name|OP_MASK_CODE2
argument_list|,
name|OP_SH_CODE2
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|USE_BITS
argument_list|(
name|OP_MASK_RS
argument_list|,
name|OP_SH_RS
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|USE_BITS
argument_list|(
name|OP_MASK_RS
argument_list|,
name|OP_SH_RS
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|USE_BITS
argument_list|(
name|OP_MASK_RT
argument_list|,
name|OP_SH_RT
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
name|USE_BITS
argument_list|(
name|OP_MASK_IMMEDIATE
argument_list|,
name|OP_SH_IMMEDIATE
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
name|USE_BITS
argument_list|(
name|OP_MASK_RS
argument_list|,
name|OP_SH_RS
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
name|USE_BITS
argument_list|(
name|OP_MASK_RT
argument_list|,
name|OP_SH_RT
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
break|break;
case|case
literal|'z'
case|:
break|break;
case|case
literal|'P'
case|:
name|USE_BITS
argument_list|(
name|OP_MASK_PERFREG
argument_list|,
name|OP_SH_PERFREG
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'U'
case|:
name|USE_BITS
argument_list|(
name|OP_MASK_RD
argument_list|,
name|OP_SH_RD
argument_list|)
expr_stmt|;
name|USE_BITS
argument_list|(
name|OP_MASK_RT
argument_list|,
name|OP_SH_RT
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
name|USE_BITS
argument_list|(
name|OP_MASK_VECBYTE
argument_list|,
name|OP_SH_VECBYTE
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'%'
case|:
name|USE_BITS
argument_list|(
name|OP_MASK_VECALIGN
argument_list|,
name|OP_SH_VECALIGN
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'['
case|:
break|break;
case|case
literal|']'
case|:
break|break;
default|default:
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"internal: bad mips opcode (unknown operand type `%c'): %s %s"
argument_list|)
argument_list|,
name|c
argument_list|,
name|opc
operator|->
name|name
argument_list|,
name|opc
operator|->
name|args
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
undef|#
directive|undef
name|USE_BITS
if|if
condition|(
name|used_bits
operator|!=
literal|0xffffffff
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"internal: bad mips opcode (bits 0x%lx undefined): %s %s"
argument_list|)
argument_list|,
operator|~
name|used_bits
operator|&
literal|0xffffffff
argument_list|,
name|opc
operator|->
name|name
argument_list|,
name|opc
operator|->
name|args
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* This routine assembles an instruction into its binary format.  As a    side effect, it sets one of the global variables imm_reloc or    offset_reloc to the type of relocation to do if one of the operands    is an address expression.  */
end_comment

begin_function
specifier|static
name|void
name|mips_ip
parameter_list|(
name|char
modifier|*
name|str
parameter_list|,
name|struct
name|mips_cl_insn
modifier|*
name|ip
parameter_list|)
block|{
name|char
modifier|*
name|s
decl_stmt|;
specifier|const
name|char
modifier|*
name|args
decl_stmt|;
name|char
name|c
init|=
literal|0
decl_stmt|;
name|struct
name|mips_opcode
modifier|*
name|insn
decl_stmt|;
name|char
modifier|*
name|argsStart
decl_stmt|;
name|unsigned
name|int
name|regno
decl_stmt|;
name|unsigned
name|int
name|lastregno
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|lastpos
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|limlo
decl_stmt|,
name|limhi
decl_stmt|;
name|char
modifier|*
name|s_reset
decl_stmt|;
name|char
name|save_c
init|=
literal|0
decl_stmt|;
name|insn_error
operator|=
name|NULL
expr_stmt|;
comment|/* If the instruction contains a '.', we first try to match an instruction      including the '.'.  Then we try again without the '.'.  */
name|insn
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|s
operator|=
name|str
init|;
operator|*
name|s
operator|!=
literal|'\0'
operator|&&
operator|!
name|ISSPACE
argument_list|(
operator|*
name|s
argument_list|)
condition|;
operator|++
name|s
control|)
continue|continue;
comment|/* If we stopped on whitespace, then replace the whitespace with null for      the call to hash_find.  Save the character we replaced just in case we      have to re-parse the instruction.  */
if|if
condition|(
name|ISSPACE
argument_list|(
operator|*
name|s
argument_list|)
condition|)
block|{
name|save_c
operator|=
operator|*
name|s
expr_stmt|;
operator|*
name|s
operator|++
operator|=
literal|'\0'
expr_stmt|;
block|}
name|insn
operator|=
operator|(
expr|struct
name|mips_opcode
operator|*
operator|)
name|hash_find
argument_list|(
name|op_hash
argument_list|,
name|str
argument_list|)
expr_stmt|;
comment|/* If we didn't find the instruction in the opcode table, try again, but      this time with just the instruction up to, but not including the      first '.'.  */
if|if
condition|(
name|insn
operator|==
name|NULL
condition|)
block|{
comment|/* Restore the character we overwrite above (if any).  */
if|if
condition|(
name|save_c
condition|)
operator|*
operator|(
operator|--
name|s
operator|)
operator|=
name|save_c
expr_stmt|;
comment|/* Scan up to the first '.' or whitespace.  */
for|for
control|(
name|s
operator|=
name|str
init|;
operator|*
name|s
operator|!=
literal|'\0'
operator|&&
operator|*
name|s
operator|!=
literal|'.'
operator|&&
operator|!
name|ISSPACE
argument_list|(
operator|*
name|s
argument_list|)
condition|;
operator|++
name|s
control|)
continue|continue;
comment|/* If we did not find a '.', then we can quit now.  */
if|if
condition|(
operator|*
name|s
operator|!=
literal|'.'
condition|)
block|{
name|insn_error
operator|=
literal|"unrecognized opcode"
expr_stmt|;
return|return;
block|}
comment|/* Lookup the instruction in the hash table.  */
operator|*
name|s
operator|++
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|(
name|insn
operator|=
operator|(
expr|struct
name|mips_opcode
operator|*
operator|)
name|hash_find
argument_list|(
name|op_hash
argument_list|,
name|str
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|insn_error
operator|=
literal|"unrecognized opcode"
expr_stmt|;
return|return;
block|}
block|}
name|argsStart
operator|=
name|s
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|bfd_boolean
name|ok
decl_stmt|;
name|assert
argument_list|(
name|strcmp
argument_list|(
name|insn
operator|->
name|name
argument_list|,
name|str
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|OPCODE_IS_MEMBER
argument_list|(
name|insn
argument_list|,
operator|(
name|mips_opts
operator|.
name|isa
operator||
operator|(
name|file_ase_mips16
condition|?
name|INSN_MIPS16
else|:
literal|0
operator|)
operator||
operator|(
name|mips_opts
operator|.
name|ase_mdmx
condition|?
name|INSN_MDMX
else|:
literal|0
operator|)
operator||
operator|(
name|mips_opts
operator|.
name|ase_mips3d
condition|?
name|INSN_MIPS3D
else|:
literal|0
operator|)
operator|)
argument_list|,
name|mips_opts
operator|.
name|arch
argument_list|)
condition|)
name|ok
operator|=
name|TRUE
expr_stmt|;
else|else
name|ok
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|insn
operator|->
name|pinfo
operator|!=
name|INSN_MACRO
condition|)
block|{
if|if
condition|(
name|mips_opts
operator|.
name|arch
operator|==
name|CPU_R4650
operator|&&
operator|(
name|insn
operator|->
name|pinfo
operator|&
name|FP_D
operator|)
operator|!=
literal|0
condition|)
name|ok
operator|=
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|ok
condition|)
block|{
if|if
condition|(
name|insn
operator|+
literal|1
operator|<
operator|&
name|mips_opcodes
index|[
name|NUMOPCODES
index|]
operator|&&
name|strcmp
argument_list|(
name|insn
operator|->
name|name
argument_list|,
name|insn
index|[
literal|1
index|]
operator|.
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|++
name|insn
expr_stmt|;
continue|continue;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|insn_error
condition|)
block|{
specifier|static
name|char
name|buf
index|[
literal|100
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
name|_
argument_list|(
literal|"opcode not supported on this processor: %s (%s)"
argument_list|)
argument_list|,
name|mips_cpu_info_from_arch
argument_list|(
name|mips_opts
operator|.
name|arch
argument_list|)
operator|->
name|name
argument_list|,
name|mips_cpu_info_from_isa
argument_list|(
name|mips_opts
operator|.
name|isa
argument_list|)
operator|->
name|name
argument_list|)
expr_stmt|;
name|insn_error
operator|=
name|buf
expr_stmt|;
block|}
if|if
condition|(
name|save_c
condition|)
operator|*
operator|(
operator|--
name|s
operator|)
operator|=
name|save_c
expr_stmt|;
return|return;
block|}
block|}
name|ip
operator|->
name|insn_mo
operator|=
name|insn
expr_stmt|;
name|ip
operator|->
name|insn_opcode
operator|=
name|insn
operator|->
name|match
expr_stmt|;
name|insn_error
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|args
operator|=
name|insn
operator|->
name|args
init|;
condition|;
operator|++
name|args
control|)
block|{
name|int
name|is_mdmx
decl_stmt|;
name|s
operator|+=
name|strspn
argument_list|(
name|s
argument_list|,
literal|" \t"
argument_list|)
expr_stmt|;
name|is_mdmx
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
operator|*
name|args
condition|)
block|{
case|case
literal|'\0'
case|:
comment|/* end of args */
if|if
condition|(
operator|*
name|s
operator|==
literal|'\0'
condition|)
return|return;
break|break;
case|case
literal|','
case|:
if|if
condition|(
operator|*
name|s
operator|++
operator|==
operator|*
name|args
condition|)
continue|continue;
name|s
operator|--
expr_stmt|;
switch|switch
condition|(
operator|*
operator|++
name|args
condition|)
block|{
case|case
literal|'r'
case|:
case|case
literal|'v'
case|:
name|ip
operator|->
name|insn_opcode
operator||=
name|lastregno
operator|<<
name|OP_SH_RS
expr_stmt|;
continue|continue;
case|case
literal|'w'
case|:
name|ip
operator|->
name|insn_opcode
operator||=
name|lastregno
operator|<<
name|OP_SH_RT
expr_stmt|;
continue|continue;
case|case
literal|'W'
case|:
name|ip
operator|->
name|insn_opcode
operator||=
name|lastregno
operator|<<
name|OP_SH_FT
expr_stmt|;
continue|continue;
case|case
literal|'V'
case|:
name|ip
operator|->
name|insn_opcode
operator||=
name|lastregno
operator|<<
name|OP_SH_FS
expr_stmt|;
continue|continue;
block|}
break|break;
case|case
literal|'('
case|:
comment|/* Handle optional base register. 		 Either the base register is omitted or 		 we must have a left paren.  */
comment|/* This is dependent on the next operand specifier 		 is a base register specification.  */
name|assert
argument_list|(
name|args
index|[
literal|1
index|]
operator|==
literal|'b'
operator|||
name|args
index|[
literal|1
index|]
operator|==
literal|'5'
operator|||
name|args
index|[
literal|1
index|]
operator|==
literal|'-'
operator|||
name|args
index|[
literal|1
index|]
operator|==
literal|'4'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'\0'
condition|)
return|return;
case|case
literal|')'
case|:
comment|/* these must match exactly */
case|case
literal|'['
case|:
case|case
literal|']'
case|:
if|if
condition|(
operator|*
name|s
operator|++
operator|==
operator|*
name|args
condition|)
continue|continue;
break|break;
case|case
literal|'+'
case|:
comment|/* Opcode extension character.  */
switch|switch
condition|(
operator|*
operator|++
name|args
condition|)
block|{
case|case
literal|'A'
case|:
comment|/* ins/ext position, becomes LSB.  */
name|limlo
operator|=
literal|0
expr_stmt|;
name|limhi
operator|=
literal|31
expr_stmt|;
goto|goto
name|do_lsb
goto|;
case|case
literal|'E'
case|:
name|limlo
operator|=
literal|32
expr_stmt|;
name|limhi
operator|=
literal|63
expr_stmt|;
goto|goto
name|do_lsb
goto|;
name|do_lsb
label|:
name|my_getExpression
argument_list|(
operator|&
name|imm_expr
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|check_absolute_expr
argument_list|(
name|ip
argument_list|,
operator|&
name|imm_expr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|unsigned
name|long
operator|)
name|imm_expr
operator|.
name|X_add_number
operator|<
name|limlo
operator|||
operator|(
name|unsigned
name|long
operator|)
name|imm_expr
operator|.
name|X_add_number
operator|>
name|limhi
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Improper position (%lu)"
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|imm_expr
operator|.
name|X_add_number
argument_list|)
expr_stmt|;
name|imm_expr
operator|.
name|X_add_number
operator|=
name|limlo
expr_stmt|;
block|}
name|lastpos
operator|=
name|imm_expr
operator|.
name|X_add_number
expr_stmt|;
name|ip
operator|->
name|insn_opcode
operator||=
operator|(
name|imm_expr
operator|.
name|X_add_number
operator|&
name|OP_MASK_SHAMT
operator|)
operator|<<
name|OP_SH_SHAMT
expr_stmt|;
name|imm_expr
operator|.
name|X_op
operator|=
name|O_absent
expr_stmt|;
name|s
operator|=
name|expr_end
expr_stmt|;
continue|continue;
case|case
literal|'B'
case|:
comment|/* ins size, becomes MSB.  */
name|limlo
operator|=
literal|1
expr_stmt|;
name|limhi
operator|=
literal|32
expr_stmt|;
goto|goto
name|do_msb
goto|;
case|case
literal|'F'
case|:
name|limlo
operator|=
literal|33
expr_stmt|;
name|limhi
operator|=
literal|64
expr_stmt|;
goto|goto
name|do_msb
goto|;
name|do_msb
label|:
name|my_getExpression
argument_list|(
operator|&
name|imm_expr
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|check_absolute_expr
argument_list|(
name|ip
argument_list|,
operator|&
name|imm_expr
argument_list|)
expr_stmt|;
comment|/* Check for negative input so that small negative numbers 		     will not succeed incorrectly.  The checks against 		     (pos+size) transitively check "size" itself, 		     assuming that "pos" is reasonable.  */
if|if
condition|(
operator|(
name|long
operator|)
name|imm_expr
operator|.
name|X_add_number
operator|<
literal|0
operator|||
operator|(
operator|(
name|unsigned
name|long
operator|)
name|imm_expr
operator|.
name|X_add_number
operator|+
name|lastpos
operator|)
operator|<
name|limlo
operator|||
operator|(
operator|(
name|unsigned
name|long
operator|)
name|imm_expr
operator|.
name|X_add_number
operator|+
name|lastpos
operator|)
operator|>
name|limhi
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Improper insert size (%lu, position %lu)"
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|imm_expr
operator|.
name|X_add_number
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|lastpos
argument_list|)
expr_stmt|;
name|imm_expr
operator|.
name|X_add_number
operator|=
name|limlo
operator|-
name|lastpos
expr_stmt|;
block|}
name|ip
operator|->
name|insn_opcode
operator||=
operator|(
operator|(
name|lastpos
operator|+
name|imm_expr
operator|.
name|X_add_number
operator|-
literal|1
operator|)
operator|&
name|OP_MASK_INSMSB
operator|)
operator|<<
name|OP_SH_INSMSB
expr_stmt|;
name|imm_expr
operator|.
name|X_op
operator|=
name|O_absent
expr_stmt|;
name|s
operator|=
name|expr_end
expr_stmt|;
continue|continue;
case|case
literal|'C'
case|:
comment|/* ext size, becomes MSBD.  */
name|limlo
operator|=
literal|1
expr_stmt|;
name|limhi
operator|=
literal|32
expr_stmt|;
goto|goto
name|do_msbd
goto|;
case|case
literal|'G'
case|:
name|limlo
operator|=
literal|33
expr_stmt|;
name|limhi
operator|=
literal|64
expr_stmt|;
goto|goto
name|do_msbd
goto|;
case|case
literal|'H'
case|:
name|limlo
operator|=
literal|33
expr_stmt|;
name|limhi
operator|=
literal|64
expr_stmt|;
goto|goto
name|do_msbd
goto|;
name|do_msbd
label|:
name|my_getExpression
argument_list|(
operator|&
name|imm_expr
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|check_absolute_expr
argument_list|(
name|ip
argument_list|,
operator|&
name|imm_expr
argument_list|)
expr_stmt|;
comment|/* Check for negative input so that small negative numbers 		     will not succeed incorrectly.  The checks against 		     (pos+size) transitively check "size" itself, 		     assuming that "pos" is reasonable.  */
if|if
condition|(
operator|(
name|long
operator|)
name|imm_expr
operator|.
name|X_add_number
operator|<
literal|0
operator|||
operator|(
operator|(
name|unsigned
name|long
operator|)
name|imm_expr
operator|.
name|X_add_number
operator|+
name|lastpos
operator|)
operator|<
name|limlo
operator|||
operator|(
operator|(
name|unsigned
name|long
operator|)
name|imm_expr
operator|.
name|X_add_number
operator|+
name|lastpos
operator|)
operator|>
name|limhi
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Improper extract size (%lu, position %lu)"
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|imm_expr
operator|.
name|X_add_number
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|lastpos
argument_list|)
expr_stmt|;
name|imm_expr
operator|.
name|X_add_number
operator|=
name|limlo
operator|-
name|lastpos
expr_stmt|;
block|}
name|ip
operator|->
name|insn_opcode
operator||=
operator|(
operator|(
name|imm_expr
operator|.
name|X_add_number
operator|-
literal|1
operator|)
operator|&
name|OP_MASK_EXTMSBD
operator|)
operator|<<
name|OP_SH_EXTMSBD
expr_stmt|;
name|imm_expr
operator|.
name|X_op
operator|=
name|O_absent
expr_stmt|;
name|s
operator|=
name|expr_end
expr_stmt|;
continue|continue;
case|case
literal|'D'
case|:
comment|/* +D is for disassembly only; never match.  */
break|break;
case|case
literal|'I'
case|:
comment|/* "+I" is like "I", except that imm2_expr is used.  */
name|my_getExpression
argument_list|(
operator|&
name|imm2_expr
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|imm2_expr
operator|.
name|X_op
operator|!=
name|O_big
operator|&&
name|imm2_expr
operator|.
name|X_op
operator|!=
name|O_constant
condition|)
name|insn_error
operator|=
name|_
argument_list|(
literal|"absolute expression required"
argument_list|)
expr_stmt|;
name|normalize_constant_expr
argument_list|(
operator|&
name|imm2_expr
argument_list|)
expr_stmt|;
name|s
operator|=
name|expr_end
expr_stmt|;
continue|continue;
default|default:
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"internal: bad mips opcode (unknown extension operand type `+%c'): %s %s"
argument_list|)
argument_list|,
operator|*
name|args
argument_list|,
name|insn
operator|->
name|name
argument_list|,
name|insn
operator|->
name|args
argument_list|)
expr_stmt|;
comment|/* Further processing is fruitless.  */
return|return;
block|}
break|break;
case|case
literal|'<'
case|:
comment|/* must be at least one digit */
comment|/* 	       * According to the manual, if the shift amount is greater 	       * than 31 or less than 0, then the shift amount should be 	       * mod 32.  In reality the mips assembler issues an error. 	       * We issue a warning and mask out all but the low 5 bits. 	       */
name|my_getExpression
argument_list|(
operator|&
name|imm_expr
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|check_absolute_expr
argument_list|(
name|ip
argument_list|,
operator|&
name|imm_expr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|unsigned
name|long
operator|)
name|imm_expr
operator|.
name|X_add_number
operator|>
literal|31
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"Improper shift amount (%lu)"
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|imm_expr
operator|.
name|X_add_number
argument_list|)
expr_stmt|;
name|imm_expr
operator|.
name|X_add_number
operator|&=
name|OP_MASK_SHAMT
expr_stmt|;
block|}
name|ip
operator|->
name|insn_opcode
operator||=
name|imm_expr
operator|.
name|X_add_number
operator|<<
name|OP_SH_SHAMT
expr_stmt|;
name|imm_expr
operator|.
name|X_op
operator|=
name|O_absent
expr_stmt|;
name|s
operator|=
name|expr_end
expr_stmt|;
continue|continue;
case|case
literal|'>'
case|:
comment|/* shift amount minus 32 */
name|my_getExpression
argument_list|(
operator|&
name|imm_expr
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|check_absolute_expr
argument_list|(
name|ip
argument_list|,
operator|&
name|imm_expr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|unsigned
name|long
operator|)
name|imm_expr
operator|.
name|X_add_number
operator|<
literal|32
operator|||
operator|(
name|unsigned
name|long
operator|)
name|imm_expr
operator|.
name|X_add_number
operator|>
literal|63
condition|)
break|break;
name|ip
operator|->
name|insn_opcode
operator||=
operator|(
name|imm_expr
operator|.
name|X_add_number
operator|-
literal|32
operator|)
operator|<<
name|OP_SH_SHAMT
expr_stmt|;
name|imm_expr
operator|.
name|X_op
operator|=
name|O_absent
expr_stmt|;
name|s
operator|=
name|expr_end
expr_stmt|;
continue|continue;
case|case
literal|'k'
case|:
comment|/* cache code */
case|case
literal|'h'
case|:
comment|/* prefx code */
name|my_getExpression
argument_list|(
operator|&
name|imm_expr
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|check_absolute_expr
argument_list|(
name|ip
argument_list|,
operator|&
name|imm_expr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|unsigned
name|long
operator|)
name|imm_expr
operator|.
name|X_add_number
operator|>
literal|31
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"Invalid value for `%s' (%lu)"
argument_list|)
argument_list|,
name|ip
operator|->
name|insn_mo
operator|->
name|name
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|imm_expr
operator|.
name|X_add_number
argument_list|)
expr_stmt|;
name|imm_expr
operator|.
name|X_add_number
operator|&=
literal|0x1f
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|args
operator|==
literal|'k'
condition|)
name|ip
operator|->
name|insn_opcode
operator||=
name|imm_expr
operator|.
name|X_add_number
operator|<<
name|OP_SH_CACHE
expr_stmt|;
else|else
name|ip
operator|->
name|insn_opcode
operator||=
name|imm_expr
operator|.
name|X_add_number
operator|<<
name|OP_SH_PREFX
expr_stmt|;
name|imm_expr
operator|.
name|X_op
operator|=
name|O_absent
expr_stmt|;
name|s
operator|=
name|expr_end
expr_stmt|;
continue|continue;
case|case
literal|'c'
case|:
comment|/* break code */
name|my_getExpression
argument_list|(
operator|&
name|imm_expr
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|check_absolute_expr
argument_list|(
name|ip
argument_list|,
operator|&
name|imm_expr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|unsigned
name|long
operator|)
name|imm_expr
operator|.
name|X_add_number
operator|>
literal|1023
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"Illegal break code (%lu)"
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|imm_expr
operator|.
name|X_add_number
argument_list|)
expr_stmt|;
name|imm_expr
operator|.
name|X_add_number
operator|&=
name|OP_MASK_CODE
expr_stmt|;
block|}
name|ip
operator|->
name|insn_opcode
operator||=
name|imm_expr
operator|.
name|X_add_number
operator|<<
name|OP_SH_CODE
expr_stmt|;
name|imm_expr
operator|.
name|X_op
operator|=
name|O_absent
expr_stmt|;
name|s
operator|=
name|expr_end
expr_stmt|;
continue|continue;
case|case
literal|'q'
case|:
comment|/* lower break code */
name|my_getExpression
argument_list|(
operator|&
name|imm_expr
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|check_absolute_expr
argument_list|(
name|ip
argument_list|,
operator|&
name|imm_expr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|unsigned
name|long
operator|)
name|imm_expr
operator|.
name|X_add_number
operator|>
literal|1023
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"Illegal lower break code (%lu)"
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|imm_expr
operator|.
name|X_add_number
argument_list|)
expr_stmt|;
name|imm_expr
operator|.
name|X_add_number
operator|&=
name|OP_MASK_CODE2
expr_stmt|;
block|}
name|ip
operator|->
name|insn_opcode
operator||=
name|imm_expr
operator|.
name|X_add_number
operator|<<
name|OP_SH_CODE2
expr_stmt|;
name|imm_expr
operator|.
name|X_op
operator|=
name|O_absent
expr_stmt|;
name|s
operator|=
name|expr_end
expr_stmt|;
continue|continue;
case|case
literal|'B'
case|:
comment|/* 20-bit syscall/break code.  */
name|my_getExpression
argument_list|(
operator|&
name|imm_expr
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|check_absolute_expr
argument_list|(
name|ip
argument_list|,
operator|&
name|imm_expr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|unsigned
name|long
operator|)
name|imm_expr
operator|.
name|X_add_number
operator|>
name|OP_MASK_CODE20
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"Illegal 20-bit code (%lu)"
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|imm_expr
operator|.
name|X_add_number
argument_list|)
expr_stmt|;
name|ip
operator|->
name|insn_opcode
operator||=
name|imm_expr
operator|.
name|X_add_number
operator|<<
name|OP_SH_CODE20
expr_stmt|;
name|imm_expr
operator|.
name|X_op
operator|=
name|O_absent
expr_stmt|;
name|s
operator|=
name|expr_end
expr_stmt|;
continue|continue;
case|case
literal|'C'
case|:
comment|/* Coprocessor code */
name|my_getExpression
argument_list|(
operator|&
name|imm_expr
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|check_absolute_expr
argument_list|(
name|ip
argument_list|,
operator|&
name|imm_expr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|unsigned
name|long
operator|)
name|imm_expr
operator|.
name|X_add_number
operator|>=
operator|(
literal|1
operator|<<
literal|25
operator|)
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"Coproccesor code> 25 bits (%lu)"
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|imm_expr
operator|.
name|X_add_number
argument_list|)
expr_stmt|;
name|imm_expr
operator|.
name|X_add_number
operator|&=
operator|(
operator|(
literal|1
operator|<<
literal|25
operator|)
operator|-
literal|1
operator|)
expr_stmt|;
block|}
name|ip
operator|->
name|insn_opcode
operator||=
name|imm_expr
operator|.
name|X_add_number
expr_stmt|;
name|imm_expr
operator|.
name|X_op
operator|=
name|O_absent
expr_stmt|;
name|s
operator|=
name|expr_end
expr_stmt|;
continue|continue;
case|case
literal|'J'
case|:
comment|/* 19-bit wait code.  */
name|my_getExpression
argument_list|(
operator|&
name|imm_expr
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|check_absolute_expr
argument_list|(
name|ip
argument_list|,
operator|&
name|imm_expr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|unsigned
name|long
operator|)
name|imm_expr
operator|.
name|X_add_number
operator|>
name|OP_MASK_CODE19
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"Illegal 19-bit code (%lu)"
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|imm_expr
operator|.
name|X_add_number
argument_list|)
expr_stmt|;
name|ip
operator|->
name|insn_opcode
operator||=
name|imm_expr
operator|.
name|X_add_number
operator|<<
name|OP_SH_CODE19
expr_stmt|;
name|imm_expr
operator|.
name|X_op
operator|=
name|O_absent
expr_stmt|;
name|s
operator|=
name|expr_end
expr_stmt|;
continue|continue;
case|case
literal|'P'
case|:
comment|/* Performance register */
name|my_getExpression
argument_list|(
operator|&
name|imm_expr
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|check_absolute_expr
argument_list|(
name|ip
argument_list|,
operator|&
name|imm_expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|imm_expr
operator|.
name|X_add_number
operator|!=
literal|0
operator|&&
name|imm_expr
operator|.
name|X_add_number
operator|!=
literal|1
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"Invalid performance register (%lu)"
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|imm_expr
operator|.
name|X_add_number
argument_list|)
expr_stmt|;
name|imm_expr
operator|.
name|X_add_number
operator|&=
name|OP_MASK_PERFREG
expr_stmt|;
block|}
name|ip
operator|->
name|insn_opcode
operator||=
operator|(
name|imm_expr
operator|.
name|X_add_number
operator|<<
name|OP_SH_PERFREG
operator|)
expr_stmt|;
name|imm_expr
operator|.
name|X_op
operator|=
name|O_absent
expr_stmt|;
name|s
operator|=
name|expr_end
expr_stmt|;
continue|continue;
case|case
literal|'b'
case|:
comment|/* base register */
case|case
literal|'d'
case|:
comment|/* destination register */
case|case
literal|'s'
case|:
comment|/* source register */
case|case
literal|'t'
case|:
comment|/* target register */
case|case
literal|'r'
case|:
comment|/* both target and source */
case|case
literal|'v'
case|:
comment|/* both dest and source */
case|case
literal|'w'
case|:
comment|/* both dest and target */
case|case
literal|'E'
case|:
comment|/* coprocessor target register */
case|case
literal|'G'
case|:
comment|/* coprocessor destination register */
case|case
literal|'K'
case|:
comment|/* 'rdhwr' destination register */
case|case
literal|'x'
case|:
comment|/* ignore register name */
case|case
literal|'z'
case|:
comment|/* must be zero register */
case|case
literal|'U'
case|:
comment|/* destination register (clo/clz).  */
name|s_reset
operator|=
name|s
expr_stmt|;
if|if
condition|(
name|s
index|[
literal|0
index|]
operator|==
literal|'$'
condition|)
block|{
if|if
condition|(
name|ISDIGIT
argument_list|(
name|s
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
operator|++
name|s
expr_stmt|;
name|regno
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|regno
operator|*=
literal|10
expr_stmt|;
name|regno
operator|+=
operator|*
name|s
operator|-
literal|'0'
expr_stmt|;
operator|++
name|s
expr_stmt|;
block|}
do|while
condition|(
name|ISDIGIT
argument_list|(
operator|*
name|s
argument_list|)
condition|)
do|;
if|if
condition|(
name|regno
operator|>
literal|31
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Invalid register number (%d)"
argument_list|)
argument_list|,
name|regno
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|args
operator|==
literal|'E'
operator|||
operator|*
name|args
operator|==
literal|'G'
operator|||
operator|*
name|args
operator|==
literal|'K'
condition|)
goto|goto
name|notreg
goto|;
else|else
block|{
if|if
condition|(
name|s
index|[
literal|1
index|]
operator|==
literal|'r'
operator|&&
name|s
index|[
literal|2
index|]
operator|==
literal|'a'
condition|)
block|{
name|s
operator|+=
literal|3
expr_stmt|;
name|regno
operator|=
name|RA
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|s
index|[
literal|1
index|]
operator|==
literal|'f'
operator|&&
name|s
index|[
literal|2
index|]
operator|==
literal|'p'
condition|)
block|{
name|s
operator|+=
literal|3
expr_stmt|;
name|regno
operator|=
name|FP
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|s
index|[
literal|1
index|]
operator|==
literal|'s'
operator|&&
name|s
index|[
literal|2
index|]
operator|==
literal|'p'
condition|)
block|{
name|s
operator|+=
literal|3
expr_stmt|;
name|regno
operator|=
name|SP
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|s
index|[
literal|1
index|]
operator|==
literal|'g'
operator|&&
name|s
index|[
literal|2
index|]
operator|==
literal|'p'
condition|)
block|{
name|s
operator|+=
literal|3
expr_stmt|;
name|regno
operator|=
name|GP
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|s
index|[
literal|1
index|]
operator|==
literal|'a'
operator|&&
name|s
index|[
literal|2
index|]
operator|==
literal|'t'
condition|)
block|{
name|s
operator|+=
literal|3
expr_stmt|;
name|regno
operator|=
name|AT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|s
index|[
literal|1
index|]
operator|==
literal|'k'
operator|&&
name|s
index|[
literal|2
index|]
operator|==
literal|'t'
operator|&&
name|s
index|[
literal|3
index|]
operator|==
literal|'0'
condition|)
block|{
name|s
operator|+=
literal|4
expr_stmt|;
name|regno
operator|=
name|KT0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|s
index|[
literal|1
index|]
operator|==
literal|'k'
operator|&&
name|s
index|[
literal|2
index|]
operator|==
literal|'t'
operator|&&
name|s
index|[
literal|3
index|]
operator|==
literal|'1'
condition|)
block|{
name|s
operator|+=
literal|4
expr_stmt|;
name|regno
operator|=
name|KT1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|s
index|[
literal|1
index|]
operator|==
literal|'z'
operator|&&
name|s
index|[
literal|2
index|]
operator|==
literal|'e'
operator|&&
name|s
index|[
literal|3
index|]
operator|==
literal|'r'
operator|&&
name|s
index|[
literal|4
index|]
operator|==
literal|'o'
condition|)
block|{
name|s
operator|+=
literal|5
expr_stmt|;
name|regno
operator|=
name|ZERO
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|itbl_have_entries
condition|)
block|{
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|n
decl_stmt|;
name|unsigned
name|long
name|r
decl_stmt|;
name|p
operator|=
name|s
operator|+
literal|1
expr_stmt|;
comment|/* advance past '$' */
name|n
operator|=
name|itbl_get_field
argument_list|(
operator|&
name|p
argument_list|)
expr_stmt|;
comment|/* n is name */
comment|/* See if this is a register defined in an 			     itbl entry.  */
if|if
condition|(
name|itbl_get_reg_val
argument_list|(
name|n
argument_list|,
operator|&
name|r
argument_list|)
condition|)
block|{
comment|/* Get_field advances to the start of 				 the next field, so we need to back 				 rack to the end of the last field.  */
if|if
condition|(
name|p
condition|)
name|s
operator|=
name|p
operator|-
literal|1
expr_stmt|;
else|else
name|s
operator|=
name|strchr
argument_list|(
name|s
argument_list|,
literal|'\0'
argument_list|)
expr_stmt|;
name|regno
operator|=
name|r
expr_stmt|;
block|}
else|else
goto|goto
name|notreg
goto|;
block|}
else|else
goto|goto
name|notreg
goto|;
block|}
if|if
condition|(
name|regno
operator|==
name|AT
operator|&&
operator|!
name|mips_opts
operator|.
name|noat
operator|&&
operator|*
name|args
operator|!=
literal|'E'
operator|&&
operator|*
name|args
operator|!=
literal|'G'
operator|&&
operator|*
name|args
operator|!=
literal|'K'
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"Used $at without \".set noat\""
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|=
operator|*
name|args
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|' '
condition|)
operator|++
name|s
expr_stmt|;
if|if
condition|(
name|args
index|[
literal|1
index|]
operator|!=
operator|*
name|s
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'r'
operator|||
name|c
operator|==
literal|'v'
operator|||
name|c
operator|==
literal|'w'
condition|)
block|{
name|regno
operator|=
name|lastregno
expr_stmt|;
name|s
operator|=
name|s_reset
expr_stmt|;
operator|++
name|args
expr_stmt|;
block|}
block|}
comment|/* 'z' only matches $0.  */
if|if
condition|(
name|c
operator|==
literal|'z'
operator|&&
name|regno
operator|!=
literal|0
condition|)
break|break;
comment|/* Now that we have assembled one operand, we use the args string 	 * to figure out where it goes in the instruction.  */
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'r'
case|:
case|case
literal|'s'
case|:
case|case
literal|'v'
case|:
case|case
literal|'b'
case|:
name|ip
operator|->
name|insn_opcode
operator||=
name|regno
operator|<<
name|OP_SH_RS
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
case|case
literal|'G'
case|:
case|case
literal|'K'
case|:
name|ip
operator|->
name|insn_opcode
operator||=
name|regno
operator|<<
name|OP_SH_RD
expr_stmt|;
break|break;
case|case
literal|'U'
case|:
name|ip
operator|->
name|insn_opcode
operator||=
name|regno
operator|<<
name|OP_SH_RD
expr_stmt|;
name|ip
operator|->
name|insn_opcode
operator||=
name|regno
operator|<<
name|OP_SH_RT
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
case|case
literal|'t'
case|:
case|case
literal|'E'
case|:
name|ip
operator|->
name|insn_opcode
operator||=
name|regno
operator|<<
name|OP_SH_RT
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
comment|/* This case exists because on the r3000 trunc 			 expands into a macro which requires a gp 			 register.  On the r6000 or r4000 it is 			 assembled into a single instruction which 			 ignores the register.  Thus the insn version 			 is MIPS_ISA2 and uses 'x', and the macro 			 version is MIPS_ISA1 and uses 't'.  */
break|break;
case|case
literal|'z'
case|:
comment|/* This case is for the div instruction, which 			 acts differently if the destination argument 			 is $0.  This only matches $0, and is checked 			 outside the switch.  */
break|break;
case|case
literal|'D'
case|:
comment|/* Itbl operand; not yet implemented. FIXME ?? */
break|break;
comment|/* What about all other operands like 'i', which 			 can be specified in the opcode table? */
block|}
name|lastregno
operator|=
name|regno
expr_stmt|;
continue|continue;
block|}
name|notreg
label|:
switch|switch
condition|(
operator|*
name|args
operator|++
condition|)
block|{
case|case
literal|'r'
case|:
case|case
literal|'v'
case|:
name|ip
operator|->
name|insn_opcode
operator||=
name|lastregno
operator|<<
name|OP_SH_RS
expr_stmt|;
continue|continue;
case|case
literal|'w'
case|:
name|ip
operator|->
name|insn_opcode
operator||=
name|lastregno
operator|<<
name|OP_SH_RT
expr_stmt|;
continue|continue;
block|}
break|break;
case|case
literal|'O'
case|:
comment|/* MDMX alignment immediate constant.  */
name|my_getExpression
argument_list|(
operator|&
name|imm_expr
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|check_absolute_expr
argument_list|(
name|ip
argument_list|,
operator|&
name|imm_expr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|unsigned
name|long
operator|)
name|imm_expr
operator|.
name|X_add_number
operator|>
name|OP_MASK_ALN
condition|)
block|{
name|as_warn
argument_list|(
literal|"Improper align amount (%ld), using low bits"
argument_list|,
operator|(
name|long
operator|)
name|imm_expr
operator|.
name|X_add_number
argument_list|)
expr_stmt|;
name|imm_expr
operator|.
name|X_add_number
operator|&=
name|OP_MASK_ALN
expr_stmt|;
block|}
name|ip
operator|->
name|insn_opcode
operator||=
name|imm_expr
operator|.
name|X_add_number
operator|<<
name|OP_SH_ALN
expr_stmt|;
name|imm_expr
operator|.
name|X_op
operator|=
name|O_absent
expr_stmt|;
name|s
operator|=
name|expr_end
expr_stmt|;
continue|continue;
case|case
literal|'Q'
case|:
comment|/* MDMX vector, element sel, or const.  */
if|if
condition|(
name|s
index|[
literal|0
index|]
operator|!=
literal|'$'
condition|)
block|{
comment|/* MDMX Immediate.  */
name|my_getExpression
argument_list|(
operator|&
name|imm_expr
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|check_absolute_expr
argument_list|(
name|ip
argument_list|,
operator|&
name|imm_expr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|unsigned
name|long
operator|)
name|imm_expr
operator|.
name|X_add_number
operator|>
name|OP_MASK_FT
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"Invalid MDMX Immediate (%ld)"
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|imm_expr
operator|.
name|X_add_number
argument_list|)
expr_stmt|;
name|imm_expr
operator|.
name|X_add_number
operator|&=
name|OP_MASK_FT
expr_stmt|;
block|}
name|imm_expr
operator|.
name|X_add_number
operator|&=
name|OP_MASK_FT
expr_stmt|;
if|if
condition|(
name|ip
operator|->
name|insn_opcode
operator|&
operator|(
name|OP_MASK_VSEL
operator|<<
name|OP_SH_VSEL
operator|)
condition|)
name|ip
operator|->
name|insn_opcode
operator||=
name|MDMX_FMTSEL_IMM_QH
operator|<<
name|OP_SH_VSEL
expr_stmt|;
else|else
name|ip
operator|->
name|insn_opcode
operator||=
name|MDMX_FMTSEL_IMM_OB
operator|<<
name|OP_SH_VSEL
expr_stmt|;
name|ip
operator|->
name|insn_opcode
operator||=
name|imm_expr
operator|.
name|X_add_number
operator|<<
name|OP_SH_FT
expr_stmt|;
name|imm_expr
operator|.
name|X_op
operator|=
name|O_absent
expr_stmt|;
name|s
operator|=
name|expr_end
expr_stmt|;
continue|continue;
block|}
comment|/* Not MDMX Immediate.  Fall through.  */
case|case
literal|'X'
case|:
comment|/* MDMX destination register.  */
case|case
literal|'Y'
case|:
comment|/* MDMX source register.  */
case|case
literal|'Z'
case|:
comment|/* MDMX target register.  */
name|is_mdmx
operator|=
literal|1
expr_stmt|;
case|case
literal|'D'
case|:
comment|/* floating point destination register */
case|case
literal|'S'
case|:
comment|/* floating point source register */
case|case
literal|'T'
case|:
comment|/* floating point target register */
case|case
literal|'R'
case|:
comment|/* floating point source register */
case|case
literal|'V'
case|:
case|case
literal|'W'
case|:
name|s_reset
operator|=
name|s
expr_stmt|;
comment|/* Accept $fN for FP and MDMX register numbers, and in                  addition accept $vN for MDMX register numbers.  */
if|if
condition|(
operator|(
name|s
index|[
literal|0
index|]
operator|==
literal|'$'
operator|&&
name|s
index|[
literal|1
index|]
operator|==
literal|'f'
operator|&&
name|ISDIGIT
argument_list|(
name|s
index|[
literal|2
index|]
argument_list|)
operator|)
operator|||
operator|(
name|is_mdmx
operator|!=
literal|0
operator|&&
name|s
index|[
literal|0
index|]
operator|==
literal|'$'
operator|&&
name|s
index|[
literal|1
index|]
operator|==
literal|'v'
operator|&&
name|ISDIGIT
argument_list|(
name|s
index|[
literal|2
index|]
argument_list|)
operator|)
condition|)
block|{
name|s
operator|+=
literal|2
expr_stmt|;
name|regno
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|regno
operator|*=
literal|10
expr_stmt|;
name|regno
operator|+=
operator|*
name|s
operator|-
literal|'0'
expr_stmt|;
operator|++
name|s
expr_stmt|;
block|}
do|while
condition|(
name|ISDIGIT
argument_list|(
operator|*
name|s
argument_list|)
condition|)
do|;
if|if
condition|(
name|regno
operator|>
literal|31
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Invalid float register number (%d)"
argument_list|)
argument_list|,
name|regno
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|regno
operator|&
literal|1
operator|)
operator|!=
literal|0
operator|&&
name|HAVE_32BIT_FPRS
operator|&&
operator|!
operator|(
name|strcmp
argument_list|(
name|str
argument_list|,
literal|"mtc1"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|str
argument_list|,
literal|"mfc1"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|str
argument_list|,
literal|"lwc1"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|str
argument_list|,
literal|"swc1"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|str
argument_list|,
literal|"l.s"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|str
argument_list|,
literal|"s.s"
argument_list|)
operator|==
literal|0
operator|)
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"Float register should be even, was %d"
argument_list|)
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|c
operator|=
operator|*
name|args
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|' '
condition|)
operator|++
name|s
expr_stmt|;
if|if
condition|(
name|args
index|[
literal|1
index|]
operator|!=
operator|*
name|s
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'V'
operator|||
name|c
operator|==
literal|'W'
condition|)
block|{
name|regno
operator|=
name|lastregno
expr_stmt|;
name|s
operator|=
name|s_reset
expr_stmt|;
operator|++
name|args
expr_stmt|;
block|}
block|}
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'D'
case|:
case|case
literal|'X'
case|:
name|ip
operator|->
name|insn_opcode
operator||=
name|regno
operator|<<
name|OP_SH_FD
expr_stmt|;
break|break;
case|case
literal|'V'
case|:
case|case
literal|'S'
case|:
case|case
literal|'Y'
case|:
name|ip
operator|->
name|insn_opcode
operator||=
name|regno
operator|<<
name|OP_SH_FS
expr_stmt|;
break|break;
case|case
literal|'Q'
case|:
comment|/* This is like 'Z', but also needs to fix the MDMX 			 vector/scalar select bits.  Note that the 			 scalar immediate case is handled above.  */
if|if
condition|(
operator|*
name|s
operator|==
literal|'['
condition|)
block|{
name|int
name|is_qh
init|=
operator|(
name|ip
operator|->
name|insn_opcode
operator|&
operator|(
literal|1
operator|<<
name|OP_SH_VSEL
operator|)
operator|)
decl_stmt|;
name|int
name|max_el
init|=
operator|(
name|is_qh
condition|?
literal|3
else|:
literal|7
operator|)
decl_stmt|;
name|s
operator|++
expr_stmt|;
name|my_getExpression
argument_list|(
operator|&
name|imm_expr
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|check_absolute_expr
argument_list|(
name|ip
argument_list|,
operator|&
name|imm_expr
argument_list|)
expr_stmt|;
name|s
operator|=
name|expr_end
expr_stmt|;
if|if
condition|(
name|imm_expr
operator|.
name|X_add_number
operator|>
name|max_el
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Bad element selector %ld"
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|imm_expr
operator|.
name|X_add_number
argument_list|)
expr_stmt|;
name|imm_expr
operator|.
name|X_add_number
operator|&=
name|max_el
expr_stmt|;
name|ip
operator|->
name|insn_opcode
operator||=
operator|(
name|imm_expr
operator|.
name|X_add_number
operator|<<
operator|(
name|OP_SH_VSEL
operator|+
operator|(
name|is_qh
condition|?
literal|2
else|:
literal|1
operator|)
operator|)
operator|)
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|!=
literal|']'
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"Expecting ']' found '%s'"
argument_list|)
argument_list|,
name|s
argument_list|)
expr_stmt|;
else|else
name|s
operator|++
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ip
operator|->
name|insn_opcode
operator|&
operator|(
name|OP_MASK_VSEL
operator|<<
name|OP_SH_VSEL
operator|)
condition|)
name|ip
operator|->
name|insn_opcode
operator||=
operator|(
name|MDMX_FMTSEL_VEC_QH
operator|<<
name|OP_SH_VSEL
operator|)
expr_stmt|;
else|else
name|ip
operator|->
name|insn_opcode
operator||=
operator|(
name|MDMX_FMTSEL_VEC_OB
operator|<<
name|OP_SH_VSEL
operator|)
expr_stmt|;
block|}
comment|/* Fall through */
case|case
literal|'W'
case|:
case|case
literal|'T'
case|:
case|case
literal|'Z'
case|:
name|ip
operator|->
name|insn_opcode
operator||=
name|regno
operator|<<
name|OP_SH_FT
expr_stmt|;
break|break;
case|case
literal|'R'
case|:
name|ip
operator|->
name|insn_opcode
operator||=
name|regno
operator|<<
name|OP_SH_FR
expr_stmt|;
break|break;
block|}
name|lastregno
operator|=
name|regno
expr_stmt|;
continue|continue;
block|}
switch|switch
condition|(
operator|*
name|args
operator|++
condition|)
block|{
case|case
literal|'V'
case|:
name|ip
operator|->
name|insn_opcode
operator||=
name|lastregno
operator|<<
name|OP_SH_FS
expr_stmt|;
continue|continue;
case|case
literal|'W'
case|:
name|ip
operator|->
name|insn_opcode
operator||=
name|lastregno
operator|<<
name|OP_SH_FT
expr_stmt|;
continue|continue;
block|}
break|break;
case|case
literal|'I'
case|:
name|my_getExpression
argument_list|(
operator|&
name|imm_expr
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|imm_expr
operator|.
name|X_op
operator|!=
name|O_big
operator|&&
name|imm_expr
operator|.
name|X_op
operator|!=
name|O_constant
condition|)
name|insn_error
operator|=
name|_
argument_list|(
literal|"absolute expression required"
argument_list|)
expr_stmt|;
name|normalize_constant_expr
argument_list|(
operator|&
name|imm_expr
argument_list|)
expr_stmt|;
name|s
operator|=
name|expr_end
expr_stmt|;
continue|continue;
case|case
literal|'A'
case|:
name|my_getExpression
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|s
argument_list|)
expr_stmt|;
operator|*
name|imm_reloc
operator|=
name|BFD_RELOC_32
expr_stmt|;
name|s
operator|=
name|expr_end
expr_stmt|;
continue|continue;
case|case
literal|'F'
case|:
case|case
literal|'L'
case|:
case|case
literal|'f'
case|:
case|case
literal|'l'
case|:
block|{
name|int
name|f64
decl_stmt|;
name|int
name|using_gprs
decl_stmt|;
name|char
modifier|*
name|save_in
decl_stmt|;
name|char
modifier|*
name|err
decl_stmt|;
name|unsigned
name|char
name|temp
index|[
literal|8
index|]
decl_stmt|;
name|int
name|len
decl_stmt|;
name|unsigned
name|int
name|length
decl_stmt|;
name|segT
name|seg
decl_stmt|;
name|subsegT
name|subseg
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
comment|/* These only appear as the last operand in an 		   instruction, and every instruction that accepts 		   them in any variant accepts them in all variants. 		   This means we don't have to worry about backing out 		   any changes if the instruction does not match.  		   The difference between them is the size of the 		   floating point constant and where it goes.  For 'F' 		   and 'L' the constant is 64 bits; for 'f' and 'l' it 		   is 32 bits.  Where the constant is placed is based 		   on how the MIPS assembler does things: 		    F -- .rdata 		    L -- .lit8 		    f -- immediate value 		    l -- .lit4  		    The .lit4 and .lit8 sections are only used if 		    permitted by the -G argument.  		    When generating embedded PIC code, we use the 		    .lit8 section but not the .lit4 section (we can do 		    .lit4 inline easily; we need to put .lit8 		    somewhere in the data segment, and using .lit8 		    permits the linker to eventually combine identical 		    .lit8 entries).  		    The code below needs to know whether the target register 		    is 32 or 64 bits wide.  It relies on the fact 'f' and 		    'F' are used with GPR-based instructions and 'l' and 		    'L' are used with FPR-based instructions.  */
name|f64
operator|=
operator|*
name|args
operator|==
literal|'F'
operator|||
operator|*
name|args
operator|==
literal|'L'
expr_stmt|;
name|using_gprs
operator|=
operator|*
name|args
operator|==
literal|'F'
operator|||
operator|*
name|args
operator|==
literal|'f'
expr_stmt|;
name|save_in
operator|=
name|input_line_pointer
expr_stmt|;
name|input_line_pointer
operator|=
name|s
expr_stmt|;
name|err
operator|=
name|md_atof
argument_list|(
name|f64
condition|?
literal|'d'
else|:
literal|'f'
argument_list|,
operator|(
name|char
operator|*
operator|)
name|temp
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
name|length
operator|=
name|len
expr_stmt|;
name|s
operator|=
name|input_line_pointer
expr_stmt|;
name|input_line_pointer
operator|=
name|save_in
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|NULL
operator|&&
operator|*
name|err
operator|!=
literal|'\0'
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Bad floating point constant: %s"
argument_list|)
argument_list|,
name|err
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|temp
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
name|temp
argument_list|)
expr_stmt|;
name|length
operator|=
name|f64
condition|?
literal|8
else|:
literal|4
expr_stmt|;
block|}
name|assert
argument_list|(
name|length
operator|==
call|(
name|unsigned
call|)
argument_list|(
name|f64
condition|?
literal|8
else|:
literal|4
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|args
operator|==
literal|'f'
operator|||
operator|(
operator|*
name|args
operator|==
literal|'l'
operator|&&
operator|(
operator|!
name|USE_GLOBAL_POINTER_OPT
operator|||
name|mips_pic
operator|==
name|EMBEDDED_PIC
operator|||
name|g_switch_value
operator|<
literal|4
operator|||
operator|(
name|temp
index|[
literal|0
index|]
operator|==
literal|0
operator|&&
name|temp
index|[
literal|1
index|]
operator|==
literal|0
operator|)
operator|||
operator|(
name|temp
index|[
literal|2
index|]
operator|==
literal|0
operator|&&
name|temp
index|[
literal|3
index|]
operator|==
literal|0
operator|)
operator|)
operator|)
condition|)
block|{
name|imm_expr
operator|.
name|X_op
operator|=
name|O_constant
expr_stmt|;
if|if
condition|(
operator|!
name|target_big_endian
condition|)
name|imm_expr
operator|.
name|X_add_number
operator|=
name|bfd_getl32
argument_list|(
name|temp
argument_list|)
expr_stmt|;
else|else
name|imm_expr
operator|.
name|X_add_number
operator|=
name|bfd_getb32
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|length
operator|>
literal|4
operator|&&
operator|!
name|mips_disable_float_construction
comment|/* Constants can only be constructed in GPRs and 			    copied to FPRs if the GPRs are at least as wide 			    as the FPRs.  Force the constant into memory if 			    we are using 64-bit FPRs but the GPRs are only 			    32 bits wide.  */
operator|&&
operator|(
name|using_gprs
operator|||
operator|!
operator|(
name|HAVE_64BIT_FPRS
operator|&&
name|HAVE_32BIT_GPRS
operator|)
operator|)
operator|&&
operator|(
operator|(
name|temp
index|[
literal|0
index|]
operator|==
literal|0
operator|&&
name|temp
index|[
literal|1
index|]
operator|==
literal|0
operator|)
operator|||
operator|(
name|temp
index|[
literal|2
index|]
operator|==
literal|0
operator|&&
name|temp
index|[
literal|3
index|]
operator|==
literal|0
operator|)
operator|)
operator|&&
operator|(
operator|(
name|temp
index|[
literal|4
index|]
operator|==
literal|0
operator|&&
name|temp
index|[
literal|5
index|]
operator|==
literal|0
operator|)
operator|||
operator|(
name|temp
index|[
literal|6
index|]
operator|==
literal|0
operator|&&
name|temp
index|[
literal|7
index|]
operator|==
literal|0
operator|)
operator|)
condition|)
block|{
comment|/* The value is simple enough to load with a couple of                        instructions.  If using 32-bit registers, set                        imm_expr to the high order 32 bits and offset_expr to                        the low order 32 bits.  Otherwise, set imm_expr to                        the entire 64 bit constant.  */
if|if
condition|(
name|using_gprs
condition|?
name|HAVE_32BIT_GPRS
else|:
name|HAVE_32BIT_FPRS
condition|)
block|{
name|imm_expr
operator|.
name|X_op
operator|=
name|O_constant
expr_stmt|;
name|offset_expr
operator|.
name|X_op
operator|=
name|O_constant
expr_stmt|;
if|if
condition|(
operator|!
name|target_big_endian
condition|)
block|{
name|imm_expr
operator|.
name|X_add_number
operator|=
name|bfd_getl32
argument_list|(
name|temp
operator|+
literal|4
argument_list|)
expr_stmt|;
name|offset_expr
operator|.
name|X_add_number
operator|=
name|bfd_getl32
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|imm_expr
operator|.
name|X_add_number
operator|=
name|bfd_getb32
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|offset_expr
operator|.
name|X_add_number
operator|=
name|bfd_getb32
argument_list|(
name|temp
operator|+
literal|4
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|offset_expr
operator|.
name|X_add_number
operator|==
literal|0
condition|)
name|offset_expr
operator|.
name|X_op
operator|=
name|O_absent
expr_stmt|;
block|}
elseif|else
if|if
condition|(
sizeof|sizeof
argument_list|(
name|imm_expr
operator|.
name|X_add_number
argument_list|)
operator|>
literal|4
condition|)
block|{
name|imm_expr
operator|.
name|X_op
operator|=
name|O_constant
expr_stmt|;
if|if
condition|(
operator|!
name|target_big_endian
condition|)
name|imm_expr
operator|.
name|X_add_number
operator|=
name|bfd_getl64
argument_list|(
name|temp
argument_list|)
expr_stmt|;
else|else
name|imm_expr
operator|.
name|X_add_number
operator|=
name|bfd_getb64
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|imm_expr
operator|.
name|X_op
operator|=
name|O_big
expr_stmt|;
name|imm_expr
operator|.
name|X_add_number
operator|=
literal|4
expr_stmt|;
if|if
condition|(
operator|!
name|target_big_endian
condition|)
block|{
name|generic_bignum
index|[
literal|0
index|]
operator|=
name|bfd_getl16
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|generic_bignum
index|[
literal|1
index|]
operator|=
name|bfd_getl16
argument_list|(
name|temp
operator|+
literal|2
argument_list|)
expr_stmt|;
name|generic_bignum
index|[
literal|2
index|]
operator|=
name|bfd_getl16
argument_list|(
name|temp
operator|+
literal|4
argument_list|)
expr_stmt|;
name|generic_bignum
index|[
literal|3
index|]
operator|=
name|bfd_getl16
argument_list|(
name|temp
operator|+
literal|6
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|generic_bignum
index|[
literal|0
index|]
operator|=
name|bfd_getb16
argument_list|(
name|temp
operator|+
literal|6
argument_list|)
expr_stmt|;
name|generic_bignum
index|[
literal|1
index|]
operator|=
name|bfd_getb16
argument_list|(
name|temp
operator|+
literal|4
argument_list|)
expr_stmt|;
name|generic_bignum
index|[
literal|2
index|]
operator|=
name|bfd_getb16
argument_list|(
name|temp
operator|+
literal|2
argument_list|)
expr_stmt|;
name|generic_bignum
index|[
literal|3
index|]
operator|=
name|bfd_getb16
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
specifier|const
name|char
modifier|*
name|newname
decl_stmt|;
name|segT
name|new_seg
decl_stmt|;
comment|/* Switch to the right section.  */
name|seg
operator|=
name|now_seg
expr_stmt|;
name|subseg
operator|=
name|now_subseg
expr_stmt|;
switch|switch
condition|(
operator|*
name|args
condition|)
block|{
default|default:
comment|/* unused default case avoids warnings.  */
case|case
literal|'L'
case|:
name|newname
operator|=
name|RDATA_SECTION_NAME
expr_stmt|;
if|if
condition|(
operator|(
name|USE_GLOBAL_POINTER_OPT
operator|&&
name|g_switch_value
operator|>=
literal|8
operator|)
operator|||
name|mips_pic
operator|==
name|EMBEDDED_PIC
condition|)
name|newname
operator|=
literal|".lit8"
expr_stmt|;
break|break;
case|case
literal|'F'
case|:
if|if
condition|(
name|mips_pic
operator|==
name|EMBEDDED_PIC
condition|)
name|newname
operator|=
literal|".lit8"
expr_stmt|;
else|else
name|newname
operator|=
name|RDATA_SECTION_NAME
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|assert
argument_list|(
operator|!
name|USE_GLOBAL_POINTER_OPT
operator|||
name|g_switch_value
operator|>=
literal|4
argument_list|)
expr_stmt|;
name|newname
operator|=
literal|".lit4"
expr_stmt|;
break|break;
block|}
name|new_seg
operator|=
name|subseg_new
argument_list|(
name|newname
argument_list|,
operator|(
name|subsegT
operator|)
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|OUTPUT_FLAVOR
operator|==
name|bfd_target_elf_flavour
condition|)
name|bfd_set_section_flags
argument_list|(
name|stdoutput
argument_list|,
name|new_seg
argument_list|,
operator|(
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_READONLY
operator||
name|SEC_DATA
operator|)
argument_list|)
expr_stmt|;
name|frag_align
argument_list|(
operator|*
name|args
operator|==
literal|'l'
condition|?
literal|2
else|:
literal|3
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|OUTPUT_FLAVOR
operator|==
name|bfd_target_elf_flavour
operator|&&
name|strcmp
argument_list|(
name|TARGET_OS
argument_list|,
literal|"elf"
argument_list|)
operator|!=
literal|0
condition|)
name|record_alignment
argument_list|(
name|new_seg
argument_list|,
literal|4
argument_list|)
expr_stmt|;
else|else
name|record_alignment
argument_list|(
name|new_seg
argument_list|,
operator|*
name|args
operator|==
literal|'l'
condition|?
literal|2
else|:
literal|3
argument_list|)
expr_stmt|;
if|if
condition|(
name|seg
operator|==
name|now_seg
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Can't use floating point insn in this section"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Set the argument to the current address in the 		       section.  */
name|offset_expr
operator|.
name|X_op
operator|=
name|O_symbol
expr_stmt|;
name|offset_expr
operator|.
name|X_add_symbol
operator|=
name|symbol_new
argument_list|(
literal|"L0\001"
argument_list|,
name|now_seg
argument_list|,
operator|(
name|valueT
operator|)
name|frag_now_fix
argument_list|()
argument_list|,
name|frag_now
argument_list|)
expr_stmt|;
name|offset_expr
operator|.
name|X_add_number
operator|=
literal|0
expr_stmt|;
comment|/* Put the floating point number into the section.  */
name|p
operator|=
name|frag_more
argument_list|(
operator|(
name|int
operator|)
name|length
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|p
argument_list|,
name|temp
argument_list|,
name|length
argument_list|)
expr_stmt|;
comment|/* Switch back to the original section.  */
name|subseg_set
argument_list|(
name|seg
argument_list|,
name|subseg
argument_list|)
expr_stmt|;
block|}
block|}
continue|continue;
case|case
literal|'i'
case|:
comment|/* 16 bit unsigned immediate */
case|case
literal|'j'
case|:
comment|/* 16 bit signed immediate */
operator|*
name|imm_reloc
operator|=
name|BFD_RELOC_LO16
expr_stmt|;
if|if
condition|(
name|my_getSmallExpression
argument_list|(
operator|&
name|imm_expr
argument_list|,
name|imm_reloc
argument_list|,
name|s
argument_list|)
operator|==
literal|0
condition|)
block|{
name|int
name|more
decl_stmt|;
name|offsetT
name|minval
decl_stmt|,
name|maxval
decl_stmt|;
name|more
operator|=
operator|(
name|insn
operator|+
literal|1
operator|<
operator|&
name|mips_opcodes
index|[
name|NUMOPCODES
index|]
operator|&&
name|strcmp
argument_list|(
name|insn
operator|->
name|name
argument_list|,
name|insn
index|[
literal|1
index|]
operator|.
name|name
argument_list|)
operator|==
literal|0
operator|)
expr_stmt|;
comment|/* If the expression was written as an unsigned number, 		     only treat it as signed if there are no more 		     alternatives.  */
if|if
condition|(
name|more
operator|&&
operator|*
name|args
operator|==
literal|'j'
operator|&&
sizeof|sizeof
argument_list|(
name|imm_expr
operator|.
name|X_add_number
argument_list|)
operator|<=
literal|4
operator|&&
name|imm_expr
operator|.
name|X_op
operator|==
name|O_constant
operator|&&
name|imm_expr
operator|.
name|X_add_number
operator|<
literal|0
operator|&&
name|imm_expr
operator|.
name|X_unsigned
operator|&&
name|HAVE_64BIT_GPRS
condition|)
break|break;
comment|/* For compatibility with older assemblers, we accept 		     0x8000-0xffff as signed 16-bit numbers when only 		     signed numbers are allowed.  */
if|if
condition|(
operator|*
name|args
operator|==
literal|'i'
condition|)
name|minval
operator|=
literal|0
operator|,
name|maxval
operator|=
literal|0xffff
expr_stmt|;
elseif|else
if|if
condition|(
name|more
condition|)
name|minval
operator|=
operator|-
literal|0x8000
operator|,
name|maxval
operator|=
literal|0x7fff
expr_stmt|;
else|else
name|minval
operator|=
operator|-
literal|0x8000
operator|,
name|maxval
operator|=
literal|0xffff
expr_stmt|;
if|if
condition|(
name|imm_expr
operator|.
name|X_op
operator|!=
name|O_constant
operator|||
name|imm_expr
operator|.
name|X_add_number
operator|<
name|minval
operator|||
name|imm_expr
operator|.
name|X_add_number
operator|>
name|maxval
condition|)
block|{
if|if
condition|(
name|more
condition|)
break|break;
if|if
condition|(
name|imm_expr
operator|.
name|X_op
operator|==
name|O_constant
operator|||
name|imm_expr
operator|.
name|X_op
operator|==
name|O_big
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"expression out of range"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|s
operator|=
name|expr_end
expr_stmt|;
continue|continue;
case|case
literal|'o'
case|:
comment|/* 16 bit offset */
comment|/* Check whether there is only a single bracketed expression 		 left.  If so, it must be the base register and the 		 constant must be zero.  */
if|if
condition|(
operator|*
name|s
operator|==
literal|'('
operator|&&
name|strchr
argument_list|(
name|s
operator|+
literal|1
argument_list|,
literal|'('
argument_list|)
operator|==
literal|0
condition|)
block|{
name|offset_expr
operator|.
name|X_op
operator|=
name|O_constant
expr_stmt|;
name|offset_expr
operator|.
name|X_add_number
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
comment|/* If this value won't fit into a 16 bit offset, then go 		 find a macro that will generate the 32 bit offset 		 code pattern.  */
if|if
condition|(
name|my_getSmallExpression
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|offset_reloc
argument_list|,
name|s
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|offset_expr
operator|.
name|X_op
operator|!=
name|O_constant
operator|||
name|offset_expr
operator|.
name|X_add_number
operator|>=
literal|0x8000
operator|||
name|offset_expr
operator|.
name|X_add_number
operator|<
operator|-
literal|0x8000
operator|)
condition|)
break|break;
name|s
operator|=
name|expr_end
expr_stmt|;
continue|continue;
case|case
literal|'p'
case|:
comment|/* pc relative offset */
operator|*
name|offset_reloc
operator|=
name|BFD_RELOC_16_PCREL_S2
expr_stmt|;
name|my_getExpression
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|s
operator|=
name|expr_end
expr_stmt|;
continue|continue;
case|case
literal|'u'
case|:
comment|/* upper 16 bits */
if|if
condition|(
name|my_getSmallExpression
argument_list|(
operator|&
name|imm_expr
argument_list|,
name|imm_reloc
argument_list|,
name|s
argument_list|)
operator|==
literal|0
operator|&&
name|imm_expr
operator|.
name|X_op
operator|==
name|O_constant
operator|&&
operator|(
name|imm_expr
operator|.
name|X_add_number
operator|<
literal|0
operator|||
name|imm_expr
operator|.
name|X_add_number
operator|>=
literal|0x10000
operator|)
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"lui expression not in range 0..65535"
argument_list|)
argument_list|)
expr_stmt|;
name|s
operator|=
name|expr_end
expr_stmt|;
continue|continue;
case|case
literal|'a'
case|:
comment|/* 26 bit address */
name|my_getExpression
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|s
operator|=
name|expr_end
expr_stmt|;
operator|*
name|offset_reloc
operator|=
name|BFD_RELOC_MIPS_JMP
expr_stmt|;
continue|continue;
case|case
literal|'N'
case|:
comment|/* 3 bit branch condition code */
case|case
literal|'M'
case|:
comment|/* 3 bit compare condition code */
if|if
condition|(
name|strncmp
argument_list|(
name|s
argument_list|,
literal|"$fcc"
argument_list|,
literal|4
argument_list|)
operator|!=
literal|0
condition|)
break|break;
name|s
operator|+=
literal|4
expr_stmt|;
name|regno
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|regno
operator|*=
literal|10
expr_stmt|;
name|regno
operator|+=
operator|*
name|s
operator|-
literal|'0'
expr_stmt|;
operator|++
name|s
expr_stmt|;
block|}
do|while
condition|(
name|ISDIGIT
argument_list|(
operator|*
name|s
argument_list|)
condition|)
do|;
if|if
condition|(
name|regno
operator|>
literal|7
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Invalid condition code register $fcc%d"
argument_list|)
argument_list|,
name|regno
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|strcmp
argument_list|(
name|str
operator|+
name|strlen
argument_list|(
name|str
argument_list|)
operator|-
literal|3
argument_list|,
literal|".ps"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|str
operator|+
name|strlen
argument_list|(
name|str
argument_list|)
operator|-
literal|5
argument_list|,
literal|"any2f"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|str
operator|+
name|strlen
argument_list|(
name|str
argument_list|)
operator|-
literal|5
argument_list|,
literal|"any2t"
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|regno
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"Condition code register should be even for %s, was %d"
argument_list|)
argument_list|,
name|str
argument_list|,
name|regno
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|strcmp
argument_list|(
name|str
operator|+
name|strlen
argument_list|(
name|str
argument_list|)
operator|-
literal|5
argument_list|,
literal|"any4f"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|str
operator|+
name|strlen
argument_list|(
name|str
argument_list|)
operator|-
literal|5
argument_list|,
literal|"any4t"
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|regno
operator|&
literal|3
operator|)
operator|!=
literal|0
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"Condition code register should be 0 or 4 for %s, was %d"
argument_list|)
argument_list|,
name|str
argument_list|,
name|regno
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|args
operator|==
literal|'N'
condition|)
name|ip
operator|->
name|insn_opcode
operator||=
name|regno
operator|<<
name|OP_SH_BCC
expr_stmt|;
else|else
name|ip
operator|->
name|insn_opcode
operator||=
name|regno
operator|<<
name|OP_SH_CCC
expr_stmt|;
continue|continue;
case|case
literal|'H'
case|:
if|if
condition|(
name|s
index|[
literal|0
index|]
operator|==
literal|'0'
operator|&&
operator|(
name|s
index|[
literal|1
index|]
operator|==
literal|'x'
operator|||
name|s
index|[
literal|1
index|]
operator|==
literal|'X'
operator|)
condition|)
name|s
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|ISDIGIT
argument_list|(
operator|*
name|s
argument_list|)
condition|)
block|{
name|c
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|c
operator|*=
literal|10
expr_stmt|;
name|c
operator|+=
operator|*
name|s
operator|-
literal|'0'
expr_stmt|;
operator|++
name|s
expr_stmt|;
block|}
do|while
condition|(
name|ISDIGIT
argument_list|(
operator|*
name|s
argument_list|)
condition|)
do|;
block|}
else|else
name|c
operator|=
literal|8
expr_stmt|;
comment|/* Invalid sel value.  */
if|if
condition|(
name|c
operator|>
literal|7
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"invalid coprocessor sub-selection value (0-7)"
argument_list|)
argument_list|)
expr_stmt|;
name|ip
operator|->
name|insn_opcode
operator||=
name|c
expr_stmt|;
continue|continue;
case|case
literal|'e'
case|:
comment|/* Must be at least one digit.  */
name|my_getExpression
argument_list|(
operator|&
name|imm_expr
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|check_absolute_expr
argument_list|(
name|ip
argument_list|,
operator|&
name|imm_expr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|unsigned
name|long
operator|)
name|imm_expr
operator|.
name|X_add_number
operator|>
operator|(
name|unsigned
name|long
operator|)
name|OP_MASK_VECBYTE
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"bad byte vector index (%ld)"
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|imm_expr
operator|.
name|X_add_number
argument_list|)
expr_stmt|;
name|imm_expr
operator|.
name|X_add_number
operator|=
literal|0
expr_stmt|;
block|}
name|ip
operator|->
name|insn_opcode
operator||=
name|imm_expr
operator|.
name|X_add_number
operator|<<
name|OP_SH_VECBYTE
expr_stmt|;
name|imm_expr
operator|.
name|X_op
operator|=
name|O_absent
expr_stmt|;
name|s
operator|=
name|expr_end
expr_stmt|;
continue|continue;
case|case
literal|'%'
case|:
name|my_getExpression
argument_list|(
operator|&
name|imm_expr
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|check_absolute_expr
argument_list|(
name|ip
argument_list|,
operator|&
name|imm_expr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|unsigned
name|long
operator|)
name|imm_expr
operator|.
name|X_add_number
operator|>
operator|(
name|unsigned
name|long
operator|)
name|OP_MASK_VECALIGN
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"bad byte vector index (%ld)"
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|imm_expr
operator|.
name|X_add_number
argument_list|)
expr_stmt|;
name|imm_expr
operator|.
name|X_add_number
operator|=
literal|0
expr_stmt|;
block|}
name|ip
operator|->
name|insn_opcode
operator||=
name|imm_expr
operator|.
name|X_add_number
operator|<<
name|OP_SH_VECALIGN
expr_stmt|;
name|imm_expr
operator|.
name|X_op
operator|=
name|O_absent
expr_stmt|;
name|s
operator|=
name|expr_end
expr_stmt|;
continue|continue;
default|default:
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"bad char = '%c'\n"
argument_list|)
argument_list|,
operator|*
name|args
argument_list|)
expr_stmt|;
name|internalError
argument_list|()
expr_stmt|;
block|}
break|break;
block|}
comment|/* Args don't match.  */
if|if
condition|(
name|insn
operator|+
literal|1
operator|<
operator|&
name|mips_opcodes
index|[
name|NUMOPCODES
index|]
operator|&&
operator|!
name|strcmp
argument_list|(
name|insn
operator|->
name|name
argument_list|,
name|insn
index|[
literal|1
index|]
operator|.
name|name
argument_list|)
condition|)
block|{
operator|++
name|insn
expr_stmt|;
name|s
operator|=
name|argsStart
expr_stmt|;
name|insn_error
operator|=
name|_
argument_list|(
literal|"illegal operands"
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|save_c
condition|)
operator|*
operator|(
operator|--
name|s
operator|)
operator|=
name|save_c
expr_stmt|;
name|insn_error
operator|=
name|_
argument_list|(
literal|"illegal operands"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
end_function

begin_comment
comment|/* This routine assembles an instruction into its binary format when    assembling for the mips16.  As a side effect, it sets one of the    global variables imm_reloc or offset_reloc to the type of    relocation to do if one of the operands is an address expression.    It also sets mips16_small and mips16_ext if the user explicitly    requested a small or extended instruction.  */
end_comment

begin_function
specifier|static
name|void
name|mips16_ip
parameter_list|(
name|char
modifier|*
name|str
parameter_list|,
name|struct
name|mips_cl_insn
modifier|*
name|ip
parameter_list|)
block|{
name|char
modifier|*
name|s
decl_stmt|;
specifier|const
name|char
modifier|*
name|args
decl_stmt|;
name|struct
name|mips_opcode
modifier|*
name|insn
decl_stmt|;
name|char
modifier|*
name|argsstart
decl_stmt|;
name|unsigned
name|int
name|regno
decl_stmt|;
name|unsigned
name|int
name|lastregno
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|s_reset
decl_stmt|;
name|insn_error
operator|=
name|NULL
expr_stmt|;
name|mips16_small
operator|=
name|FALSE
expr_stmt|;
name|mips16_ext
operator|=
name|FALSE
expr_stmt|;
for|for
control|(
name|s
operator|=
name|str
init|;
name|ISLOWER
argument_list|(
operator|*
name|s
argument_list|)
condition|;
operator|++
name|s
control|)
empty_stmt|;
switch|switch
condition|(
operator|*
name|s
condition|)
block|{
case|case
literal|'\0'
case|:
break|break;
case|case
literal|' '
case|:
operator|*
name|s
operator|++
operator|=
literal|'\0'
expr_stmt|;
break|break;
case|case
literal|'.'
case|:
if|if
condition|(
name|s
index|[
literal|1
index|]
operator|==
literal|'t'
operator|&&
name|s
index|[
literal|2
index|]
operator|==
literal|' '
condition|)
block|{
operator|*
name|s
operator|=
literal|'\0'
expr_stmt|;
name|mips16_small
operator|=
name|TRUE
expr_stmt|;
name|s
operator|+=
literal|3
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|s
index|[
literal|1
index|]
operator|==
literal|'e'
operator|&&
name|s
index|[
literal|2
index|]
operator|==
literal|' '
condition|)
block|{
operator|*
name|s
operator|=
literal|'\0'
expr_stmt|;
name|mips16_ext
operator|=
name|TRUE
expr_stmt|;
name|s
operator|+=
literal|3
expr_stmt|;
break|break;
block|}
comment|/* Fall through.  */
default|default:
name|insn_error
operator|=
name|_
argument_list|(
literal|"unknown opcode"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|mips_opts
operator|.
name|noautoextend
operator|&&
operator|!
name|mips16_ext
condition|)
name|mips16_small
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
operator|(
name|insn
operator|=
operator|(
expr|struct
name|mips_opcode
operator|*
operator|)
name|hash_find
argument_list|(
name|mips16_op_hash
argument_list|,
name|str
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|insn_error
operator|=
name|_
argument_list|(
literal|"unrecognized opcode"
argument_list|)
expr_stmt|;
return|return;
block|}
name|argsstart
operator|=
name|s
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|assert
argument_list|(
name|strcmp
argument_list|(
name|insn
operator|->
name|name
argument_list|,
name|str
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ip
operator|->
name|insn_mo
operator|=
name|insn
expr_stmt|;
name|ip
operator|->
name|insn_opcode
operator|=
name|insn
operator|->
name|match
expr_stmt|;
name|ip
operator|->
name|use_extend
operator|=
name|FALSE
expr_stmt|;
name|imm_expr
operator|.
name|X_op
operator|=
name|O_absent
expr_stmt|;
name|imm_reloc
index|[
literal|0
index|]
operator|=
name|BFD_RELOC_UNUSED
expr_stmt|;
name|imm_reloc
index|[
literal|1
index|]
operator|=
name|BFD_RELOC_UNUSED
expr_stmt|;
name|imm_reloc
index|[
literal|2
index|]
operator|=
name|BFD_RELOC_UNUSED
expr_stmt|;
name|imm2_expr
operator|.
name|X_op
operator|=
name|O_absent
expr_stmt|;
name|offset_expr
operator|.
name|X_op
operator|=
name|O_absent
expr_stmt|;
name|offset_reloc
index|[
literal|0
index|]
operator|=
name|BFD_RELOC_UNUSED
expr_stmt|;
name|offset_reloc
index|[
literal|1
index|]
operator|=
name|BFD_RELOC_UNUSED
expr_stmt|;
name|offset_reloc
index|[
literal|2
index|]
operator|=
name|BFD_RELOC_UNUSED
expr_stmt|;
for|for
control|(
name|args
operator|=
name|insn
operator|->
name|args
init|;
literal|1
condition|;
operator|++
name|args
control|)
block|{
name|int
name|c
decl_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|' '
condition|)
operator|++
name|s
expr_stmt|;
comment|/* In this switch statement we call break if we did not find              a match, continue if we did find a match, or return if we              are done.  */
name|c
operator|=
operator|*
name|args
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\0'
case|:
if|if
condition|(
operator|*
name|s
operator|==
literal|'\0'
condition|)
block|{
comment|/* Stuff the immediate value in now, if we can.  */
if|if
condition|(
name|imm_expr
operator|.
name|X_op
operator|==
name|O_constant
operator|&&
operator|*
name|imm_reloc
operator|>
name|BFD_RELOC_UNUSED
operator|&&
name|insn
operator|->
name|pinfo
operator|!=
name|INSN_MACRO
condition|)
block|{
name|mips16_immed
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|,
operator|*
name|imm_reloc
operator|-
name|BFD_RELOC_UNUSED
argument_list|,
name|imm_expr
operator|.
name|X_add_number
argument_list|,
name|TRUE
argument_list|,
name|mips16_small
argument_list|,
name|mips16_ext
argument_list|,
operator|&
name|ip
operator|->
name|insn_opcode
argument_list|,
operator|&
name|ip
operator|->
name|use_extend
argument_list|,
operator|&
name|ip
operator|->
name|extend
argument_list|)
expr_stmt|;
name|imm_expr
operator|.
name|X_op
operator|=
name|O_absent
expr_stmt|;
operator|*
name|imm_reloc
operator|=
name|BFD_RELOC_UNUSED
expr_stmt|;
block|}
return|return;
block|}
break|break;
case|case
literal|','
case|:
if|if
condition|(
operator|*
name|s
operator|++
operator|==
name|c
condition|)
continue|continue;
name|s
operator|--
expr_stmt|;
switch|switch
condition|(
operator|*
operator|++
name|args
condition|)
block|{
case|case
literal|'v'
case|:
name|ip
operator|->
name|insn_opcode
operator||=
name|lastregno
operator|<<
name|MIPS16OP_SH_RX
expr_stmt|;
continue|continue;
case|case
literal|'w'
case|:
name|ip
operator|->
name|insn_opcode
operator||=
name|lastregno
operator|<<
name|MIPS16OP_SH_RY
expr_stmt|;
continue|continue;
block|}
break|break;
case|case
literal|'('
case|:
case|case
literal|')'
case|:
if|if
condition|(
operator|*
name|s
operator|++
operator|==
name|c
condition|)
continue|continue;
break|break;
case|case
literal|'v'
case|:
case|case
literal|'w'
case|:
if|if
condition|(
name|s
index|[
literal|0
index|]
operator|!=
literal|'$'
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'v'
condition|)
name|ip
operator|->
name|insn_opcode
operator||=
name|lastregno
operator|<<
name|MIPS16OP_SH_RX
expr_stmt|;
else|else
name|ip
operator|->
name|insn_opcode
operator||=
name|lastregno
operator|<<
name|MIPS16OP_SH_RY
expr_stmt|;
operator|++
name|args
expr_stmt|;
continue|continue;
block|}
comment|/* Fall through.  */
case|case
literal|'x'
case|:
case|case
literal|'y'
case|:
case|case
literal|'z'
case|:
case|case
literal|'Z'
case|:
case|case
literal|'0'
case|:
case|case
literal|'S'
case|:
case|case
literal|'R'
case|:
case|case
literal|'X'
case|:
case|case
literal|'Y'
case|:
if|if
condition|(
name|s
index|[
literal|0
index|]
operator|!=
literal|'$'
condition|)
break|break;
name|s_reset
operator|=
name|s
expr_stmt|;
if|if
condition|(
name|ISDIGIT
argument_list|(
name|s
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
operator|++
name|s
expr_stmt|;
name|regno
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|regno
operator|*=
literal|10
expr_stmt|;
name|regno
operator|+=
operator|*
name|s
operator|-
literal|'0'
expr_stmt|;
operator|++
name|s
expr_stmt|;
block|}
do|while
condition|(
name|ISDIGIT
argument_list|(
operator|*
name|s
argument_list|)
condition|)
do|;
if|if
condition|(
name|regno
operator|>
literal|31
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"invalid register number (%d)"
argument_list|)
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|regno
operator|=
literal|2
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|s
index|[
literal|1
index|]
operator|==
literal|'r'
operator|&&
name|s
index|[
literal|2
index|]
operator|==
literal|'a'
condition|)
block|{
name|s
operator|+=
literal|3
expr_stmt|;
name|regno
operator|=
name|RA
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|s
index|[
literal|1
index|]
operator|==
literal|'f'
operator|&&
name|s
index|[
literal|2
index|]
operator|==
literal|'p'
condition|)
block|{
name|s
operator|+=
literal|3
expr_stmt|;
name|regno
operator|=
name|FP
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|s
index|[
literal|1
index|]
operator|==
literal|'s'
operator|&&
name|s
index|[
literal|2
index|]
operator|==
literal|'p'
condition|)
block|{
name|s
operator|+=
literal|3
expr_stmt|;
name|regno
operator|=
name|SP
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|s
index|[
literal|1
index|]
operator|==
literal|'g'
operator|&&
name|s
index|[
literal|2
index|]
operator|==
literal|'p'
condition|)
block|{
name|s
operator|+=
literal|3
expr_stmt|;
name|regno
operator|=
name|GP
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|s
index|[
literal|1
index|]
operator|==
literal|'a'
operator|&&
name|s
index|[
literal|2
index|]
operator|==
literal|'t'
condition|)
block|{
name|s
operator|+=
literal|3
expr_stmt|;
name|regno
operator|=
name|AT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|s
index|[
literal|1
index|]
operator|==
literal|'k'
operator|&&
name|s
index|[
literal|2
index|]
operator|==
literal|'t'
operator|&&
name|s
index|[
literal|3
index|]
operator|==
literal|'0'
condition|)
block|{
name|s
operator|+=
literal|4
expr_stmt|;
name|regno
operator|=
name|KT0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|s
index|[
literal|1
index|]
operator|==
literal|'k'
operator|&&
name|s
index|[
literal|2
index|]
operator|==
literal|'t'
operator|&&
name|s
index|[
literal|3
index|]
operator|==
literal|'1'
condition|)
block|{
name|s
operator|+=
literal|4
expr_stmt|;
name|regno
operator|=
name|KT1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|s
index|[
literal|1
index|]
operator|==
literal|'z'
operator|&&
name|s
index|[
literal|2
index|]
operator|==
literal|'e'
operator|&&
name|s
index|[
literal|3
index|]
operator|==
literal|'r'
operator|&&
name|s
index|[
literal|4
index|]
operator|==
literal|'o'
condition|)
block|{
name|s
operator|+=
literal|5
expr_stmt|;
name|regno
operator|=
name|ZERO
expr_stmt|;
block|}
else|else
break|break;
block|}
if|if
condition|(
operator|*
name|s
operator|==
literal|' '
condition|)
operator|++
name|s
expr_stmt|;
if|if
condition|(
name|args
index|[
literal|1
index|]
operator|!=
operator|*
name|s
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'v'
operator|||
name|c
operator|==
literal|'w'
condition|)
block|{
name|regno
operator|=
name|mips16_to_32_reg_map
index|[
name|lastregno
index|]
expr_stmt|;
name|s
operator|=
name|s_reset
expr_stmt|;
operator|++
name|args
expr_stmt|;
block|}
block|}
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'x'
case|:
case|case
literal|'y'
case|:
case|case
literal|'z'
case|:
case|case
literal|'v'
case|:
case|case
literal|'w'
case|:
case|case
literal|'Z'
case|:
name|regno
operator|=
name|mips32_to_16_reg_map
index|[
name|regno
index|]
expr_stmt|;
break|break;
case|case
literal|'0'
case|:
if|if
condition|(
name|regno
operator|!=
literal|0
condition|)
name|regno
operator|=
name|ILLEGAL_REG
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
if|if
condition|(
name|regno
operator|!=
name|SP
condition|)
name|regno
operator|=
name|ILLEGAL_REG
expr_stmt|;
break|break;
case|case
literal|'R'
case|:
if|if
condition|(
name|regno
operator|!=
name|RA
condition|)
name|regno
operator|=
name|ILLEGAL_REG
expr_stmt|;
break|break;
case|case
literal|'X'
case|:
case|case
literal|'Y'
case|:
if|if
condition|(
name|regno
operator|==
name|AT
operator|&&
operator|!
name|mips_opts
operator|.
name|noat
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"used $at without \".set noat\""
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|internalError
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|regno
operator|==
name|ILLEGAL_REG
condition|)
break|break;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'x'
case|:
case|case
literal|'v'
case|:
name|ip
operator|->
name|insn_opcode
operator||=
name|regno
operator|<<
name|MIPS16OP_SH_RX
expr_stmt|;
break|break;
case|case
literal|'y'
case|:
case|case
literal|'w'
case|:
name|ip
operator|->
name|insn_opcode
operator||=
name|regno
operator|<<
name|MIPS16OP_SH_RY
expr_stmt|;
break|break;
case|case
literal|'z'
case|:
name|ip
operator|->
name|insn_opcode
operator||=
name|regno
operator|<<
name|MIPS16OP_SH_RZ
expr_stmt|;
break|break;
case|case
literal|'Z'
case|:
name|ip
operator|->
name|insn_opcode
operator||=
name|regno
operator|<<
name|MIPS16OP_SH_MOVE32Z
expr_stmt|;
case|case
literal|'0'
case|:
case|case
literal|'S'
case|:
case|case
literal|'R'
case|:
break|break;
case|case
literal|'X'
case|:
name|ip
operator|->
name|insn_opcode
operator||=
name|regno
operator|<<
name|MIPS16OP_SH_REGR32
expr_stmt|;
break|break;
case|case
literal|'Y'
case|:
name|regno
operator|=
operator|(
operator|(
name|regno
operator|&
literal|7
operator|)
operator|<<
literal|2
operator|)
operator||
operator|(
operator|(
name|regno
operator|&
literal|0x18
operator|)
operator|>>
literal|3
operator|)
expr_stmt|;
name|ip
operator|->
name|insn_opcode
operator||=
name|regno
operator|<<
name|MIPS16OP_SH_REG32R
expr_stmt|;
break|break;
default|default:
name|internalError
argument_list|()
expr_stmt|;
block|}
name|lastregno
operator|=
name|regno
expr_stmt|;
continue|continue;
case|case
literal|'P'
case|:
if|if
condition|(
name|strncmp
argument_list|(
name|s
argument_list|,
literal|"$pc"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
block|{
name|s
operator|+=
literal|3
expr_stmt|;
continue|continue;
block|}
break|break;
case|case
literal|'<'
case|:
case|case
literal|'>'
case|:
case|case
literal|'['
case|:
case|case
literal|']'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'H'
case|:
case|case
literal|'W'
case|:
case|case
literal|'D'
case|:
case|case
literal|'j'
case|:
case|case
literal|'8'
case|:
case|case
literal|'V'
case|:
case|case
literal|'C'
case|:
case|case
literal|'U'
case|:
case|case
literal|'k'
case|:
case|case
literal|'K'
case|:
if|if
condition|(
name|s
index|[
literal|0
index|]
operator|==
literal|'%'
operator|&&
name|strncmp
argument_list|(
name|s
operator|+
literal|1
argument_list|,
literal|"gprel("
argument_list|,
sizeof|sizeof
expr|"gprel("
operator|-
literal|1
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* This is %gprel(SYMBOL).  We need to read SYMBOL,                      and generate the appropriate reloc.  If the text                      inside %gprel is not a symbol name with an                      optional offset, then we generate a normal reloc                      and will probably fail later.  */
name|my_getExpression
argument_list|(
operator|&
name|imm_expr
argument_list|,
name|s
operator|+
sizeof|sizeof
expr|"%gprel"
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|imm_expr
operator|.
name|X_op
operator|==
name|O_symbol
condition|)
block|{
name|mips16_ext
operator|=
name|TRUE
expr_stmt|;
operator|*
name|imm_reloc
operator|=
name|BFD_RELOC_MIPS16_GPREL
expr_stmt|;
name|s
operator|=
name|expr_end
expr_stmt|;
name|ip
operator|->
name|use_extend
operator|=
name|TRUE
expr_stmt|;
name|ip
operator|->
name|extend
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
block|}
else|else
block|{
comment|/* Just pick up a normal expression.  */
name|my_getExpression
argument_list|(
operator|&
name|imm_expr
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|imm_expr
operator|.
name|X_op
operator|==
name|O_register
condition|)
block|{
comment|/* What we thought was an expression turned out to                      be a register.  */
if|if
condition|(
name|s
index|[
literal|0
index|]
operator|==
literal|'('
operator|&&
name|args
index|[
literal|1
index|]
operator|==
literal|'('
condition|)
block|{
comment|/* It looks like the expression was omitted 			 before a register indirection, which means 			 that the expression is implicitly zero.  We 			 still set up imm_expr, so that we handle 			 explicit extensions correctly.  */
name|imm_expr
operator|.
name|X_op
operator|=
name|O_constant
expr_stmt|;
name|imm_expr
operator|.
name|X_add_number
operator|=
literal|0
expr_stmt|;
operator|*
name|imm_reloc
operator|=
operator|(
name|int
operator|)
name|BFD_RELOC_UNUSED
operator|+
name|c
expr_stmt|;
continue|continue;
block|}
break|break;
block|}
comment|/* We need to relax this instruction.  */
operator|*
name|imm_reloc
operator|=
operator|(
name|int
operator|)
name|BFD_RELOC_UNUSED
operator|+
name|c
expr_stmt|;
name|s
operator|=
name|expr_end
expr_stmt|;
continue|continue;
case|case
literal|'p'
case|:
case|case
literal|'q'
case|:
case|case
literal|'A'
case|:
case|case
literal|'B'
case|:
case|case
literal|'E'
case|:
comment|/* We use offset_reloc rather than imm_reloc for the PC                  relative operands.  This lets macros with both                  immediate and address operands work correctly.  */
name|my_getExpression
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset_expr
operator|.
name|X_op
operator|==
name|O_register
condition|)
break|break;
comment|/* We need to relax this instruction.  */
operator|*
name|offset_reloc
operator|=
operator|(
name|int
operator|)
name|BFD_RELOC_UNUSED
operator|+
name|c
expr_stmt|;
name|s
operator|=
name|expr_end
expr_stmt|;
continue|continue;
case|case
literal|'6'
case|:
comment|/* break code */
name|my_getExpression
argument_list|(
operator|&
name|imm_expr
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|check_absolute_expr
argument_list|(
name|ip
argument_list|,
operator|&
name|imm_expr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|unsigned
name|long
operator|)
name|imm_expr
operator|.
name|X_add_number
operator|>
literal|63
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"Invalid value for `%s' (%lu)"
argument_list|)
argument_list|,
name|ip
operator|->
name|insn_mo
operator|->
name|name
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|imm_expr
operator|.
name|X_add_number
argument_list|)
expr_stmt|;
name|imm_expr
operator|.
name|X_add_number
operator|&=
literal|0x3f
expr_stmt|;
block|}
name|ip
operator|->
name|insn_opcode
operator||=
name|imm_expr
operator|.
name|X_add_number
operator|<<
name|MIPS16OP_SH_IMM6
expr_stmt|;
name|imm_expr
operator|.
name|X_op
operator|=
name|O_absent
expr_stmt|;
name|s
operator|=
name|expr_end
expr_stmt|;
continue|continue;
case|case
literal|'a'
case|:
comment|/* 26 bit address */
name|my_getExpression
argument_list|(
operator|&
name|offset_expr
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|s
operator|=
name|expr_end
expr_stmt|;
operator|*
name|offset_reloc
operator|=
name|BFD_RELOC_MIPS16_JMP
expr_stmt|;
name|ip
operator|->
name|insn_opcode
operator|<<=
literal|16
expr_stmt|;
continue|continue;
case|case
literal|'l'
case|:
comment|/* register list for entry macro */
case|case
literal|'L'
case|:
comment|/* register list for exit macro */
block|{
name|int
name|mask
decl_stmt|;
if|if
condition|(
name|c
operator|==
literal|'l'
condition|)
name|mask
operator|=
literal|0
expr_stmt|;
else|else
name|mask
operator|=
literal|7
operator|<<
literal|3
expr_stmt|;
while|while
condition|(
operator|*
name|s
operator|!=
literal|'\0'
condition|)
block|{
name|int
name|freg
decl_stmt|,
name|reg1
decl_stmt|,
name|reg2
decl_stmt|;
while|while
condition|(
operator|*
name|s
operator|==
literal|' '
operator|||
operator|*
name|s
operator|==
literal|','
condition|)
operator|++
name|s
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|!=
literal|'$'
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"can't parse register list"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
operator|++
name|s
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|!=
literal|'f'
condition|)
name|freg
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|freg
operator|=
literal|1
expr_stmt|;
operator|++
name|s
expr_stmt|;
block|}
name|reg1
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|ISDIGIT
argument_list|(
operator|*
name|s
argument_list|)
condition|)
block|{
name|reg1
operator|*=
literal|10
expr_stmt|;
name|reg1
operator|+=
operator|*
name|s
operator|-
literal|'0'
expr_stmt|;
operator|++
name|s
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|s
operator|==
literal|' '
condition|)
operator|++
name|s
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|!=
literal|'-'
condition|)
name|reg2
operator|=
name|reg1
expr_stmt|;
else|else
block|{
operator|++
name|s
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|!=
literal|'$'
condition|)
break|break;
operator|++
name|s
expr_stmt|;
if|if
condition|(
name|freg
condition|)
block|{
if|if
condition|(
operator|*
name|s
operator|==
literal|'f'
condition|)
operator|++
name|s
expr_stmt|;
else|else
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"invalid register list"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|reg2
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|ISDIGIT
argument_list|(
operator|*
name|s
argument_list|)
condition|)
block|{
name|reg2
operator|*=
literal|10
expr_stmt|;
name|reg2
operator|+=
operator|*
name|s
operator|-
literal|'0'
expr_stmt|;
operator|++
name|s
expr_stmt|;
block|}
block|}
if|if
condition|(
name|freg
operator|&&
name|reg1
operator|==
literal|0
operator|&&
name|reg2
operator|==
literal|0
operator|&&
name|c
operator|==
literal|'L'
condition|)
block|{
name|mask
operator|&=
operator|~
operator|(
literal|7
operator|<<
literal|3
operator|)
expr_stmt|;
name|mask
operator||=
literal|5
operator|<<
literal|3
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|freg
operator|&&
name|reg1
operator|==
literal|0
operator|&&
name|reg2
operator|==
literal|1
operator|&&
name|c
operator|==
literal|'L'
condition|)
block|{
name|mask
operator|&=
operator|~
operator|(
literal|7
operator|<<
literal|3
operator|)
expr_stmt|;
name|mask
operator||=
literal|6
operator|<<
literal|3
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|reg1
operator|==
literal|4
operator|&&
name|reg2
operator|>=
literal|4
operator|&&
name|reg2
operator|<=
literal|7
operator|&&
name|c
operator|!=
literal|'L'
condition|)
name|mask
operator||=
operator|(
name|reg2
operator|-
literal|3
operator|)
operator|<<
literal|3
expr_stmt|;
elseif|else
if|if
condition|(
name|reg1
operator|==
literal|16
operator|&&
name|reg2
operator|>=
literal|16
operator|&&
name|reg2
operator|<=
literal|17
condition|)
name|mask
operator||=
operator|(
name|reg2
operator|-
literal|15
operator|)
operator|<<
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|reg1
operator|==
name|RA
operator|&&
name|reg2
operator|==
name|RA
condition|)
name|mask
operator||=
literal|1
expr_stmt|;
else|else
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"invalid register list"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|/* The mask is filled in in the opcode table for the                    benefit of the disassembler.  We remove it before                    applying the actual mask.  */
name|ip
operator|->
name|insn_opcode
operator|&=
operator|~
operator|(
operator|(
literal|7
operator|<<
literal|3
operator|)
operator|<<
name|MIPS16OP_SH_IMM6
operator|)
expr_stmt|;
name|ip
operator|->
name|insn_opcode
operator||=
name|mask
operator|<<
name|MIPS16OP_SH_IMM6
expr_stmt|;
block|}
continue|continue;
case|case
literal|'e'
case|:
comment|/* extend code */
name|my_getExpression
argument_list|(
operator|&
name|imm_expr
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|check_absolute_expr
argument_list|(
name|ip
argument_list|,
operator|&
name|imm_expr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|unsigned
name|long
operator|)
name|imm_expr
operator|.
name|X_add_number
operator|>
literal|0x7ff
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"Invalid value for `%s' (%lu)"
argument_list|)
argument_list|,
name|ip
operator|->
name|insn_mo
operator|->
name|name
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|imm_expr
operator|.
name|X_add_number
argument_list|)
expr_stmt|;
name|imm_expr
operator|.
name|X_add_number
operator|&=
literal|0x7ff
expr_stmt|;
block|}
name|ip
operator|->
name|insn_opcode
operator||=
name|imm_expr
operator|.
name|X_add_number
expr_stmt|;
name|imm_expr
operator|.
name|X_op
operator|=
name|O_absent
expr_stmt|;
name|s
operator|=
name|expr_end
expr_stmt|;
continue|continue;
default|default:
name|internalError
argument_list|()
expr_stmt|;
block|}
break|break;
block|}
comment|/* Args don't match.  */
if|if
condition|(
name|insn
operator|+
literal|1
operator|<
operator|&
name|mips16_opcodes
index|[
name|bfd_mips16_num_opcodes
index|]
operator|&&
name|strcmp
argument_list|(
name|insn
operator|->
name|name
argument_list|,
name|insn
index|[
literal|1
index|]
operator|.
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|++
name|insn
expr_stmt|;
name|s
operator|=
name|argsstart
expr_stmt|;
continue|continue;
block|}
name|insn_error
operator|=
name|_
argument_list|(
literal|"illegal operands"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
end_function

begin_comment
comment|/* This structure holds information we know about a mips16 immediate    argument type.  */
end_comment

begin_struct
struct|struct
name|mips16_immed_operand
block|{
comment|/* The type code used in the argument string in the opcode table.  */
name|int
name|type
decl_stmt|;
comment|/* The number of bits in the short form of the opcode.  */
name|int
name|nbits
decl_stmt|;
comment|/* The number of bits in the extended form of the opcode.  */
name|int
name|extbits
decl_stmt|;
comment|/* The amount by which the short form is shifted when it is used;      for example, the sw instruction has a shift count of 2.  */
name|int
name|shift
decl_stmt|;
comment|/* The amount by which the short form is shifted when it is stored      into the instruction code.  */
name|int
name|op_shift
decl_stmt|;
comment|/* Non-zero if the short form is unsigned.  */
name|int
name|unsp
decl_stmt|;
comment|/* Non-zero if the extended form is unsigned.  */
name|int
name|extu
decl_stmt|;
comment|/* Non-zero if the value is PC relative.  */
name|int
name|pcrel
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* The mips16 immediate operand types.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|mips16_immed_operand
name|mips16_immed_operands
index|[]
init|=
block|{
block|{
literal|'<'
block|,
literal|3
block|,
literal|5
block|,
literal|0
block|,
name|MIPS16OP_SH_RZ
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|}
block|,
block|{
literal|'>'
block|,
literal|3
block|,
literal|5
block|,
literal|0
block|,
name|MIPS16OP_SH_RX
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|}
block|,
block|{
literal|'['
block|,
literal|3
block|,
literal|6
block|,
literal|0
block|,
name|MIPS16OP_SH_RZ
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|}
block|,
block|{
literal|']'
block|,
literal|3
block|,
literal|6
block|,
literal|0
block|,
name|MIPS16OP_SH_RX
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|}
block|,
block|{
literal|'4'
block|,
literal|4
block|,
literal|15
block|,
literal|0
block|,
name|MIPS16OP_SH_IMM4
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|'5'
block|,
literal|5
block|,
literal|16
block|,
literal|0
block|,
name|MIPS16OP_SH_IMM5
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|'H'
block|,
literal|5
block|,
literal|16
block|,
literal|1
block|,
name|MIPS16OP_SH_IMM5
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|'W'
block|,
literal|5
block|,
literal|16
block|,
literal|2
block|,
name|MIPS16OP_SH_IMM5
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|'D'
block|,
literal|5
block|,
literal|16
block|,
literal|3
block|,
name|MIPS16OP_SH_IMM5
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|'j'
block|,
literal|5
block|,
literal|16
block|,
literal|0
block|,
name|MIPS16OP_SH_IMM5
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|'8'
block|,
literal|8
block|,
literal|16
block|,
literal|0
block|,
name|MIPS16OP_SH_IMM8
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|'V'
block|,
literal|8
block|,
literal|16
block|,
literal|2
block|,
name|MIPS16OP_SH_IMM8
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|'C'
block|,
literal|8
block|,
literal|16
block|,
literal|3
block|,
name|MIPS16OP_SH_IMM8
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|'U'
block|,
literal|8
block|,
literal|16
block|,
literal|0
block|,
name|MIPS16OP_SH_IMM8
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|}
block|,
block|{
literal|'k'
block|,
literal|8
block|,
literal|16
block|,
literal|0
block|,
name|MIPS16OP_SH_IMM8
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|'K'
block|,
literal|8
block|,
literal|16
block|,
literal|3
block|,
name|MIPS16OP_SH_IMM8
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|'p'
block|,
literal|8
block|,
literal|16
block|,
literal|0
block|,
name|MIPS16OP_SH_IMM8
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|}
block|,
block|{
literal|'q'
block|,
literal|11
block|,
literal|16
block|,
literal|0
block|,
name|MIPS16OP_SH_IMM8
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|}
block|,
block|{
literal|'A'
block|,
literal|8
block|,
literal|16
block|,
literal|2
block|,
name|MIPS16OP_SH_IMM8
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|}
block|,
block|{
literal|'B'
block|,
literal|5
block|,
literal|16
block|,
literal|3
block|,
name|MIPS16OP_SH_IMM5
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|}
block|,
block|{
literal|'E'
block|,
literal|5
block|,
literal|16
block|,
literal|2
block|,
name|MIPS16OP_SH_IMM5
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|MIPS16_NUM_IMMED
define|\
value|(sizeof mips16_immed_operands / sizeof mips16_immed_operands[0])
end_define

begin_comment
comment|/* Handle a mips16 instruction with an immediate value.  This or's the    small immediate value into *INSN.  It sets *USE_EXTEND to indicate    whether an extended value is needed; if one is needed, it sets    *EXTEND to the value.  The argument type is TYPE.  The value is VAL.    If SMALL is true, an unextended opcode was explicitly requested.    If EXT is true, an extended opcode was explicitly requested.  If    WARN is true, warn if EXT does not match reality.  */
end_comment

begin_function
specifier|static
name|void
name|mips16_immed
parameter_list|(
name|char
modifier|*
name|file
parameter_list|,
name|unsigned
name|int
name|line
parameter_list|,
name|int
name|type
parameter_list|,
name|offsetT
name|val
parameter_list|,
name|bfd_boolean
name|warn
parameter_list|,
name|bfd_boolean
name|small
parameter_list|,
name|bfd_boolean
name|ext
parameter_list|,
name|unsigned
name|long
modifier|*
name|insn
parameter_list|,
name|bfd_boolean
modifier|*
name|use_extend
parameter_list|,
name|unsigned
name|short
modifier|*
name|extend
parameter_list|)
block|{
specifier|register
specifier|const
name|struct
name|mips16_immed_operand
modifier|*
name|op
decl_stmt|;
name|int
name|mintiny
decl_stmt|,
name|maxtiny
decl_stmt|;
name|bfd_boolean
name|needext
decl_stmt|;
name|op
operator|=
name|mips16_immed_operands
expr_stmt|;
while|while
condition|(
name|op
operator|->
name|type
operator|!=
name|type
condition|)
block|{
operator|++
name|op
expr_stmt|;
name|assert
argument_list|(
name|op
operator|<
name|mips16_immed_operands
operator|+
name|MIPS16_NUM_IMMED
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|op
operator|->
name|unsp
condition|)
block|{
if|if
condition|(
name|type
operator|==
literal|'<'
operator|||
name|type
operator|==
literal|'>'
operator|||
name|type
operator|==
literal|'['
operator|||
name|type
operator|==
literal|']'
condition|)
block|{
name|mintiny
operator|=
literal|1
expr_stmt|;
name|maxtiny
operator|=
literal|1
operator|<<
name|op
operator|->
name|nbits
expr_stmt|;
block|}
else|else
block|{
name|mintiny
operator|=
literal|0
expr_stmt|;
name|maxtiny
operator|=
operator|(
literal|1
operator|<<
name|op
operator|->
name|nbits
operator|)
operator|-
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
name|mintiny
operator|=
operator|-
operator|(
literal|1
operator|<<
operator|(
name|op
operator|->
name|nbits
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
name|maxtiny
operator|=
operator|(
literal|1
operator|<<
operator|(
name|op
operator|->
name|nbits
operator|-
literal|1
operator|)
operator|)
operator|-
literal|1
expr_stmt|;
block|}
comment|/* Branch offsets have an implicit 0 in the lowest bit.  */
if|if
condition|(
name|type
operator|==
literal|'p'
operator|||
name|type
operator|==
literal|'q'
condition|)
name|val
operator|/=
literal|2
expr_stmt|;
if|if
condition|(
operator|(
name|val
operator|&
operator|(
operator|(
literal|1
operator|<<
name|op
operator|->
name|shift
operator|)
operator|-
literal|1
operator|)
operator|)
operator|!=
literal|0
operator|||
name|val
operator|<
operator|(
name|mintiny
operator|<<
name|op
operator|->
name|shift
operator|)
operator|||
name|val
operator|>
operator|(
name|maxtiny
operator|<<
name|op
operator|->
name|shift
operator|)
condition|)
name|needext
operator|=
name|TRUE
expr_stmt|;
else|else
name|needext
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|warn
operator|&&
name|ext
operator|&&
operator|!
name|needext
condition|)
name|as_warn_where
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
name|_
argument_list|(
literal|"extended operand requested but not required"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|small
operator|&&
name|needext
condition|)
name|as_bad_where
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
name|_
argument_list|(
literal|"invalid unextended operand value"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|small
operator|||
operator|(
operator|!
name|ext
operator|&&
operator|!
name|needext
operator|)
condition|)
block|{
name|int
name|insnval
decl_stmt|;
operator|*
name|use_extend
operator|=
name|FALSE
expr_stmt|;
name|insnval
operator|=
operator|(
operator|(
name|val
operator|>>
name|op
operator|->
name|shift
operator|)
operator|&
operator|(
operator|(
literal|1
operator|<<
name|op
operator|->
name|nbits
operator|)
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
name|insnval
operator|<<=
name|op
operator|->
name|op_shift
expr_stmt|;
operator|*
name|insn
operator||=
name|insnval
expr_stmt|;
block|}
else|else
block|{
name|long
name|minext
decl_stmt|,
name|maxext
decl_stmt|;
name|int
name|extval
decl_stmt|;
if|if
condition|(
name|op
operator|->
name|extu
condition|)
block|{
name|minext
operator|=
literal|0
expr_stmt|;
name|maxext
operator|=
operator|(
literal|1
operator|<<
name|op
operator|->
name|extbits
operator|)
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|minext
operator|=
operator|-
operator|(
literal|1
operator|<<
operator|(
name|op
operator|->
name|extbits
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
name|maxext
operator|=
operator|(
literal|1
operator|<<
operator|(
name|op
operator|->
name|extbits
operator|-
literal|1
operator|)
operator|)
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|val
operator|<
name|minext
operator|||
name|val
operator|>
name|maxext
condition|)
name|as_bad_where
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
name|_
argument_list|(
literal|"operand value out of range for instruction"
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|use_extend
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|op
operator|->
name|extbits
operator|==
literal|16
condition|)
block|{
name|extval
operator|=
operator|(
operator|(
name|val
operator|>>
literal|11
operator|)
operator|&
literal|0x1f
operator|)
operator||
operator|(
name|val
operator|&
literal|0x7e0
operator|)
expr_stmt|;
name|val
operator|&=
literal|0x1f
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|op
operator|->
name|extbits
operator|==
literal|15
condition|)
block|{
name|extval
operator|=
operator|(
operator|(
name|val
operator|>>
literal|11
operator|)
operator|&
literal|0xf
operator|)
operator||
operator|(
name|val
operator|&
literal|0x7f0
operator|)
expr_stmt|;
name|val
operator|&=
literal|0xf
expr_stmt|;
block|}
else|else
block|{
name|extval
operator|=
operator|(
operator|(
name|val
operator|&
literal|0x1f
operator|)
operator|<<
literal|6
operator|)
operator||
operator|(
name|val
operator|&
literal|0x20
operator|)
expr_stmt|;
name|val
operator|=
literal|0
expr_stmt|;
block|}
operator|*
name|extend
operator|=
operator|(
name|unsigned
name|short
operator|)
name|extval
expr_stmt|;
operator|*
name|insn
operator||=
name|val
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_struct
specifier|static
specifier|const
struct|struct
name|percent_op_match
block|{
specifier|const
name|char
modifier|*
name|str
decl_stmt|;
name|bfd_reloc_code_real_type
name|reloc
decl_stmt|;
block|}
name|percent_op
index|[]
init|=
block|{
block|{
literal|"%lo"
block|,
name|BFD_RELOC_LO16
block|}
block|,
ifdef|#
directive|ifdef
name|OBJ_ELF
block|{
literal|"%call_hi"
block|,
name|BFD_RELOC_MIPS_CALL_HI16
block|}
block|,
block|{
literal|"%call_lo"
block|,
name|BFD_RELOC_MIPS_CALL_LO16
block|}
block|,
block|{
literal|"%call16"
block|,
name|BFD_RELOC_MIPS_CALL16
block|}
block|,
block|{
literal|"%got_disp"
block|,
name|BFD_RELOC_MIPS_GOT_DISP
block|}
block|,
block|{
literal|"%got_page"
block|,
name|BFD_RELOC_MIPS_GOT_PAGE
block|}
block|,
block|{
literal|"%got_ofst"
block|,
name|BFD_RELOC_MIPS_GOT_OFST
block|}
block|,
block|{
literal|"%got_hi"
block|,
name|BFD_RELOC_MIPS_GOT_HI16
block|}
block|,
block|{
literal|"%got_lo"
block|,
name|BFD_RELOC_MIPS_GOT_LO16
block|}
block|,
block|{
literal|"%got"
block|,
name|BFD_RELOC_MIPS_GOT16
block|}
block|,
block|{
literal|"%gp_rel"
block|,
name|BFD_RELOC_GPREL16
block|}
block|,
block|{
literal|"%half"
block|,
name|BFD_RELOC_16
block|}
block|,
block|{
literal|"%highest"
block|,
name|BFD_RELOC_MIPS_HIGHEST
block|}
block|,
block|{
literal|"%higher"
block|,
name|BFD_RELOC_MIPS_HIGHER
block|}
block|,
block|{
literal|"%neg"
block|,
name|BFD_RELOC_MIPS_SUB
block|}
block|,
endif|#
directive|endif
block|{
literal|"%hi"
block|,
name|BFD_RELOC_HI16_S
block|}
block|}
struct|;
end_struct

begin_comment
comment|/* Return true if *STR points to a relocation operator.  When returning true,    move *STR over the operator and store its relocation code in *RELOC.    Leave both *STR and *RELOC alone when returning false.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|parse_relocation
parameter_list|(
name|char
modifier|*
modifier|*
name|str
parameter_list|,
name|bfd_reloc_code_real_type
modifier|*
name|reloc
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|percent_op
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|strncasecmp
argument_list|(
operator|*
name|str
argument_list|,
name|percent_op
index|[
name|i
index|]
operator|.
name|str
argument_list|,
name|strlen
argument_list|(
name|percent_op
index|[
name|i
index|]
operator|.
name|str
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|str
operator|+=
name|strlen
argument_list|(
name|percent_op
index|[
name|i
index|]
operator|.
name|str
argument_list|)
expr_stmt|;
operator|*
name|reloc
operator|=
name|percent_op
index|[
name|i
index|]
operator|.
name|reloc
expr_stmt|;
comment|/* Check whether the output BFD supports this relocation. 	   If not, issue an error and fall back on something safe.  */
if|if
condition|(
operator|!
name|bfd_reloc_type_lookup
argument_list|(
name|stdoutput
argument_list|,
name|percent_op
index|[
name|i
index|]
operator|.
name|reloc
argument_list|)
condition|)
block|{
name|as_bad
argument_list|(
literal|"relocation %s isn't supported by the current ABI"
argument_list|,
name|percent_op
index|[
name|i
index|]
operator|.
name|str
argument_list|)
expr_stmt|;
operator|*
name|reloc
operator|=
name|BFD_RELOC_LO16
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* Parse string STR as a 16-bit relocatable operand.  Store the    expression in *EP and the relocations in the array starting    at RELOC.  Return the number of relocation operators used.     On exit, EXPR_END points to the first character after the expression.    If no relocation operators are used, RELOC[0] is set to BFD_RELOC_LO16.  */
end_comment

begin_function
specifier|static
name|size_t
name|my_getSmallExpression
parameter_list|(
name|expressionS
modifier|*
name|ep
parameter_list|,
name|bfd_reloc_code_real_type
modifier|*
name|reloc
parameter_list|,
name|char
modifier|*
name|str
parameter_list|)
block|{
name|bfd_reloc_code_real_type
name|reversed_reloc
index|[
literal|3
index|]
decl_stmt|;
name|size_t
name|reloc_index
decl_stmt|,
name|i
decl_stmt|;
name|int
name|crux_depth
decl_stmt|,
name|str_depth
decl_stmt|;
name|char
modifier|*
name|crux
decl_stmt|;
comment|/* Search for the start of the main expression, recoding relocations      in REVERSED_RELOC.  End the loop with CRUX pointing to the start      of the main expression and with CRUX_DEPTH containing the number      of open brackets at that point.  */
name|reloc_index
operator|=
operator|-
literal|1
expr_stmt|;
name|str_depth
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|reloc_index
operator|++
expr_stmt|;
name|crux
operator|=
name|str
expr_stmt|;
name|crux_depth
operator|=
name|str_depth
expr_stmt|;
comment|/* Skip over whitespace and brackets, keeping count of the number 	 of brackets.  */
while|while
condition|(
operator|*
name|str
operator|==
literal|' '
operator|||
operator|*
name|str
operator|==
literal|'\t'
operator|||
operator|*
name|str
operator|==
literal|'('
condition|)
if|if
condition|(
operator|*
name|str
operator|++
operator|==
literal|'('
condition|)
name|str_depth
operator|++
expr_stmt|;
block|}
do|while
condition|(
operator|*
name|str
operator|==
literal|'%'
operator|&&
name|reloc_index
operator|<
operator|(
name|HAVE_NEWABI
condition|?
literal|3
else|:
literal|1
operator|)
operator|&&
name|parse_relocation
argument_list|(
operator|&
name|str
argument_list|,
operator|&
name|reversed_reloc
index|[
name|reloc_index
index|]
argument_list|)
condition|)
do|;
name|my_getExpression
argument_list|(
name|ep
argument_list|,
name|crux
argument_list|)
expr_stmt|;
name|str
operator|=
name|expr_end
expr_stmt|;
comment|/* Match every open bracket.  */
while|while
condition|(
name|crux_depth
operator|>
literal|0
operator|&&
operator|(
operator|*
name|str
operator|==
literal|')'
operator|||
operator|*
name|str
operator|==
literal|' '
operator|||
operator|*
name|str
operator|==
literal|'\t'
operator|)
condition|)
if|if
condition|(
operator|*
name|str
operator|++
operator|==
literal|')'
condition|)
name|crux_depth
operator|--
expr_stmt|;
if|if
condition|(
name|crux_depth
operator|>
literal|0
condition|)
name|as_bad
argument_list|(
literal|"unclosed '('"
argument_list|)
expr_stmt|;
name|expr_end
operator|=
name|str
expr_stmt|;
if|if
condition|(
name|reloc_index
operator|==
literal|0
condition|)
name|reloc
index|[
literal|0
index|]
operator|=
name|BFD_RELOC_LO16
expr_stmt|;
else|else
block|{
name|prev_reloc_op_frag
operator|=
name|frag_now
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|reloc_index
condition|;
name|i
operator|++
control|)
name|reloc
index|[
name|i
index|]
operator|=
name|reversed_reloc
index|[
name|reloc_index
operator|-
literal|1
operator|-
name|i
index|]
expr_stmt|;
block|}
return|return
name|reloc_index
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|my_getExpression
parameter_list|(
name|expressionS
modifier|*
name|ep
parameter_list|,
name|char
modifier|*
name|str
parameter_list|)
block|{
name|char
modifier|*
name|save_in
decl_stmt|;
name|valueT
name|val
decl_stmt|;
name|save_in
operator|=
name|input_line_pointer
expr_stmt|;
name|input_line_pointer
operator|=
name|str
expr_stmt|;
name|expression
argument_list|(
name|ep
argument_list|)
expr_stmt|;
name|expr_end
operator|=
name|input_line_pointer
expr_stmt|;
name|input_line_pointer
operator|=
name|save_in
expr_stmt|;
comment|/* If we are in mips16 mode, and this is an expression based on `.',      then we bump the value of the symbol by 1 since that is how other      text symbols are handled.  We don't bother to handle complex      expressions, just `.' plus or minus a constant.  */
if|if
condition|(
name|mips_opts
operator|.
name|mips16
operator|&&
name|ep
operator|->
name|X_op
operator|==
name|O_symbol
operator|&&
name|strcmp
argument_list|(
name|S_GET_NAME
argument_list|(
name|ep
operator|->
name|X_add_symbol
argument_list|)
argument_list|,
name|FAKE_LABEL_NAME
argument_list|)
operator|==
literal|0
operator|&&
name|S_GET_SEGMENT
argument_list|(
name|ep
operator|->
name|X_add_symbol
argument_list|)
operator|==
name|now_seg
operator|&&
name|symbol_get_frag
argument_list|(
name|ep
operator|->
name|X_add_symbol
argument_list|)
operator|==
name|frag_now
operator|&&
name|symbol_constant_p
argument_list|(
name|ep
operator|->
name|X_add_symbol
argument_list|)
operator|&&
operator|(
name|val
operator|=
name|S_GET_VALUE
argument_list|(
name|ep
operator|->
name|X_add_symbol
argument_list|)
operator|)
operator|==
name|frag_now_fix
argument_list|()
condition|)
name|S_SET_VALUE
argument_list|(
name|ep
operator|->
name|X_add_symbol
argument_list|,
name|val
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Turn a string in input_line_pointer into a floating point constant    of type TYPE, and store the appropriate bytes in *LITP.  The number    of LITTLENUMS emitted is stored in *SIZEP.  An error message is    returned, or NULL on OK.  */
end_comment

begin_function
name|char
modifier|*
name|md_atof
parameter_list|(
name|int
name|type
parameter_list|,
name|char
modifier|*
name|litP
parameter_list|,
name|int
modifier|*
name|sizeP
parameter_list|)
block|{
name|int
name|prec
decl_stmt|;
name|LITTLENUM_TYPE
name|words
index|[
literal|4
index|]
decl_stmt|;
name|char
modifier|*
name|t
decl_stmt|;
name|int
name|i
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
literal|'f'
case|:
name|prec
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|prec
operator|=
literal|4
expr_stmt|;
break|break;
default|default:
operator|*
name|sizeP
operator|=
literal|0
expr_stmt|;
return|return
name|_
argument_list|(
literal|"bad call to md_atof"
argument_list|)
return|;
block|}
name|t
operator|=
name|atof_ieee
argument_list|(
name|input_line_pointer
argument_list|,
name|type
argument_list|,
name|words
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
condition|)
name|input_line_pointer
operator|=
name|t
expr_stmt|;
operator|*
name|sizeP
operator|=
name|prec
operator|*
literal|2
expr_stmt|;
if|if
condition|(
operator|!
name|target_big_endian
condition|)
block|{
for|for
control|(
name|i
operator|=
name|prec
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|md_number_to_chars
argument_list|(
name|litP
argument_list|,
name|words
index|[
name|i
index|]
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|litP
operator|+=
literal|2
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|prec
condition|;
name|i
operator|++
control|)
block|{
name|md_number_to_chars
argument_list|(
name|litP
argument_list|,
name|words
index|[
name|i
index|]
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|litP
operator|+=
literal|2
expr_stmt|;
block|}
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|void
name|md_number_to_chars
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|valueT
name|val
parameter_list|,
name|int
name|n
parameter_list|)
block|{
if|if
condition|(
name|target_big_endian
condition|)
name|number_to_chars_bigendian
argument_list|(
name|buf
argument_list|,
name|val
argument_list|,
name|n
argument_list|)
expr_stmt|;
else|else
name|number_to_chars_littleendian
argument_list|(
name|buf
argument_list|,
name|val
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|OBJ_ELF
end_ifdef

begin_function
specifier|static
name|int
name|support_64bit_objects
parameter_list|(
name|void
parameter_list|)
block|{
specifier|const
name|char
modifier|*
modifier|*
name|list
decl_stmt|,
modifier|*
modifier|*
name|l
decl_stmt|;
name|int
name|yes
decl_stmt|;
name|list
operator|=
name|bfd_target_list
argument_list|()
expr_stmt|;
for|for
control|(
name|l
operator|=
name|list
init|;
operator|*
name|l
operator|!=
name|NULL
condition|;
name|l
operator|++
control|)
ifdef|#
directive|ifdef
name|TE_TMIPS
comment|/* This is traditional mips */
if|if
condition|(
name|strcmp
argument_list|(
operator|*
name|l
argument_list|,
literal|"elf64-tradbigmips"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
operator|*
name|l
argument_list|,
literal|"elf64-tradlittlemips"
argument_list|)
operator|==
literal|0
condition|)
else|#
directive|else
if|if
condition|(
name|strcmp
argument_list|(
operator|*
name|l
argument_list|,
literal|"elf64-bigmips"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
operator|*
name|l
argument_list|,
literal|"elf64-littlemips"
argument_list|)
operator|==
literal|0
condition|)
endif|#
directive|endif
break|break;
name|yes
operator|=
operator|(
operator|*
name|l
operator|!=
name|NULL
operator|)
expr_stmt|;
name|free
argument_list|(
name|list
argument_list|)
expr_stmt|;
return|return
name|yes
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* OBJ_ELF */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|md_shortopts
init|=
literal|"O::g::G:"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|option
name|md_longopts
index|[]
init|=
block|{
comment|/* Options which specify architecture.  */
define|#
directive|define
name|OPTION_ARCH_BASE
value|(OPTION_MD_BASE)
define|#
directive|define
name|OPTION_MARCH
value|(OPTION_ARCH_BASE + 0)
block|{
literal|"march"
block|,
name|required_argument
block|,
name|NULL
block|,
name|OPTION_MARCH
block|}
block|,
define|#
directive|define
name|OPTION_MTUNE
value|(OPTION_ARCH_BASE + 1)
block|{
literal|"mtune"
block|,
name|required_argument
block|,
name|NULL
block|,
name|OPTION_MTUNE
block|}
block|,
define|#
directive|define
name|OPTION_MIPS1
value|(OPTION_ARCH_BASE + 2)
block|{
literal|"mips0"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_MIPS1
block|}
block|,
block|{
literal|"mips1"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_MIPS1
block|}
block|,
define|#
directive|define
name|OPTION_MIPS2
value|(OPTION_ARCH_BASE + 3)
block|{
literal|"mips2"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_MIPS2
block|}
block|,
define|#
directive|define
name|OPTION_MIPS3
value|(OPTION_ARCH_BASE + 4)
block|{
literal|"mips3"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_MIPS3
block|}
block|,
define|#
directive|define
name|OPTION_MIPS4
value|(OPTION_ARCH_BASE + 5)
block|{
literal|"mips4"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_MIPS4
block|}
block|,
define|#
directive|define
name|OPTION_MIPS5
value|(OPTION_ARCH_BASE + 6)
block|{
literal|"mips5"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_MIPS5
block|}
block|,
define|#
directive|define
name|OPTION_MIPS32
value|(OPTION_ARCH_BASE + 7)
block|{
literal|"mips32"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_MIPS32
block|}
block|,
define|#
directive|define
name|OPTION_MIPS64
value|(OPTION_ARCH_BASE + 8)
block|{
literal|"mips64"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_MIPS64
block|}
block|,
define|#
directive|define
name|OPTION_MIPS32R2
value|(OPTION_ARCH_BASE + 9)
block|{
literal|"mips32r2"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_MIPS32R2
block|}
block|,
define|#
directive|define
name|OPTION_MIPS64R2
value|(OPTION_ARCH_BASE + 10)
block|{
literal|"mips64r2"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_MIPS64R2
block|}
block|,
comment|/* Options which specify Application Specific Extensions (ASEs).  */
define|#
directive|define
name|OPTION_ASE_BASE
value|(OPTION_ARCH_BASE + 11)
define|#
directive|define
name|OPTION_MIPS16
value|(OPTION_ASE_BASE + 0)
block|{
literal|"mips16"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_MIPS16
block|}
block|,
define|#
directive|define
name|OPTION_NO_MIPS16
value|(OPTION_ASE_BASE + 1)
block|{
literal|"no-mips16"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_NO_MIPS16
block|}
block|,
define|#
directive|define
name|OPTION_MIPS3D
value|(OPTION_ASE_BASE + 2)
block|{
literal|"mips3d"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_MIPS3D
block|}
block|,
define|#
directive|define
name|OPTION_NO_MIPS3D
value|(OPTION_ASE_BASE + 3)
block|{
literal|"no-mips3d"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_NO_MIPS3D
block|}
block|,
define|#
directive|define
name|OPTION_MDMX
value|(OPTION_ASE_BASE + 4)
block|{
literal|"mdmx"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_MDMX
block|}
block|,
define|#
directive|define
name|OPTION_NO_MDMX
value|(OPTION_ASE_BASE + 5)
block|{
literal|"no-mdmx"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_NO_MDMX
block|}
block|,
comment|/* Old-style architecture options.  Don't add more of these.  */
define|#
directive|define
name|OPTION_COMPAT_ARCH_BASE
value|(OPTION_ASE_BASE + 6)
define|#
directive|define
name|OPTION_M4650
value|(OPTION_COMPAT_ARCH_BASE + 0)
block|{
literal|"m4650"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_M4650
block|}
block|,
define|#
directive|define
name|OPTION_NO_M4650
value|(OPTION_COMPAT_ARCH_BASE + 1)
block|{
literal|"no-m4650"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_NO_M4650
block|}
block|,
define|#
directive|define
name|OPTION_M4010
value|(OPTION_COMPAT_ARCH_BASE + 2)
block|{
literal|"m4010"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_M4010
block|}
block|,
define|#
directive|define
name|OPTION_NO_M4010
value|(OPTION_COMPAT_ARCH_BASE + 3)
block|{
literal|"no-m4010"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_NO_M4010
block|}
block|,
define|#
directive|define
name|OPTION_M4100
value|(OPTION_COMPAT_ARCH_BASE + 4)
block|{
literal|"m4100"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_M4100
block|}
block|,
define|#
directive|define
name|OPTION_NO_M4100
value|(OPTION_COMPAT_ARCH_BASE + 5)
block|{
literal|"no-m4100"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_NO_M4100
block|}
block|,
define|#
directive|define
name|OPTION_M3900
value|(OPTION_COMPAT_ARCH_BASE + 6)
block|{
literal|"m3900"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_M3900
block|}
block|,
define|#
directive|define
name|OPTION_NO_M3900
value|(OPTION_COMPAT_ARCH_BASE + 7)
block|{
literal|"no-m3900"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_NO_M3900
block|}
block|,
comment|/* Options which enable bug fixes.  */
define|#
directive|define
name|OPTION_FIX_BASE
value|(OPTION_COMPAT_ARCH_BASE + 8)
define|#
directive|define
name|OPTION_M7000_HILO_FIX
value|(OPTION_FIX_BASE + 0)
block|{
literal|"mfix7000"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_M7000_HILO_FIX
block|}
block|,
define|#
directive|define
name|OPTION_MNO_7000_HILO_FIX
value|(OPTION_FIX_BASE + 1)
block|{
literal|"no-fix-7000"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_MNO_7000_HILO_FIX
block|}
block|,
block|{
literal|"mno-fix7000"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_MNO_7000_HILO_FIX
block|}
block|,
define|#
directive|define
name|OPTION_FIX_VR4120
value|(OPTION_FIX_BASE + 2)
define|#
directive|define
name|OPTION_NO_FIX_VR4120
value|(OPTION_FIX_BASE + 3)
block|{
literal|"mfix-vr4120"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_FIX_VR4120
block|}
block|,
block|{
literal|"mno-fix-vr4120"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_NO_FIX_VR4120
block|}
block|,
comment|/* Miscellaneous options.  */
define|#
directive|define
name|OPTION_MISC_BASE
value|(OPTION_FIX_BASE + 4)
define|#
directive|define
name|OPTION_MEMBEDDED_PIC
value|(OPTION_MISC_BASE + 0)
block|{
literal|"membedded-pic"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_MEMBEDDED_PIC
block|}
block|,
define|#
directive|define
name|OPTION_TRAP
value|(OPTION_MISC_BASE + 1)
block|{
literal|"trap"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_TRAP
block|}
block|,
block|{
literal|"no-break"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_TRAP
block|}
block|,
define|#
directive|define
name|OPTION_BREAK
value|(OPTION_MISC_BASE + 2)
block|{
literal|"break"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_BREAK
block|}
block|,
block|{
literal|"no-trap"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_BREAK
block|}
block|,
define|#
directive|define
name|OPTION_EB
value|(OPTION_MISC_BASE + 3)
block|{
literal|"EB"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_EB
block|}
block|,
define|#
directive|define
name|OPTION_EL
value|(OPTION_MISC_BASE + 4)
block|{
literal|"EL"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_EL
block|}
block|,
define|#
directive|define
name|OPTION_FP32
value|(OPTION_MISC_BASE + 5)
block|{
literal|"mfp32"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_FP32
block|}
block|,
define|#
directive|define
name|OPTION_GP32
value|(OPTION_MISC_BASE + 6)
block|{
literal|"mgp32"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_GP32
block|}
block|,
define|#
directive|define
name|OPTION_CONSTRUCT_FLOATS
value|(OPTION_MISC_BASE + 7)
block|{
literal|"construct-floats"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_CONSTRUCT_FLOATS
block|}
block|,
define|#
directive|define
name|OPTION_NO_CONSTRUCT_FLOATS
value|(OPTION_MISC_BASE + 8)
block|{
literal|"no-construct-floats"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_NO_CONSTRUCT_FLOATS
block|}
block|,
define|#
directive|define
name|OPTION_FP64
value|(OPTION_MISC_BASE + 9)
block|{
literal|"mfp64"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_FP64
block|}
block|,
define|#
directive|define
name|OPTION_GP64
value|(OPTION_MISC_BASE + 10)
block|{
literal|"mgp64"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_GP64
block|}
block|,
define|#
directive|define
name|OPTION_RELAX_BRANCH
value|(OPTION_MISC_BASE + 11)
define|#
directive|define
name|OPTION_NO_RELAX_BRANCH
value|(OPTION_MISC_BASE + 12)
block|{
literal|"relax-branch"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_RELAX_BRANCH
block|}
block|,
block|{
literal|"no-relax-branch"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_NO_RELAX_BRANCH
block|}
block|,
comment|/* ELF-specific options.  */
ifdef|#
directive|ifdef
name|OBJ_ELF
define|#
directive|define
name|OPTION_ELF_BASE
value|(OPTION_MISC_BASE + 13)
define|#
directive|define
name|OPTION_CALL_SHARED
value|(OPTION_ELF_BASE + 0)
block|{
literal|"KPIC"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_CALL_SHARED
block|}
block|,
block|{
literal|"call_shared"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_CALL_SHARED
block|}
block|,
define|#
directive|define
name|OPTION_NON_SHARED
value|(OPTION_ELF_BASE + 1)
block|{
literal|"non_shared"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_NON_SHARED
block|}
block|,
define|#
directive|define
name|OPTION_XGOT
value|(OPTION_ELF_BASE + 2)
block|{
literal|"xgot"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_XGOT
block|}
block|,
define|#
directive|define
name|OPTION_MABI
value|(OPTION_ELF_BASE + 3)
block|{
literal|"mabi"
block|,
name|required_argument
block|,
name|NULL
block|,
name|OPTION_MABI
block|}
block|,
define|#
directive|define
name|OPTION_32
value|(OPTION_ELF_BASE + 4)
block|{
literal|"32"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_32
block|}
block|,
define|#
directive|define
name|OPTION_N32
value|(OPTION_ELF_BASE + 5)
block|{
literal|"n32"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_N32
block|}
block|,
define|#
directive|define
name|OPTION_64
value|(OPTION_ELF_BASE + 6)
block|{
literal|"64"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_64
block|}
block|,
define|#
directive|define
name|OPTION_MDEBUG
value|(OPTION_ELF_BASE + 7)
block|{
literal|"mdebug"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_MDEBUG
block|}
block|,
define|#
directive|define
name|OPTION_NO_MDEBUG
value|(OPTION_ELF_BASE + 8)
block|{
literal|"no-mdebug"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_NO_MDEBUG
block|}
block|,
define|#
directive|define
name|OPTION_PDR
value|(OPTION_ELF_BASE + 9)
block|{
literal|"mpdr"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_PDR
block|}
block|,
define|#
directive|define
name|OPTION_NO_PDR
value|(OPTION_ELF_BASE + 10)
block|{
literal|"mno-pdr"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_NO_PDR
block|}
block|,
endif|#
directive|endif
comment|/* OBJ_ELF */
block|{
name|NULL
block|,
name|no_argument
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|size_t
name|md_longopts_size
init|=
sizeof|sizeof
argument_list|(
name|md_longopts
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set STRING_PTR (either&mips_arch_string or&mips_tune_string) to    NEW_VALUE.  Warn if another value was already specified.  Note:    we have to defer parsing the -march and -mtune arguments in order    to handle 'from-abi' correctly, since the ABI might be specified    in a later argument.  */
end_comment

begin_function
specifier|static
name|void
name|mips_set_option_string
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|string_ptr
parameter_list|,
specifier|const
name|char
modifier|*
name|new_value
parameter_list|)
block|{
if|if
condition|(
operator|*
name|string_ptr
operator|!=
literal|0
operator|&&
name|strcasecmp
argument_list|(
operator|*
name|string_ptr
argument_list|,
name|new_value
argument_list|)
operator|!=
literal|0
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"A different %s was already specified, is now %s"
argument_list|)
argument_list|,
name|string_ptr
operator|==
operator|&
name|mips_arch_string
condition|?
literal|"-march"
else|:
literal|"-mtune"
argument_list|,
name|new_value
argument_list|)
expr_stmt|;
operator|*
name|string_ptr
operator|=
name|new_value
expr_stmt|;
block|}
end_function

begin_function
name|int
name|md_parse_option
parameter_list|(
name|int
name|c
parameter_list|,
name|char
modifier|*
name|arg
parameter_list|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
name|OPTION_CONSTRUCT_FLOATS
case|:
name|mips_disable_float_construction
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|OPTION_NO_CONSTRUCT_FLOATS
case|:
name|mips_disable_float_construction
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|OPTION_TRAP
case|:
name|mips_trap
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|OPTION_BREAK
case|:
name|mips_trap
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|OPTION_EB
case|:
name|target_big_endian
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|OPTION_EL
case|:
name|target_big_endian
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'O'
case|:
if|if
condition|(
name|arg
operator|&&
name|arg
index|[
literal|1
index|]
operator|==
literal|'0'
condition|)
name|mips_optimize
operator|=
literal|1
expr_stmt|;
else|else
name|mips_optimize
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|'g'
case|:
if|if
condition|(
name|arg
operator|==
name|NULL
condition|)
name|mips_debug
operator|=
literal|2
expr_stmt|;
else|else
name|mips_debug
operator|=
name|atoi
argument_list|(
name|arg
argument_list|)
expr_stmt|;
comment|/* When the MIPS assembler sees -g or -g2, it does not do          optimizations which limit full symbolic debugging.  We take          that to be equivalent to -O0.  */
if|if
condition|(
name|mips_debug
operator|==
literal|2
condition|)
name|mips_optimize
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|OPTION_MIPS1
case|:
name|file_mips_isa
operator|=
name|ISA_MIPS1
expr_stmt|;
break|break;
case|case
name|OPTION_MIPS2
case|:
name|file_mips_isa
operator|=
name|ISA_MIPS2
expr_stmt|;
break|break;
case|case
name|OPTION_MIPS3
case|:
name|file_mips_isa
operator|=
name|ISA_MIPS3
expr_stmt|;
break|break;
case|case
name|OPTION_MIPS4
case|:
name|file_mips_isa
operator|=
name|ISA_MIPS4
expr_stmt|;
break|break;
case|case
name|OPTION_MIPS5
case|:
name|file_mips_isa
operator|=
name|ISA_MIPS5
expr_stmt|;
break|break;
case|case
name|OPTION_MIPS32
case|:
name|file_mips_isa
operator|=
name|ISA_MIPS32
expr_stmt|;
break|break;
case|case
name|OPTION_MIPS32R2
case|:
name|file_mips_isa
operator|=
name|ISA_MIPS32R2
expr_stmt|;
break|break;
case|case
name|OPTION_MIPS64R2
case|:
name|file_mips_isa
operator|=
name|ISA_MIPS64R2
expr_stmt|;
break|break;
case|case
name|OPTION_MIPS64
case|:
name|file_mips_isa
operator|=
name|ISA_MIPS64
expr_stmt|;
break|break;
case|case
name|OPTION_MTUNE
case|:
name|mips_set_option_string
argument_list|(
operator|&
name|mips_tune_string
argument_list|,
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPTION_MARCH
case|:
name|mips_set_option_string
argument_list|(
operator|&
name|mips_arch_string
argument_list|,
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPTION_M4650
case|:
name|mips_set_option_string
argument_list|(
operator|&
name|mips_arch_string
argument_list|,
literal|"4650"
argument_list|)
expr_stmt|;
name|mips_set_option_string
argument_list|(
operator|&
name|mips_tune_string
argument_list|,
literal|"4650"
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPTION_NO_M4650
case|:
break|break;
case|case
name|OPTION_M4010
case|:
name|mips_set_option_string
argument_list|(
operator|&
name|mips_arch_string
argument_list|,
literal|"4010"
argument_list|)
expr_stmt|;
name|mips_set_option_string
argument_list|(
operator|&
name|mips_tune_string
argument_list|,
literal|"4010"
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPTION_NO_M4010
case|:
break|break;
case|case
name|OPTION_M4100
case|:
name|mips_set_option_string
argument_list|(
operator|&
name|mips_arch_string
argument_list|,
literal|"4100"
argument_list|)
expr_stmt|;
name|mips_set_option_string
argument_list|(
operator|&
name|mips_tune_string
argument_list|,
literal|"4100"
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPTION_NO_M4100
case|:
break|break;
case|case
name|OPTION_M3900
case|:
name|mips_set_option_string
argument_list|(
operator|&
name|mips_arch_string
argument_list|,
literal|"3900"
argument_list|)
expr_stmt|;
name|mips_set_option_string
argument_list|(
operator|&
name|mips_tune_string
argument_list|,
literal|"3900"
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPTION_NO_M3900
case|:
break|break;
case|case
name|OPTION_MDMX
case|:
name|mips_opts
operator|.
name|ase_mdmx
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|OPTION_NO_MDMX
case|:
name|mips_opts
operator|.
name|ase_mdmx
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|OPTION_MIPS16
case|:
name|mips_opts
operator|.
name|mips16
operator|=
literal|1
expr_stmt|;
name|mips_no_prev_insn
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPTION_NO_MIPS16
case|:
name|mips_opts
operator|.
name|mips16
operator|=
literal|0
expr_stmt|;
name|mips_no_prev_insn
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPTION_MIPS3D
case|:
name|mips_opts
operator|.
name|ase_mips3d
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|OPTION_NO_MIPS3D
case|:
name|mips_opts
operator|.
name|ase_mips3d
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|OPTION_MEMBEDDED_PIC
case|:
name|mips_pic
operator|=
name|EMBEDDED_PIC
expr_stmt|;
if|if
condition|(
name|USE_GLOBAL_POINTER_OPT
operator|&&
name|g_switch_seen
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"-G may not be used with embedded PIC code"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|g_switch_value
operator|=
literal|0x7fffffff
expr_stmt|;
break|break;
case|case
name|OPTION_FIX_VR4120
case|:
name|mips_fix_vr4120
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|OPTION_NO_FIX_VR4120
case|:
name|mips_fix_vr4120
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|OPTION_RELAX_BRANCH
case|:
name|mips_relax_branch
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|OPTION_NO_RELAX_BRANCH
case|:
name|mips_relax_branch
operator|=
literal|0
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|OBJ_ELF
comment|/* When generating ELF code, we permit -KPIC and -call_shared to 	 select SVR4_PIC, and -non_shared to select no PIC.  This is 	 intended to be compatible with Irix 5.  */
case|case
name|OPTION_CALL_SHARED
case|:
if|if
condition|(
name|OUTPUT_FLAVOR
operator|!=
name|bfd_target_elf_flavour
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"-call_shared is supported only for ELF format"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|mips_pic
operator|=
name|SVR4_PIC
expr_stmt|;
name|mips_abicalls
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|g_switch_seen
operator|&&
name|g_switch_value
operator|!=
literal|0
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"-G may not be used with SVR4 PIC code"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|g_switch_value
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|OPTION_NON_SHARED
case|:
if|if
condition|(
name|OUTPUT_FLAVOR
operator|!=
name|bfd_target_elf_flavour
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"-non_shared is supported only for ELF format"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|mips_pic
operator|=
name|NO_PIC
expr_stmt|;
name|mips_abicalls
operator|=
name|FALSE
expr_stmt|;
break|break;
comment|/* The -xgot option tells the assembler to use 32 offsets when          accessing the got in SVR4_PIC mode.  It is for Irix          compatibility.  */
case|case
name|OPTION_XGOT
case|:
name|mips_big_got
operator|=
literal|1
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* OBJ_ELF */
case|case
literal|'G'
case|:
if|if
condition|(
operator|!
name|USE_GLOBAL_POINTER_OPT
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"-G is not supported for this configuration"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|mips_pic
operator|==
name|SVR4_PIC
operator|||
name|mips_pic
operator|==
name|EMBEDDED_PIC
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"-G may not be used with SVR4 or embedded PIC code"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
name|g_switch_value
operator|=
name|atoi
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|g_switch_seen
operator|=
literal|1
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|OBJ_ELF
comment|/* The -32, -n32 and -64 options are shortcuts for -mabi=32, -mabi=n32 	 and -mabi=64.  */
case|case
name|OPTION_32
case|:
if|if
condition|(
name|OUTPUT_FLAVOR
operator|!=
name|bfd_target_elf_flavour
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"-32 is supported for ELF format only"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|mips_abi
operator|=
name|O32_ABI
expr_stmt|;
break|break;
case|case
name|OPTION_N32
case|:
if|if
condition|(
name|OUTPUT_FLAVOR
operator|!=
name|bfd_target_elf_flavour
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"-n32 is supported for ELF format only"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|mips_abi
operator|=
name|N32_ABI
expr_stmt|;
break|break;
case|case
name|OPTION_64
case|:
if|if
condition|(
name|OUTPUT_FLAVOR
operator|!=
name|bfd_target_elf_flavour
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"-64 is supported for ELF format only"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|mips_abi
operator|=
name|N64_ABI
expr_stmt|;
if|if
condition|(
operator|!
name|support_64bit_objects
argument_list|()
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"No compiled in support for 64 bit object file format"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* OBJ_ELF */
case|case
name|OPTION_GP32
case|:
name|file_mips_gp32
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|OPTION_GP64
case|:
name|file_mips_gp32
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|OPTION_FP32
case|:
name|file_mips_fp32
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|OPTION_FP64
case|:
name|file_mips_fp32
operator|=
literal|0
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|OBJ_ELF
case|case
name|OPTION_MABI
case|:
if|if
condition|(
name|OUTPUT_FLAVOR
operator|!=
name|bfd_target_elf_flavour
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"-mabi is supported for ELF format only"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"32"
argument_list|)
operator|==
literal|0
condition|)
name|mips_abi
operator|=
name|O32_ABI
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"o64"
argument_list|)
operator|==
literal|0
condition|)
name|mips_abi
operator|=
name|O64_ABI
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"n32"
argument_list|)
operator|==
literal|0
condition|)
name|mips_abi
operator|=
name|N32_ABI
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"64"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|mips_abi
operator|=
name|N64_ABI
expr_stmt|;
if|if
condition|(
operator|!
name|support_64bit_objects
argument_list|()
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"No compiled in support for 64 bit object file "
literal|"format"
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"eabi"
argument_list|)
operator|==
literal|0
condition|)
name|mips_abi
operator|=
name|EABI_ABI
expr_stmt|;
else|else
block|{
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"invalid abi -mabi=%s"
argument_list|)
argument_list|,
name|arg
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
break|break;
endif|#
directive|endif
comment|/* OBJ_ELF */
case|case
name|OPTION_M7000_HILO_FIX
case|:
name|mips_7000_hilo_fix
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|OPTION_MNO_7000_HILO_FIX
case|:
name|mips_7000_hilo_fix
operator|=
name|FALSE
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|OBJ_ELF
case|case
name|OPTION_MDEBUG
case|:
name|mips_flag_mdebug
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|OPTION_NO_MDEBUG
case|:
name|mips_flag_mdebug
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
name|OPTION_PDR
case|:
name|mips_flag_pdr
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|OPTION_NO_PDR
case|:
name|mips_flag_pdr
operator|=
name|FALSE
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* OBJ_ELF */
default|default:
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Set up globals to generate code for the ISA or processor    described by INFO.  */
end_comment

begin_function
specifier|static
name|void
name|mips_set_architecture
parameter_list|(
specifier|const
name|struct
name|mips_cpu_info
modifier|*
name|info
parameter_list|)
block|{
if|if
condition|(
name|info
operator|!=
literal|0
condition|)
block|{
name|file_mips_arch
operator|=
name|info
operator|->
name|cpu
expr_stmt|;
name|mips_opts
operator|.
name|arch
operator|=
name|info
operator|->
name|cpu
expr_stmt|;
name|mips_opts
operator|.
name|isa
operator|=
name|info
operator|->
name|isa
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Likewise for tuning.  */
end_comment

begin_function
specifier|static
name|void
name|mips_set_tune
parameter_list|(
specifier|const
name|struct
name|mips_cpu_info
modifier|*
name|info
parameter_list|)
block|{
if|if
condition|(
name|info
operator|!=
literal|0
condition|)
name|mips_tune
operator|=
name|info
operator|->
name|cpu
expr_stmt|;
block|}
end_function

begin_function
name|void
name|mips_after_parse_args
parameter_list|(
name|void
parameter_list|)
block|{
specifier|const
name|struct
name|mips_cpu_info
modifier|*
name|arch_info
init|=
literal|0
decl_stmt|;
specifier|const
name|struct
name|mips_cpu_info
modifier|*
name|tune_info
init|=
literal|0
decl_stmt|;
comment|/* GP relative stuff not working for PE */
if|if
condition|(
name|strncmp
argument_list|(
name|TARGET_OS
argument_list|,
literal|"pe"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
operator|&&
name|g_switch_value
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|g_switch_seen
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"-G not supported in this configuration."
argument_list|)
argument_list|)
expr_stmt|;
name|g_switch_value
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|mips_abi
operator|==
name|NO_ABI
condition|)
name|mips_abi
operator|=
name|MIPS_DEFAULT_ABI
expr_stmt|;
comment|/* The following code determines the architecture and register size.      Similar code was added to GCC 3.3 (see override_options() in      config/mips/mips.c).  The GAS and GCC code should be kept in sync      as much as possible.  */
if|if
condition|(
name|mips_arch_string
operator|!=
literal|0
condition|)
name|arch_info
operator|=
name|mips_parse_cpu
argument_list|(
literal|"-march"
argument_list|,
name|mips_arch_string
argument_list|)
expr_stmt|;
if|if
condition|(
name|file_mips_isa
operator|!=
name|ISA_UNKNOWN
condition|)
block|{
comment|/* Handle -mipsN.  At this point, file_mips_isa contains the 	 ISA level specified by -mipsN, while arch_info->isa contains 	 the -march selection (if any).  */
if|if
condition|(
name|arch_info
operator|!=
literal|0
condition|)
block|{
comment|/* -march takes precedence over -mipsN, since it is more descriptive. 	     There's no harm in specifying both as long as the ISA levels 	     are the same.  */
if|if
condition|(
name|file_mips_isa
operator|!=
name|arch_info
operator|->
name|isa
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"-%s conflicts with the other architecture options, which imply -%s"
argument_list|)
argument_list|,
name|mips_cpu_info_from_isa
argument_list|(
name|file_mips_isa
argument_list|)
operator|->
name|name
argument_list|,
name|mips_cpu_info_from_isa
argument_list|(
name|arch_info
operator|->
name|isa
argument_list|)
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
else|else
name|arch_info
operator|=
name|mips_cpu_info_from_isa
argument_list|(
name|file_mips_isa
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|arch_info
operator|==
literal|0
condition|)
name|arch_info
operator|=
name|mips_parse_cpu
argument_list|(
literal|"default CPU"
argument_list|,
name|MIPS_CPU_STRING_DEFAULT
argument_list|)
expr_stmt|;
if|if
condition|(
name|ABI_NEEDS_64BIT_REGS
argument_list|(
name|mips_abi
argument_list|)
operator|&&
operator|!
name|ISA_HAS_64BIT_REGS
argument_list|(
name|arch_info
operator|->
name|isa
argument_list|)
condition|)
name|as_bad
argument_list|(
literal|"-march=%s is not compatible with the selected ABI"
argument_list|,
name|arch_info
operator|->
name|name
argument_list|)
expr_stmt|;
name|mips_set_architecture
argument_list|(
name|arch_info
argument_list|)
expr_stmt|;
comment|/* Optimize for file_mips_arch, unless -mtune selects a different processor.  */
if|if
condition|(
name|mips_tune_string
operator|!=
literal|0
condition|)
name|tune_info
operator|=
name|mips_parse_cpu
argument_list|(
literal|"-mtune"
argument_list|,
name|mips_tune_string
argument_list|)
expr_stmt|;
if|if
condition|(
name|tune_info
operator|==
literal|0
condition|)
name|mips_set_tune
argument_list|(
name|arch_info
argument_list|)
expr_stmt|;
else|else
name|mips_set_tune
argument_list|(
name|tune_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|file_mips_gp32
operator|>=
literal|0
condition|)
block|{
comment|/* The user specified the size of the integer registers.  Make sure 	 it agrees with the ABI and ISA.  */
if|if
condition|(
name|file_mips_gp32
operator|==
literal|0
operator|&&
operator|!
name|ISA_HAS_64BIT_REGS
argument_list|(
name|mips_opts
operator|.
name|isa
argument_list|)
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"-mgp64 used with a 32-bit processor"
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|file_mips_gp32
operator|==
literal|1
operator|&&
name|ABI_NEEDS_64BIT_REGS
argument_list|(
name|mips_abi
argument_list|)
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"-mgp32 used with a 64-bit ABI"
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|file_mips_gp32
operator|==
literal|0
operator|&&
name|ABI_NEEDS_32BIT_REGS
argument_list|(
name|mips_abi
argument_list|)
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"-mgp64 used with a 32-bit ABI"
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Infer the integer register size from the ABI and processor. 	 Restrict ourselves to 32-bit registers if that's all the 	 processor has, or if the ABI cannot handle 64-bit registers.  */
name|file_mips_gp32
operator|=
operator|(
name|ABI_NEEDS_32BIT_REGS
argument_list|(
name|mips_abi
argument_list|)
operator|||
operator|!
name|ISA_HAS_64BIT_REGS
argument_list|(
name|mips_opts
operator|.
name|isa
argument_list|)
operator|)
expr_stmt|;
block|}
comment|/* ??? GAS treats single-float processors as though they had 64-bit      float registers (although it complains when double-precision      instructions are used).  As things stand, saying they have 32-bit      registers would lead to spurious "register must be even" messages.      So here we assume float registers are always the same size as      integer ones, unless the user says otherwise.  */
if|if
condition|(
name|file_mips_fp32
operator|<
literal|0
condition|)
name|file_mips_fp32
operator|=
name|file_mips_gp32
expr_stmt|;
comment|/* End of GCC-shared inference code.  */
comment|/* This flag is set when we have a 64-bit capable CPU but use only      32-bit wide registers.  Note that EABI does not use it.  */
if|if
condition|(
name|ISA_HAS_64BIT_REGS
argument_list|(
name|mips_opts
operator|.
name|isa
argument_list|)
operator|&&
operator|(
operator|(
name|mips_abi
operator|==
name|NO_ABI
operator|&&
name|file_mips_gp32
operator|==
literal|1
operator|)
operator|||
name|mips_abi
operator|==
name|O32_ABI
operator|)
condition|)
name|mips_32bitmode
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|mips_opts
operator|.
name|isa
operator|==
name|ISA_MIPS1
operator|&&
name|mips_trap
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"trap exception not supported at ISA 1"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If the selected architecture includes support for ASEs, enable      generation of code for them.  */
if|if
condition|(
name|mips_opts
operator|.
name|mips16
operator|==
operator|-
literal|1
condition|)
name|mips_opts
operator|.
name|mips16
operator|=
operator|(
name|CPU_HAS_MIPS16
argument_list|(
name|file_mips_arch
argument_list|)
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|mips_opts
operator|.
name|ase_mips3d
operator|==
operator|-
literal|1
condition|)
name|mips_opts
operator|.
name|ase_mips3d
operator|=
operator|(
name|CPU_HAS_MIPS3D
argument_list|(
name|file_mips_arch
argument_list|)
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|mips_opts
operator|.
name|ase_mdmx
operator|==
operator|-
literal|1
condition|)
name|mips_opts
operator|.
name|ase_mdmx
operator|=
operator|(
name|CPU_HAS_MDMX
argument_list|(
name|file_mips_arch
argument_list|)
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|file_mips_isa
operator|=
name|mips_opts
operator|.
name|isa
expr_stmt|;
name|file_ase_mips16
operator|=
name|mips_opts
operator|.
name|mips16
expr_stmt|;
name|file_ase_mips3d
operator|=
name|mips_opts
operator|.
name|ase_mips3d
expr_stmt|;
name|file_ase_mdmx
operator|=
name|mips_opts
operator|.
name|ase_mdmx
expr_stmt|;
name|mips_opts
operator|.
name|gp32
operator|=
name|file_mips_gp32
expr_stmt|;
name|mips_opts
operator|.
name|fp32
operator|=
name|file_mips_fp32
expr_stmt|;
if|if
condition|(
name|mips_flag_mdebug
operator|<
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|OBJ_MAYBE_ECOFF
if|if
condition|(
name|OUTPUT_FLAVOR
operator|==
name|bfd_target_ecoff_flavour
condition|)
name|mips_flag_mdebug
operator|=
literal|1
expr_stmt|;
else|else
endif|#
directive|endif
comment|/* OBJ_MAYBE_ECOFF */
name|mips_flag_mdebug
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_function
name|void
name|mips_init_after_args
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* initialize opcodes */
name|bfd_mips_num_opcodes
operator|=
name|bfd_mips_num_builtin_opcodes
expr_stmt|;
name|mips_opcodes
operator|=
operator|(
expr|struct
name|mips_opcode
operator|*
operator|)
name|mips_builtin_opcodes
expr_stmt|;
block|}
end_function

begin_function
name|long
name|md_pcrel_from
parameter_list|(
name|fixS
modifier|*
name|fixP
parameter_list|)
block|{
name|valueT
name|addr
init|=
name|fixP
operator|->
name|fx_where
operator|+
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_address
decl_stmt|;
switch|switch
condition|(
name|fixP
operator|->
name|fx_r_type
condition|)
block|{
case|case
name|BFD_RELOC_16_PCREL_S2
case|:
case|case
name|BFD_RELOC_MIPS_JMP
case|:
comment|/* Return the address of the delay slot.  */
return|return
name|addr
operator|+
literal|4
return|;
default|default:
return|return
name|addr
return|;
block|}
block|}
end_function

begin_comment
comment|/* This is called before the symbol table is processed.  In order to    work with gcc when using mips-tfile, we must keep all local labels.    However, in other cases, we want to discard them.  If we were    called with -g, but we didn't see any debugging information, it may    mean that gcc is smuggling debugging information through to    mips-tfile, in which case we must generate all local labels.  */
end_comment

begin_function
name|void
name|mips_frob_file_before_adjust
parameter_list|(
name|void
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|NO_ECOFF_DEBUGGING
if|if
condition|(
name|ECOFF_DEBUGGING
operator|&&
name|mips_debug
operator|!=
literal|0
operator|&&
operator|!
name|ecoff_debugging_seen
condition|)
name|flag_keep_locals
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Sort any unmatched HI16_S relocs so that they immediately precede    the corresponding LO reloc.  This is called before md_apply_fix3 and    tc_gen_reloc.  Unmatched HI16_S relocs can only be generated by    explicit use of the %hi modifier.  */
end_comment

begin_function
name|void
name|mips_frob_file
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|mips_hi_fixup
modifier|*
name|l
decl_stmt|;
for|for
control|(
name|l
operator|=
name|mips_hi_fixup_list
init|;
name|l
operator|!=
name|NULL
condition|;
name|l
operator|=
name|l
operator|->
name|next
control|)
block|{
name|segment_info_type
modifier|*
name|seginfo
decl_stmt|;
name|int
name|pass
decl_stmt|;
name|assert
argument_list|(
name|reloc_needs_lo_p
argument_list|(
name|l
operator|->
name|fixp
operator|->
name|fx_r_type
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If a GOT16 relocation turns out to be against a global symbol, 	 there isn't supposed to be a matching LO.  */
if|if
condition|(
name|l
operator|->
name|fixp
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_MIPS_GOT16
operator|&&
operator|!
name|pic_need_relax
argument_list|(
name|l
operator|->
name|fixp
operator|->
name|fx_addsy
argument_list|,
name|l
operator|->
name|seg
argument_list|)
condition|)
continue|continue;
comment|/* Check quickly whether the next fixup happens to be a matching %lo.  */
if|if
condition|(
name|fixup_has_matching_lo_p
argument_list|(
name|l
operator|->
name|fixp
argument_list|)
condition|)
continue|continue;
comment|/* Look through the fixups for this segment for a matching %lo.          When we find one, move the %hi just in front of it.  We do          this in two passes.  In the first pass, we try to find a          unique %lo.  In the second pass, we permit multiple %hi          relocs for a single %lo (this is a GNU extension).  */
name|seginfo
operator|=
name|seg_info
argument_list|(
name|l
operator|->
name|seg
argument_list|)
expr_stmt|;
for|for
control|(
name|pass
operator|=
literal|0
init|;
name|pass
operator|<
literal|2
condition|;
name|pass
operator|++
control|)
block|{
name|fixS
modifier|*
name|f
decl_stmt|,
modifier|*
name|prev
decl_stmt|;
name|prev
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|f
operator|=
name|seginfo
operator|->
name|fix_root
init|;
name|f
operator|!=
name|NULL
condition|;
name|f
operator|=
name|f
operator|->
name|fx_next
control|)
block|{
comment|/* Check whether this is a %lo fixup which matches l->fixp.  */
if|if
condition|(
name|f
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_LO16
operator|&&
name|f
operator|->
name|fx_addsy
operator|==
name|l
operator|->
name|fixp
operator|->
name|fx_addsy
operator|&&
name|f
operator|->
name|fx_offset
operator|==
name|l
operator|->
name|fixp
operator|->
name|fx_offset
operator|&&
operator|(
name|pass
operator|==
literal|1
operator|||
name|prev
operator|==
name|NULL
operator|||
operator|!
name|reloc_needs_lo_p
argument_list|(
name|prev
operator|->
name|fx_r_type
argument_list|)
operator|||
operator|!
name|fixup_has_matching_lo_p
argument_list|(
name|prev
argument_list|)
operator|)
condition|)
block|{
name|fixS
modifier|*
modifier|*
name|pf
decl_stmt|;
comment|/* Move l->fixp before f.  */
for|for
control|(
name|pf
operator|=
operator|&
name|seginfo
operator|->
name|fix_root
init|;
operator|*
name|pf
operator|!=
name|l
operator|->
name|fixp
condition|;
name|pf
operator|=
operator|&
operator|(
operator|*
name|pf
operator|)
operator|->
name|fx_next
control|)
name|assert
argument_list|(
operator|*
name|pf
operator|!=
name|NULL
argument_list|)
expr_stmt|;
operator|*
name|pf
operator|=
name|l
operator|->
name|fixp
operator|->
name|fx_next
expr_stmt|;
name|l
operator|->
name|fixp
operator|->
name|fx_next
operator|=
name|f
expr_stmt|;
if|if
condition|(
name|prev
operator|==
name|NULL
condition|)
name|seginfo
operator|->
name|fix_root
operator|=
name|l
operator|->
name|fixp
expr_stmt|;
else|else
name|prev
operator|->
name|fx_next
operator|=
name|l
operator|->
name|fixp
expr_stmt|;
break|break;
block|}
name|prev
operator|=
name|f
expr_stmt|;
block|}
if|if
condition|(
name|f
operator|!=
name|NULL
condition|)
break|break;
if|#
directive|if
literal|0
comment|/* GCC code motion plus incomplete dead code elimination 	 can leave a %hi without a %lo.  */
block|if (pass == 1) 	    as_warn_where (l->fixp->fx_file, l->fixp->fx_line, 			   _("Unmatched %%hi reloc"));
endif|#
directive|endif
block|}
block|}
block|}
end_function

begin_comment
comment|/* When generating embedded PIC code we need to use a special    relocation to represent the difference of two symbols in the .text    section (switch tables use a difference of this sort).  See    include/coff/mips.h for details.  This macro checks whether this    fixup requires the special reloc.  */
end_comment

begin_define
define|#
directive|define
name|SWITCH_TABLE
parameter_list|(
name|fixp
parameter_list|)
define|\
value|((fixp)->fx_r_type == BFD_RELOC_32 \&& OUTPUT_FLAVOR != bfd_target_elf_flavour \&& (fixp)->fx_addsy != NULL \&& (fixp)->fx_subsy != NULL \&& S_GET_SEGMENT ((fixp)->fx_addsy) == text_section \&& S_GET_SEGMENT ((fixp)->fx_subsy) == text_section)
end_define

begin_comment
comment|/* When generating embedded PIC code we must keep all PC relative    relocations, in case the linker has to relax a call.  We also need    to keep relocations for switch table entries.     We may have combined relocations without symbols in the N32/N64 ABI.    We have to prevent gas from dropping them.  */
end_comment

begin_function
name|int
name|mips_force_relocation
parameter_list|(
name|fixS
modifier|*
name|fixp
parameter_list|)
block|{
if|if
condition|(
name|generic_force_reloc
argument_list|(
name|fixp
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|HAVE_NEWABI
operator|&&
name|S_GET_SEGMENT
argument_list|(
name|fixp
operator|->
name|fx_addsy
argument_list|)
operator|==
name|bfd_abs_section_ptr
operator|&&
operator|(
name|fixp
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_MIPS_SUB
operator|||
name|fixp
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_HI16_S
operator|||
name|fixp
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_LO16
operator|)
condition|)
return|return
literal|1
return|;
return|return
operator|(
name|mips_pic
operator|==
name|EMBEDDED_PIC
operator|&&
operator|(
name|fixp
operator|->
name|fx_pcrel
operator|||
name|SWITCH_TABLE
argument_list|(
name|fixp
argument_list|)
operator|||
name|fixp
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_PCREL_HI16_S
operator|||
name|fixp
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_PCREL_LO16
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* This hook is called before a fix is simplified.  We don't really    decide whether to skip a fix here.  Rather, we turn global symbols    used as branch targets into local symbols, such that they undergo    simplification.  We can only do this if the symbol is defined and    it is in the same section as the branch.  If this doesn't hold, we    emit a better error message than just saying the relocation is not    valid for the selected object format.     FIXP is the fix-up we're going to try to simplify, SEG is the    segment in which the fix up occurs.  The return value should be    non-zero to indicate the fix-up is valid for further    simplifications.  */
end_comment

begin_function
name|int
name|mips_validate_fix
parameter_list|(
name|struct
name|fix
modifier|*
name|fixP
parameter_list|,
name|asection
modifier|*
name|seg
parameter_list|)
block|{
comment|/* There's a lot of discussion on whether it should be possible to      use R_MIPS_PC16 to represent branch relocations.  The outcome      seems to be that it can, but gas/bfd are very broken in creating      RELA relocations for this, so for now we only accept branches to      symbols in the same section.  Anything else is of dubious value,      since there's no guarantee that at link time the symbol would be      in range.  Even for branches to local symbols this is arguably      wrong, since it we assume the symbol is not going to be      overridden, which should be possible per ELF library semantics,      but then, there isn't a dynamic relocation that could be used to      this effect, and the target would likely be out of range as well.       Unfortunately, it seems that there is too much code out there      that relies on branches to symbols that are global to be resolved      as if they were local, like the IRIX tools do, so we do it as      well, but with a warning so that people are reminded to fix their      code.  If we ever get back to using R_MIPS_PC16 for branch      targets, this entire block should go away (and probably the      whole function).  */
if|if
condition|(
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_16_PCREL_S2
operator|&&
operator|(
operator|(
operator|(
name|OUTPUT_FLAVOR
operator|==
name|bfd_target_ecoff_flavour
operator|||
name|OUTPUT_FLAVOR
operator|==
name|bfd_target_elf_flavour
operator|)
operator|&&
name|mips_pic
operator|!=
name|EMBEDDED_PIC
operator|)
operator|||
name|bfd_reloc_type_lookup
argument_list|(
name|stdoutput
argument_list|,
name|BFD_RELOC_16_PCREL_S2
argument_list|)
operator|==
name|NULL
operator|)
operator|&&
name|fixP
operator|->
name|fx_addsy
condition|)
block|{
if|if
condition|(
operator|!
name|S_IS_DEFINED
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
condition|)
block|{
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"Cannot branch to undefined symbol."
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Avoid any further errors about this fixup.  */
name|fixP
operator|->
name|fx_done
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|S_GET_SEGMENT
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
operator|!=
name|seg
condition|)
block|{
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"Cannot branch to symbol in another section."
argument_list|)
argument_list|)
expr_stmt|;
name|fixP
operator|->
name|fx_done
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|S_IS_EXTERNAL
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
condition|)
block|{
name|symbolS
modifier|*
name|sym
init|=
name|fixP
operator|->
name|fx_addsy
decl_stmt|;
if|if
condition|(
name|mips_pic
operator|==
name|SVR4_PIC
condition|)
name|as_warn_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"Pretending global symbol used as branch target is local."
argument_list|)
argument_list|)
expr_stmt|;
name|fixP
operator|->
name|fx_addsy
operator|=
name|symbol_create
argument_list|(
name|S_GET_NAME
argument_list|(
name|sym
argument_list|)
argument_list|,
name|S_GET_SEGMENT
argument_list|(
name|sym
argument_list|)
argument_list|,
name|S_GET_VALUE
argument_list|(
name|sym
argument_list|)
argument_list|,
name|symbol_get_frag
argument_list|(
name|sym
argument_list|)
argument_list|)
expr_stmt|;
name|copy_symbol_attributes
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|,
name|sym
argument_list|)
expr_stmt|;
name|S_CLEAR_EXTERNAL
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|symbol_resolved_p
argument_list|(
name|sym
argument_list|)
argument_list|)
expr_stmt|;
name|symbol_mark_resolved
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Apply a fixup to the object file.  */
end_comment

begin_function
name|void
name|md_apply_fix3
parameter_list|(
name|fixS
modifier|*
name|fixP
parameter_list|,
name|valueT
modifier|*
name|valP
parameter_list|,
name|segT
name|seg
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|bfd_byte
modifier|*
name|buf
decl_stmt|;
name|long
name|insn
decl_stmt|;
specifier|static
name|int
name|previous_fx_r_type
init|=
literal|0
decl_stmt|;
name|reloc_howto_type
modifier|*
name|howto
decl_stmt|;
comment|/* We ignore generic BFD relocations we don't know about.  */
name|howto
operator|=
name|bfd_reloc_type_lookup
argument_list|(
name|stdoutput
argument_list|,
name|fixP
operator|->
name|fx_r_type
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|howto
condition|)
return|return;
name|assert
argument_list|(
name|fixP
operator|->
name|fx_size
operator|==
literal|4
operator|||
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_16
operator|||
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_64
operator|||
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_CTOR
operator|||
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_MIPS_SUB
operator|||
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_VTABLE_INHERIT
operator|||
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_VTABLE_ENTRY
argument_list|)
expr_stmt|;
name|buf
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
operator|(
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_literal
operator|+
name|fixP
operator|->
name|fx_where
operator|)
expr_stmt|;
comment|/* We are not done if this is a composite relocation to set up gp.  */
if|if
condition|(
name|fixP
operator|->
name|fx_addsy
operator|==
name|NULL
operator|&&
operator|!
name|fixP
operator|->
name|fx_pcrel
operator|&&
operator|!
operator|(
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_MIPS_SUB
operator|||
operator|(
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_64
operator|&&
operator|(
name|previous_fx_r_type
operator|==
name|BFD_RELOC_GPREL32
operator|||
name|previous_fx_r_type
operator|==
name|BFD_RELOC_GPREL16
operator|)
operator|)
operator|||
operator|(
name|previous_fx_r_type
operator|==
name|BFD_RELOC_MIPS_SUB
operator|&&
operator|(
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_HI16_S
operator|||
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_LO16
operator|)
operator|)
operator|)
condition|)
name|fixP
operator|->
name|fx_done
operator|=
literal|1
expr_stmt|;
name|previous_fx_r_type
operator|=
name|fixP
operator|->
name|fx_r_type
expr_stmt|;
switch|switch
condition|(
name|fixP
operator|->
name|fx_r_type
condition|)
block|{
case|case
name|BFD_RELOC_MIPS_JMP
case|:
case|case
name|BFD_RELOC_MIPS_SHIFT5
case|:
case|case
name|BFD_RELOC_MIPS_SHIFT6
case|:
case|case
name|BFD_RELOC_MIPS_GOT_DISP
case|:
case|case
name|BFD_RELOC_MIPS_GOT_PAGE
case|:
case|case
name|BFD_RELOC_MIPS_GOT_OFST
case|:
case|case
name|BFD_RELOC_MIPS_SUB
case|:
case|case
name|BFD_RELOC_MIPS_INSERT_A
case|:
case|case
name|BFD_RELOC_MIPS_INSERT_B
case|:
case|case
name|BFD_RELOC_MIPS_DELETE
case|:
case|case
name|BFD_RELOC_MIPS_HIGHEST
case|:
case|case
name|BFD_RELOC_MIPS_HIGHER
case|:
case|case
name|BFD_RELOC_MIPS_SCN_DISP
case|:
case|case
name|BFD_RELOC_MIPS_REL16
case|:
case|case
name|BFD_RELOC_MIPS_RELGOT
case|:
case|case
name|BFD_RELOC_MIPS_JALR
case|:
case|case
name|BFD_RELOC_HI16
case|:
case|case
name|BFD_RELOC_HI16_S
case|:
case|case
name|BFD_RELOC_GPREL16
case|:
case|case
name|BFD_RELOC_MIPS_LITERAL
case|:
case|case
name|BFD_RELOC_MIPS_CALL16
case|:
case|case
name|BFD_RELOC_MIPS_GOT16
case|:
case|case
name|BFD_RELOC_GPREL32
case|:
case|case
name|BFD_RELOC_MIPS_GOT_HI16
case|:
case|case
name|BFD_RELOC_MIPS_GOT_LO16
case|:
case|case
name|BFD_RELOC_MIPS_CALL_HI16
case|:
case|case
name|BFD_RELOC_MIPS_CALL_LO16
case|:
case|case
name|BFD_RELOC_MIPS16_GPREL
case|:
if|if
condition|(
name|fixP
operator|->
name|fx_pcrel
condition|)
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"Invalid PC relative reloc"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Nothing needed to do. The value comes from the reloc entry */
break|break;
case|case
name|BFD_RELOC_MIPS16_JMP
case|:
comment|/* We currently always generate a reloc against a symbol, which          means that we don't want an addend even if the symbol is          defined.  */
operator|*
name|valP
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PCREL_HI16_S
case|:
comment|/* The addend for this is tricky if it is internal, so we just 	 do everything here rather than in bfd_install_relocation.  */
if|if
condition|(
name|OUTPUT_FLAVOR
operator|==
name|bfd_target_elf_flavour
operator|&&
operator|!
name|fixP
operator|->
name|fx_done
condition|)
break|break;
if|if
condition|(
name|fixP
operator|->
name|fx_addsy
operator|&&
operator|(
name|symbol_get_bfdsym
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
operator|->
name|flags
operator|&
name|BSF_SECTION_SYM
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* For an external symbol adjust by the address to make it 	     pcrel_offset.  We use the address of the RELLO reloc 	     which follows this one.  */
operator|*
name|valP
operator|+=
operator|(
name|fixP
operator|->
name|fx_next
operator|->
name|fx_frag
operator|->
name|fr_address
operator|+
name|fixP
operator|->
name|fx_next
operator|->
name|fx_where
operator|)
expr_stmt|;
block|}
operator|*
name|valP
operator|=
operator|(
operator|(
operator|*
name|valP
operator|+
literal|0x8000
operator|)
operator|>>
literal|16
operator|)
operator|&
literal|0xffff
expr_stmt|;
if|if
condition|(
name|target_big_endian
condition|)
name|buf
operator|+=
literal|2
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|buf
argument_list|,
operator|*
name|valP
argument_list|,
literal|2
argument_list|)
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PCREL_LO16
case|:
comment|/* The addend for this is tricky if it is internal, so we just 	 do everything here rather than in bfd_install_relocation.  */
if|if
condition|(
name|OUTPUT_FLAVOR
operator|==
name|bfd_target_elf_flavour
operator|&&
operator|!
name|fixP
operator|->
name|fx_done
condition|)
break|break;
if|if
condition|(
name|fixP
operator|->
name|fx_addsy
operator|&&
operator|(
name|symbol_get_bfdsym
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
operator|->
name|flags
operator|&
name|BSF_SECTION_SYM
operator|)
operator|==
literal|0
condition|)
operator|*
name|valP
operator|+=
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_address
operator|+
name|fixP
operator|->
name|fx_where
expr_stmt|;
if|if
condition|(
name|target_big_endian
condition|)
name|buf
operator|+=
literal|2
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|buf
argument_list|,
operator|*
name|valP
argument_list|,
literal|2
argument_list|)
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_64
case|:
comment|/* This is handled like BFD_RELOC_32, but we output a sign          extended value if we are only 32 bits.  */
if|if
condition|(
name|fixP
operator|->
name|fx_done
operator|||
operator|(
name|mips_pic
operator|==
name|EMBEDDED_PIC
operator|&&
name|SWITCH_TABLE
argument_list|(
name|fixP
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
literal|8
operator|<=
sizeof|sizeof
argument_list|(
name|valueT
argument_list|)
condition|)
name|md_number_to_chars
argument_list|(
name|buf
argument_list|,
operator|*
name|valP
argument_list|,
literal|8
argument_list|)
expr_stmt|;
else|else
block|{
name|valueT
name|hiv
decl_stmt|;
if|if
condition|(
operator|(
operator|*
name|valP
operator|&
literal|0x80000000
operator|)
operator|!=
literal|0
condition|)
name|hiv
operator|=
literal|0xffffffff
expr_stmt|;
else|else
name|hiv
operator|=
literal|0
expr_stmt|;
name|md_number_to_chars
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|buf
operator|+
name|target_big_endian
condition|?
literal|4
else|:
literal|0
operator|)
argument_list|,
operator|*
name|valP
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|buf
operator|+
name|target_big_endian
condition|?
literal|0
else|:
literal|4
operator|)
argument_list|,
name|hiv
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|BFD_RELOC_RVA
case|:
case|case
name|BFD_RELOC_32
case|:
comment|/* If we are deleting this reloc entry, we must fill in the 	 value now.  This can happen if we have a .word which is not 	 resolved when it appears but is later defined.  We also need 	 to fill in the value if this is an embedded PIC switch table 	 entry.  */
if|if
condition|(
name|fixP
operator|->
name|fx_done
operator|||
operator|(
name|mips_pic
operator|==
name|EMBEDDED_PIC
operator|&&
name|SWITCH_TABLE
argument_list|(
name|fixP
argument_list|)
operator|)
condition|)
name|md_number_to_chars
argument_list|(
name|buf
argument_list|,
operator|*
name|valP
argument_list|,
literal|4
argument_list|)
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_16
case|:
comment|/* If we are deleting this reloc entry, we must fill in the          value now.  */
name|assert
argument_list|(
name|fixP
operator|->
name|fx_size
operator|==
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|fixP
operator|->
name|fx_done
condition|)
name|md_number_to_chars
argument_list|(
name|buf
argument_list|,
operator|*
name|valP
argument_list|,
literal|2
argument_list|)
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_LO16
case|:
comment|/* When handling an embedded PIC switch statement, we can wind 	 up deleting a LO16 reloc.  See the 'o' case in mips_ip.  */
if|if
condition|(
name|fixP
operator|->
name|fx_done
condition|)
block|{
if|if
condition|(
operator|*
name|valP
operator|+
literal|0x8000
operator|>
literal|0xffff
condition|)
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"relocation overflow"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|target_big_endian
condition|)
name|buf
operator|+=
literal|2
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|buf
argument_list|,
operator|*
name|valP
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|BFD_RELOC_16_PCREL_S2
case|:
if|if
condition|(
operator|(
operator|*
name|valP
operator|&
literal|0x3
operator|)
operator|!=
literal|0
condition|)
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"Branch to odd address (%lx)"
argument_list|)
argument_list|,
operator|(
name|long
operator|)
operator|*
name|valP
argument_list|)
expr_stmt|;
comment|/*        * We need to save the bits in the instruction since fixup_segment()        * might be deleting the relocation entry (i.e., a branch within        * the current segment).        */
if|if
condition|(
operator|!
name|fixP
operator|->
name|fx_done
condition|)
break|break;
comment|/* update old instruction data */
if|if
condition|(
name|target_big_endian
condition|)
name|insn
operator|=
operator|(
name|buf
index|[
literal|0
index|]
operator|<<
literal|24
operator|)
operator||
operator|(
name|buf
index|[
literal|1
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|buf
index|[
literal|2
index|]
operator|<<
literal|8
operator|)
operator||
name|buf
index|[
literal|3
index|]
expr_stmt|;
else|else
name|insn
operator|=
operator|(
name|buf
index|[
literal|3
index|]
operator|<<
literal|24
operator|)
operator||
operator|(
name|buf
index|[
literal|2
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|buf
index|[
literal|1
index|]
operator|<<
literal|8
operator|)
operator||
name|buf
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
operator|*
name|valP
operator|+
literal|0x20000
operator|<=
literal|0x3ffff
condition|)
block|{
name|insn
operator||=
operator|(
operator|*
name|valP
operator|>>
literal|2
operator|)
operator|&
literal|0xffff
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|buf
argument_list|,
name|insn
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mips_pic
operator|==
name|NO_PIC
operator|&&
name|fixP
operator|->
name|fx_done
operator|&&
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_address
operator|>=
name|text_section
operator|->
name|vma
operator|&&
operator|(
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_address
operator|<
name|text_section
operator|->
name|vma
operator|+
name|text_section
operator|->
name|_raw_size
operator|)
operator|&&
operator|(
operator|(
name|insn
operator|&
literal|0xffff0000
operator|)
operator|==
literal|0x10000000
comment|/* beq $0,$0 */
operator|||
operator|(
name|insn
operator|&
literal|0xffff0000
operator|)
operator|==
literal|0x04010000
comment|/* bgez $0 */
operator|||
operator|(
name|insn
operator|&
literal|0xffff0000
operator|)
operator|==
literal|0x04110000
operator|)
condition|)
comment|/* bgezal $0 */
block|{
comment|/* The branch offset is too large.  If this is an              unconditional branch, and we are not generating PIC code,              we can convert it to an absolute jump instruction.  */
if|if
condition|(
operator|(
name|insn
operator|&
literal|0xffff0000
operator|)
operator|==
literal|0x04110000
condition|)
comment|/* bgezal $0 */
name|insn
operator|=
literal|0x0c000000
expr_stmt|;
comment|/* jal */
else|else
name|insn
operator|=
literal|0x08000000
expr_stmt|;
comment|/* j */
name|fixP
operator|->
name|fx_r_type
operator|=
name|BFD_RELOC_MIPS_JMP
expr_stmt|;
name|fixP
operator|->
name|fx_done
operator|=
literal|0
expr_stmt|;
name|fixP
operator|->
name|fx_addsy
operator|=
name|section_symbol
argument_list|(
name|text_section
argument_list|)
expr_stmt|;
operator|*
name|valP
operator|+=
name|md_pcrel_from
argument_list|(
name|fixP
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|buf
argument_list|,
name|insn
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* If we got here, we have branch-relaxation disabled, 	     and there's nothing we can do to fix this instruction 	     without turning it into a longer sequence.  */
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"Branch out of range"
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|BFD_RELOC_VTABLE_INHERIT
case|:
name|fixP
operator|->
name|fx_done
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|fixP
operator|->
name|fx_addsy
operator|&&
operator|!
name|S_IS_DEFINED
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
operator|&&
operator|!
name|S_IS_WEAK
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
condition|)
name|S_SET_WEAK
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_VTABLE_ENTRY
case|:
name|fixP
operator|->
name|fx_done
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|internalError
argument_list|()
expr_stmt|;
block|}
comment|/* Remember value for tc_gen_reloc.  */
name|fixP
operator|->
name|fx_addnumber
operator|=
operator|*
name|valP
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|void printInsn (unsigned long oc) {   const struct mips_opcode *p;   int treg, sreg, dreg, shamt;   short imm;   const char *args;   int i;    for (i = 0; i< NUMOPCODES; ++i)     {       p =&mips_opcodes[i];       if (((oc& p->mask) == p->match)&& (p->pinfo != INSN_MACRO)) 	{ 	  printf ("%08lx %s\t", oc, p->name); 	  treg = (oc>> 16)& 0x1f; 	  sreg = (oc>> 21)& 0x1f; 	  dreg = (oc>> 11)& 0x1f; 	  shamt = (oc>> 6)& 0x1f; 	  imm = oc; 	  for (args = p->args;; ++args) 	    { 	      switch (*args) 		{ 		case '\0': 		  printf ("\n"); 		  break;  		case ',': 		case '(': 		case ')': 		  printf ("%c", *args); 		  continue;  		case 'r': 		  assert (treg == sreg); 		  printf ("$%d,$%d", treg, sreg); 		  continue;  		case 'd': 		case 'G': 		  printf ("$%d", dreg); 		  continue;  		case 't': 		case 'E': 		  printf ("$%d", treg); 		  continue;  		case 'k': 		  printf ("0x%x", treg); 		  continue;  		case 'b': 		case 's': 		  printf ("$%d", sreg); 		  continue;  		case 'a': 		  printf ("0x%08lx", oc& 0x1ffffff); 		  continue;  		case 'i': 		case 'j': 		case 'o': 		case 'u': 		  printf ("%d", imm); 		  continue;  		case '<': 		case '>': 		  printf ("$%d", shamt); 		  continue;  		default: 		  internalError (); 		} 	      break; 	    } 	  return; 	}     }   printf (_("%08lx  UNDEFINED\n"), oc); }
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|symbolS
modifier|*
name|get_symbol
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|symbolS
modifier|*
name|p
decl_stmt|;
name|name
operator|=
name|input_line_pointer
expr_stmt|;
name|c
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
name|p
operator|=
operator|(
name|symbolS
operator|*
operator|)
name|symbol_find_or_make
argument_list|(
name|name
argument_list|)
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_comment
comment|/* Align the current frag to a given power of two.  The MIPS assembler    also automatically adjusts any preceding label.  */
end_comment

begin_function
specifier|static
name|void
name|mips_align
parameter_list|(
name|int
name|to
parameter_list|,
name|int
name|fill
parameter_list|,
name|symbolS
modifier|*
name|label
parameter_list|)
block|{
name|mips_emit_delays
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
name|frag_align
argument_list|(
name|to
argument_list|,
name|fill
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|record_alignment
argument_list|(
name|now_seg
argument_list|,
name|to
argument_list|)
expr_stmt|;
if|if
condition|(
name|label
operator|!=
name|NULL
condition|)
block|{
name|assert
argument_list|(
name|S_GET_SEGMENT
argument_list|(
name|label
argument_list|)
operator|==
name|now_seg
argument_list|)
expr_stmt|;
name|symbol_set_frag
argument_list|(
name|label
argument_list|,
name|frag_now
argument_list|)
expr_stmt|;
name|S_SET_VALUE
argument_list|(
name|label
argument_list|,
operator|(
name|valueT
operator|)
name|frag_now_fix
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Align to a given power of two.  .align 0 turns off the automatic    alignment used by the data creating pseudo-ops.  */
end_comment

begin_function
specifier|static
name|void
name|s_align
parameter_list|(
name|int
name|x
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
specifier|register
name|int
name|temp
decl_stmt|;
specifier|register
name|long
name|temp_fill
decl_stmt|;
name|long
name|max_alignment
init|=
literal|15
decl_stmt|;
comment|/*      o  Note that the assembler pulls down any immediately preceding label        to the aligned address.     o  It's not documented but auto alignment is reinstated by        a .align pseudo instruction.     o  Note also that after auto alignment is turned off the mips assembler        issues an error on attempt to assemble an improperly aligned data item.        We don't.      */
name|temp
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
if|if
condition|(
name|temp
operator|>
name|max_alignment
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Alignment too large: %d. assumed."
argument_list|)
argument_list|,
name|temp
operator|=
name|max_alignment
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|temp
operator|<
literal|0
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"Alignment negative: 0 assumed."
argument_list|)
argument_list|)
expr_stmt|;
name|temp
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|','
condition|)
block|{
operator|++
name|input_line_pointer
expr_stmt|;
name|temp_fill
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
block|}
else|else
name|temp_fill
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|temp
condition|)
block|{
name|auto_align
operator|=
literal|1
expr_stmt|;
name|mips_align
argument_list|(
name|temp
argument_list|,
operator|(
name|int
operator|)
name|temp_fill
argument_list|,
name|insn_labels
operator|!=
name|NULL
condition|?
name|insn_labels
operator|->
name|label
else|:
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|auto_align
operator|=
literal|0
expr_stmt|;
block|}
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|mips_flush_pending_output
parameter_list|(
name|void
parameter_list|)
block|{
name|mips_emit_delays
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
name|mips_clear_insn_labels
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|s_change_sec
parameter_list|(
name|int
name|sec
parameter_list|)
block|{
name|segT
name|seg
decl_stmt|;
comment|/* When generating embedded PIC code, we only use the .text, .lit8,      .sdata and .sbss sections.  We change the .data and .rdata      pseudo-ops to use .sdata.  */
if|if
condition|(
name|mips_pic
operator|==
name|EMBEDDED_PIC
operator|&&
operator|(
name|sec
operator|==
literal|'d'
operator|||
name|sec
operator|==
literal|'r'
operator|)
condition|)
name|sec
operator|=
literal|'s'
expr_stmt|;
ifdef|#
directive|ifdef
name|OBJ_ELF
comment|/* The ELF backend needs to know that we are changing sections, so      that .previous works correctly.  We could do something like check      for an obj_section_change_hook macro, but that might be confusing      as it would not be appropriate to use it in the section changing      functions in read.c, since obj-elf.c intercepts those.  FIXME:      This should be cleaner, somehow.  */
name|obj_elf_section_change_hook
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|mips_emit_delays
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|sec
condition|)
block|{
case|case
literal|'t'
case|:
name|s_text
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|s_data
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
name|subseg_set
argument_list|(
name|bss_section
argument_list|,
operator|(
name|subsegT
operator|)
name|get_absolute_expression
argument_list|()
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
if|if
condition|(
name|USE_GLOBAL_POINTER_OPT
condition|)
block|{
name|seg
operator|=
name|subseg_new
argument_list|(
name|RDATA_SECTION_NAME
argument_list|,
operator|(
name|subsegT
operator|)
name|get_absolute_expression
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|OUTPUT_FLAVOR
operator|==
name|bfd_target_elf_flavour
condition|)
block|{
name|bfd_set_section_flags
argument_list|(
name|stdoutput
argument_list|,
name|seg
argument_list|,
operator|(
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_READONLY
operator||
name|SEC_RELOC
operator||
name|SEC_DATA
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|TARGET_OS
argument_list|,
literal|"elf"
argument_list|)
operator|!=
literal|0
condition|)
name|record_alignment
argument_list|(
name|seg
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"No read only data section in this object file format"
argument_list|)
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
break|break;
case|case
literal|'s'
case|:
if|if
condition|(
name|USE_GLOBAL_POINTER_OPT
condition|)
block|{
name|seg
operator|=
name|subseg_new
argument_list|(
literal|".sdata"
argument_list|,
operator|(
name|subsegT
operator|)
name|get_absolute_expression
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|OUTPUT_FLAVOR
operator|==
name|bfd_target_elf_flavour
condition|)
block|{
name|bfd_set_section_flags
argument_list|(
name|stdoutput
argument_list|,
name|seg
argument_list|,
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_RELOC
operator||
name|SEC_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|TARGET_OS
argument_list|,
literal|"elf"
argument_list|)
operator|!=
literal|0
condition|)
name|record_alignment
argument_list|(
name|seg
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
break|break;
block|}
else|else
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Global pointers not supported; recompile -G 0"
argument_list|)
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
block|}
name|auto_align
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
name|void
name|s_change_section
parameter_list|(
name|int
name|ignore
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|OBJ_ELF
name|char
modifier|*
name|section_name
decl_stmt|;
name|char
name|c
decl_stmt|;
name|char
name|next_c
init|=
literal|0
decl_stmt|;
name|int
name|section_type
decl_stmt|;
name|int
name|section_flag
decl_stmt|;
name|int
name|section_entry_size
decl_stmt|;
name|int
name|section_alignment
decl_stmt|;
if|if
condition|(
name|OUTPUT_FLAVOR
operator|!=
name|bfd_target_elf_flavour
condition|)
return|return;
name|section_name
operator|=
name|input_line_pointer
expr_stmt|;
name|c
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
condition|)
name|next_c
operator|=
operator|*
operator|(
name|input_line_pointer
operator|+
literal|1
operator|)
expr_stmt|;
comment|/* Do we have .section Name<,"flags">?  */
if|if
condition|(
name|c
operator|!=
literal|','
operator|||
operator|(
name|c
operator|==
literal|','
operator|&&
name|next_c
operator|==
literal|'"'
operator|)
condition|)
block|{
comment|/* just after name is now '\0'.  */
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
name|input_line_pointer
operator|=
name|section_name
expr_stmt|;
name|obj_elf_section
argument_list|(
name|ignore
argument_list|)
expr_stmt|;
return|return;
block|}
name|input_line_pointer
operator|++
expr_stmt|;
comment|/* Do we have .section Name<,type><,flag><,entry_size><,alignment>  */
if|if
condition|(
name|c
operator|==
literal|','
condition|)
name|section_type
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
else|else
name|section_type
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|++
operator|==
literal|','
condition|)
name|section_flag
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
else|else
name|section_flag
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|++
operator|==
literal|','
condition|)
name|section_entry_size
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
else|else
name|section_entry_size
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|++
operator|==
literal|','
condition|)
name|section_alignment
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
else|else
name|section_alignment
operator|=
literal|0
expr_stmt|;
name|section_name
operator|=
name|xstrdup
argument_list|(
name|section_name
argument_list|)
expr_stmt|;
comment|/* When using the generic form of .section (as implemented by obj-elf.c),      there's no way to set the section type to SHT_MIPS_DWARF.  Users have      traditionally had to fall back on the more common @progbits instead.       There's nothing really harmful in this, since bfd will correct      SHT_PROGBITS to SHT_MIPS_DWARF before writing out the file.  But it      means that, for backwards compatibiltiy, the special_section entries      for dwarf sections must use SHT_PROGBITS rather than SHT_MIPS_DWARF.       Even so, we shouldn't force users of the MIPS .section syntax to      incorrectly label the sections as SHT_PROGBITS.  The best compromise      seems to be to map SHT_MIPS_DWARF to SHT_PROGBITS before calling the      generic type-checking code.  */
if|if
condition|(
name|section_type
operator|==
name|SHT_MIPS_DWARF
condition|)
name|section_type
operator|=
name|SHT_PROGBITS
expr_stmt|;
name|obj_elf_change_section
argument_list|(
name|section_name
argument_list|,
name|section_type
argument_list|,
name|section_flag
argument_list|,
name|section_entry_size
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|now_seg
operator|->
name|name
operator|!=
name|section_name
condition|)
name|free
argument_list|(
name|section_name
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* OBJ_ELF */
block|}
end_function

begin_function
name|void
name|mips_enable_auto_align
parameter_list|(
name|void
parameter_list|)
block|{
name|auto_align
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|s_cons
parameter_list|(
name|int
name|log_size
parameter_list|)
block|{
name|symbolS
modifier|*
name|label
decl_stmt|;
name|label
operator|=
name|insn_labels
operator|!=
name|NULL
condition|?
name|insn_labels
operator|->
name|label
else|:
name|NULL
expr_stmt|;
name|mips_emit_delays
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|log_size
operator|>
literal|0
operator|&&
name|auto_align
condition|)
name|mips_align
argument_list|(
name|log_size
argument_list|,
literal|0
argument_list|,
name|label
argument_list|)
expr_stmt|;
name|mips_clear_insn_labels
argument_list|()
expr_stmt|;
name|cons
argument_list|(
literal|1
operator|<<
name|log_size
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|s_float_cons
parameter_list|(
name|int
name|type
parameter_list|)
block|{
name|symbolS
modifier|*
name|label
decl_stmt|;
name|label
operator|=
name|insn_labels
operator|!=
name|NULL
condition|?
name|insn_labels
operator|->
name|label
else|:
name|NULL
expr_stmt|;
name|mips_emit_delays
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|auto_align
condition|)
block|{
if|if
condition|(
name|type
operator|==
literal|'d'
condition|)
name|mips_align
argument_list|(
literal|3
argument_list|,
literal|0
argument_list|,
name|label
argument_list|)
expr_stmt|;
else|else
name|mips_align
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|,
name|label
argument_list|)
expr_stmt|;
block|}
name|mips_clear_insn_labels
argument_list|()
expr_stmt|;
name|float_cons
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle .globl.  We need to override it because on Irix 5 you are    permitted to say        .globl foo .text    where foo is an undefined symbol, to mean that foo should be    considered to be the address of a function.  */
end_comment

begin_function
specifier|static
name|void
name|s_mips_globl
parameter_list|(
name|int
name|x
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|c
decl_stmt|;
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
name|flagword
name|flag
decl_stmt|;
name|name
operator|=
name|input_line_pointer
expr_stmt|;
name|c
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
name|symbolP
operator|=
name|symbol_find_or_make
argument_list|(
name|name
argument_list|)
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
comment|/* On Irix 5, every global symbol that is not explicitly labelled as      being a function is apparently labelled as being an object.  */
name|flag
operator|=
name|BSF_OBJECT
expr_stmt|;
if|if
condition|(
operator|!
name|is_end_of_line
index|[
operator|(
name|unsigned
name|char
operator|)
operator|*
name|input_line_pointer
index|]
condition|)
block|{
name|char
modifier|*
name|secname
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|secname
operator|=
name|input_line_pointer
expr_stmt|;
name|c
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
name|sec
operator|=
name|bfd_get_section_by_name
argument_list|(
name|stdoutput
argument_list|,
name|secname
argument_list|)
expr_stmt|;
if|if
condition|(
name|sec
operator|==
name|NULL
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"%s: no such section"
argument_list|)
argument_list|,
name|secname
argument_list|)
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|sec
operator|!=
name|NULL
operator|&&
operator|(
name|sec
operator|->
name|flags
operator|&
name|SEC_CODE
operator|)
operator|!=
literal|0
condition|)
name|flag
operator|=
name|BSF_FUNCTION
expr_stmt|;
block|}
name|symbol_get_bfdsym
argument_list|(
name|symbolP
argument_list|)
operator|->
name|flags
operator||=
name|flag
expr_stmt|;
name|S_SET_EXTERNAL
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|s_option
parameter_list|(
name|int
name|x
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|char
modifier|*
name|opt
decl_stmt|;
name|char
name|c
decl_stmt|;
name|opt
operator|=
name|input_line_pointer
expr_stmt|;
name|c
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|opt
operator|==
literal|'O'
condition|)
block|{
comment|/* FIXME: What does this mean?  */
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|opt
argument_list|,
literal|"pic"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
block|{
name|int
name|i
decl_stmt|;
name|i
operator|=
name|atoi
argument_list|(
name|opt
operator|+
literal|3
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
name|mips_pic
operator|=
name|NO_PIC
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|==
literal|2
condition|)
block|{
name|mips_pic
operator|=
name|SVR4_PIC
expr_stmt|;
name|mips_abicalls
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
name|as_bad
argument_list|(
name|_
argument_list|(
literal|".option pic%d not supported"
argument_list|)
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|USE_GLOBAL_POINTER_OPT
operator|&&
name|mips_pic
operator|==
name|SVR4_PIC
condition|)
block|{
if|if
condition|(
name|g_switch_seen
operator|&&
name|g_switch_value
operator|!=
literal|0
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"-G may not be used with SVR4 PIC code"
argument_list|)
argument_list|)
expr_stmt|;
name|g_switch_value
operator|=
literal|0
expr_stmt|;
name|bfd_set_gp_size
argument_list|(
name|stdoutput
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"Unrecognized option \"%s\""
argument_list|)
argument_list|,
name|opt
argument_list|)
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This structure is used to hold a stack of .set values.  */
end_comment

begin_struct
struct|struct
name|mips_option_stack
block|{
name|struct
name|mips_option_stack
modifier|*
name|next
decl_stmt|;
name|struct
name|mips_set_options
name|options
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|mips_option_stack
modifier|*
name|mips_opts_stack
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Handle the .set pseudo-op.  */
end_comment

begin_function
specifier|static
name|void
name|s_mipsset
parameter_list|(
name|int
name|x
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|char
modifier|*
name|name
init|=
name|input_line_pointer
decl_stmt|,
name|ch
decl_stmt|;
while|while
condition|(
operator|!
name|is_end_of_line
index|[
operator|(
name|unsigned
name|char
operator|)
operator|*
name|input_line_pointer
index|]
condition|)
operator|++
name|input_line_pointer
expr_stmt|;
name|ch
operator|=
operator|*
name|input_line_pointer
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"reorder"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|mips_opts
operator|.
name|noreorder
operator|&&
name|prev_nop_frag
operator|!=
name|NULL
condition|)
block|{
comment|/* If we still have pending nops, we can discard them.  The 	     usual nop handling will insert any that are still 	     needed.  */
name|prev_nop_frag
operator|->
name|fr_fix
operator|-=
operator|(
name|prev_nop_frag_holds
operator|*
operator|(
name|mips_opts
operator|.
name|mips16
condition|?
literal|2
else|:
literal|4
operator|)
operator|)
expr_stmt|;
name|prev_nop_frag
operator|=
name|NULL
expr_stmt|;
block|}
name|mips_opts
operator|.
name|noreorder
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"noreorder"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|mips_emit_delays
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
name|mips_opts
operator|.
name|noreorder
operator|=
literal|1
expr_stmt|;
name|mips_any_noreorder
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"at"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|mips_opts
operator|.
name|noat
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"noat"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|mips_opts
operator|.
name|noat
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"macro"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|mips_opts
operator|.
name|warn_about_macros
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"nomacro"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|mips_opts
operator|.
name|noreorder
operator|==
literal|0
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"`noreorder' must be set before `nomacro'"
argument_list|)
argument_list|)
expr_stmt|;
name|mips_opts
operator|.
name|warn_about_macros
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"move"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"novolatile"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|mips_opts
operator|.
name|nomove
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"nomove"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"volatile"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|mips_opts
operator|.
name|nomove
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"bopt"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|mips_opts
operator|.
name|nobopt
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"nobopt"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|mips_opts
operator|.
name|nobopt
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"mips16"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"MIPS-16"
argument_list|)
operator|==
literal|0
condition|)
name|mips_opts
operator|.
name|mips16
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"nomips16"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"noMIPS-16"
argument_list|)
operator|==
literal|0
condition|)
name|mips_opts
operator|.
name|mips16
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"mips3d"
argument_list|)
operator|==
literal|0
condition|)
name|mips_opts
operator|.
name|ase_mips3d
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"nomips3d"
argument_list|)
operator|==
literal|0
condition|)
name|mips_opts
operator|.
name|ase_mips3d
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"mdmx"
argument_list|)
operator|==
literal|0
condition|)
name|mips_opts
operator|.
name|ase_mdmx
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"nomdmx"
argument_list|)
operator|==
literal|0
condition|)
name|mips_opts
operator|.
name|ase_mdmx
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
literal|"mips"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
operator|||
name|strncmp
argument_list|(
name|name
argument_list|,
literal|"arch="
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
block|{
name|int
name|reset
init|=
literal|0
decl_stmt|;
comment|/* Permit the user to change the ISA and architecture on the fly. 	 Needless to say, misuse can cause serious problems.  */
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"mips0"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|reset
operator|=
literal|1
expr_stmt|;
name|mips_opts
operator|.
name|isa
operator|=
name|file_mips_isa
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"mips1"
argument_list|)
operator|==
literal|0
condition|)
name|mips_opts
operator|.
name|isa
operator|=
name|ISA_MIPS1
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"mips2"
argument_list|)
operator|==
literal|0
condition|)
name|mips_opts
operator|.
name|isa
operator|=
name|ISA_MIPS2
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"mips3"
argument_list|)
operator|==
literal|0
condition|)
name|mips_opts
operator|.
name|isa
operator|=
name|ISA_MIPS3
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"mips4"
argument_list|)
operator|==
literal|0
condition|)
name|mips_opts
operator|.
name|isa
operator|=
name|ISA_MIPS4
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"mips5"
argument_list|)
operator|==
literal|0
condition|)
name|mips_opts
operator|.
name|isa
operator|=
name|ISA_MIPS5
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"mips32"
argument_list|)
operator|==
literal|0
condition|)
name|mips_opts
operator|.
name|isa
operator|=
name|ISA_MIPS32
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"mips32r2"
argument_list|)
operator|==
literal|0
condition|)
name|mips_opts
operator|.
name|isa
operator|=
name|ISA_MIPS32R2
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"mips64"
argument_list|)
operator|==
literal|0
condition|)
name|mips_opts
operator|.
name|isa
operator|=
name|ISA_MIPS64
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"mips64r2"
argument_list|)
operator|==
literal|0
condition|)
name|mips_opts
operator|.
name|isa
operator|=
name|ISA_MIPS64R2
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"arch=default"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|reset
operator|=
literal|1
expr_stmt|;
name|mips_opts
operator|.
name|arch
operator|=
name|file_mips_arch
expr_stmt|;
name|mips_opts
operator|.
name|isa
operator|=
name|file_mips_isa
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
literal|"arch="
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
block|{
specifier|const
name|struct
name|mips_cpu_info
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|mips_parse_cpu
argument_list|(
literal|"internal use"
argument_list|,
name|name
operator|+
literal|5
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"unknown architecture %s"
argument_list|)
argument_list|,
name|name
operator|+
literal|5
argument_list|)
expr_stmt|;
else|else
block|{
name|mips_opts
operator|.
name|arch
operator|=
name|p
operator|->
name|cpu
expr_stmt|;
name|mips_opts
operator|.
name|isa
operator|=
name|p
operator|->
name|isa
expr_stmt|;
block|}
block|}
else|else
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"unknown ISA level %s"
argument_list|)
argument_list|,
name|name
operator|+
literal|4
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|mips_opts
operator|.
name|isa
condition|)
block|{
case|case
literal|0
case|:
break|break;
case|case
name|ISA_MIPS1
case|:
case|case
name|ISA_MIPS2
case|:
case|case
name|ISA_MIPS32
case|:
case|case
name|ISA_MIPS32R2
case|:
name|mips_opts
operator|.
name|gp32
operator|=
literal|1
expr_stmt|;
name|mips_opts
operator|.
name|fp32
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|ISA_MIPS3
case|:
case|case
name|ISA_MIPS4
case|:
case|case
name|ISA_MIPS5
case|:
case|case
name|ISA_MIPS64
case|:
case|case
name|ISA_MIPS64R2
case|:
name|mips_opts
operator|.
name|gp32
operator|=
literal|0
expr_stmt|;
name|mips_opts
operator|.
name|fp32
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"unknown ISA level %s"
argument_list|)
argument_list|,
name|name
operator|+
literal|4
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|reset
condition|)
block|{
name|mips_opts
operator|.
name|gp32
operator|=
name|file_mips_gp32
expr_stmt|;
name|mips_opts
operator|.
name|fp32
operator|=
name|file_mips_fp32
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"autoextend"
argument_list|)
operator|==
literal|0
condition|)
name|mips_opts
operator|.
name|noautoextend
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"noautoextend"
argument_list|)
operator|==
literal|0
condition|)
name|mips_opts
operator|.
name|noautoextend
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"push"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|struct
name|mips_option_stack
modifier|*
name|s
decl_stmt|;
name|s
operator|=
operator|(
expr|struct
name|mips_option_stack
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
expr|*
name|s
argument_list|)
expr_stmt|;
name|s
operator|->
name|next
operator|=
name|mips_opts_stack
expr_stmt|;
name|s
operator|->
name|options
operator|=
name|mips_opts
expr_stmt|;
name|mips_opts_stack
operator|=
name|s
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"pop"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|struct
name|mips_option_stack
modifier|*
name|s
decl_stmt|;
name|s
operator|=
name|mips_opts_stack
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|".set pop with no .set push"
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* If we're changing the reorder mode we need to handle              delay slots correctly.  */
if|if
condition|(
name|s
operator|->
name|options
operator|.
name|noreorder
operator|&&
operator|!
name|mips_opts
operator|.
name|noreorder
condition|)
name|mips_emit_delays
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|s
operator|->
name|options
operator|.
name|noreorder
operator|&&
name|mips_opts
operator|.
name|noreorder
condition|)
block|{
if|if
condition|(
name|prev_nop_frag
operator|!=
name|NULL
condition|)
block|{
name|prev_nop_frag
operator|->
name|fr_fix
operator|-=
operator|(
name|prev_nop_frag_holds
operator|*
operator|(
name|mips_opts
operator|.
name|mips16
condition|?
literal|2
else|:
literal|4
operator|)
operator|)
expr_stmt|;
name|prev_nop_frag
operator|=
name|NULL
expr_stmt|;
block|}
block|}
name|mips_opts
operator|=
name|s
operator|->
name|options
expr_stmt|;
name|mips_opts_stack
operator|=
name|s
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"Tried to set unrecognized symbol: %s\n"
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
operator|*
name|input_line_pointer
operator|=
name|ch
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle the .abicalls pseudo-op.  I believe this is equivalent to    .option pic2.  It means to generate SVR4 PIC calls.  */
end_comment

begin_function
specifier|static
name|void
name|s_abicalls
parameter_list|(
name|int
name|ignore
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|mips_pic
operator|=
name|SVR4_PIC
expr_stmt|;
name|mips_abicalls
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|USE_GLOBAL_POINTER_OPT
condition|)
block|{
if|if
condition|(
name|g_switch_seen
operator|&&
name|g_switch_value
operator|!=
literal|0
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"-G may not be used with SVR4 PIC code"
argument_list|)
argument_list|)
expr_stmt|;
name|g_switch_value
operator|=
literal|0
expr_stmt|;
block|}
name|bfd_set_gp_size
argument_list|(
name|stdoutput
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle the .cpload pseudo-op.  This is used when generating SVR4    PIC code.  It sets the $gp register for the function based on the    function address, which is in the register named in the argument.    This uses a relocation against _gp_disp, which is handled specially    by the linker.  The result is: 	lui	$gp,%hi(_gp_disp) 	addiu	$gp,$gp,%lo(_gp_disp) 	addu	$gp,$gp,.cpload argument    The .cpload argument is normally $25 == $t9.  */
end_comment

begin_function
specifier|static
name|void
name|s_cpload
parameter_list|(
name|int
name|ignore
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|expressionS
name|ex
decl_stmt|;
comment|/* If we are not generating SVR4 PIC code, or if this is NewABI code,      .cpload is ignored.  */
if|if
condition|(
name|mips_pic
operator|!=
name|SVR4_PIC
operator|||
name|HAVE_NEWABI
condition|)
block|{
name|s_ignore
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* .cpload should be in a .set noreorder section.  */
if|if
condition|(
name|mips_opts
operator|.
name|noreorder
operator|==
literal|0
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|".cpload not in noreorder section"
argument_list|)
argument_list|)
expr_stmt|;
name|ex
operator|.
name|X_op
operator|=
name|O_symbol
expr_stmt|;
name|ex
operator|.
name|X_add_symbol
operator|=
name|symbol_find_or_make
argument_list|(
literal|"_gp_disp"
argument_list|)
expr_stmt|;
name|ex
operator|.
name|X_op_symbol
operator|=
name|NULL
expr_stmt|;
name|ex
operator|.
name|X_add_number
operator|=
literal|0
expr_stmt|;
comment|/* In ELF, this symbol is implicitly an STT_OBJECT symbol.  */
name|symbol_get_bfdsym
argument_list|(
name|ex
operator|.
name|X_add_symbol
argument_list|)
operator|->
name|flags
operator||=
name|BSF_OBJECT
expr_stmt|;
name|macro_start
argument_list|()
expr_stmt|;
name|macro_build_lui
argument_list|(
operator|&
name|ex
argument_list|,
name|mips_gp_register
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|ex
argument_list|,
literal|"addiu"
argument_list|,
literal|"t,r,j"
argument_list|,
name|mips_gp_register
argument_list|,
name|mips_gp_register
argument_list|,
name|BFD_RELOC_LO16
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"addu"
argument_list|,
literal|"d,v,t"
argument_list|,
name|mips_gp_register
argument_list|,
name|mips_gp_register
argument_list|,
name|tc_get_register
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|macro_end
argument_list|()
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle the .cpsetup pseudo-op defined for NewABI PIC code.  The syntax is:      .cpsetup $reg1, offset|$reg2, label     If offset is given, this results in:      sd		$gp, offset($sp)      lui	$gp, %hi(%neg(%gp_rel(label)))      addiu	$gp, $gp, %lo(%neg(%gp_rel(label)))      daddu	$gp, $gp, $reg1     If $reg2 is given, this results in:      daddu	$reg2, $gp, $0      lui	$gp, %hi(%neg(%gp_rel(label)))      addiu	$gp, $gp, %lo(%neg(%gp_rel(label)))      daddu	$gp, $gp, $reg1    $reg1 is normally $25 == $t9.  */
end_comment

begin_function
specifier|static
name|void
name|s_cpsetup
parameter_list|(
name|int
name|ignore
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|expressionS
name|ex_off
decl_stmt|;
name|expressionS
name|ex_sym
decl_stmt|;
name|int
name|reg1
decl_stmt|;
name|char
modifier|*
name|f
decl_stmt|;
comment|/* If we are not generating SVR4 PIC code, .cpsetup is ignored.      We also need NewABI support.  */
if|if
condition|(
name|mips_pic
operator|!=
name|SVR4_PIC
operator|||
operator|!
name|HAVE_NEWABI
condition|)
block|{
name|s_ignore
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
name|reg1
operator|=
name|tc_get_register
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|!=
literal|','
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"missing argument separator ',' for .cpsetup"
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
operator|++
name|input_line_pointer
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|'$'
condition|)
block|{
name|mips_cpreturn_register
operator|=
name|tc_get_register
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|mips_cpreturn_offset
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|mips_cpreturn_offset
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
name|mips_cpreturn_register
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|!=
literal|','
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"missing argument separator ',' for .cpsetup"
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
operator|++
name|input_line_pointer
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
name|expression
argument_list|(
operator|&
name|ex_sym
argument_list|)
expr_stmt|;
name|macro_start
argument_list|()
expr_stmt|;
if|if
condition|(
name|mips_cpreturn_register
operator|==
operator|-
literal|1
condition|)
block|{
name|ex_off
operator|.
name|X_op
operator|=
name|O_constant
expr_stmt|;
name|ex_off
operator|.
name|X_add_symbol
operator|=
name|NULL
expr_stmt|;
name|ex_off
operator|.
name|X_op_symbol
operator|=
name|NULL
expr_stmt|;
name|ex_off
operator|.
name|X_add_number
operator|=
name|mips_cpreturn_offset
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|ex_off
argument_list|,
literal|"sd"
argument_list|,
literal|"t,o(b)"
argument_list|,
name|mips_gp_register
argument_list|,
name|BFD_RELOC_LO16
argument_list|,
name|SP
argument_list|)
expr_stmt|;
block|}
else|else
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"daddu"
argument_list|,
literal|"d,v,t"
argument_list|,
name|mips_cpreturn_register
argument_list|,
name|mips_gp_register
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Ensure there's room for the next two instructions, so that `f'      doesn't end up with an address in the wrong frag.  */
name|frag_grow
argument_list|(
literal|8
argument_list|)
expr_stmt|;
name|f
operator|=
name|frag_more
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|ex_sym
argument_list|,
literal|"lui"
argument_list|,
literal|"t,u"
argument_list|,
name|mips_gp_register
argument_list|,
name|BFD_RELOC_GPREL16
argument_list|)
expr_stmt|;
name|fix_new
argument_list|(
name|frag_now
argument_list|,
name|f
operator|-
name|frag_now
operator|->
name|fr_literal
argument_list|,
literal|8
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|BFD_RELOC_MIPS_SUB
argument_list|)
expr_stmt|;
name|fix_new
argument_list|(
name|frag_now
argument_list|,
name|f
operator|-
name|frag_now
operator|->
name|fr_literal
argument_list|,
literal|4
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|BFD_RELOC_HI16_S
argument_list|)
expr_stmt|;
name|f
operator|=
name|frag_more
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|ex_sym
argument_list|,
literal|"addiu"
argument_list|,
literal|"t,r,j"
argument_list|,
name|mips_gp_register
argument_list|,
name|mips_gp_register
argument_list|,
name|BFD_RELOC_GPREL16
argument_list|)
expr_stmt|;
name|fix_new
argument_list|(
name|frag_now
argument_list|,
name|f
operator|-
name|frag_now
operator|->
name|fr_literal
argument_list|,
literal|8
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|BFD_RELOC_MIPS_SUB
argument_list|)
expr_stmt|;
name|fix_new
argument_list|(
name|frag_now
argument_list|,
name|f
operator|-
name|frag_now
operator|->
name|fr_literal
argument_list|,
literal|4
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|BFD_RELOC_LO16
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
name|ADDRESS_ADD_INSN
argument_list|,
literal|"d,v,t"
argument_list|,
name|mips_gp_register
argument_list|,
name|mips_gp_register
argument_list|,
name|reg1
argument_list|)
expr_stmt|;
name|macro_end
argument_list|()
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|s_cplocal
parameter_list|(
name|int
name|ignore
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
comment|/* If we are not generating SVR4 PIC code, or if this is not NewABI code,    .cplocal is ignored.  */
if|if
condition|(
name|mips_pic
operator|!=
name|SVR4_PIC
operator|||
operator|!
name|HAVE_NEWABI
condition|)
block|{
name|s_ignore
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
name|mips_gp_register
operator|=
name|tc_get_register
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle the .cprestore pseudo-op.  This stores $gp into a given    offset from $sp.  The offset is remembered, and after making a PIC    call $gp is restored from that location.  */
end_comment

begin_function
specifier|static
name|void
name|s_cprestore
parameter_list|(
name|int
name|ignore
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|expressionS
name|ex
decl_stmt|;
comment|/* If we are not generating SVR4 PIC code, or if this is NewABI code,      .cprestore is ignored.  */
if|if
condition|(
name|mips_pic
operator|!=
name|SVR4_PIC
operator|||
name|HAVE_NEWABI
condition|)
block|{
name|s_ignore
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
name|mips_cprestore_offset
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
name|mips_cprestore_valid
operator|=
literal|1
expr_stmt|;
name|ex
operator|.
name|X_op
operator|=
name|O_constant
expr_stmt|;
name|ex
operator|.
name|X_add_symbol
operator|=
name|NULL
expr_stmt|;
name|ex
operator|.
name|X_op_symbol
operator|=
name|NULL
expr_stmt|;
name|ex
operator|.
name|X_add_number
operator|=
name|mips_cprestore_offset
expr_stmt|;
name|macro_start
argument_list|()
expr_stmt|;
name|macro_build_ldst_constoffset
argument_list|(
operator|&
name|ex
argument_list|,
name|ADDRESS_STORE_INSN
argument_list|,
name|mips_gp_register
argument_list|,
name|SP
argument_list|,
name|HAVE_64BIT_ADDRESSES
argument_list|)
expr_stmt|;
name|macro_end
argument_list|()
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle the .cpreturn pseudo-op defined for NewABI PIC code. If an offset    was given in the preceding .cpsetup, it results in:      ld		$gp, offset($sp)     If a register $reg2 was given there, it results in:      daddu	$gp, $reg2, $0  */
end_comment

begin_function
specifier|static
name|void
name|s_cpreturn
parameter_list|(
name|int
name|ignore
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|expressionS
name|ex
decl_stmt|;
comment|/* If we are not generating SVR4 PIC code, .cpreturn is ignored.      We also need NewABI support.  */
if|if
condition|(
name|mips_pic
operator|!=
name|SVR4_PIC
operator|||
operator|!
name|HAVE_NEWABI
condition|)
block|{
name|s_ignore
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
name|macro_start
argument_list|()
expr_stmt|;
if|if
condition|(
name|mips_cpreturn_register
operator|==
operator|-
literal|1
condition|)
block|{
name|ex
operator|.
name|X_op
operator|=
name|O_constant
expr_stmt|;
name|ex
operator|.
name|X_add_symbol
operator|=
name|NULL
expr_stmt|;
name|ex
operator|.
name|X_op_symbol
operator|=
name|NULL
expr_stmt|;
name|ex
operator|.
name|X_add_number
operator|=
name|mips_cpreturn_offset
expr_stmt|;
name|macro_build
argument_list|(
operator|&
name|ex
argument_list|,
literal|"ld"
argument_list|,
literal|"t,o(b)"
argument_list|,
name|mips_gp_register
argument_list|,
name|BFD_RELOC_LO16
argument_list|,
name|SP
argument_list|)
expr_stmt|;
block|}
else|else
name|macro_build
argument_list|(
name|NULL
argument_list|,
literal|"daddu"
argument_list|,
literal|"d,v,t"
argument_list|,
name|mips_gp_register
argument_list|,
name|mips_cpreturn_register
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|macro_end
argument_list|()
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle the .gpvalue pseudo-op.  This is used when generating NewABI PIC    code.  It sets the offset to use in gp_rel relocations.  */
end_comment

begin_function
specifier|static
name|void
name|s_gpvalue
parameter_list|(
name|int
name|ignore
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
comment|/* If we are not generating SVR4 PIC code, .gpvalue is ignored.      We also need NewABI support.  */
if|if
condition|(
name|mips_pic
operator|!=
name|SVR4_PIC
operator|||
operator|!
name|HAVE_NEWABI
condition|)
block|{
name|s_ignore
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
name|mips_gprel_offset
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle the .gpword pseudo-op.  This is used when generating PIC    code.  It generates a 32 bit GP relative reloc.  */
end_comment

begin_function
specifier|static
name|void
name|s_gpword
parameter_list|(
name|int
name|ignore
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|symbolS
modifier|*
name|label
decl_stmt|;
name|expressionS
name|ex
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
comment|/* When not generating PIC code, this is treated as .word.  */
if|if
condition|(
name|mips_pic
operator|!=
name|SVR4_PIC
condition|)
block|{
name|s_cons
argument_list|(
literal|2
argument_list|)
expr_stmt|;
return|return;
block|}
name|label
operator|=
name|insn_labels
operator|!=
name|NULL
condition|?
name|insn_labels
operator|->
name|label
else|:
name|NULL
expr_stmt|;
name|mips_emit_delays
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|auto_align
condition|)
name|mips_align
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|,
name|label
argument_list|)
expr_stmt|;
name|mips_clear_insn_labels
argument_list|()
expr_stmt|;
name|expression
argument_list|(
operator|&
name|ex
argument_list|)
expr_stmt|;
if|if
condition|(
name|ex
operator|.
name|X_op
operator|!=
name|O_symbol
operator|||
name|ex
operator|.
name|X_add_number
operator|!=
literal|0
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Unsupported use of .gpword"
argument_list|)
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
block|}
name|p
operator|=
name|frag_more
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|p
argument_list|,
literal|0
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|fix_new_exp
argument_list|(
name|frag_now
argument_list|,
name|p
operator|-
name|frag_now
operator|->
name|fr_literal
argument_list|,
literal|4
argument_list|,
operator|&
name|ex
argument_list|,
name|FALSE
argument_list|,
name|BFD_RELOC_GPREL32
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|s_gpdword
parameter_list|(
name|int
name|ignore
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|symbolS
modifier|*
name|label
decl_stmt|;
name|expressionS
name|ex
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
comment|/* When not generating PIC code, this is treated as .dword.  */
if|if
condition|(
name|mips_pic
operator|!=
name|SVR4_PIC
condition|)
block|{
name|s_cons
argument_list|(
literal|3
argument_list|)
expr_stmt|;
return|return;
block|}
name|label
operator|=
name|insn_labels
operator|!=
name|NULL
condition|?
name|insn_labels
operator|->
name|label
else|:
name|NULL
expr_stmt|;
name|mips_emit_delays
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|auto_align
condition|)
name|mips_align
argument_list|(
literal|3
argument_list|,
literal|0
argument_list|,
name|label
argument_list|)
expr_stmt|;
name|mips_clear_insn_labels
argument_list|()
expr_stmt|;
name|expression
argument_list|(
operator|&
name|ex
argument_list|)
expr_stmt|;
if|if
condition|(
name|ex
operator|.
name|X_op
operator|!=
name|O_symbol
operator|||
name|ex
operator|.
name|X_add_number
operator|!=
literal|0
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Unsupported use of .gpdword"
argument_list|)
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
block|}
name|p
operator|=
name|frag_more
argument_list|(
literal|8
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|p
argument_list|,
literal|0
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|fix_new_exp
argument_list|(
name|frag_now
argument_list|,
name|p
operator|-
name|frag_now
operator|->
name|fr_literal
argument_list|,
literal|4
argument_list|,
operator|&
name|ex
argument_list|,
name|FALSE
argument_list|,
name|BFD_RELOC_GPREL32
argument_list|)
expr_stmt|;
comment|/* GPREL32 composed with 64 gives a 64-bit GP offset.  */
name|ex
operator|.
name|X_op
operator|=
name|O_absent
expr_stmt|;
name|ex
operator|.
name|X_add_symbol
operator|=
literal|0
expr_stmt|;
name|ex
operator|.
name|X_add_number
operator|=
literal|0
expr_stmt|;
name|fix_new_exp
argument_list|(
name|frag_now
argument_list|,
name|p
operator|-
name|frag_now
operator|->
name|fr_literal
argument_list|,
literal|8
argument_list|,
operator|&
name|ex
argument_list|,
name|FALSE
argument_list|,
name|BFD_RELOC_64
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle the .cpadd pseudo-op.  This is used when dealing with switch    tables in SVR4 PIC code.  */
end_comment

begin_function
specifier|static
name|void
name|s_cpadd
parameter_list|(
name|int
name|ignore
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|int
name|reg
decl_stmt|;
comment|/* This is ignored when not generating SVR4 PIC code.  */
if|if
condition|(
name|mips_pic
operator|!=
name|SVR4_PIC
condition|)
block|{
name|s_ignore
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Add $gp to the register named as an argument.  */
name|macro_start
argument_list|()
expr_stmt|;
name|reg
operator|=
name|tc_get_register
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|macro_build
argument_list|(
name|NULL
argument_list|,
name|ADDRESS_ADD_INSN
argument_list|,
literal|"d,v,t"
argument_list|,
name|reg
argument_list|,
name|reg
argument_list|,
name|mips_gp_register
argument_list|)
expr_stmt|;
name|macro_end
argument_list|()
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle the .insn pseudo-op.  This marks instruction labels in    mips16 mode.  This permits the linker to handle them specially,    such as generating jalx instructions when needed.  We also make    them odd for the duration of the assembly, in order to generate the    right sort of code.  We will make them even in the adjust_symtab    routine, while leaving them marked.  This is convenient for the    debugger and the disassembler.  The linker knows to make them odd    again.  */
end_comment

begin_function
specifier|static
name|void
name|s_insn
parameter_list|(
name|int
name|ignore
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|mips16_mark_labels
argument_list|()
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle a .stabn directive.  We need these in order to mark a label    as being a mips16 text label correctly.  Sometimes the compiler    will emit a label, followed by a .stabn, and then switch sections.    If the label and .stabn are in mips16 mode, then the label is    really a mips16 text label.  */
end_comment

begin_function
specifier|static
name|void
name|s_mips_stab
parameter_list|(
name|int
name|type
parameter_list|)
block|{
if|if
condition|(
name|type
operator|==
literal|'n'
condition|)
name|mips16_mark_labels
argument_list|()
expr_stmt|;
name|s_stab
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle the .weakext pseudo-op as defined in Kane and Heinrich.  */
end_comment

begin_function
specifier|static
name|void
name|s_mips_weakext
parameter_list|(
name|int
name|ignore
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|c
decl_stmt|;
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
name|expressionS
name|exp
decl_stmt|;
name|name
operator|=
name|input_line_pointer
expr_stmt|;
name|c
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
name|symbolP
operator|=
name|symbol_find_or_make
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|S_SET_WEAK
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|is_end_of_line
index|[
operator|(
name|unsigned
name|char
operator|)
operator|*
name|input_line_pointer
index|]
condition|)
block|{
if|if
condition|(
name|S_IS_DEFINED
argument_list|(
name|symbolP
argument_list|)
condition|)
block|{
name|as_bad
argument_list|(
literal|"ignoring attempt to redefine symbol %s"
argument_list|,
name|S_GET_NAME
argument_list|(
name|symbolP
argument_list|)
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|','
condition|)
block|{
operator|++
name|input_line_pointer
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
block|}
name|expression
argument_list|(
operator|&
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
name|exp
operator|.
name|X_op
operator|!=
name|O_symbol
condition|)
block|{
name|as_bad
argument_list|(
literal|"bad .weakext directive"
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
name|symbol_set_value_expression
argument_list|(
name|symbolP
argument_list|,
operator|&
name|exp
argument_list|)
expr_stmt|;
block|}
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Parse a register string into a number.  Called from the ECOFF code    to parse .frame.  The argument is non-zero if this is the frame    register, so that we can record it in mips_frame_reg.  */
end_comment

begin_function
name|int
name|tc_get_register
parameter_list|(
name|int
name|frame
parameter_list|)
block|{
name|int
name|reg
decl_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|++
operator|!=
literal|'$'
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"expected `$'"
argument_list|)
argument_list|)
expr_stmt|;
name|reg
operator|=
name|ZERO
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ISDIGIT
argument_list|(
operator|*
name|input_line_pointer
argument_list|)
condition|)
block|{
name|reg
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
if|if
condition|(
name|reg
operator|<
literal|0
operator|||
name|reg
operator|>=
literal|32
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"Bad register number"
argument_list|)
argument_list|)
expr_stmt|;
name|reg
operator|=
name|ZERO
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|input_line_pointer
argument_list|,
literal|"ra"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
block|{
name|reg
operator|=
name|RA
expr_stmt|;
name|input_line_pointer
operator|+=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|input_line_pointer
argument_list|,
literal|"fp"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
block|{
name|reg
operator|=
name|FP
expr_stmt|;
name|input_line_pointer
operator|+=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|input_line_pointer
argument_list|,
literal|"sp"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
block|{
name|reg
operator|=
name|SP
expr_stmt|;
name|input_line_pointer
operator|+=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|input_line_pointer
argument_list|,
literal|"gp"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
block|{
name|reg
operator|=
name|GP
expr_stmt|;
name|input_line_pointer
operator|+=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|input_line_pointer
argument_list|,
literal|"at"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
block|{
name|reg
operator|=
name|AT
expr_stmt|;
name|input_line_pointer
operator|+=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|input_line_pointer
argument_list|,
literal|"kt0"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
block|{
name|reg
operator|=
name|KT0
expr_stmt|;
name|input_line_pointer
operator|+=
literal|3
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|input_line_pointer
argument_list|,
literal|"kt1"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
block|{
name|reg
operator|=
name|KT1
expr_stmt|;
name|input_line_pointer
operator|+=
literal|3
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|input_line_pointer
argument_list|,
literal|"zero"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
block|{
name|reg
operator|=
name|ZERO
expr_stmt|;
name|input_line_pointer
operator|+=
literal|4
expr_stmt|;
block|}
else|else
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"Unrecognized register name"
argument_list|)
argument_list|)
expr_stmt|;
name|reg
operator|=
name|ZERO
expr_stmt|;
while|while
condition|(
name|ISALNUM
argument_list|(
operator|*
name|input_line_pointer
argument_list|)
condition|)
name|input_line_pointer
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|frame
condition|)
block|{
name|mips_frame_reg
operator|=
name|reg
operator|!=
literal|0
condition|?
name|reg
else|:
name|SP
expr_stmt|;
name|mips_frame_reg_valid
operator|=
literal|1
expr_stmt|;
name|mips_cprestore_valid
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|reg
return|;
block|}
end_function

begin_function
name|valueT
name|md_section_align
parameter_list|(
name|asection
modifier|*
name|seg
parameter_list|,
name|valueT
name|addr
parameter_list|)
block|{
name|int
name|align
init|=
name|bfd_get_section_alignment
argument_list|(
name|stdoutput
argument_list|,
name|seg
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|OBJ_ELF
comment|/* We don't need to align ELF sections to the full alignment.      However, Irix 5 may prefer that we align them at least to a 16      byte boundary.  We don't bother to align the sections if we are      targeted for an embedded system.  */
if|if
condition|(
name|strcmp
argument_list|(
name|TARGET_OS
argument_list|,
literal|"elf"
argument_list|)
operator|==
literal|0
condition|)
return|return
name|addr
return|;
if|if
condition|(
name|align
operator|>
literal|4
condition|)
name|align
operator|=
literal|4
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
operator|(
name|addr
operator|+
operator|(
literal|1
operator|<<
name|align
operator|)
operator|-
literal|1
operator|)
operator|&
operator|(
operator|-
literal|1
operator|<<
name|align
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Utility routine, called from above as well.  If called while the    input file is still being read, it's only an approximation.  (For    example, a symbol may later become defined which appeared to be    undefined earlier.)  */
end_comment

begin_function
specifier|static
name|int
name|nopic_need_relax
parameter_list|(
name|symbolS
modifier|*
name|sym
parameter_list|,
name|int
name|before_relaxing
parameter_list|)
block|{
if|if
condition|(
name|sym
operator|==
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|USE_GLOBAL_POINTER_OPT
operator|&&
name|g_switch_value
operator|>
literal|0
condition|)
block|{
specifier|const
name|char
modifier|*
name|symname
decl_stmt|;
name|int
name|change
decl_stmt|;
comment|/* Find out whether this symbol can be referenced off the $gp 	 register.  It can be if it is smaller than the -G size or if 	 it is in the .sdata or .sbss section.  Certain symbols can 	 not be referenced off the $gp, although it appears as though 	 they can.  */
name|symname
operator|=
name|S_GET_NAME
argument_list|(
name|sym
argument_list|)
expr_stmt|;
if|if
condition|(
name|symname
operator|!=
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
operator|&&
operator|(
name|strcmp
argument_list|(
name|symname
argument_list|,
literal|"eprol"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|symname
argument_list|,
literal|"etext"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|symname
argument_list|,
literal|"_gp"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|symname
argument_list|,
literal|"edata"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|symname
argument_list|,
literal|"_fbss"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|symname
argument_list|,
literal|"_fdata"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|symname
argument_list|,
literal|"_ftext"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|symname
argument_list|,
literal|"end"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|symname
argument_list|,
literal|"_gp_disp"
argument_list|)
operator|==
literal|0
operator|)
condition|)
name|change
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
operator|!
name|S_IS_DEFINED
argument_list|(
name|sym
argument_list|)
operator|||
name|S_IS_COMMON
argument_list|(
name|sym
argument_list|)
operator|)
operator|&&
operator|(
literal|0
ifndef|#
directive|ifndef
name|NO_ECOFF_DEBUGGING
operator|||
operator|(
name|symbol_get_obj
argument_list|(
name|sym
argument_list|)
operator|->
name|ecoff_extern_size
operator|!=
literal|0
operator|&&
operator|(
name|symbol_get_obj
argument_list|(
name|sym
argument_list|)
operator|->
name|ecoff_extern_size
operator|<=
name|g_switch_value
operator|)
operator|)
endif|#
directive|endif
comment|/* We must defer this decision until after the whole 		      file has been read, since there might be a .extern 		      after the first use of this symbol.  */
operator|||
operator|(
name|before_relaxing
ifndef|#
directive|ifndef
name|NO_ECOFF_DEBUGGING
operator|&&
name|symbol_get_obj
argument_list|(
name|sym
argument_list|)
operator|->
name|ecoff_extern_size
operator|==
literal|0
endif|#
directive|endif
operator|&&
name|S_GET_VALUE
argument_list|(
name|sym
argument_list|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|S_GET_VALUE
argument_list|(
name|sym
argument_list|)
operator|!=
literal|0
operator|&&
name|S_GET_VALUE
argument_list|(
name|sym
argument_list|)
operator|<=
name|g_switch_value
operator|)
operator|)
condition|)
name|change
operator|=
literal|0
expr_stmt|;
else|else
block|{
specifier|const
name|char
modifier|*
name|segname
decl_stmt|;
name|segname
operator|=
name|segment_name
argument_list|(
name|S_GET_SEGMENT
argument_list|(
name|sym
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|strcmp
argument_list|(
name|segname
argument_list|,
literal|".lit8"
argument_list|)
operator|!=
literal|0
operator|&&
name|strcmp
argument_list|(
name|segname
argument_list|,
literal|".lit4"
argument_list|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|change
operator|=
operator|(
name|strcmp
argument_list|(
name|segname
argument_list|,
literal|".sdata"
argument_list|)
operator|!=
literal|0
operator|&&
name|strcmp
argument_list|(
name|segname
argument_list|,
literal|".sbss"
argument_list|)
operator|!=
literal|0
operator|&&
name|strncmp
argument_list|(
name|segname
argument_list|,
literal|".sdata."
argument_list|,
literal|7
argument_list|)
operator|!=
literal|0
operator|&&
name|strncmp
argument_list|(
name|segname
argument_list|,
literal|".gnu.linkonce.s."
argument_list|,
literal|16
argument_list|)
operator|!=
literal|0
operator|)
expr_stmt|;
block|}
return|return
name|change
return|;
block|}
else|else
comment|/* We are not optimizing for the $gp register.  */
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Return true if the given symbol should be considered local for SVR4 PIC.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|pic_need_relax
parameter_list|(
name|symbolS
modifier|*
name|sym
parameter_list|,
name|asection
modifier|*
name|segtype
parameter_list|)
block|{
name|asection
modifier|*
name|symsec
decl_stmt|;
name|bfd_boolean
name|linkonce
decl_stmt|;
comment|/* Handle the case of a symbol equated to another symbol.  */
while|while
condition|(
name|symbol_equated_reloc_p
argument_list|(
name|sym
argument_list|)
condition|)
block|{
name|symbolS
modifier|*
name|n
decl_stmt|;
comment|/* It's possible to get a loop here in a badly written 	 program.  */
name|n
operator|=
name|symbol_get_value_expression
argument_list|(
name|sym
argument_list|)
operator|->
name|X_add_symbol
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|sym
condition|)
break|break;
name|sym
operator|=
name|n
expr_stmt|;
block|}
name|symsec
operator|=
name|S_GET_SEGMENT
argument_list|(
name|sym
argument_list|)
expr_stmt|;
comment|/* duplicate the test for LINK_ONCE sections as in adjust_reloc_syms */
name|linkonce
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|symsec
operator|!=
name|segtype
operator|&&
operator|!
name|S_IS_LOCAL
argument_list|(
name|sym
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|bfd_get_section_flags
argument_list|(
name|stdoutput
argument_list|,
name|symsec
argument_list|)
operator|&
name|SEC_LINK_ONCE
operator|)
operator|!=
literal|0
condition|)
name|linkonce
operator|=
name|TRUE
expr_stmt|;
comment|/* The GNU toolchain uses an extension for ELF: a section 	 beginning with the magic string .gnu.linkonce is a linkonce 	 section.  */
if|if
condition|(
name|strncmp
argument_list|(
name|segment_name
argument_list|(
name|symsec
argument_list|)
argument_list|,
literal|".gnu.linkonce"
argument_list|,
sizeof|sizeof
expr|".gnu.linkonce"
operator|-
literal|1
argument_list|)
operator|==
literal|0
condition|)
name|linkonce
operator|=
name|TRUE
expr_stmt|;
block|}
comment|/* This must duplicate the test in adjust_reloc_syms.  */
return|return
operator|(
name|symsec
operator|!=
operator|&
name|bfd_und_section
operator|&&
name|symsec
operator|!=
operator|&
name|bfd_abs_section
operator|&&
operator|!
name|bfd_is_com_section
argument_list|(
name|symsec
argument_list|)
operator|&&
operator|!
name|linkonce
ifdef|#
directive|ifdef
name|OBJ_ELF
comment|/* A global or weak symbol is treated as external.  */
operator|&&
operator|(
name|OUTPUT_FLAVOR
operator|!=
name|bfd_target_elf_flavour
operator|||
operator|(
operator|!
name|S_IS_WEAK
argument_list|(
name|sym
argument_list|)
operator|&&
operator|(
operator|!
name|S_IS_EXTERNAL
argument_list|(
name|sym
argument_list|)
operator|||
name|mips_pic
operator|==
name|EMBEDDED_PIC
operator|)
operator|)
operator|)
endif|#
directive|endif
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Given a mips16 variant frag FRAGP, return non-zero if it needs an    extended opcode.  SEC is the section the frag is in.  */
end_comment

begin_function
specifier|static
name|int
name|mips16_extended_frag
parameter_list|(
name|fragS
modifier|*
name|fragp
parameter_list|,
name|asection
modifier|*
name|sec
parameter_list|,
name|long
name|stretch
parameter_list|)
block|{
name|int
name|type
decl_stmt|;
specifier|register
specifier|const
name|struct
name|mips16_immed_operand
modifier|*
name|op
decl_stmt|;
name|offsetT
name|val
decl_stmt|;
name|int
name|mintiny
decl_stmt|,
name|maxtiny
decl_stmt|;
name|segT
name|symsec
decl_stmt|;
name|fragS
modifier|*
name|sym_frag
decl_stmt|;
if|if
condition|(
name|RELAX_MIPS16_USER_SMALL
argument_list|(
name|fragp
operator|->
name|fr_subtype
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|RELAX_MIPS16_USER_EXT
argument_list|(
name|fragp
operator|->
name|fr_subtype
argument_list|)
condition|)
return|return
literal|1
return|;
name|type
operator|=
name|RELAX_MIPS16_TYPE
argument_list|(
name|fragp
operator|->
name|fr_subtype
argument_list|)
expr_stmt|;
name|op
operator|=
name|mips16_immed_operands
expr_stmt|;
while|while
condition|(
name|op
operator|->
name|type
operator|!=
name|type
condition|)
block|{
operator|++
name|op
expr_stmt|;
name|assert
argument_list|(
name|op
operator|<
name|mips16_immed_operands
operator|+
name|MIPS16_NUM_IMMED
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|op
operator|->
name|unsp
condition|)
block|{
if|if
condition|(
name|type
operator|==
literal|'<'
operator|||
name|type
operator|==
literal|'>'
operator|||
name|type
operator|==
literal|'['
operator|||
name|type
operator|==
literal|']'
condition|)
block|{
name|mintiny
operator|=
literal|1
expr_stmt|;
name|maxtiny
operator|=
literal|1
operator|<<
name|op
operator|->
name|nbits
expr_stmt|;
block|}
else|else
block|{
name|mintiny
operator|=
literal|0
expr_stmt|;
name|maxtiny
operator|=
operator|(
literal|1
operator|<<
name|op
operator|->
name|nbits
operator|)
operator|-
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
name|mintiny
operator|=
operator|-
operator|(
literal|1
operator|<<
operator|(
name|op
operator|->
name|nbits
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
name|maxtiny
operator|=
operator|(
literal|1
operator|<<
operator|(
name|op
operator|->
name|nbits
operator|-
literal|1
operator|)
operator|)
operator|-
literal|1
expr_stmt|;
block|}
name|sym_frag
operator|=
name|symbol_get_frag
argument_list|(
name|fragp
operator|->
name|fr_symbol
argument_list|)
expr_stmt|;
name|val
operator|=
name|S_GET_VALUE
argument_list|(
name|fragp
operator|->
name|fr_symbol
argument_list|)
expr_stmt|;
name|symsec
operator|=
name|S_GET_SEGMENT
argument_list|(
name|fragp
operator|->
name|fr_symbol
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|->
name|pcrel
condition|)
block|{
name|addressT
name|addr
decl_stmt|;
comment|/* We won't have the section when we are called from          mips_relax_frag.  However, we will always have been called          from md_estimate_size_before_relax first.  If this is a          branch to a different section, we mark it as such.  If SEC is          NULL, and the frag is not marked, then it must be a branch to          the same section.  */
if|if
condition|(
name|sec
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|RELAX_MIPS16_LONG_BRANCH
argument_list|(
name|fragp
operator|->
name|fr_subtype
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
else|else
block|{
comment|/* Must have been called from md_estimate_size_before_relax.  */
if|if
condition|(
name|symsec
operator|!=
name|sec
condition|)
block|{
name|fragp
operator|->
name|fr_subtype
operator|=
name|RELAX_MIPS16_MARK_LONG_BRANCH
argument_list|(
name|fragp
operator|->
name|fr_subtype
argument_list|)
expr_stmt|;
comment|/* FIXME: We should support this, and let the linker                  catch branches and loads that are out of range.  */
name|as_bad_where
argument_list|(
name|fragp
operator|->
name|fr_file
argument_list|,
name|fragp
operator|->
name|fr_line
argument_list|,
name|_
argument_list|(
literal|"unsupported PC relative reference to different section"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|fragp
operator|!=
name|sym_frag
operator|&&
name|sym_frag
operator|->
name|fr_address
operator|==
literal|0
condition|)
comment|/* Assume non-extended on the first relaxation pass. 	       The address we have calculated will be bogus if this is 	       a forward branch to another frag, as the forward frag 	       will have fr_address == 0.  */
return|return
literal|0
return|;
block|}
comment|/* In this case, we know for sure that the symbol fragment is in 	 the same section.  If the relax_marker of the symbol fragment 	 differs from the relax_marker of this fragment, we have not 	 yet adjusted the symbol fragment fr_address.  We want to add 	 in STRETCH in order to get a better estimate of the address. 	 This particularly matters because of the shift bits.  */
if|if
condition|(
name|stretch
operator|!=
literal|0
operator|&&
name|sym_frag
operator|->
name|relax_marker
operator|!=
name|fragp
operator|->
name|relax_marker
condition|)
block|{
name|fragS
modifier|*
name|f
decl_stmt|;
comment|/* Adjust stretch for any alignment frag.  Note that if have              been expanding the earlier code, the symbol may be              defined in what appears to be an earlier frag.  FIXME:              This doesn't handle the fr_subtype field, which specifies              a maximum number of bytes to skip when doing an              alignment.  */
for|for
control|(
name|f
operator|=
name|fragp
init|;
name|f
operator|!=
name|NULL
operator|&&
name|f
operator|!=
name|sym_frag
condition|;
name|f
operator|=
name|f
operator|->
name|fr_next
control|)
block|{
if|if
condition|(
name|f
operator|->
name|fr_type
operator|==
name|rs_align
operator|||
name|f
operator|->
name|fr_type
operator|==
name|rs_align_code
condition|)
block|{
if|if
condition|(
name|stretch
operator|<
literal|0
condition|)
name|stretch
operator|=
operator|-
operator|(
operator|(
operator|-
name|stretch
operator|)
operator|&
operator|~
operator|(
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|f
operator|->
name|fr_offset
operator|)
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
else|else
name|stretch
operator|&=
operator|~
operator|(
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|f
operator|->
name|fr_offset
operator|)
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|stretch
operator|==
literal|0
condition|)
break|break;
block|}
block|}
if|if
condition|(
name|f
operator|!=
name|NULL
condition|)
name|val
operator|+=
name|stretch
expr_stmt|;
block|}
name|addr
operator|=
name|fragp
operator|->
name|fr_address
operator|+
name|fragp
operator|->
name|fr_fix
expr_stmt|;
comment|/* The base address rules are complicated.  The base address of          a branch is the following instruction.  The base address of a          PC relative load or add is the instruction itself, but if it          is in a delay slot (in which case it can not be extended) use          the address of the instruction whose delay slot it is in.  */
if|if
condition|(
name|type
operator|==
literal|'p'
operator|||
name|type
operator|==
literal|'q'
condition|)
block|{
name|addr
operator|+=
literal|2
expr_stmt|;
comment|/* If we are currently assuming that this frag should be 	     extended, then, the current address is two bytes 	     higher.  */
if|if
condition|(
name|RELAX_MIPS16_EXTENDED
argument_list|(
name|fragp
operator|->
name|fr_subtype
argument_list|)
condition|)
name|addr
operator|+=
literal|2
expr_stmt|;
comment|/* Ignore the low bit in the target, since it will be set              for a text label.  */
if|if
condition|(
operator|(
name|val
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
operator|--
name|val
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|RELAX_MIPS16_JAL_DSLOT
argument_list|(
name|fragp
operator|->
name|fr_subtype
argument_list|)
condition|)
name|addr
operator|-=
literal|4
expr_stmt|;
elseif|else
if|if
condition|(
name|RELAX_MIPS16_DSLOT
argument_list|(
name|fragp
operator|->
name|fr_subtype
argument_list|)
condition|)
name|addr
operator|-=
literal|2
expr_stmt|;
name|val
operator|-=
name|addr
operator|&
operator|~
operator|(
operator|(
literal|1
operator|<<
name|op
operator|->
name|shift
operator|)
operator|-
literal|1
operator|)
expr_stmt|;
comment|/* Branch offsets have an implicit 0 in the lowest bit.  */
if|if
condition|(
name|type
operator|==
literal|'p'
operator|||
name|type
operator|==
literal|'q'
condition|)
name|val
operator|/=
literal|2
expr_stmt|;
comment|/* If any of the shifted bits are set, we must use an extended          opcode.  If the address depends on the size of this          instruction, this can lead to a loop, so we arrange to always          use an extended opcode.  We only check this when we are in          the main relaxation loop, when SEC is NULL.  */
if|if
condition|(
operator|(
name|val
operator|&
operator|(
operator|(
literal|1
operator|<<
name|op
operator|->
name|shift
operator|)
operator|-
literal|1
operator|)
operator|)
operator|!=
literal|0
operator|&&
name|sec
operator|==
name|NULL
condition|)
block|{
name|fragp
operator|->
name|fr_subtype
operator|=
name|RELAX_MIPS16_MARK_LONG_BRANCH
argument_list|(
name|fragp
operator|->
name|fr_subtype
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* If we are about to mark a frag as extended because the value          is precisely maxtiny + 1, then there is a chance of an          infinite loop as in the following code: 	     la	$4,foo 	     .skip	1020 	     .align	2 	   foo: 	 In this case when the la is extended, foo is 0x3fc bytes 	 away, so the la can be shrunk, but then foo is 0x400 away, so 	 the la must be extended.  To avoid this loop, we mark the 	 frag as extended if it was small, and is about to become 	 extended with a value of maxtiny + 1.  */
if|if
condition|(
name|val
operator|==
operator|(
operator|(
name|maxtiny
operator|+
literal|1
operator|)
operator|<<
name|op
operator|->
name|shift
operator|)
operator|&&
operator|!
name|RELAX_MIPS16_EXTENDED
argument_list|(
name|fragp
operator|->
name|fr_subtype
argument_list|)
operator|&&
name|sec
operator|==
name|NULL
condition|)
block|{
name|fragp
operator|->
name|fr_subtype
operator|=
name|RELAX_MIPS16_MARK_LONG_BRANCH
argument_list|(
name|fragp
operator|->
name|fr_subtype
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|symsec
operator|!=
name|absolute_section
operator|&&
name|sec
operator|!=
name|NULL
condition|)
name|as_bad_where
argument_list|(
name|fragp
operator|->
name|fr_file
argument_list|,
name|fragp
operator|->
name|fr_line
argument_list|,
name|_
argument_list|(
literal|"unsupported relocation"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|val
operator|&
operator|(
operator|(
literal|1
operator|<<
name|op
operator|->
name|shift
operator|)
operator|-
literal|1
operator|)
operator|)
operator|!=
literal|0
operator|||
name|val
operator|<
operator|(
name|mintiny
operator|<<
name|op
operator|->
name|shift
operator|)
operator|||
name|val
operator|>
operator|(
name|maxtiny
operator|<<
name|op
operator|->
name|shift
operator|)
condition|)
return|return
literal|1
return|;
else|else
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Compute the length of a branch sequence, and adjust the    RELAX_BRANCH_TOOFAR bit accordingly.  If FRAGP is NULL, the    worst-case length is computed, with UPDATE being used to indicate    whether an unconditional (-1), branch-likely (+1) or regular (0)    branch is to be computed.  */
end_comment

begin_function
specifier|static
name|int
name|relaxed_branch_length
parameter_list|(
name|fragS
modifier|*
name|fragp
parameter_list|,
name|asection
modifier|*
name|sec
parameter_list|,
name|int
name|update
parameter_list|)
block|{
name|bfd_boolean
name|toofar
decl_stmt|;
name|int
name|length
decl_stmt|;
if|if
condition|(
name|fragp
operator|&&
name|S_IS_DEFINED
argument_list|(
name|fragp
operator|->
name|fr_symbol
argument_list|)
operator|&&
name|sec
operator|==
name|S_GET_SEGMENT
argument_list|(
name|fragp
operator|->
name|fr_symbol
argument_list|)
condition|)
block|{
name|addressT
name|addr
decl_stmt|;
name|offsetT
name|val
decl_stmt|;
name|val
operator|=
name|S_GET_VALUE
argument_list|(
name|fragp
operator|->
name|fr_symbol
argument_list|)
operator|+
name|fragp
operator|->
name|fr_offset
expr_stmt|;
name|addr
operator|=
name|fragp
operator|->
name|fr_address
operator|+
name|fragp
operator|->
name|fr_fix
operator|+
literal|4
expr_stmt|;
name|val
operator|-=
name|addr
expr_stmt|;
name|toofar
operator|=
name|val
operator|<
operator|-
operator|(
literal|0x8000
operator|<<
literal|2
operator|)
operator|||
name|val
operator|>=
operator|(
literal|0x8000
operator|<<
literal|2
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fragp
condition|)
comment|/* If the symbol is not defined or it's in a different segment,        assume the user knows what's going on and emit a short        branch.  */
name|toofar
operator|=
name|FALSE
expr_stmt|;
else|else
name|toofar
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|fragp
operator|&&
name|update
operator|&&
name|toofar
operator|!=
name|RELAX_BRANCH_TOOFAR
argument_list|(
name|fragp
operator|->
name|fr_subtype
argument_list|)
condition|)
name|fragp
operator|->
name|fr_subtype
operator|=
name|RELAX_BRANCH_ENCODE
argument_list|(
name|RELAX_BRANCH_UNCOND
argument_list|(
name|fragp
operator|->
name|fr_subtype
argument_list|)
argument_list|,
name|RELAX_BRANCH_LIKELY
argument_list|(
name|fragp
operator|->
name|fr_subtype
argument_list|)
argument_list|,
name|RELAX_BRANCH_LINK
argument_list|(
name|fragp
operator|->
name|fr_subtype
argument_list|)
argument_list|,
name|toofar
argument_list|)
expr_stmt|;
name|length
operator|=
literal|4
expr_stmt|;
if|if
condition|(
name|toofar
condition|)
block|{
if|if
condition|(
name|fragp
condition|?
name|RELAX_BRANCH_LIKELY
argument_list|(
name|fragp
operator|->
name|fr_subtype
argument_list|)
else|:
operator|(
name|update
operator|>
literal|0
operator|)
condition|)
name|length
operator|+=
literal|8
expr_stmt|;
if|if
condition|(
name|mips_pic
operator|!=
name|NO_PIC
condition|)
block|{
comment|/* Additional space for PIC loading of target address.  */
name|length
operator|+=
literal|8
expr_stmt|;
if|if
condition|(
name|mips_opts
operator|.
name|isa
operator|==
name|ISA_MIPS1
condition|)
comment|/* Additional space for $at-stabilizing nop.  */
name|length
operator|+=
literal|4
expr_stmt|;
block|}
comment|/* If branch is conditional.  */
if|if
condition|(
name|fragp
condition|?
operator|!
name|RELAX_BRANCH_UNCOND
argument_list|(
name|fragp
operator|->
name|fr_subtype
argument_list|)
else|:
operator|(
name|update
operator|>=
literal|0
operator|)
condition|)
name|length
operator|+=
literal|8
expr_stmt|;
block|}
return|return
name|length
return|;
block|}
end_function

begin_comment
comment|/* Estimate the size of a frag before relaxing.  Unless this is the    mips16, we are not really relaxing here, and the final size is    encoded in the subtype information.  For the mips16, we have to    decide whether we are using an extended opcode or not.  */
end_comment

begin_function
name|int
name|md_estimate_size_before_relax
parameter_list|(
name|fragS
modifier|*
name|fragp
parameter_list|,
name|asection
modifier|*
name|segtype
parameter_list|)
block|{
name|int
name|change
decl_stmt|;
if|if
condition|(
name|RELAX_BRANCH_P
argument_list|(
name|fragp
operator|->
name|fr_subtype
argument_list|)
condition|)
block|{
name|fragp
operator|->
name|fr_var
operator|=
name|relaxed_branch_length
argument_list|(
name|fragp
argument_list|,
name|segtype
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
return|return
name|fragp
operator|->
name|fr_var
return|;
block|}
if|if
condition|(
name|RELAX_MIPS16_P
argument_list|(
name|fragp
operator|->
name|fr_subtype
argument_list|)
condition|)
comment|/* We don't want to modify the EXTENDED bit here; it might get us        into infinite loops.  We change it only in mips_relax_frag().  */
return|return
operator|(
name|RELAX_MIPS16_EXTENDED
argument_list|(
name|fragp
operator|->
name|fr_subtype
argument_list|)
condition|?
literal|4
else|:
literal|2
operator|)
return|;
if|if
condition|(
name|mips_pic
operator|==
name|NO_PIC
condition|)
name|change
operator|=
name|nopic_need_relax
argument_list|(
name|fragp
operator|->
name|fr_symbol
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|mips_pic
operator|==
name|SVR4_PIC
condition|)
name|change
operator|=
name|pic_need_relax
argument_list|(
name|fragp
operator|->
name|fr_symbol
argument_list|,
name|segtype
argument_list|)
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|change
condition|)
block|{
name|fragp
operator|->
name|fr_subtype
operator||=
name|RELAX_USE_SECOND
expr_stmt|;
return|return
operator|-
name|RELAX_FIRST
argument_list|(
name|fragp
operator|->
name|fr_subtype
argument_list|)
return|;
block|}
else|else
return|return
operator|-
name|RELAX_SECOND
argument_list|(
name|fragp
operator|->
name|fr_subtype
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* This is called to see whether a reloc against a defined symbol    should be converted into a reloc against a section.  Don't adjust    MIPS16 jump relocations, so we don't have to worry about the format    of the offset in the .o file.  Don't adjust relocations against    mips16 symbols, so that the linker can find them if it needs to set    up a stub.  */
end_comment

begin_function
name|int
name|mips_fix_adjustable
parameter_list|(
name|fixS
modifier|*
name|fixp
parameter_list|)
block|{
if|if
condition|(
name|fixp
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_MIPS16_JMP
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|fixp
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_VTABLE_INHERIT
operator|||
name|fixp
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_VTABLE_ENTRY
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|fixp
operator|->
name|fx_addsy
operator|==
name|NULL
condition|)
return|return
literal|1
return|;
ifdef|#
directive|ifdef
name|OBJ_ELF
if|if
condition|(
name|OUTPUT_FLAVOR
operator|==
name|bfd_target_elf_flavour
operator|&&
name|S_GET_OTHER
argument_list|(
name|fixp
operator|->
name|fx_addsy
argument_list|)
operator|==
name|STO_MIPS16
operator|&&
name|fixp
operator|->
name|fx_subsy
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
endif|#
directive|endif
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Translate internal representation of relocation info to BFD target    format.  */
end_comment

begin_function
name|arelent
modifier|*
modifier|*
name|tc_gen_reloc
parameter_list|(
name|asection
modifier|*
name|section
name|ATTRIBUTE_UNUSED
parameter_list|,
name|fixS
modifier|*
name|fixp
parameter_list|)
block|{
specifier|static
name|arelent
modifier|*
name|retval
index|[
literal|4
index|]
decl_stmt|;
name|arelent
modifier|*
name|reloc
decl_stmt|;
name|bfd_reloc_code_real_type
name|code
decl_stmt|;
name|memset
argument_list|(
name|retval
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|retval
argument_list|)
argument_list|)
expr_stmt|;
name|reloc
operator|=
name|retval
index|[
literal|0
index|]
operator|=
operator|(
name|arelent
operator|*
operator|)
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|arelent
argument_list|)
argument_list|)
expr_stmt|;
name|reloc
operator|->
name|sym_ptr_ptr
operator|=
operator|(
name|asymbol
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|asymbol
operator|*
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|reloc
operator|->
name|sym_ptr_ptr
operator|=
name|symbol_get_bfdsym
argument_list|(
name|fixp
operator|->
name|fx_addsy
argument_list|)
expr_stmt|;
name|reloc
operator|->
name|address
operator|=
name|fixp
operator|->
name|fx_frag
operator|->
name|fr_address
operator|+
name|fixp
operator|->
name|fx_where
expr_stmt|;
if|if
condition|(
name|mips_pic
operator|==
name|EMBEDDED_PIC
operator|&&
name|SWITCH_TABLE
argument_list|(
name|fixp
argument_list|)
condition|)
block|{
comment|/* For a switch table entry we use a special reloc.  The addend 	 is actually the difference between the reloc address and the 	 subtrahend.  */
name|reloc
operator|->
name|addend
operator|=
name|reloc
operator|->
name|address
operator|-
name|S_GET_VALUE
argument_list|(
name|fixp
operator|->
name|fx_subsy
argument_list|)
expr_stmt|;
if|if
condition|(
name|OUTPUT_FLAVOR
operator|!=
name|bfd_target_ecoff_flavour
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"Double check fx_r_type in tc-mips.c:tc_gen_reloc"
argument_list|)
argument_list|)
expr_stmt|;
name|fixp
operator|->
name|fx_r_type
operator|=
name|BFD_RELOC_GPREL32
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fixp
operator|->
name|fx_pcrel
condition|)
block|{
name|bfd_vma
name|pcrel_address
decl_stmt|;
comment|/* Set PCREL_ADDRESS to this relocation's "PC".  The PC for high 	 high-part relocs is the address of the low-part reloc.  */
if|if
condition|(
name|fixp
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_PCREL_HI16_S
condition|)
block|{
name|assert
argument_list|(
name|fixp
operator|->
name|fx_next
operator|!=
name|NULL
operator|&&
name|fixp
operator|->
name|fx_next
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_PCREL_LO16
argument_list|)
expr_stmt|;
name|pcrel_address
operator|=
operator|(
name|fixp
operator|->
name|fx_next
operator|->
name|fx_where
operator|+
name|fixp
operator|->
name|fx_next
operator|->
name|fx_frag
operator|->
name|fr_address
operator|)
expr_stmt|;
block|}
else|else
name|pcrel_address
operator|=
name|reloc
operator|->
name|address
expr_stmt|;
if|if
condition|(
name|OUTPUT_FLAVOR
operator|==
name|bfd_target_elf_flavour
condition|)
block|{
comment|/* At this point, fx_addnumber is "symbol offset - pcrel_address". 	     Relocations want only the symbol offset.  */
name|reloc
operator|->
name|addend
operator|=
name|fixp
operator|->
name|fx_addnumber
operator|+
name|pcrel_address
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fixp
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_PCREL_LO16
operator|||
name|fixp
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_PCREL_HI16_S
condition|)
block|{
comment|/* We use a special addend for an internal RELLO or RELHI reloc.  */
if|if
condition|(
name|symbol_section_p
argument_list|(
name|fixp
operator|->
name|fx_addsy
argument_list|)
condition|)
name|reloc
operator|->
name|addend
operator|=
name|pcrel_address
operator|-
name|S_GET_VALUE
argument_list|(
name|fixp
operator|->
name|fx_subsy
argument_list|)
expr_stmt|;
else|else
name|reloc
operator|->
name|addend
operator|=
name|fixp
operator|->
name|fx_addnumber
operator|+
name|pcrel_address
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|OUTPUT_FLAVOR
operator|!=
name|bfd_target_aout_flavour
condition|)
comment|/* A gruesome hack which is a result of the gruesome gas reloc 	       handling.  */
name|reloc
operator|->
name|addend
operator|=
name|pcrel_address
expr_stmt|;
else|else
name|reloc
operator|->
name|addend
operator|=
operator|-
name|pcrel_address
expr_stmt|;
block|}
block|}
else|else
name|reloc
operator|->
name|addend
operator|=
name|fixp
operator|->
name|fx_addnumber
expr_stmt|;
comment|/* Since the old MIPS ELF ABI uses Rel instead of Rela, encode the vtable      entry to be used in the relocation's section offset.  */
if|if
condition|(
operator|!
name|HAVE_NEWABI
operator|&&
name|fixp
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_VTABLE_ENTRY
condition|)
block|{
name|reloc
operator|->
name|address
operator|=
name|reloc
operator|->
name|addend
expr_stmt|;
name|reloc
operator|->
name|addend
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Since DIFF_EXPR_OK is defined in tc-mips.h, it is possible that      fixup_segment converted a non-PC relative reloc into a PC      relative reloc.  In such a case, we need to convert the reloc      code.  */
name|code
operator|=
name|fixp
operator|->
name|fx_r_type
expr_stmt|;
if|if
condition|(
name|fixp
operator|->
name|fx_pcrel
condition|)
block|{
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|BFD_RELOC_8
case|:
name|code
operator|=
name|BFD_RELOC_8_PCREL
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_16
case|:
name|code
operator|=
name|BFD_RELOC_16_PCREL
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_32
case|:
name|code
operator|=
name|BFD_RELOC_32_PCREL
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_64
case|:
name|code
operator|=
name|BFD_RELOC_64_PCREL
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_8_PCREL
case|:
case|case
name|BFD_RELOC_16_PCREL
case|:
case|case
name|BFD_RELOC_32_PCREL
case|:
case|case
name|BFD_RELOC_64_PCREL
case|:
case|case
name|BFD_RELOC_16_PCREL_S2
case|:
case|case
name|BFD_RELOC_PCREL_HI16_S
case|:
case|case
name|BFD_RELOC_PCREL_LO16
case|:
break|break;
default|default:
name|as_bad_where
argument_list|(
name|fixp
operator|->
name|fx_file
argument_list|,
name|fixp
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"Cannot make %s relocation PC relative"
argument_list|)
argument_list|,
name|bfd_get_reloc_code_name
argument_list|(
name|code
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* To support a PC relative reloc when generating embedded PIC code      for ECOFF, we use a Cygnus extension.  We check for that here to      make sure that we don't let such a reloc escape normally.  */
if|if
condition|(
operator|(
name|OUTPUT_FLAVOR
operator|==
name|bfd_target_ecoff_flavour
operator|||
name|OUTPUT_FLAVOR
operator|==
name|bfd_target_elf_flavour
operator|)
operator|&&
name|code
operator|==
name|BFD_RELOC_16_PCREL_S2
operator|&&
name|mips_pic
operator|!=
name|EMBEDDED_PIC
condition|)
name|reloc
operator|->
name|howto
operator|=
name|NULL
expr_stmt|;
else|else
name|reloc
operator|->
name|howto
operator|=
name|bfd_reloc_type_lookup
argument_list|(
name|stdoutput
argument_list|,
name|code
argument_list|)
expr_stmt|;
if|if
condition|(
name|reloc
operator|->
name|howto
operator|==
name|NULL
condition|)
block|{
name|as_bad_where
argument_list|(
name|fixp
operator|->
name|fx_file
argument_list|,
name|fixp
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"Can not represent %s relocation in this object file format"
argument_list|)
argument_list|,
name|bfd_get_reloc_code_name
argument_list|(
name|code
argument_list|)
argument_list|)
expr_stmt|;
name|retval
index|[
literal|0
index|]
operator|=
name|NULL
expr_stmt|;
block|}
return|return
name|retval
return|;
block|}
end_function

begin_comment
comment|/* Relax a machine dependent frag.  This returns the amount by which    the current size of the frag should change.  */
end_comment

begin_function
name|int
name|mips_relax_frag
parameter_list|(
name|asection
modifier|*
name|sec
parameter_list|,
name|fragS
modifier|*
name|fragp
parameter_list|,
name|long
name|stretch
parameter_list|)
block|{
if|if
condition|(
name|RELAX_BRANCH_P
argument_list|(
name|fragp
operator|->
name|fr_subtype
argument_list|)
condition|)
block|{
name|offsetT
name|old_var
init|=
name|fragp
operator|->
name|fr_var
decl_stmt|;
name|fragp
operator|->
name|fr_var
operator|=
name|relaxed_branch_length
argument_list|(
name|fragp
argument_list|,
name|sec
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
return|return
name|fragp
operator|->
name|fr_var
operator|-
name|old_var
return|;
block|}
if|if
condition|(
operator|!
name|RELAX_MIPS16_P
argument_list|(
name|fragp
operator|->
name|fr_subtype
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|mips16_extended_frag
argument_list|(
name|fragp
argument_list|,
name|NULL
argument_list|,
name|stretch
argument_list|)
condition|)
block|{
if|if
condition|(
name|RELAX_MIPS16_EXTENDED
argument_list|(
name|fragp
operator|->
name|fr_subtype
argument_list|)
condition|)
return|return
literal|0
return|;
name|fragp
operator|->
name|fr_subtype
operator|=
name|RELAX_MIPS16_MARK_EXTENDED
argument_list|(
name|fragp
operator|->
name|fr_subtype
argument_list|)
expr_stmt|;
return|return
literal|2
return|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|RELAX_MIPS16_EXTENDED
argument_list|(
name|fragp
operator|->
name|fr_subtype
argument_list|)
condition|)
return|return
literal|0
return|;
name|fragp
operator|->
name|fr_subtype
operator|=
name|RELAX_MIPS16_CLEAR_EXTENDED
argument_list|(
name|fragp
operator|->
name|fr_subtype
argument_list|)
expr_stmt|;
return|return
operator|-
literal|2
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Convert a machine dependent frag.  */
end_comment

begin_function
name|void
name|md_convert_frag
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|segT
name|asec
parameter_list|,
name|fragS
modifier|*
name|fragp
parameter_list|)
block|{
if|if
condition|(
name|RELAX_BRANCH_P
argument_list|(
name|fragp
operator|->
name|fr_subtype
argument_list|)
condition|)
block|{
name|bfd_byte
modifier|*
name|buf
decl_stmt|;
name|unsigned
name|long
name|insn
decl_stmt|;
name|expressionS
name|exp
decl_stmt|;
name|fixS
modifier|*
name|fixp
decl_stmt|;
name|buf
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|fragp
operator|->
name|fr_literal
operator|+
name|fragp
operator|->
name|fr_fix
expr_stmt|;
if|if
condition|(
name|target_big_endian
condition|)
name|insn
operator|=
name|bfd_getb32
argument_list|(
name|buf
argument_list|)
expr_stmt|;
else|else
name|insn
operator|=
name|bfd_getl32
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|RELAX_BRANCH_TOOFAR
argument_list|(
name|fragp
operator|->
name|fr_subtype
argument_list|)
condition|)
block|{
comment|/* We generate a fixup instead of applying it right now 	     because, if there are linker relaxations, we're going to 	     need the relocations.  */
name|exp
operator|.
name|X_op
operator|=
name|O_symbol
expr_stmt|;
name|exp
operator|.
name|X_add_symbol
operator|=
name|fragp
operator|->
name|fr_symbol
expr_stmt|;
name|exp
operator|.
name|X_add_number
operator|=
name|fragp
operator|->
name|fr_offset
expr_stmt|;
name|fixp
operator|=
name|fix_new_exp
argument_list|(
name|fragp
argument_list|,
name|buf
operator|-
operator|(
name|bfd_byte
operator|*
operator|)
name|fragp
operator|->
name|fr_literal
argument_list|,
literal|4
argument_list|,
operator|&
name|exp
argument_list|,
literal|1
argument_list|,
name|BFD_RELOC_16_PCREL_S2
argument_list|)
expr_stmt|;
name|fixp
operator|->
name|fx_file
operator|=
name|fragp
operator|->
name|fr_file
expr_stmt|;
name|fixp
operator|->
name|fx_line
operator|=
name|fragp
operator|->
name|fr_line
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|buf
argument_list|,
name|insn
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|buf
operator|+=
literal|4
expr_stmt|;
block|}
else|else
block|{
name|int
name|i
decl_stmt|;
name|as_warn_where
argument_list|(
name|fragp
operator|->
name|fr_file
argument_list|,
name|fragp
operator|->
name|fr_line
argument_list|,
name|_
argument_list|(
literal|"relaxed out-of-range branch into a jump"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|RELAX_BRANCH_UNCOND
argument_list|(
name|fragp
operator|->
name|fr_subtype
argument_list|)
condition|)
goto|goto
name|uncond
goto|;
if|if
condition|(
operator|!
name|RELAX_BRANCH_LIKELY
argument_list|(
name|fragp
operator|->
name|fr_subtype
argument_list|)
condition|)
block|{
comment|/* Reverse the branch.  */
switch|switch
condition|(
operator|(
name|insn
operator|>>
literal|28
operator|)
operator|&
literal|0xf
condition|)
block|{
case|case
literal|4
case|:
comment|/* bc[0-3][tf]l? and bc1any[24][ft] instructions can 		     have the condition reversed by tweaking a single 		     bit, and their opcodes all have 0x4???????.  */
name|assert
argument_list|(
operator|(
name|insn
operator|&
literal|0xf1000000
operator|)
operator|==
literal|0x41000000
argument_list|)
expr_stmt|;
name|insn
operator|^=
literal|0x00010000
expr_stmt|;
break|break;
case|case
literal|0
case|:
comment|/* bltz	0x04000000	bgez	0x04010000 		     bltzal	0x04100000	bgezal	0x04110000 */
name|assert
argument_list|(
operator|(
name|insn
operator|&
literal|0xfc0e0000
operator|)
operator|==
literal|0x04000000
argument_list|)
expr_stmt|;
name|insn
operator|^=
literal|0x00010000
expr_stmt|;
break|break;
case|case
literal|1
case|:
comment|/* beq	0x10000000	bne	0x14000000 		     blez	0x18000000	bgtz	0x1c000000 */
name|insn
operator|^=
literal|0x04000000
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|RELAX_BRANCH_LINK
argument_list|(
name|fragp
operator|->
name|fr_subtype
argument_list|)
condition|)
block|{
comment|/* Clear the and-link bit.  */
name|assert
argument_list|(
operator|(
name|insn
operator|&
literal|0xfc1c0000
operator|)
operator|==
literal|0x04100000
argument_list|)
expr_stmt|;
comment|/* bltzal	0x04100000	bgezal	0x04110000 		bltzall	0x04120000     bgezall	0x04130000 */
name|insn
operator|&=
operator|~
literal|0x00100000
expr_stmt|;
block|}
comment|/* Branch over the branch (if the branch was likely) or the 	     full jump (not likely case).  Compute the offset from the 	     current instruction to branch to.  */
if|if
condition|(
name|RELAX_BRANCH_LIKELY
argument_list|(
name|fragp
operator|->
name|fr_subtype
argument_list|)
condition|)
name|i
operator|=
literal|16
expr_stmt|;
else|else
block|{
comment|/* How many bytes in instructions we've already emitted?  */
name|i
operator|=
name|buf
operator|-
operator|(
name|bfd_byte
operator|*
operator|)
name|fragp
operator|->
name|fr_literal
operator|-
name|fragp
operator|->
name|fr_fix
expr_stmt|;
comment|/* How many bytes in instructions from here to the end?  */
name|i
operator|=
name|fragp
operator|->
name|fr_var
operator|-
name|i
expr_stmt|;
block|}
comment|/* Convert to instruction count.  */
name|i
operator|>>=
literal|2
expr_stmt|;
comment|/* Branch counts from the next instruction.  */
name|i
operator|--
expr_stmt|;
name|insn
operator||=
name|i
expr_stmt|;
comment|/* Branch over the jump.  */
name|md_number_to_chars
argument_list|(
name|buf
argument_list|,
name|insn
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|buf
operator|+=
literal|4
expr_stmt|;
comment|/* Nop */
name|md_number_to_chars
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|buf
operator|+=
literal|4
expr_stmt|;
if|if
condition|(
name|RELAX_BRANCH_LIKELY
argument_list|(
name|fragp
operator|->
name|fr_subtype
argument_list|)
condition|)
block|{
comment|/* beql $0, $0, 2f */
name|insn
operator|=
literal|0x50000000
expr_stmt|;
comment|/* Compute the PC offset from the current instruction to 		 the end of the variable frag.  */
comment|/* How many bytes in instructions we've already emitted?  */
name|i
operator|=
name|buf
operator|-
operator|(
name|bfd_byte
operator|*
operator|)
name|fragp
operator|->
name|fr_literal
operator|-
name|fragp
operator|->
name|fr_fix
expr_stmt|;
comment|/* How many bytes in instructions from here to the end?  */
name|i
operator|=
name|fragp
operator|->
name|fr_var
operator|-
name|i
expr_stmt|;
comment|/* Convert to instruction count.  */
name|i
operator|>>=
literal|2
expr_stmt|;
comment|/* Don't decrement i, because we want to branch over the 		 delay slot.  */
name|insn
operator||=
name|i
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|buf
argument_list|,
name|insn
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|buf
operator|+=
literal|4
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|buf
operator|+=
literal|4
expr_stmt|;
block|}
name|uncond
label|:
if|if
condition|(
name|mips_pic
operator|==
name|NO_PIC
condition|)
block|{
comment|/* j or jal.  */
name|insn
operator|=
operator|(
name|RELAX_BRANCH_LINK
argument_list|(
name|fragp
operator|->
name|fr_subtype
argument_list|)
condition|?
literal|0x0c000000
else|:
literal|0x08000000
operator|)
expr_stmt|;
name|exp
operator|.
name|X_op
operator|=
name|O_symbol
expr_stmt|;
name|exp
operator|.
name|X_add_symbol
operator|=
name|fragp
operator|->
name|fr_symbol
expr_stmt|;
name|exp
operator|.
name|X_add_number
operator|=
name|fragp
operator|->
name|fr_offset
expr_stmt|;
name|fixp
operator|=
name|fix_new_exp
argument_list|(
name|fragp
argument_list|,
name|buf
operator|-
operator|(
name|bfd_byte
operator|*
operator|)
name|fragp
operator|->
name|fr_literal
argument_list|,
literal|4
argument_list|,
operator|&
name|exp
argument_list|,
literal|0
argument_list|,
name|BFD_RELOC_MIPS_JMP
argument_list|)
expr_stmt|;
name|fixp
operator|->
name|fx_file
operator|=
name|fragp
operator|->
name|fr_file
expr_stmt|;
name|fixp
operator|->
name|fx_line
operator|=
name|fragp
operator|->
name|fr_line
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|buf
argument_list|,
name|insn
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|buf
operator|+=
literal|4
expr_stmt|;
block|}
else|else
block|{
comment|/* lw/ld $at,<sym>($gp)  R_MIPS_GOT16 */
name|insn
operator|=
name|HAVE_64BIT_ADDRESSES
condition|?
literal|0xdf810000
else|:
literal|0x8f810000
expr_stmt|;
name|exp
operator|.
name|X_op
operator|=
name|O_symbol
expr_stmt|;
name|exp
operator|.
name|X_add_symbol
operator|=
name|fragp
operator|->
name|fr_symbol
expr_stmt|;
name|exp
operator|.
name|X_add_number
operator|=
name|fragp
operator|->
name|fr_offset
expr_stmt|;
if|if
condition|(
name|fragp
operator|->
name|fr_offset
condition|)
block|{
name|exp
operator|.
name|X_add_symbol
operator|=
name|make_expr_symbol
argument_list|(
operator|&
name|exp
argument_list|)
expr_stmt|;
name|exp
operator|.
name|X_add_number
operator|=
literal|0
expr_stmt|;
block|}
name|fixp
operator|=
name|fix_new_exp
argument_list|(
name|fragp
argument_list|,
name|buf
operator|-
operator|(
name|bfd_byte
operator|*
operator|)
name|fragp
operator|->
name|fr_literal
argument_list|,
literal|4
argument_list|,
operator|&
name|exp
argument_list|,
literal|0
argument_list|,
name|BFD_RELOC_MIPS_GOT16
argument_list|)
expr_stmt|;
name|fixp
operator|->
name|fx_file
operator|=
name|fragp
operator|->
name|fr_file
expr_stmt|;
name|fixp
operator|->
name|fx_line
operator|=
name|fragp
operator|->
name|fr_line
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|buf
argument_list|,
name|insn
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|buf
operator|+=
literal|4
expr_stmt|;
if|if
condition|(
name|mips_opts
operator|.
name|isa
operator|==
name|ISA_MIPS1
condition|)
block|{
comment|/* nop */
name|md_number_to_chars
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|buf
operator|+=
literal|4
expr_stmt|;
block|}
comment|/* d/addiu $at, $at,<sym>  R_MIPS_LO16 */
name|insn
operator|=
name|HAVE_64BIT_ADDRESSES
condition|?
literal|0x64210000
else|:
literal|0x24210000
expr_stmt|;
name|fixp
operator|=
name|fix_new_exp
argument_list|(
name|fragp
argument_list|,
name|buf
operator|-
operator|(
name|bfd_byte
operator|*
operator|)
name|fragp
operator|->
name|fr_literal
argument_list|,
literal|4
argument_list|,
operator|&
name|exp
argument_list|,
literal|0
argument_list|,
name|BFD_RELOC_LO16
argument_list|)
expr_stmt|;
name|fixp
operator|->
name|fx_file
operator|=
name|fragp
operator|->
name|fr_file
expr_stmt|;
name|fixp
operator|->
name|fx_line
operator|=
name|fragp
operator|->
name|fr_line
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|buf
argument_list|,
name|insn
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|buf
operator|+=
literal|4
expr_stmt|;
comment|/* j(al)r $at.  */
if|if
condition|(
name|RELAX_BRANCH_LINK
argument_list|(
name|fragp
operator|->
name|fr_subtype
argument_list|)
condition|)
name|insn
operator|=
literal|0x0020f809
expr_stmt|;
else|else
name|insn
operator|=
literal|0x00200008
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|buf
argument_list|,
name|insn
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|buf
operator|+=
literal|4
expr_stmt|;
block|}
block|}
name|assert
argument_list|(
name|buf
operator|==
operator|(
name|bfd_byte
operator|*
operator|)
name|fragp
operator|->
name|fr_literal
operator|+
name|fragp
operator|->
name|fr_fix
operator|+
name|fragp
operator|->
name|fr_var
argument_list|)
expr_stmt|;
name|fragp
operator|->
name|fr_fix
operator|+=
name|fragp
operator|->
name|fr_var
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|RELAX_MIPS16_P
argument_list|(
name|fragp
operator|->
name|fr_subtype
argument_list|)
condition|)
block|{
name|int
name|type
decl_stmt|;
specifier|register
specifier|const
name|struct
name|mips16_immed_operand
modifier|*
name|op
decl_stmt|;
name|bfd_boolean
name|small
decl_stmt|,
name|ext
decl_stmt|;
name|offsetT
name|val
decl_stmt|;
name|bfd_byte
modifier|*
name|buf
decl_stmt|;
name|unsigned
name|long
name|insn
decl_stmt|;
name|bfd_boolean
name|use_extend
decl_stmt|;
name|unsigned
name|short
name|extend
decl_stmt|;
name|type
operator|=
name|RELAX_MIPS16_TYPE
argument_list|(
name|fragp
operator|->
name|fr_subtype
argument_list|)
expr_stmt|;
name|op
operator|=
name|mips16_immed_operands
expr_stmt|;
while|while
condition|(
name|op
operator|->
name|type
operator|!=
name|type
condition|)
operator|++
name|op
expr_stmt|;
if|if
condition|(
name|RELAX_MIPS16_EXTENDED
argument_list|(
name|fragp
operator|->
name|fr_subtype
argument_list|)
condition|)
block|{
name|small
operator|=
name|FALSE
expr_stmt|;
name|ext
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
name|small
operator|=
name|TRUE
expr_stmt|;
name|ext
operator|=
name|FALSE
expr_stmt|;
block|}
name|resolve_symbol_value
argument_list|(
name|fragp
operator|->
name|fr_symbol
argument_list|)
expr_stmt|;
name|val
operator|=
name|S_GET_VALUE
argument_list|(
name|fragp
operator|->
name|fr_symbol
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|->
name|pcrel
condition|)
block|{
name|addressT
name|addr
decl_stmt|;
name|addr
operator|=
name|fragp
operator|->
name|fr_address
operator|+
name|fragp
operator|->
name|fr_fix
expr_stmt|;
comment|/* The rules for the base address of a PC relative reloc are              complicated; see mips16_extended_frag.  */
if|if
condition|(
name|type
operator|==
literal|'p'
operator|||
name|type
operator|==
literal|'q'
condition|)
block|{
name|addr
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|ext
condition|)
name|addr
operator|+=
literal|2
expr_stmt|;
comment|/* Ignore the low bit in the target, since it will be                  set for a text label.  */
if|if
condition|(
operator|(
name|val
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
operator|--
name|val
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|RELAX_MIPS16_JAL_DSLOT
argument_list|(
name|fragp
operator|->
name|fr_subtype
argument_list|)
condition|)
name|addr
operator|-=
literal|4
expr_stmt|;
elseif|else
if|if
condition|(
name|RELAX_MIPS16_DSLOT
argument_list|(
name|fragp
operator|->
name|fr_subtype
argument_list|)
condition|)
name|addr
operator|-=
literal|2
expr_stmt|;
name|addr
operator|&=
operator|~
call|(
name|addressT
call|)
argument_list|(
operator|(
literal|1
operator|<<
name|op
operator|->
name|shift
operator|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|val
operator|-=
name|addr
expr_stmt|;
comment|/* Make sure the section winds up with the alignment we have              assumed.  */
if|if
condition|(
name|op
operator|->
name|shift
operator|>
literal|0
condition|)
name|record_alignment
argument_list|(
name|asec
argument_list|,
name|op
operator|->
name|shift
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ext
operator|&&
operator|(
name|RELAX_MIPS16_JAL_DSLOT
argument_list|(
name|fragp
operator|->
name|fr_subtype
argument_list|)
operator|||
name|RELAX_MIPS16_DSLOT
argument_list|(
name|fragp
operator|->
name|fr_subtype
argument_list|)
operator|)
condition|)
name|as_warn_where
argument_list|(
name|fragp
operator|->
name|fr_file
argument_list|,
name|fragp
operator|->
name|fr_line
argument_list|,
name|_
argument_list|(
literal|"extended instruction in delay slot"
argument_list|)
argument_list|)
expr_stmt|;
name|buf
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
operator|(
name|fragp
operator|->
name|fr_literal
operator|+
name|fragp
operator|->
name|fr_fix
operator|)
expr_stmt|;
if|if
condition|(
name|target_big_endian
condition|)
name|insn
operator|=
name|bfd_getb16
argument_list|(
name|buf
argument_list|)
expr_stmt|;
else|else
name|insn
operator|=
name|bfd_getl16
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|mips16_immed
argument_list|(
name|fragp
operator|->
name|fr_file
argument_list|,
name|fragp
operator|->
name|fr_line
argument_list|,
name|type
argument_list|,
name|val
argument_list|,
name|RELAX_MIPS16_USER_EXT
argument_list|(
name|fragp
operator|->
name|fr_subtype
argument_list|)
argument_list|,
name|small
argument_list|,
name|ext
argument_list|,
operator|&
name|insn
argument_list|,
operator|&
name|use_extend
argument_list|,
operator|&
name|extend
argument_list|)
expr_stmt|;
if|if
condition|(
name|use_extend
condition|)
block|{
name|md_number_to_chars
argument_list|(
name|buf
argument_list|,
literal|0xf000
operator||
name|extend
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|fragp
operator|->
name|fr_fix
operator|+=
literal|2
expr_stmt|;
name|buf
operator|+=
literal|2
expr_stmt|;
block|}
name|md_number_to_chars
argument_list|(
name|buf
argument_list|,
name|insn
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|fragp
operator|->
name|fr_fix
operator|+=
literal|2
expr_stmt|;
name|buf
operator|+=
literal|2
expr_stmt|;
block|}
else|else
block|{
name|int
name|first
decl_stmt|,
name|second
decl_stmt|;
name|fixS
modifier|*
name|fixp
decl_stmt|;
name|first
operator|=
name|RELAX_FIRST
argument_list|(
name|fragp
operator|->
name|fr_subtype
argument_list|)
expr_stmt|;
name|second
operator|=
name|RELAX_SECOND
argument_list|(
name|fragp
operator|->
name|fr_subtype
argument_list|)
expr_stmt|;
name|fixp
operator|=
operator|(
name|fixS
operator|*
operator|)
name|fragp
operator|->
name|fr_opcode
expr_stmt|;
comment|/* Possibly emit a warning if we've chosen the longer option.  */
if|if
condition|(
operator|(
operator|(
name|fragp
operator|->
name|fr_subtype
operator|&
name|RELAX_USE_SECOND
operator|)
operator|!=
literal|0
operator|)
operator|==
operator|(
operator|(
name|fragp
operator|->
name|fr_subtype
operator|&
name|RELAX_SECOND_LONGER
operator|)
operator|!=
literal|0
operator|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|msg
init|=
name|macro_warning
argument_list|(
name|fragp
operator|->
name|fr_subtype
argument_list|)
decl_stmt|;
if|if
condition|(
name|msg
operator|!=
literal|0
condition|)
name|as_warn_where
argument_list|(
name|fragp
operator|->
name|fr_file
argument_list|,
name|fragp
operator|->
name|fr_line
argument_list|,
name|msg
argument_list|)
expr_stmt|;
block|}
comment|/* Go through all the fixups for the first sequence.  Disable them 	 (by marking them as done) if we're going to use the second 	 sequence instead.  */
while|while
condition|(
name|fixp
operator|&&
name|fixp
operator|->
name|fx_frag
operator|==
name|fragp
operator|&&
name|fixp
operator|->
name|fx_where
operator|<
name|fragp
operator|->
name|fr_fix
operator|-
name|second
condition|)
block|{
if|if
condition|(
name|fragp
operator|->
name|fr_subtype
operator|&
name|RELAX_USE_SECOND
condition|)
name|fixp
operator|->
name|fx_done
operator|=
literal|1
expr_stmt|;
name|fixp
operator|=
name|fixp
operator|->
name|fx_next
expr_stmt|;
block|}
comment|/* Go through the fixups for the second sequence.  Disable them if 	 we're going to use the first sequence, otherwise adjust their 	 addresses to account for the relaxation.  */
while|while
condition|(
name|fixp
operator|&&
name|fixp
operator|->
name|fx_frag
operator|==
name|fragp
condition|)
block|{
if|if
condition|(
name|fragp
operator|->
name|fr_subtype
operator|&
name|RELAX_USE_SECOND
condition|)
name|fixp
operator|->
name|fx_where
operator|-=
name|first
expr_stmt|;
else|else
name|fixp
operator|->
name|fx_done
operator|=
literal|1
expr_stmt|;
name|fixp
operator|=
name|fixp
operator|->
name|fx_next
expr_stmt|;
block|}
comment|/* Now modify the frag contents.  */
if|if
condition|(
name|fragp
operator|->
name|fr_subtype
operator|&
name|RELAX_USE_SECOND
condition|)
block|{
name|char
modifier|*
name|start
decl_stmt|;
name|start
operator|=
name|fragp
operator|->
name|fr_literal
operator|+
name|fragp
operator|->
name|fr_fix
operator|-
name|first
operator|-
name|second
expr_stmt|;
name|memmove
argument_list|(
name|start
argument_list|,
name|start
operator|+
name|first
argument_list|,
name|second
argument_list|)
expr_stmt|;
name|fragp
operator|->
name|fr_fix
operator|-=
name|first
expr_stmt|;
block|}
else|else
name|fragp
operator|->
name|fr_fix
operator|-=
name|second
expr_stmt|;
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|OBJ_ELF
end_ifdef

begin_comment
comment|/* This function is called after the relocs have been generated.    We've been storing mips16 text labels as odd.  Here we convert them    back to even for the convenience of the debugger.  */
end_comment

begin_function
name|void
name|mips_frob_file_after_relocs
parameter_list|(
name|void
parameter_list|)
block|{
name|asymbol
modifier|*
modifier|*
name|syms
decl_stmt|;
name|unsigned
name|int
name|count
decl_stmt|,
name|i
decl_stmt|;
if|if
condition|(
name|OUTPUT_FLAVOR
operator|!=
name|bfd_target_elf_flavour
condition|)
return|return;
name|syms
operator|=
name|bfd_get_outsymbols
argument_list|(
name|stdoutput
argument_list|)
expr_stmt|;
name|count
operator|=
name|bfd_get_symcount
argument_list|(
name|stdoutput
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
operator|,
name|syms
operator|++
control|)
block|{
if|if
condition|(
name|elf_symbol
argument_list|(
operator|*
name|syms
argument_list|)
operator|->
name|internal_elf_sym
operator|.
name|st_other
operator|==
name|STO_MIPS16
operator|&&
operator|(
operator|(
operator|*
name|syms
operator|)
operator|->
name|value
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
block|{
operator|(
operator|*
name|syms
operator|)
operator|->
name|value
operator|&=
operator|~
literal|1
expr_stmt|;
comment|/* If the symbol has an odd size, it was probably computed 	     incorrectly, so adjust that as well.  */
if|if
condition|(
operator|(
name|elf_symbol
argument_list|(
operator|*
name|syms
argument_list|)
operator|->
name|internal_elf_sym
operator|.
name|st_size
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
operator|++
name|elf_symbol
argument_list|(
operator|*
name|syms
argument_list|)
operator|->
name|internal_elf_sym
operator|.
name|st_size
expr_stmt|;
block|}
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* This function is called whenever a label is defined.  It is used    when handling branch delays; if a branch has a label, we assume we    can not move it.  */
end_comment

begin_function
name|void
name|mips_define_label
parameter_list|(
name|symbolS
modifier|*
name|sym
parameter_list|)
block|{
name|struct
name|insn_label_list
modifier|*
name|l
decl_stmt|;
if|if
condition|(
name|free_insn_labels
operator|==
name|NULL
condition|)
name|l
operator|=
operator|(
expr|struct
name|insn_label_list
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
expr|*
name|l
argument_list|)
expr_stmt|;
else|else
block|{
name|l
operator|=
name|free_insn_labels
expr_stmt|;
name|free_insn_labels
operator|=
name|l
operator|->
name|next
expr_stmt|;
block|}
name|l
operator|->
name|label
operator|=
name|sym
expr_stmt|;
name|l
operator|->
name|next
operator|=
name|insn_labels
expr_stmt|;
name|insn_labels
operator|=
name|l
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_if
if|#
directive|if
name|defined
argument_list|(
name|OBJ_ELF
argument_list|)
operator|||
name|defined
argument_list|(
name|OBJ_MAYBE_ELF
argument_list|)
end_if

begin_comment
comment|/* Some special processing for a MIPS ELF file.  */
end_comment

begin_function
name|void
name|mips_elf_final_processing
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* Write out the register information.  */
if|if
condition|(
name|mips_abi
operator|!=
name|N64_ABI
condition|)
block|{
name|Elf32_RegInfo
name|s
decl_stmt|;
name|s
operator|.
name|ri_gprmask
operator|=
name|mips_gprmask
expr_stmt|;
name|s
operator|.
name|ri_cprmask
index|[
literal|0
index|]
operator|=
name|mips_cprmask
index|[
literal|0
index|]
expr_stmt|;
name|s
operator|.
name|ri_cprmask
index|[
literal|1
index|]
operator|=
name|mips_cprmask
index|[
literal|1
index|]
expr_stmt|;
name|s
operator|.
name|ri_cprmask
index|[
literal|2
index|]
operator|=
name|mips_cprmask
index|[
literal|2
index|]
expr_stmt|;
name|s
operator|.
name|ri_cprmask
index|[
literal|3
index|]
operator|=
name|mips_cprmask
index|[
literal|3
index|]
expr_stmt|;
comment|/* The gp_value field is set by the MIPS ELF backend.  */
name|bfd_mips_elf32_swap_reginfo_out
argument_list|(
name|stdoutput
argument_list|,
operator|&
name|s
argument_list|,
operator|(
operator|(
name|Elf32_External_RegInfo
operator|*
operator|)
name|mips_regmask_frag
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Elf64_Internal_RegInfo
name|s
decl_stmt|;
name|s
operator|.
name|ri_gprmask
operator|=
name|mips_gprmask
expr_stmt|;
name|s
operator|.
name|ri_pad
operator|=
literal|0
expr_stmt|;
name|s
operator|.
name|ri_cprmask
index|[
literal|0
index|]
operator|=
name|mips_cprmask
index|[
literal|0
index|]
expr_stmt|;
name|s
operator|.
name|ri_cprmask
index|[
literal|1
index|]
operator|=
name|mips_cprmask
index|[
literal|1
index|]
expr_stmt|;
name|s
operator|.
name|ri_cprmask
index|[
literal|2
index|]
operator|=
name|mips_cprmask
index|[
literal|2
index|]
expr_stmt|;
name|s
operator|.
name|ri_cprmask
index|[
literal|3
index|]
operator|=
name|mips_cprmask
index|[
literal|3
index|]
expr_stmt|;
comment|/* The gp_value field is set by the MIPS ELF backend.  */
name|bfd_mips_elf64_swap_reginfo_out
argument_list|(
name|stdoutput
argument_list|,
operator|&
name|s
argument_list|,
operator|(
operator|(
name|Elf64_External_RegInfo
operator|*
operator|)
name|mips_regmask_frag
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* Set the MIPS ELF flag bits.  FIXME: There should probably be some      sort of BFD interface for this.  */
if|if
condition|(
name|mips_any_noreorder
condition|)
name|elf_elfheader
argument_list|(
name|stdoutput
argument_list|)
operator|->
name|e_flags
operator||=
name|EF_MIPS_NOREORDER
expr_stmt|;
if|if
condition|(
name|mips_pic
operator|!=
name|NO_PIC
condition|)
block|{
name|elf_elfheader
argument_list|(
name|stdoutput
argument_list|)
operator|->
name|e_flags
operator||=
name|EF_MIPS_PIC
expr_stmt|;
name|elf_elfheader
argument_list|(
name|stdoutput
argument_list|)
operator|->
name|e_flags
operator||=
name|EF_MIPS_CPIC
expr_stmt|;
block|}
if|if
condition|(
name|mips_abicalls
condition|)
name|elf_elfheader
argument_list|(
name|stdoutput
argument_list|)
operator|->
name|e_flags
operator||=
name|EF_MIPS_CPIC
expr_stmt|;
comment|/* Set MIPS ELF flags for ASEs.  */
if|if
condition|(
name|file_ase_mips16
condition|)
name|elf_elfheader
argument_list|(
name|stdoutput
argument_list|)
operator|->
name|e_flags
operator||=
name|EF_MIPS_ARCH_ASE_M16
expr_stmt|;
if|#
directive|if
literal|0
comment|/* XXX FIXME */
block|if (file_ase_mips3d)     elf_elfheader (stdoutput)->e_flags |= ???;
endif|#
directive|endif
if|if
condition|(
name|file_ase_mdmx
condition|)
name|elf_elfheader
argument_list|(
name|stdoutput
argument_list|)
operator|->
name|e_flags
operator||=
name|EF_MIPS_ARCH_ASE_MDMX
expr_stmt|;
comment|/* Set the MIPS ELF ABI flags.  */
if|if
condition|(
name|mips_abi
operator|==
name|O32_ABI
operator|&&
name|USE_E_MIPS_ABI_O32
condition|)
name|elf_elfheader
argument_list|(
name|stdoutput
argument_list|)
operator|->
name|e_flags
operator||=
name|E_MIPS_ABI_O32
expr_stmt|;
elseif|else
if|if
condition|(
name|mips_abi
operator|==
name|O64_ABI
condition|)
name|elf_elfheader
argument_list|(
name|stdoutput
argument_list|)
operator|->
name|e_flags
operator||=
name|E_MIPS_ABI_O64
expr_stmt|;
elseif|else
if|if
condition|(
name|mips_abi
operator|==
name|EABI_ABI
condition|)
block|{
if|if
condition|(
operator|!
name|file_mips_gp32
condition|)
name|elf_elfheader
argument_list|(
name|stdoutput
argument_list|)
operator|->
name|e_flags
operator||=
name|E_MIPS_ABI_EABI64
expr_stmt|;
else|else
name|elf_elfheader
argument_list|(
name|stdoutput
argument_list|)
operator|->
name|e_flags
operator||=
name|E_MIPS_ABI_EABI32
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mips_abi
operator|==
name|N32_ABI
condition|)
name|elf_elfheader
argument_list|(
name|stdoutput
argument_list|)
operator|->
name|e_flags
operator||=
name|EF_MIPS_ABI2
expr_stmt|;
comment|/* Nothing to do for N64_ABI.  */
if|if
condition|(
name|mips_32bitmode
condition|)
name|elf_elfheader
argument_list|(
name|stdoutput
argument_list|)
operator|->
name|e_flags
operator||=
name|EF_MIPS_32BITMODE
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* OBJ_ELF || OBJ_MAYBE_ELF */
end_comment

begin_escape
end_escape

begin_typedef
typedef|typedef
struct|struct
name|proc
block|{
name|symbolS
modifier|*
name|isym
decl_stmt|;
name|unsigned
name|long
name|reg_mask
decl_stmt|;
name|unsigned
name|long
name|reg_offset
decl_stmt|;
name|unsigned
name|long
name|fpreg_mask
decl_stmt|;
name|unsigned
name|long
name|fpreg_offset
decl_stmt|;
name|unsigned
name|long
name|frame_offset
decl_stmt|;
name|unsigned
name|long
name|frame_reg
decl_stmt|;
name|unsigned
name|long
name|pc_reg
decl_stmt|;
block|}
name|procS
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|procS
name|cur_proc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|procS
modifier|*
name|cur_proc_ptr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|numprocs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Fill in an rs_align_code fragment.  */
end_comment

begin_function
name|void
name|mips_handle_align
parameter_list|(
name|fragS
modifier|*
name|fragp
parameter_list|)
block|{
if|if
condition|(
name|fragp
operator|->
name|fr_type
operator|!=
name|rs_align_code
condition|)
return|return;
if|if
condition|(
name|mips_opts
operator|.
name|mips16
condition|)
block|{
specifier|static
specifier|const
name|unsigned
name|char
name|be_nop
index|[]
init|=
block|{
literal|0x65
block|,
literal|0x00
block|}
decl_stmt|;
specifier|static
specifier|const
name|unsigned
name|char
name|le_nop
index|[]
init|=
block|{
literal|0x00
block|,
literal|0x65
block|}
decl_stmt|;
name|int
name|bytes
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|bytes
operator|=
name|fragp
operator|->
name|fr_next
operator|->
name|fr_address
operator|-
name|fragp
operator|->
name|fr_address
operator|-
name|fragp
operator|->
name|fr_fix
expr_stmt|;
name|p
operator|=
name|fragp
operator|->
name|fr_literal
operator|+
name|fragp
operator|->
name|fr_fix
expr_stmt|;
if|if
condition|(
name|bytes
operator|&
literal|1
condition|)
block|{
operator|*
name|p
operator|++
operator|=
literal|0
expr_stmt|;
name|fragp
operator|->
name|fr_fix
operator|++
expr_stmt|;
block|}
name|memcpy
argument_list|(
name|p
argument_list|,
operator|(
name|target_big_endian
condition|?
name|be_nop
else|:
name|le_nop
operator|)
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|fragp
operator|->
name|fr_var
operator|=
literal|2
expr_stmt|;
block|}
comment|/* For mips32, a nop is a zero, which we trivially get by doing nothing.  */
block|}
end_function

begin_function
specifier|static
name|void
name|md_obj_begin
parameter_list|(
name|void
parameter_list|)
block|{ }
end_function

begin_function
specifier|static
name|void
name|md_obj_end
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* check for premature end, nesting errors, etc */
if|if
condition|(
name|cur_proc_ptr
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"missing .end at end of assembly"
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|long
name|get_number
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|negative
init|=
literal|0
decl_stmt|;
name|long
name|val
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|'-'
condition|)
block|{
operator|++
name|input_line_pointer
expr_stmt|;
name|negative
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|ISDIGIT
argument_list|(
operator|*
name|input_line_pointer
argument_list|)
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"expected simple number"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|input_line_pointer
index|[
literal|0
index|]
operator|==
literal|'0'
condition|)
block|{
if|if
condition|(
name|input_line_pointer
index|[
literal|1
index|]
operator|==
literal|'x'
condition|)
block|{
name|input_line_pointer
operator|+=
literal|2
expr_stmt|;
while|while
condition|(
name|ISXDIGIT
argument_list|(
operator|*
name|input_line_pointer
argument_list|)
condition|)
block|{
name|val
operator|<<=
literal|4
expr_stmt|;
name|val
operator||=
name|hex_value
argument_list|(
operator|*
name|input_line_pointer
operator|++
argument_list|)
expr_stmt|;
block|}
return|return
name|negative
condition|?
operator|-
name|val
else|:
name|val
return|;
block|}
else|else
block|{
operator|++
name|input_line_pointer
expr_stmt|;
while|while
condition|(
name|ISDIGIT
argument_list|(
operator|*
name|input_line_pointer
argument_list|)
condition|)
block|{
name|val
operator|<<=
literal|3
expr_stmt|;
name|val
operator||=
operator|*
name|input_line_pointer
operator|++
operator|-
literal|'0'
expr_stmt|;
block|}
return|return
name|negative
condition|?
operator|-
name|val
else|:
name|val
return|;
block|}
block|}
if|if
condition|(
operator|!
name|ISDIGIT
argument_list|(
operator|*
name|input_line_pointer
argument_list|)
condition|)
block|{
name|printf
argument_list|(
name|_
argument_list|(
literal|" *input_line_pointer == '%c' 0x%02x\n"
argument_list|)
argument_list|,
operator|*
name|input_line_pointer
argument_list|,
operator|*
name|input_line_pointer
argument_list|)
expr_stmt|;
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"invalid number"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
while|while
condition|(
name|ISDIGIT
argument_list|(
operator|*
name|input_line_pointer
argument_list|)
condition|)
block|{
name|val
operator|*=
literal|10
expr_stmt|;
name|val
operator|+=
operator|*
name|input_line_pointer
operator|++
operator|-
literal|'0'
expr_stmt|;
block|}
return|return
name|negative
condition|?
operator|-
name|val
else|:
name|val
return|;
block|}
end_function

begin_comment
comment|/* The .file directive; just like the usual .file directive, but there    is an initial number which is the ECOFF file index.  In the non-ECOFF    case .file implies DWARF-2.  */
end_comment

begin_function
specifier|static
name|void
name|s_mips_file
parameter_list|(
name|int
name|x
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
specifier|static
name|int
name|first_file_directive
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|ECOFF_DEBUGGING
condition|)
block|{
name|get_number
argument_list|()
expr_stmt|;
name|s_app_file
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|char
modifier|*
name|filename
decl_stmt|;
name|filename
operator|=
name|dwarf2_directive_file
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* Versions of GCC up to 3.1 start files with a ".file" 	 directive even for stabs output.  Make sure that this 	 ".file" is handled.  Note that you need a version of GCC          after 3.1 in order to support DWARF-2 on MIPS.  */
if|if
condition|(
name|filename
operator|!=
name|NULL
operator|&&
operator|!
name|first_file_directive
condition|)
block|{
operator|(
name|void
operator|)
name|new_logical_line
argument_list|(
name|filename
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|s_app_file_string
argument_list|(
name|filename
argument_list|)
expr_stmt|;
block|}
name|first_file_directive
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* The .loc directive, implying DWARF-2.  */
end_comment

begin_function
specifier|static
name|void
name|s_mips_loc
parameter_list|(
name|int
name|x
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
if|if
condition|(
operator|!
name|ECOFF_DEBUGGING
condition|)
name|dwarf2_directive_loc
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The .end directive.  */
end_comment

begin_function
specifier|static
name|void
name|s_mips_end
parameter_list|(
name|int
name|x
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|symbolS
modifier|*
name|p
decl_stmt|;
comment|/* Following functions need their own .frame and .cprestore directives.  */
name|mips_frame_reg_valid
operator|=
literal|0
expr_stmt|;
name|mips_cprestore_valid
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|is_end_of_line
index|[
operator|(
name|unsigned
name|char
operator|)
operator|*
name|input_line_pointer
index|]
condition|)
block|{
name|p
operator|=
name|get_symbol
argument_list|()
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
else|else
name|p
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|bfd_get_section_flags
argument_list|(
name|stdoutput
argument_list|,
name|now_seg
argument_list|)
operator|&
name|SEC_CODE
operator|)
operator|==
literal|0
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|".end not in text section"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cur_proc_ptr
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|".end directive without a preceding .ent directive."
argument_list|)
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
block|{
name|assert
argument_list|(
name|S_GET_NAME
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|S_GET_NAME
argument_list|(
name|p
argument_list|)
argument_list|,
name|S_GET_NAME
argument_list|(
name|cur_proc_ptr
operator|->
name|isym
argument_list|)
argument_list|)
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|".end symbol does not match .ent symbol."
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug_type
operator|==
name|DEBUG_STABS
condition|)
name|stabs_generate_asm_endfunc
argument_list|(
name|S_GET_NAME
argument_list|(
name|p
argument_list|)
argument_list|,
name|S_GET_NAME
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|as_warn
argument_list|(
name|_
argument_list|(
literal|".end directive missing or unknown symbol"
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|OBJ_ELF
comment|/* Generate a .pdr section.  */
if|if
condition|(
name|OUTPUT_FLAVOR
operator|==
name|bfd_target_elf_flavour
operator|&&
operator|!
name|ECOFF_DEBUGGING
operator|&&
name|mips_flag_pdr
condition|)
block|{
name|segT
name|saved_seg
init|=
name|now_seg
decl_stmt|;
name|subsegT
name|saved_subseg
init|=
name|now_subseg
decl_stmt|;
name|valueT
name|dot
decl_stmt|;
name|expressionS
name|exp
decl_stmt|;
name|char
modifier|*
name|fragp
decl_stmt|;
name|dot
operator|=
name|frag_now_fix
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|md_flush_pending_output
name|md_flush_pending_output
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|assert
argument_list|(
name|pdr_seg
argument_list|)
expr_stmt|;
name|subseg_set
argument_list|(
name|pdr_seg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Write the symbol.  */
name|exp
operator|.
name|X_op
operator|=
name|O_symbol
expr_stmt|;
name|exp
operator|.
name|X_add_symbol
operator|=
name|p
expr_stmt|;
name|exp
operator|.
name|X_add_number
operator|=
literal|0
expr_stmt|;
name|emit_expr
argument_list|(
operator|&
name|exp
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|fragp
operator|=
name|frag_more
argument_list|(
literal|7
operator|*
literal|4
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|fragp
argument_list|,
name|cur_proc_ptr
operator|->
name|reg_mask
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|fragp
operator|+
literal|4
argument_list|,
name|cur_proc_ptr
operator|->
name|reg_offset
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|fragp
operator|+
literal|8
argument_list|,
name|cur_proc_ptr
operator|->
name|fpreg_mask
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|fragp
operator|+
literal|12
argument_list|,
name|cur_proc_ptr
operator|->
name|fpreg_offset
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|fragp
operator|+
literal|16
argument_list|,
name|cur_proc_ptr
operator|->
name|frame_offset
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|fragp
operator|+
literal|20
argument_list|,
name|cur_proc_ptr
operator|->
name|frame_reg
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|fragp
operator|+
literal|24
argument_list|,
name|cur_proc_ptr
operator|->
name|pc_reg
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|subseg_set
argument_list|(
name|saved_seg
argument_list|,
name|saved_subseg
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* OBJ_ELF */
name|cur_proc_ptr
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The .aent and .ent directives.  */
end_comment

begin_function
specifier|static
name|void
name|s_mips_ent
parameter_list|(
name|int
name|aent
parameter_list|)
block|{
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
name|symbolP
operator|=
name|get_symbol
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|','
condition|)
operator|++
name|input_line_pointer
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
name|ISDIGIT
argument_list|(
operator|*
name|input_line_pointer
argument_list|)
operator|||
operator|*
name|input_line_pointer
operator|==
literal|'-'
condition|)
name|get_number
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|bfd_get_section_flags
argument_list|(
name|stdoutput
argument_list|,
name|now_seg
argument_list|)
operator|&
name|SEC_CODE
operator|)
operator|==
literal|0
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|".ent or .aent not in text section."
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|aent
operator|&&
name|cur_proc_ptr
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"missing .end"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|aent
condition|)
block|{
comment|/* This function needs its own .frame and .cprestore directives.  */
name|mips_frame_reg_valid
operator|=
literal|0
expr_stmt|;
name|mips_cprestore_valid
operator|=
literal|0
expr_stmt|;
name|cur_proc_ptr
operator|=
operator|&
name|cur_proc
expr_stmt|;
name|memset
argument_list|(
name|cur_proc_ptr
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
name|procS
argument_list|)
argument_list|)
expr_stmt|;
name|cur_proc_ptr
operator|->
name|isym
operator|=
name|symbolP
expr_stmt|;
name|symbol_get_bfdsym
argument_list|(
name|symbolP
argument_list|)
operator|->
name|flags
operator||=
name|BSF_FUNCTION
expr_stmt|;
operator|++
name|numprocs
expr_stmt|;
if|if
condition|(
name|debug_type
operator|==
name|DEBUG_STABS
condition|)
name|stabs_generate_asm_func
argument_list|(
name|S_GET_NAME
argument_list|(
name|symbolP
argument_list|)
argument_list|,
name|S_GET_NAME
argument_list|(
name|symbolP
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The .frame directive. If the mdebug section is present (IRIX 5 native)    then ecoff.c (ecoff_directive_frame) is used. For embedded targets,    s_mips_frame is used so that we can set the PDR information correctly.    We can't use the ecoff routines because they make reference to the ecoff    symbol table (in the mdebug section).  */
end_comment

begin_function
specifier|static
name|void
name|s_mips_frame
parameter_list|(
name|int
name|ignore
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|OBJ_ELF
if|if
condition|(
name|OUTPUT_FLAVOR
operator|==
name|bfd_target_elf_flavour
operator|&&
operator|!
name|ECOFF_DEBUGGING
condition|)
block|{
name|long
name|val
decl_stmt|;
if|if
condition|(
name|cur_proc_ptr
operator|==
operator|(
name|procS
operator|*
operator|)
name|NULL
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|".frame outside of .ent"
argument_list|)
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
name|cur_proc_ptr
operator|->
name|frame_reg
operator|=
name|tc_get_register
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|++
operator|!=
literal|','
operator|||
name|get_absolute_expression_and_terminator
argument_list|(
operator|&
name|val
argument_list|)
operator|!=
literal|','
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"Bad .frame directive"
argument_list|)
argument_list|)
expr_stmt|;
operator|--
name|input_line_pointer
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
name|cur_proc_ptr
operator|->
name|frame_offset
operator|=
name|val
expr_stmt|;
name|cur_proc_ptr
operator|->
name|pc_reg
operator|=
name|tc_get_register
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
else|else
endif|#
directive|endif
comment|/* OBJ_ELF */
name|s_ignore
argument_list|(
name|ignore
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The .fmask and .mask directives. If the mdebug section is present    (IRIX 5 native) then ecoff.c (ecoff_directive_mask) is used. For    embedded targets, s_mips_mask is used so that we can set the PDR    information correctly. We can't use the ecoff routines because they    make reference to the ecoff symbol table (in the mdebug section).  */
end_comment

begin_function
specifier|static
name|void
name|s_mips_mask
parameter_list|(
name|int
name|reg_type
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|OBJ_ELF
if|if
condition|(
name|OUTPUT_FLAVOR
operator|==
name|bfd_target_elf_flavour
operator|&&
operator|!
name|ECOFF_DEBUGGING
condition|)
block|{
name|long
name|mask
decl_stmt|,
name|off
decl_stmt|;
if|if
condition|(
name|cur_proc_ptr
operator|==
operator|(
name|procS
operator|*
operator|)
name|NULL
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|".mask/.fmask outside of .ent"
argument_list|)
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|get_absolute_expression_and_terminator
argument_list|(
operator|&
name|mask
argument_list|)
operator|!=
literal|','
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"Bad .mask/.fmask directive"
argument_list|)
argument_list|)
expr_stmt|;
operator|--
name|input_line_pointer
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
name|off
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
if|if
condition|(
name|reg_type
operator|==
literal|'F'
condition|)
block|{
name|cur_proc_ptr
operator|->
name|fpreg_mask
operator|=
name|mask
expr_stmt|;
name|cur_proc_ptr
operator|->
name|fpreg_offset
operator|=
name|off
expr_stmt|;
block|}
else|else
block|{
name|cur_proc_ptr
operator|->
name|reg_mask
operator|=
name|mask
expr_stmt|;
name|cur_proc_ptr
operator|->
name|reg_offset
operator|=
name|off
expr_stmt|;
block|}
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
else|else
endif|#
directive|endif
comment|/* OBJ_ELF */
name|s_ignore
argument_list|(
name|reg_type
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The .loc directive.  */
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static void s_loc (int x) {   symbolS *symbolP;   int lineno;   int addroff;    assert (now_seg == text_section);    lineno = get_number ();   addroff = frag_now_fix ();    symbolP = symbol_new ("", N_SLINE, addroff, frag_now);   S_SET_TYPE (symbolP, N_SLINE);   S_SET_OTHER (symbolP, 0);   S_SET_DESC (symbolP, lineno);   symbolP->sy_segment = now_seg; }
endif|#
directive|endif
end_endif

begin_comment
comment|/* A table describing all the processors gas knows about.  Names are    matched in the order listed.     To ease comparison, please keep this table in the same order as    gcc's mips_cpu_info_table[].  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|mips_cpu_info
name|mips_cpu_info_table
index|[]
init|=
block|{
comment|/* Entries for generic ISAs */
block|{
literal|"mips1"
block|,
literal|1
block|,
name|ISA_MIPS1
block|,
name|CPU_R3000
block|}
block|,
block|{
literal|"mips2"
block|,
literal|1
block|,
name|ISA_MIPS2
block|,
name|CPU_R6000
block|}
block|,
block|{
literal|"mips3"
block|,
literal|1
block|,
name|ISA_MIPS3
block|,
name|CPU_R4000
block|}
block|,
block|{
literal|"mips4"
block|,
literal|1
block|,
name|ISA_MIPS4
block|,
name|CPU_R8000
block|}
block|,
block|{
literal|"mips5"
block|,
literal|1
block|,
name|ISA_MIPS5
block|,
name|CPU_MIPS5
block|}
block|,
block|{
literal|"mips32"
block|,
literal|1
block|,
name|ISA_MIPS32
block|,
name|CPU_MIPS32
block|}
block|,
block|{
literal|"mips32r2"
block|,
literal|1
block|,
name|ISA_MIPS32R2
block|,
name|CPU_MIPS32R2
block|}
block|,
block|{
literal|"mips64"
block|,
literal|1
block|,
name|ISA_MIPS64
block|,
name|CPU_MIPS64
block|}
block|,
block|{
literal|"mips64r2"
block|,
literal|1
block|,
name|ISA_MIPS64R2
block|,
name|CPU_MIPS64R2
block|}
block|,
comment|/* MIPS I */
block|{
literal|"r3000"
block|,
literal|0
block|,
name|ISA_MIPS1
block|,
name|CPU_R3000
block|}
block|,
block|{
literal|"r2000"
block|,
literal|0
block|,
name|ISA_MIPS1
block|,
name|CPU_R3000
block|}
block|,
block|{
literal|"r3900"
block|,
literal|0
block|,
name|ISA_MIPS1
block|,
name|CPU_R3900
block|}
block|,
comment|/* MIPS II */
block|{
literal|"r6000"
block|,
literal|0
block|,
name|ISA_MIPS2
block|,
name|CPU_R6000
block|}
block|,
comment|/* MIPS III */
block|{
literal|"r4000"
block|,
literal|0
block|,
name|ISA_MIPS3
block|,
name|CPU_R4000
block|}
block|,
block|{
literal|"r4010"
block|,
literal|0
block|,
name|ISA_MIPS2
block|,
name|CPU_R4010
block|}
block|,
block|{
literal|"vr4100"
block|,
literal|0
block|,
name|ISA_MIPS3
block|,
name|CPU_VR4100
block|}
block|,
block|{
literal|"vr4111"
block|,
literal|0
block|,
name|ISA_MIPS3
block|,
name|CPU_R4111
block|}
block|,
block|{
literal|"vr4120"
block|,
literal|0
block|,
name|ISA_MIPS3
block|,
name|CPU_VR4120
block|}
block|,
block|{
literal|"vr4130"
block|,
literal|0
block|,
name|ISA_MIPS3
block|,
name|CPU_VR4120
block|}
block|,
block|{
literal|"vr4181"
block|,
literal|0
block|,
name|ISA_MIPS3
block|,
name|CPU_R4111
block|}
block|,
block|{
literal|"vr4300"
block|,
literal|0
block|,
name|ISA_MIPS3
block|,
name|CPU_R4300
block|}
block|,
block|{
literal|"r4400"
block|,
literal|0
block|,
name|ISA_MIPS3
block|,
name|CPU_R4400
block|}
block|,
block|{
literal|"r4600"
block|,
literal|0
block|,
name|ISA_MIPS3
block|,
name|CPU_R4600
block|}
block|,
block|{
literal|"orion"
block|,
literal|0
block|,
name|ISA_MIPS3
block|,
name|CPU_R4600
block|}
block|,
block|{
literal|"r4650"
block|,
literal|0
block|,
name|ISA_MIPS3
block|,
name|CPU_R4650
block|}
block|,
comment|/* MIPS IV */
block|{
literal|"r8000"
block|,
literal|0
block|,
name|ISA_MIPS4
block|,
name|CPU_R8000
block|}
block|,
block|{
literal|"r10000"
block|,
literal|0
block|,
name|ISA_MIPS4
block|,
name|CPU_R10000
block|}
block|,
block|{
literal|"r12000"
block|,
literal|0
block|,
name|ISA_MIPS4
block|,
name|CPU_R12000
block|}
block|,
block|{
literal|"vr5000"
block|,
literal|0
block|,
name|ISA_MIPS4
block|,
name|CPU_R5000
block|}
block|,
block|{
literal|"vr5400"
block|,
literal|0
block|,
name|ISA_MIPS4
block|,
name|CPU_VR5400
block|}
block|,
block|{
literal|"vr5500"
block|,
literal|0
block|,
name|ISA_MIPS4
block|,
name|CPU_VR5500
block|}
block|,
block|{
literal|"rm5200"
block|,
literal|0
block|,
name|ISA_MIPS4
block|,
name|CPU_R5000
block|}
block|,
block|{
literal|"rm5230"
block|,
literal|0
block|,
name|ISA_MIPS4
block|,
name|CPU_R5000
block|}
block|,
block|{
literal|"rm5231"
block|,
literal|0
block|,
name|ISA_MIPS4
block|,
name|CPU_R5000
block|}
block|,
block|{
literal|"rm5261"
block|,
literal|0
block|,
name|ISA_MIPS4
block|,
name|CPU_R5000
block|}
block|,
block|{
literal|"rm5721"
block|,
literal|0
block|,
name|ISA_MIPS4
block|,
name|CPU_R5000
block|}
block|,
block|{
literal|"rm7000"
block|,
literal|0
block|,
name|ISA_MIPS4
block|,
name|CPU_RM7000
block|}
block|,
block|{
literal|"rm9000"
block|,
literal|0
block|,
name|ISA_MIPS4
block|,
name|CPU_RM7000
block|}
block|,
comment|/* MIPS 32 */
block|{
literal|"4kc"
block|,
literal|0
block|,
name|ISA_MIPS32
block|,
name|CPU_MIPS32
block|}
block|,
block|{
literal|"4km"
block|,
literal|0
block|,
name|ISA_MIPS32
block|,
name|CPU_MIPS32
block|}
block|,
block|{
literal|"4kp"
block|,
literal|0
block|,
name|ISA_MIPS32
block|,
name|CPU_MIPS32
block|}
block|,
comment|/* MIPS 64 */
block|{
literal|"5kc"
block|,
literal|0
block|,
name|ISA_MIPS64
block|,
name|CPU_MIPS64
block|}
block|,
block|{
literal|"20kc"
block|,
literal|0
block|,
name|ISA_MIPS64
block|,
name|CPU_MIPS64
block|}
block|,
comment|/* Broadcom SB-1 CPU core */
block|{
literal|"sb1"
block|,
literal|0
block|,
name|ISA_MIPS64
block|,
name|CPU_SB1
block|}
block|,
comment|/* End marker */
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Return true if GIVEN is the same as CANONICAL, or if it is CANONICAL    with a final "000" replaced by "k".  Ignore case.     Note: this function is shared between GCC and GAS.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|mips_strict_matching_cpu_name_p
parameter_list|(
specifier|const
name|char
modifier|*
name|canonical
parameter_list|,
specifier|const
name|char
modifier|*
name|given
parameter_list|)
block|{
while|while
condition|(
operator|*
name|given
operator|!=
literal|0
operator|&&
name|TOLOWER
argument_list|(
operator|*
name|given
argument_list|)
operator|==
name|TOLOWER
argument_list|(
operator|*
name|canonical
argument_list|)
condition|)
name|given
operator|++
operator|,
name|canonical
operator|++
expr_stmt|;
return|return
operator|(
operator|(
operator|*
name|given
operator|==
literal|0
operator|&&
operator|*
name|canonical
operator|==
literal|0
operator|)
operator|||
operator|(
name|strcmp
argument_list|(
name|canonical
argument_list|,
literal|"000"
argument_list|)
operator|==
literal|0
operator|&&
name|strcasecmp
argument_list|(
name|given
argument_list|,
literal|"k"
argument_list|)
operator|==
literal|0
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return true if GIVEN matches CANONICAL, where GIVEN is a user-supplied    CPU name.  We've traditionally allowed a lot of variation here.     Note: this function is shared between GCC and GAS.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|mips_matching_cpu_name_p
parameter_list|(
specifier|const
name|char
modifier|*
name|canonical
parameter_list|,
specifier|const
name|char
modifier|*
name|given
parameter_list|)
block|{
comment|/* First see if the name matches exactly, or with a final "000"      turned into "k".  */
if|if
condition|(
name|mips_strict_matching_cpu_name_p
argument_list|(
name|canonical
argument_list|,
name|given
argument_list|)
condition|)
return|return
name|TRUE
return|;
comment|/* If not, try comparing based on numerical designation alone.      See if GIVEN is an unadorned number, or 'r' followed by a number.  */
if|if
condition|(
name|TOLOWER
argument_list|(
operator|*
name|given
argument_list|)
operator|==
literal|'r'
condition|)
name|given
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|ISDIGIT
argument_list|(
operator|*
name|given
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* Skip over some well-known prefixes in the canonical name,      hoping to find a number there too.  */
if|if
condition|(
name|TOLOWER
argument_list|(
name|canonical
index|[
literal|0
index|]
argument_list|)
operator|==
literal|'v'
operator|&&
name|TOLOWER
argument_list|(
name|canonical
index|[
literal|1
index|]
argument_list|)
operator|==
literal|'r'
condition|)
name|canonical
operator|+=
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
name|TOLOWER
argument_list|(
name|canonical
index|[
literal|0
index|]
argument_list|)
operator|==
literal|'r'
operator|&&
name|TOLOWER
argument_list|(
name|canonical
index|[
literal|1
index|]
argument_list|)
operator|==
literal|'m'
condition|)
name|canonical
operator|+=
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
name|TOLOWER
argument_list|(
name|canonical
index|[
literal|0
index|]
argument_list|)
operator|==
literal|'r'
condition|)
name|canonical
operator|+=
literal|1
expr_stmt|;
return|return
name|mips_strict_matching_cpu_name_p
argument_list|(
name|canonical
argument_list|,
name|given
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Parse an option that takes the name of a processor as its argument.    OPTION is the name of the option and CPU_STRING is the argument.    Return the corresponding processor enumeration if the CPU_STRING is    recognized, otherwise report an error and return null.     A similar function exists in GCC.  */
end_comment

begin_function
specifier|static
specifier|const
name|struct
name|mips_cpu_info
modifier|*
name|mips_parse_cpu
parameter_list|(
specifier|const
name|char
modifier|*
name|option
parameter_list|,
specifier|const
name|char
modifier|*
name|cpu_string
parameter_list|)
block|{
specifier|const
name|struct
name|mips_cpu_info
modifier|*
name|p
decl_stmt|;
comment|/* 'from-abi' selects the most compatible architecture for the given      ABI: MIPS I for 32-bit ABIs and MIPS III for 64-bit ABIs.  For the      EABIs, we have to decide whether we're using the 32-bit or 64-bit      version.  Look first at the -mgp options, if given, otherwise base      the choice on MIPS_DEFAULT_64BIT.       Treat NO_ABI like the EABIs.  One reason to do this is that the      plain 'mips' and 'mips64' configs have 'from-abi' as their default      architecture.  This code picks MIPS I for 'mips' and MIPS III for      'mips64', just as we did in the days before 'from-abi'.  */
if|if
condition|(
name|strcasecmp
argument_list|(
name|cpu_string
argument_list|,
literal|"from-abi"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|ABI_NEEDS_32BIT_REGS
argument_list|(
name|mips_abi
argument_list|)
condition|)
return|return
name|mips_cpu_info_from_isa
argument_list|(
name|ISA_MIPS1
argument_list|)
return|;
if|if
condition|(
name|ABI_NEEDS_64BIT_REGS
argument_list|(
name|mips_abi
argument_list|)
condition|)
return|return
name|mips_cpu_info_from_isa
argument_list|(
name|ISA_MIPS3
argument_list|)
return|;
if|if
condition|(
name|file_mips_gp32
operator|>=
literal|0
condition|)
return|return
name|mips_cpu_info_from_isa
argument_list|(
name|file_mips_gp32
condition|?
name|ISA_MIPS1
else|:
name|ISA_MIPS3
argument_list|)
return|;
return|return
name|mips_cpu_info_from_isa
argument_list|(
name|MIPS_DEFAULT_64BIT
condition|?
name|ISA_MIPS3
else|:
name|ISA_MIPS1
argument_list|)
return|;
block|}
comment|/* 'default' has traditionally been a no-op.  Probably not very useful.  */
if|if
condition|(
name|strcasecmp
argument_list|(
name|cpu_string
argument_list|,
literal|"default"
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
for|for
control|(
name|p
operator|=
name|mips_cpu_info_table
init|;
name|p
operator|->
name|name
operator|!=
literal|0
condition|;
name|p
operator|++
control|)
if|if
condition|(
name|mips_matching_cpu_name_p
argument_list|(
name|p
operator|->
name|name
argument_list|,
name|cpu_string
argument_list|)
condition|)
return|return
name|p
return|;
name|as_bad
argument_list|(
literal|"Bad value (%s) for %s"
argument_list|,
name|cpu_string
argument_list|,
name|option
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return the canonical processor information for ISA (a member of the    ISA_MIPS* enumeration).  */
end_comment

begin_function
specifier|static
specifier|const
name|struct
name|mips_cpu_info
modifier|*
name|mips_cpu_info_from_isa
parameter_list|(
name|int
name|isa
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|mips_cpu_info_table
index|[
name|i
index|]
operator|.
name|name
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|mips_cpu_info_table
index|[
name|i
index|]
operator|.
name|is_isa
operator|&&
name|isa
operator|==
name|mips_cpu_info_table
index|[
name|i
index|]
operator|.
name|isa
condition|)
return|return
operator|(
operator|&
name|mips_cpu_info_table
index|[
name|i
index|]
operator|)
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|struct
name|mips_cpu_info
modifier|*
name|mips_cpu_info_from_arch
parameter_list|(
name|int
name|arch
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|mips_cpu_info_table
index|[
name|i
index|]
operator|.
name|name
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|arch
operator|==
name|mips_cpu_info_table
index|[
name|i
index|]
operator|.
name|cpu
condition|)
return|return
operator|(
operator|&
name|mips_cpu_info_table
index|[
name|i
index|]
operator|)
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|show
parameter_list|(
name|FILE
modifier|*
name|stream
parameter_list|,
specifier|const
name|char
modifier|*
name|string
parameter_list|,
name|int
modifier|*
name|col_p
parameter_list|,
name|int
modifier|*
name|first_p
parameter_list|)
block|{
if|if
condition|(
operator|*
name|first_p
condition|)
block|{
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"%24s"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
operator|*
name|col_p
operator|=
literal|24
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
operator|*
name|col_p
operator|+=
literal|2
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|col_p
operator|+
name|strlen
argument_list|(
name|string
argument_list|)
operator|>
literal|72
condition|)
block|{
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\n%24s"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
operator|*
name|col_p
operator|=
literal|24
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"%s"
argument_list|,
name|string
argument_list|)
expr_stmt|;
operator|*
name|col_p
operator|+=
name|strlen
argument_list|(
name|string
argument_list|)
expr_stmt|;
operator|*
name|first_p
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|void
name|md_show_usage
parameter_list|(
name|FILE
modifier|*
name|stream
parameter_list|)
block|{
name|int
name|column
decl_stmt|,
name|first
decl_stmt|;
name|size_t
name|i
decl_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"\ MIPS options:\n\ -membedded-pic		generate embedded position independent code\n\ -EB			generate big endian output\n\ -EL			generate little endian output\n\ -g, -g2			do not remove unneeded NOPs or swap branches\n\ -G NUM			allow referencing objects up to NUM bytes\n\ 			implicitly with the gp register [default 8]\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"\ -mips1			generate MIPS ISA I instructions\n\ -mips2			generate MIPS ISA II instructions\n\ -mips3			generate MIPS ISA III instructions\n\ -mips4			generate MIPS ISA IV instructions\n\ -mips5                  generate MIPS ISA V instructions\n\ -mips32                 generate MIPS32 ISA instructions\n\ -mips32r2               generate MIPS32 release 2 ISA instructions\n\ -mips64                 generate MIPS64 ISA instructions\n\ -mips64r2               generate MIPS64 release 2 ISA instructions\n\ -march=CPU/-mtune=CPU	generate code/schedule for CPU, where CPU is one of:\n"
argument_list|)
argument_list|)
expr_stmt|;
name|first
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|mips_cpu_info_table
index|[
name|i
index|]
operator|.
name|name
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
name|show
argument_list|(
name|stream
argument_list|,
name|mips_cpu_info_table
index|[
name|i
index|]
operator|.
name|name
argument_list|,
operator|&
name|column
argument_list|,
operator|&
name|first
argument_list|)
expr_stmt|;
name|show
argument_list|(
name|stream
argument_list|,
literal|"from-abi"
argument_list|,
operator|&
name|column
argument_list|,
operator|&
name|first
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"\ -mCPU			equivalent to -march=CPU -mtune=CPU. Deprecated.\n\ -no-mCPU		don't generate code specific to CPU.\n\ 			For -mCPU and -no-mCPU, CPU must be one of:\n"
argument_list|)
argument_list|)
expr_stmt|;
name|first
operator|=
literal|1
expr_stmt|;
name|show
argument_list|(
name|stream
argument_list|,
literal|"3900"
argument_list|,
operator|&
name|column
argument_list|,
operator|&
name|first
argument_list|)
expr_stmt|;
name|show
argument_list|(
name|stream
argument_list|,
literal|"4010"
argument_list|,
operator|&
name|column
argument_list|,
operator|&
name|first
argument_list|)
expr_stmt|;
name|show
argument_list|(
name|stream
argument_list|,
literal|"4100"
argument_list|,
operator|&
name|column
argument_list|,
operator|&
name|first
argument_list|)
expr_stmt|;
name|show
argument_list|(
name|stream
argument_list|,
literal|"4650"
argument_list|,
operator|&
name|column
argument_list|,
operator|&
name|first
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"\ -mips16			generate mips16 instructions\n\ -no-mips16		do not generate mips16 instructions\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"\ -mfix-vr4120		work around certain VR4120 errata\n\ -mgp32			use 32-bit GPRs, regardless of the chosen ISA\n\ -mfp32			use 32-bit FPRs, regardless of the chosen ISA\n\ -O0			remove unneeded NOPs, do not swap branches\n\ -O			remove unneeded NOPs and swap branches\n\ --[no-]construct-floats [dis]allow floating point values to be constructed\n\ --trap, --no-break	trap exception on div by 0 and mult overflow\n\ --break, --no-trap	break exception on div by 0 and mult overflow\n"
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|OBJ_ELF
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"\ -KPIC, -call_shared	generate SVR4 position independent code\n\ -non_shared		do not generate position independent code\n\ -xgot			assume a 32 bit GOT\n\ -mpdr, -mno-pdr		enable/disable creation of .pdr sections\n\ -mabi=ABI		create ABI conformant object file for:\n"
argument_list|)
argument_list|)
expr_stmt|;
name|first
operator|=
literal|1
expr_stmt|;
name|show
argument_list|(
name|stream
argument_list|,
literal|"32"
argument_list|,
operator|&
name|column
argument_list|,
operator|&
name|first
argument_list|)
expr_stmt|;
name|show
argument_list|(
name|stream
argument_list|,
literal|"o64"
argument_list|,
operator|&
name|column
argument_list|,
operator|&
name|first
argument_list|)
expr_stmt|;
name|show
argument_list|(
name|stream
argument_list|,
literal|"n32"
argument_list|,
operator|&
name|column
argument_list|,
operator|&
name|first
argument_list|)
expr_stmt|;
name|show
argument_list|(
name|stream
argument_list|,
literal|"64"
argument_list|,
operator|&
name|column
argument_list|,
operator|&
name|first
argument_list|)
expr_stmt|;
name|show
argument_list|(
name|stream
argument_list|,
literal|"eabi"
argument_list|,
operator|&
name|column
argument_list|,
operator|&
name|first
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"\ -32			create o32 ABI object file (default)\n\ -n32			create n32 ABI object file\n\ -64			create 64 ABI object file\n"
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|enum
name|dwarf2_format
name|mips_dwarf2_format
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|mips_abi
operator|==
name|N64_ABI
condition|)
block|{
ifdef|#
directive|ifdef
name|TE_IRIX
return|return
name|dwarf2_format_64bit_irix
return|;
else|#
directive|else
return|return
name|dwarf2_format_64bit
return|;
endif|#
directive|endif
block|}
else|else
return|return
name|dwarf2_format_32bit
return|;
block|}
end_function

begin_function
name|int
name|mips_dwarf2_addr_size
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|mips_abi
operator|==
name|N64_ABI
condition|)
return|return
literal|8
return|;
else|else
return|return
literal|4
return|;
block|}
end_function

end_unit

