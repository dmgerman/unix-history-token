begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* tc-s390.c -- Assemble for the S390    Copyright 2000, 2001, 2002, 2003, 2004 Free Software Foundation, Inc.    Contributed by Martin Schwidefsky (schwidefsky@de.ibm.com).     This file is part of GAS, the GNU Assembler.     GAS is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     GAS is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with GAS; see the file COPYING.  If not, write to the Free    Software Foundation, 59 Temple Place - Suite 330, Boston, MA    02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"as.h"
end_include

begin_include
include|#
directive|include
file|"safe-ctype.h"
end_include

begin_include
include|#
directive|include
file|"subsegs.h"
end_include

begin_include
include|#
directive|include
file|"struc-symbol.h"
end_include

begin_include
include|#
directive|include
file|"dwarf2dbg.h"
end_include

begin_include
include|#
directive|include
file|"dw2gencfi.h"
end_include

begin_include
include|#
directive|include
file|"opcode/s390.h"
end_include

begin_include
include|#
directive|include
file|"elf/s390.h"
end_include

begin_comment
comment|/* The default architecture.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|DEFAULT_ARCH
end_ifndef

begin_define
define|#
directive|define
name|DEFAULT_ARCH
value|"s390"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|char
modifier|*
name|default_arch
init|=
name|DEFAULT_ARCH
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Either 32 or 64, selects file format.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|s390_arch_size
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|current_mode_mask
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|current_cpu
init|=
operator|-
literal|1U
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Whether to use user friendly register names. Default is TRUE.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|TARGET_REG_NAMES_P
end_ifndef

begin_define
define|#
directive|define
name|TARGET_REG_NAMES_P
value|TRUE
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|bfd_boolean
name|reg_names_p
init|=
name|TARGET_REG_NAMES_P
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set to TRUE if we want to warn about zero base/index registers.  */
end_comment

begin_decl_stmt
specifier|static
name|bfd_boolean
name|warn_areg_zero
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Generic assembler global variables which must be defined by all    targets.  */
end_comment

begin_decl_stmt
specifier|const
name|char
name|comment_chars
index|[]
init|=
literal|"#"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Characters which start a comment at the beginning of a line.  */
end_comment

begin_decl_stmt
specifier|const
name|char
name|line_comment_chars
index|[]
init|=
literal|"#"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Characters which may be used to separate multiple commands on a    single line.  */
end_comment

begin_decl_stmt
specifier|const
name|char
name|line_separator_chars
index|[]
init|=
literal|";"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Characters which are used to indicate an exponent in a floating    point number.  */
end_comment

begin_decl_stmt
specifier|const
name|char
name|EXP_CHARS
index|[]
init|=
literal|"eE"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Characters which mean that a number is a floating point constant,    as in 0d1.0.  */
end_comment

begin_decl_stmt
specifier|const
name|char
name|FLT_CHARS
index|[]
init|=
literal|"dD"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The dwarf2 data alignment, adjusted for 32 or 64 bit.  */
end_comment

begin_decl_stmt
name|int
name|s390_cie_data_alignment
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The target specific pseudo-ops which we support.  */
end_comment

begin_comment
comment|/* Define the prototypes for the pseudo-ops */
end_comment

begin_decl_stmt
specifier|static
name|void
name|s390_byte
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|s390_elf_cons
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|s390_bss
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|s390_insn
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|s390_literals
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|pseudo_typeS
name|md_pseudo_table
index|[]
init|=
block|{
block|{
literal|"align"
block|,
name|s_align_bytes
block|,
literal|0
block|}
block|,
comment|/* Pseudo-ops which must be defined.  */
block|{
literal|"bss"
block|,
name|s390_bss
block|,
literal|0
block|}
block|,
block|{
literal|"insn"
block|,
name|s390_insn
block|,
literal|0
block|}
block|,
comment|/* Pseudo-ops which must be overridden.  */
block|{
literal|"byte"
block|,
name|s390_byte
block|,
literal|0
block|}
block|,
block|{
literal|"short"
block|,
name|s390_elf_cons
block|,
literal|2
block|}
block|,
block|{
literal|"long"
block|,
name|s390_elf_cons
block|,
literal|4
block|}
block|,
block|{
literal|"quad"
block|,
name|s390_elf_cons
block|,
literal|8
block|}
block|,
block|{
literal|"ltorg"
block|,
name|s390_literals
block|,
literal|0
block|}
block|,
block|{
literal|"string"
block|,
name|stringer
block|,
literal|2
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Structure to hold information about predefined registers.  */
end_comment

begin_struct
struct|struct
name|pd_reg
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|value
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* List of registers that are pre-defined:     Each access register has a predefined name of the form:      a<reg_num> which has the value<reg_num>.     Each control register has a predefined name of the form:      c<reg_num> which has the value<reg_num>.     Each general register has a predefined name of the form:      r<reg_num> which has the value<reg_num>.     Each floating point register a has predefined name of the form:      f<reg_num> which has the value<reg_num>.     There are individual registers as well:      sp     has the value 15      lit    has the value 12     The table is sorted. Suitable for searching by a binary search.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|pd_reg
name|pre_defined_registers
index|[]
init|=
block|{
block|{
literal|"a0"
block|,
literal|0
block|}
block|,
comment|/* Access registers */
block|{
literal|"a1"
block|,
literal|1
block|}
block|,
block|{
literal|"a10"
block|,
literal|10
block|}
block|,
block|{
literal|"a11"
block|,
literal|11
block|}
block|,
block|{
literal|"a12"
block|,
literal|12
block|}
block|,
block|{
literal|"a13"
block|,
literal|13
block|}
block|,
block|{
literal|"a14"
block|,
literal|14
block|}
block|,
block|{
literal|"a15"
block|,
literal|15
block|}
block|,
block|{
literal|"a2"
block|,
literal|2
block|}
block|,
block|{
literal|"a3"
block|,
literal|3
block|}
block|,
block|{
literal|"a4"
block|,
literal|4
block|}
block|,
block|{
literal|"a5"
block|,
literal|5
block|}
block|,
block|{
literal|"a6"
block|,
literal|6
block|}
block|,
block|{
literal|"a7"
block|,
literal|7
block|}
block|,
block|{
literal|"a8"
block|,
literal|8
block|}
block|,
block|{
literal|"a9"
block|,
literal|9
block|}
block|,
block|{
literal|"c0"
block|,
literal|0
block|}
block|,
comment|/* Control registers */
block|{
literal|"c1"
block|,
literal|1
block|}
block|,
block|{
literal|"c10"
block|,
literal|10
block|}
block|,
block|{
literal|"c11"
block|,
literal|11
block|}
block|,
block|{
literal|"c12"
block|,
literal|12
block|}
block|,
block|{
literal|"c13"
block|,
literal|13
block|}
block|,
block|{
literal|"c14"
block|,
literal|14
block|}
block|,
block|{
literal|"c15"
block|,
literal|15
block|}
block|,
block|{
literal|"c2"
block|,
literal|2
block|}
block|,
block|{
literal|"c3"
block|,
literal|3
block|}
block|,
block|{
literal|"c4"
block|,
literal|4
block|}
block|,
block|{
literal|"c5"
block|,
literal|5
block|}
block|,
block|{
literal|"c6"
block|,
literal|6
block|}
block|,
block|{
literal|"c7"
block|,
literal|7
block|}
block|,
block|{
literal|"c8"
block|,
literal|8
block|}
block|,
block|{
literal|"c9"
block|,
literal|9
block|}
block|,
block|{
literal|"f0"
block|,
literal|0
block|}
block|,
comment|/* Floating point registers */
block|{
literal|"f1"
block|,
literal|1
block|}
block|,
block|{
literal|"f10"
block|,
literal|10
block|}
block|,
block|{
literal|"f11"
block|,
literal|11
block|}
block|,
block|{
literal|"f12"
block|,
literal|12
block|}
block|,
block|{
literal|"f13"
block|,
literal|13
block|}
block|,
block|{
literal|"f14"
block|,
literal|14
block|}
block|,
block|{
literal|"f15"
block|,
literal|15
block|}
block|,
block|{
literal|"f2"
block|,
literal|2
block|}
block|,
block|{
literal|"f3"
block|,
literal|3
block|}
block|,
block|{
literal|"f4"
block|,
literal|4
block|}
block|,
block|{
literal|"f5"
block|,
literal|5
block|}
block|,
block|{
literal|"f6"
block|,
literal|6
block|}
block|,
block|{
literal|"f7"
block|,
literal|7
block|}
block|,
block|{
literal|"f8"
block|,
literal|8
block|}
block|,
block|{
literal|"f9"
block|,
literal|9
block|}
block|,
block|{
literal|"lit"
block|,
literal|13
block|}
block|,
comment|/* Pointer to literal pool */
block|{
literal|"r0"
block|,
literal|0
block|}
block|,
comment|/* General purpose registers */
block|{
literal|"r1"
block|,
literal|1
block|}
block|,
block|{
literal|"r10"
block|,
literal|10
block|}
block|,
block|{
literal|"r11"
block|,
literal|11
block|}
block|,
block|{
literal|"r12"
block|,
literal|12
block|}
block|,
block|{
literal|"r13"
block|,
literal|13
block|}
block|,
block|{
literal|"r14"
block|,
literal|14
block|}
block|,
block|{
literal|"r15"
block|,
literal|15
block|}
block|,
block|{
literal|"r2"
block|,
literal|2
block|}
block|,
block|{
literal|"r3"
block|,
literal|3
block|}
block|,
block|{
literal|"r4"
block|,
literal|4
block|}
block|,
block|{
literal|"r5"
block|,
literal|5
block|}
block|,
block|{
literal|"r6"
block|,
literal|6
block|}
block|,
block|{
literal|"r7"
block|,
literal|7
block|}
block|,
block|{
literal|"r8"
block|,
literal|8
block|}
block|,
block|{
literal|"r9"
block|,
literal|9
block|}
block|,
block|{
literal|"sp"
block|,
literal|15
block|}
block|,
comment|/* Stack pointer */
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|REG_NAME_CNT
value|(sizeof (pre_defined_registers) / sizeof (struct pd_reg))
end_define

begin_decl_stmt
specifier|static
name|int
name|reg_name_search
name|PARAMS
argument_list|(
operator|(
specifier|const
expr|struct
name|pd_reg
operator|*
operator|,
name|int
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|register_name
name|PARAMS
argument_list|(
operator|(
name|expressionS
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|init_default_arch
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|s390_insert_operand
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|,
specifier|const
expr|struct
name|s390_operand
operator|*
operator|,
name|offsetT
operator|,
name|char
operator|*
operator|,
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|md_gather_operands
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|unsigned
name|char
operator|*
operator|,
specifier|const
expr|struct
name|s390_opcode
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Given NAME, find the register number associated with that name, return    the integer value associated with the given name or -1 on failure.  */
end_comment

begin_function
specifier|static
name|int
name|reg_name_search
parameter_list|(
name|regs
parameter_list|,
name|regcount
parameter_list|,
name|name
parameter_list|)
specifier|const
name|struct
name|pd_reg
modifier|*
name|regs
decl_stmt|;
name|int
name|regcount
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|int
name|middle
decl_stmt|,
name|low
decl_stmt|,
name|high
decl_stmt|;
name|int
name|cmp
decl_stmt|;
name|low
operator|=
literal|0
expr_stmt|;
name|high
operator|=
name|regcount
operator|-
literal|1
expr_stmt|;
do|do
block|{
name|middle
operator|=
operator|(
name|low
operator|+
name|high
operator|)
operator|/
literal|2
expr_stmt|;
name|cmp
operator|=
name|strcasecmp
argument_list|(
name|name
argument_list|,
name|regs
index|[
name|middle
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmp
operator|<
literal|0
condition|)
name|high
operator|=
name|middle
operator|-
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|cmp
operator|>
literal|0
condition|)
name|low
operator|=
name|middle
operator|+
literal|1
expr_stmt|;
else|else
return|return
name|regs
index|[
name|middle
index|]
operator|.
name|value
return|;
block|}
do|while
condition|(
name|low
operator|<=
name|high
condition|)
do|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * Summary of register_name().  *  * in:	Input_line_pointer points to 1st char of operand.  *  * out:	A expressionS.  *      The operand may have been a register: in this case, X_op == O_register,  *      X_add_number is set to the register number, and truth is returned.  *	Input_line_pointer->(next non-blank) char after operand, or is in its  *      original state.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|register_name
parameter_list|(
name|expressionP
parameter_list|)
name|expressionS
modifier|*
name|expressionP
decl_stmt|;
block|{
name|int
name|reg_number
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|start
decl_stmt|;
name|char
name|c
decl_stmt|;
comment|/* Find the spelling of the operand.  */
name|start
operator|=
name|name
operator|=
name|input_line_pointer
expr_stmt|;
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'%'
operator|&&
name|ISALPHA
argument_list|(
name|name
index|[
literal|1
index|]
argument_list|)
condition|)
name|name
operator|=
operator|++
name|input_line_pointer
expr_stmt|;
else|else
return|return
name|FALSE
return|;
name|c
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
name|reg_number
operator|=
name|reg_name_search
argument_list|(
name|pre_defined_registers
argument_list|,
name|REG_NAME_CNT
argument_list|,
name|name
argument_list|)
expr_stmt|;
comment|/* Put back the delimiting char.  */
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
comment|/* Look to see if it's in the register table.  */
if|if
condition|(
name|reg_number
operator|>=
literal|0
condition|)
block|{
name|expressionP
operator|->
name|X_op
operator|=
name|O_register
expr_stmt|;
name|expressionP
operator|->
name|X_add_number
operator|=
name|reg_number
expr_stmt|;
comment|/* Make the rest nice.  */
name|expressionP
operator|->
name|X_add_symbol
operator|=
name|NULL
expr_stmt|;
name|expressionP
operator|->
name|X_op_symbol
operator|=
name|NULL
expr_stmt|;
return|return
name|TRUE
return|;
block|}
comment|/* Reset the line as if we had not done anything.  */
name|input_line_pointer
operator|=
name|start
expr_stmt|;
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* Local variables.  */
end_comment

begin_comment
comment|/* Opformat hash table.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|hash_control
modifier|*
name|s390_opformat_hash
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Opcode hash table.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|hash_control
modifier|*
name|s390_opcode_hash
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Flags to set in the elf header */
end_comment

begin_decl_stmt
specifier|static
name|flagword
name|s390_flags
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|symbolS
modifier|*
name|GOT_symbol
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pre-defined "_GLOBAL_OFFSET_TABLE_" */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|WORKING_DOT_WORD
end_ifndef

begin_decl_stmt
specifier|const
name|int
name|md_short_jump_size
init|=
literal|4
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|int
name|md_long_jump_size
init|=
literal|4
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|const
name|char
modifier|*
name|md_shortopts
init|=
literal|"A:m:kVQ:"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|option
name|md_longopts
index|[]
init|=
block|{
block|{
name|NULL
block|,
name|no_argument
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|size_t
name|md_longopts_size
init|=
sizeof|sizeof
argument_list|(
name|md_longopts
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Initialize the default opcode arch and word size from the default    architecture name if not specified by an option.  */
end_comment

begin_function
specifier|static
name|void
name|init_default_arch
parameter_list|()
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|default_arch
argument_list|,
literal|"s390"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|s390_arch_size
operator|==
literal|0
condition|)
name|s390_arch_size
operator|=
literal|32
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|default_arch
argument_list|,
literal|"s390x"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|s390_arch_size
operator|==
literal|0
condition|)
name|s390_arch_size
operator|=
literal|64
expr_stmt|;
block|}
else|else
name|as_fatal
argument_list|(
literal|"Invalid default architecture, broken assembler."
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_mode_mask
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|s390_arch_size
operator|==
literal|32
condition|)
name|current_mode_mask
operator|=
literal|1
operator|<<
name|S390_OPCODE_ESA
expr_stmt|;
else|else
name|current_mode_mask
operator|=
literal|1
operator|<<
name|S390_OPCODE_ZARCH
expr_stmt|;
block|}
if|if
condition|(
name|current_cpu
operator|==
operator|-
literal|1U
condition|)
block|{
if|if
condition|(
name|current_mode_mask
operator|==
operator|(
literal|1
operator|<<
name|S390_OPCODE_ESA
operator|)
condition|)
name|current_cpu
operator|=
name|S390_OPCODE_G5
expr_stmt|;
else|else
name|current_cpu
operator|=
name|S390_OPCODE_Z900
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Called by TARGET_FORMAT.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|s390_target_format
parameter_list|()
block|{
comment|/* We don't get a chance to initialize anything before we're called,      so handle that now.  */
name|init_default_arch
argument_list|()
expr_stmt|;
return|return
name|s390_arch_size
operator|==
literal|64
condition|?
literal|"elf64-s390"
else|:
literal|"elf32-s390"
return|;
block|}
end_function

begin_function
name|int
name|md_parse_option
parameter_list|(
name|c
parameter_list|,
name|arg
parameter_list|)
name|int
name|c
decl_stmt|;
name|char
modifier|*
name|arg
decl_stmt|;
block|{
switch|switch
condition|(
name|c
condition|)
block|{
comment|/* -k: Ignore for FreeBSD compatibility.  */
case|case
literal|'k'
case|:
break|break;
case|case
literal|'m'
case|:
if|if
condition|(
name|arg
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"regnames"
argument_list|)
operator|==
literal|0
condition|)
name|reg_names_p
operator|=
name|TRUE
expr_stmt|;
elseif|else
if|if
condition|(
name|arg
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"no-regnames"
argument_list|)
operator|==
literal|0
condition|)
name|reg_names_p
operator|=
name|FALSE
expr_stmt|;
elseif|else
if|if
condition|(
name|arg
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"warn-areg-zero"
argument_list|)
operator|==
literal|0
condition|)
name|warn_areg_zero
operator|=
name|TRUE
expr_stmt|;
elseif|else
if|if
condition|(
name|arg
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"31"
argument_list|)
operator|==
literal|0
condition|)
name|s390_arch_size
operator|=
literal|32
expr_stmt|;
elseif|else
if|if
condition|(
name|arg
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"64"
argument_list|)
operator|==
literal|0
condition|)
name|s390_arch_size
operator|=
literal|64
expr_stmt|;
elseif|else
if|if
condition|(
name|arg
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"esa"
argument_list|)
operator|==
literal|0
condition|)
name|current_mode_mask
operator|=
literal|1
operator|<<
name|S390_OPCODE_ESA
expr_stmt|;
elseif|else
if|if
condition|(
name|arg
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"zarch"
argument_list|)
operator|==
literal|0
condition|)
name|current_mode_mask
operator|=
literal|1
operator|<<
name|S390_OPCODE_ZARCH
expr_stmt|;
elseif|else
if|if
condition|(
name|arg
operator|!=
name|NULL
operator|&&
name|strncmp
argument_list|(
name|arg
argument_list|,
literal|"arch="
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|arg
operator|+
literal|5
argument_list|,
literal|"g5"
argument_list|)
operator|==
literal|0
condition|)
name|current_cpu
operator|=
name|S390_OPCODE_G5
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|arg
operator|+
literal|5
argument_list|,
literal|"g6"
argument_list|)
operator|==
literal|0
condition|)
name|current_cpu
operator|=
name|S390_OPCODE_G6
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|arg
operator|+
literal|5
argument_list|,
literal|"z900"
argument_list|)
operator|==
literal|0
condition|)
name|current_cpu
operator|=
name|S390_OPCODE_Z900
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|arg
operator|+
literal|5
argument_list|,
literal|"z990"
argument_list|)
operator|==
literal|0
condition|)
name|current_cpu
operator|=
name|S390_OPCODE_Z990
expr_stmt|;
else|else
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"invalid switch -m%s"
argument_list|)
argument_list|,
name|arg
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
else|else
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"invalid switch -m%s"
argument_list|)
argument_list|,
name|arg
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
break|break;
case|case
literal|'A'
case|:
comment|/* Option -A is deprecated. Still available for compatibility.  */
if|if
condition|(
name|arg
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"esa"
argument_list|)
operator|==
literal|0
condition|)
name|current_cpu
operator|=
name|S390_OPCODE_G5
expr_stmt|;
elseif|else
if|if
condition|(
name|arg
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"esame"
argument_list|)
operator|==
literal|0
condition|)
name|current_cpu
operator|=
name|S390_OPCODE_Z900
expr_stmt|;
else|else
name|as_bad
argument_list|(
literal|"invalid architecture -A%s"
argument_list|,
name|arg
argument_list|)
expr_stmt|;
break|break;
comment|/* -V: SVR4 argument to print version ID.  */
case|case
literal|'V'
case|:
name|print_version_id
argument_list|()
expr_stmt|;
break|break;
comment|/* -Qy, -Qn: SVR4 arguments controlling whether a .comment section 	 should be emitted or not.  FIXME: Not implemented.  */
case|case
literal|'Q'
case|:
break|break;
default|default:
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
name|void
name|md_show_usage
parameter_list|(
name|stream
parameter_list|)
name|FILE
modifier|*
name|stream
decl_stmt|;
block|{
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"\         S390 options:\n\         -mregnames        Allow symbolic names for registers\n\         -mwarn-areg-zero  Warn about zero base/index registers\n\         -mno-regnames     Do not allow symbolic names for registers\n\         -m31              Set file format to 31 bit format\n\         -m64              Set file format to 64 bit format\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"\         -V                print assembler version number\n\         -Qy, -Qn          ignored\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This function is called when the assembler starts up.  It is called    after the options have been parsed and the output file has been    opened.  */
end_comment

begin_function
name|void
name|md_begin
parameter_list|()
block|{
specifier|register
specifier|const
name|struct
name|s390_opcode
modifier|*
name|op
decl_stmt|;
specifier|const
name|struct
name|s390_opcode
modifier|*
name|op_end
decl_stmt|;
name|bfd_boolean
name|dup_insn
init|=
name|FALSE
decl_stmt|;
specifier|const
name|char
modifier|*
name|retval
decl_stmt|;
comment|/* Give a warning if the combination -m64-bit and -Aesa is used.  */
if|if
condition|(
name|s390_arch_size
operator|==
literal|64
operator|&&
name|current_cpu
operator|<
name|S390_OPCODE_Z900
condition|)
name|as_warn
argument_list|(
literal|"The 64 bit file format is used without esame instructions."
argument_list|)
expr_stmt|;
name|s390_cie_data_alignment
operator|=
operator|-
name|s390_arch_size
operator|/
literal|8
expr_stmt|;
comment|/* Set the ELF flags if desired.  */
if|if
condition|(
name|s390_flags
condition|)
name|bfd_set_private_flags
argument_list|(
name|stdoutput
argument_list|,
name|s390_flags
argument_list|)
expr_stmt|;
comment|/* Insert the opcode formats into a hash table.  */
name|s390_opformat_hash
operator|=
name|hash_new
argument_list|()
expr_stmt|;
name|op_end
operator|=
name|s390_opformats
operator|+
name|s390_num_opformats
expr_stmt|;
for|for
control|(
name|op
operator|=
name|s390_opformats
init|;
name|op
operator|<
name|op_end
condition|;
name|op
operator|++
control|)
block|{
name|retval
operator|=
name|hash_insert
argument_list|(
name|s390_opformat_hash
argument_list|,
name|op
operator|->
name|name
argument_list|,
operator|(
name|PTR
operator|)
name|op
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Internal assembler error for instruction format %s"
argument_list|)
argument_list|,
name|op
operator|->
name|name
argument_list|)
expr_stmt|;
name|dup_insn
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
comment|/* Insert the opcodes into a hash table.  */
name|s390_opcode_hash
operator|=
name|hash_new
argument_list|()
expr_stmt|;
name|op_end
operator|=
name|s390_opcodes
operator|+
name|s390_num_opcodes
expr_stmt|;
for|for
control|(
name|op
operator|=
name|s390_opcodes
init|;
name|op
operator|<
name|op_end
condition|;
name|op
operator|++
control|)
if|if
condition|(
name|op
operator|->
name|min_cpu
operator|<=
name|current_cpu
condition|)
block|{
name|retval
operator|=
name|hash_insert
argument_list|(
name|s390_opcode_hash
argument_list|,
name|op
operator|->
name|name
argument_list|,
operator|(
name|PTR
operator|)
name|op
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Internal assembler error for instruction %s"
argument_list|)
argument_list|,
name|op
operator|->
name|name
argument_list|)
expr_stmt|;
name|dup_insn
operator|=
name|TRUE
expr_stmt|;
block|}
while|while
condition|(
name|op
operator|<
name|op_end
operator|-
literal|1
operator|&&
name|strcmp
argument_list|(
name|op
operator|->
name|name
argument_list|,
name|op
index|[
literal|1
index|]
operator|.
name|name
argument_list|)
operator|==
literal|0
condition|)
name|op
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|dup_insn
condition|)
name|abort
argument_list|()
expr_stmt|;
name|record_alignment
argument_list|(
name|text_section
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|record_alignment
argument_list|(
name|data_section
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|record_alignment
argument_list|(
name|bss_section
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Called after all assembly has been done.  */
end_comment

begin_function
name|void
name|s390_md_end
parameter_list|()
block|{
if|if
condition|(
name|s390_arch_size
operator|==
literal|64
condition|)
name|bfd_set_arch_mach
argument_list|(
name|stdoutput
argument_list|,
name|bfd_arch_s390
argument_list|,
name|bfd_mach_s390_64
argument_list|)
expr_stmt|;
else|else
name|bfd_set_arch_mach
argument_list|(
name|stdoutput
argument_list|,
name|bfd_arch_s390
argument_list|,
name|bfd_mach_s390_31
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Insert an operand value into an instruction.  */
end_comment

begin_function
specifier|static
name|void
name|s390_insert_operand
parameter_list|(
name|insn
parameter_list|,
name|operand
parameter_list|,
name|val
parameter_list|,
name|file
parameter_list|,
name|line
parameter_list|)
name|unsigned
name|char
modifier|*
name|insn
decl_stmt|;
specifier|const
name|struct
name|s390_operand
modifier|*
name|operand
decl_stmt|;
name|offsetT
name|val
decl_stmt|;
name|char
modifier|*
name|file
decl_stmt|;
name|unsigned
name|int
name|line
decl_stmt|;
block|{
name|addressT
name|uval
decl_stmt|;
name|int
name|offset
decl_stmt|;
if|if
condition|(
name|operand
operator|->
name|flags
operator|&
operator|(
name|S390_OPERAND_SIGNED
operator||
name|S390_OPERAND_PCREL
operator|)
condition|)
block|{
name|offsetT
name|min
decl_stmt|,
name|max
decl_stmt|;
name|max
operator|=
operator|(
operator|(
name|offsetT
operator|)
literal|1
operator|<<
operator|(
name|operand
operator|->
name|bits
operator|-
literal|1
operator|)
operator|)
operator|-
literal|1
expr_stmt|;
name|min
operator|=
operator|-
operator|(
operator|(
name|offsetT
operator|)
literal|1
operator|<<
operator|(
name|operand
operator|->
name|bits
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
comment|/* Halve PCREL operands.  */
if|if
condition|(
name|operand
operator|->
name|flags
operator|&
name|S390_OPERAND_PCREL
condition|)
name|val
operator|>>=
literal|1
expr_stmt|;
comment|/* Check for underflow / overflow.  */
if|if
condition|(
name|val
operator|<
name|min
operator|||
name|val
operator|>
name|max
condition|)
block|{
specifier|const
name|char
modifier|*
name|err
init|=
literal|"operand out of range (%s not between %ld and %ld)"
decl_stmt|;
name|char
name|buf
index|[
literal|100
index|]
decl_stmt|;
if|if
condition|(
name|operand
operator|->
name|flags
operator|&
name|S390_OPERAND_PCREL
condition|)
block|{
name|val
operator|<<=
literal|1
expr_stmt|;
name|min
operator|<<=
literal|1
expr_stmt|;
name|max
operator|<<=
literal|1
expr_stmt|;
block|}
name|sprint_value
argument_list|(
name|buf
argument_list|,
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|file
operator|==
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
name|as_bad
argument_list|(
name|err
argument_list|,
name|buf
argument_list|,
operator|(
name|int
operator|)
name|min
argument_list|,
operator|(
name|int
operator|)
name|max
argument_list|)
expr_stmt|;
else|else
name|as_bad_where
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
name|err
argument_list|,
name|buf
argument_list|,
operator|(
name|int
operator|)
name|min
argument_list|,
operator|(
name|int
operator|)
name|max
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* val is ok, now restrict it to operand->bits bits.  */
name|uval
operator|=
operator|(
name|addressT
operator|)
name|val
operator|&
operator|(
operator|(
operator|(
operator|(
name|addressT
operator|)
literal|1
operator|<<
operator|(
name|operand
operator|->
name|bits
operator|-
literal|1
operator|)
operator|)
operator|<<
literal|1
operator|)
operator|-
literal|1
operator|)
expr_stmt|;
comment|/* val is restrict, now check for special case.  */
if|if
condition|(
name|operand
operator|->
name|bits
operator|==
literal|20
operator|&&
name|operand
operator|->
name|shift
operator|==
literal|20
condition|)
name|uval
operator|=
operator|(
name|uval
operator|>>
literal|12
operator|)
operator||
operator|(
operator|(
name|uval
operator|&
literal|0xfff
operator|)
operator|<<
literal|8
operator|)
expr_stmt|;
block|}
else|else
block|{
name|addressT
name|min
decl_stmt|,
name|max
decl_stmt|;
name|max
operator|=
operator|(
operator|(
operator|(
name|addressT
operator|)
literal|1
operator|<<
operator|(
name|operand
operator|->
name|bits
operator|-
literal|1
operator|)
operator|)
operator|<<
literal|1
operator|)
operator|-
literal|1
expr_stmt|;
name|min
operator|=
operator|(
name|offsetT
operator|)
literal|0
expr_stmt|;
name|uval
operator|=
operator|(
name|addressT
operator|)
name|val
expr_stmt|;
comment|/* Length x in an instructions has real length x+1.  */
if|if
condition|(
name|operand
operator|->
name|flags
operator|&
name|S390_OPERAND_LENGTH
condition|)
name|uval
operator|--
expr_stmt|;
comment|/* Check for underflow / overflow.  */
if|if
condition|(
name|uval
operator|<
name|min
operator|||
name|uval
operator|>
name|max
condition|)
block|{
specifier|const
name|char
modifier|*
name|err
init|=
literal|"operand out of range (%s not between %ld and %ld)"
decl_stmt|;
name|char
name|buf
index|[
literal|100
index|]
decl_stmt|;
if|if
condition|(
name|operand
operator|->
name|flags
operator|&
name|S390_OPERAND_LENGTH
condition|)
block|{
name|uval
operator|++
expr_stmt|;
name|min
operator|++
expr_stmt|;
name|max
operator|++
expr_stmt|;
block|}
name|sprint_value
argument_list|(
name|buf
argument_list|,
name|uval
argument_list|)
expr_stmt|;
if|if
condition|(
name|file
operator|==
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
name|as_bad
argument_list|(
name|err
argument_list|,
name|buf
argument_list|,
operator|(
name|int
operator|)
name|min
argument_list|,
operator|(
name|int
operator|)
name|max
argument_list|)
expr_stmt|;
else|else
name|as_bad_where
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
name|err
argument_list|,
name|buf
argument_list|,
operator|(
name|int
operator|)
name|min
argument_list|,
operator|(
name|int
operator|)
name|max
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* Insert fragments of the operand byte for byte.  */
name|offset
operator|=
name|operand
operator|->
name|shift
operator|+
name|operand
operator|->
name|bits
expr_stmt|;
name|uval
operator|<<=
operator|(
operator|-
name|offset
operator|)
operator|&
literal|7
expr_stmt|;
name|insn
operator|+=
operator|(
name|offset
operator|-
literal|1
operator|)
operator|/
literal|8
expr_stmt|;
while|while
condition|(
name|uval
operator|!=
literal|0
condition|)
block|{
operator|*
name|insn
operator|--
operator||=
name|uval
expr_stmt|;
name|uval
operator|>>=
literal|8
expr_stmt|;
block|}
block|}
end_function

begin_struct
struct|struct
name|map_tls
block|{
name|char
modifier|*
name|string
decl_stmt|;
name|int
name|length
decl_stmt|;
name|bfd_reloc_code_real_type
name|reloc
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|bfd_reloc_code_real_type
name|s390_tls_suffix
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|,
name|expressionS
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Parse tls marker and return the desired relocation.  */
end_comment

begin_function
specifier|static
name|bfd_reloc_code_real_type
name|s390_tls_suffix
parameter_list|(
name|str_p
parameter_list|,
name|exp_p
parameter_list|)
name|char
modifier|*
modifier|*
name|str_p
decl_stmt|;
name|expressionS
modifier|*
name|exp_p
decl_stmt|;
block|{
specifier|static
name|struct
name|map_tls
name|mapping
index|[]
init|=
block|{
block|{
literal|"tls_load"
block|,
literal|8
block|,
name|BFD_RELOC_390_TLS_LOAD
block|}
block|,
block|{
literal|"tls_gdcall"
block|,
literal|10
block|,
name|BFD_RELOC_390_TLS_GDCALL
block|}
block|,
block|{
literal|"tls_ldcall"
block|,
literal|10
block|,
name|BFD_RELOC_390_TLS_LDCALL
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|,
name|BFD_RELOC_UNUSED
block|}
block|}
decl_stmt|;
name|struct
name|map_tls
modifier|*
name|ptr
decl_stmt|;
name|char
modifier|*
name|orig_line
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|;
name|char
modifier|*
name|ident
decl_stmt|;
name|int
name|len
decl_stmt|;
name|str
operator|=
operator|*
name|str_p
expr_stmt|;
if|if
condition|(
operator|*
name|str
operator|++
operator|!=
literal|':'
condition|)
return|return
name|BFD_RELOC_UNUSED
return|;
name|ident
operator|=
name|str
expr_stmt|;
while|while
condition|(
name|ISIDNUM
argument_list|(
operator|*
name|str
argument_list|)
condition|)
name|str
operator|++
expr_stmt|;
name|len
operator|=
name|str
operator|-
name|ident
expr_stmt|;
if|if
condition|(
operator|*
name|str
operator|++
operator|!=
literal|':'
condition|)
return|return
name|BFD_RELOC_UNUSED
return|;
name|orig_line
operator|=
name|input_line_pointer
expr_stmt|;
name|input_line_pointer
operator|=
name|str
expr_stmt|;
name|expression
argument_list|(
name|exp_p
argument_list|)
expr_stmt|;
name|str
operator|=
name|input_line_pointer
expr_stmt|;
if|if
condition|(
operator|&
name|input_line_pointer
operator|!=
name|str_p
condition|)
name|input_line_pointer
operator|=
name|orig_line
expr_stmt|;
if|if
condition|(
name|exp_p
operator|->
name|X_op
operator|!=
name|O_symbol
condition|)
return|return
name|BFD_RELOC_UNUSED
return|;
for|for
control|(
name|ptr
operator|=
operator|&
name|mapping
index|[
literal|0
index|]
init|;
name|ptr
operator|->
name|length
operator|>
literal|0
condition|;
name|ptr
operator|++
control|)
if|if
condition|(
name|len
operator|==
name|ptr
operator|->
name|length
operator|&&
name|strncasecmp
argument_list|(
name|ident
argument_list|,
name|ptr
operator|->
name|string
argument_list|,
name|ptr
operator|->
name|length
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Found a matching tls suffix.  */
operator|*
name|str_p
operator|=
name|str
expr_stmt|;
return|return
name|ptr
operator|->
name|reloc
return|;
block|}
return|return
name|BFD_RELOC_UNUSED
return|;
block|}
end_function

begin_comment
comment|/* Structure used to hold suffixes.  */
end_comment

begin_typedef
typedef|typedef
enum|enum
block|{
name|ELF_SUFFIX_NONE
init|=
literal|0
block|,
name|ELF_SUFFIX_GOT
block|,
name|ELF_SUFFIX_PLT
block|,
name|ELF_SUFFIX_GOTENT
block|,
name|ELF_SUFFIX_GOTOFF
block|,
name|ELF_SUFFIX_GOTPLT
block|,
name|ELF_SUFFIX_PLTOFF
block|,
name|ELF_SUFFIX_TLS_GD
block|,
name|ELF_SUFFIX_TLS_GOTIE
block|,
name|ELF_SUFFIX_TLS_IE
block|,
name|ELF_SUFFIX_TLS_LDM
block|,
name|ELF_SUFFIX_TLS_LDO
block|,
name|ELF_SUFFIX_TLS_LE
block|}
name|elf_suffix_type
typedef|;
end_typedef

begin_struct
struct|struct
name|map_bfd
block|{
name|char
modifier|*
name|string
decl_stmt|;
name|int
name|length
decl_stmt|;
name|elf_suffix_type
name|suffix
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|elf_suffix_type
name|s390_elf_suffix
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|,
name|expressionS
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|s390_exp_compare
name|PARAMS
argument_list|(
operator|(
name|expressionS
operator|*
name|exp1
operator|,
name|expressionS
operator|*
name|exp2
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|elf_suffix_type
name|s390_lit_suffix
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|,
name|expressionS
operator|*
operator|,
name|elf_suffix_type
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Parse @got/@plt/@gotoff. and return the desired relocation.  */
end_comment

begin_function
specifier|static
name|elf_suffix_type
name|s390_elf_suffix
parameter_list|(
name|str_p
parameter_list|,
name|exp_p
parameter_list|)
name|char
modifier|*
modifier|*
name|str_p
decl_stmt|;
name|expressionS
modifier|*
name|exp_p
decl_stmt|;
block|{
specifier|static
name|struct
name|map_bfd
name|mapping
index|[]
init|=
block|{
block|{
literal|"got"
block|,
literal|3
block|,
name|ELF_SUFFIX_GOT
block|}
block|,
block|{
literal|"got12"
block|,
literal|5
block|,
name|ELF_SUFFIX_GOT
block|}
block|,
block|{
literal|"plt"
block|,
literal|3
block|,
name|ELF_SUFFIX_PLT
block|}
block|,
block|{
literal|"gotent"
block|,
literal|6
block|,
name|ELF_SUFFIX_GOTENT
block|}
block|,
block|{
literal|"gotoff"
block|,
literal|6
block|,
name|ELF_SUFFIX_GOTOFF
block|}
block|,
block|{
literal|"gotplt"
block|,
literal|6
block|,
name|ELF_SUFFIX_GOTPLT
block|}
block|,
block|{
literal|"pltoff"
block|,
literal|6
block|,
name|ELF_SUFFIX_PLTOFF
block|}
block|,
block|{
literal|"tlsgd"
block|,
literal|5
block|,
name|ELF_SUFFIX_TLS_GD
block|}
block|,
block|{
literal|"gotntpoff"
block|,
literal|9
block|,
name|ELF_SUFFIX_TLS_GOTIE
block|}
block|,
block|{
literal|"indntpoff"
block|,
literal|9
block|,
name|ELF_SUFFIX_TLS_IE
block|}
block|,
block|{
literal|"tlsldm"
block|,
literal|6
block|,
name|ELF_SUFFIX_TLS_LDM
block|}
block|,
block|{
literal|"dtpoff"
block|,
literal|6
block|,
name|ELF_SUFFIX_TLS_LDO
block|}
block|,
block|{
literal|"ntpoff"
block|,
literal|6
block|,
name|ELF_SUFFIX_TLS_LE
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|,
name|ELF_SUFFIX_NONE
block|}
block|}
decl_stmt|;
name|struct
name|map_bfd
modifier|*
name|ptr
decl_stmt|;
name|char
modifier|*
name|str
init|=
operator|*
name|str_p
decl_stmt|;
name|char
modifier|*
name|ident
decl_stmt|;
name|int
name|len
decl_stmt|;
if|if
condition|(
operator|*
name|str
operator|++
operator|!=
literal|'@'
condition|)
return|return
name|ELF_SUFFIX_NONE
return|;
name|ident
operator|=
name|str
expr_stmt|;
while|while
condition|(
name|ISALNUM
argument_list|(
operator|*
name|str
argument_list|)
condition|)
name|str
operator|++
expr_stmt|;
name|len
operator|=
name|str
operator|-
name|ident
expr_stmt|;
for|for
control|(
name|ptr
operator|=
operator|&
name|mapping
index|[
literal|0
index|]
init|;
name|ptr
operator|->
name|length
operator|>
literal|0
condition|;
name|ptr
operator|++
control|)
if|if
condition|(
name|len
operator|==
name|ptr
operator|->
name|length
operator|&&
name|strncasecmp
argument_list|(
name|ident
argument_list|,
name|ptr
operator|->
name|string
argument_list|,
name|ptr
operator|->
name|length
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|exp_p
operator|->
name|X_add_number
operator|!=
literal|0
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"identifier+constant@%s means identifier@%s+constant"
argument_list|)
argument_list|,
name|ptr
operator|->
name|string
argument_list|,
name|ptr
operator|->
name|string
argument_list|)
expr_stmt|;
comment|/* Now check for identifier@suffix+constant.  */
if|if
condition|(
operator|*
name|str
operator|==
literal|'-'
operator|||
operator|*
name|str
operator|==
literal|'+'
condition|)
block|{
name|char
modifier|*
name|orig_line
init|=
name|input_line_pointer
decl_stmt|;
name|expressionS
name|new_exp
decl_stmt|;
name|input_line_pointer
operator|=
name|str
expr_stmt|;
name|expression
argument_list|(
operator|&
name|new_exp
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|new_exp
operator|.
name|X_op
condition|)
block|{
case|case
name|O_constant
case|:
comment|/* X_add_number (a constant expression).  */
name|exp_p
operator|->
name|X_add_number
operator|+=
name|new_exp
operator|.
name|X_add_number
expr_stmt|;
name|str
operator|=
name|input_line_pointer
expr_stmt|;
break|break;
case|case
name|O_symbol
case|:
comment|/* X_add_symbol + X_add_number.  */
comment|/* this case is used for e.g. xyz@PLT+.Label.  */
name|exp_p
operator|->
name|X_add_number
operator|+=
name|new_exp
operator|.
name|X_add_number
expr_stmt|;
name|exp_p
operator|->
name|X_op_symbol
operator|=
name|new_exp
operator|.
name|X_add_symbol
expr_stmt|;
name|exp_p
operator|->
name|X_op
operator|=
name|O_add
expr_stmt|;
name|str
operator|=
name|input_line_pointer
expr_stmt|;
break|break;
case|case
name|O_uminus
case|:
comment|/* (- X_add_symbol) + X_add_number.  */
comment|/* this case is used for e.g. xyz@PLT-.Label.  */
name|exp_p
operator|->
name|X_add_number
operator|+=
name|new_exp
operator|.
name|X_add_number
expr_stmt|;
name|exp_p
operator|->
name|X_op_symbol
operator|=
name|new_exp
operator|.
name|X_add_symbol
expr_stmt|;
name|exp_p
operator|->
name|X_op
operator|=
name|O_subtract
expr_stmt|;
name|str
operator|=
name|input_line_pointer
expr_stmt|;
break|break;
default|default:
break|break;
block|}
comment|/* If s390_elf_suffix has not been called with&input_line_pointer as first parameter, we have 	       clobbered the input_line_pointer. We have to 	       undo that.  */
if|if
condition|(
operator|&
name|input_line_pointer
operator|!=
name|str_p
condition|)
name|input_line_pointer
operator|=
name|orig_line
expr_stmt|;
block|}
operator|*
name|str_p
operator|=
name|str
expr_stmt|;
return|return
name|ptr
operator|->
name|suffix
return|;
block|}
return|return
name|BFD_RELOC_UNUSED
return|;
block|}
end_function

begin_comment
comment|/* Structure used to hold a literal pool entry.  */
end_comment

begin_struct
struct|struct
name|s390_lpe
block|{
name|struct
name|s390_lpe
modifier|*
name|next
decl_stmt|;
name|expressionS
name|ex
decl_stmt|;
name|FLONUM_TYPE
name|floatnum
decl_stmt|;
comment|/* used if X_op == O_big&& X_add_number<= 0 */
name|LITTLENUM_TYPE
name|bignum
index|[
literal|4
index|]
decl_stmt|;
comment|/* used if X_op == O_big&& X_add_number> 0  */
name|int
name|nbytes
decl_stmt|;
name|bfd_reloc_code_real_type
name|reloc
decl_stmt|;
name|symbolS
modifier|*
name|sym
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|s390_lpe
modifier|*
name|lpe_free_list
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|s390_lpe
modifier|*
name|lpe_list
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|s390_lpe
modifier|*
name|lpe_list_tail
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|symbolS
modifier|*
name|lp_sym
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|lp_count
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|lpe_count
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|s390_exp_compare
parameter_list|(
name|exp1
parameter_list|,
name|exp2
parameter_list|)
name|expressionS
modifier|*
name|exp1
decl_stmt|;
name|expressionS
modifier|*
name|exp2
decl_stmt|;
block|{
if|if
condition|(
name|exp1
operator|->
name|X_op
operator|!=
name|exp2
operator|->
name|X_op
condition|)
return|return
literal|0
return|;
switch|switch
condition|(
name|exp1
operator|->
name|X_op
condition|)
block|{
case|case
name|O_constant
case|:
comment|/* X_add_number must be equal.  */
case|case
name|O_register
case|:
return|return
name|exp1
operator|->
name|X_add_number
operator|==
name|exp2
operator|->
name|X_add_number
return|;
case|case
name|O_big
case|:
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Can't handle O_big in s390_exp_compare"
argument_list|)
argument_list|)
expr_stmt|;
case|case
name|O_symbol
case|:
comment|/* X_add_symbol& X_add_number must be equal.  */
case|case
name|O_symbol_rva
case|:
case|case
name|O_uminus
case|:
case|case
name|O_bit_not
case|:
case|case
name|O_logical_not
case|:
return|return
operator|(
name|exp1
operator|->
name|X_add_symbol
operator|==
name|exp2
operator|->
name|X_add_symbol
operator|)
operator|&&
operator|(
name|exp1
operator|->
name|X_add_number
operator|==
name|exp2
operator|->
name|X_add_number
operator|)
return|;
case|case
name|O_multiply
case|:
comment|/* X_add_symbol,X_op_symbol&X_add_number must be equal.  */
case|case
name|O_divide
case|:
case|case
name|O_modulus
case|:
case|case
name|O_left_shift
case|:
case|case
name|O_right_shift
case|:
case|case
name|O_bit_inclusive_or
case|:
case|case
name|O_bit_or_not
case|:
case|case
name|O_bit_exclusive_or
case|:
case|case
name|O_bit_and
case|:
case|case
name|O_add
case|:
case|case
name|O_subtract
case|:
case|case
name|O_eq
case|:
case|case
name|O_ne
case|:
case|case
name|O_lt
case|:
case|case
name|O_le
case|:
case|case
name|O_ge
case|:
case|case
name|O_gt
case|:
case|case
name|O_logical_and
case|:
case|case
name|O_logical_or
case|:
return|return
operator|(
name|exp1
operator|->
name|X_add_symbol
operator|==
name|exp2
operator|->
name|X_add_symbol
operator|)
operator|&&
operator|(
name|exp1
operator|->
name|X_op_symbol
operator|==
name|exp2
operator|->
name|X_op_symbol
operator|)
operator|&&
operator|(
name|exp1
operator|->
name|X_add_number
operator|==
name|exp2
operator|->
name|X_add_number
operator|)
return|;
default|default:
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/* Test for @lit and if its present make an entry in the literal pool and    modify the current expression to be an offset into the literal pool.  */
end_comment

begin_function
specifier|static
name|elf_suffix_type
name|s390_lit_suffix
parameter_list|(
name|str_p
parameter_list|,
name|exp_p
parameter_list|,
name|suffix
parameter_list|)
name|char
modifier|*
modifier|*
name|str_p
decl_stmt|;
name|expressionS
modifier|*
name|exp_p
decl_stmt|;
name|elf_suffix_type
name|suffix
decl_stmt|;
block|{
name|bfd_reloc_code_real_type
name|reloc
decl_stmt|;
name|char
name|tmp_name
index|[
literal|64
index|]
decl_stmt|;
name|char
modifier|*
name|str
init|=
operator|*
name|str_p
decl_stmt|;
name|char
modifier|*
name|ident
decl_stmt|;
name|struct
name|s390_lpe
modifier|*
name|lpe
decl_stmt|;
name|int
name|nbytes
decl_stmt|,
name|len
decl_stmt|;
if|if
condition|(
operator|*
name|str
operator|++
operator|!=
literal|':'
condition|)
return|return
name|suffix
return|;
comment|/* No modification.  */
comment|/* We look for a suffix of the form "@lit1", "@lit2", "@lit4" or "@lit8".  */
name|ident
operator|=
name|str
expr_stmt|;
while|while
condition|(
name|ISALNUM
argument_list|(
operator|*
name|str
argument_list|)
condition|)
name|str
operator|++
expr_stmt|;
name|len
operator|=
name|str
operator|-
name|ident
expr_stmt|;
if|if
condition|(
name|len
operator|!=
literal|4
operator|||
name|strncasecmp
argument_list|(
name|ident
argument_list|,
literal|"lit"
argument_list|,
literal|3
argument_list|)
operator|!=
literal|0
operator|||
operator|(
name|ident
index|[
literal|3
index|]
operator|!=
literal|'1'
operator|&&
name|ident
index|[
literal|3
index|]
operator|!=
literal|'2'
operator|&&
name|ident
index|[
literal|3
index|]
operator|!=
literal|'4'
operator|&&
name|ident
index|[
literal|3
index|]
operator|!=
literal|'8'
operator|)
condition|)
return|return
name|suffix
return|;
comment|/* no modification */
name|nbytes
operator|=
name|ident
index|[
literal|3
index|]
operator|-
literal|'0'
expr_stmt|;
name|reloc
operator|=
name|BFD_RELOC_UNUSED
expr_stmt|;
if|if
condition|(
name|suffix
operator|==
name|ELF_SUFFIX_GOT
condition|)
block|{
if|if
condition|(
name|nbytes
operator|==
literal|2
condition|)
name|reloc
operator|=
name|BFD_RELOC_390_GOT16
expr_stmt|;
elseif|else
if|if
condition|(
name|nbytes
operator|==
literal|4
condition|)
name|reloc
operator|=
name|BFD_RELOC_32_GOT_PCREL
expr_stmt|;
elseif|else
if|if
condition|(
name|nbytes
operator|==
literal|8
condition|)
name|reloc
operator|=
name|BFD_RELOC_390_GOT64
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|suffix
operator|==
name|ELF_SUFFIX_PLT
condition|)
block|{
if|if
condition|(
name|nbytes
operator|==
literal|4
condition|)
name|reloc
operator|=
name|BFD_RELOC_390_PLT32
expr_stmt|;
elseif|else
if|if
condition|(
name|nbytes
operator|==
literal|8
condition|)
name|reloc
operator|=
name|BFD_RELOC_390_PLT64
expr_stmt|;
block|}
if|if
condition|(
name|suffix
operator|!=
name|ELF_SUFFIX_NONE
operator|&&
name|reloc
operator|==
name|BFD_RELOC_UNUSED
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Invalid suffix for literal pool entry"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Search the pool if the new entry is a duplicate.  */
if|if
condition|(
name|exp_p
operator|->
name|X_op
operator|==
name|O_big
condition|)
block|{
comment|/* Special processing for big numbers.  */
for|for
control|(
name|lpe
operator|=
name|lpe_list
init|;
name|lpe
operator|!=
name|NULL
condition|;
name|lpe
operator|=
name|lpe
operator|->
name|next
control|)
block|{
if|if
condition|(
name|lpe
operator|->
name|ex
operator|.
name|X_op
operator|==
name|O_big
condition|)
block|{
if|if
condition|(
name|exp_p
operator|->
name|X_add_number
operator|<=
literal|0
operator|&&
name|lpe
operator|->
name|ex
operator|.
name|X_add_number
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|memcmp
argument_list|(
operator|&
name|generic_floating_point_number
argument_list|,
operator|&
name|lpe
operator|->
name|floatnum
argument_list|,
sizeof|sizeof
argument_list|(
name|FLONUM_TYPE
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
break|break;
block|}
elseif|else
if|if
condition|(
name|exp_p
operator|->
name|X_add_number
operator|==
name|lpe
operator|->
name|ex
operator|.
name|X_add_number
condition|)
block|{
if|if
condition|(
name|memcmp
argument_list|(
name|generic_bignum
argument_list|,
name|lpe
operator|->
name|bignum
argument_list|,
sizeof|sizeof
argument_list|(
name|LITTLENUM_TYPE
argument_list|)
operator|*
name|exp_p
operator|->
name|X_add_number
argument_list|)
operator|==
literal|0
condition|)
break|break;
block|}
block|}
block|}
block|}
else|else
block|{
comment|/* Processing for 'normal' data types.  */
for|for
control|(
name|lpe
operator|=
name|lpe_list
init|;
name|lpe
operator|!=
name|NULL
condition|;
name|lpe
operator|=
name|lpe
operator|->
name|next
control|)
if|if
condition|(
name|lpe
operator|->
name|nbytes
operator|==
name|nbytes
operator|&&
name|lpe
operator|->
name|reloc
operator|==
name|reloc
operator|&&
name|s390_exp_compare
argument_list|(
name|exp_p
argument_list|,
operator|&
name|lpe
operator|->
name|ex
argument_list|)
operator|!=
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|lpe
operator|==
name|NULL
condition|)
block|{
comment|/* A new literal.  */
if|if
condition|(
name|lpe_free_list
operator|!=
name|NULL
condition|)
block|{
name|lpe
operator|=
name|lpe_free_list
expr_stmt|;
name|lpe_free_list
operator|=
name|lpe_free_list
operator|->
name|next
expr_stmt|;
block|}
else|else
block|{
name|lpe
operator|=
operator|(
expr|struct
name|s390_lpe
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|s390_lpe
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|lpe
operator|->
name|ex
operator|=
operator|*
name|exp_p
expr_stmt|;
if|if
condition|(
name|exp_p
operator|->
name|X_op
operator|==
name|O_big
condition|)
block|{
if|if
condition|(
name|exp_p
operator|->
name|X_add_number
operator|<=
literal|0
condition|)
name|lpe
operator|->
name|floatnum
operator|=
name|generic_floating_point_number
expr_stmt|;
elseif|else
if|if
condition|(
name|exp_p
operator|->
name|X_add_number
operator|<=
literal|4
condition|)
name|memcpy
argument_list|(
name|lpe
operator|->
name|bignum
argument_list|,
name|generic_bignum
argument_list|,
name|exp_p
operator|->
name|X_add_number
operator|*
sizeof|sizeof
argument_list|(
name|LITTLENUM_TYPE
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Big number is too big"
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|lpe
operator|->
name|nbytes
operator|=
name|nbytes
expr_stmt|;
name|lpe
operator|->
name|reloc
operator|=
name|reloc
expr_stmt|;
comment|/* Literal pool name defined ?  */
if|if
condition|(
name|lp_sym
operator|==
name|NULL
condition|)
block|{
name|sprintf
argument_list|(
name|tmp_name
argument_list|,
literal|".L\001%i"
argument_list|,
name|lp_count
argument_list|)
expr_stmt|;
name|lp_sym
operator|=
name|symbol_make
argument_list|(
name|tmp_name
argument_list|)
expr_stmt|;
block|}
comment|/* Make name for literal pool entry.  */
name|sprintf
argument_list|(
name|tmp_name
argument_list|,
literal|".L\001%i\002%i"
argument_list|,
name|lp_count
argument_list|,
name|lpe_count
argument_list|)
expr_stmt|;
name|lpe_count
operator|++
expr_stmt|;
name|lpe
operator|->
name|sym
operator|=
name|symbol_make
argument_list|(
name|tmp_name
argument_list|)
expr_stmt|;
comment|/* Add to literal pool list.  */
name|lpe
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|lpe_list_tail
operator|!=
name|NULL
condition|)
block|{
name|lpe_list_tail
operator|->
name|next
operator|=
name|lpe
expr_stmt|;
name|lpe_list_tail
operator|=
name|lpe
expr_stmt|;
block|}
else|else
name|lpe_list
operator|=
name|lpe_list_tail
operator|=
name|lpe
expr_stmt|;
block|}
comment|/* Now change exp_p to the offset into the literal pool.      Thats the expression: .L^Ax^By-.L^Ax   */
name|exp_p
operator|->
name|X_add_symbol
operator|=
name|lpe
operator|->
name|sym
expr_stmt|;
name|exp_p
operator|->
name|X_op_symbol
operator|=
name|lp_sym
expr_stmt|;
name|exp_p
operator|->
name|X_op
operator|=
name|O_subtract
expr_stmt|;
name|exp_p
operator|->
name|X_add_number
operator|=
literal|0
expr_stmt|;
operator|*
name|str_p
operator|=
name|str
expr_stmt|;
comment|/* We change the suffix type to ELF_SUFFIX_NONE, because      the difference of two local labels is just a number.  */
return|return
name|ELF_SUFFIX_NONE
return|;
block|}
end_function

begin_comment
comment|/* Like normal .long/.short/.word, except support @got, etc.    clobbers input_line_pointer, checks end-of-line.  */
end_comment

begin_function
specifier|static
name|void
name|s390_elf_cons
parameter_list|(
name|nbytes
parameter_list|)
specifier|register
name|int
name|nbytes
decl_stmt|;
comment|/* 1=.byte, 2=.word, 4=.long */
block|{
name|expressionS
name|exp
decl_stmt|;
name|elf_suffix_type
name|suffix
decl_stmt|;
if|if
condition|(
name|is_it_end_of_statement
argument_list|()
condition|)
block|{
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
do|do
block|{
name|expression
argument_list|(
operator|&
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
name|exp
operator|.
name|X_op
operator|==
name|O_symbol
operator|&&
operator|*
name|input_line_pointer
operator|==
literal|'@'
operator|&&
operator|(
name|suffix
operator|=
name|s390_elf_suffix
argument_list|(
operator|&
name|input_line_pointer
argument_list|,
operator|&
name|exp
argument_list|)
operator|)
operator|!=
name|ELF_SUFFIX_NONE
condition|)
block|{
name|bfd_reloc_code_real_type
name|reloc
decl_stmt|;
name|reloc_howto_type
modifier|*
name|reloc_howto
decl_stmt|;
name|int
name|size
decl_stmt|;
name|char
modifier|*
name|where
decl_stmt|;
if|if
condition|(
name|nbytes
operator|==
literal|2
condition|)
block|{
specifier|static
name|bfd_reloc_code_real_type
name|tab2
index|[]
init|=
block|{
name|BFD_RELOC_UNUSED
block|,
comment|/* ELF_SUFFIX_NONE  */
name|BFD_RELOC_390_GOT16
block|,
comment|/* ELF_SUFFIX_GOT  */
name|BFD_RELOC_UNUSED
block|,
comment|/* ELF_SUFFIX_PLT  */
name|BFD_RELOC_UNUSED
block|,
comment|/* ELF_SUFFIX_GOTENT  */
name|BFD_RELOC_16_GOTOFF
block|,
comment|/* ELF_SUFFIX_GOTOFF  */
name|BFD_RELOC_UNUSED
block|,
comment|/* ELF_SUFFIX_GOTPLT  */
name|BFD_RELOC_390_PLTOFF16
block|,
comment|/* ELF_SUFFIX_PLTOFF  */
name|BFD_RELOC_UNUSED
block|,
comment|/* ELF_SUFFIX_TLS_GD  */
name|BFD_RELOC_UNUSED
block|,
comment|/* ELF_SUFFIX_TLS_GOTIE  */
name|BFD_RELOC_UNUSED
block|,
comment|/* ELF_SUFFIX_TLS_IE  */
name|BFD_RELOC_UNUSED
block|,
comment|/* ELF_SUFFIX_TLS_LDM  */
name|BFD_RELOC_UNUSED
block|,
comment|/* ELF_SUFFIX_TLS_LDO  */
name|BFD_RELOC_UNUSED
comment|/* ELF_SUFFIX_TLS_LE  */
block|}
decl_stmt|;
name|reloc
operator|=
name|tab2
index|[
name|suffix
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nbytes
operator|==
literal|4
condition|)
block|{
specifier|static
name|bfd_reloc_code_real_type
name|tab4
index|[]
init|=
block|{
name|BFD_RELOC_UNUSED
block|,
comment|/* ELF_SUFFIX_NONE  */
name|BFD_RELOC_32_GOT_PCREL
block|,
comment|/* ELF_SUFFIX_GOT  */
name|BFD_RELOC_390_PLT32
block|,
comment|/* ELF_SUFFIX_PLT  */
name|BFD_RELOC_UNUSED
block|,
comment|/* ELF_SUFFIX_GOTENT  */
name|BFD_RELOC_32_GOTOFF
block|,
comment|/* ELF_SUFFIX_GOTOFF  */
name|BFD_RELOC_390_GOTPLT32
block|,
comment|/* ELF_SUFFIX_GOTPLT  */
name|BFD_RELOC_390_PLTOFF32
block|,
comment|/* ELF_SUFFIX_PLTOFF  */
name|BFD_RELOC_390_TLS_GD32
block|,
comment|/* ELF_SUFFIX_TLS_GD  */
name|BFD_RELOC_390_TLS_GOTIE32
block|,
comment|/* ELF_SUFFIX_TLS_GOTIE  */
name|BFD_RELOC_390_TLS_IE32
block|,
comment|/* ELF_SUFFIX_TLS_IE  */
name|BFD_RELOC_390_TLS_LDM32
block|,
comment|/* ELF_SUFFIX_TLS_LDM  */
name|BFD_RELOC_390_TLS_LDO32
block|,
comment|/* ELF_SUFFIX_TLS_LDO  */
name|BFD_RELOC_390_TLS_LE32
comment|/* ELF_SUFFIX_TLS_LE  */
block|}
decl_stmt|;
name|reloc
operator|=
name|tab4
index|[
name|suffix
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nbytes
operator|==
literal|8
condition|)
block|{
specifier|static
name|bfd_reloc_code_real_type
name|tab8
index|[]
init|=
block|{
name|BFD_RELOC_UNUSED
block|,
comment|/* ELF_SUFFIX_NONE  */
name|BFD_RELOC_390_GOT64
block|,
comment|/* ELF_SUFFIX_GOT  */
name|BFD_RELOC_390_PLT64
block|,
comment|/* ELF_SUFFIX_PLT  */
name|BFD_RELOC_UNUSED
block|,
comment|/* ELF_SUFFIX_GOTENT  */
name|BFD_RELOC_390_GOTOFF64
block|,
comment|/* ELF_SUFFIX_GOTOFF  */
name|BFD_RELOC_390_GOTPLT64
block|,
comment|/* ELF_SUFFIX_GOTPLT  */
name|BFD_RELOC_390_PLTOFF64
block|,
comment|/* ELF_SUFFIX_PLTOFF  */
name|BFD_RELOC_390_TLS_GD64
block|,
comment|/* ELF_SUFFIX_TLS_GD  */
name|BFD_RELOC_390_TLS_GOTIE64
block|,
comment|/* ELF_SUFFIX_TLS_GOTIE  */
name|BFD_RELOC_390_TLS_IE64
block|,
comment|/* ELF_SUFFIX_TLS_IE  */
name|BFD_RELOC_390_TLS_LDM64
block|,
comment|/* ELF_SUFFIX_TLS_LDM  */
name|BFD_RELOC_390_TLS_LDO64
block|,
comment|/* ELF_SUFFIX_TLS_LDO  */
name|BFD_RELOC_390_TLS_LE64
comment|/* ELF_SUFFIX_TLS_LE  */
block|}
decl_stmt|;
name|reloc
operator|=
name|tab8
index|[
name|suffix
index|]
expr_stmt|;
block|}
else|else
name|reloc
operator|=
name|BFD_RELOC_UNUSED
expr_stmt|;
if|if
condition|(
name|reloc
operator|!=
name|BFD_RELOC_UNUSED
operator|&&
operator|(
name|reloc_howto
operator|=
name|bfd_reloc_type_lookup
argument_list|(
name|stdoutput
argument_list|,
name|reloc
argument_list|)
operator|)
condition|)
block|{
name|size
operator|=
name|bfd_get_reloc_size
argument_list|(
name|reloc_howto
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|>
name|nbytes
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"%s relocations do not fit in %d bytes"
argument_list|)
argument_list|,
name|reloc_howto
operator|->
name|name
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
name|where
operator|=
name|frag_more
argument_list|(
name|nbytes
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|where
argument_list|,
literal|0
argument_list|,
name|size
argument_list|)
expr_stmt|;
comment|/* To make fixup_segment do the pc relative conversion the 		 pcrel parameter on the fix_new_exp call needs to be FALSE.  */
name|fix_new_exp
argument_list|(
name|frag_now
argument_list|,
name|where
operator|-
name|frag_now
operator|->
name|fr_literal
argument_list|,
name|size
argument_list|,
operator|&
name|exp
argument_list|,
name|FALSE
argument_list|,
name|reloc
argument_list|)
expr_stmt|;
block|}
else|else
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"relocation not applicable"
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|emit_expr
argument_list|(
operator|&
name|exp
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|nbytes
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|*
name|input_line_pointer
operator|++
operator|==
literal|','
condition|)
do|;
name|input_line_pointer
operator|--
expr_stmt|;
comment|/* Put terminator back into stream.  */
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* We need to keep a list of fixups.  We can't simply generate them as    we go, because that would require us to first create the frag, and    that would screw up references to ``.''.  */
end_comment

begin_struct
struct|struct
name|s390_fixup
block|{
name|expressionS
name|exp
decl_stmt|;
name|int
name|opindex
decl_stmt|;
name|bfd_reloc_code_real_type
name|reloc
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|MAX_INSN_FIXUPS
value|(4)
end_define

begin_comment
comment|/* This routine is called for each instruction to be assembled.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|md_gather_operands
parameter_list|(
name|str
parameter_list|,
name|insn
parameter_list|,
name|opcode
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
name|unsigned
name|char
modifier|*
name|insn
decl_stmt|;
specifier|const
name|struct
name|s390_opcode
modifier|*
name|opcode
decl_stmt|;
block|{
name|struct
name|s390_fixup
name|fixups
index|[
name|MAX_INSN_FIXUPS
index|]
decl_stmt|;
specifier|const
name|struct
name|s390_operand
modifier|*
name|operand
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|opindex_ptr
decl_stmt|;
name|expressionS
name|ex
decl_stmt|;
name|elf_suffix_type
name|suffix
decl_stmt|;
name|bfd_reloc_code_real_type
name|reloc
decl_stmt|;
name|int
name|skip_optional
decl_stmt|;
name|int
name|parentheses
decl_stmt|;
name|char
modifier|*
name|f
decl_stmt|;
name|int
name|fc
decl_stmt|,
name|i
decl_stmt|;
while|while
condition|(
name|ISSPACE
argument_list|(
operator|*
name|str
argument_list|)
condition|)
name|str
operator|++
expr_stmt|;
name|parentheses
operator|=
literal|0
expr_stmt|;
name|skip_optional
operator|=
literal|0
expr_stmt|;
comment|/* Gather the operands.  */
name|fc
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|opindex_ptr
operator|=
name|opcode
operator|->
name|operands
init|;
operator|*
name|opindex_ptr
operator|!=
literal|0
condition|;
name|opindex_ptr
operator|++
control|)
block|{
name|char
modifier|*
name|hold
decl_stmt|;
name|operand
operator|=
name|s390_operands
operator|+
operator|*
name|opindex_ptr
expr_stmt|;
if|if
condition|(
name|skip_optional
operator|&&
operator|(
name|operand
operator|->
name|flags
operator|&
name|S390_OPERAND_INDEX
operator|)
condition|)
block|{
comment|/* We do an early skip. For D(X,B) constructions the index 	     register is skipped (X is optional). For D(L,B) the base 	     register will be the skipped operand, because L is NOT 	     optional.  */
name|skip_optional
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
comment|/* Gather the operand.  */
name|hold
operator|=
name|input_line_pointer
expr_stmt|;
name|input_line_pointer
operator|=
name|str
expr_stmt|;
comment|/* Parse the operand.  */
if|if
condition|(
operator|!
name|register_name
argument_list|(
operator|&
name|ex
argument_list|)
condition|)
name|expression
argument_list|(
operator|&
name|ex
argument_list|)
expr_stmt|;
name|str
operator|=
name|input_line_pointer
expr_stmt|;
name|input_line_pointer
operator|=
name|hold
expr_stmt|;
comment|/* Write the operand to the insn.  */
if|if
condition|(
name|ex
operator|.
name|X_op
operator|==
name|O_illegal
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"illegal operand"
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ex
operator|.
name|X_op
operator|==
name|O_absent
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"missing operand"
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ex
operator|.
name|X_op
operator|==
name|O_register
operator|||
name|ex
operator|.
name|X_op
operator|==
name|O_constant
condition|)
block|{
name|s390_lit_suffix
argument_list|(
operator|&
name|str
argument_list|,
operator|&
name|ex
argument_list|,
name|ELF_SUFFIX_NONE
argument_list|)
expr_stmt|;
if|if
condition|(
name|ex
operator|.
name|X_op
operator|!=
name|O_register
operator|&&
name|ex
operator|.
name|X_op
operator|!=
name|O_constant
condition|)
block|{
comment|/* We need to generate a fixup for the 		 expression returned by s390_lit_suffix.  */
if|if
condition|(
name|fc
operator|>=
name|MAX_INSN_FIXUPS
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"too many fixups"
argument_list|)
argument_list|)
expr_stmt|;
name|fixups
index|[
name|fc
index|]
operator|.
name|exp
operator|=
name|ex
expr_stmt|;
name|fixups
index|[
name|fc
index|]
operator|.
name|opindex
operator|=
operator|*
name|opindex_ptr
expr_stmt|;
name|fixups
index|[
name|fc
index|]
operator|.
name|reloc
operator|=
name|BFD_RELOC_UNUSED
expr_stmt|;
operator|++
name|fc
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|operand
operator|->
name|flags
operator|&
name|S390_OPERAND_INDEX
operator|)
operator|&&
name|ex
operator|.
name|X_add_number
operator|==
literal|0
operator|&&
name|warn_areg_zero
condition|)
name|as_warn
argument_list|(
literal|"index register specified but zero"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|operand
operator|->
name|flags
operator|&
name|S390_OPERAND_BASE
operator|)
operator|&&
name|ex
operator|.
name|X_add_number
operator|==
literal|0
operator|&&
name|warn_areg_zero
condition|)
name|as_warn
argument_list|(
literal|"base register specified but zero"
argument_list|)
expr_stmt|;
name|s390_insert_operand
argument_list|(
name|insn
argument_list|,
name|operand
argument_list|,
name|ex
operator|.
name|X_add_number
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|suffix
operator|=
name|s390_elf_suffix
argument_list|(
operator|&
name|str
argument_list|,
operator|&
name|ex
argument_list|)
expr_stmt|;
name|suffix
operator|=
name|s390_lit_suffix
argument_list|(
operator|&
name|str
argument_list|,
operator|&
name|ex
argument_list|,
name|suffix
argument_list|)
expr_stmt|;
name|reloc
operator|=
name|BFD_RELOC_UNUSED
expr_stmt|;
if|if
condition|(
name|suffix
operator|==
name|ELF_SUFFIX_GOT
condition|)
block|{
if|if
condition|(
operator|(
name|operand
operator|->
name|flags
operator|&
name|S390_OPERAND_DISP
operator|)
operator|&&
operator|(
name|operand
operator|->
name|bits
operator|==
literal|12
operator|)
condition|)
name|reloc
operator|=
name|BFD_RELOC_390_GOT12
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|operand
operator|->
name|flags
operator|&
name|S390_OPERAND_DISP
operator|)
operator|&&
operator|(
name|operand
operator|->
name|bits
operator|==
literal|20
operator|)
condition|)
name|reloc
operator|=
name|BFD_RELOC_390_GOT20
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|operand
operator|->
name|flags
operator|&
name|S390_OPERAND_SIGNED
operator|)
operator|&&
operator|(
name|operand
operator|->
name|bits
operator|==
literal|16
operator|)
condition|)
name|reloc
operator|=
name|BFD_RELOC_390_GOT16
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|operand
operator|->
name|flags
operator|&
name|S390_OPERAND_PCREL
operator|)
operator|&&
operator|(
name|operand
operator|->
name|bits
operator|==
literal|32
operator|)
condition|)
name|reloc
operator|=
name|BFD_RELOC_390_GOTENT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|suffix
operator|==
name|ELF_SUFFIX_PLT
condition|)
block|{
if|if
condition|(
operator|(
name|operand
operator|->
name|flags
operator|&
name|S390_OPERAND_PCREL
operator|)
operator|&&
operator|(
name|operand
operator|->
name|bits
operator|==
literal|16
operator|)
condition|)
name|reloc
operator|=
name|BFD_RELOC_390_PLT16DBL
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|operand
operator|->
name|flags
operator|&
name|S390_OPERAND_PCREL
operator|)
operator|&&
operator|(
name|operand
operator|->
name|bits
operator|==
literal|32
operator|)
condition|)
name|reloc
operator|=
name|BFD_RELOC_390_PLT32DBL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|suffix
operator|==
name|ELF_SUFFIX_GOTENT
condition|)
block|{
if|if
condition|(
operator|(
name|operand
operator|->
name|flags
operator|&
name|S390_OPERAND_PCREL
operator|)
operator|&&
operator|(
name|operand
operator|->
name|bits
operator|==
literal|32
operator|)
condition|)
name|reloc
operator|=
name|BFD_RELOC_390_GOTENT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|suffix
operator|==
name|ELF_SUFFIX_GOTOFF
condition|)
block|{
if|if
condition|(
operator|(
name|operand
operator|->
name|flags
operator|&
name|S390_OPERAND_SIGNED
operator|)
operator|&&
operator|(
name|operand
operator|->
name|bits
operator|==
literal|16
operator|)
condition|)
name|reloc
operator|=
name|BFD_RELOC_16_GOTOFF
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|suffix
operator|==
name|ELF_SUFFIX_PLTOFF
condition|)
block|{
if|if
condition|(
operator|(
name|operand
operator|->
name|flags
operator|&
name|S390_OPERAND_SIGNED
operator|)
operator|&&
operator|(
name|operand
operator|->
name|bits
operator|==
literal|16
operator|)
condition|)
name|reloc
operator|=
name|BFD_RELOC_390_PLTOFF16
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|suffix
operator|==
name|ELF_SUFFIX_GOTPLT
condition|)
block|{
if|if
condition|(
operator|(
name|operand
operator|->
name|flags
operator|&
name|S390_OPERAND_DISP
operator|)
operator|&&
operator|(
name|operand
operator|->
name|bits
operator|==
literal|12
operator|)
condition|)
name|reloc
operator|=
name|BFD_RELOC_390_GOTPLT12
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|operand
operator|->
name|flags
operator|&
name|S390_OPERAND_SIGNED
operator|)
operator|&&
operator|(
name|operand
operator|->
name|bits
operator|==
literal|16
operator|)
condition|)
name|reloc
operator|=
name|BFD_RELOC_390_GOTPLT16
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|operand
operator|->
name|flags
operator|&
name|S390_OPERAND_PCREL
operator|)
operator|&&
operator|(
name|operand
operator|->
name|bits
operator|==
literal|32
operator|)
condition|)
name|reloc
operator|=
name|BFD_RELOC_390_GOTPLTENT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|suffix
operator|==
name|ELF_SUFFIX_TLS_GOTIE
condition|)
block|{
if|if
condition|(
operator|(
name|operand
operator|->
name|flags
operator|&
name|S390_OPERAND_DISP
operator|)
operator|&&
operator|(
name|operand
operator|->
name|bits
operator|==
literal|12
operator|)
condition|)
name|reloc
operator|=
name|BFD_RELOC_390_TLS_GOTIE12
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|operand
operator|->
name|flags
operator|&
name|S390_OPERAND_DISP
operator|)
operator|&&
operator|(
name|operand
operator|->
name|bits
operator|==
literal|20
operator|)
condition|)
name|reloc
operator|=
name|BFD_RELOC_390_TLS_GOTIE20
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|suffix
operator|==
name|ELF_SUFFIX_TLS_IE
condition|)
block|{
if|if
condition|(
operator|(
name|operand
operator|->
name|flags
operator|&
name|S390_OPERAND_PCREL
operator|)
operator|&&
operator|(
name|operand
operator|->
name|bits
operator|==
literal|32
operator|)
condition|)
name|reloc
operator|=
name|BFD_RELOC_390_TLS_IEENT
expr_stmt|;
block|}
if|if
condition|(
name|suffix
operator|!=
name|ELF_SUFFIX_NONE
operator|&&
name|reloc
operator|==
name|BFD_RELOC_UNUSED
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"invalid operand suffix"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We need to generate a fixup of type 'reloc' for this 	     expression.  */
if|if
condition|(
name|fc
operator|>=
name|MAX_INSN_FIXUPS
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"too many fixups"
argument_list|)
argument_list|)
expr_stmt|;
name|fixups
index|[
name|fc
index|]
operator|.
name|exp
operator|=
name|ex
expr_stmt|;
name|fixups
index|[
name|fc
index|]
operator|.
name|opindex
operator|=
operator|*
name|opindex_ptr
expr_stmt|;
name|fixups
index|[
name|fc
index|]
operator|.
name|reloc
operator|=
name|reloc
expr_stmt|;
operator|++
name|fc
expr_stmt|;
block|}
comment|/* Check the next character. The call to expression has advanced 	 str past any whitespace.  */
if|if
condition|(
name|operand
operator|->
name|flags
operator|&
name|S390_OPERAND_DISP
condition|)
block|{
comment|/* After a displacement a block in parentheses can start.  */
if|if
condition|(
operator|*
name|str
operator|!=
literal|'('
condition|)
block|{
comment|/* Check if parenthesized block can be skipped. If the next 		 operand is neiter an optional operand nor a base register 		 then we have a syntax error.  */
name|operand
operator|=
name|s390_operands
operator|+
operator|*
operator|(
operator|++
name|opindex_ptr
operator|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|operand
operator|->
name|flags
operator|&
operator|(
name|S390_OPERAND_INDEX
operator||
name|S390_OPERAND_BASE
operator|)
operator|)
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"syntax error; missing '(' after displacement"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Ok, skip all operands until S390_OPERAND_BASE.  */
while|while
condition|(
operator|!
operator|(
name|operand
operator|->
name|flags
operator|&
name|S390_OPERAND_BASE
operator|)
condition|)
name|operand
operator|=
name|s390_operands
operator|+
operator|*
operator|(
operator|++
name|opindex_ptr
operator|)
expr_stmt|;
comment|/* If there is a next operand it must be separated by a comma.  */
if|if
condition|(
name|opindex_ptr
index|[
literal|1
index|]
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
operator|*
name|str
operator|++
operator|!=
literal|','
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"syntax error; expected ,"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* We found an opening parentheses.  */
name|str
operator|++
expr_stmt|;
for|for
control|(
name|f
operator|=
name|str
init|;
operator|*
name|f
operator|!=
literal|'\0'
condition|;
name|f
operator|++
control|)
if|if
condition|(
operator|*
name|f
operator|==
literal|','
operator|||
operator|*
name|f
operator|==
literal|')'
condition|)
break|break;
comment|/* If there is no comma until the closing parentheses OR 		 there is a comma right after the opening parentheses, 		 we have to skip optional operands.  */
if|if
condition|(
operator|*
name|f
operator|==
literal|','
operator|&&
name|f
operator|==
name|str
condition|)
block|{
comment|/* comma directly after '(' ? */
name|skip_optional
operator|=
literal|1
expr_stmt|;
name|str
operator|++
expr_stmt|;
block|}
else|else
name|skip_optional
operator|=
operator|(
operator|*
name|f
operator|!=
literal|','
operator|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|operand
operator|->
name|flags
operator|&
name|S390_OPERAND_BASE
condition|)
block|{
comment|/* After the base register the parenthesed block ends.  */
if|if
condition|(
operator|*
name|str
operator|++
operator|!=
literal|')'
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"syntax error; missing ')' after base register"
argument_list|)
argument_list|)
expr_stmt|;
name|skip_optional
operator|=
literal|0
expr_stmt|;
comment|/* If there is a next operand it must be separated by a comma.  */
if|if
condition|(
name|opindex_ptr
index|[
literal|1
index|]
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
operator|*
name|str
operator|++
operator|!=
literal|','
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"syntax error; expected ,"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* We can find an 'early' closing parentheses in e.g. D(L) instead 	     of D(L,B).  In this case the base register has to be skipped.  */
if|if
condition|(
operator|*
name|str
operator|==
literal|')'
condition|)
block|{
name|operand
operator|=
name|s390_operands
operator|+
operator|*
operator|(
operator|++
name|opindex_ptr
operator|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|operand
operator|->
name|flags
operator|&
name|S390_OPERAND_BASE
operator|)
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"syntax error; ')' not allowed here"
argument_list|)
argument_list|)
expr_stmt|;
name|str
operator|++
expr_stmt|;
block|}
comment|/* If there is a next operand it must be separated by a comma.  */
if|if
condition|(
name|opindex_ptr
index|[
literal|1
index|]
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
operator|*
name|str
operator|++
operator|!=
literal|','
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"syntax error; expected ,"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
while|while
condition|(
name|ISSPACE
argument_list|(
operator|*
name|str
argument_list|)
condition|)
operator|++
name|str
expr_stmt|;
comment|/* Check for tls instruction marker.  */
name|reloc
operator|=
name|s390_tls_suffix
argument_list|(
operator|&
name|str
argument_list|,
operator|&
name|ex
argument_list|)
expr_stmt|;
if|if
condition|(
name|reloc
operator|!=
name|BFD_RELOC_UNUSED
condition|)
block|{
comment|/* We need to generate a fixup of type 'reloc' for this 	 instruction.  */
if|if
condition|(
name|fc
operator|>=
name|MAX_INSN_FIXUPS
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"too many fixups"
argument_list|)
argument_list|)
expr_stmt|;
name|fixups
index|[
name|fc
index|]
operator|.
name|exp
operator|=
name|ex
expr_stmt|;
name|fixups
index|[
name|fc
index|]
operator|.
name|opindex
operator|=
operator|-
literal|1
expr_stmt|;
name|fixups
index|[
name|fc
index|]
operator|.
name|reloc
operator|=
name|reloc
expr_stmt|;
operator|++
name|fc
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|str
operator|!=
literal|'\0'
condition|)
block|{
name|char
modifier|*
name|linefeed
decl_stmt|;
if|if
condition|(
operator|(
name|linefeed
operator|=
name|strchr
argument_list|(
name|str
argument_list|,
literal|'\n'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
operator|*
name|linefeed
operator|=
literal|'\0'
expr_stmt|;
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"junk at end of line: `%s'"
argument_list|)
argument_list|,
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|linefeed
operator|!=
name|NULL
condition|)
operator|*
name|linefeed
operator|=
literal|'\n'
expr_stmt|;
block|}
comment|/* Write out the instruction.  */
name|f
operator|=
name|frag_more
argument_list|(
name|opcode
operator|->
name|oplen
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|f
argument_list|,
name|insn
argument_list|,
name|opcode
operator|->
name|oplen
argument_list|)
expr_stmt|;
name|dwarf2_emit_insn
argument_list|(
name|opcode
operator|->
name|oplen
argument_list|)
expr_stmt|;
comment|/* Create any fixups.  At this point we do not use a      bfd_reloc_code_real_type, but instead just use the      BFD_RELOC_UNUSED plus the operand index.  This lets us easily      handle fixups for any operand type, although that is admittedly      not a very exciting feature.  We pick a BFD reloc type in      md_apply_fix3.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|fc
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|fixups
index|[
name|i
index|]
operator|.
name|opindex
operator|<
literal|0
condition|)
block|{
comment|/* Create tls instruction marker relocation.  */
name|fix_new_exp
argument_list|(
name|frag_now
argument_list|,
name|f
operator|-
name|frag_now
operator|->
name|fr_literal
argument_list|,
name|opcode
operator|->
name|oplen
argument_list|,
operator|&
name|fixups
index|[
name|i
index|]
operator|.
name|exp
argument_list|,
literal|0
argument_list|,
name|fixups
index|[
name|i
index|]
operator|.
name|reloc
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|operand
operator|=
name|s390_operands
operator|+
name|fixups
index|[
name|i
index|]
operator|.
name|opindex
expr_stmt|;
if|if
condition|(
name|fixups
index|[
name|i
index|]
operator|.
name|reloc
operator|!=
name|BFD_RELOC_UNUSED
condition|)
block|{
name|reloc_howto_type
modifier|*
name|reloc_howto
decl_stmt|;
name|fixS
modifier|*
name|fixP
decl_stmt|;
name|int
name|size
decl_stmt|;
name|reloc_howto
operator|=
name|bfd_reloc_type_lookup
argument_list|(
name|stdoutput
argument_list|,
name|fixups
index|[
name|i
index|]
operator|.
name|reloc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|reloc_howto
condition|)
name|abort
argument_list|()
expr_stmt|;
name|size
operator|=
name|bfd_get_reloc_size
argument_list|(
name|reloc_howto
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|<
literal|1
operator|||
name|size
operator|>
literal|4
condition|)
name|abort
argument_list|()
expr_stmt|;
name|fixP
operator|=
name|fix_new_exp
argument_list|(
name|frag_now
argument_list|,
name|f
operator|-
name|frag_now
operator|->
name|fr_literal
operator|+
operator|(
name|operand
operator|->
name|shift
operator|/
literal|8
operator|)
argument_list|,
name|size
argument_list|,
operator|&
name|fixups
index|[
name|i
index|]
operator|.
name|exp
argument_list|,
name|reloc_howto
operator|->
name|pc_relative
argument_list|,
name|fixups
index|[
name|i
index|]
operator|.
name|reloc
argument_list|)
expr_stmt|;
comment|/* Turn off overflow checking in fixup_segment. This is necessary 	     because fixup_segment will signal an overflow for large 4 byte 	     quantities for GOT12 relocations.  */
if|if
condition|(
name|fixups
index|[
name|i
index|]
operator|.
name|reloc
operator|==
name|BFD_RELOC_390_GOT12
operator|||
name|fixups
index|[
name|i
index|]
operator|.
name|reloc
operator|==
name|BFD_RELOC_390_GOT20
operator|||
name|fixups
index|[
name|i
index|]
operator|.
name|reloc
operator|==
name|BFD_RELOC_390_GOT16
condition|)
name|fixP
operator|->
name|fx_no_overflow
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|fix_new_exp
argument_list|(
name|frag_now
argument_list|,
name|f
operator|-
name|frag_now
operator|->
name|fr_literal
argument_list|,
literal|4
argument_list|,
operator|&
name|fixups
index|[
name|i
index|]
operator|.
name|exp
argument_list|,
operator|(
name|operand
operator|->
name|flags
operator|&
name|S390_OPERAND_PCREL
operator|)
operator|!=
literal|0
argument_list|,
operator|(
call|(
name|bfd_reloc_code_real_type
call|)
argument_list|(
name|fixups
index|[
name|i
index|]
operator|.
name|opindex
operator|+
operator|(
name|int
operator|)
name|BFD_RELOC_UNUSED
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
return|return
name|str
return|;
block|}
end_function

begin_comment
comment|/* This routine is called for each instruction to be assembled.  */
end_comment

begin_function
name|void
name|md_assemble
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
specifier|const
name|struct
name|s390_opcode
modifier|*
name|opcode
decl_stmt|;
name|unsigned
name|char
name|insn
index|[
literal|6
index|]
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
comment|/* Get the opcode.  */
for|for
control|(
name|s
operator|=
name|str
init|;
operator|*
name|s
operator|!=
literal|'\0'
operator|&&
operator|!
name|ISSPACE
argument_list|(
operator|*
name|s
argument_list|)
condition|;
name|s
operator|++
control|)
empty_stmt|;
if|if
condition|(
operator|*
name|s
operator|!=
literal|'\0'
condition|)
operator|*
name|s
operator|++
operator|=
literal|'\0'
expr_stmt|;
comment|/* Look up the opcode in the hash table.  */
name|opcode
operator|=
operator|(
expr|struct
name|s390_opcode
operator|*
operator|)
name|hash_find
argument_list|(
name|s390_opcode_hash
argument_list|,
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|opcode
operator|==
operator|(
specifier|const
expr|struct
name|s390_opcode
operator|*
operator|)
name|NULL
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Unrecognized opcode: `%s'"
argument_list|)
argument_list|,
name|str
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|opcode
operator|->
name|modes
operator|&
name|current_mode_mask
operator|)
condition|)
block|{
name|as_bad
argument_list|(
literal|"Opcode %s not available in this mode"
argument_list|,
name|str
argument_list|)
expr_stmt|;
return|return;
block|}
name|memcpy
argument_list|(
name|insn
argument_list|,
name|opcode
operator|->
name|opcode
argument_list|,
sizeof|sizeof
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|md_gather_operands
argument_list|(
name|s
argument_list|,
name|insn
argument_list|,
name|opcode
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|WORKING_DOT_WORD
end_ifndef

begin_comment
comment|/* Handle long and short jumps. We don't support these */
end_comment

begin_function
name|void
name|md_create_short_jump
parameter_list|(
name|ptr
parameter_list|,
name|from_addr
parameter_list|,
name|to_addr
parameter_list|,
name|frag
parameter_list|,
name|to_symbol
parameter_list|)
name|char
modifier|*
name|ptr
decl_stmt|;
name|addressT
name|from_addr
decl_stmt|,
name|to_addr
decl_stmt|;
name|fragS
modifier|*
name|frag
decl_stmt|;
name|symbolS
modifier|*
name|to_symbol
decl_stmt|;
block|{
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|md_create_long_jump
parameter_list|(
name|ptr
parameter_list|,
name|from_addr
parameter_list|,
name|to_addr
parameter_list|,
name|frag
parameter_list|,
name|to_symbol
parameter_list|)
name|char
modifier|*
name|ptr
decl_stmt|;
name|addressT
name|from_addr
decl_stmt|,
name|to_addr
decl_stmt|;
name|fragS
modifier|*
name|frag
decl_stmt|;
name|symbolS
modifier|*
name|to_symbol
decl_stmt|;
block|{
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|s390_bss
parameter_list|(
name|ignore
parameter_list|)
name|int
name|ignore
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
comment|/* We don't support putting frags in the BSS segment, we fake it      by marking in_bss, then looking at s_skip for clues.  */
name|subseg_set
argument_list|(
name|bss_section
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Pseudo-op handling.  */
end_comment

begin_function
name|void
name|s390_insn
parameter_list|(
name|ignore
parameter_list|)
name|int
name|ignore
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|expressionS
name|exp
decl_stmt|;
specifier|const
name|struct
name|s390_opcode
modifier|*
name|opformat
decl_stmt|;
name|unsigned
name|char
name|insn
index|[
literal|6
index|]
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
comment|/* Get the opcode format.  */
name|s
operator|=
name|input_line_pointer
expr_stmt|;
while|while
condition|(
operator|*
name|s
operator|!=
literal|'\0'
operator|&&
operator|*
name|s
operator|!=
literal|','
operator|&&
operator|!
name|ISSPACE
argument_list|(
operator|*
name|s
argument_list|)
condition|)
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|!=
literal|','
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Invalid .insn format\n"
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|s
operator|++
operator|=
literal|'\0'
expr_stmt|;
comment|/* Look up the opcode in the hash table.  */
name|opformat
operator|=
operator|(
expr|struct
name|s390_opcode
operator|*
operator|)
name|hash_find
argument_list|(
name|s390_opformat_hash
argument_list|,
name|input_line_pointer
argument_list|)
expr_stmt|;
if|if
condition|(
name|opformat
operator|==
operator|(
specifier|const
expr|struct
name|s390_opcode
operator|*
operator|)
name|NULL
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Unrecognized opcode format: `%s'"
argument_list|)
argument_list|,
name|input_line_pointer
argument_list|)
expr_stmt|;
return|return;
block|}
name|input_line_pointer
operator|=
name|s
expr_stmt|;
name|expression
argument_list|(
operator|&
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
name|exp
operator|.
name|X_op
operator|==
name|O_constant
condition|)
block|{
if|if
condition|(
operator|(
name|opformat
operator|->
name|oplen
operator|==
literal|6
operator|&&
name|exp
operator|.
name|X_add_number
operator|>=
literal|0
operator|&&
operator|(
name|addressT
operator|)
name|exp
operator|.
name|X_add_number
operator|<
operator|(
literal|1ULL
operator|<<
literal|48
operator|)
operator|)
operator|||
operator|(
name|opformat
operator|->
name|oplen
operator|==
literal|4
operator|&&
name|exp
operator|.
name|X_add_number
operator|>=
literal|0
operator|&&
operator|(
name|addressT
operator|)
name|exp
operator|.
name|X_add_number
operator|<
operator|(
literal|1ULL
operator|<<
literal|32
operator|)
operator|)
operator|||
operator|(
name|opformat
operator|->
name|oplen
operator|==
literal|2
operator|&&
name|exp
operator|.
name|X_add_number
operator|>=
literal|0
operator|&&
operator|(
name|addressT
operator|)
name|exp
operator|.
name|X_add_number
operator|<
operator|(
literal|1ULL
operator|<<
literal|16
operator|)
operator|)
condition|)
name|md_number_to_chars
argument_list|(
name|insn
argument_list|,
name|exp
operator|.
name|X_add_number
argument_list|,
name|opformat
operator|->
name|oplen
argument_list|)
expr_stmt|;
else|else
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Invalid .insn format\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|exp
operator|.
name|X_op
operator|==
name|O_big
condition|)
block|{
if|if
condition|(
name|exp
operator|.
name|X_add_number
operator|>
literal|0
operator|&&
name|opformat
operator|->
name|oplen
operator|==
literal|6
operator|&&
name|generic_bignum
index|[
literal|3
index|]
operator|==
literal|0
condition|)
block|{
name|md_number_to_chars
argument_list|(
name|insn
argument_list|,
name|generic_bignum
index|[
literal|2
index|]
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
operator|&
name|insn
index|[
literal|2
index|]
argument_list|,
name|generic_bignum
index|[
literal|1
index|]
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
operator|&
name|insn
index|[
literal|4
index|]
argument_list|,
name|generic_bignum
index|[
literal|0
index|]
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
else|else
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Invalid .insn format\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"second operand of .insn not a constant\n"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|opformat
operator|->
name|name
argument_list|,
literal|"e"
argument_list|)
operator|!=
literal|0
operator|&&
operator|*
name|input_line_pointer
operator|++
operator|!=
literal|','
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"missing comma after insn constant\n"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|s
operator|=
name|strchr
argument_list|(
name|input_line_pointer
argument_list|,
literal|'\n'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
operator|*
name|s
operator|=
literal|'\0'
expr_stmt|;
name|input_line_pointer
operator|=
name|md_gather_operands
argument_list|(
name|input_line_pointer
argument_list|,
name|insn
argument_list|,
name|opformat
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
condition|)
operator|*
name|s
operator|=
literal|'\n'
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The .byte pseudo-op.  This is similar to the normal .byte    pseudo-op, but it can also take a single ASCII string.  */
end_comment

begin_function
specifier|static
name|void
name|s390_byte
parameter_list|(
name|ignore
parameter_list|)
name|int
name|ignore
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
if|if
condition|(
operator|*
name|input_line_pointer
operator|!=
literal|'\"'
condition|)
block|{
name|cons
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Gather characters.  A real double quote is doubled.  Unusual      characters are not permitted.  */
operator|++
name|input_line_pointer
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|char
name|c
decl_stmt|;
name|c
operator|=
operator|*
name|input_line_pointer
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\"'
condition|)
block|{
if|if
condition|(
operator|*
name|input_line_pointer
operator|!=
literal|'\"'
condition|)
break|break;
operator|++
name|input_line_pointer
expr_stmt|;
block|}
name|FRAG_APPEND_1_CHAR
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The .ltorg pseudo-op.This emits all literals defined since the last    .ltorg or the invocation of gas. Literals are defined with the    @lit suffix.  */
end_comment

begin_function
specifier|static
name|void
name|s390_literals
parameter_list|(
name|ignore
parameter_list|)
name|int
name|ignore
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|struct
name|s390_lpe
modifier|*
name|lpe
decl_stmt|;
if|if
condition|(
name|lp_sym
operator|==
name|NULL
operator|||
name|lpe_count
operator|==
literal|0
condition|)
return|return;
comment|/* Nothing to be done.  */
comment|/* Emit symbol for start of literal pool.  */
name|S_SET_SEGMENT
argument_list|(
name|lp_sym
argument_list|,
name|now_seg
argument_list|)
expr_stmt|;
name|S_SET_VALUE
argument_list|(
name|lp_sym
argument_list|,
operator|(
name|valueT
operator|)
name|frag_now_fix
argument_list|()
argument_list|)
expr_stmt|;
name|lp_sym
operator|->
name|sy_frag
operator|=
name|frag_now
expr_stmt|;
while|while
condition|(
name|lpe_list
condition|)
block|{
name|lpe
operator|=
name|lpe_list
expr_stmt|;
name|lpe_list
operator|=
name|lpe_list
operator|->
name|next
expr_stmt|;
name|S_SET_SEGMENT
argument_list|(
name|lpe
operator|->
name|sym
argument_list|,
name|now_seg
argument_list|)
expr_stmt|;
name|S_SET_VALUE
argument_list|(
name|lpe
operator|->
name|sym
argument_list|,
operator|(
name|valueT
operator|)
name|frag_now_fix
argument_list|()
argument_list|)
expr_stmt|;
name|lpe
operator|->
name|sym
operator|->
name|sy_frag
operator|=
name|frag_now
expr_stmt|;
comment|/* Emit literal pool entry.  */
if|if
condition|(
name|lpe
operator|->
name|reloc
operator|!=
name|BFD_RELOC_UNUSED
condition|)
block|{
name|reloc_howto_type
modifier|*
name|reloc_howto
init|=
name|bfd_reloc_type_lookup
argument_list|(
name|stdoutput
argument_list|,
name|lpe
operator|->
name|reloc
argument_list|)
decl_stmt|;
name|int
name|size
init|=
name|bfd_get_reloc_size
argument_list|(
name|reloc_howto
argument_list|)
decl_stmt|;
name|char
modifier|*
name|where
decl_stmt|;
if|if
condition|(
name|size
operator|>
name|lpe
operator|->
name|nbytes
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"%s relocations do not fit in %d bytes"
argument_list|)
argument_list|,
name|reloc_howto
operator|->
name|name
argument_list|,
name|lpe
operator|->
name|nbytes
argument_list|)
expr_stmt|;
name|where
operator|=
name|frag_more
argument_list|(
name|lpe
operator|->
name|nbytes
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|where
argument_list|,
literal|0
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|fix_new_exp
argument_list|(
name|frag_now
argument_list|,
name|where
operator|-
name|frag_now
operator|->
name|fr_literal
argument_list|,
name|size
argument_list|,
operator|&
name|lpe
operator|->
name|ex
argument_list|,
name|reloc_howto
operator|->
name|pc_relative
argument_list|,
name|lpe
operator|->
name|reloc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|lpe
operator|->
name|ex
operator|.
name|X_op
operator|==
name|O_big
condition|)
block|{
if|if
condition|(
name|lpe
operator|->
name|ex
operator|.
name|X_add_number
operator|<=
literal|0
condition|)
name|generic_floating_point_number
operator|=
name|lpe
operator|->
name|floatnum
expr_stmt|;
else|else
name|memcpy
argument_list|(
name|generic_bignum
argument_list|,
name|lpe
operator|->
name|bignum
argument_list|,
name|lpe
operator|->
name|ex
operator|.
name|X_add_number
operator|*
sizeof|sizeof
argument_list|(
name|LITTLENUM_TYPE
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|emit_expr
argument_list|(
operator|&
name|lpe
operator|->
name|ex
argument_list|,
name|lpe
operator|->
name|nbytes
argument_list|)
expr_stmt|;
block|}
name|lpe
operator|->
name|next
operator|=
name|lpe_free_list
expr_stmt|;
name|lpe_free_list
operator|=
name|lpe
expr_stmt|;
block|}
name|lpe_list_tail
operator|=
name|NULL
expr_stmt|;
name|lp_sym
operator|=
name|NULL
expr_stmt|;
name|lp_count
operator|++
expr_stmt|;
name|lpe_count
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Turn a string in input_line_pointer into a floating point constant    of type type, and store the appropriate bytes in *litp.  The number    of LITTLENUMS emitted is stored in *sizep .  An error message is    returned, or NULL on OK.  */
end_comment

begin_function
name|char
modifier|*
name|md_atof
parameter_list|(
name|type
parameter_list|,
name|litp
parameter_list|,
name|sizep
parameter_list|)
name|int
name|type
decl_stmt|;
name|char
modifier|*
name|litp
decl_stmt|;
name|int
modifier|*
name|sizep
decl_stmt|;
block|{
name|int
name|prec
decl_stmt|;
name|LITTLENUM_TYPE
name|words
index|[
literal|4
index|]
decl_stmt|;
name|char
modifier|*
name|t
decl_stmt|;
name|int
name|i
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
literal|'f'
case|:
name|prec
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|prec
operator|=
literal|4
expr_stmt|;
break|break;
default|default:
operator|*
name|sizep
operator|=
literal|0
expr_stmt|;
return|return
literal|"bad call to md_atof"
return|;
block|}
name|t
operator|=
name|atof_ieee
argument_list|(
name|input_line_pointer
argument_list|,
name|type
argument_list|,
name|words
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
condition|)
name|input_line_pointer
operator|=
name|t
expr_stmt|;
operator|*
name|sizep
operator|=
name|prec
operator|*
literal|2
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|prec
condition|;
name|i
operator|++
control|)
block|{
name|md_number_to_chars
argument_list|(
name|litp
argument_list|,
operator|(
name|valueT
operator|)
name|words
index|[
name|i
index|]
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|litp
operator|+=
literal|2
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Align a section (I don't know why this is machine dependent).  */
end_comment

begin_function
name|valueT
name|md_section_align
parameter_list|(
name|seg
parameter_list|,
name|addr
parameter_list|)
name|asection
modifier|*
name|seg
decl_stmt|;
name|valueT
name|addr
decl_stmt|;
block|{
name|int
name|align
init|=
name|bfd_get_section_alignment
argument_list|(
name|stdoutput
argument_list|,
name|seg
argument_list|)
decl_stmt|;
return|return
operator|(
operator|(
name|addr
operator|+
operator|(
literal|1
operator|<<
name|align
operator|)
operator|-
literal|1
operator|)
operator|&
operator|(
operator|-
literal|1
operator|<<
name|align
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* We don't have any form of relaxing.  */
end_comment

begin_function
name|int
name|md_estimate_size_before_relax
parameter_list|(
name|fragp
parameter_list|,
name|seg
parameter_list|)
name|fragS
modifier|*
name|fragp
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|asection
modifier|*
name|seg
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|abort
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Convert a machine dependent frag.  We never generate these.  */
end_comment

begin_function
name|void
name|md_convert_frag
parameter_list|(
name|abfd
parameter_list|,
name|sec
parameter_list|,
name|fragp
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|asection
modifier|*
name|sec
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|fragS
modifier|*
name|fragp
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|symbolS
modifier|*
name|md_undefined_symbol
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
if|if
condition|(
operator|*
name|name
operator|==
literal|'_'
operator|&&
operator|*
operator|(
name|name
operator|+
literal|1
operator|)
operator|==
literal|'G'
operator|&&
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"_GLOBAL_OFFSET_TABLE_"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|GOT_symbol
condition|)
block|{
if|if
condition|(
name|symbol_find
argument_list|(
name|name
argument_list|)
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"GOT already in symbol table"
argument_list|)
argument_list|)
expr_stmt|;
name|GOT_symbol
operator|=
name|symbol_new
argument_list|(
name|name
argument_list|,
name|undefined_section
argument_list|,
operator|(
name|valueT
operator|)
literal|0
argument_list|,
operator|&
name|zero_address_frag
argument_list|)
expr_stmt|;
block|}
return|return
name|GOT_symbol
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Functions concerning relocs.  */
end_comment

begin_comment
comment|/* The location from which a PC relative jump should be calculated,    given a PC relative reloc.  */
end_comment

begin_function
name|long
name|md_pcrel_from_section
parameter_list|(
name|fixp
parameter_list|,
name|sec
parameter_list|)
name|fixS
modifier|*
name|fixp
decl_stmt|;
name|segT
name|sec
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
return|return
name|fixp
operator|->
name|fx_frag
operator|->
name|fr_address
operator|+
name|fixp
operator|->
name|fx_where
return|;
block|}
end_function

begin_comment
comment|/* Here we decide which fixups can be adjusted to make them relative to    the beginning of the section instead of the symbol.  Basically we need    to make sure that the dynamic relocations are done correctly, so in    some cases we force the original symbol to be used.  */
end_comment

begin_function
name|int
name|tc_s390_fix_adjustable
parameter_list|(
name|fixP
parameter_list|)
name|fixS
modifier|*
name|fixP
decl_stmt|;
block|{
comment|/* Don't adjust references to merge sections.  */
if|if
condition|(
operator|(
name|S_GET_SEGMENT
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
operator|->
name|flags
operator|&
name|SEC_MERGE
operator|)
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
comment|/* adjust_reloc_syms doesn't know about the GOT.  */
if|if
condition|(
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_16_GOTOFF
operator|||
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_32_GOTOFF
operator|||
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_390_GOTOFF64
operator|||
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_390_PLTOFF16
operator|||
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_390_PLTOFF32
operator|||
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_390_PLTOFF64
operator|||
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_390_PLT16DBL
operator|||
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_390_PLT32
operator|||
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_390_PLT32DBL
operator|||
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_390_PLT64
operator|||
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_390_GOT12
operator|||
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_390_GOT20
operator|||
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_390_GOT16
operator|||
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_32_GOT_PCREL
operator|||
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_390_GOT64
operator|||
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_390_GOTENT
operator|||
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_390_GOTPLT12
operator|||
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_390_GOTPLT16
operator|||
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_390_GOTPLT20
operator|||
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_390_GOTPLT32
operator|||
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_390_GOTPLT64
operator|||
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_390_GOTPLTENT
operator|||
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_390_TLS_LOAD
operator|||
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_390_TLS_GDCALL
operator|||
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_390_TLS_LDCALL
operator|||
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_390_TLS_GD32
operator|||
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_390_TLS_GD64
operator|||
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_390_TLS_GOTIE12
operator|||
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_390_TLS_GOTIE20
operator|||
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_390_TLS_GOTIE32
operator|||
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_390_TLS_GOTIE64
operator|||
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_390_TLS_LDM32
operator|||
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_390_TLS_LDM64
operator|||
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_390_TLS_IE32
operator|||
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_390_TLS_IE64
operator|||
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_390_TLS_IEENT
operator|||
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_390_TLS_LE32
operator|||
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_390_TLS_LE64
operator|||
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_390_TLS_LDO32
operator|||
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_390_TLS_LDO64
operator|||
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_390_TLS_DTPMOD
operator|||
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_390_TLS_DTPOFF
operator|||
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_390_TLS_TPOFF
operator|||
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_VTABLE_INHERIT
operator|||
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_VTABLE_ENTRY
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Return true if we must always emit a reloc for a type and false if    there is some hope of resolving it at assembly time.  */
end_comment

begin_function
name|int
name|tc_s390_force_relocation
parameter_list|(
name|fixp
parameter_list|)
name|struct
name|fix
modifier|*
name|fixp
decl_stmt|;
block|{
comment|/* Ensure we emit a relocation for every reference to the global      offset table or to the procedure link table.  */
switch|switch
condition|(
name|fixp
operator|->
name|fx_r_type
condition|)
block|{
case|case
name|BFD_RELOC_390_GOT12
case|:
case|case
name|BFD_RELOC_390_GOT20
case|:
case|case
name|BFD_RELOC_32_GOT_PCREL
case|:
case|case
name|BFD_RELOC_32_GOTOFF
case|:
case|case
name|BFD_RELOC_390_GOTOFF64
case|:
case|case
name|BFD_RELOC_390_PLTOFF16
case|:
case|case
name|BFD_RELOC_390_PLTOFF32
case|:
case|case
name|BFD_RELOC_390_PLTOFF64
case|:
case|case
name|BFD_RELOC_390_GOTPC
case|:
case|case
name|BFD_RELOC_390_GOT16
case|:
case|case
name|BFD_RELOC_390_GOTPCDBL
case|:
case|case
name|BFD_RELOC_390_GOT64
case|:
case|case
name|BFD_RELOC_390_GOTENT
case|:
case|case
name|BFD_RELOC_390_PLT32
case|:
case|case
name|BFD_RELOC_390_PLT16DBL
case|:
case|case
name|BFD_RELOC_390_PLT32DBL
case|:
case|case
name|BFD_RELOC_390_PLT64
case|:
case|case
name|BFD_RELOC_390_GOTPLT12
case|:
case|case
name|BFD_RELOC_390_GOTPLT16
case|:
case|case
name|BFD_RELOC_390_GOTPLT20
case|:
case|case
name|BFD_RELOC_390_GOTPLT32
case|:
case|case
name|BFD_RELOC_390_GOTPLT64
case|:
case|case
name|BFD_RELOC_390_GOTPLTENT
case|:
return|return
literal|1
return|;
default|default:
break|break;
empty_stmt|;
block|}
return|return
name|generic_force_reloc
argument_list|(
name|fixp
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Apply a fixup to the object code.  This is called for all the    fixups we generated by the call to fix_new_exp, above.  In the call    above we used a reloc code which was the largest legal reloc code    plus the operand index.  Here we undo that to recover the operand    index.  At this point all symbol values should be fully resolved,    and we attempt to completely resolve the reloc.  If we can not do    that, we determine the correct reloc code and put it back in the    fixup.  */
end_comment

begin_function
name|void
name|md_apply_fix3
parameter_list|(
name|fixP
parameter_list|,
name|valP
parameter_list|,
name|seg
parameter_list|)
name|fixS
modifier|*
name|fixP
decl_stmt|;
name|valueT
modifier|*
name|valP
decl_stmt|;
name|segT
name|seg
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|char
modifier|*
name|where
decl_stmt|;
name|valueT
name|value
init|=
operator|*
name|valP
decl_stmt|;
name|where
operator|=
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_literal
operator|+
name|fixP
operator|->
name|fx_where
expr_stmt|;
if|if
condition|(
name|fixP
operator|->
name|fx_subsy
operator|!=
name|NULL
condition|)
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
literal|"cannot emit relocation %s against subsy symbol %s"
argument_list|,
name|bfd_get_reloc_code_name
argument_list|(
name|fixP
operator|->
name|fx_r_type
argument_list|)
argument_list|,
name|S_GET_NAME
argument_list|(
name|fixP
operator|->
name|fx_subsy
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fixP
operator|->
name|fx_addsy
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|fixP
operator|->
name|fx_pcrel
condition|)
name|value
operator|+=
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_address
operator|+
name|fixP
operator|->
name|fx_where
expr_stmt|;
block|}
else|else
name|fixP
operator|->
name|fx_done
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|int
operator|)
name|fixP
operator|->
name|fx_r_type
operator|>=
operator|(
name|int
operator|)
name|BFD_RELOC_UNUSED
condition|)
block|{
specifier|const
name|struct
name|s390_operand
modifier|*
name|operand
decl_stmt|;
name|int
name|opindex
decl_stmt|;
name|opindex
operator|=
operator|(
name|int
operator|)
name|fixP
operator|->
name|fx_r_type
operator|-
operator|(
name|int
operator|)
name|BFD_RELOC_UNUSED
expr_stmt|;
name|operand
operator|=
operator|&
name|s390_operands
index|[
name|opindex
index|]
expr_stmt|;
if|if
condition|(
name|fixP
operator|->
name|fx_done
condition|)
block|{
comment|/* Insert the fully resolved operand value.  */
name|s390_insert_operand
argument_list|(
name|where
argument_list|,
name|operand
argument_list|,
operator|(
name|offsetT
operator|)
name|value
argument_list|,
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Determine a BFD reloc value based on the operand information. 	 We are only prepared to turn a few of the operands into 	 relocs.  */
name|fixP
operator|->
name|fx_offset
operator|=
name|value
expr_stmt|;
if|if
condition|(
name|operand
operator|->
name|bits
operator|==
literal|12
operator|&&
name|operand
operator|->
name|shift
operator|==
literal|20
condition|)
block|{
name|fixP
operator|->
name|fx_size
operator|=
literal|2
expr_stmt|;
name|fixP
operator|->
name|fx_where
operator|+=
literal|2
expr_stmt|;
name|fixP
operator|->
name|fx_r_type
operator|=
name|BFD_RELOC_390_12
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|operand
operator|->
name|bits
operator|==
literal|12
operator|&&
name|operand
operator|->
name|shift
operator|==
literal|36
condition|)
block|{
name|fixP
operator|->
name|fx_size
operator|=
literal|2
expr_stmt|;
name|fixP
operator|->
name|fx_where
operator|+=
literal|4
expr_stmt|;
name|fixP
operator|->
name|fx_r_type
operator|=
name|BFD_RELOC_390_12
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|operand
operator|->
name|bits
operator|==
literal|20
operator|&&
name|operand
operator|->
name|shift
operator|==
literal|20
condition|)
block|{
name|fixP
operator|->
name|fx_size
operator|=
literal|2
expr_stmt|;
name|fixP
operator|->
name|fx_where
operator|+=
literal|2
expr_stmt|;
name|fixP
operator|->
name|fx_r_type
operator|=
name|BFD_RELOC_390_20
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|operand
operator|->
name|bits
operator|==
literal|8
operator|&&
name|operand
operator|->
name|shift
operator|==
literal|8
condition|)
block|{
name|fixP
operator|->
name|fx_size
operator|=
literal|1
expr_stmt|;
name|fixP
operator|->
name|fx_where
operator|+=
literal|1
expr_stmt|;
name|fixP
operator|->
name|fx_r_type
operator|=
name|BFD_RELOC_8
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|operand
operator|->
name|bits
operator|==
literal|16
operator|&&
name|operand
operator|->
name|shift
operator|==
literal|16
condition|)
block|{
name|fixP
operator|->
name|fx_size
operator|=
literal|2
expr_stmt|;
name|fixP
operator|->
name|fx_where
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|operand
operator|->
name|flags
operator|&
name|S390_OPERAND_PCREL
condition|)
block|{
name|fixP
operator|->
name|fx_r_type
operator|=
name|BFD_RELOC_390_PC16DBL
expr_stmt|;
name|fixP
operator|->
name|fx_offset
operator|+=
literal|2
expr_stmt|;
block|}
else|else
name|fixP
operator|->
name|fx_r_type
operator|=
name|BFD_RELOC_16
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|operand
operator|->
name|bits
operator|==
literal|32
operator|&&
name|operand
operator|->
name|shift
operator|==
literal|16
operator|&&
operator|(
name|operand
operator|->
name|flags
operator|&
name|S390_OPERAND_PCREL
operator|)
condition|)
block|{
name|fixP
operator|->
name|fx_size
operator|=
literal|4
expr_stmt|;
name|fixP
operator|->
name|fx_where
operator|+=
literal|2
expr_stmt|;
name|fixP
operator|->
name|fx_offset
operator|+=
literal|2
expr_stmt|;
name|fixP
operator|->
name|fx_r_type
operator|=
name|BFD_RELOC_390_PC32DBL
expr_stmt|;
block|}
else|else
block|{
name|char
modifier|*
name|sfile
decl_stmt|;
name|unsigned
name|int
name|sline
decl_stmt|;
comment|/* Use expr_symbol_where to see if this is an expression 	     symbol.  */
if|if
condition|(
name|expr_symbol_where
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|,
operator|&
name|sfile
argument_list|,
operator|&
name|sline
argument_list|)
condition|)
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"unresolved expression that must be resolved"
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"unsupported relocation type"
argument_list|)
argument_list|)
expr_stmt|;
name|fixP
operator|->
name|fx_done
operator|=
literal|1
expr_stmt|;
return|return;
block|}
block|}
else|else
block|{
switch|switch
condition|(
name|fixP
operator|->
name|fx_r_type
condition|)
block|{
case|case
name|BFD_RELOC_8
case|:
if|if
condition|(
name|fixP
operator|->
name|fx_pcrel
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|fixP
operator|->
name|fx_done
condition|)
name|md_number_to_chars
argument_list|(
name|where
argument_list|,
name|value
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_390_12
case|:
case|case
name|BFD_RELOC_390_GOT12
case|:
case|case
name|BFD_RELOC_390_GOTPLT12
case|:
if|if
condition|(
name|fixP
operator|->
name|fx_done
condition|)
block|{
name|unsigned
name|short
name|mop
decl_stmt|;
name|mop
operator|=
name|bfd_getb16
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|where
argument_list|)
expr_stmt|;
name|mop
operator||=
call|(
name|unsigned
name|short
call|)
argument_list|(
name|value
operator|&
literal|0xfff
argument_list|)
expr_stmt|;
name|bfd_putb16
argument_list|(
operator|(
name|bfd_vma
operator|)
name|mop
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|where
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|BFD_RELOC_390_20
case|:
case|case
name|BFD_RELOC_390_GOT20
case|:
case|case
name|BFD_RELOC_390_GOTPLT20
case|:
if|if
condition|(
name|fixP
operator|->
name|fx_done
condition|)
block|{
name|unsigned
name|int
name|mop
decl_stmt|;
name|mop
operator|=
name|bfd_getb32
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|where
argument_list|)
expr_stmt|;
name|mop
operator||=
call|(
name|unsigned
name|int
call|)
argument_list|(
operator|(
name|value
operator|&
literal|0xfff
operator|)
operator|<<
literal|8
operator||
operator|(
name|value
operator|&
literal|0xff000
operator|)
operator|>>
literal|12
argument_list|)
expr_stmt|;
name|bfd_putb32
argument_list|(
operator|(
name|bfd_vma
operator|)
name|mop
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|where
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|BFD_RELOC_16
case|:
case|case
name|BFD_RELOC_GPREL16
case|:
case|case
name|BFD_RELOC_16_GOT_PCREL
case|:
case|case
name|BFD_RELOC_16_GOTOFF
case|:
if|if
condition|(
name|fixP
operator|->
name|fx_pcrel
condition|)
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
literal|"cannot emit PC relative %s relocation%s%s"
argument_list|,
name|bfd_get_reloc_code_name
argument_list|(
name|fixP
operator|->
name|fx_r_type
argument_list|)
argument_list|,
name|fixP
operator|->
name|fx_addsy
operator|!=
name|NULL
condition|?
literal|" against "
else|:
literal|""
argument_list|,
operator|(
name|fixP
operator|->
name|fx_addsy
operator|!=
name|NULL
condition|?
name|S_GET_NAME
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
else|:
literal|""
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fixP
operator|->
name|fx_done
condition|)
name|md_number_to_chars
argument_list|(
name|where
argument_list|,
name|value
argument_list|,
literal|2
argument_list|)
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_390_GOT16
case|:
case|case
name|BFD_RELOC_390_PLTOFF16
case|:
case|case
name|BFD_RELOC_390_GOTPLT16
case|:
if|if
condition|(
name|fixP
operator|->
name|fx_done
condition|)
name|md_number_to_chars
argument_list|(
name|where
argument_list|,
name|value
argument_list|,
literal|2
argument_list|)
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_390_PC16DBL
case|:
case|case
name|BFD_RELOC_390_PLT16DBL
case|:
name|value
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|fixP
operator|->
name|fx_done
condition|)
name|md_number_to_chars
argument_list|(
name|where
argument_list|,
operator|(
name|offsetT
operator|)
name|value
operator|>>
literal|1
argument_list|,
literal|2
argument_list|)
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_32
case|:
if|if
condition|(
name|fixP
operator|->
name|fx_pcrel
condition|)
name|fixP
operator|->
name|fx_r_type
operator|=
name|BFD_RELOC_32_PCREL
expr_stmt|;
else|else
name|fixP
operator|->
name|fx_r_type
operator|=
name|BFD_RELOC_32
expr_stmt|;
if|if
condition|(
name|fixP
operator|->
name|fx_done
condition|)
name|md_number_to_chars
argument_list|(
name|where
argument_list|,
name|value
argument_list|,
literal|4
argument_list|)
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_32_PCREL
case|:
case|case
name|BFD_RELOC_32_BASEREL
case|:
name|fixP
operator|->
name|fx_r_type
operator|=
name|BFD_RELOC_32_PCREL
expr_stmt|;
if|if
condition|(
name|fixP
operator|->
name|fx_done
condition|)
name|md_number_to_chars
argument_list|(
name|where
argument_list|,
name|value
argument_list|,
literal|4
argument_list|)
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_32_GOT_PCREL
case|:
case|case
name|BFD_RELOC_390_PLTOFF32
case|:
case|case
name|BFD_RELOC_390_PLT32
case|:
case|case
name|BFD_RELOC_390_GOTPLT32
case|:
if|if
condition|(
name|fixP
operator|->
name|fx_done
condition|)
name|md_number_to_chars
argument_list|(
name|where
argument_list|,
name|value
argument_list|,
literal|4
argument_list|)
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_390_PC32DBL
case|:
case|case
name|BFD_RELOC_390_PLT32DBL
case|:
case|case
name|BFD_RELOC_390_GOTPCDBL
case|:
case|case
name|BFD_RELOC_390_GOTENT
case|:
case|case
name|BFD_RELOC_390_GOTPLTENT
case|:
name|value
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|fixP
operator|->
name|fx_done
condition|)
name|md_number_to_chars
argument_list|(
name|where
argument_list|,
operator|(
name|offsetT
operator|)
name|value
operator|>>
literal|1
argument_list|,
literal|4
argument_list|)
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_32_GOTOFF
case|:
if|if
condition|(
name|fixP
operator|->
name|fx_done
condition|)
name|md_number_to_chars
argument_list|(
name|where
argument_list|,
name|value
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_390_GOTOFF64
case|:
if|if
condition|(
name|fixP
operator|->
name|fx_done
condition|)
name|md_number_to_chars
argument_list|(
name|where
argument_list|,
name|value
argument_list|,
literal|8
argument_list|)
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_390_GOT64
case|:
case|case
name|BFD_RELOC_390_PLTOFF64
case|:
case|case
name|BFD_RELOC_390_PLT64
case|:
case|case
name|BFD_RELOC_390_GOTPLT64
case|:
if|if
condition|(
name|fixP
operator|->
name|fx_done
condition|)
name|md_number_to_chars
argument_list|(
name|where
argument_list|,
name|value
argument_list|,
literal|8
argument_list|)
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_64
case|:
if|if
condition|(
name|fixP
operator|->
name|fx_pcrel
condition|)
name|fixP
operator|->
name|fx_r_type
operator|=
name|BFD_RELOC_64_PCREL
expr_stmt|;
else|else
name|fixP
operator|->
name|fx_r_type
operator|=
name|BFD_RELOC_64
expr_stmt|;
if|if
condition|(
name|fixP
operator|->
name|fx_done
condition|)
name|md_number_to_chars
argument_list|(
name|where
argument_list|,
name|value
argument_list|,
literal|8
argument_list|)
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_64_PCREL
case|:
name|fixP
operator|->
name|fx_r_type
operator|=
name|BFD_RELOC_64_PCREL
expr_stmt|;
if|if
condition|(
name|fixP
operator|->
name|fx_done
condition|)
name|md_number_to_chars
argument_list|(
name|where
argument_list|,
name|value
argument_list|,
literal|8
argument_list|)
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_VTABLE_INHERIT
case|:
case|case
name|BFD_RELOC_VTABLE_ENTRY
case|:
name|fixP
operator|->
name|fx_done
operator|=
literal|0
expr_stmt|;
return|return;
case|case
name|BFD_RELOC_390_TLS_LOAD
case|:
case|case
name|BFD_RELOC_390_TLS_GDCALL
case|:
case|case
name|BFD_RELOC_390_TLS_LDCALL
case|:
case|case
name|BFD_RELOC_390_TLS_GD32
case|:
case|case
name|BFD_RELOC_390_TLS_GD64
case|:
case|case
name|BFD_RELOC_390_TLS_GOTIE12
case|:
case|case
name|BFD_RELOC_390_TLS_GOTIE20
case|:
case|case
name|BFD_RELOC_390_TLS_GOTIE32
case|:
case|case
name|BFD_RELOC_390_TLS_GOTIE64
case|:
case|case
name|BFD_RELOC_390_TLS_LDM32
case|:
case|case
name|BFD_RELOC_390_TLS_LDM64
case|:
case|case
name|BFD_RELOC_390_TLS_IE32
case|:
case|case
name|BFD_RELOC_390_TLS_IE64
case|:
case|case
name|BFD_RELOC_390_TLS_LE32
case|:
case|case
name|BFD_RELOC_390_TLS_LE64
case|:
case|case
name|BFD_RELOC_390_TLS_LDO32
case|:
case|case
name|BFD_RELOC_390_TLS_LDO64
case|:
case|case
name|BFD_RELOC_390_TLS_DTPMOD
case|:
case|case
name|BFD_RELOC_390_TLS_DTPOFF
case|:
case|case
name|BFD_RELOC_390_TLS_TPOFF
case|:
comment|/* Fully resolved at link time.  */
break|break;
case|case
name|BFD_RELOC_390_TLS_IEENT
case|:
comment|/* Fully resolved at link time.  */
name|value
operator|+=
literal|2
expr_stmt|;
break|break;
default|default:
block|{
specifier|const
name|char
modifier|*
name|reloc_name
init|=
name|bfd_get_reloc_code_name
argument_list|(
name|fixP
operator|->
name|fx_r_type
argument_list|)
decl_stmt|;
if|if
condition|(
name|reloc_name
operator|!=
name|NULL
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Gas failure, reloc type %s\n"
argument_list|,
name|reloc_name
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Gas failure, reloc type #%i\n"
argument_list|,
name|fixP
operator|->
name|fx_r_type
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
name|fixP
operator|->
name|fx_offset
operator|=
name|value
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Generate a reloc for a fixup.  */
end_comment

begin_function
name|arelent
modifier|*
name|tc_gen_reloc
parameter_list|(
name|seg
parameter_list|,
name|fixp
parameter_list|)
name|asection
modifier|*
name|seg
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|fixS
modifier|*
name|fixp
decl_stmt|;
block|{
name|bfd_reloc_code_real_type
name|code
decl_stmt|;
name|arelent
modifier|*
name|reloc
decl_stmt|;
name|code
operator|=
name|fixp
operator|->
name|fx_r_type
expr_stmt|;
if|if
condition|(
name|GOT_symbol
operator|&&
name|fixp
operator|->
name|fx_addsy
operator|==
name|GOT_symbol
condition|)
block|{
if|if
condition|(
operator|(
name|s390_arch_size
operator|==
literal|32
operator|&&
name|code
operator|==
name|BFD_RELOC_32_PCREL
operator|)
operator|||
operator|(
name|s390_arch_size
operator|==
literal|64
operator|&&
name|code
operator|==
name|BFD_RELOC_64_PCREL
operator|)
condition|)
name|code
operator|=
name|BFD_RELOC_390_GOTPC
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|BFD_RELOC_390_PC32DBL
condition|)
name|code
operator|=
name|BFD_RELOC_390_GOTPCDBL
expr_stmt|;
block|}
name|reloc
operator|=
operator|(
name|arelent
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|arelent
argument_list|)
argument_list|)
expr_stmt|;
name|reloc
operator|->
name|sym_ptr_ptr
operator|=
operator|(
name|asymbol
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|asymbol
operator|*
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|reloc
operator|->
name|sym_ptr_ptr
operator|=
name|symbol_get_bfdsym
argument_list|(
name|fixp
operator|->
name|fx_addsy
argument_list|)
expr_stmt|;
name|reloc
operator|->
name|address
operator|=
name|fixp
operator|->
name|fx_frag
operator|->
name|fr_address
operator|+
name|fixp
operator|->
name|fx_where
expr_stmt|;
name|reloc
operator|->
name|howto
operator|=
name|bfd_reloc_type_lookup
argument_list|(
name|stdoutput
argument_list|,
name|code
argument_list|)
expr_stmt|;
if|if
condition|(
name|reloc
operator|->
name|howto
operator|==
name|NULL
condition|)
block|{
name|as_bad_where
argument_list|(
name|fixp
operator|->
name|fx_file
argument_list|,
name|fixp
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"cannot represent relocation type %s"
argument_list|)
argument_list|,
name|bfd_get_reloc_code_name
argument_list|(
name|code
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Set howto to a garbage value so that we can keep going.  */
name|reloc
operator|->
name|howto
operator|=
name|bfd_reloc_type_lookup
argument_list|(
name|stdoutput
argument_list|,
name|BFD_RELOC_32
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|reloc
operator|->
name|howto
operator|!=
name|NULL
argument_list|)
expr_stmt|;
block|}
name|reloc
operator|->
name|addend
operator|=
name|fixp
operator|->
name|fx_offset
expr_stmt|;
return|return
name|reloc
return|;
block|}
end_function

begin_function
name|void
name|s390_cfi_frame_initial_instructions
parameter_list|()
block|{
name|cfi_add_CFA_def_cfa
argument_list|(
literal|15
argument_list|,
name|s390_arch_size
operator|==
literal|64
condition|?
literal|160
else|:
literal|96
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|tc_s390_regname_to_dw2regnum
parameter_list|(
specifier|const
name|char
modifier|*
name|regname
parameter_list|)
block|{
name|int
name|regnum
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|regname
index|[
literal|0
index|]
operator|!=
literal|'c'
operator|&&
name|regname
index|[
literal|0
index|]
operator|!=
literal|'a'
condition|)
block|{
name|regnum
operator|=
name|reg_name_search
argument_list|(
name|pre_defined_registers
argument_list|,
name|REG_NAME_CNT
argument_list|,
name|regname
argument_list|)
expr_stmt|;
if|if
condition|(
name|regname
index|[
literal|0
index|]
operator|==
literal|'f'
operator|&&
name|regnum
operator|!=
operator|-
literal|1
condition|)
name|regnum
operator|+=
literal|16
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|regname
argument_list|,
literal|"ap"
argument_list|)
operator|==
literal|0
condition|)
name|regnum
operator|=
literal|32
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|regname
argument_list|,
literal|"cc"
argument_list|)
operator|==
literal|0
condition|)
name|regnum
operator|=
literal|33
expr_stmt|;
return|return
name|regnum
return|;
block|}
end_function

end_unit

