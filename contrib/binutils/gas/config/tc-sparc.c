begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* tc-sparc.c -- Assemble for the SPARC    Copyright 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998,    1999, 2000, 2001, 2002    Free Software Foundation, Inc.    This file is part of GAS, the GNU Assembler.     GAS is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     GAS is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public    License along with GAS; see the file COPYING.  If not, write    to the Free Software Foundation, 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"as.h"
end_include

begin_include
include|#
directive|include
file|"safe-ctype.h"
end_include

begin_include
include|#
directive|include
file|"subsegs.h"
end_include

begin_include
include|#
directive|include
file|"opcode/sparc.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|OBJ_ELF
end_ifdef

begin_include
include|#
directive|include
file|"elf/sparc.h"
end_include

begin_include
include|#
directive|include
file|"dwarf2dbg.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Some ancient Sun C compilers would not take such hex constants as    unsigned, and would end up sign-extending them to form an offsetT,    so use these constants instead.  */
end_comment

begin_define
define|#
directive|define
name|U0xffffffff
value|((((unsigned long) 1<< 16)<< 16) - 1)
end_define

begin_define
define|#
directive|define
name|U0x80000000
value|((((unsigned long) 1<< 16)<< 15))
end_define

begin_decl_stmt
specifier|static
name|struct
name|sparc_arch
modifier|*
name|lookup_arch
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|init_default_arch
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|sparc_ip
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
specifier|const
expr|struct
name|sparc_opcode
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|in_signed_range
name|PARAMS
argument_list|(
operator|(
name|bfd_signed_vma
operator|,
name|bfd_signed_vma
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|in_unsigned_range
name|PARAMS
argument_list|(
operator|(
name|bfd_vma
operator|,
name|bfd_vma
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|in_bitfield_range
name|PARAMS
argument_list|(
operator|(
name|bfd_signed_vma
operator|,
name|bfd_signed_vma
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|sparc_ffs
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|synthetize_setuw
name|PARAMS
argument_list|(
operator|(
specifier|const
expr|struct
name|sparc_opcode
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|synthetize_setsw
name|PARAMS
argument_list|(
operator|(
specifier|const
expr|struct
name|sparc_opcode
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|synthetize_setx
name|PARAMS
argument_list|(
operator|(
specifier|const
expr|struct
name|sparc_opcode
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_vma
name|BSR
name|PARAMS
argument_list|(
operator|(
name|bfd_vma
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|cmp_reg_entry
name|PARAMS
argument_list|(
operator|(
specifier|const
name|PTR
operator|,
specifier|const
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|parse_keyword_arg
name|PARAMS
argument_list|(
operator|(
name|int
argument_list|(
operator|*
argument_list|)
argument_list|(
specifier|const
name|char
operator|*
argument_list|)
operator|,
name|char
operator|*
operator|*
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|parse_const_expr_arg
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|get_expression
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
name|str
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Default architecture.  */
end_comment

begin_comment
comment|/* ??? The default value should be V8, but sparclite support was added    by making it the default.  GCC now passes -Asparclite, so maybe sometime in    the future we can set this to V8.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|DEFAULT_ARCH
end_ifndef

begin_define
define|#
directive|define
name|DEFAULT_ARCH
value|"sparclite"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|char
modifier|*
name|default_arch
init|=
name|DEFAULT_ARCH
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero if the initial values of `max_architecture' and `sparc_arch_size'    have been set.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|default_init_p
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Current architecture.  We don't bump up unless necessary.  */
end_comment

begin_decl_stmt
specifier|static
name|enum
name|sparc_opcode_arch_val
name|current_architecture
init|=
name|SPARC_OPCODE_ARCH_V6
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The maximum architecture level we can bump up to.    In a 32 bit environment, don't allow bumping up to v9 by default.    The native assembler works this way.  The user is required to pass    an explicit argument before we'll create v9 object files.  However, if    we don't see any v9 insns, a v8plus object file is not created.  */
end_comment

begin_decl_stmt
specifier|static
name|enum
name|sparc_opcode_arch_val
name|max_architecture
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Either 32 or 64, selects file format.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|sparc_arch_size
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Initial (default) value, recorded separately in case a user option    changes the value before md_show_usage is called.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|default_arch_size
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|OBJ_ELF
end_ifdef

begin_comment
comment|/* The currently selected v9 memory model.  Currently only used for    ELF.  */
end_comment

begin_enum
specifier|static
enum|enum
block|{
name|MM_TSO
block|,
name|MM_PSO
block|,
name|MM_RMO
block|}
name|sparc_memory_model
init|=
name|MM_RMO
enum|;
end_enum

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|int
name|architecture_requested
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|warn_on_bump
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If warn_on_bump and the needed architecture is higher than this    architecture, issue a warning.  */
end_comment

begin_decl_stmt
specifier|static
name|enum
name|sparc_opcode_arch_val
name|warn_after_architecture
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero if as should generate error if an undeclared g[23] register    has been used in -64.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|no_undeclared_regs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero if we should try to relax jumps and calls.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|sparc_relax
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero if we are generating PIC code.  */
end_comment

begin_decl_stmt
name|int
name|sparc_pic_code
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero if we should give an error when misaligned data is seen.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|enforce_aligned_data
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|target_big_endian
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|target_little_endian_data
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Symbols for global registers on v9.  */
end_comment

begin_decl_stmt
specifier|static
name|symbolS
modifier|*
name|globals
index|[
literal|8
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* V9 and 86x have big and little endian data, but instructions are always big    endian.  The sparclet has bi-endian support but both data and insns have    the same endianness.  Global `target_big_endian' is used for data.    The following macro is used for instructions.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|INSN_BIG_ENDIAN
end_ifndef

begin_define
define|#
directive|define
name|INSN_BIG_ENDIAN
value|(target_big_endian \ 			 || default_arch_type == sparc86x \ 			 || SPARC_OPCODE_ARCH_V9_P (max_architecture))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Handle of the OPCODE hash table.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|hash_control
modifier|*
name|op_hash
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|log2
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|s_data1
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|s_seg
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|s_proc
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|s_reserve
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|s_common
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|s_empty
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|s_uacons
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|s_ncons
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|s_register
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|pseudo_typeS
name|md_pseudo_table
index|[]
init|=
block|{
block|{
literal|"align"
block|,
name|s_align_bytes
block|,
literal|0
block|}
block|,
comment|/* Defaulting is invalid (0).  */
block|{
literal|"common"
block|,
name|s_common
block|,
literal|0
block|}
block|,
block|{
literal|"empty"
block|,
name|s_empty
block|,
literal|0
block|}
block|,
block|{
literal|"global"
block|,
name|s_globl
block|,
literal|0
block|}
block|,
block|{
literal|"half"
block|,
name|cons
block|,
literal|2
block|}
block|,
block|{
literal|"nword"
block|,
name|s_ncons
block|,
literal|0
block|}
block|,
block|{
literal|"optim"
block|,
name|s_ignore
block|,
literal|0
block|}
block|,
block|{
literal|"proc"
block|,
name|s_proc
block|,
literal|0
block|}
block|,
block|{
literal|"reserve"
block|,
name|s_reserve
block|,
literal|0
block|}
block|,
block|{
literal|"seg"
block|,
name|s_seg
block|,
literal|0
block|}
block|,
block|{
literal|"skip"
block|,
name|s_space
block|,
literal|0
block|}
block|,
block|{
literal|"word"
block|,
name|cons
block|,
literal|4
block|}
block|,
block|{
literal|"xword"
block|,
name|cons
block|,
literal|8
block|}
block|,
block|{
literal|"uahalf"
block|,
name|s_uacons
block|,
literal|2
block|}
block|,
block|{
literal|"uaword"
block|,
name|s_uacons
block|,
literal|4
block|}
block|,
block|{
literal|"uaxword"
block|,
name|s_uacons
block|,
literal|8
block|}
block|,
ifdef|#
directive|ifdef
name|OBJ_ELF
block|{
literal|"file"
block|,
name|dwarf2_directive_file
block|,
literal|0
block|}
block|,
block|{
literal|"loc"
block|,
name|dwarf2_directive_loc
block|,
literal|0
block|}
block|,
comment|/* These are specific to sparc/svr4.  */
block|{
literal|"2byte"
block|,
name|s_uacons
block|,
literal|2
block|}
block|,
block|{
literal|"4byte"
block|,
name|s_uacons
block|,
literal|4
block|}
block|,
block|{
literal|"8byte"
block|,
name|s_uacons
block|,
literal|8
block|}
block|,
block|{
literal|"register"
block|,
name|s_register
block|,
literal|0
block|}
block|,
endif|#
directive|endif
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Size of relocation record.  */
end_comment

begin_decl_stmt
specifier|const
name|int
name|md_reloc_size
init|=
literal|12
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This array holds the chars that always start a comment.  If the    pre-processor is disabled, these aren't very useful.  */
end_comment

begin_decl_stmt
specifier|const
name|char
name|comment_chars
index|[]
init|=
literal|"!"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* JF removed '|' from                                            comment_chars.  */
end_comment

begin_comment
comment|/* This array holds the chars that only start a comment at the beginning of    a line.  If the line seems to have the form '# 123 filename'    .line and .file directives will appear in the pre-processed output.  */
end_comment

begin_comment
comment|/* Note that input_file.c hand checks for '#' at the beginning of the    first line of the input file.  This is because the compiler outputs    #NO_APP at the beginning of its output.  */
end_comment

begin_comment
comment|/* Also note that comments started like this one will always    work if '/' isn't otherwise defined.  */
end_comment

begin_decl_stmt
specifier|const
name|char
name|line_comment_chars
index|[]
init|=
literal|"#"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
name|line_separator_chars
index|[]
init|=
literal|";"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Chars that can be used to separate mant from exp in floating point    nums.  */
end_comment

begin_decl_stmt
specifier|const
name|char
name|EXP_CHARS
index|[]
init|=
literal|"eE"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Chars that mean this number is a floating point constant.    As in 0f12.456    or    0d1.2345e12  */
end_comment

begin_decl_stmt
specifier|const
name|char
name|FLT_CHARS
index|[]
init|=
literal|"rRsSfFdDxXpP"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Also be aware that MAXIMUM_NUMBER_OF_CHARS_FOR_FLOAT may have to be    changed in read.c.  Ideally it shouldn't have to know about it at all,    but nothing is ideal around here.  */
end_comment

begin_define
define|#
directive|define
name|isoctal
parameter_list|(
name|c
parameter_list|)
value|((unsigned) ((c) - '0')< '8')
end_define

begin_struct
struct|struct
name|sparc_it
block|{
name|char
modifier|*
name|error
decl_stmt|;
name|unsigned
name|long
name|opcode
decl_stmt|;
name|struct
name|nlist
modifier|*
name|nlistp
decl_stmt|;
name|expressionS
name|exp
decl_stmt|;
name|expressionS
name|exp2
decl_stmt|;
name|int
name|pcrel
decl_stmt|;
name|bfd_reloc_code_real_type
name|reloc
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|sparc_it
name|the_insn
decl_stmt|,
name|set_insn
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_insn
name|PARAMS
argument_list|(
operator|(
specifier|const
expr|struct
name|sparc_opcode
operator|*
operator|,
expr|struct
name|sparc_it
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Table of arguments to -A.    The sparc_opcode_arch table in sparc-opc.c is insufficient and incorrect    for this use.  That table is for opcodes only.  This table is for opcodes    and file formats.  */
end_comment

begin_enum
enum|enum
name|sparc_arch_types
block|{
name|v6
block|,
name|v7
block|,
name|v8
block|,
name|sparclet
block|,
name|sparclite
block|,
name|sparc86x
block|,
name|v8plus
block|,
name|v8plusa
block|,
name|v9
block|,
name|v9a
block|,
name|v9b
block|,
name|v9_64
block|}
enum|;
end_enum

begin_struct
specifier|static
struct|struct
name|sparc_arch
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|opcode_arch
decl_stmt|;
name|enum
name|sparc_arch_types
name|arch_type
decl_stmt|;
comment|/* Default word size, as specified during configuration.      A value of zero means can't be used to specify default architecture.  */
name|int
name|default_arch_size
decl_stmt|;
comment|/* Allowable arg to -A?  */
name|int
name|user_option_p
decl_stmt|;
block|}
name|sparc_arch_table
index|[]
init|=
block|{
block|{
literal|"v6"
block|,
literal|"v6"
block|,
name|v6
block|,
literal|0
block|,
literal|1
block|}
block|,
block|{
literal|"v7"
block|,
literal|"v7"
block|,
name|v7
block|,
literal|0
block|,
literal|1
block|}
block|,
block|{
literal|"v8"
block|,
literal|"v8"
block|,
name|v8
block|,
literal|32
block|,
literal|1
block|}
block|,
block|{
literal|"sparclet"
block|,
literal|"sparclet"
block|,
name|sparclet
block|,
literal|32
block|,
literal|1
block|}
block|,
block|{
literal|"sparclite"
block|,
literal|"sparclite"
block|,
name|sparclite
block|,
literal|32
block|,
literal|1
block|}
block|,
block|{
literal|"sparc86x"
block|,
literal|"sparclite"
block|,
name|sparc86x
block|,
literal|32
block|,
literal|1
block|}
block|,
block|{
literal|"v8plus"
block|,
literal|"v9"
block|,
name|v9
block|,
literal|0
block|,
literal|1
block|}
block|,
block|{
literal|"v8plusa"
block|,
literal|"v9a"
block|,
name|v9
block|,
literal|0
block|,
literal|1
block|}
block|,
block|{
literal|"v8plusb"
block|,
literal|"v9b"
block|,
name|v9
block|,
literal|0
block|,
literal|1
block|}
block|,
block|{
literal|"v9"
block|,
literal|"v9"
block|,
name|v9
block|,
literal|0
block|,
literal|1
block|}
block|,
block|{
literal|"v9a"
block|,
literal|"v9a"
block|,
name|v9
block|,
literal|0
block|,
literal|1
block|}
block|,
block|{
literal|"v9b"
block|,
literal|"v9b"
block|,
name|v9
block|,
literal|0
block|,
literal|1
block|}
block|,
comment|/* This exists to allow configure.in/Makefile.in to pass one      value to specify both the default machine and default word size.  */
block|{
literal|"v9-64"
block|,
literal|"v9"
block|,
name|v9
block|,
literal|64
block|,
literal|0
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
name|v8
block|,
literal|0
block|,
literal|0
block|}
block|}
struct|;
end_struct

begin_comment
comment|/* Variant of default_arch */
end_comment

begin_decl_stmt
specifier|static
name|enum
name|sparc_arch_types
name|default_arch_type
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|struct
name|sparc_arch
modifier|*
name|lookup_arch
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|struct
name|sparc_arch
modifier|*
name|sa
decl_stmt|;
for|for
control|(
name|sa
operator|=
operator|&
name|sparc_arch_table
index|[
literal|0
index|]
init|;
name|sa
operator|->
name|name
operator|!=
name|NULL
condition|;
name|sa
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|sa
operator|->
name|name
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|sa
operator|->
name|name
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
return|return
name|sa
return|;
block|}
end_function

begin_comment
comment|/* Initialize the default opcode arch and word size from the default    architecture name.  */
end_comment

begin_function
specifier|static
name|void
name|init_default_arch
parameter_list|()
block|{
name|struct
name|sparc_arch
modifier|*
name|sa
init|=
name|lookup_arch
argument_list|(
name|default_arch
argument_list|)
decl_stmt|;
if|if
condition|(
name|sa
operator|==
name|NULL
operator|||
name|sa
operator|->
name|default_arch_size
operator|==
literal|0
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"Invalid default architecture, broken assembler."
argument_list|)
argument_list|)
expr_stmt|;
name|max_architecture
operator|=
name|sparc_opcode_lookup_arch
argument_list|(
name|sa
operator|->
name|opcode_arch
argument_list|)
expr_stmt|;
if|if
condition|(
name|max_architecture
operator|==
name|SPARC_OPCODE_ARCH_BAD
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"Bad opcode table, broken assembler."
argument_list|)
argument_list|)
expr_stmt|;
name|default_arch_size
operator|=
name|sparc_arch_size
operator|=
name|sa
operator|->
name|default_arch_size
expr_stmt|;
name|default_init_p
operator|=
literal|1
expr_stmt|;
name|default_arch_type
operator|=
name|sa
operator|->
name|arch_type
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Called by TARGET_FORMAT.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|sparc_target_format
parameter_list|()
block|{
comment|/* We don't get a chance to initialize anything before we're called,      so handle that now.  */
if|if
condition|(
operator|!
name|default_init_p
condition|)
name|init_default_arch
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|OBJ_AOUT
ifdef|#
directive|ifdef
name|TE_NetBSD
return|return
literal|"a.out-sparc-netbsd"
return|;
else|#
directive|else
ifdef|#
directive|ifdef
name|TE_SPARCAOUT
if|if
condition|(
name|target_big_endian
condition|)
return|return
literal|"a.out-sunos-big"
return|;
elseif|else
if|if
condition|(
name|default_arch_type
operator|==
name|sparc86x
operator|&&
name|target_little_endian_data
condition|)
return|return
literal|"a.out-sunos-big"
return|;
else|else
return|return
literal|"a.out-sparc-little"
return|;
else|#
directive|else
return|return
literal|"a.out-sunos-big"
return|;
endif|#
directive|endif
endif|#
directive|endif
endif|#
directive|endif
ifdef|#
directive|ifdef
name|OBJ_BOUT
return|return
literal|"b.out.big"
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|OBJ_COFF
ifdef|#
directive|ifdef
name|TE_LYNX
return|return
literal|"coff-sparc-lynx"
return|;
else|#
directive|else
return|return
literal|"coff-sparc"
return|;
endif|#
directive|endif
endif|#
directive|endif
ifdef|#
directive|ifdef
name|OBJ_ELF
return|return
name|sparc_arch_size
operator|==
literal|64
condition|?
literal|"elf64-sparc"
else|:
literal|"elf32-sparc"
return|;
endif|#
directive|endif
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* md_parse_option  *	Invocation line includes a switch not recognized by the base assembler.  *	See if it's a processor-specific option.  These are:  *  *	-bump  *		Warn on architecture bumps.  See also -A.  *  *	-Av6, -Av7, -Av8, -Asparclite, -Asparclet  *		Standard 32 bit architectures.  *	-Av9, -Av9a, -Av9b  *		Sparc64 in either a 32 or 64 bit world (-32/-64 says which).  *		This used to only mean 64 bits, but properly specifying it  *		complicated gcc's ASM_SPECs, so now opcode selection is  *		specified orthogonally to word size (except when specifying  *		the default, but that is an internal implementation detail).  *	-Av8plus, -Av8plusa, -Av8plusb  *		Same as -Av9{,a,b}.  *	-xarch=v8plus, -xarch=v8plusa, -xarch=v8plusb  *		Same as -Av8plus{,a,b} -32, for compatibility with Sun's  *		assembler.  *	-xarch=v9, -xarch=v9a, -xarch=v9b  *		Same as -Av9{,a,b} -64, for compatibility with Sun's  *		assembler.  *  *		Select the architecture and possibly the file format.  *		Instructions or features not supported by the selected  *		architecture cause fatal errors.  *  *		The default is to start at v6, and bump the architecture up  *		whenever an instruction is seen at a higher level.  In 32 bit  *		environments, v9 is not bumped up to, the user must pass  * 		-Av8plus{,a,b}.  *  *		If -bump is specified, a warning is printing when bumping to  *		higher levels.  *  *		If an architecture is specified, all instructions must match  *		that architecture.  Any higher level instructions are flagged  *		as errors.  Note that in the 32 bit environment specifying  *		-Av8plus does not automatically create a v8plus object file, a  *		v9 insn must be seen.  *  *		If both an architecture and -bump are specified, the  *		architecture starts at the specified level, but bumps are  *		warnings.  Note that we can't set `current_architecture' to  *		the requested level in this case: in the 32 bit environment,  *		we still must avoid creating v8plus object files unless v9  * 		insns are seen.  *  * Note:  *		Bumping between incompatible architectures is always an  *		error.  For example, from sparclite to v9.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|OBJ_ELF
end_ifdef

begin_decl_stmt
name|CONST
name|char
modifier|*
name|md_shortopts
init|=
literal|"A:K:VQ:sq"
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_ifdef
ifdef|#
directive|ifdef
name|OBJ_AOUT
end_ifdef

begin_decl_stmt
name|CONST
name|char
modifier|*
name|md_shortopts
init|=
literal|"A:k"
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
name|CONST
name|char
modifier|*
name|md_shortopts
init|=
literal|"A:"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|struct
name|option
name|md_longopts
index|[]
init|=
block|{
define|#
directive|define
name|OPTION_BUMP
value|(OPTION_MD_BASE)
block|{
literal|"bump"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_BUMP
block|}
block|,
define|#
directive|define
name|OPTION_SPARC
value|(OPTION_MD_BASE + 1)
block|{
literal|"sparc"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_SPARC
block|}
block|,
define|#
directive|define
name|OPTION_XARCH
value|(OPTION_MD_BASE + 2)
block|{
literal|"xarch"
block|,
name|required_argument
block|,
name|NULL
block|,
name|OPTION_XARCH
block|}
block|,
ifdef|#
directive|ifdef
name|OBJ_ELF
define|#
directive|define
name|OPTION_32
value|(OPTION_MD_BASE + 3)
block|{
literal|"32"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_32
block|}
block|,
define|#
directive|define
name|OPTION_64
value|(OPTION_MD_BASE + 4)
block|{
literal|"64"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_64
block|}
block|,
define|#
directive|define
name|OPTION_TSO
value|(OPTION_MD_BASE + 5)
block|{
literal|"TSO"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_TSO
block|}
block|,
define|#
directive|define
name|OPTION_PSO
value|(OPTION_MD_BASE + 6)
block|{
literal|"PSO"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_PSO
block|}
block|,
define|#
directive|define
name|OPTION_RMO
value|(OPTION_MD_BASE + 7)
block|{
literal|"RMO"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_RMO
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SPARC_BIENDIAN
define|#
directive|define
name|OPTION_LITTLE_ENDIAN
value|(OPTION_MD_BASE + 8)
block|{
literal|"EL"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_LITTLE_ENDIAN
block|}
block|,
define|#
directive|define
name|OPTION_BIG_ENDIAN
value|(OPTION_MD_BASE + 9)
block|{
literal|"EB"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_BIG_ENDIAN
block|}
block|,
endif|#
directive|endif
define|#
directive|define
name|OPTION_ENFORCE_ALIGNED_DATA
value|(OPTION_MD_BASE + 10)
block|{
literal|"enforce-aligned-data"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_ENFORCE_ALIGNED_DATA
block|}
block|,
define|#
directive|define
name|OPTION_LITTLE_ENDIAN_DATA
value|(OPTION_MD_BASE + 11)
block|{
literal|"little-endian-data"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_LITTLE_ENDIAN_DATA
block|}
block|,
ifdef|#
directive|ifdef
name|OBJ_ELF
define|#
directive|define
name|OPTION_NO_UNDECLARED_REGS
value|(OPTION_MD_BASE + 12)
block|{
literal|"no-undeclared-regs"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_NO_UNDECLARED_REGS
block|}
block|,
define|#
directive|define
name|OPTION_UNDECLARED_REGS
value|(OPTION_MD_BASE + 13)
block|{
literal|"undeclared-regs"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_UNDECLARED_REGS
block|}
block|,
endif|#
directive|endif
define|#
directive|define
name|OPTION_RELAX
value|(OPTION_MD_BASE + 14)
block|{
literal|"relax"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_RELAX
block|}
block|,
define|#
directive|define
name|OPTION_NO_RELAX
value|(OPTION_MD_BASE + 15)
block|{
literal|"no-relax"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_NO_RELAX
block|}
block|,
block|{
name|NULL
block|,
name|no_argument
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|size_t
name|md_longopts_size
init|=
sizeof|sizeof
argument_list|(
name|md_longopts
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|md_parse_option
parameter_list|(
name|c
parameter_list|,
name|arg
parameter_list|)
name|int
name|c
decl_stmt|;
name|char
modifier|*
name|arg
decl_stmt|;
block|{
comment|/* We don't get a chance to initialize anything before we're called,      so handle that now.  */
if|if
condition|(
operator|!
name|default_init_p
condition|)
name|init_default_arch
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
name|OPTION_BUMP
case|:
name|warn_on_bump
operator|=
literal|1
expr_stmt|;
name|warn_after_architecture
operator|=
name|SPARC_OPCODE_ARCH_V6
expr_stmt|;
break|break;
case|case
name|OPTION_XARCH
case|:
ifdef|#
directive|ifdef
name|OBJ_ELF
if|if
condition|(
name|strncmp
argument_list|(
name|arg
argument_list|,
literal|"v9"
argument_list|,
literal|2
argument_list|)
operator|!=
literal|0
condition|)
name|md_parse_option
argument_list|(
name|OPTION_32
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|else
name|md_parse_option
argument_list|(
name|OPTION_64
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Fall through.  */
case|case
literal|'A'
case|:
block|{
name|struct
name|sparc_arch
modifier|*
name|sa
decl_stmt|;
name|enum
name|sparc_opcode_arch_val
name|opcode_arch
decl_stmt|;
name|sa
operator|=
name|lookup_arch
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|sa
operator|==
name|NULL
operator|||
operator|!
name|sa
operator|->
name|user_option_p
condition|)
block|{
if|if
condition|(
name|c
operator|==
name|OPTION_XARCH
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"invalid architecture -xarch=%s"
argument_list|)
argument_list|,
name|arg
argument_list|)
expr_stmt|;
else|else
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"invalid architecture -A%s"
argument_list|)
argument_list|,
name|arg
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|opcode_arch
operator|=
name|sparc_opcode_lookup_arch
argument_list|(
name|sa
operator|->
name|opcode_arch
argument_list|)
expr_stmt|;
if|if
condition|(
name|opcode_arch
operator|==
name|SPARC_OPCODE_ARCH_BAD
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"Bad opcode table, broken assembler."
argument_list|)
argument_list|)
expr_stmt|;
name|max_architecture
operator|=
name|opcode_arch
expr_stmt|;
name|architecture_requested
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|OPTION_SPARC
case|:
comment|/* Ignore -sparc, used by SunOS make default .s.o rule.  */
break|break;
case|case
name|OPTION_ENFORCE_ALIGNED_DATA
case|:
name|enforce_aligned_data
operator|=
literal|1
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|SPARC_BIENDIAN
case|case
name|OPTION_LITTLE_ENDIAN
case|:
name|target_big_endian
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|default_arch_type
operator|!=
name|sparclet
condition|)
name|as_fatal
argument_list|(
literal|"This target does not support -EL"
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPTION_LITTLE_ENDIAN_DATA
case|:
name|target_little_endian_data
operator|=
literal|1
expr_stmt|;
name|target_big_endian
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|default_arch_type
operator|!=
name|sparc86x
operator|&&
name|default_arch_type
operator|!=
name|v9
condition|)
name|as_fatal
argument_list|(
literal|"This target does not support --little-endian-data"
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPTION_BIG_ENDIAN
case|:
name|target_big_endian
operator|=
literal|1
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|OBJ_AOUT
case|case
literal|'k'
case|:
name|sparc_pic_code
operator|=
literal|1
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|OBJ_ELF
case|case
name|OPTION_32
case|:
case|case
name|OPTION_64
case|:
block|{
specifier|const
name|char
modifier|*
modifier|*
name|list
decl_stmt|,
modifier|*
modifier|*
name|l
decl_stmt|;
name|sparc_arch_size
operator|=
name|c
operator|==
name|OPTION_32
condition|?
literal|32
else|:
literal|64
expr_stmt|;
name|list
operator|=
name|bfd_target_list
argument_list|()
expr_stmt|;
for|for
control|(
name|l
operator|=
name|list
init|;
operator|*
name|l
operator|!=
name|NULL
condition|;
name|l
operator|++
control|)
block|{
if|if
condition|(
name|sparc_arch_size
operator|==
literal|32
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
operator|*
name|l
argument_list|,
literal|"elf32-sparc"
argument_list|)
operator|==
literal|0
condition|)
break|break;
block|}
else|else
block|{
if|if
condition|(
name|strcmp
argument_list|(
operator|*
name|l
argument_list|,
literal|"elf64-sparc"
argument_list|)
operator|==
literal|0
condition|)
break|break;
block|}
block|}
if|if
condition|(
operator|*
name|l
operator|==
name|NULL
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"No compiled in support for %d bit object file format"
argument_list|)
argument_list|,
name|sparc_arch_size
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|list
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|OPTION_TSO
case|:
name|sparc_memory_model
operator|=
name|MM_TSO
expr_stmt|;
break|break;
case|case
name|OPTION_PSO
case|:
name|sparc_memory_model
operator|=
name|MM_PSO
expr_stmt|;
break|break;
case|case
name|OPTION_RMO
case|:
name|sparc_memory_model
operator|=
name|MM_RMO
expr_stmt|;
break|break;
case|case
literal|'V'
case|:
name|print_version_id
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'Q'
case|:
comment|/* Qy - do emit .comment 	 Qn - do not emit .comment.  */
break|break;
case|case
literal|'s'
case|:
comment|/* Use .stab instead of .stab.excl.  */
break|break;
case|case
literal|'q'
case|:
comment|/* quick -- Native assembler does fewer checks.  */
break|break;
case|case
literal|'K'
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"PIC"
argument_list|)
operator|!=
literal|0
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"Unrecognized option following -K"
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|sparc_pic_code
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|OPTION_NO_UNDECLARED_REGS
case|:
name|no_undeclared_regs
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|OPTION_UNDECLARED_REGS
case|:
name|no_undeclared_regs
operator|=
literal|0
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|OPTION_RELAX
case|:
name|sparc_relax
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|OPTION_NO_RELAX
case|:
name|sparc_relax
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
name|void
name|md_show_usage
parameter_list|(
name|stream
parameter_list|)
name|FILE
modifier|*
name|stream
decl_stmt|;
block|{
specifier|const
name|struct
name|sparc_arch
modifier|*
name|arch
decl_stmt|;
name|int
name|column
decl_stmt|;
comment|/* We don't get a chance to initialize anything before we're called,      so handle that now.  */
if|if
condition|(
operator|!
name|default_init_p
condition|)
name|init_default_arch
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"SPARC options:\n"
argument_list|)
argument_list|)
expr_stmt|;
name|column
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|arch
operator|=
operator|&
name|sparc_arch_table
index|[
literal|0
index|]
init|;
name|arch
operator|->
name|name
condition|;
name|arch
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|arch
operator|->
name|user_option_p
condition|)
continue|continue;
if|if
condition|(
name|arch
operator|!=
operator|&
name|sparc_arch_table
index|[
literal|0
index|]
condition|)
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|" | "
argument_list|)
expr_stmt|;
if|if
condition|(
name|column
operator|+
name|strlen
argument_list|(
name|arch
operator|->
name|name
argument_list|)
operator|>
literal|70
condition|)
block|{
name|column
operator|=
literal|0
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
name|column
operator|+=
literal|5
operator|+
literal|2
operator|+
name|strlen
argument_list|(
name|arch
operator|->
name|name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"-A%s"
argument_list|,
name|arch
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|arch
operator|=
operator|&
name|sparc_arch_table
index|[
literal|0
index|]
init|;
name|arch
operator|->
name|name
condition|;
name|arch
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|arch
operator|->
name|user_option_p
condition|)
continue|continue;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|" | "
argument_list|)
expr_stmt|;
if|if
condition|(
name|column
operator|+
name|strlen
argument_list|(
name|arch
operator|->
name|name
argument_list|)
operator|>
literal|65
condition|)
block|{
name|column
operator|=
literal|0
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
name|column
operator|+=
literal|5
operator|+
literal|7
operator|+
name|strlen
argument_list|(
name|arch
operator|->
name|name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"-xarch=%s"
argument_list|,
name|arch
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"\n\ 			specify variant of SPARC architecture\n\ -bump			warn when assembler switches architectures\n\ -sparc			ignored\n\ --enforce-aligned-data	force .long, etc., to be aligned correctly\n\ -relax			relax jumps and branches (default)\n\ -no-relax		avoid changing any jumps and branches\n"
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|OBJ_AOUT
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"\ -k			generate PIC\n"
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|OBJ_ELF
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"\ -32			create 32 bit object file\n\ -64			create 64 bit object file\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"\ 			[default is %d]\n"
argument_list|)
argument_list|,
name|default_arch_size
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"\ -TSO			use Total Store Ordering\n\ -PSO			use Partial Store Ordering\n\ -RMO			use Relaxed Memory Ordering\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"\ 			[default is %s]\n"
argument_list|)
argument_list|,
operator|(
name|default_arch_size
operator|==
literal|64
operator|)
condition|?
literal|"RMO"
else|:
literal|"TSO"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"\ -KPIC			generate PIC\n\ -V			print assembler version number\n\ -undeclared-regs	ignore application global register usage without\n\ 			appropriate .register directive (default)\n\ -no-undeclared-regs	force error on application global register usage\n\ 			without appropriate .register directive\n\ -q			ignored\n\ -Qy, -Qn		ignored\n\ -s			ignored\n"
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SPARC_BIENDIAN
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"\ -EL			generate code for a little endian machine\n\ -EB			generate code for a big endian machine\n\ --little-endian-data	generate code for a machine having big endian\n\                         instructions and little endian data.\n"
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Native operand size opcode translation.  */
end_comment

begin_struct
struct|struct
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|name32
decl_stmt|;
name|char
modifier|*
name|name64
decl_stmt|;
block|}
name|native_op_table
index|[]
init|=
block|{
block|{
literal|"ldn"
block|,
literal|"ld"
block|,
literal|"ldx"
block|}
block|,
block|{
literal|"ldna"
block|,
literal|"lda"
block|,
literal|"ldxa"
block|}
block|,
block|{
literal|"stn"
block|,
literal|"st"
block|,
literal|"stx"
block|}
block|,
block|{
literal|"stna"
block|,
literal|"sta"
block|,
literal|"stxa"
block|}
block|,
block|{
literal|"slln"
block|,
literal|"sll"
block|,
literal|"sllx"
block|}
block|,
block|{
literal|"srln"
block|,
literal|"srl"
block|,
literal|"srlx"
block|}
block|,
block|{
literal|"sran"
block|,
literal|"sra"
block|,
literal|"srax"
block|}
block|,
block|{
literal|"casn"
block|,
literal|"cas"
block|,
literal|"casx"
block|}
block|,
block|{
literal|"casna"
block|,
literal|"casa"
block|,
literal|"casxa"
block|}
block|,
block|{
literal|"clrn"
block|,
literal|"clr"
block|,
literal|"clrx"
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
block|, }
struct|;
end_struct

begin_escape
end_escape

begin_comment
comment|/* sparc64 priviledged registers.  */
end_comment

begin_struct
struct|struct
name|priv_reg_entry
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|regnum
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|priv_reg_entry
name|priv_reg_table
index|[]
init|=
block|{
block|{
literal|"tpc"
block|,
literal|0
block|}
block|,
block|{
literal|"tnpc"
block|,
literal|1
block|}
block|,
block|{
literal|"tstate"
block|,
literal|2
block|}
block|,
block|{
literal|"tt"
block|,
literal|3
block|}
block|,
block|{
literal|"tick"
block|,
literal|4
block|}
block|,
block|{
literal|"tba"
block|,
literal|5
block|}
block|,
block|{
literal|"pstate"
block|,
literal|6
block|}
block|,
block|{
literal|"tl"
block|,
literal|7
block|}
block|,
block|{
literal|"pil"
block|,
literal|8
block|}
block|,
block|{
literal|"cwp"
block|,
literal|9
block|}
block|,
block|{
literal|"cansave"
block|,
literal|10
block|}
block|,
block|{
literal|"canrestore"
block|,
literal|11
block|}
block|,
block|{
literal|"cleanwin"
block|,
literal|12
block|}
block|,
block|{
literal|"otherwin"
block|,
literal|13
block|}
block|,
block|{
literal|"wstate"
block|,
literal|14
block|}
block|,
block|{
literal|"fq"
block|,
literal|15
block|}
block|,
block|{
literal|"ver"
block|,
literal|31
block|}
block|,
block|{
literal|""
block|,
operator|-
literal|1
block|}
block|,
comment|/* End marker.  */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* v9a specific asrs.  */
end_comment

begin_decl_stmt
name|struct
name|priv_reg_entry
name|v9a_asr_table
index|[]
init|=
block|{
block|{
literal|"tick_cmpr"
block|,
literal|23
block|}
block|,
block|{
literal|"sys_tick_cmpr"
block|,
literal|25
block|}
block|,
block|{
literal|"sys_tick"
block|,
literal|24
block|}
block|,
block|{
literal|"softint"
block|,
literal|22
block|}
block|,
block|{
literal|"set_softint"
block|,
literal|20
block|}
block|,
block|{
literal|"pic"
block|,
literal|17
block|}
block|,
block|{
literal|"pcr"
block|,
literal|16
block|}
block|,
block|{
literal|"gsr"
block|,
literal|19
block|}
block|,
block|{
literal|"dcr"
block|,
literal|18
block|}
block|,
block|{
literal|"clear_softint"
block|,
literal|21
block|}
block|,
block|{
literal|""
block|,
operator|-
literal|1
block|}
block|,
comment|/* End marker.  */
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|cmp_reg_entry
parameter_list|(
name|parg
parameter_list|,
name|qarg
parameter_list|)
specifier|const
name|PTR
name|parg
decl_stmt|;
specifier|const
name|PTR
name|qarg
decl_stmt|;
block|{
specifier|const
name|struct
name|priv_reg_entry
modifier|*
name|p
init|=
operator|(
specifier|const
expr|struct
name|priv_reg_entry
operator|*
operator|)
name|parg
decl_stmt|;
specifier|const
name|struct
name|priv_reg_entry
modifier|*
name|q
init|=
operator|(
specifier|const
expr|struct
name|priv_reg_entry
operator|*
operator|)
name|qarg
decl_stmt|;
return|return
name|strcmp
argument_list|(
name|q
operator|->
name|name
argument_list|,
name|p
operator|->
name|name
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This function is called once, at assembler startup time.  It should    set up all the tables, etc. that the MD part of the assembler will    need.  */
end_comment

begin_function
name|void
name|md_begin
parameter_list|()
block|{
specifier|register
specifier|const
name|char
modifier|*
name|retval
init|=
name|NULL
decl_stmt|;
name|int
name|lose
init|=
literal|0
decl_stmt|;
specifier|register
name|unsigned
name|int
name|i
init|=
literal|0
decl_stmt|;
comment|/* We don't get a chance to initialize anything before md_parse_option      is called, and it may not be called, so handle default initialization      now if not already done.  */
if|if
condition|(
operator|!
name|default_init_p
condition|)
name|init_default_arch
argument_list|()
expr_stmt|;
name|op_hash
operator|=
name|hash_new
argument_list|()
expr_stmt|;
while|while
condition|(
name|i
operator|<
operator|(
name|unsigned
name|int
operator|)
name|sparc_num_opcodes
condition|)
block|{
specifier|const
name|char
modifier|*
name|name
init|=
name|sparc_opcodes
index|[
name|i
index|]
operator|.
name|name
decl_stmt|;
name|retval
operator|=
name|hash_insert
argument_list|(
name|op_hash
argument_list|,
name|name
argument_list|,
operator|(
name|PTR
operator|)
operator|&
name|sparc_opcodes
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
name|NULL
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Internal error: can't hash `%s': %s\n"
argument_list|)
argument_list|,
name|sparc_opcodes
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|retval
argument_list|)
expr_stmt|;
name|lose
operator|=
literal|1
expr_stmt|;
block|}
do|do
block|{
if|if
condition|(
name|sparc_opcodes
index|[
name|i
index|]
operator|.
name|match
operator|&
name|sparc_opcodes
index|[
name|i
index|]
operator|.
name|lose
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Internal error: losing opcode: `%s' \"%s\"\n"
argument_list|)
argument_list|,
name|sparc_opcodes
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|sparc_opcodes
index|[
name|i
index|]
operator|.
name|args
argument_list|)
expr_stmt|;
name|lose
operator|=
literal|1
expr_stmt|;
block|}
operator|++
name|i
expr_stmt|;
block|}
do|while
condition|(
name|i
operator|<
operator|(
name|unsigned
name|int
operator|)
name|sparc_num_opcodes
operator|&&
operator|!
name|strcmp
argument_list|(
name|sparc_opcodes
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|name
argument_list|)
condition|)
do|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|native_op_table
index|[
name|i
index|]
operator|.
name|name
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|struct
name|sparc_opcode
modifier|*
name|insn
decl_stmt|;
name|char
modifier|*
name|name
init|=
operator|(
operator|(
name|sparc_arch_size
operator|==
literal|32
operator|)
condition|?
name|native_op_table
index|[
name|i
index|]
operator|.
name|name32
else|:
name|native_op_table
index|[
name|i
index|]
operator|.
name|name64
operator|)
decl_stmt|;
name|insn
operator|=
operator|(
expr|struct
name|sparc_opcode
operator|*
operator|)
name|hash_find
argument_list|(
name|op_hash
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn
operator|==
name|NULL
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Internal error: can't find opcode `%s' for `%s'\n"
argument_list|)
argument_list|,
name|name
argument_list|,
name|native_op_table
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|lose
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|retval
operator|=
name|hash_insert
argument_list|(
name|op_hash
argument_list|,
name|native_op_table
index|[
name|i
index|]
operator|.
name|name
argument_list|,
operator|(
name|PTR
operator|)
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
name|NULL
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Internal error: can't hash `%s': %s\n"
argument_list|)
argument_list|,
name|sparc_opcodes
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|retval
argument_list|)
expr_stmt|;
name|lose
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|lose
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"Broken assembler.  No assembly attempted."
argument_list|)
argument_list|)
expr_stmt|;
name|qsort
argument_list|(
name|priv_reg_table
argument_list|,
sizeof|sizeof
argument_list|(
name|priv_reg_table
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|priv_reg_table
index|[
literal|0
index|]
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|priv_reg_table
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|cmp_reg_entry
argument_list|)
expr_stmt|;
comment|/* If -bump, record the architecture level at which we start issuing      warnings.  The behaviour is different depending upon whether an      architecture was explicitly specified.  If it wasn't, we issue warnings      for all upwards bumps.  If it was, we don't start issuing warnings until      we need to bump beyond the requested architecture or when we bump between      conflicting architectures.  */
if|if
condition|(
name|warn_on_bump
operator|&&
name|architecture_requested
condition|)
block|{
comment|/* `max_architecture' records the requested architecture. 	 Issue warnings if we go above it.  */
name|warn_after_architecture
operator|=
name|max_architecture
expr_stmt|;
comment|/* Find the highest architecture level that doesn't conflict with 	 the requested one.  */
for|for
control|(
name|max_architecture
operator|=
name|SPARC_OPCODE_ARCH_MAX
init|;
name|max_architecture
operator|>
name|warn_after_architecture
condition|;
operator|--
name|max_architecture
control|)
if|if
condition|(
operator|!
name|SPARC_OPCODE_CONFLICT_P
argument_list|(
name|max_architecture
argument_list|,
name|warn_after_architecture
argument_list|)
condition|)
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Called after all assembly has been done.  */
end_comment

begin_function
name|void
name|sparc_md_end
parameter_list|()
block|{
name|unsigned
name|long
name|mach
init|=
name|bfd_mach_sparc
decl_stmt|;
if|if
condition|(
name|sparc_arch_size
operator|==
literal|64
condition|)
switch|switch
condition|(
name|current_architecture
condition|)
block|{
case|case
name|SPARC_OPCODE_ARCH_V9A
case|:
name|mach
operator|=
name|bfd_mach_sparc_v9a
expr_stmt|;
break|break;
case|case
name|SPARC_OPCODE_ARCH_V9B
case|:
name|mach
operator|=
name|bfd_mach_sparc_v9b
expr_stmt|;
break|break;
default|default:
name|mach
operator|=
name|bfd_mach_sparc_v9
expr_stmt|;
break|break;
block|}
else|else
switch|switch
condition|(
name|current_architecture
condition|)
block|{
case|case
name|SPARC_OPCODE_ARCH_SPARCLET
case|:
name|mach
operator|=
name|bfd_mach_sparc_sparclet
expr_stmt|;
break|break;
case|case
name|SPARC_OPCODE_ARCH_V9
case|:
name|mach
operator|=
name|bfd_mach_sparc_v8plus
expr_stmt|;
break|break;
case|case
name|SPARC_OPCODE_ARCH_V9A
case|:
name|mach
operator|=
name|bfd_mach_sparc_v8plusa
expr_stmt|;
break|break;
case|case
name|SPARC_OPCODE_ARCH_V9B
case|:
name|mach
operator|=
name|bfd_mach_sparc_v8plusb
expr_stmt|;
break|break;
comment|/* The sparclite is treated like a normal sparc.  Perhaps it shouldn't 	 be but for now it is (since that's the way it's always been 	 treated).  */
default|default:
break|break;
block|}
name|bfd_set_arch_mach
argument_list|(
name|stdoutput
argument_list|,
name|bfd_arch_sparc
argument_list|,
name|mach
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return non-zero if VAL is in the range -(MAX+1) to MAX.  */
end_comment

begin_function
specifier|static
name|INLINE
name|int
name|in_signed_range
parameter_list|(
name|val
parameter_list|,
name|max
parameter_list|)
name|bfd_signed_vma
name|val
decl_stmt|,
name|max
decl_stmt|;
block|{
if|if
condition|(
name|max
operator|<=
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Sign-extend the value from the architecture word size, so that      0xffffffff is always considered -1 on sparc32.  */
if|if
condition|(
name|sparc_arch_size
operator|==
literal|32
condition|)
block|{
name|bfd_signed_vma
name|sign
init|=
operator|(
name|bfd_signed_vma
operator|)
literal|1
operator|<<
literal|31
decl_stmt|;
name|val
operator|=
operator|(
operator|(
name|val
operator|&
name|U0xffffffff
operator|)
operator|^
name|sign
operator|)
operator|-
name|sign
expr_stmt|;
block|}
if|if
condition|(
name|val
operator|>
name|max
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|val
operator|<
operator|~
name|max
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Return non-zero if VAL is in the range 0 to MAX.  */
end_comment

begin_function
specifier|static
name|INLINE
name|int
name|in_unsigned_range
parameter_list|(
name|val
parameter_list|,
name|max
parameter_list|)
name|bfd_vma
name|val
decl_stmt|,
name|max
decl_stmt|;
block|{
if|if
condition|(
name|val
operator|>
name|max
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Return non-zero if VAL is in the range -(MAX/2+1) to MAX.    (e.g. -15 to +31).  */
end_comment

begin_function
specifier|static
name|INLINE
name|int
name|in_bitfield_range
parameter_list|(
name|val
parameter_list|,
name|max
parameter_list|)
name|bfd_signed_vma
name|val
decl_stmt|,
name|max
decl_stmt|;
block|{
if|if
condition|(
name|max
operator|<=
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|val
operator|>
name|max
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|val
operator|<
operator|~
operator|(
name|max
operator|>>
literal|1
operator|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sparc_ffs
parameter_list|(
name|mask
parameter_list|)
name|unsigned
name|int
name|mask
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|mask
operator|==
literal|0
condition|)
return|return
operator|-
literal|1
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|mask
operator|&
literal|1
operator|)
operator|==
literal|0
condition|;
operator|++
name|i
control|)
name|mask
operator|>>=
literal|1
expr_stmt|;
return|return
name|i
return|;
block|}
end_function

begin_comment
comment|/* Implement big shift right.  */
end_comment

begin_function
specifier|static
name|bfd_vma
name|BSR
parameter_list|(
name|val
parameter_list|,
name|amount
parameter_list|)
name|bfd_vma
name|val
decl_stmt|;
name|int
name|amount
decl_stmt|;
block|{
if|if
condition|(
sizeof|sizeof
argument_list|(
name|bfd_vma
argument_list|)
operator|<=
literal|4
operator|&&
name|amount
operator|>=
literal|32
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"Support for 64-bit arithmetic not compiled in."
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|val
operator|>>
name|amount
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* For communication between sparc_ip and get_expression.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|expr_end
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Values for `special_case'.    Instructions that require wierd handling because they're longer than    4 bytes.  */
end_comment

begin_define
define|#
directive|define
name|SPECIAL_CASE_NONE
value|0
end_define

begin_define
define|#
directive|define
name|SPECIAL_CASE_SET
value|1
end_define

begin_define
define|#
directive|define
name|SPECIAL_CASE_SETSW
value|2
end_define

begin_define
define|#
directive|define
name|SPECIAL_CASE_SETX
value|3
end_define

begin_comment
comment|/* FIXME: sparc-opc.c doesn't have necessary "S" trigger to enable this.  */
end_comment

begin_define
define|#
directive|define
name|SPECIAL_CASE_FDIV
value|4
end_define

begin_comment
comment|/* Bit masks of various insns.  */
end_comment

begin_define
define|#
directive|define
name|NOP_INSN
value|0x01000000
end_define

begin_define
define|#
directive|define
name|OR_INSN
value|0x80100000
end_define

begin_define
define|#
directive|define
name|XOR_INSN
value|0x80180000
end_define

begin_define
define|#
directive|define
name|FMOVS_INSN
value|0x81A00020
end_define

begin_define
define|#
directive|define
name|SETHI_INSN
value|0x01000000
end_define

begin_define
define|#
directive|define
name|SLLX_INSN
value|0x81281000
end_define

begin_define
define|#
directive|define
name|SRA_INSN
value|0x81380000
end_define

begin_comment
comment|/* The last instruction to be assembled.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|sparc_opcode
modifier|*
name|last_insn
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The assembled opcode of `last_insn'.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|long
name|last_opcode
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Handle the set and setuw synthetic instructions.  */
end_comment

begin_function
specifier|static
name|void
name|synthetize_setuw
parameter_list|(
name|insn
parameter_list|)
specifier|const
name|struct
name|sparc_opcode
modifier|*
name|insn
decl_stmt|;
block|{
name|int
name|need_hi22_p
init|=
literal|0
decl_stmt|;
name|int
name|rd
init|=
operator|(
name|the_insn
operator|.
name|opcode
operator|&
name|RD
argument_list|(
operator|~
literal|0
argument_list|)
operator|)
operator|>>
literal|25
decl_stmt|;
if|if
condition|(
name|the_insn
operator|.
name|exp
operator|.
name|X_op
operator|==
name|O_constant
condition|)
block|{
if|if
condition|(
name|SPARC_OPCODE_ARCH_V9_P
argument_list|(
name|max_architecture
argument_list|)
condition|)
block|{
if|if
condition|(
sizeof|sizeof
argument_list|(
name|offsetT
argument_list|)
operator|>
literal|4
operator|&&
operator|(
name|the_insn
operator|.
name|exp
operator|.
name|X_add_number
operator|<
literal|0
operator|||
name|the_insn
operator|.
name|exp
operator|.
name|X_add_number
operator|>
operator|(
name|offsetT
operator|)
name|U0xffffffff
operator|)
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"set: number not in 0..4294967295 range"
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
sizeof|sizeof
argument_list|(
name|offsetT
argument_list|)
operator|>
literal|4
operator|&&
operator|(
name|the_insn
operator|.
name|exp
operator|.
name|X_add_number
operator|<
operator|-
operator|(
name|offsetT
operator|)
name|U0x80000000
operator|||
name|the_insn
operator|.
name|exp
operator|.
name|X_add_number
operator|>
operator|(
name|offsetT
operator|)
name|U0xffffffff
operator|)
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"set: number not in -2147483648..4294967295 range"
argument_list|)
argument_list|)
expr_stmt|;
name|the_insn
operator|.
name|exp
operator|.
name|X_add_number
operator|=
operator|(
name|int
operator|)
name|the_insn
operator|.
name|exp
operator|.
name|X_add_number
expr_stmt|;
block|}
block|}
comment|/* See if operand is absolute and small; skip sethi if so.  */
if|if
condition|(
name|the_insn
operator|.
name|exp
operator|.
name|X_op
operator|!=
name|O_constant
operator|||
name|the_insn
operator|.
name|exp
operator|.
name|X_add_number
operator|>=
operator|(
literal|1
operator|<<
literal|12
operator|)
operator|||
name|the_insn
operator|.
name|exp
operator|.
name|X_add_number
operator|<
operator|-
operator|(
literal|1
operator|<<
literal|12
operator|)
condition|)
block|{
name|the_insn
operator|.
name|opcode
operator|=
operator|(
name|SETHI_INSN
operator||
name|RD
argument_list|(
name|rd
argument_list|)
operator||
operator|(
operator|(
name|the_insn
operator|.
name|exp
operator|.
name|X_add_number
operator|>>
literal|10
operator|)
operator|&
operator|(
name|the_insn
operator|.
name|exp
operator|.
name|X_op
operator|==
name|O_constant
condition|?
literal|0x3fffff
else|:
literal|0
operator|)
operator|)
operator|)
expr_stmt|;
name|the_insn
operator|.
name|reloc
operator|=
operator|(
name|the_insn
operator|.
name|exp
operator|.
name|X_op
operator|!=
name|O_constant
condition|?
name|BFD_RELOC_HI22
else|:
name|BFD_RELOC_NONE
operator|)
expr_stmt|;
name|output_insn
argument_list|(
name|insn
argument_list|,
operator|&
name|the_insn
argument_list|)
expr_stmt|;
name|need_hi22_p
operator|=
literal|1
expr_stmt|;
block|}
comment|/* See if operand has no low-order bits; skip OR if so.  */
if|if
condition|(
name|the_insn
operator|.
name|exp
operator|.
name|X_op
operator|!=
name|O_constant
operator|||
operator|(
name|need_hi22_p
operator|&&
operator|(
name|the_insn
operator|.
name|exp
operator|.
name|X_add_number
operator|&
literal|0x3FF
operator|)
operator|!=
literal|0
operator|)
operator|||
operator|!
name|need_hi22_p
condition|)
block|{
name|the_insn
operator|.
name|opcode
operator|=
operator|(
name|OR_INSN
operator||
operator|(
name|need_hi22_p
condition|?
name|RS1
argument_list|(
name|rd
argument_list|)
else|:
literal|0
operator|)
operator||
name|RD
argument_list|(
name|rd
argument_list|)
operator||
name|IMMED
operator||
operator|(
name|the_insn
operator|.
name|exp
operator|.
name|X_add_number
operator|&
operator|(
name|the_insn
operator|.
name|exp
operator|.
name|X_op
operator|!=
name|O_constant
condition|?
literal|0
else|:
name|need_hi22_p
condition|?
literal|0x3ff
else|:
literal|0x1fff
operator|)
operator|)
operator|)
expr_stmt|;
name|the_insn
operator|.
name|reloc
operator|=
operator|(
name|the_insn
operator|.
name|exp
operator|.
name|X_op
operator|!=
name|O_constant
condition|?
name|BFD_RELOC_LO10
else|:
name|BFD_RELOC_NONE
operator|)
expr_stmt|;
name|output_insn
argument_list|(
name|insn
argument_list|,
operator|&
name|the_insn
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Handle the setsw synthetic instruction.  */
end_comment

begin_function
specifier|static
name|void
name|synthetize_setsw
parameter_list|(
name|insn
parameter_list|)
specifier|const
name|struct
name|sparc_opcode
modifier|*
name|insn
decl_stmt|;
block|{
name|int
name|low32
decl_stmt|,
name|rd
decl_stmt|,
name|opc
decl_stmt|;
name|rd
operator|=
operator|(
name|the_insn
operator|.
name|opcode
operator|&
name|RD
argument_list|(
operator|~
literal|0
argument_list|)
operator|)
operator|>>
literal|25
expr_stmt|;
if|if
condition|(
name|the_insn
operator|.
name|exp
operator|.
name|X_op
operator|!=
name|O_constant
condition|)
block|{
name|synthetize_setuw
argument_list|(
name|insn
argument_list|)
expr_stmt|;
comment|/* Need to sign extend it.  */
name|the_insn
operator|.
name|opcode
operator|=
operator|(
name|SRA_INSN
operator||
name|RS1
argument_list|(
name|rd
argument_list|)
operator||
name|RD
argument_list|(
name|rd
argument_list|)
operator|)
expr_stmt|;
name|the_insn
operator|.
name|reloc
operator|=
name|BFD_RELOC_NONE
expr_stmt|;
name|output_insn
argument_list|(
name|insn
argument_list|,
operator|&
name|the_insn
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
sizeof|sizeof
argument_list|(
name|offsetT
argument_list|)
operator|>
literal|4
operator|&&
operator|(
name|the_insn
operator|.
name|exp
operator|.
name|X_add_number
operator|<
operator|-
operator|(
name|offsetT
operator|)
name|U0x80000000
operator|||
name|the_insn
operator|.
name|exp
operator|.
name|X_add_number
operator|>
operator|(
name|offsetT
operator|)
name|U0xffffffff
operator|)
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"setsw: number not in -2147483648..4294967295 range"
argument_list|)
argument_list|)
expr_stmt|;
name|low32
operator|=
name|the_insn
operator|.
name|exp
operator|.
name|X_add_number
expr_stmt|;
if|if
condition|(
name|low32
operator|>=
literal|0
condition|)
block|{
name|synthetize_setuw
argument_list|(
name|insn
argument_list|)
expr_stmt|;
return|return;
block|}
name|opc
operator|=
name|OR_INSN
expr_stmt|;
name|the_insn
operator|.
name|reloc
operator|=
name|BFD_RELOC_NONE
expr_stmt|;
comment|/* See if operand is absolute and small; skip sethi if so.  */
if|if
condition|(
name|low32
operator|<
operator|-
operator|(
literal|1
operator|<<
literal|12
operator|)
condition|)
block|{
name|the_insn
operator|.
name|opcode
operator|=
operator|(
name|SETHI_INSN
operator||
name|RD
argument_list|(
name|rd
argument_list|)
operator||
operator|(
operator|(
operator|(
operator|~
name|the_insn
operator|.
name|exp
operator|.
name|X_add_number
operator|)
operator|>>
literal|10
operator|)
operator|&
literal|0x3fffff
operator|)
operator|)
expr_stmt|;
name|output_insn
argument_list|(
name|insn
argument_list|,
operator|&
name|the_insn
argument_list|)
expr_stmt|;
name|low32
operator|=
literal|0x1c00
operator||
operator|(
name|low32
operator|&
literal|0x3ff
operator|)
expr_stmt|;
name|opc
operator|=
name|RS1
argument_list|(
name|rd
argument_list|)
operator||
name|XOR_INSN
expr_stmt|;
block|}
name|the_insn
operator|.
name|opcode
operator|=
operator|(
name|opc
operator||
name|RD
argument_list|(
name|rd
argument_list|)
operator||
name|IMMED
operator||
operator|(
name|low32
operator|&
literal|0x1fff
operator|)
operator|)
expr_stmt|;
name|output_insn
argument_list|(
name|insn
argument_list|,
operator|&
name|the_insn
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle the setsw synthetic instruction.  */
end_comment

begin_function
specifier|static
name|void
name|synthetize_setx
parameter_list|(
name|insn
parameter_list|)
specifier|const
name|struct
name|sparc_opcode
modifier|*
name|insn
decl_stmt|;
block|{
name|int
name|upper32
decl_stmt|,
name|lower32
decl_stmt|;
name|int
name|tmpreg
init|=
operator|(
name|the_insn
operator|.
name|opcode
operator|&
name|RS1
argument_list|(
operator|~
literal|0
argument_list|)
operator|)
operator|>>
literal|14
decl_stmt|;
name|int
name|dstreg
init|=
operator|(
name|the_insn
operator|.
name|opcode
operator|&
name|RD
argument_list|(
operator|~
literal|0
argument_list|)
operator|)
operator|>>
literal|25
decl_stmt|;
name|int
name|upper_dstreg
decl_stmt|;
name|int
name|need_hh22_p
init|=
literal|0
decl_stmt|,
name|need_hm10_p
init|=
literal|0
decl_stmt|,
name|need_hi22_p
init|=
literal|0
decl_stmt|,
name|need_lo10_p
init|=
literal|0
decl_stmt|;
name|int
name|need_xor10_p
init|=
literal|0
decl_stmt|;
define|#
directive|define
name|SIGNEXT32
parameter_list|(
name|x
parameter_list|)
value|((((x)& U0xffffffff) ^ U0x80000000) - U0x80000000)
name|lower32
operator|=
name|SIGNEXT32
argument_list|(
name|the_insn
operator|.
name|exp
operator|.
name|X_add_number
argument_list|)
expr_stmt|;
name|upper32
operator|=
name|SIGNEXT32
argument_list|(
name|BSR
argument_list|(
name|the_insn
operator|.
name|exp
operator|.
name|X_add_number
argument_list|,
literal|32
argument_list|)
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|SIGNEXT32
name|upper_dstreg
operator|=
name|tmpreg
expr_stmt|;
comment|/* The tmp reg should not be the dst reg.  */
if|if
condition|(
name|tmpreg
operator|==
name|dstreg
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"setx: temporary register same as destination register"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* ??? Obviously there are other optimizations we can do      (e.g. sethi+shift for 0x1f0000000) and perhaps we shouldn't be      doing some of these.  Later.  If you do change things, try to      change all of this to be table driven as well.  */
comment|/* What to output depends on the number if it's constant.      Compute that first, then output what we've decided upon.  */
if|if
condition|(
name|the_insn
operator|.
name|exp
operator|.
name|X_op
operator|!=
name|O_constant
condition|)
block|{
if|if
condition|(
name|sparc_arch_size
operator|==
literal|32
condition|)
block|{
comment|/* When arch size is 32, we want setx to be equivalent 	     to setuw for anything but constants.  */
name|the_insn
operator|.
name|exp
operator|.
name|X_add_number
operator|&=
literal|0xffffffff
expr_stmt|;
name|synthetize_setuw
argument_list|(
name|insn
argument_list|)
expr_stmt|;
return|return;
block|}
name|need_hh22_p
operator|=
name|need_hm10_p
operator|=
name|need_hi22_p
operator|=
name|need_lo10_p
operator|=
literal|1
expr_stmt|;
name|lower32
operator|=
literal|0
expr_stmt|;
name|upper32
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* Reset X_add_number, we've extracted it as upper32/lower32. 	 Otherwise fixup_segment will complain about not being able to 	 write an 8 byte number in a 4 byte field.  */
name|the_insn
operator|.
name|exp
operator|.
name|X_add_number
operator|=
literal|0
expr_stmt|;
comment|/* Only need hh22 if `or' insn can't handle constant.  */
if|if
condition|(
name|upper32
operator|<
operator|-
operator|(
literal|1
operator|<<
literal|12
operator|)
operator|||
name|upper32
operator|>=
operator|(
literal|1
operator|<<
literal|12
operator|)
condition|)
name|need_hh22_p
operator|=
literal|1
expr_stmt|;
comment|/* Does bottom part (after sethi) have bits?  */
if|if
condition|(
operator|(
name|need_hh22_p
operator|&&
operator|(
name|upper32
operator|&
literal|0x3ff
operator|)
operator|!=
literal|0
operator|)
comment|/* No hh22, but does upper32 still have bits we can't set 	     from lower32?  */
operator|||
operator|(
operator|!
name|need_hh22_p
operator|&&
name|upper32
operator|!=
literal|0
operator|&&
name|upper32
operator|!=
operator|-
literal|1
operator|)
condition|)
name|need_hm10_p
operator|=
literal|1
expr_stmt|;
comment|/* If the lower half is all zero, we build the upper half directly 	 into the dst reg.  */
if|if
condition|(
name|lower32
operator|!=
literal|0
comment|/* Need lower half if number is zero or 0xffffffff00000000.  */
operator|||
operator|(
operator|!
name|need_hh22_p
operator|&&
operator|!
name|need_hm10_p
operator|)
condition|)
block|{
comment|/* No need for sethi if `or' insn can handle constant.  */
if|if
condition|(
name|lower32
operator|<
operator|-
operator|(
literal|1
operator|<<
literal|12
operator|)
operator|||
name|lower32
operator|>=
operator|(
literal|1
operator|<<
literal|12
operator|)
comment|/* Note that we can't use a negative constant in the `or' 		 insn unless the upper 32 bits are all ones.  */
operator|||
operator|(
name|lower32
operator|<
literal|0
operator|&&
name|upper32
operator|!=
operator|-
literal|1
operator|)
operator|||
operator|(
name|lower32
operator|>=
literal|0
operator|&&
name|upper32
operator|==
operator|-
literal|1
operator|)
condition|)
name|need_hi22_p
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|need_hi22_p
operator|&&
name|upper32
operator|==
operator|-
literal|1
condition|)
name|need_xor10_p
operator|=
literal|1
expr_stmt|;
comment|/* Does bottom part (after sethi) have bits?  */
elseif|else
if|if
condition|(
operator|(
name|need_hi22_p
operator|&&
operator|(
name|lower32
operator|&
literal|0x3ff
operator|)
operator|!=
literal|0
operator|)
comment|/* No sethi.  */
operator|||
operator|(
operator|!
name|need_hi22_p
operator|&&
operator|(
name|lower32
operator|&
literal|0x1fff
operator|)
operator|!=
literal|0
operator|)
comment|/* Need `or' if we didn't set anything else.  */
operator|||
operator|(
operator|!
name|need_hi22_p
operator|&&
operator|!
name|need_hh22_p
operator|&&
operator|!
name|need_hm10_p
operator|)
condition|)
name|need_lo10_p
operator|=
literal|1
expr_stmt|;
block|}
else|else
comment|/* Output directly to dst reg if lower 32 bits are all zero.  */
name|upper_dstreg
operator|=
name|dstreg
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|upper_dstreg
operator|&&
name|dstreg
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"setx: illegal temporary register g0"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|need_hh22_p
condition|)
block|{
name|the_insn
operator|.
name|opcode
operator|=
operator|(
name|SETHI_INSN
operator||
name|RD
argument_list|(
name|upper_dstreg
argument_list|)
operator||
operator|(
operator|(
name|upper32
operator|>>
literal|10
operator|)
operator|&
literal|0x3fffff
operator|)
operator|)
expr_stmt|;
name|the_insn
operator|.
name|reloc
operator|=
operator|(
name|the_insn
operator|.
name|exp
operator|.
name|X_op
operator|!=
name|O_constant
condition|?
name|BFD_RELOC_SPARC_HH22
else|:
name|BFD_RELOC_NONE
operator|)
expr_stmt|;
name|output_insn
argument_list|(
name|insn
argument_list|,
operator|&
name|the_insn
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|need_hi22_p
condition|)
block|{
name|the_insn
operator|.
name|opcode
operator|=
operator|(
name|SETHI_INSN
operator||
name|RD
argument_list|(
name|dstreg
argument_list|)
operator||
operator|(
operator|(
operator|(
name|need_xor10_p
condition|?
operator|~
name|lower32
else|:
name|lower32
operator|)
operator|>>
literal|10
operator|)
operator|&
literal|0x3fffff
operator|)
operator|)
expr_stmt|;
name|the_insn
operator|.
name|reloc
operator|=
operator|(
name|the_insn
operator|.
name|exp
operator|.
name|X_op
operator|!=
name|O_constant
condition|?
name|BFD_RELOC_SPARC_LM22
else|:
name|BFD_RELOC_NONE
operator|)
expr_stmt|;
name|output_insn
argument_list|(
name|insn
argument_list|,
operator|&
name|the_insn
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|need_hm10_p
condition|)
block|{
name|the_insn
operator|.
name|opcode
operator|=
operator|(
name|OR_INSN
operator||
operator|(
name|need_hh22_p
condition|?
name|RS1
argument_list|(
name|upper_dstreg
argument_list|)
else|:
literal|0
operator|)
operator||
name|RD
argument_list|(
name|upper_dstreg
argument_list|)
operator||
name|IMMED
operator||
operator|(
name|upper32
operator|&
operator|(
name|need_hh22_p
condition|?
literal|0x3ff
else|:
literal|0x1fff
operator|)
operator|)
operator|)
expr_stmt|;
name|the_insn
operator|.
name|reloc
operator|=
operator|(
name|the_insn
operator|.
name|exp
operator|.
name|X_op
operator|!=
name|O_constant
condition|?
name|BFD_RELOC_SPARC_HM10
else|:
name|BFD_RELOC_NONE
operator|)
expr_stmt|;
name|output_insn
argument_list|(
name|insn
argument_list|,
operator|&
name|the_insn
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|need_lo10_p
condition|)
block|{
comment|/* FIXME: One nice optimization to do here is to OR the low part 	 with the highpart if hi22 isn't needed and the low part is 	 positive.  */
name|the_insn
operator|.
name|opcode
operator|=
operator|(
name|OR_INSN
operator||
operator|(
name|need_hi22_p
condition|?
name|RS1
argument_list|(
name|dstreg
argument_list|)
else|:
literal|0
operator|)
operator||
name|RD
argument_list|(
name|dstreg
argument_list|)
operator||
name|IMMED
operator||
operator|(
name|lower32
operator|&
operator|(
name|need_hi22_p
condition|?
literal|0x3ff
else|:
literal|0x1fff
operator|)
operator|)
operator|)
expr_stmt|;
name|the_insn
operator|.
name|reloc
operator|=
operator|(
name|the_insn
operator|.
name|exp
operator|.
name|X_op
operator|!=
name|O_constant
condition|?
name|BFD_RELOC_LO10
else|:
name|BFD_RELOC_NONE
operator|)
expr_stmt|;
name|output_insn
argument_list|(
name|insn
argument_list|,
operator|&
name|the_insn
argument_list|)
expr_stmt|;
block|}
comment|/* If we needed to build the upper part, shift it into place.  */
if|if
condition|(
name|need_hh22_p
operator|||
name|need_hm10_p
condition|)
block|{
name|the_insn
operator|.
name|opcode
operator|=
operator|(
name|SLLX_INSN
operator||
name|RS1
argument_list|(
name|upper_dstreg
argument_list|)
operator||
name|RD
argument_list|(
name|upper_dstreg
argument_list|)
operator||
name|IMMED
operator||
literal|32
operator|)
expr_stmt|;
name|the_insn
operator|.
name|reloc
operator|=
name|BFD_RELOC_NONE
expr_stmt|;
name|output_insn
argument_list|(
name|insn
argument_list|,
operator|&
name|the_insn
argument_list|)
expr_stmt|;
block|}
comment|/* To get -1 in upper32, we do sethi %hi(~x), r; xor r, -0x400 | x, r.  */
if|if
condition|(
name|need_xor10_p
condition|)
block|{
name|the_insn
operator|.
name|opcode
operator|=
operator|(
name|XOR_INSN
operator||
name|RS1
argument_list|(
name|dstreg
argument_list|)
operator||
name|RD
argument_list|(
name|dstreg
argument_list|)
operator||
name|IMMED
operator||
literal|0x1c00
operator||
operator|(
name|lower32
operator|&
literal|0x3ff
operator|)
operator|)
expr_stmt|;
name|the_insn
operator|.
name|reloc
operator|=
name|BFD_RELOC_NONE
expr_stmt|;
name|output_insn
argument_list|(
name|insn
argument_list|,
operator|&
name|the_insn
argument_list|)
expr_stmt|;
block|}
comment|/* If we needed to build both upper and lower parts, OR them together.  */
elseif|else
if|if
condition|(
operator|(
name|need_hh22_p
operator|||
name|need_hm10_p
operator|)
operator|&&
operator|(
name|need_hi22_p
operator|||
name|need_lo10_p
operator|)
condition|)
block|{
name|the_insn
operator|.
name|opcode
operator|=
operator|(
name|OR_INSN
operator||
name|RS1
argument_list|(
name|dstreg
argument_list|)
operator||
name|RS2
argument_list|(
name|upper_dstreg
argument_list|)
operator||
name|RD
argument_list|(
name|dstreg
argument_list|)
operator|)
expr_stmt|;
name|the_insn
operator|.
name|reloc
operator|=
name|BFD_RELOC_NONE
expr_stmt|;
name|output_insn
argument_list|(
name|insn
argument_list|,
operator|&
name|the_insn
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Main entry point to assemble one instruction.  */
end_comment

begin_function
name|void
name|md_assemble
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
specifier|const
name|struct
name|sparc_opcode
modifier|*
name|insn
decl_stmt|;
name|int
name|special_case
decl_stmt|;
name|know
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|special_case
operator|=
name|sparc_ip
argument_list|(
name|str
argument_list|,
operator|&
name|insn
argument_list|)
expr_stmt|;
comment|/* We warn about attempts to put a floating point branch in a delay slot,      unless the delay slot has been annulled.  */
if|if
condition|(
name|insn
operator|!=
name|NULL
operator|&&
name|last_insn
operator|!=
name|NULL
operator|&&
operator|(
name|insn
operator|->
name|flags
operator|&
name|F_FBR
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|last_insn
operator|->
name|flags
operator|&
name|F_DELAYED
operator|)
operator|!=
literal|0
comment|/* ??? This test isn't completely accurate.  We assume anything with 	 F_{UNBR,CONDBR,FBR} set is annullable.  */
operator|&&
operator|(
operator|(
name|last_insn
operator|->
name|flags
operator|&
operator|(
name|F_UNBR
operator||
name|F_CONDBR
operator||
name|F_FBR
operator|)
operator|)
operator|==
literal|0
operator|||
operator|(
name|last_opcode
operator|&
name|ANNUL
operator|)
operator|==
literal|0
operator|)
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"FP branch in delay slot"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* SPARC before v9 requires a nop instruction between a floating      point instruction and a floating point branch.  We insert one      automatically, with a warning.  */
if|if
condition|(
name|max_architecture
operator|<
name|SPARC_OPCODE_ARCH_V9
operator|&&
name|insn
operator|!=
name|NULL
operator|&&
name|last_insn
operator|!=
name|NULL
operator|&&
operator|(
name|insn
operator|->
name|flags
operator|&
name|F_FBR
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|last_insn
operator|->
name|flags
operator|&
name|F_FLOAT
operator|)
operator|!=
literal|0
condition|)
block|{
name|struct
name|sparc_it
name|nop_insn
decl_stmt|;
name|nop_insn
operator|.
name|opcode
operator|=
name|NOP_INSN
expr_stmt|;
name|nop_insn
operator|.
name|reloc
operator|=
name|BFD_RELOC_NONE
expr_stmt|;
name|output_insn
argument_list|(
name|insn
argument_list|,
operator|&
name|nop_insn
argument_list|)
expr_stmt|;
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"FP branch preceded by FP instruction; NOP inserted"
argument_list|)
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|special_case
condition|)
block|{
case|case
name|SPECIAL_CASE_NONE
case|:
comment|/* Normal insn.  */
name|output_insn
argument_list|(
name|insn
argument_list|,
operator|&
name|the_insn
argument_list|)
expr_stmt|;
break|break;
case|case
name|SPECIAL_CASE_SETSW
case|:
name|synthetize_setsw
argument_list|(
name|insn
argument_list|)
expr_stmt|;
break|break;
case|case
name|SPECIAL_CASE_SET
case|:
name|synthetize_setuw
argument_list|(
name|insn
argument_list|)
expr_stmt|;
break|break;
case|case
name|SPECIAL_CASE_SETX
case|:
name|synthetize_setx
argument_list|(
name|insn
argument_list|)
expr_stmt|;
break|break;
case|case
name|SPECIAL_CASE_FDIV
case|:
block|{
name|int
name|rd
init|=
operator|(
name|the_insn
operator|.
name|opcode
operator|>>
literal|25
operator|)
operator|&
literal|0x1f
decl_stmt|;
name|output_insn
argument_list|(
name|insn
argument_list|,
operator|&
name|the_insn
argument_list|)
expr_stmt|;
comment|/* According to information leaked from Sun, the "fdiv" instructions 	   on early SPARC machines would produce incorrect results sometimes. 	   The workaround is to add an fmovs of the destination register to 	   itself just after the instruction.  This was true on machines 	   with Weitek 1165 float chips, such as the Sun-4/260 and /280.  */
name|assert
argument_list|(
name|the_insn
operator|.
name|reloc
operator|==
name|BFD_RELOC_NONE
argument_list|)
expr_stmt|;
name|the_insn
operator|.
name|opcode
operator|=
name|FMOVS_INSN
operator||
name|rd
operator||
name|RD
argument_list|(
name|rd
argument_list|)
expr_stmt|;
name|output_insn
argument_list|(
name|insn
argument_list|,
operator|&
name|the_insn
argument_list|)
expr_stmt|;
return|return;
block|}
default|default:
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"failed special case insn sanity check"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Subroutine of md_assemble to do the actual parsing.  */
end_comment

begin_function
specifier|static
name|int
name|sparc_ip
parameter_list|(
name|str
parameter_list|,
name|pinsn
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
specifier|const
name|struct
name|sparc_opcode
modifier|*
modifier|*
name|pinsn
decl_stmt|;
block|{
name|char
modifier|*
name|error_message
init|=
literal|""
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
specifier|const
name|char
modifier|*
name|args
decl_stmt|;
name|char
name|c
decl_stmt|;
specifier|const
name|struct
name|sparc_opcode
modifier|*
name|insn
decl_stmt|;
name|char
modifier|*
name|argsStart
decl_stmt|;
name|unsigned
name|long
name|opcode
decl_stmt|;
name|unsigned
name|int
name|mask
init|=
literal|0
decl_stmt|;
name|int
name|match
init|=
literal|0
decl_stmt|;
name|int
name|comma
init|=
literal|0
decl_stmt|;
name|int
name|v9_arg_p
decl_stmt|;
name|int
name|special_case
init|=
name|SPECIAL_CASE_NONE
decl_stmt|;
name|s
operator|=
name|str
expr_stmt|;
if|if
condition|(
name|ISLOWER
argument_list|(
operator|*
name|s
argument_list|)
condition|)
block|{
do|do
operator|++
name|s
expr_stmt|;
do|while
condition|(
name|ISLOWER
argument_list|(
operator|*
name|s
argument_list|)
operator|||
name|ISDIGIT
argument_list|(
operator|*
name|s
argument_list|)
condition|)
do|;
block|}
switch|switch
condition|(
operator|*
name|s
condition|)
block|{
case|case
literal|'\0'
case|:
break|break;
case|case
literal|','
case|:
name|comma
operator|=
literal|1
expr_stmt|;
comment|/* Fall through.  */
case|case
literal|' '
case|:
operator|*
name|s
operator|++
operator|=
literal|'\0'
expr_stmt|;
break|break;
default|default:
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"Unknown opcode: `%s'"
argument_list|)
argument_list|,
name|str
argument_list|)
expr_stmt|;
block|}
name|insn
operator|=
operator|(
expr|struct
name|sparc_opcode
operator|*
operator|)
name|hash_find
argument_list|(
name|op_hash
argument_list|,
name|str
argument_list|)
expr_stmt|;
operator|*
name|pinsn
operator|=
name|insn
expr_stmt|;
if|if
condition|(
name|insn
operator|==
name|NULL
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Unknown opcode: `%s'"
argument_list|)
argument_list|,
name|str
argument_list|)
expr_stmt|;
return|return
name|special_case
return|;
block|}
if|if
condition|(
name|comma
condition|)
block|{
operator|*
operator|--
name|s
operator|=
literal|','
expr_stmt|;
block|}
name|argsStart
operator|=
name|s
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|opcode
operator|=
name|insn
operator|->
name|match
expr_stmt|;
name|memset
argument_list|(
operator|&
name|the_insn
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
name|the_insn
argument_list|)
argument_list|)
expr_stmt|;
name|the_insn
operator|.
name|reloc
operator|=
name|BFD_RELOC_NONE
expr_stmt|;
name|v9_arg_p
operator|=
literal|0
expr_stmt|;
comment|/* Build the opcode, checking as we go to make sure that the          operands match.  */
for|for
control|(
name|args
operator|=
name|insn
operator|->
name|args
init|;
condition|;
operator|++
name|args
control|)
block|{
switch|switch
condition|(
operator|*
name|args
condition|)
block|{
case|case
literal|'K'
case|:
block|{
name|int
name|kmask
init|=
literal|0
decl_stmt|;
comment|/* Parse a series of masks.  */
if|if
condition|(
operator|*
name|s
operator|==
literal|'#'
condition|)
block|{
while|while
condition|(
operator|*
name|s
operator|==
literal|'#'
condition|)
block|{
name|int
name|mask
decl_stmt|;
if|if
condition|(
operator|!
name|parse_keyword_arg
argument_list|(
name|sparc_encode_membar
argument_list|,
operator|&
name|s
argument_list|,
operator|&
name|mask
argument_list|)
condition|)
block|{
name|error_message
operator|=
name|_
argument_list|(
literal|": invalid membar mask name"
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|kmask
operator||=
name|mask
expr_stmt|;
while|while
condition|(
operator|*
name|s
operator|==
literal|' '
condition|)
operator|++
name|s
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'|'
operator|||
operator|*
name|s
operator|==
literal|'+'
condition|)
operator|++
name|s
expr_stmt|;
while|while
condition|(
operator|*
name|s
operator|==
literal|' '
condition|)
operator|++
name|s
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
name|parse_const_expr_arg
argument_list|(
operator|&
name|s
argument_list|,
operator|&
name|kmask
argument_list|)
condition|)
block|{
name|error_message
operator|=
name|_
argument_list|(
literal|": invalid membar mask expression"
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
if|if
condition|(
name|kmask
operator|<
literal|0
operator|||
name|kmask
operator|>
literal|127
condition|)
block|{
name|error_message
operator|=
name|_
argument_list|(
literal|": invalid membar mask number"
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
block|}
name|opcode
operator||=
name|MEMBAR
argument_list|(
name|kmask
argument_list|)
expr_stmt|;
continue|continue;
block|}
case|case
literal|'3'
case|:
block|{
name|int
name|smask
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|parse_const_expr_arg
argument_list|(
operator|&
name|s
argument_list|,
operator|&
name|smask
argument_list|)
condition|)
block|{
name|error_message
operator|=
name|_
argument_list|(
literal|": invalid siam mode expression"
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
if|if
condition|(
name|smask
operator|<
literal|0
operator|||
name|smask
operator|>
literal|7
condition|)
block|{
name|error_message
operator|=
name|_
argument_list|(
literal|": invalid siam mode number"
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|opcode
operator||=
name|smask
expr_stmt|;
continue|continue;
block|}
case|case
literal|'*'
case|:
block|{
name|int
name|fcn
init|=
literal|0
decl_stmt|;
comment|/* Parse a prefetch function.  */
if|if
condition|(
operator|*
name|s
operator|==
literal|'#'
condition|)
block|{
if|if
condition|(
operator|!
name|parse_keyword_arg
argument_list|(
name|sparc_encode_prefetch
argument_list|,
operator|&
name|s
argument_list|,
operator|&
name|fcn
argument_list|)
condition|)
block|{
name|error_message
operator|=
name|_
argument_list|(
literal|": invalid prefetch function name"
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
name|parse_const_expr_arg
argument_list|(
operator|&
name|s
argument_list|,
operator|&
name|fcn
argument_list|)
condition|)
block|{
name|error_message
operator|=
name|_
argument_list|(
literal|": invalid prefetch function expression"
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
if|if
condition|(
name|fcn
operator|<
literal|0
operator|||
name|fcn
operator|>
literal|31
condition|)
block|{
name|error_message
operator|=
name|_
argument_list|(
literal|": invalid prefetch function number"
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
block|}
name|opcode
operator||=
name|RD
argument_list|(
name|fcn
argument_list|)
expr_stmt|;
continue|continue;
block|}
case|case
literal|'!'
case|:
case|case
literal|'?'
case|:
comment|/* Parse a sparc64 privileged register.  */
if|if
condition|(
operator|*
name|s
operator|==
literal|'%'
condition|)
block|{
name|struct
name|priv_reg_entry
modifier|*
name|p
init|=
name|priv_reg_table
decl_stmt|;
name|unsigned
name|int
name|len
init|=
literal|9999999
decl_stmt|;
comment|/* Init to make gcc happy.  */
name|s
operator|+=
literal|1
expr_stmt|;
while|while
condition|(
name|p
operator|->
name|name
index|[
literal|0
index|]
operator|>
name|s
index|[
literal|0
index|]
condition|)
name|p
operator|++
expr_stmt|;
while|while
condition|(
name|p
operator|->
name|name
index|[
literal|0
index|]
operator|==
name|s
index|[
literal|0
index|]
condition|)
block|{
name|len
operator|=
name|strlen
argument_list|(
name|p
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|p
operator|->
name|name
argument_list|,
name|s
argument_list|,
name|len
argument_list|)
operator|==
literal|0
condition|)
break|break;
name|p
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|->
name|name
index|[
literal|0
index|]
operator|!=
name|s
index|[
literal|0
index|]
condition|)
block|{
name|error_message
operator|=
name|_
argument_list|(
literal|": unrecognizable privileged register"
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
if|if
condition|(
operator|*
name|args
operator|==
literal|'?'
condition|)
name|opcode
operator||=
operator|(
name|p
operator|->
name|regnum
operator|<<
literal|14
operator|)
expr_stmt|;
else|else
name|opcode
operator||=
operator|(
name|p
operator|->
name|regnum
operator|<<
literal|25
operator|)
expr_stmt|;
name|s
operator|+=
name|len
expr_stmt|;
continue|continue;
block|}
else|else
block|{
name|error_message
operator|=
name|_
argument_list|(
literal|": unrecognizable privileged register"
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
case|case
literal|'_'
case|:
case|case
literal|'/'
case|:
comment|/* Parse a v9a/v9b ancillary state register.  */
if|if
condition|(
operator|*
name|s
operator|==
literal|'%'
condition|)
block|{
name|struct
name|priv_reg_entry
modifier|*
name|p
init|=
name|v9a_asr_table
decl_stmt|;
name|unsigned
name|int
name|len
init|=
literal|9999999
decl_stmt|;
comment|/* Init to make gcc happy.  */
name|s
operator|+=
literal|1
expr_stmt|;
while|while
condition|(
name|p
operator|->
name|name
index|[
literal|0
index|]
operator|>
name|s
index|[
literal|0
index|]
condition|)
name|p
operator|++
expr_stmt|;
while|while
condition|(
name|p
operator|->
name|name
index|[
literal|0
index|]
operator|==
name|s
index|[
literal|0
index|]
condition|)
block|{
name|len
operator|=
name|strlen
argument_list|(
name|p
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|p
operator|->
name|name
argument_list|,
name|s
argument_list|,
name|len
argument_list|)
operator|==
literal|0
condition|)
break|break;
name|p
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|->
name|name
index|[
literal|0
index|]
operator|!=
name|s
index|[
literal|0
index|]
condition|)
block|{
name|error_message
operator|=
name|_
argument_list|(
literal|": unrecognizable v9a or v9b ancillary state register"
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
if|if
condition|(
operator|*
name|args
operator|==
literal|'/'
operator|&&
operator|(
name|p
operator|->
name|regnum
operator|==
literal|20
operator|||
name|p
operator|->
name|regnum
operator|==
literal|21
operator|)
condition|)
block|{
name|error_message
operator|=
name|_
argument_list|(
literal|": rd on write only ancillary state register"
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
if|if
condition|(
name|p
operator|->
name|regnum
operator|>=
literal|24
operator|&&
operator|(
name|insn
operator|->
name|architecture
operator|&
name|SPARC_OPCODE_ARCH_MASK
argument_list|(
name|SPARC_OPCODE_ARCH_V9A
argument_list|)
operator|)
condition|)
block|{
comment|/* %sys_tick and %sys_tick_cmpr are v9bnotv9a */
name|error_message
operator|=
name|_
argument_list|(
literal|": unrecognizable v9a ancillary state register"
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
if|if
condition|(
operator|*
name|args
operator|==
literal|'/'
condition|)
name|opcode
operator||=
operator|(
name|p
operator|->
name|regnum
operator|<<
literal|14
operator|)
expr_stmt|;
else|else
name|opcode
operator||=
operator|(
name|p
operator|->
name|regnum
operator|<<
literal|25
operator|)
expr_stmt|;
name|s
operator|+=
name|len
expr_stmt|;
continue|continue;
block|}
else|else
block|{
name|error_message
operator|=
name|_
argument_list|(
literal|": unrecognizable v9a or v9b ancillary state register"
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
case|case
literal|'M'
case|:
case|case
literal|'m'
case|:
if|if
condition|(
name|strncmp
argument_list|(
name|s
argument_list|,
literal|"%asr"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
block|{
name|s
operator|+=
literal|4
expr_stmt|;
if|if
condition|(
name|ISDIGIT
argument_list|(
operator|*
name|s
argument_list|)
condition|)
block|{
name|long
name|num
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|ISDIGIT
argument_list|(
operator|*
name|s
argument_list|)
condition|)
block|{
name|num
operator|=
name|num
operator|*
literal|10
operator|+
operator|*
name|s
operator|-
literal|'0'
expr_stmt|;
operator|++
name|s
expr_stmt|;
block|}
if|if
condition|(
name|current_architecture
operator|>=
name|SPARC_OPCODE_ARCH_V9
condition|)
block|{
if|if
condition|(
name|num
operator|<
literal|16
operator|||
literal|31
operator|<
name|num
condition|)
block|{
name|error_message
operator|=
name|_
argument_list|(
literal|": asr number must be between 16 and 31"
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|num
operator|<
literal|0
operator|||
literal|31
operator|<
name|num
condition|)
block|{
name|error_message
operator|=
name|_
argument_list|(
literal|": asr number must be between 0 and 31"
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
block|}
name|opcode
operator||=
operator|(
operator|*
name|args
operator|==
literal|'M'
condition|?
name|RS1
argument_list|(
name|num
argument_list|)
else|:
name|RD
argument_list|(
name|num
argument_list|)
operator|)
expr_stmt|;
continue|continue;
block|}
else|else
block|{
name|error_message
operator|=
name|_
argument_list|(
literal|": expecting %asrN"
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
block|}
comment|/* if %asr  */
break|break;
case|case
literal|'I'
case|:
name|the_insn
operator|.
name|reloc
operator|=
name|BFD_RELOC_SPARC_11
expr_stmt|;
goto|goto
name|immediate
goto|;
case|case
literal|'j'
case|:
name|the_insn
operator|.
name|reloc
operator|=
name|BFD_RELOC_SPARC_10
expr_stmt|;
goto|goto
name|immediate
goto|;
case|case
literal|'X'
case|:
comment|/* V8 systems don't understand BFD_RELOC_SPARC_5.  */
if|if
condition|(
name|SPARC_OPCODE_ARCH_V9_P
argument_list|(
name|max_architecture
argument_list|)
condition|)
name|the_insn
operator|.
name|reloc
operator|=
name|BFD_RELOC_SPARC_5
expr_stmt|;
else|else
name|the_insn
operator|.
name|reloc
operator|=
name|BFD_RELOC_SPARC13
expr_stmt|;
comment|/* These fields are unsigned, but for upward compatibility, 		 allow negative values as well.  */
goto|goto
name|immediate
goto|;
case|case
literal|'Y'
case|:
comment|/* V8 systems don't understand BFD_RELOC_SPARC_6.  */
if|if
condition|(
name|SPARC_OPCODE_ARCH_V9_P
argument_list|(
name|max_architecture
argument_list|)
condition|)
name|the_insn
operator|.
name|reloc
operator|=
name|BFD_RELOC_SPARC_6
expr_stmt|;
else|else
name|the_insn
operator|.
name|reloc
operator|=
name|BFD_RELOC_SPARC13
expr_stmt|;
comment|/* These fields are unsigned, but for upward compatibility, 		 allow negative values as well.  */
goto|goto
name|immediate
goto|;
case|case
literal|'k'
case|:
name|the_insn
operator|.
name|reloc
operator|=
comment|/* RELOC_WDISP2_14 */
name|BFD_RELOC_SPARC_WDISP16
expr_stmt|;
name|the_insn
operator|.
name|pcrel
operator|=
literal|1
expr_stmt|;
goto|goto
name|immediate
goto|;
case|case
literal|'G'
case|:
name|the_insn
operator|.
name|reloc
operator|=
name|BFD_RELOC_SPARC_WDISP19
expr_stmt|;
name|the_insn
operator|.
name|pcrel
operator|=
literal|1
expr_stmt|;
goto|goto
name|immediate
goto|;
case|case
literal|'N'
case|:
if|if
condition|(
operator|*
name|s
operator|==
literal|'p'
operator|&&
name|s
index|[
literal|1
index|]
operator|==
literal|'n'
condition|)
block|{
name|s
operator|+=
literal|2
expr_stmt|;
continue|continue;
block|}
break|break;
case|case
literal|'T'
case|:
if|if
condition|(
operator|*
name|s
operator|==
literal|'p'
operator|&&
name|s
index|[
literal|1
index|]
operator|==
literal|'t'
condition|)
block|{
name|s
operator|+=
literal|2
expr_stmt|;
continue|continue;
block|}
break|break;
case|case
literal|'z'
case|:
if|if
condition|(
operator|*
name|s
operator|==
literal|' '
condition|)
block|{
operator|++
name|s
expr_stmt|;
block|}
if|if
condition|(
name|strncmp
argument_list|(
name|s
argument_list|,
literal|"%icc"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
block|{
name|s
operator|+=
literal|4
expr_stmt|;
continue|continue;
block|}
break|break;
case|case
literal|'Z'
case|:
if|if
condition|(
operator|*
name|s
operator|==
literal|' '
condition|)
block|{
operator|++
name|s
expr_stmt|;
block|}
if|if
condition|(
name|strncmp
argument_list|(
name|s
argument_list|,
literal|"%xcc"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
block|{
name|s
operator|+=
literal|4
expr_stmt|;
continue|continue;
block|}
break|break;
case|case
literal|'6'
case|:
if|if
condition|(
operator|*
name|s
operator|==
literal|' '
condition|)
block|{
operator|++
name|s
expr_stmt|;
block|}
if|if
condition|(
name|strncmp
argument_list|(
name|s
argument_list|,
literal|"%fcc0"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
block|{
name|s
operator|+=
literal|5
expr_stmt|;
continue|continue;
block|}
break|break;
case|case
literal|'7'
case|:
if|if
condition|(
operator|*
name|s
operator|==
literal|' '
condition|)
block|{
operator|++
name|s
expr_stmt|;
block|}
if|if
condition|(
name|strncmp
argument_list|(
name|s
argument_list|,
literal|"%fcc1"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
block|{
name|s
operator|+=
literal|5
expr_stmt|;
continue|continue;
block|}
break|break;
case|case
literal|'8'
case|:
if|if
condition|(
operator|*
name|s
operator|==
literal|' '
condition|)
block|{
operator|++
name|s
expr_stmt|;
block|}
if|if
condition|(
name|strncmp
argument_list|(
name|s
argument_list|,
literal|"%fcc2"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
block|{
name|s
operator|+=
literal|5
expr_stmt|;
continue|continue;
block|}
break|break;
case|case
literal|'9'
case|:
if|if
condition|(
operator|*
name|s
operator|==
literal|' '
condition|)
block|{
operator|++
name|s
expr_stmt|;
block|}
if|if
condition|(
name|strncmp
argument_list|(
name|s
argument_list|,
literal|"%fcc3"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
block|{
name|s
operator|+=
literal|5
expr_stmt|;
continue|continue;
block|}
break|break;
case|case
literal|'P'
case|:
if|if
condition|(
name|strncmp
argument_list|(
name|s
argument_list|,
literal|"%pc"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
block|{
name|s
operator|+=
literal|3
expr_stmt|;
continue|continue;
block|}
break|break;
case|case
literal|'W'
case|:
if|if
condition|(
name|strncmp
argument_list|(
name|s
argument_list|,
literal|"%tick"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
block|{
name|s
operator|+=
literal|5
expr_stmt|;
continue|continue;
block|}
break|break;
case|case
literal|'\0'
case|:
comment|/* End of args.  */
if|if
condition|(
operator|*
name|s
operator|==
literal|'\0'
condition|)
block|{
name|match
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
literal|'+'
case|:
if|if
condition|(
operator|*
name|s
operator|==
literal|'+'
condition|)
block|{
operator|++
name|s
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|*
name|s
operator|==
literal|'-'
condition|)
block|{
continue|continue;
block|}
break|break;
case|case
literal|'['
case|:
comment|/* These must match exactly.  */
case|case
literal|']'
case|:
case|case
literal|','
case|:
case|case
literal|' '
case|:
if|if
condition|(
operator|*
name|s
operator|++
operator|==
operator|*
name|args
condition|)
continue|continue;
break|break;
case|case
literal|'#'
case|:
comment|/* Must be at least one digit.  */
if|if
condition|(
name|ISDIGIT
argument_list|(
operator|*
name|s
operator|++
argument_list|)
condition|)
block|{
while|while
condition|(
name|ISDIGIT
argument_list|(
operator|*
name|s
argument_list|)
condition|)
block|{
operator|++
name|s
expr_stmt|;
block|}
continue|continue;
block|}
break|break;
case|case
literal|'C'
case|:
comment|/* Coprocessor state register.  */
if|if
condition|(
name|strncmp
argument_list|(
name|s
argument_list|,
literal|"%csr"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
block|{
name|s
operator|+=
literal|4
expr_stmt|;
continue|continue;
block|}
break|break;
case|case
literal|'b'
case|:
comment|/* Next operand is a coprocessor register.  */
case|case
literal|'c'
case|:
case|case
literal|'D'
case|:
if|if
condition|(
operator|*
name|s
operator|++
operator|==
literal|'%'
operator|&&
operator|*
name|s
operator|++
operator|==
literal|'c'
operator|&&
name|ISDIGIT
argument_list|(
operator|*
name|s
argument_list|)
condition|)
block|{
name|mask
operator|=
operator|*
name|s
operator|++
expr_stmt|;
if|if
condition|(
name|ISDIGIT
argument_list|(
operator|*
name|s
argument_list|)
condition|)
block|{
name|mask
operator|=
literal|10
operator|*
operator|(
name|mask
operator|-
literal|'0'
operator|)
operator|+
operator|(
operator|*
name|s
operator|++
operator|-
literal|'0'
operator|)
expr_stmt|;
if|if
condition|(
name|mask
operator|>=
literal|32
condition|)
block|{
break|break;
block|}
block|}
else|else
block|{
name|mask
operator|-=
literal|'0'
expr_stmt|;
block|}
switch|switch
condition|(
operator|*
name|args
condition|)
block|{
case|case
literal|'b'
case|:
name|opcode
operator||=
name|mask
operator|<<
literal|14
expr_stmt|;
continue|continue;
case|case
literal|'c'
case|:
name|opcode
operator||=
name|mask
expr_stmt|;
continue|continue;
case|case
literal|'D'
case|:
name|opcode
operator||=
name|mask
operator|<<
literal|25
expr_stmt|;
continue|continue;
block|}
block|}
break|break;
case|case
literal|'r'
case|:
comment|/* next operand must be a register */
case|case
literal|'O'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'d'
case|:
if|if
condition|(
operator|*
name|s
operator|++
operator|==
literal|'%'
condition|)
block|{
switch|switch
condition|(
name|c
operator|=
operator|*
name|s
operator|++
condition|)
block|{
case|case
literal|'f'
case|:
comment|/* frame pointer */
if|if
condition|(
operator|*
name|s
operator|++
operator|==
literal|'p'
condition|)
block|{
name|mask
operator|=
literal|0x1e
expr_stmt|;
break|break;
block|}
goto|goto
name|error
goto|;
case|case
literal|'g'
case|:
comment|/* global register */
name|c
operator|=
operator|*
name|s
operator|++
expr_stmt|;
if|if
condition|(
name|isoctal
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|mask
operator|=
name|c
operator|-
literal|'0'
expr_stmt|;
break|break;
block|}
goto|goto
name|error
goto|;
case|case
literal|'i'
case|:
comment|/* in register */
name|c
operator|=
operator|*
name|s
operator|++
expr_stmt|;
if|if
condition|(
name|isoctal
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|mask
operator|=
name|c
operator|-
literal|'0'
operator|+
literal|24
expr_stmt|;
break|break;
block|}
goto|goto
name|error
goto|;
case|case
literal|'l'
case|:
comment|/* local register */
name|c
operator|=
operator|*
name|s
operator|++
expr_stmt|;
if|if
condition|(
name|isoctal
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|mask
operator|=
operator|(
name|c
operator|-
literal|'0'
operator|+
literal|16
operator|)
expr_stmt|;
break|break;
block|}
goto|goto
name|error
goto|;
case|case
literal|'o'
case|:
comment|/* out register */
name|c
operator|=
operator|*
name|s
operator|++
expr_stmt|;
if|if
condition|(
name|isoctal
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|mask
operator|=
operator|(
name|c
operator|-
literal|'0'
operator|+
literal|8
operator|)
expr_stmt|;
break|break;
block|}
goto|goto
name|error
goto|;
case|case
literal|'s'
case|:
comment|/* stack pointer */
if|if
condition|(
operator|*
name|s
operator|++
operator|==
literal|'p'
condition|)
block|{
name|mask
operator|=
literal|0xe
expr_stmt|;
break|break;
block|}
goto|goto
name|error
goto|;
case|case
literal|'r'
case|:
comment|/* any register */
if|if
condition|(
operator|!
name|ISDIGIT
argument_list|(
operator|(
name|c
operator|=
operator|*
name|s
operator|++
operator|)
argument_list|)
condition|)
block|{
goto|goto
name|error
goto|;
block|}
comment|/* FALLTHROUGH */
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
if|if
condition|(
name|ISDIGIT
argument_list|(
operator|*
name|s
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|c
operator|=
literal|10
operator|*
operator|(
name|c
operator|-
literal|'0'
operator|)
operator|+
operator|(
operator|*
name|s
operator|++
operator|-
literal|'0'
operator|)
operator|)
operator|>=
literal|32
condition|)
block|{
goto|goto
name|error
goto|;
block|}
block|}
else|else
block|{
name|c
operator|-=
literal|'0'
expr_stmt|;
block|}
name|mask
operator|=
name|c
expr_stmt|;
break|break;
default|default:
goto|goto
name|error
goto|;
block|}
if|if
condition|(
operator|(
name|mask
operator|&
operator|~
literal|1
operator|)
operator|==
literal|2
operator|&&
name|sparc_arch_size
operator|==
literal|64
operator|&&
name|no_undeclared_regs
operator|&&
operator|!
name|globals
index|[
name|mask
index|]
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"detected global register use not covered by .register pseudo-op"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Got the register, now figure out where 		     it goes in the opcode.  */
switch|switch
condition|(
operator|*
name|args
condition|)
block|{
case|case
literal|'1'
case|:
name|opcode
operator||=
name|mask
operator|<<
literal|14
expr_stmt|;
continue|continue;
case|case
literal|'2'
case|:
name|opcode
operator||=
name|mask
expr_stmt|;
continue|continue;
case|case
literal|'d'
case|:
name|opcode
operator||=
name|mask
operator|<<
literal|25
expr_stmt|;
continue|continue;
case|case
literal|'r'
case|:
name|opcode
operator||=
operator|(
name|mask
operator|<<
literal|25
operator|)
operator||
operator|(
name|mask
operator|<<
literal|14
operator|)
expr_stmt|;
continue|continue;
case|case
literal|'O'
case|:
name|opcode
operator||=
operator|(
name|mask
operator|<<
literal|25
operator|)
operator||
operator|(
name|mask
operator|<<
literal|0
operator|)
expr_stmt|;
continue|continue;
block|}
block|}
break|break;
case|case
literal|'e'
case|:
comment|/* next operand is a floating point register */
case|case
literal|'v'
case|:
case|case
literal|'V'
case|:
case|case
literal|'f'
case|:
case|case
literal|'B'
case|:
case|case
literal|'R'
case|:
case|case
literal|'g'
case|:
case|case
literal|'H'
case|:
case|case
literal|'J'
case|:
block|{
name|char
name|format
decl_stmt|;
if|if
condition|(
operator|*
name|s
operator|++
operator|==
literal|'%'
operator|&&
operator|(
operator|(
name|format
operator|=
operator|*
name|s
operator|)
operator|==
literal|'f'
operator|)
operator|&&
name|ISDIGIT
argument_list|(
operator|*
operator|++
name|s
argument_list|)
condition|)
block|{
for|for
control|(
name|mask
operator|=
literal|0
init|;
name|ISDIGIT
argument_list|(
operator|*
name|s
argument_list|)
condition|;
operator|++
name|s
control|)
block|{
name|mask
operator|=
literal|10
operator|*
name|mask
operator|+
operator|(
operator|*
name|s
operator|-
literal|'0'
operator|)
expr_stmt|;
block|}
comment|/* read the number */
if|if
condition|(
operator|(
operator|*
name|args
operator|==
literal|'v'
operator|||
operator|*
name|args
operator|==
literal|'B'
operator|||
operator|*
name|args
operator|==
literal|'H'
operator|)
operator|&&
operator|(
name|mask
operator|&
literal|1
operator|)
condition|)
block|{
break|break;
block|}
comment|/* register must be even numbered */
if|if
condition|(
operator|(
operator|*
name|args
operator|==
literal|'V'
operator|||
operator|*
name|args
operator|==
literal|'R'
operator|||
operator|*
name|args
operator|==
literal|'J'
operator|)
operator|&&
operator|(
name|mask
operator|&
literal|3
operator|)
condition|)
block|{
break|break;
block|}
comment|/* register must be multiple of 4 */
if|if
condition|(
name|mask
operator|>=
literal|64
condition|)
block|{
if|if
condition|(
name|SPARC_OPCODE_ARCH_V9_P
argument_list|(
name|max_architecture
argument_list|)
condition|)
name|error_message
operator|=
name|_
argument_list|(
literal|": There are only 64 f registers; [0-63]"
argument_list|)
expr_stmt|;
else|else
name|error_message
operator|=
name|_
argument_list|(
literal|": There are only 32 f registers; [0-31]"
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
comment|/* on error */
elseif|else
if|if
condition|(
name|mask
operator|>=
literal|32
condition|)
block|{
if|if
condition|(
name|SPARC_OPCODE_ARCH_V9_P
argument_list|(
name|max_architecture
argument_list|)
condition|)
block|{
name|v9_arg_p
operator|=
literal|1
expr_stmt|;
name|mask
operator|-=
literal|31
expr_stmt|;
comment|/* wrap high bit */
block|}
else|else
block|{
name|error_message
operator|=
name|_
argument_list|(
literal|": There are only 32 f registers; [0-31]"
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
block|}
block|}
else|else
block|{
break|break;
block|}
comment|/* if not an 'f' register.  */
switch|switch
condition|(
operator|*
name|args
condition|)
block|{
case|case
literal|'v'
case|:
case|case
literal|'V'
case|:
case|case
literal|'e'
case|:
name|opcode
operator||=
name|RS1
argument_list|(
name|mask
argument_list|)
expr_stmt|;
continue|continue;
case|case
literal|'f'
case|:
case|case
literal|'B'
case|:
case|case
literal|'R'
case|:
name|opcode
operator||=
name|RS2
argument_list|(
name|mask
argument_list|)
expr_stmt|;
continue|continue;
case|case
literal|'g'
case|:
case|case
literal|'H'
case|:
case|case
literal|'J'
case|:
name|opcode
operator||=
name|RD
argument_list|(
name|mask
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Pack it in.  */
name|know
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* float arg  */
case|case
literal|'F'
case|:
if|if
condition|(
name|strncmp
argument_list|(
name|s
argument_list|,
literal|"%fsr"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
block|{
name|s
operator|+=
literal|4
expr_stmt|;
continue|continue;
block|}
break|break;
case|case
literal|'0'
case|:
comment|/* 64 bit immediate (set, setsw, setx insn)  */
name|the_insn
operator|.
name|reloc
operator|=
name|BFD_RELOC_NONE
expr_stmt|;
comment|/* reloc handled elsewhere  */
goto|goto
name|immediate
goto|;
case|case
literal|'l'
case|:
comment|/* 22 bit PC relative immediate  */
name|the_insn
operator|.
name|reloc
operator|=
name|BFD_RELOC_SPARC_WDISP22
expr_stmt|;
name|the_insn
operator|.
name|pcrel
operator|=
literal|1
expr_stmt|;
goto|goto
name|immediate
goto|;
case|case
literal|'L'
case|:
comment|/* 30 bit immediate  */
name|the_insn
operator|.
name|reloc
operator|=
name|BFD_RELOC_32_PCREL_S2
expr_stmt|;
name|the_insn
operator|.
name|pcrel
operator|=
literal|1
expr_stmt|;
goto|goto
name|immediate
goto|;
case|case
literal|'h'
case|:
case|case
literal|'n'
case|:
comment|/* 22 bit immediate  */
name|the_insn
operator|.
name|reloc
operator|=
name|BFD_RELOC_SPARC22
expr_stmt|;
goto|goto
name|immediate
goto|;
case|case
literal|'i'
case|:
comment|/* 13 bit immediate  */
name|the_insn
operator|.
name|reloc
operator|=
name|BFD_RELOC_SPARC13
expr_stmt|;
comment|/* fallthrough */
name|immediate
label|:
if|if
condition|(
operator|*
name|s
operator|==
literal|' '
condition|)
name|s
operator|++
expr_stmt|;
block|{
name|char
modifier|*
name|s1
decl_stmt|;
name|char
modifier|*
name|op_arg
init|=
name|NULL
decl_stmt|;
name|expressionS
name|op_exp
decl_stmt|;
name|bfd_reloc_code_real_type
name|old_reloc
init|=
name|the_insn
operator|.
name|reloc
decl_stmt|;
comment|/* Check for %hi, etc.  */
if|if
condition|(
operator|*
name|s
operator|==
literal|'%'
condition|)
block|{
specifier|static
specifier|const
struct|struct
name|ops
block|{
comment|/* The name as it appears in assembler.  */
name|char
modifier|*
name|name
decl_stmt|;
comment|/* strlen (name), precomputed for speed */
name|int
name|len
decl_stmt|;
comment|/* The reloc this pseudo-op translates to.  */
name|int
name|reloc
decl_stmt|;
comment|/* Non-zero if for v9 only.  */
name|int
name|v9_p
decl_stmt|;
comment|/* Non-zero if can be used in pc-relative contexts.  */
name|int
name|pcrel_p
decl_stmt|;
comment|/*FIXME:wip*/
block|}
name|ops
index|[]
init|=
block|{
comment|/* hix/lox must appear before hi/lo so %hix won't be 			 mistaken for %hi.  */
block|{
literal|"hix"
block|,
literal|3
block|,
name|BFD_RELOC_SPARC_HIX22
block|,
literal|1
block|,
literal|0
block|}
block|,
block|{
literal|"lox"
block|,
literal|3
block|,
name|BFD_RELOC_SPARC_LOX10
block|,
literal|1
block|,
literal|0
block|}
block|,
block|{
literal|"hi"
block|,
literal|2
block|,
name|BFD_RELOC_HI22
block|,
literal|0
block|,
literal|1
block|}
block|,
block|{
literal|"lo"
block|,
literal|2
block|,
name|BFD_RELOC_LO10
block|,
literal|0
block|,
literal|1
block|}
block|,
block|{
literal|"hh"
block|,
literal|2
block|,
name|BFD_RELOC_SPARC_HH22
block|,
literal|1
block|,
literal|1
block|}
block|,
block|{
literal|"hm"
block|,
literal|2
block|,
name|BFD_RELOC_SPARC_HM10
block|,
literal|1
block|,
literal|1
block|}
block|,
block|{
literal|"lm"
block|,
literal|2
block|,
name|BFD_RELOC_SPARC_LM22
block|,
literal|1
block|,
literal|1
block|}
block|,
block|{
literal|"h44"
block|,
literal|3
block|,
name|BFD_RELOC_SPARC_H44
block|,
literal|1
block|,
literal|0
block|}
block|,
block|{
literal|"m44"
block|,
literal|3
block|,
name|BFD_RELOC_SPARC_M44
block|,
literal|1
block|,
literal|0
block|}
block|,
block|{
literal|"l44"
block|,
literal|3
block|,
name|BFD_RELOC_SPARC_L44
block|,
literal|1
block|,
literal|0
block|}
block|,
block|{
literal|"uhi"
block|,
literal|3
block|,
name|BFD_RELOC_SPARC_HH22
block|,
literal|1
block|,
literal|0
block|}
block|,
block|{
literal|"ulo"
block|,
literal|3
block|,
name|BFD_RELOC_SPARC_HM10
block|,
literal|1
block|,
literal|0
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
struct|;
specifier|const
name|struct
name|ops
modifier|*
name|o
decl_stmt|;
for|for
control|(
name|o
operator|=
name|ops
init|;
name|o
operator|->
name|name
condition|;
name|o
operator|++
control|)
if|if
condition|(
name|strncmp
argument_list|(
name|s
operator|+
literal|1
argument_list|,
name|o
operator|->
name|name
argument_list|,
name|o
operator|->
name|len
argument_list|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|o
operator|->
name|name
operator|==
name|NULL
condition|)
break|break;
if|if
condition|(
name|s
index|[
name|o
operator|->
name|len
operator|+
literal|1
index|]
operator|!=
literal|'('
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Illegal operands: %%%s requires arguments in ()"
argument_list|)
argument_list|,
name|o
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
name|special_case
return|;
block|}
name|op_arg
operator|=
name|o
operator|->
name|name
expr_stmt|;
name|the_insn
operator|.
name|reloc
operator|=
name|o
operator|->
name|reloc
expr_stmt|;
name|s
operator|+=
name|o
operator|->
name|len
operator|+
literal|2
expr_stmt|;
name|v9_arg_p
operator|=
name|o
operator|->
name|v9_p
expr_stmt|;
block|}
comment|/* Note that if the get_expression() fails, we will still 		   have created U entries in the symbol table for the 		   'symbols' in the input string.  Try not to create U 		   symbols for registers, etc.  */
comment|/* This stuff checks to see if the expression ends in 		   +%reg.  If it does, it removes the register from 		   the expression, and re-sets 's' to point to the 		   right place.  */
if|if
condition|(
name|op_arg
condition|)
block|{
name|int
name|npar
init|=
literal|0
decl_stmt|;
for|for
control|(
name|s1
operator|=
name|s
init|;
operator|*
name|s1
operator|&&
operator|*
name|s1
operator|!=
literal|','
operator|&&
operator|*
name|s1
operator|!=
literal|']'
condition|;
name|s1
operator|++
control|)
if|if
condition|(
operator|*
name|s1
operator|==
literal|'('
condition|)
name|npar
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|s1
operator|==
literal|')'
condition|)
block|{
if|if
condition|(
operator|!
name|npar
condition|)
break|break;
name|npar
operator|--
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|s1
operator|!=
literal|')'
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Illegal operands: %%%s requires arguments in ()"
argument_list|)
argument_list|,
name|op_arg
argument_list|)
expr_stmt|;
return|return
name|special_case
return|;
block|}
operator|*
name|s1
operator|=
literal|'\0'
expr_stmt|;
operator|(
name|void
operator|)
name|get_expression
argument_list|(
name|s
argument_list|)
expr_stmt|;
operator|*
name|s1
operator|=
literal|')'
expr_stmt|;
name|s
operator|=
name|s1
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|','
operator|||
operator|*
name|s
operator|==
literal|']'
operator|||
operator|!
operator|*
name|s
condition|)
continue|continue;
if|if
condition|(
operator|*
name|s
operator|!=
literal|'+'
operator|&&
operator|*
name|s
operator|!=
literal|'-'
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Illegal operands: Can't do arithmetics other than + and - involving %%%s()"
argument_list|)
argument_list|,
name|op_arg
argument_list|)
expr_stmt|;
return|return
name|special_case
return|;
block|}
operator|*
name|s1
operator|=
literal|'0'
expr_stmt|;
name|s
operator|=
name|s1
expr_stmt|;
name|op_exp
operator|=
name|the_insn
operator|.
name|exp
expr_stmt|;
name|memset
argument_list|(
operator|&
name|the_insn
operator|.
name|exp
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|the_insn
operator|.
name|exp
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|s1
operator|=
name|s
init|;
operator|*
name|s1
operator|&&
operator|*
name|s1
operator|!=
literal|','
operator|&&
operator|*
name|s1
operator|!=
literal|']'
condition|;
name|s1
operator|++
control|)
empty_stmt|;
if|if
condition|(
name|s1
operator|!=
name|s
operator|&&
name|ISDIGIT
argument_list|(
name|s1
index|[
operator|-
literal|1
index|]
argument_list|)
condition|)
block|{
if|if
condition|(
name|s1
index|[
operator|-
literal|2
index|]
operator|==
literal|'%'
operator|&&
name|s1
index|[
operator|-
literal|3
index|]
operator|==
literal|'+'
condition|)
name|s1
operator|-=
literal|3
expr_stmt|;
elseif|else
if|if
condition|(
name|strchr
argument_list|(
literal|"goli0123456789"
argument_list|,
name|s1
index|[
operator|-
literal|2
index|]
argument_list|)
operator|&&
name|s1
index|[
operator|-
literal|3
index|]
operator|==
literal|'%'
operator|&&
name|s1
index|[
operator|-
literal|4
index|]
operator|==
literal|'+'
condition|)
name|s1
operator|-=
literal|4
expr_stmt|;
else|else
name|s1
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|s1
condition|)
block|{
operator|*
name|s1
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|op_arg
operator|&&
name|s1
operator|==
name|s
operator|+
literal|1
condition|)
name|the_insn
operator|.
name|exp
operator|.
name|X_op
operator|=
name|O_absent
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|get_expression
argument_list|(
name|s
argument_list|)
expr_stmt|;
operator|*
name|s1
operator|=
literal|'+'
expr_stmt|;
if|if
condition|(
name|op_arg
condition|)
operator|*
name|s
operator|=
literal|')'
expr_stmt|;
name|s
operator|=
name|s1
expr_stmt|;
block|}
block|}
else|else
name|s1
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|s1
condition|)
block|{
operator|(
name|void
operator|)
name|get_expression
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|op_arg
condition|)
operator|*
name|s
operator|=
literal|')'
expr_stmt|;
name|s
operator|=
name|expr_end
expr_stmt|;
block|}
if|if
condition|(
name|op_arg
condition|)
block|{
name|the_insn
operator|.
name|exp2
operator|=
name|the_insn
operator|.
name|exp
expr_stmt|;
name|the_insn
operator|.
name|exp
operator|=
name|op_exp
expr_stmt|;
if|if
condition|(
name|the_insn
operator|.
name|exp2
operator|.
name|X_op
operator|==
name|O_absent
condition|)
name|the_insn
operator|.
name|exp2
operator|.
name|X_op
operator|=
name|O_illegal
expr_stmt|;
elseif|else
if|if
condition|(
name|the_insn
operator|.
name|exp
operator|.
name|X_op
operator|==
name|O_absent
condition|)
block|{
name|the_insn
operator|.
name|exp
operator|=
name|the_insn
operator|.
name|exp2
expr_stmt|;
name|the_insn
operator|.
name|exp2
operator|.
name|X_op
operator|=
name|O_illegal
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|the_insn
operator|.
name|exp
operator|.
name|X_op
operator|==
name|O_constant
condition|)
block|{
name|valueT
name|val
init|=
name|the_insn
operator|.
name|exp
operator|.
name|X_add_number
decl_stmt|;
switch|switch
condition|(
name|the_insn
operator|.
name|reloc
condition|)
block|{
default|default:
break|break;
case|case
name|BFD_RELOC_SPARC_HH22
case|:
name|val
operator|=
name|BSR
argument_list|(
name|val
argument_list|,
literal|32
argument_list|)
expr_stmt|;
comment|/* Fall through.  */
case|case
name|BFD_RELOC_SPARC_LM22
case|:
case|case
name|BFD_RELOC_HI22
case|:
name|val
operator|=
operator|(
name|val
operator|>>
literal|10
operator|)
operator|&
literal|0x3fffff
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_SPARC_HM10
case|:
name|val
operator|=
name|BSR
argument_list|(
name|val
argument_list|,
literal|32
argument_list|)
expr_stmt|;
comment|/* Fall through.  */
case|case
name|BFD_RELOC_LO10
case|:
name|val
operator|&=
literal|0x3ff
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_SPARC_H44
case|:
name|val
operator|>>=
literal|22
expr_stmt|;
name|val
operator|&=
literal|0x3fffff
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_SPARC_M44
case|:
name|val
operator|>>=
literal|12
expr_stmt|;
name|val
operator|&=
literal|0x3ff
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_SPARC_L44
case|:
name|val
operator|&=
literal|0xfff
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_SPARC_HIX22
case|:
name|val
operator|=
operator|~
name|val
expr_stmt|;
name|val
operator|=
operator|(
name|val
operator|>>
literal|10
operator|)
operator|&
literal|0x3fffff
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_SPARC_LOX10
case|:
name|val
operator|=
operator|(
name|val
operator|&
literal|0x3ff
operator|)
operator||
literal|0x1c00
expr_stmt|;
break|break;
block|}
name|the_insn
operator|.
name|exp
operator|=
name|the_insn
operator|.
name|exp2
expr_stmt|;
name|the_insn
operator|.
name|exp
operator|.
name|X_add_number
operator|+=
name|val
expr_stmt|;
name|the_insn
operator|.
name|exp2
operator|.
name|X_op
operator|=
name|O_illegal
expr_stmt|;
name|the_insn
operator|.
name|reloc
operator|=
name|old_reloc
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|the_insn
operator|.
name|exp2
operator|.
name|X_op
operator|!=
name|O_constant
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Illegal operands: Can't add non-constant expression to %%%s()"
argument_list|)
argument_list|,
name|op_arg
argument_list|)
expr_stmt|;
return|return
name|special_case
return|;
block|}
else|else
block|{
if|if
condition|(
name|old_reloc
operator|!=
name|BFD_RELOC_SPARC13
operator|||
name|the_insn
operator|.
name|reloc
operator|!=
name|BFD_RELOC_LO10
operator|||
name|sparc_arch_size
operator|!=
literal|64
operator|||
name|sparc_pic_code
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Illegal operands: Can't do arithmetics involving %%%s() of a relocatable symbol"
argument_list|)
argument_list|,
name|op_arg
argument_list|)
expr_stmt|;
return|return
name|special_case
return|;
block|}
name|the_insn
operator|.
name|reloc
operator|=
name|BFD_RELOC_SPARC_OLO10
expr_stmt|;
block|}
block|}
block|}
comment|/* Check for constants that don't require emitting a reloc.  */
if|if
condition|(
name|the_insn
operator|.
name|exp
operator|.
name|X_op
operator|==
name|O_constant
operator|&&
name|the_insn
operator|.
name|exp
operator|.
name|X_add_symbol
operator|==
literal|0
operator|&&
name|the_insn
operator|.
name|exp
operator|.
name|X_op_symbol
operator|==
literal|0
condition|)
block|{
comment|/* For pc-relative call instructions, we reject 		     constants to get better code.  */
if|if
condition|(
name|the_insn
operator|.
name|pcrel
operator|&&
name|the_insn
operator|.
name|reloc
operator|==
name|BFD_RELOC_32_PCREL_S2
operator|&&
name|in_signed_range
argument_list|(
name|the_insn
operator|.
name|exp
operator|.
name|X_add_number
argument_list|,
literal|0x3fff
argument_list|)
condition|)
block|{
name|error_message
operator|=
name|_
argument_list|(
literal|": PC-relative operand can't be a constant"
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
comment|/* Constants that won't fit are checked in md_apply_fix3 		     and bfd_install_relocation. 		     ??? It would be preferable to install the constants 		     into the insn here and save having to create a fixS 		     for each one.  There already exists code to handle 		     all the various cases (e.g. in md_apply_fix3 and 		     bfd_install_relocation) so duplicating all that code 		     here isn't right.  */
block|}
continue|continue;
case|case
literal|'a'
case|:
if|if
condition|(
operator|*
name|s
operator|++
operator|==
literal|'a'
condition|)
block|{
name|opcode
operator||=
name|ANNUL
expr_stmt|;
continue|continue;
block|}
break|break;
case|case
literal|'A'
case|:
block|{
name|int
name|asi
init|=
literal|0
decl_stmt|;
comment|/* Parse an asi.  */
if|if
condition|(
operator|*
name|s
operator|==
literal|'#'
condition|)
block|{
if|if
condition|(
operator|!
name|parse_keyword_arg
argument_list|(
name|sparc_encode_asi
argument_list|,
operator|&
name|s
argument_list|,
operator|&
name|asi
argument_list|)
condition|)
block|{
name|error_message
operator|=
name|_
argument_list|(
literal|": invalid ASI name"
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
name|parse_const_expr_arg
argument_list|(
operator|&
name|s
argument_list|,
operator|&
name|asi
argument_list|)
condition|)
block|{
name|error_message
operator|=
name|_
argument_list|(
literal|": invalid ASI expression"
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
if|if
condition|(
name|asi
operator|<
literal|0
operator|||
name|asi
operator|>
literal|255
condition|)
block|{
name|error_message
operator|=
name|_
argument_list|(
literal|": invalid ASI number"
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
block|}
name|opcode
operator||=
name|ASI
argument_list|(
name|asi
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Alternate space.  */
case|case
literal|'p'
case|:
if|if
condition|(
name|strncmp
argument_list|(
name|s
argument_list|,
literal|"%psr"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
block|{
name|s
operator|+=
literal|4
expr_stmt|;
continue|continue;
block|}
break|break;
case|case
literal|'q'
case|:
comment|/* Floating point queue.  */
if|if
condition|(
name|strncmp
argument_list|(
name|s
argument_list|,
literal|"%fq"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
block|{
name|s
operator|+=
literal|3
expr_stmt|;
continue|continue;
block|}
break|break;
case|case
literal|'Q'
case|:
comment|/* Coprocessor queue.  */
if|if
condition|(
name|strncmp
argument_list|(
name|s
argument_list|,
literal|"%cq"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
block|{
name|s
operator|+=
literal|3
expr_stmt|;
continue|continue;
block|}
break|break;
case|case
literal|'S'
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|str
argument_list|,
literal|"set"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|str
argument_list|,
literal|"setuw"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|special_case
operator|=
name|SPECIAL_CASE_SET
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|str
argument_list|,
literal|"setsw"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|special_case
operator|=
name|SPECIAL_CASE_SETSW
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|str
argument_list|,
literal|"setx"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|special_case
operator|=
name|SPECIAL_CASE_SETX
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|str
argument_list|,
literal|"fdiv"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
block|{
name|special_case
operator|=
name|SPECIAL_CASE_FDIV
expr_stmt|;
continue|continue;
block|}
break|break;
case|case
literal|'o'
case|:
if|if
condition|(
name|strncmp
argument_list|(
name|s
argument_list|,
literal|"%asi"
argument_list|,
literal|4
argument_list|)
operator|!=
literal|0
condition|)
break|break;
name|s
operator|+=
literal|4
expr_stmt|;
continue|continue;
case|case
literal|'s'
case|:
if|if
condition|(
name|strncmp
argument_list|(
name|s
argument_list|,
literal|"%fprs"
argument_list|,
literal|5
argument_list|)
operator|!=
literal|0
condition|)
break|break;
name|s
operator|+=
literal|5
expr_stmt|;
continue|continue;
case|case
literal|'E'
case|:
if|if
condition|(
name|strncmp
argument_list|(
name|s
argument_list|,
literal|"%ccr"
argument_list|,
literal|4
argument_list|)
operator|!=
literal|0
condition|)
break|break;
name|s
operator|+=
literal|4
expr_stmt|;
continue|continue;
case|case
literal|'t'
case|:
if|if
condition|(
name|strncmp
argument_list|(
name|s
argument_list|,
literal|"%tbr"
argument_list|,
literal|4
argument_list|)
operator|!=
literal|0
condition|)
break|break;
name|s
operator|+=
literal|4
expr_stmt|;
continue|continue;
case|case
literal|'w'
case|:
if|if
condition|(
name|strncmp
argument_list|(
name|s
argument_list|,
literal|"%wim"
argument_list|,
literal|4
argument_list|)
operator|!=
literal|0
condition|)
break|break;
name|s
operator|+=
literal|4
expr_stmt|;
continue|continue;
case|case
literal|'x'
case|:
block|{
name|char
modifier|*
name|push
init|=
name|input_line_pointer
decl_stmt|;
name|expressionS
name|e
decl_stmt|;
name|input_line_pointer
operator|=
name|s
expr_stmt|;
name|expression
argument_list|(
operator|&
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|.
name|X_op
operator|==
name|O_constant
condition|)
block|{
name|int
name|n
init|=
name|e
operator|.
name|X_add_number
decl_stmt|;
if|if
condition|(
name|n
operator|!=
name|e
operator|.
name|X_add_number
operator|||
operator|(
name|n
operator|&
operator|~
literal|0x1ff
operator|)
operator|!=
literal|0
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"OPF immediate operand out of range (0-0x1ff)"
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|opcode
operator||=
name|e
operator|.
name|X_add_number
operator|<<
literal|5
expr_stmt|;
block|}
else|else
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"non-immediate OPF operand, ignored"
argument_list|)
argument_list|)
expr_stmt|;
name|s
operator|=
name|input_line_pointer
expr_stmt|;
name|input_line_pointer
operator|=
name|push
expr_stmt|;
continue|continue;
block|}
case|case
literal|'y'
case|:
if|if
condition|(
name|strncmp
argument_list|(
name|s
argument_list|,
literal|"%y"
argument_list|,
literal|2
argument_list|)
operator|!=
literal|0
condition|)
break|break;
name|s
operator|+=
literal|2
expr_stmt|;
continue|continue;
case|case
literal|'u'
case|:
case|case
literal|'U'
case|:
block|{
comment|/* Parse a sparclet cpreg.  */
name|int
name|cpreg
decl_stmt|;
if|if
condition|(
operator|!
name|parse_keyword_arg
argument_list|(
name|sparc_encode_sparclet_cpreg
argument_list|,
operator|&
name|s
argument_list|,
operator|&
name|cpreg
argument_list|)
condition|)
block|{
name|error_message
operator|=
name|_
argument_list|(
literal|": invalid cpreg name"
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|opcode
operator||=
operator|(
operator|*
name|args
operator|==
literal|'U'
condition|?
name|RS1
argument_list|(
name|cpreg
argument_list|)
else|:
name|RD
argument_list|(
name|cpreg
argument_list|)
operator|)
expr_stmt|;
continue|continue;
block|}
default|default:
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"failed sanity check."
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* switch on arg code.  */
comment|/* Break out of for() loop.  */
break|break;
block|}
comment|/* For each arg that we expect.  */
name|error
label|:
if|if
condition|(
name|match
operator|==
literal|0
condition|)
block|{
comment|/* Args don't match.  */
if|if
condition|(
operator|&
name|insn
index|[
literal|1
index|]
operator|-
name|sparc_opcodes
operator|<
name|sparc_num_opcodes
operator|&&
operator|(
name|insn
operator|->
name|name
operator|==
name|insn
index|[
literal|1
index|]
operator|.
name|name
operator|||
operator|!
name|strcmp
argument_list|(
name|insn
operator|->
name|name
argument_list|,
name|insn
index|[
literal|1
index|]
operator|.
name|name
argument_list|)
operator|)
condition|)
block|{
operator|++
name|insn
expr_stmt|;
name|s
operator|=
name|argsStart
expr_stmt|;
continue|continue;
block|}
else|else
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Illegal operands%s"
argument_list|)
argument_list|,
name|error_message
argument_list|)
expr_stmt|;
return|return
name|special_case
return|;
block|}
block|}
else|else
block|{
comment|/* We have a match.  Now see if the architecture is OK.  */
name|int
name|needed_arch_mask
init|=
name|insn
operator|->
name|architecture
decl_stmt|;
if|if
condition|(
name|v9_arg_p
condition|)
block|{
name|needed_arch_mask
operator|&=
operator|~
operator|(
name|SPARC_OPCODE_ARCH_MASK
argument_list|(
name|SPARC_OPCODE_ARCH_V9
argument_list|)
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|needed_arch_mask
condition|)
name|needed_arch_mask
operator|=
name|SPARC_OPCODE_ARCH_MASK
argument_list|(
name|SPARC_OPCODE_ARCH_V9
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|needed_arch_mask
operator|&
name|SPARC_OPCODE_SUPPORTED
argument_list|(
name|current_architecture
argument_list|)
condition|)
comment|/* OK.  */
empty_stmt|;
comment|/* Can we bump up the architecture?  */
elseif|else
if|if
condition|(
name|needed_arch_mask
operator|&
name|SPARC_OPCODE_SUPPORTED
argument_list|(
name|max_architecture
argument_list|)
condition|)
block|{
name|enum
name|sparc_opcode_arch_val
name|needed_architecture
init|=
name|sparc_ffs
argument_list|(
name|SPARC_OPCODE_SUPPORTED
argument_list|(
name|max_architecture
argument_list|)
operator|&
name|needed_arch_mask
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|needed_architecture
operator|<=
name|SPARC_OPCODE_ARCH_MAX
argument_list|)
expr_stmt|;
if|if
condition|(
name|warn_on_bump
operator|&&
name|needed_architecture
operator|>
name|warn_after_architecture
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"architecture bumped from \"%s\" to \"%s\" on \"%s\""
argument_list|)
argument_list|,
name|sparc_opcode_archs
index|[
name|current_architecture
index|]
operator|.
name|name
argument_list|,
name|sparc_opcode_archs
index|[
name|needed_architecture
index|]
operator|.
name|name
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|warn_after_architecture
operator|=
name|needed_architecture
expr_stmt|;
block|}
name|current_architecture
operator|=
name|needed_architecture
expr_stmt|;
block|}
comment|/* Conflict.  */
comment|/* ??? This seems to be a bit fragile.  What if the next entry in 	     the opcode table is the one we want and it is supported? 	     It is possible to arrange the table today so that this can't 	     happen but what about tomorrow?  */
else|else
block|{
name|int
name|arch
decl_stmt|,
name|printed_one_p
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|char
name|required_archs
index|[
name|SPARC_OPCODE_ARCH_MAX
operator|*
literal|16
index|]
decl_stmt|;
comment|/* Create a list of the architectures that support the insn.  */
name|needed_arch_mask
operator|&=
operator|~
name|SPARC_OPCODE_SUPPORTED
argument_list|(
name|max_architecture
argument_list|)
expr_stmt|;
name|p
operator|=
name|required_archs
expr_stmt|;
name|arch
operator|=
name|sparc_ffs
argument_list|(
name|needed_arch_mask
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
literal|1
operator|<<
name|arch
operator|)
operator|<=
name|needed_arch_mask
condition|)
block|{
if|if
condition|(
operator|(
literal|1
operator|<<
name|arch
operator|)
operator|&
name|needed_arch_mask
condition|)
block|{
if|if
condition|(
name|printed_one_p
condition|)
operator|*
name|p
operator|++
operator|=
literal|'|'
expr_stmt|;
name|strcpy
argument_list|(
name|p
argument_list|,
name|sparc_opcode_archs
index|[
name|arch
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|p
operator|+=
name|strlen
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|printed_one_p
operator|=
literal|1
expr_stmt|;
block|}
operator|++
name|arch
expr_stmt|;
block|}
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Architecture mismatch on \"%s\"."
argument_list|)
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|as_tsktsk
argument_list|(
name|_
argument_list|(
literal|" (Requires %s; requested architecture is %s.)"
argument_list|)
argument_list|,
name|required_archs
argument_list|,
name|sparc_opcode_archs
index|[
name|max_architecture
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
return|return
name|special_case
return|;
block|}
block|}
comment|/* If no match.  */
break|break;
block|}
comment|/* Forever looking for a match.  */
name|the_insn
operator|.
name|opcode
operator|=
name|opcode
expr_stmt|;
return|return
name|special_case
return|;
block|}
end_function

begin_comment
comment|/* Parse an argument that can be expressed as a keyword.    (eg: #StoreStore or %ccfr).    The result is a boolean indicating success.    If successful, INPUT_POINTER is updated.  */
end_comment

begin_function_decl
specifier|static
name|int
name|parse_keyword_arg
parameter_list|(
name|lookup_fn
parameter_list|,
name|input_pointerP
parameter_list|,
name|valueP
parameter_list|)
function_decl|int
parameter_list|(
function_decl|*lookup_fn
end_function_decl

begin_expr_stmt
unit|)
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|char
modifier|*
modifier|*
name|input_pointerP
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|valueP
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|value
decl_stmt|;
name|char
name|c
decl_stmt|,
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|p
operator|=
operator|*
name|input_pointerP
expr_stmt|;
for|for
control|(
name|q
operator|=
name|p
operator|+
operator|(
operator|*
name|p
operator|==
literal|'#'
operator|||
operator|*
name|p
operator|==
literal|'%'
operator|)
init|;
name|ISALNUM
argument_list|(
operator|*
name|q
argument_list|)
operator|||
operator|*
name|q
operator|==
literal|'_'
condition|;
operator|++
name|q
control|)
continue|continue;
name|c
operator|=
operator|*
name|q
expr_stmt|;
operator|*
name|q
operator|=
literal|0
expr_stmt|;
name|value
operator|=
call|(
modifier|*
name|lookup_fn
call|)
argument_list|(
name|p
argument_list|)
expr_stmt|;
operator|*
name|q
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|value
operator|==
operator|-
literal|1
condition|)
return|return
literal|0
return|;
operator|*
name|valueP
operator|=
name|value
expr_stmt|;
operator|*
name|input_pointerP
operator|=
name|q
expr_stmt|;
return|return
literal|1
return|;
block|}
end_block

begin_comment
comment|/* Parse an argument that is a constant expression.    The result is a boolean indicating success.  */
end_comment

begin_function
specifier|static
name|int
name|parse_const_expr_arg
parameter_list|(
name|input_pointerP
parameter_list|,
name|valueP
parameter_list|)
name|char
modifier|*
modifier|*
name|input_pointerP
decl_stmt|;
name|int
modifier|*
name|valueP
decl_stmt|;
block|{
name|char
modifier|*
name|save
init|=
name|input_line_pointer
decl_stmt|;
name|expressionS
name|exp
decl_stmt|;
name|input_line_pointer
operator|=
operator|*
name|input_pointerP
expr_stmt|;
comment|/* The next expression may be something other than a constant      (say if we're not processing the right variant of the insn).      Don't call expression unless we're sure it will succeed as it will      signal an error (which we want to defer until later).  */
comment|/* FIXME: It might be better to define md_operand and have it recognize      things like %asi, etc. but continuing that route through to the end      is a lot of work.  */
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|'%'
condition|)
block|{
name|input_line_pointer
operator|=
name|save
expr_stmt|;
return|return
literal|0
return|;
block|}
name|expression
argument_list|(
operator|&
name|exp
argument_list|)
expr_stmt|;
operator|*
name|input_pointerP
operator|=
name|input_line_pointer
expr_stmt|;
name|input_line_pointer
operator|=
name|save
expr_stmt|;
if|if
condition|(
name|exp
operator|.
name|X_op
operator|!=
name|O_constant
condition|)
return|return
literal|0
return|;
operator|*
name|valueP
operator|=
name|exp
operator|.
name|X_add_number
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Subroutine of sparc_ip to parse an expression.  */
end_comment

begin_function
specifier|static
name|int
name|get_expression
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|char
modifier|*
name|save_in
decl_stmt|;
name|segT
name|seg
decl_stmt|;
name|save_in
operator|=
name|input_line_pointer
expr_stmt|;
name|input_line_pointer
operator|=
name|str
expr_stmt|;
name|seg
operator|=
name|expression
argument_list|(
operator|&
name|the_insn
operator|.
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
name|seg
operator|!=
name|absolute_section
operator|&&
name|seg
operator|!=
name|text_section
operator|&&
name|seg
operator|!=
name|data_section
operator|&&
name|seg
operator|!=
name|bss_section
operator|&&
name|seg
operator|!=
name|undefined_section
condition|)
block|{
name|the_insn
operator|.
name|error
operator|=
name|_
argument_list|(
literal|"bad segment"
argument_list|)
expr_stmt|;
name|expr_end
operator|=
name|input_line_pointer
expr_stmt|;
name|input_line_pointer
operator|=
name|save_in
expr_stmt|;
return|return
literal|1
return|;
block|}
name|expr_end
operator|=
name|input_line_pointer
expr_stmt|;
name|input_line_pointer
operator|=
name|save_in
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Subroutine of md_assemble to output one insn.  */
end_comment

begin_function
specifier|static
name|void
name|output_insn
parameter_list|(
name|insn
parameter_list|,
name|the_insn
parameter_list|)
specifier|const
name|struct
name|sparc_opcode
modifier|*
name|insn
decl_stmt|;
name|struct
name|sparc_it
modifier|*
name|the_insn
decl_stmt|;
block|{
name|char
modifier|*
name|toP
init|=
name|frag_more
argument_list|(
literal|4
argument_list|)
decl_stmt|;
comment|/* Put out the opcode.  */
if|if
condition|(
name|INSN_BIG_ENDIAN
condition|)
name|number_to_chars_bigendian
argument_list|(
name|toP
argument_list|,
operator|(
name|valueT
operator|)
name|the_insn
operator|->
name|opcode
argument_list|,
literal|4
argument_list|)
expr_stmt|;
else|else
name|number_to_chars_littleendian
argument_list|(
name|toP
argument_list|,
operator|(
name|valueT
operator|)
name|the_insn
operator|->
name|opcode
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* Put out the symbol-dependent stuff.  */
if|if
condition|(
name|the_insn
operator|->
name|reloc
operator|!=
name|BFD_RELOC_NONE
condition|)
block|{
name|fixS
modifier|*
name|fixP
init|=
name|fix_new_exp
argument_list|(
name|frag_now
argument_list|,
comment|/* Which frag.  */
operator|(
name|toP
operator|-
name|frag_now
operator|->
name|fr_literal
operator|)
argument_list|,
comment|/* Where.  */
literal|4
argument_list|,
comment|/* Size.  */
operator|&
name|the_insn
operator|->
name|exp
argument_list|,
name|the_insn
operator|->
name|pcrel
argument_list|,
name|the_insn
operator|->
name|reloc
argument_list|)
decl_stmt|;
comment|/* Turn off overflow checking in fixup_segment.  We'll do our 	 own overflow checking in md_apply_fix3.  This is necessary because 	 the insn size is 4 and fixup_segment will signal an overflow for 	 large 8 byte quantities.  */
name|fixP
operator|->
name|fx_no_overflow
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|the_insn
operator|->
name|reloc
operator|==
name|BFD_RELOC_SPARC_OLO10
condition|)
name|fixP
operator|->
name|tc_fix_data
operator|=
name|the_insn
operator|->
name|exp2
operator|.
name|X_add_number
expr_stmt|;
block|}
name|last_insn
operator|=
name|insn
expr_stmt|;
name|last_opcode
operator|=
name|the_insn
operator|->
name|opcode
expr_stmt|;
ifdef|#
directive|ifdef
name|OBJ_ELF
name|dwarf2_emit_insn
argument_list|(
literal|4
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This is identical to the md_atof in m68k.c.  I think this is right,    but I'm not sure.     Turn a string in input_line_pointer into a floating point constant    of type TYPE, and store the appropriate bytes in *LITP.  The number    of LITTLENUMS emitted is stored in *SIZEP.  An error message is    returned, or NULL on OK.  */
end_comment

begin_comment
comment|/* Equal to MAX_PRECISION in atof-ieee.c.  */
end_comment

begin_define
define|#
directive|define
name|MAX_LITTLENUMS
value|6
end_define

begin_function
name|char
modifier|*
name|md_atof
parameter_list|(
name|type
parameter_list|,
name|litP
parameter_list|,
name|sizeP
parameter_list|)
name|char
name|type
decl_stmt|;
name|char
modifier|*
name|litP
decl_stmt|;
name|int
modifier|*
name|sizeP
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|prec
decl_stmt|;
name|LITTLENUM_TYPE
name|words
index|[
name|MAX_LITTLENUMS
index|]
decl_stmt|;
name|char
modifier|*
name|t
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
literal|'f'
case|:
case|case
literal|'F'
case|:
case|case
literal|'s'
case|:
case|case
literal|'S'
case|:
name|prec
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
case|case
literal|'D'
case|:
case|case
literal|'r'
case|:
case|case
literal|'R'
case|:
name|prec
operator|=
literal|4
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
case|case
literal|'X'
case|:
name|prec
operator|=
literal|6
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
case|case
literal|'P'
case|:
name|prec
operator|=
literal|6
expr_stmt|;
break|break;
default|default:
operator|*
name|sizeP
operator|=
literal|0
expr_stmt|;
return|return
name|_
argument_list|(
literal|"Bad call to MD_ATOF()"
argument_list|)
return|;
block|}
name|t
operator|=
name|atof_ieee
argument_list|(
name|input_line_pointer
argument_list|,
name|type
argument_list|,
name|words
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
condition|)
name|input_line_pointer
operator|=
name|t
expr_stmt|;
operator|*
name|sizeP
operator|=
name|prec
operator|*
sizeof|sizeof
argument_list|(
name|LITTLENUM_TYPE
argument_list|)
expr_stmt|;
if|if
condition|(
name|target_big_endian
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|prec
condition|;
name|i
operator|++
control|)
block|{
name|md_number_to_chars
argument_list|(
name|litP
argument_list|,
operator|(
name|valueT
operator|)
name|words
index|[
name|i
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|LITTLENUM_TYPE
argument_list|)
argument_list|)
expr_stmt|;
name|litP
operator|+=
sizeof|sizeof
argument_list|(
name|LITTLENUM_TYPE
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
name|prec
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|md_number_to_chars
argument_list|(
name|litP
argument_list|,
operator|(
name|valueT
operator|)
name|words
index|[
name|i
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|LITTLENUM_TYPE
argument_list|)
argument_list|)
expr_stmt|;
name|litP
operator|+=
sizeof|sizeof
argument_list|(
name|LITTLENUM_TYPE
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Write a value out to the object file, using the appropriate    endianness.  */
end_comment

begin_function
name|void
name|md_number_to_chars
parameter_list|(
name|buf
parameter_list|,
name|val
parameter_list|,
name|n
parameter_list|)
name|char
modifier|*
name|buf
decl_stmt|;
name|valueT
name|val
decl_stmt|;
name|int
name|n
decl_stmt|;
block|{
if|if
condition|(
name|target_big_endian
condition|)
name|number_to_chars_bigendian
argument_list|(
name|buf
argument_list|,
name|val
argument_list|,
name|n
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|target_little_endian_data
operator|&&
operator|(
operator|(
name|n
operator|==
literal|4
operator|||
name|n
operator|==
literal|2
operator|)
operator|&&
operator|~
name|now_seg
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
condition|)
comment|/* Output debug words, which are not in allocated sections, as big        endian.  */
name|number_to_chars_bigendian
argument_list|(
name|buf
argument_list|,
name|val
argument_list|,
name|n
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|target_little_endian_data
operator|||
operator|!
name|target_big_endian
condition|)
name|number_to_chars_littleendian
argument_list|(
name|buf
argument_list|,
name|val
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Apply a fixS to the frags, now that we know the value it ought to    hold.  */
end_comment

begin_function
name|void
name|md_apply_fix3
parameter_list|(
name|fixP
parameter_list|,
name|valP
parameter_list|,
name|segment
parameter_list|)
name|fixS
modifier|*
name|fixP
decl_stmt|;
name|valueT
modifier|*
name|valP
decl_stmt|;
name|segT
name|segment
decl_stmt|;
block|{
name|char
modifier|*
name|buf
init|=
name|fixP
operator|->
name|fx_where
operator|+
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_literal
decl_stmt|;
name|offsetT
name|val
init|=
operator|*
operator|(
name|offsetT
operator|*
operator|)
name|valP
decl_stmt|;
name|long
name|insn
decl_stmt|;
name|assert
argument_list|(
name|fixP
operator|->
name|fx_r_type
operator|<
name|BFD_RELOC_UNUSED
argument_list|)
expr_stmt|;
name|fixP
operator|->
name|fx_addnumber
operator|=
name|val
expr_stmt|;
comment|/* Remember value for emit_reloc.  */
ifdef|#
directive|ifdef
name|OBJ_ELF
comment|/* FIXME: SPARC ELF relocations don't use an addend in the data      field itself.  This whole approach should be somehow combined      with the calls to bfd_install_relocation.  Also, the value passed      in by fixup_segment includes the value of a defined symbol.  We      don't want to include the value of an externally visible symbol.  */
if|if
condition|(
name|fixP
operator|->
name|fx_addsy
operator|!=
name|NULL
condition|)
block|{
name|symbolS
modifier|*
name|sym
init|=
name|fixP
operator|->
name|fx_addsy
decl_stmt|;
name|segT
name|seg
init|=
name|S_GET_SEGMENT
argument_list|(
name|sym
argument_list|)
decl_stmt|;
if|if
condition|(
name|symbol_used_in_reloc_p
argument_list|(
name|sym
argument_list|)
operator|&&
operator|(
name|S_IS_EXTERNAL
argument_list|(
name|sym
argument_list|)
operator|||
name|S_IS_WEAK
argument_list|(
name|sym
argument_list|)
operator|||
operator|(
name|seg
operator|->
name|flags
operator|&
name|SEC_MERGE
operator|)
operator|||
operator|(
name|sparc_pic_code
operator|&&
operator|!
name|fixP
operator|->
name|fx_pcrel
operator|)
operator|||
operator|(
name|seg
operator|!=
name|segment
operator|&&
operator|(
operator|(
operator|(
name|bfd_get_section_flags
argument_list|(
name|stdoutput
argument_list|,
name|seg
argument_list|)
operator|&
name|SEC_LINK_ONCE
operator|)
operator|!=
literal|0
operator|)
operator|||
operator|(
name|strncmp
argument_list|(
name|segment_name
argument_list|(
name|seg
argument_list|)
argument_list|,
literal|".gnu.linkonce"
argument_list|,
sizeof|sizeof
expr|".gnu.linkonce"
operator|-
literal|1
argument_list|)
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
operator|&&
name|seg
operator|!=
name|absolute_section
operator|&&
name|seg
operator|!=
name|undefined_section
operator|&&
operator|!
name|bfd_is_com_section
argument_list|(
name|seg
argument_list|)
condition|)
name|fixP
operator|->
name|fx_addnumber
operator|-=
name|S_GET_VALUE
argument_list|(
name|sym
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
comment|/* This is a hack.  There should be a better way to      handle this.  Probably in terms of howto fields, once      we can look at these fixups in terms of howtos.  */
if|if
condition|(
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_32_PCREL_S2
operator|&&
name|fixP
operator|->
name|fx_addsy
condition|)
name|val
operator|+=
name|fixP
operator|->
name|fx_where
operator|+
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_address
expr_stmt|;
ifdef|#
directive|ifdef
name|OBJ_AOUT
comment|/* FIXME: More ridiculous gas reloc hacking.  If we are going to      generate a reloc, then we just want to let the reloc addend set      the value.  We do not want to also stuff the addend into the      object file.  Including the addend in the object file works when      doing a static link, because the linker will ignore the object      file contents.  However, the dynamic linker does not ignore the      object file contents.  */
if|if
condition|(
name|fixP
operator|->
name|fx_addsy
operator|!=
name|NULL
operator|&&
name|fixP
operator|->
name|fx_r_type
operator|!=
name|BFD_RELOC_32_PCREL_S2
condition|)
name|val
operator|=
literal|0
expr_stmt|;
comment|/* When generating PIC code, we do not want an addend for a reloc      against a local symbol.  We adjust fx_addnumber to cancel out the      value already included in val, and to also cancel out the      adjustment which bfd_install_relocation will create.  */
if|if
condition|(
name|sparc_pic_code
operator|&&
name|fixP
operator|->
name|fx_r_type
operator|!=
name|BFD_RELOC_32_PCREL_S2
operator|&&
name|fixP
operator|->
name|fx_addsy
operator|!=
name|NULL
operator|&&
operator|!
name|S_IS_COMMON
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
operator|&&
name|symbol_section_p
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
condition|)
name|fixP
operator|->
name|fx_addnumber
operator|-=
literal|2
operator|*
name|S_GET_VALUE
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
expr_stmt|;
comment|/* When generating PIC code, we need to fiddle to get      bfd_install_relocation to do the right thing for a PC relative      reloc against a local symbol which we are going to keep.  */
if|if
condition|(
name|sparc_pic_code
operator|&&
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_32_PCREL_S2
operator|&&
name|fixP
operator|->
name|fx_addsy
operator|!=
name|NULL
operator|&&
operator|(
name|S_IS_EXTERNAL
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
operator|||
name|S_IS_WEAK
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
operator|)
operator|&&
name|S_IS_DEFINED
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
operator|&&
operator|!
name|S_IS_COMMON
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
condition|)
block|{
name|val
operator|=
literal|0
expr_stmt|;
name|fixP
operator|->
name|fx_addnumber
operator|-=
literal|2
operator|*
name|S_GET_VALUE
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* If this is a data relocation, just output VAL.  */
if|if
condition|(
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_16
operator|||
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_SPARC_UA16
condition|)
block|{
name|md_number_to_chars
argument_list|(
name|buf
argument_list|,
name|val
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_32
operator|||
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_SPARC_UA32
operator|||
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_SPARC_REV32
condition|)
block|{
name|md_number_to_chars
argument_list|(
name|buf
argument_list|,
name|val
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_64
operator|||
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_SPARC_UA64
condition|)
block|{
name|md_number_to_chars
argument_list|(
name|buf
argument_list|,
name|val
argument_list|,
literal|8
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_VTABLE_INHERIT
operator|||
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_VTABLE_ENTRY
condition|)
block|{
name|fixP
operator|->
name|fx_done
operator|=
literal|0
expr_stmt|;
return|return;
block|}
else|else
block|{
comment|/* It's a relocation against an instruction.  */
if|if
condition|(
name|INSN_BIG_ENDIAN
condition|)
name|insn
operator|=
name|bfd_getb32
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|buf
argument_list|)
expr_stmt|;
else|else
name|insn
operator|=
name|bfd_getl32
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|buf
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|fixP
operator|->
name|fx_r_type
condition|)
block|{
case|case
name|BFD_RELOC_32_PCREL_S2
case|:
name|val
operator|=
name|val
operator|>>
literal|2
expr_stmt|;
comment|/* FIXME: This increment-by-one deserves a comment of why it's 	     being done!  */
if|if
condition|(
operator|!
name|sparc_pic_code
operator|||
name|fixP
operator|->
name|fx_addsy
operator|==
name|NULL
operator|||
name|symbol_section_p
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
condition|)
operator|++
name|val
expr_stmt|;
name|insn
operator||=
name|val
operator|&
literal|0x3fffffff
expr_stmt|;
comment|/* See if we have a delay slot.  */
if|if
condition|(
name|sparc_relax
operator|&&
name|fixP
operator|->
name|fx_where
operator|+
literal|8
operator|<=
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_fix
condition|)
block|{
define|#
directive|define
name|G0
value|0
define|#
directive|define
name|O7
value|15
define|#
directive|define
name|XCC
value|(2<< 20)
define|#
directive|define
name|COND
parameter_list|(
name|x
parameter_list|)
value|(((x)&0xf)<<25)
define|#
directive|define
name|CONDA
value|COND(0x8)
define|#
directive|define
name|INSN_BPA
value|(F2(0,1) | CONDA | BPRED | XCC)
define|#
directive|define
name|INSN_BA
value|(F2(0,2) | CONDA)
define|#
directive|define
name|INSN_OR
value|F3(2, 0x2, 0)
define|#
directive|define
name|INSN_NOP
value|F2(0,4)
name|long
name|delay
decl_stmt|;
comment|/* If the instruction is a call with either: 		 restore 		 arithmetic instruction with rd == %o7 		 where rs1 != %o7 and rs2 if it is register != %o7 		 then we can optimize if the call destination is near 		 by changing the call into a branch always.  */
if|if
condition|(
name|INSN_BIG_ENDIAN
condition|)
name|delay
operator|=
name|bfd_getb32
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|buf
operator|+
literal|4
argument_list|)
expr_stmt|;
else|else
name|delay
operator|=
name|bfd_getl32
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|buf
operator|+
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|insn
operator|&
name|OP
argument_list|(
operator|~
literal|0
argument_list|)
operator|)
operator|!=
name|OP
argument_list|(
literal|1
argument_list|)
operator|||
operator|(
name|delay
operator|&
name|OP
argument_list|(
operator|~
literal|0
argument_list|)
operator|)
operator|!=
name|OP
argument_list|(
literal|2
argument_list|)
condition|)
break|break;
if|if
condition|(
operator|(
name|delay
operator|&
name|OP3
argument_list|(
operator|~
literal|0
argument_list|)
operator|)
operator|!=
name|OP3
argument_list|(
literal|0x3d
argument_list|)
comment|/* Restore.  */
operator|&&
operator|(
operator|(
name|delay
operator|&
name|OP3
argument_list|(
literal|0x28
argument_list|)
operator|)
operator|!=
literal|0
comment|/* Arithmetic.  */
operator|||
operator|(
operator|(
name|delay
operator|&
name|RD
argument_list|(
operator|~
literal|0
argument_list|)
operator|)
operator|!=
name|RD
argument_list|(
name|O7
argument_list|)
operator|)
operator|)
condition|)
break|break;
if|if
condition|(
operator|(
name|delay
operator|&
name|RS1
argument_list|(
operator|~
literal|0
argument_list|)
operator|)
operator|==
name|RS1
argument_list|(
name|O7
argument_list|)
operator|||
operator|(
operator|(
name|delay
operator|&
name|F3I
argument_list|(
operator|~
literal|0
argument_list|)
operator|)
operator|==
literal|0
operator|&&
operator|(
name|delay
operator|&
name|RS2
argument_list|(
operator|~
literal|0
argument_list|)
operator|)
operator|==
name|RS2
argument_list|(
name|O7
argument_list|)
operator|)
condition|)
break|break;
comment|/* Ensure the branch will fit into simm22.  */
if|if
condition|(
operator|(
name|val
operator|&
literal|0x3fe00000
operator|)
operator|&&
operator|(
name|val
operator|&
literal|0x3fe00000
operator|)
operator|!=
literal|0x3fe00000
condition|)
break|break;
comment|/* Check if the arch is v9 and branch will fit 		 into simm19.  */
if|if
condition|(
operator|(
operator|(
name|val
operator|&
literal|0x3c0000
operator|)
operator|==
literal|0
operator|||
operator|(
name|val
operator|&
literal|0x3c0000
operator|)
operator|==
literal|0x3c0000
operator|)
operator|&&
operator|(
name|sparc_arch_size
operator|==
literal|64
operator|||
name|current_architecture
operator|>=
name|SPARC_OPCODE_ARCH_V9
operator|)
condition|)
comment|/* ba,pt %xcc  */
name|insn
operator|=
name|INSN_BPA
operator||
operator|(
name|val
operator|&
literal|0x7ffff
operator|)
expr_stmt|;
else|else
comment|/* ba  */
name|insn
operator|=
name|INSN_BA
operator||
operator|(
name|val
operator|&
literal|0x3fffff
operator|)
expr_stmt|;
if|if
condition|(
name|fixP
operator|->
name|fx_where
operator|>=
literal|4
operator|&&
operator|(
operator|(
name|delay
operator|&
operator|(
literal|0xffffffff
operator|^
name|RS1
argument_list|(
operator|~
literal|0
argument_list|)
operator|)
operator|)
operator|==
operator|(
name|INSN_OR
operator||
name|RD
argument_list|(
name|O7
argument_list|)
operator||
name|RS2
argument_list|(
name|G0
argument_list|)
operator|)
operator|)
condition|)
block|{
name|long
name|setter
decl_stmt|;
name|int
name|reg
decl_stmt|;
if|if
condition|(
name|INSN_BIG_ENDIAN
condition|)
name|setter
operator|=
name|bfd_getb32
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|buf
operator|-
literal|4
argument_list|)
expr_stmt|;
else|else
name|setter
operator|=
name|bfd_getl32
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|buf
operator|-
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|setter
operator|&
operator|(
literal|0xffffffff
operator|^
name|RD
argument_list|(
operator|~
literal|0
argument_list|)
operator|)
operator|)
operator|!=
operator|(
name|INSN_OR
operator||
name|RS1
argument_list|(
name|O7
argument_list|)
operator||
name|RS2
argument_list|(
name|G0
argument_list|)
operator|)
condition|)
break|break;
comment|/* The sequence was 		     or %o7, %g0, %rN 		     call foo 		     or %rN, %g0, %o7  		     If call foo was replaced with ba, replace 		     or %rN, %g0, %o7 with nop.  */
name|reg
operator|=
operator|(
name|delay
operator|&
name|RS1
argument_list|(
operator|~
literal|0
argument_list|)
operator|)
operator|>>
literal|14
expr_stmt|;
if|if
condition|(
name|reg
operator|!=
operator|(
operator|(
name|setter
operator|&
name|RD
argument_list|(
operator|~
literal|0
argument_list|)
operator|)
operator|>>
literal|25
operator|)
operator|||
name|reg
operator|==
name|G0
operator|||
name|reg
operator|==
name|O7
condition|)
break|break;
if|if
condition|(
name|INSN_BIG_ENDIAN
condition|)
name|bfd_putb32
argument_list|(
name|INSN_NOP
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|buf
operator|+
literal|4
argument_list|)
expr_stmt|;
else|else
name|bfd_putl32
argument_list|(
name|INSN_NOP
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|buf
operator|+
literal|4
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|BFD_RELOC_SPARC_11
case|:
if|if
condition|(
operator|!
name|in_signed_range
argument_list|(
name|val
argument_list|,
literal|0x7ff
argument_list|)
condition|)
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"relocation overflow"
argument_list|)
argument_list|)
expr_stmt|;
name|insn
operator||=
name|val
operator|&
literal|0x7ff
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_SPARC_10
case|:
if|if
condition|(
operator|!
name|in_signed_range
argument_list|(
name|val
argument_list|,
literal|0x3ff
argument_list|)
condition|)
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"relocation overflow"
argument_list|)
argument_list|)
expr_stmt|;
name|insn
operator||=
name|val
operator|&
literal|0x3ff
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_SPARC_7
case|:
if|if
condition|(
operator|!
name|in_bitfield_range
argument_list|(
name|val
argument_list|,
literal|0x7f
argument_list|)
condition|)
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"relocation overflow"
argument_list|)
argument_list|)
expr_stmt|;
name|insn
operator||=
name|val
operator|&
literal|0x7f
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_SPARC_6
case|:
if|if
condition|(
operator|!
name|in_bitfield_range
argument_list|(
name|val
argument_list|,
literal|0x3f
argument_list|)
condition|)
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"relocation overflow"
argument_list|)
argument_list|)
expr_stmt|;
name|insn
operator||=
name|val
operator|&
literal|0x3f
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_SPARC_5
case|:
if|if
condition|(
operator|!
name|in_bitfield_range
argument_list|(
name|val
argument_list|,
literal|0x1f
argument_list|)
condition|)
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"relocation overflow"
argument_list|)
argument_list|)
expr_stmt|;
name|insn
operator||=
name|val
operator|&
literal|0x1f
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_SPARC_WDISP16
case|:
comment|/* FIXME: simplify.  */
if|if
condition|(
operator|(
operator|(
name|val
operator|>
literal|0
operator|)
operator|&&
operator|(
name|val
operator|&
operator|~
literal|0x3fffc
operator|)
operator|)
operator|||
operator|(
operator|(
name|val
operator|<
literal|0
operator|)
operator|&&
operator|(
operator|~
operator|(
name|val
operator|-
literal|1
operator|)
operator|&
operator|~
literal|0x3fffc
operator|)
operator|)
condition|)
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"relocation overflow"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* FIXME: The +1 deserves a comment.  */
name|val
operator|=
operator|(
name|val
operator|>>
literal|2
operator|)
operator|+
literal|1
expr_stmt|;
name|insn
operator||=
operator|(
operator|(
name|val
operator|&
literal|0xc000
operator|)
operator|<<
literal|6
operator|)
operator||
operator|(
name|val
operator|&
literal|0x3fff
operator|)
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_SPARC_WDISP19
case|:
comment|/* FIXME: simplify.  */
if|if
condition|(
operator|(
operator|(
name|val
operator|>
literal|0
operator|)
operator|&&
operator|(
name|val
operator|&
operator|~
literal|0x1ffffc
operator|)
operator|)
operator|||
operator|(
operator|(
name|val
operator|<
literal|0
operator|)
operator|&&
operator|(
operator|~
operator|(
name|val
operator|-
literal|1
operator|)
operator|&
operator|~
literal|0x1ffffc
operator|)
operator|)
condition|)
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"relocation overflow"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* FIXME: The +1 deserves a comment.  */
name|val
operator|=
operator|(
name|val
operator|>>
literal|2
operator|)
operator|+
literal|1
expr_stmt|;
name|insn
operator||=
name|val
operator|&
literal|0x7ffff
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_SPARC_HH22
case|:
name|val
operator|=
name|BSR
argument_list|(
name|val
argument_list|,
literal|32
argument_list|)
expr_stmt|;
comment|/* Fall through.  */
case|case
name|BFD_RELOC_SPARC_LM22
case|:
case|case
name|BFD_RELOC_HI22
case|:
if|if
condition|(
operator|!
name|fixP
operator|->
name|fx_addsy
condition|)
name|insn
operator||=
operator|(
name|val
operator|>>
literal|10
operator|)
operator|&
literal|0x3fffff
expr_stmt|;
else|else
comment|/* FIXME: Need comment explaining why we do this.  */
name|insn
operator|&=
operator|~
literal|0xffff
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_SPARC22
case|:
if|if
condition|(
name|val
operator|&
operator|~
literal|0x003fffff
condition|)
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"relocation overflow"
argument_list|)
argument_list|)
expr_stmt|;
name|insn
operator||=
operator|(
name|val
operator|&
literal|0x3fffff
operator|)
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_SPARC_HM10
case|:
name|val
operator|=
name|BSR
argument_list|(
name|val
argument_list|,
literal|32
argument_list|)
expr_stmt|;
comment|/* Fall through.  */
case|case
name|BFD_RELOC_LO10
case|:
if|if
condition|(
operator|!
name|fixP
operator|->
name|fx_addsy
condition|)
name|insn
operator||=
name|val
operator|&
literal|0x3ff
expr_stmt|;
else|else
comment|/* FIXME: Need comment explaining why we do this.  */
name|insn
operator|&=
operator|~
literal|0xff
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_SPARC_OLO10
case|:
name|val
operator|&=
literal|0x3ff
expr_stmt|;
name|val
operator|+=
name|fixP
operator|->
name|tc_fix_data
expr_stmt|;
comment|/* Fall through.  */
case|case
name|BFD_RELOC_SPARC13
case|:
if|if
condition|(
operator|!
name|in_signed_range
argument_list|(
name|val
argument_list|,
literal|0x1fff
argument_list|)
condition|)
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"relocation overflow"
argument_list|)
argument_list|)
expr_stmt|;
name|insn
operator||=
name|val
operator|&
literal|0x1fff
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_SPARC_WDISP22
case|:
name|val
operator|=
operator|(
name|val
operator|>>
literal|2
operator|)
operator|+
literal|1
expr_stmt|;
comment|/* Fall through.  */
case|case
name|BFD_RELOC_SPARC_BASE22
case|:
name|insn
operator||=
name|val
operator|&
literal|0x3fffff
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_SPARC_H44
case|:
if|if
condition|(
operator|!
name|fixP
operator|->
name|fx_addsy
condition|)
block|{
name|bfd_vma
name|tval
init|=
name|val
decl_stmt|;
name|tval
operator|>>=
literal|22
expr_stmt|;
name|insn
operator||=
name|tval
operator|&
literal|0x3fffff
expr_stmt|;
block|}
break|break;
case|case
name|BFD_RELOC_SPARC_M44
case|:
if|if
condition|(
operator|!
name|fixP
operator|->
name|fx_addsy
condition|)
name|insn
operator||=
operator|(
name|val
operator|>>
literal|12
operator|)
operator|&
literal|0x3ff
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_SPARC_L44
case|:
if|if
condition|(
operator|!
name|fixP
operator|->
name|fx_addsy
condition|)
name|insn
operator||=
name|val
operator|&
literal|0xfff
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_SPARC_HIX22
case|:
if|if
condition|(
operator|!
name|fixP
operator|->
name|fx_addsy
condition|)
block|{
name|val
operator|^=
operator|~
operator|(
name|offsetT
operator|)
literal|0
expr_stmt|;
name|insn
operator||=
operator|(
name|val
operator|>>
literal|10
operator|)
operator|&
literal|0x3fffff
expr_stmt|;
block|}
break|break;
case|case
name|BFD_RELOC_SPARC_LOX10
case|:
if|if
condition|(
operator|!
name|fixP
operator|->
name|fx_addsy
condition|)
name|insn
operator||=
literal|0x1c00
operator||
operator|(
name|val
operator|&
literal|0x3ff
operator|)
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_NONE
case|:
default|default:
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"bad or unhandled relocation type: 0x%02x"
argument_list|)
argument_list|,
name|fixP
operator|->
name|fx_r_type
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|INSN_BIG_ENDIAN
condition|)
name|bfd_putb32
argument_list|(
name|insn
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|buf
argument_list|)
expr_stmt|;
else|else
name|bfd_putl32
argument_list|(
name|insn
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|buf
argument_list|)
expr_stmt|;
block|}
comment|/* Are we finished with this relocation now?  */
if|if
condition|(
name|fixP
operator|->
name|fx_addsy
operator|==
literal|0
operator|&&
operator|!
name|fixP
operator|->
name|fx_pcrel
condition|)
name|fixP
operator|->
name|fx_done
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Translate internal representation of relocation info to BFD target    format.  */
end_comment

begin_function
name|arelent
modifier|*
modifier|*
name|tc_gen_reloc
parameter_list|(
name|section
parameter_list|,
name|fixp
parameter_list|)
name|asection
modifier|*
name|section
decl_stmt|;
name|fixS
modifier|*
name|fixp
decl_stmt|;
block|{
specifier|static
name|arelent
modifier|*
name|relocs
index|[
literal|3
index|]
decl_stmt|;
name|arelent
modifier|*
name|reloc
decl_stmt|;
name|bfd_reloc_code_real_type
name|code
decl_stmt|;
name|relocs
index|[
literal|0
index|]
operator|=
name|reloc
operator|=
operator|(
name|arelent
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|arelent
argument_list|)
argument_list|)
expr_stmt|;
name|relocs
index|[
literal|1
index|]
operator|=
name|NULL
expr_stmt|;
name|reloc
operator|->
name|sym_ptr_ptr
operator|=
operator|(
name|asymbol
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|asymbol
operator|*
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|reloc
operator|->
name|sym_ptr_ptr
operator|=
name|symbol_get_bfdsym
argument_list|(
name|fixp
operator|->
name|fx_addsy
argument_list|)
expr_stmt|;
name|reloc
operator|->
name|address
operator|=
name|fixp
operator|->
name|fx_frag
operator|->
name|fr_address
operator|+
name|fixp
operator|->
name|fx_where
expr_stmt|;
switch|switch
condition|(
name|fixp
operator|->
name|fx_r_type
condition|)
block|{
case|case
name|BFD_RELOC_16
case|:
case|case
name|BFD_RELOC_32
case|:
case|case
name|BFD_RELOC_HI22
case|:
case|case
name|BFD_RELOC_LO10
case|:
case|case
name|BFD_RELOC_32_PCREL_S2
case|:
case|case
name|BFD_RELOC_SPARC13
case|:
case|case
name|BFD_RELOC_SPARC22
case|:
case|case
name|BFD_RELOC_SPARC_BASE13
case|:
case|case
name|BFD_RELOC_SPARC_WDISP16
case|:
case|case
name|BFD_RELOC_SPARC_WDISP19
case|:
case|case
name|BFD_RELOC_SPARC_WDISP22
case|:
case|case
name|BFD_RELOC_64
case|:
case|case
name|BFD_RELOC_SPARC_5
case|:
case|case
name|BFD_RELOC_SPARC_6
case|:
case|case
name|BFD_RELOC_SPARC_7
case|:
case|case
name|BFD_RELOC_SPARC_10
case|:
case|case
name|BFD_RELOC_SPARC_11
case|:
case|case
name|BFD_RELOC_SPARC_HH22
case|:
case|case
name|BFD_RELOC_SPARC_HM10
case|:
case|case
name|BFD_RELOC_SPARC_LM22
case|:
case|case
name|BFD_RELOC_SPARC_PC_HH22
case|:
case|case
name|BFD_RELOC_SPARC_PC_HM10
case|:
case|case
name|BFD_RELOC_SPARC_PC_LM22
case|:
case|case
name|BFD_RELOC_SPARC_H44
case|:
case|case
name|BFD_RELOC_SPARC_M44
case|:
case|case
name|BFD_RELOC_SPARC_L44
case|:
case|case
name|BFD_RELOC_SPARC_HIX22
case|:
case|case
name|BFD_RELOC_SPARC_LOX10
case|:
case|case
name|BFD_RELOC_SPARC_REV32
case|:
case|case
name|BFD_RELOC_SPARC_OLO10
case|:
case|case
name|BFD_RELOC_SPARC_UA16
case|:
case|case
name|BFD_RELOC_SPARC_UA32
case|:
case|case
name|BFD_RELOC_SPARC_UA64
case|:
case|case
name|BFD_RELOC_8_PCREL
case|:
case|case
name|BFD_RELOC_16_PCREL
case|:
case|case
name|BFD_RELOC_32_PCREL
case|:
case|case
name|BFD_RELOC_64_PCREL
case|:
case|case
name|BFD_RELOC_SPARC_PLT32
case|:
case|case
name|BFD_RELOC_SPARC_PLT64
case|:
case|case
name|BFD_RELOC_VTABLE_ENTRY
case|:
case|case
name|BFD_RELOC_VTABLE_INHERIT
case|:
name|code
operator|=
name|fixp
operator|->
name|fx_r_type
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|OBJ_ELF
argument_list|)
operator|||
name|defined
argument_list|(
name|OBJ_AOUT
argument_list|)
comment|/* If we are generating PIC code, we need to generate a different      set of relocs.  */
ifdef|#
directive|ifdef
name|OBJ_ELF
define|#
directive|define
name|GOT_NAME
value|"_GLOBAL_OFFSET_TABLE_"
else|#
directive|else
define|#
directive|define
name|GOT_NAME
value|"__GLOBAL_OFFSET_TABLE_"
endif|#
directive|endif
comment|/* This code must be parallel to the OBJ_ELF tc_fix_adjustable.  */
if|if
condition|(
name|sparc_pic_code
condition|)
block|{
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|BFD_RELOC_32_PCREL_S2
case|:
if|if
condition|(
operator|!
name|S_IS_DEFINED
argument_list|(
name|fixp
operator|->
name|fx_addsy
argument_list|)
operator|||
name|S_IS_COMMON
argument_list|(
name|fixp
operator|->
name|fx_addsy
argument_list|)
operator|||
name|S_IS_EXTERNAL
argument_list|(
name|fixp
operator|->
name|fx_addsy
argument_list|)
operator|||
name|S_IS_WEAK
argument_list|(
name|fixp
operator|->
name|fx_addsy
argument_list|)
condition|)
name|code
operator|=
name|BFD_RELOC_SPARC_WPLT30
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_HI22
case|:
if|if
condition|(
name|fixp
operator|->
name|fx_addsy
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|S_GET_NAME
argument_list|(
name|fixp
operator|->
name|fx_addsy
argument_list|)
argument_list|,
name|GOT_NAME
argument_list|)
operator|==
literal|0
condition|)
name|code
operator|=
name|BFD_RELOC_SPARC_PC22
expr_stmt|;
else|else
name|code
operator|=
name|BFD_RELOC_SPARC_GOT22
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_LO10
case|:
if|if
condition|(
name|fixp
operator|->
name|fx_addsy
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|S_GET_NAME
argument_list|(
name|fixp
operator|->
name|fx_addsy
argument_list|)
argument_list|,
name|GOT_NAME
argument_list|)
operator|==
literal|0
condition|)
name|code
operator|=
name|BFD_RELOC_SPARC_PC10
expr_stmt|;
else|else
name|code
operator|=
name|BFD_RELOC_SPARC_GOT10
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_SPARC13
case|:
name|code
operator|=
name|BFD_RELOC_SPARC_GOT13
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
endif|#
directive|endif
comment|/* defined (OBJ_ELF) || defined (OBJ_AOUT)  */
if|if
condition|(
name|code
operator|==
name|BFD_RELOC_SPARC_OLO10
condition|)
name|reloc
operator|->
name|howto
operator|=
name|bfd_reloc_type_lookup
argument_list|(
name|stdoutput
argument_list|,
name|BFD_RELOC_LO10
argument_list|)
expr_stmt|;
else|else
name|reloc
operator|->
name|howto
operator|=
name|bfd_reloc_type_lookup
argument_list|(
name|stdoutput
argument_list|,
name|code
argument_list|)
expr_stmt|;
if|if
condition|(
name|reloc
operator|->
name|howto
operator|==
literal|0
condition|)
block|{
name|as_bad_where
argument_list|(
name|fixp
operator|->
name|fx_file
argument_list|,
name|fixp
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"internal error: can't export reloc type %d (`%s')"
argument_list|)
argument_list|,
name|fixp
operator|->
name|fx_r_type
argument_list|,
name|bfd_get_reloc_code_name
argument_list|(
name|code
argument_list|)
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|reloc
argument_list|)
expr_stmt|;
name|relocs
index|[
literal|0
index|]
operator|=
name|NULL
expr_stmt|;
return|return
name|relocs
return|;
block|}
comment|/* @@ Why fx_addnumber sometimes and fx_offset other times?  */
ifdef|#
directive|ifdef
name|OBJ_AOUT
if|if
condition|(
name|reloc
operator|->
name|howto
operator|->
name|pc_relative
operator|==
literal|0
operator|||
name|code
operator|==
name|BFD_RELOC_SPARC_PC10
operator|||
name|code
operator|==
name|BFD_RELOC_SPARC_PC22
condition|)
name|reloc
operator|->
name|addend
operator|=
name|fixp
operator|->
name|fx_addnumber
expr_stmt|;
elseif|else
if|if
condition|(
name|sparc_pic_code
operator|&&
name|fixp
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_32_PCREL_S2
operator|&&
name|fixp
operator|->
name|fx_addsy
operator|!=
name|NULL
operator|&&
operator|(
name|S_IS_EXTERNAL
argument_list|(
name|fixp
operator|->
name|fx_addsy
argument_list|)
operator|||
name|S_IS_WEAK
argument_list|(
name|fixp
operator|->
name|fx_addsy
argument_list|)
operator|)
operator|&&
name|S_IS_DEFINED
argument_list|(
name|fixp
operator|->
name|fx_addsy
argument_list|)
operator|&&
operator|!
name|S_IS_COMMON
argument_list|(
name|fixp
operator|->
name|fx_addsy
argument_list|)
condition|)
name|reloc
operator|->
name|addend
operator|=
name|fixp
operator|->
name|fx_addnumber
expr_stmt|;
else|else
name|reloc
operator|->
name|addend
operator|=
name|fixp
operator|->
name|fx_offset
operator|-
name|reloc
operator|->
name|address
expr_stmt|;
else|#
directive|else
comment|/* elf or coff  */
if|if
condition|(
name|code
operator|!=
name|BFD_RELOC_32_PCREL_S2
operator|&&
name|code
operator|!=
name|BFD_RELOC_SPARC_WDISP22
operator|&&
name|code
operator|!=
name|BFD_RELOC_SPARC_WDISP16
operator|&&
name|code
operator|!=
name|BFD_RELOC_SPARC_WDISP19
operator|&&
name|code
operator|!=
name|BFD_RELOC_SPARC_WPLT30
condition|)
name|reloc
operator|->
name|addend
operator|=
name|fixp
operator|->
name|fx_addnumber
expr_stmt|;
elseif|else
if|if
condition|(
name|symbol_section_p
argument_list|(
name|fixp
operator|->
name|fx_addsy
argument_list|)
condition|)
name|reloc
operator|->
name|addend
operator|=
operator|(
name|section
operator|->
name|vma
operator|+
name|fixp
operator|->
name|fx_addnumber
operator|+
name|md_pcrel_from
argument_list|(
name|fixp
argument_list|)
operator|)
expr_stmt|;
else|else
name|reloc
operator|->
name|addend
operator|=
name|fixp
operator|->
name|fx_offset
expr_stmt|;
endif|#
directive|endif
comment|/* We expand R_SPARC_OLO10 to R_SPARC_LO10 and R_SPARC_13      on the same location.  */
if|if
condition|(
name|code
operator|==
name|BFD_RELOC_SPARC_OLO10
condition|)
block|{
name|relocs
index|[
literal|1
index|]
operator|=
name|reloc
operator|=
operator|(
name|arelent
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|arelent
argument_list|)
argument_list|)
expr_stmt|;
name|relocs
index|[
literal|2
index|]
operator|=
name|NULL
expr_stmt|;
name|reloc
operator|->
name|sym_ptr_ptr
operator|=
operator|(
name|asymbol
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|asymbol
operator|*
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|reloc
operator|->
name|sym_ptr_ptr
operator|=
name|symbol_get_bfdsym
argument_list|(
name|section_symbol
argument_list|(
name|absolute_section
argument_list|)
argument_list|)
expr_stmt|;
name|reloc
operator|->
name|address
operator|=
name|fixp
operator|->
name|fx_frag
operator|->
name|fr_address
operator|+
name|fixp
operator|->
name|fx_where
expr_stmt|;
name|reloc
operator|->
name|howto
operator|=
name|bfd_reloc_type_lookup
argument_list|(
name|stdoutput
argument_list|,
name|BFD_RELOC_SPARC13
argument_list|)
expr_stmt|;
name|reloc
operator|->
name|addend
operator|=
name|fixp
operator|->
name|tc_fix_data
expr_stmt|;
block|}
return|return
name|relocs
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* We have no need to default values of symbols.  */
end_comment

begin_function
name|symbolS
modifier|*
name|md_undefined_symbol
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Round up a section size to the appropriate boundary.  */
end_comment

begin_function
name|valueT
name|md_section_align
parameter_list|(
name|segment
parameter_list|,
name|size
parameter_list|)
name|segT
name|segment
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|valueT
name|size
decl_stmt|;
block|{
ifndef|#
directive|ifndef
name|OBJ_ELF
comment|/* This is not right for ELF; a.out wants it, and COFF will force      the alignment anyways.  */
name|valueT
name|align
init|=
operator|(
operator|(
name|valueT
operator|)
literal|1
operator|<<
operator|(
name|valueT
operator|)
name|bfd_get_section_alignment
argument_list|(
name|stdoutput
argument_list|,
name|segment
argument_list|)
operator|)
decl_stmt|;
name|valueT
name|newsize
decl_stmt|;
comment|/* Turn alignment value into a mask.  */
name|align
operator|--
expr_stmt|;
name|newsize
operator|=
operator|(
name|size
operator|+
name|align
operator|)
operator|&
operator|~
name|align
expr_stmt|;
return|return
name|newsize
return|;
else|#
directive|else
return|return
name|size
return|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Exactly what point is a PC-relative offset relative TO?    On the sparc, they're relative to the address of the offset, plus    its size.  This gets us to the following instruction.    (??? Is this right?  FIXME-SOON)  */
end_comment

begin_function
name|long
name|md_pcrel_from
parameter_list|(
name|fixP
parameter_list|)
name|fixS
modifier|*
name|fixP
decl_stmt|;
block|{
name|long
name|ret
decl_stmt|;
name|ret
operator|=
name|fixP
operator|->
name|fx_where
operator|+
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_address
expr_stmt|;
if|if
condition|(
operator|!
name|sparc_pic_code
operator|||
name|fixP
operator|->
name|fx_addsy
operator|==
name|NULL
operator|||
name|symbol_section_p
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
condition|)
name|ret
operator|+=
name|fixP
operator|->
name|fx_size
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return log2 (VALUE), or -1 if VALUE is not an exact positive power    of two.  */
end_comment

begin_function
specifier|static
name|int
name|log2
parameter_list|(
name|value
parameter_list|)
name|int
name|value
decl_stmt|;
block|{
name|int
name|shift
decl_stmt|;
if|if
condition|(
name|value
operator|<=
literal|0
condition|)
return|return
operator|-
literal|1
return|;
for|for
control|(
name|shift
operator|=
literal|0
init|;
operator|(
name|value
operator|&
literal|1
operator|)
operator|==
literal|0
condition|;
name|value
operator|>>=
literal|1
control|)
operator|++
name|shift
expr_stmt|;
return|return
operator|(
name|value
operator|==
literal|1
operator|)
condition|?
name|shift
else|:
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Sort of like s_lcomm.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|OBJ_ELF
end_ifndef

begin_decl_stmt
specifier|static
name|int
name|max_alignment
init|=
literal|15
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|s_reserve
parameter_list|(
name|ignore
parameter_list|)
name|int
name|ignore
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|char
name|c
decl_stmt|;
name|int
name|align
decl_stmt|;
name|int
name|size
decl_stmt|;
name|int
name|temp
decl_stmt|;
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
name|name
operator|=
name|input_line_pointer
expr_stmt|;
name|c
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
name|p
operator|=
name|input_line_pointer
expr_stmt|;
operator|*
name|p
operator|=
name|c
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|!=
literal|','
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Expected comma after name"
argument_list|)
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
operator|++
name|input_line_pointer
expr_stmt|;
if|if
condition|(
operator|(
name|size
operator|=
name|get_absolute_expression
argument_list|()
operator|)
operator|<
literal|0
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"BSS length (%d.)<0! Ignored."
argument_list|)
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
comment|/* Bad length.  */
operator|*
name|p
operator|=
literal|0
expr_stmt|;
name|symbolP
operator|=
name|symbol_find_or_make
argument_list|(
name|name
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|input_line_pointer
argument_list|,
literal|",\"bss\""
argument_list|,
literal|6
argument_list|)
operator|!=
literal|0
operator|&&
name|strncmp
argument_list|(
name|input_line_pointer
argument_list|,
literal|",\".bss\""
argument_list|,
literal|7
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"bad .reserve segment -- expected BSS segment"
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|input_line_pointer
index|[
literal|2
index|]
operator|==
literal|'.'
condition|)
name|input_line_pointer
operator|+=
literal|7
expr_stmt|;
else|else
name|input_line_pointer
operator|+=
literal|6
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|','
condition|)
block|{
operator|++
name|input_line_pointer
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|'\n'
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"missing alignment"
argument_list|)
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
name|align
operator|=
operator|(
name|int
operator|)
name|get_absolute_expression
argument_list|()
expr_stmt|;
ifndef|#
directive|ifndef
name|OBJ_ELF
if|if
condition|(
name|align
operator|>
name|max_alignment
condition|)
block|{
name|align
operator|=
name|max_alignment
expr_stmt|;
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"alignment too large; assuming %d"
argument_list|)
argument_list|,
name|align
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|align
operator|<
literal|0
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"negative alignment"
argument_list|)
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|align
operator|!=
literal|0
condition|)
block|{
name|temp
operator|=
name|log2
argument_list|(
name|align
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|<
literal|0
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"alignment not a power of 2"
argument_list|)
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
name|align
operator|=
name|temp
expr_stmt|;
block|}
name|record_alignment
argument_list|(
name|bss_section
argument_list|,
name|align
argument_list|)
expr_stmt|;
block|}
else|else
name|align
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|S_IS_DEFINED
argument_list|(
name|symbolP
argument_list|)
ifdef|#
directive|ifdef
name|OBJ_AOUT
operator|&&
name|S_GET_OTHER
argument_list|(
name|symbolP
argument_list|)
operator|==
literal|0
operator|&&
name|S_GET_DESC
argument_list|(
name|symbolP
argument_list|)
operator|==
literal|0
endif|#
directive|endif
condition|)
block|{
if|if
condition|(
operator|!
name|need_pass_2
condition|)
block|{
name|char
modifier|*
name|pfrag
decl_stmt|;
name|segT
name|current_seg
init|=
name|now_seg
decl_stmt|;
name|subsegT
name|current_subseg
init|=
name|now_subseg
decl_stmt|;
comment|/* Switch to bss.  */
name|subseg_set
argument_list|(
name|bss_section
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|align
condition|)
comment|/* Do alignment.  */
name|frag_align
argument_list|(
name|align
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Detach from old frag.  */
if|if
condition|(
name|S_GET_SEGMENT
argument_list|(
name|symbolP
argument_list|)
operator|==
name|bss_section
condition|)
name|symbol_get_frag
argument_list|(
name|symbolP
argument_list|)
operator|->
name|fr_symbol
operator|=
name|NULL
expr_stmt|;
name|symbol_set_frag
argument_list|(
name|symbolP
argument_list|,
name|frag_now
argument_list|)
expr_stmt|;
name|pfrag
operator|=
name|frag_var
argument_list|(
name|rs_org
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
operator|(
name|relax_substateT
operator|)
literal|0
argument_list|,
name|symbolP
argument_list|,
operator|(
name|offsetT
operator|)
name|size
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
operator|*
name|pfrag
operator|=
literal|0
expr_stmt|;
name|S_SET_SEGMENT
argument_list|(
name|symbolP
argument_list|,
name|bss_section
argument_list|)
expr_stmt|;
name|subseg_set
argument_list|(
name|current_seg
argument_list|,
name|current_subseg
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|OBJ_ELF
name|S_SET_SIZE
argument_list|(
name|symbolP
argument_list|,
name|size
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
else|else
block|{
name|as_warn
argument_list|(
literal|"Ignoring attempt to re-define symbol %s"
argument_list|,
name|S_GET_NAME
argument_list|(
name|symbolP
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* if not redefining.  */
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|s_common
parameter_list|(
name|ignore
parameter_list|)
name|int
name|ignore
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|char
name|c
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|temp
decl_stmt|,
name|size
decl_stmt|;
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
name|name
operator|=
name|input_line_pointer
expr_stmt|;
name|c
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
comment|/* Just after name is now '\0'.  */
name|p
operator|=
name|input_line_pointer
expr_stmt|;
operator|*
name|p
operator|=
name|c
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|!=
literal|','
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Expected comma after symbol-name"
argument_list|)
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
comment|/* Skip ','.  */
name|input_line_pointer
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|temp
operator|=
name|get_absolute_expression
argument_list|()
operator|)
operator|<
literal|0
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|".COMMon length (%d.)<0! Ignored."
argument_list|)
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
name|size
operator|=
name|temp
expr_stmt|;
operator|*
name|p
operator|=
literal|0
expr_stmt|;
name|symbolP
operator|=
name|symbol_find_or_make
argument_list|(
name|name
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|S_IS_DEFINED
argument_list|(
name|symbolP
argument_list|)
operator|&&
operator|!
name|S_IS_COMMON
argument_list|(
name|symbolP
argument_list|)
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Ignoring attempt to re-define symbol"
argument_list|)
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|S_GET_VALUE
argument_list|(
name|symbolP
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|S_GET_VALUE
argument_list|(
name|symbolP
argument_list|)
operator|!=
operator|(
name|valueT
operator|)
name|size
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"Length of .comm \"%s\" is already %ld. Not changed to %d."
argument_list|)
argument_list|,
name|S_GET_NAME
argument_list|(
name|symbolP
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|S_GET_VALUE
argument_list|(
name|symbolP
argument_list|)
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
ifndef|#
directive|ifndef
name|OBJ_ELF
name|S_SET_VALUE
argument_list|(
name|symbolP
argument_list|,
operator|(
name|valueT
operator|)
name|size
argument_list|)
expr_stmt|;
name|S_SET_EXTERNAL
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|know
argument_list|(
name|symbol_get_frag
argument_list|(
name|symbolP
argument_list|)
operator|==
operator|&
name|zero_address_frag
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|!=
literal|','
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Expected comma after common length"
argument_list|)
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
name|input_line_pointer
operator|++
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|!=
literal|'"'
condition|)
block|{
name|temp
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
ifndef|#
directive|ifndef
name|OBJ_ELF
if|if
condition|(
name|temp
operator|>
name|max_alignment
condition|)
block|{
name|temp
operator|=
name|max_alignment
expr_stmt|;
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"alignment too large; assuming %d"
argument_list|)
argument_list|,
name|temp
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|temp
operator|<
literal|0
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"negative alignment"
argument_list|)
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
ifdef|#
directive|ifdef
name|OBJ_ELF
if|if
condition|(
name|symbol_get_obj
argument_list|(
name|symbolP
argument_list|)
operator|->
name|local
condition|)
block|{
name|segT
name|old_sec
decl_stmt|;
name|int
name|old_subsec
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|align
decl_stmt|;
name|old_sec
operator|=
name|now_seg
expr_stmt|;
name|old_subsec
operator|=
name|now_subseg
expr_stmt|;
if|if
condition|(
name|temp
operator|==
literal|0
condition|)
name|align
operator|=
literal|0
expr_stmt|;
else|else
name|align
operator|=
name|log2
argument_list|(
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
name|align
operator|<
literal|0
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"alignment not a power of 2"
argument_list|)
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
name|record_alignment
argument_list|(
name|bss_section
argument_list|,
name|align
argument_list|)
expr_stmt|;
name|subseg_set
argument_list|(
name|bss_section
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|align
condition|)
name|frag_align
argument_list|(
name|align
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|S_GET_SEGMENT
argument_list|(
name|symbolP
argument_list|)
operator|==
name|bss_section
condition|)
name|symbol_get_frag
argument_list|(
name|symbolP
argument_list|)
operator|->
name|fr_symbol
operator|=
literal|0
expr_stmt|;
name|symbol_set_frag
argument_list|(
name|symbolP
argument_list|,
name|frag_now
argument_list|)
expr_stmt|;
name|p
operator|=
name|frag_var
argument_list|(
name|rs_org
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
operator|(
name|relax_substateT
operator|)
literal|0
argument_list|,
name|symbolP
argument_list|,
operator|(
name|offsetT
operator|)
name|size
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
literal|0
expr_stmt|;
name|S_SET_SEGMENT
argument_list|(
name|symbolP
argument_list|,
name|bss_section
argument_list|)
expr_stmt|;
name|S_CLEAR_EXTERNAL
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
name|S_SET_SIZE
argument_list|(
name|symbolP
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|subseg_set
argument_list|(
name|old_sec
argument_list|,
name|old_subsec
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
comment|/* OBJ_ELF  */
block|{
name|allocate_common
label|:
name|S_SET_VALUE
argument_list|(
name|symbolP
argument_list|,
operator|(
name|valueT
operator|)
name|size
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|OBJ_ELF
name|S_SET_ALIGN
argument_list|(
name|symbolP
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|S_SET_SIZE
argument_list|(
name|symbolP
argument_list|,
name|size
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|S_SET_EXTERNAL
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
name|S_SET_SEGMENT
argument_list|(
name|symbolP
argument_list|,
name|bfd_com_section_ptr
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|input_line_pointer
operator|++
expr_stmt|;
comment|/* @@ Some use the dot, some don't.  Can we get some consistency??  */
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|'.'
condition|)
name|input_line_pointer
operator|++
expr_stmt|;
comment|/* @@ Some say data, some say bss.  */
if|if
condition|(
name|strncmp
argument_list|(
name|input_line_pointer
argument_list|,
literal|"bss\""
argument_list|,
literal|4
argument_list|)
operator|&&
name|strncmp
argument_list|(
name|input_line_pointer
argument_list|,
literal|"data\""
argument_list|,
literal|5
argument_list|)
condition|)
block|{
while|while
condition|(
operator|*
operator|--
name|input_line_pointer
operator|!=
literal|'"'
condition|)
empty_stmt|;
name|input_line_pointer
operator|--
expr_stmt|;
goto|goto
name|bad_common_segment
goto|;
block|}
while|while
condition|(
operator|*
name|input_line_pointer
operator|++
operator|!=
literal|'"'
condition|)
empty_stmt|;
goto|goto
name|allocate_common
goto|;
block|}
ifdef|#
directive|ifdef
name|BFD_ASSEMBLER
name|symbol_get_bfdsym
argument_list|(
name|symbolP
argument_list|)
operator|->
name|flags
operator||=
name|BSF_OBJECT
expr_stmt|;
endif|#
directive|endif
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|{
name|bad_common_segment
label|:
name|p
operator|=
name|input_line_pointer
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|&&
operator|*
name|p
operator|!=
literal|'\n'
condition|)
name|p
operator|++
expr_stmt|;
name|c
operator|=
operator|*
name|p
expr_stmt|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"bad .common segment %s"
argument_list|)
argument_list|,
name|input_line_pointer
operator|+
literal|1
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
name|c
expr_stmt|;
name|input_line_pointer
operator|=
name|p
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
block|}
end_function

begin_comment
comment|/* Handle the .empty pseudo-op.  This supresses the warnings about    invalid delay slot usage.  */
end_comment

begin_function
specifier|static
name|void
name|s_empty
parameter_list|(
name|ignore
parameter_list|)
name|int
name|ignore
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
comment|/* The easy way to implement is to just forget about the last      instruction.  */
name|last_insn
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|s_seg
parameter_list|(
name|ignore
parameter_list|)
name|int
name|ignore
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|input_line_pointer
argument_list|,
literal|"\"text\""
argument_list|,
literal|6
argument_list|)
operator|==
literal|0
condition|)
block|{
name|input_line_pointer
operator|+=
literal|6
expr_stmt|;
name|s_text
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|strncmp
argument_list|(
name|input_line_pointer
argument_list|,
literal|"\"data\""
argument_list|,
literal|6
argument_list|)
operator|==
literal|0
condition|)
block|{
name|input_line_pointer
operator|+=
literal|6
expr_stmt|;
name|s_data
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|strncmp
argument_list|(
name|input_line_pointer
argument_list|,
literal|"\"data1\""
argument_list|,
literal|7
argument_list|)
operator|==
literal|0
condition|)
block|{
name|input_line_pointer
operator|+=
literal|7
expr_stmt|;
name|s_data1
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|strncmp
argument_list|(
name|input_line_pointer
argument_list|,
literal|"\"bss\""
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
block|{
name|input_line_pointer
operator|+=
literal|5
expr_stmt|;
comment|/* We only support 2 segments -- text and data -- for now, so 	 things in the "bss segment" will have to go into data for now. 	 You can still allocate SEG_BSS stuff with .lcomm or .reserve.  */
name|subseg_set
argument_list|(
name|data_section
argument_list|,
literal|255
argument_list|)
expr_stmt|;
comment|/* FIXME-SOMEDAY.  */
return|return;
block|}
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Unknown segment type"
argument_list|)
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|s_data1
parameter_list|()
block|{
name|subseg_set
argument_list|(
name|data_section
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|s_proc
parameter_list|(
name|ignore
parameter_list|)
name|int
name|ignore
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
while|while
condition|(
operator|!
name|is_end_of_line
index|[
operator|(
name|unsigned
name|char
operator|)
operator|*
name|input_line_pointer
index|]
condition|)
block|{
operator|++
name|input_line_pointer
expr_stmt|;
block|}
operator|++
name|input_line_pointer
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This static variable is set by s_uacons to tell sparc_cons_align    that the expession does not need to be aligned.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|sparc_no_align_cons
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This static variable is set by sparc_cons to emit requested types    of relocations in cons_fix_new_sparc.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|sparc_cons_special_reloc
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This handles the unaligned space allocation pseudo-ops, such as    .uaword.  .uaword is just like .word, but the value does not need    to be aligned.  */
end_comment

begin_function
specifier|static
name|void
name|s_uacons
parameter_list|(
name|bytes
parameter_list|)
name|int
name|bytes
decl_stmt|;
block|{
comment|/* Tell sparc_cons_align not to align this value.  */
name|sparc_no_align_cons
operator|=
literal|1
expr_stmt|;
name|cons
argument_list|(
name|bytes
argument_list|)
expr_stmt|;
name|sparc_no_align_cons
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This handles the native word allocation pseudo-op .nword.    For sparc_arch_size 32 it is equivalent to .word,  for    sparc_arch_size 64 it is equivalent to .xword.  */
end_comment

begin_function
specifier|static
name|void
name|s_ncons
parameter_list|(
name|bytes
parameter_list|)
name|int
name|bytes
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|cons
argument_list|(
name|sparc_arch_size
operator|==
literal|32
condition|?
literal|4
else|:
literal|8
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|OBJ_ELF
end_ifdef

begin_comment
comment|/* Handle the SPARC ELF .register pseudo-op.  This sets the binding of a    global register.    The syntax is:     .register %g[2367],{#scratch|symbolname|#ignore} */
end_comment

begin_function
specifier|static
name|void
name|s_register
parameter_list|(
name|ignore
parameter_list|)
name|int
name|ignore
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|char
name|c
decl_stmt|;
name|int
name|reg
decl_stmt|;
name|int
name|flags
decl_stmt|;
specifier|const
name|char
modifier|*
name|regname
decl_stmt|;
if|if
condition|(
name|input_line_pointer
index|[
literal|0
index|]
operator|!=
literal|'%'
operator|||
name|input_line_pointer
index|[
literal|1
index|]
operator|!=
literal|'g'
operator|||
operator|(
operator|(
name|input_line_pointer
index|[
literal|2
index|]
operator|&
operator|~
literal|1
operator|)
operator|!=
literal|'2'
operator|&&
operator|(
name|input_line_pointer
index|[
literal|2
index|]
operator|&
operator|~
literal|1
operator|)
operator|!=
literal|'6'
operator|)
operator|||
name|input_line_pointer
index|[
literal|3
index|]
operator|!=
literal|','
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"register syntax is .register %%g[2367],{#scratch|symbolname|#ignore}"
argument_list|)
argument_list|)
expr_stmt|;
name|reg
operator|=
name|input_line_pointer
index|[
literal|2
index|]
operator|-
literal|'0'
expr_stmt|;
name|input_line_pointer
operator|+=
literal|4
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|'#'
condition|)
block|{
operator|++
name|input_line_pointer
expr_stmt|;
name|regname
operator|=
name|input_line_pointer
expr_stmt|;
name|c
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|regname
argument_list|,
literal|"scratch"
argument_list|)
operator|&&
name|strcmp
argument_list|(
name|regname
argument_list|,
literal|"ignore"
argument_list|)
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"register syntax is .register %%g[2367],{#scratch|symbolname|#ignore}"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|regname
index|[
literal|0
index|]
operator|==
literal|'i'
condition|)
name|regname
operator|=
name|NULL
expr_stmt|;
else|else
name|regname
operator|=
literal|""
expr_stmt|;
block|}
else|else
block|{
name|regname
operator|=
name|input_line_pointer
expr_stmt|;
name|c
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|sparc_arch_size
operator|==
literal|64
condition|)
block|{
if|if
condition|(
name|globals
index|[
name|reg
index|]
condition|)
block|{
if|if
condition|(
operator|(
name|regname
operator|&&
name|globals
index|[
name|reg
index|]
operator|!=
operator|(
name|symbolS
operator|*
operator|)
literal|1
operator|&&
name|strcmp
argument_list|(
name|S_GET_NAME
argument_list|(
name|globals
index|[
name|reg
index|]
argument_list|)
argument_list|,
name|regname
argument_list|)
operator|)
operator|||
operator|(
operator|(
name|regname
operator|!=
name|NULL
operator|)
operator|^
operator|(
name|globals
index|[
name|reg
index|]
operator|!=
operator|(
name|symbolS
operator|*
operator|)
literal|1
operator|)
operator|)
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"redefinition of global register"
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|regname
operator|==
name|NULL
condition|)
name|globals
index|[
name|reg
index|]
operator|=
operator|(
name|symbolS
operator|*
operator|)
literal|1
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|*
name|regname
condition|)
block|{
if|if
condition|(
name|symbol_find
argument_list|(
name|regname
argument_list|)
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Register symbol %s already defined."
argument_list|)
argument_list|,
name|regname
argument_list|)
expr_stmt|;
block|}
name|globals
index|[
name|reg
index|]
operator|=
name|symbol_make
argument_list|(
name|regname
argument_list|)
expr_stmt|;
name|flags
operator|=
name|symbol_get_bfdsym
argument_list|(
name|globals
index|[
name|reg
index|]
argument_list|)
operator|->
name|flags
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|regname
condition|)
name|flags
operator|=
name|flags
operator|&
operator|~
operator|(
name|BSF_GLOBAL
operator||
name|BSF_LOCAL
operator||
name|BSF_WEAK
operator|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
operator|(
name|BSF_GLOBAL
operator||
name|BSF_LOCAL
operator||
name|BSF_WEAK
operator|)
operator|)
condition|)
name|flags
operator||=
name|BSF_GLOBAL
expr_stmt|;
name|symbol_get_bfdsym
argument_list|(
name|globals
index|[
name|reg
index|]
argument_list|)
operator|->
name|flags
operator|=
name|flags
expr_stmt|;
name|S_SET_VALUE
argument_list|(
name|globals
index|[
name|reg
index|]
argument_list|,
operator|(
name|valueT
operator|)
name|reg
argument_list|)
expr_stmt|;
name|S_SET_ALIGN
argument_list|(
name|globals
index|[
name|reg
index|]
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|S_SET_SIZE
argument_list|(
name|globals
index|[
name|reg
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Although we actually want undefined_section here, 		 we have to use absolute_section, because otherwise 		 generic as code will make it a COM section. 		 We fix this up in sparc_adjust_symtab.  */
name|S_SET_SEGMENT
argument_list|(
name|globals
index|[
name|reg
index|]
argument_list|,
name|absolute_section
argument_list|)
expr_stmt|;
name|S_SET_OTHER
argument_list|(
name|globals
index|[
name|reg
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|elf_symbol
argument_list|(
name|symbol_get_bfdsym
argument_list|(
name|globals
index|[
name|reg
index|]
argument_list|)
argument_list|)
operator|->
name|internal_elf_sym
operator|.
name|st_info
operator|=
name|ELF_ST_INFO
argument_list|(
name|STB_GLOBAL
argument_list|,
name|STT_REGISTER
argument_list|)
expr_stmt|;
name|elf_symbol
argument_list|(
name|symbol_get_bfdsym
argument_list|(
name|globals
index|[
name|reg
index|]
argument_list|)
argument_list|)
operator|->
name|internal_elf_sym
operator|.
name|st_shndx
operator|=
name|SHN_UNDEF
expr_stmt|;
block|}
block|}
block|}
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Adjust the symbol table.  We set undefined sections for STT_REGISTER    symbols which need it.  */
end_comment

begin_function
name|void
name|sparc_adjust_symtab
parameter_list|()
block|{
name|symbolS
modifier|*
name|sym
decl_stmt|;
for|for
control|(
name|sym
operator|=
name|symbol_rootP
init|;
name|sym
operator|!=
name|NULL
condition|;
name|sym
operator|=
name|symbol_next
argument_list|(
name|sym
argument_list|)
control|)
block|{
if|if
condition|(
name|ELF_ST_TYPE
argument_list|(
name|elf_symbol
argument_list|(
name|symbol_get_bfdsym
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|->
name|internal_elf_sym
operator|.
name|st_info
argument_list|)
operator|!=
name|STT_REGISTER
condition|)
continue|continue;
if|if
condition|(
name|ELF_ST_TYPE
argument_list|(
name|elf_symbol
argument_list|(
name|symbol_get_bfdsym
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|->
name|internal_elf_sym
operator|.
name|st_shndx
operator|!=
name|SHN_UNDEF
argument_list|)
condition|)
continue|continue;
name|S_SET_SEGMENT
argument_list|(
name|sym
argument_list|,
name|undefined_section
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* If the --enforce-aligned-data option is used, we require .word,    et. al., to be aligned correctly.  We do it by setting up an    rs_align_code frag, and checking in HANDLE_ALIGN to make sure that    no unexpected alignment was introduced.     The SunOS and Solaris native assemblers enforce aligned data by    default.  We don't want to do that, because gcc can deliberately    generate misaligned data if the packed attribute is used.  Instead,    we permit misaligned data by default, and permit the user to set an    option to check for it.  */
end_comment

begin_function
name|void
name|sparc_cons_align
parameter_list|(
name|nbytes
parameter_list|)
name|int
name|nbytes
decl_stmt|;
block|{
name|int
name|nalign
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
comment|/* Only do this if we are enforcing aligned data.  */
if|if
condition|(
operator|!
name|enforce_aligned_data
condition|)
return|return;
comment|/* Don't align if this is an unaligned pseudo-op.  */
if|if
condition|(
name|sparc_no_align_cons
condition|)
return|return;
name|nalign
operator|=
name|log2
argument_list|(
name|nbytes
argument_list|)
expr_stmt|;
if|if
condition|(
name|nalign
operator|==
literal|0
condition|)
return|return;
name|assert
argument_list|(
name|nalign
operator|>
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|now_seg
operator|==
name|absolute_section
condition|)
block|{
if|if
condition|(
operator|(
name|abs_section_offset
operator|&
operator|(
operator|(
literal|1
operator|<<
name|nalign
operator|)
operator|-
literal|1
operator|)
operator|)
operator|!=
literal|0
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"misaligned data"
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|p
operator|=
name|frag_var
argument_list|(
name|rs_align_test
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
operator|(
name|relax_substateT
operator|)
literal|0
argument_list|,
operator|(
name|symbolS
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|offsetT
operator|)
name|nalign
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|record_alignment
argument_list|(
name|now_seg
argument_list|,
name|nalign
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This is called from HANDLE_ALIGN in tc-sparc.h.  */
end_comment

begin_function
name|void
name|sparc_handle_align
parameter_list|(
name|fragp
parameter_list|)
name|fragS
modifier|*
name|fragp
decl_stmt|;
block|{
name|int
name|count
decl_stmt|,
name|fix
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|count
operator|=
name|fragp
operator|->
name|fr_next
operator|->
name|fr_address
operator|-
name|fragp
operator|->
name|fr_address
operator|-
name|fragp
operator|->
name|fr_fix
expr_stmt|;
switch|switch
condition|(
name|fragp
operator|->
name|fr_type
condition|)
block|{
case|case
name|rs_align_test
case|:
if|if
condition|(
name|count
operator|!=
literal|0
condition|)
name|as_bad_where
argument_list|(
name|fragp
operator|->
name|fr_file
argument_list|,
name|fragp
operator|->
name|fr_line
argument_list|,
name|_
argument_list|(
literal|"misaligned data"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|rs_align_code
case|:
name|p
operator|=
name|fragp
operator|->
name|fr_literal
operator|+
name|fragp
operator|->
name|fr_fix
expr_stmt|;
name|fix
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|count
operator|&
literal|3
condition|)
block|{
name|fix
operator|=
name|count
operator|&
literal|3
expr_stmt|;
name|memset
argument_list|(
name|p
argument_list|,
literal|0
argument_list|,
name|fix
argument_list|)
expr_stmt|;
name|p
operator|+=
name|fix
expr_stmt|;
name|count
operator|-=
name|fix
expr_stmt|;
block|}
if|if
condition|(
name|SPARC_OPCODE_ARCH_V9_P
argument_list|(
name|max_architecture
argument_list|)
operator|&&
name|count
operator|>
literal|8
condition|)
block|{
name|unsigned
name|wval
init|=
operator|(
literal|0x30680000
operator||
name|count
operator|>>
literal|2
operator|)
decl_stmt|;
comment|/* ba,a,pt %xcc, 1f  */
if|if
condition|(
name|INSN_BIG_ENDIAN
condition|)
name|number_to_chars_bigendian
argument_list|(
name|p
argument_list|,
name|wval
argument_list|,
literal|4
argument_list|)
expr_stmt|;
else|else
name|number_to_chars_littleendian
argument_list|(
name|p
argument_list|,
name|wval
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|4
expr_stmt|;
name|count
operator|-=
literal|4
expr_stmt|;
name|fix
operator|+=
literal|4
expr_stmt|;
block|}
if|if
condition|(
name|INSN_BIG_ENDIAN
condition|)
name|number_to_chars_bigendian
argument_list|(
name|p
argument_list|,
literal|0x01000000
argument_list|,
literal|4
argument_list|)
expr_stmt|;
else|else
name|number_to_chars_littleendian
argument_list|(
name|p
argument_list|,
literal|0x01000000
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|fragp
operator|->
name|fr_fix
operator|+=
name|fix
expr_stmt|;
name|fragp
operator|->
name|fr_var
operator|=
literal|4
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|OBJ_ELF
end_ifdef

begin_comment
comment|/* Some special processing for a Sparc ELF file.  */
end_comment

begin_function
name|void
name|sparc_elf_final_processing
parameter_list|()
block|{
comment|/* Set the Sparc ELF flag bits.  FIXME: There should probably be some      sort of BFD interface for this.  */
if|if
condition|(
name|sparc_arch_size
operator|==
literal|64
condition|)
block|{
switch|switch
condition|(
name|sparc_memory_model
condition|)
block|{
case|case
name|MM_RMO
case|:
name|elf_elfheader
argument_list|(
name|stdoutput
argument_list|)
operator|->
name|e_flags
operator||=
name|EF_SPARCV9_RMO
expr_stmt|;
break|break;
case|case
name|MM_PSO
case|:
name|elf_elfheader
argument_list|(
name|stdoutput
argument_list|)
operator|->
name|e_flags
operator||=
name|EF_SPARCV9_PSO
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|current_architecture
operator|>=
name|SPARC_OPCODE_ARCH_V9
condition|)
name|elf_elfheader
argument_list|(
name|stdoutput
argument_list|)
operator|->
name|e_flags
operator||=
name|EF_SPARC_32PLUS
expr_stmt|;
if|if
condition|(
name|current_architecture
operator|==
name|SPARC_OPCODE_ARCH_V9A
condition|)
name|elf_elfheader
argument_list|(
name|stdoutput
argument_list|)
operator|->
name|e_flags
operator||=
name|EF_SPARC_SUN_US1
expr_stmt|;
elseif|else
if|if
condition|(
name|current_architecture
operator|==
name|SPARC_OPCODE_ARCH_V9B
condition|)
name|elf_elfheader
argument_list|(
name|stdoutput
argument_list|)
operator|->
name|e_flags
operator||=
name|EF_SPARC_SUN_US1
operator||
name|EF_SPARC_SUN_US3
expr_stmt|;
block|}
end_function

begin_function
name|void
name|sparc_cons
parameter_list|(
name|exp
parameter_list|,
name|size
parameter_list|)
name|expressionS
modifier|*
name|exp
decl_stmt|;
name|int
name|size
decl_stmt|;
block|{
name|char
modifier|*
name|save
decl_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
name|sparc_cons_special_reloc
operator|=
name|NULL
expr_stmt|;
name|save
operator|=
name|input_line_pointer
expr_stmt|;
if|if
condition|(
name|input_line_pointer
index|[
literal|0
index|]
operator|==
literal|'%'
operator|&&
name|input_line_pointer
index|[
literal|1
index|]
operator|==
literal|'r'
operator|&&
name|input_line_pointer
index|[
literal|2
index|]
operator|==
literal|'_'
condition|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|input_line_pointer
operator|+
literal|3
argument_list|,
literal|"disp"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
block|{
name|input_line_pointer
operator|+=
literal|7
expr_stmt|;
name|sparc_cons_special_reloc
operator|=
literal|"disp"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|input_line_pointer
operator|+
literal|3
argument_list|,
literal|"plt"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|size
operator|!=
literal|4
operator|&&
name|size
operator|!=
literal|8
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Illegal operands: %%r_plt in %d-byte data field"
argument_list|)
argument_list|,
name|size
argument_list|)
expr_stmt|;
else|else
block|{
name|input_line_pointer
operator|+=
literal|6
expr_stmt|;
name|sparc_cons_special_reloc
operator|=
literal|"plt"
expr_stmt|;
block|}
block|}
if|if
condition|(
name|sparc_cons_special_reloc
condition|)
block|{
name|int
name|bad
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|size
condition|)
block|{
case|case
literal|1
case|:
if|if
condition|(
operator|*
name|input_line_pointer
operator|!=
literal|'8'
condition|)
name|bad
operator|=
literal|1
expr_stmt|;
name|input_line_pointer
operator|--
expr_stmt|;
break|break;
case|case
literal|2
case|:
if|if
condition|(
name|input_line_pointer
index|[
literal|0
index|]
operator|!=
literal|'1'
operator|||
name|input_line_pointer
index|[
literal|1
index|]
operator|!=
literal|'6'
condition|)
name|bad
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|4
case|:
if|if
condition|(
name|input_line_pointer
index|[
literal|0
index|]
operator|!=
literal|'3'
operator|||
name|input_line_pointer
index|[
literal|1
index|]
operator|!=
literal|'2'
condition|)
name|bad
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|8
case|:
if|if
condition|(
name|input_line_pointer
index|[
literal|0
index|]
operator|!=
literal|'6'
operator|||
name|input_line_pointer
index|[
literal|1
index|]
operator|!=
literal|'4'
condition|)
name|bad
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
name|bad
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|bad
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Illegal operands: Only %%r_%s%d allowed in %d-byte data fields"
argument_list|)
argument_list|,
name|sparc_cons_special_reloc
argument_list|,
name|size
operator|*
literal|8
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|input_line_pointer
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|!=
literal|'('
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Illegal operands: %%r_%s%d requires arguments in ()"
argument_list|)
argument_list|,
name|sparc_cons_special_reloc
argument_list|,
name|size
operator|*
literal|8
argument_list|)
expr_stmt|;
name|bad
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|bad
condition|)
block|{
name|input_line_pointer
operator|=
name|save
expr_stmt|;
name|sparc_cons_special_reloc
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|int
name|c
decl_stmt|;
name|char
modifier|*
name|end
init|=
operator|++
name|input_line_pointer
decl_stmt|;
name|int
name|npar
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|!
name|is_end_of_line
index|[
operator|(
name|c
operator|=
operator|*
name|end
operator|)
index|]
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'('
condition|)
name|npar
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|')'
condition|)
block|{
if|if
condition|(
operator|!
name|npar
condition|)
break|break;
name|npar
operator|--
expr_stmt|;
block|}
name|end
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|!=
literal|')'
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Illegal operands: %%r_%s%d requires arguments in ()"
argument_list|)
argument_list|,
name|sparc_cons_special_reloc
argument_list|,
name|size
operator|*
literal|8
argument_list|)
expr_stmt|;
else|else
block|{
operator|*
name|end
operator|=
literal|'\0'
expr_stmt|;
name|expression
argument_list|(
name|exp
argument_list|)
expr_stmt|;
operator|*
name|end
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|input_line_pointer
operator|!=
name|end
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Illegal operands: %%r_%s%d requires arguments in ()"
argument_list|)
argument_list|,
name|sparc_cons_special_reloc
argument_list|,
name|size
operator|*
literal|8
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|input_line_pointer
operator|++
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
name|c
operator|=
operator|*
name|input_line_pointer
expr_stmt|;
if|if
condition|(
operator|!
name|is_end_of_line
index|[
name|c
index|]
operator|&&
name|c
operator|!=
literal|','
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Illegal operands: garbage after %%r_%s%d()"
argument_list|)
argument_list|,
name|sparc_cons_special_reloc
argument_list|,
name|size
operator|*
literal|8
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
if|if
condition|(
name|sparc_cons_special_reloc
operator|==
name|NULL
condition|)
name|expression
argument_list|(
name|exp
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* This is called by emit_expr via TC_CONS_FIX_NEW when creating a    reloc for a cons.  We could use the definition there, except that    we want to handle little endian relocs specially.  */
end_comment

begin_function
name|void
name|cons_fix_new_sparc
parameter_list|(
name|frag
parameter_list|,
name|where
parameter_list|,
name|nbytes
parameter_list|,
name|exp
parameter_list|)
name|fragS
modifier|*
name|frag
decl_stmt|;
name|int
name|where
decl_stmt|;
name|unsigned
name|int
name|nbytes
decl_stmt|;
name|expressionS
modifier|*
name|exp
decl_stmt|;
block|{
name|bfd_reloc_code_real_type
name|r
decl_stmt|;
name|r
operator|=
operator|(
name|nbytes
operator|==
literal|1
condition|?
name|BFD_RELOC_8
else|:
operator|(
name|nbytes
operator|==
literal|2
condition|?
name|BFD_RELOC_16
else|:
operator|(
name|nbytes
operator|==
literal|4
condition|?
name|BFD_RELOC_32
else|:
name|BFD_RELOC_64
operator|)
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|target_little_endian_data
operator|&&
name|nbytes
operator|==
literal|4
operator|&&
name|now_seg
operator|->
name|flags
operator|&
name|SEC_ALLOC
condition|)
name|r
operator|=
name|BFD_RELOC_SPARC_REV32
expr_stmt|;
if|if
condition|(
name|sparc_cons_special_reloc
condition|)
block|{
if|if
condition|(
operator|*
name|sparc_cons_special_reloc
operator|==
literal|'d'
condition|)
switch|switch
condition|(
name|nbytes
condition|)
block|{
case|case
literal|1
case|:
name|r
operator|=
name|BFD_RELOC_8_PCREL
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|r
operator|=
name|BFD_RELOC_16_PCREL
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|r
operator|=
name|BFD_RELOC_32_PCREL
expr_stmt|;
break|break;
case|case
literal|8
case|:
name|r
operator|=
name|BFD_RELOC_64_PCREL
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
else|else
switch|switch
condition|(
name|nbytes
condition|)
block|{
case|case
literal|4
case|:
name|r
operator|=
name|BFD_RELOC_SPARC_PLT32
expr_stmt|;
break|break;
case|case
literal|8
case|:
name|r
operator|=
name|BFD_RELOC_SPARC_PLT64
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|sparc_no_align_cons
condition|)
block|{
switch|switch
condition|(
name|nbytes
condition|)
block|{
case|case
literal|2
case|:
name|r
operator|=
name|BFD_RELOC_SPARC_UA16
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|r
operator|=
name|BFD_RELOC_SPARC_UA32
expr_stmt|;
break|break;
case|case
literal|8
case|:
name|r
operator|=
name|BFD_RELOC_SPARC_UA64
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
name|fix_new_exp
argument_list|(
name|frag
argument_list|,
name|where
argument_list|,
operator|(
name|int
operator|)
name|nbytes
argument_list|,
name|exp
argument_list|,
literal|0
argument_list|,
name|r
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|OBJ_ELF
end_ifdef

begin_function
name|int
name|elf32_sparc_force_relocation
parameter_list|(
name|fixp
parameter_list|)
name|struct
name|fix
modifier|*
name|fixp
decl_stmt|;
block|{
if|if
condition|(
name|fixp
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_VTABLE_INHERIT
operator|||
name|fixp
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_VTABLE_ENTRY
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

