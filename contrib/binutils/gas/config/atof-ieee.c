begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* atof_ieee.c - turn a Flonum into an IEEE floating point number    Copyright (C) 1987, 92, 93, 94, 95, 96, 1997 Free Software Foundation, Inc.     This file is part of GAS, the GNU Assembler.     GAS is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     GAS is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with GAS; see the file COPYING.  If not, write to the Free    Software Foundation, 59 Temple Place - Suite 330, Boston, MA    02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"as.h"
end_include

begin_comment
comment|/* Flonums returned here.  */
end_comment

begin_decl_stmt
specifier|extern
name|FLONUM_TYPE
name|generic_floating_point_number
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|next_bits
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|unget_bits
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|make_invalid_floating_point_number
name|PARAMS
argument_list|(
operator|(
name|LITTLENUM_TYPE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
specifier|const
name|char
name|EXP_CHARS
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Precision in LittleNums. */
end_comment

begin_comment
comment|/* Don't count the gap in the m68k extended precision format.  */
end_comment

begin_define
define|#
directive|define
name|MAX_PRECISION
value|(5)
end_define

begin_define
define|#
directive|define
name|F_PRECISION
value|(2)
end_define

begin_define
define|#
directive|define
name|D_PRECISION
value|(4)
end_define

begin_define
define|#
directive|define
name|X_PRECISION
value|(5)
end_define

begin_define
define|#
directive|define
name|P_PRECISION
value|(5)
end_define

begin_comment
comment|/* Length in LittleNums of guard bits. */
end_comment

begin_define
define|#
directive|define
name|GUARD
value|(2)
end_define

begin_decl_stmt
specifier|static
specifier|const
name|unsigned
name|long
name|mask
index|[]
init|=
block|{
literal|0x00000000
block|,
literal|0x00000001
block|,
literal|0x00000003
block|,
literal|0x00000007
block|,
literal|0x0000000f
block|,
literal|0x0000001f
block|,
literal|0x0000003f
block|,
literal|0x0000007f
block|,
literal|0x000000ff
block|,
literal|0x000001ff
block|,
literal|0x000003ff
block|,
literal|0x000007ff
block|,
literal|0x00000fff
block|,
literal|0x00001fff
block|,
literal|0x00003fff
block|,
literal|0x00007fff
block|,
literal|0x0000ffff
block|,
literal|0x0001ffff
block|,
literal|0x0003ffff
block|,
literal|0x0007ffff
block|,
literal|0x000fffff
block|,
literal|0x001fffff
block|,
literal|0x003fffff
block|,
literal|0x007fffff
block|,
literal|0x00ffffff
block|,
literal|0x01ffffff
block|,
literal|0x03ffffff
block|,
literal|0x07ffffff
block|,
literal|0x0fffffff
block|,
literal|0x1fffffff
block|,
literal|0x3fffffff
block|,
literal|0x7fffffff
block|,
literal|0xffffffff
block|, }
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_decl_stmt
specifier|static
name|int
name|bits_left_in_littlenum
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|littlenums_left
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|LITTLENUM_TYPE
modifier|*
name|littlenum_pointer
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|next_bits
parameter_list|(
name|number_of_bits
parameter_list|)
name|int
name|number_of_bits
decl_stmt|;
block|{
name|int
name|return_value
decl_stmt|;
if|if
condition|(
operator|!
name|littlenums_left
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|number_of_bits
operator|>=
name|bits_left_in_littlenum
condition|)
block|{
name|return_value
operator|=
name|mask
index|[
name|bits_left_in_littlenum
index|]
operator|&
operator|*
name|littlenum_pointer
expr_stmt|;
name|number_of_bits
operator|-=
name|bits_left_in_littlenum
expr_stmt|;
name|return_value
operator|<<=
name|number_of_bits
expr_stmt|;
if|if
condition|(
operator|--
name|littlenums_left
condition|)
block|{
name|bits_left_in_littlenum
operator|=
name|LITTLENUM_NUMBER_OF_BITS
operator|-
name|number_of_bits
expr_stmt|;
operator|--
name|littlenum_pointer
expr_stmt|;
name|return_value
operator||=
operator|(
operator|*
name|littlenum_pointer
operator|>>
name|bits_left_in_littlenum
operator|)
operator|&
name|mask
index|[
name|number_of_bits
index|]
expr_stmt|;
block|}
block|}
else|else
block|{
name|bits_left_in_littlenum
operator|-=
name|number_of_bits
expr_stmt|;
name|return_value
operator|=
name|mask
index|[
name|number_of_bits
index|]
operator|&
operator|(
operator|*
name|littlenum_pointer
operator|>>
name|bits_left_in_littlenum
operator|)
expr_stmt|;
block|}
return|return
operator|(
name|return_value
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Num had better be less than LITTLENUM_NUMBER_OF_BITS */
end_comment

begin_function
specifier|static
name|void
name|unget_bits
parameter_list|(
name|num
parameter_list|)
name|int
name|num
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|littlenums_left
condition|)
block|{
operator|++
name|littlenum_pointer
expr_stmt|;
operator|++
name|littlenums_left
expr_stmt|;
name|bits_left_in_littlenum
operator|=
name|num
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bits_left_in_littlenum
operator|+
name|num
operator|>
name|LITTLENUM_NUMBER_OF_BITS
condition|)
block|{
name|bits_left_in_littlenum
operator|=
name|num
operator|-
operator|(
name|LITTLENUM_NUMBER_OF_BITS
operator|-
name|bits_left_in_littlenum
operator|)
expr_stmt|;
operator|++
name|littlenum_pointer
expr_stmt|;
operator|++
name|littlenums_left
expr_stmt|;
block|}
else|else
name|bits_left_in_littlenum
operator|+=
name|num
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|make_invalid_floating_point_number
parameter_list|(
name|words
parameter_list|)
name|LITTLENUM_TYPE
modifier|*
name|words
decl_stmt|;
block|{
name|as_bad
argument_list|(
literal|"cannot create floating-point number"
argument_list|)
expr_stmt|;
name|words
index|[
literal|0
index|]
operator|=
call|(
name|LITTLENUM_TYPE
call|)
argument_list|(
operator|(
name|unsigned
operator|)
operator|-
literal|1
argument_list|)
operator|>>
literal|1
expr_stmt|;
comment|/* Zero the leftmost bit */
name|words
index|[
literal|1
index|]
operator|=
operator|(
name|LITTLENUM_TYPE
operator|)
operator|-
literal|1
expr_stmt|;
name|words
index|[
literal|2
index|]
operator|=
operator|(
name|LITTLENUM_TYPE
operator|)
operator|-
literal|1
expr_stmt|;
name|words
index|[
literal|3
index|]
operator|=
operator|(
name|LITTLENUM_TYPE
operator|)
operator|-
literal|1
expr_stmt|;
name|words
index|[
literal|4
index|]
operator|=
operator|(
name|LITTLENUM_TYPE
operator|)
operator|-
literal|1
expr_stmt|;
name|words
index|[
literal|5
index|]
operator|=
operator|(
name|LITTLENUM_TYPE
operator|)
operator|-
literal|1
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/************************************************************************\  *	Warning: this returns 16-bit LITTLENUMs. It is up to the caller	*  *	to figure out any alignment problems and to conspire for the	*  *	bytes/word to be emitted in the right order. Bigendians beware!	*  *									* \************************************************************************/
end_comment

begin_comment
comment|/* Note that atof-ieee always has X and P precisions enabled.  it is up    to md_atof to filter them out if the target machine does not support    them.  */
end_comment

begin_comment
comment|/* Returns pointer past text consumed. */
end_comment

begin_function
name|char
modifier|*
name|atof_ieee
parameter_list|(
name|str
parameter_list|,
name|what_kind
parameter_list|,
name|words
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
comment|/* Text to convert to binary. */
name|char
name|what_kind
decl_stmt|;
comment|/* 'd', 'f', 'g', 'h' */
name|LITTLENUM_TYPE
modifier|*
name|words
decl_stmt|;
comment|/* Build the binary here. */
block|{
comment|/* Extra bits for zeroed low-order bits.  The 1st MAX_PRECISION are      zeroed, the last contain flonum bits. */
specifier|static
name|LITTLENUM_TYPE
name|bits
index|[
name|MAX_PRECISION
operator|+
name|MAX_PRECISION
operator|+
name|GUARD
index|]
decl_stmt|;
name|char
modifier|*
name|return_value
decl_stmt|;
comment|/* Number of 16-bit words in the format. */
name|int
name|precision
decl_stmt|;
name|long
name|exponent_bits
decl_stmt|;
name|FLONUM_TYPE
name|save_gen_flonum
decl_stmt|;
comment|/* We have to save the generic_floating_point_number because it      contains storage allocation about the array of LITTLENUMs where      the value is actually stored.  We will allocate our own array of      littlenums below, but have to restore the global one on exit.  */
name|save_gen_flonum
operator|=
name|generic_floating_point_number
expr_stmt|;
name|return_value
operator|=
name|str
expr_stmt|;
name|generic_floating_point_number
operator|.
name|low
operator|=
name|bits
operator|+
name|MAX_PRECISION
expr_stmt|;
name|generic_floating_point_number
operator|.
name|high
operator|=
name|NULL
expr_stmt|;
name|generic_floating_point_number
operator|.
name|leader
operator|=
name|NULL
expr_stmt|;
name|generic_floating_point_number
operator|.
name|exponent
operator|=
literal|0
expr_stmt|;
name|generic_floating_point_number
operator|.
name|sign
operator|=
literal|'\0'
expr_stmt|;
comment|/* Use more LittleNums than seems necessary: the highest flonum may      have 15 leading 0 bits, so could be useless. */
name|memset
argument_list|(
name|bits
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
name|LITTLENUM_TYPE
argument_list|)
operator|*
name|MAX_PRECISION
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|what_kind
condition|)
block|{
case|case
literal|'f'
case|:
case|case
literal|'F'
case|:
case|case
literal|'s'
case|:
case|case
literal|'S'
case|:
name|precision
operator|=
name|F_PRECISION
expr_stmt|;
name|exponent_bits
operator|=
literal|8
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
case|case
literal|'D'
case|:
case|case
literal|'r'
case|:
case|case
literal|'R'
case|:
name|precision
operator|=
name|D_PRECISION
expr_stmt|;
name|exponent_bits
operator|=
literal|11
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
case|case
literal|'X'
case|:
case|case
literal|'e'
case|:
case|case
literal|'E'
case|:
name|precision
operator|=
name|X_PRECISION
expr_stmt|;
name|exponent_bits
operator|=
literal|15
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
case|case
literal|'P'
case|:
name|precision
operator|=
name|P_PRECISION
expr_stmt|;
name|exponent_bits
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
default|default:
name|make_invalid_floating_point_number
argument_list|(
name|words
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|generic_floating_point_number
operator|.
name|high
operator|=
name|generic_floating_point_number
operator|.
name|low
operator|+
name|precision
operator|-
literal|1
operator|+
name|GUARD
expr_stmt|;
if|if
condition|(
name|atof_generic
argument_list|(
operator|&
name|return_value
argument_list|,
literal|"."
argument_list|,
name|EXP_CHARS
argument_list|,
operator|&
name|generic_floating_point_number
argument_list|)
condition|)
block|{
name|make_invalid_floating_point_number
argument_list|(
name|words
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|gen_to_words
argument_list|(
name|words
argument_list|,
name|precision
argument_list|,
name|exponent_bits
argument_list|)
expr_stmt|;
comment|/* Restore the generic_floating_point_number's storage alloc (and      everything else).  */
name|generic_floating_point_number
operator|=
name|save_gen_flonum
expr_stmt|;
return|return
name|return_value
return|;
block|}
end_function

begin_comment
comment|/* Turn generic_floating_point_number into a real float/double/extended.  */
end_comment

begin_function
name|int
name|gen_to_words
parameter_list|(
name|words
parameter_list|,
name|precision
parameter_list|,
name|exponent_bits
parameter_list|)
name|LITTLENUM_TYPE
modifier|*
name|words
decl_stmt|;
name|int
name|precision
decl_stmt|;
name|long
name|exponent_bits
decl_stmt|;
block|{
name|int
name|return_value
init|=
literal|0
decl_stmt|;
name|long
name|exponent_1
decl_stmt|;
name|long
name|exponent_2
decl_stmt|;
name|long
name|exponent_3
decl_stmt|;
name|long
name|exponent_4
decl_stmt|;
name|int
name|exponent_skippage
decl_stmt|;
name|LITTLENUM_TYPE
name|word1
decl_stmt|;
name|LITTLENUM_TYPE
modifier|*
name|lp
decl_stmt|;
name|LITTLENUM_TYPE
modifier|*
name|words_end
decl_stmt|;
name|words_end
operator|=
name|words
operator|+
name|precision
expr_stmt|;
ifdef|#
directive|ifdef
name|TC_M68K
if|if
condition|(
name|precision
operator|==
name|X_PRECISION
condition|)
comment|/* On the m68k the extended precision format has a gap of 16 bits        between the exponent and the mantissa.  */
name|words_end
operator|++
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|generic_floating_point_number
operator|.
name|low
operator|>
name|generic_floating_point_number
operator|.
name|leader
condition|)
block|{
comment|/* 0.0e0 seen. */
if|if
condition|(
name|generic_floating_point_number
operator|.
name|sign
operator|==
literal|'+'
condition|)
name|words
index|[
literal|0
index|]
operator|=
literal|0x0000
expr_stmt|;
else|else
name|words
index|[
literal|0
index|]
operator|=
literal|0x8000
expr_stmt|;
name|memset
argument_list|(
operator|&
name|words
index|[
literal|1
index|]
argument_list|,
literal|'\0'
argument_list|,
operator|(
name|words_end
operator|-
name|words
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|LITTLENUM_TYPE
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|return_value
operator|)
return|;
block|}
comment|/* NaN:  Do the right thing */
if|if
condition|(
name|generic_floating_point_number
operator|.
name|sign
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|precision
operator|==
name|F_PRECISION
condition|)
block|{
name|words
index|[
literal|0
index|]
operator|=
literal|0x7fff
expr_stmt|;
name|words
index|[
literal|1
index|]
operator|=
literal|0xffff
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|precision
operator|==
name|X_PRECISION
condition|)
block|{
ifdef|#
directive|ifdef
name|TC_M68K
name|words
index|[
literal|0
index|]
operator|=
literal|0x7fff
expr_stmt|;
name|words
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|words
index|[
literal|2
index|]
operator|=
literal|0xffff
expr_stmt|;
name|words
index|[
literal|3
index|]
operator|=
literal|0xffff
expr_stmt|;
name|words
index|[
literal|4
index|]
operator|=
literal|0xffff
expr_stmt|;
name|words
index|[
literal|5
index|]
operator|=
literal|0xffff
expr_stmt|;
else|#
directive|else
comment|/* ! TC_M68K */
ifdef|#
directive|ifdef
name|TC_I386
name|words
index|[
literal|0
index|]
operator|=
literal|0xffff
expr_stmt|;
name|words
index|[
literal|1
index|]
operator|=
literal|0xc000
expr_stmt|;
name|words
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|words
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
name|words
index|[
literal|4
index|]
operator|=
literal|0
expr_stmt|;
else|#
directive|else
comment|/* ! TC_I386 */
name|abort
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* ! TC_I386 */
endif|#
directive|endif
comment|/* ! TC_M68K */
block|}
else|else
block|{
name|words
index|[
literal|0
index|]
operator|=
literal|0x7fff
expr_stmt|;
name|words
index|[
literal|1
index|]
operator|=
literal|0xffff
expr_stmt|;
name|words
index|[
literal|2
index|]
operator|=
literal|0xffff
expr_stmt|;
name|words
index|[
literal|3
index|]
operator|=
literal|0xffff
expr_stmt|;
block|}
return|return
name|return_value
return|;
block|}
elseif|else
if|if
condition|(
name|generic_floating_point_number
operator|.
name|sign
operator|==
literal|'P'
condition|)
block|{
comment|/* +INF:  Do the right thing */
if|if
condition|(
name|precision
operator|==
name|F_PRECISION
condition|)
block|{
name|words
index|[
literal|0
index|]
operator|=
literal|0x7f80
expr_stmt|;
name|words
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|precision
operator|==
name|X_PRECISION
condition|)
block|{
ifdef|#
directive|ifdef
name|TC_M68K
name|words
index|[
literal|0
index|]
operator|=
literal|0x7fff
expr_stmt|;
name|words
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|words
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|words
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
name|words
index|[
literal|4
index|]
operator|=
literal|0
expr_stmt|;
name|words
index|[
literal|5
index|]
operator|=
literal|0
expr_stmt|;
else|#
directive|else
comment|/* ! TC_M68K */
ifdef|#
directive|ifdef
name|TC_I386
name|words
index|[
literal|0
index|]
operator|=
literal|0x7fff
expr_stmt|;
name|words
index|[
literal|1
index|]
operator|=
literal|0x8000
expr_stmt|;
name|words
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|words
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
name|words
index|[
literal|4
index|]
operator|=
literal|0
expr_stmt|;
else|#
directive|else
comment|/* ! TC_I386 */
name|abort
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* ! TC_I386 */
endif|#
directive|endif
comment|/* ! TC_M68K */
block|}
else|else
block|{
name|words
index|[
literal|0
index|]
operator|=
literal|0x7ff0
expr_stmt|;
name|words
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|words
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|words
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
name|return_value
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|generic_floating_point_number
operator|.
name|sign
operator|==
literal|'N'
condition|)
block|{
comment|/* Negative INF */
if|if
condition|(
name|precision
operator|==
name|F_PRECISION
condition|)
block|{
name|words
index|[
literal|0
index|]
operator|=
literal|0xff80
expr_stmt|;
name|words
index|[
literal|1
index|]
operator|=
literal|0x0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|precision
operator|==
name|X_PRECISION
condition|)
block|{
ifdef|#
directive|ifdef
name|TC_M68K
name|words
index|[
literal|0
index|]
operator|=
literal|0xffff
expr_stmt|;
name|words
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|words
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|words
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
name|words
index|[
literal|4
index|]
operator|=
literal|0
expr_stmt|;
name|words
index|[
literal|5
index|]
operator|=
literal|0
expr_stmt|;
else|#
directive|else
comment|/* ! TC_M68K */
ifdef|#
directive|ifdef
name|TC_I386
name|words
index|[
literal|0
index|]
operator|=
literal|0xffff
expr_stmt|;
name|words
index|[
literal|1
index|]
operator|=
literal|0x8000
expr_stmt|;
name|words
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|words
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
name|words
index|[
literal|4
index|]
operator|=
literal|0
expr_stmt|;
else|#
directive|else
comment|/* ! TC_I386 */
name|abort
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* ! TC_I386 */
endif|#
directive|endif
comment|/* ! TC_M68K */
block|}
else|else
block|{
name|words
index|[
literal|0
index|]
operator|=
literal|0xfff0
expr_stmt|;
name|words
index|[
literal|1
index|]
operator|=
literal|0x0
expr_stmt|;
name|words
index|[
literal|2
index|]
operator|=
literal|0x0
expr_stmt|;
name|words
index|[
literal|3
index|]
operator|=
literal|0x0
expr_stmt|;
block|}
return|return
operator|(
name|return_value
operator|)
return|;
block|}
comment|/*    * The floating point formats we support have:    * Bit 15 is sign bit.    * Bits 14:n are excess-whatever exponent.    * Bits n-1:0 (if any) are most significant bits of fraction.    * Bits 15:0 of the next word(s) are the next most significant bits.    *    * So we need: number of bits of exponent, number of bits of    * mantissa.    */
name|bits_left_in_littlenum
operator|=
name|LITTLENUM_NUMBER_OF_BITS
expr_stmt|;
name|littlenum_pointer
operator|=
name|generic_floating_point_number
operator|.
name|leader
expr_stmt|;
name|littlenums_left
operator|=
operator|(
literal|1
operator|+
name|generic_floating_point_number
operator|.
name|leader
operator|-
name|generic_floating_point_number
operator|.
name|low
operator|)
expr_stmt|;
comment|/* Seek (and forget) 1st significant bit */
for|for
control|(
name|exponent_skippage
operator|=
literal|0
init|;
operator|!
name|next_bits
argument_list|(
literal|1
argument_list|)
condition|;
operator|++
name|exponent_skippage
control|)
empty_stmt|;
empty_stmt|;
name|exponent_1
operator|=
operator|(
name|generic_floating_point_number
operator|.
name|exponent
operator|+
name|generic_floating_point_number
operator|.
name|leader
operator|+
literal|1
operator|-
name|generic_floating_point_number
operator|.
name|low
operator|)
expr_stmt|;
comment|/* Radix LITTLENUM_RADIX, point just higher than      generic_floating_point_number.leader. */
name|exponent_2
operator|=
name|exponent_1
operator|*
name|LITTLENUM_NUMBER_OF_BITS
expr_stmt|;
comment|/* Radix 2. */
name|exponent_3
operator|=
name|exponent_2
operator|-
name|exponent_skippage
expr_stmt|;
comment|/* Forget leading zeros, forget 1st bit. */
name|exponent_4
operator|=
name|exponent_3
operator|+
operator|(
operator|(
literal|1
operator|<<
operator|(
name|exponent_bits
operator|-
literal|1
operator|)
operator|)
operator|-
literal|2
operator|)
expr_stmt|;
comment|/* Offset exponent. */
name|lp
operator|=
name|words
expr_stmt|;
comment|/* Word 1. Sign, exponent and perhaps high bits. */
name|word1
operator|=
operator|(
operator|(
name|generic_floating_point_number
operator|.
name|sign
operator|==
literal|'+'
operator|)
condition|?
literal|0
else|:
operator|(
literal|1
operator|<<
operator|(
name|LITTLENUM_NUMBER_OF_BITS
operator|-
literal|1
operator|)
operator|)
operator|)
expr_stmt|;
comment|/* Assume 2's complement integers. */
if|if
condition|(
name|exponent_4
operator|<=
literal|0
condition|)
block|{
name|int
name|prec_bits
decl_stmt|;
name|int
name|num_bits
decl_stmt|;
name|unget_bits
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|num_bits
operator|=
operator|-
name|exponent_4
expr_stmt|;
name|prec_bits
operator|=
name|LITTLENUM_NUMBER_OF_BITS
operator|*
name|precision
operator|-
operator|(
name|exponent_bits
operator|+
literal|1
operator|+
name|num_bits
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TC_I386
if|if
condition|(
name|precision
operator|==
name|X_PRECISION
operator|&&
name|exponent_bits
operator|==
literal|15
condition|)
block|{
comment|/* On the i386 a denormalized extended precision float is 	     shifted down by one, effectively decreasing the exponent 	     bias by one.  */
name|prec_bits
operator|-=
literal|1
expr_stmt|;
name|num_bits
operator|+=
literal|1
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|num_bits
operator|>=
name|LITTLENUM_NUMBER_OF_BITS
operator|-
name|exponent_bits
condition|)
block|{
comment|/* Bigger than one littlenum */
name|num_bits
operator|-=
operator|(
name|LITTLENUM_NUMBER_OF_BITS
operator|-
literal|1
operator|)
operator|-
name|exponent_bits
expr_stmt|;
operator|*
name|lp
operator|++
operator|=
name|word1
expr_stmt|;
if|if
condition|(
name|num_bits
operator|+
name|exponent_bits
operator|+
literal|1
operator|>=
name|precision
operator|*
name|LITTLENUM_NUMBER_OF_BITS
condition|)
block|{
comment|/* Exponent overflow */
name|make_invalid_floating_point_number
argument_list|(
name|words
argument_list|)
expr_stmt|;
return|return
operator|(
name|return_value
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|TC_M68K
if|if
condition|(
name|precision
operator|==
name|X_PRECISION
operator|&&
name|exponent_bits
operator|==
literal|15
condition|)
operator|*
name|lp
operator|++
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
while|while
condition|(
name|num_bits
operator|>=
name|LITTLENUM_NUMBER_OF_BITS
condition|)
block|{
name|num_bits
operator|-=
name|LITTLENUM_NUMBER_OF_BITS
expr_stmt|;
operator|*
name|lp
operator|++
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|num_bits
condition|)
operator|*
name|lp
operator|++
operator|=
name|next_bits
argument_list|(
name|LITTLENUM_NUMBER_OF_BITS
operator|-
operator|(
name|num_bits
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|precision
operator|==
name|X_PRECISION
operator|&&
name|exponent_bits
operator|==
literal|15
condition|)
block|{
operator|*
name|lp
operator|++
operator|=
name|word1
expr_stmt|;
ifdef|#
directive|ifdef
name|TC_M68K
operator|*
name|lp
operator|++
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
operator|*
name|lp
operator|++
operator|=
name|next_bits
argument_list|(
name|LITTLENUM_NUMBER_OF_BITS
operator|-
name|num_bits
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|word1
operator||=
name|next_bits
argument_list|(
operator|(
name|LITTLENUM_NUMBER_OF_BITS
operator|-
literal|1
operator|)
operator|-
operator|(
name|exponent_bits
operator|+
name|num_bits
operator|)
argument_list|)
expr_stmt|;
operator|*
name|lp
operator|++
operator|=
name|word1
expr_stmt|;
block|}
block|}
while|while
condition|(
name|lp
operator|<
name|words_end
condition|)
operator|*
name|lp
operator|++
operator|=
name|next_bits
argument_list|(
name|LITTLENUM_NUMBER_OF_BITS
argument_list|)
expr_stmt|;
comment|/* Round the mantissa up, but don't change the number */
if|if
condition|(
name|next_bits
argument_list|(
literal|1
argument_list|)
condition|)
block|{
operator|--
name|lp
expr_stmt|;
if|if
condition|(
name|prec_bits
operator|>
name|LITTLENUM_NUMBER_OF_BITS
condition|)
block|{
name|int
name|n
init|=
literal|0
decl_stmt|;
name|int
name|tmp_bits
decl_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
name|tmp_bits
operator|=
name|prec_bits
expr_stmt|;
while|while
condition|(
name|tmp_bits
operator|>
name|LITTLENUM_NUMBER_OF_BITS
condition|)
block|{
if|if
condition|(
name|lp
index|[
name|n
index|]
operator|!=
operator|(
name|LITTLENUM_TYPE
operator|)
operator|-
literal|1
condition|)
break|break;
operator|--
name|n
expr_stmt|;
name|tmp_bits
operator|-=
name|LITTLENUM_NUMBER_OF_BITS
expr_stmt|;
block|}
if|if
condition|(
name|tmp_bits
operator|>
name|LITTLENUM_NUMBER_OF_BITS
operator|||
operator|(
name|lp
index|[
name|n
index|]
operator|&
name|mask
index|[
name|tmp_bits
index|]
operator|)
operator|!=
name|mask
index|[
name|tmp_bits
index|]
condition|)
block|{
name|unsigned
name|long
name|carry
decl_stmt|;
for|for
control|(
name|carry
operator|=
literal|1
init|;
name|carry
operator|&&
operator|(
name|lp
operator|>=
name|words
operator|)
condition|;
name|lp
operator|--
control|)
block|{
name|carry
operator|=
operator|*
name|lp
operator|+
name|carry
expr_stmt|;
operator|*
name|lp
operator|=
name|carry
expr_stmt|;
name|carry
operator|>>=
name|LITTLENUM_NUMBER_OF_BITS
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
operator|(
operator|*
name|lp
operator|&
name|mask
index|[
name|prec_bits
index|]
operator|)
operator|!=
name|mask
index|[
name|prec_bits
index|]
condition|)
operator|*
name|lp
operator|+=
literal|1
expr_stmt|;
block|}
return|return
name|return_value
return|;
block|}
elseif|else
if|if
condition|(
name|exponent_4
operator|>=
name|mask
index|[
name|exponent_bits
index|]
condition|)
block|{
comment|/*        * Exponent overflow. Lose immediately.        */
comment|/*        * We leave return_value alone: admit we read the        * number, but return a floating exception        * because we can't encode the number.        */
name|make_invalid_floating_point_number
argument_list|(
name|words
argument_list|)
expr_stmt|;
return|return
name|return_value
return|;
block|}
else|else
block|{
name|word1
operator||=
operator|(
name|exponent_4
operator|<<
operator|(
operator|(
name|LITTLENUM_NUMBER_OF_BITS
operator|-
literal|1
operator|)
operator|-
name|exponent_bits
operator|)
operator|)
operator||
name|next_bits
argument_list|(
operator|(
name|LITTLENUM_NUMBER_OF_BITS
operator|-
literal|1
operator|)
operator|-
name|exponent_bits
argument_list|)
expr_stmt|;
block|}
operator|*
name|lp
operator|++
operator|=
name|word1
expr_stmt|;
comment|/* X_PRECISION is special: on the 68k, it has 16 bits of zero in the      middle.  Either way, it is then followed by a 1 bit. */
if|if
condition|(
name|exponent_bits
operator|==
literal|15
operator|&&
name|precision
operator|==
name|X_PRECISION
condition|)
block|{
ifdef|#
directive|ifdef
name|TC_M68K
operator|*
name|lp
operator|++
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
operator|*
name|lp
operator|++
operator|=
operator|(
literal|1
operator|<<
operator|(
name|LITTLENUM_NUMBER_OF_BITS
operator|-
literal|1
operator|)
operator||
name|next_bits
argument_list|(
name|LITTLENUM_NUMBER_OF_BITS
operator|-
literal|1
argument_list|)
operator|)
expr_stmt|;
block|}
comment|/* The rest of the words are just mantissa bits. */
while|while
condition|(
name|lp
operator|<
name|words_end
condition|)
operator|*
name|lp
operator|++
operator|=
name|next_bits
argument_list|(
name|LITTLENUM_NUMBER_OF_BITS
argument_list|)
expr_stmt|;
if|if
condition|(
name|next_bits
argument_list|(
literal|1
argument_list|)
condition|)
block|{
name|unsigned
name|long
name|carry
decl_stmt|;
comment|/*        * Since the NEXT bit is a 1, round UP the mantissa.        * The cunning design of these hidden-1 floats permits        * us to let the mantissa overflow into the exponent, and        * it 'does the right thing'. However, we lose if the        * highest-order bit of the lowest-order word flips.        * Is that clear?        */
comment|/* #if (sizeof(carry))< ((sizeof(bits[0]) * BITS_PER_CHAR) + 2) 	 Please allow at least 1 more bit in carry than is in a LITTLENUM. 	 We need that extra bit to hold a carry during a LITTLENUM carry 	 propagation. Another extra bit (kept 0) will assure us that we 	 don't get a sticky sign bit after shifting right, and that 	 permits us to propagate the carry without any masking of bits. 	 #endif */
for|for
control|(
name|carry
operator|=
literal|1
operator|,
name|lp
operator|--
init|;
name|carry
operator|&&
operator|(
name|lp
operator|>=
name|words
operator|)
condition|;
name|lp
operator|--
control|)
block|{
name|carry
operator|=
operator|*
name|lp
operator|+
name|carry
expr_stmt|;
operator|*
name|lp
operator|=
name|carry
expr_stmt|;
name|carry
operator|>>=
name|LITTLENUM_NUMBER_OF_BITS
expr_stmt|;
block|}
if|if
condition|(
name|precision
operator|==
name|X_PRECISION
operator|&&
name|exponent_bits
operator|==
literal|15
condition|)
block|{
comment|/* Extended precision numbers have an explicit integer bit 	     that we may have to restore.  */
if|if
condition|(
name|lp
operator|==
name|words
condition|)
block|{
ifdef|#
directive|ifdef
name|TC_M68K
comment|/* On the m68k there is a gap of 16 bits.  We must 		 explicitly propagate the carry into the exponent. */
name|words
index|[
literal|0
index|]
operator|+=
name|words
index|[
literal|1
index|]
expr_stmt|;
name|words
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|lp
operator|++
expr_stmt|;
endif|#
directive|endif
comment|/* Put back the integer bit.  */
name|lp
index|[
literal|1
index|]
operator||=
literal|1
operator|<<
operator|(
name|LITTLENUM_NUMBER_OF_BITS
operator|-
literal|1
operator|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|word1
operator|^
operator|*
name|words
operator|)
operator|&
operator|(
literal|1
operator|<<
operator|(
name|LITTLENUM_NUMBER_OF_BITS
operator|-
literal|1
operator|)
operator|)
condition|)
block|{
comment|/* We leave return_value alone: admit we read the 	   * number, but return a floating exception 	   * because we can't encode the number. 	   */
operator|*
name|words
operator|&=
operator|~
operator|(
literal|1
operator|<<
operator|(
name|LITTLENUM_NUMBER_OF_BITS
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
comment|/* make_invalid_floating_point_number (words); */
comment|/* return return_value; */
block|}
block|}
return|return
operator|(
name|return_value
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* unused */
end_comment

begin_comment
comment|/* This routine is a real kludge.  Someone really should do it better,    but I'm too lazy, and I don't understand this stuff all too well    anyway. (JF)  */
end_comment

begin_endif
unit|static void int_to_gen (x)      long x; {   char buf[20];   char *bufp;    sprintf (buf, "%ld", x);   bufp =&buf[0];   if (atof_generic (&bufp, ".", EXP_CHARS,&generic_floating_point_number))     as_bad ("Error converting number to floating point (Exponent overflow?)"); }
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|TEST
end_ifdef

begin_function
name|char
modifier|*
name|print_gen
parameter_list|(
name|gen
parameter_list|)
name|FLONUM_TYPE
modifier|*
name|gen
decl_stmt|;
block|{
name|FLONUM_TYPE
name|f
decl_stmt|;
name|LITTLENUM_TYPE
name|arr
index|[
literal|10
index|]
decl_stmt|;
name|double
name|dv
decl_stmt|;
name|float
name|fv
decl_stmt|;
specifier|static
name|char
name|sbuf
index|[
literal|40
index|]
decl_stmt|;
if|if
condition|(
name|gen
condition|)
block|{
name|f
operator|=
name|generic_floating_point_number
expr_stmt|;
name|generic_floating_point_number
operator|=
operator|*
name|gen
expr_stmt|;
block|}
name|gen_to_words
argument_list|(
operator|&
name|arr
index|[
literal|0
index|]
argument_list|,
literal|4
argument_list|,
literal|11
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|dv
argument_list|,
operator|&
name|arr
index|[
literal|0
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|double
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|sbuf
argument_list|,
literal|"%x %x %x %x %.14G   "
argument_list|,
name|arr
index|[
literal|0
index|]
argument_list|,
name|arr
index|[
literal|1
index|]
argument_list|,
name|arr
index|[
literal|2
index|]
argument_list|,
name|arr
index|[
literal|3
index|]
argument_list|,
name|dv
argument_list|)
expr_stmt|;
name|gen_to_words
argument_list|(
operator|&
name|arr
index|[
literal|0
index|]
argument_list|,
literal|2
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|fv
argument_list|,
operator|&
name|arr
index|[
literal|0
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|float
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|sbuf
operator|+
name|strlen
argument_list|(
name|sbuf
argument_list|)
argument_list|,
literal|"%x %x %.12g\n"
argument_list|,
name|arr
index|[
literal|0
index|]
argument_list|,
name|arr
index|[
literal|1
index|]
argument_list|,
name|fv
argument_list|)
expr_stmt|;
if|if
condition|(
name|gen
condition|)
block|{
name|generic_floating_point_number
operator|=
name|f
expr_stmt|;
block|}
return|return
operator|(
name|sbuf
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* end of atof-ieee.c */
end_comment

end_unit

