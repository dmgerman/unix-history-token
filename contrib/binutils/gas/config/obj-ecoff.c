begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* ECOFF object file format.    Copyright (C) 1993, 94, 95, 96, 1997 Free Software Foundation, Inc.    Contributed by Cygnus Support.    This file was put together by Ian Lance Taylor<ian@cygnus.com>.     This file is part of GAS.     GAS is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     GAS is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with GAS; see the file COPYING.  If not, write to the Free    Software Foundation, 59 Temple Place - Suite 330, Boston, MA    02111-1307, USA.  */
end_comment

begin_define
define|#
directive|define
name|OBJ_HEADER
value|"obj-ecoff.h"
end_define

begin_include
include|#
directive|include
file|"as.h"
end_include

begin_include
include|#
directive|include
file|"coff/internal.h"
end_include

begin_include
include|#
directive|include
file|"bfd/libcoff.h"
end_include

begin_include
include|#
directive|include
file|"bfd/libecoff.h"
end_include

begin_comment
comment|/* Almost all of the ECOFF support is actually in ecoff.c in the main    gas directory.  This file mostly just arranges to call that one at    the right times.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|ecoff_sec_sym_ok_for_reloc
name|PARAMS
argument_list|(
operator|(
name|asection
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|obj_ecoff_frob_symbol
name|PARAMS
argument_list|(
operator|(
name|symbolS
operator|*
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ecoff_pop_insert
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* These are the pseudo-ops we support in this file.  Only those    relating to debugging information are supported here.     The following pseudo-ops from the Kane and Heinrich MIPS book    should be defined here, but are currently unsupported: .aent,    .bgnb, .endb, .verstamp, .vreg.     The following pseudo-ops from the Kane and Heinrich MIPS book are    MIPS CPU specific, and should be defined by tc-mips.c: .alias,    .extern, .galive, .gjaldef, .gjrlive, .livereg, .noalias, .option,    .rdata, .sdata, .set.     The following pseudo-ops from the Kane and Heinrich MIPS book are    not MIPS CPU specific, but are also not ECOFF specific.  I have    only listed the ones which are not already in read.c.  It's not    completely clear where these should be defined, but tc-mips.c is    probably the most reasonable place: .asciiz, .asm0, .endr, .err,    .half, .lab, .repeat, .struct, .weakext.  */
end_comment

begin_decl_stmt
specifier|const
name|pseudo_typeS
name|obj_pseudo_table
index|[]
init|=
block|{
comment|/* COFF style debugging information. .ln is not used; .loc is used      instead.  */
block|{
literal|"def"
block|,
name|ecoff_directive_def
block|,
literal|0
block|}
block|,
block|{
literal|"dim"
block|,
name|ecoff_directive_dim
block|,
literal|0
block|}
block|,
block|{
literal|"endef"
block|,
name|ecoff_directive_endef
block|,
literal|0
block|}
block|,
block|{
literal|"file"
block|,
name|ecoff_directive_file
block|,
literal|0
block|}
block|,
block|{
literal|"scl"
block|,
name|ecoff_directive_scl
block|,
literal|0
block|}
block|,
block|{
literal|"size"
block|,
name|ecoff_directive_size
block|,
literal|0
block|}
block|,
block|{
literal|"esize"
block|,
name|ecoff_directive_size
block|,
literal|0
block|}
block|,
block|{
literal|"tag"
block|,
name|ecoff_directive_tag
block|,
literal|0
block|}
block|,
block|{
literal|"type"
block|,
name|ecoff_directive_type
block|,
literal|0
block|}
block|,
block|{
literal|"etype"
block|,
name|ecoff_directive_type
block|,
literal|0
block|}
block|,
block|{
literal|"val"
block|,
name|ecoff_directive_val
block|,
literal|0
block|}
block|,
comment|/* ECOFF specific debugging information.  */
block|{
literal|"begin"
block|,
name|ecoff_directive_begin
block|,
literal|0
block|}
block|,
block|{
literal|"bend"
block|,
name|ecoff_directive_bend
block|,
literal|0
block|}
block|,
block|{
literal|"end"
block|,
name|ecoff_directive_end
block|,
literal|0
block|}
block|,
block|{
literal|"ent"
block|,
name|ecoff_directive_ent
block|,
literal|0
block|}
block|,
block|{
literal|"fmask"
block|,
name|ecoff_directive_fmask
block|,
literal|0
block|}
block|,
block|{
literal|"frame"
block|,
name|ecoff_directive_frame
block|,
literal|0
block|}
block|,
block|{
literal|"loc"
block|,
name|ecoff_directive_loc
block|,
literal|0
block|}
block|,
block|{
literal|"mask"
block|,
name|ecoff_directive_mask
block|,
literal|0
block|}
block|,
comment|/* Other ECOFF directives.  */
block|{
literal|"extern"
block|,
name|ecoff_directive_extern
block|,
literal|0
block|}
block|,
block|{
literal|"weakext"
block|,
name|ecoff_directive_weakext
block|,
literal|0
block|}
block|,
comment|/* These are used on Irix.  I don't know how to implement them.  */
block|{
literal|"bgnb"
block|,
name|s_ignore
block|,
literal|0
block|}
block|,
block|{
literal|"endb"
block|,
name|s_ignore
block|,
literal|0
block|}
block|,
block|{
literal|"verstamp"
block|,
name|s_ignore
block|,
literal|0
block|}
block|,
comment|/* Sentinel.  */
block|{
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Swap out the symbols and debugging information for BFD.  */
end_comment

begin_function
name|void
name|ecoff_frob_file
parameter_list|()
block|{
specifier|const
name|struct
name|ecoff_debug_swap
modifier|*
specifier|const
name|debug_swap
init|=
operator|&
name|ecoff_backend
argument_list|(
name|stdoutput
argument_list|)
operator|->
name|debug_swap
decl_stmt|;
name|bfd_vma
name|addr
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|HDRR
modifier|*
name|hdr
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|char
modifier|*
name|set
decl_stmt|;
comment|/* Set the section VMA values.  We force the .sdata and .sbss      sections to the end to ensure that their VMA addresses are close      together so that the GP register can address both of them.  We      put the .bss section after the .sbss section.       Also, for the Alpha, we must sort the sections, to make sure they      appear in the output file in the correct order.  (Actually, maybe      this is a job for BFD.  But the VMAs computed would be out of      whack if we computed them given our initial, random ordering.      It's possible that that wouldn't break things; I could do some      experimenting sometime and find out.       This output ordering of sections is magic, on the Alpha, at      least.  The .lita section must come before .lit8 and .lit4,      otherwise the OSF/1 linker may silently trash the .lit{4,8}      section contents.  Also, .text must preceed .rdata.  These differ      from the order described in some parts of the DEC OSF/1 Assembly      Language Programmer's Guide, but that order doesn't seem to work      with their linker.       I don't know if section ordering on the MIPS is important.  */
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|names
index|[]
init|=
block|{
comment|/* text segment */
literal|".text"
block|,
literal|".rdata"
block|,
literal|".init"
block|,
literal|".fini"
block|,
comment|/* data segment */
literal|".data"
block|,
literal|".lita"
block|,
literal|".lit8"
block|,
literal|".lit4"
block|,
literal|".sdata"
block|,
literal|".got"
block|,
comment|/* bss segment */
literal|".sbss"
block|,
literal|".bss"
block|,   }
decl_stmt|;
define|#
directive|define
name|n_names
value|(sizeof (names) / sizeof (names[0]))
name|addr
operator|=
literal|0
expr_stmt|;
block|{
comment|/* Sections that match names, order to be straightened out later.  */
name|asection
modifier|*
name|secs
index|[
name|n_names
index|]
decl_stmt|;
comment|/* Linked list of sections with non-matching names.  Random ordering.  */
name|asection
modifier|*
name|other_sections
init|=
literal|0
decl_stmt|;
comment|/* Pointer to next section, since we're destroying the original        ordering.  */
name|asection
modifier|*
name|next
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_names
condition|;
name|i
operator|++
control|)
name|secs
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|sec
operator|=
name|stdoutput
operator|->
name|sections
init|;
name|sec
operator|!=
operator|(
name|asection
operator|*
operator|)
name|NULL
condition|;
name|sec
operator|=
name|next
control|)
block|{
name|next
operator|=
name|sec
operator|->
name|next
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_names
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|sec
operator|->
name|name
argument_list|,
name|names
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|secs
index|[
name|i
index|]
operator|=
name|sec
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|i
operator|==
name|n_names
condition|)
block|{
name|bfd_set_section_vma
argument_list|(
name|stdoutput
argument_list|,
name|sec
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|addr
operator|+=
name|bfd_section_size
argument_list|(
name|stdoutput
argument_list|,
name|sec
argument_list|)
expr_stmt|;
name|sec
operator|->
name|next
operator|=
name|other_sections
expr_stmt|;
name|other_sections
operator|=
name|sec
expr_stmt|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_names
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|secs
index|[
name|i
index|]
condition|)
block|{
name|sec
operator|=
name|secs
index|[
name|i
index|]
expr_stmt|;
name|bfd_set_section_vma
argument_list|(
name|stdoutput
argument_list|,
name|sec
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|addr
operator|+=
name|bfd_section_size
argument_list|(
name|stdoutput
argument_list|,
name|sec
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
name|n_names
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|secs
index|[
name|i
index|]
condition|)
block|{
name|sec
operator|=
name|secs
index|[
name|i
index|]
expr_stmt|;
name|sec
operator|->
name|next
operator|=
name|other_sections
expr_stmt|;
name|other_sections
operator|=
name|sec
expr_stmt|;
block|}
name|stdoutput
operator|->
name|sections
operator|=
name|other_sections
expr_stmt|;
block|}
comment|/* Build the ECOFF debugging information.  */
name|assert
argument_list|(
name|ecoff_data
argument_list|(
name|stdoutput
argument_list|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|hdr
operator|=
operator|&
name|ecoff_data
argument_list|(
name|stdoutput
argument_list|)
operator|->
name|debug_info
operator|.
name|symbolic_header
expr_stmt|;
name|ecoff_build_debug
argument_list|(
name|hdr
argument_list|,
operator|&
name|buf
argument_list|,
name|debug_swap
argument_list|)
expr_stmt|;
comment|/* Finish up the ecoff_tdata structure.  */
name|set
operator|=
name|buf
expr_stmt|;
define|#
directive|define
name|SET
parameter_list|(
name|ptr
parameter_list|,
name|count
parameter_list|,
name|type
parameter_list|,
name|size
parameter_list|)
define|\
value|if (hdr->count == 0) \     ecoff_data (stdoutput)->debug_info.ptr = (type) NULL; \   else \     { \       ecoff_data (stdoutput)->debug_info.ptr = (type) set; \       set += hdr->count * size; \     }
name|SET
argument_list|(
argument|line
argument_list|,
argument|cbLine
argument_list|,
argument|unsigned char *
argument_list|,
argument|sizeof (unsigned char)
argument_list|)
empty_stmt|;
name|SET
argument_list|(
name|external_dnr
argument_list|,
name|idnMax
argument_list|,
name|PTR
argument_list|,
name|debug_swap
operator|->
name|external_dnr_size
argument_list|)
expr_stmt|;
name|SET
argument_list|(
name|external_pdr
argument_list|,
name|ipdMax
argument_list|,
name|PTR
argument_list|,
name|debug_swap
operator|->
name|external_pdr_size
argument_list|)
expr_stmt|;
name|SET
argument_list|(
name|external_sym
argument_list|,
name|isymMax
argument_list|,
name|PTR
argument_list|,
name|debug_swap
operator|->
name|external_sym_size
argument_list|)
expr_stmt|;
name|SET
argument_list|(
name|external_opt
argument_list|,
name|ioptMax
argument_list|,
name|PTR
argument_list|,
name|debug_swap
operator|->
name|external_opt_size
argument_list|)
expr_stmt|;
name|SET
argument_list|(
name|external_aux
argument_list|,
name|iauxMax
argument_list|,
expr|union
name|aux_ext
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
expr|union
name|aux_ext
argument_list|)
argument_list|)
expr_stmt|;
name|SET
argument_list|(
name|ss
argument_list|,
name|issMax
argument_list|,
name|char
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
name|SET
argument_list|(
name|ssext
argument_list|,
name|issExtMax
argument_list|,
name|char
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
name|SET
argument_list|(
name|external_rfd
argument_list|,
name|crfd
argument_list|,
name|PTR
argument_list|,
name|debug_swap
operator|->
name|external_rfd_size
argument_list|)
expr_stmt|;
name|SET
argument_list|(
name|external_fdr
argument_list|,
name|ifdMax
argument_list|,
name|PTR
argument_list|,
name|debug_swap
operator|->
name|external_fdr_size
argument_list|)
expr_stmt|;
name|SET
argument_list|(
name|external_ext
argument_list|,
name|iextMax
argument_list|,
name|PTR
argument_list|,
name|debug_swap
operator|->
name|external_ext_size
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|SET
comment|/* Fill in the register masks.  */
block|{
name|unsigned
name|long
name|gprmask
init|=
literal|0
decl_stmt|;
name|unsigned
name|long
name|fprmask
init|=
literal|0
decl_stmt|;
name|unsigned
name|long
modifier|*
name|cprmask
init|=
name|NULL
decl_stmt|;
ifdef|#
directive|ifdef
name|TC_MIPS
comment|/* Fill in the MIPS register masks.  It's probably not worth        setting up a generic interface for this.  */
name|gprmask
operator|=
name|mips_gprmask
expr_stmt|;
name|cprmask
operator|=
name|mips_cprmask
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TC_ALPHA
name|alpha_frob_ecoff_data
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_ecoff_set_gp_value
argument_list|(
name|stdoutput
argument_list|,
name|alpha_gp_value
argument_list|)
condition|)
name|as_fatal
argument_list|(
literal|"Can't set GP value"
argument_list|)
expr_stmt|;
name|gprmask
operator|=
name|alpha_gprmask
expr_stmt|;
name|fprmask
operator|=
name|alpha_fprmask
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|bfd_ecoff_set_regmasks
argument_list|(
name|stdoutput
argument_list|,
name|gprmask
argument_list|,
name|fprmask
argument_list|,
name|cprmask
argument_list|)
condition|)
name|as_fatal
argument_list|(
literal|"Can't set register masks"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* This is called by the ECOFF code to set the external information    for a symbol.  We just pass it on to BFD, which expects the swapped    information to be stored in the native field of the symbol.  */
end_comment

begin_function
name|void
name|obj_ecoff_set_ext
parameter_list|(
name|sym
parameter_list|,
name|ext
parameter_list|)
name|symbolS
modifier|*
name|sym
decl_stmt|;
name|EXTR
modifier|*
name|ext
decl_stmt|;
block|{
specifier|const
name|struct
name|ecoff_debug_swap
modifier|*
specifier|const
name|debug_swap
init|=
operator|&
name|ecoff_backend
argument_list|(
name|stdoutput
argument_list|)
operator|->
name|debug_swap
decl_stmt|;
name|ecoff_symbol_type
modifier|*
name|esym
decl_stmt|;
name|know
argument_list|(
name|bfd_asymbol_flavour
argument_list|(
name|sym
operator|->
name|bsym
argument_list|)
operator|==
name|bfd_target_ecoff_flavour
argument_list|)
expr_stmt|;
name|esym
operator|=
name|ecoffsymbol
argument_list|(
name|sym
operator|->
name|bsym
argument_list|)
expr_stmt|;
name|esym
operator|->
name|local
operator|=
name|false
expr_stmt|;
name|esym
operator|->
name|native
operator|=
name|xmalloc
argument_list|(
name|debug_swap
operator|->
name|external_ext_size
argument_list|)
expr_stmt|;
call|(
modifier|*
name|debug_swap
operator|->
name|swap_ext_out
call|)
argument_list|(
name|stdoutput
argument_list|,
name|ext
argument_list|,
name|esym
operator|->
name|native
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|ecoff_sec_sym_ok_for_reloc
parameter_list|(
name|sec
parameter_list|)
name|asection
modifier|*
name|sec
decl_stmt|;
block|{
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|obj_ecoff_frob_symbol
parameter_list|(
name|sym
parameter_list|,
name|puntp
parameter_list|)
name|symbolS
modifier|*
name|sym
decl_stmt|;
name|int
modifier|*
name|puntp
decl_stmt|;
block|{
name|ecoff_frob_symbol
argument_list|(
name|sym
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ecoff_pop_insert
parameter_list|()
block|{
name|pop_insert
argument_list|(
name|obj_pseudo_table
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|const
name|struct
name|format_ops
name|ecoff_format_ops
init|=
block|{
name|bfd_target_ecoff_flavour
block|,
literal|0
block|,
literal|1
block|,
name|obj_ecoff_frob_symbol
block|,
name|ecoff_frob_file
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|ecoff_generate_asm_lineno
block|,
name|ecoff_stab
block|,
name|ecoff_sec_sym_ok_for_reloc
block|,
name|ecoff_pop_insert
block|,
name|ecoff_set_ext
block|,
name|ecoff_read_begin_hook
block|,
name|ecoff_symbol_new_hook
block|, }
decl_stmt|;
end_decl_stmt

end_unit

