begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* coff object file format    Copyright 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998,    1999, 2000, 2001    Free Software Foundation, Inc.     This file is part of GAS.     GAS is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     GAS is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with GAS; see the file COPYING.  If not, write to the Free    Software Foundation, 59 Temple Place - Suite 330, Boston, MA    02111-1307, USA.  */
end_comment

begin_define
define|#
directive|define
name|OBJ_HEADER
value|"obj-coff.h"
end_define

begin_include
include|#
directive|include
file|"as.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_include
include|#
directive|include
file|"subsegs.h"
end_include

begin_comment
comment|/* I think this is probably always correct.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|KEEP_RELOC_INFO
end_ifndef

begin_define
define|#
directive|define
name|KEEP_RELOC_INFO
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* The BFD_ASSEMBLER version of obj_coff_section will use this macro to set    a new section's attributes when a directive has no valid flags or the    "w" flag is used. This default should be appropriate for most.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|TC_COFF_SECTION_DEFAULT_ATTRIBUTES
end_ifndef

begin_define
define|#
directive|define
name|TC_COFF_SECTION_DEFAULT_ATTRIBUTES
value|(SEC_LOAD | SEC_DATA)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|void
name|obj_coff_bss
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
modifier|*
name|s_get_name
name|PARAMS
argument_list|(
operator|(
name|symbolS
operator|*
name|s
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|obj_coff_ln
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|obj_coff_def
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|obj_coff_endef
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|obj_coff_dim
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|obj_coff_line
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|obj_coff_size
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|obj_coff_scl
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|obj_coff_tag
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|obj_coff_val
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|obj_coff_type
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|obj_coff_ident
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|BFD_ASSEMBLER
end_ifdef

begin_decl_stmt
specifier|static
name|void
name|obj_coff_loc
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* This is used to hold the symbol built by a sequence of pseudo-ops    from .def and .endef.  */
end_comment

begin_decl_stmt
specifier|static
name|symbolS
modifier|*
name|def_symbol_in_progress
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* stack stuff */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|unsigned
name|long
name|chunk_size
decl_stmt|;
name|unsigned
name|long
name|element_size
decl_stmt|;
name|unsigned
name|long
name|size
decl_stmt|;
name|char
modifier|*
name|data
decl_stmt|;
name|unsigned
name|long
name|pointer
decl_stmt|;
block|}
name|stack
typedef|;
end_typedef

begin_function
specifier|static
name|stack
modifier|*
name|stack_init
parameter_list|(
name|chunk_size
parameter_list|,
name|element_size
parameter_list|)
name|unsigned
name|long
name|chunk_size
decl_stmt|;
name|unsigned
name|long
name|element_size
decl_stmt|;
block|{
name|stack
modifier|*
name|st
decl_stmt|;
name|st
operator|=
operator|(
name|stack
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|stack
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|st
condition|)
return|return
literal|0
return|;
name|st
operator|->
name|data
operator|=
name|malloc
argument_list|(
name|chunk_size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|st
operator|->
name|data
condition|)
block|{
name|free
argument_list|(
name|st
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|st
operator|->
name|pointer
operator|=
literal|0
expr_stmt|;
name|st
operator|->
name|size
operator|=
name|chunk_size
expr_stmt|;
name|st
operator|->
name|chunk_size
operator|=
name|chunk_size
expr_stmt|;
name|st
operator|->
name|element_size
operator|=
name|element_size
expr_stmt|;
return|return
name|st
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* Not currently used.  */
end_comment

begin_endif
unit|static void stack_delete (st)      stack *st; {   free (st->data);   free (st); }
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|char
modifier|*
name|stack_push
parameter_list|(
name|st
parameter_list|,
name|element
parameter_list|)
name|stack
modifier|*
name|st
decl_stmt|;
name|char
modifier|*
name|element
decl_stmt|;
block|{
if|if
condition|(
name|st
operator|->
name|pointer
operator|+
name|st
operator|->
name|element_size
operator|>=
name|st
operator|->
name|size
condition|)
block|{
name|st
operator|->
name|size
operator|+=
name|st
operator|->
name|chunk_size
expr_stmt|;
if|if
condition|(
operator|(
name|st
operator|->
name|data
operator|=
name|xrealloc
argument_list|(
name|st
operator|->
name|data
argument_list|,
name|st
operator|->
name|size
argument_list|)
operator|)
operator|==
operator|(
name|char
operator|*
operator|)
literal|0
condition|)
return|return
operator|(
name|char
operator|*
operator|)
literal|0
return|;
block|}
name|memcpy
argument_list|(
name|st
operator|->
name|data
operator|+
name|st
operator|->
name|pointer
argument_list|,
name|element
argument_list|,
name|st
operator|->
name|element_size
argument_list|)
expr_stmt|;
name|st
operator|->
name|pointer
operator|+=
name|st
operator|->
name|element_size
expr_stmt|;
return|return
name|st
operator|->
name|data
operator|+
name|st
operator|->
name|pointer
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|stack_pop
parameter_list|(
name|st
parameter_list|)
name|stack
modifier|*
name|st
decl_stmt|;
block|{
if|if
condition|(
name|st
operator|->
name|pointer
operator|<
name|st
operator|->
name|element_size
condition|)
block|{
name|st
operator|->
name|pointer
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|char
operator|*
operator|)
literal|0
return|;
block|}
name|st
operator|->
name|pointer
operator|-=
name|st
operator|->
name|element_size
expr_stmt|;
return|return
name|st
operator|->
name|data
operator|+
name|st
operator|->
name|pointer
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  * Maintain a list of the tagnames of the structres.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|hash_control
modifier|*
name|tag_hash
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|tag_init
parameter_list|()
block|{
name|tag_hash
operator|=
name|hash_new
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|tag_insert
parameter_list|(
name|name
parameter_list|,
name|symbolP
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|error_string
decl_stmt|;
if|if
condition|(
operator|(
name|error_string
operator|=
name|hash_jam
argument_list|(
name|tag_hash
argument_list|,
name|name
argument_list|,
operator|(
name|char
operator|*
operator|)
name|symbolP
argument_list|)
operator|)
condition|)
block|{
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"Inserting \"%s\" into structure table failed: %s"
argument_list|)
argument_list|,
name|name
argument_list|,
name|error_string
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|symbolS
modifier|*
name|tag_find
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|STRIP_UNDERSCORE
if|if
condition|(
operator|*
name|name
operator|==
literal|'_'
condition|)
name|name
operator|++
expr_stmt|;
endif|#
directive|endif
comment|/* STRIP_UNDERSCORE */
return|return
operator|(
name|symbolS
operator|*
operator|)
name|hash_find
argument_list|(
name|tag_hash
argument_list|,
name|name
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|symbolS
modifier|*
name|tag_find_or_make
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
if|if
condition|(
operator|(
name|symbolP
operator|=
name|tag_find
argument_list|(
name|name
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|symbolP
operator|=
name|symbol_new
argument_list|(
name|name
argument_list|,
name|undefined_section
argument_list|,
literal|0
argument_list|,
operator|&
name|zero_address_frag
argument_list|)
expr_stmt|;
name|tag_insert
argument_list|(
name|S_GET_NAME
argument_list|(
name|symbolP
argument_list|)
argument_list|,
name|symbolP
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|BFD_ASSEMBLER
name|symbol_table_insert
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* not found */
return|return
name|symbolP
return|;
block|}
end_function

begin_comment
comment|/* We accept the .bss directive to set the section for backward    compatibility with earlier versions of gas.  */
end_comment

begin_function
specifier|static
name|void
name|obj_coff_bss
parameter_list|(
name|ignore
parameter_list|)
name|int
name|ignore
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|'\n'
condition|)
name|subseg_new
argument_list|(
literal|".bss"
argument_list|,
name|get_absolute_expression
argument_list|()
argument_list|)
expr_stmt|;
else|else
name|s_lcomm
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle .weak.  This is a GNU extension.  */
end_comment

begin_function
specifier|static
name|void
name|obj_coff_weak
parameter_list|(
name|ignore
parameter_list|)
name|int
name|ignore
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|c
decl_stmt|;
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
do|do
block|{
name|name
operator|=
name|input_line_pointer
expr_stmt|;
name|c
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
name|symbolP
operator|=
name|symbol_find_or_make
argument_list|(
name|name
argument_list|)
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|#
directive|if
name|defined
name|BFD_ASSEMBLER
operator|||
name|defined
name|S_SET_WEAK
name|S_SET_WEAK
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TE_PE
name|S_SET_STORAGE_CLASS
argument_list|(
name|symbolP
argument_list|,
name|C_NT_WEAK
argument_list|)
expr_stmt|;
else|#
directive|else
name|S_SET_STORAGE_CLASS
argument_list|(
name|symbolP
argument_list|,
name|C_WEAKEXT
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|c
operator|==
literal|','
condition|)
block|{
name|input_line_pointer
operator|++
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|'\n'
condition|)
name|c
operator|=
literal|'\n'
expr_stmt|;
block|}
block|}
do|while
condition|(
name|c
operator|==
literal|','
condition|)
do|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|BFD_ASSEMBLER
end_ifdef

begin_decl_stmt
specifier|static
name|void
name|SA_SET_SYM_TAGNDX
name|PARAMS
argument_list|(
operator|(
name|symbolS
operator|*
operator|,
name|symbolS
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|GET_FILENAME_STRING
parameter_list|(
name|X
parameter_list|)
define|\
value|((char*) (&((X)->sy_symbol.ost_auxent->x_file.x_n.x_offset))[1])
end_define

begin_comment
comment|/* @@ Ick.  */
end_comment

begin_function
specifier|static
name|segT
name|fetch_coff_debug_section
parameter_list|()
block|{
specifier|static
name|segT
name|debug_section
decl_stmt|;
if|if
condition|(
operator|!
name|debug_section
condition|)
block|{
name|CONST
name|asymbol
modifier|*
name|s
decl_stmt|;
name|s
operator|=
name|bfd_make_debug_symbol
argument_list|(
name|stdoutput
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|s
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|debug_section
operator|=
name|s
operator|->
name|section
expr_stmt|;
block|}
return|return
name|debug_section
return|;
block|}
end_function

begin_function
name|void
name|SA_SET_SYM_ENDNDX
parameter_list|(
name|sym
parameter_list|,
name|val
parameter_list|)
name|symbolS
modifier|*
name|sym
decl_stmt|;
name|symbolS
modifier|*
name|val
decl_stmt|;
block|{
name|combined_entry_type
modifier|*
name|entry
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|entry
operator|=
operator|&
name|coffsymbol
argument_list|(
name|symbol_get_bfdsym
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|->
name|native
index|[
literal|1
index|]
expr_stmt|;
name|p
operator|=
name|coffsymbol
argument_list|(
name|symbol_get_bfdsym
argument_list|(
name|val
argument_list|)
argument_list|)
operator|->
name|native
expr_stmt|;
name|entry
operator|->
name|u
operator|.
name|auxent
operator|.
name|x_sym
operator|.
name|x_fcnary
operator|.
name|x_fcn
operator|.
name|x_endndx
operator|.
name|p
operator|=
name|p
expr_stmt|;
name|entry
operator|->
name|fix_end
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|SA_SET_SYM_TAGNDX
parameter_list|(
name|sym
parameter_list|,
name|val
parameter_list|)
name|symbolS
modifier|*
name|sym
decl_stmt|;
name|symbolS
modifier|*
name|val
decl_stmt|;
block|{
name|combined_entry_type
modifier|*
name|entry
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|entry
operator|=
operator|&
name|coffsymbol
argument_list|(
name|symbol_get_bfdsym
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|->
name|native
index|[
literal|1
index|]
expr_stmt|;
name|p
operator|=
name|coffsymbol
argument_list|(
name|symbol_get_bfdsym
argument_list|(
name|val
argument_list|)
argument_list|)
operator|->
name|native
expr_stmt|;
name|entry
operator|->
name|u
operator|.
name|auxent
operator|.
name|x_sym
operator|.
name|x_tagndx
operator|.
name|p
operator|=
name|p
expr_stmt|;
name|entry
operator|->
name|fix_tag
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|S_GET_DATA_TYPE
parameter_list|(
name|sym
parameter_list|)
name|symbolS
modifier|*
name|sym
decl_stmt|;
block|{
return|return
name|coffsymbol
argument_list|(
name|symbol_get_bfdsym
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|->
name|native
operator|->
name|u
operator|.
name|syment
operator|.
name|n_type
return|;
block|}
end_function

begin_function
name|int
name|S_SET_DATA_TYPE
parameter_list|(
name|sym
parameter_list|,
name|val
parameter_list|)
name|symbolS
modifier|*
name|sym
decl_stmt|;
name|int
name|val
decl_stmt|;
block|{
name|coffsymbol
argument_list|(
name|symbol_get_bfdsym
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|->
name|native
operator|->
name|u
operator|.
name|syment
operator|.
name|n_type
operator|=
name|val
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_function
name|int
name|S_GET_STORAGE_CLASS
parameter_list|(
name|sym
parameter_list|)
name|symbolS
modifier|*
name|sym
decl_stmt|;
block|{
return|return
name|coffsymbol
argument_list|(
name|symbol_get_bfdsym
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|->
name|native
operator|->
name|u
operator|.
name|syment
operator|.
name|n_sclass
return|;
block|}
end_function

begin_function
name|int
name|S_SET_STORAGE_CLASS
parameter_list|(
name|sym
parameter_list|,
name|val
parameter_list|)
name|symbolS
modifier|*
name|sym
decl_stmt|;
name|int
name|val
decl_stmt|;
block|{
name|coffsymbol
argument_list|(
name|symbol_get_bfdsym
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|->
name|native
operator|->
name|u
operator|.
name|syment
operator|.
name|n_sclass
operator|=
name|val
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_comment
comment|/* Merge a debug symbol containing debug information into a normal symbol.  */
end_comment

begin_function
name|void
name|c_symbol_merge
parameter_list|(
name|debug
parameter_list|,
name|normal
parameter_list|)
name|symbolS
modifier|*
name|debug
decl_stmt|;
name|symbolS
modifier|*
name|normal
decl_stmt|;
block|{
name|S_SET_DATA_TYPE
argument_list|(
name|normal
argument_list|,
name|S_GET_DATA_TYPE
argument_list|(
name|debug
argument_list|)
argument_list|)
expr_stmt|;
name|S_SET_STORAGE_CLASS
argument_list|(
name|normal
argument_list|,
name|S_GET_STORAGE_CLASS
argument_list|(
name|debug
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|S_GET_NUMBER_AUXILIARY
argument_list|(
name|debug
argument_list|)
operator|>
name|S_GET_NUMBER_AUXILIARY
argument_list|(
name|normal
argument_list|)
condition|)
block|{
comment|/* take the most we have */
name|S_SET_NUMBER_AUXILIARY
argument_list|(
name|normal
argument_list|,
name|S_GET_NUMBER_AUXILIARY
argument_list|(
name|debug
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|S_GET_NUMBER_AUXILIARY
argument_list|(
name|debug
argument_list|)
operator|>
literal|0
condition|)
block|{
comment|/* Move all the auxiliary information.  */
name|memcpy
argument_list|(
name|SYM_AUXINFO
argument_list|(
name|normal
argument_list|)
argument_list|,
name|SYM_AUXINFO
argument_list|(
name|debug
argument_list|)
argument_list|,
operator|(
name|S_GET_NUMBER_AUXILIARY
argument_list|(
name|debug
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|SYM_AUXINFO
argument_list|(
name|debug
argument_list|)
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* Move the debug flags.  */
name|SF_SET_DEBUG_FIELD
argument_list|(
name|normal
argument_list|,
name|SF_GET_DEBUG_FIELD
argument_list|(
name|debug
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|c_dot_file_symbol
parameter_list|(
name|filename
parameter_list|)
specifier|const
name|char
modifier|*
name|filename
decl_stmt|;
block|{
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
comment|/* BFD converts filename to a .file symbol with an aux entry.  It      also handles chaining.  */
name|symbolP
operator|=
name|symbol_new
argument_list|(
name|filename
argument_list|,
name|bfd_abs_section_ptr
argument_list|,
literal|0
argument_list|,
operator|&
name|zero_address_frag
argument_list|)
expr_stmt|;
name|S_SET_STORAGE_CLASS
argument_list|(
name|symbolP
argument_list|,
name|C_FILE
argument_list|)
expr_stmt|;
name|S_SET_NUMBER_AUXILIARY
argument_list|(
name|symbolP
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|symbol_get_bfdsym
argument_list|(
name|symbolP
argument_list|)
operator|->
name|flags
operator|=
name|BSF_DEBUGGING
expr_stmt|;
ifndef|#
directive|ifndef
name|NO_LISTING
block|{
specifier|extern
name|int
name|listing
decl_stmt|;
if|if
condition|(
name|listing
condition|)
block|{
name|listing_source_file
argument_list|(
name|filename
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* Make sure that the symbol is first on the symbol chain */
if|if
condition|(
name|symbol_rootP
operator|!=
name|symbolP
condition|)
block|{
name|symbol_remove
argument_list|(
name|symbolP
argument_list|,
operator|&
name|symbol_rootP
argument_list|,
operator|&
name|symbol_lastP
argument_list|)
expr_stmt|;
name|symbol_insert
argument_list|(
name|symbolP
argument_list|,
name|symbol_rootP
argument_list|,
operator|&
name|symbol_rootP
argument_list|,
operator|&
name|symbol_lastP
argument_list|)
expr_stmt|;
block|}
comment|/* if not first on the list */
block|}
end_function

begin_comment
comment|/* Line number handling */
end_comment

begin_struct
struct|struct
name|line_no
block|{
name|struct
name|line_no
modifier|*
name|next
decl_stmt|;
name|fragS
modifier|*
name|frag
decl_stmt|;
name|alent
name|l
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|int
name|coff_line_base
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Symbol of last function, which we should hang line#s off of.  */
end_comment

begin_decl_stmt
specifier|static
name|symbolS
modifier|*
name|line_fsym
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|in_function
parameter_list|()
value|(line_fsym != 0)
end_define

begin_define
define|#
directive|define
name|clear_function
parameter_list|()
value|(line_fsym = 0)
end_define

begin_define
define|#
directive|define
name|set_function
parameter_list|(
name|F
parameter_list|)
value|(line_fsym = (F), coff_add_linesym (F))
end_define

begin_escape
end_escape

begin_function
name|void
name|coff_obj_symbol_new_hook
parameter_list|(
name|symbolP
parameter_list|)
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
block|{
name|long
name|sz
init|=
operator|(
name|OBJ_COFF_MAX_AUXENTRIES
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|combined_entry_type
argument_list|)
decl_stmt|;
name|char
modifier|*
name|s
init|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|sz
argument_list|)
decl_stmt|;
name|memset
argument_list|(
name|s
argument_list|,
literal|0
argument_list|,
name|sz
argument_list|)
expr_stmt|;
name|coffsymbol
argument_list|(
name|symbol_get_bfdsym
argument_list|(
name|symbolP
argument_list|)
argument_list|)
operator|->
name|native
operator|=
operator|(
name|combined_entry_type
operator|*
operator|)
name|s
expr_stmt|;
name|S_SET_DATA_TYPE
argument_list|(
name|symbolP
argument_list|,
name|T_NULL
argument_list|)
expr_stmt|;
name|S_SET_STORAGE_CLASS
argument_list|(
name|symbolP
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|S_SET_NUMBER_AUXILIARY
argument_list|(
name|symbolP
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|S_IS_STRING
argument_list|(
name|symbolP
argument_list|)
condition|)
name|SF_SET_STRING
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
if|if
condition|(
name|S_IS_LOCAL
argument_list|(
name|symbolP
argument_list|)
condition|)
name|SF_SET_LOCAL
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  * Handle .ln directives.  */
end_comment

begin_decl_stmt
specifier|static
name|symbolS
modifier|*
name|current_lineno_sym
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|line_no
modifier|*
name|line_nos
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* @@ Blindly assume all .ln directives will be in the .text section...  */
end_comment

begin_decl_stmt
name|int
name|coff_n_line_nos
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|add_lineno
parameter_list|(
name|frag
parameter_list|,
name|offset
parameter_list|,
name|num
parameter_list|)
name|fragS
modifier|*
name|frag
decl_stmt|;
name|addressT
name|offset
decl_stmt|;
name|int
name|num
decl_stmt|;
block|{
name|struct
name|line_no
modifier|*
name|new_line
init|=
operator|(
expr|struct
name|line_no
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|line_no
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|current_lineno_sym
condition|)
block|{
name|abort
argument_list|()
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|OBJ_XCOFF
comment|/* The native aix assembler accepts negative line number */
if|if
condition|(
name|num
operator|<=
literal|0
condition|)
block|{
comment|/* Zero is used as an end marker in the file.  */
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"Line numbers must be positive integers\n"
argument_list|)
argument_list|)
expr_stmt|;
name|num
operator|=
literal|1
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* OBJ_XCOFF */
name|new_line
operator|->
name|next
operator|=
name|line_nos
expr_stmt|;
name|new_line
operator|->
name|frag
operator|=
name|frag
expr_stmt|;
name|new_line
operator|->
name|l
operator|.
name|line_number
operator|=
name|num
expr_stmt|;
name|new_line
operator|->
name|l
operator|.
name|u
operator|.
name|offset
operator|=
name|offset
expr_stmt|;
name|line_nos
operator|=
name|new_line
expr_stmt|;
name|coff_n_line_nos
operator|++
expr_stmt|;
block|}
end_function

begin_function
name|void
name|coff_add_linesym
parameter_list|(
name|sym
parameter_list|)
name|symbolS
modifier|*
name|sym
decl_stmt|;
block|{
if|if
condition|(
name|line_nos
condition|)
block|{
name|coffsymbol
argument_list|(
name|symbol_get_bfdsym
argument_list|(
name|current_lineno_sym
argument_list|)
argument_list|)
operator|->
name|lineno
operator|=
operator|(
name|alent
operator|*
operator|)
name|line_nos
expr_stmt|;
name|coff_n_line_nos
operator|++
expr_stmt|;
name|line_nos
operator|=
literal|0
expr_stmt|;
block|}
name|current_lineno_sym
operator|=
name|sym
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|obj_coff_ln
parameter_list|(
name|appline
parameter_list|)
name|int
name|appline
decl_stmt|;
block|{
name|int
name|l
decl_stmt|;
if|if
condition|(
operator|!
name|appline
operator|&&
name|def_symbol_in_progress
operator|!=
name|NULL
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|".ln pseudo-op inside .def/.endef: ignored."
argument_list|)
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
name|l
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|appline
condition|)
block|{
name|add_lineno
argument_list|(
name|frag_now
argument_list|,
name|frag_now_fix
argument_list|()
argument_list|,
name|l
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|appline
condition|)
name|new_logical_line
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|l
operator|-
literal|1
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|NO_LISTING
block|{
specifier|extern
name|int
name|listing
decl_stmt|;
if|if
condition|(
name|listing
condition|)
block|{
if|if
condition|(
operator|!
name|appline
condition|)
name|l
operator|+=
name|coff_line_base
operator|-
literal|1
expr_stmt|;
name|listing_source_line
argument_list|(
name|l
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* .loc is essentially the same as .ln; parse it for assembler    compatibility.  */
end_comment

begin_function
specifier|static
name|void
name|obj_coff_loc
parameter_list|(
name|ignore
parameter_list|)
name|int
name|ignore
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|int
name|lineno
decl_stmt|;
comment|/* FIXME: Why do we need this check?  We need it for ECOFF, but why      do we need it for COFF?  */
if|if
condition|(
name|now_seg
operator|!=
name|text_section
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|".loc outside of .text"
argument_list|)
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|def_symbol_in_progress
operator|!=
name|NULL
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|".loc pseudo-op inside .def/.endef: ignored."
argument_list|)
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
comment|/* Skip the file number.  */
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
name|get_absolute_expression
argument_list|()
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
name|lineno
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
ifndef|#
directive|ifndef
name|NO_LISTING
block|{
specifier|extern
name|int
name|listing
decl_stmt|;
if|if
condition|(
name|listing
condition|)
block|{
name|lineno
operator|+=
name|coff_line_base
operator|-
literal|1
expr_stmt|;
name|listing_source_line
argument_list|(
name|lineno
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
name|add_lineno
argument_list|(
name|frag_now
argument_list|,
name|frag_now_fix
argument_list|()
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle the .ident pseudo-op.  */
end_comment

begin_function
specifier|static
name|void
name|obj_coff_ident
parameter_list|(
name|ignore
parameter_list|)
name|int
name|ignore
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|segT
name|current_seg
init|=
name|now_seg
decl_stmt|;
name|subsegT
name|current_subseg
init|=
name|now_subseg
decl_stmt|;
ifdef|#
directive|ifdef
name|TE_PE
block|{
name|segT
name|sec
decl_stmt|;
comment|/* We could put it in .comment, but that creates an extra section        that shouldn't be loaded into memory, which requires linker        changes...  For now, until proven otherwise, use .rdata.  */
name|sec
operator|=
name|subseg_new
argument_list|(
literal|".rdata$zzz"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bfd_set_section_flags
argument_list|(
name|stdoutput
argument_list|,
name|sec
argument_list|,
operator|(
operator|(
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_READONLY
operator||
name|SEC_DATA
operator|)
operator|&
name|bfd_applicable_section_flags
argument_list|(
name|stdoutput
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|subseg_new
argument_list|(
literal|".comment"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|stringer
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|subseg_set
argument_list|(
name|current_seg
argument_list|,
name|current_subseg
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *			def()  *  * Handle .def directives.  *  * One might ask : why can't we symbol_new if the symbol does not  * already exist and fill it with debug information.  Because of  * the C_EFCN special symbol. It would clobber the value of the  * function symbol before we have a chance to notice that it is  * a C_EFCN. And a second reason is that the code is more clear this  * way. (at least I think it is :-).  *  */
end_comment

begin_define
define|#
directive|define
name|SKIP_SEMI_COLON
parameter_list|()
value|while (*input_line_pointer++ != ';')
end_define

begin_define
define|#
directive|define
name|SKIP_WHITESPACES
parameter_list|()
value|while (*input_line_pointer == ' ' || \ 				       *input_line_pointer == '\t') \     input_line_pointer++;
end_define

begin_function
specifier|static
name|void
name|obj_coff_def
parameter_list|(
name|what
parameter_list|)
name|int
name|what
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|char
name|name_end
decl_stmt|;
comment|/* Char after the end of name */
name|char
modifier|*
name|symbol_name
decl_stmt|;
comment|/* Name of the debug symbol */
name|char
modifier|*
name|symbol_name_copy
decl_stmt|;
comment|/* Temporary copy of the name */
name|unsigned
name|int
name|symbol_name_length
decl_stmt|;
if|if
condition|(
name|def_symbol_in_progress
operator|!=
name|NULL
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|".def pseudo-op used inside of .def/.endef: ignored."
argument_list|)
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
comment|/* if not inside .def/.endef */
name|SKIP_WHITESPACES
argument_list|()
expr_stmt|;
name|symbol_name
operator|=
name|input_line_pointer
expr_stmt|;
ifdef|#
directive|ifdef
name|STRIP_UNDERSCORE
if|if
condition|(
name|symbol_name
index|[
literal|0
index|]
operator|==
literal|'_'
operator|&&
name|symbol_name
index|[
literal|1
index|]
operator|!=
literal|0
condition|)
name|symbol_name
operator|++
expr_stmt|;
endif|#
directive|endif
comment|/* STRIP_UNDERSCORE */
name|name_end
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
name|symbol_name_length
operator|=
name|strlen
argument_list|(
name|symbol_name
argument_list|)
expr_stmt|;
name|symbol_name_copy
operator|=
name|xmalloc
argument_list|(
name|symbol_name_length
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|symbol_name_copy
argument_list|,
name|symbol_name
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|tc_canonicalize_symbol_name
name|symbol_name_copy
operator|=
name|tc_canonicalize_symbol_name
argument_list|(
name|symbol_name_copy
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Initialize the new symbol */
name|def_symbol_in_progress
operator|=
name|symbol_make
argument_list|(
name|symbol_name_copy
argument_list|)
expr_stmt|;
name|symbol_set_frag
argument_list|(
name|def_symbol_in_progress
argument_list|,
operator|&
name|zero_address_frag
argument_list|)
expr_stmt|;
name|S_SET_VALUE
argument_list|(
name|def_symbol_in_progress
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|S_IS_STRING
argument_list|(
name|def_symbol_in_progress
argument_list|)
condition|)
name|SF_SET_STRING
argument_list|(
name|def_symbol_in_progress
argument_list|)
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
name|name_end
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|unsigned
name|int
name|dim_index
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|obj_coff_endef
parameter_list|(
name|ignore
parameter_list|)
name|int
name|ignore
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|symbolS
modifier|*
name|symbolP
init|=
name|NULL
decl_stmt|;
comment|/* DIM BUG FIX sac@cygnus.com */
name|dim_index
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|def_symbol_in_progress
operator|==
name|NULL
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|".endef pseudo-op used outside of .def/.endef: ignored."
argument_list|)
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
comment|/* if not inside .def/.endef */
comment|/* Set the section number according to storage class.  */
switch|switch
condition|(
name|S_GET_STORAGE_CLASS
argument_list|(
name|def_symbol_in_progress
argument_list|)
condition|)
block|{
case|case
name|C_STRTAG
case|:
case|case
name|C_ENTAG
case|:
case|case
name|C_UNTAG
case|:
name|SF_SET_TAG
argument_list|(
name|def_symbol_in_progress
argument_list|)
expr_stmt|;
comment|/* intentional fallthrough */
case|case
name|C_FILE
case|:
case|case
name|C_TPDEF
case|:
name|SF_SET_DEBUG
argument_list|(
name|def_symbol_in_progress
argument_list|)
expr_stmt|;
name|S_SET_SEGMENT
argument_list|(
name|def_symbol_in_progress
argument_list|,
name|fetch_coff_debug_section
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|C_EFCN
case|:
name|SF_SET_LOCAL
argument_list|(
name|def_symbol_in_progress
argument_list|)
expr_stmt|;
comment|/* Do not emit this symbol.  */
comment|/* intentional fallthrough */
case|case
name|C_BLOCK
case|:
name|SF_SET_PROCESS
argument_list|(
name|def_symbol_in_progress
argument_list|)
expr_stmt|;
comment|/* Will need processing before writing */
comment|/* intentional fallthrough */
case|case
name|C_FCN
case|:
block|{
name|CONST
name|char
modifier|*
name|name
decl_stmt|;
name|S_SET_SEGMENT
argument_list|(
name|def_symbol_in_progress
argument_list|,
name|text_section
argument_list|)
expr_stmt|;
name|name
operator|=
name|S_GET_NAME
argument_list|(
name|def_symbol_in_progress
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
name|name
index|[
literal|2
index|]
operator|==
literal|'f'
operator|&&
name|name
index|[
literal|3
index|]
operator|==
literal|'\0'
condition|)
block|{
switch|switch
condition|(
name|name
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|'b'
case|:
comment|/* .bf */
if|if
condition|(
operator|!
name|in_function
argument_list|()
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"`%s' symbol without preceding function"
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
comment|/* Will need relocating.  */
name|SF_SET_PROCESS
argument_list|(
name|def_symbol_in_progress
argument_list|)
expr_stmt|;
name|clear_function
argument_list|()
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|TE_PE
case|case
literal|'e'
case|:
comment|/* .ef */
comment|/* The MS compilers output the actual endline, not the 		   function-relative one... we want to match without 		   changing the assembler input.  */
name|SA_SET_SYM_LNNO
argument_list|(
name|def_symbol_in_progress
argument_list|,
operator|(
name|SA_GET_SYM_LNNO
argument_list|(
name|def_symbol_in_progress
argument_list|)
operator|+
name|coff_line_base
operator|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
block|}
block|}
block|}
break|break;
ifdef|#
directive|ifdef
name|C_AUTOARG
case|case
name|C_AUTOARG
case|:
endif|#
directive|endif
comment|/* C_AUTOARG */
case|case
name|C_AUTO
case|:
case|case
name|C_REG
case|:
case|case
name|C_ARG
case|:
case|case
name|C_REGPARM
case|:
case|case
name|C_FIELD
case|:
comment|/* According to the COFF documentation:         http://osr5doc.sco.com:1996/topics/COFF_SectNumFld.html         A special section number (-2) marks symbolic debugging symbols,        including structure/union/enumeration tag names, typedefs, and        the name of the file. A section number of -1 indicates that the        symbol has a value but is not relocatable. Examples of        absolute-valued symbols include automatic and register variables,        function arguments, and .eos symbols.         But from Ian Lance Taylor:         http://sources.redhat.com/ml/binutils/2000-08/msg00202.html         the actual tools all marked them as section -1. So the GNU COFF        assembler follows historical COFF assemblers.         However, it causes problems for djgpp         http://sources.redhat.com/ml/binutils/2000-08/msg00210.html         By defining STRICTCOFF, a COFF port can make the assembler to        follow the documented behavior.  */
ifdef|#
directive|ifdef
name|STRICTCOFF
case|case
name|C_MOS
case|:
case|case
name|C_MOE
case|:
case|case
name|C_MOU
case|:
case|case
name|C_EOS
case|:
endif|#
directive|endif
name|SF_SET_DEBUG
argument_list|(
name|def_symbol_in_progress
argument_list|)
expr_stmt|;
name|S_SET_SEGMENT
argument_list|(
name|def_symbol_in_progress
argument_list|,
name|absolute_section
argument_list|)
expr_stmt|;
break|break;
ifndef|#
directive|ifndef
name|STRICTCOFF
case|case
name|C_MOS
case|:
case|case
name|C_MOE
case|:
case|case
name|C_MOU
case|:
case|case
name|C_EOS
case|:
name|S_SET_SEGMENT
argument_list|(
name|def_symbol_in_progress
argument_list|,
name|absolute_section
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|C_EXT
case|:
case|case
name|C_WEAKEXT
case|:
ifdef|#
directive|ifdef
name|TE_PE
case|case
name|C_NT_WEAK
case|:
endif|#
directive|endif
case|case
name|C_STAT
case|:
case|case
name|C_LABEL
case|:
comment|/* Valid but set somewhere else (s_comm, s_lcomm, colon) */
break|break;
default|default:
case|case
name|C_USTATIC
case|:
case|case
name|C_EXTDEF
case|:
case|case
name|C_ULABEL
case|:
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"unexpected storage class %d"
argument_list|)
argument_list|,
name|S_GET_STORAGE_CLASS
argument_list|(
name|def_symbol_in_progress
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* switch on storage class */
comment|/* Now that we have built a debug symbol, try to find if we should      merge with an existing symbol or not.  If a symbol is C_EFCN or      absolute_section or untagged SEG_DEBUG it never merges.  We also      don't merge labels, which are in a different namespace, nor      symbols which have not yet been defined since they are typically      unique, nor do we merge tags with non-tags.  */
comment|/* Two cases for functions.  Either debug followed by definition or      definition followed by debug.  For definition first, we will      merge the debug symbol into the definition.  For debug first, the      lineno entry MUST point to the definition function or else it      will point off into space when obj_crawl_symbol_chain() merges      the debug symbol into the real symbol.  Therefor, let's presume      the debug symbol is a real function reference.  */
comment|/* FIXME-SOON If for some reason the definition label/symbol is      never seen, this will probably leave an undefined symbol at link      time.  */
if|if
condition|(
name|S_GET_STORAGE_CLASS
argument_list|(
name|def_symbol_in_progress
argument_list|)
operator|==
name|C_EFCN
operator|||
name|S_GET_STORAGE_CLASS
argument_list|(
name|def_symbol_in_progress
argument_list|)
operator|==
name|C_LABEL
operator|||
operator|(
operator|!
name|strcmp
argument_list|(
name|bfd_get_section_name
argument_list|(
name|stdoutput
argument_list|,
name|S_GET_SEGMENT
argument_list|(
name|def_symbol_in_progress
argument_list|)
argument_list|)
argument_list|,
literal|"*DEBUG*"
argument_list|)
operator|&&
operator|!
name|SF_GET_TAG
argument_list|(
name|def_symbol_in_progress
argument_list|)
operator|)
operator|||
name|S_GET_SEGMENT
argument_list|(
name|def_symbol_in_progress
argument_list|)
operator|==
name|absolute_section
operator|||
operator|!
name|symbol_constant_p
argument_list|(
name|def_symbol_in_progress
argument_list|)
operator|||
operator|(
name|symbolP
operator|=
name|symbol_find_base
argument_list|(
name|S_GET_NAME
argument_list|(
name|def_symbol_in_progress
argument_list|)
argument_list|,
name|DO_NOT_STRIP
argument_list|)
operator|)
operator|==
name|NULL
operator|||
name|SF_GET_TAG
argument_list|(
name|def_symbol_in_progress
argument_list|)
operator|!=
name|SF_GET_TAG
argument_list|(
name|symbolP
argument_list|)
condition|)
block|{
comment|/* If it already is at the end of the symbol list, do nothing */
if|if
condition|(
name|def_symbol_in_progress
operator|!=
name|symbol_lastP
condition|)
block|{
name|symbol_remove
argument_list|(
name|def_symbol_in_progress
argument_list|,
operator|&
name|symbol_rootP
argument_list|,
operator|&
name|symbol_lastP
argument_list|)
expr_stmt|;
name|symbol_append
argument_list|(
name|def_symbol_in_progress
argument_list|,
name|symbol_lastP
argument_list|,
operator|&
name|symbol_rootP
argument_list|,
operator|&
name|symbol_lastP
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* This symbol already exists, merge the newly created symbol 	 into the old one.  This is not mandatory. The linker can 	 handle duplicate symbols correctly. But I guess that it save 	 a *lot* of space if the assembly file defines a lot of 	 symbols. [loic] */
comment|/* The debug entry (def_symbol_in_progress) is merged into the 	 previous definition.  */
name|c_symbol_merge
argument_list|(
name|def_symbol_in_progress
argument_list|,
name|symbolP
argument_list|)
expr_stmt|;
name|symbol_remove
argument_list|(
name|def_symbol_in_progress
argument_list|,
operator|&
name|symbol_rootP
argument_list|,
operator|&
name|symbol_lastP
argument_list|)
expr_stmt|;
name|def_symbol_in_progress
operator|=
name|symbolP
expr_stmt|;
if|if
condition|(
name|SF_GET_FUNCTION
argument_list|(
name|def_symbol_in_progress
argument_list|)
operator|||
name|SF_GET_TAG
argument_list|(
name|def_symbol_in_progress
argument_list|)
operator|||
name|S_GET_STORAGE_CLASS
argument_list|(
name|def_symbol_in_progress
argument_list|)
operator|==
name|C_STAT
condition|)
block|{
comment|/* For functions, and tags, and static symbols, the symbol 	     *must* be where the debug symbol appears.  Move the 	     existing symbol to the current place.  */
comment|/* If it already is at the end of the symbol list, do nothing */
if|if
condition|(
name|def_symbol_in_progress
operator|!=
name|symbol_lastP
condition|)
block|{
name|symbol_remove
argument_list|(
name|def_symbol_in_progress
argument_list|,
operator|&
name|symbol_rootP
argument_list|,
operator|&
name|symbol_lastP
argument_list|)
expr_stmt|;
name|symbol_append
argument_list|(
name|def_symbol_in_progress
argument_list|,
name|symbol_lastP
argument_list|,
operator|&
name|symbol_rootP
argument_list|,
operator|&
name|symbol_lastP
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|SF_GET_TAG
argument_list|(
name|def_symbol_in_progress
argument_list|)
condition|)
block|{
name|symbolS
modifier|*
name|oldtag
decl_stmt|;
name|oldtag
operator|=
name|symbol_find_base
argument_list|(
name|S_GET_NAME
argument_list|(
name|def_symbol_in_progress
argument_list|)
argument_list|,
name|DO_NOT_STRIP
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldtag
operator|==
name|NULL
operator|||
operator|!
name|SF_GET_TAG
argument_list|(
name|oldtag
argument_list|)
condition|)
name|tag_insert
argument_list|(
name|S_GET_NAME
argument_list|(
name|def_symbol_in_progress
argument_list|)
argument_list|,
name|def_symbol_in_progress
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|SF_GET_FUNCTION
argument_list|(
name|def_symbol_in_progress
argument_list|)
condition|)
block|{
name|know
argument_list|(
sizeof|sizeof
argument_list|(
name|def_symbol_in_progress
argument_list|)
operator|<=
sizeof|sizeof
argument_list|(
name|long
argument_list|)
argument_list|)
expr_stmt|;
name|set_function
argument_list|(
name|def_symbol_in_progress
argument_list|)
expr_stmt|;
name|SF_SET_PROCESS
argument_list|(
name|def_symbol_in_progress
argument_list|)
expr_stmt|;
if|if
condition|(
name|symbolP
operator|==
name|NULL
condition|)
block|{
comment|/* That is, if this is the first time we've seen the 	     function...  */
name|symbol_table_insert
argument_list|(
name|def_symbol_in_progress
argument_list|)
expr_stmt|;
block|}
comment|/* definition follows debug */
block|}
comment|/* Create the line number entry pointing to the function being defined */
name|def_symbol_in_progress
operator|=
name|NULL
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|obj_coff_dim
parameter_list|(
name|ignore
parameter_list|)
name|int
name|ignore
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|int
name|dim_index
decl_stmt|;
if|if
condition|(
name|def_symbol_in_progress
operator|==
name|NULL
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|".dim pseudo-op used outside of .def/.endef: ignored."
argument_list|)
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
comment|/* if not inside .def/.endef */
name|S_SET_NUMBER_AUXILIARY
argument_list|(
name|def_symbol_in_progress
argument_list|,
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|dim_index
operator|=
literal|0
init|;
name|dim_index
operator|<
name|DIMNUM
condition|;
name|dim_index
operator|++
control|)
block|{
name|SKIP_WHITESPACES
argument_list|()
expr_stmt|;
name|SA_SET_SYM_DIMEN
argument_list|(
name|def_symbol_in_progress
argument_list|,
name|dim_index
argument_list|,
name|get_absolute_expression
argument_list|()
argument_list|)
expr_stmt|;
switch|switch
condition|(
operator|*
name|input_line_pointer
condition|)
block|{
case|case
literal|','
case|:
name|input_line_pointer
operator|++
expr_stmt|;
break|break;
default|default:
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"badly formed .dim directive ignored"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* intentional fallthrough */
case|case
literal|'\n'
case|:
case|case
literal|';'
case|:
name|dim_index
operator|=
name|DIMNUM
expr_stmt|;
break|break;
block|}
block|}
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|obj_coff_line
parameter_list|(
name|ignore
parameter_list|)
name|int
name|ignore
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|int
name|this_base
decl_stmt|;
if|if
condition|(
name|def_symbol_in_progress
operator|==
name|NULL
condition|)
block|{
comment|/* Probably stabs-style line?  */
name|obj_coff_ln
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
name|this_base
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
literal|".bf"
argument_list|,
name|S_GET_NAME
argument_list|(
name|def_symbol_in_progress
argument_list|)
argument_list|)
condition|)
name|coff_line_base
operator|=
name|this_base
expr_stmt|;
name|S_SET_NUMBER_AUXILIARY
argument_list|(
name|def_symbol_in_progress
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SA_SET_SYM_LNNO
argument_list|(
name|def_symbol_in_progress
argument_list|,
name|this_base
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
ifndef|#
directive|ifndef
name|NO_LISTING
if|if
condition|(
name|strcmp
argument_list|(
literal|".bf"
argument_list|,
name|S_GET_NAME
argument_list|(
name|def_symbol_in_progress
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
specifier|extern
name|int
name|listing
decl_stmt|;
if|if
condition|(
name|listing
condition|)
name|listing_source_line
argument_list|(
operator|(
name|unsigned
name|int
operator|)
name|this_base
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|obj_coff_size
parameter_list|(
name|ignore
parameter_list|)
name|int
name|ignore
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
if|if
condition|(
name|def_symbol_in_progress
operator|==
name|NULL
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|".size pseudo-op used outside of .def/.endef ignored."
argument_list|)
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
comment|/* if not inside .def/.endef */
name|S_SET_NUMBER_AUXILIARY
argument_list|(
name|def_symbol_in_progress
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SA_SET_SYM_SIZE
argument_list|(
name|def_symbol_in_progress
argument_list|,
name|get_absolute_expression
argument_list|()
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|obj_coff_scl
parameter_list|(
name|ignore
parameter_list|)
name|int
name|ignore
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
if|if
condition|(
name|def_symbol_in_progress
operator|==
name|NULL
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|".scl pseudo-op used outside of .def/.endef ignored."
argument_list|)
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
comment|/* if not inside .def/.endef */
name|S_SET_STORAGE_CLASS
argument_list|(
name|def_symbol_in_progress
argument_list|,
name|get_absolute_expression
argument_list|()
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|obj_coff_tag
parameter_list|(
name|ignore
parameter_list|)
name|int
name|ignore
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|char
modifier|*
name|symbol_name
decl_stmt|;
name|char
name|name_end
decl_stmt|;
if|if
condition|(
name|def_symbol_in_progress
operator|==
name|NULL
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|".tag pseudo-op used outside of .def/.endef ignored."
argument_list|)
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
name|S_SET_NUMBER_AUXILIARY
argument_list|(
name|def_symbol_in_progress
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|symbol_name
operator|=
name|input_line_pointer
expr_stmt|;
name|name_end
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|tc_canonicalize_symbol_name
name|symbol_name
operator|=
name|tc_canonicalize_symbol_name
argument_list|(
name|symbol_name
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Assume that the symbol referred to by .tag is always defined.      This was a bad assumption.  I've added find_or_make. xoxorich.  */
name|SA_SET_SYM_TAGNDX
argument_list|(
name|def_symbol_in_progress
argument_list|,
name|tag_find_or_make
argument_list|(
name|symbol_name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|SA_GET_SYM_TAGNDX
argument_list|(
name|def_symbol_in_progress
argument_list|)
operator|==
literal|0L
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"tag not found for .tag %s"
argument_list|)
argument_list|,
name|symbol_name
argument_list|)
expr_stmt|;
block|}
comment|/* not defined */
name|SF_SET_TAGGED
argument_list|(
name|def_symbol_in_progress
argument_list|)
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
name|name_end
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|obj_coff_type
parameter_list|(
name|ignore
parameter_list|)
name|int
name|ignore
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
if|if
condition|(
name|def_symbol_in_progress
operator|==
name|NULL
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|".type pseudo-op used outside of .def/.endef ignored."
argument_list|)
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
comment|/* if not inside .def/.endef */
name|S_SET_DATA_TYPE
argument_list|(
name|def_symbol_in_progress
argument_list|,
name|get_absolute_expression
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|ISFCN
argument_list|(
name|S_GET_DATA_TYPE
argument_list|(
name|def_symbol_in_progress
argument_list|)
argument_list|)
operator|&&
name|S_GET_STORAGE_CLASS
argument_list|(
name|def_symbol_in_progress
argument_list|)
operator|!=
name|C_TPDEF
condition|)
block|{
name|SF_SET_FUNCTION
argument_list|(
name|def_symbol_in_progress
argument_list|)
expr_stmt|;
block|}
comment|/* is a function */
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|obj_coff_val
parameter_list|(
name|ignore
parameter_list|)
name|int
name|ignore
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
if|if
condition|(
name|def_symbol_in_progress
operator|==
name|NULL
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|".val pseudo-op used outside of .def/.endef ignored."
argument_list|)
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
comment|/* if not inside .def/.endef */
if|if
condition|(
name|is_name_beginner
argument_list|(
operator|*
name|input_line_pointer
argument_list|)
condition|)
block|{
name|char
modifier|*
name|symbol_name
init|=
name|input_line_pointer
decl_stmt|;
name|char
name|name_end
init|=
name|get_symbol_end
argument_list|()
decl_stmt|;
ifdef|#
directive|ifdef
name|tc_canonicalize_symbol_name
name|symbol_name
operator|=
name|tc_canonicalize_symbol_name
argument_list|(
name|symbol_name
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|symbol_name
argument_list|,
literal|"."
argument_list|)
condition|)
block|{
name|symbol_set_frag
argument_list|(
name|def_symbol_in_progress
argument_list|,
name|frag_now
argument_list|)
expr_stmt|;
name|S_SET_VALUE
argument_list|(
name|def_symbol_in_progress
argument_list|,
operator|(
name|valueT
operator|)
name|frag_now_fix
argument_list|()
argument_list|)
expr_stmt|;
comment|/* If the .val is != from the .def (e.g. statics) */
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|S_GET_NAME
argument_list|(
name|def_symbol_in_progress
argument_list|)
argument_list|,
name|symbol_name
argument_list|)
condition|)
block|{
name|expressionS
name|exp
decl_stmt|;
name|exp
operator|.
name|X_op
operator|=
name|O_symbol
expr_stmt|;
name|exp
operator|.
name|X_add_symbol
operator|=
name|symbol_find_or_make
argument_list|(
name|symbol_name
argument_list|)
expr_stmt|;
name|exp
operator|.
name|X_op_symbol
operator|=
name|NULL
expr_stmt|;
name|exp
operator|.
name|X_add_number
operator|=
literal|0
expr_stmt|;
name|symbol_set_value_expression
argument_list|(
name|def_symbol_in_progress
argument_list|,
operator|&
name|exp
argument_list|)
expr_stmt|;
comment|/* If the segment is undefined when the forward reference is 	     resolved, then copy the segment id from the forward 	     symbol.  */
name|SF_SET_GET_SEGMENT
argument_list|(
name|def_symbol_in_progress
argument_list|)
expr_stmt|;
comment|/* FIXME: gcc can generate address expressions here in 	     unusual cases (search for "obscure" in sdbout.c).  We 	     just ignore the offset here, thus generating incorrect 	     debugging information.  We ignore the rest of the line 	     just below.  */
block|}
comment|/* Otherwise, it is the name of a non debug symbol and its value          will be calculated later.  */
operator|*
name|input_line_pointer
operator|=
name|name_end
expr_stmt|;
block|}
else|else
block|{
name|S_SET_VALUE
argument_list|(
name|def_symbol_in_progress
argument_list|,
name|get_absolute_expression
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/* if symbol based */
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|coff_obj_read_begin_hook
parameter_list|()
block|{
comment|/* These had better be the same.  Usually 18 bytes.  */
ifndef|#
directive|ifndef
name|BFD_HEADERS
name|know
argument_list|(
sizeof|sizeof
argument_list|(
name|SYMENT
argument_list|)
operator|==
sizeof|sizeof
argument_list|(
name|AUXENT
argument_list|)
argument_list|)
expr_stmt|;
name|know
argument_list|(
name|SYMESZ
operator|==
name|AUXESZ
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|tag_init
argument_list|()
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|symbolS
modifier|*
name|coff_last_function
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|symbolS
modifier|*
name|coff_last_bf
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|coff_frob_symbol
parameter_list|(
name|symp
parameter_list|,
name|punt
parameter_list|)
name|symbolS
modifier|*
name|symp
decl_stmt|;
name|int
modifier|*
name|punt
decl_stmt|;
block|{
specifier|static
name|symbolS
modifier|*
name|last_tagP
decl_stmt|;
specifier|static
name|stack
modifier|*
name|block_stack
decl_stmt|;
specifier|static
name|symbolS
modifier|*
name|set_end
decl_stmt|;
name|symbolS
modifier|*
name|next_set_end
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|symp
operator|==
operator|&
name|abs_symbol
condition|)
block|{
operator|*
name|punt
operator|=
literal|1
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|current_lineno_sym
condition|)
name|coff_add_linesym
argument_list|(
operator|(
name|symbolS
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|block_stack
condition|)
name|block_stack
operator|=
name|stack_init
argument_list|(
literal|512
argument_list|,
sizeof|sizeof
argument_list|(
name|symbolS
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|S_IS_WEAK
argument_list|(
name|symp
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|TE_PE
name|S_SET_STORAGE_CLASS
argument_list|(
name|symp
argument_list|,
name|C_NT_WEAK
argument_list|)
expr_stmt|;
else|#
directive|else
name|S_SET_STORAGE_CLASS
argument_list|(
name|symp
argument_list|,
name|C_WEAKEXT
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
operator|!
name|S_IS_DEFINED
argument_list|(
name|symp
argument_list|)
operator|&&
operator|!
name|S_IS_WEAK
argument_list|(
name|symp
argument_list|)
operator|&&
name|S_GET_STORAGE_CLASS
argument_list|(
name|symp
argument_list|)
operator|!=
name|C_STAT
condition|)
name|S_SET_STORAGE_CLASS
argument_list|(
name|symp
argument_list|,
name|C_EXT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|SF_GET_DEBUG
argument_list|(
name|symp
argument_list|)
condition|)
block|{
name|symbolS
modifier|*
name|real
decl_stmt|;
if|if
condition|(
operator|!
name|SF_GET_LOCAL
argument_list|(
name|symp
argument_list|)
operator|&&
operator|!
name|SF_GET_STATICS
argument_list|(
name|symp
argument_list|)
operator|&&
name|S_GET_STORAGE_CLASS
argument_list|(
name|symp
argument_list|)
operator|!=
name|C_LABEL
operator|&&
name|symbol_constant_p
argument_list|(
name|symp
argument_list|)
operator|&&
operator|(
name|real
operator|=
name|symbol_find_base
argument_list|(
name|S_GET_NAME
argument_list|(
name|symp
argument_list|)
argument_list|,
name|DO_NOT_STRIP
argument_list|)
operator|)
operator|&&
name|real
operator|!=
name|symp
condition|)
block|{
name|c_symbol_merge
argument_list|(
name|symp
argument_list|,
name|real
argument_list|)
expr_stmt|;
operator|*
name|punt
operator|=
literal|1
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|S_IS_DEFINED
argument_list|(
name|symp
argument_list|)
operator|&&
operator|!
name|SF_GET_LOCAL
argument_list|(
name|symp
argument_list|)
condition|)
block|{
name|assert
argument_list|(
name|S_GET_VALUE
argument_list|(
name|symp
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|S_SET_EXTERNAL
argument_list|(
name|symp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|S_GET_STORAGE_CLASS
argument_list|(
name|symp
argument_list|)
operator|==
name|C_NULL
condition|)
block|{
if|if
condition|(
name|S_GET_SEGMENT
argument_list|(
name|symp
argument_list|)
operator|==
name|text_section
operator|&&
name|symp
operator|!=
name|seg_info
argument_list|(
name|text_section
argument_list|)
operator|->
name|sym
condition|)
name|S_SET_STORAGE_CLASS
argument_list|(
name|symp
argument_list|,
name|C_LABEL
argument_list|)
expr_stmt|;
else|else
name|S_SET_STORAGE_CLASS
argument_list|(
name|symp
argument_list|,
name|C_STAT
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|SF_GET_PROCESS
argument_list|(
name|symp
argument_list|)
condition|)
block|{
if|if
condition|(
name|S_GET_STORAGE_CLASS
argument_list|(
name|symp
argument_list|)
operator|==
name|C_BLOCK
condition|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|S_GET_NAME
argument_list|(
name|symp
argument_list|)
argument_list|,
literal|".bb"
argument_list|)
condition|)
name|stack_push
argument_list|(
name|block_stack
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|symp
argument_list|)
expr_stmt|;
else|else
block|{
name|symbolS
modifier|*
name|begin
decl_stmt|;
name|begin
operator|=
operator|*
operator|(
name|symbolS
operator|*
operator|*
operator|)
name|stack_pop
argument_list|(
name|block_stack
argument_list|)
expr_stmt|;
if|if
condition|(
name|begin
operator|==
literal|0
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"mismatched .eb"
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|next_set_end
operator|=
name|begin
expr_stmt|;
block|}
block|}
if|if
condition|(
name|coff_last_function
operator|==
literal|0
operator|&&
name|SF_GET_FUNCTION
argument_list|(
name|symp
argument_list|)
condition|)
block|{
name|union
name|internal_auxent
modifier|*
name|auxp
decl_stmt|;
name|coff_last_function
operator|=
name|symp
expr_stmt|;
if|if
condition|(
name|S_GET_NUMBER_AUXILIARY
argument_list|(
name|symp
argument_list|)
operator|<
literal|1
condition|)
name|S_SET_NUMBER_AUXILIARY
argument_list|(
name|symp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|auxp
operator|=
name|SYM_AUXENT
argument_list|(
name|symp
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|auxp
operator|->
name|x_sym
operator|.
name|x_fcnary
operator|.
name|x_ary
operator|.
name|x_dimen
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|auxp
operator|->
name|x_sym
operator|.
name|x_fcnary
operator|.
name|x_ary
operator|.
name|x_dimen
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|S_GET_STORAGE_CLASS
argument_list|(
name|symp
argument_list|)
operator|==
name|C_EFCN
condition|)
block|{
if|if
condition|(
name|coff_last_function
operator|==
literal|0
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"C_EFCN symbol out of scope"
argument_list|)
argument_list|)
expr_stmt|;
name|SA_SET_SYM_FSIZE
argument_list|(
name|coff_last_function
argument_list|,
call|(
name|long
call|)
argument_list|(
name|S_GET_VALUE
argument_list|(
name|symp
argument_list|)
operator|-
name|S_GET_VALUE
argument_list|(
name|coff_last_function
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|next_set_end
operator|=
name|coff_last_function
expr_stmt|;
name|coff_last_function
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|S_IS_EXTERNAL
argument_list|(
name|symp
argument_list|)
condition|)
name|S_SET_STORAGE_CLASS
argument_list|(
name|symp
argument_list|,
name|C_EXT
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|SF_GET_LOCAL
argument_list|(
name|symp
argument_list|)
condition|)
operator|*
name|punt
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|SF_GET_FUNCTION
argument_list|(
name|symp
argument_list|)
condition|)
name|symbol_get_bfdsym
argument_list|(
name|symp
argument_list|)
operator|->
name|flags
operator||=
name|BSF_FUNCTION
expr_stmt|;
comment|/* more ...  */
block|}
comment|/* Double check weak symbols.  */
if|if
condition|(
name|S_IS_WEAK
argument_list|(
name|symp
argument_list|)
operator|&&
name|S_IS_COMMON
argument_list|(
name|symp
argument_list|)
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Symbol `%s' can not be both weak and common"
argument_list|)
argument_list|,
name|S_GET_NAME
argument_list|(
name|symp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|SF_GET_TAG
argument_list|(
name|symp
argument_list|)
condition|)
name|last_tagP
operator|=
name|symp
expr_stmt|;
elseif|else
if|if
condition|(
name|S_GET_STORAGE_CLASS
argument_list|(
name|symp
argument_list|)
operator|==
name|C_EOS
condition|)
name|next_set_end
operator|=
name|last_tagP
expr_stmt|;
ifdef|#
directive|ifdef
name|OBJ_XCOFF
comment|/* This is pretty horrible, but we have to set *punt correctly in      order to call SA_SET_SYM_ENDNDX correctly.  */
if|if
condition|(
operator|!
name|symbol_used_in_reloc_p
argument_list|(
name|symp
argument_list|)
operator|&&
operator|(
operator|(
name|symbol_get_bfdsym
argument_list|(
name|symp
argument_list|)
operator|->
name|flags
operator|&
name|BSF_SECTION_SYM
operator|)
operator|!=
literal|0
operator|||
operator|(
operator|!
name|S_IS_EXTERNAL
argument_list|(
name|symp
argument_list|)
operator|&&
operator|!
name|symbol_get_tc
argument_list|(
name|symp
argument_list|)
operator|->
name|output
operator|&&
name|S_GET_STORAGE_CLASS
argument_list|(
name|symp
argument_list|)
operator|!=
name|C_FILE
operator|)
operator|)
condition|)
operator|*
name|punt
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|set_end
operator|!=
operator|(
name|symbolS
operator|*
operator|)
name|NULL
operator|&&
operator|!
operator|*
name|punt
operator|&&
operator|(
operator|(
name|symbol_get_bfdsym
argument_list|(
name|symp
argument_list|)
operator|->
name|flags
operator|&
name|BSF_NOT_AT_END
operator|)
operator|!=
literal|0
operator|||
operator|(
name|S_IS_DEFINED
argument_list|(
name|symp
argument_list|)
operator|&&
operator|!
name|S_IS_COMMON
argument_list|(
name|symp
argument_list|)
operator|&&
operator|(
operator|!
name|S_IS_EXTERNAL
argument_list|(
name|symp
argument_list|)
operator|||
name|SF_GET_FUNCTION
argument_list|(
name|symp
argument_list|)
operator|)
operator|)
operator|)
condition|)
block|{
name|SA_SET_SYM_ENDNDX
argument_list|(
name|set_end
argument_list|,
name|symp
argument_list|)
expr_stmt|;
name|set_end
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|next_set_end
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|set_end
operator|!=
name|NULL
condition|)
name|as_warn
argument_list|(
literal|"Warning: internal error: forgetting to set endndx of %s"
argument_list|,
name|S_GET_NAME
argument_list|(
name|set_end
argument_list|)
argument_list|)
expr_stmt|;
name|set_end
operator|=
name|next_set_end
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|*
name|punt
operator|&&
name|S_GET_STORAGE_CLASS
argument_list|(
name|symp
argument_list|)
operator|==
name|C_FCN
operator|&&
name|strcmp
argument_list|(
name|S_GET_NAME
argument_list|(
name|symp
argument_list|)
argument_list|,
literal|".bf"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|coff_last_bf
operator|!=
name|NULL
condition|)
name|SA_SET_SYM_ENDNDX
argument_list|(
name|coff_last_bf
argument_list|,
name|symp
argument_list|)
expr_stmt|;
name|coff_last_bf
operator|=
name|symp
expr_stmt|;
block|}
if|if
condition|(
name|coffsymbol
argument_list|(
name|symbol_get_bfdsym
argument_list|(
name|symp
argument_list|)
argument_list|)
operator|->
name|lineno
condition|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|line_no
modifier|*
name|lptr
decl_stmt|;
name|alent
modifier|*
name|l
decl_stmt|;
name|lptr
operator|=
operator|(
expr|struct
name|line_no
operator|*
operator|)
name|coffsymbol
argument_list|(
name|symbol_get_bfdsym
argument_list|(
name|symp
argument_list|)
argument_list|)
operator|->
name|lineno
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|lptr
condition|;
name|lptr
operator|=
name|lptr
operator|->
name|next
control|)
name|i
operator|++
expr_stmt|;
name|lptr
operator|=
operator|(
expr|struct
name|line_no
operator|*
operator|)
name|coffsymbol
argument_list|(
name|symbol_get_bfdsym
argument_list|(
name|symp
argument_list|)
argument_list|)
operator|->
name|lineno
expr_stmt|;
comment|/* We need i entries for line numbers, plus 1 for the first 	 entry which BFD will override, plus 1 for the last zero 	 entry (a marker for BFD).  */
name|l
operator|=
operator|(
name|alent
operator|*
operator|)
name|xmalloc
argument_list|(
operator|(
name|i
operator|+
literal|2
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|alent
argument_list|)
argument_list|)
expr_stmt|;
name|coffsymbol
argument_list|(
name|symbol_get_bfdsym
argument_list|(
name|symp
argument_list|)
argument_list|)
operator|->
name|lineno
operator|=
name|l
expr_stmt|;
name|l
index|[
name|i
operator|+
literal|1
index|]
operator|.
name|line_number
operator|=
literal|0
expr_stmt|;
name|l
index|[
name|i
operator|+
literal|1
index|]
operator|.
name|u
operator|.
name|sym
operator|=
name|NULL
expr_stmt|;
for|for
control|(
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|lptr
operator|->
name|frag
condition|)
name|lptr
operator|->
name|l
operator|.
name|u
operator|.
name|offset
operator|+=
name|lptr
operator|->
name|frag
operator|->
name|fr_address
operator|/
name|OCTETS_PER_BYTE
expr_stmt|;
name|l
index|[
name|i
index|]
operator|=
name|lptr
operator|->
name|l
expr_stmt|;
name|lptr
operator|=
name|lptr
operator|->
name|next
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
name|coff_adjust_section_syms
parameter_list|(
name|abfd
parameter_list|,
name|sec
parameter_list|,
name|x
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|PTR
name|x
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|symbolS
modifier|*
name|secsym
decl_stmt|;
name|segment_info_type
modifier|*
name|seginfo
init|=
name|seg_info
argument_list|(
name|sec
argument_list|)
decl_stmt|;
name|int
name|nlnno
decl_stmt|,
name|nrelocs
init|=
literal|0
decl_stmt|;
comment|/* RS/6000 gas creates a .debug section manually in ppc_frob_file in      tc-ppc.c.  Do not get confused by it.  */
if|if
condition|(
name|seginfo
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|sec
operator|->
name|name
argument_list|,
literal|".text"
argument_list|)
condition|)
name|nlnno
operator|=
name|coff_n_line_nos
expr_stmt|;
else|else
name|nlnno
operator|=
literal|0
expr_stmt|;
block|{
comment|/* @@ Hope that none of the fixups expand to more than one reloc        entry...  */
name|fixS
modifier|*
name|fixp
init|=
name|seginfo
operator|->
name|fix_root
decl_stmt|;
while|while
condition|(
name|fixp
condition|)
block|{
if|if
condition|(
operator|!
name|fixp
operator|->
name|fx_done
condition|)
name|nrelocs
operator|++
expr_stmt|;
name|fixp
operator|=
name|fixp
operator|->
name|fx_next
expr_stmt|;
block|}
block|}
if|if
condition|(
name|bfd_get_section_size_before_reloc
argument_list|(
name|sec
argument_list|)
operator|==
literal|0
operator|&&
name|nrelocs
operator|==
literal|0
operator|&&
name|nlnno
operator|==
literal|0
operator|&&
name|sec
operator|!=
name|text_section
operator|&&
name|sec
operator|!=
name|data_section
operator|&&
name|sec
operator|!=
name|bss_section
condition|)
return|return;
name|secsym
operator|=
name|section_symbol
argument_list|(
name|sec
argument_list|)
expr_stmt|;
comment|/* This is an estimate; we'll plug in the real value using      SET_SECTION_RELOCS later */
name|SA_SET_SCN_NRELOC
argument_list|(
name|secsym
argument_list|,
name|nrelocs
argument_list|)
expr_stmt|;
name|SA_SET_SCN_NLINNO
argument_list|(
name|secsym
argument_list|,
name|nlnno
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|coff_frob_file_after_relocs
parameter_list|()
block|{
name|bfd_map_over_sections
argument_list|(
name|stdoutput
argument_list|,
name|coff_adjust_section_syms
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * implement the .section pseudo op:  *	.section name {, "flags"}  *                ^         ^  *                |         +--- optional flags: 'b' for bss  *                |                              'i' for info  *                +-- section name               'l' for lib  *                                               'n' for noload  *                                               'o' for over  *                                               'w' for data  *						 'd' (apparently m88k for data)  *                                               'x' for text  *						 'r' for read-only data  *						 's' for shared data (PE)  * But if the argument is not a quoted string, treat it as a  * subsegment number.  */
end_comment

begin_function
name|void
name|obj_coff_section
parameter_list|(
name|ignore
parameter_list|)
name|int
name|ignore
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
comment|/* Strip out the section name */
name|char
modifier|*
name|section_name
decl_stmt|;
name|char
name|c
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|unsigned
name|int
name|exp
decl_stmt|;
name|flagword
name|flags
decl_stmt|,
name|oldflags
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
if|if
condition|(
name|flag_mri
condition|)
block|{
name|char
name|type
decl_stmt|;
name|s_mri_sect
argument_list|(
operator|&
name|type
argument_list|)
expr_stmt|;
return|return;
block|}
name|section_name
operator|=
name|input_line_pointer
expr_stmt|;
name|c
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
name|name
operator|=
name|xmalloc
argument_list|(
name|input_line_pointer
operator|-
name|section_name
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|name
argument_list|,
name|section_name
argument_list|)
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
name|exp
operator|=
literal|0
expr_stmt|;
name|flags
operator|=
name|SEC_NO_FLAGS
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|','
condition|)
block|{
operator|++
name|input_line_pointer
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|!=
literal|'"'
condition|)
name|exp
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
else|else
block|{
operator|++
name|input_line_pointer
expr_stmt|;
while|while
condition|(
operator|*
name|input_line_pointer
operator|!=
literal|'"'
operator|&&
operator|!
name|is_end_of_line
index|[
operator|(
name|unsigned
name|char
operator|)
operator|*
name|input_line_pointer
index|]
condition|)
block|{
switch|switch
condition|(
operator|*
name|input_line_pointer
condition|)
block|{
case|case
literal|'b'
case|:
name|flags
operator||=
name|SEC_ALLOC
expr_stmt|;
name|flags
operator|&=
operator|~
name|SEC_LOAD
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
name|flags
operator|&=
operator|~
name|SEC_LOAD
expr_stmt|;
name|flags
operator||=
name|SEC_NEVER_LOAD
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|flags
operator||=
name|SEC_DATA
operator||
name|SEC_LOAD
expr_stmt|;
comment|/* fall through */
case|case
literal|'w'
case|:
name|flags
operator|&=
operator|~
name|SEC_READONLY
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
name|flags
operator||=
name|SEC_CODE
operator||
name|SEC_LOAD
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|flags
operator||=
name|SEC_READONLY
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|flags
operator||=
name|SEC_SHARED
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
comment|/* STYP_INFO */
case|case
literal|'l'
case|:
comment|/* STYP_LIB */
case|case
literal|'o'
case|:
comment|/* STYP_OVER */
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"unsupported section attribute '%c'"
argument_list|)
argument_list|,
operator|*
name|input_line_pointer
argument_list|)
expr_stmt|;
break|break;
default|default:
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"unknown section attribute '%c'"
argument_list|)
argument_list|,
operator|*
name|input_line_pointer
argument_list|)
expr_stmt|;
break|break;
block|}
operator|++
name|input_line_pointer
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|'"'
condition|)
operator|++
name|input_line_pointer
expr_stmt|;
block|}
block|}
name|sec
operator|=
name|subseg_new
argument_list|(
name|name
argument_list|,
operator|(
name|subsegT
operator|)
name|exp
argument_list|)
expr_stmt|;
name|oldflags
operator|=
name|bfd_get_section_flags
argument_list|(
name|stdoutput
argument_list|,
name|sec
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldflags
operator|==
name|SEC_NO_FLAGS
condition|)
block|{
comment|/* Set section flags for a new section just created by subseg_new.          Provide a default if no flags were parsed.  */
if|if
condition|(
name|flags
operator|==
name|SEC_NO_FLAGS
condition|)
name|flags
operator|=
name|TC_COFF_SECTION_DEFAULT_ATTRIBUTES
expr_stmt|;
ifdef|#
directive|ifdef
name|COFF_LONG_SECTION_NAMES
comment|/* Add SEC_LINK_ONCE and SEC_LINK_DUPLICATES_DISCARD to .gnu.linkonce          sections so adjust_reloc_syms in write.c will correctly handle          relocs which refer to non-local symbols in these sections.  */
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
literal|".gnu.linkonce"
argument_list|,
sizeof|sizeof
argument_list|(
literal|".gnu.linkonce"
argument_list|)
operator|-
literal|1
argument_list|)
operator|==
literal|0
condition|)
name|flags
operator||=
name|SEC_LINK_ONCE
operator||
name|SEC_LINK_DUPLICATES_DISCARD
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|bfd_set_section_flags
argument_list|(
name|stdoutput
argument_list|,
name|sec
argument_list|,
name|flags
argument_list|)
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"error setting flags for \"%s\": %s"
argument_list|)
argument_list|,
name|bfd_section_name
argument_list|(
name|stdoutput
argument_list|,
name|sec
argument_list|)
argument_list|,
name|bfd_errmsg
argument_list|(
name|bfd_get_error
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|flags
operator|!=
name|SEC_NO_FLAGS
condition|)
block|{
comment|/* This section's attributes have already been set. Warn if the          attributes don't match.  */
name|flagword
name|matchflags
init|=
operator|(
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_READONLY
operator||
name|SEC_CODE
operator||
name|SEC_DATA
operator||
name|SEC_SHARED
operator||
name|SEC_NEVER_LOAD
operator|)
decl_stmt|;
if|if
condition|(
operator|(
name|flags
operator|^
name|oldflags
operator|)
operator|&
name|matchflags
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"Ignoring changed section attributes for %s"
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|coff_adjust_symtab
parameter_list|()
block|{
if|if
condition|(
name|symbol_rootP
operator|==
name|NULL
operator|||
name|S_GET_STORAGE_CLASS
argument_list|(
name|symbol_rootP
argument_list|)
operator|!=
name|C_FILE
condition|)
name|c_dot_file_symbol
argument_list|(
literal|"fake"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|coff_frob_section
parameter_list|(
name|sec
parameter_list|)
name|segT
name|sec
decl_stmt|;
block|{
name|segT
name|strsec
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|fragS
modifier|*
name|fragp
decl_stmt|;
name|bfd_vma
name|size
decl_stmt|,
name|n_entries
decl_stmt|,
name|mask
decl_stmt|;
name|bfd_vma
name|align_power
init|=
operator|(
name|bfd_vma
operator|)
name|sec
operator|->
name|alignment_power
operator|+
name|OCTETS_PER_BYTE_POWER
decl_stmt|;
comment|/* The COFF back end in BFD requires that all section sizes be      rounded up to multiples of the corresponding section alignments,      supposedly because standard COFF has no other way of encoding alignment      for sections.  If your COFF flavor has a different way of encoding      section alignment, then skip this step, as TICOFF does.  */
name|size
operator|=
name|bfd_get_section_size_before_reloc
argument_list|(
name|sec
argument_list|)
expr_stmt|;
name|mask
operator|=
operator|(
operator|(
name|bfd_vma
operator|)
literal|1
operator|<<
name|align_power
operator|)
operator|-
literal|1
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|TICOFF
argument_list|)
if|if
condition|(
name|size
operator|&
name|mask
condition|)
block|{
name|bfd_vma
name|new_size
decl_stmt|;
name|fragS
modifier|*
name|last
decl_stmt|;
name|new_size
operator|=
operator|(
name|size
operator|+
name|mask
operator|)
operator|&
operator|~
name|mask
expr_stmt|;
name|bfd_set_section_size
argument_list|(
name|stdoutput
argument_list|,
name|sec
argument_list|,
name|new_size
argument_list|)
expr_stmt|;
comment|/* If the size had to be rounded up, add some padding in          the last non-empty frag.  */
name|fragp
operator|=
name|seg_info
argument_list|(
name|sec
argument_list|)
operator|->
name|frchainP
operator|->
name|frch_root
expr_stmt|;
name|last
operator|=
name|seg_info
argument_list|(
name|sec
argument_list|)
operator|->
name|frchainP
operator|->
name|frch_last
expr_stmt|;
while|while
condition|(
name|fragp
operator|->
name|fr_next
operator|!=
name|last
condition|)
name|fragp
operator|=
name|fragp
operator|->
name|fr_next
expr_stmt|;
name|last
operator|->
name|fr_address
operator|=
name|size
expr_stmt|;
name|fragp
operator|->
name|fr_offset
operator|+=
name|new_size
operator|-
name|size
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* If the section size is non-zero, the section symbol needs an aux      entry associated with it, indicating the size.  We don't know      all the values yet; coff_frob_symbol will fill them in later.  */
ifndef|#
directive|ifndef
name|TICOFF
if|if
condition|(
name|size
operator|!=
literal|0
operator|||
name|sec
operator|==
name|text_section
operator|||
name|sec
operator|==
name|data_section
operator|||
name|sec
operator|==
name|bss_section
condition|)
endif|#
directive|endif
block|{
name|symbolS
modifier|*
name|secsym
init|=
name|section_symbol
argument_list|(
name|sec
argument_list|)
decl_stmt|;
name|S_SET_STORAGE_CLASS
argument_list|(
name|secsym
argument_list|,
name|C_STAT
argument_list|)
expr_stmt|;
name|S_SET_NUMBER_AUXILIARY
argument_list|(
name|secsym
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SF_SET_STATICS
argument_list|(
name|secsym
argument_list|)
expr_stmt|;
name|SA_SET_SCN_SCNLEN
argument_list|(
name|secsym
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
comment|/* @@ these should be in a "stabs.h" file, or maybe as.h */
ifndef|#
directive|ifndef
name|STAB_SECTION_NAME
define|#
directive|define
name|STAB_SECTION_NAME
value|".stab"
endif|#
directive|endif
ifndef|#
directive|ifndef
name|STAB_STRING_SECTION_NAME
define|#
directive|define
name|STAB_STRING_SECTION_NAME
value|".stabstr"
endif|#
directive|endif
if|if
condition|(
name|strcmp
argument_list|(
name|STAB_STRING_SECTION_NAME
argument_list|,
name|sec
operator|->
name|name
argument_list|)
condition|)
return|return;
name|strsec
operator|=
name|sec
expr_stmt|;
name|sec
operator|=
name|subseg_get
argument_list|(
name|STAB_SECTION_NAME
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* size is already rounded up, since other section will be listed first */
name|size
operator|=
name|bfd_get_section_size_before_reloc
argument_list|(
name|strsec
argument_list|)
expr_stmt|;
name|n_entries
operator|=
name|bfd_get_section_size_before_reloc
argument_list|(
name|sec
argument_list|)
operator|/
literal|12
operator|-
literal|1
expr_stmt|;
comment|/* Find first non-empty frag.  It should be large enough.  */
name|fragp
operator|=
name|seg_info
argument_list|(
name|sec
argument_list|)
operator|->
name|frchainP
operator|->
name|frch_root
expr_stmt|;
while|while
condition|(
name|fragp
operator|&&
name|fragp
operator|->
name|fr_fix
operator|==
literal|0
condition|)
name|fragp
operator|=
name|fragp
operator|->
name|fr_next
expr_stmt|;
name|assert
argument_list|(
name|fragp
operator|!=
literal|0
operator|&&
name|fragp
operator|->
name|fr_fix
operator|>=
literal|12
argument_list|)
expr_stmt|;
comment|/* Store the values.  */
name|p
operator|=
name|fragp
operator|->
name|fr_literal
expr_stmt|;
name|bfd_h_put_16
argument_list|(
name|stdoutput
argument_list|,
name|n_entries
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|p
operator|+
literal|6
argument_list|)
expr_stmt|;
name|bfd_h_put_32
argument_list|(
name|stdoutput
argument_list|,
name|size
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|p
operator|+
literal|8
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|obj_coff_init_stab_section
parameter_list|(
name|seg
parameter_list|)
name|segT
name|seg
decl_stmt|;
block|{
name|char
modifier|*
name|file
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|stabstr_name
decl_stmt|;
name|unsigned
name|int
name|stroff
decl_stmt|;
comment|/* Make space for this first symbol.  */
name|p
operator|=
name|frag_more
argument_list|(
literal|12
argument_list|)
expr_stmt|;
comment|/* Zero it out.  */
name|memset
argument_list|(
name|p
argument_list|,
literal|0
argument_list|,
literal|12
argument_list|)
expr_stmt|;
name|as_where
argument_list|(
operator|&
name|file
argument_list|,
operator|(
name|unsigned
name|int
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|stabstr_name
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|seg
operator|->
name|name
argument_list|)
operator|+
literal|4
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|stabstr_name
argument_list|,
name|seg
operator|->
name|name
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|stabstr_name
argument_list|,
literal|"str"
argument_list|)
expr_stmt|;
name|stroff
operator|=
name|get_stab_string_offset
argument_list|(
name|file
argument_list|,
name|stabstr_name
argument_list|)
expr_stmt|;
name|know
argument_list|(
name|stroff
operator|==
literal|1
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|p
argument_list|,
name|stroff
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_comment
comment|/* for debugging */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|s_get_name
parameter_list|(
name|s
parameter_list|)
name|symbolS
modifier|*
name|s
decl_stmt|;
block|{
return|return
operator|(
operator|(
name|s
operator|==
name|NULL
operator|)
condition|?
literal|"(NULL)"
else|:
name|S_GET_NAME
argument_list|(
name|s
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|symbol_dump
parameter_list|()
block|{
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
for|for
control|(
name|symbolP
operator|=
name|symbol_rootP
init|;
name|symbolP
condition|;
name|symbolP
operator|=
name|symbol_next
argument_list|(
name|symbolP
argument_list|)
control|)
block|{
name|printf
argument_list|(
name|_
argument_list|(
literal|"0x%lx: \"%s\" type = %ld, class = %d, segment = %d\n"
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|symbolP
argument_list|,
name|S_GET_NAME
argument_list|(
name|symbolP
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|S_GET_DATA_TYPE
argument_list|(
name|symbolP
argument_list|)
argument_list|,
name|S_GET_STORAGE_CLASS
argument_list|(
name|symbolP
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|S_GET_SEGMENT
argument_list|(
name|symbolP
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DEBUG */
end_comment

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* not BFD_ASSEMBLER */
end_comment

begin_include
include|#
directive|include
file|"frags.h"
end_include

begin_comment
comment|/* This is needed because we include internal bfd things.  */
end_comment

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_include
include|#
directive|include
file|"libbfd.h"
end_include

begin_include
include|#
directive|include
file|"libcoff.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|TE_PE
end_ifdef

begin_include
include|#
directive|include
file|"coff/pe.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* The NOP_OPCODE is for the alignment fill value.  Fill with nop so    that we can stick sections together without causing trouble.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|NOP_OPCODE
end_ifndef

begin_define
define|#
directive|define
name|NOP_OPCODE
value|0x00
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* The zeroes if symbol name is longer than 8 chars */
end_comment

begin_define
define|#
directive|define
name|S_SET_ZEROES
parameter_list|(
name|s
parameter_list|,
name|v
parameter_list|)
value|((s)->sy_symbol.ost_entry.n_zeroes = (v))
end_define

begin_define
define|#
directive|define
name|MIN
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|((a)< (b)? (a) : (b))
end_define

begin_comment
comment|/* This vector is used to turn a gas internal segment number into a    section number suitable for insertion into a coff symbol table.    This must correspond to seg_info_off_by_4.  */
end_comment

begin_decl_stmt
specifier|const
name|short
name|seg_N_TYPE
index|[]
init|=
block|{
comment|/* in: segT   out: N_TYPE bits */
name|C_ABS_SECTION
block|,
literal|1
block|,
literal|2
block|,
literal|3
block|,
literal|4
block|,
literal|5
block|,
literal|6
block|,
literal|7
block|,
literal|8
block|,
literal|9
block|,
literal|10
block|,
literal|11
block|,
literal|12
block|,
literal|13
block|,
literal|14
block|,
literal|15
block|,
literal|16
block|,
literal|17
block|,
literal|18
block|,
literal|19
block|,
literal|20
block|,
literal|21
block|,
literal|22
block|,
literal|23
block|,
literal|24
block|,
literal|25
block|,
literal|26
block|,
literal|27
block|,
literal|28
block|,
literal|29
block|,
literal|30
block|,
literal|31
block|,
literal|32
block|,
literal|33
block|,
literal|34
block|,
literal|35
block|,
literal|36
block|,
literal|37
block|,
literal|38
block|,
literal|39
block|,
literal|40
block|,
name|C_UNDEF_SECTION
block|,
comment|/* SEG_UNKNOWN */
name|C_UNDEF_SECTION
block|,
comment|/* SEG_GOOF */
name|C_UNDEF_SECTION
block|,
comment|/* SEG_EXPR */
name|C_DEBUG_SECTION
block|,
comment|/* SEG_DEBUG */
name|C_NTV_SECTION
block|,
comment|/* SEG_NTV */
name|C_PTV_SECTION
block|,
comment|/* SEG_PTV */
name|C_REGISTER_SECTION
block|,
comment|/* SEG_REGISTER */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|function_lineoff
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Offset in line#s where the last function 				   started (the odd entry for line #0) */
end_comment

begin_comment
comment|/* structure used to keep the filenames which    are too long around so that we can stick them    into the string table */
end_comment

begin_struct
struct|struct
name|filename_list
block|{
name|char
modifier|*
name|filename
decl_stmt|;
name|struct
name|filename_list
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|filename_list
modifier|*
name|filename_list_head
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|filename_list
modifier|*
name|filename_list_tail
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|symbolS
modifier|*
name|last_line_symbol
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Add 4 to the real value to get the index and compensate the    negatives. This vector is used by S_GET_SEGMENT to turn a coff    section number into a segment number */
end_comment

begin_decl_stmt
specifier|static
name|symbolS
modifier|*
name|previous_file_symbol
decl_stmt|;
end_decl_stmt

begin_function_decl
name|void
name|c_symbol_merge
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|int
name|line_base
decl_stmt|;
end_decl_stmt

begin_function_decl
name|symbolS
modifier|*
name|c_section_symbol
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|bfd
modifier|*
name|abfd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|fixup_segment
name|PARAMS
argument_list|(
operator|(
name|segment_info_type
operator|*
name|segP
operator|,
name|segT
name|this_segment_type
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|fixup_mdeps
name|PARAMS
argument_list|(
operator|(
name|fragS
operator|*
operator|,
name|object_headers
operator|*
operator|,
name|segT
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|fill_section
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|abfd
operator|,
name|object_headers
operator|*
operator|,
name|unsigned
name|long
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|c_line_new
name|PARAMS
argument_list|(
operator|(
name|symbolS
operator|*
name|symbol
operator|,
name|long
name|paddr
operator|,
name|int
name|line_number
operator|,
name|fragS
operator|*
name|frag
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|w_symbols
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|abfd
operator|,
name|char
operator|*
name|where
operator|,
name|symbolS
operator|*
name|symbol_rootP
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|adjust_stab_section
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|abfd
operator|,
name|segT
name|seg
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|obj_coff_lcomm
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|obj_coff_text
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|obj_coff_data
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|obj_coff_section
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* When not using BFD_ASSEMBLER, we permit up to 40 sections.     This array maps a COFF section number into a gas section number.    Because COFF uses negative section numbers, you must add 4 to the    COFF section number when indexing into this array; this is done via    the SEG_INFO_FROM_SECTION_NUMBER macro.  This must correspond to    seg_N_TYPE.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|segT
name|seg_info_off_by_4
index|[]
init|=
block|{
name|SEG_PTV
block|,
name|SEG_NTV
block|,
name|SEG_DEBUG
block|,
name|SEG_ABSOLUTE
block|,
name|SEG_UNKNOWN
block|,
name|SEG_E0
block|,
name|SEG_E1
block|,
name|SEG_E2
block|,
name|SEG_E3
block|,
name|SEG_E4
block|,
name|SEG_E5
block|,
name|SEG_E6
block|,
name|SEG_E7
block|,
name|SEG_E8
block|,
name|SEG_E9
block|,
name|SEG_E10
block|,
name|SEG_E11
block|,
name|SEG_E12
block|,
name|SEG_E13
block|,
name|SEG_E14
block|,
name|SEG_E15
block|,
name|SEG_E16
block|,
name|SEG_E17
block|,
name|SEG_E18
block|,
name|SEG_E19
block|,
name|SEG_E20
block|,
name|SEG_E21
block|,
name|SEG_E22
block|,
name|SEG_E23
block|,
name|SEG_E24
block|,
name|SEG_E25
block|,
name|SEG_E26
block|,
name|SEG_E27
block|,
name|SEG_E28
block|,
name|SEG_E29
block|,
name|SEG_E30
block|,
name|SEG_E31
block|,
name|SEG_E32
block|,
name|SEG_E33
block|,
name|SEG_E34
block|,
name|SEG_E35
block|,
name|SEG_E36
block|,
name|SEG_E37
block|,
name|SEG_E38
block|,
name|SEG_E39
block|,
operator|(
name|segT
operator|)
literal|40
block|,
operator|(
name|segT
operator|)
literal|41
block|,
operator|(
name|segT
operator|)
literal|42
block|,
operator|(
name|segT
operator|)
literal|43
block|,
operator|(
name|segT
operator|)
literal|44
block|,
operator|(
name|segT
operator|)
literal|45
block|,
operator|(
name|segT
operator|)
literal|0
block|,
operator|(
name|segT
operator|)
literal|0
block|,
operator|(
name|segT
operator|)
literal|0
block|,
name|SEG_REGISTER
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|SEG_INFO_FROM_SECTION_NUMBER
parameter_list|(
name|x
parameter_list|)
value|(seg_info_off_by_4[(x)+4])
end_define

begin_function
specifier|static
name|relax_addressT
name|relax_align
parameter_list|(
name|address
parameter_list|,
name|alignment
parameter_list|)
name|relax_addressT
name|address
decl_stmt|;
name|long
name|alignment
decl_stmt|;
block|{
name|relax_addressT
name|mask
decl_stmt|;
name|relax_addressT
name|new_address
decl_stmt|;
name|mask
operator|=
operator|~
operator|(
operator|(
operator|~
literal|0
operator|)
operator|<<
name|alignment
operator|)
expr_stmt|;
name|new_address
operator|=
operator|(
name|address
operator|+
name|mask
operator|)
operator|&
operator|(
operator|~
name|mask
operator|)
expr_stmt|;
return|return
operator|(
name|new_address
operator|-
name|address
operator|)
return|;
block|}
end_function

begin_function
name|segT
name|s_get_segment
parameter_list|(
name|x
parameter_list|)
name|symbolS
modifier|*
name|x
decl_stmt|;
block|{
return|return
name|SEG_INFO_FROM_SECTION_NUMBER
argument_list|(
name|x
operator|->
name|sy_symbol
operator|.
name|ost_entry
operator|.
name|n_scnum
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* calculate the size of the frag chain and fill in the section header    to contain all of it, also fill in the addr of the sections */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|size_section
parameter_list|(
name|abfd
parameter_list|,
name|idx
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|unsigned
name|int
name|idx
decl_stmt|;
block|{
name|unsigned
name|int
name|size
init|=
literal|0
decl_stmt|;
name|fragS
modifier|*
name|frag
init|=
name|segment_info
index|[
name|idx
index|]
operator|.
name|frchainP
operator|->
name|frch_root
decl_stmt|;
while|while
condition|(
name|frag
condition|)
block|{
name|size
operator|=
name|frag
operator|->
name|fr_address
expr_stmt|;
if|if
condition|(
name|frag
operator|->
name|fr_address
operator|!=
name|size
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"Out of step\n"
argument_list|)
argument_list|)
expr_stmt|;
name|size
operator|=
name|frag
operator|->
name|fr_address
expr_stmt|;
block|}
switch|switch
condition|(
name|frag
operator|->
name|fr_type
condition|)
block|{
ifdef|#
directive|ifdef
name|TC_COFF_SIZEMACHDEP
case|case
name|rs_machine_dependent
case|:
name|size
operator|+=
name|TC_COFF_SIZEMACHDEP
argument_list|(
name|frag
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|rs_space
case|:
name|assert
argument_list|(
name|frag
operator|->
name|fr_symbol
operator|==
literal|0
argument_list|)
expr_stmt|;
case|case
name|rs_fill
case|:
case|case
name|rs_org
case|:
name|size
operator|+=
name|frag
operator|->
name|fr_fix
expr_stmt|;
name|size
operator|+=
name|frag
operator|->
name|fr_offset
operator|*
name|frag
operator|->
name|fr_var
expr_stmt|;
break|break;
case|case
name|rs_align
case|:
case|case
name|rs_align_code
case|:
case|case
name|rs_align_test
case|:
block|{
name|addressT
name|off
decl_stmt|;
name|size
operator|+=
name|frag
operator|->
name|fr_fix
expr_stmt|;
name|off
operator|=
name|relax_align
argument_list|(
name|size
argument_list|,
name|frag
operator|->
name|fr_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|frag
operator|->
name|fr_subtype
operator|!=
literal|0
operator|&&
name|off
operator|>
name|frag
operator|->
name|fr_subtype
condition|)
name|off
operator|=
literal|0
expr_stmt|;
name|size
operator|+=
name|off
expr_stmt|;
block|}
break|break;
default|default:
name|BAD_CASE
argument_list|(
name|frag
operator|->
name|fr_type
argument_list|)
expr_stmt|;
break|break;
block|}
name|frag
operator|=
name|frag
operator|->
name|fr_next
expr_stmt|;
block|}
name|segment_info
index|[
name|idx
index|]
operator|.
name|scnhdr
operator|.
name|s_size
operator|=
name|size
expr_stmt|;
return|return
name|size
return|;
block|}
end_function

begin_function
specifier|static
name|unsigned
name|int
name|count_entries_in_chain
parameter_list|(
name|idx
parameter_list|)
name|unsigned
name|int
name|idx
decl_stmt|;
block|{
name|unsigned
name|int
name|nrelocs
decl_stmt|;
name|fixS
modifier|*
name|fixup_ptr
decl_stmt|;
comment|/* Count the relocations */
name|fixup_ptr
operator|=
name|segment_info
index|[
name|idx
index|]
operator|.
name|fix_root
expr_stmt|;
name|nrelocs
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|fixup_ptr
operator|!=
operator|(
name|fixS
operator|*
operator|)
name|NULL
condition|)
block|{
if|if
condition|(
name|fixup_ptr
operator|->
name|fx_done
operator|==
literal|0
operator|&&
name|TC_COUNT_RELOC
argument_list|(
name|fixup_ptr
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|TC_A29K
if|if
condition|(
name|fixup_ptr
operator|->
name|fx_r_type
operator|==
name|RELOC_CONSTH
condition|)
name|nrelocs
operator|+=
literal|2
expr_stmt|;
else|else
name|nrelocs
operator|++
expr_stmt|;
else|#
directive|else
name|nrelocs
operator|++
expr_stmt|;
endif|#
directive|endif
block|}
name|fixup_ptr
operator|=
name|fixup_ptr
operator|->
name|fx_next
expr_stmt|;
block|}
return|return
name|nrelocs
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|TE_AUX
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|compare_external_relocs
name|PARAMS
argument_list|(
operator|(
specifier|const
name|PTR
operator|,
specifier|const
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* AUX's ld expects relocations to be sorted */
end_comment

begin_function
specifier|static
name|int
name|compare_external_relocs
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
specifier|const
name|PTR
name|x
decl_stmt|;
specifier|const
name|PTR
name|y
decl_stmt|;
block|{
name|struct
name|external_reloc
modifier|*
name|a
init|=
operator|(
expr|struct
name|external_reloc
operator|*
operator|)
name|x
decl_stmt|;
name|struct
name|external_reloc
modifier|*
name|b
init|=
operator|(
expr|struct
name|external_reloc
operator|*
operator|)
name|y
decl_stmt|;
name|bfd_vma
name|aadr
init|=
name|bfd_getb32
argument_list|(
name|a
operator|->
name|r_vaddr
argument_list|)
decl_stmt|;
name|bfd_vma
name|badr
init|=
name|bfd_getb32
argument_list|(
name|b
operator|->
name|r_vaddr
argument_list|)
decl_stmt|;
return|return
operator|(
name|aadr
operator|<
name|badr
condition|?
operator|-
literal|1
else|:
name|badr
operator|<
name|aadr
condition|?
literal|1
else|:
literal|0
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* output all the relocations for a section */
end_comment

begin_function
name|void
name|do_relocs_for
parameter_list|(
name|abfd
parameter_list|,
name|h
parameter_list|,
name|file_cursor
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|object_headers
modifier|*
name|h
decl_stmt|;
name|unsigned
name|long
modifier|*
name|file_cursor
decl_stmt|;
block|{
name|unsigned
name|int
name|nrelocs
decl_stmt|;
name|unsigned
name|int
name|idx
decl_stmt|;
name|unsigned
name|long
name|reloc_start
init|=
operator|*
name|file_cursor
decl_stmt|;
for|for
control|(
name|idx
operator|=
name|SEG_E0
init|;
name|idx
operator|<
name|SEG_LAST
condition|;
name|idx
operator|++
control|)
block|{
if|if
condition|(
name|segment_info
index|[
name|idx
index|]
operator|.
name|scnhdr
operator|.
name|s_name
index|[
literal|0
index|]
condition|)
block|{
name|struct
name|external_reloc
modifier|*
name|ext_ptr
decl_stmt|;
name|struct
name|external_reloc
modifier|*
name|external_reloc_vec
decl_stmt|;
name|unsigned
name|int
name|external_reloc_size
decl_stmt|;
name|unsigned
name|int
name|base
init|=
name|segment_info
index|[
name|idx
index|]
operator|.
name|scnhdr
operator|.
name|s_paddr
decl_stmt|;
name|fixS
modifier|*
name|fix_ptr
init|=
name|segment_info
index|[
name|idx
index|]
operator|.
name|fix_root
decl_stmt|;
name|nrelocs
operator|=
name|count_entries_in_chain
argument_list|(
name|idx
argument_list|)
expr_stmt|;
if|if
condition|(
name|nrelocs
condition|)
comment|/* Bypass this stuff if no relocs.  This also incidentally 	       avoids a SCO bug, where free(malloc(0)) tends to crash.  */
block|{
name|external_reloc_size
operator|=
name|nrelocs
operator|*
name|RELSZ
expr_stmt|;
name|external_reloc_vec
operator|=
operator|(
expr|struct
name|external_reloc
operator|*
operator|)
name|malloc
argument_list|(
name|external_reloc_size
argument_list|)
expr_stmt|;
name|ext_ptr
operator|=
name|external_reloc_vec
expr_stmt|;
comment|/* Fill in the internal coff style reloc struct from the 		 internal fix list.  */
while|while
condition|(
name|fix_ptr
condition|)
block|{
name|struct
name|internal_reloc
name|intr
decl_stmt|;
comment|/* Only output some of the relocations */
if|if
condition|(
name|fix_ptr
operator|->
name|fx_done
operator|==
literal|0
operator|&&
name|TC_COUNT_RELOC
argument_list|(
name|fix_ptr
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|TC_RELOC_MANGLE
name|TC_RELOC_MANGLE
argument_list|(
operator|&
name|segment_info
index|[
name|idx
index|]
argument_list|,
name|fix_ptr
argument_list|,
operator|&
name|intr
argument_list|,
name|base
argument_list|)
expr_stmt|;
else|#
directive|else
name|symbolS
modifier|*
name|dot
decl_stmt|;
name|symbolS
modifier|*
name|symbol_ptr
init|=
name|fix_ptr
operator|->
name|fx_addsy
decl_stmt|;
name|intr
operator|.
name|r_type
operator|=
name|TC_COFF_FIX2RTYPE
argument_list|(
name|fix_ptr
argument_list|)
expr_stmt|;
name|intr
operator|.
name|r_vaddr
operator|=
name|base
operator|+
name|fix_ptr
operator|->
name|fx_frag
operator|->
name|fr_address
operator|+
name|fix_ptr
operator|->
name|fx_where
expr_stmt|;
ifdef|#
directive|ifdef
name|TC_KEEP_FX_OFFSET
name|intr
operator|.
name|r_offset
operator|=
name|fix_ptr
operator|->
name|fx_offset
expr_stmt|;
else|#
directive|else
name|intr
operator|.
name|r_offset
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
while|while
condition|(
name|symbol_ptr
operator|->
name|sy_value
operator|.
name|X_op
operator|==
name|O_symbol
operator|&&
operator|(
operator|!
name|S_IS_DEFINED
argument_list|(
name|symbol_ptr
argument_list|)
operator|||
name|S_IS_COMMON
argument_list|(
name|symbol_ptr
argument_list|)
operator|)
condition|)
block|{
name|symbolS
modifier|*
name|n
decl_stmt|;
comment|/* We must avoid looping, as that can occur                              with a badly written program.  */
name|n
operator|=
name|symbol_ptr
operator|->
name|sy_value
operator|.
name|X_add_symbol
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|symbol_ptr
condition|)
break|break;
name|symbol_ptr
operator|=
name|n
expr_stmt|;
block|}
comment|/* Turn the segment of the symbol into an offset.  */
if|if
condition|(
name|symbol_ptr
condition|)
block|{
name|resolve_symbol_value
argument_list|(
name|symbol_ptr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|symbol_ptr
operator|->
name|sy_resolved
condition|)
block|{
name|char
modifier|*
name|file
decl_stmt|;
name|unsigned
name|int
name|line
decl_stmt|;
if|if
condition|(
name|expr_symbol_where
argument_list|(
name|symbol_ptr
argument_list|,
operator|&
name|file
argument_list|,
operator|&
name|line
argument_list|)
condition|)
name|as_bad_where
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
name|_
argument_list|(
literal|"unresolved relocation"
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"bad relocation: symbol `%s' not in symbol table"
argument_list|)
argument_list|,
name|S_GET_NAME
argument_list|(
name|symbol_ptr
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|dot
operator|=
name|segment_info
index|[
name|S_GET_SEGMENT
argument_list|(
name|symbol_ptr
argument_list|)
index|]
operator|.
name|dot
expr_stmt|;
if|if
condition|(
name|dot
condition|)
block|{
name|intr
operator|.
name|r_symndx
operator|=
name|dot
operator|->
name|sy_number
expr_stmt|;
block|}
else|else
block|{
name|intr
operator|.
name|r_symndx
operator|=
name|symbol_ptr
operator|->
name|sy_number
expr_stmt|;
block|}
block|}
else|else
block|{
name|intr
operator|.
name|r_symndx
operator|=
operator|-
literal|1
expr_stmt|;
block|}
endif|#
directive|endif
operator|(
name|void
operator|)
name|bfd_coff_swap_reloc_out
argument_list|(
name|abfd
argument_list|,
operator|&
name|intr
argument_list|,
name|ext_ptr
argument_list|)
expr_stmt|;
name|ext_ptr
operator|++
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|TC_A29K
argument_list|)
comment|/* The 29k has a special kludge for the high 16 bit 			 reloc.  Two relocations are emited, R_IHIHALF, 			 and R_IHCONST. The second one doesn't contain a 			 symbol, but uses the value for offset.  */
if|if
condition|(
name|intr
operator|.
name|r_type
operator|==
name|R_IHIHALF
condition|)
block|{
comment|/* now emit the second bit */
name|intr
operator|.
name|r_type
operator|=
name|R_IHCONST
expr_stmt|;
name|intr
operator|.
name|r_symndx
operator|=
name|fix_ptr
operator|->
name|fx_addnumber
expr_stmt|;
operator|(
name|void
operator|)
name|bfd_coff_swap_reloc_out
argument_list|(
name|abfd
argument_list|,
operator|&
name|intr
argument_list|,
name|ext_ptr
argument_list|)
expr_stmt|;
name|ext_ptr
operator|++
expr_stmt|;
block|}
endif|#
directive|endif
block|}
name|fix_ptr
operator|=
name|fix_ptr
operator|->
name|fx_next
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|TE_AUX
comment|/* Sort the reloc table */
name|qsort
argument_list|(
operator|(
name|PTR
operator|)
name|external_reloc_vec
argument_list|,
name|nrelocs
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|external_reloc
argument_list|)
argument_list|,
name|compare_external_relocs
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Write out the reloc table */
name|bfd_write
argument_list|(
operator|(
name|PTR
operator|)
name|external_reloc_vec
argument_list|,
literal|1
argument_list|,
name|external_reloc_size
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|external_reloc_vec
argument_list|)
expr_stmt|;
comment|/* Fill in section header info.  */
name|segment_info
index|[
name|idx
index|]
operator|.
name|scnhdr
operator|.
name|s_relptr
operator|=
operator|*
name|file_cursor
expr_stmt|;
operator|*
name|file_cursor
operator|+=
name|external_reloc_size
expr_stmt|;
name|segment_info
index|[
name|idx
index|]
operator|.
name|scnhdr
operator|.
name|s_nreloc
operator|=
name|nrelocs
expr_stmt|;
block|}
else|else
block|{
comment|/* No relocs */
name|segment_info
index|[
name|idx
index|]
operator|.
name|scnhdr
operator|.
name|s_relptr
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
comment|/* Set relocation_size field in file headers */
name|H_SET_RELOCATION_SIZE
argument_list|(
name|h
argument_list|,
operator|*
name|file_cursor
operator|-
name|reloc_start
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* run through a frag chain and write out the data to go with it, fill    in the scnhdrs with the info on the file postions */
end_comment

begin_function
specifier|static
name|void
name|fill_section
parameter_list|(
name|abfd
parameter_list|,
name|h
parameter_list|,
name|file_cursor
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|object_headers
modifier|*
name|h
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|unsigned
name|long
modifier|*
name|file_cursor
decl_stmt|;
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|unsigned
name|int
name|paddr
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
name|SEG_E0
init|;
name|i
operator|<
name|SEG_UNKNOWN
condition|;
name|i
operator|++
control|)
block|{
name|unsigned
name|int
name|offset
init|=
literal|0
decl_stmt|;
name|struct
name|internal_scnhdr
modifier|*
name|s
init|=
operator|&
operator|(
name|segment_info
index|[
name|i
index|]
operator|.
name|scnhdr
operator|)
decl_stmt|;
name|PROGRESS
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|s_name
index|[
literal|0
index|]
condition|)
block|{
name|fragS
modifier|*
name|frag
init|=
name|segment_info
index|[
name|i
index|]
operator|.
name|frchainP
operator|->
name|frch_root
decl_stmt|;
name|char
modifier|*
name|buffer
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|s
operator|->
name|s_size
operator|==
literal|0
condition|)
name|s
operator|->
name|s_scnptr
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|buffer
operator|=
name|xmalloc
argument_list|(
name|s
operator|->
name|s_size
argument_list|)
expr_stmt|;
name|s
operator|->
name|s_scnptr
operator|=
operator|*
name|file_cursor
expr_stmt|;
block|}
name|know
argument_list|(
name|s
operator|->
name|s_paddr
operator|==
name|paddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|s
operator|->
name|s_name
argument_list|,
literal|".text"
argument_list|)
operator|==
literal|0
condition|)
name|s
operator|->
name|s_flags
operator||=
name|STYP_TEXT
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|s
operator|->
name|s_name
argument_list|,
literal|".data"
argument_list|)
operator|==
literal|0
condition|)
name|s
operator|->
name|s_flags
operator||=
name|STYP_DATA
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|s
operator|->
name|s_name
argument_list|,
literal|".bss"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|s
operator|->
name|s_scnptr
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|s_flags
operator||=
name|STYP_BSS
expr_stmt|;
comment|/* @@ Should make the i386 and a29k coff targets define 		 COFF_NOLOAD_PROBLEM, and have only one test here.  */
ifndef|#
directive|ifndef
name|TC_I386
ifndef|#
directive|ifndef
name|TC_A29K
ifndef|#
directive|ifndef
name|COFF_NOLOAD_PROBLEM
comment|/* Apparently the SVR3 linker (and exec syscall) and UDI 		 mondfe progrem are confused by noload sections.  */
name|s
operator|->
name|s_flags
operator||=
name|STYP_NOLOAD
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|s
operator|->
name|s_name
argument_list|,
literal|".lit"
argument_list|)
operator|==
literal|0
condition|)
name|s
operator|->
name|s_flags
operator|=
name|STYP_LIT
operator||
name|STYP_TEXT
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|s
operator|->
name|s_name
argument_list|,
literal|".init"
argument_list|)
operator|==
literal|0
condition|)
name|s
operator|->
name|s_flags
operator||=
name|STYP_TEXT
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|s
operator|->
name|s_name
argument_list|,
literal|".fini"
argument_list|)
operator|==
literal|0
condition|)
name|s
operator|->
name|s_flags
operator||=
name|STYP_TEXT
expr_stmt|;
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|s
operator|->
name|s_name
argument_list|,
literal|".comment"
argument_list|,
literal|8
argument_list|)
operator|==
literal|0
condition|)
name|s
operator|->
name|s_flags
operator||=
name|STYP_INFO
expr_stmt|;
while|while
condition|(
name|frag
condition|)
block|{
name|unsigned
name|int
name|fill_size
decl_stmt|;
switch|switch
condition|(
name|frag
operator|->
name|fr_type
condition|)
block|{
case|case
name|rs_machine_dependent
case|:
if|if
condition|(
name|frag
operator|->
name|fr_fix
condition|)
block|{
name|memcpy
argument_list|(
name|buffer
operator|+
name|frag
operator|->
name|fr_address
argument_list|,
name|frag
operator|->
name|fr_literal
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|frag
operator|->
name|fr_fix
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|frag
operator|->
name|fr_fix
expr_stmt|;
block|}
break|break;
case|case
name|rs_space
case|:
name|assert
argument_list|(
name|frag
operator|->
name|fr_symbol
operator|==
literal|0
argument_list|)
expr_stmt|;
case|case
name|rs_fill
case|:
case|case
name|rs_align
case|:
case|case
name|rs_align_code
case|:
case|case
name|rs_align_test
case|:
case|case
name|rs_org
case|:
if|if
condition|(
name|frag
operator|->
name|fr_fix
condition|)
block|{
name|memcpy
argument_list|(
name|buffer
operator|+
name|frag
operator|->
name|fr_address
argument_list|,
name|frag
operator|->
name|fr_literal
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|frag
operator|->
name|fr_fix
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|frag
operator|->
name|fr_fix
expr_stmt|;
block|}
name|fill_size
operator|=
name|frag
operator|->
name|fr_var
expr_stmt|;
if|if
condition|(
name|fill_size
operator|&&
name|frag
operator|->
name|fr_offset
operator|>
literal|0
condition|)
block|{
name|unsigned
name|int
name|count
decl_stmt|;
name|unsigned
name|int
name|off
init|=
name|frag
operator|->
name|fr_fix
decl_stmt|;
for|for
control|(
name|count
operator|=
name|frag
operator|->
name|fr_offset
init|;
name|count
condition|;
name|count
operator|--
control|)
block|{
if|if
condition|(
name|fill_size
operator|+
name|frag
operator|->
name|fr_address
operator|+
name|off
operator|<=
name|s
operator|->
name|s_size
condition|)
block|{
name|memcpy
argument_list|(
name|buffer
operator|+
name|frag
operator|->
name|fr_address
operator|+
name|off
argument_list|,
name|frag
operator|->
name|fr_literal
operator|+
name|frag
operator|->
name|fr_fix
argument_list|,
name|fill_size
argument_list|)
expr_stmt|;
name|off
operator|+=
name|fill_size
expr_stmt|;
name|offset
operator|+=
name|fill_size
expr_stmt|;
block|}
block|}
block|}
break|break;
case|case
name|rs_broken_word
case|:
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|frag
operator|=
name|frag
operator|->
name|fr_next
expr_stmt|;
block|}
if|if
condition|(
name|s
operator|->
name|s_size
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|s
operator|->
name|s_scnptr
operator|!=
literal|0
condition|)
block|{
name|bfd_write
argument_list|(
name|buffer
argument_list|,
name|s
operator|->
name|s_size
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
operator|*
name|file_cursor
operator|+=
name|s
operator|->
name|s_size
expr_stmt|;
block|}
name|free
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
block|}
name|paddr
operator|+=
name|s
operator|->
name|s_size
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Coff file generation& utilities */
end_comment

begin_function
specifier|static
name|void
name|coff_header_append
parameter_list|(
name|abfd
parameter_list|,
name|h
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|object_headers
modifier|*
name|h
decl_stmt|;
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|char
name|buffer
index|[
literal|1000
index|]
decl_stmt|;
name|char
name|buffero
index|[
literal|1000
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|COFF_LONG_SECTION_NAMES
name|unsigned
name|long
name|string_size
init|=
literal|4
decl_stmt|;
endif|#
directive|endif
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|OBJ_COFF_OMIT_OPTIONAL_HEADER
name|H_SET_MAGIC_NUMBER
argument_list|(
name|h
argument_list|,
name|COFF_MAGIC
argument_list|)
expr_stmt|;
name|H_SET_VERSION_STAMP
argument_list|(
name|h
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|H_SET_ENTRY_POINT
argument_list|(
name|h
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|H_SET_TEXT_START
argument_list|(
name|h
argument_list|,
name|segment_info
index|[
name|SEG_E0
index|]
operator|.
name|frchainP
operator|->
name|frch_root
operator|->
name|fr_address
argument_list|)
expr_stmt|;
name|H_SET_DATA_START
argument_list|(
name|h
argument_list|,
name|segment_info
index|[
name|SEG_E1
index|]
operator|.
name|frchainP
operator|->
name|frch_root
operator|->
name|fr_address
argument_list|)
expr_stmt|;
name|H_SET_SIZEOF_OPTIONAL_HEADER
argument_list|(
name|h
argument_list|,
name|bfd_coff_swap_aouthdr_out
argument_list|(
name|abfd
argument_list|,
operator|&
name|h
operator|->
name|aouthdr
argument_list|,
name|buffero
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* defined (OBJ_COFF_OMIT_OPTIONAL_HEADER) */
name|H_SET_SIZEOF_OPTIONAL_HEADER
argument_list|(
name|h
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* defined (OBJ_COFF_OMIT_OPTIONAL_HEADER) */
name|i
operator|=
name|bfd_coff_swap_filehdr_out
argument_list|(
name|abfd
argument_list|,
operator|&
name|h
operator|->
name|filehdr
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
name|bfd_write
argument_list|(
name|buffer
argument_list|,
name|i
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
name|bfd_write
argument_list|(
name|buffero
argument_list|,
name|H_GET_SIZEOF_OPTIONAL_HEADER
argument_list|(
name|h
argument_list|)
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|SEG_E0
init|;
name|i
operator|<
name|SEG_LAST
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|segment_info
index|[
name|i
index|]
operator|.
name|scnhdr
operator|.
name|s_name
index|[
literal|0
index|]
condition|)
block|{
name|unsigned
name|int
name|size
decl_stmt|;
ifdef|#
directive|ifdef
name|COFF_LONG_SECTION_NAMES
comment|/* Support long section names as found in PE.  This code              must coordinate with that in write_object_file and              w_strings.  */
if|if
condition|(
name|strlen
argument_list|(
name|segment_info
index|[
name|i
index|]
operator|.
name|name
argument_list|)
operator|>
name|SCNNMLEN
condition|)
block|{
name|memset
argument_list|(
name|segment_info
index|[
name|i
index|]
operator|.
name|scnhdr
operator|.
name|s_name
argument_list|,
literal|0
argument_list|,
name|SCNNMLEN
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|segment_info
index|[
name|i
index|]
operator|.
name|scnhdr
operator|.
name|s_name
argument_list|,
literal|"/%lu"
argument_list|,
name|string_size
argument_list|)
expr_stmt|;
name|string_size
operator|+=
name|strlen
argument_list|(
name|segment_info
index|[
name|i
index|]
operator|.
name|name
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
endif|#
directive|endif
name|size
operator|=
name|bfd_coff_swap_scnhdr_out
argument_list|(
name|abfd
argument_list|,
operator|&
operator|(
name|segment_info
index|[
name|i
index|]
operator|.
name|scnhdr
operator|)
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|==
literal|0
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"bfd_coff_swap_scnhdr_out failed"
argument_list|)
argument_list|)
expr_stmt|;
name|bfd_write
argument_list|(
name|buffer
argument_list|,
name|size
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|char
modifier|*
name|symbol_to_chars
parameter_list|(
name|abfd
parameter_list|,
name|where
parameter_list|,
name|symbolP
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|char
modifier|*
name|where
decl_stmt|;
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
block|{
name|unsigned
name|int
name|numaux
init|=
name|symbolP
operator|->
name|sy_symbol
operator|.
name|ost_entry
operator|.
name|n_numaux
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|valueT
name|val
decl_stmt|;
comment|/* Turn any symbols with register attributes into abs symbols */
if|if
condition|(
name|S_GET_SEGMENT
argument_list|(
name|symbolP
argument_list|)
operator|==
name|reg_section
condition|)
block|{
name|S_SET_SEGMENT
argument_list|(
name|symbolP
argument_list|,
name|absolute_section
argument_list|)
expr_stmt|;
block|}
comment|/* At the same time, relocate all symbols to their output value */
ifndef|#
directive|ifndef
name|TE_PE
name|val
operator|=
operator|(
name|segment_info
index|[
name|S_GET_SEGMENT
argument_list|(
name|symbolP
argument_list|)
index|]
operator|.
name|scnhdr
operator|.
name|s_paddr
operator|+
name|S_GET_VALUE
argument_list|(
name|symbolP
argument_list|)
operator|)
expr_stmt|;
else|#
directive|else
name|val
operator|=
name|S_GET_VALUE
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|S_SET_VALUE
argument_list|(
name|symbolP
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|symbolP
operator|->
name|sy_symbol
operator|.
name|ost_entry
operator|.
name|n_value
operator|=
name|val
expr_stmt|;
name|where
operator|+=
name|bfd_coff_swap_sym_out
argument_list|(
name|abfd
argument_list|,
operator|&
name|symbolP
operator|->
name|sy_symbol
operator|.
name|ost_entry
argument_list|,
name|where
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numaux
condition|;
name|i
operator|++
control|)
block|{
name|where
operator|+=
name|bfd_coff_swap_aux_out
argument_list|(
name|abfd
argument_list|,
operator|&
name|symbolP
operator|->
name|sy_symbol
operator|.
name|ost_auxent
index|[
name|i
index|]
argument_list|,
name|S_GET_DATA_TYPE
argument_list|(
name|symbolP
argument_list|)
argument_list|,
name|S_GET_STORAGE_CLASS
argument_list|(
name|symbolP
argument_list|)
argument_list|,
name|i
argument_list|,
name|numaux
argument_list|,
name|where
argument_list|)
expr_stmt|;
block|}
return|return
name|where
return|;
block|}
end_function

begin_function
name|void
name|coff_obj_symbol_new_hook
parameter_list|(
name|symbolP
parameter_list|)
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
block|{
name|char
name|underscore
init|=
literal|0
decl_stmt|;
comment|/* Symbol has leading _ */
comment|/* Effective symbol */
comment|/* Store the pointer in the offset.  */
name|S_SET_ZEROES
argument_list|(
name|symbolP
argument_list|,
literal|0L
argument_list|)
expr_stmt|;
name|S_SET_DATA_TYPE
argument_list|(
name|symbolP
argument_list|,
name|T_NULL
argument_list|)
expr_stmt|;
name|S_SET_STORAGE_CLASS
argument_list|(
name|symbolP
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|S_SET_NUMBER_AUXILIARY
argument_list|(
name|symbolP
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Additional information */
name|symbolP
operator|->
name|sy_symbol
operator|.
name|ost_flags
operator|=
literal|0
expr_stmt|;
comment|/* Auxiliary entries */
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|symbolP
operator|->
name|sy_symbol
operator|.
name|ost_auxent
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|,
name|AUXESZ
argument_list|)
expr_stmt|;
if|if
condition|(
name|S_IS_STRING
argument_list|(
name|symbolP
argument_list|)
condition|)
name|SF_SET_STRING
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|underscore
operator|&&
name|S_IS_LOCAL
argument_list|(
name|symbolP
argument_list|)
condition|)
name|SF_SET_LOCAL
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Handle .ln directives.  */
end_comment

begin_function
specifier|static
name|void
name|obj_coff_ln
parameter_list|(
name|appline
parameter_list|)
name|int
name|appline
decl_stmt|;
block|{
name|int
name|l
decl_stmt|;
if|if
condition|(
operator|!
name|appline
operator|&&
name|def_symbol_in_progress
operator|!=
name|NULL
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|".ln pseudo-op inside .def/.endef: ignored."
argument_list|)
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
comment|/* wrong context */
name|l
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
name|c_line_new
argument_list|(
literal|0
argument_list|,
name|frag_now_fix
argument_list|()
argument_list|,
name|l
argument_list|,
name|frag_now
argument_list|)
expr_stmt|;
if|if
condition|(
name|appline
condition|)
name|new_logical_line
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|l
operator|-
literal|1
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|NO_LISTING
block|{
specifier|extern
name|int
name|listing
decl_stmt|;
if|if
condition|(
name|listing
condition|)
block|{
if|if
condition|(
operator|!
name|appline
condition|)
name|l
operator|+=
name|line_base
operator|-
literal|1
expr_stmt|;
name|listing_source_line
argument_list|(
operator|(
name|unsigned
name|int
operator|)
name|l
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *			def()  *  * Handle .def directives.  *  * One might ask : why can't we symbol_new if the symbol does not  * already exist and fill it with debug information.  Because of  * the C_EFCN special symbol. It would clobber the value of the  * function symbol before we have a chance to notice that it is  * a C_EFCN. And a second reason is that the code is more clear this  * way. (at least I think it is :-).  *  */
end_comment

begin_define
define|#
directive|define
name|SKIP_SEMI_COLON
parameter_list|()
value|while (*input_line_pointer++ != ';')
end_define

begin_define
define|#
directive|define
name|SKIP_WHITESPACES
parameter_list|()
value|while (*input_line_pointer == ' ' || \ 				      *input_line_pointer == '\t') \                                          input_line_pointer++;
end_define

begin_function
specifier|static
name|void
name|obj_coff_def
parameter_list|(
name|what
parameter_list|)
name|int
name|what
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|char
name|name_end
decl_stmt|;
comment|/* Char after the end of name */
name|char
modifier|*
name|symbol_name
decl_stmt|;
comment|/* Name of the debug symbol */
name|char
modifier|*
name|symbol_name_copy
decl_stmt|;
comment|/* Temporary copy of the name */
name|unsigned
name|int
name|symbol_name_length
decl_stmt|;
if|if
condition|(
name|def_symbol_in_progress
operator|!=
name|NULL
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|".def pseudo-op used inside of .def/.endef: ignored."
argument_list|)
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
comment|/* if not inside .def/.endef */
name|SKIP_WHITESPACES
argument_list|()
expr_stmt|;
name|def_symbol_in_progress
operator|=
operator|(
name|symbolS
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|notes
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|def_symbol_in_progress
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|def_symbol_in_progress
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|def_symbol_in_progress
argument_list|)
argument_list|)
expr_stmt|;
name|symbol_name
operator|=
name|input_line_pointer
expr_stmt|;
name|name_end
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
name|symbol_name_length
operator|=
name|strlen
argument_list|(
name|symbol_name
argument_list|)
expr_stmt|;
name|symbol_name_copy
operator|=
name|xmalloc
argument_list|(
name|symbol_name_length
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|symbol_name_copy
argument_list|,
name|symbol_name
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|tc_canonicalize_symbol_name
name|symbol_name_copy
operator|=
name|tc_canonicalize_symbol_name
argument_list|(
name|symbol_name_copy
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Initialize the new symbol */
ifdef|#
directive|ifdef
name|STRIP_UNDERSCORE
name|S_SET_NAME
argument_list|(
name|def_symbol_in_progress
argument_list|,
operator|(
operator|*
name|symbol_name_copy
operator|==
literal|'_'
condition|?
name|symbol_name_copy
operator|+
literal|1
else|:
name|symbol_name_copy
operator|)
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* STRIP_UNDERSCORE */
name|S_SET_NAME
argument_list|(
name|def_symbol_in_progress
argument_list|,
name|symbol_name_copy
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* STRIP_UNDERSCORE */
comment|/* free(symbol_name_copy); */
name|def_symbol_in_progress
operator|->
name|sy_name_offset
operator|=
operator|(
name|unsigned
name|long
operator|)
operator|~
literal|0
expr_stmt|;
name|def_symbol_in_progress
operator|->
name|sy_number
operator|=
operator|~
literal|0
expr_stmt|;
name|def_symbol_in_progress
operator|->
name|sy_frag
operator|=
operator|&
name|zero_address_frag
expr_stmt|;
name|S_SET_VALUE
argument_list|(
name|def_symbol_in_progress
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|S_IS_STRING
argument_list|(
name|def_symbol_in_progress
argument_list|)
condition|)
name|SF_SET_STRING
argument_list|(
name|def_symbol_in_progress
argument_list|)
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
name|name_end
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|unsigned
name|int
name|dim_index
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|obj_coff_endef
parameter_list|(
name|ignore
parameter_list|)
name|int
name|ignore
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|symbolS
modifier|*
name|symbolP
init|=
literal|0
decl_stmt|;
comment|/* DIM BUG FIX sac@cygnus.com */
name|dim_index
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|def_symbol_in_progress
operator|==
name|NULL
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|".endef pseudo-op used outside of .def/.endef: ignored."
argument_list|)
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
comment|/* if not inside .def/.endef */
comment|/* Set the section number according to storage class.  */
switch|switch
condition|(
name|S_GET_STORAGE_CLASS
argument_list|(
name|def_symbol_in_progress
argument_list|)
condition|)
block|{
case|case
name|C_STRTAG
case|:
case|case
name|C_ENTAG
case|:
case|case
name|C_UNTAG
case|:
name|SF_SET_TAG
argument_list|(
name|def_symbol_in_progress
argument_list|)
expr_stmt|;
comment|/* intentional fallthrough */
case|case
name|C_FILE
case|:
case|case
name|C_TPDEF
case|:
name|SF_SET_DEBUG
argument_list|(
name|def_symbol_in_progress
argument_list|)
expr_stmt|;
name|S_SET_SEGMENT
argument_list|(
name|def_symbol_in_progress
argument_list|,
name|SEG_DEBUG
argument_list|)
expr_stmt|;
break|break;
case|case
name|C_EFCN
case|:
name|SF_SET_LOCAL
argument_list|(
name|def_symbol_in_progress
argument_list|)
expr_stmt|;
comment|/* Do not emit this symbol.  */
comment|/* intentional fallthrough */
case|case
name|C_BLOCK
case|:
name|SF_SET_PROCESS
argument_list|(
name|def_symbol_in_progress
argument_list|)
expr_stmt|;
comment|/* Will need processing before writing */
comment|/* intentional fallthrough */
case|case
name|C_FCN
case|:
name|S_SET_SEGMENT
argument_list|(
name|def_symbol_in_progress
argument_list|,
name|SEG_E0
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|S_GET_NAME
argument_list|(
name|def_symbol_in_progress
argument_list|)
argument_list|,
literal|".bf"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* .bf */
if|if
condition|(
name|function_lineoff
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"`.bf' symbol without preceding function\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* missing function symbol */
name|SA_GET_SYM_LNNOPTR
argument_list|(
name|last_line_symbol
argument_list|)
operator|=
name|function_lineoff
expr_stmt|;
name|SF_SET_PROCESS
argument_list|(
name|last_line_symbol
argument_list|)
expr_stmt|;
name|SF_SET_ADJ_LNNOPTR
argument_list|(
name|last_line_symbol
argument_list|)
expr_stmt|;
name|SF_SET_PROCESS
argument_list|(
name|def_symbol_in_progress
argument_list|)
expr_stmt|;
name|function_lineoff
operator|=
operator|-
literal|1
expr_stmt|;
block|}
comment|/* Value is always set to .  */
name|def_symbol_in_progress
operator|->
name|sy_frag
operator|=
name|frag_now
expr_stmt|;
name|S_SET_VALUE
argument_list|(
name|def_symbol_in_progress
argument_list|,
operator|(
name|valueT
operator|)
name|frag_now_fix
argument_list|()
argument_list|)
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|C_AUTOARG
case|case
name|C_AUTOARG
case|:
endif|#
directive|endif
comment|/* C_AUTOARG */
case|case
name|C_AUTO
case|:
case|case
name|C_REG
case|:
case|case
name|C_MOS
case|:
case|case
name|C_MOE
case|:
case|case
name|C_MOU
case|:
case|case
name|C_ARG
case|:
case|case
name|C_REGPARM
case|:
case|case
name|C_FIELD
case|:
case|case
name|C_EOS
case|:
name|SF_SET_DEBUG
argument_list|(
name|def_symbol_in_progress
argument_list|)
expr_stmt|;
name|S_SET_SEGMENT
argument_list|(
name|def_symbol_in_progress
argument_list|,
name|absolute_section
argument_list|)
expr_stmt|;
break|break;
case|case
name|C_EXT
case|:
case|case
name|C_WEAKEXT
case|:
ifdef|#
directive|ifdef
name|TE_PE
case|case
name|C_NT_WEAK
case|:
endif|#
directive|endif
case|case
name|C_STAT
case|:
case|case
name|C_LABEL
case|:
comment|/* Valid but set somewhere else (s_comm, s_lcomm, colon) */
break|break;
case|case
name|C_USTATIC
case|:
case|case
name|C_EXTDEF
case|:
case|case
name|C_ULABEL
case|:
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"unexpected storage class %d"
argument_list|)
argument_list|,
name|S_GET_STORAGE_CLASS
argument_list|(
name|def_symbol_in_progress
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* switch on storage class */
comment|/* Now that we have built a debug symbol, try to find if we should      merge with an existing symbol or not.  If a symbol is C_EFCN or      absolute_section or untagged SEG_DEBUG it never merges.  We also      don't merge labels, which are in a different namespace, nor      symbols which have not yet been defined since they are typically      unique, nor do we merge tags with non-tags.  */
comment|/* Two cases for functions.  Either debug followed by definition or      definition followed by debug.  For definition first, we will      merge the debug symbol into the definition.  For debug first, the      lineno entry MUST point to the definition function or else it      will point off into space when crawl_symbols() merges the debug      symbol into the real symbol.  Therefor, let's presume the debug      symbol is a real function reference.  */
comment|/* FIXME-SOON If for some reason the definition label/symbol is      never seen, this will probably leave an undefined symbol at link      time.  */
if|if
condition|(
name|S_GET_STORAGE_CLASS
argument_list|(
name|def_symbol_in_progress
argument_list|)
operator|==
name|C_EFCN
operator|||
name|S_GET_STORAGE_CLASS
argument_list|(
name|def_symbol_in_progress
argument_list|)
operator|==
name|C_LABEL
operator|||
operator|(
name|S_GET_SEGMENT
argument_list|(
name|def_symbol_in_progress
argument_list|)
operator|==
name|SEG_DEBUG
operator|&&
operator|!
name|SF_GET_TAG
argument_list|(
name|def_symbol_in_progress
argument_list|)
operator|)
operator|||
name|S_GET_SEGMENT
argument_list|(
name|def_symbol_in_progress
argument_list|)
operator|==
name|absolute_section
operator|||
name|def_symbol_in_progress
operator|->
name|sy_value
operator|.
name|X_op
operator|!=
name|O_constant
operator|||
operator|(
name|symbolP
operator|=
name|symbol_find_base
argument_list|(
name|S_GET_NAME
argument_list|(
name|def_symbol_in_progress
argument_list|)
argument_list|,
name|DO_NOT_STRIP
argument_list|)
operator|)
operator|==
name|NULL
operator|||
operator|(
name|SF_GET_TAG
argument_list|(
name|def_symbol_in_progress
argument_list|)
operator|!=
name|SF_GET_TAG
argument_list|(
name|symbolP
argument_list|)
operator|)
condition|)
block|{
name|symbol_append
argument_list|(
name|def_symbol_in_progress
argument_list|,
name|symbol_lastP
argument_list|,
operator|&
name|symbol_rootP
argument_list|,
operator|&
name|symbol_lastP
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* This symbol already exists, merge the newly created symbol 	 into the old one.  This is not mandatory. The linker can 	 handle duplicate symbols correctly. But I guess that it save 	 a *lot* of space if the assembly file defines a lot of 	 symbols. [loic] */
comment|/* The debug entry (def_symbol_in_progress) is merged into the 	 previous definition.  */
name|c_symbol_merge
argument_list|(
name|def_symbol_in_progress
argument_list|,
name|symbolP
argument_list|)
expr_stmt|;
comment|/* FIXME-SOON Should *def_symbol_in_progress be free'd? xoxorich.  */
name|def_symbol_in_progress
operator|=
name|symbolP
expr_stmt|;
if|if
condition|(
name|SF_GET_FUNCTION
argument_list|(
name|def_symbol_in_progress
argument_list|)
operator|||
name|SF_GET_TAG
argument_list|(
name|def_symbol_in_progress
argument_list|)
operator|||
name|S_GET_STORAGE_CLASS
argument_list|(
name|def_symbol_in_progress
argument_list|)
operator|==
name|C_STAT
condition|)
block|{
comment|/* For functions, and tags, and static symbols, the symbol 	     *must* be where the debug symbol appears.  Move the 	     existing symbol to the current place.  */
comment|/* If it already is at the end of the symbol list, do nothing */
if|if
condition|(
name|def_symbol_in_progress
operator|!=
name|symbol_lastP
condition|)
block|{
name|symbol_remove
argument_list|(
name|def_symbol_in_progress
argument_list|,
operator|&
name|symbol_rootP
argument_list|,
operator|&
name|symbol_lastP
argument_list|)
expr_stmt|;
name|symbol_append
argument_list|(
name|def_symbol_in_progress
argument_list|,
name|symbol_lastP
argument_list|,
operator|&
name|symbol_rootP
argument_list|,
operator|&
name|symbol_lastP
argument_list|)
expr_stmt|;
block|}
comment|/* if not already in place */
block|}
comment|/* if function */
block|}
comment|/* normal or mergable */
if|if
condition|(
name|SF_GET_TAG
argument_list|(
name|def_symbol_in_progress
argument_list|)
condition|)
block|{
name|symbolS
modifier|*
name|oldtag
decl_stmt|;
name|oldtag
operator|=
name|symbol_find_base
argument_list|(
name|S_GET_NAME
argument_list|(
name|def_symbol_in_progress
argument_list|)
argument_list|,
name|DO_NOT_STRIP
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldtag
operator|==
name|NULL
operator|||
operator|!
name|SF_GET_TAG
argument_list|(
name|oldtag
argument_list|)
condition|)
name|tag_insert
argument_list|(
name|S_GET_NAME
argument_list|(
name|def_symbol_in_progress
argument_list|)
argument_list|,
name|def_symbol_in_progress
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|SF_GET_FUNCTION
argument_list|(
name|def_symbol_in_progress
argument_list|)
condition|)
block|{
name|know
argument_list|(
sizeof|sizeof
argument_list|(
name|def_symbol_in_progress
argument_list|)
operator|<=
sizeof|sizeof
argument_list|(
name|long
argument_list|)
argument_list|)
expr_stmt|;
name|function_lineoff
operator|=
name|c_line_new
argument_list|(
name|def_symbol_in_progress
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|zero_address_frag
argument_list|)
expr_stmt|;
name|SF_SET_PROCESS
argument_list|(
name|def_symbol_in_progress
argument_list|)
expr_stmt|;
if|if
condition|(
name|symbolP
operator|==
name|NULL
condition|)
block|{
comment|/* That is, if this is the first time we've seen the 	     function...  */
name|symbol_table_insert
argument_list|(
name|def_symbol_in_progress
argument_list|)
expr_stmt|;
block|}
comment|/* definition follows debug */
block|}
comment|/* Create the line number entry pointing to the function being defined */
name|def_symbol_in_progress
operator|=
name|NULL
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|obj_coff_dim
parameter_list|(
name|ignore
parameter_list|)
name|int
name|ignore
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|int
name|dim_index
decl_stmt|;
if|if
condition|(
name|def_symbol_in_progress
operator|==
name|NULL
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|".dim pseudo-op used outside of .def/.endef: ignored."
argument_list|)
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
comment|/* if not inside .def/.endef */
name|S_SET_NUMBER_AUXILIARY
argument_list|(
name|def_symbol_in_progress
argument_list|,
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|dim_index
operator|=
literal|0
init|;
name|dim_index
operator|<
name|DIMNUM
condition|;
name|dim_index
operator|++
control|)
block|{
name|SKIP_WHITESPACES
argument_list|()
expr_stmt|;
name|SA_SET_SYM_DIMEN
argument_list|(
name|def_symbol_in_progress
argument_list|,
name|dim_index
argument_list|,
name|get_absolute_expression
argument_list|()
argument_list|)
expr_stmt|;
switch|switch
condition|(
operator|*
name|input_line_pointer
condition|)
block|{
case|case
literal|','
case|:
name|input_line_pointer
operator|++
expr_stmt|;
break|break;
default|default:
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"badly formed .dim directive ignored"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* intentional fallthrough */
case|case
literal|'\n'
case|:
case|case
literal|';'
case|:
name|dim_index
operator|=
name|DIMNUM
expr_stmt|;
break|break;
block|}
block|}
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|obj_coff_line
parameter_list|(
name|ignore
parameter_list|)
name|int
name|ignore
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|int
name|this_base
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
if|if
condition|(
name|def_symbol_in_progress
operator|==
name|NULL
condition|)
block|{
name|obj_coff_ln
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
name|name
operator|=
name|S_GET_NAME
argument_list|(
name|def_symbol_in_progress
argument_list|)
expr_stmt|;
name|this_base
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
comment|/* Only .bf symbols indicate the use of a new base line number; the      line numbers associated with .ef, .bb, .eb are relative to the      start of the containing function.  */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
literal|".bf"
argument_list|,
name|name
argument_list|)
condition|)
block|{
if|#
directive|if
literal|0
comment|/* XXX Can we ever have line numbers going backwards?  */
block|if (this_base> line_base)
endif|#
directive|endif
block|{
name|line_base
operator|=
name|this_base
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|NO_LISTING
block|{
specifier|extern
name|int
name|listing
decl_stmt|;
if|if
condition|(
name|listing
condition|)
block|{
name|listing_source_line
argument_list|(
operator|(
name|unsigned
name|int
operator|)
name|line_base
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
block|}
name|S_SET_NUMBER_AUXILIARY
argument_list|(
name|def_symbol_in_progress
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SA_SET_SYM_LNNO
argument_list|(
name|def_symbol_in_progress
argument_list|,
name|this_base
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|obj_coff_size
parameter_list|(
name|ignore
parameter_list|)
name|int
name|ignore
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
if|if
condition|(
name|def_symbol_in_progress
operator|==
name|NULL
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|".size pseudo-op used outside of .def/.endef ignored."
argument_list|)
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
comment|/* if not inside .def/.endef */
name|S_SET_NUMBER_AUXILIARY
argument_list|(
name|def_symbol_in_progress
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SA_SET_SYM_SIZE
argument_list|(
name|def_symbol_in_progress
argument_list|,
name|get_absolute_expression
argument_list|()
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|obj_coff_scl
parameter_list|(
name|ignore
parameter_list|)
name|int
name|ignore
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
if|if
condition|(
name|def_symbol_in_progress
operator|==
name|NULL
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|".scl pseudo-op used outside of .def/.endef ignored."
argument_list|)
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
comment|/* if not inside .def/.endef */
name|S_SET_STORAGE_CLASS
argument_list|(
name|def_symbol_in_progress
argument_list|,
name|get_absolute_expression
argument_list|()
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|obj_coff_tag
parameter_list|(
name|ignore
parameter_list|)
name|int
name|ignore
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|char
modifier|*
name|symbol_name
decl_stmt|;
name|char
name|name_end
decl_stmt|;
if|if
condition|(
name|def_symbol_in_progress
operator|==
name|NULL
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|".tag pseudo-op used outside of .def/.endef ignored."
argument_list|)
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
name|S_SET_NUMBER_AUXILIARY
argument_list|(
name|def_symbol_in_progress
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|symbol_name
operator|=
name|input_line_pointer
expr_stmt|;
name|name_end
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|tc_canonicalize_symbol_name
name|symbol_name
operator|=
name|tc_canonicalize_symbol_name
argument_list|(
name|symbol_name
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Assume that the symbol referred to by .tag is always defined.      This was a bad assumption.  I've added find_or_make. xoxorich.  */
name|SA_SET_SYM_TAGNDX
argument_list|(
name|def_symbol_in_progress
argument_list|,
operator|(
name|long
operator|)
name|tag_find_or_make
argument_list|(
name|symbol_name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|SA_GET_SYM_TAGNDX
argument_list|(
name|def_symbol_in_progress
argument_list|)
operator|==
literal|0L
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"tag not found for .tag %s"
argument_list|)
argument_list|,
name|symbol_name
argument_list|)
expr_stmt|;
block|}
comment|/* not defined */
name|SF_SET_TAGGED
argument_list|(
name|def_symbol_in_progress
argument_list|)
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
name|name_end
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|obj_coff_type
parameter_list|(
name|ignore
parameter_list|)
name|int
name|ignore
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
if|if
condition|(
name|def_symbol_in_progress
operator|==
name|NULL
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|".type pseudo-op used outside of .def/.endef ignored."
argument_list|)
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
comment|/* if not inside .def/.endef */
name|S_SET_DATA_TYPE
argument_list|(
name|def_symbol_in_progress
argument_list|,
name|get_absolute_expression
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|ISFCN
argument_list|(
name|S_GET_DATA_TYPE
argument_list|(
name|def_symbol_in_progress
argument_list|)
argument_list|)
operator|&&
name|S_GET_STORAGE_CLASS
argument_list|(
name|def_symbol_in_progress
argument_list|)
operator|!=
name|C_TPDEF
condition|)
block|{
name|SF_SET_FUNCTION
argument_list|(
name|def_symbol_in_progress
argument_list|)
expr_stmt|;
block|}
comment|/* is a function */
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|obj_coff_val
parameter_list|(
name|ignore
parameter_list|)
name|int
name|ignore
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
if|if
condition|(
name|def_symbol_in_progress
operator|==
name|NULL
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|".val pseudo-op used outside of .def/.endef ignored."
argument_list|)
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
comment|/* if not inside .def/.endef */
if|if
condition|(
name|is_name_beginner
argument_list|(
operator|*
name|input_line_pointer
argument_list|)
condition|)
block|{
name|char
modifier|*
name|symbol_name
init|=
name|input_line_pointer
decl_stmt|;
name|char
name|name_end
init|=
name|get_symbol_end
argument_list|()
decl_stmt|;
ifdef|#
directive|ifdef
name|tc_canonicalize_symbol_name
name|symbol_name
operator|=
name|tc_canonicalize_symbol_name
argument_list|(
name|symbol_name
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|symbol_name
argument_list|,
literal|"."
argument_list|)
condition|)
block|{
name|def_symbol_in_progress
operator|->
name|sy_frag
operator|=
name|frag_now
expr_stmt|;
name|S_SET_VALUE
argument_list|(
name|def_symbol_in_progress
argument_list|,
operator|(
name|valueT
operator|)
name|frag_now_fix
argument_list|()
argument_list|)
expr_stmt|;
comment|/* If the .val is != from the .def (e.g. statics) */
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|S_GET_NAME
argument_list|(
name|def_symbol_in_progress
argument_list|)
argument_list|,
name|symbol_name
argument_list|)
condition|)
block|{
name|def_symbol_in_progress
operator|->
name|sy_value
operator|.
name|X_op
operator|=
name|O_symbol
expr_stmt|;
name|def_symbol_in_progress
operator|->
name|sy_value
operator|.
name|X_add_symbol
operator|=
name|symbol_find_or_make
argument_list|(
name|symbol_name
argument_list|)
expr_stmt|;
name|def_symbol_in_progress
operator|->
name|sy_value
operator|.
name|X_op_symbol
operator|=
name|NULL
expr_stmt|;
name|def_symbol_in_progress
operator|->
name|sy_value
operator|.
name|X_add_number
operator|=
literal|0
expr_stmt|;
comment|/* If the segment is undefined when the forward reference is 	     resolved, then copy the segment id from the forward 	     symbol.  */
name|SF_SET_GET_SEGMENT
argument_list|(
name|def_symbol_in_progress
argument_list|)
expr_stmt|;
comment|/* FIXME: gcc can generate address expressions here in 	     unusual cases (search for "obscure" in sdbout.c).  We 	     just ignore the offset here, thus generating incorrect 	     debugging information.  We ignore the rest of the line 	     just below.  */
block|}
comment|/* Otherwise, it is the name of a non debug symbol and 	 its value will be calculated later.  */
operator|*
name|input_line_pointer
operator|=
name|name_end
expr_stmt|;
comment|/* FIXME: this is to avoid an error message in the 	 FIXME case mentioned just above.  */
while|while
condition|(
operator|!
name|is_end_of_line
index|[
operator|(
name|unsigned
name|char
operator|)
operator|*
name|input_line_pointer
index|]
condition|)
operator|++
name|input_line_pointer
expr_stmt|;
block|}
else|else
block|{
name|S_SET_VALUE
argument_list|(
name|def_symbol_in_progress
argument_list|,
operator|(
name|valueT
operator|)
name|get_absolute_expression
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/* if symbol based */
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|TE_PE
end_ifdef

begin_comment
comment|/* Handle the .linkonce pseudo-op.  This is parsed by s_linkonce in    read.c, which then calls this object file format specific routine.  */
end_comment

begin_function
name|void
name|obj_coff_pe_handle_link_once
parameter_list|(
name|type
parameter_list|)
name|enum
name|linkonce_type
name|type
decl_stmt|;
block|{
name|seg_info
argument_list|(
name|now_seg
argument_list|)
operator|->
name|scnhdr
operator|.
name|s_flags
operator||=
name|IMAGE_SCN_LNK_COMDAT
expr_stmt|;
comment|/* We store the type in the seg_info structure, and use it to set up      the auxiliary entry for the section symbol in c_section_symbol.  */
name|seg_info
argument_list|(
name|now_seg
argument_list|)
operator|->
name|linkonce
operator|=
name|type
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* TE_PE */
end_comment

begin_function
name|void
name|coff_obj_read_begin_hook
parameter_list|()
block|{
comment|/* These had better be the same.  Usually 18 bytes.  */
ifndef|#
directive|ifndef
name|BFD_HEADERS
name|know
argument_list|(
sizeof|sizeof
argument_list|(
name|SYMENT
argument_list|)
operator|==
sizeof|sizeof
argument_list|(
name|AUXENT
argument_list|)
argument_list|)
expr_stmt|;
name|know
argument_list|(
name|SYMESZ
operator|==
name|AUXESZ
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|tag_init
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This function runs through the symbol table and puts all the    externals onto another chain */
end_comment

begin_comment
comment|/* The chain of globals.  */
end_comment

begin_decl_stmt
name|symbolS
modifier|*
name|symbol_globalP
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|symbolS
modifier|*
name|symbol_global_lastP
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The chain of externals */
end_comment

begin_decl_stmt
name|symbolS
modifier|*
name|symbol_externP
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|symbolS
modifier|*
name|symbol_extern_lastP
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|stack
modifier|*
name|block_stack
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|symbolS
modifier|*
name|last_functionP
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|symbolS
modifier|*
name|last_bfP
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|symbolS
modifier|*
name|last_tagP
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|unsigned
name|int
name|yank_symbols
parameter_list|()
block|{
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
name|unsigned
name|int
name|symbol_number
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|last_file_symno
init|=
literal|0
decl_stmt|;
name|struct
name|filename_list
modifier|*
name|filename_list_scan
init|=
name|filename_list_head
decl_stmt|;
for|for
control|(
name|symbolP
operator|=
name|symbol_rootP
init|;
name|symbolP
condition|;
name|symbolP
operator|=
name|symbolP
condition|?
name|symbol_next
argument_list|(
name|symbolP
argument_list|)
else|:
name|symbol_rootP
control|)
block|{
if|if
condition|(
name|symbolP
operator|->
name|sy_mri_common
condition|)
block|{
if|if
condition|(
name|S_GET_STORAGE_CLASS
argument_list|(
name|symbolP
argument_list|)
operator|==
name|C_EXT
ifdef|#
directive|ifdef
name|TE_PE
operator|||
name|S_GET_STORAGE_CLASS
argument_list|(
name|symbolP
argument_list|)
operator|==
name|C_NT_WEAK
endif|#
directive|endif
operator|||
name|S_GET_STORAGE_CLASS
argument_list|(
name|symbolP
argument_list|)
operator|==
name|C_WEAKEXT
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"%s: global symbols not supported in common sections"
argument_list|)
argument_list|,
name|S_GET_NAME
argument_list|(
name|symbolP
argument_list|)
argument_list|)
expr_stmt|;
name|symbol_remove
argument_list|(
name|symbolP
argument_list|,
operator|&
name|symbol_rootP
argument_list|,
operator|&
name|symbol_lastP
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|SF_GET_DEBUG
argument_list|(
name|symbolP
argument_list|)
condition|)
block|{
comment|/* Debug symbols do not need all this rubbish */
name|symbolS
modifier|*
name|real_symbolP
decl_stmt|;
comment|/* L* and C_EFCN symbols never merge.  */
if|if
condition|(
operator|!
name|SF_GET_LOCAL
argument_list|(
name|symbolP
argument_list|)
operator|&&
operator|!
name|SF_GET_STATICS
argument_list|(
name|symbolP
argument_list|)
operator|&&
name|S_GET_STORAGE_CLASS
argument_list|(
name|symbolP
argument_list|)
operator|!=
name|C_LABEL
operator|&&
name|symbolP
operator|->
name|sy_value
operator|.
name|X_op
operator|==
name|O_constant
operator|&&
operator|(
name|real_symbolP
operator|=
name|symbol_find_base
argument_list|(
name|S_GET_NAME
argument_list|(
name|symbolP
argument_list|)
argument_list|,
name|DO_NOT_STRIP
argument_list|)
operator|)
operator|&&
name|real_symbolP
operator|!=
name|symbolP
condition|)
block|{
comment|/* FIXME-SOON: where do dups come from? 		 Maybe tag references before definitions? xoxorich.  */
comment|/* Move the debug data from the debug symbol to the 		 real symbol. Do NOT do the oposite (i.e. move from 		 real symbol to debug symbol and remove real symbol from the 		 list.) Because some pointers refer to the real symbol 		 whereas no pointers refer to the debug symbol.  */
name|c_symbol_merge
argument_list|(
name|symbolP
argument_list|,
name|real_symbolP
argument_list|)
expr_stmt|;
comment|/* Replace the current symbol by the real one */
comment|/* The symbols will never be the last or the first 		 because : 1st symbol is .file and 3 last symbols are 		 .text, .data, .bss */
name|symbol_remove
argument_list|(
name|real_symbolP
argument_list|,
operator|&
name|symbol_rootP
argument_list|,
operator|&
name|symbol_lastP
argument_list|)
expr_stmt|;
name|symbol_insert
argument_list|(
name|real_symbolP
argument_list|,
name|symbolP
argument_list|,
operator|&
name|symbol_rootP
argument_list|,
operator|&
name|symbol_lastP
argument_list|)
expr_stmt|;
name|symbol_remove
argument_list|(
name|symbolP
argument_list|,
operator|&
name|symbol_rootP
argument_list|,
operator|&
name|symbol_lastP
argument_list|)
expr_stmt|;
name|symbolP
operator|=
name|real_symbolP
expr_stmt|;
block|}
comment|/* if not local but dup'd */
if|if
condition|(
name|flag_readonly_data_in_text
operator|&&
operator|(
name|S_GET_SEGMENT
argument_list|(
name|symbolP
argument_list|)
operator|==
name|SEG_E1
operator|)
condition|)
block|{
name|S_SET_SEGMENT
argument_list|(
name|symbolP
argument_list|,
name|SEG_E0
argument_list|)
expr_stmt|;
block|}
comment|/* push data into text */
name|resolve_symbol_value
argument_list|(
name|symbolP
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|S_GET_STORAGE_CLASS
argument_list|(
name|symbolP
argument_list|)
operator|==
name|C_NULL
condition|)
block|{
if|if
condition|(
operator|!
name|S_IS_DEFINED
argument_list|(
name|symbolP
argument_list|)
operator|&&
operator|!
name|SF_GET_LOCAL
argument_list|(
name|symbolP
argument_list|)
condition|)
block|{
name|S_SET_EXTERNAL
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|S_GET_SEGMENT
argument_list|(
name|symbolP
argument_list|)
operator|==
name|SEG_E0
condition|)
block|{
name|S_SET_STORAGE_CLASS
argument_list|(
name|symbolP
argument_list|,
name|C_LABEL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|S_SET_STORAGE_CLASS
argument_list|(
name|symbolP
argument_list|,
name|C_STAT
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Mainly to speed up if not -g */
if|if
condition|(
name|SF_GET_PROCESS
argument_list|(
name|symbolP
argument_list|)
condition|)
block|{
comment|/* Handle the nested blocks auxiliary info.  */
if|if
condition|(
name|S_GET_STORAGE_CLASS
argument_list|(
name|symbolP
argument_list|)
operator|==
name|C_BLOCK
condition|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|S_GET_NAME
argument_list|(
name|symbolP
argument_list|)
argument_list|,
literal|".bb"
argument_list|)
condition|)
name|stack_push
argument_list|(
name|block_stack
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|symbolP
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* .eb */
specifier|register
name|symbolS
modifier|*
name|begin_symbolP
decl_stmt|;
name|begin_symbolP
operator|=
operator|*
operator|(
name|symbolS
operator|*
operator|*
operator|)
name|stack_pop
argument_list|(
name|block_stack
argument_list|)
expr_stmt|;
if|if
condition|(
name|begin_symbolP
operator|==
operator|(
name|symbolS
operator|*
operator|)
literal|0
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"mismatched .eb"
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|SA_SET_SYM_ENDNDX
argument_list|(
name|begin_symbolP
argument_list|,
name|symbol_number
operator|+
literal|2
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If we are able to identify the type of a function, and we 	       are out of a function (last_functionP == 0) then, the 	       function symbol will be associated with an auxiliary 	       entry.  */
if|if
condition|(
name|last_functionP
operator|==
operator|(
name|symbolS
operator|*
operator|)
literal|0
operator|&&
name|SF_GET_FUNCTION
argument_list|(
name|symbolP
argument_list|)
condition|)
block|{
name|last_functionP
operator|=
name|symbolP
expr_stmt|;
if|if
condition|(
name|S_GET_NUMBER_AUXILIARY
argument_list|(
name|symbolP
argument_list|)
operator|<
literal|1
condition|)
block|{
name|S_SET_NUMBER_AUXILIARY
argument_list|(
name|symbolP
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* make it at least 1 */
comment|/* Clobber possible stale .dim information.  */
if|#
directive|if
literal|0
comment|/* Iffed out by steve - this fries the lnnoptr info too */
block|bzero (symbolP->sy_symbol.ost_auxent[0].x_sym.x_fcnary.x_ary.x_dimen, 			 sizeof (symbolP->sy_symbol.ost_auxent[0].x_sym.x_fcnary.x_ary.x_dimen));
endif|#
directive|endif
block|}
if|if
condition|(
name|S_GET_STORAGE_CLASS
argument_list|(
name|symbolP
argument_list|)
operator|==
name|C_FCN
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|S_GET_NAME
argument_list|(
name|symbolP
argument_list|)
argument_list|,
literal|".bf"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|last_bfP
operator|!=
name|NULL
condition|)
name|SA_SET_SYM_ENDNDX
argument_list|(
name|last_bfP
argument_list|,
name|symbol_number
argument_list|)
expr_stmt|;
name|last_bfP
operator|=
name|symbolP
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|S_GET_STORAGE_CLASS
argument_list|(
name|symbolP
argument_list|)
operator|==
name|C_EFCN
condition|)
block|{
comment|/* I don't even know if this is needed for sdb. But 		     the standard assembler generates it, so...  */
if|if
condition|(
name|last_functionP
operator|==
operator|(
name|symbolS
operator|*
operator|)
literal|0
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"C_EFCN symbol out of scope"
argument_list|)
argument_list|)
expr_stmt|;
name|SA_SET_SYM_FSIZE
argument_list|(
name|last_functionP
argument_list|,
call|(
name|long
call|)
argument_list|(
name|S_GET_VALUE
argument_list|(
name|symbolP
argument_list|)
operator|-
name|S_GET_VALUE
argument_list|(
name|last_functionP
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|SA_SET_SYM_ENDNDX
argument_list|(
name|last_functionP
argument_list|,
name|symbol_number
argument_list|)
expr_stmt|;
name|last_functionP
operator|=
operator|(
name|symbolS
operator|*
operator|)
literal|0
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|SF_GET_TAG
argument_list|(
name|symbolP
argument_list|)
condition|)
block|{
comment|/* First descriptor of a structure must point to 	       the first slot after the structure description.  */
name|last_tagP
operator|=
name|symbolP
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|S_GET_STORAGE_CLASS
argument_list|(
name|symbolP
argument_list|)
operator|==
name|C_EOS
condition|)
block|{
comment|/* +2 take in account the current symbol */
name|SA_SET_SYM_ENDNDX
argument_list|(
name|last_tagP
argument_list|,
name|symbol_number
operator|+
literal|2
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|S_GET_STORAGE_CLASS
argument_list|(
name|symbolP
argument_list|)
operator|==
name|C_FILE
condition|)
block|{
comment|/* If the filename was too long to fit in the 	     auxent, put it in the string table */
if|if
condition|(
name|SA_GET_FILE_FNAME_ZEROS
argument_list|(
name|symbolP
argument_list|)
operator|==
literal|0
operator|&&
name|SA_GET_FILE_FNAME_OFFSET
argument_list|(
name|symbolP
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|SA_SET_FILE_FNAME_OFFSET
argument_list|(
name|symbolP
argument_list|,
name|string_byte_count
argument_list|)
expr_stmt|;
name|string_byte_count
operator|+=
name|strlen
argument_list|(
name|filename_list_scan
operator|->
name|filename
argument_list|)
operator|+
literal|1
expr_stmt|;
name|filename_list_scan
operator|=
name|filename_list_scan
operator|->
name|next
expr_stmt|;
block|}
if|if
condition|(
name|S_GET_VALUE
argument_list|(
name|symbolP
argument_list|)
condition|)
block|{
name|S_SET_VALUE
argument_list|(
name|symbolP
argument_list|,
name|last_file_symno
argument_list|)
expr_stmt|;
name|last_file_symno
operator|=
name|symbol_number
expr_stmt|;
block|}
comment|/* no one points at the first .file symbol */
block|}
comment|/* if debug or tag or eos or file */
ifdef|#
directive|ifdef
name|tc_frob_coff_symbol
name|tc_frob_coff_symbol
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* We must put the external symbols apart. The loader 	 does not bomb if we do not. But the references in 	 the endndx field for a .bb symbol are not corrected 	 if an external symbol is removed between .bb and .be. 	 I.e in the following case : 	 [20] .bb endndx = 22 	 [21] foo external 	 [22] .be 	 ld will move the symbol 21 to the end of the list but 	 endndx will still be 22 instead of 21.  */
if|if
condition|(
name|SF_GET_LOCAL
argument_list|(
name|symbolP
argument_list|)
condition|)
block|{
comment|/* remove C_EFCN and LOCAL (L...) symbols */
comment|/* next pointer remains valid */
name|symbol_remove
argument_list|(
name|symbolP
argument_list|,
operator|&
name|symbol_rootP
argument_list|,
operator|&
name|symbol_lastP
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|symbolP
operator|->
name|sy_value
operator|.
name|X_op
operator|==
name|O_symbol
operator|&&
operator|(
operator|!
name|S_IS_DEFINED
argument_list|(
name|symbolP
argument_list|)
operator|||
name|S_IS_COMMON
argument_list|(
name|symbolP
argument_list|)
operator|)
condition|)
block|{
comment|/* Skip symbols which were equated to undefined or common 	     symbols.  */
name|symbol_remove
argument_list|(
name|symbolP
argument_list|,
operator|&
name|symbol_rootP
argument_list|,
operator|&
name|symbol_lastP
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|S_IS_DEFINED
argument_list|(
name|symbolP
argument_list|)
operator|&&
operator|!
name|S_IS_DEBUG
argument_list|(
name|symbolP
argument_list|)
operator|&&
operator|!
name|SF_GET_STATICS
argument_list|(
name|symbolP
argument_list|)
operator|&&
operator|(
name|S_GET_STORAGE_CLASS
argument_list|(
name|symbolP
argument_list|)
operator|==
name|C_EXT
ifdef|#
directive|ifdef
name|TE_PE
operator|||
name|S_GET_STORAGE_CLASS
argument_list|(
name|symbolP
argument_list|)
operator|==
name|C_NT_WEAK
endif|#
directive|endif
operator|||
name|S_GET_STORAGE_CLASS
argument_list|(
name|symbolP
argument_list|)
operator|==
name|C_WEAKEXT
operator|)
condition|)
block|{
comment|/* if external, Remove from the list */
name|symbolS
modifier|*
name|hold
init|=
name|symbol_previous
argument_list|(
name|symbolP
argument_list|)
decl_stmt|;
name|symbol_remove
argument_list|(
name|symbolP
argument_list|,
operator|&
name|symbol_rootP
argument_list|,
operator|&
name|symbol_lastP
argument_list|)
expr_stmt|;
name|symbol_clear_list_pointers
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
name|symbol_append
argument_list|(
name|symbolP
argument_list|,
name|symbol_extern_lastP
argument_list|,
operator|&
name|symbol_externP
argument_list|,
operator|&
name|symbol_extern_lastP
argument_list|)
expr_stmt|;
name|symbolP
operator|=
name|hold
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|S_IS_DEBUG
argument_list|(
name|symbolP
argument_list|)
operator|&&
operator|!
name|SF_GET_STATICS
argument_list|(
name|symbolP
argument_list|)
operator|&&
operator|!
name|SF_GET_FUNCTION
argument_list|(
name|symbolP
argument_list|)
operator|&&
operator|(
name|S_GET_STORAGE_CLASS
argument_list|(
name|symbolP
argument_list|)
operator|==
name|C_EXT
ifdef|#
directive|ifdef
name|TE_PE
operator|||
name|S_GET_STORAGE_CLASS
argument_list|(
name|symbolP
argument_list|)
operator|==
name|C_NT_WEAK
endif|#
directive|endif
operator|||
name|S_GET_STORAGE_CLASS
argument_list|(
name|symbolP
argument_list|)
operator|==
name|C_NT_WEAK
operator|)
condition|)
block|{
name|symbolS
modifier|*
name|hold
init|=
name|symbol_previous
argument_list|(
name|symbolP
argument_list|)
decl_stmt|;
comment|/* The O'Reilly COFF book says that defined global symbols              come at the end of the symbol table, just before              undefined global symbols.  */
name|symbol_remove
argument_list|(
name|symbolP
argument_list|,
operator|&
name|symbol_rootP
argument_list|,
operator|&
name|symbol_lastP
argument_list|)
expr_stmt|;
name|symbol_clear_list_pointers
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
name|symbol_append
argument_list|(
name|symbolP
argument_list|,
name|symbol_global_lastP
argument_list|,
operator|&
name|symbol_globalP
argument_list|,
operator|&
name|symbol_global_lastP
argument_list|)
expr_stmt|;
name|symbolP
operator|=
name|hold
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|SF_GET_STRING
argument_list|(
name|symbolP
argument_list|)
condition|)
block|{
name|symbolP
operator|->
name|sy_name_offset
operator|=
name|string_byte_count
expr_stmt|;
name|string_byte_count
operator|+=
name|strlen
argument_list|(
name|S_GET_NAME
argument_list|(
name|symbolP
argument_list|)
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
name|symbolP
operator|->
name|sy_name_offset
operator|=
literal|0
expr_stmt|;
block|}
comment|/* fix "long" names */
name|symbolP
operator|->
name|sy_number
operator|=
name|symbol_number
expr_stmt|;
name|symbol_number
operator|+=
literal|1
operator|+
name|S_GET_NUMBER_AUXILIARY
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
block|}
comment|/* if local symbol */
block|}
comment|/* traverse the symbol list */
return|return
name|symbol_number
return|;
block|}
end_function

begin_function
specifier|static
name|unsigned
name|int
name|glue_symbols
parameter_list|(
name|head
parameter_list|,
name|tail
parameter_list|)
name|symbolS
modifier|*
modifier|*
name|head
decl_stmt|;
name|symbolS
modifier|*
modifier|*
name|tail
decl_stmt|;
block|{
name|unsigned
name|int
name|symbol_number
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|*
name|head
operator|!=
name|NULL
condition|)
block|{
name|symbolS
modifier|*
name|tmp
init|=
operator|*
name|head
decl_stmt|;
comment|/* append */
name|symbol_remove
argument_list|(
name|tmp
argument_list|,
name|head
argument_list|,
name|tail
argument_list|)
expr_stmt|;
name|symbol_append
argument_list|(
name|tmp
argument_list|,
name|symbol_lastP
argument_list|,
operator|&
name|symbol_rootP
argument_list|,
operator|&
name|symbol_lastP
argument_list|)
expr_stmt|;
comment|/* and process */
if|if
condition|(
name|SF_GET_STRING
argument_list|(
name|tmp
argument_list|)
condition|)
block|{
name|tmp
operator|->
name|sy_name_offset
operator|=
name|string_byte_count
expr_stmt|;
name|string_byte_count
operator|+=
name|strlen
argument_list|(
name|S_GET_NAME
argument_list|(
name|tmp
argument_list|)
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
name|tmp
operator|->
name|sy_name_offset
operator|=
literal|0
expr_stmt|;
block|}
comment|/* fix "long" names */
name|tmp
operator|->
name|sy_number
operator|=
name|symbol_number
expr_stmt|;
name|symbol_number
operator|+=
literal|1
operator|+
name|S_GET_NUMBER_AUXILIARY
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
comment|/* append the entire extern chain */
return|return
name|symbol_number
return|;
block|}
end_function

begin_function
specifier|static
name|unsigned
name|int
name|tie_tags
parameter_list|()
block|{
name|unsigned
name|int
name|symbol_number
init|=
literal|0
decl_stmt|;
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
for|for
control|(
name|symbolP
operator|=
name|symbol_rootP
init|;
name|symbolP
condition|;
name|symbolP
operator|=
name|symbol_next
argument_list|(
name|symbolP
argument_list|)
control|)
block|{
name|symbolP
operator|->
name|sy_number
operator|=
name|symbol_number
expr_stmt|;
if|if
condition|(
name|SF_GET_TAGGED
argument_list|(
name|symbolP
argument_list|)
condition|)
block|{
name|SA_SET_SYM_TAGNDX
argument_list|(
name|symbolP
argument_list|,
operator|(
operator|(
name|symbolS
operator|*
operator|)
name|SA_GET_SYM_TAGNDX
argument_list|(
name|symbolP
argument_list|)
operator|)
operator|->
name|sy_number
argument_list|)
expr_stmt|;
block|}
name|symbol_number
operator|+=
literal|1
operator|+
name|S_GET_NUMBER_AUXILIARY
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
block|}
return|return
name|symbol_number
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|crawl_symbols
parameter_list|(
name|h
parameter_list|,
name|abfd
parameter_list|)
name|object_headers
modifier|*
name|h
decl_stmt|;
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|unsigned
name|int
name|i
decl_stmt|;
comment|/* Initialize the stack used to keep track of the matching .bb .be */
name|block_stack
operator|=
name|stack_init
argument_list|(
literal|512
argument_list|,
sizeof|sizeof
argument_list|(
name|symbolS
operator|*
argument_list|)
argument_list|)
expr_stmt|;
comment|/* The symbol list should be ordered according to the following sequence    * order :    * . .file symbol    * . debug entries for functions    * . fake symbols for the sections, including .text .data and .bss    * . defined symbols    * . undefined symbols    * But this is not mandatory. The only important point is to put the    * undefined symbols at the end of the list.    */
comment|/* Is there a .file symbol ? If not insert one at the beginning.  */
if|if
condition|(
name|symbol_rootP
operator|==
name|NULL
operator|||
name|S_GET_STORAGE_CLASS
argument_list|(
name|symbol_rootP
argument_list|)
operator|!=
name|C_FILE
condition|)
block|{
name|c_dot_file_symbol
argument_list|(
literal|"fake"
argument_list|)
expr_stmt|;
block|}
comment|/*    * Build up static symbols for the sections, they are filled in later    */
for|for
control|(
name|i
operator|=
name|SEG_E0
init|;
name|i
operator|<
name|SEG_LAST
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|segment_info
index|[
name|i
index|]
operator|.
name|scnhdr
operator|.
name|s_name
index|[
literal|0
index|]
condition|)
name|segment_info
index|[
name|i
index|]
operator|.
name|dot
operator|=
name|c_section_symbol
argument_list|(
name|segment_info
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|i
operator|-
name|SEG_E0
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* Take all the externals out and put them into another chain */
name|H_SET_SYMBOL_TABLE_SIZE
argument_list|(
name|h
argument_list|,
name|yank_symbols
argument_list|()
argument_list|)
expr_stmt|;
comment|/* Take the externals and glue them onto the end.*/
name|H_SET_SYMBOL_TABLE_SIZE
argument_list|(
name|h
argument_list|,
operator|(
name|H_GET_SYMBOL_COUNT
argument_list|(
name|h
argument_list|)
operator|+
name|glue_symbols
argument_list|(
operator|&
name|symbol_globalP
argument_list|,
operator|&
name|symbol_global_lastP
argument_list|)
operator|+
name|glue_symbols
argument_list|(
operator|&
name|symbol_externP
argument_list|,
operator|&
name|symbol_extern_lastP
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|H_SET_SYMBOL_TABLE_SIZE
argument_list|(
name|h
argument_list|,
name|tie_tags
argument_list|()
argument_list|)
expr_stmt|;
name|know
argument_list|(
name|symbol_globalP
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|know
argument_list|(
name|symbol_global_lastP
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|know
argument_list|(
name|symbol_externP
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|know
argument_list|(
name|symbol_extern_lastP
operator|==
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Find strings by crawling along symbol table chain.  */
end_comment

begin_function
name|void
name|w_strings
parameter_list|(
name|where
parameter_list|)
name|char
modifier|*
name|where
decl_stmt|;
block|{
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
name|struct
name|filename_list
modifier|*
name|filename_list_scan
init|=
name|filename_list_head
decl_stmt|;
comment|/* Gotta do md_ byte-ordering stuff for string_byte_count first - KWK */
name|md_number_to_chars
argument_list|(
name|where
argument_list|,
operator|(
name|valueT
operator|)
name|string_byte_count
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|where
operator|+=
literal|4
expr_stmt|;
ifdef|#
directive|ifdef
name|COFF_LONG_SECTION_NAMES
comment|/* Support long section names as found in PE.  This code must      coordinate with that in coff_header_append and write_object_file.  */
block|{
name|unsigned
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|SEG_E0
init|;
name|i
operator|<
name|SEG_LAST
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|segment_info
index|[
name|i
index|]
operator|.
name|scnhdr
operator|.
name|s_name
index|[
literal|0
index|]
operator|&&
name|strlen
argument_list|(
name|segment_info
index|[
name|i
index|]
operator|.
name|name
argument_list|)
operator|>
name|SCNNMLEN
condition|)
block|{
name|unsigned
name|int
name|size
decl_stmt|;
name|size
operator|=
name|strlen
argument_list|(
name|segment_info
index|[
name|i
index|]
operator|.
name|name
argument_list|)
operator|+
literal|1
expr_stmt|;
name|memcpy
argument_list|(
name|where
argument_list|,
name|segment_info
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|where
operator|+=
name|size
expr_stmt|;
block|}
block|}
block|}
endif|#
directive|endif
comment|/* COFF_LONG_SECTION_NAMES */
for|for
control|(
name|symbolP
operator|=
name|symbol_rootP
init|;
name|symbolP
condition|;
name|symbolP
operator|=
name|symbol_next
argument_list|(
name|symbolP
argument_list|)
control|)
block|{
name|unsigned
name|int
name|size
decl_stmt|;
if|if
condition|(
name|SF_GET_STRING
argument_list|(
name|symbolP
argument_list|)
condition|)
block|{
name|size
operator|=
name|strlen
argument_list|(
name|S_GET_NAME
argument_list|(
name|symbolP
argument_list|)
argument_list|)
operator|+
literal|1
expr_stmt|;
name|memcpy
argument_list|(
name|where
argument_list|,
name|S_GET_NAME
argument_list|(
name|symbolP
argument_list|)
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|where
operator|+=
name|size
expr_stmt|;
block|}
if|if
condition|(
name|S_GET_STORAGE_CLASS
argument_list|(
name|symbolP
argument_list|)
operator|==
name|C_FILE
operator|&&
name|SA_GET_FILE_FNAME_ZEROS
argument_list|(
name|symbolP
argument_list|)
operator|==
literal|0
operator|&&
name|SA_GET_FILE_FNAME_OFFSET
argument_list|(
name|symbolP
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|size
operator|=
name|strlen
argument_list|(
name|filename_list_scan
operator|->
name|filename
argument_list|)
operator|+
literal|1
expr_stmt|;
name|memcpy
argument_list|(
name|where
argument_list|,
name|filename_list_scan
operator|->
name|filename
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|filename_list_scan
operator|=
name|filename_list_scan
operator|->
name|next
expr_stmt|;
name|where
operator|+=
name|size
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|do_linenos_for
parameter_list|(
name|abfd
parameter_list|,
name|h
parameter_list|,
name|file_cursor
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|object_headers
modifier|*
name|h
decl_stmt|;
name|unsigned
name|long
modifier|*
name|file_cursor
decl_stmt|;
block|{
name|unsigned
name|int
name|idx
decl_stmt|;
name|unsigned
name|long
name|start
init|=
operator|*
name|file_cursor
decl_stmt|;
for|for
control|(
name|idx
operator|=
name|SEG_E0
init|;
name|idx
operator|<
name|SEG_LAST
condition|;
name|idx
operator|++
control|)
block|{
name|segment_info_type
modifier|*
name|s
init|=
name|segment_info
operator|+
name|idx
decl_stmt|;
if|if
condition|(
name|s
operator|->
name|scnhdr
operator|.
name|s_nlnno
operator|!=
literal|0
condition|)
block|{
name|struct
name|lineno_list
modifier|*
name|line_ptr
decl_stmt|;
name|struct
name|external_lineno
modifier|*
name|buffer
init|=
operator|(
expr|struct
name|external_lineno
operator|*
operator|)
name|xmalloc
argument_list|(
name|s
operator|->
name|scnhdr
operator|.
name|s_nlnno
operator|*
name|LINESZ
argument_list|)
decl_stmt|;
name|struct
name|external_lineno
modifier|*
name|dst
init|=
name|buffer
decl_stmt|;
comment|/* Run through the table we've built and turn it into its external 	 form, take this chance to remove duplicates */
for|for
control|(
name|line_ptr
operator|=
name|s
operator|->
name|lineno_list_head
init|;
name|line_ptr
operator|!=
operator|(
expr|struct
name|lineno_list
operator|*
operator|)
name|NULL
condition|;
name|line_ptr
operator|=
name|line_ptr
operator|->
name|next
control|)
block|{
if|if
condition|(
name|line_ptr
operator|->
name|line
operator|.
name|l_lnno
operator|==
literal|0
condition|)
block|{
comment|/* Turn a pointer to a symbol into the symbols' index, 		     provided that it has been initialised.  */
if|if
condition|(
name|line_ptr
operator|->
name|line
operator|.
name|l_addr
operator|.
name|l_symndx
condition|)
name|line_ptr
operator|->
name|line
operator|.
name|l_addr
operator|.
name|l_symndx
operator|=
operator|(
operator|(
name|symbolS
operator|*
operator|)
name|line_ptr
operator|->
name|line
operator|.
name|l_addr
operator|.
name|l_symndx
operator|)
operator|->
name|sy_number
expr_stmt|;
block|}
else|else
block|{
name|line_ptr
operator|->
name|line
operator|.
name|l_addr
operator|.
name|l_paddr
operator|+=
operator|(
operator|(
expr|struct
name|frag
operator|*
operator|)
operator|(
name|line_ptr
operator|->
name|frag
operator|)
operator|)
operator|->
name|fr_address
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|bfd_coff_swap_lineno_out
argument_list|(
name|abfd
argument_list|,
operator|&
operator|(
name|line_ptr
operator|->
name|line
operator|)
argument_list|,
name|dst
argument_list|)
expr_stmt|;
name|dst
operator|++
expr_stmt|;
block|}
name|s
operator|->
name|scnhdr
operator|.
name|s_lnnoptr
operator|=
operator|*
name|file_cursor
expr_stmt|;
name|bfd_write
argument_list|(
name|buffer
argument_list|,
literal|1
argument_list|,
name|s
operator|->
name|scnhdr
operator|.
name|s_nlnno
operator|*
name|LINESZ
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
operator|*
name|file_cursor
operator|+=
name|s
operator|->
name|scnhdr
operator|.
name|s_nlnno
operator|*
name|LINESZ
expr_stmt|;
block|}
block|}
name|H_SET_LINENO_SIZE
argument_list|(
name|h
argument_list|,
operator|*
name|file_cursor
operator|-
name|start
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Now we run through the list of frag chains in a segment and    make all the subsegment frags appear at the end of the    list, as if the seg 0 was extra long */
end_comment

begin_function
specifier|static
name|void
name|remove_subsegs
parameter_list|()
block|{
name|unsigned
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|SEG_E0
init|;
name|i
operator|<
name|SEG_UNKNOWN
condition|;
name|i
operator|++
control|)
block|{
name|frchainS
modifier|*
name|head
init|=
name|segment_info
index|[
name|i
index|]
operator|.
name|frchainP
decl_stmt|;
name|fragS
name|dummy
decl_stmt|;
name|fragS
modifier|*
name|prev_frag
init|=
operator|&
name|dummy
decl_stmt|;
while|while
condition|(
name|head
operator|&&
name|head
operator|->
name|frch_seg
operator|==
name|i
condition|)
block|{
name|prev_frag
operator|->
name|fr_next
operator|=
name|head
operator|->
name|frch_root
expr_stmt|;
name|prev_frag
operator|=
name|head
operator|->
name|frch_last
expr_stmt|;
name|head
operator|=
name|head
operator|->
name|frch_next
expr_stmt|;
block|}
name|prev_frag
operator|->
name|fr_next
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_decl_stmt
name|unsigned
name|long
name|machine
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|coff_flags
decl_stmt|;
end_decl_stmt

begin_function
specifier|extern
name|void
name|write_object_file
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|struct
name|frchain
modifier|*
name|frchain_ptr
decl_stmt|;
name|object_headers
name|headers
decl_stmt|;
name|unsigned
name|long
name|file_cursor
decl_stmt|;
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|unsigned
name|int
name|addr
decl_stmt|;
name|abfd
operator|=
name|bfd_openw
argument_list|(
name|out_file_name
argument_list|,
name|TARGET_FORMAT
argument_list|)
expr_stmt|;
if|if
condition|(
name|abfd
operator|==
literal|0
condition|)
block|{
name|as_perror
argument_list|(
name|_
argument_list|(
literal|"FATAL: Can't create %s"
argument_list|)
argument_list|,
name|out_file_name
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
name|bfd_set_format
argument_list|(
name|abfd
argument_list|,
name|bfd_object
argument_list|)
expr_stmt|;
name|bfd_set_arch_mach
argument_list|(
name|abfd
argument_list|,
name|BFD_ARCH
argument_list|,
name|machine
argument_list|)
expr_stmt|;
name|string_byte_count
operator|=
literal|4
expr_stmt|;
for|for
control|(
name|frchain_ptr
operator|=
name|frchain_root
init|;
name|frchain_ptr
operator|!=
operator|(
expr|struct
name|frchain
operator|*
operator|)
name|NULL
condition|;
name|frchain_ptr
operator|=
name|frchain_ptr
operator|->
name|frch_next
control|)
block|{
comment|/* Run through all the sub-segments and align them up.  Also 	 close any open frags.  We tack a .fill onto the end of the 	 frag chain so that any .align's size can be worked by looking 	 at the next frag.  */
name|subseg_set
argument_list|(
name|frchain_ptr
operator|->
name|frch_seg
argument_list|,
name|frchain_ptr
operator|->
name|frch_subseg
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|SUB_SEGMENT_ALIGN
define|#
directive|define
name|SUB_SEGMENT_ALIGN
parameter_list|(
name|SEG
parameter_list|)
value|1
endif|#
directive|endif
ifdef|#
directive|ifdef
name|md_do_align
name|md_do_align
argument_list|(
name|SUB_SEGMENT_ALIGN
argument_list|(
name|now_seg
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|alignment_done
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|subseg_text_p
argument_list|(
name|now_seg
argument_list|)
condition|)
name|frag_align_code
argument_list|(
name|SUB_SEGMENT_ALIGN
argument_list|(
name|now_seg
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|frag_align
argument_list|(
name|SUB_SEGMENT_ALIGN
argument_list|(
name|now_seg
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|md_do_align
name|alignment_done
label|:
endif|#
directive|endif
name|frag_wane
argument_list|(
name|frag_now
argument_list|)
expr_stmt|;
name|frag_now
operator|->
name|fr_fix
operator|=
literal|0
expr_stmt|;
name|know
argument_list|(
name|frag_now
operator|->
name|fr_next
operator|==
name|NULL
argument_list|)
expr_stmt|;
block|}
name|remove_subsegs
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
name|SEG_E0
init|;
name|i
operator|<
name|SEG_UNKNOWN
condition|;
name|i
operator|++
control|)
block|{
name|relax_segment
argument_list|(
name|segment_info
index|[
name|i
index|]
operator|.
name|frchainP
operator|->
name|frch_root
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
name|H_SET_NUMBER_OF_SECTIONS
argument_list|(
operator|&
name|headers
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Find out how big the sections are, and set the addresses.  */
name|addr
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|SEG_E0
init|;
name|i
operator|<
name|SEG_UNKNOWN
condition|;
name|i
operator|++
control|)
block|{
name|long
name|size
decl_stmt|;
name|segment_info
index|[
name|i
index|]
operator|.
name|scnhdr
operator|.
name|s_paddr
operator|=
name|addr
expr_stmt|;
name|segment_info
index|[
name|i
index|]
operator|.
name|scnhdr
operator|.
name|s_vaddr
operator|=
name|addr
expr_stmt|;
if|if
condition|(
name|segment_info
index|[
name|i
index|]
operator|.
name|scnhdr
operator|.
name|s_name
index|[
literal|0
index|]
condition|)
block|{
name|H_SET_NUMBER_OF_SECTIONS
argument_list|(
operator|&
name|headers
argument_list|,
name|H_GET_NUMBER_OF_SECTIONS
argument_list|(
operator|&
name|headers
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|COFF_LONG_SECTION_NAMES
comment|/* Support long section names as found in PE.  This code 	     must coordinate with that in coff_header_append and 	     w_strings.  */
block|{
name|unsigned
name|int
name|len
decl_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|segment_info
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|SCNNMLEN
condition|)
name|string_byte_count
operator|+=
name|len
operator|+
literal|1
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* COFF_LONG_SECTION_NAMES */
block|}
name|size
operator|=
name|size_section
argument_list|(
name|abfd
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|i
argument_list|)
expr_stmt|;
name|addr
operator|+=
name|size
expr_stmt|;
comment|/* I think the section alignment is only used on the i960; the 	 i960 needs it, and it should do no harm on other targets.  */
ifdef|#
directive|ifdef
name|ALIGNMENT_IN_S_FLAGS
name|segment_info
index|[
name|i
index|]
operator|.
name|scnhdr
operator|.
name|s_flags
operator||=
operator|(
name|section_alignment
index|[
name|i
index|]
operator|&
literal|0xF
operator|)
operator|<<
literal|8
expr_stmt|;
else|#
directive|else
name|segment_info
index|[
name|i
index|]
operator|.
name|scnhdr
operator|.
name|s_align
operator|=
literal|1
operator|<<
name|section_alignment
index|[
name|i
index|]
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|i
operator|==
name|SEG_E0
condition|)
name|H_SET_TEXT_SIZE
argument_list|(
operator|&
name|headers
argument_list|,
name|size
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|==
name|SEG_E1
condition|)
name|H_SET_DATA_SIZE
argument_list|(
operator|&
name|headers
argument_list|,
name|size
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|==
name|SEG_E2
condition|)
name|H_SET_BSS_SIZE
argument_list|(
operator|&
name|headers
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
comment|/* Turn the gas native symbol table shape into a coff symbol table */
name|crawl_symbols
argument_list|(
operator|&
name|headers
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|string_byte_count
operator|==
literal|4
condition|)
name|string_byte_count
operator|=
literal|0
expr_stmt|;
name|H_SET_STRING_SIZE
argument_list|(
operator|&
name|headers
argument_list|,
name|string_byte_count
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|tc_frob_file
name|tc_frob_file
argument_list|()
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|i
operator|=
name|SEG_E0
init|;
name|i
operator|<
name|SEG_UNKNOWN
condition|;
name|i
operator|++
control|)
block|{
name|fixup_mdeps
argument_list|(
name|segment_info
index|[
name|i
index|]
operator|.
name|frchainP
operator|->
name|frch_root
argument_list|,
operator|&
name|headers
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|fixup_segment
argument_list|(
operator|&
name|segment_info
index|[
name|i
index|]
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
comment|/* Look for ".stab" segments and fill in their initial symbols      correctly.  */
for|for
control|(
name|i
operator|=
name|SEG_E0
init|;
name|i
operator|<
name|SEG_UNKNOWN
condition|;
name|i
operator|++
control|)
block|{
name|name
operator|=
name|segment_info
index|[
name|i
index|]
operator|.
name|name
expr_stmt|;
if|if
condition|(
name|name
operator|!=
name|NULL
operator|&&
name|strncmp
argument_list|(
literal|".stab"
argument_list|,
name|name
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
operator|&&
name|strncmp
argument_list|(
literal|".stabstr"
argument_list|,
name|name
argument_list|,
literal|8
argument_list|)
operator|!=
literal|0
condition|)
name|adjust_stab_section
argument_list|(
name|abfd
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
name|file_cursor
operator|=
name|H_GET_TEXT_FILE_OFFSET
argument_list|(
operator|&
name|headers
argument_list|)
expr_stmt|;
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
operator|(
name|file_ptr
operator|)
name|file_cursor
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Plant the data */
name|fill_section
argument_list|(
name|abfd
argument_list|,
operator|&
name|headers
argument_list|,
operator|&
name|file_cursor
argument_list|)
expr_stmt|;
name|do_relocs_for
argument_list|(
name|abfd
argument_list|,
operator|&
name|headers
argument_list|,
operator|&
name|file_cursor
argument_list|)
expr_stmt|;
name|do_linenos_for
argument_list|(
name|abfd
argument_list|,
operator|&
name|headers
argument_list|,
operator|&
name|file_cursor
argument_list|)
expr_stmt|;
name|H_SET_FILE_MAGIC_NUMBER
argument_list|(
operator|&
name|headers
argument_list|,
name|COFF_MAGIC
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|OBJ_COFF_OMIT_TIMESTAMP
name|H_SET_TIME_STAMP
argument_list|(
operator|&
name|headers
argument_list|,
operator|(
name|long
operator|)
name|time
argument_list|(
operator|(
name|time_t
operator|*
operator|)
literal|0
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|H_SET_TIME_STAMP
argument_list|(
operator|&
name|headers
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TC_COFF_SET_MACHINE
name|TC_COFF_SET_MACHINE
argument_list|(
operator|&
name|headers
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|COFF_FLAGS
define|#
directive|define
name|COFF_FLAGS
value|0
endif|#
directive|endif
ifdef|#
directive|ifdef
name|KEEP_RELOC_INFO
name|H_SET_FLAGS
argument_list|(
operator|&
name|headers
argument_list|,
operator|(
operator|(
name|H_GET_LINENO_SIZE
argument_list|(
operator|&
name|headers
argument_list|)
condition|?
literal|0
else|:
name|F_LNNO
operator|)
operator||
name|COFF_FLAGS
operator||
name|coff_flags
operator|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|H_SET_FLAGS
argument_list|(
operator|&
name|headers
argument_list|,
operator|(
operator|(
name|H_GET_LINENO_SIZE
argument_list|(
operator|&
name|headers
argument_list|)
condition|?
literal|0
else|:
name|F_LNNO
operator|)
operator||
operator|(
name|H_GET_RELOCATION_SIZE
argument_list|(
operator|&
name|headers
argument_list|)
condition|?
literal|0
else|:
name|F_RELFLG
operator|)
operator||
name|COFF_FLAGS
operator||
name|coff_flags
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|{
name|unsigned
name|int
name|symtable_size
init|=
name|H_GET_SYMBOL_TABLE_SIZE
argument_list|(
operator|&
name|headers
argument_list|)
decl_stmt|;
name|char
modifier|*
name|buffer1
init|=
name|xmalloc
argument_list|(
name|symtable_size
operator|+
name|string_byte_count
operator|+
literal|1
argument_list|)
decl_stmt|;
name|H_SET_SYMBOL_TABLE_POINTER
argument_list|(
operator|&
name|headers
argument_list|,
name|bfd_tell
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
name|w_symbols
argument_list|(
name|abfd
argument_list|,
name|buffer1
argument_list|,
name|symbol_rootP
argument_list|)
expr_stmt|;
if|if
condition|(
name|string_byte_count
operator|>
literal|0
condition|)
name|w_strings
argument_list|(
name|buffer1
operator|+
name|symtable_size
argument_list|)
expr_stmt|;
name|bfd_write
argument_list|(
name|buffer1
argument_list|,
literal|1
argument_list|,
name|symtable_size
operator|+
name|string_byte_count
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buffer1
argument_list|)
expr_stmt|;
block|}
name|coff_header_append
argument_list|(
name|abfd
argument_list|,
operator|&
name|headers
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* Recent changes to write need this, but where it should      go is up to Ken..  */
block|if (bfd_close_all_done (abfd) == false)     as_fatal (_("Can't close %s: %s"), out_file_name, 	      bfd_errmsg (bfd_get_error ()));
else|#
directive|else
block|{
specifier|extern
name|bfd
modifier|*
name|stdoutput
decl_stmt|;
name|stdoutput
operator|=
name|abfd
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Add a new segment.  This is called from subseg_new via the    obj_new_segment macro.  */
end_comment

begin_function
name|segT
name|obj_coff_add_segment
parameter_list|(
name|name
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|unsigned
name|int
name|i
decl_stmt|;
ifndef|#
directive|ifndef
name|COFF_LONG_SECTION_NAMES
name|char
name|buf
index|[
name|SCNNMLEN
operator|+
literal|1
index|]
decl_stmt|;
name|strncpy
argument_list|(
name|buf
argument_list|,
name|name
argument_list|,
name|SCNNMLEN
argument_list|)
expr_stmt|;
name|buf
index|[
name|SCNNMLEN
index|]
operator|=
literal|'\0'
expr_stmt|;
name|name
operator|=
name|buf
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|i
operator|=
name|SEG_E0
init|;
name|i
operator|<
name|SEG_LAST
operator|&&
name|segment_info
index|[
name|i
index|]
operator|.
name|scnhdr
operator|.
name|s_name
index|[
literal|0
index|]
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|segment_info
index|[
name|i
index|]
operator|.
name|name
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|segT
operator|)
name|i
return|;
if|if
condition|(
name|i
operator|==
name|SEG_LAST
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Too many new sections; can't add \"%s\""
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
name|now_seg
return|;
block|}
comment|/* Add a new section.  */
name|strncpy
argument_list|(
name|segment_info
index|[
name|i
index|]
operator|.
name|scnhdr
operator|.
name|s_name
argument_list|,
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|segment_info
index|[
name|i
index|]
operator|.
name|scnhdr
operator|.
name|s_name
argument_list|)
argument_list|)
expr_stmt|;
name|segment_info
index|[
name|i
index|]
operator|.
name|scnhdr
operator|.
name|s_flags
operator|=
name|STYP_REG
expr_stmt|;
name|segment_info
index|[
name|i
index|]
operator|.
name|name
operator|=
name|xstrdup
argument_list|(
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|segT
operator|)
name|i
return|;
block|}
end_function

begin_comment
comment|/*  * implement the .section pseudo op:  *	.section name {, "flags"}  *                ^         ^  *                |         +--- optional flags: 'b' for bss  *                |                              'i' for info  *                +-- section name               'l' for lib  *                                               'n' for noload  *                                               'o' for over  *                                               'w' for data  *						 'd' (apparently m88k for data)  *                                               'x' for text  *						 'r' for read-only data  * But if the argument is not a quoted string, treat it as a  * subsegment number.  */
end_comment

begin_function
name|void
name|obj_coff_section
parameter_list|(
name|ignore
parameter_list|)
name|int
name|ignore
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
comment|/* Strip out the section name */
name|char
modifier|*
name|section_name
decl_stmt|,
modifier|*
name|name
decl_stmt|;
name|char
name|c
decl_stmt|;
name|unsigned
name|int
name|exp
decl_stmt|;
name|long
name|flags
decl_stmt|;
if|if
condition|(
name|flag_mri
condition|)
block|{
name|char
name|type
decl_stmt|;
name|s_mri_sect
argument_list|(
operator|&
name|type
argument_list|)
expr_stmt|;
name|flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|type
operator|==
literal|'C'
condition|)
name|flags
operator|=
name|STYP_TEXT
expr_stmt|;
elseif|else
if|if
condition|(
name|type
operator|==
literal|'D'
condition|)
name|flags
operator|=
name|STYP_DATA
expr_stmt|;
name|segment_info
index|[
name|now_seg
index|]
operator|.
name|scnhdr
operator|.
name|s_flags
operator||=
name|flags
expr_stmt|;
return|return;
block|}
name|section_name
operator|=
name|input_line_pointer
expr_stmt|;
name|c
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
name|name
operator|=
name|xmalloc
argument_list|(
name|input_line_pointer
operator|-
name|section_name
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|name
argument_list|,
name|section_name
argument_list|)
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
name|exp
operator|=
literal|0
expr_stmt|;
name|flags
operator|=
literal|0
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|','
condition|)
block|{
operator|++
name|input_line_pointer
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|!=
literal|'"'
condition|)
name|exp
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
else|else
block|{
operator|++
name|input_line_pointer
expr_stmt|;
while|while
condition|(
operator|*
name|input_line_pointer
operator|!=
literal|'"'
operator|&&
operator|!
name|is_end_of_line
index|[
operator|(
name|unsigned
name|char
operator|)
operator|*
name|input_line_pointer
index|]
condition|)
block|{
switch|switch
condition|(
operator|*
name|input_line_pointer
condition|)
block|{
case|case
literal|'b'
case|:
name|flags
operator||=
name|STYP_BSS
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
name|flags
operator||=
name|STYP_INFO
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|flags
operator||=
name|STYP_LIB
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
name|flags
operator||=
name|STYP_NOLOAD
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
name|flags
operator||=
name|STYP_OVER
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
case|case
literal|'w'
case|:
name|flags
operator||=
name|STYP_DATA
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
name|flags
operator||=
name|STYP_TEXT
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|flags
operator||=
name|STYP_LIT
expr_stmt|;
break|break;
default|default:
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"unknown section attribute '%c'"
argument_list|)
argument_list|,
operator|*
name|input_line_pointer
argument_list|)
expr_stmt|;
break|break;
block|}
operator|++
name|input_line_pointer
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|'"'
condition|)
operator|++
name|input_line_pointer
expr_stmt|;
block|}
block|}
name|subseg_new
argument_list|(
name|name
argument_list|,
operator|(
name|subsegT
operator|)
name|exp
argument_list|)
expr_stmt|;
name|segment_info
index|[
name|now_seg
index|]
operator|.
name|scnhdr
operator|.
name|s_flags
operator||=
name|flags
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|obj_coff_text
parameter_list|(
name|ignore
parameter_list|)
name|int
name|ignore
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|subseg_new
argument_list|(
literal|".text"
argument_list|,
name|get_absolute_expression
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|obj_coff_data
parameter_list|(
name|ignore
parameter_list|)
name|int
name|ignore
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
if|if
condition|(
name|flag_readonly_data_in_text
condition|)
name|subseg_new
argument_list|(
literal|".text"
argument_list|,
name|get_absolute_expression
argument_list|()
operator|+
literal|1000
argument_list|)
expr_stmt|;
else|else
name|subseg_new
argument_list|(
literal|".data"
argument_list|,
name|get_absolute_expression
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|obj_coff_ident
parameter_list|(
name|ignore
parameter_list|)
name|int
name|ignore
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|segT
name|current_seg
init|=
name|now_seg
decl_stmt|;
comment|/* save current seg	*/
name|subsegT
name|current_subseg
init|=
name|now_subseg
decl_stmt|;
name|subseg_new
argument_list|(
literal|".comment"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* .comment seg		*/
name|stringer
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* read string		*/
name|subseg_set
argument_list|(
name|current_seg
argument_list|,
name|current_subseg
argument_list|)
expr_stmt|;
comment|/* restore current seg	*/
block|}
end_function

begin_function
name|void
name|c_symbol_merge
parameter_list|(
name|debug
parameter_list|,
name|normal
parameter_list|)
name|symbolS
modifier|*
name|debug
decl_stmt|;
name|symbolS
modifier|*
name|normal
decl_stmt|;
block|{
name|S_SET_DATA_TYPE
argument_list|(
name|normal
argument_list|,
name|S_GET_DATA_TYPE
argument_list|(
name|debug
argument_list|)
argument_list|)
expr_stmt|;
name|S_SET_STORAGE_CLASS
argument_list|(
name|normal
argument_list|,
name|S_GET_STORAGE_CLASS
argument_list|(
name|debug
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|S_GET_NUMBER_AUXILIARY
argument_list|(
name|debug
argument_list|)
operator|>
name|S_GET_NUMBER_AUXILIARY
argument_list|(
name|normal
argument_list|)
condition|)
block|{
name|S_SET_NUMBER_AUXILIARY
argument_list|(
name|normal
argument_list|,
name|S_GET_NUMBER_AUXILIARY
argument_list|(
name|debug
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* take the most we have */
if|if
condition|(
name|S_GET_NUMBER_AUXILIARY
argument_list|(
name|debug
argument_list|)
operator|>
literal|0
condition|)
block|{
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|normal
operator|->
name|sy_symbol
operator|.
name|ost_auxent
index|[
literal|0
index|]
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|debug
operator|->
name|sy_symbol
operator|.
name|ost_auxent
index|[
literal|0
index|]
argument_list|,
call|(
name|unsigned
name|int
call|)
argument_list|(
name|S_GET_NUMBER_AUXILIARY
argument_list|(
name|debug
argument_list|)
operator|*
name|AUXESZ
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Move all the auxiliary information */
comment|/* Move the debug flags.  */
name|SF_SET_DEBUG_FIELD
argument_list|(
name|normal
argument_list|,
name|SF_GET_DEBUG_FIELD
argument_list|(
name|debug
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* c_symbol_merge() */
end_comment

begin_function
specifier|static
name|int
name|c_line_new
parameter_list|(
name|symbol
parameter_list|,
name|paddr
parameter_list|,
name|line_number
parameter_list|,
name|frag
parameter_list|)
name|symbolS
modifier|*
name|symbol
decl_stmt|;
name|long
name|paddr
decl_stmt|;
name|int
name|line_number
decl_stmt|;
name|fragS
modifier|*
name|frag
decl_stmt|;
block|{
name|struct
name|lineno_list
modifier|*
name|new_line
init|=
operator|(
expr|struct
name|lineno_list
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|lineno_list
argument_list|)
argument_list|)
decl_stmt|;
name|segment_info_type
modifier|*
name|s
init|=
name|segment_info
operator|+
name|now_seg
decl_stmt|;
name|new_line
operator|->
name|line
operator|.
name|l_lnno
operator|=
name|line_number
expr_stmt|;
if|if
condition|(
name|line_number
operator|==
literal|0
condition|)
block|{
name|last_line_symbol
operator|=
name|symbol
expr_stmt|;
name|new_line
operator|->
name|line
operator|.
name|l_addr
operator|.
name|l_symndx
operator|=
operator|(
name|long
operator|)
name|symbol
expr_stmt|;
block|}
else|else
block|{
name|new_line
operator|->
name|line
operator|.
name|l_addr
operator|.
name|l_paddr
operator|=
name|paddr
expr_stmt|;
block|}
name|new_line
operator|->
name|frag
operator|=
operator|(
name|char
operator|*
operator|)
name|frag
expr_stmt|;
name|new_line
operator|->
name|next
operator|=
operator|(
expr|struct
name|lineno_list
operator|*
operator|)
name|NULL
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|lineno_list_head
operator|==
operator|(
expr|struct
name|lineno_list
operator|*
operator|)
name|NULL
condition|)
block|{
name|s
operator|->
name|lineno_list_head
operator|=
name|new_line
expr_stmt|;
block|}
else|else
block|{
name|s
operator|->
name|lineno_list_tail
operator|->
name|next
operator|=
name|new_line
expr_stmt|;
block|}
name|s
operator|->
name|lineno_list_tail
operator|=
name|new_line
expr_stmt|;
return|return
name|LINESZ
operator|*
name|s
operator|->
name|scnhdr
operator|.
name|s_nlnno
operator|++
return|;
block|}
end_function

begin_function
name|void
name|c_dot_file_symbol
parameter_list|(
name|filename
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
block|{
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
name|symbolP
operator|=
name|symbol_new
argument_list|(
literal|".file"
argument_list|,
name|SEG_DEBUG
argument_list|,
literal|0
argument_list|,
operator|&
name|zero_address_frag
argument_list|)
expr_stmt|;
name|S_SET_STORAGE_CLASS
argument_list|(
name|symbolP
argument_list|,
name|C_FILE
argument_list|)
expr_stmt|;
name|S_SET_NUMBER_AUXILIARY
argument_list|(
name|symbolP
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|filename
argument_list|)
operator|>
name|FILNMLEN
condition|)
block|{
comment|/* Filename is too long to fit into an auxent, 	 we stick it into the string table instead.  We keep 	 a linked list of the filenames we find so we can emit 	 them later.*/
name|struct
name|filename_list
modifier|*
name|f
init|=
operator|(
operator|(
expr|struct
name|filename_list
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|filename_list
argument_list|)
argument_list|)
operator|)
decl_stmt|;
name|f
operator|->
name|filename
operator|=
name|filename
expr_stmt|;
name|f
operator|->
name|next
operator|=
literal|0
expr_stmt|;
name|SA_SET_FILE_FNAME_ZEROS
argument_list|(
name|symbolP
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|SA_SET_FILE_FNAME_OFFSET
argument_list|(
name|symbolP
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|filename_list_tail
condition|)
name|filename_list_tail
operator|->
name|next
operator|=
name|f
expr_stmt|;
else|else
name|filename_list_head
operator|=
name|f
expr_stmt|;
name|filename_list_tail
operator|=
name|f
expr_stmt|;
block|}
else|else
block|{
name|SA_SET_FILE_FNAME
argument_list|(
name|symbolP
argument_list|,
name|filename
argument_list|)
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|NO_LISTING
block|{
specifier|extern
name|int
name|listing
decl_stmt|;
if|if
condition|(
name|listing
condition|)
block|{
name|listing_source_file
argument_list|(
name|filename
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
name|SF_SET_DEBUG
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
name|S_SET_VALUE
argument_list|(
name|symbolP
argument_list|,
operator|(
name|valueT
operator|)
name|previous_file_symbol
argument_list|)
expr_stmt|;
name|previous_file_symbol
operator|=
name|symbolP
expr_stmt|;
comment|/* Make sure that the symbol is first on the symbol chain */
if|if
condition|(
name|symbol_rootP
operator|!=
name|symbolP
condition|)
block|{
name|symbol_remove
argument_list|(
name|symbolP
argument_list|,
operator|&
name|symbol_rootP
argument_list|,
operator|&
name|symbol_lastP
argument_list|)
expr_stmt|;
name|symbol_insert
argument_list|(
name|symbolP
argument_list|,
name|symbol_rootP
argument_list|,
operator|&
name|symbol_rootP
argument_list|,
operator|&
name|symbol_lastP
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* c_dot_file_symbol() */
end_comment

begin_comment
comment|/*  * Build a 'section static' symbol.  */
end_comment

begin_function
name|symbolS
modifier|*
name|c_section_symbol
parameter_list|(
name|name
parameter_list|,
name|idx
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|idx
decl_stmt|;
block|{
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
name|symbolP
operator|=
name|symbol_find_base
argument_list|(
name|name
argument_list|,
name|DO_NOT_STRIP
argument_list|)
expr_stmt|;
if|if
condition|(
name|symbolP
operator|==
name|NULL
condition|)
name|symbolP
operator|=
name|symbol_new
argument_list|(
name|name
argument_list|,
name|idx
argument_list|,
literal|0
argument_list|,
operator|&
name|zero_address_frag
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Mmmm.  I just love violating interfaces.  Makes me feel...dirty.  */
name|S_SET_SEGMENT
argument_list|(
name|symbolP
argument_list|,
name|idx
argument_list|)
expr_stmt|;
name|symbolP
operator|->
name|sy_frag
operator|=
operator|&
name|zero_address_frag
expr_stmt|;
block|}
name|S_SET_STORAGE_CLASS
argument_list|(
name|symbolP
argument_list|,
name|C_STAT
argument_list|)
expr_stmt|;
name|S_SET_NUMBER_AUXILIARY
argument_list|(
name|symbolP
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SF_SET_STATICS
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TE_DELTA
comment|/* manfred@s-direktnet.de: section symbols *must* have the LOCAL bit cleared,      which is set by the new definition of LOCAL_LABEL in tc-m68k.h.  */
name|SF_CLEAR_LOCAL
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TE_PE
comment|/* If the .linkonce pseudo-op was used for this section, we must      store the information in the auxiliary entry for the section      symbol.  */
if|if
condition|(
name|segment_info
index|[
name|idx
index|]
operator|.
name|linkonce
operator|!=
name|LINKONCE_UNSET
condition|)
block|{
name|int
name|type
decl_stmt|;
switch|switch
condition|(
name|segment_info
index|[
name|idx
index|]
operator|.
name|linkonce
condition|)
block|{
default|default:
name|abort
argument_list|()
expr_stmt|;
case|case
name|LINKONCE_DISCARD
case|:
name|type
operator|=
name|IMAGE_COMDAT_SELECT_ANY
expr_stmt|;
break|break;
case|case
name|LINKONCE_ONE_ONLY
case|:
name|type
operator|=
name|IMAGE_COMDAT_SELECT_NODUPLICATES
expr_stmt|;
break|break;
case|case
name|LINKONCE_SAME_SIZE
case|:
name|type
operator|=
name|IMAGE_COMDAT_SELECT_SAME_SIZE
expr_stmt|;
break|break;
case|case
name|LINKONCE_SAME_CONTENTS
case|:
name|type
operator|=
name|IMAGE_COMDAT_SELECT_EXACT_MATCH
expr_stmt|;
break|break;
block|}
name|SYM_AUXENT
argument_list|(
name|symbolP
argument_list|)
operator|->
name|x_scn
operator|.
name|x_comdat
operator|=
name|type
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* TE_PE */
return|return
name|symbolP
return|;
block|}
end_function

begin_comment
comment|/* c_section_symbol() */
end_comment

begin_function
specifier|static
name|void
name|w_symbols
parameter_list|(
name|abfd
parameter_list|,
name|where
parameter_list|,
name|symbol_rootP
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|char
modifier|*
name|where
decl_stmt|;
name|symbolS
modifier|*
name|symbol_rootP
decl_stmt|;
block|{
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
comment|/* First fill in those values we have only just worked out */
for|for
control|(
name|i
operator|=
name|SEG_E0
init|;
name|i
operator|<
name|SEG_LAST
condition|;
name|i
operator|++
control|)
block|{
name|symbolP
operator|=
name|segment_info
index|[
name|i
index|]
operator|.
name|dot
expr_stmt|;
if|if
condition|(
name|symbolP
condition|)
block|{
name|SA_SET_SCN_SCNLEN
argument_list|(
name|symbolP
argument_list|,
name|segment_info
index|[
name|i
index|]
operator|.
name|scnhdr
operator|.
name|s_size
argument_list|)
expr_stmt|;
name|SA_SET_SCN_NRELOC
argument_list|(
name|symbolP
argument_list|,
name|segment_info
index|[
name|i
index|]
operator|.
name|scnhdr
operator|.
name|s_nreloc
argument_list|)
expr_stmt|;
name|SA_SET_SCN_NLINNO
argument_list|(
name|symbolP
argument_list|,
name|segment_info
index|[
name|i
index|]
operator|.
name|scnhdr
operator|.
name|s_nlnno
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*      * Emit all symbols left in the symbol chain.      */
for|for
control|(
name|symbolP
operator|=
name|symbol_rootP
init|;
name|symbolP
condition|;
name|symbolP
operator|=
name|symbol_next
argument_list|(
name|symbolP
argument_list|)
control|)
block|{
comment|/* Used to save the offset of the name. It is used to point 	       to the string in memory but must be a file offset.  */
specifier|register
name|char
modifier|*
name|temp
decl_stmt|;
comment|/* We can't fix the lnnoptr field in yank_symbols with the other          adjustments, because we have to wait until we know where they          go in the file.  */
if|if
condition|(
name|SF_GET_ADJ_LNNOPTR
argument_list|(
name|symbolP
argument_list|)
condition|)
block|{
name|SA_GET_SYM_LNNOPTR
argument_list|(
name|symbolP
argument_list|)
operator|+=
name|segment_info
index|[
name|S_GET_SEGMENT
argument_list|(
name|symbolP
argument_list|)
index|]
operator|.
name|scnhdr
operator|.
name|s_lnnoptr
expr_stmt|;
block|}
name|tc_coff_symbol_emit_hook
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
name|temp
operator|=
name|S_GET_NAME
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
if|if
condition|(
name|SF_GET_STRING
argument_list|(
name|symbolP
argument_list|)
condition|)
block|{
name|S_SET_OFFSET
argument_list|(
name|symbolP
argument_list|,
name|symbolP
operator|->
name|sy_name_offset
argument_list|)
expr_stmt|;
name|S_SET_ZEROES
argument_list|(
name|symbolP
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|memset
argument_list|(
name|symbolP
operator|->
name|sy_symbol
operator|.
name|ost_entry
operator|.
name|n_name
argument_list|,
literal|0
argument_list|,
name|SYMNMLEN
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|symbolP
operator|->
name|sy_symbol
operator|.
name|ost_entry
operator|.
name|n_name
argument_list|,
name|temp
argument_list|,
name|SYMNMLEN
argument_list|)
expr_stmt|;
block|}
name|where
operator|=
name|symbol_to_chars
argument_list|(
name|abfd
argument_list|,
name|where
argument_list|,
name|symbolP
argument_list|)
expr_stmt|;
name|S_SET_NAME
argument_list|(
name|symbolP
argument_list|,
name|temp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* w_symbols() */
end_comment

begin_function
specifier|static
name|void
name|obj_coff_lcomm
parameter_list|(
name|ignore
parameter_list|)
name|int
name|ignore
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|s_lcomm
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return;
if|#
directive|if
literal|0
block|char *name;   char c;   int temp;   char *p;    symbolS *symbolP;    name = input_line_pointer;    c = get_symbol_end ();   p = input_line_pointer;   *p = c;   SKIP_WHITESPACE ();   if (*input_line_pointer != ',')     {       as_bad (_("Expected comma after name"));       ignore_rest_of_line ();       return;     }   if (*input_line_pointer == '\n')     {       as_bad (_("Missing size expression"));       return;     }   input_line_pointer++;   if ((temp = get_absolute_expression ())< 0)     {       as_warn (_("lcomm length (%d.)<0! Ignored."), temp);       ignore_rest_of_line ();       return;     }   *p = 0;    symbolP = symbol_find_or_make (name);    if (S_GET_SEGMENT (symbolP) == SEG_UNKNOWN&&       S_GET_VALUE (symbolP) == 0)     {       if (! need_pass_2) 	{ 	  char *p; 	  segT current_seg = now_seg;
comment|/* save current seg     */
block|subsegT current_subseg = now_subseg;  	  subseg_set (SEG_E2, 1); 	  symbolP->sy_frag = frag_now; 	  p = frag_var(rs_org, 1, 1, (relax_substateT)0, symbolP, 		       (offsetT) temp, (char *) 0); 	  *p = 0; 	  subseg_set (current_seg, current_subseg);
comment|/* restore current seg */
block|S_SET_SEGMENT (symbolP, SEG_E2); 	  S_SET_STORAGE_CLASS (symbolP, C_STAT); 	}     }   else     as_bad (_("Symbol %s already defined"), name);    demand_empty_rest_of_line ();
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|fixup_mdeps
parameter_list|(
name|frags
parameter_list|,
name|h
parameter_list|,
name|this_segment
parameter_list|)
name|fragS
modifier|*
name|frags
decl_stmt|;
name|object_headers
modifier|*
name|h
decl_stmt|;
name|segT
name|this_segment
decl_stmt|;
block|{
name|subseg_change
argument_list|(
name|this_segment
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
name|frags
condition|)
block|{
switch|switch
condition|(
name|frags
operator|->
name|fr_type
condition|)
block|{
case|case
name|rs_align
case|:
case|case
name|rs_align_code
case|:
case|case
name|rs_align_test
case|:
case|case
name|rs_org
case|:
ifdef|#
directive|ifdef
name|HANDLE_ALIGN
name|HANDLE_ALIGN
argument_list|(
name|frags
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|frags
operator|->
name|fr_type
operator|=
name|rs_fill
expr_stmt|;
name|frags
operator|->
name|fr_offset
operator|=
operator|(
operator|(
name|frags
operator|->
name|fr_next
operator|->
name|fr_address
operator|-
name|frags
operator|->
name|fr_address
operator|-
name|frags
operator|->
name|fr_fix
operator|)
operator|/
name|frags
operator|->
name|fr_var
operator|)
expr_stmt|;
break|break;
case|case
name|rs_machine_dependent
case|:
name|md_convert_frag
argument_list|(
name|h
argument_list|,
name|this_segment
argument_list|,
name|frags
argument_list|)
expr_stmt|;
name|frag_wane
argument_list|(
name|frags
argument_list|)
expr_stmt|;
break|break;
default|default:
empty_stmt|;
block|}
name|frags
operator|=
name|frags
operator|->
name|fr_next
expr_stmt|;
block|}
block|}
end_function

begin_if
if|#
directive|if
literal|1
end_if

begin_ifndef
ifndef|#
directive|ifndef
name|TC_FORCE_RELOCATION
end_ifndef

begin_define
define|#
directive|define
name|TC_FORCE_RELOCATION
parameter_list|(
name|fix
parameter_list|)
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|fixup_segment
parameter_list|(
name|segP
parameter_list|,
name|this_segment_type
parameter_list|)
name|segment_info_type
modifier|*
name|segP
decl_stmt|;
name|segT
name|this_segment_type
decl_stmt|;
block|{
specifier|register
name|fixS
modifier|*
name|fixP
decl_stmt|;
specifier|register
name|symbolS
modifier|*
name|add_symbolP
decl_stmt|;
specifier|register
name|symbolS
modifier|*
name|sub_symbolP
decl_stmt|;
name|long
name|add_number
decl_stmt|;
specifier|register
name|int
name|size
decl_stmt|;
specifier|register
name|char
modifier|*
name|place
decl_stmt|;
specifier|register
name|long
name|where
decl_stmt|;
specifier|register
name|char
name|pcrel
decl_stmt|;
specifier|register
name|fragS
modifier|*
name|fragP
decl_stmt|;
specifier|register
name|segT
name|add_symbol_segment
init|=
name|absolute_section
decl_stmt|;
for|for
control|(
name|fixP
operator|=
name|segP
operator|->
name|fix_root
init|;
name|fixP
condition|;
name|fixP
operator|=
name|fixP
operator|->
name|fx_next
control|)
block|{
name|fragP
operator|=
name|fixP
operator|->
name|fx_frag
expr_stmt|;
name|know
argument_list|(
name|fragP
argument_list|)
expr_stmt|;
name|where
operator|=
name|fixP
operator|->
name|fx_where
expr_stmt|;
name|place
operator|=
name|fragP
operator|->
name|fr_literal
operator|+
name|where
expr_stmt|;
name|size
operator|=
name|fixP
operator|->
name|fx_size
expr_stmt|;
name|add_symbolP
operator|=
name|fixP
operator|->
name|fx_addsy
expr_stmt|;
name|sub_symbolP
operator|=
name|fixP
operator|->
name|fx_subsy
expr_stmt|;
name|add_number
operator|=
name|fixP
operator|->
name|fx_offset
expr_stmt|;
name|pcrel
operator|=
name|fixP
operator|->
name|fx_pcrel
expr_stmt|;
comment|/* We want function-relative stabs to work on systems which 	 may use a relaxing linker; thus we must handle the sym1-sym2 	 fixups function-relative stabs generates.  	 Of course, if you actually enable relaxing in the linker, the 	 line and block scoping information is going to be incorrect 	 in some cases.  The only way to really fix this is to support 	 a reloc involving the difference of two symbols.  */
if|if
condition|(
name|linkrelax
operator|&&
operator|(
operator|!
name|sub_symbolP
operator|||
name|pcrel
operator|)
condition|)
continue|continue;
ifdef|#
directive|ifdef
name|TC_I960
if|if
condition|(
name|fixP
operator|->
name|fx_tcbit
operator|&&
name|SF_GET_CALLNAME
argument_list|(
name|add_symbolP
argument_list|)
condition|)
block|{
comment|/* Relocation should be done via the associated 'bal' entry 	     point symbol.  */
if|if
condition|(
operator|!
name|SF_GET_BALNAME
argument_list|(
name|tc_get_bal_of_call
argument_list|(
name|add_symbolP
argument_list|)
argument_list|)
condition|)
block|{
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"No 'bal' entry point for leafproc %s"
argument_list|)
argument_list|,
name|S_GET_NAME
argument_list|(
name|add_symbolP
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|fixP
operator|->
name|fx_addsy
operator|=
name|add_symbolP
operator|=
name|tc_get_bal_of_call
argument_list|(
name|add_symbolP
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Make sure the symbols have been resolved; this may not have          happened if these are expression symbols.  */
if|if
condition|(
name|add_symbolP
operator|!=
name|NULL
operator|&&
operator|!
name|add_symbolP
operator|->
name|sy_resolved
condition|)
name|resolve_symbol_value
argument_list|(
name|add_symbolP
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|add_symbolP
operator|!=
name|NULL
condition|)
block|{
comment|/* If this fixup is against a symbol which has been equated 	     to another symbol, convert it to the other symbol.  */
if|if
condition|(
name|add_symbolP
operator|->
name|sy_value
operator|.
name|X_op
operator|==
name|O_symbol
operator|&&
operator|(
operator|!
name|S_IS_DEFINED
argument_list|(
name|add_symbolP
argument_list|)
operator|||
name|S_IS_COMMON
argument_list|(
name|add_symbolP
argument_list|)
operator|)
condition|)
block|{
while|while
condition|(
name|add_symbolP
operator|->
name|sy_value
operator|.
name|X_op
operator|==
name|O_symbol
operator|&&
operator|(
operator|!
name|S_IS_DEFINED
argument_list|(
name|add_symbolP
argument_list|)
operator|||
name|S_IS_COMMON
argument_list|(
name|add_symbolP
argument_list|)
operator|)
condition|)
block|{
name|symbolS
modifier|*
name|n
decl_stmt|;
comment|/* We must avoid looping, as that can occur with a 		     badly written program.  */
name|n
operator|=
name|add_symbolP
operator|->
name|sy_value
operator|.
name|X_add_symbol
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|add_symbolP
condition|)
break|break;
name|add_number
operator|+=
name|add_symbolP
operator|->
name|sy_value
operator|.
name|X_add_number
expr_stmt|;
name|add_symbolP
operator|=
name|n
expr_stmt|;
block|}
name|fixP
operator|->
name|fx_addsy
operator|=
name|add_symbolP
expr_stmt|;
name|fixP
operator|->
name|fx_offset
operator|=
name|add_number
expr_stmt|;
block|}
block|}
if|if
condition|(
name|sub_symbolP
operator|!=
name|NULL
operator|&&
operator|!
name|sub_symbolP
operator|->
name|sy_resolved
condition|)
name|resolve_symbol_value
argument_list|(
name|sub_symbolP
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|add_symbolP
operator|!=
name|NULL
operator|&&
name|add_symbolP
operator|->
name|sy_mri_common
condition|)
block|{
name|know
argument_list|(
name|add_symbolP
operator|->
name|sy_value
operator|.
name|X_op
operator|==
name|O_symbol
argument_list|)
expr_stmt|;
name|add_number
operator|+=
name|S_GET_VALUE
argument_list|(
name|add_symbolP
argument_list|)
expr_stmt|;
name|fixP
operator|->
name|fx_offset
operator|=
name|add_number
expr_stmt|;
name|add_symbolP
operator|=
name|fixP
operator|->
name|fx_addsy
operator|=
name|add_symbolP
operator|->
name|sy_value
operator|.
name|X_add_symbol
expr_stmt|;
block|}
if|if
condition|(
name|add_symbolP
condition|)
block|{
name|add_symbol_segment
operator|=
name|S_GET_SEGMENT
argument_list|(
name|add_symbolP
argument_list|)
expr_stmt|;
block|}
comment|/* if there is an addend */
if|if
condition|(
name|sub_symbolP
condition|)
block|{
if|if
condition|(
name|add_symbolP
operator|==
name|NULL
operator|||
name|add_symbol_segment
operator|==
name|absolute_section
condition|)
block|{
if|if
condition|(
name|add_symbolP
operator|!=
name|NULL
condition|)
block|{
name|add_number
operator|+=
name|S_GET_VALUE
argument_list|(
name|add_symbolP
argument_list|)
expr_stmt|;
name|add_symbolP
operator|=
name|NULL
expr_stmt|;
name|fixP
operator|->
name|fx_addsy
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* It's just -sym.  */
if|if
condition|(
name|S_GET_SEGMENT
argument_list|(
name|sub_symbolP
argument_list|)
operator|==
name|absolute_section
condition|)
block|{
name|add_number
operator|-=
name|S_GET_VALUE
argument_list|(
name|sub_symbolP
argument_list|)
expr_stmt|;
name|fixP
operator|->
name|fx_subsy
operator|=
literal|0
expr_stmt|;
name|fixP
operator|->
name|fx_done
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
ifndef|#
directive|ifndef
name|TC_M68K
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"Negative of non-absolute symbol %s"
argument_list|)
argument_list|,
name|S_GET_NAME
argument_list|(
name|sub_symbolP
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|add_number
operator|-=
name|S_GET_VALUE
argument_list|(
name|sub_symbolP
argument_list|)
expr_stmt|;
block|}
comment|/* not absolute */
comment|/* if sub_symbol is in the same segment that add_symbol 		 and add_symbol is either in DATA, TEXT, BSS or ABSOLUTE */
block|}
elseif|else
if|if
condition|(
name|S_GET_SEGMENT
argument_list|(
name|sub_symbolP
argument_list|)
operator|==
name|add_symbol_segment
operator|&&
name|SEG_NORMAL
argument_list|(
name|add_symbol_segment
argument_list|)
condition|)
block|{
comment|/* Difference of 2 symbols from same segment.  Can't 		 make difference of 2 undefineds: 'value' means 		 something different for N_UNDF.  */
ifdef|#
directive|ifdef
name|TC_I960
comment|/* Makes no sense to use the difference of 2 arbitrary symbols 	         as the target of a call instruction.  */
if|if
condition|(
name|fixP
operator|->
name|fx_tcbit
condition|)
block|{
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"callj to difference of 2 symbols"
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* TC_I960 */
name|add_number
operator|+=
name|S_GET_VALUE
argument_list|(
name|add_symbolP
argument_list|)
operator|-
name|S_GET_VALUE
argument_list|(
name|sub_symbolP
argument_list|)
expr_stmt|;
name|add_symbolP
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|TC_FORCE_RELOCATION
argument_list|(
name|fixP
argument_list|)
condition|)
block|{
name|fixP
operator|->
name|fx_addsy
operator|=
name|NULL
expr_stmt|;
name|fixP
operator|->
name|fx_subsy
operator|=
name|NULL
expr_stmt|;
name|fixP
operator|->
name|fx_done
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|TC_M68K
comment|/* is this right? */
name|pcrel
operator|=
literal|0
expr_stmt|;
name|fixP
operator|->
name|fx_pcrel
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
block|}
block|}
else|else
block|{
comment|/* Different segments in subtraction.  */
name|know
argument_list|(
operator|!
operator|(
name|S_IS_EXTERNAL
argument_list|(
name|sub_symbolP
argument_list|)
operator|&&
operator|(
name|S_GET_SEGMENT
argument_list|(
name|sub_symbolP
argument_list|)
operator|==
name|absolute_section
operator|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|S_GET_SEGMENT
argument_list|(
name|sub_symbolP
argument_list|)
operator|==
name|absolute_section
operator|)
condition|)
block|{
name|add_number
operator|-=
name|S_GET_VALUE
argument_list|(
name|sub_symbolP
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DIFF_EXPR_OK
elseif|else
if|if
condition|(
name|S_GET_SEGMENT
argument_list|(
name|sub_symbolP
argument_list|)
operator|==
name|this_segment_type
if|#
directive|if
literal|0
comment|/* Okay for 68k, at least...  */
condition|&& !pcrel
endif|#
directive|endif
condition|)
block|{
comment|/* Make it pc-relative.  */
name|add_number
operator|+=
operator|(
name|md_pcrel_from
argument_list|(
name|fixP
argument_list|)
operator|-
name|S_GET_VALUE
argument_list|(
name|sub_symbolP
argument_list|)
operator|)
expr_stmt|;
name|pcrel
operator|=
literal|1
expr_stmt|;
name|fixP
operator|->
name|fx_pcrel
operator|=
literal|1
expr_stmt|;
name|sub_symbolP
operator|=
literal|0
expr_stmt|;
name|fixP
operator|->
name|fx_subsy
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
else|else
block|{
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"Can't emit reloc {- %s-seg symbol \"%s\"} @ file address %ld."
argument_list|)
argument_list|,
name|segment_name
argument_list|(
name|S_GET_SEGMENT
argument_list|(
name|sub_symbolP
argument_list|)
argument_list|)
argument_list|,
name|S_GET_NAME
argument_list|(
name|sub_symbolP
argument_list|)
argument_list|,
call|(
name|long
call|)
argument_list|(
name|fragP
operator|->
name|fr_address
operator|+
name|where
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* if absolute */
block|}
block|}
comment|/* if sub_symbolP */
if|if
condition|(
name|add_symbolP
condition|)
block|{
if|if
condition|(
name|add_symbol_segment
operator|==
name|this_segment_type
operator|&&
name|pcrel
condition|)
block|{
comment|/* 	       * This fixup was made when the symbol's segment was 	       * SEG_UNKNOWN, but it is now in the local segment. 	       * So we know how to do the address without relocation. 	       */
ifdef|#
directive|ifdef
name|TC_I960
comment|/* reloc_callj() may replace a 'call' with a 'calls' or a 'bal', 	       * in which cases it modifies *fixP as appropriate.  In the case 	       * of a 'calls', no further work is required, and *fixP has been 	       * set up to make the rest of the code below a no-op. 	       */
name|reloc_callj
argument_list|(
name|fixP
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* TC_I960 */
name|add_number
operator|+=
name|S_GET_VALUE
argument_list|(
name|add_symbolP
argument_list|)
expr_stmt|;
name|add_number
operator|-=
name|md_pcrel_from
argument_list|(
name|fixP
argument_list|)
expr_stmt|;
comment|/* We used to do 		   add_number -= segP->scnhdr.s_vaddr; 		 if defined (TC_I386) || defined (TE_LYNX).  I now 		 think that was an error propagated from the case when 		 we are going to emit the relocation.  If we are not 		 going to emit the relocation, then we just want to 		 set add_number to the difference between the symbols. 		 This is a case that would only arise when there is a 		 PC relative reference from a section other than .text 		 to a symbol defined in the same section, and the 		 reference is not relaxed.  Since jump instructions on 		 the i386 are relaxed, this could only arise with a 		 call instruction.  */
name|pcrel
operator|=
literal|0
expr_stmt|;
comment|/* Lie. Don't want further pcrel processing.  */
if|if
condition|(
operator|!
name|TC_FORCE_RELOCATION
argument_list|(
name|fixP
argument_list|)
condition|)
block|{
name|fixP
operator|->
name|fx_addsy
operator|=
name|NULL
expr_stmt|;
name|fixP
operator|->
name|fx_done
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
switch|switch
condition|(
name|add_symbol_segment
condition|)
block|{
case|case
name|absolute_section
case|:
ifdef|#
directive|ifdef
name|TC_I960
name|reloc_callj
argument_list|(
name|fixP
argument_list|)
expr_stmt|;
comment|/* See comment about reloc_callj() above*/
endif|#
directive|endif
comment|/* TC_I960 */
name|add_number
operator|+=
name|S_GET_VALUE
argument_list|(
name|add_symbolP
argument_list|)
expr_stmt|;
name|add_symbolP
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|TC_FORCE_RELOCATION
argument_list|(
name|fixP
argument_list|)
condition|)
block|{
name|fixP
operator|->
name|fx_addsy
operator|=
name|NULL
expr_stmt|;
name|fixP
operator|->
name|fx_done
operator|=
literal|1
expr_stmt|;
block|}
break|break;
default|default:
if|#
directive|if
name|defined
argument_list|(
name|TC_A29K
argument_list|)
operator|||
operator|(
name|defined
argument_list|(
name|TE_PE
argument_list|)
operator|&&
name|defined
argument_list|(
name|TC_I386
argument_list|)
operator|)
operator|||
name|defined
argument_list|(
name|TC_M88K
argument_list|)
comment|/* This really should be handled in the linker, but 		     backward compatibility forbids.  */
name|add_number
operator|+=
name|S_GET_VALUE
argument_list|(
name|add_symbolP
argument_list|)
expr_stmt|;
else|#
directive|else
name|add_number
operator|+=
name|S_GET_VALUE
argument_list|(
name|add_symbolP
argument_list|)
operator|+
name|segment_info
index|[
name|S_GET_SEGMENT
argument_list|(
name|add_symbolP
argument_list|)
index|]
operator|.
name|scnhdr
operator|.
name|s_paddr
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|SEG_UNKNOWN
case|:
ifdef|#
directive|ifdef
name|TC_I960
if|if
condition|(
operator|(
name|int
operator|)
name|fixP
operator|->
name|fx_bit_fixP
operator|==
literal|13
condition|)
block|{
comment|/* This is a COBR instruction.  They have only a 		       * 13-bit displacement and are only to be used 		       * for local branches: flag as error, don't generate 		       * relocation. 		       */
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"can't use COBR format with external label"
argument_list|)
argument_list|)
expr_stmt|;
name|fixP
operator|->
name|fx_addsy
operator|=
name|NULL
expr_stmt|;
name|fixP
operator|->
name|fx_done
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
comment|/* COBR */
endif|#
directive|endif
comment|/* TC_I960 */
if|#
directive|if
operator|(
operator|(
name|defined
argument_list|(
name|TC_I386
argument_list|)
operator|||
name|defined
argument_list|(
name|TE_LYNX
argument_list|)
operator|||
name|defined
argument_list|(
name|TE_AUX
argument_list|)
operator|)
operator|&&
operator|!
name|defined
argument_list|(
name|TE_PE
argument_list|)
operator|)
operator|||
name|defined
argument_list|(
name|COFF_COMMON_ADDEND
argument_list|)
comment|/* 386 COFF uses a peculiar format in which the 		     value of a common symbol is stored in the .text 		     segment (I've checked this on SVR3.2 and SCO 		     3.2.2) Ian Taylor<ian@cygnus.com>.  */
comment|/* This is also true for 68k COFF on sysv machines 		     (Checked on Motorola sysv68 R3V6 and R3V7.1, and also on 		     UNIX System V/M68000, Release 1.0 from ATT/Bell Labs) 		     Philippe De Muyter<phdm@info.ucl.ac.be>.  */
if|if
condition|(
name|S_IS_COMMON
argument_list|(
name|add_symbolP
argument_list|)
condition|)
name|add_number
operator|+=
name|S_GET_VALUE
argument_list|(
name|add_symbolP
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
comment|/* switch on symbol seg */
block|}
comment|/* if not in local seg */
block|}
comment|/* if there was a + symbol */
if|if
condition|(
name|pcrel
condition|)
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|TC_M88K
argument_list|)
operator|&&
operator|!
operator|(
name|defined
argument_list|(
name|TE_PE
argument_list|)
operator|&&
name|defined
argument_list|(
name|TC_I386
argument_list|)
operator|)
operator|&&
operator|!
name|defined
argument_list|(
name|TC_A29K
argument_list|)
comment|/* This adjustment is not correct on the m88k, for which the 	     linker does all the computation.  */
name|add_number
operator|-=
name|md_pcrel_from
argument_list|(
name|fixP
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|add_symbolP
operator|==
literal|0
condition|)
block|{
name|fixP
operator|->
name|fx_addsy
operator|=
operator|&
name|abs_symbol
expr_stmt|;
block|}
comment|/* if there's an add_symbol */
if|#
directive|if
name|defined
argument_list|(
name|TC_I386
argument_list|)
operator|||
name|defined
argument_list|(
name|TE_LYNX
argument_list|)
operator|||
name|defined
argument_list|(
name|TC_I960
argument_list|)
operator|||
name|defined
argument_list|(
name|TC_M68K
argument_list|)
comment|/* On the 386 we must adjust by the segment vaddr as well. 	     Ian Taylor.  	     I changed the i960 to work this way as well.  This is 	     compatible with the current GNU linker behaviour.  I do 	     not know what other i960 COFF assemblers do.  This is not 	     a common case: normally, only assembler code will contain 	     a PC relative reloc, and only branches which do not 	     originate in the .text section will have a non-zero 	     address.  	     I changed the m68k to work this way as well.  This will 	     break existing PC relative relocs from sections which do 	     not start at address 0, but it will make ld -r work. 	     Ian Taylor, 4 Oct 96.  */
name|add_number
operator|-=
name|segP
operator|->
name|scnhdr
operator|.
name|s_vaddr
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* if pcrel */
ifdef|#
directive|ifdef
name|MD_APPLY_FIX3
name|md_apply_fix3
argument_list|(
name|fixP
argument_list|,
operator|(
name|valueT
operator|*
operator|)
operator|&
name|add_number
argument_list|,
name|this_segment_type
argument_list|)
expr_stmt|;
else|#
directive|else
name|md_apply_fix
argument_list|(
name|fixP
argument_list|,
name|add_number
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|fixP
operator|->
name|fx_bit_fixP
operator|&&
operator|!
name|fixP
operator|->
name|fx_no_overflow
condition|)
block|{
ifndef|#
directive|ifndef
name|TC_M88K
comment|/* The m88k uses the offset field of the reloc to get around 	     this problem.  */
if|if
condition|(
operator|(
name|size
operator|==
literal|1
operator|&&
operator|(
operator|(
name|add_number
operator|&
operator|~
literal|0xFF
operator|)
operator|||
operator|(
name|fixP
operator|->
name|fx_signed
operator|&&
operator|(
name|add_number
operator|&
literal|0x80
operator|)
operator|)
operator|)
operator|&&
operator|(
operator|(
name|add_number
operator|&
operator|~
literal|0xFF
operator|)
operator|!=
operator|(
operator|-
literal|1
operator|&
operator|~
literal|0xFF
operator|)
operator|||
operator|(
name|add_number
operator|&
literal|0x80
operator|)
operator|==
literal|0
operator|)
operator|)
operator|||
operator|(
name|size
operator|==
literal|2
operator|&&
operator|(
operator|(
name|add_number
operator|&
operator|~
literal|0xFFFF
operator|)
operator|||
operator|(
name|fixP
operator|->
name|fx_signed
operator|&&
operator|(
name|add_number
operator|&
literal|0x8000
operator|)
operator|)
operator|)
operator|&&
operator|(
operator|(
name|add_number
operator|&
operator|~
literal|0xFFFF
operator|)
operator|!=
operator|(
operator|-
literal|1
operator|&
operator|~
literal|0xFFFF
operator|)
operator|||
operator|(
name|add_number
operator|&
literal|0x8000
operator|)
operator|==
literal|0
operator|)
operator|)
condition|)
block|{
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"Value of %ld too large for field of %d bytes at 0x%lx"
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|add_number
argument_list|,
name|size
argument_list|,
call|(
name|unsigned
name|long
call|)
argument_list|(
name|fragP
operator|->
name|fr_address
operator|+
name|where
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|WARN_SIGNED_OVERFLOW_WORD
comment|/* Warn if a .word value is too large when treated as a 	     signed number.  We already know it is not too negative. 	     This is to catch over-large switches generated by gcc on 	     the 68k.  */
if|if
condition|(
operator|!
name|flag_signed_overflow_ok
operator|&&
name|size
operator|==
literal|2
operator|&&
name|add_number
operator|>
literal|0x7fff
condition|)
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"Signed .word overflow; switch may be too large; %ld at 0x%lx"
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|add_number
argument_list|,
call|(
name|unsigned
name|long
call|)
argument_list|(
name|fragP
operator|->
name|fr_address
operator|+
name|where
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* not a bit fix */
block|}
comment|/* For each fixS in this segment.  */
block|}
end_function

begin_comment
comment|/* fixup_segment() */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* The first entry in a .stab section is special.  */
end_comment

begin_function
name|void
name|obj_coff_init_stab_section
parameter_list|(
name|seg
parameter_list|)
name|segT
name|seg
decl_stmt|;
block|{
name|char
modifier|*
name|file
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|stabstr_name
decl_stmt|;
name|unsigned
name|int
name|stroff
decl_stmt|;
comment|/* Make space for this first symbol.  */
name|p
operator|=
name|frag_more
argument_list|(
literal|12
argument_list|)
expr_stmt|;
comment|/* Zero it out.  */
name|memset
argument_list|(
name|p
argument_list|,
literal|0
argument_list|,
literal|12
argument_list|)
expr_stmt|;
name|as_where
argument_list|(
operator|&
name|file
argument_list|,
operator|(
name|unsigned
name|int
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|stabstr_name
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|segment_info
index|[
name|seg
index|]
operator|.
name|name
argument_list|)
operator|+
literal|4
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|stabstr_name
argument_list|,
name|segment_info
index|[
name|seg
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|stabstr_name
argument_list|,
literal|"str"
argument_list|)
expr_stmt|;
name|stroff
operator|=
name|get_stab_string_offset
argument_list|(
name|file
argument_list|,
name|stabstr_name
argument_list|)
expr_stmt|;
name|know
argument_list|(
name|stroff
operator|==
literal|1
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|p
argument_list|,
name|stroff
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Fill in the counts in the first entry in a .stab section.  */
end_comment

begin_function
specifier|static
name|void
name|adjust_stab_section
parameter_list|(
name|abfd
parameter_list|,
name|seg
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|segT
name|seg
decl_stmt|;
block|{
name|segT
name|stabstrseg
init|=
name|SEG_UNKNOWN
decl_stmt|;
specifier|const
name|char
modifier|*
name|secname
decl_stmt|,
modifier|*
name|name2
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|p
init|=
name|NULL
decl_stmt|;
name|int
name|i
decl_stmt|,
name|strsz
init|=
literal|0
decl_stmt|,
name|nsyms
decl_stmt|;
name|fragS
modifier|*
name|frag
init|=
name|segment_info
index|[
name|seg
index|]
operator|.
name|frchainP
operator|->
name|frch_root
decl_stmt|;
comment|/* Look for the associated string table section.  */
name|secname
operator|=
name|segment_info
index|[
name|seg
index|]
operator|.
name|name
expr_stmt|;
name|name
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|secname
argument_list|)
operator|+
literal|4
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|name
argument_list|,
name|secname
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|name
argument_list|,
literal|"str"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|SEG_E0
init|;
name|i
operator|<
name|SEG_UNKNOWN
condition|;
name|i
operator|++
control|)
block|{
name|name2
operator|=
name|segment_info
index|[
name|i
index|]
operator|.
name|name
expr_stmt|;
if|if
condition|(
name|name2
operator|!=
name|NULL
operator|&&
name|strncmp
argument_list|(
name|name2
argument_list|,
name|name
argument_list|,
literal|8
argument_list|)
operator|==
literal|0
condition|)
block|{
name|stabstrseg
operator|=
name|i
expr_stmt|;
break|break;
block|}
block|}
comment|/* If we found the section, get its size.  */
if|if
condition|(
name|stabstrseg
operator|!=
name|SEG_UNKNOWN
condition|)
name|strsz
operator|=
name|size_section
argument_list|(
name|abfd
argument_list|,
name|stabstrseg
argument_list|)
expr_stmt|;
name|nsyms
operator|=
name|size_section
argument_list|(
name|abfd
argument_list|,
name|seg
argument_list|)
operator|/
literal|12
operator|-
literal|1
expr_stmt|;
comment|/* Look for the first frag of sufficient size for the initial stab      symbol, and collect a pointer to it.  */
while|while
condition|(
name|frag
operator|&&
name|frag
operator|->
name|fr_fix
operator|<
literal|12
condition|)
name|frag
operator|=
name|frag
operator|->
name|fr_next
expr_stmt|;
name|assert
argument_list|(
name|frag
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|p
operator|=
name|frag
operator|->
name|fr_literal
expr_stmt|;
name|assert
argument_list|(
name|p
operator|!=
literal|0
argument_list|)
expr_stmt|;
comment|/* Write in the number of stab symbols and the size of the string      table.  */
name|bfd_h_put_16
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|nsyms
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|p
operator|+
literal|6
argument_list|)
expr_stmt|;
name|bfd_h_put_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|strsz
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|p
operator|+
literal|8
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not BFD_ASSEMBLER */
end_comment

begin_decl_stmt
specifier|const
name|pseudo_typeS
name|coff_pseudo_table
index|[]
init|=
block|{
block|{
literal|"def"
block|,
name|obj_coff_def
block|,
literal|0
block|}
block|,
block|{
literal|"dim"
block|,
name|obj_coff_dim
block|,
literal|0
block|}
block|,
block|{
literal|"endef"
block|,
name|obj_coff_endef
block|,
literal|0
block|}
block|,
block|{
literal|"line"
block|,
name|obj_coff_line
block|,
literal|0
block|}
block|,
block|{
literal|"ln"
block|,
name|obj_coff_ln
block|,
literal|0
block|}
block|,
ifdef|#
directive|ifdef
name|BFD_ASSEMBLER
block|{
literal|"loc"
block|,
name|obj_coff_loc
block|,
literal|0
block|}
block|,
endif|#
directive|endif
block|{
literal|"appline"
block|,
name|obj_coff_ln
block|,
literal|1
block|}
block|,
block|{
literal|"scl"
block|,
name|obj_coff_scl
block|,
literal|0
block|}
block|,
block|{
literal|"size"
block|,
name|obj_coff_size
block|,
literal|0
block|}
block|,
block|{
literal|"tag"
block|,
name|obj_coff_tag
block|,
literal|0
block|}
block|,
block|{
literal|"type"
block|,
name|obj_coff_type
block|,
literal|0
block|}
block|,
block|{
literal|"val"
block|,
name|obj_coff_val
block|,
literal|0
block|}
block|,
block|{
literal|"section"
block|,
name|obj_coff_section
block|,
literal|0
block|}
block|,
block|{
literal|"sect"
block|,
name|obj_coff_section
block|,
literal|0
block|}
block|,
comment|/* FIXME: We ignore the MRI short attribute.  */
block|{
literal|"section.s"
block|,
name|obj_coff_section
block|,
literal|0
block|}
block|,
block|{
literal|"sect.s"
block|,
name|obj_coff_section
block|,
literal|0
block|}
block|,
comment|/* We accept the .bss directive for backward compatibility with      earlier versions of gas.  */
block|{
literal|"bss"
block|,
name|obj_coff_bss
block|,
literal|0
block|}
block|,
block|{
literal|"weak"
block|,
name|obj_coff_weak
block|,
literal|0
block|}
block|,
block|{
literal|"ident"
block|,
name|obj_coff_ident
block|,
literal|0
block|}
block|,
ifndef|#
directive|ifndef
name|BFD_ASSEMBLER
block|{
literal|"use"
block|,
name|obj_coff_section
block|,
literal|0
block|}
block|,
block|{
literal|"text"
block|,
name|obj_coff_text
block|,
literal|0
block|}
block|,
block|{
literal|"data"
block|,
name|obj_coff_data
block|,
literal|0
block|}
block|,
block|{
literal|"lcomm"
block|,
name|obj_coff_lcomm
block|,
literal|0
block|}
block|,
else|#
directive|else
block|{
literal|"optim"
block|,
name|s_ignore
block|,
literal|0
block|}
block|,
comment|/* For sun386i cc (?) */
endif|#
directive|endif
block|{
literal|"version"
block|,
name|s_ignore
block|,
literal|0
block|}
block|,
block|{
literal|"ABORT"
block|,
name|s_abort
block|,
literal|0
block|}
block|,
ifdef|#
directive|ifdef
name|TC_M88K
comment|/* The m88k uses sdef instead of def.  */
block|{
literal|"sdef"
block|,
name|obj_coff_def
block|,
literal|0
block|}
block|,
endif|#
directive|endif
block|{
name|NULL
block|,
name|NULL
block|,
literal|0
block|}
comment|/* end sentinel */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* coff_pseudo_table */
end_comment

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|BFD_ASSEMBLER
end_ifdef

begin_comment
comment|/* Support for a COFF emulation.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|coff_pop_insert
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|coff_separate_stab_sections
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|coff_pop_insert
parameter_list|()
block|{
name|pop_insert
argument_list|(
name|coff_pseudo_table
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|coff_separate_stab_sections
parameter_list|()
block|{
return|return
literal|1
return|;
block|}
end_function

begin_decl_stmt
specifier|const
name|struct
name|format_ops
name|coff_format_ops
init|=
block|{
name|bfd_target_coff_flavour
block|,
literal|0
block|,
comment|/* dfl_leading_underscore */
literal|1
block|,
comment|/* emit_section_symbols */
literal|0
block|,
comment|/* begin */
name|c_dot_file_symbol
block|,
name|coff_frob_symbol
block|,
literal|0
block|,
comment|/* frob_file */
literal|0
block|,
comment|/* frob_file_before_adjust */
name|coff_frob_file_after_relocs
block|,
literal|0
block|,
comment|/* s_get_size */
literal|0
block|,
comment|/* s_set_size */
literal|0
block|,
comment|/* s_get_align */
literal|0
block|,
comment|/* s_set_align */
literal|0
block|,
comment|/* s_get_other */
literal|0
block|,
comment|/* s_set_other */
literal|0
block|,
comment|/* s_get_desc */
literal|0
block|,
comment|/* s_set_desc */
literal|0
block|,
comment|/* s_get_type */
literal|0
block|,
comment|/* s_set_type */
literal|0
block|,
comment|/* copy_symbol_attributes */
literal|0
block|,
comment|/* generate_asm_lineno */
literal|0
block|,
comment|/* process_stab */
name|coff_separate_stab_sections
block|,
name|obj_coff_init_stab_section
block|,
literal|0
block|,
comment|/* sec_sym_ok_for_reloc */
name|coff_pop_insert
block|,
literal|0
block|,
comment|/* ecoff_set_ext */
name|coff_obj_read_begin_hook
block|,
name|coff_obj_symbol_new_hook
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

end_unit

