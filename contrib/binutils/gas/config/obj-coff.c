begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* coff object file format    Copyright 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998,    1999, 2000, 2001, 2002, 2003, 2004, 2005    Free Software Foundation, Inc.     This file is part of GAS.     GAS is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     GAS is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with GAS; see the file COPYING.  If not, write to the Free    Software Foundation, 51 Franklin Street - Fifth Floor, Boston, MA    02110-1301, USA.  */
end_comment

begin_define
define|#
directive|define
name|OBJ_HEADER
value|"obj-coff.h"
end_define

begin_include
include|#
directive|include
file|"as.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_include
include|#
directive|include
file|"subsegs.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|TE_PE
end_ifdef

begin_include
include|#
directive|include
file|"coff/pe.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|streq
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|(strcmp ((a), (b)) == 0)
end_define

begin_define
define|#
directive|define
name|strneq
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|n
parameter_list|)
value|(strncmp ((a), (b), (n)) == 0)
end_define

begin_comment
comment|/* I think this is probably always correct.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|KEEP_RELOC_INFO
end_ifndef

begin_define
define|#
directive|define
name|KEEP_RELOC_INFO
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* obj_coff_section will use this macro to set a new section's    attributes when a directive has no valid flags or the "w" flag is    used.  This default should be appropriate for most.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|TC_COFF_SECTION_DEFAULT_ATTRIBUTES
end_ifndef

begin_define
define|#
directive|define
name|TC_COFF_SECTION_DEFAULT_ATTRIBUTES
value|(SEC_LOAD | SEC_DATA)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* This is used to hold the symbol built by a sequence of pseudo-ops    from .def and .endef.  */
end_comment

begin_decl_stmt
specifier|static
name|symbolS
modifier|*
name|def_symbol_in_progress
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|TE_PE
end_ifdef

begin_comment
comment|/* PE weak alternate symbols begin with this string.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
name|weak_altprefix
index|[]
init|=
literal|".weak."
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* TE_PE */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|unsigned
name|long
name|chunk_size
decl_stmt|;
name|unsigned
name|long
name|element_size
decl_stmt|;
name|unsigned
name|long
name|size
decl_stmt|;
name|char
modifier|*
name|data
decl_stmt|;
name|unsigned
name|long
name|pointer
decl_stmt|;
block|}
name|stack
typedef|;
end_typedef

begin_escape
end_escape

begin_comment
comment|/* Stack stuff.  */
end_comment

begin_function
specifier|static
name|stack
modifier|*
name|stack_init
parameter_list|(
name|unsigned
name|long
name|chunk_size
parameter_list|,
name|unsigned
name|long
name|element_size
parameter_list|)
block|{
name|stack
modifier|*
name|st
decl_stmt|;
name|st
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|st
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|st
condition|)
return|return
name|NULL
return|;
name|st
operator|->
name|data
operator|=
name|malloc
argument_list|(
name|chunk_size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|st
operator|->
name|data
condition|)
block|{
name|free
argument_list|(
name|st
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|st
operator|->
name|pointer
operator|=
literal|0
expr_stmt|;
name|st
operator|->
name|size
operator|=
name|chunk_size
expr_stmt|;
name|st
operator|->
name|chunk_size
operator|=
name|chunk_size
expr_stmt|;
name|st
operator|->
name|element_size
operator|=
name|element_size
expr_stmt|;
return|return
name|st
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|stack_push
parameter_list|(
name|stack
modifier|*
name|st
parameter_list|,
name|char
modifier|*
name|element
parameter_list|)
block|{
if|if
condition|(
name|st
operator|->
name|pointer
operator|+
name|st
operator|->
name|element_size
operator|>=
name|st
operator|->
name|size
condition|)
block|{
name|st
operator|->
name|size
operator|+=
name|st
operator|->
name|chunk_size
expr_stmt|;
if|if
condition|(
operator|(
name|st
operator|->
name|data
operator|=
name|xrealloc
argument_list|(
name|st
operator|->
name|data
argument_list|,
name|st
operator|->
name|size
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
block|}
name|memcpy
argument_list|(
name|st
operator|->
name|data
operator|+
name|st
operator|->
name|pointer
argument_list|,
name|element
argument_list|,
name|st
operator|->
name|element_size
argument_list|)
expr_stmt|;
name|st
operator|->
name|pointer
operator|+=
name|st
operator|->
name|element_size
expr_stmt|;
return|return
name|st
operator|->
name|data
operator|+
name|st
operator|->
name|pointer
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|stack_pop
parameter_list|(
name|stack
modifier|*
name|st
parameter_list|)
block|{
if|if
condition|(
name|st
operator|->
name|pointer
operator|<
name|st
operator|->
name|element_size
condition|)
block|{
name|st
operator|->
name|pointer
operator|=
literal|0
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|st
operator|->
name|pointer
operator|-=
name|st
operator|->
name|element_size
expr_stmt|;
return|return
name|st
operator|->
name|data
operator|+
name|st
operator|->
name|pointer
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Maintain a list of the tagnames of the structures.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|hash_control
modifier|*
name|tag_hash
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|tag_init
parameter_list|(
name|void
parameter_list|)
block|{
name|tag_hash
operator|=
name|hash_new
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|tag_insert
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|symbolS
modifier|*
name|symbolP
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|error_string
decl_stmt|;
if|if
condition|(
operator|(
name|error_string
operator|=
name|hash_jam
argument_list|(
name|tag_hash
argument_list|,
name|name
argument_list|,
operator|(
name|char
operator|*
operator|)
name|symbolP
argument_list|)
operator|)
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"Inserting \"%s\" into structure table failed: %s"
argument_list|)
argument_list|,
name|name
argument_list|,
name|error_string
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|symbolS
modifier|*
name|tag_find
parameter_list|(
name|char
modifier|*
name|name
parameter_list|)
block|{
return|return
operator|(
name|symbolS
operator|*
operator|)
name|hash_find
argument_list|(
name|tag_hash
argument_list|,
name|name
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|symbolS
modifier|*
name|tag_find_or_make
parameter_list|(
name|char
modifier|*
name|name
parameter_list|)
block|{
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
if|if
condition|(
operator|(
name|symbolP
operator|=
name|tag_find
argument_list|(
name|name
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|symbolP
operator|=
name|symbol_new
argument_list|(
name|name
argument_list|,
name|undefined_section
argument_list|,
literal|0
argument_list|,
operator|&
name|zero_address_frag
argument_list|)
expr_stmt|;
name|tag_insert
argument_list|(
name|S_GET_NAME
argument_list|(
name|symbolP
argument_list|)
argument_list|,
name|symbolP
argument_list|)
expr_stmt|;
name|symbol_table_insert
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
block|}
return|return
name|symbolP
return|;
block|}
end_function

begin_comment
comment|/* We accept the .bss directive to set the section for backward    compatibility with earlier versions of gas.  */
end_comment

begin_function
specifier|static
name|void
name|obj_coff_bss
parameter_list|(
name|int
name|ignore
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|'\n'
condition|)
name|subseg_new
argument_list|(
literal|".bss"
argument_list|,
name|get_absolute_expression
argument_list|()
argument_list|)
expr_stmt|;
else|else
name|s_lcomm
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|GET_FILENAME_STRING
parameter_list|(
name|X
parameter_list|)
define|\
value|((char *) (&((X)->sy_symbol.ost_auxent->x_file.x_n.x_offset))[1])
end_define

begin_comment
comment|/* @@ Ick.  */
end_comment

begin_function
specifier|static
name|segT
name|fetch_coff_debug_section
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|segT
name|debug_section
decl_stmt|;
if|if
condition|(
operator|!
name|debug_section
condition|)
block|{
specifier|const
name|asymbol
modifier|*
name|s
decl_stmt|;
name|s
operator|=
name|bfd_make_debug_symbol
argument_list|(
name|stdoutput
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|s
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|debug_section
operator|=
name|s
operator|->
name|section
expr_stmt|;
block|}
return|return
name|debug_section
return|;
block|}
end_function

begin_function
name|void
name|SA_SET_SYM_ENDNDX
parameter_list|(
name|symbolS
modifier|*
name|sym
parameter_list|,
name|symbolS
modifier|*
name|val
parameter_list|)
block|{
name|combined_entry_type
modifier|*
name|entry
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|entry
operator|=
operator|&
name|coffsymbol
argument_list|(
name|symbol_get_bfdsym
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|->
name|native
index|[
literal|1
index|]
expr_stmt|;
name|p
operator|=
name|coffsymbol
argument_list|(
name|symbol_get_bfdsym
argument_list|(
name|val
argument_list|)
argument_list|)
operator|->
name|native
expr_stmt|;
name|entry
operator|->
name|u
operator|.
name|auxent
operator|.
name|x_sym
operator|.
name|x_fcnary
operator|.
name|x_fcn
operator|.
name|x_endndx
operator|.
name|p
operator|=
name|p
expr_stmt|;
name|entry
operator|->
name|fix_end
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|SA_SET_SYM_TAGNDX
parameter_list|(
name|symbolS
modifier|*
name|sym
parameter_list|,
name|symbolS
modifier|*
name|val
parameter_list|)
block|{
name|combined_entry_type
modifier|*
name|entry
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|entry
operator|=
operator|&
name|coffsymbol
argument_list|(
name|symbol_get_bfdsym
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|->
name|native
index|[
literal|1
index|]
expr_stmt|;
name|p
operator|=
name|coffsymbol
argument_list|(
name|symbol_get_bfdsym
argument_list|(
name|val
argument_list|)
argument_list|)
operator|->
name|native
expr_stmt|;
name|entry
operator|->
name|u
operator|.
name|auxent
operator|.
name|x_sym
operator|.
name|x_tagndx
operator|.
name|p
operator|=
name|p
expr_stmt|;
name|entry
operator|->
name|fix_tag
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|S_GET_DATA_TYPE
parameter_list|(
name|symbolS
modifier|*
name|sym
parameter_list|)
block|{
return|return
name|coffsymbol
argument_list|(
name|symbol_get_bfdsym
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|->
name|native
operator|->
name|u
operator|.
name|syment
operator|.
name|n_type
return|;
block|}
end_function

begin_function
name|int
name|S_SET_DATA_TYPE
parameter_list|(
name|symbolS
modifier|*
name|sym
parameter_list|,
name|int
name|val
parameter_list|)
block|{
name|coffsymbol
argument_list|(
name|symbol_get_bfdsym
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|->
name|native
operator|->
name|u
operator|.
name|syment
operator|.
name|n_type
operator|=
name|val
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_function
name|int
name|S_GET_STORAGE_CLASS
parameter_list|(
name|symbolS
modifier|*
name|sym
parameter_list|)
block|{
return|return
name|coffsymbol
argument_list|(
name|symbol_get_bfdsym
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|->
name|native
operator|->
name|u
operator|.
name|syment
operator|.
name|n_sclass
return|;
block|}
end_function

begin_function
name|int
name|S_SET_STORAGE_CLASS
parameter_list|(
name|symbolS
modifier|*
name|sym
parameter_list|,
name|int
name|val
parameter_list|)
block|{
name|coffsymbol
argument_list|(
name|symbol_get_bfdsym
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|->
name|native
operator|->
name|u
operator|.
name|syment
operator|.
name|n_sclass
operator|=
name|val
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_comment
comment|/* Merge a debug symbol containing debug information into a normal symbol.  */
end_comment

begin_function
specifier|static
name|void
name|c_symbol_merge
parameter_list|(
name|symbolS
modifier|*
name|debug
parameter_list|,
name|symbolS
modifier|*
name|normal
parameter_list|)
block|{
name|S_SET_DATA_TYPE
argument_list|(
name|normal
argument_list|,
name|S_GET_DATA_TYPE
argument_list|(
name|debug
argument_list|)
argument_list|)
expr_stmt|;
name|S_SET_STORAGE_CLASS
argument_list|(
name|normal
argument_list|,
name|S_GET_STORAGE_CLASS
argument_list|(
name|debug
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|S_GET_NUMBER_AUXILIARY
argument_list|(
name|debug
argument_list|)
operator|>
name|S_GET_NUMBER_AUXILIARY
argument_list|(
name|normal
argument_list|)
condition|)
comment|/* Take the most we have.  */
name|S_SET_NUMBER_AUXILIARY
argument_list|(
name|normal
argument_list|,
name|S_GET_NUMBER_AUXILIARY
argument_list|(
name|debug
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|S_GET_NUMBER_AUXILIARY
argument_list|(
name|debug
argument_list|)
operator|>
literal|0
condition|)
comment|/* Move all the auxiliary information.  */
name|memcpy
argument_list|(
name|SYM_AUXINFO
argument_list|(
name|normal
argument_list|)
argument_list|,
name|SYM_AUXINFO
argument_list|(
name|debug
argument_list|)
argument_list|,
operator|(
name|S_GET_NUMBER_AUXILIARY
argument_list|(
name|debug
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|SYM_AUXINFO
argument_list|(
name|debug
argument_list|)
argument_list|)
operator|)
argument_list|)
expr_stmt|;
comment|/* Move the debug flags.  */
name|SF_SET_DEBUG_FIELD
argument_list|(
name|normal
argument_list|,
name|SF_GET_DEBUG_FIELD
argument_list|(
name|debug
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|c_dot_file_symbol
parameter_list|(
specifier|const
name|char
modifier|*
name|filename
parameter_list|,
name|int
name|appfile
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
comment|/* BFD converts filename to a .file symbol with an aux entry.  It      also handles chaining.  */
name|symbolP
operator|=
name|symbol_new
argument_list|(
name|filename
argument_list|,
name|bfd_abs_section_ptr
argument_list|,
literal|0
argument_list|,
operator|&
name|zero_address_frag
argument_list|)
expr_stmt|;
name|S_SET_STORAGE_CLASS
argument_list|(
name|symbolP
argument_list|,
name|C_FILE
argument_list|)
expr_stmt|;
name|S_SET_NUMBER_AUXILIARY
argument_list|(
name|symbolP
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|symbol_get_bfdsym
argument_list|(
name|symbolP
argument_list|)
operator|->
name|flags
operator|=
name|BSF_DEBUGGING
expr_stmt|;
ifndef|#
directive|ifndef
name|NO_LISTING
block|{
specifier|extern
name|int
name|listing
decl_stmt|;
if|if
condition|(
name|listing
condition|)
name|listing_source_file
argument_list|(
name|filename
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Make sure that the symbol is first on the symbol chain.  */
if|if
condition|(
name|symbol_rootP
operator|!=
name|symbolP
condition|)
block|{
name|symbol_remove
argument_list|(
name|symbolP
argument_list|,
operator|&
name|symbol_rootP
argument_list|,
operator|&
name|symbol_lastP
argument_list|)
expr_stmt|;
name|symbol_insert
argument_list|(
name|symbolP
argument_list|,
name|symbol_rootP
argument_list|,
operator|&
name|symbol_rootP
argument_list|,
operator|&
name|symbol_lastP
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Line number handling.  */
end_comment

begin_struct
struct|struct
name|line_no
block|{
name|struct
name|line_no
modifier|*
name|next
decl_stmt|;
name|fragS
modifier|*
name|frag
decl_stmt|;
name|alent
name|l
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|int
name|coff_line_base
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Symbol of last function, which we should hang line#s off of.  */
end_comment

begin_decl_stmt
specifier|static
name|symbolS
modifier|*
name|line_fsym
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|in_function
parameter_list|()
value|(line_fsym != 0)
end_define

begin_define
define|#
directive|define
name|clear_function
parameter_list|()
value|(line_fsym = 0)
end_define

begin_define
define|#
directive|define
name|set_function
parameter_list|(
name|F
parameter_list|)
value|(line_fsym = (F), coff_add_linesym (F))
end_define

begin_escape
end_escape

begin_function
name|void
name|coff_obj_symbol_new_hook
parameter_list|(
name|symbolS
modifier|*
name|symbolP
parameter_list|)
block|{
name|long
name|sz
init|=
operator|(
name|OBJ_COFF_MAX_AUXENTRIES
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|combined_entry_type
argument_list|)
decl_stmt|;
name|char
modifier|*
name|s
init|=
name|xmalloc
argument_list|(
name|sz
argument_list|)
decl_stmt|;
name|memset
argument_list|(
name|s
argument_list|,
literal|0
argument_list|,
name|sz
argument_list|)
expr_stmt|;
name|coffsymbol
argument_list|(
name|symbol_get_bfdsym
argument_list|(
name|symbolP
argument_list|)
argument_list|)
operator|->
name|native
operator|=
operator|(
name|combined_entry_type
operator|*
operator|)
name|s
expr_stmt|;
name|S_SET_DATA_TYPE
argument_list|(
name|symbolP
argument_list|,
name|T_NULL
argument_list|)
expr_stmt|;
name|S_SET_STORAGE_CLASS
argument_list|(
name|symbolP
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|S_SET_NUMBER_AUXILIARY
argument_list|(
name|symbolP
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|S_IS_STRING
argument_list|(
name|symbolP
argument_list|)
condition|)
name|SF_SET_STRING
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
if|if
condition|(
name|S_IS_LOCAL
argument_list|(
name|symbolP
argument_list|)
condition|)
name|SF_SET_LOCAL
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|coff_obj_symbol_clone_hook
parameter_list|(
name|symbolS
modifier|*
name|newsymP
parameter_list|,
name|symbolS
modifier|*
name|orgsymP
parameter_list|)
block|{
name|long
name|sz
init|=
operator|(
name|OBJ_COFF_MAX_AUXENTRIES
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|combined_entry_type
argument_list|)
decl_stmt|;
name|combined_entry_type
modifier|*
name|s
init|=
name|xmalloc
argument_list|(
name|sz
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
name|s
argument_list|,
name|coffsymbol
argument_list|(
name|symbol_get_bfdsym
argument_list|(
name|orgsymP
argument_list|)
argument_list|)
operator|->
name|native
argument_list|,
name|sz
argument_list|)
expr_stmt|;
name|coffsymbol
argument_list|(
name|symbol_get_bfdsym
argument_list|(
name|newsymP
argument_list|)
argument_list|)
operator|->
name|native
operator|=
name|s
expr_stmt|;
name|SF_SET
argument_list|(
name|newsymP
argument_list|,
name|SF_GET
argument_list|(
name|orgsymP
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Handle .ln directives.  */
end_comment

begin_decl_stmt
specifier|static
name|symbolS
modifier|*
name|current_lineno_sym
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|line_no
modifier|*
name|line_nos
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* FIXME:  Blindly assume all .ln directives will be in the .text section.  */
end_comment

begin_decl_stmt
name|int
name|coff_n_line_nos
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|add_lineno
parameter_list|(
name|fragS
modifier|*
name|frag
parameter_list|,
name|addressT
name|offset
parameter_list|,
name|int
name|num
parameter_list|)
block|{
name|struct
name|line_no
modifier|*
name|new_line
init|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|new_line
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|current_lineno_sym
condition|)
name|abort
argument_list|()
expr_stmt|;
ifndef|#
directive|ifndef
name|OBJ_XCOFF
comment|/* The native aix assembler accepts negative line number.  */
if|if
condition|(
name|num
operator|<=
literal|0
condition|)
block|{
comment|/* Zero is used as an end marker in the file.  */
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"Line numbers must be positive integers\n"
argument_list|)
argument_list|)
expr_stmt|;
name|num
operator|=
literal|1
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* OBJ_XCOFF */
name|new_line
operator|->
name|next
operator|=
name|line_nos
expr_stmt|;
name|new_line
operator|->
name|frag
operator|=
name|frag
expr_stmt|;
name|new_line
operator|->
name|l
operator|.
name|line_number
operator|=
name|num
expr_stmt|;
name|new_line
operator|->
name|l
operator|.
name|u
operator|.
name|offset
operator|=
name|offset
expr_stmt|;
name|line_nos
operator|=
name|new_line
expr_stmt|;
name|coff_n_line_nos
operator|++
expr_stmt|;
block|}
end_function

begin_function
name|void
name|coff_add_linesym
parameter_list|(
name|symbolS
modifier|*
name|sym
parameter_list|)
block|{
if|if
condition|(
name|line_nos
condition|)
block|{
name|coffsymbol
argument_list|(
name|symbol_get_bfdsym
argument_list|(
name|current_lineno_sym
argument_list|)
argument_list|)
operator|->
name|lineno
operator|=
operator|(
name|alent
operator|*
operator|)
name|line_nos
expr_stmt|;
name|coff_n_line_nos
operator|++
expr_stmt|;
name|line_nos
operator|=
literal|0
expr_stmt|;
block|}
name|current_lineno_sym
operator|=
name|sym
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|obj_coff_ln
parameter_list|(
name|int
name|appline
parameter_list|)
block|{
name|int
name|l
decl_stmt|;
if|if
condition|(
operator|!
name|appline
operator|&&
name|def_symbol_in_progress
operator|!=
name|NULL
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|".ln pseudo-op inside .def/.endef: ignored."
argument_list|)
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
name|l
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
comment|/* If there is no lineno symbol, treat a .ln      directive as if it were a .appline directive.  */
if|if
condition|(
name|appline
operator|||
name|current_lineno_sym
operator|==
name|NULL
condition|)
name|new_logical_line
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|l
operator|-
literal|1
argument_list|)
expr_stmt|;
else|else
name|add_lineno
argument_list|(
name|frag_now
argument_list|,
name|frag_now_fix
argument_list|()
argument_list|,
name|l
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|NO_LISTING
block|{
specifier|extern
name|int
name|listing
decl_stmt|;
if|if
condition|(
name|listing
condition|)
block|{
if|if
condition|(
operator|!
name|appline
condition|)
name|l
operator|+=
name|coff_line_base
operator|-
literal|1
expr_stmt|;
name|listing_source_line
argument_list|(
name|l
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* .loc is essentially the same as .ln; parse it for assembler    compatibility.  */
end_comment

begin_function
specifier|static
name|void
name|obj_coff_loc
parameter_list|(
name|int
name|ignore
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|int
name|lineno
decl_stmt|;
comment|/* FIXME: Why do we need this check?  We need it for ECOFF, but why      do we need it for COFF?  */
if|if
condition|(
name|now_seg
operator|!=
name|text_section
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|".loc outside of .text"
argument_list|)
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|def_symbol_in_progress
operator|!=
name|NULL
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|".loc pseudo-op inside .def/.endef: ignored."
argument_list|)
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
comment|/* Skip the file number.  */
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
name|get_absolute_expression
argument_list|()
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
name|lineno
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
ifndef|#
directive|ifndef
name|NO_LISTING
block|{
specifier|extern
name|int
name|listing
decl_stmt|;
if|if
condition|(
name|listing
condition|)
block|{
name|lineno
operator|+=
name|coff_line_base
operator|-
literal|1
expr_stmt|;
name|listing_source_line
argument_list|(
name|lineno
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
name|add_lineno
argument_list|(
name|frag_now
argument_list|,
name|frag_now_fix
argument_list|()
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle the .ident pseudo-op.  */
end_comment

begin_function
specifier|static
name|void
name|obj_coff_ident
parameter_list|(
name|int
name|ignore
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|segT
name|current_seg
init|=
name|now_seg
decl_stmt|;
name|subsegT
name|current_subseg
init|=
name|now_subseg
decl_stmt|;
ifdef|#
directive|ifdef
name|TE_PE
block|{
name|segT
name|sec
decl_stmt|;
comment|/* We could put it in .comment, but that creates an extra section        that shouldn't be loaded into memory, which requires linker        changes...  For now, until proven otherwise, use .rdata.  */
name|sec
operator|=
name|subseg_new
argument_list|(
literal|".rdata$zzz"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bfd_set_section_flags
argument_list|(
name|stdoutput
argument_list|,
name|sec
argument_list|,
operator|(
operator|(
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_READONLY
operator||
name|SEC_DATA
operator|)
operator|&
name|bfd_applicable_section_flags
argument_list|(
name|stdoutput
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|subseg_new
argument_list|(
literal|".comment"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|stringer
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|subseg_set
argument_list|(
name|current_seg
argument_list|,
name|current_subseg
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle .def directives.     One might ask : why can't we symbol_new if the symbol does not    already exist and fill it with debug information.  Because of    the C_EFCN special symbol. It would clobber the value of the    function symbol before we have a chance to notice that it is    a C_EFCN. And a second reason is that the code is more clear this    way. (at least I think it is :-).  */
end_comment

begin_define
define|#
directive|define
name|SKIP_SEMI_COLON
parameter_list|()
value|while (*input_line_pointer++ != ';')
end_define

begin_define
define|#
directive|define
name|SKIP_WHITESPACES
parameter_list|()
value|while (*input_line_pointer == ' ' || \ 				       *input_line_pointer == '\t')  \                                   input_line_pointer++;
end_define

begin_function
specifier|static
name|void
name|obj_coff_def
parameter_list|(
name|int
name|what
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|char
name|name_end
decl_stmt|;
comment|/* Char after the end of name.  */
name|char
modifier|*
name|symbol_name
decl_stmt|;
comment|/* Name of the debug symbol.  */
name|char
modifier|*
name|symbol_name_copy
decl_stmt|;
comment|/* Temporary copy of the name.  */
name|unsigned
name|int
name|symbol_name_length
decl_stmt|;
if|if
condition|(
name|def_symbol_in_progress
operator|!=
name|NULL
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|".def pseudo-op used inside of .def/.endef: ignored."
argument_list|)
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
name|SKIP_WHITESPACES
argument_list|()
expr_stmt|;
name|symbol_name
operator|=
name|input_line_pointer
expr_stmt|;
name|name_end
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
name|symbol_name_length
operator|=
name|strlen
argument_list|(
name|symbol_name
argument_list|)
expr_stmt|;
name|symbol_name_copy
operator|=
name|xmalloc
argument_list|(
name|symbol_name_length
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|symbol_name_copy
argument_list|,
name|symbol_name
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|tc_canonicalize_symbol_name
name|symbol_name_copy
operator|=
name|tc_canonicalize_symbol_name
argument_list|(
name|symbol_name_copy
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Initialize the new symbol.  */
name|def_symbol_in_progress
operator|=
name|symbol_make
argument_list|(
name|symbol_name_copy
argument_list|)
expr_stmt|;
name|symbol_set_frag
argument_list|(
name|def_symbol_in_progress
argument_list|,
operator|&
name|zero_address_frag
argument_list|)
expr_stmt|;
name|S_SET_VALUE
argument_list|(
name|def_symbol_in_progress
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|S_IS_STRING
argument_list|(
name|def_symbol_in_progress
argument_list|)
condition|)
name|SF_SET_STRING
argument_list|(
name|def_symbol_in_progress
argument_list|)
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
name|name_end
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|unsigned
name|int
name|dim_index
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|obj_coff_endef
parameter_list|(
name|int
name|ignore
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|symbolS
modifier|*
name|symbolP
init|=
name|NULL
decl_stmt|;
name|dim_index
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|def_symbol_in_progress
operator|==
name|NULL
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|".endef pseudo-op used outside of .def/.endef: ignored."
argument_list|)
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
comment|/* Set the section number according to storage class.  */
switch|switch
condition|(
name|S_GET_STORAGE_CLASS
argument_list|(
name|def_symbol_in_progress
argument_list|)
condition|)
block|{
case|case
name|C_STRTAG
case|:
case|case
name|C_ENTAG
case|:
case|case
name|C_UNTAG
case|:
name|SF_SET_TAG
argument_list|(
name|def_symbol_in_progress
argument_list|)
expr_stmt|;
comment|/* Fall through.  */
case|case
name|C_FILE
case|:
case|case
name|C_TPDEF
case|:
name|SF_SET_DEBUG
argument_list|(
name|def_symbol_in_progress
argument_list|)
expr_stmt|;
name|S_SET_SEGMENT
argument_list|(
name|def_symbol_in_progress
argument_list|,
name|fetch_coff_debug_section
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|C_EFCN
case|:
name|SF_SET_LOCAL
argument_list|(
name|def_symbol_in_progress
argument_list|)
expr_stmt|;
comment|/* Do not emit this symbol.  */
comment|/* Fall through.  */
case|case
name|C_BLOCK
case|:
name|SF_SET_PROCESS
argument_list|(
name|def_symbol_in_progress
argument_list|)
expr_stmt|;
comment|/* Will need processing before writing.  */
comment|/* Fall through.  */
case|case
name|C_FCN
case|:
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|S_SET_SEGMENT
argument_list|(
name|def_symbol_in_progress
argument_list|,
name|text_section
argument_list|)
expr_stmt|;
name|name
operator|=
name|S_GET_NAME
argument_list|(
name|def_symbol_in_progress
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
name|name
index|[
literal|2
index|]
operator|==
literal|'f'
operator|&&
name|name
index|[
literal|3
index|]
operator|==
literal|'\0'
condition|)
block|{
switch|switch
condition|(
name|name
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|'b'
case|:
comment|/* .bf */
if|if
condition|(
operator|!
name|in_function
argument_list|()
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"`%s' symbol without preceding function"
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
comment|/* Will need relocating.  */
name|SF_SET_PROCESS
argument_list|(
name|def_symbol_in_progress
argument_list|)
expr_stmt|;
name|clear_function
argument_list|()
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|TE_PE
case|case
literal|'e'
case|:
comment|/* .ef */
comment|/* The MS compilers output the actual endline, not the 		   function-relative one... we want to match without 		   changing the assembler input.  */
name|SA_SET_SYM_LNNO
argument_list|(
name|def_symbol_in_progress
argument_list|,
operator|(
name|SA_GET_SYM_LNNO
argument_list|(
name|def_symbol_in_progress
argument_list|)
operator|+
name|coff_line_base
operator|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
block|}
block|}
block|}
break|break;
ifdef|#
directive|ifdef
name|C_AUTOARG
case|case
name|C_AUTOARG
case|:
endif|#
directive|endif
comment|/* C_AUTOARG */
case|case
name|C_AUTO
case|:
case|case
name|C_REG
case|:
case|case
name|C_ARG
case|:
case|case
name|C_REGPARM
case|:
case|case
name|C_FIELD
case|:
comment|/* According to the COFF documentation:         http://osr5doc.sco.com:1996/topics/COFF_SectNumFld.html         A special section number (-2) marks symbolic debugging symbols,        including structure/union/enumeration tag names, typedefs, and        the name of the file. A section number of -1 indicates that the        symbol has a value but is not relocatable. Examples of        absolute-valued symbols include automatic and register variables,        function arguments, and .eos symbols.         But from Ian Lance Taylor:         http://sources.redhat.com/ml/binutils/2000-08/msg00202.html         the actual tools all marked them as section -1. So the GNU COFF        assembler follows historical COFF assemblers.         However, it causes problems for djgpp         http://sources.redhat.com/ml/binutils/2000-08/msg00210.html         By defining STRICTCOFF, a COFF port can make the assembler to        follow the documented behavior.  */
ifdef|#
directive|ifdef
name|STRICTCOFF
case|case
name|C_MOS
case|:
case|case
name|C_MOE
case|:
case|case
name|C_MOU
case|:
case|case
name|C_EOS
case|:
endif|#
directive|endif
name|SF_SET_DEBUG
argument_list|(
name|def_symbol_in_progress
argument_list|)
expr_stmt|;
name|S_SET_SEGMENT
argument_list|(
name|def_symbol_in_progress
argument_list|,
name|absolute_section
argument_list|)
expr_stmt|;
break|break;
ifndef|#
directive|ifndef
name|STRICTCOFF
case|case
name|C_MOS
case|:
case|case
name|C_MOE
case|:
case|case
name|C_MOU
case|:
case|case
name|C_EOS
case|:
name|S_SET_SEGMENT
argument_list|(
name|def_symbol_in_progress
argument_list|,
name|absolute_section
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|C_EXT
case|:
case|case
name|C_WEAKEXT
case|:
ifdef|#
directive|ifdef
name|TE_PE
case|case
name|C_NT_WEAK
case|:
endif|#
directive|endif
case|case
name|C_STAT
case|:
case|case
name|C_LABEL
case|:
comment|/* Valid but set somewhere else (s_comm, s_lcomm, colon).  */
break|break;
default|default:
case|case
name|C_USTATIC
case|:
case|case
name|C_EXTDEF
case|:
case|case
name|C_ULABEL
case|:
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"unexpected storage class %d"
argument_list|)
argument_list|,
name|S_GET_STORAGE_CLASS
argument_list|(
name|def_symbol_in_progress
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Now that we have built a debug symbol, try to find if we should      merge with an existing symbol or not.  If a symbol is C_EFCN or      absolute_section or untagged SEG_DEBUG it never merges.  We also      don't merge labels, which are in a different namespace, nor      symbols which have not yet been defined since they are typically      unique, nor do we merge tags with non-tags.  */
comment|/* Two cases for functions.  Either debug followed by definition or      definition followed by debug.  For definition first, we will      merge the debug symbol into the definition.  For debug first, the      lineno entry MUST point to the definition function or else it      will point off into space when obj_crawl_symbol_chain() merges      the debug symbol into the real symbol.  Therefor, let's presume      the debug symbol is a real function reference.  */
comment|/* FIXME-SOON If for some reason the definition label/symbol is      never seen, this will probably leave an undefined symbol at link      time.  */
if|if
condition|(
name|S_GET_STORAGE_CLASS
argument_list|(
name|def_symbol_in_progress
argument_list|)
operator|==
name|C_EFCN
operator|||
name|S_GET_STORAGE_CLASS
argument_list|(
name|def_symbol_in_progress
argument_list|)
operator|==
name|C_LABEL
operator|||
operator|(
name|streq
argument_list|(
name|bfd_get_section_name
argument_list|(
name|stdoutput
argument_list|,
name|S_GET_SEGMENT
argument_list|(
name|def_symbol_in_progress
argument_list|)
argument_list|)
argument_list|,
literal|"*DEBUG*"
argument_list|)
operator|&&
operator|!
name|SF_GET_TAG
argument_list|(
name|def_symbol_in_progress
argument_list|)
operator|)
operator|||
name|S_GET_SEGMENT
argument_list|(
name|def_symbol_in_progress
argument_list|)
operator|==
name|absolute_section
operator|||
operator|!
name|symbol_constant_p
argument_list|(
name|def_symbol_in_progress
argument_list|)
operator|||
operator|(
name|symbolP
operator|=
name|symbol_find
argument_list|(
name|S_GET_NAME
argument_list|(
name|def_symbol_in_progress
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
operator|||
name|SF_GET_TAG
argument_list|(
name|def_symbol_in_progress
argument_list|)
operator|!=
name|SF_GET_TAG
argument_list|(
name|symbolP
argument_list|)
condition|)
block|{
comment|/* If it already is at the end of the symbol list, do nothing */
if|if
condition|(
name|def_symbol_in_progress
operator|!=
name|symbol_lastP
condition|)
block|{
name|symbol_remove
argument_list|(
name|def_symbol_in_progress
argument_list|,
operator|&
name|symbol_rootP
argument_list|,
operator|&
name|symbol_lastP
argument_list|)
expr_stmt|;
name|symbol_append
argument_list|(
name|def_symbol_in_progress
argument_list|,
name|symbol_lastP
argument_list|,
operator|&
name|symbol_rootP
argument_list|,
operator|&
name|symbol_lastP
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* This symbol already exists, merge the newly created symbol 	 into the old one.  This is not mandatory. The linker can 	 handle duplicate symbols correctly. But I guess that it save 	 a *lot* of space if the assembly file defines a lot of 	 symbols. [loic]  */
comment|/* The debug entry (def_symbol_in_progress) is merged into the 	 previous definition.  */
name|c_symbol_merge
argument_list|(
name|def_symbol_in_progress
argument_list|,
name|symbolP
argument_list|)
expr_stmt|;
name|symbol_remove
argument_list|(
name|def_symbol_in_progress
argument_list|,
operator|&
name|symbol_rootP
argument_list|,
operator|&
name|symbol_lastP
argument_list|)
expr_stmt|;
name|def_symbol_in_progress
operator|=
name|symbolP
expr_stmt|;
if|if
condition|(
name|SF_GET_FUNCTION
argument_list|(
name|def_symbol_in_progress
argument_list|)
operator|||
name|SF_GET_TAG
argument_list|(
name|def_symbol_in_progress
argument_list|)
operator|||
name|S_GET_STORAGE_CLASS
argument_list|(
name|def_symbol_in_progress
argument_list|)
operator|==
name|C_STAT
condition|)
block|{
comment|/* For functions, and tags, and static symbols, the symbol 	     *must* be where the debug symbol appears.  Move the 	     existing symbol to the current place.  */
comment|/* If it already is at the end of the symbol list, do nothing.  */
if|if
condition|(
name|def_symbol_in_progress
operator|!=
name|symbol_lastP
condition|)
block|{
name|symbol_remove
argument_list|(
name|def_symbol_in_progress
argument_list|,
operator|&
name|symbol_rootP
argument_list|,
operator|&
name|symbol_lastP
argument_list|)
expr_stmt|;
name|symbol_append
argument_list|(
name|def_symbol_in_progress
argument_list|,
name|symbol_lastP
argument_list|,
operator|&
name|symbol_rootP
argument_list|,
operator|&
name|symbol_lastP
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|SF_GET_TAG
argument_list|(
name|def_symbol_in_progress
argument_list|)
condition|)
block|{
name|symbolS
modifier|*
name|oldtag
decl_stmt|;
name|oldtag
operator|=
name|symbol_find
argument_list|(
name|S_GET_NAME
argument_list|(
name|def_symbol_in_progress
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldtag
operator|==
name|NULL
operator|||
operator|!
name|SF_GET_TAG
argument_list|(
name|oldtag
argument_list|)
condition|)
name|tag_insert
argument_list|(
name|S_GET_NAME
argument_list|(
name|def_symbol_in_progress
argument_list|)
argument_list|,
name|def_symbol_in_progress
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|SF_GET_FUNCTION
argument_list|(
name|def_symbol_in_progress
argument_list|)
condition|)
block|{
name|know
argument_list|(
sizeof|sizeof
argument_list|(
name|def_symbol_in_progress
argument_list|)
operator|<=
sizeof|sizeof
argument_list|(
name|long
argument_list|)
argument_list|)
expr_stmt|;
name|set_function
argument_list|(
name|def_symbol_in_progress
argument_list|)
expr_stmt|;
name|SF_SET_PROCESS
argument_list|(
name|def_symbol_in_progress
argument_list|)
expr_stmt|;
if|if
condition|(
name|symbolP
operator|==
name|NULL
condition|)
comment|/* That is, if this is the first time we've seen the 	   function.  */
name|symbol_table_insert
argument_list|(
name|def_symbol_in_progress
argument_list|)
expr_stmt|;
block|}
name|def_symbol_in_progress
operator|=
name|NULL
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|obj_coff_dim
parameter_list|(
name|int
name|ignore
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|int
name|dim_index
decl_stmt|;
if|if
condition|(
name|def_symbol_in_progress
operator|==
name|NULL
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|".dim pseudo-op used outside of .def/.endef: ignored."
argument_list|)
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
name|S_SET_NUMBER_AUXILIARY
argument_list|(
name|def_symbol_in_progress
argument_list|,
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|dim_index
operator|=
literal|0
init|;
name|dim_index
operator|<
name|DIMNUM
condition|;
name|dim_index
operator|++
control|)
block|{
name|SKIP_WHITESPACES
argument_list|()
expr_stmt|;
name|SA_SET_SYM_DIMEN
argument_list|(
name|def_symbol_in_progress
argument_list|,
name|dim_index
argument_list|,
name|get_absolute_expression
argument_list|()
argument_list|)
expr_stmt|;
switch|switch
condition|(
operator|*
name|input_line_pointer
condition|)
block|{
case|case
literal|','
case|:
name|input_line_pointer
operator|++
expr_stmt|;
break|break;
default|default:
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"badly formed .dim directive ignored"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Fall through.  */
case|case
literal|'\n'
case|:
case|case
literal|';'
case|:
name|dim_index
operator|=
name|DIMNUM
expr_stmt|;
break|break;
block|}
block|}
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|obj_coff_line
parameter_list|(
name|int
name|ignore
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|int
name|this_base
decl_stmt|;
if|if
condition|(
name|def_symbol_in_progress
operator|==
name|NULL
condition|)
block|{
comment|/* Probably stabs-style line?  */
name|obj_coff_ln
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
name|this_base
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
if|if
condition|(
name|streq
argument_list|(
literal|".bf"
argument_list|,
name|S_GET_NAME
argument_list|(
name|def_symbol_in_progress
argument_list|)
argument_list|)
condition|)
name|coff_line_base
operator|=
name|this_base
expr_stmt|;
name|S_SET_NUMBER_AUXILIARY
argument_list|(
name|def_symbol_in_progress
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SA_SET_SYM_LNNO
argument_list|(
name|def_symbol_in_progress
argument_list|,
name|this_base
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
ifndef|#
directive|ifndef
name|NO_LISTING
if|if
condition|(
name|streq
argument_list|(
literal|".bf"
argument_list|,
name|S_GET_NAME
argument_list|(
name|def_symbol_in_progress
argument_list|)
argument_list|)
condition|)
block|{
specifier|extern
name|int
name|listing
decl_stmt|;
if|if
condition|(
name|listing
condition|)
name|listing_source_line
argument_list|(
operator|(
name|unsigned
name|int
operator|)
name|this_base
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|obj_coff_size
parameter_list|(
name|int
name|ignore
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
if|if
condition|(
name|def_symbol_in_progress
operator|==
name|NULL
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|".size pseudo-op used outside of .def/.endef ignored."
argument_list|)
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
name|S_SET_NUMBER_AUXILIARY
argument_list|(
name|def_symbol_in_progress
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SA_SET_SYM_SIZE
argument_list|(
name|def_symbol_in_progress
argument_list|,
name|get_absolute_expression
argument_list|()
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|obj_coff_scl
parameter_list|(
name|int
name|ignore
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
if|if
condition|(
name|def_symbol_in_progress
operator|==
name|NULL
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|".scl pseudo-op used outside of .def/.endef ignored."
argument_list|)
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
name|S_SET_STORAGE_CLASS
argument_list|(
name|def_symbol_in_progress
argument_list|,
name|get_absolute_expression
argument_list|()
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|obj_coff_tag
parameter_list|(
name|int
name|ignore
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|char
modifier|*
name|symbol_name
decl_stmt|;
name|char
name|name_end
decl_stmt|;
if|if
condition|(
name|def_symbol_in_progress
operator|==
name|NULL
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|".tag pseudo-op used outside of .def/.endef ignored."
argument_list|)
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
name|S_SET_NUMBER_AUXILIARY
argument_list|(
name|def_symbol_in_progress
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|symbol_name
operator|=
name|input_line_pointer
expr_stmt|;
name|name_end
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|tc_canonicalize_symbol_name
name|symbol_name
operator|=
name|tc_canonicalize_symbol_name
argument_list|(
name|symbol_name
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Assume that the symbol referred to by .tag is always defined.      This was a bad assumption.  I've added find_or_make. xoxorich.  */
name|SA_SET_SYM_TAGNDX
argument_list|(
name|def_symbol_in_progress
argument_list|,
name|tag_find_or_make
argument_list|(
name|symbol_name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|SA_GET_SYM_TAGNDX
argument_list|(
name|def_symbol_in_progress
argument_list|)
operator|==
literal|0L
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"tag not found for .tag %s"
argument_list|)
argument_list|,
name|symbol_name
argument_list|)
expr_stmt|;
name|SF_SET_TAGGED
argument_list|(
name|def_symbol_in_progress
argument_list|)
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
name|name_end
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|obj_coff_type
parameter_list|(
name|int
name|ignore
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
if|if
condition|(
name|def_symbol_in_progress
operator|==
name|NULL
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|".type pseudo-op used outside of .def/.endef ignored."
argument_list|)
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
name|S_SET_DATA_TYPE
argument_list|(
name|def_symbol_in_progress
argument_list|,
name|get_absolute_expression
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|ISFCN
argument_list|(
name|S_GET_DATA_TYPE
argument_list|(
name|def_symbol_in_progress
argument_list|)
argument_list|)
operator|&&
name|S_GET_STORAGE_CLASS
argument_list|(
name|def_symbol_in_progress
argument_list|)
operator|!=
name|C_TPDEF
condition|)
name|SF_SET_FUNCTION
argument_list|(
name|def_symbol_in_progress
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|obj_coff_val
parameter_list|(
name|int
name|ignore
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
if|if
condition|(
name|def_symbol_in_progress
operator|==
name|NULL
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|".val pseudo-op used outside of .def/.endef ignored."
argument_list|)
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|is_name_beginner
argument_list|(
operator|*
name|input_line_pointer
argument_list|)
condition|)
block|{
name|char
modifier|*
name|symbol_name
init|=
name|input_line_pointer
decl_stmt|;
name|char
name|name_end
init|=
name|get_symbol_end
argument_list|()
decl_stmt|;
ifdef|#
directive|ifdef
name|tc_canonicalize_symbol_name
name|symbol_name
operator|=
name|tc_canonicalize_symbol_name
argument_list|(
name|symbol_name
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|streq
argument_list|(
name|symbol_name
argument_list|,
literal|"."
argument_list|)
condition|)
block|{
comment|/* If the .val is != from the .def (e.g. statics).  */
name|symbol_set_frag
argument_list|(
name|def_symbol_in_progress
argument_list|,
name|frag_now
argument_list|)
expr_stmt|;
name|S_SET_VALUE
argument_list|(
name|def_symbol_in_progress
argument_list|,
operator|(
name|valueT
operator|)
name|frag_now_fix
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|streq
argument_list|(
name|S_GET_NAME
argument_list|(
name|def_symbol_in_progress
argument_list|)
argument_list|,
name|symbol_name
argument_list|)
condition|)
block|{
name|expressionS
name|exp
decl_stmt|;
name|exp
operator|.
name|X_op
operator|=
name|O_symbol
expr_stmt|;
name|exp
operator|.
name|X_add_symbol
operator|=
name|symbol_find_or_make
argument_list|(
name|symbol_name
argument_list|)
expr_stmt|;
name|exp
operator|.
name|X_op_symbol
operator|=
name|NULL
expr_stmt|;
name|exp
operator|.
name|X_add_number
operator|=
literal|0
expr_stmt|;
name|symbol_set_value_expression
argument_list|(
name|def_symbol_in_progress
argument_list|,
operator|&
name|exp
argument_list|)
expr_stmt|;
comment|/* If the segment is undefined when the forward reference is 	     resolved, then copy the segment id from the forward 	     symbol.  */
name|SF_SET_GET_SEGMENT
argument_list|(
name|def_symbol_in_progress
argument_list|)
expr_stmt|;
comment|/* FIXME: gcc can generate address expressions here in 	     unusual cases (search for "obscure" in sdbout.c).  We 	     just ignore the offset here, thus generating incorrect 	     debugging information.  We ignore the rest of the line 	     just below.  */
block|}
comment|/* Otherwise, it is the name of a non debug symbol and its value          will be calculated later.  */
operator|*
name|input_line_pointer
operator|=
name|name_end
expr_stmt|;
block|}
else|else
block|{
name|S_SET_VALUE
argument_list|(
name|def_symbol_in_progress
argument_list|,
name|get_absolute_expression
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|TE_PE
end_ifdef

begin_comment
comment|/* Return nonzero if name begins with weak alternate symbol prefix.  */
end_comment

begin_function
specifier|static
name|int
name|weak_is_altname
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
return|return
name|strneq
argument_list|(
name|name
argument_list|,
name|weak_altprefix
argument_list|,
sizeof|sizeof
argument_list|(
name|weak_altprefix
argument_list|)
operator|-
literal|1
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return the name of the alternate symbol    name corresponding to a weak symbol's name.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|weak_name2altname
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|char
modifier|*
name|alt_name
decl_stmt|;
name|alt_name
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|weak_altprefix
argument_list|)
operator|+
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|alt_name
argument_list|,
name|weak_altprefix
argument_list|)
expr_stmt|;
return|return
name|strcat
argument_list|(
name|alt_name
argument_list|,
name|name
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return the name of the weak symbol corresponding to an    alternate symbol.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|weak_altname2name
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|char
modifier|*
name|weak_name
decl_stmt|;
name|char
modifier|*
name|dot
decl_stmt|;
name|assert
argument_list|(
name|weak_is_altname
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|weak_name
operator|=
name|xstrdup
argument_list|(
name|name
operator|+
literal|6
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|dot
operator|=
name|strchr
argument_list|(
name|weak_name
argument_list|,
literal|'.'
argument_list|)
operator|)
condition|)
operator|*
name|dot
operator|=
literal|0
expr_stmt|;
return|return
name|weak_name
return|;
block|}
end_function

begin_comment
comment|/* Make a weak symbol name unique by    appending the name of an external symbol.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|weak_uniquify
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|char
modifier|*
name|ret
decl_stmt|;
specifier|const
name|char
modifier|*
name|unique
init|=
literal|""
decl_stmt|;
ifdef|#
directive|ifdef
name|USE_UNIQUE
if|if
condition|(
name|an_external_name
operator|!=
name|NULL
condition|)
name|unique
operator|=
name|an_external_name
expr_stmt|;
endif|#
directive|endif
name|assert
argument_list|(
name|weak_is_altname
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|strchr
argument_list|(
name|name
operator|+
sizeof|sizeof
argument_list|(
name|weak_altprefix
argument_list|)
argument_list|,
literal|'.'
argument_list|)
condition|)
return|return
name|name
return|;
name|ret
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
name|strlen
argument_list|(
name|unique
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|ret
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|ret
argument_list|,
literal|"."
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|ret
argument_list|,
name|unique
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|void
name|pecoff_obj_set_weak_hook
parameter_list|(
name|symbolS
modifier|*
name|symbolP
parameter_list|)
block|{
name|symbolS
modifier|*
name|alternateP
decl_stmt|;
comment|/* See _Microsoft Portable Executable and Common Object      File Format Specification_, section 5.5.3.      Create a symbol representing the alternate value.      coff_frob_symbol will set the value of this symbol from      the value of the weak symbol itself.  */
name|S_SET_STORAGE_CLASS
argument_list|(
name|symbolP
argument_list|,
name|C_NT_WEAK
argument_list|)
expr_stmt|;
name|S_SET_NUMBER_AUXILIARY
argument_list|(
name|symbolP
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SA_SET_SYM_FSIZE
argument_list|(
name|symbolP
argument_list|,
name|IMAGE_WEAK_EXTERN_SEARCH_NOLIBRARY
argument_list|)
expr_stmt|;
name|alternateP
operator|=
name|symbol_find_or_make
argument_list|(
name|weak_name2altname
argument_list|(
name|S_GET_NAME
argument_list|(
name|symbolP
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|S_SET_EXTERNAL
argument_list|(
name|alternateP
argument_list|)
expr_stmt|;
name|S_SET_STORAGE_CLASS
argument_list|(
name|alternateP
argument_list|,
name|C_NT_WEAK
argument_list|)
expr_stmt|;
name|SA_SET_SYM_TAGNDX
argument_list|(
name|symbolP
argument_list|,
name|alternateP
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pecoff_obj_clear_weak_hook
parameter_list|(
name|symbolS
modifier|*
name|symbolP
parameter_list|)
block|{
name|symbolS
modifier|*
name|alternateP
decl_stmt|;
name|S_SET_STORAGE_CLASS
argument_list|(
name|symbolP
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|SA_SET_SYM_FSIZE
argument_list|(
name|symbolP
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|alternateP
operator|=
name|symbol_find
argument_list|(
name|weak_name2altname
argument_list|(
name|S_GET_NAME
argument_list|(
name|symbolP
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|S_CLEAR_EXTERNAL
argument_list|(
name|alternateP
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* TE_PE */
end_comment

begin_comment
comment|/* Handle .weak.  This is a GNU extension in formats other than PE. */
end_comment

begin_function
specifier|static
name|void
name|obj_coff_weak
parameter_list|(
name|int
name|ignore
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|c
decl_stmt|;
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
do|do
block|{
name|name
operator|=
name|input_line_pointer
expr_stmt|;
name|c
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|name
operator|==
literal|0
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"badly formed .weak directive ignored"
argument_list|)
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
name|c
operator|=
literal|0
expr_stmt|;
name|symbolP
operator|=
name|symbol_find_or_make
argument_list|(
name|name
argument_list|)
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
name|S_SET_WEAK
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|','
condition|)
block|{
name|input_line_pointer
operator|++
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|'\n'
condition|)
name|c
operator|=
literal|'\n'
expr_stmt|;
block|}
block|}
do|while
condition|(
name|c
operator|==
literal|','
condition|)
do|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|coff_obj_read_begin_hook
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* These had better be the same.  Usually 18 bytes.  */
name|know
argument_list|(
sizeof|sizeof
argument_list|(
name|SYMENT
argument_list|)
operator|==
sizeof|sizeof
argument_list|(
name|AUXENT
argument_list|)
argument_list|)
expr_stmt|;
name|know
argument_list|(
name|SYMESZ
operator|==
name|AUXESZ
argument_list|)
expr_stmt|;
name|tag_init
argument_list|()
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|symbolS
modifier|*
name|coff_last_function
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|OBJ_XCOFF
end_ifndef

begin_decl_stmt
specifier|static
name|symbolS
modifier|*
name|coff_last_bf
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|coff_frob_symbol
parameter_list|(
name|symbolS
modifier|*
name|symp
parameter_list|,
name|int
modifier|*
name|punt
parameter_list|)
block|{
specifier|static
name|symbolS
modifier|*
name|last_tagP
decl_stmt|;
specifier|static
name|stack
modifier|*
name|block_stack
decl_stmt|;
specifier|static
name|symbolS
modifier|*
name|set_end
decl_stmt|;
name|symbolS
modifier|*
name|next_set_end
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|symp
operator|==
operator|&
name|abs_symbol
condition|)
block|{
operator|*
name|punt
operator|=
literal|1
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|current_lineno_sym
condition|)
name|coff_add_linesym
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|block_stack
condition|)
name|block_stack
operator|=
name|stack_init
argument_list|(
literal|512
argument_list|,
sizeof|sizeof
argument_list|(
name|symbolS
operator|*
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TE_PE
if|if
condition|(
name|S_GET_STORAGE_CLASS
argument_list|(
name|symp
argument_list|)
operator|==
name|C_NT_WEAK
operator|&&
operator|!
name|S_IS_WEAK
argument_list|(
name|symp
argument_list|)
operator|&&
name|weak_is_altname
argument_list|(
name|S_GET_NAME
argument_list|(
name|symp
argument_list|)
argument_list|)
condition|)
block|{
comment|/* This is a weak alternate symbol.  All processing of 	 PECOFFweak symbols is done here, through the alternate.  */
name|symbolS
modifier|*
name|weakp
init|=
name|symbol_find_noref
argument_list|(
name|weak_altname2name
argument_list|(
name|S_GET_NAME
argument_list|(
name|symp
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|weakp
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|S_GET_NUMBER_AUXILIARY
argument_list|(
name|weakp
argument_list|)
operator|==
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|S_IS_WEAK
argument_list|(
name|weakp
argument_list|)
condition|)
block|{
comment|/* The symbol was turned from weak to strong.  Discard altname.  */
operator|*
name|punt
operator|=
literal|1
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|symbol_equated_p
argument_list|(
name|weakp
argument_list|)
condition|)
block|{
comment|/* The weak symbol has an alternate specified; symp is unneeded.  */
name|S_SET_STORAGE_CLASS
argument_list|(
name|weakp
argument_list|,
name|C_NT_WEAK
argument_list|)
expr_stmt|;
name|SA_SET_SYM_TAGNDX
argument_list|(
name|weakp
argument_list|,
name|symbol_get_value_expression
argument_list|(
name|weakp
argument_list|)
operator|->
name|X_add_symbol
argument_list|)
expr_stmt|;
name|S_CLEAR_EXTERNAL
argument_list|(
name|symp
argument_list|)
expr_stmt|;
operator|*
name|punt
operator|=
literal|1
expr_stmt|;
return|return;
block|}
else|else
block|{
comment|/* The weak symbol has been assigned an alternate value.              Copy this value to symp, and set symp as weakp's alternate.  */
if|if
condition|(
name|S_GET_STORAGE_CLASS
argument_list|(
name|weakp
argument_list|)
operator|!=
name|C_NT_WEAK
condition|)
block|{
name|S_SET_STORAGE_CLASS
argument_list|(
name|symp
argument_list|,
name|S_GET_STORAGE_CLASS
argument_list|(
name|weakp
argument_list|)
argument_list|)
expr_stmt|;
name|S_SET_STORAGE_CLASS
argument_list|(
name|weakp
argument_list|,
name|C_NT_WEAK
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|S_IS_DEFINED
argument_list|(
name|weakp
argument_list|)
condition|)
block|{
comment|/* This is a defined weak symbol.  Copy value information 	         from the weak symbol itself to the alternate symbol.  */
name|symbol_set_value_expression
argument_list|(
name|symp
argument_list|,
name|symbol_get_value_expression
argument_list|(
name|weakp
argument_list|)
argument_list|)
expr_stmt|;
name|symbol_set_frag
argument_list|(
name|symp
argument_list|,
name|symbol_get_frag
argument_list|(
name|weakp
argument_list|)
argument_list|)
expr_stmt|;
name|S_SET_SEGMENT
argument_list|(
name|symp
argument_list|,
name|S_GET_SEGMENT
argument_list|(
name|weakp
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* This is an undefined weak symbol. 		 Define the alternate symbol to zero.  */
name|S_SET_VALUE
argument_list|(
name|symp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|S_SET_SEGMENT
argument_list|(
name|symp
argument_list|,
name|absolute_section
argument_list|)
expr_stmt|;
block|}
name|S_SET_NAME
argument_list|(
name|symp
argument_list|,
name|weak_uniquify
argument_list|(
name|S_GET_NAME
argument_list|(
name|symp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|S_SET_STORAGE_CLASS
argument_list|(
name|symp
argument_list|,
name|C_EXT
argument_list|)
expr_stmt|;
name|S_SET_VALUE
argument_list|(
name|weakp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|S_SET_SEGMENT
argument_list|(
name|weakp
argument_list|,
name|undefined_section
argument_list|)
expr_stmt|;
block|}
block|}
else|#
directive|else
comment|/* TE_PE */
if|if
condition|(
name|S_IS_WEAK
argument_list|(
name|symp
argument_list|)
condition|)
name|S_SET_STORAGE_CLASS
argument_list|(
name|symp
argument_list|,
name|C_WEAKEXT
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* TE_PE */
if|if
condition|(
operator|!
name|S_IS_DEFINED
argument_list|(
name|symp
argument_list|)
operator|&&
operator|!
name|S_IS_WEAK
argument_list|(
name|symp
argument_list|)
operator|&&
name|S_GET_STORAGE_CLASS
argument_list|(
name|symp
argument_list|)
operator|!=
name|C_STAT
condition|)
name|S_SET_STORAGE_CLASS
argument_list|(
name|symp
argument_list|,
name|C_EXT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|SF_GET_DEBUG
argument_list|(
name|symp
argument_list|)
condition|)
block|{
name|symbolS
modifier|*
name|real
decl_stmt|;
if|if
condition|(
operator|!
name|SF_GET_LOCAL
argument_list|(
name|symp
argument_list|)
operator|&&
operator|!
name|SF_GET_STATICS
argument_list|(
name|symp
argument_list|)
operator|&&
name|S_GET_STORAGE_CLASS
argument_list|(
name|symp
argument_list|)
operator|!=
name|C_LABEL
operator|&&
name|symbol_constant_p
argument_list|(
name|symp
argument_list|)
operator|&&
operator|(
name|real
operator|=
name|symbol_find_noref
argument_list|(
name|S_GET_NAME
argument_list|(
name|symp
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|)
operator|&&
name|S_GET_STORAGE_CLASS
argument_list|(
name|real
argument_list|)
operator|==
name|C_NULL
operator|&&
name|real
operator|!=
name|symp
condition|)
block|{
name|c_symbol_merge
argument_list|(
name|symp
argument_list|,
name|real
argument_list|)
expr_stmt|;
operator|*
name|punt
operator|=
literal|1
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|S_IS_DEFINED
argument_list|(
name|symp
argument_list|)
operator|&&
operator|!
name|SF_GET_LOCAL
argument_list|(
name|symp
argument_list|)
condition|)
block|{
name|assert
argument_list|(
name|S_GET_VALUE
argument_list|(
name|symp
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|S_IS_WEAKREFD
argument_list|(
name|symp
argument_list|)
condition|)
operator|*
name|punt
operator|=
literal|1
expr_stmt|;
else|else
name|S_SET_EXTERNAL
argument_list|(
name|symp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|S_GET_STORAGE_CLASS
argument_list|(
name|symp
argument_list|)
operator|==
name|C_NULL
condition|)
block|{
if|if
condition|(
name|S_GET_SEGMENT
argument_list|(
name|symp
argument_list|)
operator|==
name|text_section
operator|&&
name|symp
operator|!=
name|seg_info
argument_list|(
name|text_section
argument_list|)
operator|->
name|sym
condition|)
name|S_SET_STORAGE_CLASS
argument_list|(
name|symp
argument_list|,
name|C_LABEL
argument_list|)
expr_stmt|;
else|else
name|S_SET_STORAGE_CLASS
argument_list|(
name|symp
argument_list|,
name|C_STAT
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|SF_GET_PROCESS
argument_list|(
name|symp
argument_list|)
condition|)
block|{
if|if
condition|(
name|S_GET_STORAGE_CLASS
argument_list|(
name|symp
argument_list|)
operator|==
name|C_BLOCK
condition|)
block|{
if|if
condition|(
name|streq
argument_list|(
name|S_GET_NAME
argument_list|(
name|symp
argument_list|)
argument_list|,
literal|".bb"
argument_list|)
condition|)
name|stack_push
argument_list|(
name|block_stack
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|symp
argument_list|)
expr_stmt|;
else|else
block|{
name|symbolS
modifier|*
name|begin
decl_stmt|;
name|begin
operator|=
operator|*
operator|(
name|symbolS
operator|*
operator|*
operator|)
name|stack_pop
argument_list|(
name|block_stack
argument_list|)
expr_stmt|;
if|if
condition|(
name|begin
operator|==
literal|0
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"mismatched .eb"
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|next_set_end
operator|=
name|begin
expr_stmt|;
block|}
block|}
if|if
condition|(
name|coff_last_function
operator|==
literal|0
operator|&&
name|SF_GET_FUNCTION
argument_list|(
name|symp
argument_list|)
condition|)
block|{
name|union
name|internal_auxent
modifier|*
name|auxp
decl_stmt|;
name|coff_last_function
operator|=
name|symp
expr_stmt|;
if|if
condition|(
name|S_GET_NUMBER_AUXILIARY
argument_list|(
name|symp
argument_list|)
operator|<
literal|1
condition|)
name|S_SET_NUMBER_AUXILIARY
argument_list|(
name|symp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|auxp
operator|=
name|SYM_AUXENT
argument_list|(
name|symp
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|auxp
operator|->
name|x_sym
operator|.
name|x_fcnary
operator|.
name|x_ary
operator|.
name|x_dimen
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|auxp
operator|->
name|x_sym
operator|.
name|x_fcnary
operator|.
name|x_ary
operator|.
name|x_dimen
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|S_GET_STORAGE_CLASS
argument_list|(
name|symp
argument_list|)
operator|==
name|C_EFCN
condition|)
block|{
if|if
condition|(
name|coff_last_function
operator|==
literal|0
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"C_EFCN symbol for %s out of scope"
argument_list|)
argument_list|,
name|S_GET_NAME
argument_list|(
name|symp
argument_list|)
argument_list|)
expr_stmt|;
name|SA_SET_SYM_FSIZE
argument_list|(
name|coff_last_function
argument_list|,
call|(
name|long
call|)
argument_list|(
name|S_GET_VALUE
argument_list|(
name|symp
argument_list|)
operator|-
name|S_GET_VALUE
argument_list|(
name|coff_last_function
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|next_set_end
operator|=
name|coff_last_function
expr_stmt|;
name|coff_last_function
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|S_IS_EXTERNAL
argument_list|(
name|symp
argument_list|)
condition|)
name|S_SET_STORAGE_CLASS
argument_list|(
name|symp
argument_list|,
name|C_EXT
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|SF_GET_LOCAL
argument_list|(
name|symp
argument_list|)
condition|)
operator|*
name|punt
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|SF_GET_FUNCTION
argument_list|(
name|symp
argument_list|)
condition|)
name|symbol_get_bfdsym
argument_list|(
name|symp
argument_list|)
operator|->
name|flags
operator||=
name|BSF_FUNCTION
expr_stmt|;
block|}
comment|/* Double check weak symbols.  */
if|if
condition|(
name|S_IS_WEAK
argument_list|(
name|symp
argument_list|)
operator|&&
name|S_IS_COMMON
argument_list|(
name|symp
argument_list|)
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Symbol `%s' can not be both weak and common"
argument_list|)
argument_list|,
name|S_GET_NAME
argument_list|(
name|symp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|SF_GET_TAG
argument_list|(
name|symp
argument_list|)
condition|)
name|last_tagP
operator|=
name|symp
expr_stmt|;
elseif|else
if|if
condition|(
name|S_GET_STORAGE_CLASS
argument_list|(
name|symp
argument_list|)
operator|==
name|C_EOS
condition|)
name|next_set_end
operator|=
name|last_tagP
expr_stmt|;
ifdef|#
directive|ifdef
name|OBJ_XCOFF
comment|/* This is pretty horrible, but we have to set *punt correctly in      order to call SA_SET_SYM_ENDNDX correctly.  */
if|if
condition|(
operator|!
name|symbol_used_in_reloc_p
argument_list|(
name|symp
argument_list|)
operator|&&
operator|(
operator|(
name|symbol_get_bfdsym
argument_list|(
name|symp
argument_list|)
operator|->
name|flags
operator|&
name|BSF_SECTION_SYM
operator|)
operator|!=
literal|0
operator|||
operator|(
operator|!
operator|(
name|S_IS_EXTERNAL
argument_list|(
name|symp
argument_list|)
operator|||
name|S_IS_WEAK
argument_list|(
name|symp
argument_list|)
operator|)
operator|&&
operator|!
name|symbol_get_tc
argument_list|(
name|symp
argument_list|)
operator|->
name|output
operator|&&
name|S_GET_STORAGE_CLASS
argument_list|(
name|symp
argument_list|)
operator|!=
name|C_FILE
operator|)
operator|)
condition|)
operator|*
name|punt
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|set_end
operator|!=
operator|(
name|symbolS
operator|*
operator|)
name|NULL
operator|&&
operator|!
operator|*
name|punt
operator|&&
operator|(
operator|(
name|symbol_get_bfdsym
argument_list|(
name|symp
argument_list|)
operator|->
name|flags
operator|&
name|BSF_NOT_AT_END
operator|)
operator|!=
literal|0
operator|||
operator|(
name|S_IS_DEFINED
argument_list|(
name|symp
argument_list|)
operator|&&
operator|!
name|S_IS_COMMON
argument_list|(
name|symp
argument_list|)
operator|&&
operator|(
operator|!
name|S_IS_EXTERNAL
argument_list|(
name|symp
argument_list|)
operator|||
name|SF_GET_FUNCTION
argument_list|(
name|symp
argument_list|)
operator|)
operator|)
operator|)
condition|)
block|{
name|SA_SET_SYM_ENDNDX
argument_list|(
name|set_end
argument_list|,
name|symp
argument_list|)
expr_stmt|;
name|set_end
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|next_set_end
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|set_end
operator|!=
name|NULL
condition|)
name|as_warn
argument_list|(
literal|"Warning: internal error: forgetting to set endndx of %s"
argument_list|,
name|S_GET_NAME
argument_list|(
name|set_end
argument_list|)
argument_list|)
expr_stmt|;
name|set_end
operator|=
name|next_set_end
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|OBJ_XCOFF
if|if
condition|(
operator|!
operator|*
name|punt
operator|&&
name|S_GET_STORAGE_CLASS
argument_list|(
name|symp
argument_list|)
operator|==
name|C_FCN
operator|&&
name|streq
argument_list|(
name|S_GET_NAME
argument_list|(
name|symp
argument_list|)
argument_list|,
literal|".bf"
argument_list|)
condition|)
block|{
if|if
condition|(
name|coff_last_bf
operator|!=
name|NULL
condition|)
name|SA_SET_SYM_ENDNDX
argument_list|(
name|coff_last_bf
argument_list|,
name|symp
argument_list|)
expr_stmt|;
name|coff_last_bf
operator|=
name|symp
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|coffsymbol
argument_list|(
name|symbol_get_bfdsym
argument_list|(
name|symp
argument_list|)
argument_list|)
operator|->
name|lineno
condition|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|line_no
modifier|*
name|lptr
decl_stmt|;
name|alent
modifier|*
name|l
decl_stmt|;
name|lptr
operator|=
operator|(
expr|struct
name|line_no
operator|*
operator|)
name|coffsymbol
argument_list|(
name|symbol_get_bfdsym
argument_list|(
name|symp
argument_list|)
argument_list|)
operator|->
name|lineno
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|lptr
condition|;
name|lptr
operator|=
name|lptr
operator|->
name|next
control|)
name|i
operator|++
expr_stmt|;
name|lptr
operator|=
operator|(
expr|struct
name|line_no
operator|*
operator|)
name|coffsymbol
argument_list|(
name|symbol_get_bfdsym
argument_list|(
name|symp
argument_list|)
argument_list|)
operator|->
name|lineno
expr_stmt|;
comment|/* We need i entries for line numbers, plus 1 for the first 	 entry which BFD will override, plus 1 for the last zero 	 entry (a marker for BFD).  */
name|l
operator|=
name|xmalloc
argument_list|(
operator|(
name|i
operator|+
literal|2
operator|)
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|l
argument_list|)
argument_list|)
expr_stmt|;
name|coffsymbol
argument_list|(
name|symbol_get_bfdsym
argument_list|(
name|symp
argument_list|)
argument_list|)
operator|->
name|lineno
operator|=
name|l
expr_stmt|;
name|l
index|[
name|i
operator|+
literal|1
index|]
operator|.
name|line_number
operator|=
literal|0
expr_stmt|;
name|l
index|[
name|i
operator|+
literal|1
index|]
operator|.
name|u
operator|.
name|sym
operator|=
name|NULL
expr_stmt|;
for|for
control|(
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|lptr
operator|->
name|frag
condition|)
name|lptr
operator|->
name|l
operator|.
name|u
operator|.
name|offset
operator|+=
name|lptr
operator|->
name|frag
operator|->
name|fr_address
operator|/
name|OCTETS_PER_BYTE
expr_stmt|;
name|l
index|[
name|i
index|]
operator|=
name|lptr
operator|->
name|l
expr_stmt|;
name|lptr
operator|=
name|lptr
operator|->
name|next
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
name|coff_adjust_section_syms
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|asection
modifier|*
name|sec
parameter_list|,
name|void
modifier|*
name|x
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|symbolS
modifier|*
name|secsym
decl_stmt|;
name|segment_info_type
modifier|*
name|seginfo
init|=
name|seg_info
argument_list|(
name|sec
argument_list|)
decl_stmt|;
name|int
name|nlnno
decl_stmt|,
name|nrelocs
init|=
literal|0
decl_stmt|;
comment|/* RS/6000 gas creates a .debug section manually in ppc_frob_file in      tc-ppc.c.  Do not get confused by it.  */
if|if
condition|(
name|seginfo
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|streq
argument_list|(
name|sec
operator|->
name|name
argument_list|,
literal|".text"
argument_list|)
condition|)
name|nlnno
operator|=
name|coff_n_line_nos
expr_stmt|;
else|else
name|nlnno
operator|=
literal|0
expr_stmt|;
block|{
comment|/* @@ Hope that none of the fixups expand to more than one reloc        entry...  */
name|fixS
modifier|*
name|fixp
init|=
name|seginfo
operator|->
name|fix_root
decl_stmt|;
while|while
condition|(
name|fixp
condition|)
block|{
if|if
condition|(
operator|!
name|fixp
operator|->
name|fx_done
condition|)
name|nrelocs
operator|++
expr_stmt|;
name|fixp
operator|=
name|fixp
operator|->
name|fx_next
expr_stmt|;
block|}
block|}
if|if
condition|(
name|bfd_get_section_size
argument_list|(
name|sec
argument_list|)
operator|==
literal|0
operator|&&
name|nrelocs
operator|==
literal|0
operator|&&
name|nlnno
operator|==
literal|0
operator|&&
name|sec
operator|!=
name|text_section
operator|&&
name|sec
operator|!=
name|data_section
operator|&&
name|sec
operator|!=
name|bss_section
condition|)
return|return;
name|secsym
operator|=
name|section_symbol
argument_list|(
name|sec
argument_list|)
expr_stmt|;
comment|/* This is an estimate; we'll plug in the real value using      SET_SECTION_RELOCS later */
name|SA_SET_SCN_NRELOC
argument_list|(
name|secsym
argument_list|,
name|nrelocs
argument_list|)
expr_stmt|;
name|SA_SET_SCN_NLINNO
argument_list|(
name|secsym
argument_list|,
name|nlnno
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|coff_frob_file_after_relocs
parameter_list|(
name|void
parameter_list|)
block|{
name|bfd_map_over_sections
argument_list|(
name|stdoutput
argument_list|,
name|coff_adjust_section_syms
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Implement the .section pseudo op:   	.section name {, "flags"}                   ^         ^                   |         +--- optional flags: 'b' for bss                   |                              'i' for info                   +-- section name               'l' for lib                                                  'n' for noload                                                  'o' for over                                                  'w' for data   						 'd' (apparently m88k for data)                                                  'x' for text   						 'r' for read-only data   						 's' for shared data (PE)    But if the argument is not a quoted string, treat it as a    subsegment number.     Note the 'a' flag is silently ignored.  This allows the same    .section directive to be parsed in both ELF and COFF formats.  */
end_comment

begin_function
name|void
name|obj_coff_section
parameter_list|(
name|int
name|ignore
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
comment|/* Strip out the section name.  */
name|char
modifier|*
name|section_name
decl_stmt|;
name|char
name|c
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|unsigned
name|int
name|exp
decl_stmt|;
name|flagword
name|flags
decl_stmt|,
name|oldflags
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
if|if
condition|(
name|flag_mri
condition|)
block|{
name|char
name|type
decl_stmt|;
name|s_mri_sect
argument_list|(
operator|&
name|type
argument_list|)
expr_stmt|;
return|return;
block|}
name|section_name
operator|=
name|input_line_pointer
expr_stmt|;
name|c
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
name|name
operator|=
name|xmalloc
argument_list|(
name|input_line_pointer
operator|-
name|section_name
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|name
argument_list|,
name|section_name
argument_list|)
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
name|exp
operator|=
literal|0
expr_stmt|;
name|flags
operator|=
name|SEC_NO_FLAGS
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|','
condition|)
block|{
operator|++
name|input_line_pointer
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|!=
literal|'"'
condition|)
name|exp
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
else|else
block|{
name|unsigned
name|char
name|attr
decl_stmt|;
name|int
name|readonly_removed
init|=
literal|0
decl_stmt|;
name|int
name|load_removed
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|attr
operator|=
operator|*
operator|++
name|input_line_pointer
operator|,
name|attr
operator|!=
literal|'"'
operator|&&
operator|!
name|is_end_of_line
index|[
name|attr
index|]
condition|)
block|{
switch|switch
condition|(
name|attr
condition|)
block|{
case|case
literal|'b'
case|:
comment|/* Uninitialised data section.  */
name|flags
operator||=
name|SEC_ALLOC
expr_stmt|;
name|flags
operator|&=
operator|~
name|SEC_LOAD
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
comment|/* Section not loaded.  */
name|flags
operator|&=
operator|~
name|SEC_LOAD
expr_stmt|;
name|flags
operator||=
name|SEC_NEVER_LOAD
expr_stmt|;
name|load_removed
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
comment|/* Shared section.  */
name|flags
operator||=
name|SEC_COFF_SHARED
expr_stmt|;
comment|/* Fall through.  */
case|case
literal|'d'
case|:
comment|/* Data section.  */
name|flags
operator||=
name|SEC_DATA
expr_stmt|;
if|if
condition|(
operator|!
name|load_removed
condition|)
name|flags
operator||=
name|SEC_LOAD
expr_stmt|;
name|flags
operator|&=
operator|~
name|SEC_READONLY
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
comment|/* Writable section.  */
name|flags
operator|&=
operator|~
name|SEC_READONLY
expr_stmt|;
name|readonly_removed
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
comment|/* Ignore.  Here for compatibility with ELF.  */
break|break;
case|case
literal|'r'
case|:
comment|/* Read-only section.  Implies a data section.  */
name|readonly_removed
operator|=
literal|0
expr_stmt|;
comment|/* Fall through.  */
case|case
literal|'x'
case|:
comment|/* Executable section.  */
comment|/* If we are setting the 'x' attribute or if the 'r' 		     attribute is being used to restore the readonly status 		     of a code section (eg "wxr") then set the SEC_CODE flag, 		     otherwise set the SEC_DATA flag.  */
name|flags
operator||=
operator|(
name|attr
operator|==
literal|'x'
operator|||
operator|(
name|flags
operator|&
name|SEC_CODE
operator|)
condition|?
name|SEC_CODE
else|:
name|SEC_DATA
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|load_removed
condition|)
name|flags
operator||=
name|SEC_LOAD
expr_stmt|;
comment|/* Note - the READONLY flag is set here, even for the 'x' 		     attribute in order to be compatible with the MSVC 		     linker.  */
if|if
condition|(
operator|!
name|readonly_removed
condition|)
name|flags
operator||=
name|SEC_READONLY
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
comment|/* STYP_INFO */
case|case
literal|'l'
case|:
comment|/* STYP_LIB */
case|case
literal|'o'
case|:
comment|/* STYP_OVER */
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"unsupported section attribute '%c'"
argument_list|)
argument_list|,
name|attr
argument_list|)
expr_stmt|;
break|break;
default|default:
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"unknown section attribute '%c'"
argument_list|)
argument_list|,
name|attr
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|attr
operator|==
literal|'"'
condition|)
operator|++
name|input_line_pointer
expr_stmt|;
block|}
block|}
name|sec
operator|=
name|subseg_new
argument_list|(
name|name
argument_list|,
operator|(
name|subsegT
operator|)
name|exp
argument_list|)
expr_stmt|;
name|oldflags
operator|=
name|bfd_get_section_flags
argument_list|(
name|stdoutput
argument_list|,
name|sec
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldflags
operator|==
name|SEC_NO_FLAGS
condition|)
block|{
comment|/* Set section flags for a new section just created by subseg_new.          Provide a default if no flags were parsed.  */
if|if
condition|(
name|flags
operator|==
name|SEC_NO_FLAGS
condition|)
name|flags
operator|=
name|TC_COFF_SECTION_DEFAULT_ATTRIBUTES
expr_stmt|;
ifdef|#
directive|ifdef
name|COFF_LONG_SECTION_NAMES
comment|/* Add SEC_LINK_ONCE and SEC_LINK_DUPLICATES_DISCARD to .gnu.linkonce          sections so adjust_reloc_syms in write.c will correctly handle          relocs which refer to non-local symbols in these sections.  */
if|if
condition|(
name|strneq
argument_list|(
name|name
argument_list|,
literal|".gnu.linkonce"
argument_list|,
sizeof|sizeof
argument_list|(
literal|".gnu.linkonce"
argument_list|)
operator|-
literal|1
argument_list|)
condition|)
name|flags
operator||=
name|SEC_LINK_ONCE
operator||
name|SEC_LINK_DUPLICATES_DISCARD
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|bfd_set_section_flags
argument_list|(
name|stdoutput
argument_list|,
name|sec
argument_list|,
name|flags
argument_list|)
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"error setting flags for \"%s\": %s"
argument_list|)
argument_list|,
name|bfd_section_name
argument_list|(
name|stdoutput
argument_list|,
name|sec
argument_list|)
argument_list|,
name|bfd_errmsg
argument_list|(
name|bfd_get_error
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|flags
operator|!=
name|SEC_NO_FLAGS
condition|)
block|{
comment|/* This section's attributes have already been set.  Warn if the          attributes don't match.  */
name|flagword
name|matchflags
init|=
operator|(
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_READONLY
operator||
name|SEC_CODE
operator||
name|SEC_DATA
operator||
name|SEC_COFF_SHARED
operator||
name|SEC_NEVER_LOAD
operator|)
decl_stmt|;
if|if
condition|(
operator|(
name|flags
operator|^
name|oldflags
operator|)
operator|&
name|matchflags
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"Ignoring changed section attributes for %s"
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|coff_adjust_symtab
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|symbol_rootP
operator|==
name|NULL
operator|||
name|S_GET_STORAGE_CLASS
argument_list|(
name|symbol_rootP
argument_list|)
operator|!=
name|C_FILE
condition|)
name|c_dot_file_symbol
argument_list|(
literal|"fake"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|coff_frob_section
parameter_list|(
name|segT
name|sec
parameter_list|)
block|{
name|segT
name|strsec
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|fragS
modifier|*
name|fragp
decl_stmt|;
name|bfd_vma
name|size
decl_stmt|,
name|n_entries
decl_stmt|,
name|mask
decl_stmt|;
name|bfd_vma
name|align_power
init|=
operator|(
name|bfd_vma
operator|)
name|sec
operator|->
name|alignment_power
operator|+
name|OCTETS_PER_BYTE_POWER
decl_stmt|;
comment|/* The COFF back end in BFD requires that all section sizes be      rounded up to multiples of the corresponding section alignments,      supposedly because standard COFF has no other way of encoding alignment      for sections.  If your COFF flavor has a different way of encoding      section alignment, then skip this step, as TICOFF does.  */
name|size
operator|=
name|bfd_get_section_size
argument_list|(
name|sec
argument_list|)
expr_stmt|;
name|mask
operator|=
operator|(
operator|(
name|bfd_vma
operator|)
literal|1
operator|<<
name|align_power
operator|)
operator|-
literal|1
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|TICOFF
argument_list|)
if|if
condition|(
name|size
operator|&
name|mask
condition|)
block|{
name|bfd_vma
name|new_size
decl_stmt|;
name|fragS
modifier|*
name|last
decl_stmt|;
name|new_size
operator|=
operator|(
name|size
operator|+
name|mask
operator|)
operator|&
operator|~
name|mask
expr_stmt|;
name|bfd_set_section_size
argument_list|(
name|stdoutput
argument_list|,
name|sec
argument_list|,
name|new_size
argument_list|)
expr_stmt|;
comment|/* If the size had to be rounded up, add some padding in          the last non-empty frag.  */
name|fragp
operator|=
name|seg_info
argument_list|(
name|sec
argument_list|)
operator|->
name|frchainP
operator|->
name|frch_root
expr_stmt|;
name|last
operator|=
name|seg_info
argument_list|(
name|sec
argument_list|)
operator|->
name|frchainP
operator|->
name|frch_last
expr_stmt|;
while|while
condition|(
name|fragp
operator|->
name|fr_next
operator|!=
name|last
condition|)
name|fragp
operator|=
name|fragp
operator|->
name|fr_next
expr_stmt|;
name|last
operator|->
name|fr_address
operator|=
name|size
expr_stmt|;
name|fragp
operator|->
name|fr_offset
operator|+=
name|new_size
operator|-
name|size
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* If the section size is non-zero, the section symbol needs an aux      entry associated with it, indicating the size.  We don't know      all the values yet; coff_frob_symbol will fill them in later.  */
ifndef|#
directive|ifndef
name|TICOFF
if|if
condition|(
name|size
operator|!=
literal|0
operator|||
name|sec
operator|==
name|text_section
operator|||
name|sec
operator|==
name|data_section
operator|||
name|sec
operator|==
name|bss_section
condition|)
endif|#
directive|endif
block|{
name|symbolS
modifier|*
name|secsym
init|=
name|section_symbol
argument_list|(
name|sec
argument_list|)
decl_stmt|;
name|S_SET_STORAGE_CLASS
argument_list|(
name|secsym
argument_list|,
name|C_STAT
argument_list|)
expr_stmt|;
name|S_SET_NUMBER_AUXILIARY
argument_list|(
name|secsym
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SF_SET_STATICS
argument_list|(
name|secsym
argument_list|)
expr_stmt|;
name|SA_SET_SCN_SCNLEN
argument_list|(
name|secsym
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
comment|/* FIXME: These should be in a "stabs.h" file, or maybe as.h.  */
ifndef|#
directive|ifndef
name|STAB_SECTION_NAME
define|#
directive|define
name|STAB_SECTION_NAME
value|".stab"
endif|#
directive|endif
ifndef|#
directive|ifndef
name|STAB_STRING_SECTION_NAME
define|#
directive|define
name|STAB_STRING_SECTION_NAME
value|".stabstr"
endif|#
directive|endif
if|if
condition|(
operator|!
name|streq
argument_list|(
name|STAB_STRING_SECTION_NAME
argument_list|,
name|sec
operator|->
name|name
argument_list|)
condition|)
return|return;
name|strsec
operator|=
name|sec
expr_stmt|;
name|sec
operator|=
name|subseg_get
argument_list|(
name|STAB_SECTION_NAME
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* size is already rounded up, since other section will be listed first */
name|size
operator|=
name|bfd_get_section_size
argument_list|(
name|strsec
argument_list|)
expr_stmt|;
name|n_entries
operator|=
name|bfd_get_section_size
argument_list|(
name|sec
argument_list|)
operator|/
literal|12
operator|-
literal|1
expr_stmt|;
comment|/* Find first non-empty frag.  It should be large enough.  */
name|fragp
operator|=
name|seg_info
argument_list|(
name|sec
argument_list|)
operator|->
name|frchainP
operator|->
name|frch_root
expr_stmt|;
while|while
condition|(
name|fragp
operator|&&
name|fragp
operator|->
name|fr_fix
operator|==
literal|0
condition|)
name|fragp
operator|=
name|fragp
operator|->
name|fr_next
expr_stmt|;
name|assert
argument_list|(
name|fragp
operator|!=
literal|0
operator|&&
name|fragp
operator|->
name|fr_fix
operator|>=
literal|12
argument_list|)
expr_stmt|;
comment|/* Store the values.  */
name|p
operator|=
name|fragp
operator|->
name|fr_literal
expr_stmt|;
name|bfd_h_put_16
argument_list|(
name|stdoutput
argument_list|,
name|n_entries
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|p
operator|+
literal|6
argument_list|)
expr_stmt|;
name|bfd_h_put_32
argument_list|(
name|stdoutput
argument_list|,
name|size
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|p
operator|+
literal|8
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|obj_coff_init_stab_section
parameter_list|(
name|segT
name|seg
parameter_list|)
block|{
name|char
modifier|*
name|file
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|stabstr_name
decl_stmt|;
name|unsigned
name|int
name|stroff
decl_stmt|;
comment|/* Make space for this first symbol.  */
name|p
operator|=
name|frag_more
argument_list|(
literal|12
argument_list|)
expr_stmt|;
comment|/* Zero it out.  */
name|memset
argument_list|(
name|p
argument_list|,
literal|0
argument_list|,
literal|12
argument_list|)
expr_stmt|;
name|as_where
argument_list|(
operator|&
name|file
argument_list|,
operator|(
name|unsigned
name|int
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|stabstr_name
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|seg
operator|->
name|name
argument_list|)
operator|+
literal|4
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|stabstr_name
argument_list|,
name|seg
operator|->
name|name
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|stabstr_name
argument_list|,
literal|"str"
argument_list|)
expr_stmt|;
name|stroff
operator|=
name|get_stab_string_offset
argument_list|(
name|file
argument_list|,
name|stabstr_name
argument_list|)
expr_stmt|;
name|know
argument_list|(
name|stroff
operator|==
literal|1
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|p
argument_list|,
name|stroff
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_function
specifier|const
name|char
modifier|*
name|s_get_name
parameter_list|(
name|symbolS
modifier|*
name|s
parameter_list|)
block|{
return|return
operator|(
operator|(
name|s
operator|==
name|NULL
operator|)
condition|?
literal|"(NULL)"
else|:
name|S_GET_NAME
argument_list|(
name|s
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|symbol_dump
parameter_list|(
name|void
parameter_list|)
block|{
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
for|for
control|(
name|symbolP
operator|=
name|symbol_rootP
init|;
name|symbolP
condition|;
name|symbolP
operator|=
name|symbol_next
argument_list|(
name|symbolP
argument_list|)
control|)
name|printf
argument_list|(
name|_
argument_list|(
literal|"0x%lx: \"%s\" type = %ld, class = %d, segment = %d\n"
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|symbolP
argument_list|,
name|S_GET_NAME
argument_list|(
name|symbolP
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|S_GET_DATA_TYPE
argument_list|(
name|symbolP
argument_list|)
argument_list|,
name|S_GET_STORAGE_CLASS
argument_list|(
name|symbolP
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|S_GET_SEGMENT
argument_list|(
name|symbolP
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DEBUG */
end_comment

begin_decl_stmt
specifier|const
name|pseudo_typeS
name|coff_pseudo_table
index|[]
init|=
block|{
block|{
literal|"ABORT"
block|,
name|s_abort
block|,
literal|0
block|}
block|,
block|{
literal|"appline"
block|,
name|obj_coff_ln
block|,
literal|1
block|}
block|,
comment|/* We accept the .bss directive for backward compatibility with      earlier versions of gas.  */
block|{
literal|"bss"
block|,
name|obj_coff_bss
block|,
literal|0
block|}
block|,
block|{
literal|"def"
block|,
name|obj_coff_def
block|,
literal|0
block|}
block|,
block|{
literal|"dim"
block|,
name|obj_coff_dim
block|,
literal|0
block|}
block|,
block|{
literal|"endef"
block|,
name|obj_coff_endef
block|,
literal|0
block|}
block|,
block|{
literal|"ident"
block|,
name|obj_coff_ident
block|,
literal|0
block|}
block|,
block|{
literal|"line"
block|,
name|obj_coff_line
block|,
literal|0
block|}
block|,
block|{
literal|"ln"
block|,
name|obj_coff_ln
block|,
literal|0
block|}
block|,
block|{
literal|"scl"
block|,
name|obj_coff_scl
block|,
literal|0
block|}
block|,
block|{
literal|"sect"
block|,
name|obj_coff_section
block|,
literal|0
block|}
block|,
block|{
literal|"sect.s"
block|,
name|obj_coff_section
block|,
literal|0
block|}
block|,
block|{
literal|"section"
block|,
name|obj_coff_section
block|,
literal|0
block|}
block|,
block|{
literal|"section.s"
block|,
name|obj_coff_section
block|,
literal|0
block|}
block|,
comment|/* FIXME: We ignore the MRI short attribute.  */
block|{
literal|"size"
block|,
name|obj_coff_size
block|,
literal|0
block|}
block|,
block|{
literal|"tag"
block|,
name|obj_coff_tag
block|,
literal|0
block|}
block|,
block|{
literal|"type"
block|,
name|obj_coff_type
block|,
literal|0
block|}
block|,
block|{
literal|"val"
block|,
name|obj_coff_val
block|,
literal|0
block|}
block|,
block|{
literal|"version"
block|,
name|s_ignore
block|,
literal|0
block|}
block|,
block|{
literal|"loc"
block|,
name|obj_coff_loc
block|,
literal|0
block|}
block|,
block|{
literal|"optim"
block|,
name|s_ignore
block|,
literal|0
block|}
block|,
comment|/* For sun386i cc (?) */
block|{
literal|"weak"
block|,
name|obj_coff_weak
block|,
literal|0
block|}
block|,
if|#
directive|if
name|defined
name|TC_TIC4X
comment|/* The tic4x uses sdef instead of def.  */
block|{
literal|"sdef"
block|,
name|obj_coff_def
block|,
literal|0
block|}
block|,
endif|#
directive|endif
block|{
name|NULL
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Support for a COFF emulation.  */
end_comment

begin_function
specifier|static
name|void
name|coff_pop_insert
parameter_list|(
name|void
parameter_list|)
block|{
name|pop_insert
argument_list|(
name|coff_pseudo_table
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|coff_separate_stab_sections
parameter_list|(
name|void
parameter_list|)
block|{
return|return
literal|1
return|;
block|}
end_function

begin_decl_stmt
specifier|const
name|struct
name|format_ops
name|coff_format_ops
init|=
block|{
name|bfd_target_coff_flavour
block|,
literal|0
block|,
comment|/* dfl_leading_underscore */
literal|1
block|,
comment|/* emit_section_symbols */
literal|0
block|,
comment|/* begin */
name|c_dot_file_symbol
block|,
name|coff_frob_symbol
block|,
literal|0
block|,
comment|/* frob_file */
literal|0
block|,
comment|/* frob_file_before_adjust */
literal|0
block|,
comment|/* frob_file_before_fix */
name|coff_frob_file_after_relocs
block|,
literal|0
block|,
comment|/* s_get_size */
literal|0
block|,
comment|/* s_set_size */
literal|0
block|,
comment|/* s_get_align */
literal|0
block|,
comment|/* s_set_align */
literal|0
block|,
comment|/* s_get_other */
literal|0
block|,
comment|/* s_set_other */
literal|0
block|,
comment|/* s_get_desc */
literal|0
block|,
comment|/* s_set_desc */
literal|0
block|,
comment|/* s_get_type */
literal|0
block|,
comment|/* s_set_type */
literal|0
block|,
comment|/* copy_symbol_attributes */
literal|0
block|,
comment|/* generate_asm_lineno */
literal|0
block|,
comment|/* process_stab */
name|coff_separate_stab_sections
block|,
name|obj_coff_init_stab_section
block|,
literal|0
block|,
comment|/* sec_sym_ok_for_reloc */
name|coff_pop_insert
block|,
literal|0
block|,
comment|/* ecoff_set_ext */
name|coff_obj_read_begin_hook
block|,
name|coff_obj_symbol_new_hook
block|}
decl_stmt|;
end_decl_stmt

end_unit

