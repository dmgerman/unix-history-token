begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* tc-arc.c -- Assembler for the ARC    Copyright (C) 1994, 1995, 1997, 1998, 1999 Free Software Foundation, Inc.    Contributed by Doug Evans (dje@cygnus.com).     This file is part of GAS, the GNU Assembler.     GAS is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     GAS is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with GAS; see the file COPYING.  If not, write to the Free    Software Foundation, 59 Temple Place - Suite 330, Boston, MA    02111-1307, USA. */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|"as.h"
end_include

begin_include
include|#
directive|include
file|"subsegs.h"
end_include

begin_include
include|#
directive|include
file|"opcode/arc.h"
end_include

begin_include
include|#
directive|include
file|"elf/arc.h"
end_include

begin_decl_stmt
specifier|extern
name|int
name|arc_get_mach
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|arc_insn
name|arc_insert_operand
name|PARAMS
argument_list|(
operator|(
name|arc_insn
operator|,
specifier|const
expr|struct
name|arc_operand
operator|*
operator|,
name|int
operator|,
specifier|const
expr|struct
name|arc_operand_value
operator|*
operator|,
name|offsetT
operator|,
name|char
operator|*
operator|,
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|arc_common
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|arc_cpu
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*static void arc_rename PARAMS ((int));*/
end_comment

begin_decl_stmt
specifier|static
name|int
name|get_arc_exp_reloc_type
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|,
name|expressionS
operator|*
operator|,
name|expressionS
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|pseudo_typeS
name|md_pseudo_table
index|[]
init|=
block|{
block|{
literal|"align"
block|,
name|s_align_bytes
block|,
literal|0
block|}
block|,
comment|/* Defaulting is invalid (0) */
block|{
literal|"common"
block|,
name|arc_common
block|,
literal|0
block|}
block|,
comment|/*{ "hword", cons, 2 }, - already exists */
block|{
literal|"word"
block|,
name|cons
block|,
literal|4
block|}
block|,
comment|/*{ "xword", cons, 8 },*/
block|{
literal|"cpu"
block|,
name|arc_cpu
block|,
literal|0
block|}
block|,
comment|/*{ "rename", arc_rename, 0 },*/
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This array holds the chars that always start a comment.  If the    pre-processor is disabled, these aren't very useful */
end_comment

begin_decl_stmt
specifier|const
name|char
name|comment_chars
index|[]
init|=
literal|"#;"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This array holds the chars that only start a comment at the beginning of    a line.  If the line seems to have the form '# 123 filename'    .line and .file directives will appear in the pre-processed output */
end_comment

begin_comment
comment|/* Note that input_file.c hand checks for '#' at the beginning of the    first line of the input file.  This is because the compiler outputs    #NO_APP at the beginning of its output. */
end_comment

begin_comment
comment|/* Also note that comments started like this one will always    work if '/' isn't otherwise defined. */
end_comment

begin_decl_stmt
specifier|const
name|char
name|line_comment_chars
index|[]
init|=
literal|"#"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
name|line_separator_chars
index|[]
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Chars that can be used to separate mant from exp in floating point nums */
end_comment

begin_decl_stmt
specifier|const
name|char
name|EXP_CHARS
index|[]
init|=
literal|"eE"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Chars that mean this number is a floating point constant */
end_comment

begin_comment
comment|/* As in 0f12.456 */
end_comment

begin_comment
comment|/* or    0d1.2345e12 */
end_comment

begin_decl_stmt
specifier|const
name|char
name|FLT_CHARS
index|[]
init|=
literal|"rRsSfFdD"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Byte order.  */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|target_big_endian
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
modifier|*
name|arc_target_format
init|=
name|DEFAULT_TARGET_FORMAT
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|byte_order
init|=
name|DEFAULT_BYTE_ORDER
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* One of bfd_mach_arc_xxx.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|arc_mach_type
init|=
name|bfd_mach_arc_base
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero if the cpu type has been explicitly specified.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|mach_type_specified_p
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero if opcode tables have been initialized.    A .cpu command must appear before any instructions.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|cpu_tables_init_p
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|hash_control
modifier|*
name|arc_suffix_hash
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_decl_stmt
specifier|const
name|char
modifier|*
name|md_shortopts
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|option
name|md_longopts
index|[]
init|=
block|{
define|#
directive|define
name|OPTION_EB
value|(OPTION_MD_BASE + 0)
block|{
literal|"EB"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_EB
block|}
block|,
define|#
directive|define
name|OPTION_EL
value|(OPTION_MD_BASE + 1)
block|{
literal|"EL"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_EL
block|}
block|,
block|{
name|NULL
block|,
name|no_argument
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|size_t
name|md_longopts_size
init|=
sizeof|sizeof
argument_list|(
name|md_longopts
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * md_parse_option  *  * Invocation line includes a switch not recognized by the base assembler.  * See if it's a processor-specific option.  */
end_comment

begin_function
name|int
name|md_parse_option
parameter_list|(
name|c
parameter_list|,
name|arg
parameter_list|)
name|int
name|c
decl_stmt|;
name|char
modifier|*
name|arg
decl_stmt|;
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
name|OPTION_EB
case|:
name|byte_order
operator|=
name|BIG_ENDIAN
expr_stmt|;
name|arc_target_format
operator|=
literal|"elf32-bigarc"
expr_stmt|;
break|break;
case|case
name|OPTION_EL
case|:
name|byte_order
operator|=
name|LITTLE_ENDIAN
expr_stmt|;
name|arc_target_format
operator|=
literal|"elf32-littlearc"
expr_stmt|;
break|break;
default|default:
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
name|void
name|md_show_usage
parameter_list|(
name|stream
parameter_list|)
name|FILE
modifier|*
name|stream
decl_stmt|;
block|{
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"\ ARC options:\n\ -EB			generate big endian output\n\ -EL			generate little endian output\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This function is called once, at assembler startup time.  It should    set up all the tables, etc. that the MD part of the assembler will need.    Opcode selection is defered until later because we might see a .cpu    command.  */
end_comment

begin_function
name|void
name|md_begin
parameter_list|()
block|{
comment|/* The endianness can be chosen "at the factory".  */
name|target_big_endian
operator|=
name|byte_order
operator|==
name|BIG_ENDIAN
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_set_arch_mach
argument_list|(
name|stdoutput
argument_list|,
name|bfd_arch_arc
argument_list|,
name|arc_mach_type
argument_list|)
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"could not set architecture and machine"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Assume the base cpu.  This call is necessary because we need to      initialize `arc_operand_map' which may be needed before we see the      first insn.  */
name|arc_opcode_init_tables
argument_list|(
name|arc_get_opcode_mach
argument_list|(
name|bfd_mach_arc_base
argument_list|,
name|target_big_endian
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Initialize the various opcode and operand tables.    MACH is one of bfd_mach_arc_xxx.  */
end_comment

begin_function
specifier|static
name|void
name|init_opcode_tables
parameter_list|(
name|mach
parameter_list|)
name|int
name|mach
decl_stmt|;
block|{
specifier|register
name|unsigned
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|last
decl_stmt|;
if|if
condition|(
operator|(
name|arc_suffix_hash
operator|=
name|hash_new
argument_list|()
operator|)
operator|==
name|NULL
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"virtual memory exhausted"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_set_arch_mach
argument_list|(
name|stdoutput
argument_list|,
name|bfd_arch_arc
argument_list|,
name|mach
argument_list|)
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"could not set architecture and machine"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* This initializes a few things in arc-opc.c that we need.      This must be called before the various arc_xxx_supported fns.  */
name|arc_opcode_init_tables
argument_list|(
name|arc_get_opcode_mach
argument_list|(
name|mach
argument_list|,
name|target_big_endian
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Only put the first entry of each equivalently named suffix in the      table.  */
name|last
operator|=
literal|""
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|arc_suffixes_count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|arc_opval_supported
argument_list|(
operator|&
name|arc_suffixes
index|[
name|i
index|]
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|strcmp
argument_list|(
name|arc_suffixes
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|last
argument_list|)
operator|!=
literal|0
condition|)
name|hash_insert
argument_list|(
name|arc_suffix_hash
argument_list|,
name|arc_suffixes
index|[
name|i
index|]
operator|.
name|name
argument_list|,
call|(
name|PTR
call|)
argument_list|(
name|arc_suffixes
operator|+
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|last
operator|=
name|arc_suffixes
index|[
name|i
index|]
operator|.
name|name
expr_stmt|;
block|}
comment|/* Since registers don't have a prefix, we put them in the symbol table so      they can't be used as symbols.  This also simplifies argument parsing as      we can let gas parse registers for us.  The recorded register number is      the index in `arc_reg_names'.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|arc_reg_names_count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|arc_opval_supported
argument_list|(
operator|&
name|arc_reg_names
index|[
name|i
index|]
argument_list|)
condition|)
continue|continue;
comment|/* Use symbol_create here instead of symbol_new so we don't try to 	 output registers into the object file's symbol table.  */
name|symbol_table_insert
argument_list|(
name|symbol_create
argument_list|(
name|arc_reg_names
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|reg_section
argument_list|,
name|i
argument_list|,
operator|&
name|zero_address_frag
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Tell `s_cpu' it's too late.  */
name|cpu_tables_init_p
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Insert an operand value into an instruction.    If REG is non-NULL, it is a register number and ignore VAL.  */
end_comment

begin_function
specifier|static
name|arc_insn
name|arc_insert_operand
parameter_list|(
name|insn
parameter_list|,
name|operand
parameter_list|,
name|mods
parameter_list|,
name|reg
parameter_list|,
name|val
parameter_list|,
name|file
parameter_list|,
name|line
parameter_list|)
name|arc_insn
name|insn
decl_stmt|;
specifier|const
name|struct
name|arc_operand
modifier|*
name|operand
decl_stmt|;
name|int
name|mods
decl_stmt|;
specifier|const
name|struct
name|arc_operand_value
modifier|*
name|reg
decl_stmt|;
name|offsetT
name|val
decl_stmt|;
name|char
modifier|*
name|file
decl_stmt|;
name|unsigned
name|int
name|line
decl_stmt|;
block|{
if|if
condition|(
name|operand
operator|->
name|bits
operator|!=
literal|32
condition|)
block|{
name|long
name|min
decl_stmt|,
name|max
decl_stmt|;
name|offsetT
name|test
decl_stmt|;
if|if
condition|(
operator|(
name|operand
operator|->
name|flags
operator|&
name|ARC_OPERAND_SIGNED
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|operand
operator|->
name|flags
operator|&
name|ARC_OPERAND_SIGNOPT
operator|)
operator|!=
literal|0
condition|)
name|max
operator|=
operator|(
literal|1
operator|<<
name|operand
operator|->
name|bits
operator|)
operator|-
literal|1
expr_stmt|;
else|else
name|max
operator|=
operator|(
literal|1
operator|<<
operator|(
name|operand
operator|->
name|bits
operator|-
literal|1
operator|)
operator|)
operator|-
literal|1
expr_stmt|;
name|min
operator|=
operator|-
operator|(
literal|1
operator|<<
operator|(
name|operand
operator|->
name|bits
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
block|}
else|else
block|{
name|max
operator|=
operator|(
literal|1
operator|<<
name|operand
operator|->
name|bits
operator|)
operator|-
literal|1
expr_stmt|;
name|min
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|operand
operator|->
name|flags
operator|&
name|ARC_OPERAND_NEGATIVE
operator|)
operator|!=
literal|0
condition|)
name|test
operator|=
operator|-
name|val
expr_stmt|;
else|else
name|test
operator|=
name|val
expr_stmt|;
if|if
condition|(
name|test
operator|<
operator|(
name|offsetT
operator|)
name|min
operator|||
name|test
operator|>
operator|(
name|offsetT
operator|)
name|max
condition|)
block|{
specifier|const
name|char
modifier|*
name|err
init|=
name|_
argument_list|(
literal|"operand out of range (%s not between %ld and %ld)"
argument_list|)
decl_stmt|;
name|char
name|buf
index|[
literal|100
index|]
decl_stmt|;
name|sprint_value
argument_list|(
name|buf
argument_list|,
name|test
argument_list|)
expr_stmt|;
if|if
condition|(
name|file
operator|==
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
name|as_warn
argument_list|(
name|err
argument_list|,
name|buf
argument_list|,
name|min
argument_list|,
name|max
argument_list|)
expr_stmt|;
else|else
name|as_warn_where
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
name|err
argument_list|,
name|buf
argument_list|,
name|min
argument_list|,
name|max
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|operand
operator|->
name|insert
condition|)
block|{
specifier|const
name|char
modifier|*
name|errmsg
decl_stmt|;
name|errmsg
operator|=
name|NULL
expr_stmt|;
name|insn
operator|=
call|(
modifier|*
name|operand
operator|->
name|insert
call|)
argument_list|(
name|insn
argument_list|,
name|operand
argument_list|,
name|mods
argument_list|,
name|reg
argument_list|,
operator|(
name|long
operator|)
name|val
argument_list|,
operator|&
name|errmsg
argument_list|)
expr_stmt|;
if|if
condition|(
name|errmsg
operator|!=
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
condition|)
name|as_warn
argument_list|(
name|errmsg
argument_list|)
expr_stmt|;
block|}
else|else
name|insn
operator||=
operator|(
operator|(
operator|(
name|long
operator|)
name|val
operator|&
operator|(
operator|(
literal|1
operator|<<
name|operand
operator|->
name|bits
operator|)
operator|-
literal|1
operator|)
operator|)
operator|<<
name|operand
operator|->
name|shift
operator|)
expr_stmt|;
return|return
name|insn
return|;
block|}
end_function

begin_comment
comment|/* We need to keep a list of fixups.  We can't simply generate them as    we go, because that would require us to first create the frag, and    that would screw up references to ``.''.  */
end_comment

begin_struct
struct|struct
name|arc_fixup
block|{
comment|/* index into `arc_operands' */
name|int
name|opindex
decl_stmt|;
name|expressionS
name|exp
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|MAX_FIXUPS
value|5
end_define

begin_define
define|#
directive|define
name|MAX_SUFFIXES
value|5
end_define

begin_comment
comment|/* This routine is called for each instruction to be assembled.  */
end_comment

begin_function
name|void
name|md_assemble
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
specifier|const
name|struct
name|arc_opcode
modifier|*
name|opcode
decl_stmt|;
name|char
modifier|*
name|start
decl_stmt|;
name|arc_insn
name|insn
decl_stmt|;
specifier|static
name|int
name|init_tables_p
init|=
literal|0
decl_stmt|;
comment|/* Opcode table initialization is deferred until here because we have to      wait for a possible .cpu command.  */
if|if
condition|(
operator|!
name|init_tables_p
condition|)
block|{
name|init_opcode_tables
argument_list|(
name|arc_mach_type
argument_list|)
expr_stmt|;
name|init_tables_p
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Skip leading white space.  */
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|str
argument_list|)
condition|)
name|str
operator|++
expr_stmt|;
comment|/* The instructions are stored in lists hashed by the first letter (though      we needn't care how they're hashed).  Get the first in the list.  */
name|opcode
operator|=
name|arc_opcode_lookup_asm
argument_list|(
name|str
argument_list|)
expr_stmt|;
comment|/* Keep looking until we find a match.  */
name|start
operator|=
name|str
expr_stmt|;
for|for
control|(
init|;
name|opcode
operator|!=
name|NULL
condition|;
name|opcode
operator|=
name|ARC_OPCODE_NEXT_ASM
argument_list|(
name|opcode
argument_list|)
control|)
block|{
name|int
name|past_opcode_p
decl_stmt|,
name|fc
decl_stmt|,
name|num_suffixes
decl_stmt|;
name|char
modifier|*
name|syn
decl_stmt|;
name|struct
name|arc_fixup
name|fixups
index|[
name|MAX_FIXUPS
index|]
decl_stmt|;
comment|/* Used as a sanity check.  If we need a limm reloc, make sure we ask 	 for an extra 4 bytes from frag_more.  */
name|int
name|limm_reloc_p
decl_stmt|;
specifier|const
name|struct
name|arc_operand_value
modifier|*
name|insn_suffixes
index|[
name|MAX_SUFFIXES
index|]
decl_stmt|;
comment|/* Is this opcode supported by the selected cpu?  */
if|if
condition|(
operator|!
name|arc_opcode_supported
argument_list|(
name|opcode
argument_list|)
condition|)
continue|continue;
comment|/* Scan the syntax string.  If it doesn't match, try the next one.  */
name|arc_opcode_init_insert
argument_list|()
expr_stmt|;
name|insn
operator|=
name|opcode
operator|->
name|value
expr_stmt|;
name|fc
operator|=
literal|0
expr_stmt|;
name|past_opcode_p
operator|=
literal|0
expr_stmt|;
name|num_suffixes
operator|=
literal|0
expr_stmt|;
name|limm_reloc_p
operator|=
literal|0
expr_stmt|;
comment|/* We don't check for (*str != '\0') here because we want to parse 	 any trailing fake arguments in the syntax string.  */
for|for
control|(
name|str
operator|=
name|start
operator|,
name|syn
operator|=
name|opcode
operator|->
name|syntax
init|;
operator|*
name|syn
operator|!=
literal|'\0'
condition|;
control|)
block|{
name|int
name|mods
decl_stmt|;
specifier|const
name|struct
name|arc_operand
modifier|*
name|operand
decl_stmt|;
comment|/* Non operand chars must match exactly.  */
if|if
condition|(
operator|*
name|syn
operator|!=
literal|'%'
operator|||
operator|*
operator|++
name|syn
operator|==
literal|'%'
condition|)
block|{
comment|/* Handle '+' specially as we want to allow "ld r0,[sp-4]".  */
comment|/* ??? The syntax has changed to [sp,-4].  */
if|if
condition|(
literal|0
operator|&&
operator|*
name|syn
operator|==
literal|'+'
operator|&&
operator|*
name|str
operator|==
literal|'-'
condition|)
block|{
comment|/* Skip over syn's +, but leave str's - alone. 		     That makes the case identical to "ld r0,[sp+-4]".  */
operator|++
name|syn
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|str
operator|==
operator|*
name|syn
condition|)
block|{
if|if
condition|(
operator|*
name|syn
operator|==
literal|' '
condition|)
name|past_opcode_p
operator|=
literal|1
expr_stmt|;
operator|++
name|syn
expr_stmt|;
operator|++
name|str
expr_stmt|;
block|}
else|else
break|break;
continue|continue;
block|}
comment|/* We have an operand.  Pick out any modifiers.  */
name|mods
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|ARC_MOD_P
argument_list|(
name|arc_operands
index|[
name|arc_operand_map
index|[
operator|*
name|syn
index|]
index|]
operator|.
name|flags
argument_list|)
condition|)
block|{
name|mods
operator||=
name|arc_operands
index|[
name|arc_operand_map
index|[
operator|*
name|syn
index|]
index|]
operator|.
name|flags
operator|&
name|ARC_MOD_BITS
expr_stmt|;
operator|++
name|syn
expr_stmt|;
block|}
name|operand
operator|=
name|arc_operands
operator|+
name|arc_operand_map
index|[
operator|*
name|syn
index|]
expr_stmt|;
if|if
condition|(
name|operand
operator|->
name|fmt
operator|==
literal|0
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"unknown syntax format character `%c'"
argument_list|)
argument_list|,
operator|*
name|syn
argument_list|)
expr_stmt|;
if|if
condition|(
name|operand
operator|->
name|flags
operator|&
name|ARC_OPERAND_FAKE
condition|)
block|{
specifier|const
name|char
modifier|*
name|errmsg
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|operand
operator|->
name|insert
condition|)
block|{
name|insn
operator|=
call|(
modifier|*
name|operand
operator|->
name|insert
call|)
argument_list|(
name|insn
argument_list|,
name|operand
argument_list|,
name|mods
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
operator|&
name|errmsg
argument_list|)
expr_stmt|;
comment|/* If we get an error, go on to try the next insn.  */
if|if
condition|(
name|errmsg
condition|)
break|break;
block|}
operator|++
name|syn
expr_stmt|;
block|}
comment|/* Are we finished with suffixes?  */
elseif|else
if|if
condition|(
operator|!
name|past_opcode_p
condition|)
block|{
name|int
name|found
decl_stmt|;
name|char
name|c
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|t
decl_stmt|;
specifier|const
name|struct
name|arc_operand_value
modifier|*
name|suf
decl_stmt|,
modifier|*
name|suffix
decl_stmt|,
modifier|*
name|suffix_end
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|operand
operator|->
name|flags
operator|&
name|ARC_OPERAND_SUFFIX
operator|)
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* If we're at a space in the input string, we want to skip the 		 remaining suffixes.  There may be some fake ones though, so 		 just go on to try the next one.  */
if|if
condition|(
operator|*
name|str
operator|==
literal|' '
condition|)
block|{
operator|++
name|syn
expr_stmt|;
continue|continue;
block|}
name|s
operator|=
name|str
expr_stmt|;
if|if
condition|(
name|mods
operator|&
name|ARC_MOD_DOT
condition|)
block|{
if|if
condition|(
operator|*
name|s
operator|!=
literal|'.'
condition|)
break|break;
operator|++
name|s
expr_stmt|;
block|}
else|else
block|{
comment|/* This can happen in "b.nd foo" and we're currently looking 		     for "%q" (ie: a condition code suffix).  */
if|if
condition|(
operator|*
name|s
operator|==
literal|'.'
condition|)
block|{
operator|++
name|syn
expr_stmt|;
continue|continue;
block|}
block|}
comment|/* Pick the suffix out and look it up via the hash table.  */
for|for
control|(
name|t
operator|=
name|s
init|;
operator|*
name|t
operator|&&
name|isalpha
argument_list|(
operator|*
name|t
argument_list|)
condition|;
operator|++
name|t
control|)
continue|continue;
name|c
operator|=
operator|*
name|t
expr_stmt|;
operator|*
name|t
operator|=
literal|'\0'
expr_stmt|;
name|suf
operator|=
name|hash_find
argument_list|(
name|arc_suffix_hash
argument_list|,
name|s
argument_list|)
expr_stmt|;
operator|*
name|t
operator|=
name|c
expr_stmt|;
if|if
condition|(
operator|!
name|suf
condition|)
block|{
comment|/* This can happen in "blle foo" and we're currently using 		     the template "b%q%.n %j".  The "bl" insn occurs later in 		     the table so "lle" isn't an illegal suffix.  */
break|break;
block|}
comment|/* Is it the right type?  Note that the same character is used 	         several times, so we have to examine all of them.  This is 		 relatively efficient as equivalent entries are kept 		 together.  If it's not the right type, don't increment `str' 		 so we try the next one in the series.  */
name|found
operator|=
literal|0
expr_stmt|;
name|suffix_end
operator|=
name|arc_suffixes
operator|+
name|arc_suffixes_count
expr_stmt|;
for|for
control|(
name|suffix
operator|=
name|suf
init|;
name|suffix
operator|<
name|suffix_end
operator|&&
name|strcmp
argument_list|(
name|suffix
operator|->
name|name
argument_list|,
name|suf
operator|->
name|name
argument_list|)
operator|==
literal|0
condition|;
operator|++
name|suffix
control|)
block|{
if|if
condition|(
name|arc_operands
index|[
name|suffix
operator|->
name|type
index|]
operator|.
name|fmt
operator|==
operator|*
name|syn
condition|)
block|{
comment|/* Insert the suffix's value into the insn.  */
if|if
condition|(
name|operand
operator|->
name|insert
condition|)
name|insn
operator|=
call|(
modifier|*
name|operand
operator|->
name|insert
call|)
argument_list|(
name|insn
argument_list|,
name|operand
argument_list|,
name|mods
argument_list|,
name|NULL
argument_list|,
name|suffix
operator|->
name|value
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|else
name|insn
operator||=
name|suffix
operator|->
name|value
operator|<<
name|operand
operator|->
name|shift
expr_stmt|;
name|str
operator|=
name|t
expr_stmt|;
name|found
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
operator|++
name|syn
expr_stmt|;
if|if
condition|(
operator|!
name|found
condition|)
empty_stmt|;
comment|/* Wrong type.  Just go on to try next insn entry.  */
else|else
block|{
if|if
condition|(
name|num_suffixes
operator|==
name|MAX_SUFFIXES
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"too many suffixes"
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|insn_suffixes
index|[
name|num_suffixes
operator|++
index|]
operator|=
name|suffix
expr_stmt|;
block|}
block|}
else|else
comment|/* This is either a register or an expression of some kind.  */
block|{
name|char
name|c
decl_stmt|;
name|char
modifier|*
name|hold
decl_stmt|;
specifier|const
name|struct
name|arc_operand_value
modifier|*
name|reg
init|=
name|NULL
decl_stmt|;
name|long
name|value
init|=
literal|0
decl_stmt|;
name|expressionS
name|exp
decl_stmt|;
if|if
condition|(
name|operand
operator|->
name|flags
operator|&
name|ARC_OPERAND_SUFFIX
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Is there anything left to parse? 		 We don't check for this at the top because we want to parse 		 any trailing fake arguments in the syntax string.  */
if|if
condition|(
operator|*
name|str
operator|==
literal|'\0'
condition|)
break|break;
if|#
directive|if
literal|0
comment|/* Is this a syntax character?  Eg: is there a '[' present when 		 there shouldn't be?  */
block|if (!isalnum (*str)
comment|/* '.' as in ".LLC0" */
block|&& *str != '.'
comment|/* '_' as in "_print" */
block|&& *str != '_'
comment|/* '-' as in "[fp,-4]" */
block|&& *str != '-'
comment|/* '%' as in "%ia(_func)" */
block|&& *str != '%') 		break;
endif|#
directive|endif
comment|/* Parse the operand.  */
name|hold
operator|=
name|input_line_pointer
expr_stmt|;
name|input_line_pointer
operator|=
name|str
expr_stmt|;
name|expression
argument_list|(
operator|&
name|exp
argument_list|)
expr_stmt|;
name|str
operator|=
name|input_line_pointer
expr_stmt|;
name|input_line_pointer
operator|=
name|hold
expr_stmt|;
if|if
condition|(
name|exp
operator|.
name|X_op
operator|==
name|O_illegal
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"illegal operand"
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|exp
operator|.
name|X_op
operator|==
name|O_absent
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"missing operand"
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|exp
operator|.
name|X_op
operator|==
name|O_constant
condition|)
block|{
name|value
operator|=
name|exp
operator|.
name|X_add_number
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|exp
operator|.
name|X_op
operator|==
name|O_register
condition|)
block|{
name|reg
operator|=
name|arc_reg_names
operator|+
name|exp
operator|.
name|X_add_number
expr_stmt|;
block|}
else|else
block|{
comment|/* We need to generate a fixup for this expression.  */
if|if
condition|(
name|fc
operator|>=
name|MAX_FIXUPS
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"too many fixups"
argument_list|)
argument_list|)
expr_stmt|;
name|fixups
index|[
name|fc
index|]
operator|.
name|exp
operator|=
name|exp
expr_stmt|;
comment|/* If this is a register constant (IE: one whose 		     register value gets stored as 61-63) then this 		     must be a limm.  We don't support shimm relocs.  */
comment|/* ??? This bit could use some cleaning up. 		     Referencing the format chars like this goes 		     against style.  */
define|#
directive|define
name|IS_REG_OPERAND
parameter_list|(
name|o
parameter_list|)
value|((o) == 'a' || (o) == 'b' || (o) == 'c')
if|if
condition|(
name|IS_REG_OPERAND
argument_list|(
operator|*
name|syn
argument_list|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|junk
decl_stmt|;
name|fixups
index|[
name|fc
index|]
operator|.
name|opindex
operator|=
name|arc_operand_map
index|[
literal|'L'
index|]
expr_stmt|;
name|limm_reloc_p
operator|=
literal|1
expr_stmt|;
comment|/* Tell insert_reg we need a limm.  This is 			 needed because the value at this point is 			 zero, a shimm.  */
comment|/* ??? We need a cleaner interface than this.  */
operator|(
operator|*
name|arc_operands
index|[
name|arc_operand_map
index|[
literal|'Q'
index|]
index|]
operator|.
name|insert
operator|)
operator|(
name|insn
operator|,
name|operand
operator|,
name|mods
operator|,
name|reg
operator|,
literal|0L
operator|,
operator|&
name|junk
operator|)
expr_stmt|;
block|}
else|else
name|fixups
index|[
name|fc
index|]
operator|.
name|opindex
operator|=
name|arc_operand_map
index|[
operator|*
name|syn
index|]
expr_stmt|;
operator|++
name|fc
expr_stmt|;
name|value
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Insert the register or expression into the instruction.  */
if|if
condition|(
name|operand
operator|->
name|insert
condition|)
block|{
specifier|const
name|char
modifier|*
name|errmsg
init|=
name|NULL
decl_stmt|;
name|insn
operator|=
call|(
modifier|*
name|operand
operator|->
name|insert
call|)
argument_list|(
name|insn
argument_list|,
name|operand
argument_list|,
name|mods
argument_list|,
name|reg
argument_list|,
operator|(
name|long
operator|)
name|value
argument_list|,
operator|&
name|errmsg
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|if (errmsg != (const char *) NULL) 		    as_warn (errmsg);
endif|#
directive|endif
comment|/* FIXME: We want to try shimm insns for limm ones.  But if 		     the constant won't fit, we must go on to try the next 		     possibility.  Where do we issue warnings for constants 		     that are too big then?  At present, we'll flag the insn 		     as unrecognizable!  Maybe have the "bad instruction" 		     error message include our `errmsg'?  */
if|if
condition|(
name|errmsg
operator|!=
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
condition|)
break|break;
block|}
else|else
name|insn
operator||=
operator|(
name|value
operator|&
operator|(
operator|(
literal|1
operator|<<
name|operand
operator|->
name|bits
operator|)
operator|-
literal|1
operator|)
operator|)
operator|<<
name|operand
operator|->
name|shift
expr_stmt|;
operator|++
name|syn
expr_stmt|;
block|}
block|}
comment|/* If we're at the end of the syntax string, we're done.  */
comment|/* FIXME: try to move this to a separate function.  */
if|if
condition|(
operator|*
name|syn
operator|==
literal|'\0'
condition|)
block|{
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|f
decl_stmt|;
name|long
name|limm
decl_stmt|,
name|limm_p
decl_stmt|;
comment|/* For the moment we assume a valid `str' can only contain blanks 	     now.  IE: We needn't try again with a longer version of the 	     insn and it is assumed that longer versions of insns appear 	     before shorter ones (eg: lsr r2,r3,1 vs lsr r2,r3).  */
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|str
argument_list|)
condition|)
operator|++
name|str
expr_stmt|;
if|if
condition|(
operator|*
name|str
operator|!=
literal|'\0'
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"junk at end of line: `%s'"
argument_list|)
argument_list|,
name|str
argument_list|)
expr_stmt|;
comment|/* Is there a limm value?  */
name|limm_p
operator|=
name|arc_opcode_limm_p
argument_list|(
operator|&
name|limm
argument_list|)
expr_stmt|;
comment|/* Perform various error and warning tests.  */
block|{
specifier|static
name|int
name|in_delay_slot_p
init|=
literal|0
decl_stmt|;
specifier|static
name|int
name|prev_insn_needs_cc_nop_p
init|=
literal|0
decl_stmt|;
comment|/* delay slot type seen */
name|int
name|delay_slot_type
init|=
name|ARC_DELAY_NONE
decl_stmt|;
comment|/* conditional execution flag seen */
name|int
name|conditional
init|=
literal|0
decl_stmt|;
comment|/* 1 if condition codes are being set */
name|int
name|cc_set_p
init|=
literal|0
decl_stmt|;
comment|/* 1 if conditional branch, including `b' "branch always" */
name|int
name|cond_branch_p
init|=
name|opcode
operator|->
name|flags
operator|&
name|ARC_OPCODE_COND_BRANCH
decl_stmt|;
name|int
name|need_cc_nop_p
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_suffixes
condition|;
operator|++
name|i
control|)
block|{
switch|switch
condition|(
name|arc_operands
index|[
name|insn_suffixes
index|[
name|i
index|]
operator|->
name|type
index|]
operator|.
name|fmt
condition|)
block|{
case|case
literal|'n'
case|:
name|delay_slot_type
operator|=
name|insn_suffixes
index|[
name|i
index|]
operator|->
name|value
expr_stmt|;
break|break;
case|case
literal|'q'
case|:
name|conditional
operator|=
name|insn_suffixes
index|[
name|i
index|]
operator|->
name|value
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|cc_set_p
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
comment|/* Putting an insn with a limm value in a delay slot is supposed to 	       be legal, but let's warn the user anyway.  Ditto for 8 byte 	       jumps with delay slots.  */
if|if
condition|(
name|in_delay_slot_p
operator|&&
name|limm_p
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"8 byte instruction in delay slot"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|delay_slot_type
operator|!=
name|ARC_DELAY_NONE
operator|&&
name|limm_p
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"8 byte jump instruction with delay slot"
argument_list|)
argument_list|)
expr_stmt|;
name|in_delay_slot_p
operator|=
operator|(
name|delay_slot_type
operator|!=
name|ARC_DELAY_NONE
operator|)
operator|&&
operator|!
name|limm_p
expr_stmt|;
comment|/* Warn when a conditional branch immediately follows a set of 	       the condition codes.  Note that this needn't be done if the 	       insn that sets the condition codes uses a limm.  */
if|if
condition|(
name|cond_branch_p
operator|&&
name|conditional
operator|!=
literal|0
comment|/* 0 = "always" */
operator|&&
name|prev_insn_needs_cc_nop_p
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"conditional branch follows set of flags"
argument_list|)
argument_list|)
expr_stmt|;
name|prev_insn_needs_cc_nop_p
operator|=
name|cc_set_p
operator|&&
operator|!
name|limm_p
expr_stmt|;
block|}
comment|/* Write out the instruction. 	     It is important to fetch enough space in one call to `frag_more'. 	     We use (f - frag_now->fr_literal) to compute where we are and we 	     don't want frag_now to change between calls.  */
if|if
condition|(
name|limm_p
condition|)
block|{
name|f
operator|=
name|frag_more
argument_list|(
literal|8
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|f
argument_list|,
name|insn
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|f
operator|+
literal|4
argument_list|,
name|limm
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|limm_reloc_p
condition|)
block|{
comment|/* We need a limm reloc, but the tables think we don't.  */
name|abort
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|f
operator|=
name|frag_more
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|f
argument_list|,
name|insn
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
comment|/* Create any fixups.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|fc
condition|;
operator|++
name|i
control|)
block|{
name|int
name|op_type
decl_stmt|,
name|reloc_type
decl_stmt|;
name|expressionS
name|exptmp
decl_stmt|;
specifier|const
name|struct
name|arc_operand
modifier|*
name|operand
decl_stmt|;
comment|/* Create a fixup for this operand. 		 At this point we do not use a bfd_reloc_code_real_type for 		 operands residing in the insn, but instead just use the 		 operand index.  This lets us easily handle fixups for any 		 operand type, although that is admittedly not a very exciting 		 feature.  We pick a BFD reloc type in md_apply_fix.  		 Limm values (4 byte immediate "constants") must be treated 		 normally because they're not part of the actual insn word 		 and thus the insertion routines don't handle them.  */
if|if
condition|(
name|arc_operands
index|[
name|fixups
index|[
name|i
index|]
operator|.
name|opindex
index|]
operator|.
name|flags
operator|&
name|ARC_OPERAND_LIMM
condition|)
block|{
name|op_type
operator|=
name|fixups
index|[
name|i
index|]
operator|.
name|opindex
expr_stmt|;
comment|/* FIXME: can we add this data to the operand table?  */
if|if
condition|(
name|op_type
operator|==
name|arc_operand_map
index|[
literal|'L'
index|]
condition|)
name|reloc_type
operator|=
name|BFD_RELOC_32
expr_stmt|;
elseif|else
if|if
condition|(
name|op_type
operator|==
name|arc_operand_map
index|[
literal|'J'
index|]
condition|)
name|reloc_type
operator|=
name|BFD_RELOC_ARC_B26
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
name|reloc_type
operator|=
name|get_arc_exp_reloc_type
argument_list|(
literal|1
argument_list|,
name|reloc_type
argument_list|,
operator|&
name|fixups
index|[
name|i
index|]
operator|.
name|exp
argument_list|,
operator|&
name|exptmp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|op_type
operator|=
name|get_arc_exp_reloc_type
argument_list|(
literal|0
argument_list|,
name|fixups
index|[
name|i
index|]
operator|.
name|opindex
argument_list|,
operator|&
name|fixups
index|[
name|i
index|]
operator|.
name|exp
argument_list|,
operator|&
name|exptmp
argument_list|)
expr_stmt|;
name|reloc_type
operator|=
name|op_type
operator|+
operator|(
name|int
operator|)
name|BFD_RELOC_UNUSED
expr_stmt|;
block|}
name|operand
operator|=
operator|&
name|arc_operands
index|[
name|op_type
index|]
expr_stmt|;
name|fix_new_exp
argument_list|(
name|frag_now
argument_list|,
operator|(
operator|(
name|f
operator|-
name|frag_now
operator|->
name|fr_literal
operator|)
operator|+
operator|(
name|operand
operator|->
name|flags
operator|&
name|ARC_OPERAND_LIMM
condition|?
literal|4
else|:
literal|0
operator|)
operator|)
argument_list|,
literal|4
argument_list|,
operator|&
name|exptmp
argument_list|,
operator|(
name|operand
operator|->
name|flags
operator|&
name|ARC_OPERAND_RELATIVE_BRANCH
operator|)
operator|!=
literal|0
argument_list|,
operator|(
name|bfd_reloc_code_real_type
operator|)
name|reloc_type
argument_list|)
expr_stmt|;
block|}
comment|/* All done.  */
return|return;
block|}
comment|/* Try the next entry.  */
block|}
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"bad instruction `%s'"
argument_list|)
argument_list|,
name|start
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* ??? This was copied from tc-sparc.c, I think.  Is it necessary?  */
end_comment

begin_function
specifier|static
name|void
name|arc_common
parameter_list|(
name|ignore
parameter_list|)
name|int
name|ignore
decl_stmt|;
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|char
name|c
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|temp
decl_stmt|,
name|size
decl_stmt|;
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
name|name
operator|=
name|input_line_pointer
expr_stmt|;
name|c
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
comment|/* just after name is now '\0' */
name|p
operator|=
name|input_line_pointer
expr_stmt|;
operator|*
name|p
operator|=
name|c
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|!=
literal|','
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"expected comma after symbol-name"
argument_list|)
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
name|input_line_pointer
operator|++
expr_stmt|;
comment|/* skip ',' */
if|if
condition|(
operator|(
name|temp
operator|=
name|get_absolute_expression
argument_list|()
operator|)
operator|<
literal|0
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|".COMMon length (%d.)<0! Ignored."
argument_list|)
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
name|size
operator|=
name|temp
expr_stmt|;
operator|*
name|p
operator|=
literal|0
expr_stmt|;
name|symbolP
operator|=
name|symbol_find_or_make
argument_list|(
name|name
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|S_IS_DEFINED
argument_list|(
name|symbolP
argument_list|)
operator|&&
operator|!
name|S_IS_COMMON
argument_list|(
name|symbolP
argument_list|)
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"ignoring attempt to re-define symbol"
argument_list|)
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|S_GET_VALUE
argument_list|(
name|symbolP
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|S_GET_VALUE
argument_list|(
name|symbolP
argument_list|)
operator|!=
name|size
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"Length of .comm \"%s\" is already %ld. Not changed to %d."
argument_list|)
argument_list|,
name|S_GET_NAME
argument_list|(
name|symbolP
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|S_GET_VALUE
argument_list|(
name|symbolP
argument_list|)
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
block|}
name|assert
argument_list|(
name|symbol_get_frag
argument_list|(
name|symbolP
argument_list|)
operator|==
operator|&
name|zero_address_frag
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|!=
literal|','
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"expected comma after common length"
argument_list|)
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
name|input_line_pointer
operator|++
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|!=
literal|'"'
condition|)
block|{
name|temp
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
if|if
condition|(
name|temp
operator|<
literal|0
condition|)
block|{
name|temp
operator|=
literal|0
expr_stmt|;
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"Common alignment negative; 0 assumed"
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|symbolP
operator|->
name|local
condition|)
block|{
name|segT
name|old_sec
decl_stmt|;
name|int
name|old_subsec
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|align
decl_stmt|;
name|allocate_bss
label|:
name|old_sec
operator|=
name|now_seg
expr_stmt|;
name|old_subsec
operator|=
name|now_subseg
expr_stmt|;
name|align
operator|=
name|temp
expr_stmt|;
name|record_alignment
argument_list|(
name|bss_section
argument_list|,
name|align
argument_list|)
expr_stmt|;
name|subseg_set
argument_list|(
name|bss_section
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|align
condition|)
name|frag_align
argument_list|(
name|align
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|S_GET_SEGMENT
argument_list|(
name|symbolP
argument_list|)
operator|==
name|bss_section
condition|)
name|symbol_get_frag
argument_list|(
name|symbolP
argument_list|)
operator|->
name|fr_symbol
operator|=
literal|0
expr_stmt|;
name|symbol_set_frag
argument_list|(
name|symbolP
argument_list|,
name|frag_now
argument_list|)
expr_stmt|;
name|p
operator|=
name|frag_var
argument_list|(
name|rs_org
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
operator|(
name|relax_substateT
operator|)
literal|0
argument_list|,
name|symbolP
argument_list|,
operator|(
name|offsetT
operator|)
name|size
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
literal|0
expr_stmt|;
name|S_SET_SEGMENT
argument_list|(
name|symbolP
argument_list|,
name|bss_section
argument_list|)
expr_stmt|;
name|S_CLEAR_EXTERNAL
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
name|subseg_set
argument_list|(
name|old_sec
argument_list|,
name|old_subsec
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|allocate_common
label|:
name|S_SET_VALUE
argument_list|(
name|symbolP
argument_list|,
operator|(
name|valueT
operator|)
name|size
argument_list|)
expr_stmt|;
name|S_SET_ALIGN
argument_list|(
name|symbolP
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|S_SET_EXTERNAL
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
name|S_SET_SEGMENT
argument_list|(
name|symbolP
argument_list|,
name|bfd_com_section_ptr
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|input_line_pointer
operator|++
expr_stmt|;
comment|/* ??? Some say data, some say bss.  */
if|if
condition|(
name|strncmp
argument_list|(
name|input_line_pointer
argument_list|,
literal|".bss\""
argument_list|,
literal|5
argument_list|)
operator|&&
name|strncmp
argument_list|(
name|input_line_pointer
argument_list|,
literal|".data\""
argument_list|,
literal|6
argument_list|)
condition|)
block|{
name|input_line_pointer
operator|--
expr_stmt|;
goto|goto
name|bad_common_segment
goto|;
block|}
while|while
condition|(
operator|*
name|input_line_pointer
operator|++
operator|!=
literal|'"'
condition|)
empty_stmt|;
goto|goto
name|allocate_common
goto|;
block|}
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|{
name|bad_common_segment
label|:
name|p
operator|=
name|input_line_pointer
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|&&
operator|*
name|p
operator|!=
literal|'\n'
condition|)
name|p
operator|++
expr_stmt|;
name|c
operator|=
operator|*
name|p
expr_stmt|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"bad .common segment %s"
argument_list|)
argument_list|,
name|input_line_pointer
operator|+
literal|1
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
name|c
expr_stmt|;
name|input_line_pointer
operator|=
name|p
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
block|}
end_function

begin_comment
comment|/* Select the cpu we're assembling for.  */
end_comment

begin_function
specifier|static
name|void
name|arc_cpu
parameter_list|(
name|ignore
parameter_list|)
name|int
name|ignore
decl_stmt|;
block|{
name|int
name|mach
decl_stmt|;
name|char
name|c
decl_stmt|;
name|char
modifier|*
name|cpu
decl_stmt|;
comment|/* If an instruction has already been seen, it's too late.  */
if|if
condition|(
name|cpu_tables_init_p
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|".cpu command must appear before any instructions"
argument_list|)
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
name|cpu
operator|=
name|input_line_pointer
expr_stmt|;
name|c
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
name|mach
operator|=
name|arc_get_mach
argument_list|(
name|cpu
argument_list|)
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|mach
operator|==
operator|-
literal|1
condition|)
goto|goto
name|bad_cpu
goto|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
comment|/* The cpu may have been selected on the command line.      The choices must match.  */
comment|/* ??? This was a command line option early on.  It's gone now, but      leave this in.  */
if|if
condition|(
name|mach_type_specified_p
operator|&&
name|mach
operator|!=
name|arc_mach_type
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|".cpu conflicts with previous value"
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|arc_mach_type
operator|=
name|mach
expr_stmt|;
name|mach_type_specified_p
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_set_arch_mach
argument_list|(
name|stdoutput
argument_list|,
name|bfd_arch_arc
argument_list|,
name|mach
argument_list|)
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"could not set architecture and machine"
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return;
name|bad_cpu
label|:
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"bad .cpu op"
argument_list|)
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* The .rename pseudo-op.  This is used by gcc to implement    -mmangle-cpu-libgcc.  */
end_comment

begin_endif
unit|static void arc_rename (ignore)      int ignore; {   char *name,*new;   char c;   symbolS *sym;   int len;    name = input_line_pointer;   c = get_symbol_end ();   sym = symbol_find_or_make (name);   *input_line_pointer = c;    if (*input_line_pointer != ',')     {       as_bad (_("missing rename string"));       ignore_rest_of_line ();       return;     }   ++input_line_pointer;   SKIP_WHITESPACE ();    name = input_line_pointer;   c = get_symbol_end ();   if (*name == '\0')     {       *input_line_pointer = c;       as_bad (_("invalid symbol to rename to"));       ignore_rest_of_line ();       return;     }   new = (char *) xmalloc (strlen (name) + 1);   strcpy (new, name);   *input_line_pointer = c;   symbol_get_tc (sym)->real_name = new;    demand_empty_rest_of_line (); }
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* Turn a string in input_line_pointer into a floating point constant of type    type, and store the appropriate bytes in *litP.  The number of LITTLENUMS    emitted is stored in *sizeP.    An error message is returned, or NULL on OK.  */
end_comment

begin_comment
comment|/* Equal to MAX_PRECISION in atof-ieee.c */
end_comment

begin_define
define|#
directive|define
name|MAX_LITTLENUMS
value|6
end_define

begin_function
name|char
modifier|*
name|md_atof
parameter_list|(
name|type
parameter_list|,
name|litP
parameter_list|,
name|sizeP
parameter_list|)
name|char
name|type
decl_stmt|;
name|char
modifier|*
name|litP
decl_stmt|;
name|int
modifier|*
name|sizeP
decl_stmt|;
block|{
name|int
name|prec
decl_stmt|;
name|LITTLENUM_TYPE
name|words
index|[
name|MAX_LITTLENUMS
index|]
decl_stmt|;
name|LITTLENUM_TYPE
modifier|*
name|wordP
decl_stmt|;
name|char
modifier|*
name|t
decl_stmt|;
name|char
modifier|*
name|atof_ieee
parameter_list|()
function_decl|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
literal|'f'
case|:
case|case
literal|'F'
case|:
name|prec
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
case|case
literal|'D'
case|:
name|prec
operator|=
literal|4
expr_stmt|;
break|break;
default|default:
operator|*
name|sizeP
operator|=
literal|0
expr_stmt|;
return|return
name|_
argument_list|(
literal|"bad call to md_atof"
argument_list|)
return|;
block|}
name|t
operator|=
name|atof_ieee
argument_list|(
name|input_line_pointer
argument_list|,
name|type
argument_list|,
name|words
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
condition|)
name|input_line_pointer
operator|=
name|t
expr_stmt|;
operator|*
name|sizeP
operator|=
name|prec
operator|*
sizeof|sizeof
argument_list|(
name|LITTLENUM_TYPE
argument_list|)
expr_stmt|;
for|for
control|(
name|wordP
operator|=
name|words
init|;
name|prec
operator|--
condition|;
control|)
block|{
name|md_number_to_chars
argument_list|(
name|litP
argument_list|,
call|(
name|valueT
call|)
argument_list|(
operator|*
name|wordP
operator|++
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|LITTLENUM_TYPE
argument_list|)
argument_list|)
expr_stmt|;
name|litP
operator|+=
sizeof|sizeof
argument_list|(
name|LITTLENUM_TYPE
argument_list|)
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Write a value out to the object file, using the appropriate    endianness.  */
end_comment

begin_function
name|void
name|md_number_to_chars
parameter_list|(
name|buf
parameter_list|,
name|val
parameter_list|,
name|n
parameter_list|)
name|char
modifier|*
name|buf
decl_stmt|;
name|valueT
name|val
decl_stmt|;
name|int
name|n
decl_stmt|;
block|{
if|if
condition|(
name|target_big_endian
condition|)
name|number_to_chars_bigendian
argument_list|(
name|buf
argument_list|,
name|val
argument_list|,
name|n
argument_list|)
expr_stmt|;
else|else
name|number_to_chars_littleendian
argument_list|(
name|buf
argument_list|,
name|val
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Round up a section size to the appropriate boundary. */
end_comment

begin_function
name|valueT
name|md_section_align
parameter_list|(
name|segment
parameter_list|,
name|size
parameter_list|)
name|segT
name|segment
decl_stmt|;
name|valueT
name|size
decl_stmt|;
block|{
name|int
name|align
init|=
name|bfd_get_section_alignment
argument_list|(
name|stdoutput
argument_list|,
name|segment
argument_list|)
decl_stmt|;
return|return
operator|(
operator|(
name|size
operator|+
operator|(
literal|1
operator|<<
name|align
operator|)
operator|-
literal|1
operator|)
operator|&
operator|(
operator|-
literal|1
operator|<<
name|align
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* We don't have any form of relaxing.  */
end_comment

begin_function
name|int
name|md_estimate_size_before_relax
parameter_list|(
name|fragp
parameter_list|,
name|seg
parameter_list|)
name|fragS
modifier|*
name|fragp
decl_stmt|;
name|asection
modifier|*
name|seg
decl_stmt|;
block|{
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Convert a machine dependent frag.  We never generate these.  */
end_comment

begin_function
name|void
name|md_convert_frag
parameter_list|(
name|abfd
parameter_list|,
name|sec
parameter_list|,
name|fragp
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|fragS
modifier|*
name|fragp
decl_stmt|;
block|{
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Parse an operand that is machine-specific.     The ARC has a special %-op to adjust addresses so they're usable in    branches.  The "st" is short for the STatus register.    ??? Later expand this to take a flags value too.     ??? We can't create new expression types so we map the %-op's onto the    existing syntax.  This means that the user could use the chosen syntax    to achieve the same effect.  Perhaps put a special cookie in X_add_number    to mark the expression as special.  */
end_comment

begin_function
name|void
name|md_operand
parameter_list|(
name|expressionP
parameter_list|)
name|expressionS
modifier|*
name|expressionP
decl_stmt|;
block|{
name|char
modifier|*
name|p
init|=
name|input_line_pointer
decl_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'%'
operator|&&
name|strncmp
argument_list|(
name|p
argument_list|,
literal|"%st("
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
block|{
name|input_line_pointer
operator|+=
literal|4
expr_stmt|;
name|expression
argument_list|(
name|expressionP
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|!=
literal|')'
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"missing ')' in %-op"
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
operator|++
name|input_line_pointer
expr_stmt|;
if|if
condition|(
name|expressionP
operator|->
name|X_op
operator|==
name|O_symbol
operator|&&
name|expressionP
operator|->
name|X_add_number
operator|==
literal|0
comment|/* I think this test is unnecessary but just as a sanity check... */
operator|&&
name|expressionP
operator|->
name|X_op_symbol
operator|==
name|NULL
condition|)
block|{
name|expressionS
name|two
decl_stmt|;
name|expressionP
operator|->
name|X_op
operator|=
name|O_right_shift
expr_stmt|;
name|two
operator|.
name|X_op
operator|=
name|O_constant
expr_stmt|;
name|two
operator|.
name|X_add_symbol
operator|=
name|two
operator|.
name|X_op_symbol
operator|=
name|NULL
expr_stmt|;
name|two
operator|.
name|X_add_number
operator|=
literal|2
expr_stmt|;
name|expressionP
operator|->
name|X_op_symbol
operator|=
name|make_expr_symbol
argument_list|(
operator|&
name|two
argument_list|)
expr_stmt|;
block|}
comment|/* allow %st(sym1-sym2) */
elseif|else
if|if
condition|(
name|expressionP
operator|->
name|X_op
operator|==
name|O_subtract
operator|&&
name|expressionP
operator|->
name|X_add_symbol
operator|!=
name|NULL
operator|&&
name|expressionP
operator|->
name|X_op_symbol
operator|!=
name|NULL
operator|&&
name|expressionP
operator|->
name|X_add_number
operator|==
literal|0
condition|)
block|{
name|expressionS
name|two
decl_stmt|;
name|expressionP
operator|->
name|X_add_symbol
operator|=
name|make_expr_symbol
argument_list|(
name|expressionP
argument_list|)
expr_stmt|;
name|expressionP
operator|->
name|X_op
operator|=
name|O_right_shift
expr_stmt|;
name|two
operator|.
name|X_op
operator|=
name|O_constant
expr_stmt|;
name|two
operator|.
name|X_add_symbol
operator|=
name|two
operator|.
name|X_op_symbol
operator|=
name|NULL
expr_stmt|;
name|two
operator|.
name|X_add_number
operator|=
literal|2
expr_stmt|;
name|expressionP
operator|->
name|X_op_symbol
operator|=
name|make_expr_symbol
argument_list|(
operator|&
name|two
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"expression too complex for %%st"
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
end_function

begin_comment
comment|/* We have no need to default values of symbols.    We could catch register names here, but that is handled by inserting    them all in the symbol table to begin with.  */
end_comment

begin_function
name|symbolS
modifier|*
name|md_undefined_symbol
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Functions concerning expressions.  */
end_comment

begin_comment
comment|/* Parse a .byte, .word, etc. expression.     Values for the status register are specified with %st(label).    `label' will be right shifted by 2.  */
end_comment

begin_function
name|void
name|arc_parse_cons_expression
parameter_list|(
name|exp
parameter_list|,
name|nbytes
parameter_list|)
name|expressionS
modifier|*
name|exp
decl_stmt|;
name|int
name|nbytes
decl_stmt|;
block|{
name|expr
argument_list|(
literal|0
argument_list|,
name|exp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Record a fixup for a cons expression.  */
end_comment

begin_function
name|void
name|arc_cons_fix_new
parameter_list|(
name|frag
parameter_list|,
name|where
parameter_list|,
name|nbytes
parameter_list|,
name|exp
parameter_list|)
name|fragS
modifier|*
name|frag
decl_stmt|;
name|int
name|where
decl_stmt|;
name|int
name|nbytes
decl_stmt|;
name|expressionS
modifier|*
name|exp
decl_stmt|;
block|{
if|if
condition|(
name|nbytes
operator|==
literal|4
condition|)
block|{
name|int
name|reloc_type
decl_stmt|;
name|expressionS
name|exptmp
decl_stmt|;
comment|/* This may be a special ARC reloc (eg: %st()).  */
name|reloc_type
operator|=
name|get_arc_exp_reloc_type
argument_list|(
literal|1
argument_list|,
name|BFD_RELOC_32
argument_list|,
name|exp
argument_list|,
operator|&
name|exptmp
argument_list|)
expr_stmt|;
name|fix_new_exp
argument_list|(
name|frag
argument_list|,
name|where
argument_list|,
name|nbytes
argument_list|,
operator|&
name|exptmp
argument_list|,
literal|0
argument_list|,
name|reloc_type
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fix_new_exp
argument_list|(
name|frag
argument_list|,
name|where
argument_list|,
name|nbytes
argument_list|,
name|exp
argument_list|,
literal|0
argument_list|,
name|nbytes
operator|==
literal|2
condition|?
name|BFD_RELOC_16
else|:
name|nbytes
operator|==
literal|8
condition|?
name|BFD_RELOC_64
else|:
name|BFD_RELOC_32
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Functions concerning relocs.  */
end_comment

begin_comment
comment|/* The location from which a PC relative jump should be calculated,    given a PC relative reloc.  */
end_comment

begin_function
name|long
name|md_pcrel_from
parameter_list|(
name|fixP
parameter_list|)
name|fixS
modifier|*
name|fixP
decl_stmt|;
block|{
if|if
condition|(
name|fixP
operator|->
name|fx_addsy
operator|!=
operator|(
name|symbolS
operator|*
operator|)
name|NULL
operator|&&
operator|!
name|S_IS_DEFINED
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
condition|)
block|{
comment|/* The symbol is undefined.  Let the linker figure it out.  */
return|return
literal|0
return|;
block|}
comment|/* Return the address of the delay slot.  */
return|return
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_address
operator|+
name|fixP
operator|->
name|fx_where
operator|+
name|fixP
operator|->
name|fx_size
return|;
block|}
end_function

begin_comment
comment|/* Compute the reloc type of an expression.    The possibly modified expression is stored in EXPNEW.     This is used to convert the expressions generated by the %-op's into    the appropriate operand type.  It is called for both data in instructions    (operands) and data outside instructions (variables, debugging info, etc.).     Currently supported %-ops:     %st(symbol): represented as "symbol>> 2"                 "st" is short for STatus as in the status register (pc)     DEFAULT_TYPE is the type to use if no special processing is required.     DATA_P is non-zero for data or limm values, zero for insn operands.    Remember that the opcode "insertion fns" cannot be used on data, they're    only for inserting operands into insns.  They also can't be used for limm    values as the insertion routines don't handle limm values.  When called for    insns we return fudged reloc types (real_value - BFD_RELOC_UNUSED).  When    called for data or limm values we use real reloc types.  */
end_comment

begin_function
specifier|static
name|int
name|get_arc_exp_reloc_type
parameter_list|(
name|data_p
parameter_list|,
name|default_type
parameter_list|,
name|exp
parameter_list|,
name|expnew
parameter_list|)
name|int
name|data_p
decl_stmt|;
name|int
name|default_type
decl_stmt|;
name|expressionS
modifier|*
name|exp
decl_stmt|;
name|expressionS
modifier|*
name|expnew
decl_stmt|;
block|{
comment|/* If the expression is "symbol>> 2" we must change it to just "symbol",      as fix_new_exp can't handle it.  Similarily for (symbol - symbol)>> 2.      That's ok though.  What's really going on here is that we're using      ">> 2" as a special syntax for specifying BFD_RELOC_ARC_B26.  */
if|if
condition|(
name|exp
operator|->
name|X_op
operator|==
name|O_right_shift
operator|&&
name|exp
operator|->
name|X_op_symbol
operator|!=
name|NULL
operator|&&
name|symbol_constant_p
argument_list|(
name|exp
operator|->
name|X_op_symbol
argument_list|)
operator|&&
name|S_GET_VALUE
argument_list|(
name|exp
operator|->
name|X_op_symbol
argument_list|)
operator|==
literal|2
operator|&&
name|exp
operator|->
name|X_add_number
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|exp
operator|->
name|X_add_symbol
operator|!=
name|NULL
operator|&&
operator|(
name|symbol_constant_p
argument_list|(
name|exp
operator|->
name|X_add_symbol
argument_list|)
operator|||
name|symbol_equated_p
argument_list|(
name|exp
operator|->
name|X_add_symbol
argument_list|)
operator|)
condition|)
block|{
operator|*
name|expnew
operator|=
operator|*
name|exp
expr_stmt|;
name|expnew
operator|->
name|X_op
operator|=
name|O_symbol
expr_stmt|;
name|expnew
operator|->
name|X_op_symbol
operator|=
name|NULL
expr_stmt|;
return|return
name|data_p
condition|?
name|BFD_RELOC_ARC_B26
else|:
name|arc_operand_map
index|[
literal|'J'
index|]
return|;
block|}
elseif|else
if|if
condition|(
name|exp
operator|->
name|X_add_symbol
operator|!=
name|NULL
operator|&&
operator|(
name|symbol_get_value_expression
argument_list|(
name|exp
operator|->
name|X_add_symbol
argument_list|)
operator|->
name|X_op
operator|==
name|O_subtract
operator|)
condition|)
block|{
operator|*
name|expnew
operator|=
operator|*
name|symbol_get_value_expression
argument_list|(
name|exp
operator|->
name|X_add_symbol
argument_list|)
expr_stmt|;
return|return
name|data_p
condition|?
name|BFD_RELOC_ARC_B26
else|:
name|arc_operand_map
index|[
literal|'J'
index|]
return|;
block|}
block|}
operator|*
name|expnew
operator|=
operator|*
name|exp
expr_stmt|;
return|return
name|default_type
return|;
block|}
end_function

begin_comment
comment|/* Apply a fixup to the object code.  This is called for all the    fixups we generated by the call to fix_new_exp, above.  In the call    above we used a reloc code which was the largest legal reloc code    plus the operand index.  Here we undo that to recover the operand    index.  At this point all symbol values should be fully resolved,    and we attempt to completely resolve the reloc.  If we can not do    that, we determine the correct reloc code and put it back in the fixup.  */
end_comment

begin_function
name|int
name|md_apply_fix3
parameter_list|(
name|fixP
parameter_list|,
name|valueP
parameter_list|,
name|seg
parameter_list|)
name|fixS
modifier|*
name|fixP
decl_stmt|;
name|valueT
modifier|*
name|valueP
decl_stmt|;
name|segT
name|seg
decl_stmt|;
block|{
comment|/*char *buf = fixP->fx_where + fixP->fx_frag->fr_literal;*/
name|valueT
name|value
decl_stmt|;
comment|/* FIXME FIXME FIXME: The value we are passed in *valueP includes      the symbol values.  Since we are using BFD_ASSEMBLER, if we are      doing this relocation the code in write.c is going to call      bfd_perform_relocation, which is also going to use the symbol      value.  That means that if the reloc is fully resolved we want to      use *valueP since bfd_perform_relocation is not being used.      However, if the reloc is not fully resolved we do not want to use      *valueP, and must use fx_offset instead.  However, if the reloc      is PC relative, we do want to use *valueP since it includes the      result of md_pcrel_from.  This is confusing.  */
if|if
condition|(
name|fixP
operator|->
name|fx_addsy
operator|==
operator|(
name|symbolS
operator|*
operator|)
name|NULL
condition|)
block|{
name|value
operator|=
operator|*
name|valueP
expr_stmt|;
name|fixP
operator|->
name|fx_done
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fixP
operator|->
name|fx_pcrel
condition|)
block|{
name|value
operator|=
operator|*
name|valueP
expr_stmt|;
comment|/* ELF relocations are against symbols. 	 If this symbol is in a different section then we need to leave it for 	 the linker to deal with.  Unfortunately, md_pcrel_from can't tell, 	 so we have to undo it's effects here.  */
if|if
condition|(
name|S_IS_DEFINED
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
operator|&&
name|S_GET_SEGMENT
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
operator|!=
name|seg
condition|)
name|value
operator|+=
name|md_pcrel_from
argument_list|(
name|fixP
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|value
operator|=
name|fixP
operator|->
name|fx_offset
expr_stmt|;
if|if
condition|(
name|fixP
operator|->
name|fx_subsy
operator|!=
operator|(
name|symbolS
operator|*
operator|)
name|NULL
condition|)
block|{
if|if
condition|(
name|S_GET_SEGMENT
argument_list|(
name|fixP
operator|->
name|fx_subsy
argument_list|)
operator|==
name|absolute_section
condition|)
name|value
operator|-=
name|S_GET_VALUE
argument_list|(
name|fixP
operator|->
name|fx_subsy
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* We can't actually support subtracting a symbol.  */
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"expression too complex"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|(
name|int
operator|)
name|fixP
operator|->
name|fx_r_type
operator|>=
operator|(
name|int
operator|)
name|BFD_RELOC_UNUSED
condition|)
block|{
name|int
name|opindex
decl_stmt|;
specifier|const
name|struct
name|arc_operand
modifier|*
name|operand
decl_stmt|;
name|char
modifier|*
name|where
decl_stmt|;
name|arc_insn
name|insn
decl_stmt|;
name|opindex
operator|=
operator|(
name|int
operator|)
name|fixP
operator|->
name|fx_r_type
operator|-
operator|(
name|int
operator|)
name|BFD_RELOC_UNUSED
expr_stmt|;
name|operand
operator|=
operator|&
name|arc_operands
index|[
name|opindex
index|]
expr_stmt|;
comment|/* Fetch the instruction, insert the fully resolved operand 	 value, and stuff the instruction back again.  */
name|where
operator|=
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_literal
operator|+
name|fixP
operator|->
name|fx_where
expr_stmt|;
if|if
condition|(
name|target_big_endian
condition|)
name|insn
operator|=
name|bfd_getb32
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|where
argument_list|)
expr_stmt|;
else|else
name|insn
operator|=
name|bfd_getl32
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|where
argument_list|)
expr_stmt|;
name|insn
operator|=
name|arc_insert_operand
argument_list|(
name|insn
argument_list|,
name|operand
argument_list|,
operator|-
literal|1
argument_list|,
name|NULL
argument_list|,
operator|(
name|offsetT
operator|)
name|value
argument_list|,
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|)
expr_stmt|;
if|if
condition|(
name|target_big_endian
condition|)
name|bfd_putb32
argument_list|(
operator|(
name|bfd_vma
operator|)
name|insn
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|where
argument_list|)
expr_stmt|;
else|else
name|bfd_putl32
argument_list|(
operator|(
name|bfd_vma
operator|)
name|insn
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|where
argument_list|)
expr_stmt|;
if|if
condition|(
name|fixP
operator|->
name|fx_done
condition|)
block|{
comment|/* Nothing else to do here.  */
return|return
literal|1
return|;
block|}
comment|/* Determine a BFD reloc value based on the operand information. 	 We are only prepared to turn a few of the operands into relocs. 	 !!! Note that we can't handle limm values here.  Since we're using 	 implicit addends the addend must be inserted into the instruction, 	 however, the opcode insertion routines currently do nothing with 	 limm values.  */
if|if
condition|(
name|operand
operator|->
name|fmt
operator|==
literal|'B'
condition|)
block|{
name|assert
argument_list|(
operator|(
name|operand
operator|->
name|flags
operator|&
name|ARC_OPERAND_RELATIVE_BRANCH
operator|)
operator|!=
literal|0
operator|&&
name|operand
operator|->
name|bits
operator|==
literal|20
operator|&&
name|operand
operator|->
name|shift
operator|==
literal|7
argument_list|)
expr_stmt|;
name|fixP
operator|->
name|fx_r_type
operator|=
name|BFD_RELOC_ARC_B22_PCREL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
literal|0
operator|&&
name|operand
operator|->
name|fmt
operator|==
literal|'J'
condition|)
block|{
name|assert
argument_list|(
operator|(
name|operand
operator|->
name|flags
operator|&
name|ARC_OPERAND_ABSOLUTE_BRANCH
operator|)
operator|!=
literal|0
operator|&&
name|operand
operator|->
name|bits
operator|==
literal|24
operator|&&
name|operand
operator|->
name|shift
operator|==
literal|32
argument_list|)
expr_stmt|;
name|fixP
operator|->
name|fx_r_type
operator|=
name|BFD_RELOC_ARC_B26
expr_stmt|;
block|}
elseif|else
if|if
condition|(
literal|0
operator|&&
name|operand
operator|->
name|fmt
operator|==
literal|'L'
condition|)
block|{
name|assert
argument_list|(
operator|(
name|operand
operator|->
name|flags
operator|&
name|ARC_OPERAND_LIMM
operator|)
operator|!=
literal|0
operator|&&
name|operand
operator|->
name|bits
operator|==
literal|32
operator|&&
name|operand
operator|->
name|shift
operator|==
literal|32
argument_list|)
expr_stmt|;
name|fixP
operator|->
name|fx_r_type
operator|=
name|BFD_RELOC_32
expr_stmt|;
block|}
else|else
block|{
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"unresolved expression that must be resolved"
argument_list|)
argument_list|)
expr_stmt|;
name|fixP
operator|->
name|fx_done
operator|=
literal|1
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
else|else
block|{
switch|switch
condition|(
name|fixP
operator|->
name|fx_r_type
condition|)
block|{
case|case
name|BFD_RELOC_8
case|:
name|md_number_to_chars
argument_list|(
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_literal
operator|+
name|fixP
operator|->
name|fx_where
argument_list|,
name|value
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_16
case|:
name|md_number_to_chars
argument_list|(
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_literal
operator|+
name|fixP
operator|->
name|fx_where
argument_list|,
name|value
argument_list|,
literal|2
argument_list|)
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_32
case|:
name|md_number_to_chars
argument_list|(
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_literal
operator|+
name|fixP
operator|->
name|fx_where
argument_list|,
name|value
argument_list|,
literal|4
argument_list|)
expr_stmt|;
break|break;
if|#
directive|if
literal|0
block|case BFD_RELOC_64: 	  md_number_to_chars (fixP->fx_frag->fr_literal + fixP->fx_where, 			      value, 8); 	  break;
endif|#
directive|endif
case|case
name|BFD_RELOC_ARC_B26
case|:
comment|/* If !fixP->fx_done then `value' is an implicit addend. 	     We must shift it right by 2 in this case as well because the 	     linker performs the relocation and then adds this in (as opposed 	     to adding this in and then shifting right by 2).  */
name|value
operator|>>=
literal|2
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_literal
operator|+
name|fixP
operator|->
name|fx_where
argument_list|,
name|value
argument_list|,
literal|4
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
name|fixP
operator|->
name|fx_addnumber
operator|=
name|value
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Translate internal representation of relocation info to BFD target    format.  */
end_comment

begin_function
name|arelent
modifier|*
name|tc_gen_reloc
parameter_list|(
name|section
parameter_list|,
name|fixP
parameter_list|)
name|asection
modifier|*
name|section
decl_stmt|;
name|fixS
modifier|*
name|fixP
decl_stmt|;
block|{
name|arelent
modifier|*
name|reloc
decl_stmt|;
name|reloc
operator|=
operator|(
name|arelent
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|arelent
argument_list|)
argument_list|)
expr_stmt|;
name|reloc
operator|->
name|sym_ptr_ptr
operator|=
operator|(
name|asymbol
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|asymbol
operator|*
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|reloc
operator|->
name|sym_ptr_ptr
operator|=
name|symbol_get_bfdsym
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
expr_stmt|;
name|reloc
operator|->
name|address
operator|=
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_address
operator|+
name|fixP
operator|->
name|fx_where
expr_stmt|;
name|reloc
operator|->
name|howto
operator|=
name|bfd_reloc_type_lookup
argument_list|(
name|stdoutput
argument_list|,
name|fixP
operator|->
name|fx_r_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|reloc
operator|->
name|howto
operator|==
operator|(
name|reloc_howto_type
operator|*
operator|)
name|NULL
condition|)
block|{
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"internal error: can't export reloc type %d (`%s')"
argument_list|)
argument_list|,
name|fixP
operator|->
name|fx_r_type
argument_list|,
name|bfd_get_reloc_code_name
argument_list|(
name|fixP
operator|->
name|fx_r_type
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|assert
argument_list|(
operator|!
name|fixP
operator|->
name|fx_pcrel
operator|==
operator|!
name|reloc
operator|->
name|howto
operator|->
name|pc_relative
argument_list|)
expr_stmt|;
name|reloc
operator|->
name|addend
operator|=
name|fixP
operator|->
name|fx_addnumber
expr_stmt|;
return|return
name|reloc
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Frobbers.  */
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* Set the real name if the .rename pseudo-op was used.    Return 1 if the symbol should not be included in the symbol table.  */
end_comment

begin_endif
unit|int arc_frob_symbol (sym)      symbolS *sym; {   if (symbol_get_tc (sym)->real_name != (char *) NULL)     S_SET_NAME (sym, symbol_get_tc (sym)->real_name);    return 0; }
endif|#
directive|endif
end_endif

end_unit

