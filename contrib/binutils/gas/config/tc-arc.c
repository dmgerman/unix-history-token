begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* tc-arc.c -- Assembler for the ARC    Copyright 1994, 1995, 1997, 1999, 2000, 2001, 2002    Free Software Foundation, Inc.    Contributed by Doug Evans (dje@cygnus.com).     This file is part of GAS, the GNU Assembler.     GAS is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     GAS is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with GAS; see the file COPYING.  If not, write to the Free    Software Foundation, 59 Temple Place - Suite 330, Boston, MA    02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"libiberty.h"
end_include

begin_include
include|#
directive|include
file|"as.h"
end_include

begin_include
include|#
directive|include
file|"struc-symbol.h"
end_include

begin_include
include|#
directive|include
file|"safe-ctype.h"
end_include

begin_include
include|#
directive|include
file|"subsegs.h"
end_include

begin_include
include|#
directive|include
file|"opcode/arc.h"
end_include

begin_include
include|#
directive|include
file|"../opcodes/arc-ext.h"
end_include

begin_include
include|#
directive|include
file|"elf/arc.h"
end_include

begin_include
include|#
directive|include
file|"dwarf2dbg.h"
end_include

begin_decl_stmt
specifier|extern
name|int
name|arc_get_mach
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|arc_operand_type
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|arc_insn_not_jl
name|PARAMS
argument_list|(
operator|(
name|arc_insn
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|arc_limm_fixup_adjust
name|PARAMS
argument_list|(
operator|(
name|arc_insn
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|arc_get_noshortcut_flag
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|arc_set_ext_seg
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|arc_code_symbol
name|PARAMS
argument_list|(
operator|(
name|expressionS
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|arc_insn
name|arc_insert_operand
name|PARAMS
argument_list|(
operator|(
name|arc_insn
operator|,
specifier|const
expr|struct
name|arc_operand
operator|*
operator|,
name|int
operator|,
specifier|const
expr|struct
name|arc_operand_value
operator|*
operator|,
name|offsetT
operator|,
name|char
operator|*
operator|,
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|arc_common
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|arc_extinst
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|arc_extoper
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|arc_option
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|get_arc_exp_reloc_type
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|,
name|expressionS
operator|*
operator|,
name|expressionS
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|init_opcode_tables
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_struct
specifier|const
struct|struct
name|suffix_classes
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|len
decl_stmt|;
block|}
name|suffixclass
index|[]
init|=
block|{
block|{
literal|"SUFFIX_COND|SUFFIX_FLAG"
block|,
literal|23
block|}
block|,
block|{
literal|"SUFFIX_FLAG"
block|,
literal|11
block|}
block|,
block|{
literal|"SUFFIX_COND"
block|,
literal|11
block|}
block|,
block|{
literal|"SUFFIX_NONE"
block|,
literal|11
block|}
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|MAXSUFFIXCLASS
value|(sizeof (suffixclass) / sizeof (struct suffix_classes))
end_define

begin_struct
specifier|const
struct|struct
name|syntax_classes
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|class
decl_stmt|;
block|}
name|syntaxclass
index|[]
init|=
block|{
block|{
literal|"SYNTAX_3OP|OP1_MUST_BE_IMM"
block|,
literal|26
block|,
name|SYNTAX_3OP
operator||
name|OP1_MUST_BE_IMM
operator||
name|SYNTAX_VALID
block|}
block|,
block|{
literal|"OP1_MUST_BE_IMM|SYNTAX_3OP"
block|,
literal|26
block|,
name|OP1_MUST_BE_IMM
operator||
name|SYNTAX_3OP
operator||
name|SYNTAX_VALID
block|}
block|,
block|{
literal|"SYNTAX_2OP|OP1_IMM_IMPLIED"
block|,
literal|26
block|,
name|SYNTAX_2OP
operator||
name|OP1_IMM_IMPLIED
operator||
name|SYNTAX_VALID
block|}
block|,
block|{
literal|"OP1_IMM_IMPLIED|SYNTAX_2OP"
block|,
literal|26
block|,
name|OP1_IMM_IMPLIED
operator||
name|SYNTAX_2OP
operator||
name|SYNTAX_VALID
block|}
block|,
block|{
literal|"SYNTAX_3OP"
block|,
literal|10
block|,
name|SYNTAX_3OP
operator||
name|SYNTAX_VALID
block|}
block|,
block|{
literal|"SYNTAX_2OP"
block|,
literal|10
block|,
name|SYNTAX_2OP
operator||
name|SYNTAX_VALID
block|}
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|MAXSYNTAXCLASS
value|(sizeof (syntaxclass) / sizeof (struct syntax_classes))
end_define

begin_decl_stmt
specifier|const
name|pseudo_typeS
name|md_pseudo_table
index|[]
init|=
block|{
block|{
literal|"align"
block|,
name|s_align_bytes
block|,
literal|0
block|}
block|,
comment|/* Defaulting is invalid (0).  */
block|{
literal|"comm"
block|,
name|arc_common
block|,
literal|0
block|}
block|,
block|{
literal|"common"
block|,
name|arc_common
block|,
literal|0
block|}
block|,
block|{
literal|"lcomm"
block|,
name|arc_common
block|,
literal|1
block|}
block|,
block|{
literal|"lcommon"
block|,
name|arc_common
block|,
literal|1
block|}
block|,
block|{
literal|"2byte"
block|,
name|cons
block|,
literal|2
block|}
block|,
block|{
literal|"half"
block|,
name|cons
block|,
literal|2
block|}
block|,
block|{
literal|"short"
block|,
name|cons
block|,
literal|2
block|}
block|,
block|{
literal|"3byte"
block|,
name|cons
block|,
literal|3
block|}
block|,
block|{
literal|"4byte"
block|,
name|cons
block|,
literal|4
block|}
block|,
block|{
literal|"word"
block|,
name|cons
block|,
literal|4
block|}
block|,
block|{
literal|"option"
block|,
name|arc_option
block|,
literal|0
block|}
block|,
block|{
literal|"cpu"
block|,
name|arc_option
block|,
literal|0
block|}
block|,
block|{
literal|"block"
block|,
name|s_space
block|,
literal|0
block|}
block|,
block|{
literal|"extcondcode"
block|,
name|arc_extoper
block|,
literal|0
block|}
block|,
block|{
literal|"extcoreregister"
block|,
name|arc_extoper
block|,
literal|1
block|}
block|,
block|{
literal|"extauxregister"
block|,
name|arc_extoper
block|,
literal|2
block|}
block|,
block|{
literal|"extinstruction"
block|,
name|arc_extinst
block|,
literal|0
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This array holds the chars that always start a comment.  If the    pre-processor is disabled, these aren't very useful.  */
end_comment

begin_decl_stmt
specifier|const
name|char
name|comment_chars
index|[]
init|=
literal|"#;"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This array holds the chars that only start a comment at the beginning of    a line.  If the line seems to have the form '# 123 filename'    .line and .file directives will appear in the pre-processed output */
end_comment

begin_comment
comment|/* Note that input_file.c hand checks for '#' at the beginning of the    first line of the input file.  This is because the compiler outputs    #NO_APP at the beginning of its output.  */
end_comment

begin_comment
comment|/* Also note that comments started like this one will always    work if '/' isn't otherwise defined.  */
end_comment

begin_decl_stmt
specifier|const
name|char
name|line_comment_chars
index|[]
init|=
literal|"#"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
name|line_separator_chars
index|[]
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Chars that can be used to separate mant from exp in floating point nums.  */
end_comment

begin_decl_stmt
specifier|const
name|char
name|EXP_CHARS
index|[]
init|=
literal|"eE"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Chars that mean this number is a floating point constant    As in 0f12.456 or 0d1.2345e12.  */
end_comment

begin_decl_stmt
specifier|const
name|char
name|FLT_CHARS
index|[]
init|=
literal|"rRsSfFdD"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Byte order.  */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|target_big_endian
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
modifier|*
name|arc_target_format
init|=
name|DEFAULT_TARGET_FORMAT
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|byte_order
init|=
name|DEFAULT_BYTE_ORDER
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|segT
name|arcext_section
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* One of bfd_mach_arc_n.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|arc_mach_type
init|=
name|bfd_mach_arc_6
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero if the cpu type has been explicitly specified.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|mach_type_specified_p
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero if opcode tables have been initialized.    A .option command must appear before any instructions.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|cpu_tables_init_p
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|hash_control
modifier|*
name|arc_suffix_hash
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_decl_stmt
specifier|const
name|char
modifier|*
name|md_shortopts
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|option
name|md_longopts
index|[]
init|=
block|{
define|#
directive|define
name|OPTION_EB
value|(OPTION_MD_BASE + 0)
block|{
literal|"EB"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_EB
block|}
block|,
define|#
directive|define
name|OPTION_EL
value|(OPTION_MD_BASE + 1)
block|{
literal|"EL"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_EL
block|}
block|,
define|#
directive|define
name|OPTION_ARC5
value|(OPTION_MD_BASE + 2)
block|{
literal|"marc5"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_ARC5
block|}
block|,
block|{
literal|"pre-v6"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_ARC5
block|}
block|,
define|#
directive|define
name|OPTION_ARC6
value|(OPTION_MD_BASE + 3)
block|{
literal|"marc6"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_ARC6
block|}
block|,
define|#
directive|define
name|OPTION_ARC7
value|(OPTION_MD_BASE + 4)
block|{
literal|"marc7"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_ARC7
block|}
block|,
define|#
directive|define
name|OPTION_ARC8
value|(OPTION_MD_BASE + 5)
block|{
literal|"marc8"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_ARC8
block|}
block|,
define|#
directive|define
name|OPTION_ARC
value|(OPTION_MD_BASE + 6)
block|{
literal|"marc"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_ARC
block|}
block|,
block|{
name|NULL
block|,
name|no_argument
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|size_t
name|md_longopts_size
init|=
sizeof|sizeof
argument_list|(
name|md_longopts
argument_list|)
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|IS_SYMBOL_OPERAND
parameter_list|(
name|o
parameter_list|)
define|\
value|((o) == 'b' || (o) == 'c' || (o) == 's' || (o) == 'o' || (o) == 'O')
end_define

begin_function_decl
name|struct
name|arc_operand_value
modifier|*
name|get_ext_suffix
parameter_list|(
name|char
modifier|*
name|s
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Invocation line includes a switch not recognized by the base assembler.    See if it's a processor-specific option.  */
end_comment

begin_function
name|int
name|md_parse_option
parameter_list|(
name|c
parameter_list|,
name|arg
parameter_list|)
name|int
name|c
decl_stmt|;
name|char
modifier|*
name|arg
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
name|OPTION_ARC5
case|:
name|arc_mach_type
operator|=
name|bfd_mach_arc_5
expr_stmt|;
break|break;
case|case
name|OPTION_ARC
case|:
case|case
name|OPTION_ARC6
case|:
name|arc_mach_type
operator|=
name|bfd_mach_arc_6
expr_stmt|;
break|break;
case|case
name|OPTION_ARC7
case|:
name|arc_mach_type
operator|=
name|bfd_mach_arc_7
expr_stmt|;
break|break;
case|case
name|OPTION_ARC8
case|:
name|arc_mach_type
operator|=
name|bfd_mach_arc_8
expr_stmt|;
break|break;
case|case
name|OPTION_EB
case|:
name|byte_order
operator|=
name|BIG_ENDIAN
expr_stmt|;
name|arc_target_format
operator|=
literal|"elf32-bigarc"
expr_stmt|;
break|break;
case|case
name|OPTION_EL
case|:
name|byte_order
operator|=
name|LITTLE_ENDIAN
expr_stmt|;
name|arc_target_format
operator|=
literal|"elf32-littlearc"
expr_stmt|;
break|break;
default|default:
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
name|void
name|md_show_usage
parameter_list|(
name|stream
parameter_list|)
name|FILE
modifier|*
name|stream
decl_stmt|;
block|{
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\ ARC Options:\n\   -marc[5|6|7|8]          select processor variant (default arc%d)\n\   -EB                     assemble code for a big endian cpu\n\   -EL                     assemble code for a little endian cpu\n"
argument_list|,
name|arc_mach_type
operator|+
literal|5
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This function is called once, at assembler startup time.  It should    set up all the tables, etc. that the MD part of the assembler will need.    Opcode selection is deferred until later because we might see a .option    command.  */
end_comment

begin_function
name|void
name|md_begin
parameter_list|()
block|{
comment|/* The endianness can be chosen "at the factory".  */
name|target_big_endian
operator|=
name|byte_order
operator|==
name|BIG_ENDIAN
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_set_arch_mach
argument_list|(
name|stdoutput
argument_list|,
name|bfd_arch_arc
argument_list|,
name|arc_mach_type
argument_list|)
condition|)
name|as_warn
argument_list|(
literal|"could not set architecture and machine"
argument_list|)
expr_stmt|;
comment|/* This call is necessary because we need to initialize `arc_operand_map'      which may be needed before we see the first insn.  */
name|arc_opcode_init_tables
argument_list|(
name|arc_get_opcode_mach
argument_list|(
name|arc_mach_type
argument_list|,
name|target_big_endian
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Initialize the various opcode and operand tables.    MACH is one of bfd_mach_arc_xxx.  */
end_comment

begin_function
specifier|static
name|void
name|init_opcode_tables
parameter_list|(
name|mach
parameter_list|)
name|int
name|mach
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|last
decl_stmt|;
if|if
condition|(
operator|(
name|arc_suffix_hash
operator|=
name|hash_new
argument_list|()
operator|)
operator|==
name|NULL
condition|)
name|as_fatal
argument_list|(
literal|"virtual memory exhausted"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_set_arch_mach
argument_list|(
name|stdoutput
argument_list|,
name|bfd_arch_arc
argument_list|,
name|mach
argument_list|)
condition|)
name|as_warn
argument_list|(
literal|"could not set architecture and machine"
argument_list|)
expr_stmt|;
comment|/* This initializes a few things in arc-opc.c that we need.      This must be called before the various arc_xxx_supported fns.  */
name|arc_opcode_init_tables
argument_list|(
name|arc_get_opcode_mach
argument_list|(
name|mach
argument_list|,
name|target_big_endian
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Only put the first entry of each equivalently named suffix in the      table.  */
name|last
operator|=
literal|""
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|arc_suffixes_count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|arc_suffixes
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|last
argument_list|)
operator|!=
literal|0
condition|)
name|hash_insert
argument_list|(
name|arc_suffix_hash
argument_list|,
name|arc_suffixes
index|[
name|i
index|]
operator|.
name|name
argument_list|,
call|(
name|PTR
call|)
argument_list|(
name|arc_suffixes
operator|+
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|last
operator|=
name|arc_suffixes
index|[
name|i
index|]
operator|.
name|name
expr_stmt|;
block|}
comment|/* Since registers don't have a prefix, we put them in the symbol table so      they can't be used as symbols.  This also simplifies argument parsing as      we can let gas parse registers for us.  The recorded register number is      the address of the register's entry in arc_reg_names.       If the register name is already in the table, then the existing      definition is assumed to be from an .ExtCoreRegister pseudo-op.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|arc_reg_names_count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|symbol_find
argument_list|(
name|arc_reg_names
index|[
name|i
index|]
operator|.
name|name
argument_list|)
condition|)
continue|continue;
comment|/* Use symbol_create here instead of symbol_new so we don't try to 	 output registers into the object file's symbol table.  */
name|symbol_table_insert
argument_list|(
name|symbol_create
argument_list|(
name|arc_reg_names
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|reg_section
argument_list|,
operator|(
name|int
operator|)
operator|&
name|arc_reg_names
index|[
name|i
index|]
argument_list|,
operator|&
name|zero_address_frag
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Tell `.option' it's too late.  */
name|cpu_tables_init_p
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Insert an operand value into an instruction.    If REG is non-NULL, it is a register number and ignore VAL.  */
end_comment

begin_function
specifier|static
name|arc_insn
name|arc_insert_operand
parameter_list|(
name|insn
parameter_list|,
name|operand
parameter_list|,
name|mods
parameter_list|,
name|reg
parameter_list|,
name|val
parameter_list|,
name|file
parameter_list|,
name|line
parameter_list|)
name|arc_insn
name|insn
decl_stmt|;
specifier|const
name|struct
name|arc_operand
modifier|*
name|operand
decl_stmt|;
name|int
name|mods
decl_stmt|;
specifier|const
name|struct
name|arc_operand_value
modifier|*
name|reg
decl_stmt|;
name|offsetT
name|val
decl_stmt|;
name|char
modifier|*
name|file
decl_stmt|;
name|unsigned
name|int
name|line
decl_stmt|;
block|{
if|if
condition|(
name|operand
operator|->
name|bits
operator|!=
literal|32
condition|)
block|{
name|long
name|min
decl_stmt|,
name|max
decl_stmt|;
name|offsetT
name|test
decl_stmt|;
if|if
condition|(
operator|(
name|operand
operator|->
name|flags
operator|&
name|ARC_OPERAND_SIGNED
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|operand
operator|->
name|flags
operator|&
name|ARC_OPERAND_SIGNOPT
operator|)
operator|!=
literal|0
condition|)
name|max
operator|=
operator|(
literal|1
operator|<<
name|operand
operator|->
name|bits
operator|)
operator|-
literal|1
expr_stmt|;
else|else
name|max
operator|=
operator|(
literal|1
operator|<<
operator|(
name|operand
operator|->
name|bits
operator|-
literal|1
operator|)
operator|)
operator|-
literal|1
expr_stmt|;
name|min
operator|=
operator|-
operator|(
literal|1
operator|<<
operator|(
name|operand
operator|->
name|bits
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
block|}
else|else
block|{
name|max
operator|=
operator|(
literal|1
operator|<<
name|operand
operator|->
name|bits
operator|)
operator|-
literal|1
expr_stmt|;
name|min
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|operand
operator|->
name|flags
operator|&
name|ARC_OPERAND_NEGATIVE
operator|)
operator|!=
literal|0
condition|)
name|test
operator|=
operator|-
name|val
expr_stmt|;
else|else
name|test
operator|=
name|val
expr_stmt|;
if|if
condition|(
name|test
operator|<
operator|(
name|offsetT
operator|)
name|min
operator|||
name|test
operator|>
operator|(
name|offsetT
operator|)
name|max
condition|)
block|{
specifier|const
name|char
modifier|*
name|err
init|=
literal|"operand out of range (%s not between %ld and %ld)"
decl_stmt|;
name|char
name|buf
index|[
literal|100
index|]
decl_stmt|;
name|sprint_value
argument_list|(
name|buf
argument_list|,
name|test
argument_list|)
expr_stmt|;
if|if
condition|(
name|file
operator|==
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
name|as_warn
argument_list|(
name|err
argument_list|,
name|buf
argument_list|,
name|min
argument_list|,
name|max
argument_list|)
expr_stmt|;
else|else
name|as_warn_where
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
name|err
argument_list|,
name|buf
argument_list|,
name|min
argument_list|,
name|max
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|operand
operator|->
name|insert
condition|)
block|{
specifier|const
name|char
modifier|*
name|errmsg
decl_stmt|;
name|errmsg
operator|=
name|NULL
expr_stmt|;
name|insn
operator|=
call|(
modifier|*
name|operand
operator|->
name|insert
call|)
argument_list|(
name|insn
argument_list|,
name|operand
argument_list|,
name|mods
argument_list|,
name|reg
argument_list|,
operator|(
name|long
operator|)
name|val
argument_list|,
operator|&
name|errmsg
argument_list|)
expr_stmt|;
if|if
condition|(
name|errmsg
operator|!=
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
condition|)
name|as_warn
argument_list|(
name|errmsg
argument_list|)
expr_stmt|;
block|}
else|else
name|insn
operator||=
operator|(
operator|(
operator|(
name|long
operator|)
name|val
operator|&
operator|(
operator|(
literal|1
operator|<<
name|operand
operator|->
name|bits
operator|)
operator|-
literal|1
operator|)
operator|)
operator|<<
name|operand
operator|->
name|shift
operator|)
expr_stmt|;
return|return
name|insn
return|;
block|}
end_function

begin_comment
comment|/* We need to keep a list of fixups.  We can't simply generate them as    we go, because that would require us to first create the frag, and    that would screw up references to ``.''.  */
end_comment

begin_struct
struct|struct
name|arc_fixup
block|{
comment|/* index into `arc_operands'  */
name|int
name|opindex
decl_stmt|;
name|expressionS
name|exp
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|MAX_FIXUPS
value|5
end_define

begin_define
define|#
directive|define
name|MAX_SUFFIXES
value|5
end_define

begin_comment
comment|/* This routine is called for each instruction to be assembled.  */
end_comment

begin_function
name|void
name|md_assemble
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
specifier|const
name|struct
name|arc_opcode
modifier|*
name|opcode
decl_stmt|;
specifier|const
name|struct
name|arc_opcode
modifier|*
name|std_opcode
decl_stmt|;
name|struct
name|arc_opcode
modifier|*
name|ext_opcode
decl_stmt|;
name|char
modifier|*
name|start
decl_stmt|;
specifier|const
name|char
modifier|*
name|last_errmsg
init|=
literal|0
decl_stmt|;
name|arc_insn
name|insn
decl_stmt|;
specifier|static
name|int
name|init_tables_p
init|=
literal|0
decl_stmt|;
comment|/* Opcode table initialization is deferred until here because we have to      wait for a possible .option command.  */
if|if
condition|(
operator|!
name|init_tables_p
condition|)
block|{
name|init_opcode_tables
argument_list|(
name|arc_mach_type
argument_list|)
expr_stmt|;
name|init_tables_p
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Skip leading white space.  */
while|while
condition|(
name|ISSPACE
argument_list|(
operator|*
name|str
argument_list|)
condition|)
name|str
operator|++
expr_stmt|;
comment|/* The instructions are stored in lists hashed by the first letter (though      we needn't care how they're hashed).  Get the first in the list.  */
name|ext_opcode
operator|=
name|arc_ext_opcodes
expr_stmt|;
name|std_opcode
operator|=
name|arc_opcode_lookup_asm
argument_list|(
name|str
argument_list|)
expr_stmt|;
comment|/* Keep looking until we find a match.  */
name|start
operator|=
name|str
expr_stmt|;
for|for
control|(
name|opcode
operator|=
operator|(
name|ext_opcode
condition|?
name|ext_opcode
else|:
name|std_opcode
operator|)
init|;
name|opcode
operator|!=
name|NULL
condition|;
name|opcode
operator|=
operator|(
name|ARC_OPCODE_NEXT_ASM
argument_list|(
name|opcode
argument_list|)
condition|?
name|ARC_OPCODE_NEXT_ASM
argument_list|(
name|opcode
argument_list|)
else|:
operator|(
name|ext_opcode
condition|?
name|ext_opcode
operator|=
name|NULL
operator|,
name|std_opcode
operator|:
name|NULL
operator|)
operator|)
control|)
block|{
name|int
name|past_opcode_p
decl_stmt|,
name|fc
decl_stmt|,
name|num_suffixes
decl_stmt|;
name|int
name|fix_up_at
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|syn
decl_stmt|;
name|struct
name|arc_fixup
name|fixups
index|[
name|MAX_FIXUPS
index|]
decl_stmt|;
comment|/* Used as a sanity check.  If we need a limm reloc, make sure we ask 	 for an extra 4 bytes from frag_more.  */
name|int
name|limm_reloc_p
decl_stmt|;
name|int
name|ext_suffix_p
decl_stmt|;
specifier|const
name|struct
name|arc_operand_value
modifier|*
name|insn_suffixes
index|[
name|MAX_SUFFIXES
index|]
decl_stmt|;
comment|/* Is this opcode supported by the selected cpu?  */
if|if
condition|(
operator|!
name|arc_opcode_supported
argument_list|(
name|opcode
argument_list|)
condition|)
continue|continue;
comment|/* Scan the syntax string.  If it doesn't match, try the next one.  */
name|arc_opcode_init_insert
argument_list|()
expr_stmt|;
name|insn
operator|=
name|opcode
operator|->
name|value
expr_stmt|;
name|fc
operator|=
literal|0
expr_stmt|;
name|past_opcode_p
operator|=
literal|0
expr_stmt|;
name|num_suffixes
operator|=
literal|0
expr_stmt|;
name|limm_reloc_p
operator|=
literal|0
expr_stmt|;
name|ext_suffix_p
operator|=
literal|0
expr_stmt|;
comment|/* We don't check for (*str != '\0') here because we want to parse 	 any trailing fake arguments in the syntax string.  */
for|for
control|(
name|str
operator|=
name|start
operator|,
name|syn
operator|=
name|opcode
operator|->
name|syntax
init|;
operator|*
name|syn
operator|!=
literal|'\0'
condition|;
control|)
block|{
name|int
name|mods
decl_stmt|;
specifier|const
name|struct
name|arc_operand
modifier|*
name|operand
decl_stmt|;
comment|/* Non operand chars must match exactly.  */
if|if
condition|(
operator|*
name|syn
operator|!=
literal|'%'
operator|||
operator|*
operator|++
name|syn
operator|==
literal|'%'
condition|)
block|{
comment|/* Handle '+' specially as we want to allow "ld r0,[sp-4]".  */
comment|/* ??? The syntax has changed to [sp,-4].  */
if|if
condition|(
literal|0
operator|&&
operator|*
name|syn
operator|==
literal|'+'
operator|&&
operator|*
name|str
operator|==
literal|'-'
condition|)
block|{
comment|/* Skip over syn's +, but leave str's - alone. 		     That makes the case identical to "ld r0,[sp+-4]".  */
operator|++
name|syn
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|str
operator|==
operator|*
name|syn
condition|)
block|{
if|if
condition|(
operator|*
name|syn
operator|==
literal|' '
condition|)
name|past_opcode_p
operator|=
literal|1
expr_stmt|;
operator|++
name|syn
expr_stmt|;
operator|++
name|str
expr_stmt|;
block|}
else|else
break|break;
continue|continue;
block|}
comment|/* We have an operand.  Pick out any modifiers.  */
name|mods
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|ARC_MOD_P
argument_list|(
name|arc_operands
index|[
name|arc_operand_map
index|[
operator|(
name|int
operator|)
operator|*
name|syn
index|]
index|]
operator|.
name|flags
argument_list|)
condition|)
block|{
name|mods
operator||=
name|arc_operands
index|[
name|arc_operand_map
index|[
operator|(
name|int
operator|)
operator|*
name|syn
index|]
index|]
operator|.
name|flags
operator|&
name|ARC_MOD_BITS
expr_stmt|;
operator|++
name|syn
expr_stmt|;
block|}
name|operand
operator|=
name|arc_operands
operator|+
name|arc_operand_map
index|[
operator|(
name|int
operator|)
operator|*
name|syn
index|]
expr_stmt|;
if|if
condition|(
name|operand
operator|->
name|fmt
operator|==
literal|0
condition|)
name|as_fatal
argument_list|(
literal|"unknown syntax format character `%c'"
argument_list|,
operator|*
name|syn
argument_list|)
expr_stmt|;
if|if
condition|(
name|operand
operator|->
name|flags
operator|&
name|ARC_OPERAND_FAKE
condition|)
block|{
specifier|const
name|char
modifier|*
name|errmsg
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|operand
operator|->
name|insert
condition|)
block|{
name|insn
operator|=
call|(
modifier|*
name|operand
operator|->
name|insert
call|)
argument_list|(
name|insn
argument_list|,
name|operand
argument_list|,
name|mods
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
operator|&
name|errmsg
argument_list|)
expr_stmt|;
if|if
condition|(
name|errmsg
operator|!=
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
condition|)
block|{
name|last_errmsg
operator|=
name|errmsg
expr_stmt|;
if|if
condition|(
name|operand
operator|->
name|flags
operator|&
name|ARC_OPERAND_ERROR
condition|)
block|{
name|as_bad
argument_list|(
name|errmsg
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|operand
operator|->
name|flags
operator|&
name|ARC_OPERAND_WARN
condition|)
name|as_warn
argument_list|(
name|errmsg
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|limm_reloc_p
operator|&&
operator|(
name|operand
operator|->
name|flags
operator|&&
name|operand
operator|->
name|flags
operator|&
name|ARC_OPERAND_LIMM
operator|)
operator|&&
operator|(
name|operand
operator|->
name|flags
operator|&
operator|(
name|ARC_OPERAND_ABSOLUTE_BRANCH
operator||
name|ARC_OPERAND_ADDRESS
operator|)
operator|)
condition|)
block|{
name|fixups
index|[
name|fix_up_at
index|]
operator|.
name|opindex
operator|=
name|arc_operand_map
index|[
name|operand
operator|->
name|fmt
index|]
expr_stmt|;
block|}
block|}
operator|++
name|syn
expr_stmt|;
block|}
comment|/* Are we finished with suffixes?  */
elseif|else
if|if
condition|(
operator|!
name|past_opcode_p
condition|)
block|{
name|int
name|found
decl_stmt|;
name|char
name|c
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|t
decl_stmt|;
specifier|const
name|struct
name|arc_operand_value
modifier|*
name|suf
decl_stmt|,
modifier|*
name|suffix_end
decl_stmt|;
specifier|const
name|struct
name|arc_operand_value
modifier|*
name|suffix
init|=
name|NULL
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|operand
operator|->
name|flags
operator|&
name|ARC_OPERAND_SUFFIX
operator|)
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* If we're at a space in the input string, we want to skip the 		 remaining suffixes.  There may be some fake ones though, so 		 just go on to try the next one.  */
if|if
condition|(
operator|*
name|str
operator|==
literal|' '
condition|)
block|{
operator|++
name|syn
expr_stmt|;
continue|continue;
block|}
name|s
operator|=
name|str
expr_stmt|;
if|if
condition|(
name|mods
operator|&
name|ARC_MOD_DOT
condition|)
block|{
if|if
condition|(
operator|*
name|s
operator|!=
literal|'.'
condition|)
break|break;
operator|++
name|s
expr_stmt|;
block|}
else|else
block|{
comment|/* This can happen in "b.nd foo" and we're currently looking 		     for "%q" (ie: a condition code suffix).  */
if|if
condition|(
operator|*
name|s
operator|==
literal|'.'
condition|)
block|{
operator|++
name|syn
expr_stmt|;
continue|continue;
block|}
block|}
comment|/* Pick the suffix out and look it up via the hash table.  */
for|for
control|(
name|t
operator|=
name|s
init|;
operator|*
name|t
operator|&&
name|ISALNUM
argument_list|(
operator|*
name|t
argument_list|)
condition|;
operator|++
name|t
control|)
continue|continue;
name|c
operator|=
operator|*
name|t
expr_stmt|;
operator|*
name|t
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|(
name|suf
operator|=
name|get_ext_suffix
argument_list|(
name|s
argument_list|)
operator|)
condition|)
name|ext_suffix_p
operator|=
literal|1
expr_stmt|;
else|else
name|suf
operator|=
name|hash_find
argument_list|(
name|arc_suffix_hash
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|suf
condition|)
block|{
comment|/* This can happen in "blle foo" and we're currently using 		     the template "b%q%.n %j".  The "bl" insn occurs later in 		     the table so "lle" isn't an illegal suffix.  */
operator|*
name|t
operator|=
name|c
expr_stmt|;
break|break;
block|}
comment|/* Is it the right type?  Note that the same character is used 		 several times, so we have to examine all of them.  This is 		 relatively efficient as equivalent entries are kept 		 together.  If it's not the right type, don't increment `str' 		 so we try the next one in the series.  */
name|found
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ext_suffix_p
operator|&&
name|arc_operands
index|[
name|suf
operator|->
name|type
index|]
operator|.
name|fmt
operator|==
operator|*
name|syn
condition|)
block|{
comment|/* Insert the suffix's value into the insn.  */
operator|*
name|t
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|operand
operator|->
name|insert
condition|)
name|insn
operator|=
call|(
modifier|*
name|operand
operator|->
name|insert
call|)
argument_list|(
name|insn
argument_list|,
name|operand
argument_list|,
name|mods
argument_list|,
name|NULL
argument_list|,
name|suf
operator|->
name|value
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|else
name|insn
operator||=
name|suf
operator|->
name|value
operator|<<
name|operand
operator|->
name|shift
expr_stmt|;
name|str
operator|=
name|t
expr_stmt|;
name|found
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
operator|*
name|t
operator|=
name|c
expr_stmt|;
name|suffix_end
operator|=
name|arc_suffixes
operator|+
name|arc_suffixes_count
expr_stmt|;
for|for
control|(
name|suffix
operator|=
name|suf
init|;
name|suffix
operator|<
name|suffix_end
operator|&&
name|strcmp
argument_list|(
name|suffix
operator|->
name|name
argument_list|,
name|suf
operator|->
name|name
argument_list|)
operator|==
literal|0
condition|;
operator|++
name|suffix
control|)
block|{
if|if
condition|(
name|arc_operands
index|[
name|suffix
operator|->
name|type
index|]
operator|.
name|fmt
operator|==
operator|*
name|syn
condition|)
block|{
comment|/* Insert the suffix's value into the insn.  */
if|if
condition|(
name|operand
operator|->
name|insert
condition|)
name|insn
operator|=
call|(
modifier|*
name|operand
operator|->
name|insert
call|)
argument_list|(
name|insn
argument_list|,
name|operand
argument_list|,
name|mods
argument_list|,
name|NULL
argument_list|,
name|suffix
operator|->
name|value
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|else
name|insn
operator||=
name|suffix
operator|->
name|value
operator|<<
name|operand
operator|->
name|shift
expr_stmt|;
name|str
operator|=
name|t
expr_stmt|;
name|found
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
block|}
operator|++
name|syn
expr_stmt|;
if|if
condition|(
operator|!
name|found
condition|)
comment|/* Wrong type.  Just go on to try next insn entry.  */
empty_stmt|;
else|else
block|{
if|if
condition|(
name|num_suffixes
operator|==
name|MAX_SUFFIXES
condition|)
name|as_bad
argument_list|(
literal|"too many suffixes"
argument_list|)
expr_stmt|;
else|else
name|insn_suffixes
index|[
name|num_suffixes
operator|++
index|]
operator|=
name|suffix
expr_stmt|;
block|}
block|}
else|else
comment|/* This is either a register or an expression of some kind.  */
block|{
name|char
modifier|*
name|hold
decl_stmt|;
specifier|const
name|struct
name|arc_operand_value
modifier|*
name|reg
init|=
name|NULL
decl_stmt|;
name|long
name|value
init|=
literal|0
decl_stmt|;
name|expressionS
name|exp
decl_stmt|;
if|if
condition|(
name|operand
operator|->
name|flags
operator|&
name|ARC_OPERAND_SUFFIX
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Is there anything left to parse? 		 We don't check for this at the top because we want to parse 		 any trailing fake arguments in the syntax string.  */
if|if
condition|(
name|is_end_of_line
index|[
operator|(
name|unsigned
name|char
operator|)
operator|*
name|str
index|]
condition|)
break|break;
comment|/* Parse the operand.  */
name|hold
operator|=
name|input_line_pointer
expr_stmt|;
name|input_line_pointer
operator|=
name|str
expr_stmt|;
name|expression
argument_list|(
operator|&
name|exp
argument_list|)
expr_stmt|;
name|str
operator|=
name|input_line_pointer
expr_stmt|;
name|input_line_pointer
operator|=
name|hold
expr_stmt|;
if|if
condition|(
name|exp
operator|.
name|X_op
operator|==
name|O_illegal
condition|)
name|as_bad
argument_list|(
literal|"illegal operand"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|exp
operator|.
name|X_op
operator|==
name|O_absent
condition|)
name|as_bad
argument_list|(
literal|"missing operand"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|exp
operator|.
name|X_op
operator|==
name|O_constant
condition|)
block|{
name|value
operator|=
name|exp
operator|.
name|X_add_number
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|exp
operator|.
name|X_op
operator|==
name|O_register
condition|)
block|{
name|reg
operator|=
operator|(
expr|struct
name|arc_operand_value
operator|*
operator|)
name|exp
operator|.
name|X_add_number
expr_stmt|;
block|}
define|#
directive|define
name|IS_REG_DEST_OPERAND
parameter_list|(
name|o
parameter_list|)
value|((o) == 'a')
elseif|else
if|if
condition|(
name|IS_REG_DEST_OPERAND
argument_list|(
operator|*
name|syn
argument_list|)
condition|)
name|as_bad
argument_list|(
literal|"symbol as destination register"
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|str
argument_list|,
literal|"@h30"
argument_list|,
literal|4
argument_list|)
condition|)
block|{
name|arc_code_symbol
argument_list|(
operator|&
name|exp
argument_list|)
expr_stmt|;
name|str
operator|+=
literal|4
expr_stmt|;
block|}
comment|/* We need to generate a fixup for this expression.  */
if|if
condition|(
name|fc
operator|>=
name|MAX_FIXUPS
condition|)
name|as_fatal
argument_list|(
literal|"too many fixups"
argument_list|)
expr_stmt|;
name|fixups
index|[
name|fc
index|]
operator|.
name|exp
operator|=
name|exp
expr_stmt|;
comment|/* We don't support shimm relocs. break here to force 		     the assembler to output a limm.  */
define|#
directive|define
name|IS_REG_SHIMM_OFFSET
parameter_list|(
name|o
parameter_list|)
value|((o) == 'd')
if|if
condition|(
name|IS_REG_SHIMM_OFFSET
argument_list|(
operator|*
name|syn
argument_list|)
condition|)
break|break;
comment|/* If this is a register constant (IE: one whose 		     register value gets stored as 61-63) then this 		     must be a limm.  */
comment|/* ??? This bit could use some cleaning up. 		     Referencing the format chars like this goes 		     against style.  */
if|if
condition|(
name|IS_SYMBOL_OPERAND
argument_list|(
operator|*
name|syn
argument_list|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|junk
decl_stmt|;
name|limm_reloc_p
operator|=
literal|1
expr_stmt|;
comment|/* Save this, we don't yet know what reloc to use.  */
name|fix_up_at
operator|=
name|fc
expr_stmt|;
comment|/* Tell insert_reg we need a limm.  This is 			 needed because the value at this point is 			 zero, a shimm.  */
comment|/* ??? We need a cleaner interface than this.  */
operator|(
operator|*
name|arc_operands
index|[
name|arc_operand_map
index|[
literal|'Q'
index|]
index|]
operator|.
name|insert
operator|)
operator|(
name|insn
operator|,
name|operand
operator|,
name|mods
operator|,
name|reg
operator|,
literal|0L
operator|,
operator|&
name|junk
operator|)
expr_stmt|;
block|}
else|else
name|fixups
index|[
name|fc
index|]
operator|.
name|opindex
operator|=
name|arc_operand_map
index|[
operator|(
name|int
operator|)
operator|*
name|syn
index|]
expr_stmt|;
operator|++
name|fc
expr_stmt|;
name|value
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Insert the register or expression into the instruction.  */
if|if
condition|(
name|operand
operator|->
name|insert
condition|)
block|{
specifier|const
name|char
modifier|*
name|errmsg
init|=
name|NULL
decl_stmt|;
name|insn
operator|=
call|(
modifier|*
name|operand
operator|->
name|insert
call|)
argument_list|(
name|insn
argument_list|,
name|operand
argument_list|,
name|mods
argument_list|,
name|reg
argument_list|,
operator|(
name|long
operator|)
name|value
argument_list|,
operator|&
name|errmsg
argument_list|)
expr_stmt|;
if|if
condition|(
name|errmsg
operator|!=
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
condition|)
block|{
name|last_errmsg
operator|=
name|errmsg
expr_stmt|;
if|if
condition|(
name|operand
operator|->
name|flags
operator|&
name|ARC_OPERAND_ERROR
condition|)
block|{
name|as_bad
argument_list|(
name|errmsg
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|operand
operator|->
name|flags
operator|&
name|ARC_OPERAND_WARN
condition|)
name|as_warn
argument_list|(
name|errmsg
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
else|else
name|insn
operator||=
operator|(
name|value
operator|&
operator|(
operator|(
literal|1
operator|<<
name|operand
operator|->
name|bits
operator|)
operator|-
literal|1
operator|)
operator|)
operator|<<
name|operand
operator|->
name|shift
expr_stmt|;
operator|++
name|syn
expr_stmt|;
block|}
block|}
comment|/* If we're at the end of the syntax string, we're done.  */
comment|/* FIXME: try to move this to a separate function.  */
if|if
condition|(
operator|*
name|syn
operator|==
literal|'\0'
condition|)
block|{
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|f
decl_stmt|;
name|long
name|limm
decl_stmt|,
name|limm_p
decl_stmt|;
comment|/* For the moment we assume a valid `str' can only contain blanks 	     now.  IE: We needn't try again with a longer version of the 	     insn and it is assumed that longer versions of insns appear 	     before shorter ones (eg: lsr r2,r3,1 vs lsr r2,r3).  */
while|while
condition|(
name|ISSPACE
argument_list|(
operator|*
name|str
argument_list|)
condition|)
operator|++
name|str
expr_stmt|;
if|if
condition|(
operator|!
name|is_end_of_line
index|[
operator|(
name|unsigned
name|char
operator|)
operator|*
name|str
index|]
condition|)
name|as_bad
argument_list|(
literal|"junk at end of line: `%s'"
argument_list|,
name|str
argument_list|)
expr_stmt|;
comment|/* Is there a limm value?  */
name|limm_p
operator|=
name|arc_opcode_limm_p
argument_list|(
operator|&
name|limm
argument_list|)
expr_stmt|;
comment|/* Perform various error and warning tests.  */
block|{
specifier|static
name|int
name|in_delay_slot_p
init|=
literal|0
decl_stmt|;
specifier|static
name|int
name|prev_insn_needs_cc_nop_p
init|=
literal|0
decl_stmt|;
comment|/* delay slot type seen */
name|int
name|delay_slot_type
init|=
name|ARC_DELAY_NONE
decl_stmt|;
comment|/* conditional execution flag seen */
name|int
name|conditional
init|=
literal|0
decl_stmt|;
comment|/* 1 if condition codes are being set */
name|int
name|cc_set_p
init|=
literal|0
decl_stmt|;
comment|/* 1 if conditional branch, including `b' "branch always" */
name|int
name|cond_branch_p
init|=
name|opcode
operator|->
name|flags
operator|&
name|ARC_OPCODE_COND_BRANCH
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_suffixes
condition|;
operator|++
name|i
control|)
block|{
switch|switch
condition|(
name|arc_operands
index|[
name|insn_suffixes
index|[
name|i
index|]
operator|->
name|type
index|]
operator|.
name|fmt
condition|)
block|{
case|case
literal|'n'
case|:
name|delay_slot_type
operator|=
name|insn_suffixes
index|[
name|i
index|]
operator|->
name|value
expr_stmt|;
break|break;
case|case
literal|'q'
case|:
name|conditional
operator|=
name|insn_suffixes
index|[
name|i
index|]
operator|->
name|value
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|cc_set_p
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
comment|/* Putting an insn with a limm value in a delay slot is supposed to 	       be legal, but let's warn the user anyway.  Ditto for 8 byte 	       jumps with delay slots.  */
if|if
condition|(
name|in_delay_slot_p
operator|&&
name|limm_p
condition|)
name|as_warn
argument_list|(
literal|"8 byte instruction in delay slot"
argument_list|)
expr_stmt|;
if|if
condition|(
name|delay_slot_type
operator|!=
name|ARC_DELAY_NONE
operator|&&
name|limm_p
operator|&&
name|arc_insn_not_jl
argument_list|(
name|insn
argument_list|)
condition|)
comment|/* except for jl  addr */
name|as_warn
argument_list|(
literal|"8 byte jump instruction with delay slot"
argument_list|)
expr_stmt|;
name|in_delay_slot_p
operator|=
operator|(
name|delay_slot_type
operator|!=
name|ARC_DELAY_NONE
operator|)
operator|&&
operator|!
name|limm_p
expr_stmt|;
comment|/* Warn when a conditional branch immediately follows a set of 	       the condition codes.  Note that this needn't be done if the 	       insn that sets the condition codes uses a limm.  */
if|if
condition|(
name|cond_branch_p
operator|&&
name|conditional
operator|!=
literal|0
comment|/* 0 = "always" */
operator|&&
name|prev_insn_needs_cc_nop_p
operator|&&
name|arc_mach_type
operator|==
name|bfd_mach_arc_5
condition|)
name|as_warn
argument_list|(
literal|"conditional branch follows set of flags"
argument_list|)
expr_stmt|;
name|prev_insn_needs_cc_nop_p
operator|=
comment|/* FIXME: ??? not required: 		 (delay_slot_type != ARC_DELAY_NONE)&&  */
name|cc_set_p
operator|&&
operator|!
name|limm_p
expr_stmt|;
block|}
comment|/* Write out the instruction. 	     It is important to fetch enough space in one call to `frag_more'. 	     We use (f - frag_now->fr_literal) to compute where we are and we 	     don't want frag_now to change between calls.  */
if|if
condition|(
name|limm_p
condition|)
block|{
name|f
operator|=
name|frag_more
argument_list|(
literal|8
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|f
argument_list|,
name|insn
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|f
operator|+
literal|4
argument_list|,
name|limm
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|dwarf2_emit_insn
argument_list|(
literal|8
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|limm_reloc_p
condition|)
block|{
comment|/* We need a limm reloc, but the tables think we don't.  */
name|abort
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|f
operator|=
name|frag_more
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|f
argument_list|,
name|insn
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|dwarf2_emit_insn
argument_list|(
literal|4
argument_list|)
expr_stmt|;
block|}
comment|/* Create any fixups.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|fc
condition|;
operator|++
name|i
control|)
block|{
name|int
name|op_type
decl_stmt|,
name|reloc_type
decl_stmt|;
name|expressionS
name|exptmp
decl_stmt|;
specifier|const
name|struct
name|arc_operand
modifier|*
name|operand
decl_stmt|;
comment|/* Create a fixup for this operand. 		 At this point we do not use a bfd_reloc_code_real_type for 		 operands residing in the insn, but instead just use the 		 operand index.  This lets us easily handle fixups for any 		 operand type, although that is admittedly not a very exciting 		 feature.  We pick a BFD reloc type in md_apply_fix3.  		 Limm values (4 byte immediate "constants") must be treated 		 normally because they're not part of the actual insn word 		 and thus the insertion routines don't handle them.  */
if|if
condition|(
name|arc_operands
index|[
name|fixups
index|[
name|i
index|]
operator|.
name|opindex
index|]
operator|.
name|flags
operator|&
name|ARC_OPERAND_LIMM
condition|)
block|{
comment|/* Modify the fixup addend as required by the cpu.  */
name|fixups
index|[
name|i
index|]
operator|.
name|exp
operator|.
name|X_add_number
operator|+=
name|arc_limm_fixup_adjust
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|op_type
operator|=
name|fixups
index|[
name|i
index|]
operator|.
name|opindex
expr_stmt|;
comment|/* FIXME: can we add this data to the operand table?  */
if|if
condition|(
name|op_type
operator|==
name|arc_operand_map
index|[
literal|'L'
index|]
operator|||
name|op_type
operator|==
name|arc_operand_map
index|[
literal|'s'
index|]
operator|||
name|op_type
operator|==
name|arc_operand_map
index|[
literal|'o'
index|]
operator|||
name|op_type
operator|==
name|arc_operand_map
index|[
literal|'O'
index|]
condition|)
name|reloc_type
operator|=
name|BFD_RELOC_32
expr_stmt|;
elseif|else
if|if
condition|(
name|op_type
operator|==
name|arc_operand_map
index|[
literal|'J'
index|]
condition|)
name|reloc_type
operator|=
name|BFD_RELOC_ARC_B26
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
name|reloc_type
operator|=
name|get_arc_exp_reloc_type
argument_list|(
literal|1
argument_list|,
name|reloc_type
argument_list|,
operator|&
name|fixups
index|[
name|i
index|]
operator|.
name|exp
argument_list|,
operator|&
name|exptmp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|op_type
operator|=
name|get_arc_exp_reloc_type
argument_list|(
literal|0
argument_list|,
name|fixups
index|[
name|i
index|]
operator|.
name|opindex
argument_list|,
operator|&
name|fixups
index|[
name|i
index|]
operator|.
name|exp
argument_list|,
operator|&
name|exptmp
argument_list|)
expr_stmt|;
name|reloc_type
operator|=
name|op_type
operator|+
operator|(
name|int
operator|)
name|BFD_RELOC_UNUSED
expr_stmt|;
block|}
name|operand
operator|=
operator|&
name|arc_operands
index|[
name|op_type
index|]
expr_stmt|;
name|fix_new_exp
argument_list|(
name|frag_now
argument_list|,
operator|(
operator|(
name|f
operator|-
name|frag_now
operator|->
name|fr_literal
operator|)
operator|+
operator|(
name|operand
operator|->
name|flags
operator|&
name|ARC_OPERAND_LIMM
condition|?
literal|4
else|:
literal|0
operator|)
operator|)
argument_list|,
literal|4
argument_list|,
operator|&
name|exptmp
argument_list|,
operator|(
name|operand
operator|->
name|flags
operator|&
name|ARC_OPERAND_RELATIVE_BRANCH
operator|)
operator|!=
literal|0
argument_list|,
operator|(
name|bfd_reloc_code_real_type
operator|)
name|reloc_type
argument_list|)
expr_stmt|;
block|}
comment|/* All done.  */
return|return;
block|}
comment|/* Try the next entry.  */
block|}
if|if
condition|(
name|NULL
operator|==
name|last_errmsg
condition|)
name|as_bad
argument_list|(
literal|"bad instruction `%s'"
argument_list|,
name|start
argument_list|)
expr_stmt|;
else|else
name|as_bad
argument_list|(
name|last_errmsg
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|arc_extoper
parameter_list|(
name|opertype
parameter_list|)
name|int
name|opertype
decl_stmt|;
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|mode
decl_stmt|;
name|char
name|c
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|imode
init|=
literal|0
decl_stmt|;
name|int
name|number
decl_stmt|;
name|struct
name|arc_ext_operand_value
modifier|*
name|ext_oper
decl_stmt|;
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
name|segT
name|old_sec
decl_stmt|;
name|int
name|old_subsec
decl_stmt|;
name|name
operator|=
name|input_line_pointer
expr_stmt|;
name|c
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
name|name
operator|=
name|xstrdup
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|p
operator|=
name|name
expr_stmt|;
while|while
condition|(
operator|*
name|p
condition|)
block|{
operator|*
name|p
operator|=
name|TOLOWER
argument_list|(
operator|*
name|p
argument_list|)
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
comment|/* just after name is now '\0'  */
name|p
operator|=
name|input_line_pointer
expr_stmt|;
operator|*
name|p
operator|=
name|c
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|!=
literal|','
condition|)
block|{
name|as_bad
argument_list|(
literal|"expected comma after operand name"
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
name|free
argument_list|(
name|name
argument_list|)
expr_stmt|;
return|return;
block|}
name|input_line_pointer
operator|++
expr_stmt|;
comment|/* skip ','  */
name|number
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
if|if
condition|(
name|number
operator|<
literal|0
condition|)
block|{
name|as_bad
argument_list|(
literal|"negative operand number %d"
argument_list|,
name|number
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
name|free
argument_list|(
name|name
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|opertype
condition|)
block|{
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|!=
literal|','
condition|)
block|{
name|as_bad
argument_list|(
literal|"expected comma after register-number"
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
name|free
argument_list|(
name|name
argument_list|)
expr_stmt|;
return|return;
block|}
name|input_line_pointer
operator|++
expr_stmt|;
comment|/* skip ','  */
name|mode
operator|=
name|input_line_pointer
expr_stmt|;
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|mode
argument_list|,
literal|"r|w"
argument_list|,
literal|3
argument_list|)
condition|)
block|{
name|imode
operator|=
literal|0
expr_stmt|;
name|input_line_pointer
operator|+=
literal|3
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|mode
argument_list|,
literal|"r"
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|imode
operator|=
name|ARC_REGISTER_READONLY
expr_stmt|;
name|input_line_pointer
operator|+=
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|mode
argument_list|,
literal|"w"
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|as_bad
argument_list|(
literal|"invalid mode"
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
name|free
argument_list|(
name|name
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
name|imode
operator|=
name|ARC_REGISTER_WRITEONLY
expr_stmt|;
name|input_line_pointer
operator|+=
literal|1
expr_stmt|;
block|}
block|}
block|}
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
literal|1
operator|==
name|opertype
condition|)
block|{
if|if
condition|(
operator|*
name|input_line_pointer
operator|!=
literal|','
condition|)
block|{
name|as_bad
argument_list|(
literal|"expected comma after register-mode"
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
name|free
argument_list|(
name|name
argument_list|)
expr_stmt|;
return|return;
block|}
name|input_line_pointer
operator|++
expr_stmt|;
comment|/* skip ','  */
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|input_line_pointer
argument_list|,
literal|"cannot_shortcut"
argument_list|,
literal|15
argument_list|)
condition|)
block|{
name|imode
operator||=
name|arc_get_noshortcut_flag
argument_list|()
expr_stmt|;
name|input_line_pointer
operator|+=
literal|15
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|input_line_pointer
argument_list|,
literal|"can_shortcut"
argument_list|,
literal|12
argument_list|)
condition|)
block|{
name|as_bad
argument_list|(
literal|"shortcut designator invalid"
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
name|free
argument_list|(
name|name
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
name|input_line_pointer
operator|+=
literal|12
expr_stmt|;
block|}
block|}
block|}
block|}
if|if
condition|(
operator|(
name|opertype
operator|==
literal|1
operator|)
operator|&&
name|number
operator|>
literal|60
condition|)
block|{
name|as_bad
argument_list|(
literal|"core register value (%d) too large"
argument_list|,
name|number
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
name|free
argument_list|(
name|name
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|opertype
operator|==
literal|0
operator|)
operator|&&
name|number
operator|>
literal|31
condition|)
block|{
name|as_bad
argument_list|(
literal|"condition code value (%d) too large"
argument_list|,
name|number
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
name|free
argument_list|(
name|name
argument_list|)
expr_stmt|;
return|return;
block|}
name|ext_oper
operator|=
operator|(
expr|struct
name|arc_ext_operand_value
operator|*
operator|)
expr|\
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|arc_ext_operand_value
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|opertype
condition|)
block|{
comment|/* If the symbol already exists, point it at the new definition.  */
if|if
condition|(
operator|(
name|symbolP
operator|=
name|symbol_find
argument_list|(
name|name
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|S_GET_SEGMENT
argument_list|(
name|symbolP
argument_list|)
operator|==
name|reg_section
condition|)
name|S_SET_VALUE
argument_list|(
name|symbolP
argument_list|,
operator|(
name|int
operator|)
operator|&
name|ext_oper
operator|->
name|operand
argument_list|)
expr_stmt|;
else|else
block|{
name|as_bad
argument_list|(
literal|"attempt to override symbol: %s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
name|free
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ext_oper
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
else|else
block|{
comment|/* If its not there, add it.  */
name|symbol_table_insert
argument_list|(
name|symbol_create
argument_list|(
name|name
argument_list|,
name|reg_section
argument_list|,
operator|(
name|int
operator|)
operator|&
name|ext_oper
operator|->
name|operand
argument_list|,
operator|&
name|zero_address_frag
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|ext_oper
operator|->
name|operand
operator|.
name|name
operator|=
name|name
expr_stmt|;
name|ext_oper
operator|->
name|operand
operator|.
name|value
operator|=
name|number
expr_stmt|;
name|ext_oper
operator|->
name|operand
operator|.
name|type
operator|=
name|arc_operand_type
argument_list|(
name|opertype
argument_list|)
expr_stmt|;
name|ext_oper
operator|->
name|operand
operator|.
name|flags
operator|=
name|imode
expr_stmt|;
name|ext_oper
operator|->
name|next
operator|=
name|arc_ext_operands
expr_stmt|;
name|arc_ext_operands
operator|=
name|ext_oper
expr_stmt|;
comment|/* OK, now that we know what this operand is, put a description in      the arc extension section of the output file.  */
name|old_sec
operator|=
name|now_seg
expr_stmt|;
name|old_subsec
operator|=
name|now_subseg
expr_stmt|;
name|arc_set_ext_seg
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|opertype
condition|)
block|{
case|case
literal|0
case|:
name|p
operator|=
name|frag_more
argument_list|(
literal|1
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
literal|3
operator|+
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
expr_stmt|;
name|p
operator|=
name|frag_more
argument_list|(
literal|1
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
name|EXT_COND_CODE
expr_stmt|;
name|p
operator|=
name|frag_more
argument_list|(
literal|1
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
name|number
expr_stmt|;
name|p
operator|=
name|frag_more
argument_list|(
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|p
argument_list|,
name|name
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|p
operator|=
name|frag_more
argument_list|(
literal|1
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
literal|3
operator|+
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
expr_stmt|;
name|p
operator|=
name|frag_more
argument_list|(
literal|1
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
name|EXT_CORE_REGISTER
expr_stmt|;
name|p
operator|=
name|frag_more
argument_list|(
literal|1
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
name|number
expr_stmt|;
name|p
operator|=
name|frag_more
argument_list|(
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|p
argument_list|,
name|name
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|p
operator|=
name|frag_more
argument_list|(
literal|1
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
literal|6
operator|+
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
expr_stmt|;
name|p
operator|=
name|frag_more
argument_list|(
literal|1
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
name|EXT_AUX_REGISTER
expr_stmt|;
name|p
operator|=
name|frag_more
argument_list|(
literal|1
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
name|number
operator|>>
literal|24
operator|&
literal|0xff
expr_stmt|;
name|p
operator|=
name|frag_more
argument_list|(
literal|1
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
name|number
operator|>>
literal|16
operator|&
literal|0xff
expr_stmt|;
name|p
operator|=
name|frag_more
argument_list|(
literal|1
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
name|number
operator|>>
literal|8
operator|&
literal|0xff
expr_stmt|;
name|p
operator|=
name|frag_more
argument_list|(
literal|1
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
name|number
operator|&
literal|0xff
expr_stmt|;
name|p
operator|=
name|frag_more
argument_list|(
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|p
argument_list|,
name|name
argument_list|)
expr_stmt|;
break|break;
default|default:
name|as_bad
argument_list|(
literal|"invalid opertype"
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
name|free
argument_list|(
name|name
argument_list|)
expr_stmt|;
return|return;
break|break;
block|}
name|subseg_set
argument_list|(
name|old_sec
argument_list|,
name|old_subsec
argument_list|)
expr_stmt|;
comment|/* Enter all registers into the symbol table.  */
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|arc_extinst
parameter_list|(
name|ignore
parameter_list|)
name|int
name|ignore
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|unsigned
name|char
name|syntax
index|[
literal|129
index|]
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|char
name|c
decl_stmt|;
name|int
name|suffixcode
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|opcode
decl_stmt|,
name|subopcode
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|class
init|=
literal|0
decl_stmt|;
name|int
name|name_len
decl_stmt|;
name|struct
name|arc_opcode
modifier|*
name|ext_op
decl_stmt|;
name|segT
name|old_sec
decl_stmt|;
name|int
name|old_subsec
decl_stmt|;
name|name
operator|=
name|input_line_pointer
expr_stmt|;
name|c
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
name|name
operator|=
name|xstrdup
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|syntax
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|name_len
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
comment|/* just after name is now '\0'  */
name|p
operator|=
name|input_line_pointer
expr_stmt|;
operator|*
name|p
operator|=
name|c
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|!=
literal|','
condition|)
block|{
name|as_bad
argument_list|(
literal|"expected comma after operand name"
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
name|input_line_pointer
operator|++
expr_stmt|;
comment|/* skip ','  */
name|opcode
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|!=
literal|','
condition|)
block|{
name|as_bad
argument_list|(
literal|"expected comma after opcode"
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
name|input_line_pointer
operator|++
expr_stmt|;
comment|/* skip ','  */
name|subopcode
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
if|if
condition|(
name|subopcode
operator|<
literal|0
condition|)
block|{
name|as_bad
argument_list|(
literal|"negative subopcode %d"
argument_list|,
name|subopcode
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|subopcode
condition|)
block|{
if|if
condition|(
literal|3
operator|!=
name|opcode
condition|)
block|{
name|as_bad
argument_list|(
literal|"subcode value found when opcode not equal 0x03"
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
else|else
block|{
if|if
condition|(
name|subopcode
operator|<
literal|0x09
operator|||
name|subopcode
operator|==
literal|0x3f
condition|)
block|{
name|as_bad
argument_list|(
literal|"invalid subopcode %d"
argument_list|,
name|subopcode
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
block|}
block|}
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|!=
literal|','
condition|)
block|{
name|as_bad
argument_list|(
literal|"expected comma after subopcode"
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
name|input_line_pointer
operator|++
expr_stmt|;
comment|/* skip ','  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|int
operator|)
name|MAXSUFFIXCLASS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|suffixclass
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|input_line_pointer
argument_list|,
name|suffixclass
index|[
name|i
index|]
operator|.
name|len
argument_list|)
condition|)
block|{
name|suffixcode
operator|=
name|i
expr_stmt|;
name|input_line_pointer
operator|+=
name|suffixclass
index|[
name|i
index|]
operator|.
name|len
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|-
literal|1
operator|==
name|suffixcode
condition|)
block|{
name|as_bad
argument_list|(
literal|"invalid suffix class"
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|!=
literal|','
condition|)
block|{
name|as_bad
argument_list|(
literal|"expected comma after suffix class"
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
name|input_line_pointer
operator|++
expr_stmt|;
comment|/* skip ','  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|int
operator|)
name|MAXSYNTAXCLASS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|syntaxclass
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|input_line_pointer
argument_list|,
name|syntaxclass
index|[
name|i
index|]
operator|.
name|len
argument_list|)
condition|)
block|{
name|class
operator|=
name|syntaxclass
index|[
name|i
index|]
operator|.
name|class
expr_stmt|;
name|input_line_pointer
operator|+=
name|syntaxclass
index|[
name|i
index|]
operator|.
name|len
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
literal|0
operator|==
operator|(
name|SYNTAX_VALID
operator|&
name|class
operator|)
condition|)
block|{
name|as_bad
argument_list|(
literal|"invalid syntax class"
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
literal|0x3
operator|==
name|opcode
operator|)
operator|&
operator|(
name|class
operator|&
name|SYNTAX_3OP
operator|)
condition|)
block|{
name|as_bad
argument_list|(
literal|"opcode 0x3 and SYNTAX_3OP invalid"
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
switch|switch
condition|(
name|suffixcode
condition|)
block|{
case|case
literal|0
case|:
name|strcat
argument_list|(
name|syntax
argument_list|,
literal|"%.q%.f "
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|strcat
argument_list|(
name|syntax
argument_list|,
literal|"%.f "
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|strcat
argument_list|(
name|syntax
argument_list|,
literal|"%.q "
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|strcat
argument_list|(
name|syntax
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
break|break;
default|default:
name|as_bad
argument_list|(
literal|"unknown suffix class"
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
break|break;
block|}
empty_stmt|;
name|strcat
argument_list|(
name|syntax
argument_list|,
operator|(
operator|(
name|opcode
operator|==
literal|0x3
operator|)
condition|?
literal|"%a,%b"
else|:
operator|(
operator|(
name|class
operator|&
name|SYNTAX_3OP
operator|)
condition|?
literal|"%a,%b,%c"
else|:
literal|"%b,%c"
operator|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|suffixcode
operator|<
literal|2
condition|)
name|strcat
argument_list|(
name|syntax
argument_list|,
literal|"%F"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|syntax
argument_list|,
literal|"%S%L"
argument_list|)
expr_stmt|;
name|ext_op
operator|=
operator|(
expr|struct
name|arc_opcode
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|arc_opcode
argument_list|)
argument_list|)
expr_stmt|;
name|ext_op
operator|->
name|syntax
operator|=
name|xstrdup
argument_list|(
name|syntax
argument_list|)
expr_stmt|;
name|ext_op
operator|->
name|mask
operator|=
name|I
argument_list|(
operator|-
literal|1
argument_list|)
operator||
operator|(
operator|(
literal|0x3
operator|==
name|opcode
operator|)
condition|?
name|C
argument_list|(
operator|-
literal|1
argument_list|)
else|:
literal|0
operator|)
expr_stmt|;
name|ext_op
operator|->
name|value
operator|=
name|I
argument_list|(
name|opcode
argument_list|)
operator||
operator|(
operator|(
literal|0x3
operator|==
name|opcode
operator|)
condition|?
name|C
argument_list|(
name|subopcode
argument_list|)
else|:
literal|0
operator|)
expr_stmt|;
name|ext_op
operator|->
name|flags
operator|=
name|class
expr_stmt|;
name|ext_op
operator|->
name|next_asm
operator|=
name|arc_ext_opcodes
expr_stmt|;
name|ext_op
operator|->
name|next_dis
operator|=
name|arc_ext_opcodes
expr_stmt|;
name|arc_ext_opcodes
operator|=
name|ext_op
expr_stmt|;
comment|/* OK, now that we know what this inst is, put a description in the      arc extension section of the output file.  */
name|old_sec
operator|=
name|now_seg
expr_stmt|;
name|old_subsec
operator|=
name|now_subseg
expr_stmt|;
name|arc_set_ext_seg
argument_list|()
expr_stmt|;
name|p
operator|=
name|frag_more
argument_list|(
literal|1
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
literal|5
operator|+
name|name_len
operator|+
literal|1
expr_stmt|;
name|p
operator|=
name|frag_more
argument_list|(
literal|1
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
name|EXT_INSTRUCTION
expr_stmt|;
name|p
operator|=
name|frag_more
argument_list|(
literal|1
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
name|opcode
expr_stmt|;
name|p
operator|=
name|frag_more
argument_list|(
literal|1
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
name|subopcode
expr_stmt|;
name|p
operator|=
name|frag_more
argument_list|(
literal|1
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
operator|(
name|class
operator|&
operator|(
name|OP1_MUST_BE_IMM
operator||
name|OP1_IMM_IMPLIED
operator|)
condition|?
name|IGNORE_FIRST_OPD
else|:
literal|0
operator|)
expr_stmt|;
name|p
operator|=
name|frag_more
argument_list|(
name|name_len
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|p
argument_list|,
name|syntax
argument_list|,
name|name_len
argument_list|)
expr_stmt|;
name|p
operator|=
name|frag_more
argument_list|(
literal|1
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
name|subseg_set
argument_list|(
name|old_sec
argument_list|,
name|old_subsec
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|int
name|arc_set_ext_seg
parameter_list|()
block|{
if|if
condition|(
operator|!
name|arcext_section
condition|)
block|{
name|arcext_section
operator|=
name|subseg_new
argument_list|(
literal|".arcextmap"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bfd_set_section_flags
argument_list|(
name|stdoutput
argument_list|,
name|arcext_section
argument_list|,
name|SEC_READONLY
operator||
name|SEC_HAS_CONTENTS
argument_list|)
expr_stmt|;
block|}
else|else
name|subseg_set
argument_list|(
name|arcext_section
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|arc_common
parameter_list|(
name|localScope
parameter_list|)
name|int
name|localScope
decl_stmt|;
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|char
name|c
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|align
decl_stmt|,
name|size
decl_stmt|;
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
name|name
operator|=
name|input_line_pointer
expr_stmt|;
name|c
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
comment|/* just after name is now '\0'  */
name|p
operator|=
name|input_line_pointer
expr_stmt|;
operator|*
name|p
operator|=
name|c
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|!=
literal|','
condition|)
block|{
name|as_bad
argument_list|(
literal|"expected comma after symbol name"
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
name|input_line_pointer
operator|++
expr_stmt|;
comment|/* skip ','  */
name|size
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
if|if
condition|(
name|size
operator|<
literal|0
condition|)
block|{
name|as_bad
argument_list|(
literal|"negative symbol length"
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
operator|*
name|p
operator|=
literal|0
expr_stmt|;
name|symbolP
operator|=
name|symbol_find_or_make
argument_list|(
name|name
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|S_IS_DEFINED
argument_list|(
name|symbolP
argument_list|)
operator|&&
operator|!
name|S_IS_COMMON
argument_list|(
name|symbolP
argument_list|)
condition|)
block|{
name|as_bad
argument_list|(
literal|"ignoring attempt to re-define symbol"
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
operator|(
name|int
operator|)
name|S_GET_VALUE
argument_list|(
name|symbolP
argument_list|)
operator|!=
literal|0
operator|)
expr|\
operator|&&
operator|(
operator|(
name|int
operator|)
name|S_GET_VALUE
argument_list|(
name|symbolP
argument_list|)
operator|!=
name|size
operator|)
condition|)
block|{
name|as_warn
argument_list|(
literal|"length of symbol \"%s\" already %ld, ignoring %d"
argument_list|,
name|S_GET_NAME
argument_list|(
name|symbolP
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|S_GET_VALUE
argument_list|(
name|symbolP
argument_list|)
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
name|assert
argument_list|(
name|symbolP
operator|->
name|sy_frag
operator|==
operator|&
name|zero_address_frag
argument_list|)
expr_stmt|;
comment|/* Now parse the alignment field.  This field is optional for      local and global symbols. Default alignment is zero.  */
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|','
condition|)
block|{
name|input_line_pointer
operator|++
expr_stmt|;
name|align
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
if|if
condition|(
name|align
operator|<
literal|0
condition|)
block|{
name|align
operator|=
literal|0
expr_stmt|;
name|as_warn
argument_list|(
literal|"assuming symbol alignment of zero"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|align
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|localScope
operator|!=
literal|0
condition|)
block|{
name|segT
name|old_sec
decl_stmt|;
name|int
name|old_subsec
decl_stmt|;
name|char
modifier|*
name|pfrag
decl_stmt|;
name|old_sec
operator|=
name|now_seg
expr_stmt|;
name|old_subsec
operator|=
name|now_subseg
expr_stmt|;
name|record_alignment
argument_list|(
name|bss_section
argument_list|,
name|align
argument_list|)
expr_stmt|;
name|subseg_set
argument_list|(
name|bss_section
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* ??? subseg_set (bss_section, 1); ???  */
if|if
condition|(
name|align
condition|)
comment|/* Do alignment.  */
name|frag_align
argument_list|(
name|align
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Detach from old frag.  */
if|if
condition|(
name|S_GET_SEGMENT
argument_list|(
name|symbolP
argument_list|)
operator|==
name|bss_section
condition|)
name|symbolP
operator|->
name|sy_frag
operator|->
name|fr_symbol
operator|=
name|NULL
expr_stmt|;
name|symbolP
operator|->
name|sy_frag
operator|=
name|frag_now
expr_stmt|;
name|pfrag
operator|=
name|frag_var
argument_list|(
name|rs_org
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
operator|(
name|relax_substateT
operator|)
literal|0
argument_list|,
name|symbolP
argument_list|,
operator|(
name|offsetT
operator|)
name|size
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
operator|*
name|pfrag
operator|=
literal|0
expr_stmt|;
name|S_SET_SIZE
argument_list|(
name|symbolP
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|S_SET_SEGMENT
argument_list|(
name|symbolP
argument_list|,
name|bss_section
argument_list|)
expr_stmt|;
name|S_CLEAR_EXTERNAL
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
name|symbolP
operator|->
name|local
operator|=
literal|1
expr_stmt|;
name|subseg_set
argument_list|(
name|old_sec
argument_list|,
name|old_subsec
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|S_SET_VALUE
argument_list|(
name|symbolP
argument_list|,
operator|(
name|valueT
operator|)
name|size
argument_list|)
expr_stmt|;
name|S_SET_ALIGN
argument_list|(
name|symbolP
argument_list|,
name|align
argument_list|)
expr_stmt|;
name|S_SET_EXTERNAL
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
name|S_SET_SEGMENT
argument_list|(
name|symbolP
argument_list|,
name|bfd_com_section_ptr
argument_list|)
expr_stmt|;
block|}
name|symbolP
operator|->
name|bsym
operator|->
name|flags
operator||=
name|BSF_OBJECT
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Select the cpu we're assembling for.  */
end_comment

begin_function
specifier|static
name|void
name|arc_option
parameter_list|(
name|ignore
parameter_list|)
name|int
name|ignore
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|int
name|mach
decl_stmt|;
name|char
name|c
decl_stmt|;
name|char
modifier|*
name|cpu
decl_stmt|;
name|cpu
operator|=
name|input_line_pointer
expr_stmt|;
name|c
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
name|mach
operator|=
name|arc_get_mach
argument_list|(
name|cpu
argument_list|)
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
comment|/* If an instruction has already been seen, it's too late.  */
if|if
condition|(
name|cpu_tables_init_p
condition|)
block|{
name|as_bad
argument_list|(
literal|"\".option\" directive must appear before any instructions"
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|mach
operator|==
operator|-
literal|1
condition|)
goto|goto
name|bad_cpu
goto|;
if|if
condition|(
name|mach_type_specified_p
operator|&&
name|mach
operator|!=
name|arc_mach_type
condition|)
block|{
name|as_bad
argument_list|(
literal|"\".option\" directive conflicts with initial definition"
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
else|else
block|{
comment|/* The cpu may have been selected on the command line.  */
if|if
condition|(
name|mach
operator|!=
name|arc_mach_type
condition|)
name|as_warn
argument_list|(
literal|"\".option\" directive overrides command-line (default) value"
argument_list|)
expr_stmt|;
name|arc_mach_type
operator|=
name|mach
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_set_arch_mach
argument_list|(
name|stdoutput
argument_list|,
name|bfd_arch_arc
argument_list|,
name|mach
argument_list|)
condition|)
name|as_fatal
argument_list|(
literal|"could not set architecture and machine"
argument_list|)
expr_stmt|;
name|mach_type_specified_p
operator|=
literal|1
expr_stmt|;
block|}
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
return|return;
name|bad_cpu
label|:
name|as_bad
argument_list|(
literal|"invalid identifier for \".option\""
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Turn a string in input_line_pointer into a floating point constant    of type TYPE, and store the appropriate bytes in *LITP.  The number    of LITTLENUMS emitted is stored in *SIZEP.  An error message is    returned, or NULL on OK.  */
end_comment

begin_comment
comment|/* Equal to MAX_PRECISION in atof-ieee.c  */
end_comment

begin_define
define|#
directive|define
name|MAX_LITTLENUMS
value|6
end_define

begin_function
name|char
modifier|*
name|md_atof
parameter_list|(
name|type
parameter_list|,
name|litP
parameter_list|,
name|sizeP
parameter_list|)
name|int
name|type
decl_stmt|;
name|char
modifier|*
name|litP
decl_stmt|;
name|int
modifier|*
name|sizeP
decl_stmt|;
block|{
name|int
name|prec
decl_stmt|;
name|LITTLENUM_TYPE
name|words
index|[
name|MAX_LITTLENUMS
index|]
decl_stmt|;
name|LITTLENUM_TYPE
modifier|*
name|wordP
decl_stmt|;
name|char
modifier|*
name|t
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
literal|'f'
case|:
case|case
literal|'F'
case|:
name|prec
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
case|case
literal|'D'
case|:
name|prec
operator|=
literal|4
expr_stmt|;
break|break;
default|default:
operator|*
name|sizeP
operator|=
literal|0
expr_stmt|;
return|return
literal|"bad call to md_atof"
return|;
block|}
name|t
operator|=
name|atof_ieee
argument_list|(
name|input_line_pointer
argument_list|,
name|type
argument_list|,
name|words
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
condition|)
name|input_line_pointer
operator|=
name|t
expr_stmt|;
operator|*
name|sizeP
operator|=
name|prec
operator|*
sizeof|sizeof
argument_list|(
name|LITTLENUM_TYPE
argument_list|)
expr_stmt|;
for|for
control|(
name|wordP
operator|=
name|words
init|;
name|prec
operator|--
condition|;
control|)
block|{
name|md_number_to_chars
argument_list|(
name|litP
argument_list|,
call|(
name|valueT
call|)
argument_list|(
operator|*
name|wordP
operator|++
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|LITTLENUM_TYPE
argument_list|)
argument_list|)
expr_stmt|;
name|litP
operator|+=
sizeof|sizeof
argument_list|(
name|LITTLENUM_TYPE
argument_list|)
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Write a value out to the object file, using the appropriate    endianness.  */
end_comment

begin_function
name|void
name|md_number_to_chars
parameter_list|(
name|buf
parameter_list|,
name|val
parameter_list|,
name|n
parameter_list|)
name|char
modifier|*
name|buf
decl_stmt|;
name|valueT
name|val
decl_stmt|;
name|int
name|n
decl_stmt|;
block|{
if|if
condition|(
name|target_big_endian
condition|)
name|number_to_chars_bigendian
argument_list|(
name|buf
argument_list|,
name|val
argument_list|,
name|n
argument_list|)
expr_stmt|;
else|else
name|number_to_chars_littleendian
argument_list|(
name|buf
argument_list|,
name|val
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Round up a section size to the appropriate boundary.  */
end_comment

begin_function
name|valueT
name|md_section_align
parameter_list|(
name|segment
parameter_list|,
name|size
parameter_list|)
name|segT
name|segment
decl_stmt|;
name|valueT
name|size
decl_stmt|;
block|{
name|int
name|align
init|=
name|bfd_get_section_alignment
argument_list|(
name|stdoutput
argument_list|,
name|segment
argument_list|)
decl_stmt|;
return|return
operator|(
operator|(
name|size
operator|+
operator|(
literal|1
operator|<<
name|align
operator|)
operator|-
literal|1
operator|)
operator|&
operator|(
operator|-
literal|1
operator|<<
name|align
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* We don't have any form of relaxing.  */
end_comment

begin_function
name|int
name|md_estimate_size_before_relax
parameter_list|(
name|fragp
parameter_list|,
name|seg
parameter_list|)
name|fragS
modifier|*
name|fragp
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|asection
modifier|*
name|seg
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"md_estimate_size_before_relax\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Convert a machine dependent frag.  We never generate these.  */
end_comment

begin_function
name|void
name|md_convert_frag
parameter_list|(
name|abfd
parameter_list|,
name|sec
parameter_list|,
name|fragp
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|asection
modifier|*
name|sec
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|fragS
modifier|*
name|fragp
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"md_convert_frag\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|arc_code_symbol
parameter_list|(
name|expressionP
parameter_list|)
name|expressionS
modifier|*
name|expressionP
decl_stmt|;
block|{
if|if
condition|(
name|expressionP
operator|->
name|X_op
operator|==
name|O_symbol
operator|&&
name|expressionP
operator|->
name|X_add_number
operator|==
literal|0
condition|)
block|{
name|expressionS
name|two
decl_stmt|;
name|expressionP
operator|->
name|X_op
operator|=
name|O_right_shift
expr_stmt|;
name|expressionP
operator|->
name|X_add_symbol
operator|->
name|sy_value
operator|.
name|X_op
operator|=
name|O_constant
expr_stmt|;
name|two
operator|.
name|X_op
operator|=
name|O_constant
expr_stmt|;
name|two
operator|.
name|X_add_symbol
operator|=
name|two
operator|.
name|X_op_symbol
operator|=
name|NULL
expr_stmt|;
name|two
operator|.
name|X_add_number
operator|=
literal|2
expr_stmt|;
name|expressionP
operator|->
name|X_op_symbol
operator|=
name|make_expr_symbol
argument_list|(
operator|&
name|two
argument_list|)
expr_stmt|;
block|}
comment|/* Allow %st(sym1-sym2)  */
elseif|else
if|if
condition|(
name|expressionP
operator|->
name|X_op
operator|==
name|O_subtract
operator|&&
name|expressionP
operator|->
name|X_add_symbol
operator|!=
name|NULL
operator|&&
name|expressionP
operator|->
name|X_op_symbol
operator|!=
name|NULL
operator|&&
name|expressionP
operator|->
name|X_add_number
operator|==
literal|0
condition|)
block|{
name|expressionS
name|two
decl_stmt|;
name|expressionP
operator|->
name|X_add_symbol
operator|=
name|make_expr_symbol
argument_list|(
name|expressionP
argument_list|)
expr_stmt|;
name|expressionP
operator|->
name|X_op
operator|=
name|O_right_shift
expr_stmt|;
name|two
operator|.
name|X_op
operator|=
name|O_constant
expr_stmt|;
name|two
operator|.
name|X_add_symbol
operator|=
name|two
operator|.
name|X_op_symbol
operator|=
name|NULL
expr_stmt|;
name|two
operator|.
name|X_add_number
operator|=
literal|2
expr_stmt|;
name|expressionP
operator|->
name|X_op_symbol
operator|=
name|make_expr_symbol
argument_list|(
operator|&
name|two
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|as_bad
argument_list|(
literal|"expression too complex code symbol"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
end_function

begin_comment
comment|/* Parse an operand that is machine-specific.     The ARC has a special %-op to adjust addresses so they're usable in    branches.  The "st" is short for the STatus register.    ??? Later expand this to take a flags value too.     ??? We can't create new expression types so we map the %-op's onto the    existing syntax.  This means that the user could use the chosen syntax    to achieve the same effect.  */
end_comment

begin_function
name|void
name|md_operand
parameter_list|(
name|expressionP
parameter_list|)
name|expressionS
modifier|*
name|expressionP
decl_stmt|;
block|{
name|char
modifier|*
name|p
init|=
name|input_line_pointer
decl_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'%'
condition|)
if|if
condition|(
name|strncmp
argument_list|(
name|p
argument_list|,
literal|"%st("
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
block|{
name|input_line_pointer
operator|+=
literal|4
expr_stmt|;
name|expression
argument_list|(
name|expressionP
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|!=
literal|')'
condition|)
block|{
name|as_bad
argument_list|(
literal|"missing ')' in %%-op"
argument_list|)
expr_stmt|;
return|return;
block|}
operator|++
name|input_line_pointer
expr_stmt|;
name|arc_code_symbol
argument_list|(
name|expressionP
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* It could be a register.  */
name|int
name|i
decl_stmt|,
name|l
decl_stmt|;
name|struct
name|arc_ext_operand_value
modifier|*
name|ext_oper
init|=
name|arc_ext_operands
decl_stmt|;
name|p
operator|++
expr_stmt|;
while|while
condition|(
name|ext_oper
condition|)
block|{
name|l
operator|=
name|strlen
argument_list|(
name|ext_oper
operator|->
name|operand
operator|.
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|p
argument_list|,
name|ext_oper
operator|->
name|operand
operator|.
name|name
argument_list|,
name|l
argument_list|)
operator|&&
operator|!
name|ISALNUM
argument_list|(
operator|*
operator|(
name|p
operator|+
name|l
operator|)
argument_list|)
condition|)
block|{
name|input_line_pointer
operator|+=
name|l
operator|+
literal|1
expr_stmt|;
name|expressionP
operator|->
name|X_op
operator|=
name|O_register
expr_stmt|;
name|expressionP
operator|->
name|X_add_number
operator|=
operator|(
name|int
operator|)
operator|&
name|ext_oper
operator|->
name|operand
expr_stmt|;
return|return;
block|}
name|ext_oper
operator|=
name|ext_oper
operator|->
name|next
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|arc_reg_names_count
condition|;
name|i
operator|++
control|)
block|{
name|l
operator|=
name|strlen
argument_list|(
name|arc_reg_names
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|p
argument_list|,
name|arc_reg_names
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|l
argument_list|)
operator|&&
operator|!
name|ISALNUM
argument_list|(
operator|*
operator|(
name|p
operator|+
name|l
operator|)
argument_list|)
condition|)
block|{
name|input_line_pointer
operator|+=
name|l
operator|+
literal|1
expr_stmt|;
name|expressionP
operator|->
name|X_op
operator|=
name|O_register
expr_stmt|;
name|expressionP
operator|->
name|X_add_number
operator|=
operator|(
name|int
operator|)
operator|&
name|arc_reg_names
index|[
name|i
index|]
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* We have no need to default values of symbols.    We could catch register names here, but that is handled by inserting    them all in the symbol table to begin with.  */
end_comment

begin_function
name|symbolS
modifier|*
name|md_undefined_symbol
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Functions concerning expressions.  */
end_comment

begin_comment
comment|/* Parse a .byte, .word, etc. expression.     Values for the status register are specified with %st(label).    `label' will be right shifted by 2.  */
end_comment

begin_function
name|void
name|arc_parse_cons_expression
parameter_list|(
name|exp
parameter_list|,
name|nbytes
parameter_list|)
name|expressionS
modifier|*
name|exp
decl_stmt|;
name|unsigned
name|int
name|nbytes
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|char
modifier|*
name|p
init|=
name|input_line_pointer
decl_stmt|;
name|int
name|code_symbol_fix
init|=
literal|0
decl_stmt|;
for|for
control|(
init|;
operator|!
name|is_end_of_line
index|[
operator|(
name|unsigned
name|char
operator|)
operator|*
name|p
index|]
condition|;
name|p
operator|++
control|)
if|if
condition|(
operator|*
name|p
operator|==
literal|'@'
operator|&&
operator|!
name|strncmp
argument_list|(
name|p
argument_list|,
literal|"@h30"
argument_list|,
literal|4
argument_list|)
condition|)
block|{
name|code_symbol_fix
operator|=
literal|1
expr_stmt|;
name|strcpy
argument_list|(
name|p
argument_list|,
literal|";   "
argument_list|)
expr_stmt|;
block|}
name|expr
argument_list|(
literal|0
argument_list|,
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
name|code_symbol_fix
condition|)
block|{
name|arc_code_symbol
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|input_line_pointer
operator|=
name|p
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Record a fixup for a cons expression.  */
end_comment

begin_function
name|void
name|arc_cons_fix_new
parameter_list|(
name|frag
parameter_list|,
name|where
parameter_list|,
name|nbytes
parameter_list|,
name|exp
parameter_list|)
name|fragS
modifier|*
name|frag
decl_stmt|;
name|int
name|where
decl_stmt|;
name|int
name|nbytes
decl_stmt|;
name|expressionS
modifier|*
name|exp
decl_stmt|;
block|{
if|if
condition|(
name|nbytes
operator|==
literal|4
condition|)
block|{
name|int
name|reloc_type
decl_stmt|;
name|expressionS
name|exptmp
decl_stmt|;
comment|/* This may be a special ARC reloc (eg: %st()).  */
name|reloc_type
operator|=
name|get_arc_exp_reloc_type
argument_list|(
literal|1
argument_list|,
name|BFD_RELOC_32
argument_list|,
name|exp
argument_list|,
operator|&
name|exptmp
argument_list|)
expr_stmt|;
name|fix_new_exp
argument_list|(
name|frag
argument_list|,
name|where
argument_list|,
name|nbytes
argument_list|,
operator|&
name|exptmp
argument_list|,
literal|0
argument_list|,
name|reloc_type
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fix_new_exp
argument_list|(
name|frag
argument_list|,
name|where
argument_list|,
name|nbytes
argument_list|,
name|exp
argument_list|,
literal|0
argument_list|,
name|nbytes
operator|==
literal|2
condition|?
name|BFD_RELOC_16
else|:
name|nbytes
operator|==
literal|8
condition|?
name|BFD_RELOC_64
else|:
name|BFD_RELOC_32
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Functions concerning relocs.  */
end_comment

begin_comment
comment|/* The location from which a PC relative jump should be calculated,    given a PC relative reloc.  */
end_comment

begin_function
name|long
name|md_pcrel_from
parameter_list|(
name|fixP
parameter_list|)
name|fixS
modifier|*
name|fixP
decl_stmt|;
block|{
comment|/* Return the address of the delay slot.  */
return|return
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_address
operator|+
name|fixP
operator|->
name|fx_where
operator|+
name|fixP
operator|->
name|fx_size
return|;
block|}
end_function

begin_comment
comment|/* Compute the reloc type of an expression.    The possibly modified expression is stored in EXPNEW.     This is used to convert the expressions generated by the %-op's into    the appropriate operand type.  It is called for both data in instructions    (operands) and data outside instructions (variables, debugging info, etc.).     Currently supported %-ops:     %st(symbol): represented as "symbol>> 2"                 "st" is short for STatus as in the status register (pc)     DEFAULT_TYPE is the type to use if no special processing is required.     DATA_P is non-zero for data or limm values, zero for insn operands.    Remember that the opcode "insertion fns" cannot be used on data, they're    only for inserting operands into insns.  They also can't be used for limm    values as the insertion routines don't handle limm values.  When called for    insns we return fudged reloc types (real_value - BFD_RELOC_UNUSED).  When    called for data or limm values we use real reloc types.  */
end_comment

begin_function
specifier|static
name|int
name|get_arc_exp_reloc_type
parameter_list|(
name|data_p
parameter_list|,
name|default_type
parameter_list|,
name|exp
parameter_list|,
name|expnew
parameter_list|)
name|int
name|data_p
decl_stmt|;
name|int
name|default_type
decl_stmt|;
name|expressionS
modifier|*
name|exp
decl_stmt|;
name|expressionS
modifier|*
name|expnew
decl_stmt|;
block|{
comment|/* If the expression is "symbol>> 2" we must change it to just "symbol",      as fix_new_exp can't handle it.  Similarly for (symbol - symbol)>> 2.      That's ok though.  What's really going on here is that we're using      ">> 2" as a special syntax for specifying BFD_RELOC_ARC_B26.  */
if|if
condition|(
name|exp
operator|->
name|X_op
operator|==
name|O_right_shift
operator|&&
name|exp
operator|->
name|X_op_symbol
operator|!=
name|NULL
operator|&&
name|exp
operator|->
name|X_op_symbol
operator|->
name|sy_value
operator|.
name|X_op
operator|==
name|O_constant
operator|&&
name|exp
operator|->
name|X_op_symbol
operator|->
name|sy_value
operator|.
name|X_add_number
operator|==
literal|2
operator|&&
name|exp
operator|->
name|X_add_number
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|exp
operator|->
name|X_add_symbol
operator|!=
name|NULL
operator|&&
operator|(
name|exp
operator|->
name|X_add_symbol
operator|->
name|sy_value
operator|.
name|X_op
operator|==
name|O_constant
operator|||
name|exp
operator|->
name|X_add_symbol
operator|->
name|sy_value
operator|.
name|X_op
operator|==
name|O_symbol
operator|)
condition|)
block|{
operator|*
name|expnew
operator|=
operator|*
name|exp
expr_stmt|;
name|expnew
operator|->
name|X_op
operator|=
name|O_symbol
expr_stmt|;
name|expnew
operator|->
name|X_op_symbol
operator|=
name|NULL
expr_stmt|;
return|return
name|data_p
condition|?
name|BFD_RELOC_ARC_B26
else|:
name|arc_operand_map
index|[
literal|'J'
index|]
return|;
block|}
elseif|else
if|if
condition|(
name|exp
operator|->
name|X_add_symbol
operator|!=
name|NULL
operator|&&
name|exp
operator|->
name|X_add_symbol
operator|->
name|sy_value
operator|.
name|X_op
operator|==
name|O_subtract
condition|)
block|{
operator|*
name|expnew
operator|=
name|exp
operator|->
name|X_add_symbol
operator|->
name|sy_value
expr_stmt|;
return|return
name|data_p
condition|?
name|BFD_RELOC_ARC_B26
else|:
name|arc_operand_map
index|[
literal|'J'
index|]
return|;
block|}
block|}
operator|*
name|expnew
operator|=
operator|*
name|exp
expr_stmt|;
return|return
name|default_type
return|;
block|}
end_function

begin_comment
comment|/* Apply a fixup to the object code.  This is called for all the    fixups we generated by the call to fix_new_exp, above.  In the call    above we used a reloc code which was the largest legal reloc code    plus the operand index.  Here we undo that to recover the operand    index.  At this point all symbol values should be fully resolved,    and we attempt to completely resolve the reloc.  If we can not do    that, we determine the correct reloc code and put it back in the fixup.  */
end_comment

begin_function
name|void
name|md_apply_fix3
parameter_list|(
name|fixP
parameter_list|,
name|valP
parameter_list|,
name|seg
parameter_list|)
name|fixS
modifier|*
name|fixP
decl_stmt|;
name|valueT
modifier|*
name|valP
decl_stmt|;
name|segT
name|seg
decl_stmt|;
block|{
if|#
directive|if
literal|0
block|char *buf = fixP->fx_where + fixP->fx_frag->fr_literal;
endif|#
directive|endif
name|valueT
name|value
init|=
operator|*
name|valP
decl_stmt|;
if|if
condition|(
name|fixP
operator|->
name|fx_addsy
operator|==
operator|(
name|symbolS
operator|*
operator|)
name|NULL
condition|)
name|fixP
operator|->
name|fx_done
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|fixP
operator|->
name|fx_pcrel
condition|)
block|{
comment|/* Hack around bfd_install_relocation brain damage.  */
if|if
condition|(
name|S_GET_SEGMENT
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
operator|!=
name|seg
condition|)
name|value
operator|+=
name|md_pcrel_from
argument_list|(
name|fixP
argument_list|)
expr_stmt|;
block|}
comment|/* We can't actually support subtracting a symbol.  */
if|if
condition|(
name|fixP
operator|->
name|fx_subsy
operator|!=
name|NULL
condition|)
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"expression too complex"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|int
operator|)
name|fixP
operator|->
name|fx_r_type
operator|>=
operator|(
name|int
operator|)
name|BFD_RELOC_UNUSED
condition|)
block|{
name|int
name|opindex
decl_stmt|;
specifier|const
name|struct
name|arc_operand
modifier|*
name|operand
decl_stmt|;
name|char
modifier|*
name|where
decl_stmt|;
name|arc_insn
name|insn
decl_stmt|;
name|opindex
operator|=
operator|(
name|int
operator|)
name|fixP
operator|->
name|fx_r_type
operator|-
operator|(
name|int
operator|)
name|BFD_RELOC_UNUSED
expr_stmt|;
name|operand
operator|=
operator|&
name|arc_operands
index|[
name|opindex
index|]
expr_stmt|;
comment|/* Fetch the instruction, insert the fully resolved operand 	 value, and stuff the instruction back again.  */
name|where
operator|=
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_literal
operator|+
name|fixP
operator|->
name|fx_where
expr_stmt|;
if|if
condition|(
name|target_big_endian
condition|)
name|insn
operator|=
name|bfd_getb32
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|where
argument_list|)
expr_stmt|;
else|else
name|insn
operator|=
name|bfd_getl32
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|where
argument_list|)
expr_stmt|;
name|insn
operator|=
name|arc_insert_operand
argument_list|(
name|insn
argument_list|,
name|operand
argument_list|,
operator|-
literal|1
argument_list|,
name|NULL
argument_list|,
operator|(
name|offsetT
operator|)
name|value
argument_list|,
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|)
expr_stmt|;
if|if
condition|(
name|target_big_endian
condition|)
name|bfd_putb32
argument_list|(
operator|(
name|bfd_vma
operator|)
name|insn
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|where
argument_list|)
expr_stmt|;
else|else
name|bfd_putl32
argument_list|(
operator|(
name|bfd_vma
operator|)
name|insn
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|where
argument_list|)
expr_stmt|;
if|if
condition|(
name|fixP
operator|->
name|fx_done
condition|)
block|{
comment|/* Nothing else to do here.  */
return|return;
block|}
comment|/* Determine a BFD reloc value based on the operand information. 	 We are only prepared to turn a few of the operands into relocs. 	 !!! Note that we can't handle limm values here.  Since we're using 	 implicit addends the addend must be inserted into the instruction, 	 however, the opcode insertion routines currently do nothing with 	 limm values.  */
if|if
condition|(
name|operand
operator|->
name|fmt
operator|==
literal|'B'
condition|)
block|{
name|assert
argument_list|(
operator|(
name|operand
operator|->
name|flags
operator|&
name|ARC_OPERAND_RELATIVE_BRANCH
operator|)
operator|!=
literal|0
operator|&&
name|operand
operator|->
name|bits
operator|==
literal|20
operator|&&
name|operand
operator|->
name|shift
operator|==
literal|7
argument_list|)
expr_stmt|;
name|fixP
operator|->
name|fx_r_type
operator|=
name|BFD_RELOC_ARC_B22_PCREL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|operand
operator|->
name|fmt
operator|==
literal|'J'
condition|)
block|{
name|assert
argument_list|(
operator|(
name|operand
operator|->
name|flags
operator|&
name|ARC_OPERAND_ABSOLUTE_BRANCH
operator|)
operator|!=
literal|0
operator|&&
name|operand
operator|->
name|bits
operator|==
literal|24
operator|&&
name|operand
operator|->
name|shift
operator|==
literal|32
argument_list|)
expr_stmt|;
name|fixP
operator|->
name|fx_r_type
operator|=
name|BFD_RELOC_ARC_B26
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|operand
operator|->
name|fmt
operator|==
literal|'L'
condition|)
block|{
name|assert
argument_list|(
operator|(
name|operand
operator|->
name|flags
operator|&
name|ARC_OPERAND_LIMM
operator|)
operator|!=
literal|0
operator|&&
name|operand
operator|->
name|bits
operator|==
literal|32
operator|&&
name|operand
operator|->
name|shift
operator|==
literal|32
argument_list|)
expr_stmt|;
name|fixP
operator|->
name|fx_r_type
operator|=
name|BFD_RELOC_32
expr_stmt|;
block|}
else|else
block|{
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
literal|"unresolved expression that must be resolved"
argument_list|)
expr_stmt|;
name|fixP
operator|->
name|fx_done
operator|=
literal|1
expr_stmt|;
return|return;
block|}
block|}
else|else
block|{
switch|switch
condition|(
name|fixP
operator|->
name|fx_r_type
condition|)
block|{
case|case
name|BFD_RELOC_8
case|:
name|md_number_to_chars
argument_list|(
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_literal
operator|+
name|fixP
operator|->
name|fx_where
argument_list|,
name|value
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_16
case|:
name|md_number_to_chars
argument_list|(
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_literal
operator|+
name|fixP
operator|->
name|fx_where
argument_list|,
name|value
argument_list|,
literal|2
argument_list|)
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_32
case|:
name|md_number_to_chars
argument_list|(
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_literal
operator|+
name|fixP
operator|->
name|fx_where
argument_list|,
name|value
argument_list|,
literal|4
argument_list|)
expr_stmt|;
break|break;
if|#
directive|if
literal|0
block|case BFD_RELOC_64: 	  md_number_to_chars (fixP->fx_frag->fr_literal + fixP->fx_where, 			      value, 8); 	  break;
endif|#
directive|endif
case|case
name|BFD_RELOC_ARC_B26
case|:
comment|/* If !fixP->fx_done then `value' is an implicit addend. 	     We must shift it right by 2 in this case as well because the 	     linker performs the relocation and then adds this in (as opposed 	     to adding this in and then shifting right by 2).  */
name|value
operator|>>=
literal|2
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_literal
operator|+
name|fixP
operator|->
name|fx_where
argument_list|,
name|value
argument_list|,
literal|4
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Translate internal representation of relocation info to BFD target    format.  */
end_comment

begin_function
name|arelent
modifier|*
name|tc_gen_reloc
parameter_list|(
name|section
parameter_list|,
name|fixP
parameter_list|)
name|asection
modifier|*
name|section
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|fixS
modifier|*
name|fixP
decl_stmt|;
block|{
name|arelent
modifier|*
name|reloc
decl_stmt|;
name|reloc
operator|=
operator|(
name|arelent
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|arelent
argument_list|)
argument_list|)
expr_stmt|;
name|reloc
operator|->
name|sym_ptr_ptr
operator|=
operator|&
name|fixP
operator|->
name|fx_addsy
operator|->
name|bsym
expr_stmt|;
name|reloc
operator|->
name|address
operator|=
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_address
operator|+
name|fixP
operator|->
name|fx_where
expr_stmt|;
name|reloc
operator|->
name|howto
operator|=
name|bfd_reloc_type_lookup
argument_list|(
name|stdoutput
argument_list|,
name|fixP
operator|->
name|fx_r_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|reloc
operator|->
name|howto
operator|==
operator|(
name|reloc_howto_type
operator|*
operator|)
name|NULL
condition|)
block|{
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
literal|"internal error: can't export reloc type %d (`%s')"
argument_list|,
name|fixP
operator|->
name|fx_r_type
argument_list|,
name|bfd_get_reloc_code_name
argument_list|(
name|fixP
operator|->
name|fx_r_type
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|assert
argument_list|(
operator|!
name|fixP
operator|->
name|fx_pcrel
operator|==
operator|!
name|reloc
operator|->
name|howto
operator|->
name|pc_relative
argument_list|)
expr_stmt|;
comment|/* Set addend to account for PC being advanced one insn before the      target address is computed.  */
name|reloc
operator|->
name|addend
operator|=
operator|(
name|fixP
operator|->
name|fx_pcrel
condition|?
operator|-
literal|4
else|:
literal|0
operator|)
expr_stmt|;
return|return
name|reloc
return|;
block|}
end_function

end_unit

