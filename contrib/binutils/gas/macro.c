begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* macro.c - macro support for gas and gasp    Copyright (C) 1994, 95, 96, 97, 98, 99, 2000    Free Software Foundation, Inc.     Written by Steve and Judy Chamberlain of Cygnus Support,       sac@cygnus.com     This file is part of GAS, the GNU Assembler.     GAS is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     GAS is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with GAS; see the file COPYING.  If not, write to the Free    Software Foundation, 59 Temple Place - Suite 330, Boston, MA    02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_comment
comment|/* AIX requires this to be the first thing in the file.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__GNUC__
end_ifdef

begin_ifndef
ifndef|#
directive|ifndef
name|alloca
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_function_decl
specifier|extern
name|void
modifier|*
name|alloca
parameter_list|()
function_decl|;
end_function_decl

begin_else
else|#
directive|else
end_else

begin_function_decl
specifier|extern
name|char
modifier|*
name|alloca
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_if
if|#
directive|if
name|HAVE_ALLOCA_H
end_if

begin_include
include|#
directive|include
file|<alloca.h>
end_include

begin_else
else|#
directive|else
end_else

begin_ifdef
ifdef|#
directive|ifdef
name|_AIX
end_ifdef

begin_pragma
pragma|#
directive|pragma
name|alloca
end_pragma

begin_else
else|#
directive|else
end_else

begin_ifndef
ifndef|#
directive|ifndef
name|alloca
end_ifndef

begin_comment
comment|/* predefined by HP cc +Olibcalls */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__STDC__
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__hpux
argument_list|)
end_if

begin_function_decl
specifier|extern
name|char
modifier|*
name|alloca
parameter_list|()
function_decl|;
end_function_decl

begin_else
else|#
directive|else
end_else

begin_function_decl
specifier|extern
name|void
modifier|*
name|alloca
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __STDC__, __hpux */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* alloca */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* _AIX */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_ALLOCA_H */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_STRING_H
end_ifdef

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<strings.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_STDLIB_H
end_ifdef

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"libiberty.h"
end_include

begin_include
include|#
directive|include
file|"sb.h"
end_include

begin_include
include|#
directive|include
file|"hash.h"
end_include

begin_include
include|#
directive|include
file|"macro.h"
end_include

begin_include
include|#
directive|include
file|"asintl.h"
end_include

begin_comment
comment|/* The routines in this file handle macro definition and expansion.    They are called by both gasp and gas.  */
end_comment

begin_comment
comment|/* Internal functions.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|get_token
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|sb
operator|*
operator|,
name|sb
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|getstring
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|sb
operator|*
operator|,
name|sb
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|get_any_string
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|sb
operator|*
operator|,
name|sb
operator|*
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|do_formals
name|PARAMS
argument_list|(
operator|(
name|macro_entry
operator|*
operator|,
name|int
operator|,
name|sb
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|get_apost_token
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|sb
operator|*
operator|,
name|sb
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|sub_actual
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|sb
operator|*
operator|,
name|sb
operator|*
operator|,
expr|struct
name|hash_control
operator|*
operator|,
name|int
operator|,
name|sb
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|macro_expand_body
name|PARAMS
argument_list|(
operator|(
name|sb
operator|*
operator|,
name|sb
operator|*
operator|,
name|formal_entry
operator|*
operator|,
expr|struct
name|hash_control
operator|*
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|macro_expand
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|sb
operator|*
operator|,
name|macro_entry
operator|*
operator|,
name|sb
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|ISWHITE
parameter_list|(
name|x
parameter_list|)
value|((x) == ' ' || (x) == '\t')
end_define

begin_define
define|#
directive|define
name|ISSEP
parameter_list|(
name|x
parameter_list|)
define|\
value|((x) == ' ' || (x) == '\t' || (x) == ',' || (x) == '"' || (x) == ';' \   || (x) == ')' || (x) == '(' \   || ((macro_alternate || macro_mri)&& ((x) == '<' || (x) == '>')))
end_define

begin_define
define|#
directive|define
name|ISBASE
parameter_list|(
name|x
parameter_list|)
define|\
value|((x) == 'b' || (x) == 'B' \    || (x) == 'q' || (x) == 'Q' \    || (x) == 'h' || (x) == 'H' \    || (x) == 'd' || (x) == 'D')
end_define

begin_comment
comment|/* The macro hash table.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|hash_control
modifier|*
name|macro_hash
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Whether any macros have been defined.  */
end_comment

begin_decl_stmt
name|int
name|macro_defined
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Whether we are in GASP alternate mode.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|macro_alternate
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Whether we are in MRI mode.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|macro_mri
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Whether we should strip '@' characters.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|macro_strip_at
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Function to use to parse an expression.  */
end_comment

begin_expr_stmt
specifier|static
name|int
argument_list|(
argument|*macro_expr
argument_list|)
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
name|int
operator|,
name|sb
operator|*
operator|,
name|int
operator|*
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Number of macro expansions that have been done.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|macro_number
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Initialize macro processing.  */
end_comment

begin_function_decl
name|void
name|macro_init
parameter_list|(
name|alternate
parameter_list|,
name|mri
parameter_list|,
name|strip_at
parameter_list|,
name|expr
parameter_list|)
name|int
name|alternate
decl_stmt|;
name|int
name|mri
decl_stmt|;
name|int
name|strip_at
decl_stmt|;
function_decl|int
parameter_list|(
function_decl|*expr
end_function_decl

begin_expr_stmt
unit|)
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
name|int
operator|,
name|sb
operator|*
operator|,
name|int
operator|*
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|macro_hash
operator|=
name|hash_new
argument_list|()
expr_stmt|;
name|macro_defined
operator|=
literal|0
expr_stmt|;
name|macro_alternate
operator|=
name|alternate
expr_stmt|;
name|macro_mri
operator|=
name|mri
expr_stmt|;
name|macro_strip_at
operator|=
name|strip_at
expr_stmt|;
name|macro_expr
operator|=
name|expr
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Switch in and out of MRI mode on the fly.  */
end_comment

begin_function
name|void
name|macro_mri_mode
parameter_list|(
name|mri
parameter_list|)
name|int
name|mri
decl_stmt|;
block|{
name|macro_mri
operator|=
name|mri
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Read input lines till we get to a TO string.    Increase nesting depth if we get a FROM string.    Put the results into sb at PTR.    Add a new input line to an sb using GET_LINE.    Return 1 on success, 0 on unexpected EOF.  */
end_comment

begin_function_decl
name|int
name|buffer_and_nest
parameter_list|(
name|from
parameter_list|,
name|to
parameter_list|,
name|ptr
parameter_list|,
name|get_line
parameter_list|)
specifier|const
name|char
modifier|*
name|from
decl_stmt|;
specifier|const
name|char
modifier|*
name|to
decl_stmt|;
name|sb
modifier|*
name|ptr
decl_stmt|;
function_decl|int
parameter_list|(
function_decl|*get_line
end_function_decl

begin_expr_stmt
unit|)
name|PARAMS
argument_list|(
operator|(
name|sb
operator|*
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|int
name|from_len
init|=
name|strlen
argument_list|(
name|from
argument_list|)
decl_stmt|;
name|int
name|to_len
init|=
name|strlen
argument_list|(
name|to
argument_list|)
decl_stmt|;
name|int
name|depth
init|=
literal|1
decl_stmt|;
name|int
name|line_start
init|=
name|ptr
operator|->
name|len
decl_stmt|;
name|int
name|more
init|=
name|get_line
argument_list|(
name|ptr
argument_list|)
decl_stmt|;
while|while
condition|(
name|more
condition|)
block|{
comment|/* Try and find the first pseudo op on the line.  */
name|int
name|i
init|=
name|line_start
decl_stmt|;
if|if
condition|(
operator|!
name|macro_alternate
operator|&&
operator|!
name|macro_mri
condition|)
block|{
comment|/* With normal syntax we can suck what we want till we get 	     to the dot.  With the alternate, labels have to start in 	     the first column, since we cant tell what's a label and 	     whats a pseudoop.  */
comment|/* Skip leading whitespace.  */
while|while
condition|(
name|i
operator|<
name|ptr
operator|->
name|len
operator|&&
name|ISWHITE
argument_list|(
name|ptr
operator|->
name|ptr
index|[
name|i
index|]
argument_list|)
condition|)
name|i
operator|++
expr_stmt|;
comment|/* Skip over a label.  */
while|while
condition|(
name|i
operator|<
name|ptr
operator|->
name|len
operator|&&
operator|(
name|isalnum
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|ptr
operator|->
name|ptr
index|[
name|i
index|]
argument_list|)
operator|||
name|ptr
operator|->
name|ptr
index|[
name|i
index|]
operator|==
literal|'_'
operator|||
name|ptr
operator|->
name|ptr
index|[
name|i
index|]
operator|==
literal|'$'
operator|)
condition|)
name|i
operator|++
expr_stmt|;
comment|/* And a colon.  */
if|if
condition|(
name|i
operator|<
name|ptr
operator|->
name|len
operator|&&
name|ptr
operator|->
name|ptr
index|[
name|i
index|]
operator|==
literal|':'
condition|)
name|i
operator|++
expr_stmt|;
block|}
comment|/* Skip trailing whitespace.  */
while|while
condition|(
name|i
operator|<
name|ptr
operator|->
name|len
operator|&&
name|ISWHITE
argument_list|(
name|ptr
operator|->
name|ptr
index|[
name|i
index|]
argument_list|)
condition|)
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|ptr
operator|->
name|len
operator|&&
operator|(
name|ptr
operator|->
name|ptr
index|[
name|i
index|]
operator|==
literal|'.'
operator|||
name|macro_alternate
operator|||
name|macro_mri
operator|)
condition|)
block|{
if|if
condition|(
name|ptr
operator|->
name|ptr
index|[
name|i
index|]
operator|==
literal|'.'
condition|)
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|strncasecmp
argument_list|(
name|ptr
operator|->
name|ptr
operator|+
name|i
argument_list|,
name|from
argument_list|,
name|from_len
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|ptr
operator|->
name|len
operator|==
operator|(
name|i
operator|+
name|from_len
operator|)
operator|||
operator|!
name|isalnum
argument_list|(
name|ptr
operator|->
name|ptr
index|[
name|i
operator|+
name|from_len
index|]
argument_list|)
operator|)
condition|)
name|depth
operator|++
expr_stmt|;
if|if
condition|(
name|strncasecmp
argument_list|(
name|ptr
operator|->
name|ptr
operator|+
name|i
argument_list|,
name|to
argument_list|,
name|to_len
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|ptr
operator|->
name|len
operator|==
operator|(
name|i
operator|+
name|to_len
operator|)
operator|||
operator|!
name|isalnum
argument_list|(
name|ptr
operator|->
name|ptr
index|[
name|i
operator|+
name|to_len
index|]
argument_list|)
operator|)
condition|)
block|{
name|depth
operator|--
expr_stmt|;
if|if
condition|(
name|depth
operator|==
literal|0
condition|)
block|{
comment|/* Reset the string to not include the ending rune.  */
name|ptr
operator|->
name|len
operator|=
name|line_start
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|/* Add a CR to the end and keep running.  */
name|sb_add_char
argument_list|(
name|ptr
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
name|line_start
operator|=
name|ptr
operator|->
name|len
expr_stmt|;
name|more
operator|=
name|get_line
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
block|}
comment|/* Return 1 on success, 0 on unexpected EOF.  */
return|return
name|depth
operator|==
literal|0
return|;
block|}
end_block

begin_comment
comment|/* Pick up a token.  */
end_comment

begin_function
specifier|static
name|int
name|get_token
parameter_list|(
name|idx
parameter_list|,
name|in
parameter_list|,
name|name
parameter_list|)
name|int
name|idx
decl_stmt|;
name|sb
modifier|*
name|in
decl_stmt|;
name|sb
modifier|*
name|name
decl_stmt|;
block|{
if|if
condition|(
name|idx
operator|<
name|in
operator|->
name|len
operator|&&
operator|(
name|isalpha
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|in
operator|->
name|ptr
index|[
name|idx
index|]
argument_list|)
operator|||
name|in
operator|->
name|ptr
index|[
name|idx
index|]
operator|==
literal|'_'
operator|||
name|in
operator|->
name|ptr
index|[
name|idx
index|]
operator|==
literal|'$'
operator|)
condition|)
block|{
name|sb_add_char
argument_list|(
name|name
argument_list|,
name|in
operator|->
name|ptr
index|[
name|idx
operator|++
index|]
argument_list|)
expr_stmt|;
while|while
condition|(
name|idx
operator|<
name|in
operator|->
name|len
operator|&&
operator|(
name|isalnum
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|in
operator|->
name|ptr
index|[
name|idx
index|]
argument_list|)
operator|||
name|in
operator|->
name|ptr
index|[
name|idx
index|]
operator|==
literal|'_'
operator|||
name|in
operator|->
name|ptr
index|[
name|idx
index|]
operator|==
literal|'$'
operator|)
condition|)
block|{
name|sb_add_char
argument_list|(
name|name
argument_list|,
name|in
operator|->
name|ptr
index|[
name|idx
operator|++
index|]
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Ignore trailing&.  */
if|if
condition|(
name|macro_alternate
operator|&&
name|idx
operator|<
name|in
operator|->
name|len
operator|&&
name|in
operator|->
name|ptr
index|[
name|idx
index|]
operator|==
literal|'&'
condition|)
name|idx
operator|++
expr_stmt|;
return|return
name|idx
return|;
block|}
end_function

begin_comment
comment|/* Pick up a string.  */
end_comment

begin_function
specifier|static
name|int
name|getstring
parameter_list|(
name|idx
parameter_list|,
name|in
parameter_list|,
name|acc
parameter_list|)
name|int
name|idx
decl_stmt|;
name|sb
modifier|*
name|in
decl_stmt|;
name|sb
modifier|*
name|acc
decl_stmt|;
block|{
name|idx
operator|=
name|sb_skip_white
argument_list|(
name|idx
argument_list|,
name|in
argument_list|)
expr_stmt|;
while|while
condition|(
name|idx
operator|<
name|in
operator|->
name|len
operator|&&
operator|(
name|in
operator|->
name|ptr
index|[
name|idx
index|]
operator|==
literal|'"'
operator|||
operator|(
name|in
operator|->
name|ptr
index|[
name|idx
index|]
operator|==
literal|'<'
operator|&&
operator|(
name|macro_alternate
operator|||
name|macro_mri
operator|)
operator|)
operator|||
operator|(
name|in
operator|->
name|ptr
index|[
name|idx
index|]
operator|==
literal|'\''
operator|&&
name|macro_alternate
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|in
operator|->
name|ptr
index|[
name|idx
index|]
operator|==
literal|'<'
condition|)
block|{
name|int
name|nest
init|=
literal|0
decl_stmt|;
name|idx
operator|++
expr_stmt|;
while|while
condition|(
operator|(
name|in
operator|->
name|ptr
index|[
name|idx
index|]
operator|!=
literal|'>'
operator|||
name|nest
operator|)
operator|&&
name|idx
operator|<
name|in
operator|->
name|len
condition|)
block|{
if|if
condition|(
name|in
operator|->
name|ptr
index|[
name|idx
index|]
operator|==
literal|'!'
condition|)
block|{
name|idx
operator|++
expr_stmt|;
name|sb_add_char
argument_list|(
name|acc
argument_list|,
name|in
operator|->
name|ptr
index|[
name|idx
operator|++
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|in
operator|->
name|ptr
index|[
name|idx
index|]
operator|==
literal|'>'
condition|)
name|nest
operator|--
expr_stmt|;
if|if
condition|(
name|in
operator|->
name|ptr
index|[
name|idx
index|]
operator|==
literal|'<'
condition|)
name|nest
operator|++
expr_stmt|;
name|sb_add_char
argument_list|(
name|acc
argument_list|,
name|in
operator|->
name|ptr
index|[
name|idx
operator|++
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|idx
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|in
operator|->
name|ptr
index|[
name|idx
index|]
operator|==
literal|'"'
operator|||
name|in
operator|->
name|ptr
index|[
name|idx
index|]
operator|==
literal|'\''
condition|)
block|{
name|char
name|tchar
init|=
name|in
operator|->
name|ptr
index|[
name|idx
index|]
decl_stmt|;
name|int
name|escaped
init|=
literal|0
decl_stmt|;
name|idx
operator|++
expr_stmt|;
while|while
condition|(
name|idx
operator|<
name|in
operator|->
name|len
condition|)
block|{
if|if
condition|(
name|in
operator|->
name|ptr
index|[
name|idx
operator|-
literal|1
index|]
operator|==
literal|'\\'
condition|)
name|escaped
operator|^=
literal|1
expr_stmt|;
else|else
name|escaped
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|macro_alternate
operator|&&
name|in
operator|->
name|ptr
index|[
name|idx
index|]
operator|==
literal|'!'
condition|)
block|{
name|idx
operator|++
expr_stmt|;
name|sb_add_char
argument_list|(
name|acc
argument_list|,
name|in
operator|->
name|ptr
index|[
name|idx
index|]
argument_list|)
expr_stmt|;
name|idx
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|escaped
operator|&&
name|in
operator|->
name|ptr
index|[
name|idx
index|]
operator|==
name|tchar
condition|)
block|{
name|sb_add_char
argument_list|(
name|acc
argument_list|,
name|tchar
argument_list|)
expr_stmt|;
name|idx
operator|++
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|in
operator|->
name|ptr
index|[
name|idx
index|]
operator|==
name|tchar
condition|)
block|{
name|idx
operator|++
expr_stmt|;
if|if
condition|(
name|idx
operator|>=
name|in
operator|->
name|len
operator|||
name|in
operator|->
name|ptr
index|[
name|idx
index|]
operator|!=
name|tchar
condition|)
break|break;
block|}
name|sb_add_char
argument_list|(
name|acc
argument_list|,
name|in
operator|->
name|ptr
index|[
name|idx
index|]
argument_list|)
expr_stmt|;
name|idx
operator|++
expr_stmt|;
block|}
block|}
block|}
block|}
return|return
name|idx
return|;
block|}
end_function

begin_comment
comment|/* Fetch string from the input stream,    rules:     'Bxyx<whitespace>  	-> return 'Bxyza     %<char>		-> return string of decimal value of x     "<string>"		-> return string     xyx<whitespace>     -> return xyz */
end_comment

begin_function
specifier|static
name|int
name|get_any_string
parameter_list|(
name|idx
parameter_list|,
name|in
parameter_list|,
name|out
parameter_list|,
name|expand
parameter_list|,
name|pretend_quoted
parameter_list|)
name|int
name|idx
decl_stmt|;
name|sb
modifier|*
name|in
decl_stmt|;
name|sb
modifier|*
name|out
decl_stmt|;
name|int
name|expand
decl_stmt|;
name|int
name|pretend_quoted
decl_stmt|;
block|{
name|sb_reset
argument_list|(
name|out
argument_list|)
expr_stmt|;
name|idx
operator|=
name|sb_skip_white
argument_list|(
name|idx
argument_list|,
name|in
argument_list|)
expr_stmt|;
if|if
condition|(
name|idx
operator|<
name|in
operator|->
name|len
condition|)
block|{
if|if
condition|(
name|in
operator|->
name|len
operator|>
literal|2
operator|&&
name|in
operator|->
name|ptr
index|[
name|idx
operator|+
literal|1
index|]
operator|==
literal|'\''
operator|&&
name|ISBASE
argument_list|(
name|in
operator|->
name|ptr
index|[
name|idx
index|]
argument_list|)
condition|)
block|{
while|while
condition|(
operator|!
name|ISSEP
argument_list|(
name|in
operator|->
name|ptr
index|[
name|idx
index|]
argument_list|)
condition|)
name|sb_add_char
argument_list|(
name|out
argument_list|,
name|in
operator|->
name|ptr
index|[
name|idx
operator|++
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|in
operator|->
name|ptr
index|[
name|idx
index|]
operator|==
literal|'%'
operator|&&
name|macro_alternate
operator|&&
name|expand
condition|)
block|{
name|int
name|val
decl_stmt|;
name|char
name|buf
index|[
literal|20
index|]
decl_stmt|;
comment|/* Turns the next expression into a string.  */
name|idx
operator|=
call|(
modifier|*
name|macro_expr
call|)
argument_list|(
name|_
argument_list|(
literal|"% operator needs absolute expression"
argument_list|)
argument_list|,
name|idx
operator|+
literal|1
argument_list|,
name|in
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%d"
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|sb_add_string
argument_list|(
name|out
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|in
operator|->
name|ptr
index|[
name|idx
index|]
operator|==
literal|'"'
operator|||
operator|(
name|in
operator|->
name|ptr
index|[
name|idx
index|]
operator|==
literal|'<'
operator|&&
operator|(
name|macro_alternate
operator|||
name|macro_mri
operator|)
operator|)
operator|||
operator|(
name|macro_alternate
operator|&&
name|in
operator|->
name|ptr
index|[
name|idx
index|]
operator|==
literal|'\''
operator|)
condition|)
block|{
if|if
condition|(
name|macro_alternate
operator|&&
operator|!
name|macro_strip_at
operator|&&
name|expand
condition|)
block|{
comment|/* Keep the quotes.  */
name|sb_add_char
argument_list|(
name|out
argument_list|,
literal|'\"'
argument_list|)
expr_stmt|;
name|idx
operator|=
name|getstring
argument_list|(
name|idx
argument_list|,
name|in
argument_list|,
name|out
argument_list|)
expr_stmt|;
name|sb_add_char
argument_list|(
name|out
argument_list|,
literal|'\"'
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|idx
operator|=
name|getstring
argument_list|(
name|idx
argument_list|,
name|in
argument_list|,
name|out
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
while|while
condition|(
name|idx
operator|<
name|in
operator|->
name|len
operator|&&
operator|(
name|in
operator|->
name|ptr
index|[
name|idx
index|]
operator|==
literal|'"'
operator|||
name|in
operator|->
name|ptr
index|[
name|idx
index|]
operator|==
literal|'\''
operator|||
name|pretend_quoted
operator|||
operator|(
name|in
operator|->
name|ptr
index|[
name|idx
index|]
operator|!=
literal|' '
operator|&&
name|in
operator|->
name|ptr
index|[
name|idx
index|]
operator|!=
literal|'\t'
operator|&&
name|in
operator|->
name|ptr
index|[
name|idx
index|]
operator|!=
literal|','
operator|&&
operator|(
name|in
operator|->
name|ptr
index|[
name|idx
index|]
operator|!=
literal|'<'
operator|||
operator|(
operator|!
name|macro_alternate
operator|&&
operator|!
name|macro_mri
operator|)
operator|)
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|in
operator|->
name|ptr
index|[
name|idx
index|]
operator|==
literal|'"'
operator|||
name|in
operator|->
name|ptr
index|[
name|idx
index|]
operator|==
literal|'\''
condition|)
block|{
name|char
name|tchar
init|=
name|in
operator|->
name|ptr
index|[
name|idx
index|]
decl_stmt|;
name|sb_add_char
argument_list|(
name|out
argument_list|,
name|in
operator|->
name|ptr
index|[
name|idx
operator|++
index|]
argument_list|)
expr_stmt|;
while|while
condition|(
name|idx
operator|<
name|in
operator|->
name|len
operator|&&
name|in
operator|->
name|ptr
index|[
name|idx
index|]
operator|!=
name|tchar
condition|)
name|sb_add_char
argument_list|(
name|out
argument_list|,
name|in
operator|->
name|ptr
index|[
name|idx
operator|++
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|idx
operator|==
name|in
operator|->
name|len
condition|)
return|return
name|idx
return|;
block|}
name|sb_add_char
argument_list|(
name|out
argument_list|,
name|in
operator|->
name|ptr
index|[
name|idx
operator|++
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|idx
return|;
block|}
end_function

begin_comment
comment|/* Pick up the formal parameters of a macro definition.  */
end_comment

begin_function
specifier|static
name|int
name|do_formals
parameter_list|(
name|macro
parameter_list|,
name|idx
parameter_list|,
name|in
parameter_list|)
name|macro_entry
modifier|*
name|macro
decl_stmt|;
name|int
name|idx
decl_stmt|;
name|sb
modifier|*
name|in
decl_stmt|;
block|{
name|formal_entry
modifier|*
modifier|*
name|p
init|=
operator|&
name|macro
operator|->
name|formals
decl_stmt|;
name|macro
operator|->
name|formal_count
operator|=
literal|0
expr_stmt|;
name|macro
operator|->
name|formal_hash
operator|=
name|hash_new
argument_list|()
expr_stmt|;
while|while
condition|(
name|idx
operator|<
name|in
operator|->
name|len
condition|)
block|{
name|formal_entry
modifier|*
name|formal
decl_stmt|;
name|formal
operator|=
operator|(
name|formal_entry
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|formal_entry
argument_list|)
argument_list|)
expr_stmt|;
name|sb_new
argument_list|(
operator|&
name|formal
operator|->
name|name
argument_list|)
expr_stmt|;
name|sb_new
argument_list|(
operator|&
name|formal
operator|->
name|def
argument_list|)
expr_stmt|;
name|sb_new
argument_list|(
operator|&
name|formal
operator|->
name|actual
argument_list|)
expr_stmt|;
name|idx
operator|=
name|sb_skip_white
argument_list|(
name|idx
argument_list|,
name|in
argument_list|)
expr_stmt|;
name|idx
operator|=
name|get_token
argument_list|(
name|idx
argument_list|,
name|in
argument_list|,
operator|&
name|formal
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|formal
operator|->
name|name
operator|.
name|len
operator|==
literal|0
condition|)
break|break;
name|idx
operator|=
name|sb_skip_white
argument_list|(
name|idx
argument_list|,
name|in
argument_list|)
expr_stmt|;
if|if
condition|(
name|formal
operator|->
name|name
operator|.
name|len
condition|)
block|{
comment|/* This is a formal.  */
if|if
condition|(
name|idx
operator|<
name|in
operator|->
name|len
operator|&&
name|in
operator|->
name|ptr
index|[
name|idx
index|]
operator|==
literal|'='
condition|)
block|{
comment|/* Got a default.  */
name|idx
operator|=
name|get_any_string
argument_list|(
name|idx
operator|+
literal|1
argument_list|,
name|in
argument_list|,
operator|&
name|formal
operator|->
name|def
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Add to macro's hash table.  */
name|hash_jam
argument_list|(
name|macro
operator|->
name|formal_hash
argument_list|,
name|sb_terminate
argument_list|(
operator|&
name|formal
operator|->
name|name
argument_list|)
argument_list|,
name|formal
argument_list|)
expr_stmt|;
name|formal
operator|->
name|index
operator|=
name|macro
operator|->
name|formal_count
expr_stmt|;
name|idx
operator|=
name|sb_skip_comma
argument_list|(
name|idx
argument_list|,
name|in
argument_list|)
expr_stmt|;
name|macro
operator|->
name|formal_count
operator|++
expr_stmt|;
operator|*
name|p
operator|=
name|formal
expr_stmt|;
name|p
operator|=
operator|&
name|formal
operator|->
name|next
expr_stmt|;
operator|*
name|p
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|macro_mri
condition|)
block|{
name|formal_entry
modifier|*
name|formal
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
comment|/* Add a special NARG formal, which macro_expand will set to the          number of arguments.  */
name|formal
operator|=
operator|(
name|formal_entry
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|formal_entry
argument_list|)
argument_list|)
expr_stmt|;
name|sb_new
argument_list|(
operator|&
name|formal
operator|->
name|name
argument_list|)
expr_stmt|;
name|sb_new
argument_list|(
operator|&
name|formal
operator|->
name|def
argument_list|)
expr_stmt|;
name|sb_new
argument_list|(
operator|&
name|formal
operator|->
name|actual
argument_list|)
expr_stmt|;
comment|/* The same MRI assemblers which treat '@' characters also use          the name $NARG.  At least until we find an exception.  */
if|if
condition|(
name|macro_strip_at
condition|)
name|name
operator|=
literal|"$NARG"
expr_stmt|;
else|else
name|name
operator|=
literal|"NARG"
expr_stmt|;
name|sb_add_string
argument_list|(
operator|&
name|formal
operator|->
name|name
argument_list|,
name|name
argument_list|)
expr_stmt|;
comment|/* Add to macro's hash table.  */
name|hash_jam
argument_list|(
name|macro
operator|->
name|formal_hash
argument_list|,
name|name
argument_list|,
name|formal
argument_list|)
expr_stmt|;
name|formal
operator|->
name|index
operator|=
name|NARG_INDEX
expr_stmt|;
operator|*
name|p
operator|=
name|formal
expr_stmt|;
name|formal
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
block|}
return|return
name|idx
return|;
block|}
end_function

begin_comment
comment|/* Define a new macro.  Returns NULL on success, otherwise returns an    error message.  If NAMEP is not NULL, *NAMEP is set to the name of    the macro which was defined.  */
end_comment

begin_function_decl
specifier|const
name|char
modifier|*
name|define_macro
parameter_list|(
name|idx
parameter_list|,
name|in
parameter_list|,
name|label
parameter_list|,
name|get_line
parameter_list|,
name|namep
parameter_list|)
name|int
name|idx
decl_stmt|;
name|sb
modifier|*
name|in
decl_stmt|;
name|sb
modifier|*
name|label
decl_stmt|;
function_decl|int
parameter_list|(
function_decl|*get_line
end_function_decl

begin_expr_stmt
unit|)
name|PARAMS
argument_list|(
operator|(
name|sb
operator|*
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|const
name|char
modifier|*
modifier|*
name|namep
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|macro_entry
modifier|*
name|macro
decl_stmt|;
name|sb
name|name
decl_stmt|;
specifier|const
name|char
modifier|*
name|namestr
decl_stmt|;
name|macro
operator|=
operator|(
name|macro_entry
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|macro_entry
argument_list|)
argument_list|)
expr_stmt|;
name|sb_new
argument_list|(
operator|&
name|macro
operator|->
name|sub
argument_list|)
expr_stmt|;
name|sb_new
argument_list|(
operator|&
name|name
argument_list|)
expr_stmt|;
name|macro
operator|->
name|formal_count
operator|=
literal|0
expr_stmt|;
name|macro
operator|->
name|formals
operator|=
literal|0
expr_stmt|;
name|idx
operator|=
name|sb_skip_white
argument_list|(
name|idx
argument_list|,
name|in
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|buffer_and_nest
argument_list|(
literal|"MACRO"
argument_list|,
literal|"ENDM"
argument_list|,
operator|&
name|macro
operator|->
name|sub
argument_list|,
name|get_line
argument_list|)
condition|)
return|return
name|_
argument_list|(
literal|"unexpected end of file in macro definition"
argument_list|)
return|;
if|if
condition|(
name|label
operator|!=
name|NULL
operator|&&
name|label
operator|->
name|len
operator|!=
literal|0
condition|)
block|{
name|sb_add_sb
argument_list|(
operator|&
name|name
argument_list|,
name|label
argument_list|)
expr_stmt|;
if|if
condition|(
name|idx
operator|<
name|in
operator|->
name|len
operator|&&
name|in
operator|->
name|ptr
index|[
name|idx
index|]
operator|==
literal|'('
condition|)
block|{
comment|/* It's the label: MACRO (formals,...)  sort  */
name|idx
operator|=
name|do_formals
argument_list|(
name|macro
argument_list|,
name|idx
operator|+
literal|1
argument_list|,
name|in
argument_list|)
expr_stmt|;
if|if
condition|(
name|in
operator|->
name|ptr
index|[
name|idx
index|]
operator|!=
literal|')'
condition|)
return|return
name|_
argument_list|(
literal|"missing ) after formals"
argument_list|)
return|;
block|}
else|else
block|{
comment|/* It's the label: MACRO formals,...  sort  */
name|idx
operator|=
name|do_formals
argument_list|(
name|macro
argument_list|,
name|idx
argument_list|,
name|in
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|idx
operator|=
name|get_token
argument_list|(
name|idx
argument_list|,
name|in
argument_list|,
operator|&
name|name
argument_list|)
expr_stmt|;
name|idx
operator|=
name|sb_skip_comma
argument_list|(
name|idx
argument_list|,
name|in
argument_list|)
expr_stmt|;
name|idx
operator|=
name|do_formals
argument_list|(
name|macro
argument_list|,
name|idx
argument_list|,
name|in
argument_list|)
expr_stmt|;
block|}
comment|/* And stick it in the macro hash table.  */
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
name|name
operator|.
name|len
condition|;
name|idx
operator|++
control|)
if|if
condition|(
name|isupper
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|name
operator|.
name|ptr
index|[
name|idx
index|]
argument_list|)
condition|)
name|name
operator|.
name|ptr
index|[
name|idx
index|]
operator|=
name|tolower
argument_list|(
name|name
operator|.
name|ptr
index|[
name|idx
index|]
argument_list|)
expr_stmt|;
name|namestr
operator|=
name|sb_terminate
argument_list|(
operator|&
name|name
argument_list|)
expr_stmt|;
name|hash_jam
argument_list|(
name|macro_hash
argument_list|,
name|namestr
argument_list|,
operator|(
name|PTR
operator|)
name|macro
argument_list|)
expr_stmt|;
name|macro_defined
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|namep
operator|!=
name|NULL
condition|)
operator|*
name|namep
operator|=
name|namestr
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_block

begin_comment
comment|/* Scan a token, and then skip KIND.  */
end_comment

begin_function
specifier|static
name|int
name|get_apost_token
parameter_list|(
name|idx
parameter_list|,
name|in
parameter_list|,
name|name
parameter_list|,
name|kind
parameter_list|)
name|int
name|idx
decl_stmt|;
name|sb
modifier|*
name|in
decl_stmt|;
name|sb
modifier|*
name|name
decl_stmt|;
name|int
name|kind
decl_stmt|;
block|{
name|idx
operator|=
name|get_token
argument_list|(
name|idx
argument_list|,
name|in
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|idx
operator|<
name|in
operator|->
name|len
operator|&&
name|in
operator|->
name|ptr
index|[
name|idx
index|]
operator|==
name|kind
operator|&&
operator|(
operator|!
name|macro_mri
operator|||
name|macro_strip_at
operator|)
operator|&&
operator|(
operator|!
name|macro_strip_at
operator|||
name|kind
operator|==
literal|'@'
operator|)
condition|)
name|idx
operator|++
expr_stmt|;
return|return
name|idx
return|;
block|}
end_function

begin_comment
comment|/* Substitute the actual value for a formal parameter.  */
end_comment

begin_function
specifier|static
name|int
name|sub_actual
parameter_list|(
name|start
parameter_list|,
name|in
parameter_list|,
name|t
parameter_list|,
name|formal_hash
parameter_list|,
name|kind
parameter_list|,
name|out
parameter_list|,
name|copyifnotthere
parameter_list|)
name|int
name|start
decl_stmt|;
name|sb
modifier|*
name|in
decl_stmt|;
name|sb
modifier|*
name|t
decl_stmt|;
name|struct
name|hash_control
modifier|*
name|formal_hash
decl_stmt|;
name|int
name|kind
decl_stmt|;
name|sb
modifier|*
name|out
decl_stmt|;
name|int
name|copyifnotthere
decl_stmt|;
block|{
name|int
name|src
decl_stmt|;
name|formal_entry
modifier|*
name|ptr
decl_stmt|;
name|src
operator|=
name|get_apost_token
argument_list|(
name|start
argument_list|,
name|in
argument_list|,
name|t
argument_list|,
name|kind
argument_list|)
expr_stmt|;
comment|/* See if it's in the macro's hash table, unless this is      macro_strip_at and kind is '@' and the token did not end in '@'.  */
if|if
condition|(
name|macro_strip_at
operator|&&
name|kind
operator|==
literal|'@'
operator|&&
operator|(
name|src
operator|==
name|start
operator|||
name|in
operator|->
name|ptr
index|[
name|src
operator|-
literal|1
index|]
operator|!=
literal|'@'
operator|)
condition|)
name|ptr
operator|=
name|NULL
expr_stmt|;
else|else
name|ptr
operator|=
operator|(
name|formal_entry
operator|*
operator|)
name|hash_find
argument_list|(
name|formal_hash
argument_list|,
name|sb_terminate
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
condition|)
block|{
if|if
condition|(
name|ptr
operator|->
name|actual
operator|.
name|len
condition|)
block|{
name|sb_add_sb
argument_list|(
name|out
argument_list|,
operator|&
name|ptr
operator|->
name|actual
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sb_add_sb
argument_list|(
name|out
argument_list|,
operator|&
name|ptr
operator|->
name|def
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|kind
operator|==
literal|'&'
condition|)
block|{
comment|/* Doing this permits people to use& in macro bodies.  */
name|sb_add_char
argument_list|(
name|out
argument_list|,
literal|'&'
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|copyifnotthere
condition|)
block|{
name|sb_add_sb
argument_list|(
name|out
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sb_add_char
argument_list|(
name|out
argument_list|,
literal|'\\'
argument_list|)
expr_stmt|;
name|sb_add_sb
argument_list|(
name|out
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
return|return
name|src
return|;
block|}
end_function

begin_comment
comment|/* Expand the body of a macro.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|macro_expand_body
parameter_list|(
name|in
parameter_list|,
name|out
parameter_list|,
name|formals
parameter_list|,
name|formal_hash
parameter_list|,
name|comment_char
parameter_list|,
name|locals
parameter_list|)
name|sb
modifier|*
name|in
decl_stmt|;
name|sb
modifier|*
name|out
decl_stmt|;
name|formal_entry
modifier|*
name|formals
decl_stmt|;
name|struct
name|hash_control
modifier|*
name|formal_hash
decl_stmt|;
name|int
name|comment_char
decl_stmt|;
name|int
name|locals
decl_stmt|;
block|{
name|sb
name|t
decl_stmt|;
name|int
name|src
init|=
literal|0
decl_stmt|;
name|int
name|inquote
init|=
literal|0
decl_stmt|;
name|formal_entry
modifier|*
name|loclist
init|=
name|NULL
decl_stmt|;
name|sb_new
argument_list|(
operator|&
name|t
argument_list|)
expr_stmt|;
while|while
condition|(
name|src
operator|<
name|in
operator|->
name|len
condition|)
block|{
if|if
condition|(
name|in
operator|->
name|ptr
index|[
name|src
index|]
operator|==
literal|'&'
condition|)
block|{
name|sb_reset
argument_list|(
operator|&
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|macro_mri
condition|)
block|{
if|if
condition|(
name|src
operator|+
literal|1
operator|<
name|in
operator|->
name|len
operator|&&
name|in
operator|->
name|ptr
index|[
name|src
operator|+
literal|1
index|]
operator|==
literal|'&'
condition|)
name|src
operator|=
name|sub_actual
argument_list|(
name|src
operator|+
literal|2
argument_list|,
name|in
argument_list|,
operator|&
name|t
argument_list|,
name|formal_hash
argument_list|,
literal|'\''
argument_list|,
name|out
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|sb_add_char
argument_list|(
name|out
argument_list|,
name|in
operator|->
name|ptr
index|[
name|src
operator|++
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* FIXME: Why do we do this?  */
name|src
operator|=
name|sub_actual
argument_list|(
name|src
operator|+
literal|1
argument_list|,
name|in
argument_list|,
operator|&
name|t
argument_list|,
name|formal_hash
argument_list|,
literal|'&'
argument_list|,
name|out
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|in
operator|->
name|ptr
index|[
name|src
index|]
operator|==
literal|'\\'
condition|)
block|{
name|src
operator|++
expr_stmt|;
if|if
condition|(
name|in
operator|->
name|ptr
index|[
name|src
index|]
operator|==
name|comment_char
operator|&&
name|comment_char
operator|!=
literal|'\0'
condition|)
block|{
comment|/* This is a comment, just drop the rest of the line.  */
while|while
condition|(
name|src
operator|<
name|in
operator|->
name|len
operator|&&
name|in
operator|->
name|ptr
index|[
name|src
index|]
operator|!=
literal|'\n'
condition|)
name|src
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|in
operator|->
name|ptr
index|[
name|src
index|]
operator|==
literal|'('
condition|)
block|{
comment|/* Sub in till the next ')' literally.  */
name|src
operator|++
expr_stmt|;
while|while
condition|(
name|src
operator|<
name|in
operator|->
name|len
operator|&&
name|in
operator|->
name|ptr
index|[
name|src
index|]
operator|!=
literal|')'
condition|)
block|{
name|sb_add_char
argument_list|(
name|out
argument_list|,
name|in
operator|->
name|ptr
index|[
name|src
operator|++
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|in
operator|->
name|ptr
index|[
name|src
index|]
operator|==
literal|')'
condition|)
name|src
operator|++
expr_stmt|;
else|else
return|return
name|_
argument_list|(
literal|"missplaced )"
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|in
operator|->
name|ptr
index|[
name|src
index|]
operator|==
literal|'@'
condition|)
block|{
comment|/* Sub in the macro invocation number.  */
name|char
name|buffer
index|[
literal|10
index|]
decl_stmt|;
name|src
operator|++
expr_stmt|;
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"%d"
argument_list|,
name|macro_number
argument_list|)
expr_stmt|;
name|sb_add_string
argument_list|(
name|out
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|in
operator|->
name|ptr
index|[
name|src
index|]
operator|==
literal|'&'
condition|)
block|{
comment|/* This is a preprocessor variable name, we don't do them 		 here.  */
name|sb_add_char
argument_list|(
name|out
argument_list|,
literal|'\\'
argument_list|)
expr_stmt|;
name|sb_add_char
argument_list|(
name|out
argument_list|,
literal|'&'
argument_list|)
expr_stmt|;
name|src
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|macro_mri
operator|&&
name|isalnum
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|in
operator|->
name|ptr
index|[
name|src
index|]
argument_list|)
condition|)
block|{
name|int
name|ind
decl_stmt|;
name|formal_entry
modifier|*
name|f
decl_stmt|;
if|if
condition|(
name|isdigit
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|in
operator|->
name|ptr
index|[
name|src
index|]
argument_list|)
condition|)
name|ind
operator|=
name|in
operator|->
name|ptr
index|[
name|src
index|]
operator|-
literal|'0'
expr_stmt|;
elseif|else
if|if
condition|(
name|isupper
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|in
operator|->
name|ptr
index|[
name|src
index|]
argument_list|)
condition|)
name|ind
operator|=
name|in
operator|->
name|ptr
index|[
name|src
index|]
operator|-
literal|'A'
operator|+
literal|10
expr_stmt|;
else|else
name|ind
operator|=
name|in
operator|->
name|ptr
index|[
name|src
index|]
operator|-
literal|'a'
operator|+
literal|10
expr_stmt|;
operator|++
name|src
expr_stmt|;
for|for
control|(
name|f
operator|=
name|formals
init|;
name|f
operator|!=
name|NULL
condition|;
name|f
operator|=
name|f
operator|->
name|next
control|)
block|{
if|if
condition|(
name|f
operator|->
name|index
operator|==
name|ind
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|f
operator|->
name|actual
operator|.
name|len
operator|!=
literal|0
condition|)
name|sb_add_sb
argument_list|(
name|out
argument_list|,
operator|&
name|f
operator|->
name|actual
argument_list|)
expr_stmt|;
else|else
name|sb_add_sb
argument_list|(
name|out
argument_list|,
operator|&
name|f
operator|->
name|def
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
else|else
block|{
name|sb_reset
argument_list|(
operator|&
name|t
argument_list|)
expr_stmt|;
name|src
operator|=
name|sub_actual
argument_list|(
name|src
argument_list|,
name|in
argument_list|,
operator|&
name|t
argument_list|,
name|formal_hash
argument_list|,
literal|'\''
argument_list|,
name|out
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|macro_alternate
operator|||
name|macro_mri
operator|)
operator|&&
operator|(
name|isalpha
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|in
operator|->
name|ptr
index|[
name|src
index|]
argument_list|)
operator|||
name|in
operator|->
name|ptr
index|[
name|src
index|]
operator|==
literal|'_'
operator|||
name|in
operator|->
name|ptr
index|[
name|src
index|]
operator|==
literal|'$'
operator|)
operator|&&
operator|(
operator|!
name|inquote
operator|||
operator|!
name|macro_strip_at
operator|||
operator|(
name|src
operator|>
literal|0
operator|&&
name|in
operator|->
name|ptr
index|[
name|src
operator|-
literal|1
index|]
operator|==
literal|'@'
operator|)
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|locals
operator|||
name|src
operator|+
literal|5
operator|>=
name|in
operator|->
name|len
operator|||
name|strncasecmp
argument_list|(
name|in
operator|->
name|ptr
operator|+
name|src
argument_list|,
literal|"LOCAL"
argument_list|,
literal|5
argument_list|)
operator|!=
literal|0
operator|||
operator|!
name|ISWHITE
argument_list|(
name|in
operator|->
name|ptr
index|[
name|src
operator|+
literal|5
index|]
argument_list|)
condition|)
block|{
name|sb_reset
argument_list|(
operator|&
name|t
argument_list|)
expr_stmt|;
name|src
operator|=
name|sub_actual
argument_list|(
name|src
argument_list|,
name|in
argument_list|,
operator|&
name|t
argument_list|,
name|formal_hash
argument_list|,
operator|(
name|macro_strip_at
operator|&&
name|inquote
operator|)
condition|?
literal|'@'
else|:
literal|'\''
argument_list|,
name|out
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|formal_entry
modifier|*
name|f
decl_stmt|;
name|src
operator|=
name|sb_skip_white
argument_list|(
name|src
operator|+
literal|5
argument_list|,
name|in
argument_list|)
expr_stmt|;
while|while
condition|(
name|in
operator|->
name|ptr
index|[
name|src
index|]
operator|!=
literal|'\n'
operator|&&
name|in
operator|->
name|ptr
index|[
name|src
index|]
operator|!=
name|comment_char
condition|)
block|{
specifier|static
name|int
name|loccnt
decl_stmt|;
name|char
name|buf
index|[
literal|20
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|err
decl_stmt|;
name|f
operator|=
operator|(
name|formal_entry
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|formal_entry
argument_list|)
argument_list|)
expr_stmt|;
name|sb_new
argument_list|(
operator|&
name|f
operator|->
name|name
argument_list|)
expr_stmt|;
name|sb_new
argument_list|(
operator|&
name|f
operator|->
name|def
argument_list|)
expr_stmt|;
name|sb_new
argument_list|(
operator|&
name|f
operator|->
name|actual
argument_list|)
expr_stmt|;
name|f
operator|->
name|index
operator|=
name|LOCAL_INDEX
expr_stmt|;
name|f
operator|->
name|next
operator|=
name|loclist
expr_stmt|;
name|loclist
operator|=
name|f
expr_stmt|;
name|src
operator|=
name|get_token
argument_list|(
name|src
argument_list|,
name|in
argument_list|,
operator|&
name|f
operator|->
name|name
argument_list|)
expr_stmt|;
operator|++
name|loccnt
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"LL%04x"
argument_list|,
name|loccnt
argument_list|)
expr_stmt|;
name|sb_add_string
argument_list|(
operator|&
name|f
operator|->
name|actual
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|err
operator|=
name|hash_jam
argument_list|(
name|formal_hash
argument_list|,
name|sb_terminate
argument_list|(
operator|&
name|f
operator|->
name|name
argument_list|)
argument_list|,
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|NULL
condition|)
return|return
name|err
return|;
name|src
operator|=
name|sb_skip_comma
argument_list|(
name|src
argument_list|,
name|in
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|comment_char
operator|!=
literal|'\0'
operator|&&
name|in
operator|->
name|ptr
index|[
name|src
index|]
operator|==
name|comment_char
operator|&&
name|src
operator|+
literal|1
operator|<
name|in
operator|->
name|len
operator|&&
name|in
operator|->
name|ptr
index|[
name|src
operator|+
literal|1
index|]
operator|==
name|comment_char
operator|&&
operator|!
name|inquote
condition|)
block|{
comment|/* Two comment chars in a row cause the rest of the line to              be dropped.  */
while|while
condition|(
name|src
operator|<
name|in
operator|->
name|len
operator|&&
name|in
operator|->
name|ptr
index|[
name|src
index|]
operator|!=
literal|'\n'
condition|)
name|src
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|in
operator|->
name|ptr
index|[
name|src
index|]
operator|==
literal|'"'
operator|||
operator|(
name|macro_mri
operator|&&
name|in
operator|->
name|ptr
index|[
name|src
index|]
operator|==
literal|'\''
operator|)
condition|)
block|{
name|inquote
operator|=
operator|!
name|inquote
expr_stmt|;
name|sb_add_char
argument_list|(
name|out
argument_list|,
name|in
operator|->
name|ptr
index|[
name|src
operator|++
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|in
operator|->
name|ptr
index|[
name|src
index|]
operator|==
literal|'@'
operator|&&
name|macro_strip_at
condition|)
block|{
operator|++
name|src
expr_stmt|;
if|if
condition|(
name|src
operator|<
name|in
operator|->
name|len
operator|&&
name|in
operator|->
name|ptr
index|[
name|src
index|]
operator|==
literal|'@'
condition|)
block|{
name|sb_add_char
argument_list|(
name|out
argument_list|,
literal|'@'
argument_list|)
expr_stmt|;
operator|++
name|src
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|macro_mri
operator|&&
name|in
operator|->
name|ptr
index|[
name|src
index|]
operator|==
literal|'='
operator|&&
name|src
operator|+
literal|1
operator|<
name|in
operator|->
name|len
operator|&&
name|in
operator|->
name|ptr
index|[
name|src
operator|+
literal|1
index|]
operator|==
literal|'='
condition|)
block|{
name|formal_entry
modifier|*
name|ptr
decl_stmt|;
name|sb_reset
argument_list|(
operator|&
name|t
argument_list|)
expr_stmt|;
name|src
operator|=
name|get_token
argument_list|(
name|src
operator|+
literal|2
argument_list|,
name|in
argument_list|,
operator|&
name|t
argument_list|)
expr_stmt|;
name|ptr
operator|=
operator|(
name|formal_entry
operator|*
operator|)
name|hash_find
argument_list|(
name|formal_hash
argument_list|,
name|sb_terminate
argument_list|(
operator|&
name|t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
operator|==
name|NULL
condition|)
block|{
comment|/* FIXME: We should really return a warning string here,                  but we can't, because the == might be in the MRI                  comment field, and, since the nature of the MRI                  comment field depends upon the exact instruction                  being used, we don't have enough information here to                  figure out whether it is or not.  Instead, we leave                  the == in place, which should cause a syntax error if                  it is not in a comment.  */
name|sb_add_char
argument_list|(
name|out
argument_list|,
literal|'='
argument_list|)
expr_stmt|;
name|sb_add_char
argument_list|(
name|out
argument_list|,
literal|'='
argument_list|)
expr_stmt|;
name|sb_add_sb
argument_list|(
name|out
argument_list|,
operator|&
name|t
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ptr
operator|->
name|actual
operator|.
name|len
condition|)
block|{
name|sb_add_string
argument_list|(
name|out
argument_list|,
literal|"-1"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sb_add_char
argument_list|(
name|out
argument_list|,
literal|'0'
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|sb_add_char
argument_list|(
name|out
argument_list|,
name|in
operator|->
name|ptr
index|[
name|src
operator|++
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|sb_kill
argument_list|(
operator|&
name|t
argument_list|)
expr_stmt|;
while|while
condition|(
name|loclist
operator|!=
name|NULL
condition|)
block|{
name|formal_entry
modifier|*
name|f
decl_stmt|;
name|f
operator|=
name|loclist
operator|->
name|next
expr_stmt|;
comment|/* Setting the value to NULL effectively deletes the entry.  We          avoid calling hash_delete because it doesn't reclaim memory.  */
name|hash_jam
argument_list|(
name|formal_hash
argument_list|,
name|sb_terminate
argument_list|(
operator|&
name|loclist
operator|->
name|name
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|sb_kill
argument_list|(
operator|&
name|loclist
operator|->
name|name
argument_list|)
expr_stmt|;
name|sb_kill
argument_list|(
operator|&
name|loclist
operator|->
name|def
argument_list|)
expr_stmt|;
name|sb_kill
argument_list|(
operator|&
name|loclist
operator|->
name|actual
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|loclist
argument_list|)
expr_stmt|;
name|loclist
operator|=
name|f
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Assign values to the formal parameters of a macro, and expand the    body.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|macro_expand
parameter_list|(
name|idx
parameter_list|,
name|in
parameter_list|,
name|m
parameter_list|,
name|out
parameter_list|,
name|comment_char
parameter_list|)
name|int
name|idx
decl_stmt|;
name|sb
modifier|*
name|in
decl_stmt|;
name|macro_entry
modifier|*
name|m
decl_stmt|;
name|sb
modifier|*
name|out
decl_stmt|;
name|int
name|comment_char
decl_stmt|;
block|{
name|sb
name|t
decl_stmt|;
name|formal_entry
modifier|*
name|ptr
decl_stmt|;
name|formal_entry
modifier|*
name|f
decl_stmt|;
name|int
name|is_positional
init|=
literal|0
decl_stmt|;
name|int
name|is_keyword
init|=
literal|0
decl_stmt|;
name|int
name|narg
init|=
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
name|err
decl_stmt|;
name|sb_new
argument_list|(
operator|&
name|t
argument_list|)
expr_stmt|;
comment|/* Reset any old value the actuals may have.  */
for|for
control|(
name|f
operator|=
name|m
operator|->
name|formals
init|;
name|f
condition|;
name|f
operator|=
name|f
operator|->
name|next
control|)
name|sb_reset
argument_list|(
operator|&
name|f
operator|->
name|actual
argument_list|)
expr_stmt|;
name|f
operator|=
name|m
operator|->
name|formals
expr_stmt|;
while|while
condition|(
name|f
operator|!=
name|NULL
operator|&&
name|f
operator|->
name|index
operator|<
literal|0
condition|)
name|f
operator|=
name|f
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|macro_mri
condition|)
block|{
comment|/* The macro may be called with an optional qualifier, which may          be referred to in the macro body as \0.  */
if|if
condition|(
name|idx
operator|<
name|in
operator|->
name|len
operator|&&
name|in
operator|->
name|ptr
index|[
name|idx
index|]
operator|==
literal|'.'
condition|)
block|{
name|formal_entry
modifier|*
name|n
decl_stmt|;
name|n
operator|=
operator|(
name|formal_entry
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|formal_entry
argument_list|)
argument_list|)
expr_stmt|;
name|sb_new
argument_list|(
operator|&
name|n
operator|->
name|name
argument_list|)
expr_stmt|;
name|sb_new
argument_list|(
operator|&
name|n
operator|->
name|def
argument_list|)
expr_stmt|;
name|sb_new
argument_list|(
operator|&
name|n
operator|->
name|actual
argument_list|)
expr_stmt|;
name|n
operator|->
name|index
operator|=
name|QUAL_INDEX
expr_stmt|;
name|n
operator|->
name|next
operator|=
name|m
operator|->
name|formals
expr_stmt|;
name|m
operator|->
name|formals
operator|=
name|n
expr_stmt|;
name|idx
operator|=
name|get_any_string
argument_list|(
name|idx
operator|+
literal|1
argument_list|,
name|in
argument_list|,
operator|&
name|n
operator|->
name|actual
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Peel off the actuals and store them away in the hash tables' actuals.  */
name|idx
operator|=
name|sb_skip_white
argument_list|(
name|idx
argument_list|,
name|in
argument_list|)
expr_stmt|;
while|while
condition|(
name|idx
operator|<
name|in
operator|->
name|len
operator|&&
name|in
operator|->
name|ptr
index|[
name|idx
index|]
operator|!=
name|comment_char
condition|)
block|{
name|int
name|scan
decl_stmt|;
comment|/* Look and see if it's a positional or keyword arg.  */
name|scan
operator|=
name|idx
expr_stmt|;
while|while
condition|(
name|scan
operator|<
name|in
operator|->
name|len
operator|&&
operator|!
name|ISSEP
argument_list|(
name|in
operator|->
name|ptr
index|[
name|scan
index|]
argument_list|)
operator|&&
operator|!
operator|(
name|macro_mri
operator|&&
name|in
operator|->
name|ptr
index|[
name|scan
index|]
operator|==
literal|'\''
operator|)
operator|&&
operator|(
operator|!
name|macro_alternate
operator|&&
name|in
operator|->
name|ptr
index|[
name|scan
index|]
operator|!=
literal|'='
operator|)
condition|)
name|scan
operator|++
expr_stmt|;
if|if
condition|(
name|scan
operator|<
name|in
operator|->
name|len
operator|&&
operator|!
name|macro_alternate
operator|&&
name|in
operator|->
name|ptr
index|[
name|scan
index|]
operator|==
literal|'='
condition|)
block|{
name|is_keyword
operator|=
literal|1
expr_stmt|;
comment|/* It's OK to go from positional to keyword.  */
comment|/* This is a keyword arg, fetch the formal name and 	     then the actual stuff.  */
name|sb_reset
argument_list|(
operator|&
name|t
argument_list|)
expr_stmt|;
name|idx
operator|=
name|get_token
argument_list|(
name|idx
argument_list|,
name|in
argument_list|,
operator|&
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|in
operator|->
name|ptr
index|[
name|idx
index|]
operator|!=
literal|'='
condition|)
return|return
name|_
argument_list|(
literal|"confusion in formal parameters"
argument_list|)
return|;
comment|/* Lookup the formal in the macro's list.  */
name|ptr
operator|=
operator|(
name|formal_entry
operator|*
operator|)
name|hash_find
argument_list|(
name|m
operator|->
name|formal_hash
argument_list|,
name|sb_terminate
argument_list|(
operator|&
name|t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ptr
condition|)
return|return
name|_
argument_list|(
literal|"macro formal argument does not exist"
argument_list|)
return|;
else|else
block|{
comment|/* Insert this value into the right place.  */
name|sb_reset
argument_list|(
operator|&
name|ptr
operator|->
name|actual
argument_list|)
expr_stmt|;
name|idx
operator|=
name|get_any_string
argument_list|(
name|idx
operator|+
literal|1
argument_list|,
name|in
argument_list|,
operator|&
name|ptr
operator|->
name|actual
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
operator|->
name|actual
operator|.
name|len
operator|>
literal|0
condition|)
operator|++
name|narg
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* This is a positional arg.  */
name|is_positional
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|is_keyword
condition|)
return|return
name|_
argument_list|(
literal|"can't mix positional and keyword arguments"
argument_list|)
return|;
if|if
condition|(
operator|!
name|f
condition|)
block|{
name|formal_entry
modifier|*
modifier|*
name|pf
decl_stmt|;
name|int
name|c
decl_stmt|;
if|if
condition|(
operator|!
name|macro_mri
condition|)
return|return
name|_
argument_list|(
literal|"too many positional arguments"
argument_list|)
return|;
name|f
operator|=
operator|(
name|formal_entry
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|formal_entry
argument_list|)
argument_list|)
expr_stmt|;
name|sb_new
argument_list|(
operator|&
name|f
operator|->
name|name
argument_list|)
expr_stmt|;
name|sb_new
argument_list|(
operator|&
name|f
operator|->
name|def
argument_list|)
expr_stmt|;
name|sb_new
argument_list|(
operator|&
name|f
operator|->
name|actual
argument_list|)
expr_stmt|;
name|f
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|c
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|pf
operator|=
operator|&
name|m
operator|->
name|formals
init|;
operator|*
name|pf
operator|!=
name|NULL
condition|;
name|pf
operator|=
operator|&
operator|(
operator|*
name|pf
operator|)
operator|->
name|next
control|)
if|if
condition|(
operator|(
operator|*
name|pf
operator|)
operator|->
name|index
operator|>=
name|c
condition|)
name|c
operator|=
operator|(
operator|*
name|pf
operator|)
operator|->
name|index
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|c
operator|==
operator|-
literal|1
condition|)
name|c
operator|=
literal|0
expr_stmt|;
operator|*
name|pf
operator|=
name|f
expr_stmt|;
name|f
operator|->
name|index
operator|=
name|c
expr_stmt|;
block|}
name|sb_reset
argument_list|(
operator|&
name|f
operator|->
name|actual
argument_list|)
expr_stmt|;
name|idx
operator|=
name|get_any_string
argument_list|(
name|idx
argument_list|,
name|in
argument_list|,
operator|&
name|f
operator|->
name|actual
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|->
name|actual
operator|.
name|len
operator|>
literal|0
condition|)
operator|++
name|narg
expr_stmt|;
do|do
block|{
name|f
operator|=
name|f
operator|->
name|next
expr_stmt|;
block|}
do|while
condition|(
name|f
operator|!=
name|NULL
operator|&&
name|f
operator|->
name|index
operator|<
literal|0
condition|)
do|;
block|}
if|if
condition|(
operator|!
name|macro_mri
condition|)
name|idx
operator|=
name|sb_skip_comma
argument_list|(
name|idx
argument_list|,
name|in
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|in
operator|->
name|ptr
index|[
name|idx
index|]
operator|==
literal|','
condition|)
operator|++
name|idx
expr_stmt|;
if|if
condition|(
name|ISWHITE
argument_list|(
name|in
operator|->
name|ptr
index|[
name|idx
index|]
argument_list|)
condition|)
break|break;
block|}
block|}
if|if
condition|(
name|macro_mri
condition|)
block|{
name|char
name|buffer
index|[
literal|20
index|]
decl_stmt|;
name|sb_reset
argument_list|(
operator|&
name|t
argument_list|)
expr_stmt|;
name|sb_add_string
argument_list|(
operator|&
name|t
argument_list|,
name|macro_strip_at
condition|?
literal|"$NARG"
else|:
literal|"NARG"
argument_list|)
expr_stmt|;
name|ptr
operator|=
operator|(
name|formal_entry
operator|*
operator|)
name|hash_find
argument_list|(
name|m
operator|->
name|formal_hash
argument_list|,
name|sb_terminate
argument_list|(
operator|&
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|sb_reset
argument_list|(
operator|&
name|ptr
operator|->
name|actual
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"%d"
argument_list|,
name|narg
argument_list|)
expr_stmt|;
name|sb_add_string
argument_list|(
operator|&
name|ptr
operator|->
name|actual
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
block|}
name|err
operator|=
name|macro_expand_body
argument_list|(
operator|&
name|m
operator|->
name|sub
argument_list|,
name|out
argument_list|,
name|m
operator|->
name|formals
argument_list|,
name|m
operator|->
name|formal_hash
argument_list|,
name|comment_char
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|NULL
condition|)
return|return
name|err
return|;
comment|/* Discard any unnamed formal arguments.  */
if|if
condition|(
name|macro_mri
condition|)
block|{
name|formal_entry
modifier|*
modifier|*
name|pf
decl_stmt|;
name|pf
operator|=
operator|&
name|m
operator|->
name|formals
expr_stmt|;
while|while
condition|(
operator|*
name|pf
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|pf
operator|)
operator|->
name|name
operator|.
name|len
operator|!=
literal|0
condition|)
name|pf
operator|=
operator|&
operator|(
operator|*
name|pf
operator|)
operator|->
name|next
expr_stmt|;
else|else
block|{
name|sb_kill
argument_list|(
operator|&
operator|(
operator|*
name|pf
operator|)
operator|->
name|name
argument_list|)
expr_stmt|;
name|sb_kill
argument_list|(
operator|&
operator|(
operator|*
name|pf
operator|)
operator|->
name|def
argument_list|)
expr_stmt|;
name|sb_kill
argument_list|(
operator|&
operator|(
operator|*
name|pf
operator|)
operator|->
name|actual
argument_list|)
expr_stmt|;
name|f
operator|=
operator|(
operator|*
name|pf
operator|)
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
operator|*
name|pf
argument_list|)
expr_stmt|;
operator|*
name|pf
operator|=
name|f
expr_stmt|;
block|}
block|}
block|}
name|sb_kill
argument_list|(
operator|&
name|t
argument_list|)
expr_stmt|;
name|macro_number
operator|++
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Check for a macro.  If one is found, put the expansion into    *EXPAND.  COMMENT_CHAR is the comment character--this is used by    gasp.  Return 1 if a macro is found, 0 otherwise.  */
end_comment

begin_function
name|int
name|check_macro
parameter_list|(
name|line
parameter_list|,
name|expand
parameter_list|,
name|comment_char
parameter_list|,
name|error
parameter_list|,
name|info
parameter_list|)
specifier|const
name|char
modifier|*
name|line
decl_stmt|;
name|sb
modifier|*
name|expand
decl_stmt|;
name|int
name|comment_char
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|error
decl_stmt|;
name|macro_entry
modifier|*
modifier|*
name|info
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
name|char
modifier|*
name|copy
decl_stmt|,
modifier|*
name|cs
decl_stmt|;
name|macro_entry
modifier|*
name|macro
decl_stmt|;
name|sb
name|line_sb
decl_stmt|;
if|if
condition|(
operator|!
name|isalpha
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|line
argument_list|)
operator|&&
operator|*
name|line
operator|!=
literal|'_'
operator|&&
operator|*
name|line
operator|!=
literal|'$'
operator|&&
operator|(
operator|!
name|macro_mri
operator|||
operator|*
name|line
operator|!=
literal|'.'
operator|)
condition|)
return|return
literal|0
return|;
name|s
operator|=
name|line
operator|+
literal|1
expr_stmt|;
while|while
condition|(
name|isalnum
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|s
argument_list|)
operator|||
operator|*
name|s
operator|==
literal|'_'
operator|||
operator|*
name|s
operator|==
literal|'$'
condition|)
operator|++
name|s
expr_stmt|;
name|copy
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|s
operator|-
name|line
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|copy
argument_list|,
name|line
argument_list|,
name|s
operator|-
name|line
argument_list|)
expr_stmt|;
name|copy
index|[
name|s
operator|-
name|line
index|]
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
name|cs
operator|=
name|copy
init|;
operator|*
name|cs
operator|!=
literal|'\0'
condition|;
name|cs
operator|++
control|)
if|if
condition|(
name|isupper
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|cs
argument_list|)
condition|)
operator|*
name|cs
operator|=
name|tolower
argument_list|(
operator|*
name|cs
argument_list|)
expr_stmt|;
name|macro
operator|=
operator|(
name|macro_entry
operator|*
operator|)
name|hash_find
argument_list|(
name|macro_hash
argument_list|,
name|copy
argument_list|)
expr_stmt|;
if|if
condition|(
name|macro
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
comment|/* Wrap the line up in an sb.  */
name|sb_new
argument_list|(
operator|&
name|line_sb
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|s
operator|!=
literal|'\0'
operator|&&
operator|*
name|s
operator|!=
literal|'\n'
operator|&&
operator|*
name|s
operator|!=
literal|'\r'
condition|)
name|sb_add_char
argument_list|(
operator|&
name|line_sb
argument_list|,
operator|*
name|s
operator|++
argument_list|)
expr_stmt|;
name|sb_new
argument_list|(
name|expand
argument_list|)
expr_stmt|;
operator|*
name|error
operator|=
name|macro_expand
argument_list|(
literal|0
argument_list|,
operator|&
name|line_sb
argument_list|,
name|macro
argument_list|,
name|expand
argument_list|,
name|comment_char
argument_list|)
expr_stmt|;
name|sb_kill
argument_list|(
operator|&
name|line_sb
argument_list|)
expr_stmt|;
comment|/* Export the macro information if requested.  */
if|if
condition|(
name|info
condition|)
operator|*
name|info
operator|=
name|macro
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Delete a macro.  */
end_comment

begin_function
name|void
name|delete_macro
parameter_list|(
name|name
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|hash_delete
argument_list|(
name|macro_hash
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle the MRI IRP and IRPC pseudo-ops.  These are handled as a    combined macro definition and execution.  This returns NULL on    success, or an error message otherwise.  */
end_comment

begin_function_decl
specifier|const
name|char
modifier|*
name|expand_irp
parameter_list|(
name|irpc
parameter_list|,
name|idx
parameter_list|,
name|in
parameter_list|,
name|out
parameter_list|,
name|get_line
parameter_list|,
name|comment_char
parameter_list|)
name|int
name|irpc
decl_stmt|;
name|int
name|idx
decl_stmt|;
name|sb
modifier|*
name|in
decl_stmt|;
name|sb
modifier|*
name|out
decl_stmt|;
function_decl|int
parameter_list|(
function_decl|*get_line
end_function_decl

begin_expr_stmt
unit|)
name|PARAMS
argument_list|(
operator|(
name|sb
operator|*
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|comment_char
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|const
name|char
modifier|*
name|mn
decl_stmt|;
name|sb
name|sub
decl_stmt|;
name|formal_entry
name|f
decl_stmt|;
name|struct
name|hash_control
modifier|*
name|h
decl_stmt|;
specifier|const
name|char
modifier|*
name|err
decl_stmt|;
if|if
condition|(
name|irpc
condition|)
name|mn
operator|=
literal|"IRPC"
expr_stmt|;
else|else
name|mn
operator|=
literal|"IRP"
expr_stmt|;
name|idx
operator|=
name|sb_skip_white
argument_list|(
name|idx
argument_list|,
name|in
argument_list|)
expr_stmt|;
name|sb_new
argument_list|(
operator|&
name|sub
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|buffer_and_nest
argument_list|(
name|mn
argument_list|,
literal|"ENDR"
argument_list|,
operator|&
name|sub
argument_list|,
name|get_line
argument_list|)
condition|)
return|return
name|_
argument_list|(
literal|"unexpected end of file in irp or irpc"
argument_list|)
return|;
name|sb_new
argument_list|(
operator|&
name|f
operator|.
name|name
argument_list|)
expr_stmt|;
name|sb_new
argument_list|(
operator|&
name|f
operator|.
name|def
argument_list|)
expr_stmt|;
name|sb_new
argument_list|(
operator|&
name|f
operator|.
name|actual
argument_list|)
expr_stmt|;
name|idx
operator|=
name|get_token
argument_list|(
name|idx
argument_list|,
name|in
argument_list|,
operator|&
name|f
operator|.
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|.
name|name
operator|.
name|len
operator|==
literal|0
condition|)
return|return
name|_
argument_list|(
literal|"missing model parameter"
argument_list|)
return|;
name|h
operator|=
name|hash_new
argument_list|()
expr_stmt|;
name|err
operator|=
name|hash_jam
argument_list|(
name|h
argument_list|,
name|sb_terminate
argument_list|(
operator|&
name|f
operator|.
name|name
argument_list|)
argument_list|,
operator|&
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|NULL
condition|)
return|return
name|err
return|;
name|f
operator|.
name|index
operator|=
literal|1
expr_stmt|;
name|f
operator|.
name|next
operator|=
name|NULL
expr_stmt|;
name|sb_reset
argument_list|(
name|out
argument_list|)
expr_stmt|;
name|idx
operator|=
name|sb_skip_comma
argument_list|(
name|idx
argument_list|,
name|in
argument_list|)
expr_stmt|;
if|if
condition|(
name|idx
operator|>=
name|in
operator|->
name|len
operator|||
name|in
operator|->
name|ptr
index|[
name|idx
index|]
operator|==
name|comment_char
condition|)
block|{
comment|/* Expand once with a null string.  */
name|err
operator|=
name|macro_expand_body
argument_list|(
operator|&
name|sub
argument_list|,
name|out
argument_list|,
operator|&
name|f
argument_list|,
name|h
argument_list|,
name|comment_char
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|NULL
condition|)
return|return
name|err
return|;
block|}
else|else
block|{
if|if
condition|(
name|irpc
operator|&&
name|in
operator|->
name|ptr
index|[
name|idx
index|]
operator|==
literal|'"'
condition|)
operator|++
name|idx
expr_stmt|;
while|while
condition|(
name|idx
operator|<
name|in
operator|->
name|len
operator|&&
name|in
operator|->
name|ptr
index|[
name|idx
index|]
operator|!=
name|comment_char
condition|)
block|{
if|if
condition|(
operator|!
name|irpc
condition|)
name|idx
operator|=
name|get_any_string
argument_list|(
name|idx
argument_list|,
name|in
argument_list|,
operator|&
name|f
operator|.
name|actual
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|in
operator|->
name|ptr
index|[
name|idx
index|]
operator|==
literal|'"'
condition|)
block|{
name|int
name|nxt
decl_stmt|;
name|nxt
operator|=
name|sb_skip_white
argument_list|(
name|idx
operator|+
literal|1
argument_list|,
name|in
argument_list|)
expr_stmt|;
if|if
condition|(
name|nxt
operator|>=
name|in
operator|->
name|len
operator|||
name|in
operator|->
name|ptr
index|[
name|nxt
index|]
operator|==
name|comment_char
condition|)
block|{
name|idx
operator|=
name|nxt
expr_stmt|;
break|break;
block|}
block|}
name|sb_reset
argument_list|(
operator|&
name|f
operator|.
name|actual
argument_list|)
expr_stmt|;
name|sb_add_char
argument_list|(
operator|&
name|f
operator|.
name|actual
argument_list|,
name|in
operator|->
name|ptr
index|[
name|idx
index|]
argument_list|)
expr_stmt|;
operator|++
name|idx
expr_stmt|;
block|}
name|err
operator|=
name|macro_expand_body
argument_list|(
operator|&
name|sub
argument_list|,
name|out
argument_list|,
operator|&
name|f
argument_list|,
name|h
argument_list|,
name|comment_char
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|NULL
condition|)
return|return
name|err
return|;
if|if
condition|(
operator|!
name|irpc
condition|)
name|idx
operator|=
name|sb_skip_comma
argument_list|(
name|idx
argument_list|,
name|in
argument_list|)
expr_stmt|;
else|else
name|idx
operator|=
name|sb_skip_white
argument_list|(
name|idx
argument_list|,
name|in
argument_list|)
expr_stmt|;
block|}
block|}
name|hash_die
argument_list|(
name|h
argument_list|)
expr_stmt|;
name|sb_kill
argument_list|(
operator|&
name|sub
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_block

end_unit

