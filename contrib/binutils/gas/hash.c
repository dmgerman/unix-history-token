begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* hash.c -- gas hash table code    Copyright 1987, 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1998, 1999,    2000    Free Software Foundation, Inc.     This file is part of GAS, the GNU Assembler.     GAS is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     GAS is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with GAS; see the file COPYING.  If not, write to the Free    Software Foundation, 59 Temple Place - Suite 330, Boston, MA    02111-1307, USA.  */
end_comment

begin_comment
comment|/* This version of the hash table code is a wholescale replacement of    the old hash table code, which was fairly bad.  This is based on    the hash table code in BFD, but optimized slightly for the    asssembler.  The assembler does not need to derive structures that    are stored in the hash table.  Instead, it always stores a pointer.    The assembler uses the hash table mostly to store symbols, and we    don't need to confuse the symbol structure with a hash table    structure.  */
end_comment

begin_include
include|#
directive|include
file|"as.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_comment
comment|/* The default number of entries to use when creating a hash table.  */
end_comment

begin_define
define|#
directive|define
name|DEFAULT_SIZE
value|(4051)
end_define

begin_comment
comment|/* An entry in a hash table.  */
end_comment

begin_struct
struct|struct
name|hash_entry
block|{
comment|/* Next entry for this hash code.  */
name|struct
name|hash_entry
modifier|*
name|next
decl_stmt|;
comment|/* String being hashed.  */
specifier|const
name|char
modifier|*
name|string
decl_stmt|;
comment|/* Hash code.  This is the full hash code, not the index into the      table.  */
name|unsigned
name|long
name|hash
decl_stmt|;
comment|/* Pointer being stored in the hash table.  */
name|PTR
name|data
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* A hash table.  */
end_comment

begin_struct
struct|struct
name|hash_control
block|{
comment|/* The hash array.  */
name|struct
name|hash_entry
modifier|*
modifier|*
name|table
decl_stmt|;
comment|/* The number of slots in the hash table.  */
name|unsigned
name|int
name|size
decl_stmt|;
comment|/* An obstack for this hash table.  */
name|struct
name|obstack
name|memory
decl_stmt|;
ifdef|#
directive|ifdef
name|HASH_STATISTICS
comment|/* Statistics.  */
name|unsigned
name|long
name|lookups
decl_stmt|;
name|unsigned
name|long
name|hash_compares
decl_stmt|;
name|unsigned
name|long
name|string_compares
decl_stmt|;
name|unsigned
name|long
name|insertions
decl_stmt|;
name|unsigned
name|long
name|replacements
decl_stmt|;
name|unsigned
name|long
name|deletions
decl_stmt|;
endif|#
directive|endif
comment|/* HASH_STATISTICS */
block|}
struct|;
end_struct

begin_comment
comment|/* Create a hash table.  This return a control block.  */
end_comment

begin_function
name|struct
name|hash_control
modifier|*
name|hash_new
parameter_list|()
block|{
name|unsigned
name|int
name|size
decl_stmt|;
name|struct
name|hash_control
modifier|*
name|ret
decl_stmt|;
name|unsigned
name|int
name|alloc
decl_stmt|;
name|size
operator|=
name|DEFAULT_SIZE
expr_stmt|;
name|ret
operator|=
operator|(
expr|struct
name|hash_control
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
expr|*
name|ret
argument_list|)
expr_stmt|;
name|obstack_begin
argument_list|(
operator|&
name|ret
operator|->
name|memory
argument_list|,
name|chunksize
argument_list|)
expr_stmt|;
name|alloc
operator|=
name|size
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|hash_entry
operator|*
argument_list|)
expr_stmt|;
name|ret
operator|->
name|table
operator|=
operator|(
expr|struct
name|hash_entry
operator|*
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|ret
operator|->
name|memory
argument_list|,
name|alloc
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|ret
operator|->
name|table
argument_list|,
literal|0
argument_list|,
name|alloc
argument_list|)
expr_stmt|;
name|ret
operator|->
name|size
operator|=
name|size
expr_stmt|;
ifdef|#
directive|ifdef
name|HASH_STATISTICS
name|ret
operator|->
name|lookups
operator|=
literal|0
expr_stmt|;
name|ret
operator|->
name|hash_compares
operator|=
literal|0
expr_stmt|;
name|ret
operator|->
name|string_compares
operator|=
literal|0
expr_stmt|;
name|ret
operator|->
name|insertions
operator|=
literal|0
expr_stmt|;
name|ret
operator|->
name|replacements
operator|=
literal|0
expr_stmt|;
name|ret
operator|->
name|deletions
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Delete a hash table, freeing all allocated memory.  */
end_comment

begin_function
name|void
name|hash_die
parameter_list|(
name|table
parameter_list|)
name|struct
name|hash_control
modifier|*
name|table
decl_stmt|;
block|{
name|obstack_free
argument_list|(
operator|&
name|table
operator|->
name|memory
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|table
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Look up a string in a hash table.  This returns a pointer to the    hash_entry, or NULL if the string is not in the table.  If PLIST is    not NULL, this sets *PLIST to point to the start of the list which    would hold this hash entry.  If PHASH is not NULL, this sets *PHASH    to the hash code for KEY.     Each time we look up a string, we move it to the start of the list    for its hash code, to take advantage of referential locality.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|hash_entry
modifier|*
name|hash_lookup
name|PARAMS
argument_list|(
operator|(
expr|struct
name|hash_control
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
expr|struct
name|hash_entry
operator|*
operator|*
operator|*
operator|,
name|unsigned
name|long
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|struct
name|hash_entry
modifier|*
name|hash_lookup
parameter_list|(
name|table
parameter_list|,
name|key
parameter_list|,
name|plist
parameter_list|,
name|phash
parameter_list|)
name|struct
name|hash_control
modifier|*
name|table
decl_stmt|;
specifier|const
name|char
modifier|*
name|key
decl_stmt|;
name|struct
name|hash_entry
modifier|*
modifier|*
modifier|*
name|plist
decl_stmt|;
name|unsigned
name|long
modifier|*
name|phash
decl_stmt|;
block|{
specifier|register
name|unsigned
name|long
name|hash
decl_stmt|;
name|unsigned
name|int
name|len
decl_stmt|;
specifier|register
specifier|const
name|unsigned
name|char
modifier|*
name|s
decl_stmt|;
specifier|register
name|unsigned
name|int
name|c
decl_stmt|;
name|unsigned
name|int
name|index
decl_stmt|;
name|struct
name|hash_entry
modifier|*
modifier|*
name|list
decl_stmt|;
name|struct
name|hash_entry
modifier|*
name|p
decl_stmt|;
name|struct
name|hash_entry
modifier|*
name|prev
decl_stmt|;
ifdef|#
directive|ifdef
name|HASH_STATISTICS
operator|++
name|table
operator|->
name|lookups
expr_stmt|;
endif|#
directive|endif
name|hash
operator|=
literal|0
expr_stmt|;
name|len
operator|=
literal|0
expr_stmt|;
name|s
operator|=
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
name|key
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|s
operator|++
operator|)
operator|!=
literal|'\0'
condition|)
block|{
name|hash
operator|+=
name|c
operator|+
operator|(
name|c
operator|<<
literal|17
operator|)
expr_stmt|;
name|hash
operator|^=
name|hash
operator|>>
literal|2
expr_stmt|;
operator|++
name|len
expr_stmt|;
block|}
name|hash
operator|+=
name|len
operator|+
operator|(
name|len
operator|<<
literal|17
operator|)
expr_stmt|;
name|hash
operator|^=
name|hash
operator|>>
literal|2
expr_stmt|;
if|if
condition|(
name|phash
operator|!=
name|NULL
condition|)
operator|*
name|phash
operator|=
name|hash
expr_stmt|;
name|index
operator|=
name|hash
operator|%
name|table
operator|->
name|size
expr_stmt|;
name|list
operator|=
name|table
operator|->
name|table
operator|+
name|index
expr_stmt|;
if|if
condition|(
name|plist
operator|!=
name|NULL
condition|)
operator|*
name|plist
operator|=
name|list
expr_stmt|;
name|prev
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|p
operator|=
operator|*
name|list
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
ifdef|#
directive|ifdef
name|HASH_STATISTICS
operator|++
name|table
operator|->
name|hash_compares
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|p
operator|->
name|hash
operator|==
name|hash
condition|)
block|{
ifdef|#
directive|ifdef
name|HASH_STATISTICS
operator|++
name|table
operator|->
name|string_compares
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|strcmp
argument_list|(
name|p
operator|->
name|string
argument_list|,
name|key
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|prev
operator|!=
name|NULL
condition|)
block|{
name|prev
operator|->
name|next
operator|=
name|p
operator|->
name|next
expr_stmt|;
name|p
operator|->
name|next
operator|=
operator|*
name|list
expr_stmt|;
operator|*
name|list
operator|=
name|p
expr_stmt|;
block|}
return|return
name|p
return|;
block|}
block|}
name|prev
operator|=
name|p
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Insert an entry into a hash table.  This returns NULL on success.    On error, it returns a printable string indicating the error.  It    is considered to be an error if the entry already exists in the    hash table.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|hash_insert
parameter_list|(
name|table
parameter_list|,
name|key
parameter_list|,
name|value
parameter_list|)
name|struct
name|hash_control
modifier|*
name|table
decl_stmt|;
specifier|const
name|char
modifier|*
name|key
decl_stmt|;
name|PTR
name|value
decl_stmt|;
block|{
name|struct
name|hash_entry
modifier|*
name|p
decl_stmt|;
name|struct
name|hash_entry
modifier|*
modifier|*
name|list
decl_stmt|;
name|unsigned
name|long
name|hash
decl_stmt|;
name|p
operator|=
name|hash_lookup
argument_list|(
name|table
argument_list|,
name|key
argument_list|,
operator|&
name|list
argument_list|,
operator|&
name|hash
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
return|return
literal|"exists"
return|;
ifdef|#
directive|ifdef
name|HASH_STATISTICS
operator|++
name|table
operator|->
name|insertions
expr_stmt|;
endif|#
directive|endif
name|p
operator|=
operator|(
expr|struct
name|hash_entry
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|table
operator|->
name|memory
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|->
name|string
operator|=
name|key
expr_stmt|;
name|p
operator|->
name|hash
operator|=
name|hash
expr_stmt|;
name|p
operator|->
name|data
operator|=
name|value
expr_stmt|;
name|p
operator|->
name|next
operator|=
operator|*
name|list
expr_stmt|;
operator|*
name|list
operator|=
name|p
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Insert or replace an entry in a hash table.  This returns NULL on    success.  On error, it returns a printable string indicating the    error.  If an entry already exists, its value is replaced.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|hash_jam
parameter_list|(
name|table
parameter_list|,
name|key
parameter_list|,
name|value
parameter_list|)
name|struct
name|hash_control
modifier|*
name|table
decl_stmt|;
specifier|const
name|char
modifier|*
name|key
decl_stmt|;
name|PTR
name|value
decl_stmt|;
block|{
name|struct
name|hash_entry
modifier|*
name|p
decl_stmt|;
name|struct
name|hash_entry
modifier|*
modifier|*
name|list
decl_stmt|;
name|unsigned
name|long
name|hash
decl_stmt|;
name|p
operator|=
name|hash_lookup
argument_list|(
name|table
argument_list|,
name|key
argument_list|,
operator|&
name|list
argument_list|,
operator|&
name|hash
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|HASH_STATISTICS
operator|++
name|table
operator|->
name|replacements
expr_stmt|;
endif|#
directive|endif
name|p
operator|->
name|data
operator|=
name|value
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|HASH_STATISTICS
operator|++
name|table
operator|->
name|insertions
expr_stmt|;
endif|#
directive|endif
name|p
operator|=
operator|(
expr|struct
name|hash_entry
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|table
operator|->
name|memory
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|->
name|string
operator|=
name|key
expr_stmt|;
name|p
operator|->
name|hash
operator|=
name|hash
expr_stmt|;
name|p
operator|->
name|data
operator|=
name|value
expr_stmt|;
name|p
operator|->
name|next
operator|=
operator|*
name|list
expr_stmt|;
operator|*
name|list
operator|=
name|p
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Replace an existing entry in a hash table.  This returns the old    value stored for the entry.  If the entry is not found in the hash    table, this does nothing and returns NULL.  */
end_comment

begin_function
name|PTR
name|hash_replace
parameter_list|(
name|table
parameter_list|,
name|key
parameter_list|,
name|value
parameter_list|)
name|struct
name|hash_control
modifier|*
name|table
decl_stmt|;
specifier|const
name|char
modifier|*
name|key
decl_stmt|;
name|PTR
name|value
decl_stmt|;
block|{
name|struct
name|hash_entry
modifier|*
name|p
decl_stmt|;
name|PTR
name|ret
decl_stmt|;
name|p
operator|=
name|hash_lookup
argument_list|(
name|table
argument_list|,
name|key
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
ifdef|#
directive|ifdef
name|HASH_STATISTICS
operator|++
name|table
operator|->
name|replacements
expr_stmt|;
endif|#
directive|endif
name|ret
operator|=
name|p
operator|->
name|data
expr_stmt|;
name|p
operator|->
name|data
operator|=
name|value
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Find an entry in a hash table, returning its value.  Returns NULL    if the entry is not found.  */
end_comment

begin_function
name|PTR
name|hash_find
parameter_list|(
name|table
parameter_list|,
name|key
parameter_list|)
name|struct
name|hash_control
modifier|*
name|table
decl_stmt|;
specifier|const
name|char
modifier|*
name|key
decl_stmt|;
block|{
name|struct
name|hash_entry
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|hash_lookup
argument_list|(
name|table
argument_list|,
name|key
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
return|return
name|p
operator|->
name|data
return|;
block|}
end_function

begin_comment
comment|/* Delete an entry from a hash table.  This returns the value stored    for that entry, or NULL if there is no such entry.  */
end_comment

begin_function
name|PTR
name|hash_delete
parameter_list|(
name|table
parameter_list|,
name|key
parameter_list|)
name|struct
name|hash_control
modifier|*
name|table
decl_stmt|;
specifier|const
name|char
modifier|*
name|key
decl_stmt|;
block|{
name|struct
name|hash_entry
modifier|*
name|p
decl_stmt|;
name|struct
name|hash_entry
modifier|*
modifier|*
name|list
decl_stmt|;
name|p
operator|=
name|hash_lookup
argument_list|(
name|table
argument_list|,
name|key
argument_list|,
operator|&
name|list
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|p
operator|!=
operator|*
name|list
condition|)
name|abort
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|HASH_STATISTICS
operator|++
name|table
operator|->
name|deletions
expr_stmt|;
endif|#
directive|endif
operator|*
name|list
operator|=
name|p
operator|->
name|next
expr_stmt|;
comment|/* Note that we never reclaim the memory for this entry.  If gas      ever starts deleting hash table entries in a big way, this will      have to change.  */
return|return
name|p
operator|->
name|data
return|;
block|}
end_function

begin_comment
comment|/* Traverse a hash table.  Call the function on every entry in the    hash table.  */
end_comment

begin_function_decl
name|void
name|hash_traverse
parameter_list|(
name|table
parameter_list|,
name|pfn
parameter_list|)
name|struct
name|hash_control
modifier|*
name|table
decl_stmt|;
function_decl|void
parameter_list|(
function_decl|*pfn
end_function_decl

begin_expr_stmt
unit|)
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|key
operator|,
name|PTR
name|value
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|unsigned
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|table
operator|->
name|size
condition|;
operator|++
name|i
control|)
block|{
name|struct
name|hash_entry
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|table
operator|->
name|table
index|[
name|i
index|]
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
call|(
modifier|*
name|pfn
call|)
argument_list|(
name|p
operator|->
name|string
argument_list|,
name|p
operator|->
name|data
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* Print hash table statistics on the specified file.  NAME is the    name of the hash table, used for printing a header.  */
end_comment

begin_function
name|void
name|hash_print_statistics
parameter_list|(
name|f
parameter_list|,
name|name
parameter_list|,
name|table
parameter_list|)
name|FILE
modifier|*
name|f
name|ATTRIBUTE_UNUSED
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|struct
name|hash_control
modifier|*
name|table
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|HASH_STATISTICS
name|unsigned
name|int
name|i
decl_stmt|;
name|unsigned
name|long
name|total
decl_stmt|;
name|unsigned
name|long
name|empty
decl_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"%s hash statistics:\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\t%lu lookups\n"
argument_list|,
name|table
operator|->
name|lookups
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\t%lu hash comparisons\n"
argument_list|,
name|table
operator|->
name|hash_compares
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\t%lu string comparisons\n"
argument_list|,
name|table
operator|->
name|string_compares
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\t%lu insertions\n"
argument_list|,
name|table
operator|->
name|insertions
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\t%lu replacements\n"
argument_list|,
name|table
operator|->
name|replacements
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\t%lu deletions\n"
argument_list|,
name|table
operator|->
name|deletions
argument_list|)
expr_stmt|;
name|total
operator|=
literal|0
expr_stmt|;
name|empty
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|table
operator|->
name|size
condition|;
operator|++
name|i
control|)
block|{
name|struct
name|hash_entry
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|table
operator|->
name|table
index|[
name|i
index|]
operator|==
name|NULL
condition|)
operator|++
name|empty
expr_stmt|;
else|else
block|{
for|for
control|(
name|p
operator|=
name|table
operator|->
name|table
index|[
name|i
index|]
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
operator|++
name|total
expr_stmt|;
block|}
block|}
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\t%g average chain length\n"
argument_list|,
operator|(
name|double
operator|)
name|total
operator|/
name|table
operator|->
name|size
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\t%lu empty slots\n"
argument_list|,
name|empty
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|TEST
end_ifdef

begin_comment
comment|/* This test program is left over from the old hash table code.  */
end_comment

begin_comment
comment|/* Number of hash tables to maintain (at once) in any testing.  */
end_comment

begin_define
define|#
directive|define
name|TABLES
value|(6)
end_define

begin_comment
comment|/* We can have 12 statistics.  */
end_comment

begin_define
define|#
directive|define
name|STATBUFSIZE
value|(12)
end_define

begin_comment
comment|/* Display statistics here.  */
end_comment

begin_decl_stmt
name|int
name|statbuf
index|[
name|STATBUFSIZE
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Human farts here.  */
end_comment

begin_decl_stmt
name|char
name|answer
index|[
literal|100
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* We test many hash tables at once.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|hashtable
index|[
name|TABLES
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Points to curent hash_control.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|h
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
modifier|*
name|pp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|value
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|used
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|command
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number 0:TABLES-1 of current hashed symbol table.  */
end_comment

begin_decl_stmt
name|int
name|number
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|main
parameter_list|()
block|{
name|void
name|applicatee
parameter_list|()
function_decl|;
name|void
name|destroy
parameter_list|()
function_decl|;
name|char
modifier|*
name|what
parameter_list|()
function_decl|;
name|int
modifier|*
name|ip
decl_stmt|;
name|number
operator|=
literal|0
expr_stmt|;
name|h
operator|=
literal|0
expr_stmt|;
name|printf
argument_list|(
literal|"type h<RETURN> for help\n"
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|printf
argument_list|(
literal|"hash_test command: "
argument_list|)
expr_stmt|;
name|gets
argument_list|(
name|answer
argument_list|)
expr_stmt|;
name|command
operator|=
name|answer
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|isupper
argument_list|(
name|command
argument_list|)
condition|)
name|command
operator|=
name|tolower
argument_list|(
name|command
argument_list|)
expr_stmt|;
comment|/* Ecch!  */
switch|switch
condition|(
name|command
condition|)
block|{
case|case
literal|'#'
case|:
name|printf
argument_list|(
literal|"old hash table #=%d.\n"
argument_list|,
name|number
argument_list|)
expr_stmt|;
name|whattable
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
for|for
control|(
name|pp
operator|=
name|hashtable
init|;
name|pp
operator|<
name|hashtable
operator|+
name|TABLES
condition|;
name|pp
operator|++
control|)
block|{
name|printf
argument_list|(
literal|"address of hash table #%d control block is %xx\n"
argument_list|,
name|pp
operator|-
name|hashtable
argument_list|,
operator|*
name|pp
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'a'
case|:
name|hash_traverse
argument_list|(
name|h
argument_list|,
name|applicatee
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|hash_traverse
argument_list|(
name|h
argument_list|,
name|destroy
argument_list|)
expr_stmt|;
name|hash_die
argument_list|(
name|h
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|p
operator|=
name|hash_find
argument_list|(
name|h
argument_list|,
name|name
operator|=
name|what
argument_list|(
literal|"symbol"
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"value of \"%s\" is \"%s\"\n"
argument_list|,
name|name
argument_list|,
name|p
condition|?
name|p
else|:
literal|"NOT-PRESENT"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
name|printf
argument_list|(
literal|"# show old, select new default hash table number\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"? display all hashtable control block addresses\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"a apply a simple display-er to each symbol in table\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"d die: destroy hashtable\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"f find value of nominated symbol\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"h this help\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"i insert value into symbol\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"j jam value into symbol\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"n new hashtable\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"r replace a value with another\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"s say what %% of table is used\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"q exit this program\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"x delete a symbol from table, report its value\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
name|p
operator|=
name|hash_insert
argument_list|(
name|h
argument_list|,
name|name
operator|=
name|what
argument_list|(
literal|"symbol"
argument_list|)
argument_list|,
name|value
operator|=
name|what
argument_list|(
literal|"value"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
condition|)
block|{
name|printf
argument_list|(
literal|"symbol=\"%s\"  value=\"%s\"  error=%s\n"
argument_list|,
name|name
argument_list|,
name|value
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'j'
case|:
name|p
operator|=
name|hash_jam
argument_list|(
name|h
argument_list|,
name|name
operator|=
name|what
argument_list|(
literal|"symbol"
argument_list|)
argument_list|,
name|value
operator|=
name|what
argument_list|(
literal|"value"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
condition|)
block|{
name|printf
argument_list|(
literal|"symbol=\"%s\"  value=\"%s\"  error=%s\n"
argument_list|,
name|name
argument_list|,
name|value
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'n'
case|:
name|h
operator|=
name|hashtable
index|[
name|number
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|hash_new
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'q'
case|:
name|exit
argument_list|(
name|EXIT_SUCCESS
argument_list|)
expr_stmt|;
case|case
literal|'r'
case|:
name|p
operator|=
name|hash_replace
argument_list|(
name|h
argument_list|,
name|name
operator|=
name|what
argument_list|(
literal|"symbol"
argument_list|)
argument_list|,
name|value
operator|=
name|what
argument_list|(
literal|"value"
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"old value was \"%s\"\n"
argument_list|,
name|p
condition|?
name|p
else|:
literal|"{}"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|hash_say
argument_list|(
name|h
argument_list|,
name|statbuf
argument_list|,
name|STATBUFSIZE
argument_list|)
expr_stmt|;
for|for
control|(
name|ip
operator|=
name|statbuf
init|;
name|ip
operator|<
name|statbuf
operator|+
name|STATBUFSIZE
condition|;
name|ip
operator|++
control|)
block|{
name|printf
argument_list|(
literal|"%d "
argument_list|,
operator|*
name|ip
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
name|p
operator|=
name|hash_delete
argument_list|(
name|h
argument_list|,
name|name
operator|=
name|what
argument_list|(
literal|"symbol"
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"old value was \"%s\"\n"
argument_list|,
name|p
condition|?
name|p
else|:
literal|"{}"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"I can't understand command \"%c\"\n"
argument_list|,
name|command
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_function
name|char
modifier|*
name|what
parameter_list|(
name|description
parameter_list|)
name|char
modifier|*
name|description
decl_stmt|;
block|{
name|char
modifier|*
name|retval
decl_stmt|;
name|char
modifier|*
name|malloc
parameter_list|()
function_decl|;
name|printf
argument_list|(
literal|"   %s : "
argument_list|,
name|description
argument_list|)
expr_stmt|;
name|gets
argument_list|(
name|answer
argument_list|)
expr_stmt|;
comment|/* Will one day clean up answer here.  */
name|retval
operator|=
name|malloc
argument_list|(
name|strlen
argument_list|(
name|answer
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|retval
condition|)
block|{
name|error
argument_list|(
literal|"room"
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|retval
argument_list|,
name|answer
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_function
name|void
name|destroy
parameter_list|(
name|string
parameter_list|,
name|value
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
name|char
modifier|*
name|value
decl_stmt|;
block|{
name|free
argument_list|(
name|string
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|applicatee
parameter_list|(
name|string
parameter_list|,
name|value
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
name|char
modifier|*
name|value
decl_stmt|;
block|{
name|printf
argument_list|(
literal|"%.20s-%.20s\n"
argument_list|,
name|string
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Determine number: what hash table to use.    Also determine h: points to hash_control.  */
end_comment

begin_function
name|void
name|whattable
parameter_list|()
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
name|printf
argument_list|(
literal|"   what hash table (%d:%d) ?  "
argument_list|,
literal|0
argument_list|,
name|TABLES
operator|-
literal|1
argument_list|)
expr_stmt|;
name|gets
argument_list|(
name|answer
argument_list|)
expr_stmt|;
name|sscanf
argument_list|(
name|answer
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|number
argument_list|)
expr_stmt|;
if|if
condition|(
name|number
operator|>=
literal|0
operator|&&
name|number
operator|<
name|TABLES
condition|)
block|{
name|h
operator|=
name|hashtable
index|[
name|number
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|h
condition|)
block|{
name|printf
argument_list|(
literal|"warning: current hash-table-#%d. has no hash-control\n"
argument_list|,
name|number
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"invalid hash table number: %d\n"
argument_list|,
name|number
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* TEST */
end_comment

end_unit

