begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* hash.c - hash table lookup strings -    Copyright (C) 1987, 90, 91, 92, 93, 94, 95, 1996    Free Software Foundation, Inc.     This file is part of GAS, the GNU Assembler.     GAS is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     GAS is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with GAS; see the file COPYING.  If not, write to    the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/*  * BUGS, GRIPES, APOLOGIA etc.  *  * A typical user doesn't need ALL this: I intend to make a library out  * of it one day - Dean Elsner.  * Also, I want to change the definition of a symbol to (address,length)  * so I can put arbitrary binary in the names stored. [see hsh.c for that]  *  * This slime is common coupled inside the module. Com-coupling (and other  * vandalism) was done to speed running time. The interfaces at the  * module's edges are adequately clean.  *  * There is no way to (a) run a test script through this heap and (b)  * compare results with previous scripts, to see if we have broken any  * code. Use GNU (f)utilities to do this. A few commands assist test.  * The testing is awkward: it tries to be both batch& interactive.  * For now, interactive rules!  */
end_comment

begin_escape
end_escape

begin_comment
comment|/*  *  The idea is to implement a symbol table. A test jig is here.  *  Symbols are arbitrary strings; they can't contain '\0'.  *	[See hsh.c for a more general symbol flavour.]  *  Each symbol is associated with a char*, which can point to anything  *  you want, allowing an arbitrary property list for each symbol.  *  *  The basic operations are:  *  *    new                     creates symbol table, returns handle  *    find (symbol)           returns char*  *    insert (symbol,char*)   error if symbol already in table  *    delete (symbol)         returns char* if symbol was in table  *    apply                   so you can delete all symbols before die()  *    die                     destroy symbol table (free up memory)  *  *  Supplementary functions include:  *  *    say                     how big? what % full?  *    replace (symbol,newval) report previous value  *    jam (symbol,value)      assert symbol:=value  *  *  You, the caller, have control over errors: this just reports them.  *  *  This package requires malloc(), free().  *  Malloc(size) returns NULL or address of char[size].  *  Free(address) frees same.  */
end_comment

begin_escape
end_escape

begin_comment
comment|/*  *  The code and its structures are re-enterent.  *  *  Before you do anything else, you must call hash_new() which will  *  return the address of a hash-table-control-block.  You then use  *  this address as a handle of the symbol table by passing it to all  *  the other hash_...() functions.  The only approved way to recover  *  the memory used by the symbol table is to call hash_die() with the  *  handle of the symbol table.  *  *  Before you call hash_die() you normally delete anything pointed to  *  by individual symbols. After hash_die() you can't use that symbol  *  table again.  *  *  The char* you associate with a symbol may not be NULL (0) because  *  NULL is returned whenever a symbol is not in the table. Any other  *  value is OK, except DELETED, #defined below.  *  *  When you supply a symbol string for insertion, YOU MUST PRESERVE THE  *  STRING until that symbol is deleted from the table. The reason is that  *  only the address you supply, NOT the symbol string itself, is stored  *  in the symbol table.  *  *  You may delete and add symbols arbitrarily.  *  Any or all symbols may have the same 'value' (char *). In fact, these  *  routines don't do anything with your symbol values.  *  *  You have no right to know where the symbol:char* mapping is stored,  *  because it moves around in memory; also because we may change how it  *  works and we don't want to break your code do we? However the handle  *  (address of struct hash_control) is never changed in  *  the life of the symbol table.  *  *  What you CAN find out about a symbol table is:  *    how many slots are in the hash table?  *    how many slots are filled with symbols?  *    (total hashes,collisions) for (reads,writes) (*)  *  All of the above values vary in time.  *  (*) some of these numbers will not be meaningful if we change the  *  internals. */
end_comment

begin_escape
end_escape

begin_comment
comment|/*  *  I N T E R N A L  *  *  Hash table is an array of hash_entries; each entry is a pointer to a  *  a string and a user-supplied value 1 char* wide.  *  *  The array always has 2 ** n elements, n>0, n integer.  *  There is also a 'wall' entry after the array, which is always empty  *  and acts as a sentinel to stop running off the end of the array.  *  When the array gets too full, we create a new array twice as large  *  and re-hash the symbols into the new array, then forget the old array.  *  (Of course, we copy the values into the new array before we junk the  *  old array!)  *  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|FALSE
end_ifndef

begin_define
define|#
directive|define
name|FALSE
value|(0)
end_define

begin_define
define|#
directive|define
name|TRUE
value|(!FALSE)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* no FALSE yet */
end_comment

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_define
define|#
directive|define
name|min
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|((a)< (b) ? (a) : (b))
end_define

begin_include
include|#
directive|include
file|"as.h"
end_include

begin_define
define|#
directive|define
name|error
value|as_fatal
end_define

begin_decl_stmt
specifier|static
name|char
name|_deleted_
index|[
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|DELETED
value|((PTR)_deleted_)
end_define

begin_comment
comment|/* guarenteed unique address */
end_comment

begin_define
define|#
directive|define
name|START_POWER
value|(10)
end_define

begin_comment
comment|/* power of two: size of new hash table */
end_comment

begin_comment
comment|/* TRUE if a symbol is in entry @ ptr.  */
end_comment

begin_define
define|#
directive|define
name|islive
parameter_list|(
name|ptr
parameter_list|)
value|(ptr->hash_string&& ptr->hash_string!=DELETED)
end_define

begin_enum
enum|enum
name|stat_enum
block|{
comment|/* Number of slots in hash table.  The wall does not count here.      We expect this is always a power of 2.  */
name|STAT_SIZE
init|=
literal|0
block|,
comment|/* Number of hash_ask calls.  */
name|STAT_ACCESS
block|,
name|STAT_ACCESS_w
block|,
comment|/* Number of collisions (total).  This may exceed STAT_ACCESS if we      have lots of collisions/access.  */
name|STAT_COLLIDE
block|,
name|STAT_COLLIDE_w
block|,
comment|/* Slots used right now.  */
name|STAT_USED
block|,
comment|/* How many string compares?  */
name|STAT_STRCMP
block|,
name|STAT_STRCMP_w
block|,
comment|/* Size of statistics block... this must be last.  */
name|STATLENGTH
block|}
enum|;
end_enum

begin_define
define|#
directive|define
name|STAT__READ
value|(0)
end_define

begin_comment
comment|/* reading */
end_comment

begin_define
define|#
directive|define
name|STAT__WRITE
value|(1)
end_define

begin_comment
comment|/* writing */
end_comment

begin_comment
comment|/* When we grow a hash table, by what power of two do we increase it?  */
end_comment

begin_define
define|#
directive|define
name|GROW_FACTOR
value|1
end_define

begin_comment
comment|/* When should we grow it?  */
end_comment

begin_define
define|#
directive|define
name|FULL_VALUE
parameter_list|(
name|N
parameter_list|)
value|((N) / 2)
end_define

begin_comment
comment|/* #define SUSPECT to do runtime checks */
end_comment

begin_comment
comment|/* #define TEST to be a test jig for hash...() */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|TEST
end_ifdef

begin_comment
comment|/* TEST: use smaller hash table */
end_comment

begin_undef
undef|#
directive|undef
name|START_POWER
end_undef

begin_define
define|#
directive|define
name|START_POWER
value|(3)
end_define

begin_undef
undef|#
directive|undef
name|START_SIZE
end_undef

begin_define
define|#
directive|define
name|START_SIZE
value|(8)
end_define

begin_undef
undef|#
directive|undef
name|START_FULL
end_undef

begin_define
define|#
directive|define
name|START_FULL
value|(4)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_struct
struct|struct
name|hash_entry
block|{
specifier|const
name|char
modifier|*
name|hash_string
decl_stmt|;
comment|/* points to where the symbol string is */
comment|/* NULL means slot is not used */
comment|/* DELETED means slot was deleted */
name|PTR
name|hash_value
decl_stmt|;
comment|/* user's datum, associated with symbol */
name|unsigned
name|long
name|h
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|hash_control
block|{
name|struct
name|hash_entry
modifier|*
name|hash_where
decl_stmt|;
comment|/* address of hash table */
name|int
name|hash_sizelog
decl_stmt|;
comment|/* Log of ( hash_mask + 1 ) */
name|int
name|hash_mask
decl_stmt|;
comment|/* masks a hash into index into table */
name|int
name|hash_full
decl_stmt|;
comment|/* when hash_stat[STAT_USED] exceeds this, */
comment|/* grow table */
name|struct
name|hash_entry
modifier|*
name|hash_wall
decl_stmt|;
comment|/* point just after last (usable) entry */
comment|/* here we have some statistics */
name|int
name|hash_stat
index|[
name|STATLENGTH
index|]
decl_stmt|;
comment|/* lies& statistics */
block|}
struct|;
end_struct

begin_escape
end_escape

begin_comment
comment|/*------------------ plan ---------------------------------- i = internal    struct hash_control * c;   struct hash_entry   * e;                                                    i   int                   b[z];     buffer for statistics   z         size of b   char                * s;        symbol string (address) [ key ]   char                * v;        value string (address)  [datum]   boolean               f;        TRUE if we found s in hash table            i   char                * t;        error string; 0 means OK   int                   a;        access type [0...n)                         i    c=hash_new       ()             create new hash_control    hash_die         (c)            destroy hash_control (and hash table)   table should be empty.   doesn't check if table is empty.   c has no meaning after this.    hash_say         (c,b,z)        report statistics of hash_control.   also report number of available statistics.    v=hash_delete    (c,s)          delete symbol, return old value if any.   ask()                       NULL means no old value.   f    v=hash_replace   (c,s,v)        replace old value of s with v.   ask()                       NULL means no old value: no table change.   f    t=hash_insert    (c,s,v)        insert (s,v) in c.   ask()                       return error string.   f                           it is an error to insert if s is already   in table.   if any error, c is unchanged.    t=hash_jam       (c,s,v)        assert that new value of s will be v.       i   ask()                       it may decide to GROW the table.            i   f                                                                       i   grow()                                                                  i   t=hash_grow      (c)            grow the hash table.                        i   jam()                       will invoke JAM.                            i    ?=hash_apply     (c,y)          apply y() to every symbol in c.   y                           evtries visited in 'unspecified' order.    v=hash_find      (c,s)          return value of s, or NULL if s not in c.   ask()   f    f,e=hash_ask()   (c,s,a)        return slot where s SHOULD live.            i   code()                      maintain collision stats in c.              i    .=hash_code      (c,s)          compute hash-code for s,                    i   from parameters of c.                       i    */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Returned by hash_ask() to stop extra testing. hash_ask() wants to    return both a slot and a status. This is the status.  TRUE: found    symbol FALSE: absent: empty or deleted slot Also returned by    hash_jam().  TRUE: we replaced a value FALSE: we inserted a value.  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|hash_found
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|hash_entry
modifier|*
name|hash_ask
name|PARAMS
argument_list|(
operator|(
expr|struct
name|hash_control
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|hash_code
name|PARAMS
argument_list|(
operator|(
expr|struct
name|hash_control
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|hash_grow
name|PARAMS
argument_list|(
operator|(
expr|struct
name|hash_control
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Create a new hash table.  Return NULL if failed; otherwise return handle    (address of struct hash).  */
end_comment

begin_function
name|struct
name|hash_control
modifier|*
name|hash_new
parameter_list|()
block|{
name|struct
name|hash_control
modifier|*
name|retval
decl_stmt|;
name|struct
name|hash_entry
modifier|*
name|room
decl_stmt|;
comment|/* points to hash table */
name|struct
name|hash_entry
modifier|*
name|wall
decl_stmt|;
name|struct
name|hash_entry
modifier|*
name|entry
decl_stmt|;
name|int
modifier|*
name|ip
decl_stmt|;
comment|/* scan stats block of struct hash_control */
name|int
modifier|*
name|nd
decl_stmt|;
comment|/* limit of stats block */
name|room
operator|=
operator|(
expr|struct
name|hash_entry
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|hash_entry
argument_list|)
comment|/* +1 for the wall entry */
operator|*
operator|(
operator|(
literal|1
operator|<<
name|START_POWER
operator|)
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
name|retval
operator|=
operator|(
expr|struct
name|hash_control
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|hash_control
argument_list|)
argument_list|)
expr_stmt|;
name|nd
operator|=
name|retval
operator|->
name|hash_stat
operator|+
name|STATLENGTH
expr_stmt|;
for|for
control|(
name|ip
operator|=
name|retval
operator|->
name|hash_stat
init|;
name|ip
operator|<
name|nd
condition|;
name|ip
operator|++
control|)
operator|*
name|ip
operator|=
literal|0
expr_stmt|;
name|retval
operator|->
name|hash_stat
index|[
name|STAT_SIZE
index|]
operator|=
literal|1
operator|<<
name|START_POWER
expr_stmt|;
name|retval
operator|->
name|hash_mask
operator|=
operator|(
literal|1
operator|<<
name|START_POWER
operator|)
operator|-
literal|1
expr_stmt|;
name|retval
operator|->
name|hash_sizelog
operator|=
name|START_POWER
expr_stmt|;
comment|/* works for 1's compl ok */
name|retval
operator|->
name|hash_where
operator|=
name|room
expr_stmt|;
name|retval
operator|->
name|hash_wall
operator|=
name|wall
operator|=
name|room
operator|+
operator|(
literal|1
operator|<<
name|START_POWER
operator|)
expr_stmt|;
name|retval
operator|->
name|hash_full
operator|=
name|FULL_VALUE
argument_list|(
literal|1
operator|<<
name|START_POWER
argument_list|)
expr_stmt|;
for|for
control|(
name|entry
operator|=
name|room
init|;
name|entry
operator|<=
name|wall
condition|;
name|entry
operator|++
control|)
name|entry
operator|->
name|hash_string
operator|=
name|NULL
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_comment
comment|/*  *           h a s h _ d i e ( )  *  * Table should be empty, but this is not checked.  * To empty the table, try hash_apply()ing a symbol deleter.  * Return to free memory both the hash table and it's control  * block.  * 'handle' has no meaning after this function.  * No errors are recoverable.  */
end_comment

begin_function
name|void
name|hash_die
parameter_list|(
name|handle
parameter_list|)
name|struct
name|hash_control
modifier|*
name|handle
decl_stmt|;
block|{
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|handle
operator|->
name|hash_where
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|handle
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|TEST
end_ifdef

begin_comment
comment|/*  *           h a s h _ s a y ( )  *  * Return the size of the statistics table, and as many statistics as  * we can until either (a) we have run out of statistics or (b) caller  * has run out of buffer.  * NOTE: hash_say treats all statistics alike.  * These numbers may change with time, due to insertions, deletions  * and expansions of the table.  * The first "statistic" returned is the length of hash_stat[].  * Then contents of hash_stat[] are read out (in ascending order)  * until your buffer or hash_stat[] is exausted.  */
end_comment

begin_function
specifier|static
name|void
name|hash_say
parameter_list|(
name|handle
parameter_list|,
name|buffer
parameter_list|,
name|bufsiz
parameter_list|)
name|struct
name|hash_control
modifier|*
name|handle
decl_stmt|;
name|int
name|buffer
index|[
comment|/*bufsiz*/
index|]
decl_stmt|;
name|int
name|bufsiz
decl_stmt|;
block|{
name|int
modifier|*
name|nd
decl_stmt|;
comment|/* limit of statistics block */
name|int
modifier|*
name|ip
decl_stmt|;
comment|/* scan statistics */
name|ip
operator|=
name|handle
operator|->
name|hash_stat
expr_stmt|;
name|nd
operator|=
name|ip
operator|+
name|min
argument_list|(
name|bufsiz
operator|-
literal|1
argument_list|,
name|STATLENGTH
argument_list|)
expr_stmt|;
if|if
condition|(
name|bufsiz
operator|>
literal|0
condition|)
comment|/* trust nothing! bufsiz<=0 is dangerous */
block|{
operator|*
name|buffer
operator|++
operator|=
name|STATLENGTH
expr_stmt|;
for|for
control|(
init|;
name|ip
operator|<
name|nd
condition|;
name|ip
operator|++
operator|,
name|buffer
operator|++
control|)
block|{
operator|*
name|buffer
operator|=
operator|*
name|ip
expr_stmt|;
block|}
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/*  *           h a s h _ d e l e t e ( )  *  * Try to delete a symbol from the table.  * If it was there, return its value (and adjust STAT_USED).  * Otherwise, return NULL.  * Anyway, the symbol is not present after this function.  *  */
end_comment

begin_function
name|PTR
comment|/* NULL if string not in table, else */
comment|/* returns value of deleted symbol */
name|hash_delete
parameter_list|(
name|handle
parameter_list|,
name|string
parameter_list|)
name|struct
name|hash_control
modifier|*
name|handle
decl_stmt|;
specifier|const
name|char
modifier|*
name|string
decl_stmt|;
block|{
name|PTR
name|retval
decl_stmt|;
name|struct
name|hash_entry
modifier|*
name|entry
decl_stmt|;
name|entry
operator|=
name|hash_ask
argument_list|(
name|handle
argument_list|,
name|string
argument_list|,
name|STAT__WRITE
argument_list|)
expr_stmt|;
if|if
condition|(
name|hash_found
condition|)
block|{
name|retval
operator|=
name|entry
operator|->
name|hash_value
expr_stmt|;
name|entry
operator|->
name|hash_string
operator|=
name|DELETED
expr_stmt|;
name|handle
operator|->
name|hash_stat
index|[
name|STAT_USED
index|]
operator|-=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|SUSPECT
if|if
condition|(
name|handle
operator|->
name|hash_stat
index|[
name|STAT_USED
index|]
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"hash_delete"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* def SUSPECT */
block|}
else|else
block|{
name|retval
operator|=
name|NULL
expr_stmt|;
block|}
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *                   h a s h _ r e p l a c e ( )  *  * Try to replace the old value of a symbol with a new value.  * Normally return the old value.  * Return NULL and don't change the table if the symbol is not already  * in the table.  */
end_comment

begin_function
name|PTR
name|hash_replace
parameter_list|(
name|handle
parameter_list|,
name|string
parameter_list|,
name|value
parameter_list|)
name|struct
name|hash_control
modifier|*
name|handle
decl_stmt|;
specifier|const
name|char
modifier|*
name|string
decl_stmt|;
name|PTR
name|value
decl_stmt|;
block|{
name|struct
name|hash_entry
modifier|*
name|entry
decl_stmt|;
name|char
modifier|*
name|retval
decl_stmt|;
name|entry
operator|=
name|hash_ask
argument_list|(
name|handle
argument_list|,
name|string
argument_list|,
name|STAT__WRITE
argument_list|)
expr_stmt|;
if|if
condition|(
name|hash_found
condition|)
block|{
name|retval
operator|=
name|entry
operator|->
name|hash_value
expr_stmt|;
name|entry
operator|->
name|hash_value
operator|=
name|value
expr_stmt|;
block|}
else|else
block|{
name|retval
operator|=
name|NULL
expr_stmt|;
block|}
empty_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *                   h a s h _ i n s e r t ( )  *  * Insert a (symbol-string, value) into the hash table.  * Return an error string, 0 means OK.  * It is an 'error' to insert an existing symbol.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
comment|/* return error string */
name|hash_insert
parameter_list|(
name|handle
parameter_list|,
name|string
parameter_list|,
name|value
parameter_list|)
name|struct
name|hash_control
modifier|*
name|handle
decl_stmt|;
specifier|const
name|char
modifier|*
name|string
decl_stmt|;
name|PTR
name|value
decl_stmt|;
block|{
name|struct
name|hash_entry
modifier|*
name|entry
decl_stmt|;
specifier|const
name|char
modifier|*
name|retval
decl_stmt|;
name|retval
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|handle
operator|->
name|hash_stat
index|[
name|STAT_USED
index|]
operator|>
name|handle
operator|->
name|hash_full
condition|)
block|{
name|retval
operator|=
name|hash_grow
argument_list|(
name|handle
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|retval
condition|)
block|{
name|entry
operator|=
name|hash_ask
argument_list|(
name|handle
argument_list|,
name|string
argument_list|,
name|STAT__WRITE
argument_list|)
expr_stmt|;
if|if
condition|(
name|hash_found
condition|)
block|{
name|retval
operator|=
literal|"exists"
expr_stmt|;
block|}
else|else
block|{
name|entry
operator|->
name|hash_value
operator|=
name|value
expr_stmt|;
name|entry
operator|->
name|hash_string
operator|=
name|string
expr_stmt|;
name|handle
operator|->
name|hash_stat
index|[
name|STAT_USED
index|]
operator|+=
literal|1
expr_stmt|;
block|}
block|}
return|return
name|retval
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *               h a s h _ j a m ( )  *  * Regardless of what was in the symbol table before, after hash_jam()  * the named symbol has the given value. The symbol is either inserted or  * (its value is) replaced.  * An error message string is returned, 0 means OK.  *  * WARNING: this may decide to grow the hashed symbol table.  * To do this, we call hash_grow(), WHICH WILL recursively CALL US.  *  * We report status internally: hash_found is TRUE if we replaced, but  * false if we inserted.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|hash_jam
parameter_list|(
name|handle
parameter_list|,
name|string
parameter_list|,
name|value
parameter_list|)
name|struct
name|hash_control
modifier|*
name|handle
decl_stmt|;
specifier|const
name|char
modifier|*
name|string
decl_stmt|;
name|PTR
name|value
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|retval
decl_stmt|;
name|struct
name|hash_entry
modifier|*
name|entry
decl_stmt|;
name|retval
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|handle
operator|->
name|hash_stat
index|[
name|STAT_USED
index|]
operator|>
name|handle
operator|->
name|hash_full
condition|)
block|{
name|retval
operator|=
name|hash_grow
argument_list|(
name|handle
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|retval
condition|)
block|{
name|entry
operator|=
name|hash_ask
argument_list|(
name|handle
argument_list|,
name|string
argument_list|,
name|STAT__WRITE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|hash_found
condition|)
block|{
name|entry
operator|->
name|hash_string
operator|=
name|string
expr_stmt|;
name|handle
operator|->
name|hash_stat
index|[
name|STAT_USED
index|]
operator|+=
literal|1
expr_stmt|;
block|}
name|entry
operator|->
name|hash_value
operator|=
name|value
expr_stmt|;
block|}
return|return
name|retval
return|;
block|}
end_function

begin_comment
comment|/*  *               h a s h _ g r o w ( )  *  * Grow a new (bigger) hash table from the old one.  * We choose to double the hash table's size.  * Return a human-scrutible error string: 0 if OK.  * Warning! This uses hash_jam(), which had better not recurse  * back here! Hash_jam() conditionally calls us, but we ALWAYS  * call hash_jam()!  * Internal.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|hash_grow
parameter_list|(
name|handle
parameter_list|)
comment|/* make a hash table grow */
name|struct
name|hash_control
modifier|*
name|handle
decl_stmt|;
block|{
name|struct
name|hash_entry
modifier|*
name|newwall
decl_stmt|;
name|struct
name|hash_entry
modifier|*
name|newwhere
decl_stmt|;
name|struct
name|hash_entry
modifier|*
name|newtrack
decl_stmt|;
name|struct
name|hash_entry
modifier|*
name|oldtrack
decl_stmt|;
name|struct
name|hash_entry
modifier|*
name|oldwhere
decl_stmt|;
name|struct
name|hash_entry
modifier|*
name|oldwall
decl_stmt|;
name|int
name|temp
decl_stmt|;
name|int
name|newsize
decl_stmt|;
specifier|const
name|char
modifier|*
name|string
decl_stmt|;
specifier|const
name|char
modifier|*
name|retval
decl_stmt|;
ifdef|#
directive|ifdef
name|SUSPECT
name|int
name|oldused
decl_stmt|;
endif|#
directive|endif
comment|/*    * capture info about old hash table    */
name|oldwhere
operator|=
name|handle
operator|->
name|hash_where
expr_stmt|;
name|oldwall
operator|=
name|handle
operator|->
name|hash_wall
expr_stmt|;
ifdef|#
directive|ifdef
name|SUSPECT
name|oldused
operator|=
name|handle
operator|->
name|hash_stat
index|[
name|STAT_USED
index|]
expr_stmt|;
endif|#
directive|endif
comment|/*    * attempt to get enough room for a hash table twice as big    */
name|temp
operator|=
name|handle
operator|->
name|hash_stat
index|[
name|STAT_SIZE
index|]
expr_stmt|;
name|newwhere
operator|=
operator|(
operator|(
expr|struct
name|hash_entry
operator|*
operator|)
name|xmalloc
argument_list|(
call|(
name|unsigned
name|long
call|)
argument_list|(
operator|(
name|temp
operator|<<
operator|(
name|GROW_FACTOR
operator|+
literal|1
operator|)
operator|)
comment|/* +1 for wall slot */
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|hash_entry
argument_list|)
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|newwhere
operator|==
name|NULL
condition|)
return|return
literal|"no_room"
return|;
comment|/*    * have enough room: now we do all the work.    * double the size of everything in handle.    */
name|handle
operator|->
name|hash_mask
operator|=
operator|(
operator|(
name|handle
operator|->
name|hash_mask
operator|+
literal|1
operator|)
operator|<<
name|GROW_FACTOR
operator|)
operator|-
literal|1
expr_stmt|;
name|handle
operator|->
name|hash_stat
index|[
name|STAT_SIZE
index|]
operator|<<=
name|GROW_FACTOR
expr_stmt|;
name|newsize
operator|=
name|handle
operator|->
name|hash_stat
index|[
name|STAT_SIZE
index|]
expr_stmt|;
name|handle
operator|->
name|hash_where
operator|=
name|newwhere
expr_stmt|;
name|handle
operator|->
name|hash_full
operator|<<=
name|GROW_FACTOR
expr_stmt|;
name|handle
operator|->
name|hash_sizelog
operator|+=
name|GROW_FACTOR
expr_stmt|;
name|handle
operator|->
name|hash_wall
operator|=
name|newwall
operator|=
name|newwhere
operator|+
name|newsize
expr_stmt|;
comment|/* Set all those pesky new slots to vacant.  */
for|for
control|(
name|newtrack
operator|=
name|newwhere
init|;
name|newtrack
operator|<=
name|newwall
condition|;
name|newtrack
operator|++
control|)
name|newtrack
operator|->
name|hash_string
operator|=
name|NULL
expr_stmt|;
comment|/* We will do a scan of the old table, the hard way, using the    * new control block to re-insert the data into new hash table.  */
name|handle
operator|->
name|hash_stat
index|[
name|STAT_USED
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|oldtrack
operator|=
name|oldwhere
init|;
name|oldtrack
operator|<
name|oldwall
condition|;
name|oldtrack
operator|++
control|)
if|if
condition|(
operator|(
operator|(
name|string
operator|=
name|oldtrack
operator|->
name|hash_string
operator|)
operator|!=
name|NULL
operator|)
operator|&&
name|string
operator|!=
name|DELETED
condition|)
if|if
condition|(
operator|(
name|retval
operator|=
name|hash_jam
argument_list|(
name|handle
argument_list|,
name|string
argument_list|,
name|oldtrack
operator|->
name|hash_value
argument_list|)
operator|)
condition|)
return|return
name|retval
return|;
ifdef|#
directive|ifdef
name|SUSPECT
if|if
condition|(
name|handle
operator|->
name|hash_stat
index|[
name|STAT_USED
index|]
operator|!=
name|oldused
condition|)
return|return
literal|"hash_used"
return|;
endif|#
directive|endif
comment|/* We have a completely faked up control block.      Return the old hash table.  */
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|oldwhere
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|TEST
end_ifdef

begin_comment
comment|/*  *          h a s h _ a p p l y ( )  *  * Use this to scan each entry in symbol table.  * For each symbol, this calls (applys) a nominated function supplying the  * symbol's value (and the symbol's name).  * The idea is you use this to destroy whatever is associted with  * any values in the table BEFORE you destroy the table with hash_die.  * Of course, you can use it for other jobs; whenever you need to  * visit all extant symbols in the table.  *  * We choose to have a call-you-back idea for two reasons:  *  asthetic: it is a neater idea to use apply than an explicit loop  *  sensible: if we ever had to grow the symbol table (due to insertions)  *            then we would lose our place in the table when we re-hashed  *            symbols into the new table in a different order.  *  * The order symbols are visited depends entirely on the hashing function.  * Whenever you insert a (symbol, value) you risk expanding the table. If  * you do expand the table, then the hashing function WILL change, so you  * MIGHT get a different order of symbols visited. In other words, if you  * want the same order of visiting symbols as the last time you used  * hash_apply() then you better not have done any hash_insert()s or  * hash_jam()s since the last time you used hash_apply().  *  * In future we may use the value returned by your nominated function.  * One idea is to abort the scan if, after applying the function to a  * certain node, the function returns a certain code.  *  * The function you supply should be of the form:  *      void myfunct(string,value)  *              char * string;        |* the symbol's name *|  *              char * value;         |* the symbol's value *|  *      {  *        |* ... *|  *      }  *  */
end_comment

begin_decl_stmt
name|void
name|hash_apply
argument_list|(
name|handle
argument_list|,
name|function
argument_list|)
decl|struct
name|hash_control
modifier|*
name|handle
decl_stmt|;
end_decl_stmt

begin_function_decl
name|void
function_decl|(
modifier|*
name|function
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_block
block|{
name|struct
name|hash_entry
modifier|*
name|entry
decl_stmt|;
name|struct
name|hash_entry
modifier|*
name|wall
decl_stmt|;
name|wall
operator|=
name|handle
operator|->
name|hash_wall
expr_stmt|;
for|for
control|(
name|entry
operator|=
name|handle
operator|->
name|hash_where
init|;
name|entry
operator|<
name|wall
condition|;
name|entry
operator|++
control|)
block|{
if|if
condition|(
name|islive
argument_list|(
name|entry
argument_list|)
condition|)
comment|/* silly code: tests entry->string twice! */
block|{
call|(
modifier|*
name|function
call|)
argument_list|(
name|entry
operator|->
name|hash_string
argument_list|,
name|entry
operator|->
name|hash_value
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/*  *          h a s h _ f i n d ( )  *  * Given symbol string, find value (if any).  * Return found value or NULL.  */
end_comment

begin_function
name|PTR
name|hash_find
parameter_list|(
name|handle
parameter_list|,
name|string
parameter_list|)
name|struct
name|hash_control
modifier|*
name|handle
decl_stmt|;
specifier|const
name|char
modifier|*
name|string
decl_stmt|;
block|{
name|struct
name|hash_entry
modifier|*
name|entry
decl_stmt|;
name|entry
operator|=
name|hash_ask
argument_list|(
name|handle
argument_list|,
name|string
argument_list|,
name|STAT__READ
argument_list|)
expr_stmt|;
if|if
condition|(
name|hash_found
condition|)
return|return
name|entry
operator|->
name|hash_value
return|;
else|else
return|return
name|NULL
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *          h a s h _ a s k ( )  *  * Searches for given symbol string.  * Return the slot where it OUGHT to live. It may be there.  * Return hash_found: TRUE only if symbol is in that slot.  * Access argument is to help keep statistics in control block.  * Internal.  */
end_comment

begin_function
specifier|static
name|struct
name|hash_entry
modifier|*
comment|/* string slot, may be empty or deleted */
name|hash_ask
parameter_list|(
name|handle
parameter_list|,
name|string
parameter_list|,
name|access_type
parameter_list|)
name|struct
name|hash_control
modifier|*
name|handle
decl_stmt|;
specifier|const
name|char
modifier|*
name|string
decl_stmt|;
name|int
name|access_type
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
name|struct
name|hash_entry
modifier|*
name|slot
decl_stmt|;
name|int
name|collision
decl_stmt|;
comment|/* count collisions */
name|int
name|strcmps
decl_stmt|;
name|int
name|hcode
decl_stmt|;
comment|/* start looking here */
name|hcode
operator|=
name|hash_code
argument_list|(
name|handle
argument_list|,
name|string
argument_list|)
expr_stmt|;
name|slot
operator|=
name|handle
operator|->
name|hash_where
operator|+
operator|(
name|hcode
operator|&
name|handle
operator|->
name|hash_mask
operator|)
expr_stmt|;
name|handle
operator|->
name|hash_stat
index|[
name|STAT_ACCESS
operator|+
name|access_type
index|]
operator|+=
literal|1
expr_stmt|;
name|collision
operator|=
name|strcmps
operator|=
literal|0
expr_stmt|;
name|hash_found
operator|=
name|FALSE
expr_stmt|;
while|while
condition|(
operator|(
operator|(
name|s
operator|=
name|slot
operator|->
name|hash_string
operator|)
operator|!=
name|NULL
operator|)
operator|&&
name|s
operator|!=
name|DELETED
condition|)
block|{
if|if
condition|(
name|string
operator|==
name|s
condition|)
block|{
name|hash_found
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|slot
operator|->
name|h
operator|==
name|hcode
condition|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|string
argument_list|,
name|s
argument_list|)
condition|)
block|{
name|hash_found
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
name|strcmps
operator|++
expr_stmt|;
block|}
name|collision
operator|++
expr_stmt|;
name|slot
operator|++
expr_stmt|;
block|}
comment|/*    * slot:                                                      return:    *       in use:     we found string                           slot    *       at empty:    *                   at wall:        we fell off: wrap round   ????    *                   in table:       dig here                  slot    *       at DELETED: dig here                                  slot    */
if|if
condition|(
name|slot
operator|==
name|handle
operator|->
name|hash_wall
condition|)
block|{
name|slot
operator|=
name|handle
operator|->
name|hash_where
expr_stmt|;
comment|/* now look again */
while|while
condition|(
operator|(
operator|(
name|s
operator|=
name|slot
operator|->
name|hash_string
operator|)
operator|!=
name|NULL
operator|)
operator|&&
name|s
operator|!=
name|DELETED
condition|)
block|{
if|if
condition|(
name|string
operator|==
name|s
condition|)
block|{
name|hash_found
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|slot
operator|->
name|h
operator|==
name|hcode
condition|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|string
argument_list|,
name|s
argument_list|)
condition|)
block|{
name|hash_found
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
name|strcmps
operator|++
expr_stmt|;
block|}
name|collision
operator|++
expr_stmt|;
name|slot
operator|++
expr_stmt|;
block|}
comment|/*        * slot:                                                   return:        *       in use: we found it                                slot        *       empty:  wall:         ERROR IMPOSSIBLE             !!!!        *               in table:     dig here                     slot        *       DELETED:dig here                                   slot        */
block|}
name|handle
operator|->
name|hash_stat
index|[
name|STAT_COLLIDE
operator|+
name|access_type
index|]
operator|+=
name|collision
expr_stmt|;
name|handle
operator|->
name|hash_stat
index|[
name|STAT_STRCMP
operator|+
name|access_type
index|]
operator|+=
name|strcmps
expr_stmt|;
if|if
condition|(
operator|!
name|hash_found
condition|)
name|slot
operator|->
name|h
operator|=
name|hcode
expr_stmt|;
return|return
name|slot
return|;
comment|/* also return hash_found */
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *           h a s h _ c o d e  *  * Does hashing of symbol string to hash number.  * Internal.  */
end_comment

begin_function
specifier|static
name|int
name|hash_code
parameter_list|(
name|handle
parameter_list|,
name|string
parameter_list|)
name|struct
name|hash_control
modifier|*
name|handle
decl_stmt|;
specifier|const
name|char
modifier|*
name|string
decl_stmt|;
block|{
if|#
directive|if
literal|1
comment|/* There seems to be some interesting property of this function 	 that prevents the bfd version below from being an adequate 	 substitute.  @@ Figure out what this property is!  */
name|long
name|h
decl_stmt|;
comment|/* hash code built here */
name|long
name|c
decl_stmt|;
comment|/* each character lands here */
name|int
name|n
decl_stmt|;
comment|/* Amount to shift h by */
name|n
operator|=
operator|(
name|handle
operator|->
name|hash_sizelog
operator|-
literal|3
operator|)
expr_stmt|;
name|h
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|string
operator|++
operator|)
operator|!=
literal|0
condition|)
block|{
name|h
operator|+=
name|c
expr_stmt|;
name|h
operator|=
operator|(
name|h
operator|<<
literal|3
operator|)
operator|+
operator|(
name|h
operator|>>
name|n
operator|)
operator|+
name|c
expr_stmt|;
block|}
return|return
name|h
return|;
else|#
directive|else
comment|/* from bfd */
name|unsigned
name|long
name|h
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|len
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|c
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|string
operator|++
operator|)
operator|!=
literal|0
condition|)
block|{
name|h
operator|+=
name|c
operator|+
operator|(
name|c
operator|<<
literal|17
operator|)
expr_stmt|;
name|h
operator|^=
name|h
operator|>>
literal|2
expr_stmt|;
operator|++
name|len
expr_stmt|;
block|}
name|h
operator|+=
name|len
operator|+
operator|(
name|len
operator|<<
literal|17
operator|)
expr_stmt|;
name|h
operator|^=
name|h
operator|>>
literal|2
expr_stmt|;
return|return
name|h
return|;
endif|#
directive|endif
block|}
end_function

begin_escape
end_escape

begin_function
name|void
name|hash_print_statistics
parameter_list|(
name|file
parameter_list|,
name|name
parameter_list|,
name|h
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|struct
name|hash_control
modifier|*
name|h
decl_stmt|;
block|{
name|unsigned
name|long
name|sz
decl_stmt|,
name|used
decl_stmt|,
name|pct
decl_stmt|;
if|if
condition|(
name|h
operator|==
literal|0
condition|)
return|return;
name|sz
operator|=
name|h
operator|->
name|hash_stat
index|[
name|STAT_SIZE
index|]
expr_stmt|;
name|used
operator|=
name|h
operator|->
name|hash_stat
index|[
name|STAT_USED
index|]
expr_stmt|;
name|pct
operator|=
operator|(
name|used
operator|*
literal|100
operator|+
name|sz
operator|/
literal|2
operator|)
operator|/
name|sz
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s hash statistics:\n\t%lu/%lu slots used (%lu%%)\n"
argument_list|,
name|name
argument_list|,
name|used
argument_list|,
name|sz
argument_list|,
name|pct
argument_list|)
expr_stmt|;
define|#
directive|define
name|P
parameter_list|(
name|name
parameter_list|,
name|off
parameter_list|)
define|\
value|fprintf (file, "\t%-16s %6dr + %6dw = %7d\n", name,			\ 	   h->hash_stat[off+STAT__READ],				\ 	   h->hash_stat[off+STAT__WRITE],				\ 	   h->hash_stat[off+STAT__READ] + h->hash_stat[off+STAT__WRITE])
name|P
argument_list|(
literal|"accesses:"
argument_list|,
name|STAT_ACCESS
argument_list|)
expr_stmt|;
name|P
argument_list|(
literal|"collisions:"
argument_list|,
name|STAT_COLLIDE
argument_list|)
expr_stmt|;
name|P
argument_list|(
literal|"string compares:"
argument_list|,
name|STAT_STRCMP
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|P
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  * Here is a test program to exercise above.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|TEST
end_ifdef

begin_define
define|#
directive|define
name|TABLES
value|(6)
end_define

begin_comment
comment|/* number of hash tables to maintain */
end_comment

begin_comment
comment|/* (at once) in any testing */
end_comment

begin_define
define|#
directive|define
name|STATBUFSIZE
value|(12)
end_define

begin_comment
comment|/* we can have 12 statistics */
end_comment

begin_decl_stmt
name|int
name|statbuf
index|[
name|STATBUFSIZE
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* display statistics here */
end_comment

begin_decl_stmt
name|char
name|answer
index|[
literal|100
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* human farts here */
end_comment

begin_decl_stmt
name|char
modifier|*
name|hashtable
index|[
name|TABLES
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* we test many hash tables at once */
end_comment

begin_decl_stmt
name|char
modifier|*
name|h
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* points to curent hash_control */
end_comment

begin_decl_stmt
name|char
modifier|*
modifier|*
name|pp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|value
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|used
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|command
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|number
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number 0:TABLES-1 of current hashed */
end_comment

begin_comment
comment|/* symbol table */
end_comment

begin_function
name|main
parameter_list|()
block|{
name|void
name|applicatee
parameter_list|()
function_decl|;
name|void
name|destroy
parameter_list|()
function_decl|;
name|char
modifier|*
name|what
parameter_list|()
function_decl|;
name|int
modifier|*
name|ip
decl_stmt|;
name|number
operator|=
literal|0
expr_stmt|;
name|h
operator|=
literal|0
expr_stmt|;
name|printf
argument_list|(
literal|"type h<RETURN> for help\n"
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|printf
argument_list|(
literal|"hash_test command: "
argument_list|)
expr_stmt|;
name|gets
argument_list|(
name|answer
argument_list|)
expr_stmt|;
name|command
operator|=
name|answer
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|isupper
argument_list|(
name|command
argument_list|)
condition|)
name|command
operator|=
name|tolower
argument_list|(
name|command
argument_list|)
expr_stmt|;
comment|/* ecch! */
switch|switch
condition|(
name|command
condition|)
block|{
case|case
literal|'#'
case|:
name|printf
argument_list|(
literal|"old hash table #=%d.\n"
argument_list|,
name|number
argument_list|)
expr_stmt|;
name|whattable
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
for|for
control|(
name|pp
operator|=
name|hashtable
init|;
name|pp
operator|<
name|hashtable
operator|+
name|TABLES
condition|;
name|pp
operator|++
control|)
block|{
name|printf
argument_list|(
literal|"address of hash table #%d control block is %xx\n"
argument_list|,
name|pp
operator|-
name|hashtable
argument_list|,
operator|*
name|pp
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'a'
case|:
name|hash_apply
argument_list|(
name|h
argument_list|,
name|applicatee
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|hash_apply
argument_list|(
name|h
argument_list|,
name|destroy
argument_list|)
expr_stmt|;
name|hash_die
argument_list|(
name|h
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|p
operator|=
name|hash_find
argument_list|(
name|h
argument_list|,
name|name
operator|=
name|what
argument_list|(
literal|"symbol"
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"value of \"%s\" is \"%s\"\n"
argument_list|,
name|name
argument_list|,
name|p
condition|?
name|p
else|:
literal|"NOT-PRESENT"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
name|printf
argument_list|(
literal|"# show old, select new default hash table number\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"? display all hashtable control block addresses\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"a apply a simple display-er to each symbol in table\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"d die: destroy hashtable\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"f find value of nominated symbol\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"h this help\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"i insert value into symbol\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"j jam value into symbol\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"n new hashtable\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"r replace a value with another\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"s say what %% of table is used\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"q exit this program\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"x delete a symbol from table, report its value\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
name|p
operator|=
name|hash_insert
argument_list|(
name|h
argument_list|,
name|name
operator|=
name|what
argument_list|(
literal|"symbol"
argument_list|)
argument_list|,
name|value
operator|=
name|what
argument_list|(
literal|"value"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
condition|)
block|{
name|printf
argument_list|(
literal|"symbol=\"%s\"  value=\"%s\"  error=%s\n"
argument_list|,
name|name
argument_list|,
name|value
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'j'
case|:
name|p
operator|=
name|hash_jam
argument_list|(
name|h
argument_list|,
name|name
operator|=
name|what
argument_list|(
literal|"symbol"
argument_list|)
argument_list|,
name|value
operator|=
name|what
argument_list|(
literal|"value"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
condition|)
block|{
name|printf
argument_list|(
literal|"symbol=\"%s\"  value=\"%s\"  error=%s\n"
argument_list|,
name|name
argument_list|,
name|value
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'n'
case|:
name|h
operator|=
name|hashtable
index|[
name|number
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|hash_new
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'q'
case|:
name|exit
argument_list|(
name|EXIT_SUCCESS
argument_list|)
expr_stmt|;
case|case
literal|'r'
case|:
name|p
operator|=
name|hash_replace
argument_list|(
name|h
argument_list|,
name|name
operator|=
name|what
argument_list|(
literal|"symbol"
argument_list|)
argument_list|,
name|value
operator|=
name|what
argument_list|(
literal|"value"
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"old value was \"%s\"\n"
argument_list|,
name|p
condition|?
name|p
else|:
literal|"{}"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|hash_say
argument_list|(
name|h
argument_list|,
name|statbuf
argument_list|,
name|STATBUFSIZE
argument_list|)
expr_stmt|;
for|for
control|(
name|ip
operator|=
name|statbuf
init|;
name|ip
operator|<
name|statbuf
operator|+
name|STATBUFSIZE
condition|;
name|ip
operator|++
control|)
block|{
name|printf
argument_list|(
literal|"%d "
argument_list|,
operator|*
name|ip
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
name|p
operator|=
name|hash_delete
argument_list|(
name|h
argument_list|,
name|name
operator|=
name|what
argument_list|(
literal|"symbol"
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"old value was \"%s\"\n"
argument_list|,
name|p
condition|?
name|p
else|:
literal|"{}"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"I can't understand command \"%c\"\n"
argument_list|,
name|command
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_function
name|char
modifier|*
name|what
parameter_list|(
name|description
parameter_list|)
name|char
modifier|*
name|description
decl_stmt|;
block|{
name|char
modifier|*
name|retval
decl_stmt|;
name|char
modifier|*
name|malloc
parameter_list|()
function_decl|;
name|printf
argument_list|(
literal|"   %s : "
argument_list|,
name|description
argument_list|)
expr_stmt|;
name|gets
argument_list|(
name|answer
argument_list|)
expr_stmt|;
comment|/* will one day clean up answer here */
name|retval
operator|=
name|malloc
argument_list|(
name|strlen
argument_list|(
name|answer
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|retval
condition|)
block|{
name|error
argument_list|(
literal|"room"
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|retval
argument_list|,
name|answer
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_function
name|void
name|destroy
parameter_list|(
name|string
parameter_list|,
name|value
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
name|char
modifier|*
name|value
decl_stmt|;
block|{
name|free
argument_list|(
name|string
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|applicatee
parameter_list|(
name|string
parameter_list|,
name|value
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
name|char
modifier|*
name|value
decl_stmt|;
block|{
name|printf
argument_list|(
literal|"%.20s-%.20s\n"
argument_list|,
name|string
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
end_function

begin_macro
name|whattable
argument_list|()
end_macro

begin_comment
comment|/* determine number: what hash table to use */
end_comment

begin_comment
comment|/* also determine h: points to hash_control */
end_comment

begin_block
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
name|printf
argument_list|(
literal|"   what hash table (%d:%d) ?  "
argument_list|,
literal|0
argument_list|,
name|TABLES
operator|-
literal|1
argument_list|)
expr_stmt|;
name|gets
argument_list|(
name|answer
argument_list|)
expr_stmt|;
name|sscanf
argument_list|(
name|answer
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|number
argument_list|)
expr_stmt|;
if|if
condition|(
name|number
operator|>=
literal|0
operator|&&
name|number
operator|<
name|TABLES
condition|)
block|{
name|h
operator|=
name|hashtable
index|[
name|number
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|h
condition|)
block|{
name|printf
argument_list|(
literal|"warning: current hash-table-#%d. has no hash-control\n"
argument_list|,
name|number
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"invalid hash table number: %d\n"
argument_list|,
name|number
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* #ifdef TEST */
end_comment

begin_comment
comment|/* end of hash.c */
end_comment

end_unit

