begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* atof_generic.c - turn a string of digits into a Flonum    Copyright 1987, 1990, 1991, 1992, 1993, 1994, 1995, 1998, 1999, 2000,    2001, 2003, 2005, 2006 Free Software Foundation, Inc.     This file is part of GAS, the GNU Assembler.     GAS is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     GAS is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with GAS; see the file COPYING.  If not, write to the Free    Software Foundation, 51 Franklin Street - Fifth Floor, Boston, MA    02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"as.h"
end_include

begin_include
include|#
directive|include
file|"safe-ctype.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|FALSE
end_ifndef

begin_define
define|#
directive|define
name|FALSE
value|(0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|TRUE
end_ifndef

begin_define
define|#
directive|define
name|TRUE
value|(1)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|TRACE
end_ifdef

begin_function_decl
specifier|static
name|void
name|flonum_print
parameter_list|(
specifier|const
name|FLONUM_TYPE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|ASSUME_DECIMAL_MARK_IS_DOT
end_define

begin_comment
comment|/***********************************************************************\  *									*  *	Given a string of decimal digits , with optional decimal	*  *	mark and optional decimal exponent (place value) of the		*  *	lowest_order decimal digit: produce a floating point		*  *	number. The number is 'generic' floating point: our		*  *	caller will encode it for a specific machine architecture.	*  *									*  *	Assumptions							*  *		uses base (radix) 2					*  *		this machine uses 2's complement binary integers	*  *		target flonums use "      "         "       "		*  *		target flonums exponents fit in a long			*  *									*  \***********************************************************************/
end_comment

begin_comment
comment|/*    Syntax:<flonum> ::=<optional-sign><decimal-number><optional-exponent><optional-sign> ::= '+' | '-' | {empty}<decimal-number> ::=<integer>   |<integer><radix-character>   |<integer><radix-character><integer>   |<radix-character><integer><optional-exponent> ::= {empty}   |<exponent-character><optional-sign><integer><integer> ::=<digit> |<digit><integer><digit> ::= '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9'<exponent-character> ::= {one character from "string_of_decimal_exponent_marks"}<radix-character> ::= {one character from "string_of_decimal_marks"}    */
end_comment

begin_function
name|int
name|atof_generic
parameter_list|(
comment|/* return pointer to just AFTER number we read.  */
name|char
modifier|*
modifier|*
name|address_of_string_pointer
parameter_list|,
comment|/* At most one per number.  */
specifier|const
name|char
modifier|*
name|string_of_decimal_marks
parameter_list|,
specifier|const
name|char
modifier|*
name|string_of_decimal_exponent_marks
parameter_list|,
name|FLONUM_TYPE
modifier|*
name|address_of_generic_floating_point_number
parameter_list|)
block|{
name|int
name|return_value
decl_stmt|;
comment|/* 0 means OK.  */
name|char
modifier|*
name|first_digit
decl_stmt|;
name|unsigned
name|int
name|number_of_digits_before_decimal
decl_stmt|;
name|unsigned
name|int
name|number_of_digits_after_decimal
decl_stmt|;
name|long
name|decimal_exponent
decl_stmt|;
name|unsigned
name|int
name|number_of_digits_available
decl_stmt|;
name|char
name|digits_sign_char
decl_stmt|;
comment|/*    * Scan the input string, abstracting (1)digits (2)decimal mark (3) exponent.    * It would be simpler to modify the string, but we don't; just to be nice    * to caller.    * We need to know how many digits we have, so we can allocate space for    * the digits' value.    */
name|char
modifier|*
name|p
decl_stmt|;
name|char
name|c
decl_stmt|;
name|int
name|seen_significant_digit
decl_stmt|;
ifdef|#
directive|ifdef
name|ASSUME_DECIMAL_MARK_IS_DOT
name|assert
argument_list|(
name|string_of_decimal_marks
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
name|string_of_decimal_marks
index|[
literal|1
index|]
operator|==
literal|0
argument_list|)
expr_stmt|;
define|#
directive|define
name|IS_DECIMAL_MARK
parameter_list|(
name|c
parameter_list|)
value|((c) == '.')
else|#
directive|else
define|#
directive|define
name|IS_DECIMAL_MARK
parameter_list|(
name|c
parameter_list|)
value|(0 != strchr (string_of_decimal_marks, (c)))
endif|#
directive|endif
name|first_digit
operator|=
operator|*
name|address_of_string_pointer
expr_stmt|;
name|c
operator|=
operator|*
name|first_digit
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'-'
operator|||
name|c
operator|==
literal|'+'
condition|)
block|{
name|digits_sign_char
operator|=
name|c
expr_stmt|;
name|first_digit
operator|++
expr_stmt|;
block|}
else|else
name|digits_sign_char
operator|=
literal|'+'
expr_stmt|;
switch|switch
condition|(
name|first_digit
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|'n'
case|:
case|case
literal|'N'
case|:
if|if
condition|(
operator|!
name|strncasecmp
argument_list|(
literal|"nan"
argument_list|,
name|first_digit
argument_list|,
literal|3
argument_list|)
condition|)
block|{
name|address_of_generic_floating_point_number
operator|->
name|sign
operator|=
literal|0
expr_stmt|;
name|address_of_generic_floating_point_number
operator|->
name|exponent
operator|=
literal|0
expr_stmt|;
name|address_of_generic_floating_point_number
operator|->
name|leader
operator|=
name|address_of_generic_floating_point_number
operator|->
name|low
expr_stmt|;
operator|*
name|address_of_string_pointer
operator|=
name|first_digit
operator|+
literal|3
expr_stmt|;
return|return
literal|0
return|;
block|}
break|break;
case|case
literal|'i'
case|:
case|case
literal|'I'
case|:
if|if
condition|(
operator|!
name|strncasecmp
argument_list|(
literal|"inf"
argument_list|,
name|first_digit
argument_list|,
literal|3
argument_list|)
condition|)
block|{
name|address_of_generic_floating_point_number
operator|->
name|sign
operator|=
name|digits_sign_char
operator|==
literal|'+'
condition|?
literal|'P'
else|:
literal|'N'
expr_stmt|;
name|address_of_generic_floating_point_number
operator|->
name|exponent
operator|=
literal|0
expr_stmt|;
name|address_of_generic_floating_point_number
operator|->
name|leader
operator|=
name|address_of_generic_floating_point_number
operator|->
name|low
expr_stmt|;
name|first_digit
operator|+=
literal|3
expr_stmt|;
if|if
condition|(
operator|!
name|strncasecmp
argument_list|(
literal|"inity"
argument_list|,
name|first_digit
argument_list|,
literal|5
argument_list|)
condition|)
name|first_digit
operator|+=
literal|5
expr_stmt|;
operator|*
name|address_of_string_pointer
operator|=
name|first_digit
expr_stmt|;
return|return
literal|0
return|;
block|}
break|break;
block|}
name|number_of_digits_before_decimal
operator|=
literal|0
expr_stmt|;
name|number_of_digits_after_decimal
operator|=
literal|0
expr_stmt|;
name|decimal_exponent
operator|=
literal|0
expr_stmt|;
name|seen_significant_digit
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|p
operator|=
name|first_digit
init|;
operator|(
operator|(
operator|(
name|c
operator|=
operator|*
name|p
operator|)
operator|!=
literal|'\0'
operator|)
operator|&&
operator|(
operator|!
name|c
operator|||
operator|!
name|IS_DECIMAL_MARK
argument_list|(
name|c
argument_list|)
operator|)
operator|&&
operator|(
operator|!
name|c
operator|||
operator|!
name|strchr
argument_list|(
name|string_of_decimal_exponent_marks
argument_list|,
name|c
argument_list|)
operator|)
operator|)
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
name|ISDIGIT
argument_list|(
name|c
argument_list|)
condition|)
block|{
if|if
condition|(
name|seen_significant_digit
operator|||
name|c
operator|>
literal|'0'
condition|)
block|{
operator|++
name|number_of_digits_before_decimal
expr_stmt|;
name|seen_significant_digit
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|first_digit
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
break|break;
comment|/* p -> char after pre-decimal digits.  */
block|}
block|}
comment|/* For each digit before decimal mark.  */
ifndef|#
directive|ifndef
name|OLD_FLOAT_READS
comment|/* Ignore trailing 0's after the decimal point.  The original code here    * (ifdef'd out) does not do this, and numbers like    *	4.29496729600000000000e+09	(2**31)    * come out inexact for some reason related to length of the digit    * string.    */
if|if
condition|(
name|c
operator|&&
name|IS_DECIMAL_MARK
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|unsigned
name|int
name|zeros
init|=
literal|0
decl_stmt|;
comment|/* Length of current string of zeros */
for|for
control|(
name|p
operator|++
init|;
operator|(
name|c
operator|=
operator|*
name|p
operator|)
operator|&&
name|ISDIGIT
argument_list|(
name|c
argument_list|)
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
name|c
operator|==
literal|'0'
condition|)
block|{
name|zeros
operator|++
expr_stmt|;
block|}
else|else
block|{
name|number_of_digits_after_decimal
operator|+=
literal|1
operator|+
name|zeros
expr_stmt|;
name|zeros
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
else|#
directive|else
if|if
condition|(
name|c
operator|&&
name|IS_DECIMAL_MARK
argument_list|(
name|c
argument_list|)
condition|)
block|{
for|for
control|(
name|p
operator|++
init|;
operator|(
operator|(
operator|(
name|c
operator|=
operator|*
name|p
operator|)
operator|!=
literal|'\0'
operator|)
operator|&&
operator|(
operator|!
name|c
operator|||
operator|!
name|strchr
argument_list|(
name|string_of_decimal_exponent_marks
argument_list|,
name|c
argument_list|)
operator|)
operator|)
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
name|ISDIGIT
argument_list|(
name|c
argument_list|)
condition|)
block|{
comment|/* This may be retracted below.  */
name|number_of_digits_after_decimal
operator|++
expr_stmt|;
if|if
condition|(
comment|/* seen_significant_digit || */
name|c
operator|>
literal|'0'
condition|)
block|{
name|seen_significant_digit
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
name|seen_significant_digit
condition|)
block|{
name|number_of_digits_after_decimal
operator|=
literal|0
expr_stmt|;
block|}
break|break;
block|}
block|}
comment|/* For each digit after decimal mark.  */
block|}
while|while
condition|(
name|number_of_digits_after_decimal
operator|&&
name|first_digit
index|[
name|number_of_digits_before_decimal
operator|+
name|number_of_digits_after_decimal
index|]
operator|==
literal|'0'
condition|)
operator|--
name|number_of_digits_after_decimal
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|flag_m68k_mri
condition|)
block|{
while|while
condition|(
name|c
operator|==
literal|'_'
condition|)
name|c
operator|=
operator|*
operator|++
name|p
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|&&
name|strchr
argument_list|(
name|string_of_decimal_exponent_marks
argument_list|,
name|c
argument_list|)
condition|)
block|{
name|char
name|digits_exponent_sign_char
decl_stmt|;
name|c
operator|=
operator|*
operator|++
name|p
expr_stmt|;
if|if
condition|(
name|flag_m68k_mri
condition|)
block|{
while|while
condition|(
name|c
operator|==
literal|'_'
condition|)
name|c
operator|=
operator|*
operator|++
name|p
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|&&
name|strchr
argument_list|(
literal|"+-"
argument_list|,
name|c
argument_list|)
condition|)
block|{
name|digits_exponent_sign_char
operator|=
name|c
expr_stmt|;
name|c
operator|=
operator|*
operator|++
name|p
expr_stmt|;
block|}
else|else
block|{
name|digits_exponent_sign_char
operator|=
literal|'+'
expr_stmt|;
block|}
for|for
control|(
init|;
operator|(
name|c
operator|)
condition|;
name|c
operator|=
operator|*
operator|++
name|p
control|)
block|{
if|if
condition|(
name|ISDIGIT
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|decimal_exponent
operator|=
name|decimal_exponent
operator|*
literal|10
operator|+
name|c
operator|-
literal|'0'
expr_stmt|;
comment|/* 	       * BUG! If we overflow here, we lose! 	       */
block|}
else|else
block|{
break|break;
block|}
block|}
if|if
condition|(
name|digits_exponent_sign_char
operator|==
literal|'-'
condition|)
block|{
name|decimal_exponent
operator|=
operator|-
name|decimal_exponent
expr_stmt|;
block|}
block|}
operator|*
name|address_of_string_pointer
operator|=
name|p
expr_stmt|;
name|number_of_digits_available
operator|=
name|number_of_digits_before_decimal
operator|+
name|number_of_digits_after_decimal
expr_stmt|;
name|return_value
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|number_of_digits_available
operator|==
literal|0
condition|)
block|{
name|address_of_generic_floating_point_number
operator|->
name|exponent
operator|=
literal|0
expr_stmt|;
comment|/* Not strictly necessary */
name|address_of_generic_floating_point_number
operator|->
name|leader
operator|=
operator|-
literal|1
operator|+
name|address_of_generic_floating_point_number
operator|->
name|low
expr_stmt|;
name|address_of_generic_floating_point_number
operator|->
name|sign
operator|=
name|digits_sign_char
expr_stmt|;
comment|/* We have just concocted (+/-)0.0E0 */
block|}
else|else
block|{
name|int
name|count
decl_stmt|;
comment|/* Number of useful digits left to scan.  */
name|LITTLENUM_TYPE
modifier|*
name|digits_binary_low
decl_stmt|;
name|unsigned
name|int
name|precision
decl_stmt|;
name|unsigned
name|int
name|maximum_useful_digits
decl_stmt|;
name|unsigned
name|int
name|number_of_digits_to_use
decl_stmt|;
name|unsigned
name|int
name|more_than_enough_bits_for_digits
decl_stmt|;
name|unsigned
name|int
name|more_than_enough_littlenums_for_digits
decl_stmt|;
name|unsigned
name|int
name|size_of_digits_in_littlenums
decl_stmt|;
name|unsigned
name|int
name|size_of_digits_in_chars
decl_stmt|;
name|FLONUM_TYPE
name|power_of_10_flonum
decl_stmt|;
name|FLONUM_TYPE
name|digits_flonum
decl_stmt|;
name|precision
operator|=
operator|(
name|address_of_generic_floating_point_number
operator|->
name|high
operator|-
name|address_of_generic_floating_point_number
operator|->
name|low
operator|+
literal|1
operator|)
expr_stmt|;
comment|/* Number of destination littlenums.  */
comment|/* Includes guard bits (two littlenums worth) */
name|maximum_useful_digits
operator|=
operator|(
operator|(
operator|(
name|precision
operator|-
literal|2
operator|)
operator|)
operator|*
operator|(
operator|(
name|LITTLENUM_NUMBER_OF_BITS
operator|)
operator|)
operator|*
literal|1000000
operator|/
literal|3321928
operator|)
operator|+
literal|2
expr_stmt|;
comment|/* 2 :: guard digits.  */
if|if
condition|(
name|number_of_digits_available
operator|>
name|maximum_useful_digits
condition|)
block|{
name|number_of_digits_to_use
operator|=
name|maximum_useful_digits
expr_stmt|;
block|}
else|else
block|{
name|number_of_digits_to_use
operator|=
name|number_of_digits_available
expr_stmt|;
block|}
comment|/* Cast these to SIGNED LONG first, otherwise, on systems with 	 LONG wider than INT (such as Alpha OSF/1), unsignedness may 	 cause unexpected results.  */
name|decimal_exponent
operator|+=
operator|(
operator|(
name|long
operator|)
name|number_of_digits_before_decimal
operator|-
operator|(
name|long
operator|)
name|number_of_digits_to_use
operator|)
expr_stmt|;
name|more_than_enough_bits_for_digits
operator|=
operator|(
name|number_of_digits_to_use
operator|*
literal|3321928
operator|/
literal|1000000
operator|+
literal|1
operator|)
expr_stmt|;
name|more_than_enough_littlenums_for_digits
operator|=
operator|(
name|more_than_enough_bits_for_digits
operator|/
name|LITTLENUM_NUMBER_OF_BITS
operator|)
operator|+
literal|2
expr_stmt|;
comment|/* Compute (digits) part. In "12.34E56" this is the "1234" part. 	 Arithmetic is exact here. If no digits are supplied then this 	 part is a 0 valued binary integer.  Allocate room to build up 	 the binary number as littlenums.  We want this memory to 	 disappear when we leave this function.  Assume no alignment 	 problems => (room for n objects) == n * (room for 1 	 object).  */
name|size_of_digits_in_littlenums
operator|=
name|more_than_enough_littlenums_for_digits
expr_stmt|;
name|size_of_digits_in_chars
operator|=
name|size_of_digits_in_littlenums
operator|*
sizeof|sizeof
argument_list|(
name|LITTLENUM_TYPE
argument_list|)
expr_stmt|;
name|digits_binary_low
operator|=
operator|(
name|LITTLENUM_TYPE
operator|*
operator|)
name|alloca
argument_list|(
name|size_of_digits_in_chars
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|digits_binary_low
argument_list|,
literal|'\0'
argument_list|,
name|size_of_digits_in_chars
argument_list|)
expr_stmt|;
comment|/* Digits_binary_low[] is allocated and zeroed.  */
comment|/*        * Parse the decimal digits as if * digits_low was in the units position.        * Emit a binary number into digits_binary_low[].        *        * Use a large-precision version of:        * (((1st-digit) * 10 + 2nd-digit) * 10 + 3rd-digit ...) * 10 + last-digit        */
for|for
control|(
name|p
operator|=
name|first_digit
operator|,
name|count
operator|=
name|number_of_digits_to_use
init|;
name|count
condition|;
name|p
operator|++
operator|,
operator|--
name|count
control|)
block|{
name|c
operator|=
operator|*
name|p
expr_stmt|;
if|if
condition|(
name|ISDIGIT
argument_list|(
name|c
argument_list|)
condition|)
block|{
comment|/* 	       * Multiply by 10. Assume can never overflow. 	       * Add this digit to digits_binary_low[]. 	       */
name|long
name|carry
decl_stmt|;
name|LITTLENUM_TYPE
modifier|*
name|littlenum_pointer
decl_stmt|;
name|LITTLENUM_TYPE
modifier|*
name|littlenum_limit
decl_stmt|;
name|littlenum_limit
operator|=
name|digits_binary_low
operator|+
name|more_than_enough_littlenums_for_digits
operator|-
literal|1
expr_stmt|;
name|carry
operator|=
name|c
operator|-
literal|'0'
expr_stmt|;
comment|/* char -> binary */
for|for
control|(
name|littlenum_pointer
operator|=
name|digits_binary_low
init|;
name|littlenum_pointer
operator|<=
name|littlenum_limit
condition|;
name|littlenum_pointer
operator|++
control|)
block|{
name|long
name|work
decl_stmt|;
name|work
operator|=
name|carry
operator|+
literal|10
operator|*
call|(
name|long
call|)
argument_list|(
operator|*
name|littlenum_pointer
argument_list|)
expr_stmt|;
operator|*
name|littlenum_pointer
operator|=
name|work
operator|&
name|LITTLENUM_MASK
expr_stmt|;
name|carry
operator|=
name|work
operator|>>
name|LITTLENUM_NUMBER_OF_BITS
expr_stmt|;
block|}
if|if
condition|(
name|carry
operator|!=
literal|0
condition|)
block|{
comment|/* 		   * We have a GROSS internal error. 		   * This should never happen. 		   */
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"failed sanity check"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
operator|++
name|count
expr_stmt|;
comment|/* '.' doesn't alter digits used count.  */
block|}
block|}
comment|/*        * Digits_binary_low[] properly encodes the value of the digits.        * Forget about any high-order littlenums that are 0.        */
while|while
condition|(
name|digits_binary_low
index|[
name|size_of_digits_in_littlenums
operator|-
literal|1
index|]
operator|==
literal|0
operator|&&
name|size_of_digits_in_littlenums
operator|>=
literal|2
condition|)
name|size_of_digits_in_littlenums
operator|--
expr_stmt|;
name|digits_flonum
operator|.
name|low
operator|=
name|digits_binary_low
expr_stmt|;
name|digits_flonum
operator|.
name|high
operator|=
name|digits_binary_low
operator|+
name|size_of_digits_in_littlenums
operator|-
literal|1
expr_stmt|;
name|digits_flonum
operator|.
name|leader
operator|=
name|digits_flonum
operator|.
name|high
expr_stmt|;
name|digits_flonum
operator|.
name|exponent
operator|=
literal|0
expr_stmt|;
comment|/*        * The value of digits_flonum . sign should not be important.        * We have already decided the output's sign.        * We trust that the sign won't influence the other parts of the number!        * So we give it a value for these reasons:        * (1) courtesy to humans reading/debugging        *     these numbers so they don't get excited about strange values        * (2) in future there may be more meaning attached to sign,        *     and what was        *     harmless noise may become disruptive, ill-conditioned (or worse)        *     input.        */
name|digits_flonum
operator|.
name|sign
operator|=
literal|'+'
expr_stmt|;
block|{
comment|/* 	 * Compute the mantssa (& exponent) of the power of 10. 	 * If successful, then multiply the power of 10 by the digits 	 * giving return_binary_mantissa and return_binary_exponent. 	 */
name|LITTLENUM_TYPE
modifier|*
name|power_binary_low
decl_stmt|;
name|int
name|decimal_exponent_is_negative
decl_stmt|;
comment|/* This refers to the "-56" in "12.34E-56".  */
comment|/* FALSE: decimal_exponent is positive (or 0) */
comment|/* TRUE:  decimal_exponent is negative */
name|FLONUM_TYPE
name|temporary_flonum
decl_stmt|;
name|LITTLENUM_TYPE
modifier|*
name|temporary_binary_low
decl_stmt|;
name|unsigned
name|int
name|size_of_power_in_littlenums
decl_stmt|;
name|unsigned
name|int
name|size_of_power_in_chars
decl_stmt|;
name|size_of_power_in_littlenums
operator|=
name|precision
expr_stmt|;
comment|/* Precision has a built-in fudge factor so we get a few guard bits.  */
name|decimal_exponent_is_negative
operator|=
name|decimal_exponent
operator|<
literal|0
expr_stmt|;
if|if
condition|(
name|decimal_exponent_is_negative
condition|)
block|{
name|decimal_exponent
operator|=
operator|-
name|decimal_exponent
expr_stmt|;
block|}
comment|/* From now on: the decimal exponent is> 0. Its sign is separate.  */
name|size_of_power_in_chars
operator|=
name|size_of_power_in_littlenums
operator|*
sizeof|sizeof
argument_list|(
name|LITTLENUM_TYPE
argument_list|)
operator|+
literal|2
expr_stmt|;
name|power_binary_low
operator|=
operator|(
name|LITTLENUM_TYPE
operator|*
operator|)
name|alloca
argument_list|(
name|size_of_power_in_chars
argument_list|)
expr_stmt|;
name|temporary_binary_low
operator|=
operator|(
name|LITTLENUM_TYPE
operator|*
operator|)
name|alloca
argument_list|(
name|size_of_power_in_chars
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|power_binary_low
argument_list|,
literal|'\0'
argument_list|,
name|size_of_power_in_chars
argument_list|)
expr_stmt|;
operator|*
name|power_binary_low
operator|=
literal|1
expr_stmt|;
name|power_of_10_flonum
operator|.
name|exponent
operator|=
literal|0
expr_stmt|;
name|power_of_10_flonum
operator|.
name|low
operator|=
name|power_binary_low
expr_stmt|;
name|power_of_10_flonum
operator|.
name|leader
operator|=
name|power_binary_low
expr_stmt|;
name|power_of_10_flonum
operator|.
name|high
operator|=
name|power_binary_low
operator|+
name|size_of_power_in_littlenums
operator|-
literal|1
expr_stmt|;
name|power_of_10_flonum
operator|.
name|sign
operator|=
literal|'+'
expr_stmt|;
name|temporary_flonum
operator|.
name|low
operator|=
name|temporary_binary_low
expr_stmt|;
name|temporary_flonum
operator|.
name|high
operator|=
name|temporary_binary_low
operator|+
name|size_of_power_in_littlenums
operator|-
literal|1
expr_stmt|;
comment|/* 	 * (power) == 1. 	 * Space for temporary_flonum allocated. 	 */
comment|/* 	 * ... 	 * 	 * WHILE	more bits 	 * DO	find next bit (with place value) 	 *	multiply into power mantissa 	 * OD 	 */
block|{
name|int
name|place_number_limit
decl_stmt|;
comment|/* Any 10^(2^n) whose "n" exceeds this */
comment|/* value will fall off the end of */
comment|/* flonum_XXXX_powers_of_ten[].  */
name|int
name|place_number
decl_stmt|;
specifier|const
name|FLONUM_TYPE
modifier|*
name|multiplicand
decl_stmt|;
comment|/* -> 10^(2^n) */
name|place_number_limit
operator|=
name|table_size_of_flonum_powers_of_ten
expr_stmt|;
name|multiplicand
operator|=
operator|(
name|decimal_exponent_is_negative
condition|?
name|flonum_negative_powers_of_ten
else|:
name|flonum_positive_powers_of_ten
operator|)
expr_stmt|;
for|for
control|(
name|place_number
operator|=
literal|1
init|;
comment|/* Place value of this bit of exponent.  */
name|decimal_exponent
condition|;
comment|/* Quit when no more 1 bits in exponent.  */
name|decimal_exponent
operator|>>=
literal|1
operator|,
name|place_number
operator|++
control|)
block|{
if|if
condition|(
name|decimal_exponent
operator|&
literal|1
condition|)
block|{
if|if
condition|(
name|place_number
operator|>
name|place_number_limit
condition|)
block|{
comment|/* The decimal exponent has a magnitude so great 			 that our tables can't help us fragment it. 			 Although this routine is in error because it 			 can't imagine a number that big, signal an 			 error as if it is the user's fault for 			 presenting such a big number.  */
name|return_value
operator|=
name|ERROR_EXPONENT_OVERFLOW
expr_stmt|;
comment|/* quit out of loop gracefully */
name|decimal_exponent
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|TRACE
name|printf
argument_list|(
literal|"before multiply, place_number = %d., power_of_10_flonum:\n"
argument_list|,
name|place_number
argument_list|)
expr_stmt|;
name|flonum_print
argument_list|(
operator|&
name|power_of_10_flonum
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TRACE
name|printf
argument_list|(
literal|"multiplier:\n"
argument_list|)
expr_stmt|;
name|flonum_print
argument_list|(
name|multiplicand
operator|+
name|place_number
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|flonum_multip
argument_list|(
name|multiplicand
operator|+
name|place_number
argument_list|,
operator|&
name|power_of_10_flonum
argument_list|,
operator|&
name|temporary_flonum
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TRACE
name|printf
argument_list|(
literal|"after multiply:\n"
argument_list|)
expr_stmt|;
name|flonum_print
argument_list|(
operator|&
name|temporary_flonum
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|flonum_copy
argument_list|(
operator|&
name|temporary_flonum
argument_list|,
operator|&
name|power_of_10_flonum
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TRACE
name|printf
argument_list|(
literal|"after copy:\n"
argument_list|)
expr_stmt|;
name|flonum_print
argument_list|(
operator|&
name|power_of_10_flonum
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* If this bit of decimal_exponent was computable.*/
block|}
comment|/* If this bit of decimal_exponent was set.  */
block|}
comment|/* For each bit of binary representation of exponent */
ifdef|#
directive|ifdef
name|TRACE
name|printf
argument_list|(
literal|"after computing power_of_10_flonum:\n"
argument_list|)
expr_stmt|;
name|flonum_print
argument_list|(
operator|&
name|power_of_10_flonum
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
comment|/*        * power_of_10_flonum is power of ten in binary (mantissa) , (exponent).        * It may be the number 1, in which case we don't NEED to multiply.        *        * Multiply (decimal digits) by power_of_10_flonum.        */
name|flonum_multip
argument_list|(
operator|&
name|power_of_10_flonum
argument_list|,
operator|&
name|digits_flonum
argument_list|,
name|address_of_generic_floating_point_number
argument_list|)
expr_stmt|;
comment|/* Assert sign of the number we made is '+'.  */
name|address_of_generic_floating_point_number
operator|->
name|sign
operator|=
name|digits_sign_char
expr_stmt|;
block|}
return|return
name|return_value
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|TRACE
end_ifdef

begin_function
specifier|static
name|void
name|flonum_print
parameter_list|(
name|f
parameter_list|)
specifier|const
name|FLONUM_TYPE
modifier|*
name|f
decl_stmt|;
block|{
name|LITTLENUM_TYPE
modifier|*
name|lp
decl_stmt|;
name|char
name|littlenum_format
index|[
literal|10
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|littlenum_format
argument_list|,
literal|" %%0%dx"
argument_list|,
sizeof|sizeof
argument_list|(
name|LITTLENUM_TYPE
argument_list|)
operator|*
literal|2
argument_list|)
expr_stmt|;
define|#
directive|define
name|print_littlenum
parameter_list|(
name|LP
parameter_list|)
value|(printf (littlenum_format, LP))
name|printf
argument_list|(
literal|"flonum @%p %c e%ld"
argument_list|,
name|f
argument_list|,
name|f
operator|->
name|sign
argument_list|,
name|f
operator|->
name|exponent
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|->
name|low
operator|<
name|f
operator|->
name|high
condition|)
for|for
control|(
name|lp
operator|=
name|f
operator|->
name|high
init|;
name|lp
operator|>=
name|f
operator|->
name|low
condition|;
name|lp
operator|--
control|)
name|print_littlenum
argument_list|(
operator|*
name|lp
argument_list|)
expr_stmt|;
else|else
for|for
control|(
name|lp
operator|=
name|f
operator|->
name|low
init|;
name|lp
operator|<=
name|f
operator|->
name|high
condition|;
name|lp
operator|++
control|)
name|print_littlenum
argument_list|(
operator|*
name|lp
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* end of atof_generic.c */
end_comment

end_unit

