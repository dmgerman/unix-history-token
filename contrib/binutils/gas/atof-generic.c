begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* atof_generic.c - turn a string of digits into a Flonum    Copyright (C) 1987, 90, 91, 92, 93, 94, 95, 1996    Free Software Foundation, Inc.     This file is part of GAS, the GNU Assembler.     GAS is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     GAS is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with GAS; see the file COPYING.  If not, write to    the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|"as.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|FALSE
end_ifndef

begin_define
define|#
directive|define
name|FALSE
value|(0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|TRUE
end_ifndef

begin_define
define|#
directive|define
name|TRUE
value|(1)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|TRACE
end_ifdef

begin_decl_stmt
specifier|static
name|void
name|flonum_print
name|PARAMS
argument_list|(
operator|(
specifier|const
name|FLONUM_TYPE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|ASSUME_DECIMAL_MARK_IS_DOT
end_define

begin_comment
comment|/***********************************************************************\  *									*  *	Given a string of decimal digits , with optional decimal	*  *	mark and optional decimal exponent (place value) of the		*  *	lowest_order decimal digit: produce a floating point		*  *	number. The number is 'generic' floating point: our		*  *	caller will encode it for a specific machine architecture.	*  *									*  *	Assumptions							*  *		uses base (radix) 2					*  *		this machine uses 2's complement binary integers	*  *		target flonums use "      "         "       "		*  *		target flonums exponents fit in a long			*  *									*  \***********************************************************************/
end_comment

begin_comment
comment|/*    Syntax:<flonum> ::=<optional-sign><decimal-number><optional-exponent><optional-sign> ::= '+' | '-' | {empty}<decimal-number> ::=<integer>   |<integer><radix-character>   |<integer><radix-character><integer>   |<radix-character><integer><optional-exponent> ::= {empty}   |<exponent-character><optional-sign><integer><integer> ::=<digit> |<digit><integer><digit> ::= '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9'<exponent-character> ::= {one character from "string_of_decimal_exponent_marks"}<radix-character> ::= {one character from "string_of_decimal_marks"}    */
end_comment

begin_function
name|int
name|atof_generic
parameter_list|(
name|address_of_string_pointer
parameter_list|,
name|string_of_decimal_marks
parameter_list|,
name|string_of_decimal_exponent_marks
parameter_list|,
name|address_of_generic_floating_point_number
parameter_list|)
comment|/* return pointer to just AFTER number we read. */
name|char
modifier|*
modifier|*
name|address_of_string_pointer
decl_stmt|;
comment|/* At most one per number. */
specifier|const
name|char
modifier|*
name|string_of_decimal_marks
decl_stmt|;
specifier|const
name|char
modifier|*
name|string_of_decimal_exponent_marks
decl_stmt|;
name|FLONUM_TYPE
modifier|*
name|address_of_generic_floating_point_number
decl_stmt|;
block|{
name|int
name|return_value
decl_stmt|;
comment|/* 0 means OK. */
name|char
modifier|*
name|first_digit
decl_stmt|;
name|int
name|number_of_digits_before_decimal
decl_stmt|;
name|int
name|number_of_digits_after_decimal
decl_stmt|;
name|long
name|decimal_exponent
decl_stmt|;
name|int
name|number_of_digits_available
decl_stmt|;
name|char
name|digits_sign_char
decl_stmt|;
comment|/*    * Scan the input string, abstracting (1)digits (2)decimal mark (3) exponent.    * It would be simpler to modify the string, but we don't; just to be nice    * to caller.    * We need to know how many digits we have, so we can allocate space for    * the digits' value.    */
name|char
modifier|*
name|p
decl_stmt|;
name|char
name|c
decl_stmt|;
name|int
name|seen_significant_digit
decl_stmt|;
ifdef|#
directive|ifdef
name|ASSUME_DECIMAL_MARK_IS_DOT
name|assert
argument_list|(
name|string_of_decimal_marks
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
name|string_of_decimal_marks
index|[
literal|1
index|]
operator|==
literal|0
argument_list|)
expr_stmt|;
define|#
directive|define
name|IS_DECIMAL_MARK
parameter_list|(
name|c
parameter_list|)
value|((c) == '.')
else|#
directive|else
define|#
directive|define
name|IS_DECIMAL_MARK
parameter_list|(
name|c
parameter_list|)
value|(0 != strchr (string_of_decimal_marks, (c)))
endif|#
directive|endif
name|first_digit
operator|=
operator|*
name|address_of_string_pointer
expr_stmt|;
name|c
operator|=
operator|*
name|first_digit
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'-'
operator|||
name|c
operator|==
literal|'+'
condition|)
block|{
name|digits_sign_char
operator|=
name|c
expr_stmt|;
name|first_digit
operator|++
expr_stmt|;
block|}
else|else
name|digits_sign_char
operator|=
literal|'+'
expr_stmt|;
switch|switch
condition|(
name|first_digit
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|'n'
case|:
case|case
literal|'N'
case|:
if|if
condition|(
operator|!
name|strncasecmp
argument_list|(
literal|"nan"
argument_list|,
name|first_digit
argument_list|,
literal|3
argument_list|)
condition|)
block|{
name|address_of_generic_floating_point_number
operator|->
name|sign
operator|=
literal|0
expr_stmt|;
name|address_of_generic_floating_point_number
operator|->
name|exponent
operator|=
literal|0
expr_stmt|;
name|address_of_generic_floating_point_number
operator|->
name|leader
operator|=
name|address_of_generic_floating_point_number
operator|->
name|low
expr_stmt|;
operator|*
name|address_of_string_pointer
operator|=
name|first_digit
operator|+
literal|3
expr_stmt|;
return|return
literal|0
return|;
block|}
break|break;
case|case
literal|'i'
case|:
case|case
literal|'I'
case|:
if|if
condition|(
operator|!
name|strncasecmp
argument_list|(
literal|"inf"
argument_list|,
name|first_digit
argument_list|,
literal|3
argument_list|)
condition|)
block|{
name|address_of_generic_floating_point_number
operator|->
name|sign
operator|=
name|digits_sign_char
operator|==
literal|'+'
condition|?
literal|'P'
else|:
literal|'N'
expr_stmt|;
name|address_of_generic_floating_point_number
operator|->
name|exponent
operator|=
literal|0
expr_stmt|;
name|address_of_generic_floating_point_number
operator|->
name|leader
operator|=
name|address_of_generic_floating_point_number
operator|->
name|low
expr_stmt|;
name|first_digit
operator|+=
literal|3
expr_stmt|;
if|if
condition|(
operator|!
name|strncasecmp
argument_list|(
literal|"inity"
argument_list|,
name|first_digit
argument_list|,
literal|5
argument_list|)
condition|)
name|first_digit
operator|+=
literal|5
expr_stmt|;
operator|*
name|address_of_string_pointer
operator|=
name|first_digit
expr_stmt|;
return|return
literal|0
return|;
block|}
break|break;
block|}
name|number_of_digits_before_decimal
operator|=
literal|0
expr_stmt|;
name|number_of_digits_after_decimal
operator|=
literal|0
expr_stmt|;
name|decimal_exponent
operator|=
literal|0
expr_stmt|;
name|seen_significant_digit
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|p
operator|=
name|first_digit
init|;
operator|(
operator|(
operator|(
name|c
operator|=
operator|*
name|p
operator|)
operator|!=
literal|'\0'
operator|)
operator|&&
operator|(
operator|!
name|c
operator|||
operator|!
name|IS_DECIMAL_MARK
argument_list|(
name|c
argument_list|)
operator|)
operator|&&
operator|(
operator|!
name|c
operator|||
operator|!
name|strchr
argument_list|(
name|string_of_decimal_exponent_marks
argument_list|,
name|c
argument_list|)
operator|)
operator|)
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
name|isdigit
argument_list|(
name|c
argument_list|)
condition|)
block|{
if|if
condition|(
name|seen_significant_digit
operator|||
name|c
operator|>
literal|'0'
condition|)
block|{
operator|++
name|number_of_digits_before_decimal
expr_stmt|;
name|seen_significant_digit
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|first_digit
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
break|break;
comment|/* p -> char after pre-decimal digits. */
block|}
block|}
comment|/* For each digit before decimal mark. */
ifndef|#
directive|ifndef
name|OLD_FLOAT_READS
comment|/* Ignore trailing 0's after the decimal point.  The original code here    * (ifdef'd out) does not do this, and numbers like    *	4.29496729600000000000e+09	(2**31)    * come out inexact for some reason related to length of the digit    * string.    */
if|if
condition|(
name|c
operator|&&
name|IS_DECIMAL_MARK
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|int
name|zeros
init|=
literal|0
decl_stmt|;
comment|/* Length of current string of zeros */
for|for
control|(
name|p
operator|++
init|;
operator|(
name|c
operator|=
operator|*
name|p
operator|)
operator|&&
name|isdigit
argument_list|(
name|c
argument_list|)
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
name|c
operator|==
literal|'0'
condition|)
block|{
name|zeros
operator|++
expr_stmt|;
block|}
else|else
block|{
name|number_of_digits_after_decimal
operator|+=
literal|1
operator|+
name|zeros
expr_stmt|;
name|zeros
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
else|#
directive|else
if|if
condition|(
name|c
operator|&&
name|IS_DECIMAL_MARK
argument_list|(
name|c
argument_list|)
condition|)
block|{
for|for
control|(
name|p
operator|++
init|;
operator|(
operator|(
operator|(
name|c
operator|=
operator|*
name|p
operator|)
operator|!=
literal|'\0'
operator|)
operator|&&
operator|(
operator|!
name|c
operator|||
operator|!
name|strchr
argument_list|(
name|string_of_decimal_exponent_marks
argument_list|,
name|c
argument_list|)
operator|)
operator|)
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
name|isdigit
argument_list|(
name|c
argument_list|)
condition|)
block|{
comment|/* This may be retracted below. */
name|number_of_digits_after_decimal
operator|++
expr_stmt|;
if|if
condition|(
comment|/* seen_significant_digit || */
name|c
operator|>
literal|'0'
condition|)
block|{
name|seen_significant_digit
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
name|seen_significant_digit
condition|)
block|{
name|number_of_digits_after_decimal
operator|=
literal|0
expr_stmt|;
block|}
break|break;
block|}
block|}
comment|/* For each digit after decimal mark. */
block|}
while|while
condition|(
name|number_of_digits_after_decimal
operator|&&
name|first_digit
index|[
name|number_of_digits_before_decimal
operator|+
name|number_of_digits_after_decimal
index|]
operator|==
literal|'0'
condition|)
operator|--
name|number_of_digits_after_decimal
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|flag_m68k_mri
condition|)
block|{
while|while
condition|(
name|c
operator|==
literal|'_'
condition|)
name|c
operator|=
operator|*
operator|++
name|p
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|&&
name|strchr
argument_list|(
name|string_of_decimal_exponent_marks
argument_list|,
name|c
argument_list|)
condition|)
block|{
name|char
name|digits_exponent_sign_char
decl_stmt|;
name|c
operator|=
operator|*
operator|++
name|p
expr_stmt|;
if|if
condition|(
name|flag_m68k_mri
condition|)
block|{
while|while
condition|(
name|c
operator|==
literal|'_'
condition|)
name|c
operator|=
operator|*
operator|++
name|p
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|&&
name|strchr
argument_list|(
literal|"+-"
argument_list|,
name|c
argument_list|)
condition|)
block|{
name|digits_exponent_sign_char
operator|=
name|c
expr_stmt|;
name|c
operator|=
operator|*
operator|++
name|p
expr_stmt|;
block|}
else|else
block|{
name|digits_exponent_sign_char
operator|=
literal|'+'
expr_stmt|;
block|}
for|for
control|(
init|;
operator|(
name|c
operator|)
condition|;
name|c
operator|=
operator|*
operator|++
name|p
control|)
block|{
if|if
condition|(
name|isdigit
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|decimal_exponent
operator|=
name|decimal_exponent
operator|*
literal|10
operator|+
name|c
operator|-
literal|'0'
expr_stmt|;
comment|/* 	       * BUG! If we overflow here, we lose! 	       */
block|}
else|else
block|{
break|break;
block|}
block|}
if|if
condition|(
name|digits_exponent_sign_char
operator|==
literal|'-'
condition|)
block|{
name|decimal_exponent
operator|=
operator|-
name|decimal_exponent
expr_stmt|;
block|}
block|}
operator|*
name|address_of_string_pointer
operator|=
name|p
expr_stmt|;
name|number_of_digits_available
operator|=
name|number_of_digits_before_decimal
operator|+
name|number_of_digits_after_decimal
expr_stmt|;
name|return_value
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|number_of_digits_available
operator|==
literal|0
condition|)
block|{
name|address_of_generic_floating_point_number
operator|->
name|exponent
operator|=
literal|0
expr_stmt|;
comment|/* Not strictly necessary */
name|address_of_generic_floating_point_number
operator|->
name|leader
operator|=
operator|-
literal|1
operator|+
name|address_of_generic_floating_point_number
operator|->
name|low
expr_stmt|;
name|address_of_generic_floating_point_number
operator|->
name|sign
operator|=
name|digits_sign_char
expr_stmt|;
comment|/* We have just concocted (+/-)0.0E0 */
block|}
else|else
block|{
name|int
name|count
decl_stmt|;
comment|/* Number of useful digits left to scan. */
name|LITTLENUM_TYPE
modifier|*
name|digits_binary_low
decl_stmt|;
name|unsigned
name|int
name|precision
decl_stmt|;
name|unsigned
name|int
name|maximum_useful_digits
decl_stmt|;
name|unsigned
name|int
name|number_of_digits_to_use
decl_stmt|;
name|unsigned
name|int
name|more_than_enough_bits_for_digits
decl_stmt|;
name|unsigned
name|int
name|more_than_enough_littlenums_for_digits
decl_stmt|;
name|unsigned
name|int
name|size_of_digits_in_littlenums
decl_stmt|;
name|unsigned
name|int
name|size_of_digits_in_chars
decl_stmt|;
name|FLONUM_TYPE
name|power_of_10_flonum
decl_stmt|;
name|FLONUM_TYPE
name|digits_flonum
decl_stmt|;
name|precision
operator|=
operator|(
name|address_of_generic_floating_point_number
operator|->
name|high
operator|-
name|address_of_generic_floating_point_number
operator|->
name|low
operator|+
literal|1
operator|)
expr_stmt|;
comment|/* Number of destination littlenums. */
comment|/* Includes guard bits (two littlenums worth) */
if|#
directive|if
literal|0
comment|/* The integer version below is very close, and it doesn't 	 require floating point support (which is currently buggy on 	 the Alpha).  */
block|maximum_useful_digits = (((double) (precision - 2)) 			       * ((double) (LITTLENUM_NUMBER_OF_BITS)) 			       / (LOG_TO_BASE_2_OF_10)) 	+ 2;
comment|/* 2 :: guard digits. */
else|#
directive|else
name|maximum_useful_digits
operator|=
operator|(
operator|(
operator|(
name|precision
operator|-
literal|2
operator|)
operator|)
operator|*
operator|(
operator|(
name|LITTLENUM_NUMBER_OF_BITS
operator|)
operator|)
operator|*
literal|1000000
operator|/
literal|3321928
operator|)
operator|+
literal|2
expr_stmt|;
comment|/* 2 :: guard digits. */
endif|#
directive|endif
if|if
condition|(
name|number_of_digits_available
operator|>
name|maximum_useful_digits
condition|)
block|{
name|number_of_digits_to_use
operator|=
name|maximum_useful_digits
expr_stmt|;
block|}
else|else
block|{
name|number_of_digits_to_use
operator|=
name|number_of_digits_available
expr_stmt|;
block|}
comment|/* Cast these to SIGNED LONG first, otherwise, on systems with 	 LONG wider than INT (such as Alpha OSF/1), unsignedness may 	 cause unexpected results.  */
name|decimal_exponent
operator|+=
operator|(
operator|(
name|long
operator|)
name|number_of_digits_before_decimal
operator|-
operator|(
name|long
operator|)
name|number_of_digits_to_use
operator|)
expr_stmt|;
if|#
directive|if
literal|0
block|more_than_enough_bits_for_digits 	= ((((double) number_of_digits_to_use) * LOG_TO_BASE_2_OF_10) + 1);
else|#
directive|else
name|more_than_enough_bits_for_digits
operator|=
operator|(
name|number_of_digits_to_use
operator|*
literal|3321928
operator|/
literal|1000000
operator|+
literal|1
operator|)
expr_stmt|;
endif|#
directive|endif
name|more_than_enough_littlenums_for_digits
operator|=
operator|(
name|more_than_enough_bits_for_digits
operator|/
name|LITTLENUM_NUMBER_OF_BITS
operator|)
operator|+
literal|2
expr_stmt|;
comment|/* Compute (digits) part. In "12.34E56" this is the "1234" part. 	 Arithmetic is exact here. If no digits are supplied then this 	 part is a 0 valued binary integer.  Allocate room to build up 	 the binary number as littlenums.  We want this memory to 	 disappear when we leave this function.  Assume no alignment 	 problems => (room for n objects) == n * (room for 1 	 object).  */
name|size_of_digits_in_littlenums
operator|=
name|more_than_enough_littlenums_for_digits
expr_stmt|;
name|size_of_digits_in_chars
operator|=
name|size_of_digits_in_littlenums
operator|*
sizeof|sizeof
argument_list|(
name|LITTLENUM_TYPE
argument_list|)
expr_stmt|;
name|digits_binary_low
operator|=
operator|(
name|LITTLENUM_TYPE
operator|*
operator|)
name|alloca
argument_list|(
name|size_of_digits_in_chars
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|digits_binary_low
argument_list|,
literal|'\0'
argument_list|,
name|size_of_digits_in_chars
argument_list|)
expr_stmt|;
comment|/* Digits_binary_low[] is allocated and zeroed. */
comment|/*        * Parse the decimal digits as if * digits_low was in the units position.        * Emit a binary number into digits_binary_low[].        *        * Use a large-precision version of:        * (((1st-digit) * 10 + 2nd-digit) * 10 + 3rd-digit ...) * 10 + last-digit        */
for|for
control|(
name|p
operator|=
name|first_digit
operator|,
name|count
operator|=
name|number_of_digits_to_use
init|;
name|count
condition|;
name|p
operator|++
operator|,
operator|--
name|count
control|)
block|{
name|c
operator|=
operator|*
name|p
expr_stmt|;
if|if
condition|(
name|isdigit
argument_list|(
name|c
argument_list|)
condition|)
block|{
comment|/* 	       * Multiply by 10. Assume can never overflow. 	       * Add this digit to digits_binary_low[]. 	       */
name|long
name|carry
decl_stmt|;
name|LITTLENUM_TYPE
modifier|*
name|littlenum_pointer
decl_stmt|;
name|LITTLENUM_TYPE
modifier|*
name|littlenum_limit
decl_stmt|;
name|littlenum_limit
operator|=
name|digits_binary_low
operator|+
name|more_than_enough_littlenums_for_digits
operator|-
literal|1
expr_stmt|;
name|carry
operator|=
name|c
operator|-
literal|'0'
expr_stmt|;
comment|/* char -> binary */
for|for
control|(
name|littlenum_pointer
operator|=
name|digits_binary_low
init|;
name|littlenum_pointer
operator|<=
name|littlenum_limit
condition|;
name|littlenum_pointer
operator|++
control|)
block|{
name|long
name|work
decl_stmt|;
name|work
operator|=
name|carry
operator|+
literal|10
operator|*
call|(
name|long
call|)
argument_list|(
operator|*
name|littlenum_pointer
argument_list|)
expr_stmt|;
operator|*
name|littlenum_pointer
operator|=
name|work
operator|&
name|LITTLENUM_MASK
expr_stmt|;
name|carry
operator|=
name|work
operator|>>
name|LITTLENUM_NUMBER_OF_BITS
expr_stmt|;
block|}
if|if
condition|(
name|carry
operator|!=
literal|0
condition|)
block|{
comment|/* 		   * We have a GROSS internal error. 		   * This should never happen. 		   */
name|as_fatal
argument_list|(
literal|"failed sanity check."
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
operator|++
name|count
expr_stmt|;
comment|/* '.' doesn't alter digits used count. */
block|}
block|}
comment|/*        * Digits_binary_low[] properly encodes the value of the digits.        * Forget about any high-order littlenums that are 0.        */
while|while
condition|(
name|digits_binary_low
index|[
name|size_of_digits_in_littlenums
operator|-
literal|1
index|]
operator|==
literal|0
operator|&&
name|size_of_digits_in_littlenums
operator|>=
literal|2
condition|)
name|size_of_digits_in_littlenums
operator|--
expr_stmt|;
name|digits_flonum
operator|.
name|low
operator|=
name|digits_binary_low
expr_stmt|;
name|digits_flonum
operator|.
name|high
operator|=
name|digits_binary_low
operator|+
name|size_of_digits_in_littlenums
operator|-
literal|1
expr_stmt|;
name|digits_flonum
operator|.
name|leader
operator|=
name|digits_flonum
operator|.
name|high
expr_stmt|;
name|digits_flonum
operator|.
name|exponent
operator|=
literal|0
expr_stmt|;
comment|/*        * The value of digits_flonum . sign should not be important.        * We have already decided the output's sign.        * We trust that the sign won't influence the other parts of the number!        * So we give it a value for these reasons:        * (1) courtesy to humans reading/debugging        *     these numbers so they don't get excited about strange values        * (2) in future there may be more meaning attached to sign,        *     and what was        *     harmless noise may become disruptive, ill-conditioned (or worse)        *     input.        */
name|digits_flonum
operator|.
name|sign
operator|=
literal|'+'
expr_stmt|;
block|{
comment|/* 	 * Compute the mantssa (& exponent) of the power of 10. 	 * If sucessful, then multiply the power of 10 by the digits 	 * giving return_binary_mantissa and return_binary_exponent. 	 */
name|LITTLENUM_TYPE
modifier|*
name|power_binary_low
decl_stmt|;
name|int
name|decimal_exponent_is_negative
decl_stmt|;
comment|/* This refers to the "-56" in "12.34E-56". */
comment|/* FALSE: decimal_exponent is positive (or 0) */
comment|/* TRUE:  decimal_exponent is negative */
name|FLONUM_TYPE
name|temporary_flonum
decl_stmt|;
name|LITTLENUM_TYPE
modifier|*
name|temporary_binary_low
decl_stmt|;
name|unsigned
name|int
name|size_of_power_in_littlenums
decl_stmt|;
name|unsigned
name|int
name|size_of_power_in_chars
decl_stmt|;
name|size_of_power_in_littlenums
operator|=
name|precision
expr_stmt|;
comment|/* Precision has a built-in fudge factor so we get a few guard bits. */
name|decimal_exponent_is_negative
operator|=
name|decimal_exponent
operator|<
literal|0
expr_stmt|;
if|if
condition|(
name|decimal_exponent_is_negative
condition|)
block|{
name|decimal_exponent
operator|=
operator|-
name|decimal_exponent
expr_stmt|;
block|}
comment|/* From now on: the decimal exponent is> 0. Its sign is separate. */
name|size_of_power_in_chars
operator|=
name|size_of_power_in_littlenums
operator|*
sizeof|sizeof
argument_list|(
name|LITTLENUM_TYPE
argument_list|)
operator|+
literal|2
expr_stmt|;
name|power_binary_low
operator|=
operator|(
name|LITTLENUM_TYPE
operator|*
operator|)
name|alloca
argument_list|(
name|size_of_power_in_chars
argument_list|)
expr_stmt|;
name|temporary_binary_low
operator|=
operator|(
name|LITTLENUM_TYPE
operator|*
operator|)
name|alloca
argument_list|(
name|size_of_power_in_chars
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|power_binary_low
argument_list|,
literal|'\0'
argument_list|,
name|size_of_power_in_chars
argument_list|)
expr_stmt|;
operator|*
name|power_binary_low
operator|=
literal|1
expr_stmt|;
name|power_of_10_flonum
operator|.
name|exponent
operator|=
literal|0
expr_stmt|;
name|power_of_10_flonum
operator|.
name|low
operator|=
name|power_binary_low
expr_stmt|;
name|power_of_10_flonum
operator|.
name|leader
operator|=
name|power_binary_low
expr_stmt|;
name|power_of_10_flonum
operator|.
name|high
operator|=
name|power_binary_low
operator|+
name|size_of_power_in_littlenums
operator|-
literal|1
expr_stmt|;
name|power_of_10_flonum
operator|.
name|sign
operator|=
literal|'+'
expr_stmt|;
name|temporary_flonum
operator|.
name|low
operator|=
name|temporary_binary_low
expr_stmt|;
name|temporary_flonum
operator|.
name|high
operator|=
name|temporary_binary_low
operator|+
name|size_of_power_in_littlenums
operator|-
literal|1
expr_stmt|;
comment|/* 	 * (power) == 1. 	 * Space for temporary_flonum allocated. 	 */
comment|/* 	 * ... 	 * 	 * WHILE	more bits 	 * DO	find next bit (with place value) 	 *	multiply into power mantissa 	 * OD 	 */
block|{
name|int
name|place_number_limit
decl_stmt|;
comment|/* Any 10^(2^n) whose "n" exceeds this */
comment|/* value will fall off the end of */
comment|/* flonum_XXXX_powers_of_ten[]. */
name|int
name|place_number
decl_stmt|;
specifier|const
name|FLONUM_TYPE
modifier|*
name|multiplicand
decl_stmt|;
comment|/* -> 10^(2^n) */
name|place_number_limit
operator|=
name|table_size_of_flonum_powers_of_ten
expr_stmt|;
name|multiplicand
operator|=
operator|(
name|decimal_exponent_is_negative
condition|?
name|flonum_negative_powers_of_ten
else|:
name|flonum_positive_powers_of_ten
operator|)
expr_stmt|;
for|for
control|(
name|place_number
operator|=
literal|1
init|;
comment|/* Place value of this bit of exponent. */
name|decimal_exponent
condition|;
comment|/* Quit when no more 1 bits in exponent. */
name|decimal_exponent
operator|>>=
literal|1
operator|,
name|place_number
operator|++
control|)
block|{
if|if
condition|(
name|decimal_exponent
operator|&
literal|1
condition|)
block|{
if|if
condition|(
name|place_number
operator|>
name|place_number_limit
condition|)
block|{
comment|/* The decimal exponent has a magnitude so great 			 that our tables can't help us fragment it. 			 Although this routine is in error because it 			 can't imagine a number that big, signal an 			 error as if it is the user's fault for 			 presenting such a big number.  */
name|return_value
operator|=
name|ERROR_EXPONENT_OVERFLOW
expr_stmt|;
comment|/* quit out of loop gracefully */
name|decimal_exponent
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|TRACE
name|printf
argument_list|(
literal|"before multiply, place_number = %d., power_of_10_flonum:\n"
argument_list|,
name|place_number
argument_list|)
expr_stmt|;
name|flonum_print
argument_list|(
operator|&
name|power_of_10_flonum
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TRACE
name|printf
argument_list|(
literal|"multiplier:\n"
argument_list|)
expr_stmt|;
name|flonum_print
argument_list|(
name|multiplicand
operator|+
name|place_number
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|flonum_multip
argument_list|(
name|multiplicand
operator|+
name|place_number
argument_list|,
operator|&
name|power_of_10_flonum
argument_list|,
operator|&
name|temporary_flonum
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TRACE
name|printf
argument_list|(
literal|"after multiply:\n"
argument_list|)
expr_stmt|;
name|flonum_print
argument_list|(
operator|&
name|temporary_flonum
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|flonum_copy
argument_list|(
operator|&
name|temporary_flonum
argument_list|,
operator|&
name|power_of_10_flonum
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TRACE
name|printf
argument_list|(
literal|"after copy:\n"
argument_list|)
expr_stmt|;
name|flonum_print
argument_list|(
operator|&
name|power_of_10_flonum
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* If this bit of decimal_exponent was computable.*/
block|}
comment|/* If this bit of decimal_exponent was set. */
block|}
comment|/* For each bit of binary representation of exponent */
ifdef|#
directive|ifdef
name|TRACE
name|printf
argument_list|(
literal|"after computing power_of_10_flonum:\n"
argument_list|)
expr_stmt|;
name|flonum_print
argument_list|(
operator|&
name|power_of_10_flonum
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
comment|/*        * power_of_10_flonum is power of ten in binary (mantissa) , (exponent).        * It may be the number 1, in which case we don't NEED to multiply.        *        * Multiply (decimal digits) by power_of_10_flonum.        */
name|flonum_multip
argument_list|(
operator|&
name|power_of_10_flonum
argument_list|,
operator|&
name|digits_flonum
argument_list|,
name|address_of_generic_floating_point_number
argument_list|)
expr_stmt|;
comment|/* Assert sign of the number we made is '+'. */
name|address_of_generic_floating_point_number
operator|->
name|sign
operator|=
name|digits_sign_char
expr_stmt|;
block|}
return|return
name|return_value
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|TRACE
end_ifdef

begin_function
specifier|static
name|void
name|flonum_print
parameter_list|(
name|f
parameter_list|)
specifier|const
name|FLONUM_TYPE
modifier|*
name|f
decl_stmt|;
block|{
name|LITTLENUM_TYPE
modifier|*
name|lp
decl_stmt|;
name|char
name|littlenum_format
index|[
literal|10
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|littlenum_format
argument_list|,
literal|" %%0%dx"
argument_list|,
sizeof|sizeof
argument_list|(
name|LITTLENUM_TYPE
argument_list|)
operator|*
literal|2
argument_list|)
expr_stmt|;
define|#
directive|define
name|print_littlenum
parameter_list|(
name|LP
parameter_list|)
value|(printf (littlenum_format, LP))
name|printf
argument_list|(
literal|"flonum @%p %c e%ld"
argument_list|,
name|f
argument_list|,
name|f
operator|->
name|sign
argument_list|,
name|f
operator|->
name|exponent
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|->
name|low
operator|<
name|f
operator|->
name|high
condition|)
for|for
control|(
name|lp
operator|=
name|f
operator|->
name|high
init|;
name|lp
operator|>=
name|f
operator|->
name|low
condition|;
name|lp
operator|--
control|)
name|print_littlenum
argument_list|(
operator|*
name|lp
argument_list|)
expr_stmt|;
else|else
for|for
control|(
name|lp
operator|=
name|f
operator|->
name|low
init|;
name|lp
operator|<=
name|f
operator|->
name|high
condition|;
name|lp
operator|++
control|)
name|print_littlenum
argument_list|(
operator|*
name|lp
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* end of atof_generic.c */
end_comment

end_unit

