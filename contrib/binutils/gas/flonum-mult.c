begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* flonum_mult.c - multiply two flonums    Copyright 1987, 1990, 1991, 1992, 1995, 2000    Free Software Foundation, Inc.     This file is part of Gas, the GNU Assembler.     The GNU assembler is distributed in the hope that it will be    useful, but WITHOUT ANY WARRANTY.  No author or distributor    accepts responsibility to anyone for the consequences of using it    or for whether it serves any particular purpose or works at all,    unless he says so in writing.  Refer to the GNU Assembler General    Public License for full details.     Everyone is granted permission to copy, modify and redistribute    the GNU Assembler, but only under the conditions described in the    GNU Assembler General Public License.  A copy of this license is    supposed to have been given to you along with the GNU Assembler    so you can know your rights and responsibilities.  It should be    in a file named COPYING.  Among other things, the copyright    notice and this notice must be preserved on all copies.  */
end_comment

begin_include
include|#
directive|include
file|<ansidecl.h>
end_include

begin_include
include|#
directive|include
file|"flonum.h"
end_include

begin_comment
comment|/*	plan for a . b => p(roduct)  	+-------+-------+-/   /-+-------+-------+ 	| a	| a	|  ...	| a	| a	| 	|  A	|  A-1	|	|  1	|  0	| 	+-------+-------+-/   /-+-------+-------+  	+-------+-------+-/   /-+-------+-------+ 	| b	| b	|  ...	| b	| b	| 	|  B	|  B-1	|	|  1	|  0	| 	+-------+-------+-/   /-+-------+-------+  	+-------+-------+-/   /-+-------+-/   /-+-------+-------+ 	| p	| p	|  ...	| p	|  ...	| p	| p	| 	|  A+B+1|  A+B	|	|  N	|	|  1	|  0	| 	+-------+-------+-/   /-+-------+-/   /-+-------+-------+  	/^\ 	(carry) a .b	   ...	    |	   ...	 a .b	 a .b 	A  B 		    |		  0  1	  0  0 	| 	...	    |	   ...	 a .b 	|		  1  0 	| 	|	   ... 	| 	| 	| 	|		  ___ 	|		  \ 	+-----  P  =>  a .b 	N	  /__  i  j  	N = 0 ... A+B  	for all i,j where i+j=N 	[i,j integers> 0]  	a[], b[], p[] may not intersect. 	Zero length factors signify 0 significant bits: treat as 0.0. 	0.0 factors do the right thing. 	Zero length product OK.  	I chose the ForTran accent "foo[bar]" instead of the C accent "*garply" 	because I felt the ForTran way was more intuitive. The C way would 	probably yield better code on most C compilers. Dean Elsner. 	(C style also gives deeper insight [to me] ... oh well ...)  */
end_comment

begin_escape
end_escape

begin_function
name|void
name|flonum_multip
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|product
parameter_list|)
specifier|const
name|FLONUM_TYPE
modifier|*
name|a
decl_stmt|;
specifier|const
name|FLONUM_TYPE
modifier|*
name|b
decl_stmt|;
name|FLONUM_TYPE
modifier|*
name|product
decl_stmt|;
block|{
name|int
name|size_of_a
decl_stmt|;
comment|/* 0 origin  */
name|int
name|size_of_b
decl_stmt|;
comment|/* 0 origin  */
name|int
name|size_of_product
decl_stmt|;
comment|/* 0 origin  */
name|int
name|size_of_sum
decl_stmt|;
comment|/* 0 origin  */
name|int
name|extra_product_positions
decl_stmt|;
comment|/* 1 origin  */
name|unsigned
name|long
name|work
decl_stmt|;
name|unsigned
name|long
name|carry
decl_stmt|;
name|long
name|exponent
decl_stmt|;
name|LITTLENUM_TYPE
modifier|*
name|q
decl_stmt|;
name|long
name|significant
decl_stmt|;
comment|/* TRUE when we emit a non-0 littlenum  */
comment|/* ForTran accent follows.  */
name|int
name|P
decl_stmt|;
comment|/* Scan product low-order -> high.  */
name|int
name|N
decl_stmt|;
comment|/* As in sum above.  */
name|int
name|A
decl_stmt|;
comment|/* Which [] of a?  */
name|int
name|B
decl_stmt|;
comment|/* Which [] of b?  */
if|if
condition|(
operator|(
name|a
operator|->
name|sign
operator|!=
literal|'-'
operator|&&
name|a
operator|->
name|sign
operator|!=
literal|'+'
operator|)
operator|||
operator|(
name|b
operator|->
name|sign
operator|!=
literal|'-'
operator|&&
name|b
operator|->
name|sign
operator|!=
literal|'+'
operator|)
condition|)
block|{
comment|/* Got to fail somehow.  Any suggestions?  */
name|product
operator|->
name|sign
operator|=
literal|0
expr_stmt|;
return|return;
block|}
name|product
operator|->
name|sign
operator|=
operator|(
name|a
operator|->
name|sign
operator|==
name|b
operator|->
name|sign
operator|)
condition|?
literal|'+'
else|:
literal|'-'
expr_stmt|;
name|size_of_a
operator|=
name|a
operator|->
name|leader
operator|-
name|a
operator|->
name|low
expr_stmt|;
name|size_of_b
operator|=
name|b
operator|->
name|leader
operator|-
name|b
operator|->
name|low
expr_stmt|;
name|exponent
operator|=
name|a
operator|->
name|exponent
operator|+
name|b
operator|->
name|exponent
expr_stmt|;
name|size_of_product
operator|=
name|product
operator|->
name|high
operator|-
name|product
operator|->
name|low
expr_stmt|;
name|size_of_sum
operator|=
name|size_of_a
operator|+
name|size_of_b
expr_stmt|;
name|extra_product_positions
operator|=
name|size_of_product
operator|-
name|size_of_sum
expr_stmt|;
if|if
condition|(
name|extra_product_positions
operator|<
literal|0
condition|)
block|{
name|P
operator|=
name|extra_product_positions
expr_stmt|;
comment|/* P< 0  */
name|exponent
operator|-=
name|extra_product_positions
expr_stmt|;
comment|/* Increases exponent.  */
block|}
else|else
block|{
name|P
operator|=
literal|0
expr_stmt|;
block|}
name|carry
operator|=
literal|0
expr_stmt|;
name|significant
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|N
operator|=
literal|0
init|;
name|N
operator|<=
name|size_of_sum
condition|;
name|N
operator|++
control|)
block|{
name|work
operator|=
name|carry
expr_stmt|;
name|carry
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|A
operator|=
literal|0
init|;
name|A
operator|<=
name|N
condition|;
name|A
operator|++
control|)
block|{
name|B
operator|=
name|N
operator|-
name|A
expr_stmt|;
if|if
condition|(
name|A
operator|<=
name|size_of_a
operator|&&
name|B
operator|<=
name|size_of_b
operator|&&
name|B
operator|>=
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|TRACE
name|printf
argument_list|(
literal|"a:low[%d.]=%04x b:low[%d.]=%04x work_before=%08x\n"
argument_list|,
name|A
argument_list|,
name|a
operator|->
name|low
index|[
name|A
index|]
argument_list|,
name|B
argument_list|,
name|b
operator|->
name|low
index|[
name|B
index|]
argument_list|,
name|work
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Watch out for sign extension!  Without the casts, on 		 the DEC Alpha, the multiplication result is *signed* 		 int, which gets sign-extended to convert to the 		 unsigned long!  */
name|work
operator|+=
operator|(
name|unsigned
name|long
operator|)
name|a
operator|->
name|low
index|[
name|A
index|]
operator|*
operator|(
name|unsigned
name|long
operator|)
name|b
operator|->
name|low
index|[
name|B
index|]
expr_stmt|;
name|carry
operator|+=
name|work
operator|>>
name|LITTLENUM_NUMBER_OF_BITS
expr_stmt|;
name|work
operator|&=
name|LITTLENUM_MASK
expr_stmt|;
ifdef|#
directive|ifdef
name|TRACE
name|printf
argument_list|(
literal|"work=%08x carry=%04x\n"
argument_list|,
name|work
argument_list|,
name|carry
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
name|significant
operator||=
name|work
expr_stmt|;
if|if
condition|(
name|significant
operator|||
name|P
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|P
operator|>=
literal|0
condition|)
block|{
name|product
operator|->
name|low
index|[
name|P
index|]
operator|=
name|work
expr_stmt|;
ifdef|#
directive|ifdef
name|TRACE
name|printf
argument_list|(
literal|"P=%d. work[p]:=%04x\n"
argument_list|,
name|P
argument_list|,
name|work
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|P
operator|++
expr_stmt|;
block|}
else|else
block|{
name|extra_product_positions
operator|++
expr_stmt|;
name|exponent
operator|++
expr_stmt|;
block|}
block|}
comment|/* [P]-> position # size_of_sum + 1.      This is where 'carry' should go.  */
ifdef|#
directive|ifdef
name|TRACE
name|printf
argument_list|(
literal|"final carry =%04x\n"
argument_list|,
name|carry
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|carry
condition|)
block|{
if|if
condition|(
name|extra_product_positions
operator|>
literal|0
condition|)
name|product
operator|->
name|low
index|[
name|P
index|]
operator|=
name|carry
expr_stmt|;
else|else
block|{
comment|/* No room at high order for carry littlenum.  */
comment|/* Shift right 1 to make room for most significant littlenum.  */
name|exponent
operator|++
expr_stmt|;
name|P
operator|--
expr_stmt|;
for|for
control|(
name|q
operator|=
name|product
operator|->
name|low
operator|+
name|P
init|;
name|q
operator|>=
name|product
operator|->
name|low
condition|;
name|q
operator|--
control|)
block|{
name|work
operator|=
operator|*
name|q
expr_stmt|;
operator|*
name|q
operator|=
name|carry
expr_stmt|;
name|carry
operator|=
name|work
expr_stmt|;
block|}
block|}
block|}
else|else
name|P
operator|--
expr_stmt|;
name|product
operator|->
name|leader
operator|=
name|product
operator|->
name|low
operator|+
name|P
expr_stmt|;
name|product
operator|->
name|exponent
operator|=
name|exponent
expr_stmt|;
block|}
end_function

end_unit

