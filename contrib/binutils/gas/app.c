begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* This is the Assembler Pre-Processor    Copyright (C) 1987, 90, 91, 92, 93, 94, 95, 96, 1997    Free Software Foundation, Inc.     This file is part of GAS, the GNU Assembler.     GAS is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     GAS is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with GAS; see the file COPYING.  If not, write to the Free    Software Foundation, 59 Temple Place - Suite 330, Boston, MA    02111-1307, USA.  */
end_comment

begin_comment
comment|/* Modified by Allen Wirfs-Brock, Instantiations Inc 2/90 */
end_comment

begin_comment
comment|/* App, the assembler pre-processor.  This pre-processor strips out excess    spaces, turns single-quoted characters into a decimal constant, and turns    #<number><filename><garbage> into a .line<number>\n.file<filename>    pair.  This needs better error-handling.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"as.h"
end_include

begin_comment
comment|/* For BAD_CASE() only */
end_comment

begin_if
if|#
directive|if
operator|(
name|__STDC__
operator|!=
literal|1
operator|)
end_if

begin_ifndef
ifndef|#
directive|ifndef
name|const
end_ifndef

begin_define
define|#
directive|define
name|const
end_define

begin_comment
comment|/* empty */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Whether we are scrubbing in m68k MRI mode.  This is different from    flag_m68k_mri, because the two flags will be affected by the .mri    pseudo-op at different times.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|scrub_m68k_mri
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The pseudo-op which switches in and out of MRI mode.  See the    comment in do_scrub_chars.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
name|mri_pseudo
index|[]
init|=
literal|".mri 0"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|lex
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
name|symbol_chars
index|[]
init|=
literal|"$._ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789"
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|LEX_IS_SYMBOL_COMPONENT
value|1
end_define

begin_define
define|#
directive|define
name|LEX_IS_WHITESPACE
value|2
end_define

begin_define
define|#
directive|define
name|LEX_IS_LINE_SEPARATOR
value|3
end_define

begin_define
define|#
directive|define
name|LEX_IS_COMMENT_START
value|4
end_define

begin_define
define|#
directive|define
name|LEX_IS_LINE_COMMENT_START
value|5
end_define

begin_define
define|#
directive|define
name|LEX_IS_TWOCHAR_COMMENT_1ST
value|6
end_define

begin_define
define|#
directive|define
name|LEX_IS_STRINGQUOTE
value|8
end_define

begin_define
define|#
directive|define
name|LEX_IS_COLON
value|9
end_define

begin_define
define|#
directive|define
name|LEX_IS_NEWLINE
value|10
end_define

begin_define
define|#
directive|define
name|LEX_IS_ONECHAR_QUOTE
value|11
end_define

begin_define
define|#
directive|define
name|IS_SYMBOL_COMPONENT
parameter_list|(
name|c
parameter_list|)
value|(lex[c] == LEX_IS_SYMBOL_COMPONENT)
end_define

begin_define
define|#
directive|define
name|IS_WHITESPACE
parameter_list|(
name|c
parameter_list|)
value|(lex[c] == LEX_IS_WHITESPACE)
end_define

begin_define
define|#
directive|define
name|IS_LINE_SEPARATOR
parameter_list|(
name|c
parameter_list|)
value|(lex[c] == LEX_IS_LINE_SEPARATOR)
end_define

begin_define
define|#
directive|define
name|IS_COMMENT
parameter_list|(
name|c
parameter_list|)
value|(lex[c] == LEX_IS_COMMENT_START)
end_define

begin_define
define|#
directive|define
name|IS_LINE_COMMENT
parameter_list|(
name|c
parameter_list|)
value|(lex[c] == LEX_IS_LINE_COMMENT_START)
end_define

begin_define
define|#
directive|define
name|IS_NEWLINE
parameter_list|(
name|c
parameter_list|)
value|(lex[c] == LEX_IS_NEWLINE)
end_define

begin_decl_stmt
specifier|static
name|int
name|process_escape
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* FIXME-soon: The entire lexer/parser thingy should be    built statically at compile time rather than dynamically    each and every time the assembler is run.  xoxorich. */
end_comment

begin_function
name|void
name|do_scrub_begin
parameter_list|(
name|m68k_mri
parameter_list|)
name|int
name|m68k_mri
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|scrub_m68k_mri
operator|=
name|m68k_mri
expr_stmt|;
name|lex
index|[
literal|' '
index|]
operator|=
name|LEX_IS_WHITESPACE
expr_stmt|;
name|lex
index|[
literal|'\t'
index|]
operator|=
name|LEX_IS_WHITESPACE
expr_stmt|;
name|lex
index|[
literal|'\n'
index|]
operator|=
name|LEX_IS_NEWLINE
expr_stmt|;
name|lex
index|[
literal|';'
index|]
operator|=
name|LEX_IS_LINE_SEPARATOR
expr_stmt|;
name|lex
index|[
literal|':'
index|]
operator|=
name|LEX_IS_COLON
expr_stmt|;
if|if
condition|(
operator|!
name|m68k_mri
condition|)
block|{
name|lex
index|[
literal|'"'
index|]
operator|=
name|LEX_IS_STRINGQUOTE
expr_stmt|;
ifndef|#
directive|ifndef
name|TC_HPPA
name|lex
index|[
literal|'\''
index|]
operator|=
name|LEX_IS_ONECHAR_QUOTE
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SINGLE_QUOTE_STRINGS
name|lex
index|[
literal|'\''
index|]
operator|=
name|LEX_IS_STRINGQUOTE
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* Note: if any other character can be LEX_IS_STRINGQUOTE, the loop      in state 5 of do_scrub_chars must be changed.  */
comment|/* Note that these override the previous defaults, e.g. if ';' is a      comment char, then it isn't a line separator.  */
for|for
control|(
name|p
operator|=
name|symbol_chars
init|;
operator|*
name|p
condition|;
operator|++
name|p
control|)
block|{
name|lex
index|[
operator|(
name|unsigned
name|char
operator|)
operator|*
name|p
index|]
operator|=
name|LEX_IS_SYMBOL_COMPONENT
expr_stmt|;
block|}
comment|/* declare symbol characters */
comment|/* The m68k backend wants to be able to change comment_chars.  */
ifndef|#
directive|ifndef
name|tc_comment_chars
define|#
directive|define
name|tc_comment_chars
value|comment_chars
endif|#
directive|endif
for|for
control|(
name|p
operator|=
name|tc_comment_chars
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
block|{
name|lex
index|[
operator|(
name|unsigned
name|char
operator|)
operator|*
name|p
index|]
operator|=
name|LEX_IS_COMMENT_START
expr_stmt|;
block|}
comment|/* declare comment chars */
for|for
control|(
name|p
operator|=
name|line_comment_chars
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
block|{
name|lex
index|[
operator|(
name|unsigned
name|char
operator|)
operator|*
name|p
index|]
operator|=
name|LEX_IS_LINE_COMMENT_START
expr_stmt|;
block|}
comment|/* declare line comment chars */
for|for
control|(
name|p
operator|=
name|line_separator_chars
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
block|{
name|lex
index|[
operator|(
name|unsigned
name|char
operator|)
operator|*
name|p
index|]
operator|=
name|LEX_IS_LINE_SEPARATOR
expr_stmt|;
block|}
comment|/* declare line separators */
comment|/* Only allow slash-star comments if slash is not in use.      FIXME: This isn't right.  We should always permit them.  */
if|if
condition|(
name|lex
index|[
literal|'/'
index|]
operator|==
literal|0
condition|)
block|{
name|lex
index|[
literal|'/'
index|]
operator|=
name|LEX_IS_TWOCHAR_COMMENT_1ST
expr_stmt|;
block|}
if|if
condition|(
name|m68k_mri
condition|)
block|{
name|lex
index|[
literal|'\''
index|]
operator|=
name|LEX_IS_STRINGQUOTE
expr_stmt|;
name|lex
index|[
literal|';'
index|]
operator|=
name|LEX_IS_COMMENT_START
expr_stmt|;
name|lex
index|[
literal|'*'
index|]
operator|=
name|LEX_IS_LINE_COMMENT_START
expr_stmt|;
comment|/* The MRI documentation says '!' is LEX_IS_COMMENT_START, but          then it can't be used in an expression.  */
name|lex
index|[
literal|'!'
index|]
operator|=
name|LEX_IS_LINE_COMMENT_START
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* do_scrub_begin() */
end_comment

begin_comment
comment|/* Saved state of the scrubber */
end_comment

begin_decl_stmt
specifier|static
name|int
name|state
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|old_state
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|out_string
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|out_buf
index|[
literal|20
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|add_newlines
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|saved_input
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|saved_input_len
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|mri_state
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|mri_last_ch
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Data structure for saving the state of app across #include's.  Note that    app is called asynchronously to the parsing of the .include's, so our    state at the time .include is interpreted is completely unrelated.    That's why we have to save it all.  */
end_comment

begin_struct
struct|struct
name|app_save
block|{
name|int
name|state
decl_stmt|;
name|int
name|old_state
decl_stmt|;
name|char
modifier|*
name|out_string
decl_stmt|;
name|char
name|out_buf
index|[
sizeof|sizeof
argument_list|(
name|out_buf
argument_list|)
index|]
decl_stmt|;
name|int
name|add_newlines
decl_stmt|;
name|char
modifier|*
name|saved_input
decl_stmt|;
name|int
name|saved_input_len
decl_stmt|;
name|int
name|scrub_m68k_mri
decl_stmt|;
specifier|const
name|char
modifier|*
name|mri_state
decl_stmt|;
name|char
name|mri_last_ch
decl_stmt|;
block|}
struct|;
end_struct

begin_function
name|char
modifier|*
name|app_push
parameter_list|()
block|{
specifier|register
name|struct
name|app_save
modifier|*
name|saved
decl_stmt|;
name|saved
operator|=
operator|(
expr|struct
name|app_save
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|saved
argument_list|)
argument_list|)
expr_stmt|;
name|saved
operator|->
name|state
operator|=
name|state
expr_stmt|;
name|saved
operator|->
name|old_state
operator|=
name|old_state
expr_stmt|;
name|saved
operator|->
name|out_string
operator|=
name|out_string
expr_stmt|;
name|memcpy
argument_list|(
name|saved
operator|->
name|out_buf
argument_list|,
name|out_buf
argument_list|,
sizeof|sizeof
argument_list|(
name|out_buf
argument_list|)
argument_list|)
expr_stmt|;
name|saved
operator|->
name|add_newlines
operator|=
name|add_newlines
expr_stmt|;
name|saved
operator|->
name|saved_input
operator|=
name|saved_input
expr_stmt|;
name|saved
operator|->
name|saved_input_len
operator|=
name|saved_input_len
expr_stmt|;
name|saved
operator|->
name|scrub_m68k_mri
operator|=
name|scrub_m68k_mri
expr_stmt|;
name|saved
operator|->
name|mri_state
operator|=
name|mri_state
expr_stmt|;
name|saved
operator|->
name|mri_last_ch
operator|=
name|mri_last_ch
expr_stmt|;
comment|/* do_scrub_begin() is not useful, just wastes time. */
name|state
operator|=
literal|0
expr_stmt|;
name|saved_input
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|char
operator|*
operator|)
name|saved
return|;
block|}
end_function

begin_function
name|void
name|app_pop
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
specifier|register
name|struct
name|app_save
modifier|*
name|saved
init|=
operator|(
expr|struct
name|app_save
operator|*
operator|)
name|arg
decl_stmt|;
comment|/* There is no do_scrub_end (). */
name|state
operator|=
name|saved
operator|->
name|state
expr_stmt|;
name|old_state
operator|=
name|saved
operator|->
name|old_state
expr_stmt|;
name|out_string
operator|=
name|saved
operator|->
name|out_string
expr_stmt|;
name|memcpy
argument_list|(
name|out_buf
argument_list|,
name|saved
operator|->
name|out_buf
argument_list|,
sizeof|sizeof
argument_list|(
name|out_buf
argument_list|)
argument_list|)
expr_stmt|;
name|add_newlines
operator|=
name|saved
operator|->
name|add_newlines
expr_stmt|;
name|saved_input
operator|=
name|saved
operator|->
name|saved_input
expr_stmt|;
name|saved_input_len
operator|=
name|saved
operator|->
name|saved_input_len
expr_stmt|;
name|scrub_m68k_mri
operator|=
name|saved
operator|->
name|scrub_m68k_mri
expr_stmt|;
name|mri_state
operator|=
name|saved
operator|->
name|mri_state
expr_stmt|;
name|mri_last_ch
operator|=
name|saved
operator|->
name|mri_last_ch
expr_stmt|;
name|free
argument_list|(
name|arg
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* app_pop() */
end_comment

begin_comment
comment|/* @@ This assumes that \n&c are the same on host and target.  This is not    necessarily true.  */
end_comment

begin_function
specifier|static
name|int
name|process_escape
parameter_list|(
name|ch
parameter_list|)
name|int
name|ch
decl_stmt|;
block|{
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'b'
case|:
return|return
literal|'\b'
return|;
case|case
literal|'f'
case|:
return|return
literal|'\f'
return|;
case|case
literal|'n'
case|:
return|return
literal|'\n'
return|;
case|case
literal|'r'
case|:
return|return
literal|'\r'
return|;
case|case
literal|'t'
case|:
return|return
literal|'\t'
return|;
case|case
literal|'\''
case|:
return|return
literal|'\''
return|;
case|case
literal|'"'
case|:
return|return
literal|'\"'
return|;
default|default:
return|return
name|ch
return|;
block|}
block|}
end_function

begin_comment
comment|/* This function is called to process input characters.  The GET    parameter is used to retrieve more input characters.  GET should    set its parameter to point to a buffer, and return the length of    the buffer; it should return 0 at end of file.  The scrubbed output    characters are put into the buffer starting at TOSTART; the TOSTART    buffer is TOLEN bytes in length.  The function returns the number    of scrubbed characters put into TOSTART.  This will be TOLEN unless    end of file was seen.  This function is arranged as a state    machine, and saves its state so that it may return at any point.    This is the way the old code used to work.  */
end_comment

begin_function_decl
name|int
name|do_scrub_chars
parameter_list|(
name|get
parameter_list|,
name|tostart
parameter_list|,
name|tolen
parameter_list|)
function_decl|int
parameter_list|(
function_decl|*get
end_function_decl

begin_expr_stmt
unit|)
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|char
modifier|*
name|tostart
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|tolen
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|to
init|=
name|tostart
decl_stmt|;
name|char
modifier|*
name|toend
init|=
name|tostart
operator|+
name|tolen
decl_stmt|;
name|char
modifier|*
name|from
decl_stmt|;
name|char
modifier|*
name|fromend
decl_stmt|;
name|int
name|fromlen
decl_stmt|;
specifier|register
name|int
name|ch
decl_stmt|,
name|ch2
init|=
literal|0
decl_stmt|;
comment|/*State 0: beginning of normal line 	  1: After first whitespace on line (flush more white) 	  2: After first non-white (opcode) on line (keep 1white) 	  3: after second white on line (into operands) (flush white) 	  4: after putting out a .line, put out digits 	  5: parsing a string, then go to old-state 	  6: putting out \ escape in a "d string. 	  7: After putting out a .appfile, put out string. 	  8: After putting out a .appfile string, flush until newline. 	  9: After seeing symbol char in state 3 (keep 1white after symchar) 	 10: After seeing whitespace in state 9 (keep white before symchar) 	 11: After seeing a symbol character in state 0 (eg a label definition) 	 -1: output string in out_string and go to the state in old_state 	 -2: flush text until a '*' '/' is seen, then go to state old_state 	  */
comment|/* I added states 9 and 10 because the MIPS ECOFF assembler uses      constructs like ``.loc 1 20''.  This was turning into ``.loc      120''.  States 9 and 10 ensure that a space is never dropped in      between characters which could appear in a identifier.  Ian      Taylor, ian@cygnus.com.       I added state 11 so that something like "Lfoo add %r25,%r26,%r27" works      correctly on the PA (and any other target where colons are optional).      Jeff Law, law@cs.utah.edu.  */
comment|/* This macro gets the next input character.  */
define|#
directive|define
name|GET
parameter_list|()
define|\
value|(from< fromend			\    ? *from++				\    : ((saved_input != NULL		\        ? (free (saved_input),		\ 	  saved_input = NULL,		\ 	  0)				\        : 0),				\       fromlen = (*get) (&from),		\       fromend = from + fromlen,		\       (fromlen == 0			\        ? EOF				\        : *from++)))
comment|/* This macro pushes a character back on the input stream.  */
define|#
directive|define
name|UNGET
parameter_list|(
name|uch
parameter_list|)
value|(*--from = (uch))
comment|/* This macro puts a character into the output buffer.  If this      character fills the output buffer, this macro jumps to the label      TOFULL.  We use this rather ugly approach because we need to      handle two different termination conditions: EOF on the input      stream, and a full output buffer.  It would be simpler if we      always read in the entire input stream before processing it, but      I don't want to make such a significant change to the assembler's      memory usage.  */
define|#
directive|define
name|PUT
parameter_list|(
name|pch
parameter_list|)
define|\
value|do					\     {					\       *to++ = (pch);			\       if (to>= toend)			\         goto tofull;			\     }					\   while (0)
if|if
condition|(
name|saved_input
operator|!=
name|NULL
condition|)
block|{
name|from
operator|=
name|saved_input
expr_stmt|;
name|fromend
operator|=
name|from
operator|+
name|saved_input_len
expr_stmt|;
block|}
else|else
block|{
name|fromlen
operator|=
call|(
modifier|*
name|get
call|)
argument_list|(
operator|&
name|from
argument_list|)
expr_stmt|;
if|if
condition|(
name|fromlen
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|fromend
operator|=
name|from
operator|+
name|fromlen
expr_stmt|;
block|}
while|while
condition|(
literal|1
condition|)
block|{
comment|/* The cases in this switch end with continue, in order to          branch back to the top of this while loop and generate the          next output character in the appropriate state.  */
switch|switch
condition|(
name|state
condition|)
block|{
case|case
operator|-
literal|1
case|:
name|ch
operator|=
operator|*
name|out_string
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|out_string
operator|==
literal|'\0'
condition|)
block|{
name|state
operator|=
name|old_state
expr_stmt|;
name|old_state
operator|=
literal|3
expr_stmt|;
block|}
name|PUT
argument_list|(
name|ch
argument_list|)
expr_stmt|;
continue|continue;
case|case
operator|-
literal|2
case|:
for|for
control|(
init|;
condition|;
control|)
block|{
do|do
block|{
name|ch
operator|=
name|GET
argument_list|()
expr_stmt|;
if|if
condition|(
name|ch
operator|==
name|EOF
condition|)
block|{
name|as_warn
argument_list|(
literal|"end of file in comment"
argument_list|)
expr_stmt|;
goto|goto
name|fromeof
goto|;
block|}
if|if
condition|(
name|ch
operator|==
literal|'\n'
condition|)
name|PUT
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|ch
operator|!=
literal|'*'
condition|)
do|;
while|while
condition|(
operator|(
name|ch
operator|=
name|GET
argument_list|()
operator|)
operator|==
literal|'*'
condition|)
empty_stmt|;
if|if
condition|(
name|ch
operator|==
name|EOF
condition|)
block|{
name|as_warn
argument_list|(
literal|"end of file in comment"
argument_list|)
expr_stmt|;
goto|goto
name|fromeof
goto|;
block|}
if|if
condition|(
name|ch
operator|==
literal|'/'
condition|)
break|break;
name|UNGET
argument_list|(
name|ch
argument_list|)
expr_stmt|;
block|}
name|state
operator|=
name|old_state
expr_stmt|;
name|UNGET
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
continue|continue;
case|case
literal|4
case|:
name|ch
operator|=
name|GET
argument_list|()
expr_stmt|;
if|if
condition|(
name|ch
operator|==
name|EOF
condition|)
goto|goto
name|fromeof
goto|;
elseif|else
if|if
condition|(
name|ch
operator|>=
literal|'0'
operator|&&
name|ch
operator|<=
literal|'9'
condition|)
name|PUT
argument_list|(
name|ch
argument_list|)
expr_stmt|;
else|else
block|{
while|while
condition|(
name|ch
operator|!=
name|EOF
operator|&&
name|IS_WHITESPACE
argument_list|(
name|ch
argument_list|)
condition|)
name|ch
operator|=
name|GET
argument_list|()
expr_stmt|;
if|if
condition|(
name|ch
operator|==
literal|'"'
condition|)
block|{
name|UNGET
argument_list|(
name|ch
argument_list|)
expr_stmt|;
if|if
condition|(
name|scrub_m68k_mri
condition|)
name|out_string
operator|=
literal|"\n\tappfile "
expr_stmt|;
else|else
name|out_string
operator|=
literal|"\n\t.appfile "
expr_stmt|;
name|old_state
operator|=
literal|7
expr_stmt|;
name|state
operator|=
operator|-
literal|1
expr_stmt|;
name|PUT
argument_list|(
operator|*
name|out_string
operator|++
argument_list|)
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
name|ch
operator|!=
name|EOF
operator|&&
name|ch
operator|!=
literal|'\n'
condition|)
name|ch
operator|=
name|GET
argument_list|()
expr_stmt|;
name|state
operator|=
literal|0
expr_stmt|;
name|PUT
argument_list|(
name|ch
argument_list|)
expr_stmt|;
block|}
block|}
continue|continue;
case|case
literal|5
case|:
comment|/* We are going to copy everything up to a quote character,              with special handling for a backslash.  We try to              optimize the copying in the simple case without using the              GET and PUT macros.  */
block|{
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|len
decl_stmt|;
for|for
control|(
name|s
operator|=
name|from
init|;
name|s
operator|<
name|fromend
condition|;
name|s
operator|++
control|)
block|{
name|ch
operator|=
operator|*
name|s
expr_stmt|;
comment|/* This condition must be changed if the type of any                    other character can be LEX_IS_STRINGQUOTE.  */
if|if
condition|(
name|ch
operator|==
literal|'\\'
operator|||
name|ch
operator|==
literal|'"'
operator|||
name|ch
operator|==
literal|'\''
operator|||
name|ch
operator|==
literal|'\n'
condition|)
break|break;
block|}
name|len
operator|=
name|s
operator|-
name|from
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|toend
operator|-
name|to
condition|)
name|len
operator|=
name|toend
operator|-
name|to
expr_stmt|;
if|if
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|memcpy
argument_list|(
name|to
argument_list|,
name|from
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|to
operator|+=
name|len
expr_stmt|;
name|from
operator|+=
name|len
expr_stmt|;
block|}
block|}
name|ch
operator|=
name|GET
argument_list|()
expr_stmt|;
if|if
condition|(
name|ch
operator|==
name|EOF
condition|)
block|{
name|as_warn
argument_list|(
literal|"end of file in string: inserted '\"'"
argument_list|)
expr_stmt|;
name|state
operator|=
name|old_state
expr_stmt|;
name|UNGET
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|PUT
argument_list|(
literal|'"'
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|lex
index|[
name|ch
index|]
operator|==
name|LEX_IS_STRINGQUOTE
condition|)
block|{
name|state
operator|=
name|old_state
expr_stmt|;
name|PUT
argument_list|(
name|ch
argument_list|)
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|NO_STRING_ESCAPES
elseif|else
if|if
condition|(
name|ch
operator|==
literal|'\\'
condition|)
block|{
name|state
operator|=
literal|6
expr_stmt|;
name|PUT
argument_list|(
name|ch
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
elseif|else
if|if
condition|(
name|scrub_m68k_mri
operator|&&
name|ch
operator|==
literal|'\n'
condition|)
block|{
comment|/* Just quietly terminate the string.  This permits lines like 		   bne	label	loop if we haven't reach end yet 		 */
name|state
operator|=
name|old_state
expr_stmt|;
name|UNGET
argument_list|(
name|ch
argument_list|)
expr_stmt|;
name|PUT
argument_list|(
literal|'\''
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|PUT
argument_list|(
name|ch
argument_list|)
expr_stmt|;
block|}
continue|continue;
case|case
literal|6
case|:
name|state
operator|=
literal|5
expr_stmt|;
name|ch
operator|=
name|GET
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|ch
condition|)
block|{
comment|/* Handle strings broken across lines, by turning '\n' into 		 '\\' and 'n'.  */
case|case
literal|'\n'
case|:
name|UNGET
argument_list|(
literal|'n'
argument_list|)
expr_stmt|;
name|add_newlines
operator|++
expr_stmt|;
name|PUT
argument_list|(
literal|'\\'
argument_list|)
expr_stmt|;
continue|continue;
case|case
literal|'"'
case|:
case|case
literal|'\\'
case|:
case|case
literal|'b'
case|:
case|case
literal|'f'
case|:
case|case
literal|'n'
case|:
case|case
literal|'r'
case|:
case|case
literal|'t'
case|:
case|case
literal|'v'
case|:
case|case
literal|'x'
case|:
case|case
literal|'X'
case|:
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
break|break;
if|#
directive|if
name|defined
argument_list|(
name|IGNORE_NONSTANDARD_ESCAPES
argument_list|)
operator||
name|defined
argument_list|(
name|ONLY_STANDARD_ESCAPES
argument_list|)
default|default:
name|as_warn
argument_list|(
literal|"Unknown escape '\\%c' in string: Ignored"
argument_list|,
name|ch
argument_list|)
expr_stmt|;
break|break;
else|#
directive|else
comment|/* ONLY_STANDARD_ESCAPES */
default|default:
comment|/* Accept \x as x for any x */
break|break;
endif|#
directive|endif
comment|/* ONLY_STANDARD_ESCAPES */
case|case
name|EOF
case|:
name|as_warn
argument_list|(
literal|"End of file in string: '\"' inserted"
argument_list|)
expr_stmt|;
name|PUT
argument_list|(
literal|'"'
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|PUT
argument_list|(
name|ch
argument_list|)
expr_stmt|;
continue|continue;
case|case
literal|7
case|:
name|ch
operator|=
name|GET
argument_list|()
expr_stmt|;
name|state
operator|=
literal|5
expr_stmt|;
name|old_state
operator|=
literal|8
expr_stmt|;
if|if
condition|(
name|ch
operator|==
name|EOF
condition|)
goto|goto
name|fromeof
goto|;
name|PUT
argument_list|(
name|ch
argument_list|)
expr_stmt|;
continue|continue;
case|case
literal|8
case|:
do|do
name|ch
operator|=
name|GET
argument_list|()
expr_stmt|;
do|while
condition|(
name|ch
operator|!=
literal|'\n'
operator|&&
name|ch
operator|!=
name|EOF
condition|)
do|;
if|if
condition|(
name|ch
operator|==
name|EOF
condition|)
goto|goto
name|fromeof
goto|;
name|state
operator|=
literal|0
expr_stmt|;
name|PUT
argument_list|(
name|ch
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* OK, we are somewhere in states 0 through 4 or 9 through 11 */
comment|/* flushchar: */
name|ch
operator|=
name|GET
argument_list|()
expr_stmt|;
name|recycle
label|:
ifdef|#
directive|ifdef
name|TC_M68K
comment|/* We want to have pseudo-ops which control whether we are in          MRI mode or not.  Unfortunately, since m68k MRI mode affects          the scrubber, that means that we need a special purpose          recognizer here.  */
if|if
condition|(
name|mri_state
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|state
operator|==
literal|0
operator|||
name|state
operator|==
literal|1
operator|)
operator|&&
name|ch
operator|==
name|mri_pseudo
index|[
literal|0
index|]
condition|)
name|mri_state
operator|=
name|mri_pseudo
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* We advance to the next state if we find the right 	     character, or if we need a space character and we get any 	     whitespace character, or if we need a '0' and we get a 	     '1' (this is so that we only need one state to handle 	     ``.mri 0'' and ``.mri 1'').  */
if|if
condition|(
name|ch
operator|!=
literal|'\0'
operator|&&
operator|(
operator|*
name|mri_state
operator|==
name|ch
operator|||
operator|(
operator|*
name|mri_state
operator|==
literal|' '
operator|&&
name|lex
index|[
name|ch
index|]
operator|==
name|LEX_IS_WHITESPACE
operator|)
operator|||
operator|(
operator|*
name|mri_state
operator|==
literal|'0'
operator|&&
name|ch
operator|==
literal|'1'
operator|)
operator|)
condition|)
block|{
name|mri_last_ch
operator|=
name|ch
expr_stmt|;
operator|++
name|mri_state
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|mri_state
operator|!=
literal|'\0'
operator|||
operator|(
name|lex
index|[
name|ch
index|]
operator|!=
name|LEX_IS_WHITESPACE
operator|&&
name|lex
index|[
name|ch
index|]
operator|!=
name|LEX_IS_NEWLINE
operator|)
condition|)
block|{
comment|/* We did not get the expected character, or we didn't 		 get a valid terminating character after seeing the 		 entire pseudo-op, so we must go back to the 		 beginning.  */
name|mri_state
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
comment|/* We've read the entire pseudo-op.  mips_last_ch is                  either '0' or '1' indicating whether to enter or                  leave MRI mode.  */
name|do_scrub_begin
argument_list|(
name|mri_last_ch
operator|==
literal|'1'
argument_list|)
expr_stmt|;
comment|/* We continue handling the character as usual.  The                  main gas reader must also handle the .mri pseudo-op                  to control expression parsing and the like.  */
block|}
block|}
endif|#
directive|endif
if|if
condition|(
name|ch
operator|==
name|EOF
condition|)
block|{
if|if
condition|(
name|state
operator|!=
literal|0
condition|)
block|{
name|as_warn
argument_list|(
literal|"end of file not at end of a line; newline inserted"
argument_list|)
expr_stmt|;
name|state
operator|=
literal|0
expr_stmt|;
name|PUT
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
goto|goto
name|fromeof
goto|;
block|}
switch|switch
condition|(
name|lex
index|[
name|ch
index|]
condition|)
block|{
case|case
name|LEX_IS_WHITESPACE
case|:
do|do
block|{
name|ch
operator|=
name|GET
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
name|ch
operator|!=
name|EOF
operator|&&
name|IS_WHITESPACE
argument_list|(
name|ch
argument_list|)
condition|)
do|;
if|if
condition|(
name|ch
operator|==
name|EOF
condition|)
goto|goto
name|fromeof
goto|;
if|if
condition|(
name|state
operator|==
literal|0
condition|)
block|{
comment|/* Preserve a single whitespace character at the 		 beginning of a line.  */
name|state
operator|=
literal|1
expr_stmt|;
name|UNGET
argument_list|(
name|ch
argument_list|)
expr_stmt|;
name|PUT
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|IS_COMMENT
argument_list|(
name|ch
argument_list|)
operator|||
name|ch
operator|==
literal|'/'
operator|||
name|IS_LINE_SEPARATOR
argument_list|(
name|ch
argument_list|)
condition|)
block|{
if|if
condition|(
name|scrub_m68k_mri
condition|)
block|{
comment|/* In MRI mode, we keep these spaces.  */
name|UNGET
argument_list|(
name|ch
argument_list|)
expr_stmt|;
name|PUT
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
break|break;
block|}
goto|goto
name|recycle
goto|;
block|}
comment|/* If we're in state 2 or 11, we've seen a non-white 	     character followed by whitespace.  If the next character 	     is ':', this is whitespace after a label name which we 	     normally must ignore.  In MRI mode, though, spaces are 	     not permitted between the label and the colon.  */
if|if
condition|(
operator|(
name|state
operator|==
literal|2
operator|||
name|state
operator|==
literal|11
operator|)
operator|&&
name|lex
index|[
name|ch
index|]
operator|==
name|LEX_IS_COLON
operator|&&
operator|!
name|scrub_m68k_mri
condition|)
block|{
name|state
operator|=
literal|1
expr_stmt|;
name|PUT
argument_list|(
name|ch
argument_list|)
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|state
condition|)
block|{
case|case
literal|0
case|:
name|state
operator|++
expr_stmt|;
goto|goto
name|recycle
goto|;
comment|/* Punted leading sp */
case|case
literal|1
case|:
comment|/* We can arrive here if we leave a leading whitespace 		 character at the beginning of a line.  */
goto|goto
name|recycle
goto|;
case|case
literal|2
case|:
name|state
operator|=
literal|3
expr_stmt|;
if|if
condition|(
name|to
operator|+
literal|1
operator|<
name|toend
condition|)
block|{
comment|/* Optimize common case by skipping UNGET/GET.  */
name|PUT
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
comment|/* Sp after opco */
goto|goto
name|recycle
goto|;
block|}
name|UNGET
argument_list|(
name|ch
argument_list|)
expr_stmt|;
name|PUT
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
if|if
condition|(
name|scrub_m68k_mri
condition|)
block|{
comment|/* In MRI mode, we keep these spaces.  */
name|UNGET
argument_list|(
name|ch
argument_list|)
expr_stmt|;
name|PUT
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
break|break;
block|}
goto|goto
name|recycle
goto|;
comment|/* Sp in operands */
case|case
literal|9
case|:
case|case
literal|10
case|:
if|if
condition|(
name|scrub_m68k_mri
condition|)
block|{
comment|/* In MRI mode, we keep these spaces.  */
name|state
operator|=
literal|3
expr_stmt|;
name|UNGET
argument_list|(
name|ch
argument_list|)
expr_stmt|;
name|PUT
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
break|break;
block|}
name|state
operator|=
literal|10
expr_stmt|;
comment|/* Sp after symbol char */
goto|goto
name|recycle
goto|;
case|case
literal|11
case|:
if|if
condition|(
name|flag_m68k_mri
ifdef|#
directive|ifdef
name|LABELS_WITHOUT_COLONS
operator|||
literal|1
endif|#
directive|endif
condition|)
name|state
operator|=
literal|1
expr_stmt|;
else|else
block|{
comment|/* We know that ch is not ':', since we tested that                      case above.  Therefore this is not a label, so it                      must be the opcode, and we've just seen the                      whitespace after it.  */
name|state
operator|=
literal|3
expr_stmt|;
block|}
name|UNGET
argument_list|(
name|ch
argument_list|)
expr_stmt|;
name|PUT
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
comment|/* Sp after label definition.  */
break|break;
default|default:
name|BAD_CASE
argument_list|(
name|state
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|LEX_IS_TWOCHAR_COMMENT_1ST
case|:
name|ch2
operator|=
name|GET
argument_list|()
expr_stmt|;
if|if
condition|(
name|ch2
operator|==
literal|'*'
condition|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
do|do
block|{
name|ch2
operator|=
name|GET
argument_list|()
expr_stmt|;
if|if
condition|(
name|ch2
operator|!=
name|EOF
operator|&&
name|IS_NEWLINE
argument_list|(
name|ch2
argument_list|)
condition|)
name|add_newlines
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|ch2
operator|!=
name|EOF
operator|&&
name|ch2
operator|!=
literal|'*'
condition|)
do|;
while|while
condition|(
name|ch2
operator|==
literal|'*'
condition|)
name|ch2
operator|=
name|GET
argument_list|()
expr_stmt|;
if|if
condition|(
name|ch2
operator|==
name|EOF
operator|||
name|ch2
operator|==
literal|'/'
condition|)
break|break;
comment|/* This UNGET will ensure that we count newlines                      correctly.  */
name|UNGET
argument_list|(
name|ch2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ch2
operator|==
name|EOF
condition|)
name|as_warn
argument_list|(
literal|"end of file in multiline comment"
argument_list|)
expr_stmt|;
name|ch
operator|=
literal|' '
expr_stmt|;
goto|goto
name|recycle
goto|;
block|}
else|else
block|{
if|if
condition|(
name|ch2
operator|!=
name|EOF
condition|)
name|UNGET
argument_list|(
name|ch2
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
operator|==
literal|9
operator|||
name|state
operator|==
literal|10
condition|)
name|state
operator|=
literal|3
expr_stmt|;
name|PUT
argument_list|(
name|ch
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|LEX_IS_STRINGQUOTE
case|:
if|if
condition|(
name|state
operator|==
literal|10
condition|)
block|{
comment|/* Preserve the whitespace in foo "bar" */
name|UNGET
argument_list|(
name|ch
argument_list|)
expr_stmt|;
name|state
operator|=
literal|3
expr_stmt|;
name|PUT
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
comment|/* PUT didn't jump out.  We could just break, but we                  know what will happen, so optimize a bit.  */
name|ch
operator|=
name|GET
argument_list|()
expr_stmt|;
name|old_state
operator|=
literal|3
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|state
operator|==
literal|9
condition|)
name|old_state
operator|=
literal|3
expr_stmt|;
else|else
name|old_state
operator|=
name|state
expr_stmt|;
name|state
operator|=
literal|5
expr_stmt|;
name|PUT
argument_list|(
name|ch
argument_list|)
expr_stmt|;
break|break;
ifndef|#
directive|ifndef
name|IEEE_STYLE
case|case
name|LEX_IS_ONECHAR_QUOTE
case|:
if|if
condition|(
name|state
operator|==
literal|10
condition|)
block|{
comment|/* Preserve the whitespace in foo 'b' */
name|UNGET
argument_list|(
name|ch
argument_list|)
expr_stmt|;
name|state
operator|=
literal|3
expr_stmt|;
name|PUT
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
break|break;
block|}
name|ch
operator|=
name|GET
argument_list|()
expr_stmt|;
if|if
condition|(
name|ch
operator|==
name|EOF
condition|)
block|{
name|as_warn
argument_list|(
literal|"end of file after a one-character quote; \\0 inserted"
argument_list|)
expr_stmt|;
name|ch
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|ch
operator|==
literal|'\\'
condition|)
block|{
name|ch
operator|=
name|GET
argument_list|()
expr_stmt|;
if|if
condition|(
name|ch
operator|==
name|EOF
condition|)
block|{
name|as_warn
argument_list|(
literal|"end of file in escape character"
argument_list|)
expr_stmt|;
name|ch
operator|=
literal|'\\'
expr_stmt|;
block|}
else|else
name|ch
operator|=
name|process_escape
argument_list|(
name|ch
argument_list|)
expr_stmt|;
block|}
name|sprintf
argument_list|(
name|out_buf
argument_list|,
literal|"%d"
argument_list|,
operator|(
name|int
operator|)
operator|(
name|unsigned
name|char
operator|)
name|ch
argument_list|)
expr_stmt|;
comment|/* None of these 'x constants for us.  We want 'x'.  */
if|if
condition|(
operator|(
name|ch
operator|=
name|GET
argument_list|()
operator|)
operator|!=
literal|'\''
condition|)
block|{
ifdef|#
directive|ifdef
name|REQUIRE_CHAR_CLOSE_QUOTE
name|as_warn
argument_list|(
literal|"Missing close quote: (assumed)"
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|ch
operator|!=
name|EOF
condition|)
name|UNGET
argument_list|(
name|ch
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|strlen
argument_list|(
name|out_buf
argument_list|)
operator|==
literal|1
condition|)
block|{
name|PUT
argument_list|(
name|out_buf
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|state
operator|==
literal|9
condition|)
name|old_state
operator|=
literal|3
expr_stmt|;
else|else
name|old_state
operator|=
name|state
expr_stmt|;
name|state
operator|=
operator|-
literal|1
expr_stmt|;
name|out_string
operator|=
name|out_buf
expr_stmt|;
name|PUT
argument_list|(
operator|*
name|out_string
operator|++
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|LEX_IS_COLON
case|:
if|if
condition|(
name|state
operator|==
literal|9
operator|||
name|state
operator|==
literal|10
condition|)
name|state
operator|=
literal|3
expr_stmt|;
elseif|else
if|if
condition|(
name|state
operator|!=
literal|3
condition|)
name|state
operator|=
literal|1
expr_stmt|;
name|PUT
argument_list|(
name|ch
argument_list|)
expr_stmt|;
break|break;
case|case
name|LEX_IS_NEWLINE
case|:
comment|/* Roll out a bunch of newlines from inside comments, etc.  */
if|if
condition|(
name|add_newlines
condition|)
block|{
operator|--
name|add_newlines
expr_stmt|;
name|UNGET
argument_list|(
name|ch
argument_list|)
expr_stmt|;
block|}
comment|/* fall thru into... */
case|case
name|LEX_IS_LINE_SEPARATOR
case|:
name|state
operator|=
literal|0
expr_stmt|;
name|PUT
argument_list|(
name|ch
argument_list|)
expr_stmt|;
break|break;
case|case
name|LEX_IS_LINE_COMMENT_START
case|:
comment|/* FIXME-someday: The two character comment stuff was badly 	     thought out.  On i386, we want '/' as line comment start 	     AND we want C style comments.  hence this hack.  The 	     whole lexical process should be reworked.  xoxorich.  */
if|if
condition|(
name|ch
operator|==
literal|'/'
condition|)
block|{
name|ch2
operator|=
name|GET
argument_list|()
expr_stmt|;
if|if
condition|(
name|ch2
operator|==
literal|'*'
condition|)
block|{
name|old_state
operator|=
literal|3
expr_stmt|;
name|state
operator|=
operator|-
literal|2
expr_stmt|;
break|break;
block|}
else|else
block|{
name|UNGET
argument_list|(
name|ch2
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* bad hack */
if|if
condition|(
name|state
operator|==
literal|0
operator|||
name|state
operator|==
literal|1
condition|)
comment|/* Only comment at start of line.  */
block|{
name|int
name|startch
decl_stmt|;
name|startch
operator|=
name|ch
expr_stmt|;
do|do
block|{
name|ch
operator|=
name|GET
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
name|ch
operator|!=
name|EOF
operator|&&
name|IS_WHITESPACE
argument_list|(
name|ch
argument_list|)
condition|)
do|;
if|if
condition|(
name|ch
operator|==
name|EOF
condition|)
block|{
name|as_warn
argument_list|(
literal|"end of file in comment; newline inserted"
argument_list|)
expr_stmt|;
name|PUT
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ch
operator|<
literal|'0'
operator|||
name|ch
operator|>
literal|'9'
operator|||
name|state
operator|!=
literal|0
operator|||
name|startch
operator|!=
literal|'#'
condition|)
block|{
comment|/* Not a cpp line.  */
while|while
condition|(
name|ch
operator|!=
name|EOF
operator|&&
operator|!
name|IS_NEWLINE
argument_list|(
name|ch
argument_list|)
condition|)
name|ch
operator|=
name|GET
argument_list|()
expr_stmt|;
if|if
condition|(
name|ch
operator|==
name|EOF
condition|)
name|as_warn
argument_list|(
literal|"EOF in Comment: Newline inserted"
argument_list|)
expr_stmt|;
name|state
operator|=
literal|0
expr_stmt|;
name|PUT
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Loks like `# 123 "filename"' from cpp.  */
name|UNGET
argument_list|(
name|ch
argument_list|)
expr_stmt|;
name|old_state
operator|=
literal|4
expr_stmt|;
name|state
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|scrub_m68k_mri
condition|)
name|out_string
operator|=
literal|"\tappline "
expr_stmt|;
else|else
name|out_string
operator|=
literal|"\t.appline "
expr_stmt|;
name|PUT
argument_list|(
operator|*
name|out_string
operator|++
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* We have a line comment character which is not at the 	     start of a line.  If this is also a normal comment 	     character, fall through.  Otherwise treat it as a default 	     character.  */
if|if
condition|(
name|strchr
argument_list|(
name|tc_comment_chars
argument_list|,
name|ch
argument_list|)
operator|==
name|NULL
operator|&&
operator|(
operator|!
name|scrub_m68k_mri
operator|||
operator|(
name|ch
operator|!=
literal|'!'
operator|&&
name|ch
operator|!=
literal|'*'
operator|)
operator|)
condition|)
goto|goto
name|de_fault
goto|;
if|if
condition|(
name|scrub_m68k_mri
operator|&&
operator|(
name|ch
operator|==
literal|'!'
operator|||
name|ch
operator|==
literal|'*'
operator|||
name|ch
operator|==
literal|'#'
operator|)
operator|&&
name|state
operator|!=
literal|1
operator|&&
name|state
operator|!=
literal|10
condition|)
goto|goto
name|de_fault
goto|;
comment|/* Fall through.  */
case|case
name|LEX_IS_COMMENT_START
case|:
do|do
block|{
name|ch
operator|=
name|GET
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
name|ch
operator|!=
name|EOF
operator|&&
operator|!
name|IS_NEWLINE
argument_list|(
name|ch
argument_list|)
condition|)
do|;
if|if
condition|(
name|ch
operator|==
name|EOF
condition|)
name|as_warn
argument_list|(
literal|"end of file in comment; newline inserted"
argument_list|)
expr_stmt|;
name|state
operator|=
literal|0
expr_stmt|;
name|PUT
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
break|break;
case|case
name|LEX_IS_SYMBOL_COMPONENT
case|:
if|if
condition|(
name|state
operator|==
literal|10
condition|)
block|{
comment|/* This is a symbol character following another symbol 		 character, with whitespace in between.  We skipped 		 the whitespace earlier, so output it now.  */
name|UNGET
argument_list|(
name|ch
argument_list|)
expr_stmt|;
name|state
operator|=
literal|3
expr_stmt|;
name|PUT
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|state
operator|==
literal|3
condition|)
name|state
operator|=
literal|9
expr_stmt|;
comment|/* This is a common case.  Quickly copy CH and all the              following symbol component or normal characters.  */
if|if
condition|(
name|to
operator|+
literal|1
operator|<
name|toend
operator|&&
name|mri_state
operator|==
name|NULL
condition|)
block|{
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|len
decl_stmt|;
for|for
control|(
name|s
operator|=
name|from
init|;
name|s
operator|<
name|fromend
condition|;
name|s
operator|++
control|)
block|{
name|int
name|type
decl_stmt|;
name|ch2
operator|=
operator|*
name|s
expr_stmt|;
name|type
operator|=
name|lex
index|[
name|ch2
index|]
expr_stmt|;
if|if
condition|(
name|type
operator|!=
literal|0
operator|&&
name|type
operator|!=
name|LEX_IS_SYMBOL_COMPONENT
condition|)
break|break;
block|}
if|if
condition|(
name|s
operator|>
name|from
condition|)
block|{
comment|/* Handle the last character normally, for                      simplicity.  */
operator|--
name|s
expr_stmt|;
block|}
name|len
operator|=
name|s
operator|-
name|from
expr_stmt|;
if|if
condition|(
name|len
operator|>
operator|(
name|toend
operator|-
name|to
operator|)
operator|-
literal|1
condition|)
name|len
operator|=
operator|(
name|toend
operator|-
name|to
operator|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|PUT
argument_list|(
name|ch
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
literal|8
condition|)
block|{
name|memcpy
argument_list|(
name|to
argument_list|,
name|from
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|to
operator|+=
name|len
expr_stmt|;
name|from
operator|+=
name|len
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
name|len
condition|)
block|{
case|case
literal|8
case|:
operator|*
name|to
operator|++
operator|=
operator|*
name|from
operator|++
expr_stmt|;
case|case
literal|7
case|:
operator|*
name|to
operator|++
operator|=
operator|*
name|from
operator|++
expr_stmt|;
case|case
literal|6
case|:
operator|*
name|to
operator|++
operator|=
operator|*
name|from
operator|++
expr_stmt|;
case|case
literal|5
case|:
operator|*
name|to
operator|++
operator|=
operator|*
name|from
operator|++
expr_stmt|;
case|case
literal|4
case|:
operator|*
name|to
operator|++
operator|=
operator|*
name|from
operator|++
expr_stmt|;
case|case
literal|3
case|:
operator|*
name|to
operator|++
operator|=
operator|*
name|from
operator|++
expr_stmt|;
case|case
literal|2
case|:
operator|*
name|to
operator|++
operator|=
operator|*
name|from
operator|++
expr_stmt|;
case|case
literal|1
case|:
operator|*
name|to
operator|++
operator|=
operator|*
name|from
operator|++
expr_stmt|;
block|}
block|}
name|ch
operator|=
name|GET
argument_list|()
expr_stmt|;
block|}
block|}
comment|/* Fall through.  */
default|default:
name|de_fault
label|:
comment|/* Some relatively `normal' character.  */
if|if
condition|(
name|state
operator|==
literal|0
condition|)
block|{
name|state
operator|=
literal|11
expr_stmt|;
comment|/* Now seeing label definition */
block|}
elseif|else
if|if
condition|(
name|state
operator|==
literal|1
condition|)
block|{
name|state
operator|=
literal|2
expr_stmt|;
comment|/* Ditto */
block|}
elseif|else
if|if
condition|(
name|state
operator|==
literal|9
condition|)
block|{
if|if
condition|(
name|lex
index|[
name|ch
index|]
operator|!=
name|LEX_IS_SYMBOL_COMPONENT
condition|)
name|state
operator|=
literal|3
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|state
operator|==
literal|10
condition|)
block|{
name|state
operator|=
literal|3
expr_stmt|;
block|}
name|PUT
argument_list|(
name|ch
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|/*NOTREACHED*/
name|fromeof
label|:
comment|/* We have reached the end of the input.  */
return|return
name|to
operator|-
name|tostart
return|;
name|tofull
label|:
comment|/* The output buffer is full.  Save any input we have not yet      processed.  */
if|if
condition|(
name|fromend
operator|>
name|from
condition|)
block|{
name|char
modifier|*
name|save
decl_stmt|;
name|save
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|fromend
operator|-
name|from
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|save
argument_list|,
name|from
argument_list|,
name|fromend
operator|-
name|from
argument_list|)
expr_stmt|;
if|if
condition|(
name|saved_input
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|saved_input
argument_list|)
expr_stmt|;
name|saved_input
operator|=
name|save
expr_stmt|;
name|saved_input_len
operator|=
name|fromend
operator|-
name|from
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|saved_input
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|saved_input
argument_list|)
expr_stmt|;
name|saved_input
operator|=
name|NULL
expr_stmt|;
block|}
block|}
return|return
name|to
operator|-
name|tostart
return|;
block|}
end_block

begin_comment
comment|/* end of app.c */
end_comment

end_unit

