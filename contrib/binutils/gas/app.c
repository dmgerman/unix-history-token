begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* This is the Assembler Pre-Processor    Copyright 1987, 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998,    1999, 2000, 2001, 2002, 2003, 2006, 2007    Free Software Foundation, Inc.     This file is part of GAS, the GNU Assembler.     GAS is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     GAS is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with GAS; see the file COPYING.  If not, write to the Free    Software Foundation, 51 Franklin Street - Fifth Floor, Boston, MA    02110-1301, USA.  */
end_comment

begin_comment
comment|/* Modified by Allen Wirfs-Brock, Instantiations Inc 2/90.  */
end_comment

begin_comment
comment|/* App, the assembler pre-processor.  This pre-processor strips out    excess spaces, turns single-quoted characters into a decimal    constant, and turns the # in #<number><filename><garbage> into a    .linefile.  This needs better error-handling.  */
end_comment

begin_include
include|#
directive|include
file|"as.h"
end_include

begin_if
if|#
directive|if
operator|(
name|__STDC__
operator|!=
literal|1
operator|)
end_if

begin_ifndef
ifndef|#
directive|ifndef
name|const
end_ifndef

begin_define
define|#
directive|define
name|const
end_define

begin_comment
comment|/* empty */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|TC_M68K
end_ifdef

begin_comment
comment|/* Whether we are scrubbing in m68k MRI mode.  This is different from    flag_m68k_mri, because the two flags will be affected by the .mri    pseudo-op at different times.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|scrub_m68k_mri
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The pseudo-op which switches in and out of MRI mode.  See the    comment in do_scrub_chars.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
name|mri_pseudo
index|[]
init|=
literal|".mri 0"
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|scrub_m68k_mri
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
name|TC_ARM
operator|&&
name|defined
name|OBJ_ELF
end_if

begin_comment
comment|/* The pseudo-op for which we need to special-case `@' characters.    See the comment in do_scrub_chars.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
name|symver_pseudo
index|[]
init|=
literal|".symver"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|symver_state
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|char
name|lex
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
name|symbol_chars
index|[]
init|=
literal|"$._ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789"
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|LEX_IS_SYMBOL_COMPONENT
value|1
end_define

begin_define
define|#
directive|define
name|LEX_IS_WHITESPACE
value|2
end_define

begin_define
define|#
directive|define
name|LEX_IS_LINE_SEPARATOR
value|3
end_define

begin_define
define|#
directive|define
name|LEX_IS_COMMENT_START
value|4
end_define

begin_define
define|#
directive|define
name|LEX_IS_LINE_COMMENT_START
value|5
end_define

begin_define
define|#
directive|define
name|LEX_IS_TWOCHAR_COMMENT_1ST
value|6
end_define

begin_define
define|#
directive|define
name|LEX_IS_STRINGQUOTE
value|8
end_define

begin_define
define|#
directive|define
name|LEX_IS_COLON
value|9
end_define

begin_define
define|#
directive|define
name|LEX_IS_NEWLINE
value|10
end_define

begin_define
define|#
directive|define
name|LEX_IS_ONECHAR_QUOTE
value|11
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|TC_V850
end_ifdef

begin_define
define|#
directive|define
name|LEX_IS_DOUBLEDASH_1ST
value|12
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|TC_M32R
end_ifdef

begin_define
define|#
directive|define
name|DOUBLEBAR_PARALLEL
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|DOUBLEBAR_PARALLEL
end_ifdef

begin_define
define|#
directive|define
name|LEX_IS_DOUBLEBAR_1ST
value|13
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|LEX_IS_PARALLEL_SEPARATOR
value|14
end_define

begin_define
define|#
directive|define
name|IS_SYMBOL_COMPONENT
parameter_list|(
name|c
parameter_list|)
value|(lex[c] == LEX_IS_SYMBOL_COMPONENT)
end_define

begin_define
define|#
directive|define
name|IS_WHITESPACE
parameter_list|(
name|c
parameter_list|)
value|(lex[c] == LEX_IS_WHITESPACE)
end_define

begin_define
define|#
directive|define
name|IS_LINE_SEPARATOR
parameter_list|(
name|c
parameter_list|)
value|(lex[c] == LEX_IS_LINE_SEPARATOR)
end_define

begin_define
define|#
directive|define
name|IS_PARALLEL_SEPARATOR
parameter_list|(
name|c
parameter_list|)
value|(lex[c] == LEX_IS_PARALLEL_SEPARATOR)
end_define

begin_define
define|#
directive|define
name|IS_COMMENT
parameter_list|(
name|c
parameter_list|)
value|(lex[c] == LEX_IS_COMMENT_START)
end_define

begin_define
define|#
directive|define
name|IS_LINE_COMMENT
parameter_list|(
name|c
parameter_list|)
value|(lex[c] == LEX_IS_LINE_COMMENT_START)
end_define

begin_define
define|#
directive|define
name|IS_NEWLINE
parameter_list|(
name|c
parameter_list|)
value|(lex[c] == LEX_IS_NEWLINE)
end_define

begin_function_decl
specifier|static
name|int
name|process_escape
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* FIXME-soon: The entire lexer/parser thingy should be    built statically at compile time rather than dynamically    each and every time the assembler is run.  xoxorich.  */
end_comment

begin_function
name|void
name|do_scrub_begin
parameter_list|(
name|int
name|m68k_mri
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|c
decl_stmt|;
name|lex
index|[
literal|' '
index|]
operator|=
name|LEX_IS_WHITESPACE
expr_stmt|;
name|lex
index|[
literal|'\t'
index|]
operator|=
name|LEX_IS_WHITESPACE
expr_stmt|;
name|lex
index|[
literal|'\r'
index|]
operator|=
name|LEX_IS_WHITESPACE
expr_stmt|;
name|lex
index|[
literal|'\n'
index|]
operator|=
name|LEX_IS_NEWLINE
expr_stmt|;
name|lex
index|[
literal|':'
index|]
operator|=
name|LEX_IS_COLON
expr_stmt|;
ifdef|#
directive|ifdef
name|TC_M68K
name|scrub_m68k_mri
operator|=
name|m68k_mri
expr_stmt|;
if|if
condition|(
operator|!
name|m68k_mri
condition|)
endif|#
directive|endif
block|{
name|lex
index|[
literal|'"'
index|]
operator|=
name|LEX_IS_STRINGQUOTE
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|TC_HPPA
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|TC_I370
argument_list|)
comment|/* I370 uses single-quotes to delimit integer, float constants.  */
name|lex
index|[
literal|'\''
index|]
operator|=
name|LEX_IS_ONECHAR_QUOTE
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SINGLE_QUOTE_STRINGS
name|lex
index|[
literal|'\''
index|]
operator|=
name|LEX_IS_STRINGQUOTE
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* Note: if any other character can be LEX_IS_STRINGQUOTE, the loop      in state 5 of do_scrub_chars must be changed.  */
comment|/* Note that these override the previous defaults, e.g. if ';' is a      comment char, then it isn't a line separator.  */
for|for
control|(
name|p
operator|=
name|symbol_chars
init|;
operator|*
name|p
condition|;
operator|++
name|p
control|)
name|lex
index|[
operator|(
name|unsigned
name|char
operator|)
operator|*
name|p
index|]
operator|=
name|LEX_IS_SYMBOL_COMPONENT
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|128
init|;
name|c
operator|<
literal|256
condition|;
operator|++
name|c
control|)
name|lex
index|[
name|c
index|]
operator|=
name|LEX_IS_SYMBOL_COMPONENT
expr_stmt|;
ifdef|#
directive|ifdef
name|tc_symbol_chars
comment|/* This macro permits the processor to specify all characters which      may appears in an operand.  This will prevent the scrubber from      discarding meaningful whitespace in certain cases.  The i386      backend uses this to support prefixes, which can confuse the      scrubber as to whether it is parsing operands or opcodes.  */
for|for
control|(
name|p
operator|=
name|tc_symbol_chars
init|;
operator|*
name|p
condition|;
operator|++
name|p
control|)
name|lex
index|[
operator|(
name|unsigned
name|char
operator|)
operator|*
name|p
index|]
operator|=
name|LEX_IS_SYMBOL_COMPONENT
expr_stmt|;
endif|#
directive|endif
comment|/* The m68k backend wants to be able to change comment_chars.  */
ifndef|#
directive|ifndef
name|tc_comment_chars
define|#
directive|define
name|tc_comment_chars
value|comment_chars
endif|#
directive|endif
for|for
control|(
name|p
operator|=
name|tc_comment_chars
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
name|lex
index|[
operator|(
name|unsigned
name|char
operator|)
operator|*
name|p
index|]
operator|=
name|LEX_IS_COMMENT_START
expr_stmt|;
for|for
control|(
name|p
operator|=
name|line_comment_chars
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
name|lex
index|[
operator|(
name|unsigned
name|char
operator|)
operator|*
name|p
index|]
operator|=
name|LEX_IS_LINE_COMMENT_START
expr_stmt|;
for|for
control|(
name|p
operator|=
name|line_separator_chars
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
name|lex
index|[
operator|(
name|unsigned
name|char
operator|)
operator|*
name|p
index|]
operator|=
name|LEX_IS_LINE_SEPARATOR
expr_stmt|;
ifdef|#
directive|ifdef
name|tc_parallel_separator_chars
comment|/* This macro permits the processor to specify all characters which      separate parallel insns on the same line.  */
for|for
control|(
name|p
operator|=
name|tc_parallel_separator_chars
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
name|lex
index|[
operator|(
name|unsigned
name|char
operator|)
operator|*
name|p
index|]
operator|=
name|LEX_IS_PARALLEL_SEPARATOR
expr_stmt|;
endif|#
directive|endif
comment|/* Only allow slash-star comments if slash is not in use.      FIXME: This isn't right.  We should always permit them.  */
if|if
condition|(
name|lex
index|[
literal|'/'
index|]
operator|==
literal|0
condition|)
name|lex
index|[
literal|'/'
index|]
operator|=
name|LEX_IS_TWOCHAR_COMMENT_1ST
expr_stmt|;
ifdef|#
directive|ifdef
name|TC_M68K
if|if
condition|(
name|m68k_mri
condition|)
block|{
name|lex
index|[
literal|'\''
index|]
operator|=
name|LEX_IS_STRINGQUOTE
expr_stmt|;
name|lex
index|[
literal|';'
index|]
operator|=
name|LEX_IS_COMMENT_START
expr_stmt|;
name|lex
index|[
literal|'*'
index|]
operator|=
name|LEX_IS_LINE_COMMENT_START
expr_stmt|;
comment|/* The MRI documentation says '!' is LEX_IS_COMMENT_START, but 	 then it can't be used in an expression.  */
name|lex
index|[
literal|'!'
index|]
operator|=
name|LEX_IS_LINE_COMMENT_START
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TC_V850
name|lex
index|[
literal|'-'
index|]
operator|=
name|LEX_IS_DOUBLEDASH_1ST
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DOUBLEBAR_PARALLEL
name|lex
index|[
literal|'|'
index|]
operator|=
name|LEX_IS_DOUBLEBAR_1ST
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TC_D30V
comment|/* Must do this is we want VLIW instruction with "->" or "<-".  */
name|lex
index|[
literal|'-'
index|]
operator|=
name|LEX_IS_SYMBOL_COMPONENT
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Saved state of the scrubber.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|state
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|old_state
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|out_string
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|out_buf
index|[
literal|20
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|add_newlines
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|saved_input
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|saved_input_len
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|input_buffer
index|[
literal|32
operator|*
literal|1024
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|mri_state
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|mri_last_ch
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Data structure for saving the state of app across #include's.  Note that    app is called asynchronously to the parsing of the .include's, so our    state at the time .include is interpreted is completely unrelated.    That's why we have to save it all.  */
end_comment

begin_struct
struct|struct
name|app_save
block|{
name|int
name|state
decl_stmt|;
name|int
name|old_state
decl_stmt|;
name|char
modifier|*
name|out_string
decl_stmt|;
name|char
name|out_buf
index|[
sizeof|sizeof
argument_list|(
name|out_buf
argument_list|)
index|]
decl_stmt|;
name|int
name|add_newlines
decl_stmt|;
name|char
modifier|*
name|saved_input
decl_stmt|;
name|int
name|saved_input_len
decl_stmt|;
ifdef|#
directive|ifdef
name|TC_M68K
name|int
name|scrub_m68k_mri
decl_stmt|;
endif|#
directive|endif
specifier|const
name|char
modifier|*
name|mri_state
decl_stmt|;
name|char
name|mri_last_ch
decl_stmt|;
if|#
directive|if
name|defined
name|TC_ARM
operator|&&
name|defined
name|OBJ_ELF
specifier|const
name|char
modifier|*
name|symver_state
decl_stmt|;
endif|#
directive|endif
block|}
struct|;
end_struct

begin_function
name|char
modifier|*
name|app_push
parameter_list|(
name|void
parameter_list|)
block|{
specifier|register
name|struct
name|app_save
modifier|*
name|saved
decl_stmt|;
name|saved
operator|=
operator|(
expr|struct
name|app_save
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|saved
argument_list|)
argument_list|)
expr_stmt|;
name|saved
operator|->
name|state
operator|=
name|state
expr_stmt|;
name|saved
operator|->
name|old_state
operator|=
name|old_state
expr_stmt|;
name|saved
operator|->
name|out_string
operator|=
name|out_string
expr_stmt|;
name|memcpy
argument_list|(
name|saved
operator|->
name|out_buf
argument_list|,
name|out_buf
argument_list|,
sizeof|sizeof
argument_list|(
name|out_buf
argument_list|)
argument_list|)
expr_stmt|;
name|saved
operator|->
name|add_newlines
operator|=
name|add_newlines
expr_stmt|;
if|if
condition|(
name|saved_input
operator|==
name|NULL
condition|)
name|saved
operator|->
name|saved_input
operator|=
name|NULL
expr_stmt|;
else|else
block|{
name|saved
operator|->
name|saved_input
operator|=
name|xmalloc
argument_list|(
name|saved_input_len
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|saved
operator|->
name|saved_input
argument_list|,
name|saved_input
argument_list|,
name|saved_input_len
argument_list|)
expr_stmt|;
name|saved
operator|->
name|saved_input_len
operator|=
name|saved_input_len
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|TC_M68K
name|saved
operator|->
name|scrub_m68k_mri
operator|=
name|scrub_m68k_mri
expr_stmt|;
endif|#
directive|endif
name|saved
operator|->
name|mri_state
operator|=
name|mri_state
expr_stmt|;
name|saved
operator|->
name|mri_last_ch
operator|=
name|mri_last_ch
expr_stmt|;
if|#
directive|if
name|defined
name|TC_ARM
operator|&&
name|defined
name|OBJ_ELF
name|saved
operator|->
name|symver_state
operator|=
name|symver_state
expr_stmt|;
endif|#
directive|endif
comment|/* do_scrub_begin() is not useful, just wastes time.  */
name|state
operator|=
literal|0
expr_stmt|;
name|saved_input
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|char
operator|*
operator|)
name|saved
return|;
block|}
end_function

begin_function
name|void
name|app_pop
parameter_list|(
name|char
modifier|*
name|arg
parameter_list|)
block|{
specifier|register
name|struct
name|app_save
modifier|*
name|saved
init|=
operator|(
expr|struct
name|app_save
operator|*
operator|)
name|arg
decl_stmt|;
comment|/* There is no do_scrub_end ().  */
name|state
operator|=
name|saved
operator|->
name|state
expr_stmt|;
name|old_state
operator|=
name|saved
operator|->
name|old_state
expr_stmt|;
name|out_string
operator|=
name|saved
operator|->
name|out_string
expr_stmt|;
name|memcpy
argument_list|(
name|out_buf
argument_list|,
name|saved
operator|->
name|out_buf
argument_list|,
sizeof|sizeof
argument_list|(
name|out_buf
argument_list|)
argument_list|)
expr_stmt|;
name|add_newlines
operator|=
name|saved
operator|->
name|add_newlines
expr_stmt|;
if|if
condition|(
name|saved
operator|->
name|saved_input
operator|==
name|NULL
condition|)
name|saved_input
operator|=
name|NULL
expr_stmt|;
else|else
block|{
name|assert
argument_list|(
name|saved
operator|->
name|saved_input_len
operator|<=
call|(
name|int
call|)
argument_list|(
sizeof|sizeof
name|input_buffer
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|input_buffer
argument_list|,
name|saved
operator|->
name|saved_input
argument_list|,
name|saved
operator|->
name|saved_input_len
argument_list|)
expr_stmt|;
name|saved_input
operator|=
name|input_buffer
expr_stmt|;
name|saved_input_len
operator|=
name|saved
operator|->
name|saved_input_len
expr_stmt|;
name|free
argument_list|(
name|saved
operator|->
name|saved_input
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|TC_M68K
name|scrub_m68k_mri
operator|=
name|saved
operator|->
name|scrub_m68k_mri
expr_stmt|;
endif|#
directive|endif
name|mri_state
operator|=
name|saved
operator|->
name|mri_state
expr_stmt|;
name|mri_last_ch
operator|=
name|saved
operator|->
name|mri_last_ch
expr_stmt|;
if|#
directive|if
name|defined
name|TC_ARM
operator|&&
name|defined
name|OBJ_ELF
name|symver_state
operator|=
name|saved
operator|->
name|symver_state
expr_stmt|;
endif|#
directive|endif
name|free
argument_list|(
name|arg
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* @@ This assumes that \n&c are the same on host and target.  This is not    necessarily true.  */
end_comment

begin_function
specifier|static
name|int
name|process_escape
parameter_list|(
name|int
name|ch
parameter_list|)
block|{
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'b'
case|:
return|return
literal|'\b'
return|;
case|case
literal|'f'
case|:
return|return
literal|'\f'
return|;
case|case
literal|'n'
case|:
return|return
literal|'\n'
return|;
case|case
literal|'r'
case|:
return|return
literal|'\r'
return|;
case|case
literal|'t'
case|:
return|return
literal|'\t'
return|;
case|case
literal|'\''
case|:
return|return
literal|'\''
return|;
case|case
literal|'"'
case|:
return|return
literal|'\"'
return|;
default|default:
return|return
name|ch
return|;
block|}
block|}
end_function

begin_comment
comment|/* This function is called to process input characters.  The GET    parameter is used to retrieve more input characters.  GET should    set its parameter to point to a buffer, and return the length of    the buffer; it should return 0 at end of file.  The scrubbed output    characters are put into the buffer starting at TOSTART; the TOSTART    buffer is TOLEN bytes in length.  The function returns the number    of scrubbed characters put into TOSTART.  This will be TOLEN unless    end of file was seen.  This function is arranged as a state    machine, and saves its state so that it may return at any point.    This is the way the old code used to work.  */
end_comment

begin_function
name|int
name|do_scrub_chars
parameter_list|(
name|int
function_decl|(
modifier|*
name|get
function_decl|)
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
parameter_list|,
name|char
modifier|*
name|tostart
parameter_list|,
name|int
name|tolen
parameter_list|)
block|{
name|char
modifier|*
name|to
init|=
name|tostart
decl_stmt|;
name|char
modifier|*
name|toend
init|=
name|tostart
operator|+
name|tolen
decl_stmt|;
name|char
modifier|*
name|from
decl_stmt|;
name|char
modifier|*
name|fromend
decl_stmt|;
name|int
name|fromlen
decl_stmt|;
specifier|register
name|int
name|ch
decl_stmt|,
name|ch2
init|=
literal|0
decl_stmt|;
comment|/* Character that started the string we're working on.  */
specifier|static
name|char
name|quotechar
decl_stmt|;
comment|/*State 0: beginning of normal line 	  1: After first whitespace on line (flush more white) 	  2: After first non-white (opcode) on line (keep 1white) 	  3: after second white on line (into operands) (flush white) 	  4: after putting out a .linefile, put out digits 	  5: parsing a string, then go to old-state 	  6: putting out \ escape in a "d string. 	  7: no longer used 	  8: no longer used 	  9: After seeing symbol char in state 3 (keep 1white after symchar) 	 10: After seeing whitespace in state 9 (keep white before symchar) 	 11: After seeing a symbol character in state 0 (eg a label definition) 	 -1: output string in out_string and go to the state in old_state 	 -2: flush text until a '*' '/' is seen, then go to state old_state #ifdef TC_V850 	 12: After seeing a dash, looking for a second dash as a start 	     of comment. #endif #ifdef DOUBLEBAR_PARALLEL 	 13: After seeing a vertical bar, looking for a second 	     vertical bar as a parallel expression separator. #endif #ifdef TC_IA64 	 14: After seeing a `(' at state 0, looking for a `)' as 	     predicate. 	 15: After seeing a `(' at state 1, looking for a `)' as 	     predicate. #endif #ifdef TC_Z80 	 16: After seeing an 'a' or an 'A' at the start of a symbol 	 17: After seeing an 'f' or an 'F' in state 16 #endif 	  */
comment|/* I added states 9 and 10 because the MIPS ECOFF assembler uses      constructs like ``.loc 1 20''.  This was turning into ``.loc      120''.  States 9 and 10 ensure that a space is never dropped in      between characters which could appear in an identifier.  Ian      Taylor, ian@cygnus.com.       I added state 11 so that something like "Lfoo add %r25,%r26,%r27" works      correctly on the PA (and any other target where colons are optional).      Jeff Law, law@cs.utah.edu.       I added state 13 so that something like "cmp r1, r2 || trap #1" does not      get squashed into "cmp r1,r2||trap#1", with the all important space      between the 'trap' and the '#1' being eliminated.  nickc@cygnus.com  */
comment|/* This macro gets the next input character.  */
define|#
directive|define
name|GET
parameter_list|()
define|\
value|(from< fromend						\    ? * (unsigned char *) (from++)				\    : (saved_input = NULL,					\       fromlen = (*get) (input_buffer, sizeof input_buffer),	\       from = input_buffer,					\       fromend = from + fromlen,					\       (fromlen == 0						\        ? EOF							\        : * (unsigned char *) (from++))))
comment|/* This macro pushes a character back on the input stream.  */
define|#
directive|define
name|UNGET
parameter_list|(
name|uch
parameter_list|)
value|(*--from = (uch))
comment|/* This macro puts a character into the output buffer.  If this      character fills the output buffer, this macro jumps to the label      TOFULL.  We use this rather ugly approach because we need to      handle two different termination conditions: EOF on the input      stream, and a full output buffer.  It would be simpler if we      always read in the entire input stream before processing it, but      I don't want to make such a significant change to the assembler's      memory usage.  */
define|#
directive|define
name|PUT
parameter_list|(
name|pch
parameter_list|)
define|\
value|do						\     {						\       *to++ = (pch);				\       if (to>= toend)				\ 	goto tofull;				\     }						\   while (0)
if|if
condition|(
name|saved_input
operator|!=
name|NULL
condition|)
block|{
name|from
operator|=
name|saved_input
expr_stmt|;
name|fromend
operator|=
name|from
operator|+
name|saved_input_len
expr_stmt|;
block|}
else|else
block|{
name|fromlen
operator|=
call|(
modifier|*
name|get
call|)
argument_list|(
name|input_buffer
argument_list|,
sizeof|sizeof
name|input_buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|fromlen
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|from
operator|=
name|input_buffer
expr_stmt|;
name|fromend
operator|=
name|from
operator|+
name|fromlen
expr_stmt|;
block|}
while|while
condition|(
literal|1
condition|)
block|{
comment|/* The cases in this switch end with continue, in order to 	 branch back to the top of this while loop and generate the 	 next output character in the appropriate state.  */
switch|switch
condition|(
name|state
condition|)
block|{
case|case
operator|-
literal|1
case|:
name|ch
operator|=
operator|*
name|out_string
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|out_string
operator|==
literal|'\0'
condition|)
block|{
name|state
operator|=
name|old_state
expr_stmt|;
name|old_state
operator|=
literal|3
expr_stmt|;
block|}
name|PUT
argument_list|(
name|ch
argument_list|)
expr_stmt|;
continue|continue;
case|case
operator|-
literal|2
case|:
for|for
control|(
init|;
condition|;
control|)
block|{
do|do
block|{
name|ch
operator|=
name|GET
argument_list|()
expr_stmt|;
if|if
condition|(
name|ch
operator|==
name|EOF
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"end of file in comment"
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|fromeof
goto|;
block|}
if|if
condition|(
name|ch
operator|==
literal|'\n'
condition|)
name|PUT
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|ch
operator|!=
literal|'*'
condition|)
do|;
while|while
condition|(
operator|(
name|ch
operator|=
name|GET
argument_list|()
operator|)
operator|==
literal|'*'
condition|)
empty_stmt|;
if|if
condition|(
name|ch
operator|==
name|EOF
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"end of file in comment"
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|fromeof
goto|;
block|}
if|if
condition|(
name|ch
operator|==
literal|'/'
condition|)
break|break;
name|UNGET
argument_list|(
name|ch
argument_list|)
expr_stmt|;
block|}
name|state
operator|=
name|old_state
expr_stmt|;
name|UNGET
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
continue|continue;
case|case
literal|4
case|:
name|ch
operator|=
name|GET
argument_list|()
expr_stmt|;
if|if
condition|(
name|ch
operator|==
name|EOF
condition|)
goto|goto
name|fromeof
goto|;
elseif|else
if|if
condition|(
name|ch
operator|>=
literal|'0'
operator|&&
name|ch
operator|<=
literal|'9'
condition|)
name|PUT
argument_list|(
name|ch
argument_list|)
expr_stmt|;
else|else
block|{
while|while
condition|(
name|ch
operator|!=
name|EOF
operator|&&
name|IS_WHITESPACE
argument_list|(
name|ch
argument_list|)
condition|)
name|ch
operator|=
name|GET
argument_list|()
expr_stmt|;
if|if
condition|(
name|ch
operator|==
literal|'"'
condition|)
block|{
name|quotechar
operator|=
name|ch
expr_stmt|;
name|state
operator|=
literal|5
expr_stmt|;
name|old_state
operator|=
literal|3
expr_stmt|;
name|PUT
argument_list|(
name|ch
argument_list|)
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
name|ch
operator|!=
name|EOF
operator|&&
name|ch
operator|!=
literal|'\n'
condition|)
name|ch
operator|=
name|GET
argument_list|()
expr_stmt|;
name|state
operator|=
literal|0
expr_stmt|;
name|PUT
argument_list|(
name|ch
argument_list|)
expr_stmt|;
block|}
block|}
continue|continue;
case|case
literal|5
case|:
comment|/* We are going to copy everything up to a quote character, 	     with special handling for a backslash.  We try to 	     optimize the copying in the simple case without using the 	     GET and PUT macros.  */
block|{
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|len
decl_stmt|;
for|for
control|(
name|s
operator|=
name|from
init|;
name|s
operator|<
name|fromend
condition|;
name|s
operator|++
control|)
block|{
name|ch
operator|=
operator|*
name|s
expr_stmt|;
if|if
condition|(
name|ch
operator|==
literal|'\\'
operator|||
name|ch
operator|==
name|quotechar
operator|||
name|ch
operator|==
literal|'\n'
condition|)
break|break;
block|}
name|len
operator|=
name|s
operator|-
name|from
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|toend
operator|-
name|to
condition|)
name|len
operator|=
name|toend
operator|-
name|to
expr_stmt|;
if|if
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|memcpy
argument_list|(
name|to
argument_list|,
name|from
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|to
operator|+=
name|len
expr_stmt|;
name|from
operator|+=
name|len
expr_stmt|;
if|if
condition|(
name|to
operator|>=
name|toend
condition|)
goto|goto
name|tofull
goto|;
block|}
block|}
name|ch
operator|=
name|GET
argument_list|()
expr_stmt|;
if|if
condition|(
name|ch
operator|==
name|EOF
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"end of file in string; '%c' inserted"
argument_list|)
argument_list|,
name|quotechar
argument_list|)
expr_stmt|;
name|state
operator|=
name|old_state
expr_stmt|;
name|UNGET
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|PUT
argument_list|(
name|quotechar
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ch
operator|==
name|quotechar
condition|)
block|{
name|state
operator|=
name|old_state
expr_stmt|;
name|PUT
argument_list|(
name|ch
argument_list|)
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|NO_STRING_ESCAPES
elseif|else
if|if
condition|(
name|ch
operator|==
literal|'\\'
condition|)
block|{
name|state
operator|=
literal|6
expr_stmt|;
name|PUT
argument_list|(
name|ch
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
elseif|else
if|if
condition|(
name|scrub_m68k_mri
operator|&&
name|ch
operator|==
literal|'\n'
condition|)
block|{
comment|/* Just quietly terminate the string.  This permits lines like 		   bne	label	loop if we haven't reach end yet.  */
name|state
operator|=
name|old_state
expr_stmt|;
name|UNGET
argument_list|(
name|ch
argument_list|)
expr_stmt|;
name|PUT
argument_list|(
literal|'\''
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|PUT
argument_list|(
name|ch
argument_list|)
expr_stmt|;
block|}
continue|continue;
case|case
literal|6
case|:
name|state
operator|=
literal|5
expr_stmt|;
name|ch
operator|=
name|GET
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|ch
condition|)
block|{
comment|/* Handle strings broken across lines, by turning '\n' into 		 '\\' and 'n'.  */
case|case
literal|'\n'
case|:
name|UNGET
argument_list|(
literal|'n'
argument_list|)
expr_stmt|;
name|add_newlines
operator|++
expr_stmt|;
name|PUT
argument_list|(
literal|'\\'
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|EOF
case|:
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"end of file in string; '%c' inserted"
argument_list|)
argument_list|,
name|quotechar
argument_list|)
expr_stmt|;
name|PUT
argument_list|(
name|quotechar
argument_list|)
expr_stmt|;
continue|continue;
case|case
literal|'"'
case|:
case|case
literal|'\\'
case|:
case|case
literal|'b'
case|:
case|case
literal|'f'
case|:
case|case
literal|'n'
case|:
case|case
literal|'r'
case|:
case|case
literal|'t'
case|:
case|case
literal|'v'
case|:
case|case
literal|'x'
case|:
case|case
literal|'X'
case|:
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
break|break;
default|default:
ifdef|#
directive|ifdef
name|ONLY_STANDARD_ESCAPES
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"unknown escape '\\%c' in string; ignored"
argument_list|)
argument_list|,
name|ch
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
name|PUT
argument_list|(
name|ch
argument_list|)
expr_stmt|;
continue|continue;
ifdef|#
directive|ifdef
name|DOUBLEBAR_PARALLEL
case|case
literal|13
case|:
name|ch
operator|=
name|GET
argument_list|()
expr_stmt|;
if|if
condition|(
name|ch
operator|!=
literal|'|'
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Reset back to state 1 and pretend that we are parsing a 	     line from just after the first white space.  */
name|state
operator|=
literal|1
expr_stmt|;
name|PUT
argument_list|(
literal|'|'
argument_list|)
expr_stmt|;
continue|continue;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TC_Z80
case|case
literal|16
case|:
comment|/* We have seen an 'a' at the start of a symbol, look for an 'f'.  */
name|ch
operator|=
name|GET
argument_list|()
expr_stmt|;
if|if
condition|(
name|ch
operator|==
literal|'f'
operator|||
name|ch
operator|==
literal|'F'
condition|)
block|{
name|state
operator|=
literal|17
expr_stmt|;
name|PUT
argument_list|(
name|ch
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|state
operator|=
literal|9
expr_stmt|;
break|break;
block|}
case|case
literal|17
case|:
comment|/* We have seen "af" at the start of a symbol, 	     a ' here is a part of that symbol.  */
name|ch
operator|=
name|GET
argument_list|()
expr_stmt|;
name|state
operator|=
literal|9
expr_stmt|;
if|if
condition|(
name|ch
operator|==
literal|'\''
condition|)
comment|/* Change to avoid warning about unclosed string.  */
name|PUT
argument_list|(
literal|'`'
argument_list|)
expr_stmt|;
else|else
name|UNGET
argument_list|(
name|ch
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
block|}
comment|/* OK, we are somewhere in states 0 through 4 or 9 through 11.  */
comment|/* flushchar: */
name|ch
operator|=
name|GET
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|TC_IA64
if|if
condition|(
name|ch
operator|==
literal|'('
operator|&&
operator|(
name|state
operator|==
literal|0
operator|||
name|state
operator|==
literal|1
operator|)
condition|)
block|{
name|state
operator|+=
literal|14
expr_stmt|;
name|PUT
argument_list|(
name|ch
argument_list|)
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|state
operator|==
literal|14
operator|||
name|state
operator|==
literal|15
condition|)
block|{
if|if
condition|(
name|ch
operator|==
literal|')'
condition|)
block|{
name|state
operator|-=
literal|14
expr_stmt|;
name|PUT
argument_list|(
name|ch
argument_list|)
expr_stmt|;
name|ch
operator|=
name|GET
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|PUT
argument_list|(
name|ch
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
endif|#
directive|endif
name|recycle
label|:
if|#
directive|if
name|defined
name|TC_ARM
operator|&&
name|defined
name|OBJ_ELF
comment|/* We need to watch out for .symver directives.  See the comment later 	 in this function.  */
if|if
condition|(
name|symver_state
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|state
operator|==
literal|0
operator|||
name|state
operator|==
literal|1
operator|)
operator|&&
name|ch
operator|==
name|symver_pseudo
index|[
literal|0
index|]
condition|)
name|symver_state
operator|=
name|symver_pseudo
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* We advance to the next state if we find the right 	     character.  */
if|if
condition|(
name|ch
operator|!=
literal|'\0'
operator|&&
operator|(
operator|*
name|symver_state
operator|==
name|ch
operator|)
condition|)
operator|++
name|symver_state
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|symver_state
operator|!=
literal|'\0'
condition|)
comment|/* We did not get the expected character, or we didn't 	       get a valid terminating character after seeing the 	       entire pseudo-op, so we must go back to the beginning.  */
name|symver_state
operator|=
name|NULL
expr_stmt|;
else|else
block|{
comment|/* We've read the entire pseudo-op.  If this is the end 		 of the line, go back to the beginning.  */
if|if
condition|(
name|IS_NEWLINE
argument_list|(
name|ch
argument_list|)
condition|)
name|symver_state
operator|=
name|NULL
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* TC_ARM&& OBJ_ELF */
ifdef|#
directive|ifdef
name|TC_M68K
comment|/* We want to have pseudo-ops which control whether we are in 	 MRI mode or not.  Unfortunately, since m68k MRI mode affects 	 the scrubber, that means that we need a special purpose 	 recognizer here.  */
if|if
condition|(
name|mri_state
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|state
operator|==
literal|0
operator|||
name|state
operator|==
literal|1
operator|)
operator|&&
name|ch
operator|==
name|mri_pseudo
index|[
literal|0
index|]
condition|)
name|mri_state
operator|=
name|mri_pseudo
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* We advance to the next state if we find the right 	     character, or if we need a space character and we get any 	     whitespace character, or if we need a '0' and we get a 	     '1' (this is so that we only need one state to handle 	     ``.mri 0'' and ``.mri 1'').  */
if|if
condition|(
name|ch
operator|!=
literal|'\0'
operator|&&
operator|(
operator|*
name|mri_state
operator|==
name|ch
operator|||
operator|(
operator|*
name|mri_state
operator|==
literal|' '
operator|&&
name|lex
index|[
name|ch
index|]
operator|==
name|LEX_IS_WHITESPACE
operator|)
operator|||
operator|(
operator|*
name|mri_state
operator|==
literal|'0'
operator|&&
name|ch
operator|==
literal|'1'
operator|)
operator|)
condition|)
block|{
name|mri_last_ch
operator|=
name|ch
expr_stmt|;
operator|++
name|mri_state
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|mri_state
operator|!=
literal|'\0'
operator|||
operator|(
name|lex
index|[
name|ch
index|]
operator|!=
name|LEX_IS_WHITESPACE
operator|&&
name|lex
index|[
name|ch
index|]
operator|!=
name|LEX_IS_NEWLINE
operator|)
condition|)
block|{
comment|/* We did not get the expected character, or we didn't 		 get a valid terminating character after seeing the 		 entire pseudo-op, so we must go back to the 		 beginning.  */
name|mri_state
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
comment|/* We've read the entire pseudo-op.  mips_last_ch is 		 either '0' or '1' indicating whether to enter or 		 leave MRI mode.  */
name|do_scrub_begin
argument_list|(
name|mri_last_ch
operator|==
literal|'1'
argument_list|)
expr_stmt|;
name|mri_state
operator|=
name|NULL
expr_stmt|;
comment|/* We continue handling the character as usual.  The 		 main gas reader must also handle the .mri pseudo-op 		 to control expression parsing and the like.  */
block|}
block|}
endif|#
directive|endif
if|if
condition|(
name|ch
operator|==
name|EOF
condition|)
block|{
if|if
condition|(
name|state
operator|!=
literal|0
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"end of file not at end of a line; newline inserted"
argument_list|)
argument_list|)
expr_stmt|;
name|state
operator|=
literal|0
expr_stmt|;
name|PUT
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
goto|goto
name|fromeof
goto|;
block|}
switch|switch
condition|(
name|lex
index|[
name|ch
index|]
condition|)
block|{
case|case
name|LEX_IS_WHITESPACE
case|:
do|do
block|{
name|ch
operator|=
name|GET
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
name|ch
operator|!=
name|EOF
operator|&&
name|IS_WHITESPACE
argument_list|(
name|ch
argument_list|)
condition|)
do|;
if|if
condition|(
name|ch
operator|==
name|EOF
condition|)
goto|goto
name|fromeof
goto|;
if|if
condition|(
name|state
operator|==
literal|0
condition|)
block|{
comment|/* Preserve a single whitespace character at the 		 beginning of a line.  */
name|state
operator|=
literal|1
expr_stmt|;
name|UNGET
argument_list|(
name|ch
argument_list|)
expr_stmt|;
name|PUT
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
break|break;
block|}
ifdef|#
directive|ifdef
name|KEEP_WHITE_AROUND_COLON
if|if
condition|(
name|lex
index|[
name|ch
index|]
operator|==
name|LEX_IS_COLON
condition|)
block|{
comment|/* Only keep this white if there's no white *after* the 		 colon.  */
name|ch2
operator|=
name|GET
argument_list|()
expr_stmt|;
name|UNGET
argument_list|(
name|ch2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|IS_WHITESPACE
argument_list|(
name|ch2
argument_list|)
condition|)
block|{
name|state
operator|=
literal|9
expr_stmt|;
name|UNGET
argument_list|(
name|ch
argument_list|)
expr_stmt|;
name|PUT
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
endif|#
directive|endif
if|if
condition|(
name|IS_COMMENT
argument_list|(
name|ch
argument_list|)
operator|||
name|ch
operator|==
literal|'/'
operator|||
name|IS_LINE_SEPARATOR
argument_list|(
name|ch
argument_list|)
operator|||
name|IS_PARALLEL_SEPARATOR
argument_list|(
name|ch
argument_list|)
condition|)
block|{
if|if
condition|(
name|scrub_m68k_mri
condition|)
block|{
comment|/* In MRI mode, we keep these spaces.  */
name|UNGET
argument_list|(
name|ch
argument_list|)
expr_stmt|;
name|PUT
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
break|break;
block|}
goto|goto
name|recycle
goto|;
block|}
comment|/* If we're in state 2 or 11, we've seen a non-white 	     character followed by whitespace.  If the next character 	     is ':', this is whitespace after a label name which we 	     normally must ignore.  In MRI mode, though, spaces are 	     not permitted between the label and the colon.  */
if|if
condition|(
operator|(
name|state
operator|==
literal|2
operator|||
name|state
operator|==
literal|11
operator|)
operator|&&
name|lex
index|[
name|ch
index|]
operator|==
name|LEX_IS_COLON
operator|&&
operator|!
name|scrub_m68k_mri
condition|)
block|{
name|state
operator|=
literal|1
expr_stmt|;
name|PUT
argument_list|(
name|ch
argument_list|)
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|state
condition|)
block|{
case|case
literal|1
case|:
comment|/* We can arrive here if we leave a leading whitespace 		 character at the beginning of a line.  */
goto|goto
name|recycle
goto|;
case|case
literal|2
case|:
name|state
operator|=
literal|3
expr_stmt|;
if|if
condition|(
name|to
operator|+
literal|1
operator|<
name|toend
condition|)
block|{
comment|/* Optimize common case by skipping UNGET/GET.  */
name|PUT
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
comment|/* Sp after opco */
goto|goto
name|recycle
goto|;
block|}
name|UNGET
argument_list|(
name|ch
argument_list|)
expr_stmt|;
name|PUT
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
if|if
condition|(
name|scrub_m68k_mri
condition|)
block|{
comment|/* In MRI mode, we keep these spaces.  */
name|UNGET
argument_list|(
name|ch
argument_list|)
expr_stmt|;
name|PUT
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
break|break;
block|}
goto|goto
name|recycle
goto|;
comment|/* Sp in operands */
case|case
literal|9
case|:
case|case
literal|10
case|:
if|if
condition|(
name|scrub_m68k_mri
condition|)
block|{
comment|/* In MRI mode, we keep these spaces.  */
name|state
operator|=
literal|3
expr_stmt|;
name|UNGET
argument_list|(
name|ch
argument_list|)
expr_stmt|;
name|PUT
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
break|break;
block|}
name|state
operator|=
literal|10
expr_stmt|;
comment|/* Sp after symbol char */
goto|goto
name|recycle
goto|;
case|case
literal|11
case|:
if|if
condition|(
name|LABELS_WITHOUT_COLONS
operator|||
name|flag_m68k_mri
condition|)
name|state
operator|=
literal|1
expr_stmt|;
else|else
block|{
comment|/* We know that ch is not ':', since we tested that 		     case above.  Therefore this is not a label, so it 		     must be the opcode, and we've just seen the 		     whitespace after it.  */
name|state
operator|=
literal|3
expr_stmt|;
block|}
name|UNGET
argument_list|(
name|ch
argument_list|)
expr_stmt|;
name|PUT
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
comment|/* Sp after label definition.  */
break|break;
default|default:
name|BAD_CASE
argument_list|(
name|state
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|LEX_IS_TWOCHAR_COMMENT_1ST
case|:
name|ch2
operator|=
name|GET
argument_list|()
expr_stmt|;
if|if
condition|(
name|ch2
operator|==
literal|'*'
condition|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
do|do
block|{
name|ch2
operator|=
name|GET
argument_list|()
expr_stmt|;
if|if
condition|(
name|ch2
operator|!=
name|EOF
operator|&&
name|IS_NEWLINE
argument_list|(
name|ch2
argument_list|)
condition|)
name|add_newlines
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|ch2
operator|!=
name|EOF
operator|&&
name|ch2
operator|!=
literal|'*'
condition|)
do|;
while|while
condition|(
name|ch2
operator|==
literal|'*'
condition|)
name|ch2
operator|=
name|GET
argument_list|()
expr_stmt|;
if|if
condition|(
name|ch2
operator|==
name|EOF
operator|||
name|ch2
operator|==
literal|'/'
condition|)
break|break;
comment|/* This UNGET will ensure that we count newlines 		     correctly.  */
name|UNGET
argument_list|(
name|ch2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ch2
operator|==
name|EOF
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"end of file in multiline comment"
argument_list|)
argument_list|)
expr_stmt|;
name|ch
operator|=
literal|' '
expr_stmt|;
goto|goto
name|recycle
goto|;
block|}
ifdef|#
directive|ifdef
name|DOUBLESLASH_LINE_COMMENTS
elseif|else
if|if
condition|(
name|ch2
operator|==
literal|'/'
condition|)
block|{
do|do
block|{
name|ch
operator|=
name|GET
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
name|ch
operator|!=
name|EOF
operator|&&
operator|!
name|IS_NEWLINE
argument_list|(
name|ch
argument_list|)
condition|)
do|;
if|if
condition|(
name|ch
operator|==
name|EOF
condition|)
name|as_warn
argument_list|(
literal|"end of file in comment; newline inserted"
argument_list|)
expr_stmt|;
name|state
operator|=
literal|0
expr_stmt|;
name|PUT
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
else|else
block|{
if|if
condition|(
name|ch2
operator|!=
name|EOF
condition|)
name|UNGET
argument_list|(
name|ch2
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
operator|==
literal|9
operator|||
name|state
operator|==
literal|10
condition|)
name|state
operator|=
literal|3
expr_stmt|;
name|PUT
argument_list|(
name|ch
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|LEX_IS_STRINGQUOTE
case|:
name|quotechar
operator|=
name|ch
expr_stmt|;
if|if
condition|(
name|state
operator|==
literal|10
condition|)
block|{
comment|/* Preserve the whitespace in foo "bar".  */
name|UNGET
argument_list|(
name|ch
argument_list|)
expr_stmt|;
name|state
operator|=
literal|3
expr_stmt|;
name|PUT
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
comment|/* PUT didn't jump out.  We could just break, but we 		 know what will happen, so optimize a bit.  */
name|ch
operator|=
name|GET
argument_list|()
expr_stmt|;
name|old_state
operator|=
literal|3
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|state
operator|==
literal|9
condition|)
name|old_state
operator|=
literal|3
expr_stmt|;
else|else
name|old_state
operator|=
name|state
expr_stmt|;
name|state
operator|=
literal|5
expr_stmt|;
name|PUT
argument_list|(
name|ch
argument_list|)
expr_stmt|;
break|break;
ifndef|#
directive|ifndef
name|IEEE_STYLE
case|case
name|LEX_IS_ONECHAR_QUOTE
case|:
if|if
condition|(
name|state
operator|==
literal|10
condition|)
block|{
comment|/* Preserve the whitespace in foo 'b'.  */
name|UNGET
argument_list|(
name|ch
argument_list|)
expr_stmt|;
name|state
operator|=
literal|3
expr_stmt|;
name|PUT
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
break|break;
block|}
name|ch
operator|=
name|GET
argument_list|()
expr_stmt|;
if|if
condition|(
name|ch
operator|==
name|EOF
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"end of file after a one-character quote; \\0 inserted"
argument_list|)
argument_list|)
expr_stmt|;
name|ch
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|ch
operator|==
literal|'\\'
condition|)
block|{
name|ch
operator|=
name|GET
argument_list|()
expr_stmt|;
if|if
condition|(
name|ch
operator|==
name|EOF
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"end of file in escape character"
argument_list|)
argument_list|)
expr_stmt|;
name|ch
operator|=
literal|'\\'
expr_stmt|;
block|}
else|else
name|ch
operator|=
name|process_escape
argument_list|(
name|ch
argument_list|)
expr_stmt|;
block|}
name|sprintf
argument_list|(
name|out_buf
argument_list|,
literal|"%d"
argument_list|,
operator|(
name|int
operator|)
operator|(
name|unsigned
name|char
operator|)
name|ch
argument_list|)
expr_stmt|;
comment|/* None of these 'x constants for us.  We want 'x'.  */
if|if
condition|(
operator|(
name|ch
operator|=
name|GET
argument_list|()
operator|)
operator|!=
literal|'\''
condition|)
block|{
ifdef|#
directive|ifdef
name|REQUIRE_CHAR_CLOSE_QUOTE
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"missing close quote; (assumed)"
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|ch
operator|!=
name|EOF
condition|)
name|UNGET
argument_list|(
name|ch
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|strlen
argument_list|(
name|out_buf
argument_list|)
operator|==
literal|1
condition|)
block|{
name|PUT
argument_list|(
name|out_buf
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|state
operator|==
literal|9
condition|)
name|old_state
operator|=
literal|3
expr_stmt|;
else|else
name|old_state
operator|=
name|state
expr_stmt|;
name|state
operator|=
operator|-
literal|1
expr_stmt|;
name|out_string
operator|=
name|out_buf
expr_stmt|;
name|PUT
argument_list|(
operator|*
name|out_string
operator|++
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|LEX_IS_COLON
case|:
ifdef|#
directive|ifdef
name|KEEP_WHITE_AROUND_COLON
name|state
operator|=
literal|9
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|state
operator|==
literal|9
operator|||
name|state
operator|==
literal|10
condition|)
name|state
operator|=
literal|3
expr_stmt|;
elseif|else
if|if
condition|(
name|state
operator|!=
literal|3
condition|)
name|state
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
name|PUT
argument_list|(
name|ch
argument_list|)
expr_stmt|;
break|break;
case|case
name|LEX_IS_NEWLINE
case|:
comment|/* Roll out a bunch of newlines from inside comments, etc.  */
if|if
condition|(
name|add_newlines
condition|)
block|{
operator|--
name|add_newlines
expr_stmt|;
name|UNGET
argument_list|(
name|ch
argument_list|)
expr_stmt|;
block|}
comment|/* Fall through.  */
case|case
name|LEX_IS_LINE_SEPARATOR
case|:
name|state
operator|=
literal|0
expr_stmt|;
name|PUT
argument_list|(
name|ch
argument_list|)
expr_stmt|;
break|break;
case|case
name|LEX_IS_PARALLEL_SEPARATOR
case|:
name|state
operator|=
literal|1
expr_stmt|;
name|PUT
argument_list|(
name|ch
argument_list|)
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|TC_V850
case|case
name|LEX_IS_DOUBLEDASH_1ST
case|:
name|ch2
operator|=
name|GET
argument_list|()
expr_stmt|;
if|if
condition|(
name|ch2
operator|!=
literal|'-'
condition|)
block|{
name|UNGET
argument_list|(
name|ch2
argument_list|)
expr_stmt|;
goto|goto
name|de_fault
goto|;
block|}
comment|/* Read and skip to end of line.  */
do|do
block|{
name|ch
operator|=
name|GET
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
name|ch
operator|!=
name|EOF
operator|&&
name|ch
operator|!=
literal|'\n'
condition|)
do|;
if|if
condition|(
name|ch
operator|==
name|EOF
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"end of file in comment; newline inserted"
argument_list|)
argument_list|)
expr_stmt|;
name|state
operator|=
literal|0
expr_stmt|;
name|PUT
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DOUBLEBAR_PARALLEL
case|case
name|LEX_IS_DOUBLEBAR_1ST
case|:
name|ch2
operator|=
name|GET
argument_list|()
expr_stmt|;
name|UNGET
argument_list|(
name|ch2
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch2
operator|!=
literal|'|'
condition|)
goto|goto
name|de_fault
goto|;
comment|/* Handle '||' in two states as invoking PUT twice might 	     result in the first one jumping out of this loop.  We'd 	     then lose track of the state and one '|' char.  */
name|state
operator|=
literal|13
expr_stmt|;
name|PUT
argument_list|(
literal|'|'
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|LEX_IS_LINE_COMMENT_START
case|:
comment|/* FIXME-someday: The two character comment stuff was badly 	     thought out.  On i386, we want '/' as line comment start 	     AND we want C style comments.  hence this hack.  The 	     whole lexical process should be reworked.  xoxorich.  */
if|if
condition|(
name|ch
operator|==
literal|'/'
condition|)
block|{
name|ch2
operator|=
name|GET
argument_list|()
expr_stmt|;
if|if
condition|(
name|ch2
operator|==
literal|'*'
condition|)
block|{
name|old_state
operator|=
literal|3
expr_stmt|;
name|state
operator|=
operator|-
literal|2
expr_stmt|;
break|break;
block|}
else|else
block|{
name|UNGET
argument_list|(
name|ch2
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|state
operator|==
literal|0
operator|||
name|state
operator|==
literal|1
condition|)
comment|/* Only comment at start of line.  */
block|{
name|int
name|startch
decl_stmt|;
name|startch
operator|=
name|ch
expr_stmt|;
do|do
block|{
name|ch
operator|=
name|GET
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
name|ch
operator|!=
name|EOF
operator|&&
name|IS_WHITESPACE
argument_list|(
name|ch
argument_list|)
condition|)
do|;
if|if
condition|(
name|ch
operator|==
name|EOF
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"end of file in comment; newline inserted"
argument_list|)
argument_list|)
expr_stmt|;
name|PUT
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ch
operator|<
literal|'0'
operator|||
name|ch
operator|>
literal|'9'
operator|||
name|state
operator|!=
literal|0
operator|||
name|startch
operator|!=
literal|'#'
condition|)
block|{
comment|/* Not a cpp line.  */
while|while
condition|(
name|ch
operator|!=
name|EOF
operator|&&
operator|!
name|IS_NEWLINE
argument_list|(
name|ch
argument_list|)
condition|)
name|ch
operator|=
name|GET
argument_list|()
expr_stmt|;
if|if
condition|(
name|ch
operator|==
name|EOF
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"end of file in comment; newline inserted"
argument_list|)
argument_list|)
expr_stmt|;
name|state
operator|=
literal|0
expr_stmt|;
name|PUT
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Looks like `# 123 "filename"' from cpp.  */
name|UNGET
argument_list|(
name|ch
argument_list|)
expr_stmt|;
name|old_state
operator|=
literal|4
expr_stmt|;
name|state
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|scrub_m68k_mri
condition|)
name|out_string
operator|=
literal|"\tlinefile "
expr_stmt|;
else|else
name|out_string
operator|=
literal|"\t.linefile "
expr_stmt|;
name|PUT
argument_list|(
operator|*
name|out_string
operator|++
argument_list|)
expr_stmt|;
break|break;
block|}
ifdef|#
directive|ifdef
name|TC_D10V
comment|/* All insns end in a char for which LEX_IS_SYMBOL_COMPONENT is true. 	     Trap is the only short insn that has a first operand that is 	     neither register nor label. 	     We must prevent exef0f ||trap #1 to degenerate to exef0f ||trap#1 . 	     We can't make '#' LEX_IS_SYMBOL_COMPONENT because it is 	     already LEX_IS_LINE_COMMENT_START.  However, it is the 	     only character in line_comment_chars for d10v, hence we 	     can recognize it as such.  */
comment|/* An alternative approach would be to reset the state to 1 when 	     we see '||', '<'- or '->', but that seems to be overkill.  */
if|if
condition|(
name|state
operator|==
literal|10
condition|)
name|PUT
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* We have a line comment character which is not at the 	     start of a line.  If this is also a normal comment 	     character, fall through.  Otherwise treat it as a default 	     character.  */
if|if
condition|(
name|strchr
argument_list|(
name|tc_comment_chars
argument_list|,
name|ch
argument_list|)
operator|==
name|NULL
operator|&&
operator|(
operator|!
name|scrub_m68k_mri
operator|||
operator|(
name|ch
operator|!=
literal|'!'
operator|&&
name|ch
operator|!=
literal|'*'
operator|)
operator|)
condition|)
goto|goto
name|de_fault
goto|;
if|if
condition|(
name|scrub_m68k_mri
operator|&&
operator|(
name|ch
operator|==
literal|'!'
operator|||
name|ch
operator|==
literal|'*'
operator|||
name|ch
operator|==
literal|'#'
operator|)
operator|&&
name|state
operator|!=
literal|1
operator|&&
name|state
operator|!=
literal|10
condition|)
goto|goto
name|de_fault
goto|;
comment|/* Fall through.  */
case|case
name|LEX_IS_COMMENT_START
case|:
if|#
directive|if
name|defined
name|TC_ARM
operator|&&
name|defined
name|OBJ_ELF
comment|/* On the ARM, `@' is the comment character. 	     Unfortunately this is also a special character in ELF .symver 	     directives (and .type, though we deal with those another way). 	     So we check if this line is such a directive, and treat 	     the character as default if so.  This is a hack.  */
if|if
condition|(
operator|(
name|symver_state
operator|!=
name|NULL
operator|)
operator|&&
operator|(
operator|*
name|symver_state
operator|==
literal|0
operator|)
condition|)
goto|goto
name|de_fault
goto|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TC_ARM
comment|/* For the ARM, care is needed not to damage occurrences of \@ 	     by stripping the @ onwards.  Yuck.  */
if|if
condition|(
name|to
operator|>
name|tostart
operator|&&
operator|*
operator|(
name|to
operator|-
literal|1
operator|)
operator|==
literal|'\\'
condition|)
comment|/* Do not treat the @ as a start-of-comment.  */
goto|goto
name|de_fault
goto|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|WARN_COMMENTS
if|if
condition|(
operator|!
name|found_comment
condition|)
name|as_where
argument_list|(
operator|&
name|found_comment_file
argument_list|,
operator|&
name|found_comment
argument_list|)
expr_stmt|;
endif|#
directive|endif
do|do
block|{
name|ch
operator|=
name|GET
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
name|ch
operator|!=
name|EOF
operator|&&
operator|!
name|IS_NEWLINE
argument_list|(
name|ch
argument_list|)
condition|)
do|;
if|if
condition|(
name|ch
operator|==
name|EOF
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"end of file in comment; newline inserted"
argument_list|)
argument_list|)
expr_stmt|;
name|state
operator|=
literal|0
expr_stmt|;
name|PUT
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
break|break;
case|case
name|LEX_IS_SYMBOL_COMPONENT
case|:
if|if
condition|(
name|state
operator|==
literal|10
condition|)
block|{
comment|/* This is a symbol character following another symbol 		 character, with whitespace in between.  We skipped 		 the whitespace earlier, so output it now.  */
name|UNGET
argument_list|(
name|ch
argument_list|)
expr_stmt|;
name|state
operator|=
literal|3
expr_stmt|;
name|PUT
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
break|break;
block|}
ifdef|#
directive|ifdef
name|TC_Z80
comment|/* "af'" is a symbol containing '\''.  */
if|if
condition|(
name|state
operator|==
literal|3
operator|&&
operator|(
name|ch
operator|==
literal|'a'
operator|||
name|ch
operator|==
literal|'A'
operator|)
condition|)
block|{
name|state
operator|=
literal|16
expr_stmt|;
name|PUT
argument_list|(
name|ch
argument_list|)
expr_stmt|;
name|ch
operator|=
name|GET
argument_list|()
expr_stmt|;
if|if
condition|(
name|ch
operator|==
literal|'f'
operator|||
name|ch
operator|==
literal|'F'
condition|)
block|{
name|state
operator|=
literal|17
expr_stmt|;
name|PUT
argument_list|(
name|ch
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
block|{
name|state
operator|=
literal|9
expr_stmt|;
if|if
condition|(
operator|!
name|IS_SYMBOL_COMPONENT
argument_list|(
name|ch
argument_list|)
condition|)
block|{
name|UNGET
argument_list|(
name|ch
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
endif|#
directive|endif
if|if
condition|(
name|state
operator|==
literal|3
condition|)
name|state
operator|=
literal|9
expr_stmt|;
comment|/* This is a common case.  Quickly copy CH and all the 	     following symbol component or normal characters.  */
if|if
condition|(
name|to
operator|+
literal|1
operator|<
name|toend
operator|&&
name|mri_state
operator|==
name|NULL
if|#
directive|if
name|defined
name|TC_ARM
operator|&&
name|defined
name|OBJ_ELF
operator|&&
name|symver_state
operator|==
name|NULL
endif|#
directive|endif
condition|)
block|{
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|len
decl_stmt|;
for|for
control|(
name|s
operator|=
name|from
init|;
name|s
operator|<
name|fromend
condition|;
name|s
operator|++
control|)
block|{
name|int
name|type
decl_stmt|;
name|ch2
operator|=
operator|*
operator|(
name|unsigned
name|char
operator|*
operator|)
name|s
expr_stmt|;
name|type
operator|=
name|lex
index|[
name|ch2
index|]
expr_stmt|;
if|if
condition|(
name|type
operator|!=
literal|0
operator|&&
name|type
operator|!=
name|LEX_IS_SYMBOL_COMPONENT
condition|)
break|break;
block|}
if|if
condition|(
name|s
operator|>
name|from
condition|)
comment|/* Handle the last character normally, for 		   simplicity.  */
operator|--
name|s
expr_stmt|;
name|len
operator|=
name|s
operator|-
name|from
expr_stmt|;
if|if
condition|(
name|len
operator|>
operator|(
name|toend
operator|-
name|to
operator|)
operator|-
literal|1
condition|)
name|len
operator|=
operator|(
name|toend
operator|-
name|to
operator|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|PUT
argument_list|(
name|ch
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|to
argument_list|,
name|from
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|to
operator|+=
name|len
expr_stmt|;
name|from
operator|+=
name|len
expr_stmt|;
if|if
condition|(
name|to
operator|>=
name|toend
condition|)
goto|goto
name|tofull
goto|;
name|ch
operator|=
name|GET
argument_list|()
expr_stmt|;
block|}
block|}
comment|/* Fall through.  */
default|default:
name|de_fault
label|:
comment|/* Some relatively `normal' character.  */
if|if
condition|(
name|state
operator|==
literal|0
condition|)
block|{
name|state
operator|=
literal|11
expr_stmt|;
comment|/* Now seeing label definition.  */
block|}
elseif|else
if|if
condition|(
name|state
operator|==
literal|1
condition|)
block|{
name|state
operator|=
literal|2
expr_stmt|;
comment|/* Ditto.  */
block|}
elseif|else
if|if
condition|(
name|state
operator|==
literal|9
condition|)
block|{
if|if
condition|(
operator|!
name|IS_SYMBOL_COMPONENT
argument_list|(
name|ch
argument_list|)
condition|)
name|state
operator|=
literal|3
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|state
operator|==
literal|10
condition|)
block|{
if|if
condition|(
name|ch
operator|==
literal|'\\'
condition|)
block|{
comment|/* Special handling for backslash: a backslash may 		     be the beginning of a formal parameter (of a 		     macro) following another symbol character, with 		     whitespace in between.  If that is the case, we 		     output a space before the parameter.  Strictly 		     speaking, correct handling depends upon what the 		     macro parameter expands into; if the parameter 		     expands into something which does not start with 		     an operand character, then we don't want to keep 		     the space.  We don't have enough information to 		     make the right choice, so here we are making the 		     choice which is more likely to be correct.  */
if|if
condition|(
name|to
operator|+
literal|1
operator|>=
name|toend
condition|)
block|{
comment|/* If we're near the end of the buffer, save the 		         character for the next time round.  Otherwise 		         we'll lose our state.  */
name|UNGET
argument_list|(
name|ch
argument_list|)
expr_stmt|;
goto|goto
name|tofull
goto|;
block|}
operator|*
name|to
operator|++
operator|=
literal|' '
expr_stmt|;
block|}
name|state
operator|=
literal|3
expr_stmt|;
block|}
name|PUT
argument_list|(
name|ch
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|/*NOTREACHED*/
name|fromeof
label|:
comment|/* We have reached the end of the input.  */
return|return
name|to
operator|-
name|tostart
return|;
name|tofull
label|:
comment|/* The output buffer is full.  Save any input we have not yet      processed.  */
if|if
condition|(
name|fromend
operator|>
name|from
condition|)
block|{
name|saved_input
operator|=
name|from
expr_stmt|;
name|saved_input_len
operator|=
name|fromend
operator|-
name|from
expr_stmt|;
block|}
else|else
name|saved_input
operator|=
name|NULL
expr_stmt|;
return|return
name|to
operator|-
name|tostart
return|;
block|}
end_function

end_unit

