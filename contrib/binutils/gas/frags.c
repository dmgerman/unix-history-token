begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* frags.c - manage frags -    Copyright (C) 1987, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 2000    Free Software Foundation, Inc.     This file is part of GAS, the GNU Assembler.     GAS is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     GAS is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with GAS; see the file COPYING.  If not, write to the Free    Software Foundation, 59 Temple Place - Suite 330, Boston, MA    02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"as.h"
end_include

begin_include
include|#
directive|include
file|"subsegs.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_decl_stmt
specifier|extern
name|fragS
name|zero_address_frag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|fragS
name|bss_address_frag
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Initialization for frag routines.  */
end_comment

begin_function
name|void
name|frag_init
parameter_list|()
block|{
name|zero_address_frag
operator|.
name|fr_type
operator|=
name|rs_fill
expr_stmt|;
name|bss_address_frag
operator|.
name|fr_type
operator|=
name|rs_fill
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Allocate a frag on the specified obstack.    Call this routine from everywhere else, so that all the weird alignment    hackery can be done in just one place.  */
end_comment

begin_function
name|fragS
modifier|*
name|frag_alloc
parameter_list|(
name|ob
parameter_list|)
name|struct
name|obstack
modifier|*
name|ob
decl_stmt|;
block|{
name|fragS
modifier|*
name|ptr
decl_stmt|;
name|int
name|oalign
decl_stmt|;
operator|(
name|void
operator|)
name|obstack_alloc
argument_list|(
name|ob
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|oalign
operator|=
name|obstack_alignment_mask
argument_list|(
name|ob
argument_list|)
expr_stmt|;
name|obstack_alignment_mask
argument_list|(
name|ob
argument_list|)
operator|=
literal|0
expr_stmt|;
name|ptr
operator|=
operator|(
name|fragS
operator|*
operator|)
name|obstack_alloc
argument_list|(
name|ob
argument_list|,
name|SIZEOF_STRUCT_FRAG
argument_list|)
expr_stmt|;
name|obstack_alignment_mask
argument_list|(
name|ob
argument_list|)
operator|=
name|oalign
expr_stmt|;
name|memset
argument_list|(
name|ptr
argument_list|,
literal|0
argument_list|,
name|SIZEOF_STRUCT_FRAG
argument_list|)
expr_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *			frag_grow()  *  * Try to augment current frag by nchars chars.  * If there is no room, close of the current frag with a ".fill 0"  * and begin a new frag. Unless the new frag has nchars chars available  * do not return. Do not set up any fields of *now_frag.  */
end_comment

begin_function
name|void
name|frag_grow
parameter_list|(
name|nchars
parameter_list|)
name|unsigned
name|int
name|nchars
decl_stmt|;
block|{
if|if
condition|(
name|obstack_room
argument_list|(
operator|&
name|frchain_now
operator|->
name|frch_obstack
argument_list|)
operator|<
name|nchars
condition|)
block|{
name|unsigned
name|int
name|n
decl_stmt|;
name|long
name|oldc
decl_stmt|;
name|frag_wane
argument_list|(
name|frag_now
argument_list|)
expr_stmt|;
name|frag_new
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|oldc
operator|=
name|frchain_now
operator|->
name|frch_obstack
operator|.
name|chunk_size
expr_stmt|;
name|frchain_now
operator|->
name|frch_obstack
operator|.
name|chunk_size
operator|=
literal|2
operator|*
name|nchars
operator|+
name|SIZEOF_STRUCT_FRAG
expr_stmt|;
while|while
condition|(
operator|(
name|n
operator|=
name|obstack_room
argument_list|(
operator|&
name|frchain_now
operator|->
name|frch_obstack
argument_list|)
operator|)
operator|<
name|nchars
condition|)
block|{
name|frag_wane
argument_list|(
name|frag_now
argument_list|)
expr_stmt|;
name|frag_new
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|frchain_now
operator|->
name|frch_obstack
operator|.
name|chunk_size
operator|=
name|oldc
expr_stmt|;
block|}
if|if
condition|(
name|obstack_room
argument_list|(
operator|&
name|frchain_now
operator|->
name|frch_obstack
argument_list|)
operator|<
name|nchars
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"Can't extend frag %d. chars"
argument_list|)
argument_list|,
name|nchars
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *			frag_new()  *  * Call this to close off a completed frag, and start up a new (empty)  * frag, in the same subsegment as the old frag.  * [frchain_now remains the same but frag_now is updated.]  * Because this calculates the correct value of fr_fix by  * looking at the obstack 'frags', it needs to know how many  * characters at the end of the old frag belong to the maximal  * variable part;  The rest must belong to fr_fix.  * It doesn't actually set up the old frag's fr_var.  You may have  * set fr_var == 1, but allocated 10 chars to the end of the frag;  * In this case you pass old_frags_var_max_size == 10.  * In fact, you may use fr_var for something totally unrelated to the  * size of the variable part of the frag;  None of the generic frag  * handling code makes use of fr_var.  *  * Make a new frag, initialising some components. Link new frag at end  * of frchain_now.  */
end_comment

begin_function
name|void
name|frag_new
parameter_list|(
name|old_frags_var_max_size
parameter_list|)
comment|/* Number of chars (already allocated on obstack frags) in 	variable_length part of frag. */
name|int
name|old_frags_var_max_size
decl_stmt|;
block|{
name|fragS
modifier|*
name|former_last_fragP
decl_stmt|;
name|frchainS
modifier|*
name|frchP
decl_stmt|;
name|assert
argument_list|(
name|frchain_now
operator|->
name|frch_last
operator|==
name|frag_now
argument_list|)
expr_stmt|;
comment|/* Fix up old frag's fr_fix.  */
name|frag_now
operator|->
name|fr_fix
operator|=
name|frag_now_fix_octets
argument_list|()
operator|-
name|old_frags_var_max_size
expr_stmt|;
comment|/* Make sure its type is valid.  */
name|assert
argument_list|(
name|frag_now
operator|->
name|fr_type
operator|!=
literal|0
argument_list|)
expr_stmt|;
comment|/* This will align the obstack so the next struct we allocate on it      will begin at a correct boundary. */
name|obstack_finish
argument_list|(
operator|&
name|frchain_now
operator|->
name|frch_obstack
argument_list|)
expr_stmt|;
name|frchP
operator|=
name|frchain_now
expr_stmt|;
name|know
argument_list|(
name|frchP
argument_list|)
expr_stmt|;
name|former_last_fragP
operator|=
name|frchP
operator|->
name|frch_last
expr_stmt|;
name|assert
argument_list|(
name|former_last_fragP
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|former_last_fragP
operator|==
name|frag_now
argument_list|)
expr_stmt|;
name|frag_now
operator|=
name|frag_alloc
argument_list|(
operator|&
name|frchP
operator|->
name|frch_obstack
argument_list|)
expr_stmt|;
name|as_where
argument_list|(
operator|&
name|frag_now
operator|->
name|fr_file
argument_list|,
operator|&
name|frag_now
operator|->
name|fr_line
argument_list|)
expr_stmt|;
comment|/* Generally, frag_now->points to an address rounded up to next      alignment.  However, characters will add to obstack frags      IMMEDIATELY after the struct frag, even if they are not starting      at an alignment address. */
name|former_last_fragP
operator|->
name|fr_next
operator|=
name|frag_now
expr_stmt|;
name|frchP
operator|->
name|frch_last
operator|=
name|frag_now
expr_stmt|;
ifndef|#
directive|ifndef
name|NO_LISTING
block|{
specifier|extern
name|struct
name|list_info_struct
modifier|*
name|listing_tail
decl_stmt|;
name|frag_now
operator|->
name|line
operator|=
name|listing_tail
expr_stmt|;
block|}
endif|#
directive|endif
name|assert
argument_list|(
name|frchain_now
operator|->
name|frch_last
operator|==
name|frag_now
argument_list|)
expr_stmt|;
name|frag_now
operator|->
name|fr_next
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* frag_new() */
end_comment

begin_escape
end_escape

begin_comment
comment|/*  *			frag_more()  *  * Start a new frag unless we have n more chars of room in the current frag.  * Close off the old frag with a .fill 0.  *  * Return the address of the 1st char to write into. Advance  * frag_now_growth past the new chars.  */
end_comment

begin_function
name|char
modifier|*
name|frag_more
parameter_list|(
name|nchars
parameter_list|)
name|int
name|nchars
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|retval
decl_stmt|;
if|if
condition|(
name|now_seg
operator|==
name|absolute_section
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"attempt to allocate data in absolute section"
argument_list|)
argument_list|)
expr_stmt|;
name|subseg_set
argument_list|(
name|text_section
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mri_common_symbol
operator|!=
name|NULL
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"attempt to allocate data in common section"
argument_list|)
argument_list|)
expr_stmt|;
name|mri_common_symbol
operator|=
name|NULL
expr_stmt|;
block|}
name|frag_grow
argument_list|(
name|nchars
argument_list|)
expr_stmt|;
name|retval
operator|=
name|obstack_next_free
argument_list|(
operator|&
name|frchain_now
operator|->
name|frch_obstack
argument_list|)
expr_stmt|;
name|obstack_blank_fast
argument_list|(
operator|&
name|frchain_now
operator|->
name|frch_obstack
argument_list|,
name|nchars
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_comment
comment|/* frag_more() */
end_comment

begin_escape
end_escape

begin_comment
comment|/*  *			frag_var()  *  * Start a new frag unless we have max_chars more chars of room in the current frag.  * Close off the old frag with a .fill 0.  *  * Set up a machine_dependent relaxable frag, then start a new frag.  * Return the address of the 1st char of the var part of the old frag  * to write into.  */
end_comment

begin_function
name|char
modifier|*
name|frag_var
parameter_list|(
name|type
parameter_list|,
name|max_chars
parameter_list|,
name|var
parameter_list|,
name|subtype
parameter_list|,
name|symbol
parameter_list|,
name|offset
parameter_list|,
name|opcode
parameter_list|)
name|relax_stateT
name|type
decl_stmt|;
name|int
name|max_chars
decl_stmt|;
name|int
name|var
decl_stmt|;
name|relax_substateT
name|subtype
decl_stmt|;
name|symbolS
modifier|*
name|symbol
decl_stmt|;
name|offsetT
name|offset
decl_stmt|;
name|char
modifier|*
name|opcode
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|retval
decl_stmt|;
name|frag_grow
argument_list|(
name|max_chars
argument_list|)
expr_stmt|;
name|retval
operator|=
name|obstack_next_free
argument_list|(
operator|&
name|frchain_now
operator|->
name|frch_obstack
argument_list|)
expr_stmt|;
name|obstack_blank_fast
argument_list|(
operator|&
name|frchain_now
operator|->
name|frch_obstack
argument_list|,
name|max_chars
argument_list|)
expr_stmt|;
name|frag_now
operator|->
name|fr_var
operator|=
name|var
expr_stmt|;
name|frag_now
operator|->
name|fr_type
operator|=
name|type
expr_stmt|;
name|frag_now
operator|->
name|fr_subtype
operator|=
name|subtype
expr_stmt|;
name|frag_now
operator|->
name|fr_symbol
operator|=
name|symbol
expr_stmt|;
name|frag_now
operator|->
name|fr_offset
operator|=
name|offset
expr_stmt|;
name|frag_now
operator|->
name|fr_opcode
operator|=
name|opcode
expr_stmt|;
ifdef|#
directive|ifdef
name|USING_CGEN
name|frag_now
operator|->
name|fr_cgen
operator|.
name|insn
operator|=
literal|0
expr_stmt|;
name|frag_now
operator|->
name|fr_cgen
operator|.
name|opindex
operator|=
literal|0
expr_stmt|;
name|frag_now
operator|->
name|fr_cgen
operator|.
name|opinfo
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TC_FRAG_INIT
name|TC_FRAG_INIT
argument_list|(
name|frag_now
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|as_where
argument_list|(
operator|&
name|frag_now
operator|->
name|fr_file
argument_list|,
operator|&
name|frag_now
operator|->
name|fr_line
argument_list|)
expr_stmt|;
name|frag_new
argument_list|(
name|max_chars
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *			frag_variant()  *  * OVE: This variant of frag_var assumes that space for the tail has been  *      allocated by caller.  *      No call to frag_grow is done.  */
end_comment

begin_function
name|char
modifier|*
name|frag_variant
parameter_list|(
name|type
parameter_list|,
name|max_chars
parameter_list|,
name|var
parameter_list|,
name|subtype
parameter_list|,
name|symbol
parameter_list|,
name|offset
parameter_list|,
name|opcode
parameter_list|)
name|relax_stateT
name|type
decl_stmt|;
name|int
name|max_chars
decl_stmt|;
name|int
name|var
decl_stmt|;
name|relax_substateT
name|subtype
decl_stmt|;
name|symbolS
modifier|*
name|symbol
decl_stmt|;
name|offsetT
name|offset
decl_stmt|;
name|char
modifier|*
name|opcode
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|retval
decl_stmt|;
name|retval
operator|=
name|obstack_next_free
argument_list|(
operator|&
name|frchain_now
operator|->
name|frch_obstack
argument_list|)
expr_stmt|;
name|frag_now
operator|->
name|fr_var
operator|=
name|var
expr_stmt|;
name|frag_now
operator|->
name|fr_type
operator|=
name|type
expr_stmt|;
name|frag_now
operator|->
name|fr_subtype
operator|=
name|subtype
expr_stmt|;
name|frag_now
operator|->
name|fr_symbol
operator|=
name|symbol
expr_stmt|;
name|frag_now
operator|->
name|fr_offset
operator|=
name|offset
expr_stmt|;
name|frag_now
operator|->
name|fr_opcode
operator|=
name|opcode
expr_stmt|;
ifdef|#
directive|ifdef
name|USING_CGEN
name|frag_now
operator|->
name|fr_cgen
operator|.
name|insn
operator|=
literal|0
expr_stmt|;
name|frag_now
operator|->
name|fr_cgen
operator|.
name|opindex
operator|=
literal|0
expr_stmt|;
name|frag_now
operator|->
name|fr_cgen
operator|.
name|opinfo
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TC_FRAG_INIT
name|TC_FRAG_INIT
argument_list|(
name|frag_now
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|as_where
argument_list|(
operator|&
name|frag_now
operator|->
name|fr_file
argument_list|,
operator|&
name|frag_now
operator|->
name|fr_line
argument_list|)
expr_stmt|;
name|frag_new
argument_list|(
name|max_chars
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_comment
comment|/* frag_variant() */
end_comment

begin_escape
end_escape

begin_comment
comment|/*  *			frag_wane()  *  * Reduce the variable end of a frag to a harmless state.  */
end_comment

begin_function
name|void
name|frag_wane
parameter_list|(
name|fragP
parameter_list|)
specifier|register
name|fragS
modifier|*
name|fragP
decl_stmt|;
block|{
name|fragP
operator|->
name|fr_type
operator|=
name|rs_fill
expr_stmt|;
name|fragP
operator|->
name|fr_offset
operator|=
literal|0
expr_stmt|;
name|fragP
operator|->
name|fr_var
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Make an alignment frag.  The size of this frag will be adjusted to    force the next frag to have the appropriate alignment.  ALIGNMENT    is the power of two to which to align.  FILL_CHARACTER is the    character to use to fill in any bytes which are skipped.  MAX is    the maximum number of characters to skip when doing the alignment,    or 0 if there is no maximum.  */
end_comment

begin_function
name|void
name|frag_align
parameter_list|(
name|alignment
parameter_list|,
name|fill_character
parameter_list|,
name|max
parameter_list|)
name|int
name|alignment
decl_stmt|;
name|int
name|fill_character
decl_stmt|;
name|int
name|max
decl_stmt|;
block|{
if|if
condition|(
name|now_seg
operator|==
name|absolute_section
condition|)
block|{
name|addressT
name|new_off
decl_stmt|;
name|new_off
operator|=
operator|(
operator|(
name|abs_section_offset
operator|+
name|alignment
operator|-
literal|1
operator|)
operator|&
operator|~
operator|(
operator|(
literal|1
operator|<<
name|alignment
operator|)
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|max
operator|==
literal|0
operator|||
name|new_off
operator|-
name|abs_section_offset
operator|<=
operator|(
name|addressT
operator|)
name|max
condition|)
name|abs_section_offset
operator|=
name|new_off
expr_stmt|;
block|}
else|else
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|frag_var
argument_list|(
name|rs_align
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
operator|(
name|relax_substateT
operator|)
name|max
argument_list|,
operator|(
name|symbolS
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|offsetT
operator|)
name|alignment
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
name|fill_character
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Make an alignment frag like frag_align, but fill with a repeating    pattern rather than a single byte.  ALIGNMENT is the power of two    to which to align.  FILL_PATTERN is the fill pattern to repeat in    the bytes which are skipped.  N_FILL is the number of bytes in    FILL_PATTERN.  MAX is the maximum number of characters to skip when    doing the alignment, or 0 if there is no maximum.  */
end_comment

begin_function
name|void
name|frag_align_pattern
parameter_list|(
name|alignment
parameter_list|,
name|fill_pattern
parameter_list|,
name|n_fill
parameter_list|,
name|max
parameter_list|)
name|int
name|alignment
decl_stmt|;
specifier|const
name|char
modifier|*
name|fill_pattern
decl_stmt|;
name|int
name|n_fill
decl_stmt|;
name|int
name|max
decl_stmt|;
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|frag_var
argument_list|(
name|rs_align
argument_list|,
name|n_fill
argument_list|,
name|n_fill
argument_list|,
operator|(
name|relax_substateT
operator|)
name|max
argument_list|,
operator|(
name|symbolS
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|offsetT
operator|)
name|alignment
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|p
argument_list|,
name|fill_pattern
argument_list|,
name|n_fill
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|addressT
name|frag_now_fix_octets
parameter_list|()
block|{
if|if
condition|(
name|now_seg
operator|==
name|absolute_section
condition|)
return|return
name|abs_section_offset
return|;
return|return
operator|(
operator|(
name|char
operator|*
operator|)
name|obstack_next_free
argument_list|(
operator|&
name|frchain_now
operator|->
name|frch_obstack
argument_list|)
operator|-
name|frag_now
operator|->
name|fr_literal
operator|)
return|;
block|}
end_function

begin_function
name|addressT
name|frag_now_fix
parameter_list|()
block|{
return|return
name|frag_now_fix_octets
argument_list|()
operator|/
name|OCTETS_PER_BYTE
return|;
block|}
end_function

begin_function
name|void
name|frag_append_1_char
parameter_list|(
name|datum
parameter_list|)
name|int
name|datum
decl_stmt|;
block|{
if|if
condition|(
name|obstack_room
argument_list|(
operator|&
name|frchain_now
operator|->
name|frch_obstack
argument_list|)
operator|<=
literal|1
condition|)
block|{
name|frag_wane
argument_list|(
name|frag_now
argument_list|)
expr_stmt|;
name|frag_new
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|obstack_1grow
argument_list|(
operator|&
name|frchain_now
operator|->
name|frch_obstack
argument_list|,
name|datum
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* end of frags.c */
end_comment

end_unit

