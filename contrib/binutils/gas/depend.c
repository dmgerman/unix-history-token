begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* depend.c - Handle dependency tracking.    Copyright 1997, 1998, 2000 Free Software Foundation, Inc.     This file is part of GAS, the GNU Assembler.     GAS is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     GAS is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with GAS; see the file COPYING.  If not, write to the Free    Software Foundation, 59 Temple Place - Suite 330, Boston, MA    02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"as.h"
end_include

begin_comment
comment|/* The file to write to, or NULL if no dependencies being kept.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|dep_file
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|dependency
block|{
name|char
modifier|*
name|file
decl_stmt|;
name|struct
name|dependency
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* All the files we depend on.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|dependency
modifier|*
name|dep_chain
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Current column in output file.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|column
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|quote_string_for_make
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|wrap_output
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|,
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of columns allowable.  */
end_comment

begin_define
define|#
directive|define
name|MAX_COLUMNS
value|72
end_define

begin_escape
end_escape

begin_comment
comment|/* Start saving dependencies, to be written to FILENAME.  If this is    never called, then dependency tracking is simply skipped.  */
end_comment

begin_function
name|void
name|start_dependencies
parameter_list|(
name|filename
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
block|{
name|dep_file
operator|=
name|filename
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Noticed a new filename, so try to register it.  */
end_comment

begin_function
name|void
name|register_dependency
parameter_list|(
name|filename
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
block|{
name|struct
name|dependency
modifier|*
name|dep
decl_stmt|;
if|if
condition|(
name|dep_file
operator|==
name|NULL
condition|)
return|return;
for|for
control|(
name|dep
operator|=
name|dep_chain
init|;
name|dep
operator|!=
name|NULL
condition|;
name|dep
operator|=
name|dep
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|filename
argument_list|,
name|dep
operator|->
name|file
argument_list|)
condition|)
return|return;
block|}
name|dep
operator|=
operator|(
expr|struct
name|dependency
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|dependency
argument_list|)
argument_list|)
expr_stmt|;
name|dep
operator|->
name|file
operator|=
name|xstrdup
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|dep
operator|->
name|next
operator|=
name|dep_chain
expr_stmt|;
name|dep_chain
operator|=
name|dep
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Quote a file name the way `make' wants it, and print it to FILE.    If FILE is NULL, do no printing, but return the length of the    quoted string.     This code is taken from gcc with only minor changes.  */
end_comment

begin_function
specifier|static
name|int
name|quote_string_for_make
parameter_list|(
name|file
parameter_list|,
name|src
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|char
modifier|*
name|src
decl_stmt|;
block|{
name|char
modifier|*
name|p
init|=
name|src
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|char
name|c
init|=
operator|*
name|p
operator|++
decl_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\0'
case|:
case|case
literal|' '
case|:
case|case
literal|'\t'
case|:
block|{
comment|/* GNU make uses a weird quoting scheme for white space. 	       A space or tab preceded by 2N+1 backslashes represents 	       N backslashes followed by space; a space or tab 	       preceded by 2N backslashes represents N backslashes at 	       the end of a file name; and backslashes in other 	       contexts should not be doubled.  */
name|char
modifier|*
name|q
decl_stmt|;
for|for
control|(
name|q
operator|=
name|p
operator|-
literal|1
init|;
name|src
operator|<
name|q
operator|&&
name|q
index|[
operator|-
literal|1
index|]
operator|==
literal|'\\'
condition|;
name|q
operator|--
control|)
block|{
if|if
condition|(
name|file
condition|)
name|putc
argument_list|(
literal|'\\'
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|c
condition|)
return|return
name|i
return|;
if|if
condition|(
name|file
condition|)
name|putc
argument_list|(
literal|'\\'
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
goto|goto
name|ordinary_char
goto|;
case|case
literal|'$'
case|:
if|if
condition|(
name|file
condition|)
name|putc
argument_list|(
name|c
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
comment|/* Fall through.  This can mishandle things like "$(" but 	     there's no easy fix.  */
default|default:
name|ordinary_char
label|:
comment|/* This can mishandle characters in the string "\0\n%*?[\\~"; 	     exactly which chars are mishandled depends on the `make' version. 	     We know of no portable solution for this; 	     even GNU make 3.76.1 doesn't solve the problem entirely. 	     (Also, '\0' is mishandled due to our calling conventions.)  */
if|if
condition|(
name|file
condition|)
name|putc
argument_list|(
name|c
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Append some output to the file, keeping track of columns and doing    wrapping as necessary.  */
end_comment

begin_function
specifier|static
name|void
name|wrap_output
parameter_list|(
name|f
parameter_list|,
name|string
parameter_list|,
name|spacer
parameter_list|)
name|FILE
modifier|*
name|f
decl_stmt|;
name|char
modifier|*
name|string
decl_stmt|;
name|int
name|spacer
decl_stmt|;
block|{
name|int
name|len
init|=
name|quote_string_for_make
argument_list|(
name|NULL
argument_list|,
name|string
argument_list|)
decl_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|column
operator|&&
operator|(
name|MAX_COLUMNS
operator|-
literal|1
comment|/* spacer */
operator|-
literal|2
comment|/* ` \'   */
operator|<
name|column
operator|+
name|len
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|f
argument_list|,
literal|" \\\n "
argument_list|)
expr_stmt|;
name|column
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|spacer
operator|==
literal|' '
condition|)
name|spacer
operator|=
literal|'\0'
expr_stmt|;
block|}
if|if
condition|(
name|spacer
operator|==
literal|' '
condition|)
block|{
name|putc
argument_list|(
name|spacer
argument_list|,
name|f
argument_list|)
expr_stmt|;
operator|++
name|column
expr_stmt|;
block|}
name|quote_string_for_make
argument_list|(
name|f
argument_list|,
name|string
argument_list|)
expr_stmt|;
name|column
operator|+=
name|len
expr_stmt|;
if|if
condition|(
name|spacer
operator|==
literal|':'
condition|)
block|{
name|putc
argument_list|(
name|spacer
argument_list|,
name|f
argument_list|)
expr_stmt|;
operator|++
name|column
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Print dependency file.  */
end_comment

begin_function
name|void
name|print_dependencies
parameter_list|()
block|{
name|FILE
modifier|*
name|f
decl_stmt|;
name|struct
name|dependency
modifier|*
name|dep
decl_stmt|;
if|if
condition|(
name|dep_file
operator|==
name|NULL
condition|)
return|return;
name|f
operator|=
name|fopen
argument_list|(
name|dep_file
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
block|{
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"Can't open `%s' for writing"
argument_list|)
argument_list|,
name|dep_file
argument_list|)
expr_stmt|;
return|return;
block|}
name|column
operator|=
literal|0
expr_stmt|;
name|wrap_output
argument_list|(
name|f
argument_list|,
name|out_file_name
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
for|for
control|(
name|dep
operator|=
name|dep_chain
init|;
name|dep
operator|!=
name|NULL
condition|;
name|dep
operator|=
name|dep
operator|->
name|next
control|)
name|wrap_output
argument_list|(
name|f
argument_list|,
name|dep
operator|->
name|file
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|fclose
argument_list|(
name|f
argument_list|)
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"Can't close `%s'"
argument_list|)
argument_list|,
name|dep_file
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

