begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* gasp.c - Gnu assembler preprocessor main program.    Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002    Free Software Foundation, Inc.     Written by Steve and Judy Chamberlain of Cygnus Support,       sac@cygnus.com     This file is part of GASP, the GNU Assembler Preprocessor.     GASP is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     GASP is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with GASP; see the file COPYING.  If not, write to the Free    Software Foundation, 59 Temple Place - Suite 330, Boston, MA    02111-1307, USA.  */
end_comment

begin_comment
comment|/* This program translates the input macros and stuff into a form suitable for gas to consume.    gasp [-sdhau] [-c char] [-o<outfile>]<infile>*    -s copy source to output   -c<char> comments are started with<char> instead of !   -u allow unreasonable stuff   -p print line numbers   -d print debugging stats   -s semi colons start comments   -a use alternate syntax      Pseudo ops can start with or without a .      Labels have to be in first column.   -I specify include dir     Macro arg parameters subsituted by name, don't need the&.      String can start with ' too.      Strings can be surrounded by<..>      A %<exp> in a string evaluates the expression      Literal char in a string with ! */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"bin-bugs.h"
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|"getopt.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_STDLIB_H
end_ifdef

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|NEED_MALLOC_DECLARATION
end_ifdef

begin_function_decl
specifier|extern
name|char
modifier|*
name|malloc
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"ansidecl.h"
end_include

begin_include
include|#
directive|include
file|"libiberty.h"
end_include

begin_include
include|#
directive|include
file|"safe-ctype.h"
end_include

begin_include
include|#
directive|include
file|"sb.h"
end_include

begin_include
include|#
directive|include
file|"macro.h"
end_include

begin_include
include|#
directive|include
file|"asintl.h"
end_include

begin_include
include|#
directive|include
file|"xregex.h"
end_include

begin_decl_stmt
name|char
modifier|*
name|program_version
init|=
literal|"1.2"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This is normally declared in as.h, but we don't include that.  We    need the function because other files linked with gasp.c might call    it.  */
end_comment

begin_decl_stmt
specifier|extern
name|void
name|as_abort
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
name|int
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The default obstack chunk size.  If we set this to zero, the    obstack code will use whatever will fit in a 4096 byte block.  This    is used by the hash table code used by macro.c.  */
end_comment

begin_decl_stmt
name|int
name|chunksize
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|MAX_INCLUDES
value|30
end_define

begin_comment
comment|/* Maximum include depth.  */
end_comment

begin_define
define|#
directive|define
name|MAX_REASONABLE
value|1000
end_define

begin_comment
comment|/* Maximum number of expansions.  */
end_comment

begin_decl_stmt
name|int
name|unreasonable
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -u on command line.  */
end_comment

begin_decl_stmt
name|int
name|stats
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -d on command line.  */
end_comment

begin_decl_stmt
name|int
name|print_line_number
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -p flag on command line.  */
end_comment

begin_decl_stmt
name|int
name|copysource
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -c flag on command line.  */
end_comment

begin_decl_stmt
name|int
name|warnings
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of WARNINGs generated so far.  */
end_comment

begin_decl_stmt
name|int
name|errors
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of ERRORs generated so far.  */
end_comment

begin_decl_stmt
name|int
name|fatals
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of fatal ERRORs generated so far (either 0 or 1).  */
end_comment

begin_decl_stmt
name|int
name|alternate
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -a on command line.  */
end_comment

begin_decl_stmt
name|int
name|mri
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -M on command line.  */
end_comment

begin_decl_stmt
name|char
name|comment_char
init|=
literal|'!'
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|radix
init|=
literal|10
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Default radix.  */
end_comment

begin_decl_stmt
name|int
name|had_end
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Seen .END.  */
end_comment

begin_comment
comment|/* The output stream.  */
end_comment

begin_decl_stmt
name|FILE
modifier|*
name|outfile
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The attributes of each character are stored as a bit pattern    chartype, which gives us quick tests.  */
end_comment

begin_define
define|#
directive|define
name|FIRSTBIT
value|1
end_define

begin_define
define|#
directive|define
name|NEXTBIT
value|2
end_define

begin_define
define|#
directive|define
name|SEPBIT
value|4
end_define

begin_define
define|#
directive|define
name|WHITEBIT
value|8
end_define

begin_define
define|#
directive|define
name|COMMENTBIT
value|16
end_define

begin_define
define|#
directive|define
name|BASEBIT
value|32
end_define

begin_define
define|#
directive|define
name|ISCOMMENTCHAR
parameter_list|(
name|x
parameter_list|)
value|(chartype[(unsigned char)(x)]& COMMENTBIT)
end_define

begin_define
define|#
directive|define
name|ISFIRSTCHAR
parameter_list|(
name|x
parameter_list|)
value|(chartype[(unsigned char)(x)]& FIRSTBIT)
end_define

begin_define
define|#
directive|define
name|ISNEXTCHAR
parameter_list|(
name|x
parameter_list|)
value|(chartype[(unsigned char)(x)]& NEXTBIT)
end_define

begin_define
define|#
directive|define
name|ISSEP
parameter_list|(
name|x
parameter_list|)
value|(chartype[(unsigned char)(x)]& SEPBIT)
end_define

begin_define
define|#
directive|define
name|ISWHITE
parameter_list|(
name|x
parameter_list|)
value|(chartype[(unsigned char)(x)]& WHITEBIT)
end_define

begin_define
define|#
directive|define
name|ISBASE
parameter_list|(
name|x
parameter_list|)
value|(chartype[(unsigned char)(x)]& BASEBIT)
end_define

begin_decl_stmt
specifier|static
name|char
name|chartype
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Conditional assembly uses the `ifstack'.  Each aif pushes another    entry onto the stack, and sets the on flag if it should.  The aelse    sets hadelse, and toggles on.  An aend pops a level.  We limit to    100 levels of nesting, not because we're facists pigs with read    only minds, but because more than 100 levels of nesting is probably    a bug in the user's macro structure.  */
end_comment

begin_define
define|#
directive|define
name|IFNESTING
value|100
end_define

begin_struct
struct|struct
block|{
name|int
name|on
decl_stmt|;
comment|/* Is the level being output.  */
name|int
name|hadelse
decl_stmt|;
comment|/* Has an aelse been seen.  */
block|}
name|ifstack
index|[
name|IFNESTING
index|]
struct|;
end_struct

begin_decl_stmt
name|int
name|ifi
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The final and intermediate results of expression evaluation are kept in    exp_t's.  Note that a symbol is not an sb, but a pointer into the input    line.  It must be coped somewhere safe before the next line is read in.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|len
decl_stmt|;
block|}
name|symbol
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
block|{
name|int
name|value
decl_stmt|;
comment|/* Constant part.  */
name|symbol
name|add_symbol
decl_stmt|;
comment|/* Name part.  */
name|symbol
name|sub_symbol
decl_stmt|;
comment|/* Name part.  */
block|}
name|exp_t
typedef|;
end_typedef

begin_comment
comment|/* Hashing is done in a pretty standard way.  A hash_table has a    pointer to a vector of pointers to hash_entrys, and the size of the    vector.  A hash_entry contains a union of all the info we like to    store in hash table.  If there is a hash collision, hash_entries    with the same hash are kept in a chain.  */
end_comment

begin_comment
comment|/* What the data in a hash_entry means.  */
end_comment

begin_typedef
typedef|typedef
enum|enum
block|{
name|hash_integer
block|,
comment|/* Name->integer mapping.  */
name|hash_string
block|,
comment|/* Name->string mapping.  */
name|hash_macro
block|,
comment|/* Name is a macro.  */
name|hash_formal
comment|/* Name is a formal argument.  */
block|}
name|hash_type
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|hs
block|{
name|sb
name|key
decl_stmt|;
comment|/* Symbol name.  */
name|hash_type
name|type
decl_stmt|;
comment|/* Symbol meaning.  */
union|union
block|{
name|sb
name|s
decl_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|macro_struct
modifier|*
name|m
decl_stmt|;
name|struct
name|formal_struct
modifier|*
name|f
decl_stmt|;
block|}
name|value
union|;
name|struct
name|hs
modifier|*
name|next
decl_stmt|;
comment|/* Next hash_entry with same hash key.  */
block|}
name|hash_entry
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
block|{
name|hash_entry
modifier|*
modifier|*
name|table
decl_stmt|;
name|int
name|size
decl_stmt|;
block|}
name|hash_table
typedef|;
end_typedef

begin_comment
comment|/* How we nest files and expand macros etc.     We keep a stack of of include_stack structs.  Each include file    pushes a new level onto the stack.  We keep an sb with a pushback    too.  unget chars are pushed onto the pushback sb, getchars first    checks the pushback sb before reading from the input stream.     Small things are expanded by adding the text of the item onto the    pushback sb.  Larger items are grown by pushing a new level and    allocating the entire pushback buf for the item.  Each time    something like a macro is expanded, the stack index is changed.  We    can then perform an exitm by popping all entries off the stack with    the same stack index.  If we're being reasonable, we can detect    recusive expansion by checking the index is reasonably small.  */
end_comment

begin_typedef
typedef|typedef
enum|enum
block|{
name|include_file
block|,
name|include_repeat
block|,
name|include_while
block|,
name|include_macro
block|}
name|include_type
typedef|;
end_typedef

begin_struct
struct|struct
name|include_stack
block|{
name|sb
name|pushback
decl_stmt|;
comment|/* Current pushback stream.  */
name|int
name|pushback_index
decl_stmt|;
comment|/* Next char to read from stream.  */
name|FILE
modifier|*
name|handle
decl_stmt|;
comment|/* Open file.  */
name|sb
name|name
decl_stmt|;
comment|/* Name of file.  */
name|int
name|linecount
decl_stmt|;
comment|/* Number of lines read so far.  */
name|include_type
name|type
decl_stmt|;
name|int
name|index
decl_stmt|;
comment|/* Index of this layer.  */
block|}
name|include_stack
index|[
name|MAX_INCLUDES
index|]
struct|;
end_struct

begin_decl_stmt
name|struct
name|include_stack
modifier|*
name|sp
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|isp
value|(sp - include_stack)
end_define

begin_comment
comment|/* Include file list.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|include_path
block|{
name|struct
name|include_path
modifier|*
name|next
decl_stmt|;
name|sb
name|path
decl_stmt|;
block|}
name|include_path
typedef|;
end_typedef

begin_decl_stmt
name|include_path
modifier|*
name|paths_head
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|include_path
modifier|*
name|paths_tail
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|quit
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|hash_new_table
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|hash_table
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|hash
name|PARAMS
argument_list|(
operator|(
name|sb
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|hash_entry
modifier|*
name|hash_create
name|PARAMS
argument_list|(
operator|(
name|hash_table
operator|*
operator|,
name|sb
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|hash_add_to_string_table
name|PARAMS
argument_list|(
operator|(
name|hash_table
operator|*
operator|,
name|sb
operator|*
operator|,
name|sb
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|hash_add_to_int_table
name|PARAMS
argument_list|(
operator|(
name|hash_table
operator|*
operator|,
name|sb
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|hash_entry
modifier|*
name|hash_lookup
name|PARAMS
argument_list|(
operator|(
name|hash_table
operator|*
operator|,
name|sb
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|checkconst
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|exp_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|is_flonum
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|sb
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|chew_flonum
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|sb
operator|*
operator|,
name|sb
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|sb_strtol
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|sb
operator|*
operator|,
name|int
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|level_0
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|sb
operator|*
operator|,
name|exp_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|level_1
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|sb
operator|*
operator|,
name|exp_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|level_2
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|sb
operator|*
operator|,
name|exp_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|level_3
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|sb
operator|*
operator|,
name|exp_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|level_4
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|sb
operator|*
operator|,
name|exp_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|level_5
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|sb
operator|*
operator|,
name|exp_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|exp_parse
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|sb
operator|*
operator|,
name|exp_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|exp_string
name|PARAMS
argument_list|(
operator|(
name|exp_t
operator|*
operator|,
name|sb
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|exp_get_abs
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
name|int
operator|,
name|sb
operator|*
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static void strip_comments PARAMS ((sb *));
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|void
name|unget
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|include_buf
name|PARAMS
argument_list|(
operator|(
name|sb
operator|*
operator|,
name|sb
operator|*
operator|,
name|include_type
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|include_print_where_line
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|include_print_line
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|get_line
name|PARAMS
argument_list|(
operator|(
name|sb
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|grab_label
name|PARAMS
argument_list|(
operator|(
name|sb
operator|*
operator|,
name|sb
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|change_base
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|sb
operator|*
operator|,
name|sb
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_end
name|PARAMS
argument_list|(
operator|(
name|sb
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_assign
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|,
name|sb
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_radix
name|PARAMS
argument_list|(
operator|(
name|sb
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|get_opsize
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|sb
operator|*
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|eol
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|sb
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_data
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|sb
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_datab
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|sb
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_align
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|sb
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_res
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|sb
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_export
name|PARAMS
argument_list|(
operator|(
name|sb
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_print
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|sb
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_heading
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|sb
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_page
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_form
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|sb
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|get_any_string
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|sb
operator|*
operator|,
name|sb
operator|*
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|skip_openp
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|sb
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|skip_closep
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|sb
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|dolen
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|sb
operator|*
operator|,
name|sb
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|doinstr
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|sb
operator|*
operator|,
name|sb
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|dosubstr
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|sb
operator|*
operator|,
name|sb
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|process_assigns
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|sb
operator|*
operator|,
name|sb
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|get_and_process
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|sb
operator|*
operator|,
name|sb
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|process_file
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|free_old_entry
name|PARAMS
argument_list|(
operator|(
name|hash_entry
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_assigna
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|sb
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_assignc
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|sb
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_reg
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|sb
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|condass_lookup_name
name|PARAMS
argument_list|(
operator|(
name|sb
operator|*
operator|,
name|int
operator|,
name|sb
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|whatcond
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|sb
operator|*
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|istrue
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|sb
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_aif
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|sb
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_aelse
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_aendi
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|condass_on
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_if
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|sb
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|get_mri_string
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|sb
operator|*
operator|,
name|sb
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_ifc
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|sb
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_aendr
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_awhile
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|sb
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_aendw
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_exitm
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_arepeat
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|sb
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_endm
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_irp
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|sb
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_local
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|sb
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_macro
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|sb
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|macro_op
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|sb
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|getstring
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|sb
operator|*
operator|,
name|sb
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_sdata
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|sb
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_sdatab
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|sb
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|new_file
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_include
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|sb
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|include_pop
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|get
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|linecount
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|include_next_index
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|chartype_init
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|process_pseudo_op
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|sb
operator|*
operator|,
name|sb
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|add_keyword
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|process_init
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_define
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|show_usage
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|show_help
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|FATAL
parameter_list|(
name|x
parameter_list|)
define|\
value|do						\     {						\       include_print_where_line (stderr);	\       fprintf x;				\       fatals++;					\       quit ();					\     }						\   while (0)
end_define

begin_define
define|#
directive|define
name|ERROR
parameter_list|(
name|x
parameter_list|)
define|\
value|do						\     {						\       include_print_where_line (stderr);	\       fprintf x;				\       errors++;					\     }						\   while (0)
end_define

begin_define
define|#
directive|define
name|WARNING
parameter_list|(
name|x
parameter_list|)
define|\
value|do						\     {						\       include_print_where_line (stderr);	\       fprintf x;				\       warnings++;				\     }						\   while (0)
end_define

begin_comment
comment|/* Exit the program and return the right ERROR code.  */
end_comment

begin_function
specifier|static
name|void
name|quit
parameter_list|()
block|{
name|int
name|exitcode
decl_stmt|;
if|if
condition|(
name|fatals
operator|+
name|errors
condition|)
name|exitcode
operator|=
literal|1
expr_stmt|;
else|else
name|exitcode
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|stats
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sb_max_power_two
condition|;
name|i
operator|++
control|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"strings size %8d : %d\n"
argument_list|,
literal|1
operator|<<
name|i
argument_list|,
name|string_count
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|exit
argument_list|(
name|exitcode
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Hash table maintenance.  */
end_comment

begin_comment
comment|/* Build a new hash table with size buckets    and fill in the info at ptr.  */
end_comment

begin_function
specifier|static
name|void
name|hash_new_table
parameter_list|(
name|size
parameter_list|,
name|ptr
parameter_list|)
name|int
name|size
decl_stmt|;
name|hash_table
modifier|*
name|ptr
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|ptr
operator|->
name|size
operator|=
name|size
expr_stmt|;
name|ptr
operator|->
name|table
operator|=
operator|(
name|hash_entry
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|size
operator|*
operator|(
sizeof|sizeof
argument_list|(
name|hash_entry
operator|*
argument_list|)
operator|)
argument_list|)
expr_stmt|;
comment|/* Fill with null-pointer, not zero-bit-pattern.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
name|ptr
operator|->
name|table
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Calculate and return the hash value of the sb at key.  */
end_comment

begin_function
specifier|static
name|int
name|hash
parameter_list|(
name|key
parameter_list|)
name|sb
modifier|*
name|key
decl_stmt|;
block|{
name|int
name|k
init|=
literal|0x1234
decl_stmt|;
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|p
init|=
name|key
operator|->
name|ptr
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|key
operator|->
name|len
condition|;
name|i
operator|++
control|)
block|{
name|k
operator|^=
operator|(
name|k
operator|<<
literal|2
operator|)
operator|^
operator|*
name|p
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
return|return
name|k
operator|&
literal|0xf0fff
return|;
block|}
end_function

begin_comment
comment|/* Look up key in hash_table tab.  If present, then return it,    otherwise build a new one and fill it with hash_integer.  */
end_comment

begin_function
specifier|static
name|hash_entry
modifier|*
name|hash_create
parameter_list|(
name|tab
parameter_list|,
name|key
parameter_list|)
name|hash_table
modifier|*
name|tab
decl_stmt|;
name|sb
modifier|*
name|key
decl_stmt|;
block|{
name|int
name|k
init|=
name|hash
argument_list|(
name|key
argument_list|)
operator|%
name|tab
operator|->
name|size
decl_stmt|;
name|hash_entry
modifier|*
name|p
decl_stmt|;
name|hash_entry
modifier|*
modifier|*
name|table
init|=
name|tab
operator|->
name|table
decl_stmt|;
name|p
operator|=
name|table
index|[
name|k
index|]
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|p
condition|)
block|{
name|hash_entry
modifier|*
name|n
init|=
operator|(
name|hash_entry
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|hash_entry
argument_list|)
argument_list|)
decl_stmt|;
name|n
operator|->
name|next
operator|=
name|table
index|[
name|k
index|]
expr_stmt|;
name|sb_new
argument_list|(
operator|&
name|n
operator|->
name|key
argument_list|)
expr_stmt|;
name|sb_add_sb
argument_list|(
operator|&
name|n
operator|->
name|key
argument_list|,
name|key
argument_list|)
expr_stmt|;
name|table
index|[
name|k
index|]
operator|=
name|n
expr_stmt|;
name|n
operator|->
name|type
operator|=
name|hash_integer
expr_stmt|;
return|return
name|n
return|;
block|}
if|if
condition|(
name|strncmp
argument_list|(
name|table
index|[
name|k
index|]
operator|->
name|key
operator|.
name|ptr
argument_list|,
name|key
operator|->
name|ptr
argument_list|,
name|key
operator|->
name|len
argument_list|)
operator|==
literal|0
condition|)
block|{
return|return
name|p
return|;
block|}
name|p
operator|=
name|p
operator|->
name|next
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Add sb name with key into hash_table tab.    If replacing old value and again, then ERROR.  */
end_comment

begin_function
specifier|static
name|void
name|hash_add_to_string_table
parameter_list|(
name|tab
parameter_list|,
name|key
parameter_list|,
name|name
parameter_list|,
name|again
parameter_list|)
name|hash_table
modifier|*
name|tab
decl_stmt|;
name|sb
modifier|*
name|key
decl_stmt|;
name|sb
modifier|*
name|name
decl_stmt|;
name|int
name|again
decl_stmt|;
block|{
name|hash_entry
modifier|*
name|ptr
init|=
name|hash_create
argument_list|(
name|tab
argument_list|,
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|ptr
operator|->
name|type
operator|==
name|hash_integer
condition|)
block|{
name|sb_new
argument_list|(
operator|&
name|ptr
operator|->
name|value
operator|.
name|s
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ptr
operator|->
name|value
operator|.
name|s
operator|.
name|len
condition|)
block|{
if|if
condition|(
operator|!
name|again
condition|)
name|ERROR
argument_list|(
operator|(
name|stderr
operator|,
name|_
argument_list|(
literal|"redefinition not allowed\n"
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
name|ptr
operator|->
name|type
operator|=
name|hash_string
expr_stmt|;
name|sb_reset
argument_list|(
operator|&
name|ptr
operator|->
name|value
operator|.
name|s
argument_list|)
expr_stmt|;
name|sb_add_sb
argument_list|(
operator|&
name|ptr
operator|->
name|value
operator|.
name|s
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add integer name to hash_table tab with sb key.  */
end_comment

begin_function
specifier|static
name|void
name|hash_add_to_int_table
parameter_list|(
name|tab
parameter_list|,
name|key
parameter_list|,
name|name
parameter_list|)
name|hash_table
modifier|*
name|tab
decl_stmt|;
name|sb
modifier|*
name|key
decl_stmt|;
name|int
name|name
decl_stmt|;
block|{
name|hash_entry
modifier|*
name|ptr
init|=
name|hash_create
argument_list|(
name|tab
argument_list|,
name|key
argument_list|)
decl_stmt|;
name|ptr
operator|->
name|value
operator|.
name|i
operator|=
name|name
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Look up sb key in hash_table tab.    If found, return hash_entry result, else 0.  */
end_comment

begin_function
specifier|static
name|hash_entry
modifier|*
name|hash_lookup
parameter_list|(
name|tab
parameter_list|,
name|key
parameter_list|)
name|hash_table
modifier|*
name|tab
decl_stmt|;
name|sb
modifier|*
name|key
decl_stmt|;
block|{
name|int
name|k
init|=
name|hash
argument_list|(
name|key
argument_list|)
operator|%
name|tab
operator|->
name|size
decl_stmt|;
name|hash_entry
modifier|*
modifier|*
name|table
init|=
name|tab
operator|->
name|table
decl_stmt|;
name|hash_entry
modifier|*
name|p
init|=
name|table
index|[
name|k
index|]
decl_stmt|;
while|while
condition|(
name|p
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|key
operator|.
name|len
operator|==
name|key
operator|->
name|len
operator|&&
name|strncmp
argument_list|(
name|p
operator|->
name|key
operator|.
name|ptr
argument_list|,
name|key
operator|->
name|ptr
argument_list|,
name|key
operator|->
name|len
argument_list|)
operator|==
literal|0
condition|)
return|return
name|p
return|;
name|p
operator|=
name|p
operator|->
name|next
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* expressions     are handled in a really simple recursive decent way. each bit of    the machine takes an index into an sb and a pointer to an exp_t,    modifies the *exp_t and returns the index of the first character    past the part of the expression parsed.   expression precedence:   ( )  unary + - ~   * /   + -&   | ~ */
end_comment

begin_comment
comment|/* Make sure that the exp_t at term is constant.    If not the give the op ERROR.  */
end_comment

begin_function
specifier|static
name|void
name|checkconst
parameter_list|(
name|op
parameter_list|,
name|term
parameter_list|)
name|int
name|op
decl_stmt|;
name|exp_t
modifier|*
name|term
decl_stmt|;
block|{
if|if
condition|(
name|term
operator|->
name|add_symbol
operator|.
name|len
operator|||
name|term
operator|->
name|sub_symbol
operator|.
name|len
condition|)
block|{
name|ERROR
argument_list|(
operator|(
name|stderr
operator|,
name|_
argument_list|(
literal|"the %c operator cannot take non-absolute arguments.\n"
argument_list|)
operator|,
name|op
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Chew the flonum from the string starting at idx.  Adjust idx to    point to the next character after the flonum.  */
end_comment

begin_function
specifier|static
name|int
name|chew_flonum
parameter_list|(
name|idx
parameter_list|,
name|string
parameter_list|,
name|out
parameter_list|)
name|int
name|idx
decl_stmt|;
name|sb
modifier|*
name|string
decl_stmt|;
name|sb
modifier|*
name|out
decl_stmt|;
block|{
name|sb
name|buf
decl_stmt|;
name|regex_t
name|reg
decl_stmt|;
name|regmatch_t
name|match
decl_stmt|;
comment|/* Duplicate and null terminate `string'.  */
name|sb_new
argument_list|(
operator|&
name|buf
argument_list|)
expr_stmt|;
name|sb_add_sb
argument_list|(
operator|&
name|buf
argument_list|,
name|string
argument_list|)
expr_stmt|;
name|sb_add_char
argument_list|(
operator|&
name|buf
argument_list|,
literal|'\0'
argument_list|)
expr_stmt|;
if|if
condition|(
name|regcomp
argument_list|(
operator|&
name|reg
argument_list|,
literal|"([0-9]*\\.[0-9]+([eE][+-]?[0-9]+)?)"
argument_list|,
name|REG_EXTENDED
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|idx
return|;
if|if
condition|(
name|regexec
argument_list|(
operator|&
name|reg
argument_list|,
operator|&
name|buf
operator|.
name|ptr
index|[
name|idx
index|]
argument_list|,
literal|1
argument_list|,
operator|&
name|match
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|idx
return|;
comment|/* Copy the match to the output.  */
name|assert
argument_list|(
name|match
operator|.
name|rm_eo
operator|>=
name|match
operator|.
name|rm_so
argument_list|)
expr_stmt|;
name|sb_add_buffer
argument_list|(
name|out
argument_list|,
operator|&
name|buf
operator|.
name|ptr
index|[
name|idx
index|]
argument_list|,
name|match
operator|.
name|rm_eo
operator|-
name|match
operator|.
name|rm_so
argument_list|)
expr_stmt|;
name|sb_kill
argument_list|(
operator|&
name|buf
argument_list|)
expr_stmt|;
name|regfree
argument_list|(
operator|&
name|reg
argument_list|)
expr_stmt|;
name|idx
operator|+=
name|match
operator|.
name|rm_eo
expr_stmt|;
return|return
name|idx
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|is_flonum
parameter_list|(
name|idx
parameter_list|,
name|string
parameter_list|)
name|int
name|idx
decl_stmt|;
name|sb
modifier|*
name|string
decl_stmt|;
block|{
name|sb
name|buf
decl_stmt|;
name|regex_t
name|reg
decl_stmt|;
name|int
name|rc
decl_stmt|;
comment|/* Duplicate and null terminate `string'.  */
name|sb_new
argument_list|(
operator|&
name|buf
argument_list|)
expr_stmt|;
name|sb_add_sb
argument_list|(
operator|&
name|buf
argument_list|,
name|string
argument_list|)
expr_stmt|;
name|sb_add_char
argument_list|(
operator|&
name|buf
argument_list|,
literal|'\0'
argument_list|)
expr_stmt|;
if|if
condition|(
name|regcomp
argument_list|(
operator|&
name|reg
argument_list|,
literal|"^[0-9]*\\.[0-9]+([eE][+-]?[0-9]+)?"
argument_list|,
name|REG_EXTENDED
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
name|rc
operator|=
name|regexec
argument_list|(
operator|&
name|reg
argument_list|,
operator|&
name|buf
operator|.
name|ptr
index|[
name|idx
index|]
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sb_kill
argument_list|(
operator|&
name|buf
argument_list|)
expr_stmt|;
name|regfree
argument_list|(
operator|&
name|reg
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|==
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Turn the number in string at idx into a number of base, fill in    ptr, and return the index of the first character not in the number.  */
end_comment

begin_function
specifier|static
name|int
name|sb_strtol
parameter_list|(
name|idx
parameter_list|,
name|string
parameter_list|,
name|base
parameter_list|,
name|ptr
parameter_list|)
name|int
name|idx
decl_stmt|;
name|sb
modifier|*
name|string
decl_stmt|;
name|int
name|base
decl_stmt|;
name|int
modifier|*
name|ptr
decl_stmt|;
block|{
name|int
name|value
init|=
literal|0
decl_stmt|;
name|idx
operator|=
name|sb_skip_white
argument_list|(
name|idx
argument_list|,
name|string
argument_list|)
expr_stmt|;
while|while
condition|(
name|idx
operator|<
name|string
operator|->
name|len
condition|)
block|{
name|int
name|ch
init|=
name|string
operator|->
name|ptr
index|[
name|idx
index|]
decl_stmt|;
name|int
name|dig
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|ISDIGIT
argument_list|(
name|ch
argument_list|)
condition|)
name|dig
operator|=
name|ch
operator|-
literal|'0'
expr_stmt|;
elseif|else
if|if
condition|(
name|ch
operator|>=
literal|'a'
operator|&&
name|ch
operator|<=
literal|'f'
condition|)
name|dig
operator|=
name|ch
operator|-
literal|'a'
operator|+
literal|10
expr_stmt|;
elseif|else
if|if
condition|(
name|ch
operator|>=
literal|'A'
operator|&&
name|ch
operator|<=
literal|'F'
condition|)
name|dig
operator|=
name|ch
operator|-
literal|'A'
operator|+
literal|10
expr_stmt|;
else|else
break|break;
if|if
condition|(
name|dig
operator|>=
name|base
condition|)
break|break;
name|value
operator|=
name|value
operator|*
name|base
operator|+
name|dig
expr_stmt|;
name|idx
operator|++
expr_stmt|;
block|}
operator|*
name|ptr
operator|=
name|value
expr_stmt|;
return|return
name|idx
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|level_0
parameter_list|(
name|idx
parameter_list|,
name|string
parameter_list|,
name|lhs
parameter_list|)
name|int
name|idx
decl_stmt|;
name|sb
modifier|*
name|string
decl_stmt|;
name|exp_t
modifier|*
name|lhs
decl_stmt|;
block|{
name|lhs
operator|->
name|add_symbol
operator|.
name|len
operator|=
literal|0
expr_stmt|;
name|lhs
operator|->
name|add_symbol
operator|.
name|name
operator|=
literal|0
expr_stmt|;
name|lhs
operator|->
name|sub_symbol
operator|.
name|len
operator|=
literal|0
expr_stmt|;
name|lhs
operator|->
name|sub_symbol
operator|.
name|name
operator|=
literal|0
expr_stmt|;
name|idx
operator|=
name|sb_skip_white
argument_list|(
name|idx
argument_list|,
name|string
argument_list|)
expr_stmt|;
name|lhs
operator|->
name|value
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ISDIGIT
argument_list|(
name|string
operator|->
name|ptr
index|[
name|idx
index|]
argument_list|)
condition|)
block|{
name|idx
operator|=
name|sb_strtol
argument_list|(
name|idx
argument_list|,
name|string
argument_list|,
literal|10
argument_list|,
operator|&
name|lhs
operator|->
name|value
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ISFIRSTCHAR
argument_list|(
name|string
operator|->
name|ptr
index|[
name|idx
index|]
argument_list|)
condition|)
block|{
name|int
name|len
init|=
literal|0
decl_stmt|;
name|lhs
operator|->
name|add_symbol
operator|.
name|name
operator|=
name|string
operator|->
name|ptr
operator|+
name|idx
expr_stmt|;
while|while
condition|(
name|idx
operator|<
name|string
operator|->
name|len
operator|&&
name|ISNEXTCHAR
argument_list|(
name|string
operator|->
name|ptr
index|[
name|idx
index|]
argument_list|)
condition|)
block|{
name|idx
operator|++
expr_stmt|;
name|len
operator|++
expr_stmt|;
block|}
name|lhs
operator|->
name|add_symbol
operator|.
name|len
operator|=
name|len
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|string
operator|->
name|ptr
index|[
name|idx
index|]
operator|==
literal|'"'
condition|)
block|{
name|sb
name|acc
decl_stmt|;
name|sb_new
argument_list|(
operator|&
name|acc
argument_list|)
expr_stmt|;
name|ERROR
argument_list|(
operator|(
name|stderr
operator|,
name|_
argument_list|(
literal|"string where expression expected.\n"
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|idx
operator|=
name|getstring
argument_list|(
name|idx
argument_list|,
name|string
argument_list|,
operator|&
name|acc
argument_list|)
expr_stmt|;
name|sb_kill
argument_list|(
operator|&
name|acc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ERROR
argument_list|(
operator|(
name|stderr
operator|,
name|_
argument_list|(
literal|"can't find primary in expression.\n"
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|idx
operator|++
expr_stmt|;
block|}
return|return
name|sb_skip_white
argument_list|(
name|idx
argument_list|,
name|string
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|level_1
parameter_list|(
name|idx
parameter_list|,
name|string
parameter_list|,
name|lhs
parameter_list|)
name|int
name|idx
decl_stmt|;
name|sb
modifier|*
name|string
decl_stmt|;
name|exp_t
modifier|*
name|lhs
decl_stmt|;
block|{
name|idx
operator|=
name|sb_skip_white
argument_list|(
name|idx
argument_list|,
name|string
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|string
operator|->
name|ptr
index|[
name|idx
index|]
condition|)
block|{
case|case
literal|'+'
case|:
name|idx
operator|=
name|level_1
argument_list|(
name|idx
operator|+
literal|1
argument_list|,
name|string
argument_list|,
name|lhs
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'~'
case|:
name|idx
operator|=
name|level_1
argument_list|(
name|idx
operator|+
literal|1
argument_list|,
name|string
argument_list|,
name|lhs
argument_list|)
expr_stmt|;
name|checkconst
argument_list|(
literal|'~'
argument_list|,
name|lhs
argument_list|)
expr_stmt|;
name|lhs
operator|->
name|value
operator|=
operator|~
name|lhs
operator|->
name|value
expr_stmt|;
break|break;
case|case
literal|'-'
case|:
block|{
name|symbol
name|t
decl_stmt|;
name|idx
operator|=
name|level_1
argument_list|(
name|idx
operator|+
literal|1
argument_list|,
name|string
argument_list|,
name|lhs
argument_list|)
expr_stmt|;
name|lhs
operator|->
name|value
operator|=
operator|-
name|lhs
operator|->
name|value
expr_stmt|;
name|t
operator|=
name|lhs
operator|->
name|add_symbol
expr_stmt|;
name|lhs
operator|->
name|add_symbol
operator|=
name|lhs
operator|->
name|sub_symbol
expr_stmt|;
name|lhs
operator|->
name|sub_symbol
operator|=
name|t
expr_stmt|;
break|break;
block|}
case|case
literal|'('
case|:
name|idx
operator|++
expr_stmt|;
name|idx
operator|=
name|level_5
argument_list|(
name|sb_skip_white
argument_list|(
name|idx
argument_list|,
name|string
argument_list|)
argument_list|,
name|string
argument_list|,
name|lhs
argument_list|)
expr_stmt|;
if|if
condition|(
name|string
operator|->
name|ptr
index|[
name|idx
index|]
operator|!=
literal|')'
condition|)
name|ERROR
argument_list|(
operator|(
name|stderr
operator|,
name|_
argument_list|(
literal|"misplaced closing parens.\n"
argument_list|)
operator|)
argument_list|)
expr_stmt|;
else|else
name|idx
operator|++
expr_stmt|;
break|break;
default|default:
name|idx
operator|=
name|level_0
argument_list|(
name|idx
argument_list|,
name|string
argument_list|,
name|lhs
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|sb_skip_white
argument_list|(
name|idx
argument_list|,
name|string
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|level_2
parameter_list|(
name|idx
parameter_list|,
name|string
parameter_list|,
name|lhs
parameter_list|)
name|int
name|idx
decl_stmt|;
name|sb
modifier|*
name|string
decl_stmt|;
name|exp_t
modifier|*
name|lhs
decl_stmt|;
block|{
name|exp_t
name|rhs
decl_stmt|;
name|idx
operator|=
name|level_1
argument_list|(
name|idx
argument_list|,
name|string
argument_list|,
name|lhs
argument_list|)
expr_stmt|;
while|while
condition|(
name|idx
operator|<
name|string
operator|->
name|len
operator|&&
operator|(
name|string
operator|->
name|ptr
index|[
name|idx
index|]
operator|==
literal|'*'
operator|||
name|string
operator|->
name|ptr
index|[
name|idx
index|]
operator|==
literal|'/'
operator|)
condition|)
block|{
name|char
name|op
init|=
name|string
operator|->
name|ptr
index|[
name|idx
operator|++
index|]
decl_stmt|;
name|idx
operator|=
name|level_1
argument_list|(
name|idx
argument_list|,
name|string
argument_list|,
operator|&
name|rhs
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|op
condition|)
block|{
case|case
literal|'*'
case|:
name|checkconst
argument_list|(
literal|'*'
argument_list|,
name|lhs
argument_list|)
expr_stmt|;
name|checkconst
argument_list|(
literal|'*'
argument_list|,
operator|&
name|rhs
argument_list|)
expr_stmt|;
name|lhs
operator|->
name|value
operator|*=
name|rhs
operator|.
name|value
expr_stmt|;
break|break;
case|case
literal|'/'
case|:
name|checkconst
argument_list|(
literal|'/'
argument_list|,
name|lhs
argument_list|)
expr_stmt|;
name|checkconst
argument_list|(
literal|'/'
argument_list|,
operator|&
name|rhs
argument_list|)
expr_stmt|;
if|if
condition|(
name|rhs
operator|.
name|value
operator|==
literal|0
condition|)
name|ERROR
argument_list|(
operator|(
name|stderr
operator|,
name|_
argument_list|(
literal|"attempt to divide by zero.\n"
argument_list|)
operator|)
argument_list|)
expr_stmt|;
else|else
name|lhs
operator|->
name|value
operator|/=
name|rhs
operator|.
name|value
expr_stmt|;
break|break;
block|}
block|}
return|return
name|sb_skip_white
argument_list|(
name|idx
argument_list|,
name|string
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|level_3
parameter_list|(
name|idx
parameter_list|,
name|string
parameter_list|,
name|lhs
parameter_list|)
name|int
name|idx
decl_stmt|;
name|sb
modifier|*
name|string
decl_stmt|;
name|exp_t
modifier|*
name|lhs
decl_stmt|;
block|{
name|exp_t
name|rhs
decl_stmt|;
name|idx
operator|=
name|level_2
argument_list|(
name|idx
argument_list|,
name|string
argument_list|,
name|lhs
argument_list|)
expr_stmt|;
while|while
condition|(
name|idx
operator|<
name|string
operator|->
name|len
operator|&&
operator|(
name|string
operator|->
name|ptr
index|[
name|idx
index|]
operator|==
literal|'+'
operator|||
name|string
operator|->
name|ptr
index|[
name|idx
index|]
operator|==
literal|'-'
operator|)
condition|)
block|{
name|char
name|op
init|=
name|string
operator|->
name|ptr
index|[
name|idx
operator|++
index|]
decl_stmt|;
name|idx
operator|=
name|level_2
argument_list|(
name|idx
argument_list|,
name|string
argument_list|,
operator|&
name|rhs
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|op
condition|)
block|{
case|case
literal|'+'
case|:
name|lhs
operator|->
name|value
operator|+=
name|rhs
operator|.
name|value
expr_stmt|;
if|if
condition|(
name|lhs
operator|->
name|add_symbol
operator|.
name|name
operator|&&
name|rhs
operator|.
name|add_symbol
operator|.
name|name
condition|)
block|{
name|ERROR
argument_list|(
operator|(
name|stderr
operator|,
name|_
argument_list|(
literal|"can't add two relocatable expressions\n"
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* Change nn+symbol to symbol + nn.  */
if|if
condition|(
name|rhs
operator|.
name|add_symbol
operator|.
name|name
condition|)
block|{
name|lhs
operator|->
name|add_symbol
operator|=
name|rhs
operator|.
name|add_symbol
expr_stmt|;
block|}
break|break;
case|case
literal|'-'
case|:
name|lhs
operator|->
name|value
operator|-=
name|rhs
operator|.
name|value
expr_stmt|;
name|lhs
operator|->
name|sub_symbol
operator|=
name|rhs
operator|.
name|add_symbol
expr_stmt|;
break|break;
block|}
block|}
return|return
name|sb_skip_white
argument_list|(
name|idx
argument_list|,
name|string
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|level_4
parameter_list|(
name|idx
parameter_list|,
name|string
parameter_list|,
name|lhs
parameter_list|)
name|int
name|idx
decl_stmt|;
name|sb
modifier|*
name|string
decl_stmt|;
name|exp_t
modifier|*
name|lhs
decl_stmt|;
block|{
name|exp_t
name|rhs
decl_stmt|;
name|idx
operator|=
name|level_3
argument_list|(
name|idx
argument_list|,
name|string
argument_list|,
name|lhs
argument_list|)
expr_stmt|;
while|while
condition|(
name|idx
operator|<
name|string
operator|->
name|len
operator|&&
name|string
operator|->
name|ptr
index|[
name|idx
index|]
operator|==
literal|'&'
condition|)
block|{
name|char
name|op
init|=
name|string
operator|->
name|ptr
index|[
name|idx
operator|++
index|]
decl_stmt|;
name|idx
operator|=
name|level_3
argument_list|(
name|idx
argument_list|,
name|string
argument_list|,
operator|&
name|rhs
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|op
condition|)
block|{
case|case
literal|'&'
case|:
name|checkconst
argument_list|(
literal|'&'
argument_list|,
name|lhs
argument_list|)
expr_stmt|;
name|checkconst
argument_list|(
literal|'&'
argument_list|,
operator|&
name|rhs
argument_list|)
expr_stmt|;
name|lhs
operator|->
name|value
operator|&=
name|rhs
operator|.
name|value
expr_stmt|;
break|break;
block|}
block|}
return|return
name|sb_skip_white
argument_list|(
name|idx
argument_list|,
name|string
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|level_5
parameter_list|(
name|idx
parameter_list|,
name|string
parameter_list|,
name|lhs
parameter_list|)
name|int
name|idx
decl_stmt|;
name|sb
modifier|*
name|string
decl_stmt|;
name|exp_t
modifier|*
name|lhs
decl_stmt|;
block|{
name|exp_t
name|rhs
decl_stmt|;
name|idx
operator|=
name|level_4
argument_list|(
name|idx
argument_list|,
name|string
argument_list|,
name|lhs
argument_list|)
expr_stmt|;
while|while
condition|(
name|idx
operator|<
name|string
operator|->
name|len
operator|&&
operator|(
name|string
operator|->
name|ptr
index|[
name|idx
index|]
operator|==
literal|'|'
operator|||
name|string
operator|->
name|ptr
index|[
name|idx
index|]
operator|==
literal|'~'
operator|)
condition|)
block|{
name|char
name|op
init|=
name|string
operator|->
name|ptr
index|[
name|idx
operator|++
index|]
decl_stmt|;
name|idx
operator|=
name|level_4
argument_list|(
name|idx
argument_list|,
name|string
argument_list|,
operator|&
name|rhs
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|op
condition|)
block|{
case|case
literal|'|'
case|:
name|checkconst
argument_list|(
literal|'|'
argument_list|,
name|lhs
argument_list|)
expr_stmt|;
name|checkconst
argument_list|(
literal|'|'
argument_list|,
operator|&
name|rhs
argument_list|)
expr_stmt|;
name|lhs
operator|->
name|value
operator||=
name|rhs
operator|.
name|value
expr_stmt|;
break|break;
case|case
literal|'~'
case|:
name|checkconst
argument_list|(
literal|'~'
argument_list|,
name|lhs
argument_list|)
expr_stmt|;
name|checkconst
argument_list|(
literal|'~'
argument_list|,
operator|&
name|rhs
argument_list|)
expr_stmt|;
name|lhs
operator|->
name|value
operator|^=
name|rhs
operator|.
name|value
expr_stmt|;
break|break;
block|}
block|}
return|return
name|sb_skip_white
argument_list|(
name|idx
argument_list|,
name|string
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Parse the expression at offset idx into string, fill up res with    the result.  Return the index of the first char past the    expression.  */
end_comment

begin_function
specifier|static
name|int
name|exp_parse
parameter_list|(
name|idx
parameter_list|,
name|string
parameter_list|,
name|res
parameter_list|)
name|int
name|idx
decl_stmt|;
name|sb
modifier|*
name|string
decl_stmt|;
name|exp_t
modifier|*
name|res
decl_stmt|;
block|{
return|return
name|level_5
argument_list|(
name|sb_skip_white
argument_list|(
name|idx
argument_list|,
name|string
argument_list|)
argument_list|,
name|string
argument_list|,
name|res
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Turn the expression at exp into text and glue it onto the end of    string.  */
end_comment

begin_function
specifier|static
name|void
name|exp_string
parameter_list|(
name|exp
parameter_list|,
name|string
parameter_list|)
name|exp_t
modifier|*
name|exp
decl_stmt|;
name|sb
modifier|*
name|string
decl_stmt|;
block|{
name|int
name|np
init|=
literal|0
decl_stmt|;
name|int
name|ad
init|=
literal|0
decl_stmt|;
name|sb_reset
argument_list|(
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
name|exp
operator|->
name|add_symbol
operator|.
name|len
condition|)
block|{
name|sb_add_buffer
argument_list|(
name|string
argument_list|,
name|exp
operator|->
name|add_symbol
operator|.
name|name
argument_list|,
name|exp
operator|->
name|add_symbol
operator|.
name|len
argument_list|)
expr_stmt|;
name|np
operator|=
literal|1
expr_stmt|;
name|ad
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|exp
operator|->
name|value
condition|)
block|{
name|char
name|buf
index|[
literal|20
index|]
decl_stmt|;
if|if
condition|(
name|np
condition|)
name|sb_add_char
argument_list|(
name|string
argument_list|,
literal|'+'
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%d"
argument_list|,
name|exp
operator|->
name|value
argument_list|)
expr_stmt|;
name|sb_add_string
argument_list|(
name|string
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|np
operator|=
literal|1
expr_stmt|;
name|ad
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|exp
operator|->
name|sub_symbol
operator|.
name|len
condition|)
block|{
name|sb_add_char
argument_list|(
name|string
argument_list|,
literal|'-'
argument_list|)
expr_stmt|;
name|sb_add_buffer
argument_list|(
name|string
argument_list|,
name|exp
operator|->
name|add_symbol
operator|.
name|name
argument_list|,
name|exp
operator|->
name|add_symbol
operator|.
name|len
argument_list|)
expr_stmt|;
name|np
operator|=
literal|0
expr_stmt|;
name|ad
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|ad
condition|)
name|sb_add_char
argument_list|(
name|string
argument_list|,
literal|'0'
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Parse the expression at offset idx into sb in.  Return the value in    val.  If the expression is not constant, give ERROR emsg.  Return    the index of the first character past the end of the expression.  */
end_comment

begin_function
specifier|static
name|int
name|exp_get_abs
parameter_list|(
name|emsg
parameter_list|,
name|idx
parameter_list|,
name|in
parameter_list|,
name|val
parameter_list|)
specifier|const
name|char
modifier|*
name|emsg
decl_stmt|;
name|int
name|idx
decl_stmt|;
name|sb
modifier|*
name|in
decl_stmt|;
name|int
modifier|*
name|val
decl_stmt|;
block|{
name|exp_t
name|res
decl_stmt|;
name|idx
operator|=
name|exp_parse
argument_list|(
name|idx
argument_list|,
name|in
argument_list|,
operator|&
name|res
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|.
name|add_symbol
operator|.
name|len
operator|||
name|res
operator|.
name|sub_symbol
operator|.
name|len
condition|)
name|ERROR
argument_list|(
operator|(
name|stderr
operator|,
literal|"%s"
operator|,
name|emsg
operator|)
argument_list|)
expr_stmt|;
operator|*
name|val
operator|=
name|res
operator|.
name|value
expr_stmt|;
return|return
name|idx
return|;
block|}
end_function

begin_comment
comment|/* Current label parsed from line.  */
end_comment

begin_decl_stmt
name|sb
name|label
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Hash table for all assigned variables.  */
end_comment

begin_decl_stmt
name|hash_table
name|assign_hash_table
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Hash table for keyword.  */
end_comment

begin_decl_stmt
name|hash_table
name|keyword_hash_table
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Hash table for eq variables.  */
end_comment

begin_decl_stmt
name|hash_table
name|vars
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|in_comment
value|';'
end_define

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static void strip_comments (out)      sb *out; {   char *s = out->ptr;   int i = 0;   for (i = 0; i< out->len; i++)     {       if (ISCOMMENTCHAR (s[i])) 	{ 	  out->len = i; 	  return; 	}     } }
endif|#
directive|endif
end_endif

begin_comment
comment|/* Push back character ch so that it can be read again.  */
end_comment

begin_function
specifier|static
name|void
name|unget
parameter_list|(
name|ch
parameter_list|)
name|int
name|ch
decl_stmt|;
block|{
if|if
condition|(
name|ch
operator|==
literal|'\n'
condition|)
block|{
name|sp
operator|->
name|linecount
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|sp
operator|->
name|pushback_index
condition|)
name|sp
operator|->
name|pushback_index
operator|--
expr_stmt|;
else|else
name|sb_add_char
argument_list|(
operator|&
name|sp
operator|->
name|pushback
argument_list|,
name|ch
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Push the sb ptr onto the include stack, with the given name, type    and index.  */
end_comment

begin_function
specifier|static
name|void
name|include_buf
parameter_list|(
name|name
parameter_list|,
name|ptr
parameter_list|,
name|type
parameter_list|,
name|index
parameter_list|)
name|sb
modifier|*
name|name
decl_stmt|;
name|sb
modifier|*
name|ptr
decl_stmt|;
name|include_type
name|type
decl_stmt|;
name|int
name|index
decl_stmt|;
block|{
name|sp
operator|++
expr_stmt|;
if|if
condition|(
name|sp
operator|-
name|include_stack
operator|>=
name|MAX_INCLUDES
condition|)
name|FATAL
argument_list|(
operator|(
name|stderr
operator|,
name|_
argument_list|(
literal|"unreasonable nesting.\n"
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|sb_new
argument_list|(
operator|&
name|sp
operator|->
name|name
argument_list|)
expr_stmt|;
name|sb_add_sb
argument_list|(
operator|&
name|sp
operator|->
name|name
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|sp
operator|->
name|handle
operator|=
literal|0
expr_stmt|;
name|sp
operator|->
name|linecount
operator|=
literal|1
expr_stmt|;
name|sp
operator|->
name|pushback_index
operator|=
literal|0
expr_stmt|;
name|sp
operator|->
name|type
operator|=
name|type
expr_stmt|;
name|sp
operator|->
name|index
operator|=
name|index
expr_stmt|;
name|sb_new
argument_list|(
operator|&
name|sp
operator|->
name|pushback
argument_list|)
expr_stmt|;
name|sb_add_sb
argument_list|(
operator|&
name|sp
operator|->
name|pushback
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Used in ERROR messages, print info on where the include stack is    onto file.  */
end_comment

begin_function
specifier|static
name|void
name|include_print_where_line
parameter_list|(
name|file
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
block|{
name|struct
name|include_stack
modifier|*
name|p
init|=
name|include_stack
operator|+
literal|1
decl_stmt|;
while|while
condition|(
name|p
operator|<=
name|sp
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s:%d "
argument_list|,
name|sb_name
argument_list|(
operator|&
name|p
operator|->
name|name
argument_list|)
argument_list|,
name|p
operator|->
name|linecount
operator|-
literal|1
argument_list|)
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Used in listings, print the line number onto file.  */
end_comment

begin_function
specifier|static
name|void
name|include_print_line
parameter_list|(
name|file
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
block|{
name|int
name|n
decl_stmt|;
name|struct
name|include_stack
modifier|*
name|p
init|=
name|include_stack
operator|+
literal|1
decl_stmt|;
name|n
operator|=
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%4d"
argument_list|,
name|p
operator|->
name|linecount
argument_list|)
expr_stmt|;
name|p
operator|++
expr_stmt|;
while|while
condition|(
name|p
operator|<=
name|sp
condition|)
block|{
name|n
operator|+=
name|fprintf
argument_list|(
name|file
argument_list|,
literal|".%d"
argument_list|,
name|p
operator|->
name|linecount
argument_list|)
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
while|while
condition|(
name|n
operator|<
literal|8
operator|*
literal|3
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|n
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Read a line from the top of the include stack into sb in.  */
end_comment

begin_function
specifier|static
name|int
name|get_line
parameter_list|(
name|in
parameter_list|)
name|sb
modifier|*
name|in
decl_stmt|;
block|{
name|int
name|online
init|=
literal|0
decl_stmt|;
name|int
name|more
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|copysource
condition|)
block|{
name|putc
argument_list|(
name|comment_char
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|print_line_number
condition|)
name|include_print_line
argument_list|(
name|outfile
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
literal|1
condition|)
block|{
name|int
name|ch
init|=
name|get
argument_list|()
decl_stmt|;
while|while
condition|(
name|ch
operator|==
literal|'\r'
condition|)
name|ch
operator|=
name|get
argument_list|()
expr_stmt|;
if|if
condition|(
name|ch
operator|==
name|EOF
condition|)
block|{
if|if
condition|(
name|online
condition|)
block|{
name|WARNING
argument_list|(
operator|(
name|stderr
operator|,
name|_
argument_list|(
literal|"End of file not at start of line.\n"
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|copysource
condition|)
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
name|ch
operator|=
literal|'\n'
expr_stmt|;
block|}
else|else
name|more
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|copysource
condition|)
block|{
name|putc
argument_list|(
name|ch
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ch
operator|==
literal|'\n'
condition|)
block|{
name|ch
operator|=
name|get
argument_list|()
expr_stmt|;
name|online
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ch
operator|==
literal|'+'
condition|)
block|{
comment|/* Continued line.  */
if|if
condition|(
name|copysource
condition|)
block|{
name|putc
argument_list|(
name|comment_char
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'+'
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
block|}
name|ch
operator|=
name|get
argument_list|()
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ch
operator|!=
name|EOF
condition|)
name|unget
argument_list|(
name|ch
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
name|sb_add_char
argument_list|(
name|in
argument_list|,
name|ch
argument_list|)
expr_stmt|;
block|}
name|online
operator|++
expr_stmt|;
block|}
return|return
name|more
return|;
block|}
end_function

begin_comment
comment|/* Find a label from sb in and put it in out.  */
end_comment

begin_function
specifier|static
name|int
name|grab_label
parameter_list|(
name|in
parameter_list|,
name|out
parameter_list|)
name|sb
modifier|*
name|in
decl_stmt|;
name|sb
modifier|*
name|out
decl_stmt|;
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
name|sb_reset
argument_list|(
name|out
argument_list|)
expr_stmt|;
if|if
condition|(
name|ISFIRSTCHAR
argument_list|(
name|in
operator|->
name|ptr
index|[
name|i
index|]
argument_list|)
operator|||
name|in
operator|->
name|ptr
index|[
name|i
index|]
operator|==
literal|'\\'
condition|)
block|{
name|sb_add_char
argument_list|(
name|out
argument_list|,
name|in
operator|->
name|ptr
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
while|while
condition|(
operator|(
name|ISNEXTCHAR
argument_list|(
name|in
operator|->
name|ptr
index|[
name|i
index|]
argument_list|)
operator|||
name|in
operator|->
name|ptr
index|[
name|i
index|]
operator|==
literal|'\\'
operator|||
name|in
operator|->
name|ptr
index|[
name|i
index|]
operator|==
literal|'&'
operator|)
operator|&&
name|i
operator|<
name|in
operator|->
name|len
condition|)
block|{
name|sb_add_char
argument_list|(
name|out
argument_list|,
name|in
operator|->
name|ptr
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
block|}
return|return
name|i
return|;
block|}
end_function

begin_comment
comment|/* Find all strange base stuff and turn into decimal.  Also    find all the other numbers and convert them from the default radix.  */
end_comment

begin_function
specifier|static
name|void
name|change_base
parameter_list|(
name|idx
parameter_list|,
name|in
parameter_list|,
name|out
parameter_list|)
name|int
name|idx
decl_stmt|;
name|sb
modifier|*
name|in
decl_stmt|;
name|sb
modifier|*
name|out
decl_stmt|;
block|{
name|char
name|buffer
index|[
literal|20
index|]
decl_stmt|;
while|while
condition|(
name|idx
operator|<
name|in
operator|->
name|len
condition|)
block|{
if|if
condition|(
name|in
operator|->
name|ptr
index|[
name|idx
index|]
operator|==
literal|'\\'
operator|&&
name|idx
operator|+
literal|1
operator|<
name|in
operator|->
name|len
operator|&&
name|in
operator|->
name|ptr
index|[
name|idx
operator|+
literal|1
index|]
operator|==
literal|'('
condition|)
block|{
name|idx
operator|+=
literal|2
expr_stmt|;
while|while
condition|(
name|idx
operator|<
name|in
operator|->
name|len
operator|&&
name|in
operator|->
name|ptr
index|[
name|idx
index|]
operator|!=
literal|')'
condition|)
block|{
name|sb_add_char
argument_list|(
name|out
argument_list|,
name|in
operator|->
name|ptr
index|[
name|idx
index|]
argument_list|)
expr_stmt|;
name|idx
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|idx
operator|<
name|in
operator|->
name|len
condition|)
name|idx
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|idx
operator|<
name|in
operator|->
name|len
operator|-
literal|1
operator|&&
name|in
operator|->
name|ptr
index|[
name|idx
operator|+
literal|1
index|]
operator|==
literal|'\''
operator|&&
operator|!
name|mri
condition|)
block|{
name|int
name|base
decl_stmt|;
name|int
name|value
decl_stmt|;
switch|switch
condition|(
name|in
operator|->
name|ptr
index|[
name|idx
index|]
condition|)
block|{
case|case
literal|'b'
case|:
case|case
literal|'B'
case|:
name|base
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|'q'
case|:
case|case
literal|'Q'
case|:
name|base
operator|=
literal|8
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
case|case
literal|'H'
case|:
name|base
operator|=
literal|16
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
case|case
literal|'D'
case|:
name|base
operator|=
literal|10
expr_stmt|;
break|break;
default|default:
name|ERROR
argument_list|(
operator|(
name|stderr
operator|,
name|_
argument_list|(
literal|"Illegal base character %c.\n"
argument_list|)
operator|,
name|in
operator|->
name|ptr
index|[
name|idx
index|]
operator|)
argument_list|)
expr_stmt|;
name|base
operator|=
literal|10
expr_stmt|;
break|break;
block|}
name|idx
operator|=
name|sb_strtol
argument_list|(
name|idx
operator|+
literal|2
argument_list|,
name|in
argument_list|,
name|base
argument_list|,
operator|&
name|value
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"%d"
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|sb_add_string
argument_list|(
name|out
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ISFIRSTCHAR
argument_list|(
name|in
operator|->
name|ptr
index|[
name|idx
index|]
argument_list|)
condition|)
block|{
comment|/* Copy entire names through quickly.  */
name|sb_add_char
argument_list|(
name|out
argument_list|,
name|in
operator|->
name|ptr
index|[
name|idx
index|]
argument_list|)
expr_stmt|;
name|idx
operator|++
expr_stmt|;
while|while
condition|(
name|idx
operator|<
name|in
operator|->
name|len
operator|&&
name|ISNEXTCHAR
argument_list|(
name|in
operator|->
name|ptr
index|[
name|idx
index|]
argument_list|)
condition|)
block|{
name|sb_add_char
argument_list|(
name|out
argument_list|,
name|in
operator|->
name|ptr
index|[
name|idx
index|]
argument_list|)
expr_stmt|;
name|idx
operator|++
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|is_flonum
argument_list|(
name|idx
argument_list|,
name|in
argument_list|)
condition|)
block|{
name|idx
operator|=
name|chew_flonum
argument_list|(
name|idx
argument_list|,
name|in
argument_list|,
name|out
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ISDIGIT
argument_list|(
name|in
operator|->
name|ptr
index|[
name|idx
index|]
argument_list|)
condition|)
block|{
name|int
name|value
decl_stmt|;
comment|/* All numbers must start with a digit, let's chew it and 	     spit out decimal.  */
name|idx
operator|=
name|sb_strtol
argument_list|(
name|idx
argument_list|,
name|in
argument_list|,
name|radix
argument_list|,
operator|&
name|value
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"%d"
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|sb_add_string
argument_list|(
name|out
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
comment|/* Skip all undigsested letters.  */
while|while
condition|(
name|idx
operator|<
name|in
operator|->
name|len
operator|&&
name|ISNEXTCHAR
argument_list|(
name|in
operator|->
name|ptr
index|[
name|idx
index|]
argument_list|)
condition|)
block|{
name|sb_add_char
argument_list|(
name|out
argument_list|,
name|in
operator|->
name|ptr
index|[
name|idx
index|]
argument_list|)
expr_stmt|;
name|idx
operator|++
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|in
operator|->
name|ptr
index|[
name|idx
index|]
operator|==
literal|'"'
operator|||
name|in
operator|->
name|ptr
index|[
name|idx
index|]
operator|==
literal|'\''
condition|)
block|{
name|char
name|tchar
init|=
name|in
operator|->
name|ptr
index|[
name|idx
index|]
decl_stmt|;
comment|/* Copy entire names through quickly.  */
name|sb_add_char
argument_list|(
name|out
argument_list|,
name|in
operator|->
name|ptr
index|[
name|idx
index|]
argument_list|)
expr_stmt|;
name|idx
operator|++
expr_stmt|;
while|while
condition|(
name|idx
operator|<
name|in
operator|->
name|len
operator|&&
name|in
operator|->
name|ptr
index|[
name|idx
index|]
operator|!=
name|tchar
condition|)
block|{
name|sb_add_char
argument_list|(
name|out
argument_list|,
name|in
operator|->
name|ptr
index|[
name|idx
index|]
argument_list|)
expr_stmt|;
name|idx
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Nothing special, just pass it through.  */
name|sb_add_char
argument_list|(
name|out
argument_list|,
name|in
operator|->
name|ptr
index|[
name|idx
index|]
argument_list|)
expr_stmt|;
name|idx
operator|++
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* .end  */
end_comment

begin_function
specifier|static
name|void
name|do_end
parameter_list|(
name|in
parameter_list|)
name|sb
modifier|*
name|in
decl_stmt|;
block|{
name|had_end
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|mri
condition|)
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"%s\n"
argument_list|,
name|sb_name
argument_list|(
name|in
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* .assign  */
end_comment

begin_function
specifier|static
name|void
name|do_assign
parameter_list|(
name|again
parameter_list|,
name|idx
parameter_list|,
name|in
parameter_list|)
name|int
name|again
decl_stmt|;
name|int
name|idx
decl_stmt|;
name|sb
modifier|*
name|in
decl_stmt|;
block|{
comment|/* Stick label in symbol table with following value.  */
name|exp_t
name|e
decl_stmt|;
name|sb
name|acc
decl_stmt|;
name|sb_new
argument_list|(
operator|&
name|acc
argument_list|)
expr_stmt|;
name|idx
operator|=
name|exp_parse
argument_list|(
name|idx
argument_list|,
name|in
argument_list|,
operator|&
name|e
argument_list|)
expr_stmt|;
name|exp_string
argument_list|(
operator|&
name|e
argument_list|,
operator|&
name|acc
argument_list|)
expr_stmt|;
name|hash_add_to_string_table
argument_list|(
operator|&
name|assign_hash_table
argument_list|,
operator|&
name|label
argument_list|,
operator|&
name|acc
argument_list|,
name|again
argument_list|)
expr_stmt|;
name|sb_kill
argument_list|(
operator|&
name|acc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* .radix [b|q|d|h]  */
end_comment

begin_function
specifier|static
name|void
name|do_radix
parameter_list|(
name|ptr
parameter_list|)
name|sb
modifier|*
name|ptr
decl_stmt|;
block|{
name|int
name|idx
init|=
name|sb_skip_white
argument_list|(
literal|0
argument_list|,
name|ptr
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|ptr
operator|->
name|ptr
index|[
name|idx
index|]
condition|)
block|{
case|case
literal|'B'
case|:
case|case
literal|'b'
case|:
name|radix
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|'q'
case|:
case|case
literal|'Q'
case|:
name|radix
operator|=
literal|8
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
case|case
literal|'D'
case|:
name|radix
operator|=
literal|10
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
case|case
literal|'H'
case|:
name|radix
operator|=
literal|16
expr_stmt|;
break|break;
default|default:
name|ERROR
argument_list|(
operator|(
name|stderr
operator|,
name|_
argument_list|(
literal|"radix is %c must be one of b, q, d or h"
argument_list|)
operator|,
name|radix
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Parse off a .b, .w or .l.  */
end_comment

begin_function
specifier|static
name|int
name|get_opsize
parameter_list|(
name|idx
parameter_list|,
name|in
parameter_list|,
name|size
parameter_list|)
name|int
name|idx
decl_stmt|;
name|sb
modifier|*
name|in
decl_stmt|;
name|int
modifier|*
name|size
decl_stmt|;
block|{
operator|*
name|size
operator|=
literal|4
expr_stmt|;
if|if
condition|(
name|in
operator|->
name|ptr
index|[
name|idx
index|]
operator|==
literal|'.'
condition|)
block|{
name|idx
operator|++
expr_stmt|;
block|}
switch|switch
condition|(
name|in
operator|->
name|ptr
index|[
name|idx
index|]
condition|)
block|{
case|case
literal|'b'
case|:
case|case
literal|'B'
case|:
operator|*
name|size
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
case|case
literal|'W'
case|:
operator|*
name|size
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
case|case
literal|'L'
case|:
operator|*
name|size
operator|=
literal|4
expr_stmt|;
break|break;
case|case
literal|' '
case|:
case|case
literal|'\t'
case|:
break|break;
default|default:
name|ERROR
argument_list|(
operator|(
name|stderr
operator|,
name|_
argument_list|(
literal|"size must be one of b, w or l, is %c.\n"
argument_list|)
operator|,
name|in
operator|->
name|ptr
index|[
name|idx
index|]
operator|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|idx
operator|++
expr_stmt|;
return|return
name|idx
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|eol
parameter_list|(
name|idx
parameter_list|,
name|line
parameter_list|)
name|int
name|idx
decl_stmt|;
name|sb
modifier|*
name|line
decl_stmt|;
block|{
name|idx
operator|=
name|sb_skip_white
argument_list|(
name|idx
argument_list|,
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|idx
operator|<
name|line
operator|->
name|len
operator|&&
name|ISCOMMENTCHAR
argument_list|(
name|line
operator|->
name|ptr
index|[
name|idx
index|]
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|idx
operator|>=
name|line
operator|->
name|len
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* .data [.b|.w|.l]<data>*     or d[bwl]<data>*  */
end_comment

begin_function
specifier|static
name|void
name|do_data
parameter_list|(
name|idx
parameter_list|,
name|in
parameter_list|,
name|size
parameter_list|)
name|int
name|idx
decl_stmt|;
name|sb
modifier|*
name|in
decl_stmt|;
name|int
name|size
decl_stmt|;
block|{
name|int
name|opsize
init|=
literal|4
decl_stmt|;
name|char
modifier|*
name|opname
init|=
literal|".yikes!"
decl_stmt|;
name|sb
name|acc
decl_stmt|;
name|sb_new
argument_list|(
operator|&
name|acc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|size
condition|)
block|{
name|idx
operator|=
name|get_opsize
argument_list|(
name|idx
argument_list|,
name|in
argument_list|,
operator|&
name|opsize
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|opsize
operator|=
name|size
expr_stmt|;
block|}
switch|switch
condition|(
name|opsize
condition|)
block|{
case|case
literal|4
case|:
name|opname
operator|=
literal|".long"
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|opname
operator|=
literal|".short"
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|opname
operator|=
literal|".byte"
expr_stmt|;
break|break;
block|}
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"%s\t"
argument_list|,
name|opname
argument_list|)
expr_stmt|;
name|idx
operator|=
name|sb_skip_white
argument_list|(
name|idx
argument_list|,
name|in
argument_list|)
expr_stmt|;
if|if
condition|(
name|alternate
operator|&&
name|idx
operator|<
name|in
operator|->
name|len
operator|&&
name|in
operator|->
name|ptr
index|[
name|idx
index|]
operator|==
literal|'"'
condition|)
block|{
name|int
name|i
decl_stmt|;
name|idx
operator|=
name|getstring
argument_list|(
name|idx
argument_list|,
name|in
argument_list|,
operator|&
name|acc
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|acc
operator|.
name|len
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
condition|)
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|","
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"%d"
argument_list|,
name|acc
operator|.
name|ptr
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
while|while
condition|(
operator|!
name|eol
argument_list|(
name|idx
argument_list|,
name|in
argument_list|)
condition|)
block|{
name|exp_t
name|e
decl_stmt|;
name|idx
operator|=
name|exp_parse
argument_list|(
name|idx
argument_list|,
name|in
argument_list|,
operator|&
name|e
argument_list|)
expr_stmt|;
name|exp_string
argument_list|(
operator|&
name|e
argument_list|,
operator|&
name|acc
argument_list|)
expr_stmt|;
name|sb_add_char
argument_list|(
operator|&
name|acc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"%s"
argument_list|,
name|acc
operator|.
name|ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|idx
operator|<
name|in
operator|->
name|len
operator|&&
name|in
operator|->
name|ptr
index|[
name|idx
index|]
operator|==
literal|','
condition|)
block|{
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|","
argument_list|)
expr_stmt|;
name|idx
operator|++
expr_stmt|;
block|}
block|}
block|}
name|sb_kill
argument_list|(
operator|&
name|acc
argument_list|)
expr_stmt|;
name|sb_print_at
argument_list|(
name|outfile
argument_list|,
name|idx
argument_list|,
name|in
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* .datab [.b|.w|.l]<repeat>,<fill>  */
end_comment

begin_function
specifier|static
name|void
name|do_datab
parameter_list|(
name|idx
parameter_list|,
name|in
parameter_list|)
name|int
name|idx
decl_stmt|;
name|sb
modifier|*
name|in
decl_stmt|;
block|{
name|int
name|opsize
decl_stmt|;
name|int
name|repeat
decl_stmt|;
name|int
name|fill
decl_stmt|;
name|idx
operator|=
name|get_opsize
argument_list|(
name|idx
argument_list|,
name|in
argument_list|,
operator|&
name|opsize
argument_list|)
expr_stmt|;
name|idx
operator|=
name|exp_get_abs
argument_list|(
name|_
argument_list|(
literal|"datab repeat must be constant.\n"
argument_list|)
argument_list|,
name|idx
argument_list|,
name|in
argument_list|,
operator|&
name|repeat
argument_list|)
expr_stmt|;
name|idx
operator|=
name|sb_skip_comma
argument_list|(
name|idx
argument_list|,
name|in
argument_list|)
expr_stmt|;
name|idx
operator|=
name|exp_get_abs
argument_list|(
name|_
argument_list|(
literal|"datab data must be absolute.\n"
argument_list|)
argument_list|,
name|idx
argument_list|,
name|in
argument_list|,
operator|&
name|fill
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|".fill\t%d,%d,%d\n"
argument_list|,
name|repeat
argument_list|,
name|opsize
argument_list|,
name|fill
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* .align<size>  */
end_comment

begin_function
specifier|static
name|void
name|do_align
parameter_list|(
name|idx
parameter_list|,
name|in
parameter_list|)
name|int
name|idx
decl_stmt|;
name|sb
modifier|*
name|in
decl_stmt|;
block|{
name|int
name|al
decl_stmt|,
name|have_fill
decl_stmt|,
name|fill
decl_stmt|;
name|idx
operator|=
name|exp_get_abs
argument_list|(
name|_
argument_list|(
literal|"align needs absolute expression.\n"
argument_list|)
argument_list|,
name|idx
argument_list|,
name|in
argument_list|,
operator|&
name|al
argument_list|)
expr_stmt|;
name|idx
operator|=
name|sb_skip_white
argument_list|(
name|idx
argument_list|,
name|in
argument_list|)
expr_stmt|;
name|have_fill
operator|=
literal|0
expr_stmt|;
name|fill
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|eol
argument_list|(
name|idx
argument_list|,
name|in
argument_list|)
condition|)
block|{
name|idx
operator|=
name|sb_skip_comma
argument_list|(
name|idx
argument_list|,
name|in
argument_list|)
expr_stmt|;
name|idx
operator|=
name|exp_get_abs
argument_list|(
name|_
argument_list|(
literal|".align needs absolute fill value.\n"
argument_list|)
argument_list|,
name|idx
argument_list|,
name|in
argument_list|,
operator|&
name|fill
argument_list|)
expr_stmt|;
name|have_fill
operator|=
literal|1
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|".align	%d"
argument_list|,
name|al
argument_list|)
expr_stmt|;
if|if
condition|(
name|have_fill
condition|)
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|",%d"
argument_list|,
name|fill
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* .res[.b|.w|.l]<size>  */
end_comment

begin_function
specifier|static
name|void
name|do_res
parameter_list|(
name|idx
parameter_list|,
name|in
parameter_list|,
name|type
parameter_list|)
name|int
name|idx
decl_stmt|;
name|sb
modifier|*
name|in
decl_stmt|;
name|int
name|type
decl_stmt|;
block|{
name|int
name|size
init|=
literal|4
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
name|idx
operator|=
name|get_opsize
argument_list|(
name|idx
argument_list|,
name|in
argument_list|,
operator|&
name|size
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|eol
argument_list|(
name|idx
argument_list|,
name|in
argument_list|)
condition|)
block|{
name|idx
operator|=
name|sb_skip_white
argument_list|(
name|idx
argument_list|,
name|in
argument_list|)
expr_stmt|;
if|if
condition|(
name|in
operator|->
name|ptr
index|[
name|idx
index|]
operator|==
literal|','
condition|)
name|idx
operator|++
expr_stmt|;
name|idx
operator|=
name|exp_get_abs
argument_list|(
name|_
argument_list|(
literal|"res needs absolute expression for fill count.\n"
argument_list|)
argument_list|,
name|idx
argument_list|,
name|in
argument_list|,
operator|&
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
literal|'c'
operator|||
name|type
operator|==
literal|'z'
condition|)
name|count
operator|++
expr_stmt|;
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|".space	%d\n"
argument_list|,
name|count
operator|*
name|size
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* .export  */
end_comment

begin_function
specifier|static
name|void
name|do_export
parameter_list|(
name|in
parameter_list|)
name|sb
modifier|*
name|in
decl_stmt|;
block|{
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|".global	%s\n"
argument_list|,
name|sb_name
argument_list|(
name|in
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* .print [list] [nolist]  */
end_comment

begin_function
specifier|static
name|void
name|do_print
parameter_list|(
name|idx
parameter_list|,
name|in
parameter_list|)
name|int
name|idx
decl_stmt|;
name|sb
modifier|*
name|in
decl_stmt|;
block|{
name|idx
operator|=
name|sb_skip_white
argument_list|(
name|idx
argument_list|,
name|in
argument_list|)
expr_stmt|;
while|while
condition|(
name|idx
operator|<
name|in
operator|->
name|len
condition|)
block|{
if|if
condition|(
name|strncasecmp
argument_list|(
name|in
operator|->
name|ptr
operator|+
name|idx
argument_list|,
literal|"LIST"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|".list\n"
argument_list|)
expr_stmt|;
name|idx
operator|+=
literal|4
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncasecmp
argument_list|(
name|in
operator|->
name|ptr
operator|+
name|idx
argument_list|,
literal|"NOLIST"
argument_list|,
literal|6
argument_list|)
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|".nolist\n"
argument_list|)
expr_stmt|;
name|idx
operator|+=
literal|6
expr_stmt|;
block|}
name|idx
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* .head  */
end_comment

begin_function
specifier|static
name|void
name|do_heading
parameter_list|(
name|idx
parameter_list|,
name|in
parameter_list|)
name|int
name|idx
decl_stmt|;
name|sb
modifier|*
name|in
decl_stmt|;
block|{
name|sb
name|head
decl_stmt|;
name|sb_new
argument_list|(
operator|&
name|head
argument_list|)
expr_stmt|;
name|idx
operator|=
name|getstring
argument_list|(
name|idx
argument_list|,
name|in
argument_list|,
operator|&
name|head
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|".title	\"%s\"\n"
argument_list|,
name|sb_name
argument_list|(
operator|&
name|head
argument_list|)
argument_list|)
expr_stmt|;
name|sb_kill
argument_list|(
operator|&
name|head
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* .page  */
end_comment

begin_function
specifier|static
name|void
name|do_page
parameter_list|()
block|{
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|".eject\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* .form [lin=<value>] [col=<value>]  */
end_comment

begin_function
specifier|static
name|void
name|do_form
parameter_list|(
name|idx
parameter_list|,
name|in
parameter_list|)
name|int
name|idx
decl_stmt|;
name|sb
modifier|*
name|in
decl_stmt|;
block|{
name|int
name|lines
init|=
literal|60
decl_stmt|;
name|int
name|columns
init|=
literal|132
decl_stmt|;
name|idx
operator|=
name|sb_skip_white
argument_list|(
name|idx
argument_list|,
name|in
argument_list|)
expr_stmt|;
while|while
condition|(
name|idx
operator|<
name|in
operator|->
name|len
condition|)
block|{
if|if
condition|(
name|strncasecmp
argument_list|(
name|in
operator|->
name|ptr
operator|+
name|idx
argument_list|,
literal|"LIN="
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
block|{
name|idx
operator|+=
literal|4
expr_stmt|;
name|idx
operator|=
name|exp_get_abs
argument_list|(
name|_
argument_list|(
literal|"form LIN= needs absolute expresssion.\n"
argument_list|)
argument_list|,
name|idx
argument_list|,
name|in
argument_list|,
operator|&
name|lines
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|strncasecmp
argument_list|(
name|in
operator|->
name|ptr
operator|+
name|idx
argument_list|,
name|_
argument_list|(
literal|"COL="
argument_list|)
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
block|{
name|idx
operator|+=
literal|4
expr_stmt|;
name|idx
operator|=
name|exp_get_abs
argument_list|(
name|_
argument_list|(
literal|"form COL= needs absolute expresssion.\n"
argument_list|)
argument_list|,
name|idx
argument_list|,
name|in
argument_list|,
operator|&
name|columns
argument_list|)
expr_stmt|;
block|}
name|idx
operator|++
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|".psize %d,%d\n"
argument_list|,
name|lines
argument_list|,
name|columns
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Fetch string from the input stream,    rules:     'Bxyx<whitespace>  	-> return 'Bxyza     %<char>		-> return string of decimal value of x     "<string>"		-> return string     xyx<whitespace>     -> return xyz */
end_comment

begin_function
specifier|static
name|int
name|get_any_string
parameter_list|(
name|idx
parameter_list|,
name|in
parameter_list|,
name|out
parameter_list|,
name|expand
parameter_list|,
name|pretend_quoted
parameter_list|)
name|int
name|idx
decl_stmt|;
name|sb
modifier|*
name|in
decl_stmt|;
name|sb
modifier|*
name|out
decl_stmt|;
name|int
name|expand
decl_stmt|;
name|int
name|pretend_quoted
decl_stmt|;
block|{
name|sb_reset
argument_list|(
name|out
argument_list|)
expr_stmt|;
name|idx
operator|=
name|sb_skip_white
argument_list|(
name|idx
argument_list|,
name|in
argument_list|)
expr_stmt|;
if|if
condition|(
name|idx
operator|<
name|in
operator|->
name|len
condition|)
block|{
if|if
condition|(
name|in
operator|->
name|len
operator|>
literal|2
operator|&&
name|in
operator|->
name|ptr
index|[
name|idx
operator|+
literal|1
index|]
operator|==
literal|'\''
operator|&&
name|ISBASE
argument_list|(
name|in
operator|->
name|ptr
index|[
name|idx
index|]
argument_list|)
condition|)
block|{
while|while
condition|(
operator|!
name|ISSEP
argument_list|(
name|in
operator|->
name|ptr
index|[
name|idx
index|]
argument_list|)
condition|)
name|sb_add_char
argument_list|(
name|out
argument_list|,
name|in
operator|->
name|ptr
index|[
name|idx
operator|++
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|in
operator|->
name|ptr
index|[
name|idx
index|]
operator|==
literal|'%'
operator|&&
name|alternate
operator|&&
name|expand
condition|)
block|{
name|int
name|val
decl_stmt|;
name|char
name|buf
index|[
literal|20
index|]
decl_stmt|;
comment|/* Turns the next expression into a string.  */
comment|/* xgettext: no-c-format */
name|idx
operator|=
name|exp_get_abs
argument_list|(
name|_
argument_list|(
literal|"% operator needs absolute expression"
argument_list|)
argument_list|,
name|idx
operator|+
literal|1
argument_list|,
name|in
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%d"
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|sb_add_string
argument_list|(
name|out
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|in
operator|->
name|ptr
index|[
name|idx
index|]
operator|==
literal|'"'
operator|||
name|in
operator|->
name|ptr
index|[
name|idx
index|]
operator|==
literal|'<'
operator|||
operator|(
name|alternate
operator|&&
name|in
operator|->
name|ptr
index|[
name|idx
index|]
operator|==
literal|'\''
operator|)
condition|)
block|{
if|if
condition|(
name|alternate
operator|&&
name|expand
condition|)
block|{
comment|/* Keep the quotes.  */
name|sb_add_char
argument_list|(
name|out
argument_list|,
literal|'\"'
argument_list|)
expr_stmt|;
name|idx
operator|=
name|getstring
argument_list|(
name|idx
argument_list|,
name|in
argument_list|,
name|out
argument_list|)
expr_stmt|;
name|sb_add_char
argument_list|(
name|out
argument_list|,
literal|'\"'
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|idx
operator|=
name|getstring
argument_list|(
name|idx
argument_list|,
name|in
argument_list|,
name|out
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
while|while
condition|(
name|idx
operator|<
name|in
operator|->
name|len
operator|&&
operator|(
name|in
operator|->
name|ptr
index|[
name|idx
index|]
operator|==
literal|'"'
operator|||
name|in
operator|->
name|ptr
index|[
name|idx
index|]
operator|==
literal|'\''
operator|||
name|pretend_quoted
operator|||
operator|!
name|ISSEP
argument_list|(
name|in
operator|->
name|ptr
index|[
name|idx
index|]
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|in
operator|->
name|ptr
index|[
name|idx
index|]
operator|==
literal|'"'
operator|||
name|in
operator|->
name|ptr
index|[
name|idx
index|]
operator|==
literal|'\''
condition|)
block|{
name|char
name|tchar
init|=
name|in
operator|->
name|ptr
index|[
name|idx
index|]
decl_stmt|;
name|sb_add_char
argument_list|(
name|out
argument_list|,
name|in
operator|->
name|ptr
index|[
name|idx
operator|++
index|]
argument_list|)
expr_stmt|;
while|while
condition|(
name|idx
operator|<
name|in
operator|->
name|len
operator|&&
name|in
operator|->
name|ptr
index|[
name|idx
index|]
operator|!=
name|tchar
condition|)
name|sb_add_char
argument_list|(
name|out
argument_list|,
name|in
operator|->
name|ptr
index|[
name|idx
operator|++
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|idx
operator|==
name|in
operator|->
name|len
condition|)
return|return
name|idx
return|;
block|}
name|sb_add_char
argument_list|(
name|out
argument_list|,
name|in
operator|->
name|ptr
index|[
name|idx
operator|++
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|idx
return|;
block|}
end_function

begin_comment
comment|/* Skip along sb in starting at idx, suck off whitespace a ( and more    whitespace.  Return the idx of the next char.  */
end_comment

begin_function
specifier|static
name|int
name|skip_openp
parameter_list|(
name|idx
parameter_list|,
name|in
parameter_list|)
name|int
name|idx
decl_stmt|;
name|sb
modifier|*
name|in
decl_stmt|;
block|{
name|idx
operator|=
name|sb_skip_white
argument_list|(
name|idx
argument_list|,
name|in
argument_list|)
expr_stmt|;
if|if
condition|(
name|in
operator|->
name|ptr
index|[
name|idx
index|]
operator|!=
literal|'('
condition|)
name|ERROR
argument_list|(
operator|(
name|stderr
operator|,
name|_
argument_list|(
literal|"misplaced ( .\n"
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|idx
operator|=
name|sb_skip_white
argument_list|(
name|idx
operator|+
literal|1
argument_list|,
name|in
argument_list|)
expr_stmt|;
return|return
name|idx
return|;
block|}
end_function

begin_comment
comment|/* Skip along sb in starting at idx, suck off whitespace a ) and more    whitespace.  Return the idx of the next char.  */
end_comment

begin_function
specifier|static
name|int
name|skip_closep
parameter_list|(
name|idx
parameter_list|,
name|in
parameter_list|)
name|int
name|idx
decl_stmt|;
name|sb
modifier|*
name|in
decl_stmt|;
block|{
name|idx
operator|=
name|sb_skip_white
argument_list|(
name|idx
argument_list|,
name|in
argument_list|)
expr_stmt|;
if|if
condition|(
name|in
operator|->
name|ptr
index|[
name|idx
index|]
operator|!=
literal|')'
condition|)
name|ERROR
argument_list|(
operator|(
name|stderr
operator|,
name|_
argument_list|(
literal|"misplaced ).\n"
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|idx
operator|=
name|sb_skip_white
argument_list|(
name|idx
operator|+
literal|1
argument_list|,
name|in
argument_list|)
expr_stmt|;
return|return
name|idx
return|;
block|}
end_function

begin_comment
comment|/* .len  */
end_comment

begin_function
specifier|static
name|int
name|dolen
parameter_list|(
name|idx
parameter_list|,
name|in
parameter_list|,
name|out
parameter_list|)
name|int
name|idx
decl_stmt|;
name|sb
modifier|*
name|in
decl_stmt|;
name|sb
modifier|*
name|out
decl_stmt|;
block|{
name|sb
name|stringout
decl_stmt|;
name|char
name|buffer
index|[
literal|10
index|]
decl_stmt|;
name|sb_new
argument_list|(
operator|&
name|stringout
argument_list|)
expr_stmt|;
name|idx
operator|=
name|skip_openp
argument_list|(
name|idx
argument_list|,
name|in
argument_list|)
expr_stmt|;
name|idx
operator|=
name|get_and_process
argument_list|(
name|idx
argument_list|,
name|in
argument_list|,
operator|&
name|stringout
argument_list|)
expr_stmt|;
name|idx
operator|=
name|skip_closep
argument_list|(
name|idx
argument_list|,
name|in
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"%d"
argument_list|,
name|stringout
operator|.
name|len
argument_list|)
expr_stmt|;
name|sb_add_string
argument_list|(
name|out
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
name|sb_kill
argument_list|(
operator|&
name|stringout
argument_list|)
expr_stmt|;
return|return
name|idx
return|;
block|}
end_function

begin_comment
comment|/* .instr  */
end_comment

begin_function
specifier|static
name|int
name|doinstr
parameter_list|(
name|idx
parameter_list|,
name|in
parameter_list|,
name|out
parameter_list|)
name|int
name|idx
decl_stmt|;
name|sb
modifier|*
name|in
decl_stmt|;
name|sb
modifier|*
name|out
decl_stmt|;
block|{
name|sb
name|string
decl_stmt|;
name|sb
name|search
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|start
decl_stmt|;
name|int
name|res
decl_stmt|;
name|char
name|buffer
index|[
literal|10
index|]
decl_stmt|;
name|sb_new
argument_list|(
operator|&
name|string
argument_list|)
expr_stmt|;
name|sb_new
argument_list|(
operator|&
name|search
argument_list|)
expr_stmt|;
name|idx
operator|=
name|skip_openp
argument_list|(
name|idx
argument_list|,
name|in
argument_list|)
expr_stmt|;
name|idx
operator|=
name|get_and_process
argument_list|(
name|idx
argument_list|,
name|in
argument_list|,
operator|&
name|string
argument_list|)
expr_stmt|;
name|idx
operator|=
name|sb_skip_comma
argument_list|(
name|idx
argument_list|,
name|in
argument_list|)
expr_stmt|;
name|idx
operator|=
name|get_and_process
argument_list|(
name|idx
argument_list|,
name|in
argument_list|,
operator|&
name|search
argument_list|)
expr_stmt|;
name|idx
operator|=
name|sb_skip_comma
argument_list|(
name|idx
argument_list|,
name|in
argument_list|)
expr_stmt|;
if|if
condition|(
name|ISDIGIT
argument_list|(
name|in
operator|->
name|ptr
index|[
name|idx
index|]
argument_list|)
condition|)
block|{
name|idx
operator|=
name|exp_get_abs
argument_list|(
name|_
argument_list|(
literal|".instr needs absolute expresson.\n"
argument_list|)
argument_list|,
name|idx
argument_list|,
name|in
argument_list|,
operator|&
name|start
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|start
operator|=
literal|0
expr_stmt|;
block|}
name|idx
operator|=
name|skip_closep
argument_list|(
name|idx
argument_list|,
name|in
argument_list|)
expr_stmt|;
name|res
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
name|start
init|;
name|i
operator|<
name|string
operator|.
name|len
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|string
operator|.
name|ptr
operator|+
name|i
argument_list|,
name|search
operator|.
name|ptr
argument_list|,
name|search
operator|.
name|len
argument_list|)
operator|==
literal|0
condition|)
block|{
name|res
operator|=
name|i
expr_stmt|;
break|break;
block|}
block|}
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"%d"
argument_list|,
name|res
argument_list|)
expr_stmt|;
name|sb_add_string
argument_list|(
name|out
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
name|sb_kill
argument_list|(
operator|&
name|string
argument_list|)
expr_stmt|;
name|sb_kill
argument_list|(
operator|&
name|search
argument_list|)
expr_stmt|;
return|return
name|idx
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dosubstr
parameter_list|(
name|idx
parameter_list|,
name|in
parameter_list|,
name|out
parameter_list|)
name|int
name|idx
decl_stmt|;
name|sb
modifier|*
name|in
decl_stmt|;
name|sb
modifier|*
name|out
decl_stmt|;
block|{
name|sb
name|string
decl_stmt|;
name|int
name|pos
decl_stmt|;
name|int
name|len
decl_stmt|;
name|sb_new
argument_list|(
operator|&
name|string
argument_list|)
expr_stmt|;
name|idx
operator|=
name|skip_openp
argument_list|(
name|idx
argument_list|,
name|in
argument_list|)
expr_stmt|;
name|idx
operator|=
name|get_and_process
argument_list|(
name|idx
argument_list|,
name|in
argument_list|,
operator|&
name|string
argument_list|)
expr_stmt|;
name|idx
operator|=
name|sb_skip_comma
argument_list|(
name|idx
argument_list|,
name|in
argument_list|)
expr_stmt|;
name|idx
operator|=
name|exp_get_abs
argument_list|(
name|_
argument_list|(
literal|"need absolute position.\n"
argument_list|)
argument_list|,
name|idx
argument_list|,
name|in
argument_list|,
operator|&
name|pos
argument_list|)
expr_stmt|;
name|idx
operator|=
name|sb_skip_comma
argument_list|(
name|idx
argument_list|,
name|in
argument_list|)
expr_stmt|;
name|idx
operator|=
name|exp_get_abs
argument_list|(
name|_
argument_list|(
literal|"need absolute length.\n"
argument_list|)
argument_list|,
name|idx
argument_list|,
name|in
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
name|idx
operator|=
name|skip_closep
argument_list|(
name|idx
argument_list|,
name|in
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
literal|0
operator|||
name|pos
operator|<
literal|0
operator|||
name|pos
operator|>
name|string
operator|.
name|len
operator|||
name|pos
operator|+
name|len
operator|>
name|string
operator|.
name|len
condition|)
block|{
name|sb_add_string
argument_list|(
name|out
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sb_add_char
argument_list|(
name|out
argument_list|,
literal|'"'
argument_list|)
expr_stmt|;
while|while
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|sb_add_char
argument_list|(
name|out
argument_list|,
name|string
operator|.
name|ptr
index|[
name|pos
operator|++
index|]
argument_list|)
expr_stmt|;
name|len
operator|--
expr_stmt|;
block|}
name|sb_add_char
argument_list|(
name|out
argument_list|,
literal|'"'
argument_list|)
expr_stmt|;
block|}
name|sb_kill
argument_list|(
operator|&
name|string
argument_list|)
expr_stmt|;
return|return
name|idx
return|;
block|}
end_function

begin_comment
comment|/* Scan line, change tokens in the hash table to their replacements.  */
end_comment

begin_function
specifier|static
name|void
name|process_assigns
parameter_list|(
name|idx
parameter_list|,
name|in
parameter_list|,
name|buf
parameter_list|)
name|int
name|idx
decl_stmt|;
name|sb
modifier|*
name|in
decl_stmt|;
name|sb
modifier|*
name|buf
decl_stmt|;
block|{
while|while
condition|(
name|idx
operator|<
name|in
operator|->
name|len
condition|)
block|{
name|hash_entry
modifier|*
name|ptr
decl_stmt|;
if|if
condition|(
name|in
operator|->
name|ptr
index|[
name|idx
index|]
operator|==
literal|'\\'
operator|&&
name|idx
operator|+
literal|1
operator|<
name|in
operator|->
name|len
operator|&&
name|in
operator|->
name|ptr
index|[
name|idx
operator|+
literal|1
index|]
operator|==
literal|'('
condition|)
block|{
do|do
block|{
name|sb_add_char
argument_list|(
name|buf
argument_list|,
name|in
operator|->
name|ptr
index|[
name|idx
index|]
argument_list|)
expr_stmt|;
name|idx
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|idx
operator|<
name|in
operator|->
name|len
operator|&&
name|in
operator|->
name|ptr
index|[
name|idx
operator|-
literal|1
index|]
operator|!=
literal|')'
condition|)
do|;
block|}
elseif|else
if|if
condition|(
name|in
operator|->
name|ptr
index|[
name|idx
index|]
operator|==
literal|'\\'
operator|&&
name|idx
operator|+
literal|1
operator|<
name|in
operator|->
name|len
operator|&&
name|in
operator|->
name|ptr
index|[
name|idx
operator|+
literal|1
index|]
operator|==
literal|'&'
condition|)
block|{
name|idx
operator|=
name|condass_lookup_name
argument_list|(
name|in
argument_list|,
name|idx
operator|+
literal|2
argument_list|,
name|buf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|in
operator|->
name|ptr
index|[
name|idx
index|]
operator|==
literal|'\\'
operator|&&
name|idx
operator|+
literal|1
operator|<
name|in
operator|->
name|len
operator|&&
name|in
operator|->
name|ptr
index|[
name|idx
operator|+
literal|1
index|]
operator|==
literal|'$'
condition|)
block|{
name|idx
operator|=
name|condass_lookup_name
argument_list|(
name|in
argument_list|,
name|idx
operator|+
literal|2
argument_list|,
name|buf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|idx
operator|+
literal|3
operator|<
name|in
operator|->
name|len
operator|&&
name|in
operator|->
name|ptr
index|[
name|idx
index|]
operator|==
literal|'.'
operator|&&
name|TOUPPER
argument_list|(
name|in
operator|->
name|ptr
index|[
name|idx
operator|+
literal|1
index|]
argument_list|)
operator|==
literal|'L'
operator|&&
name|TOUPPER
argument_list|(
name|in
operator|->
name|ptr
index|[
name|idx
operator|+
literal|2
index|]
argument_list|)
operator|==
literal|'E'
operator|&&
name|TOUPPER
argument_list|(
name|in
operator|->
name|ptr
index|[
name|idx
operator|+
literal|3
index|]
argument_list|)
operator|==
literal|'N'
condition|)
name|idx
operator|=
name|dolen
argument_list|(
name|idx
operator|+
literal|4
argument_list|,
name|in
argument_list|,
name|buf
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|idx
operator|+
literal|6
operator|<
name|in
operator|->
name|len
operator|&&
name|in
operator|->
name|ptr
index|[
name|idx
index|]
operator|==
literal|'.'
operator|&&
name|TOUPPER
argument_list|(
name|in
operator|->
name|ptr
index|[
name|idx
operator|+
literal|1
index|]
argument_list|)
operator|==
literal|'I'
operator|&&
name|TOUPPER
argument_list|(
name|in
operator|->
name|ptr
index|[
name|idx
operator|+
literal|2
index|]
argument_list|)
operator|==
literal|'N'
operator|&&
name|TOUPPER
argument_list|(
name|in
operator|->
name|ptr
index|[
name|idx
operator|+
literal|3
index|]
argument_list|)
operator|==
literal|'S'
operator|&&
name|TOUPPER
argument_list|(
name|in
operator|->
name|ptr
index|[
name|idx
operator|+
literal|4
index|]
argument_list|)
operator|==
literal|'T'
operator|&&
name|TOUPPER
argument_list|(
name|in
operator|->
name|ptr
index|[
name|idx
operator|+
literal|5
index|]
argument_list|)
operator|==
literal|'R'
condition|)
name|idx
operator|=
name|doinstr
argument_list|(
name|idx
operator|+
literal|6
argument_list|,
name|in
argument_list|,
name|buf
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|idx
operator|+
literal|7
operator|<
name|in
operator|->
name|len
operator|&&
name|in
operator|->
name|ptr
index|[
name|idx
index|]
operator|==
literal|'.'
operator|&&
name|TOUPPER
argument_list|(
name|in
operator|->
name|ptr
index|[
name|idx
operator|+
literal|1
index|]
argument_list|)
operator|==
literal|'S'
operator|&&
name|TOUPPER
argument_list|(
name|in
operator|->
name|ptr
index|[
name|idx
operator|+
literal|2
index|]
argument_list|)
operator|==
literal|'U'
operator|&&
name|TOUPPER
argument_list|(
name|in
operator|->
name|ptr
index|[
name|idx
operator|+
literal|3
index|]
argument_list|)
operator|==
literal|'B'
operator|&&
name|TOUPPER
argument_list|(
name|in
operator|->
name|ptr
index|[
name|idx
operator|+
literal|4
index|]
argument_list|)
operator|==
literal|'S'
operator|&&
name|TOUPPER
argument_list|(
name|in
operator|->
name|ptr
index|[
name|idx
operator|+
literal|5
index|]
argument_list|)
operator|==
literal|'T'
operator|&&
name|TOUPPER
argument_list|(
name|in
operator|->
name|ptr
index|[
name|idx
operator|+
literal|6
index|]
argument_list|)
operator|==
literal|'R'
condition|)
name|idx
operator|=
name|dosubstr
argument_list|(
name|idx
operator|+
literal|7
argument_list|,
name|in
argument_list|,
name|buf
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ISFIRSTCHAR
argument_list|(
name|in
operator|->
name|ptr
index|[
name|idx
index|]
argument_list|)
condition|)
block|{
comment|/* May be a simple name subsitution, see if we have a word.  */
name|sb
name|acc
decl_stmt|;
name|int
name|cur
init|=
name|idx
operator|+
literal|1
decl_stmt|;
while|while
condition|(
name|cur
operator|<
name|in
operator|->
name|len
operator|&&
operator|(
name|ISNEXTCHAR
argument_list|(
name|in
operator|->
name|ptr
index|[
name|cur
index|]
argument_list|)
operator|)
condition|)
name|cur
operator|++
expr_stmt|;
name|sb_new
argument_list|(
operator|&
name|acc
argument_list|)
expr_stmt|;
name|sb_add_buffer
argument_list|(
operator|&
name|acc
argument_list|,
name|in
operator|->
name|ptr
operator|+
name|idx
argument_list|,
name|cur
operator|-
name|idx
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|hash_lookup
argument_list|(
operator|&
name|assign_hash_table
argument_list|,
operator|&
name|acc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
condition|)
block|{
comment|/* Found a definition for it.  */
name|sb_add_sb
argument_list|(
name|buf
argument_list|,
operator|&
name|ptr
operator|->
name|value
operator|.
name|s
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* No definition, just copy the word.  */
name|sb_add_sb
argument_list|(
name|buf
argument_list|,
operator|&
name|acc
argument_list|)
expr_stmt|;
block|}
name|sb_kill
argument_list|(
operator|&
name|acc
argument_list|)
expr_stmt|;
name|idx
operator|=
name|cur
expr_stmt|;
block|}
else|else
block|{
name|sb_add_char
argument_list|(
name|buf
argument_list|,
name|in
operator|->
name|ptr
index|[
name|idx
operator|++
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|get_and_process
parameter_list|(
name|idx
parameter_list|,
name|in
parameter_list|,
name|out
parameter_list|)
name|int
name|idx
decl_stmt|;
name|sb
modifier|*
name|in
decl_stmt|;
name|sb
modifier|*
name|out
decl_stmt|;
block|{
name|sb
name|t
decl_stmt|;
name|sb_new
argument_list|(
operator|&
name|t
argument_list|)
expr_stmt|;
name|idx
operator|=
name|get_any_string
argument_list|(
name|idx
argument_list|,
name|in
argument_list|,
operator|&
name|t
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|process_assigns
argument_list|(
literal|0
argument_list|,
operator|&
name|t
argument_list|,
name|out
argument_list|)
expr_stmt|;
name|sb_kill
argument_list|(
operator|&
name|t
argument_list|)
expr_stmt|;
return|return
name|idx
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|process_file
parameter_list|()
block|{
name|sb
name|line
decl_stmt|;
name|sb
name|t1
decl_stmt|,
name|t2
decl_stmt|;
name|sb
name|acc
decl_stmt|;
name|sb
name|label_in
decl_stmt|;
name|int
name|more
decl_stmt|;
name|sb_new
argument_list|(
operator|&
name|line
argument_list|)
expr_stmt|;
name|sb_new
argument_list|(
operator|&
name|t1
argument_list|)
expr_stmt|;
name|sb_new
argument_list|(
operator|&
name|t2
argument_list|)
expr_stmt|;
name|sb_new
argument_list|(
operator|&
name|acc
argument_list|)
expr_stmt|;
name|sb_new
argument_list|(
operator|&
name|label_in
argument_list|)
expr_stmt|;
name|sb_reset
argument_list|(
operator|&
name|line
argument_list|)
expr_stmt|;
name|more
operator|=
name|get_line
argument_list|(
operator|&
name|line
argument_list|)
expr_stmt|;
while|while
condition|(
name|more
condition|)
block|{
comment|/* Find any label and pseudo op that we're intested in.  */
name|int
name|l
decl_stmt|;
if|if
condition|(
name|line
operator|.
name|len
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|condass_on
argument_list|()
condition|)
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mri
operator|&&
operator|(
name|line
operator|.
name|ptr
index|[
literal|0
index|]
operator|==
literal|'*'
operator|||
name|line
operator|.
name|ptr
index|[
literal|0
index|]
operator|==
literal|'!'
operator|)
condition|)
block|{
comment|/* MRI line comment.  */
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"%s"
argument_list|,
name|sb_name
argument_list|(
operator|&
name|line
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|l
operator|=
name|grab_label
argument_list|(
operator|&
name|line
argument_list|,
operator|&
name|label_in
argument_list|)
expr_stmt|;
name|sb_reset
argument_list|(
operator|&
name|label
argument_list|)
expr_stmt|;
if|if
condition|(
name|line
operator|.
name|ptr
index|[
name|l
index|]
operator|==
literal|':'
condition|)
name|l
operator|++
expr_stmt|;
while|while
condition|(
name|ISWHITE
argument_list|(
name|line
operator|.
name|ptr
index|[
name|l
index|]
argument_list|)
operator|&&
name|l
operator|<
name|line
operator|.
name|len
condition|)
name|l
operator|++
expr_stmt|;
if|if
condition|(
name|label_in
operator|.
name|len
condition|)
block|{
name|int
name|do_assigns
decl_stmt|;
comment|/* Munge the label, unless this is EQU or ASSIGN.  */
name|do_assigns
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|l
operator|<
name|line
operator|.
name|len
operator|&&
operator|(
name|line
operator|.
name|ptr
index|[
name|l
index|]
operator|==
literal|'.'
operator|||
name|alternate
operator|||
name|mri
operator|)
condition|)
block|{
name|int
name|lx
init|=
name|l
decl_stmt|;
if|if
condition|(
name|line
operator|.
name|ptr
index|[
name|lx
index|]
operator|==
literal|'.'
condition|)
operator|++
name|lx
expr_stmt|;
if|if
condition|(
name|lx
operator|+
literal|3
operator|<=
name|line
operator|.
name|len
operator|&&
name|strncasecmp
argument_list|(
literal|"EQU"
argument_list|,
name|line
operator|.
name|ptr
operator|+
name|lx
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|lx
operator|+
literal|3
operator|==
name|line
operator|.
name|len
operator|||
operator|!
name|ISFIRSTCHAR
argument_list|(
name|line
operator|.
name|ptr
index|[
name|lx
operator|+
literal|3
index|]
argument_list|)
operator|)
condition|)
name|do_assigns
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|lx
operator|+
literal|6
operator|<=
name|line
operator|.
name|len
operator|&&
name|strncasecmp
argument_list|(
literal|"ASSIGN"
argument_list|,
name|line
operator|.
name|ptr
operator|+
name|lx
argument_list|,
literal|6
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|lx
operator|+
literal|6
operator|==
name|line
operator|.
name|len
operator|||
operator|!
name|ISFIRSTCHAR
argument_list|(
name|line
operator|.
name|ptr
index|[
name|lx
operator|+
literal|6
index|]
argument_list|)
operator|)
condition|)
name|do_assigns
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|do_assigns
condition|)
name|process_assigns
argument_list|(
literal|0
argument_list|,
operator|&
name|label_in
argument_list|,
operator|&
name|label
argument_list|)
expr_stmt|;
else|else
name|sb_add_sb
argument_list|(
operator|&
name|label
argument_list|,
operator|&
name|label_in
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|l
operator|<
name|line
operator|.
name|len
condition|)
block|{
if|if
condition|(
name|process_pseudo_op
argument_list|(
name|l
argument_list|,
operator|&
name|line
argument_list|,
operator|&
name|acc
argument_list|)
condition|)
block|{  		}
elseif|else
if|if
condition|(
name|condass_on
argument_list|()
condition|)
block|{
if|if
condition|(
name|macro_op
argument_list|(
name|l
argument_list|,
operator|&
name|line
argument_list|)
condition|)
block|{  		    }
else|else
block|{
block|{
if|if
condition|(
name|label
operator|.
name|len
condition|)
block|{
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"%s:\t"
argument_list|,
name|sb_name
argument_list|(
operator|&
name|label
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"\t"
argument_list|)
expr_stmt|;
name|sb_reset
argument_list|(
operator|&
name|t1
argument_list|)
expr_stmt|;
name|process_assigns
argument_list|(
name|l
argument_list|,
operator|&
name|line
argument_list|,
operator|&
name|t1
argument_list|)
expr_stmt|;
name|sb_reset
argument_list|(
operator|&
name|t2
argument_list|)
expr_stmt|;
name|change_base
argument_list|(
literal|0
argument_list|,
operator|&
name|t1
argument_list|,
operator|&
name|t2
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"%s\n"
argument_list|,
name|sb_name
argument_list|(
operator|&
name|t2
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
else|else
block|{
comment|/* Only a label on this line.  */
if|if
condition|(
name|label
operator|.
name|len
operator|&&
name|condass_on
argument_list|()
condition|)
block|{
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"%s:\n"
argument_list|,
name|sb_name
argument_list|(
operator|&
name|label
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|had_end
condition|)
break|break;
name|sb_reset
argument_list|(
operator|&
name|line
argument_list|)
expr_stmt|;
name|more
operator|=
name|get_line
argument_list|(
operator|&
name|line
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|had_end
operator|&&
operator|!
name|mri
condition|)
name|WARNING
argument_list|(
operator|(
name|stderr
operator|,
name|_
argument_list|(
literal|"END missing from end of file.\n"
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|free_old_entry
parameter_list|(
name|ptr
parameter_list|)
name|hash_entry
modifier|*
name|ptr
decl_stmt|;
block|{
if|if
condition|(
name|ptr
condition|)
block|{
if|if
condition|(
name|ptr
operator|->
name|type
operator|==
name|hash_string
condition|)
name|sb_kill
argument_list|(
operator|&
name|ptr
operator|->
name|value
operator|.
name|s
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* name: .ASSIGNA<value>  */
end_comment

begin_function
specifier|static
name|void
name|do_assigna
parameter_list|(
name|idx
parameter_list|,
name|in
parameter_list|)
name|int
name|idx
decl_stmt|;
name|sb
modifier|*
name|in
decl_stmt|;
block|{
name|sb
name|tmp
decl_stmt|;
name|int
name|val
decl_stmt|;
name|sb_new
argument_list|(
operator|&
name|tmp
argument_list|)
expr_stmt|;
name|process_assigns
argument_list|(
name|idx
argument_list|,
name|in
argument_list|,
operator|&
name|tmp
argument_list|)
expr_stmt|;
name|idx
operator|=
name|exp_get_abs
argument_list|(
name|_
argument_list|(
literal|".ASSIGNA needs constant expression argument.\n"
argument_list|)
argument_list|,
literal|0
argument_list|,
operator|&
name|tmp
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|label
operator|.
name|len
condition|)
block|{
name|ERROR
argument_list|(
operator|(
name|stderr
operator|,
name|_
argument_list|(
literal|".ASSIGNA without label.\n"
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|hash_entry
modifier|*
name|ptr
init|=
name|hash_create
argument_list|(
operator|&
name|vars
argument_list|,
operator|&
name|label
argument_list|)
decl_stmt|;
name|free_old_entry
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
name|ptr
operator|->
name|type
operator|=
name|hash_integer
expr_stmt|;
name|ptr
operator|->
name|value
operator|.
name|i
operator|=
name|val
expr_stmt|;
block|}
name|sb_kill
argument_list|(
operator|&
name|tmp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* name: .ASSIGNC<string>  */
end_comment

begin_function
specifier|static
name|void
name|do_assignc
parameter_list|(
name|idx
parameter_list|,
name|in
parameter_list|)
name|int
name|idx
decl_stmt|;
name|sb
modifier|*
name|in
decl_stmt|;
block|{
name|sb
name|acc
decl_stmt|;
name|sb_new
argument_list|(
operator|&
name|acc
argument_list|)
expr_stmt|;
name|idx
operator|=
name|getstring
argument_list|(
name|idx
argument_list|,
name|in
argument_list|,
operator|&
name|acc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|label
operator|.
name|len
condition|)
block|{
name|ERROR
argument_list|(
operator|(
name|stderr
operator|,
name|_
argument_list|(
literal|".ASSIGNS without label.\n"
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|hash_entry
modifier|*
name|ptr
init|=
name|hash_create
argument_list|(
operator|&
name|vars
argument_list|,
operator|&
name|label
argument_list|)
decl_stmt|;
name|free_old_entry
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
name|ptr
operator|->
name|type
operator|=
name|hash_string
expr_stmt|;
name|sb_new
argument_list|(
operator|&
name|ptr
operator|->
name|value
operator|.
name|s
argument_list|)
expr_stmt|;
name|sb_add_sb
argument_list|(
operator|&
name|ptr
operator|->
name|value
operator|.
name|s
argument_list|,
operator|&
name|acc
argument_list|)
expr_stmt|;
block|}
name|sb_kill
argument_list|(
operator|&
name|acc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* name: .REG (reg)  */
end_comment

begin_function
specifier|static
name|void
name|do_reg
parameter_list|(
name|idx
parameter_list|,
name|in
parameter_list|)
name|int
name|idx
decl_stmt|;
name|sb
modifier|*
name|in
decl_stmt|;
block|{
comment|/* Remove reg stuff from inside parens.  */
name|sb
name|what
decl_stmt|;
if|if
condition|(
operator|!
name|mri
condition|)
name|idx
operator|=
name|skip_openp
argument_list|(
name|idx
argument_list|,
name|in
argument_list|)
expr_stmt|;
else|else
name|idx
operator|=
name|sb_skip_white
argument_list|(
name|idx
argument_list|,
name|in
argument_list|)
expr_stmt|;
name|sb_new
argument_list|(
operator|&
name|what
argument_list|)
expr_stmt|;
while|while
condition|(
name|idx
operator|<
name|in
operator|->
name|len
operator|&&
operator|(
name|mri
condition|?
operator|!
name|eol
argument_list|(
name|idx
argument_list|,
name|in
argument_list|)
else|:
name|in
operator|->
name|ptr
index|[
name|idx
index|]
operator|!=
literal|')'
operator|)
condition|)
block|{
name|sb_add_char
argument_list|(
operator|&
name|what
argument_list|,
name|in
operator|->
name|ptr
index|[
name|idx
index|]
argument_list|)
expr_stmt|;
name|idx
operator|++
expr_stmt|;
block|}
name|hash_add_to_string_table
argument_list|(
operator|&
name|assign_hash_table
argument_list|,
operator|&
name|label
argument_list|,
operator|&
name|what
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|sb_kill
argument_list|(
operator|&
name|what
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|condass_lookup_name
parameter_list|(
name|inbuf
parameter_list|,
name|idx
parameter_list|,
name|out
parameter_list|,
name|warn
parameter_list|)
name|sb
modifier|*
name|inbuf
decl_stmt|;
name|int
name|idx
decl_stmt|;
name|sb
modifier|*
name|out
decl_stmt|;
name|int
name|warn
decl_stmt|;
block|{
name|hash_entry
modifier|*
name|ptr
decl_stmt|;
name|sb
name|condass_acc
decl_stmt|;
name|sb_new
argument_list|(
operator|&
name|condass_acc
argument_list|)
expr_stmt|;
while|while
condition|(
name|idx
operator|<
name|inbuf
operator|->
name|len
operator|&&
name|ISNEXTCHAR
argument_list|(
name|inbuf
operator|->
name|ptr
index|[
name|idx
index|]
argument_list|)
condition|)
block|{
name|sb_add_char
argument_list|(
operator|&
name|condass_acc
argument_list|,
name|inbuf
operator|->
name|ptr
index|[
name|idx
operator|++
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|inbuf
operator|->
name|ptr
index|[
name|idx
index|]
operator|==
literal|'\''
condition|)
name|idx
operator|++
expr_stmt|;
name|ptr
operator|=
name|hash_lookup
argument_list|(
operator|&
name|vars
argument_list|,
operator|&
name|condass_acc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ptr
condition|)
block|{
if|if
condition|(
name|warn
condition|)
block|{
name|WARNING
argument_list|(
operator|(
name|stderr
operator|,
name|_
argument_list|(
literal|"Can't find preprocessor variable %s.\n"
argument_list|)
operator|,
name|sb_name
argument_list|(
operator|&
name|condass_acc
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sb_add_string
argument_list|(
name|out
argument_list|,
literal|"0"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|ptr
operator|->
name|type
operator|==
name|hash_integer
condition|)
block|{
name|char
name|buffer
index|[
literal|30
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"%d"
argument_list|,
name|ptr
operator|->
name|value
operator|.
name|i
argument_list|)
expr_stmt|;
name|sb_add_string
argument_list|(
name|out
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sb_add_sb
argument_list|(
name|out
argument_list|,
operator|&
name|ptr
operator|->
name|value
operator|.
name|s
argument_list|)
expr_stmt|;
block|}
block|}
name|sb_kill
argument_list|(
operator|&
name|condass_acc
argument_list|)
expr_stmt|;
return|return
name|idx
return|;
block|}
end_function

begin_define
define|#
directive|define
name|EQ
value|1
end_define

begin_define
define|#
directive|define
name|NE
value|2
end_define

begin_define
define|#
directive|define
name|GE
value|3
end_define

begin_define
define|#
directive|define
name|LT
value|4
end_define

begin_define
define|#
directive|define
name|LE
value|5
end_define

begin_define
define|#
directive|define
name|GT
value|6
end_define

begin_define
define|#
directive|define
name|NEVER
value|7
end_define

begin_function
specifier|static
name|int
name|whatcond
parameter_list|(
name|idx
parameter_list|,
name|in
parameter_list|,
name|val
parameter_list|)
name|int
name|idx
decl_stmt|;
name|sb
modifier|*
name|in
decl_stmt|;
name|int
modifier|*
name|val
decl_stmt|;
block|{
name|int
name|cond
decl_stmt|;
name|idx
operator|=
name|sb_skip_white
argument_list|(
name|idx
argument_list|,
name|in
argument_list|)
expr_stmt|;
name|cond
operator|=
name|NEVER
expr_stmt|;
if|if
condition|(
name|idx
operator|+
literal|1
operator|<
name|in
operator|->
name|len
condition|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|char
name|a
decl_stmt|,
name|b
decl_stmt|;
name|p
operator|=
name|in
operator|->
name|ptr
operator|+
name|idx
expr_stmt|;
name|a
operator|=
name|TOUPPER
argument_list|(
name|p
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|b
operator|=
name|TOUPPER
argument_list|(
name|p
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|a
operator|==
literal|'E'
operator|&&
name|b
operator|==
literal|'Q'
condition|)
name|cond
operator|=
name|EQ
expr_stmt|;
elseif|else
if|if
condition|(
name|a
operator|==
literal|'N'
operator|&&
name|b
operator|==
literal|'E'
condition|)
name|cond
operator|=
name|NE
expr_stmt|;
elseif|else
if|if
condition|(
name|a
operator|==
literal|'L'
operator|&&
name|b
operator|==
literal|'T'
condition|)
name|cond
operator|=
name|LT
expr_stmt|;
elseif|else
if|if
condition|(
name|a
operator|==
literal|'L'
operator|&&
name|b
operator|==
literal|'E'
condition|)
name|cond
operator|=
name|LE
expr_stmt|;
elseif|else
if|if
condition|(
name|a
operator|==
literal|'G'
operator|&&
name|b
operator|==
literal|'T'
condition|)
name|cond
operator|=
name|GT
expr_stmt|;
elseif|else
if|if
condition|(
name|a
operator|==
literal|'G'
operator|&&
name|b
operator|==
literal|'E'
condition|)
name|cond
operator|=
name|GE
expr_stmt|;
block|}
if|if
condition|(
name|cond
operator|==
name|NEVER
condition|)
block|{
name|ERROR
argument_list|(
operator|(
name|stderr
operator|,
name|_
argument_list|(
literal|"Comparison operator must be one of EQ, NE, LT, LE, GT or GE.\n"
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|cond
operator|=
name|NEVER
expr_stmt|;
block|}
name|idx
operator|=
name|sb_skip_white
argument_list|(
name|idx
operator|+
literal|2
argument_list|,
name|in
argument_list|)
expr_stmt|;
operator|*
name|val
operator|=
name|cond
expr_stmt|;
return|return
name|idx
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|istrue
parameter_list|(
name|idx
parameter_list|,
name|in
parameter_list|)
name|int
name|idx
decl_stmt|;
name|sb
modifier|*
name|in
decl_stmt|;
block|{
name|int
name|res
decl_stmt|;
name|sb
name|acc_a
decl_stmt|;
name|sb
name|cond
decl_stmt|;
name|sb
name|acc_b
decl_stmt|;
name|sb_new
argument_list|(
operator|&
name|acc_a
argument_list|)
expr_stmt|;
name|sb_new
argument_list|(
operator|&
name|cond
argument_list|)
expr_stmt|;
name|sb_new
argument_list|(
operator|&
name|acc_b
argument_list|)
expr_stmt|;
name|idx
operator|=
name|sb_skip_white
argument_list|(
name|idx
argument_list|,
name|in
argument_list|)
expr_stmt|;
if|if
condition|(
name|in
operator|->
name|ptr
index|[
name|idx
index|]
operator|==
literal|'"'
condition|)
block|{
name|int
name|cond
decl_stmt|;
name|int
name|same
decl_stmt|;
comment|/* This is a string comparision.  */
name|idx
operator|=
name|getstring
argument_list|(
name|idx
argument_list|,
name|in
argument_list|,
operator|&
name|acc_a
argument_list|)
expr_stmt|;
name|idx
operator|=
name|whatcond
argument_list|(
name|idx
argument_list|,
name|in
argument_list|,
operator|&
name|cond
argument_list|)
expr_stmt|;
name|idx
operator|=
name|getstring
argument_list|(
name|idx
argument_list|,
name|in
argument_list|,
operator|&
name|acc_b
argument_list|)
expr_stmt|;
name|same
operator|=
name|acc_a
operator|.
name|len
operator|==
name|acc_b
operator|.
name|len
operator|&&
operator|(
name|strncmp
argument_list|(
name|acc_a
operator|.
name|ptr
argument_list|,
name|acc_b
operator|.
name|ptr
argument_list|,
name|acc_a
operator|.
name|len
argument_list|)
operator|==
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|cond
operator|!=
name|EQ
operator|&&
name|cond
operator|!=
name|NE
condition|)
block|{
name|ERROR
argument_list|(
operator|(
name|stderr
operator|,
name|_
argument_list|(
literal|"Comparison operator for strings must be EQ or NE\n"
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|res
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|res
operator|=
operator|(
name|cond
operator|!=
name|EQ
operator|)
operator|^
name|same
expr_stmt|;
block|}
else|else
comment|/* This is a numeric expression.  */
block|{
name|int
name|vala
decl_stmt|;
name|int
name|valb
decl_stmt|;
name|int
name|cond
decl_stmt|;
name|idx
operator|=
name|exp_get_abs
argument_list|(
name|_
argument_list|(
literal|"Conditional operator must have absolute operands.\n"
argument_list|)
argument_list|,
name|idx
argument_list|,
name|in
argument_list|,
operator|&
name|vala
argument_list|)
expr_stmt|;
name|idx
operator|=
name|whatcond
argument_list|(
name|idx
argument_list|,
name|in
argument_list|,
operator|&
name|cond
argument_list|)
expr_stmt|;
name|idx
operator|=
name|sb_skip_white
argument_list|(
name|idx
argument_list|,
name|in
argument_list|)
expr_stmt|;
if|if
condition|(
name|in
operator|->
name|ptr
index|[
name|idx
index|]
operator|==
literal|'"'
condition|)
block|{
name|WARNING
argument_list|(
operator|(
name|stderr
operator|,
name|_
argument_list|(
literal|"String compared against expression.\n"
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|res
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|idx
operator|=
name|exp_get_abs
argument_list|(
name|_
argument_list|(
literal|"Conditional operator must have absolute operands.\n"
argument_list|)
argument_list|,
name|idx
argument_list|,
name|in
argument_list|,
operator|&
name|valb
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|cond
condition|)
block|{
default|default:
name|res
operator|=
literal|42
expr_stmt|;
break|break;
case|case
name|EQ
case|:
name|res
operator|=
name|vala
operator|==
name|valb
expr_stmt|;
break|break;
case|case
name|NE
case|:
name|res
operator|=
name|vala
operator|!=
name|valb
expr_stmt|;
break|break;
case|case
name|LT
case|:
name|res
operator|=
name|vala
operator|<
name|valb
expr_stmt|;
break|break;
case|case
name|LE
case|:
name|res
operator|=
name|vala
operator|<=
name|valb
expr_stmt|;
break|break;
case|case
name|GT
case|:
name|res
operator|=
name|vala
operator|>
name|valb
expr_stmt|;
break|break;
case|case
name|GE
case|:
name|res
operator|=
name|vala
operator|>=
name|valb
expr_stmt|;
break|break;
case|case
name|NEVER
case|:
name|res
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
block|}
name|sb_kill
argument_list|(
operator|&
name|acc_a
argument_list|)
expr_stmt|;
name|sb_kill
argument_list|(
operator|&
name|cond
argument_list|)
expr_stmt|;
name|sb_kill
argument_list|(
operator|&
name|acc_b
argument_list|)
expr_stmt|;
return|return
name|res
return|;
block|}
end_function

begin_comment
comment|/* .AIF  */
end_comment

begin_function
specifier|static
name|void
name|do_aif
parameter_list|(
name|idx
parameter_list|,
name|in
parameter_list|)
name|int
name|idx
decl_stmt|;
name|sb
modifier|*
name|in
decl_stmt|;
block|{
if|if
condition|(
name|ifi
operator|>=
name|IFNESTING
condition|)
block|{
name|FATAL
argument_list|(
operator|(
name|stderr
operator|,
name|_
argument_list|(
literal|"AIF nesting unreasonable.\n"
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
name|ifi
operator|++
expr_stmt|;
name|ifstack
index|[
name|ifi
index|]
operator|.
name|on
operator|=
name|ifstack
index|[
name|ifi
operator|-
literal|1
index|]
operator|.
name|on
condition|?
name|istrue
argument_list|(
name|idx
argument_list|,
name|in
argument_list|)
else|:
literal|0
expr_stmt|;
name|ifstack
index|[
name|ifi
index|]
operator|.
name|hadelse
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* .AELSE  */
end_comment

begin_function
specifier|static
name|void
name|do_aelse
parameter_list|()
block|{
name|ifstack
index|[
name|ifi
index|]
operator|.
name|on
operator|=
name|ifstack
index|[
name|ifi
operator|-
literal|1
index|]
operator|.
name|on
condition|?
operator|!
name|ifstack
index|[
name|ifi
index|]
operator|.
name|on
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|ifstack
index|[
name|ifi
index|]
operator|.
name|hadelse
condition|)
block|{
name|ERROR
argument_list|(
operator|(
name|stderr
operator|,
name|_
argument_list|(
literal|"Multiple AELSEs in AIF.\n"
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
name|ifstack
index|[
name|ifi
index|]
operator|.
name|hadelse
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* .AENDI  */
end_comment

begin_function
specifier|static
name|void
name|do_aendi
parameter_list|()
block|{
if|if
condition|(
name|ifi
operator|!=
literal|0
condition|)
block|{
name|ifi
operator|--
expr_stmt|;
block|}
else|else
block|{
name|ERROR
argument_list|(
operator|(
name|stderr
operator|,
name|_
argument_list|(
literal|"AENDI without AIF.\n"
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|condass_on
parameter_list|()
block|{
return|return
name|ifstack
index|[
name|ifi
index|]
operator|.
name|on
return|;
block|}
end_function

begin_comment
comment|/* MRI IFEQ, IFNE, IFLT, IFLE, IFGE, IFGT.  */
end_comment

begin_function
specifier|static
name|void
name|do_if
parameter_list|(
name|idx
parameter_list|,
name|in
parameter_list|,
name|cond
parameter_list|)
name|int
name|idx
decl_stmt|;
name|sb
modifier|*
name|in
decl_stmt|;
name|int
name|cond
decl_stmt|;
block|{
name|int
name|val
decl_stmt|;
name|int
name|res
decl_stmt|;
if|if
condition|(
name|ifi
operator|>=
name|IFNESTING
condition|)
block|{
name|FATAL
argument_list|(
operator|(
name|stderr
operator|,
name|_
argument_list|(
literal|"IF nesting unreasonable.\n"
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
name|idx
operator|=
name|exp_get_abs
argument_list|(
name|_
argument_list|(
literal|"Conditional operator must have absolute operands.\n"
argument_list|)
argument_list|,
name|idx
argument_list|,
name|in
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|cond
condition|)
block|{
default|default:
case|case
name|EQ
case|:
name|res
operator|=
name|val
operator|==
literal|0
expr_stmt|;
break|break;
case|case
name|NE
case|:
name|res
operator|=
name|val
operator|!=
literal|0
expr_stmt|;
break|break;
case|case
name|LT
case|:
name|res
operator|=
name|val
operator|<
literal|0
expr_stmt|;
break|break;
case|case
name|LE
case|:
name|res
operator|=
name|val
operator|<=
literal|0
expr_stmt|;
break|break;
case|case
name|GE
case|:
name|res
operator|=
name|val
operator|>=
literal|0
expr_stmt|;
break|break;
case|case
name|GT
case|:
name|res
operator|=
name|val
operator|>
literal|0
expr_stmt|;
break|break;
block|}
name|ifi
operator|++
expr_stmt|;
name|ifstack
index|[
name|ifi
index|]
operator|.
name|on
operator|=
name|ifstack
index|[
name|ifi
operator|-
literal|1
index|]
operator|.
name|on
condition|?
name|res
else|:
literal|0
expr_stmt|;
name|ifstack
index|[
name|ifi
index|]
operator|.
name|hadelse
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Get a string for the MRI IFC or IFNC pseudo-ops.  */
end_comment

begin_function
specifier|static
name|int
name|get_mri_string
parameter_list|(
name|idx
parameter_list|,
name|in
parameter_list|,
name|val
parameter_list|,
name|terminator
parameter_list|)
name|int
name|idx
decl_stmt|;
name|sb
modifier|*
name|in
decl_stmt|;
name|sb
modifier|*
name|val
decl_stmt|;
name|int
name|terminator
decl_stmt|;
block|{
name|idx
operator|=
name|sb_skip_white
argument_list|(
name|idx
argument_list|,
name|in
argument_list|)
expr_stmt|;
if|if
condition|(
name|idx
operator|<
name|in
operator|->
name|len
operator|&&
name|in
operator|->
name|ptr
index|[
name|idx
index|]
operator|==
literal|'\''
condition|)
block|{
name|sb_add_char
argument_list|(
name|val
argument_list|,
literal|'\''
argument_list|)
expr_stmt|;
for|for
control|(
operator|++
name|idx
init|;
name|idx
operator|<
name|in
operator|->
name|len
condition|;
operator|++
name|idx
control|)
block|{
name|sb_add_char
argument_list|(
name|val
argument_list|,
name|in
operator|->
name|ptr
index|[
name|idx
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|in
operator|->
name|ptr
index|[
name|idx
index|]
operator|==
literal|'\''
condition|)
block|{
operator|++
name|idx
expr_stmt|;
if|if
condition|(
name|idx
operator|>=
name|in
operator|->
name|len
operator|||
name|in
operator|->
name|ptr
index|[
name|idx
index|]
operator|!=
literal|'\''
condition|)
break|break;
block|}
block|}
name|idx
operator|=
name|sb_skip_white
argument_list|(
name|idx
argument_list|,
name|in
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|i
decl_stmt|;
while|while
condition|(
name|idx
operator|<
name|in
operator|->
name|len
operator|&&
name|in
operator|->
name|ptr
index|[
name|idx
index|]
operator|!=
name|terminator
condition|)
block|{
name|sb_add_char
argument_list|(
name|val
argument_list|,
name|in
operator|->
name|ptr
index|[
name|idx
index|]
argument_list|)
expr_stmt|;
operator|++
name|idx
expr_stmt|;
block|}
name|i
operator|=
name|val
operator|->
name|len
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|i
operator|>=
literal|0
operator|&&
name|ISWHITE
argument_list|(
name|val
operator|->
name|ptr
index|[
name|i
index|]
argument_list|)
condition|)
operator|--
name|i
expr_stmt|;
name|val
operator|->
name|len
operator|=
name|i
operator|+
literal|1
expr_stmt|;
block|}
return|return
name|idx
return|;
block|}
end_function

begin_comment
comment|/* MRI IFC, IFNC  */
end_comment

begin_function
specifier|static
name|void
name|do_ifc
parameter_list|(
name|idx
parameter_list|,
name|in
parameter_list|,
name|ifnc
parameter_list|)
name|int
name|idx
decl_stmt|;
name|sb
modifier|*
name|in
decl_stmt|;
name|int
name|ifnc
decl_stmt|;
block|{
name|sb
name|first
decl_stmt|;
name|sb
name|second
decl_stmt|;
name|int
name|res
decl_stmt|;
if|if
condition|(
name|ifi
operator|>=
name|IFNESTING
condition|)
block|{
name|FATAL
argument_list|(
operator|(
name|stderr
operator|,
name|_
argument_list|(
literal|"IF nesting unreasonable.\n"
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
name|sb_new
argument_list|(
operator|&
name|first
argument_list|)
expr_stmt|;
name|sb_new
argument_list|(
operator|&
name|second
argument_list|)
expr_stmt|;
name|idx
operator|=
name|get_mri_string
argument_list|(
name|idx
argument_list|,
name|in
argument_list|,
operator|&
name|first
argument_list|,
literal|','
argument_list|)
expr_stmt|;
if|if
condition|(
name|idx
operator|>=
name|in
operator|->
name|len
operator|||
name|in
operator|->
name|ptr
index|[
name|idx
index|]
operator|!=
literal|','
condition|)
block|{
name|ERROR
argument_list|(
operator|(
name|stderr
operator|,
name|_
argument_list|(
literal|"Bad format for IF or IFNC.\n"
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|idx
operator|=
name|get_mri_string
argument_list|(
name|idx
operator|+
literal|1
argument_list|,
name|in
argument_list|,
operator|&
name|second
argument_list|,
literal|';'
argument_list|)
expr_stmt|;
name|res
operator|=
operator|(
name|first
operator|.
name|len
operator|==
name|second
operator|.
name|len
operator|&&
name|strncmp
argument_list|(
name|first
operator|.
name|ptr
argument_list|,
name|second
operator|.
name|ptr
argument_list|,
name|first
operator|.
name|len
argument_list|)
operator|==
literal|0
operator|)
expr_stmt|;
name|res
operator|^=
name|ifnc
expr_stmt|;
name|ifi
operator|++
expr_stmt|;
name|ifstack
index|[
name|ifi
index|]
operator|.
name|on
operator|=
name|ifstack
index|[
name|ifi
operator|-
literal|1
index|]
operator|.
name|on
condition|?
name|res
else|:
literal|0
expr_stmt|;
name|ifstack
index|[
name|ifi
index|]
operator|.
name|hadelse
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* .ENDR  */
end_comment

begin_function
specifier|static
name|void
name|do_aendr
parameter_list|()
block|{
if|if
condition|(
operator|!
name|mri
condition|)
name|ERROR
argument_list|(
operator|(
name|stderr
operator|,
name|_
argument_list|(
literal|"AENDR without a AREPEAT.\n"
argument_list|)
operator|)
argument_list|)
expr_stmt|;
else|else
name|ERROR
argument_list|(
operator|(
name|stderr
operator|,
name|_
argument_list|(
literal|"ENDR without a REPT.\n"
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* .AWHILE  */
end_comment

begin_function
specifier|static
name|void
name|do_awhile
parameter_list|(
name|idx
parameter_list|,
name|in
parameter_list|)
name|int
name|idx
decl_stmt|;
name|sb
modifier|*
name|in
decl_stmt|;
block|{
name|int
name|line
init|=
name|linecount
argument_list|()
decl_stmt|;
name|sb
name|exp
decl_stmt|;
name|sb
name|sub
decl_stmt|;
name|int
name|doit
decl_stmt|;
name|sb_new
argument_list|(
operator|&
name|sub
argument_list|)
expr_stmt|;
name|sb_new
argument_list|(
operator|&
name|exp
argument_list|)
expr_stmt|;
name|process_assigns
argument_list|(
name|idx
argument_list|,
name|in
argument_list|,
operator|&
name|exp
argument_list|)
expr_stmt|;
name|doit
operator|=
name|istrue
argument_list|(
literal|0
argument_list|,
operator|&
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|buffer_and_nest
argument_list|(
literal|"AWHILE"
argument_list|,
literal|"AENDW"
argument_list|,
operator|&
name|sub
argument_list|,
name|get_line
argument_list|)
condition|)
name|FATAL
argument_list|(
operator|(
name|stderr
operator|,
name|_
argument_list|(
literal|"AWHILE without a AENDW at %d.\n"
argument_list|)
operator|,
name|line
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
comment|/* Turn      	.AWHILE exp 	     foo 	.AENDW      into         foo 	.AWHILE exp 	foo 	.ENDW   */
if|if
condition|(
name|doit
condition|)
block|{
name|int
name|index
init|=
name|include_next_index
argument_list|()
decl_stmt|;
name|sb
name|copy
decl_stmt|;
name|sb_new
argument_list|(
operator|&
name|copy
argument_list|)
expr_stmt|;
name|sb_add_sb
argument_list|(
operator|&
name|copy
argument_list|,
operator|&
name|sub
argument_list|)
expr_stmt|;
name|sb_add_sb
argument_list|(
operator|&
name|copy
argument_list|,
name|in
argument_list|)
expr_stmt|;
name|sb_add_string
argument_list|(
operator|&
name|copy
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|sb_add_sb
argument_list|(
operator|&
name|copy
argument_list|,
operator|&
name|sub
argument_list|)
expr_stmt|;
name|sb_add_string
argument_list|(
operator|&
name|copy
argument_list|,
literal|"\t.AENDW\n"
argument_list|)
expr_stmt|;
comment|/* Push another WHILE.  */
name|include_buf
argument_list|(
operator|&
name|exp
argument_list|,
operator|&
name|copy
argument_list|,
name|include_while
argument_list|,
name|index
argument_list|)
expr_stmt|;
name|sb_kill
argument_list|(
operator|&
name|copy
argument_list|)
expr_stmt|;
block|}
name|sb_kill
argument_list|(
operator|&
name|exp
argument_list|)
expr_stmt|;
name|sb_kill
argument_list|(
operator|&
name|sub
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* .AENDW  */
end_comment

begin_function
specifier|static
name|void
name|do_aendw
parameter_list|()
block|{
name|ERROR
argument_list|(
operator|(
name|stderr
operator|,
name|_
argument_list|(
literal|"AENDW without a AENDW.\n"
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* .EXITM     Pop things off the include stack until the type and index changes.  */
end_comment

begin_function
specifier|static
name|void
name|do_exitm
parameter_list|()
block|{
name|include_type
name|type
init|=
name|sp
operator|->
name|type
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|include_repeat
operator|||
name|type
operator|==
name|include_while
operator|||
name|type
operator|==
name|include_macro
condition|)
block|{
name|int
name|index
init|=
name|sp
operator|->
name|index
decl_stmt|;
name|include_pop
argument_list|()
expr_stmt|;
while|while
condition|(
name|sp
operator|->
name|index
operator|==
name|index
operator|&&
name|sp
operator|->
name|type
operator|==
name|type
condition|)
block|{
name|include_pop
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* .AREPEAT  */
end_comment

begin_function
specifier|static
name|void
name|do_arepeat
parameter_list|(
name|idx
parameter_list|,
name|in
parameter_list|)
name|int
name|idx
decl_stmt|;
name|sb
modifier|*
name|in
decl_stmt|;
block|{
name|int
name|line
init|=
name|linecount
argument_list|()
decl_stmt|;
name|sb
name|exp
decl_stmt|;
comment|/* Buffer with expression in it.  */
name|sb
name|copy
decl_stmt|;
comment|/* Expanded repeat block.  */
name|sb
name|sub
decl_stmt|;
comment|/* Contents of AREPEAT.  */
name|int
name|rc
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|char
name|buffer
index|[
literal|30
index|]
decl_stmt|;
name|sb_new
argument_list|(
operator|&
name|exp
argument_list|)
expr_stmt|;
name|sb_new
argument_list|(
operator|&
name|copy
argument_list|)
expr_stmt|;
name|sb_new
argument_list|(
operator|&
name|sub
argument_list|)
expr_stmt|;
name|process_assigns
argument_list|(
name|idx
argument_list|,
name|in
argument_list|,
operator|&
name|exp
argument_list|)
expr_stmt|;
name|idx
operator|=
name|exp_get_abs
argument_list|(
name|_
argument_list|(
literal|"AREPEAT must have absolute operand.\n"
argument_list|)
argument_list|,
literal|0
argument_list|,
operator|&
name|exp
argument_list|,
operator|&
name|rc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mri
condition|)
name|ret
operator|=
name|buffer_and_nest
argument_list|(
literal|"AREPEAT"
argument_list|,
literal|"AENDR"
argument_list|,
operator|&
name|sub
argument_list|,
name|get_line
argument_list|)
expr_stmt|;
else|else
name|ret
operator|=
name|buffer_and_nest
argument_list|(
literal|"REPT"
argument_list|,
literal|"ENDR"
argument_list|,
operator|&
name|sub
argument_list|,
name|get_line
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
name|FATAL
argument_list|(
operator|(
name|stderr
operator|,
name|_
argument_list|(
literal|"AREPEAT without a AENDR at %d.\n"
argument_list|)
operator|,
name|line
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|>
literal|0
condition|)
block|{
comment|/* Push back the text following the repeat, and another repeat block 	 so 	 .AREPEAT 20 	 foo 	 .AENDR 	 gets turned into 	 foo 	 .AREPEAT 19 	 foo 	 .AENDR       */
name|int
name|index
init|=
name|include_next_index
argument_list|()
decl_stmt|;
name|sb_add_sb
argument_list|(
operator|&
name|copy
argument_list|,
operator|&
name|sub
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|>
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|mri
condition|)
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"\t.AREPEAT	%d\n"
argument_list|,
name|rc
operator|-
literal|1
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"\tREPT	%d\n"
argument_list|,
name|rc
operator|-
literal|1
argument_list|)
expr_stmt|;
name|sb_add_string
argument_list|(
operator|&
name|copy
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
name|sb_add_sb
argument_list|(
operator|&
name|copy
argument_list|,
operator|&
name|sub
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mri
condition|)
name|sb_add_string
argument_list|(
operator|&
name|copy
argument_list|,
literal|"	.AENDR\n"
argument_list|)
expr_stmt|;
else|else
name|sb_add_string
argument_list|(
operator|&
name|copy
argument_list|,
literal|"	ENDR\n"
argument_list|)
expr_stmt|;
block|}
name|include_buf
argument_list|(
operator|&
name|exp
argument_list|,
operator|&
name|copy
argument_list|,
name|include_repeat
argument_list|,
name|index
argument_list|)
expr_stmt|;
block|}
name|sb_kill
argument_list|(
operator|&
name|exp
argument_list|)
expr_stmt|;
name|sb_kill
argument_list|(
operator|&
name|sub
argument_list|)
expr_stmt|;
name|sb_kill
argument_list|(
operator|&
name|copy
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* .ENDM  */
end_comment

begin_function
specifier|static
name|void
name|do_endm
parameter_list|()
block|{
name|ERROR
argument_list|(
operator|(
name|stderr
operator|,
name|_
argument_list|(
literal|".ENDM without a matching .MACRO.\n"
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* MRI IRP pseudo-op.  */
end_comment

begin_function
specifier|static
name|void
name|do_irp
parameter_list|(
name|idx
parameter_list|,
name|in
parameter_list|,
name|irpc
parameter_list|)
name|int
name|idx
decl_stmt|;
name|sb
modifier|*
name|in
decl_stmt|;
name|int
name|irpc
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|err
decl_stmt|;
name|sb
name|out
decl_stmt|;
name|sb_new
argument_list|(
operator|&
name|out
argument_list|)
expr_stmt|;
name|err
operator|=
name|expand_irp
argument_list|(
name|irpc
argument_list|,
name|idx
argument_list|,
name|in
argument_list|,
operator|&
name|out
argument_list|,
name|get_line
argument_list|,
name|comment_char
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|NULL
condition|)
name|ERROR
argument_list|(
operator|(
name|stderr
operator|,
literal|"%s\n"
operator|,
name|err
operator|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"%s"
argument_list|,
name|sb_terminate
argument_list|(
operator|&
name|out
argument_list|)
argument_list|)
expr_stmt|;
name|sb_kill
argument_list|(
operator|&
name|out
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Macro processing.  */
end_comment

begin_comment
comment|/* Parse off LOCAL n1, n2,... Invent a label name for it.  */
end_comment

begin_function
specifier|static
name|void
name|do_local
parameter_list|(
name|idx
parameter_list|,
name|line
parameter_list|)
name|int
name|idx
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|sb
modifier|*
name|line
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|ERROR
argument_list|(
operator|(
name|stderr
operator|,
name|_
argument_list|(
literal|"LOCAL outside of MACRO"
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_macro
parameter_list|(
name|idx
parameter_list|,
name|in
parameter_list|)
name|int
name|idx
decl_stmt|;
name|sb
modifier|*
name|in
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|err
decl_stmt|;
name|int
name|line
init|=
name|linecount
argument_list|()
decl_stmt|;
name|err
operator|=
name|define_macro
argument_list|(
name|idx
argument_list|,
name|in
argument_list|,
operator|&
name|label
argument_list|,
name|get_line
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|NULL
condition|)
name|ERROR
argument_list|(
operator|(
name|stderr
operator|,
name|_
argument_list|(
literal|"macro at line %d: %s\n"
argument_list|)
operator|,
name|line
operator|-
literal|1
operator|,
name|err
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|macro_op
parameter_list|(
name|idx
parameter_list|,
name|in
parameter_list|)
name|int
name|idx
decl_stmt|;
name|sb
modifier|*
name|in
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|err
decl_stmt|;
name|sb
name|out
decl_stmt|;
name|sb
name|name
decl_stmt|;
if|if
condition|(
operator|!
name|macro_defined
condition|)
return|return
literal|0
return|;
name|sb_terminate
argument_list|(
name|in
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|check_macro
argument_list|(
name|in
operator|->
name|ptr
operator|+
name|idx
argument_list|,
operator|&
name|out
argument_list|,
name|comment_char
argument_list|,
operator|&
name|err
argument_list|,
name|NULL
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|err
operator|!=
name|NULL
condition|)
name|ERROR
argument_list|(
operator|(
name|stderr
operator|,
literal|"%s\n"
operator|,
name|err
operator|)
argument_list|)
expr_stmt|;
name|sb_new
argument_list|(
operator|&
name|name
argument_list|)
expr_stmt|;
name|sb_add_string
argument_list|(
operator|&
name|name
argument_list|,
name|_
argument_list|(
literal|"macro expansion"
argument_list|)
argument_list|)
expr_stmt|;
name|include_buf
argument_list|(
operator|&
name|name
argument_list|,
operator|&
name|out
argument_list|,
name|include_macro
argument_list|,
name|include_next_index
argument_list|()
argument_list|)
expr_stmt|;
name|sb_kill
argument_list|(
operator|&
name|name
argument_list|)
expr_stmt|;
name|sb_kill
argument_list|(
operator|&
name|out
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* String handling.  */
end_comment

begin_function
specifier|static
name|int
name|getstring
parameter_list|(
name|idx
parameter_list|,
name|in
parameter_list|,
name|acc
parameter_list|)
name|int
name|idx
decl_stmt|;
name|sb
modifier|*
name|in
decl_stmt|;
name|sb
modifier|*
name|acc
decl_stmt|;
block|{
name|idx
operator|=
name|sb_skip_white
argument_list|(
name|idx
argument_list|,
name|in
argument_list|)
expr_stmt|;
while|while
condition|(
name|idx
operator|<
name|in
operator|->
name|len
operator|&&
operator|(
name|in
operator|->
name|ptr
index|[
name|idx
index|]
operator|==
literal|'"'
operator|||
name|in
operator|->
name|ptr
index|[
name|idx
index|]
operator|==
literal|'<'
operator|||
operator|(
name|in
operator|->
name|ptr
index|[
name|idx
index|]
operator|==
literal|'\''
operator|&&
name|alternate
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|in
operator|->
name|ptr
index|[
name|idx
index|]
operator|==
literal|'<'
condition|)
block|{
if|if
condition|(
name|alternate
operator|||
name|mri
condition|)
block|{
name|int
name|nest
init|=
literal|0
decl_stmt|;
name|idx
operator|++
expr_stmt|;
while|while
condition|(
operator|(
name|in
operator|->
name|ptr
index|[
name|idx
index|]
operator|!=
literal|'>'
operator|||
name|nest
operator|)
operator|&&
name|idx
operator|<
name|in
operator|->
name|len
condition|)
block|{
if|if
condition|(
name|in
operator|->
name|ptr
index|[
name|idx
index|]
operator|==
literal|'!'
condition|)
block|{
name|idx
operator|++
expr_stmt|;
name|sb_add_char
argument_list|(
name|acc
argument_list|,
name|in
operator|->
name|ptr
index|[
name|idx
operator|++
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|in
operator|->
name|ptr
index|[
name|idx
index|]
operator|==
literal|'>'
condition|)
name|nest
operator|--
expr_stmt|;
if|if
condition|(
name|in
operator|->
name|ptr
index|[
name|idx
index|]
operator|==
literal|'<'
condition|)
name|nest
operator|++
expr_stmt|;
name|sb_add_char
argument_list|(
name|acc
argument_list|,
name|in
operator|->
name|ptr
index|[
name|idx
operator|++
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|idx
operator|++
expr_stmt|;
block|}
else|else
block|{
name|int
name|code
decl_stmt|;
name|idx
operator|++
expr_stmt|;
name|idx
operator|=
name|exp_get_abs
argument_list|(
name|_
argument_list|(
literal|"Character code in string must be absolute expression.\n"
argument_list|)
argument_list|,
name|idx
argument_list|,
name|in
argument_list|,
operator|&
name|code
argument_list|)
expr_stmt|;
name|sb_add_char
argument_list|(
name|acc
argument_list|,
name|code
argument_list|)
expr_stmt|;
if|if
condition|(
name|in
operator|->
name|ptr
index|[
name|idx
index|]
operator|!=
literal|'>'
condition|)
name|ERROR
argument_list|(
operator|(
name|stderr
operator|,
name|_
argument_list|(
literal|"Missing> for character code.\n"
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|idx
operator|++
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|in
operator|->
name|ptr
index|[
name|idx
index|]
operator|==
literal|'"'
operator|||
name|in
operator|->
name|ptr
index|[
name|idx
index|]
operator|==
literal|'\''
condition|)
block|{
name|char
name|tchar
init|=
name|in
operator|->
name|ptr
index|[
name|idx
index|]
decl_stmt|;
name|idx
operator|++
expr_stmt|;
while|while
condition|(
name|idx
operator|<
name|in
operator|->
name|len
condition|)
block|{
if|if
condition|(
name|alternate
operator|&&
name|in
operator|->
name|ptr
index|[
name|idx
index|]
operator|==
literal|'!'
condition|)
block|{
name|idx
operator|++
expr_stmt|;
name|sb_add_char
argument_list|(
name|acc
argument_list|,
name|in
operator|->
name|ptr
index|[
name|idx
operator|++
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|in
operator|->
name|ptr
index|[
name|idx
index|]
operator|==
name|tchar
condition|)
block|{
name|idx
operator|++
expr_stmt|;
if|if
condition|(
name|idx
operator|>=
name|in
operator|->
name|len
operator|||
name|in
operator|->
name|ptr
index|[
name|idx
index|]
operator|!=
name|tchar
condition|)
break|break;
block|}
name|sb_add_char
argument_list|(
name|acc
argument_list|,
name|in
operator|->
name|ptr
index|[
name|idx
index|]
argument_list|)
expr_stmt|;
name|idx
operator|++
expr_stmt|;
block|}
block|}
block|}
block|}
return|return
name|idx
return|;
block|}
end_function

begin_comment
comment|/* .SDATA[C|Z]<string>  */
end_comment

begin_function
specifier|static
name|void
name|do_sdata
parameter_list|(
name|idx
parameter_list|,
name|in
parameter_list|,
name|type
parameter_list|)
name|int
name|idx
decl_stmt|;
name|sb
modifier|*
name|in
decl_stmt|;
name|int
name|type
decl_stmt|;
block|{
name|int
name|nc
init|=
literal|0
decl_stmt|;
name|int
name|pidx
init|=
operator|-
literal|1
decl_stmt|;
name|sb
name|acc
decl_stmt|;
name|sb_new
argument_list|(
operator|&
name|acc
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|".byte\t"
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|eol
argument_list|(
name|idx
argument_list|,
name|in
argument_list|)
condition|)
block|{
name|int
name|i
decl_stmt|;
name|sb_reset
argument_list|(
operator|&
name|acc
argument_list|)
expr_stmt|;
name|idx
operator|=
name|sb_skip_white
argument_list|(
name|idx
argument_list|,
name|in
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|eol
argument_list|(
name|idx
argument_list|,
name|in
argument_list|)
condition|)
block|{
name|pidx
operator|=
name|idx
operator|=
name|get_any_string
argument_list|(
name|idx
argument_list|,
name|in
argument_list|,
operator|&
name|acc
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
literal|'c'
condition|)
block|{
if|if
condition|(
name|acc
operator|.
name|len
operator|>
literal|255
condition|)
block|{
name|ERROR
argument_list|(
operator|(
name|stderr
operator|,
name|_
argument_list|(
literal|"string for SDATAC longer than 255 characters (%d).\n"
argument_list|)
operator|,
name|acc
operator|.
name|len
operator|)
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"%d"
argument_list|,
name|acc
operator|.
name|len
argument_list|)
expr_stmt|;
name|nc
operator|=
literal|1
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|acc
operator|.
name|len
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|nc
condition|)
block|{
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|","
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"%d"
argument_list|,
name|acc
operator|.
name|ptr
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|nc
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|type
operator|==
literal|'z'
condition|)
block|{
if|if
condition|(
name|nc
condition|)
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|","
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"0"
argument_list|)
expr_stmt|;
block|}
name|idx
operator|=
name|sb_skip_comma
argument_list|(
name|idx
argument_list|,
name|in
argument_list|)
expr_stmt|;
if|if
condition|(
name|idx
operator|==
name|pidx
condition|)
break|break;
block|}
if|if
condition|(
operator|!
name|alternate
operator|&&
name|in
operator|->
name|ptr
index|[
name|idx
index|]
operator|!=
literal|','
operator|&&
name|idx
operator|!=
name|in
operator|->
name|len
condition|)
block|{
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|ERROR
argument_list|(
operator|(
name|stderr
operator|,
name|_
argument_list|(
literal|"illegal character in SDATA line (0x%x).\n"
argument_list|)
operator|,
name|in
operator|->
name|ptr
index|[
name|idx
index|]
operator|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|idx
operator|++
expr_stmt|;
block|}
name|sb_kill
argument_list|(
operator|&
name|acc
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* .SDATAB<count><string>  */
end_comment

begin_function
specifier|static
name|void
name|do_sdatab
parameter_list|(
name|idx
parameter_list|,
name|in
parameter_list|)
name|int
name|idx
decl_stmt|;
name|sb
modifier|*
name|in
decl_stmt|;
block|{
name|int
name|repeat
decl_stmt|;
name|int
name|i
decl_stmt|;
name|sb
name|acc
decl_stmt|;
name|sb_new
argument_list|(
operator|&
name|acc
argument_list|)
expr_stmt|;
name|idx
operator|=
name|exp_get_abs
argument_list|(
name|_
argument_list|(
literal|"Must have absolute SDATAB repeat count.\n"
argument_list|)
argument_list|,
name|idx
argument_list|,
name|in
argument_list|,
operator|&
name|repeat
argument_list|)
expr_stmt|;
if|if
condition|(
name|repeat
operator|<=
literal|0
condition|)
block|{
name|ERROR
argument_list|(
operator|(
name|stderr
operator|,
name|_
argument_list|(
literal|"Must have positive SDATAB repeat count (%d).\n"
argument_list|)
operator|,
name|repeat
operator|)
argument_list|)
expr_stmt|;
name|repeat
operator|=
literal|1
expr_stmt|;
block|}
name|idx
operator|=
name|sb_skip_comma
argument_list|(
name|idx
argument_list|,
name|in
argument_list|)
expr_stmt|;
name|idx
operator|=
name|getstring
argument_list|(
name|idx
argument_list|,
name|in
argument_list|,
operator|&
name|acc
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|repeat
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
condition|)
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"\t"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|".byte\t"
argument_list|)
expr_stmt|;
name|sb_print
argument_list|(
name|outfile
argument_list|,
operator|&
name|acc
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|sb_kill
argument_list|(
operator|&
name|acc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|new_file
parameter_list|(
name|name
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|FILE
modifier|*
name|newone
init|=
name|fopen
argument_list|(
name|name
argument_list|,
literal|"r"
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|newone
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|isp
operator|==
name|MAX_INCLUDES
condition|)
name|FATAL
argument_list|(
operator|(
name|stderr
operator|,
name|_
argument_list|(
literal|"Unreasonable include depth (%ld).\n"
argument_list|)
operator|,
operator|(
name|long
operator|)
name|isp
operator|)
argument_list|)
expr_stmt|;
name|sp
operator|++
expr_stmt|;
name|sp
operator|->
name|handle
operator|=
name|newone
expr_stmt|;
name|sb_new
argument_list|(
operator|&
name|sp
operator|->
name|name
argument_list|)
expr_stmt|;
name|sb_add_string
argument_list|(
operator|&
name|sp
operator|->
name|name
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|sp
operator|->
name|linecount
operator|=
literal|1
expr_stmt|;
name|sp
operator|->
name|pushback_index
operator|=
literal|0
expr_stmt|;
name|sp
operator|->
name|type
operator|=
name|include_file
expr_stmt|;
name|sp
operator|->
name|index
operator|=
literal|0
expr_stmt|;
name|sb_new
argument_list|(
operator|&
name|sp
operator|->
name|pushback
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_include
parameter_list|(
name|idx
parameter_list|,
name|in
parameter_list|)
name|int
name|idx
decl_stmt|;
name|sb
modifier|*
name|in
decl_stmt|;
block|{
name|sb
name|t
decl_stmt|;
name|sb
name|cat
decl_stmt|;
name|include_path
modifier|*
name|includes
decl_stmt|;
name|sb_new
argument_list|(
operator|&
name|t
argument_list|)
expr_stmt|;
name|sb_new
argument_list|(
operator|&
name|cat
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mri
condition|)
name|idx
operator|=
name|getstring
argument_list|(
name|idx
argument_list|,
name|in
argument_list|,
operator|&
name|t
argument_list|)
expr_stmt|;
else|else
block|{
name|idx
operator|=
name|sb_skip_white
argument_list|(
name|idx
argument_list|,
name|in
argument_list|)
expr_stmt|;
while|while
condition|(
name|idx
operator|<
name|in
operator|->
name|len
operator|&&
operator|!
name|ISWHITE
argument_list|(
name|in
operator|->
name|ptr
index|[
name|idx
index|]
argument_list|)
condition|)
block|{
name|sb_add_char
argument_list|(
operator|&
name|t
argument_list|,
name|in
operator|->
name|ptr
index|[
name|idx
index|]
argument_list|)
expr_stmt|;
operator|++
name|idx
expr_stmt|;
block|}
block|}
for|for
control|(
name|includes
operator|=
name|paths_head
init|;
name|includes
condition|;
name|includes
operator|=
name|includes
operator|->
name|next
control|)
block|{
name|sb_reset
argument_list|(
operator|&
name|cat
argument_list|)
expr_stmt|;
name|sb_add_sb
argument_list|(
operator|&
name|cat
argument_list|,
operator|&
name|includes
operator|->
name|path
argument_list|)
expr_stmt|;
name|sb_add_char
argument_list|(
operator|&
name|cat
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
name|sb_add_sb
argument_list|(
operator|&
name|cat
argument_list|,
operator|&
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_file
argument_list|(
name|sb_name
argument_list|(
operator|&
name|cat
argument_list|)
argument_list|)
condition|)
block|{
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|includes
condition|)
block|{
if|if
condition|(
operator|!
name|new_file
argument_list|(
name|sb_name
argument_list|(
operator|&
name|t
argument_list|)
argument_list|)
condition|)
name|FATAL
argument_list|(
operator|(
name|stderr
operator|,
name|_
argument_list|(
literal|"Can't open include file `%s'.\n"
argument_list|)
operator|,
name|sb_name
argument_list|(
operator|&
name|t
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
name|sb_kill
argument_list|(
operator|&
name|cat
argument_list|)
expr_stmt|;
name|sb_kill
argument_list|(
operator|&
name|t
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|include_pop
parameter_list|()
block|{
if|if
condition|(
name|sp
operator|!=
name|include_stack
condition|)
block|{
if|if
condition|(
name|sp
operator|->
name|handle
condition|)
name|fclose
argument_list|(
name|sp
operator|->
name|handle
argument_list|)
expr_stmt|;
name|sp
operator|--
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Get the next character from the include stack.  If there's anything    in the pushback buffer, take that first.  If we're at eof, pop from    the stack and try again.  Keep the linecount up to date.  */
end_comment

begin_function
specifier|static
name|int
name|get
parameter_list|()
block|{
name|int
name|r
decl_stmt|;
if|if
condition|(
name|sp
operator|->
name|pushback
operator|.
name|len
operator|!=
name|sp
operator|->
name|pushback_index
condition|)
block|{
name|r
operator|=
call|(
name|char
call|)
argument_list|(
name|sp
operator|->
name|pushback
operator|.
name|ptr
index|[
name|sp
operator|->
name|pushback_index
operator|++
index|]
argument_list|)
expr_stmt|;
comment|/* When they've all gone, reset the pointer.  */
if|if
condition|(
name|sp
operator|->
name|pushback_index
operator|==
name|sp
operator|->
name|pushback
operator|.
name|len
condition|)
block|{
name|sp
operator|->
name|pushback
operator|.
name|len
operator|=
literal|0
expr_stmt|;
name|sp
operator|->
name|pushback_index
operator|=
literal|0
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|sp
operator|->
name|handle
condition|)
block|{
name|r
operator|=
name|getc
argument_list|(
name|sp
operator|->
name|handle
argument_list|)
expr_stmt|;
block|}
else|else
name|r
operator|=
name|EOF
expr_stmt|;
if|if
condition|(
name|r
operator|==
name|EOF
operator|&&
name|isp
condition|)
block|{
name|include_pop
argument_list|()
expr_stmt|;
name|r
operator|=
name|get
argument_list|()
expr_stmt|;
while|while
condition|(
name|r
operator|==
name|EOF
operator|&&
name|isp
condition|)
block|{
name|include_pop
argument_list|()
expr_stmt|;
name|r
operator|=
name|get
argument_list|()
expr_stmt|;
block|}
return|return
name|r
return|;
block|}
if|if
condition|(
name|r
operator|==
literal|'\n'
condition|)
block|{
name|sp
operator|->
name|linecount
operator|++
expr_stmt|;
block|}
return|return
name|r
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|linecount
parameter_list|()
block|{
return|return
name|sp
operator|->
name|linecount
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|include_next_index
parameter_list|()
block|{
specifier|static
name|int
name|index
decl_stmt|;
if|if
condition|(
operator|!
name|unreasonable
operator|&&
name|index
operator|>
name|MAX_REASONABLE
condition|)
name|FATAL
argument_list|(
operator|(
name|stderr
operator|,
name|_
argument_list|(
literal|"Unreasonable expansion (-u turns off check).\n"
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return
operator|++
name|index
return|;
block|}
end_function

begin_comment
comment|/* Initialize the chartype vector.  */
end_comment

begin_function
specifier|static
name|void
name|chartype_init
parameter_list|()
block|{
name|int
name|x
decl_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
literal|256
condition|;
name|x
operator|++
control|)
block|{
if|if
condition|(
name|ISALPHA
argument_list|(
name|x
argument_list|)
operator|||
name|x
operator|==
literal|'_'
operator|||
name|x
operator|==
literal|'$'
condition|)
name|chartype
index|[
name|x
index|]
operator||=
name|FIRSTBIT
expr_stmt|;
if|if
condition|(
name|mri
operator|&&
name|x
operator|==
literal|'.'
condition|)
name|chartype
index|[
name|x
index|]
operator||=
name|FIRSTBIT
expr_stmt|;
if|if
condition|(
name|ISDIGIT
argument_list|(
name|x
argument_list|)
operator|||
name|ISALPHA
argument_list|(
name|x
argument_list|)
operator|||
name|x
operator|==
literal|'_'
operator|||
name|x
operator|==
literal|'$'
condition|)
name|chartype
index|[
name|x
index|]
operator||=
name|NEXTBIT
expr_stmt|;
if|if
condition|(
name|x
operator|==
literal|' '
operator|||
name|x
operator|==
literal|'\t'
operator|||
name|x
operator|==
literal|','
operator|||
name|x
operator|==
literal|'"'
operator|||
name|x
operator|==
literal|';'
operator|||
name|x
operator|==
literal|'"'
operator|||
name|x
operator|==
literal|'<'
operator|||
name|x
operator|==
literal|'>'
operator|||
name|x
operator|==
literal|')'
operator|||
name|x
operator|==
literal|'('
condition|)
name|chartype
index|[
name|x
index|]
operator||=
name|SEPBIT
expr_stmt|;
if|if
condition|(
name|x
operator|==
literal|'b'
operator|||
name|x
operator|==
literal|'B'
operator|||
name|x
operator|==
literal|'q'
operator|||
name|x
operator|==
literal|'Q'
operator|||
name|x
operator|==
literal|'h'
operator|||
name|x
operator|==
literal|'H'
operator|||
name|x
operator|==
literal|'d'
operator|||
name|x
operator|==
literal|'D'
condition|)
name|chartype
index|[
name|x
index|]
operator||=
name|BASEBIT
expr_stmt|;
if|if
condition|(
name|x
operator|==
literal|' '
operator|||
name|x
operator|==
literal|'\t'
condition|)
name|chartype
index|[
name|x
index|]
operator||=
name|WHITEBIT
expr_stmt|;
if|if
condition|(
name|x
operator|==
name|comment_char
condition|)
name|chartype
index|[
name|x
index|]
operator||=
name|COMMENTBIT
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* What to do with all the keywords.  */
end_comment

begin_define
define|#
directive|define
name|PROCESS
value|0x1000
end_define

begin_comment
comment|/* Run substitution over the line.  */
end_comment

begin_define
define|#
directive|define
name|LAB
value|0x2000
end_define

begin_comment
comment|/* Spit out the label.  */
end_comment

begin_define
define|#
directive|define
name|K_EQU
value|(PROCESS|1)
end_define

begin_define
define|#
directive|define
name|K_ASSIGN
value|(PROCESS|2)
end_define

begin_define
define|#
directive|define
name|K_REG
value|(PROCESS|3)
end_define

begin_define
define|#
directive|define
name|K_ORG
value|(PROCESS|4)
end_define

begin_define
define|#
directive|define
name|K_RADIX
value|(PROCESS|5)
end_define

begin_define
define|#
directive|define
name|K_DATA
value|(LAB|PROCESS|6)
end_define

begin_define
define|#
directive|define
name|K_DATAB
value|(LAB|PROCESS|7)
end_define

begin_define
define|#
directive|define
name|K_SDATA
value|(LAB|PROCESS|8)
end_define

begin_define
define|#
directive|define
name|K_SDATAB
value|(LAB|PROCESS|9)
end_define

begin_define
define|#
directive|define
name|K_SDATAC
value|(LAB|PROCESS|10)
end_define

begin_define
define|#
directive|define
name|K_SDATAZ
value|(LAB|PROCESS|11)
end_define

begin_define
define|#
directive|define
name|K_RES
value|(LAB|PROCESS|12)
end_define

begin_define
define|#
directive|define
name|K_SRES
value|(LAB|PROCESS|13)
end_define

begin_define
define|#
directive|define
name|K_SRESC
value|(LAB|PROCESS|14)
end_define

begin_define
define|#
directive|define
name|K_SRESZ
value|(LAB|PROCESS|15)
end_define

begin_define
define|#
directive|define
name|K_EXPORT
value|(LAB|PROCESS|16)
end_define

begin_define
define|#
directive|define
name|K_GLOBAL
value|(LAB|PROCESS|17)
end_define

begin_define
define|#
directive|define
name|K_PRINT
value|(LAB|PROCESS|19)
end_define

begin_define
define|#
directive|define
name|K_FORM
value|(LAB|PROCESS|20)
end_define

begin_define
define|#
directive|define
name|K_HEADING
value|(LAB|PROCESS|21)
end_define

begin_define
define|#
directive|define
name|K_PAGE
value|(LAB|PROCESS|22)
end_define

begin_define
define|#
directive|define
name|K_IMPORT
value|(LAB|PROCESS|23)
end_define

begin_define
define|#
directive|define
name|K_PROGRAM
value|(LAB|PROCESS|24)
end_define

begin_define
define|#
directive|define
name|K_END
value|(PROCESS|25)
end_define

begin_define
define|#
directive|define
name|K_INCLUDE
value|(PROCESS|26)
end_define

begin_define
define|#
directive|define
name|K_IGNORED
value|(PROCESS|27)
end_define

begin_define
define|#
directive|define
name|K_ASSIGNA
value|(PROCESS|28)
end_define

begin_define
define|#
directive|define
name|K_ASSIGNC
value|(29)
end_define

begin_define
define|#
directive|define
name|K_AIF
value|(PROCESS|30)
end_define

begin_define
define|#
directive|define
name|K_AELSE
value|(PROCESS|31)
end_define

begin_define
define|#
directive|define
name|K_AENDI
value|(PROCESS|32)
end_define

begin_define
define|#
directive|define
name|K_AREPEAT
value|(PROCESS|33)
end_define

begin_define
define|#
directive|define
name|K_AENDR
value|(PROCESS|34)
end_define

begin_define
define|#
directive|define
name|K_AWHILE
value|(35)
end_define

begin_define
define|#
directive|define
name|K_AENDW
value|(PROCESS|36)
end_define

begin_define
define|#
directive|define
name|K_EXITM
value|(37)
end_define

begin_define
define|#
directive|define
name|K_MACRO
value|(PROCESS|38)
end_define

begin_define
define|#
directive|define
name|K_ENDM
value|(39)
end_define

begin_define
define|#
directive|define
name|K_ALIGN
value|(PROCESS|LAB|40)
end_define

begin_define
define|#
directive|define
name|K_ALTERNATE
value|(41)
end_define

begin_define
define|#
directive|define
name|K_DB
value|(LAB|PROCESS|42)
end_define

begin_define
define|#
directive|define
name|K_DW
value|(LAB|PROCESS|43)
end_define

begin_define
define|#
directive|define
name|K_DL
value|(LAB|PROCESS|44)
end_define

begin_define
define|#
directive|define
name|K_LOCAL
value|(45)
end_define

begin_define
define|#
directive|define
name|K_IFEQ
value|(PROCESS|46)
end_define

begin_define
define|#
directive|define
name|K_IFNE
value|(PROCESS|47)
end_define

begin_define
define|#
directive|define
name|K_IFLT
value|(PROCESS|48)
end_define

begin_define
define|#
directive|define
name|K_IFLE
value|(PROCESS|49)
end_define

begin_define
define|#
directive|define
name|K_IFGE
value|(PROCESS|50)
end_define

begin_define
define|#
directive|define
name|K_IFGT
value|(PROCESS|51)
end_define

begin_define
define|#
directive|define
name|K_IFC
value|(PROCESS|52)
end_define

begin_define
define|#
directive|define
name|K_IFNC
value|(PROCESS|53)
end_define

begin_define
define|#
directive|define
name|K_IRP
value|(PROCESS|54)
end_define

begin_define
define|#
directive|define
name|K_IRPC
value|(PROCESS|55)
end_define

begin_struct
struct|struct
name|keyword
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|code
decl_stmt|;
name|int
name|extra
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|keyword
name|kinfo
index|[]
init|=
block|{
block|{
literal|"EQU"
block|,
name|K_EQU
block|,
literal|0
block|}
block|,
block|{
literal|"ALTERNATE"
block|,
name|K_ALTERNATE
block|,
literal|0
block|}
block|,
block|{
literal|"ASSIGN"
block|,
name|K_ASSIGN
block|,
literal|0
block|}
block|,
block|{
literal|"REG"
block|,
name|K_REG
block|,
literal|0
block|}
block|,
block|{
literal|"ORG"
block|,
name|K_ORG
block|,
literal|0
block|}
block|,
block|{
literal|"RADIX"
block|,
name|K_RADIX
block|,
literal|0
block|}
block|,
block|{
literal|"DATA"
block|,
name|K_DATA
block|,
literal|0
block|}
block|,
block|{
literal|"DB"
block|,
name|K_DB
block|,
literal|0
block|}
block|,
block|{
literal|"DW"
block|,
name|K_DW
block|,
literal|0
block|}
block|,
block|{
literal|"DL"
block|,
name|K_DL
block|,
literal|0
block|}
block|,
block|{
literal|"DATAB"
block|,
name|K_DATAB
block|,
literal|0
block|}
block|,
block|{
literal|"SDATA"
block|,
name|K_SDATA
block|,
literal|0
block|}
block|,
block|{
literal|"SDATAB"
block|,
name|K_SDATAB
block|,
literal|0
block|}
block|,
block|{
literal|"SDATAZ"
block|,
name|K_SDATAZ
block|,
literal|0
block|}
block|,
block|{
literal|"SDATAC"
block|,
name|K_SDATAC
block|,
literal|0
block|}
block|,
block|{
literal|"RES"
block|,
name|K_RES
block|,
literal|0
block|}
block|,
block|{
literal|"SRES"
block|,
name|K_SRES
block|,
literal|0
block|}
block|,
block|{
literal|"SRESC"
block|,
name|K_SRESC
block|,
literal|0
block|}
block|,
block|{
literal|"SRESZ"
block|,
name|K_SRESZ
block|,
literal|0
block|}
block|,
block|{
literal|"EXPORT"
block|,
name|K_EXPORT
block|,
literal|0
block|}
block|,
block|{
literal|"GLOBAL"
block|,
name|K_GLOBAL
block|,
literal|0
block|}
block|,
block|{
literal|"PRINT"
block|,
name|K_PRINT
block|,
literal|0
block|}
block|,
block|{
literal|"FORM"
block|,
name|K_FORM
block|,
literal|0
block|}
block|,
block|{
literal|"HEADING"
block|,
name|K_HEADING
block|,
literal|0
block|}
block|,
block|{
literal|"PAGE"
block|,
name|K_PAGE
block|,
literal|0
block|}
block|,
block|{
literal|"PROGRAM"
block|,
name|K_IGNORED
block|,
literal|0
block|}
block|,
block|{
literal|"END"
block|,
name|K_END
block|,
literal|0
block|}
block|,
block|{
literal|"INCLUDE"
block|,
name|K_INCLUDE
block|,
literal|0
block|}
block|,
block|{
literal|"ASSIGNA"
block|,
name|K_ASSIGNA
block|,
literal|0
block|}
block|,
block|{
literal|"ASSIGNC"
block|,
name|K_ASSIGNC
block|,
literal|0
block|}
block|,
block|{
literal|"AIF"
block|,
name|K_AIF
block|,
literal|0
block|}
block|,
block|{
literal|"AELSE"
block|,
name|K_AELSE
block|,
literal|0
block|}
block|,
block|{
literal|"AENDI"
block|,
name|K_AENDI
block|,
literal|0
block|}
block|,
block|{
literal|"AREPEAT"
block|,
name|K_AREPEAT
block|,
literal|0
block|}
block|,
block|{
literal|"AENDR"
block|,
name|K_AENDR
block|,
literal|0
block|}
block|,
block|{
literal|"EXITM"
block|,
name|K_EXITM
block|,
literal|0
block|}
block|,
block|{
literal|"MACRO"
block|,
name|K_MACRO
block|,
literal|0
block|}
block|,
block|{
literal|"ENDM"
block|,
name|K_ENDM
block|,
literal|0
block|}
block|,
block|{
literal|"AWHILE"
block|,
name|K_AWHILE
block|,
literal|0
block|}
block|,
block|{
literal|"ALIGN"
block|,
name|K_ALIGN
block|,
literal|0
block|}
block|,
block|{
literal|"AENDW"
block|,
name|K_AENDW
block|,
literal|0
block|}
block|,
block|{
literal|"ALTERNATE"
block|,
name|K_ALTERNATE
block|,
literal|0
block|}
block|,
block|{
literal|"LOCAL"
block|,
name|K_LOCAL
block|,
literal|0
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Although the conditional operators are handled by gas, we need to    handle them here as well, in case they are used in a recursive    macro to end the recursion.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|keyword
name|mrikinfo
index|[]
init|=
block|{
block|{
literal|"IFEQ"
block|,
name|K_IFEQ
block|,
literal|0
block|}
block|,
block|{
literal|"IFNE"
block|,
name|K_IFNE
block|,
literal|0
block|}
block|,
block|{
literal|"IFLT"
block|,
name|K_IFLT
block|,
literal|0
block|}
block|,
block|{
literal|"IFLE"
block|,
name|K_IFLE
block|,
literal|0
block|}
block|,
block|{
literal|"IFGE"
block|,
name|K_IFGE
block|,
literal|0
block|}
block|,
block|{
literal|"IFGT"
block|,
name|K_IFGT
block|,
literal|0
block|}
block|,
block|{
literal|"IFC"
block|,
name|K_IFC
block|,
literal|0
block|}
block|,
block|{
literal|"IFNC"
block|,
name|K_IFNC
block|,
literal|0
block|}
block|,
block|{
literal|"ELSEC"
block|,
name|K_AELSE
block|,
literal|0
block|}
block|,
block|{
literal|"ENDC"
block|,
name|K_AENDI
block|,
literal|0
block|}
block|,
block|{
literal|"MEXIT"
block|,
name|K_EXITM
block|,
literal|0
block|}
block|,
block|{
literal|"REPT"
block|,
name|K_AREPEAT
block|,
literal|0
block|}
block|,
block|{
literal|"IRP"
block|,
name|K_IRP
block|,
literal|0
block|}
block|,
block|{
literal|"IRPC"
block|,
name|K_IRPC
block|,
literal|0
block|}
block|,
block|{
literal|"ENDR"
block|,
name|K_AENDR
block|,
literal|0
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Look for a pseudo op on the line. If one's there then call    its handler.  */
end_comment

begin_function
specifier|static
name|int
name|process_pseudo_op
parameter_list|(
name|idx
parameter_list|,
name|line
parameter_list|,
name|acc
parameter_list|)
name|int
name|idx
decl_stmt|;
name|sb
modifier|*
name|line
decl_stmt|;
name|sb
modifier|*
name|acc
decl_stmt|;
block|{
name|int
name|oidx
init|=
name|idx
decl_stmt|;
if|if
condition|(
name|line
operator|->
name|ptr
index|[
name|idx
index|]
operator|==
literal|'.'
operator|||
name|alternate
operator|||
name|mri
condition|)
block|{
comment|/* Scan forward and find pseudo name.  */
name|char
modifier|*
name|in
decl_stmt|;
name|hash_entry
modifier|*
name|ptr
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
name|char
modifier|*
name|e
decl_stmt|;
if|if
condition|(
name|line
operator|->
name|ptr
index|[
name|idx
index|]
operator|==
literal|'.'
condition|)
name|idx
operator|++
expr_stmt|;
name|in
operator|=
name|line
operator|->
name|ptr
operator|+
name|idx
expr_stmt|;
name|s
operator|=
name|in
expr_stmt|;
name|e
operator|=
name|s
expr_stmt|;
name|sb_reset
argument_list|(
name|acc
argument_list|)
expr_stmt|;
while|while
condition|(
name|idx
operator|<
name|line
operator|->
name|len
operator|&&
operator|*
name|e
operator|&&
name|ISFIRSTCHAR
argument_list|(
operator|*
name|e
argument_list|)
condition|)
block|{
name|sb_add_char
argument_list|(
name|acc
argument_list|,
operator|*
name|e
argument_list|)
expr_stmt|;
name|e
operator|++
expr_stmt|;
name|idx
operator|++
expr_stmt|;
block|}
name|ptr
operator|=
name|hash_lookup
argument_list|(
operator|&
name|keyword_hash_table
argument_list|,
name|acc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ptr
condition|)
block|{
if|#
directive|if
literal|0
comment|/* This one causes lots of pain when trying to preprocess 	     ordinary code.  */
block|WARNING ((stderr, _("Unrecognised pseudo op `%s'.\n"), 		    sb_name (acc)));
endif|#
directive|endif
return|return
literal|0
return|;
block|}
if|if
condition|(
name|ptr
operator|->
name|value
operator|.
name|i
operator|&
name|LAB
condition|)
block|{
comment|/* Output the label.  */
if|if
condition|(
name|label
operator|.
name|len
condition|)
block|{
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"%s:\t"
argument_list|,
name|sb_name
argument_list|(
operator|&
name|label
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"\t"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mri
operator|&&
name|ptr
operator|->
name|value
operator|.
name|i
operator|==
name|K_END
condition|)
block|{
name|sb
name|t
decl_stmt|;
name|sb_new
argument_list|(
operator|&
name|t
argument_list|)
expr_stmt|;
name|sb_add_buffer
argument_list|(
operator|&
name|t
argument_list|,
name|line
operator|->
name|ptr
operator|+
name|oidx
argument_list|,
name|idx
operator|-
name|oidx
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"\t%s"
argument_list|,
name|sb_name
argument_list|(
operator|&
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|sb_kill
argument_list|(
operator|&
name|t
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ptr
operator|->
name|value
operator|.
name|i
operator|&
name|PROCESS
condition|)
block|{
comment|/* Polish the rest of the line before handling the pseudo op.  */
if|#
directive|if
literal|0
block|strip_comments (line);
endif|#
directive|endif
name|sb_reset
argument_list|(
name|acc
argument_list|)
expr_stmt|;
name|process_assigns
argument_list|(
name|idx
argument_list|,
name|line
argument_list|,
name|acc
argument_list|)
expr_stmt|;
name|sb_reset
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|change_base
argument_list|(
literal|0
argument_list|,
name|acc
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|idx
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|condass_on
argument_list|()
condition|)
block|{
switch|switch
condition|(
name|ptr
operator|->
name|value
operator|.
name|i
condition|)
block|{
case|case
name|K_AIF
case|:
name|do_aif
argument_list|(
name|idx
argument_list|,
name|line
argument_list|)
expr_stmt|;
break|break;
case|case
name|K_AELSE
case|:
name|do_aelse
argument_list|()
expr_stmt|;
break|break;
case|case
name|K_AENDI
case|:
name|do_aendi
argument_list|()
expr_stmt|;
break|break;
block|}
return|return
literal|1
return|;
block|}
else|else
block|{
switch|switch
condition|(
name|ptr
operator|->
name|value
operator|.
name|i
condition|)
block|{
case|case
name|K_ALTERNATE
case|:
name|alternate
operator|=
literal|1
expr_stmt|;
name|macro_init
argument_list|(
literal|1
argument_list|,
name|mri
argument_list|,
literal|0
argument_list|,
name|exp_get_abs
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
case|case
name|K_AELSE
case|:
name|do_aelse
argument_list|()
expr_stmt|;
return|return
literal|1
return|;
case|case
name|K_AENDI
case|:
name|do_aendi
argument_list|()
expr_stmt|;
return|return
literal|1
return|;
case|case
name|K_ORG
case|:
name|ERROR
argument_list|(
operator|(
name|stderr
operator|,
name|_
argument_list|(
literal|"ORG command not allowed.\n"
argument_list|)
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|K_RADIX
case|:
name|do_radix
argument_list|(
name|line
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
case|case
name|K_DB
case|:
name|do_data
argument_list|(
name|idx
argument_list|,
name|line
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
case|case
name|K_DW
case|:
name|do_data
argument_list|(
name|idx
argument_list|,
name|line
argument_list|,
literal|2
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
case|case
name|K_DL
case|:
name|do_data
argument_list|(
name|idx
argument_list|,
name|line
argument_list|,
literal|4
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
case|case
name|K_DATA
case|:
name|do_data
argument_list|(
name|idx
argument_list|,
name|line
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
case|case
name|K_DATAB
case|:
name|do_datab
argument_list|(
name|idx
argument_list|,
name|line
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
case|case
name|K_SDATA
case|:
name|do_sdata
argument_list|(
name|idx
argument_list|,
name|line
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
case|case
name|K_SDATAB
case|:
name|do_sdatab
argument_list|(
name|idx
argument_list|,
name|line
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
case|case
name|K_SDATAC
case|:
name|do_sdata
argument_list|(
name|idx
argument_list|,
name|line
argument_list|,
literal|'c'
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
case|case
name|K_SDATAZ
case|:
name|do_sdata
argument_list|(
name|idx
argument_list|,
name|line
argument_list|,
literal|'z'
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
case|case
name|K_ASSIGN
case|:
name|do_assign
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|line
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
case|case
name|K_AIF
case|:
name|do_aif
argument_list|(
name|idx
argument_list|,
name|line
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
case|case
name|K_AREPEAT
case|:
name|do_arepeat
argument_list|(
name|idx
argument_list|,
name|line
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
case|case
name|K_AENDW
case|:
name|do_aendw
argument_list|()
expr_stmt|;
return|return
literal|1
return|;
case|case
name|K_AWHILE
case|:
name|do_awhile
argument_list|(
name|idx
argument_list|,
name|line
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
case|case
name|K_AENDR
case|:
name|do_aendr
argument_list|()
expr_stmt|;
return|return
literal|1
return|;
case|case
name|K_EQU
case|:
name|do_assign
argument_list|(
literal|1
argument_list|,
name|idx
argument_list|,
name|line
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
case|case
name|K_ALIGN
case|:
name|do_align
argument_list|(
name|idx
argument_list|,
name|line
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
case|case
name|K_RES
case|:
name|do_res
argument_list|(
name|idx
argument_list|,
name|line
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
case|case
name|K_SRES
case|:
name|do_res
argument_list|(
name|idx
argument_list|,
name|line
argument_list|,
literal|'s'
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
case|case
name|K_INCLUDE
case|:
name|do_include
argument_list|(
name|idx
argument_list|,
name|line
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
case|case
name|K_LOCAL
case|:
name|do_local
argument_list|(
name|idx
argument_list|,
name|line
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
case|case
name|K_MACRO
case|:
name|do_macro
argument_list|(
name|idx
argument_list|,
name|line
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
case|case
name|K_ENDM
case|:
name|do_endm
argument_list|()
expr_stmt|;
return|return
literal|1
return|;
case|case
name|K_SRESC
case|:
name|do_res
argument_list|(
name|idx
argument_list|,
name|line
argument_list|,
literal|'c'
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
case|case
name|K_PRINT
case|:
name|do_print
argument_list|(
name|idx
argument_list|,
name|line
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
case|case
name|K_FORM
case|:
name|do_form
argument_list|(
name|idx
argument_list|,
name|line
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
case|case
name|K_HEADING
case|:
name|do_heading
argument_list|(
name|idx
argument_list|,
name|line
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
case|case
name|K_PAGE
case|:
name|do_page
argument_list|()
expr_stmt|;
return|return
literal|1
return|;
case|case
name|K_GLOBAL
case|:
case|case
name|K_EXPORT
case|:
name|do_export
argument_list|(
name|line
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
case|case
name|K_IMPORT
case|:
return|return
literal|1
return|;
case|case
name|K_SRESZ
case|:
name|do_res
argument_list|(
name|idx
argument_list|,
name|line
argument_list|,
literal|'z'
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
case|case
name|K_IGNORED
case|:
return|return
literal|1
return|;
case|case
name|K_END
case|:
name|do_end
argument_list|(
name|line
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
case|case
name|K_ASSIGNA
case|:
name|do_assigna
argument_list|(
name|idx
argument_list|,
name|line
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
case|case
name|K_ASSIGNC
case|:
name|do_assignc
argument_list|(
name|idx
argument_list|,
name|line
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
case|case
name|K_EXITM
case|:
name|do_exitm
argument_list|()
expr_stmt|;
return|return
literal|1
return|;
case|case
name|K_REG
case|:
name|do_reg
argument_list|(
name|idx
argument_list|,
name|line
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
case|case
name|K_IFEQ
case|:
name|do_if
argument_list|(
name|idx
argument_list|,
name|line
argument_list|,
name|EQ
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
case|case
name|K_IFNE
case|:
name|do_if
argument_list|(
name|idx
argument_list|,
name|line
argument_list|,
name|NE
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
case|case
name|K_IFLT
case|:
name|do_if
argument_list|(
name|idx
argument_list|,
name|line
argument_list|,
name|LT
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
case|case
name|K_IFLE
case|:
name|do_if
argument_list|(
name|idx
argument_list|,
name|line
argument_list|,
name|LE
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
case|case
name|K_IFGE
case|:
name|do_if
argument_list|(
name|idx
argument_list|,
name|line
argument_list|,
name|GE
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
case|case
name|K_IFGT
case|:
name|do_if
argument_list|(
name|idx
argument_list|,
name|line
argument_list|,
name|GT
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
case|case
name|K_IFC
case|:
name|do_ifc
argument_list|(
name|idx
argument_list|,
name|line
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
case|case
name|K_IFNC
case|:
name|do_ifc
argument_list|(
name|idx
argument_list|,
name|line
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
case|case
name|K_IRP
case|:
name|do_irp
argument_list|(
name|idx
argument_list|,
name|line
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
case|case
name|K_IRPC
case|:
name|do_irp
argument_list|(
name|idx
argument_list|,
name|line
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Add a keyword to the hash table.  */
end_comment

begin_function
specifier|static
name|void
name|add_keyword
parameter_list|(
name|name
parameter_list|,
name|code
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|code
decl_stmt|;
block|{
name|sb
name|label
decl_stmt|;
name|int
name|j
decl_stmt|;
name|sb_new
argument_list|(
operator|&
name|label
argument_list|)
expr_stmt|;
name|sb_add_string
argument_list|(
operator|&
name|label
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|hash_add_to_int_table
argument_list|(
operator|&
name|keyword_hash_table
argument_list|,
operator|&
name|label
argument_list|,
name|code
argument_list|)
expr_stmt|;
name|sb_reset
argument_list|(
operator|&
name|label
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|name
index|[
name|j
index|]
condition|;
name|j
operator|++
control|)
name|sb_add_char
argument_list|(
operator|&
name|label
argument_list|,
name|name
index|[
name|j
index|]
operator|-
literal|'A'
operator|+
literal|'a'
argument_list|)
expr_stmt|;
name|hash_add_to_int_table
argument_list|(
operator|&
name|keyword_hash_table
argument_list|,
operator|&
name|label
argument_list|,
name|code
argument_list|)
expr_stmt|;
name|sb_kill
argument_list|(
operator|&
name|label
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Build the keyword hash table - put each keyword in the table twice,    once upper and once lower case.  */
end_comment

begin_function
specifier|static
name|void
name|process_init
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|kinfo
index|[
name|i
index|]
operator|.
name|name
condition|;
name|i
operator|++
control|)
name|add_keyword
argument_list|(
name|kinfo
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|kinfo
index|[
name|i
index|]
operator|.
name|code
argument_list|)
expr_stmt|;
if|if
condition|(
name|mri
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|mrikinfo
index|[
name|i
index|]
operator|.
name|name
condition|;
name|i
operator|++
control|)
name|add_keyword
argument_list|(
name|mrikinfo
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|mrikinfo
index|[
name|i
index|]
operator|.
name|code
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|do_define
parameter_list|(
name|string
parameter_list|)
specifier|const
name|char
modifier|*
name|string
decl_stmt|;
block|{
name|sb
name|label
decl_stmt|;
name|int
name|res
init|=
literal|1
decl_stmt|;
name|hash_entry
modifier|*
name|ptr
decl_stmt|;
name|sb_new
argument_list|(
operator|&
name|label
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|string
condition|)
block|{
if|if
condition|(
operator|*
name|string
operator|==
literal|'='
condition|)
block|{
name|sb
name|value
decl_stmt|;
name|sb_new
argument_list|(
operator|&
name|value
argument_list|)
expr_stmt|;
name|string
operator|++
expr_stmt|;
while|while
condition|(
operator|*
name|string
condition|)
block|{
name|sb_add_char
argument_list|(
operator|&
name|value
argument_list|,
operator|*
name|string
argument_list|)
expr_stmt|;
name|string
operator|++
expr_stmt|;
block|}
name|exp_get_abs
argument_list|(
name|_
argument_list|(
literal|"Invalid expression on command line.\n"
argument_list|)
argument_list|,
literal|0
argument_list|,
operator|&
name|value
argument_list|,
operator|&
name|res
argument_list|)
expr_stmt|;
name|sb_kill
argument_list|(
operator|&
name|value
argument_list|)
expr_stmt|;
break|break;
block|}
name|sb_add_char
argument_list|(
operator|&
name|label
argument_list|,
operator|*
name|string
argument_list|)
expr_stmt|;
name|string
operator|++
expr_stmt|;
block|}
name|ptr
operator|=
name|hash_create
argument_list|(
operator|&
name|vars
argument_list|,
operator|&
name|label
argument_list|)
expr_stmt|;
name|free_old_entry
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
name|ptr
operator|->
name|type
operator|=
name|hash_integer
expr_stmt|;
name|ptr
operator|->
name|value
operator|.
name|i
operator|=
name|res
expr_stmt|;
name|sb_kill
argument_list|(
operator|&
name|label
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|char
modifier|*
name|program_name
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The list of long options.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|option
name|long_options
index|[]
init|=
block|{
block|{
literal|"alternate"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'a'
block|}
block|,
block|{
literal|"include"
block|,
name|required_argument
block|,
literal|0
block|,
literal|'I'
block|}
block|,
block|{
literal|"commentchar"
block|,
name|required_argument
block|,
literal|0
block|,
literal|'c'
block|}
block|,
block|{
literal|"copysource"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'s'
block|}
block|,
block|{
literal|"debug"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'d'
block|}
block|,
block|{
literal|"help"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'h'
block|}
block|,
block|{
literal|"mri"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'M'
block|}
block|,
block|{
literal|"output"
block|,
name|required_argument
block|,
literal|0
block|,
literal|'o'
block|}
block|,
block|{
literal|"print"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'p'
block|}
block|,
block|{
literal|"unreasonable"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'u'
block|}
block|,
block|{
literal|"version"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'v'
block|}
block|,
block|{
literal|"define"
block|,
name|required_argument
block|,
literal|0
block|,
literal|'d'
block|}
block|,
block|{
name|NULL
block|,
name|no_argument
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Show a usage message and exit.  */
end_comment

begin_function
specifier|static
name|void
name|show_usage
parameter_list|(
name|file
parameter_list|,
name|status
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|int
name|status
decl_stmt|;
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|"\ Usage: %s \n\   [-a]      [--alternate]         enter alternate macro mode\n\   [-c char] [--commentchar char]  change the comment character from !\n\   [-d]      [--debug]             print some debugging info\n\   [-h]      [--help]              print this message\n\   [-M]      [--mri]               enter MRI compatibility mode\n\   [-o out]  [--output out]        set the output file\n\   [-p]      [--print]             print line numbers\n"
argument_list|)
argument_list|,
name|program_name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|"\   [-s]      [--copysource]        copy source through as comments \n\   [-u]      [--unreasonable]      allow unreasonable nesting\n\   [-v]      [--version]           print the program version\n\   [-Dname=value]                  create preprocessor variable called name, with value\n\   [-Ipath]                        add to include path list\n\   [in-file]\n"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
literal|0
condition|)
name|printf
argument_list|(
name|_
argument_list|(
literal|"Report bugs to %s\n"
argument_list|)
argument_list|,
name|REPORT_BUGS_TO
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|status
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Display a help message and exit.  */
end_comment

begin_function
specifier|static
name|void
name|show_help
parameter_list|()
block|{
name|printf
argument_list|(
name|_
argument_list|(
literal|"%s: Gnu Assembler Macro Preprocessor\n"
argument_list|)
argument_list|,
name|program_name
argument_list|)
expr_stmt|;
name|show_usage
argument_list|(
name|stdout
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|int
decl|main
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|int
name|opt
decl_stmt|;
name|char
modifier|*
name|out_name
init|=
literal|0
decl_stmt|;
name|sp
operator|=
name|include_stack
expr_stmt|;
name|ifstack
index|[
literal|0
index|]
operator|.
name|on
operator|=
literal|1
expr_stmt|;
name|ifi
operator|=
literal|0
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HAVE_SETLOCALE
argument_list|)
operator|&&
name|defined
argument_list|(
name|HAVE_LC_MESSAGES
argument_list|)
name|setlocale
argument_list|(
name|LC_MESSAGES
argument_list|,
literal|""
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|HAVE_SETLOCALE
argument_list|)
name|setlocale
argument_list|(
name|LC_CTYPE
argument_list|,
literal|""
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|bindtextdomain
argument_list|(
name|PACKAGE
argument_list|,
name|LOCALEDIR
argument_list|)
expr_stmt|;
name|textdomain
argument_list|(
name|PACKAGE
argument_list|)
expr_stmt|;
name|program_name
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
name|xmalloc_set_program_name
argument_list|(
name|program_name
argument_list|)
expr_stmt|;
name|hash_new_table
argument_list|(
literal|101
argument_list|,
operator|&
name|keyword_hash_table
argument_list|)
expr_stmt|;
name|hash_new_table
argument_list|(
literal|101
argument_list|,
operator|&
name|assign_hash_table
argument_list|)
expr_stmt|;
name|hash_new_table
argument_list|(
literal|101
argument_list|,
operator|&
name|vars
argument_list|)
expr_stmt|;
name|sb_new
argument_list|(
operator|&
name|label
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|opt
operator|=
name|getopt_long
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"I:sdhavc:upo:D:M"
argument_list|,
name|long_options
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
switch|switch
condition|(
name|opt
condition|)
block|{
case|case
literal|'o'
case|:
name|out_name
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
name|unreasonable
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'I'
case|:
block|{
name|include_path
modifier|*
name|p
init|=
operator|(
name|include_path
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|include_path
argument_list|)
argument_list|)
decl_stmt|;
name|p
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|sb_new
argument_list|(
operator|&
name|p
operator|->
name|path
argument_list|)
expr_stmt|;
name|sb_add_string
argument_list|(
operator|&
name|p
operator|->
name|path
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
if|if
condition|(
name|paths_tail
condition|)
name|paths_tail
operator|->
name|next
operator|=
name|p
expr_stmt|;
else|else
name|paths_head
operator|=
name|p
expr_stmt|;
name|paths_tail
operator|=
name|p
expr_stmt|;
block|}
break|break;
case|case
literal|'p'
case|:
name|print_line_number
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|comment_char
operator|=
name|optarg
index|[
literal|0
index|]
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
name|alternate
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|copysource
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|stats
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
name|do_define
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'M'
case|:
name|mri
operator|=
literal|1
expr_stmt|;
name|comment_char
operator|=
literal|';'
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
name|show_help
argument_list|()
expr_stmt|;
comment|/* NOTREACHED  */
case|case
literal|'v'
case|:
comment|/* This output is intended to follow the GNU standards document.  */
name|printf
argument_list|(
name|_
argument_list|(
literal|"GNU assembler pre-processor %s\n"
argument_list|)
argument_list|,
name|program_version
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"Copyright 1996 Free Software Foundation, Inc.\n"
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"\ This program is free software; you may redistribute it under the terms of\n\ the GNU General Public License.  This program has absolutely no warranty.\n"
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* NOTREACHED  */
case|case
literal|0
case|:
break|break;
default|default:
name|show_usage
argument_list|(
name|stderr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* NOTREACHED  */
block|}
block|}
name|process_init
argument_list|()
expr_stmt|;
name|macro_init
argument_list|(
name|alternate
argument_list|,
name|mri
argument_list|,
literal|0
argument_list|,
name|exp_get_abs
argument_list|)
expr_stmt|;
if|if
condition|(
name|out_name
condition|)
block|{
name|outfile
operator|=
name|fopen
argument_list|(
name|out_name
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|outfile
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"%s: Can't open output file `%s'.\n"
argument_list|)
argument_list|,
name|program_name
argument_list|,
name|out_name
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|outfile
operator|=
name|stdout
expr_stmt|;
block|}
name|chartype_init
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|outfile
condition|)
name|outfile
operator|=
name|stdout
expr_stmt|;
comment|/* Process all the input files.  */
while|while
condition|(
name|optind
operator|<
name|argc
condition|)
block|{
if|if
condition|(
name|new_file
argument_list|(
name|argv
index|[
name|optind
index|]
argument_list|)
condition|)
block|{
name|process_file
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"%s: Can't open input file `%s'.\n"
argument_list|)
argument_list|,
name|program_name
argument_list|,
name|argv
index|[
name|optind
index|]
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|optind
operator|++
expr_stmt|;
block|}
name|quit
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* This function is used because an abort in some of the other files    may be compiled into as_abort because they include as.h.  */
end_comment

begin_function
name|void
name|as_abort
parameter_list|(
name|file
parameter_list|,
name|line
parameter_list|,
name|fn
parameter_list|)
specifier|const
name|char
modifier|*
name|file
decl_stmt|,
decl|*
name|fn
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|line
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"Internal error, aborting at %s line %d"
argument_list|)
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|fn
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" in %s"
argument_list|,
name|fn
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"\nPlease report this bug.\n"
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

