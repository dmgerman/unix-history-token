begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* write.c - emit .o file    Copyright 1986, 1987, 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997,    1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007    Free Software Foundation, Inc.     This file is part of GAS, the GNU Assembler.     GAS is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     GAS is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with GAS; see the file COPYING.  If not, write to the Free    Software Foundation, 51 Franklin Street - Fifth Floor, Boston, MA    02110-1301, USA.  */
end_comment

begin_comment
comment|/* This thing should be set up to do byteordering correctly.  But...  */
end_comment

begin_include
include|#
directive|include
file|"as.h"
end_include

begin_include
include|#
directive|include
file|"subsegs.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_include
include|#
directive|include
file|"output-file.h"
end_include

begin_include
include|#
directive|include
file|"dwarf2dbg.h"
end_include

begin_include
include|#
directive|include
file|"libbfd.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|TC_ADJUST_RELOC_COUNT
end_ifndef

begin_define
define|#
directive|define
name|TC_ADJUST_RELOC_COUNT
parameter_list|(
name|FIX
parameter_list|,
name|COUNT
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|TC_FORCE_RELOCATION
end_ifndef

begin_define
define|#
directive|define
name|TC_FORCE_RELOCATION
parameter_list|(
name|FIX
parameter_list|)
define|\
value|(generic_force_reloc (FIX))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|TC_FORCE_RELOCATION_ABS
end_ifndef

begin_define
define|#
directive|define
name|TC_FORCE_RELOCATION_ABS
parameter_list|(
name|FIX
parameter_list|)
define|\
value|(TC_FORCE_RELOCATION (FIX))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|TC_FORCE_RELOCATION_LOCAL
end_ifndef

begin_define
define|#
directive|define
name|TC_FORCE_RELOCATION_LOCAL
parameter_list|(
name|FIX
parameter_list|)
define|\
value|(!(FIX)->fx_pcrel				\    || TC_FORCE_RELOCATION (FIX))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|TC_FORCE_RELOCATION_SUB_SAME
end_ifndef

begin_define
define|#
directive|define
name|TC_FORCE_RELOCATION_SUB_SAME
parameter_list|(
name|FIX
parameter_list|,
name|SEG
parameter_list|)
define|\
value|(! SEG_NORMAL (SEG))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|TC_FORCE_RELOCATION_SUB_ABS
end_ifndef

begin_define
define|#
directive|define
name|TC_FORCE_RELOCATION_SUB_ABS
parameter_list|(
name|FIX
parameter_list|)
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|TC_FORCE_RELOCATION_SUB_LOCAL
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|DIFF_EXPR_OK
end_ifdef

begin_define
define|#
directive|define
name|TC_FORCE_RELOCATION_SUB_LOCAL
parameter_list|(
name|FIX
parameter_list|)
value|0
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|TC_FORCE_RELOCATION_SUB_LOCAL
parameter_list|(
name|FIX
parameter_list|)
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|TC_VALIDATE_FIX_SUB
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|UNDEFINED_DIFFERENCE_OK
end_ifdef

begin_comment
comment|/* The PA needs this for PIC code generation.  */
end_comment

begin_define
define|#
directive|define
name|TC_VALIDATE_FIX_SUB
parameter_list|(
name|FIX
parameter_list|)
value|1
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|TC_VALIDATE_FIX_SUB
parameter_list|(
name|FIX
parameter_list|)
define|\
value|((FIX)->fx_r_type == BFD_RELOC_GPREL32	\    || (FIX)->fx_r_type == BFD_RELOC_GPREL16)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|TC_LINKRELAX_FIXUP
end_ifndef

begin_define
define|#
directive|define
name|TC_LINKRELAX_FIXUP
parameter_list|(
name|SEG
parameter_list|)
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|MD_APPLY_SYM_VALUE
end_ifndef

begin_define
define|#
directive|define
name|MD_APPLY_SYM_VALUE
parameter_list|(
name|FIX
parameter_list|)
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|TC_FINALIZE_SYMS_BEFORE_SIZE_SEG
end_ifndef

begin_define
define|#
directive|define
name|TC_FINALIZE_SYMS_BEFORE_SIZE_SEG
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|MD_PCREL_FROM_SECTION
end_ifndef

begin_define
define|#
directive|define
name|MD_PCREL_FROM_SECTION
parameter_list|(
name|FIX
parameter_list|,
name|SEC
parameter_list|)
value|md_pcrel_from (FIX)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|TC_FAKE_LABEL
end_ifndef

begin_define
define|#
directive|define
name|TC_FAKE_LABEL
parameter_list|(
name|NAME
parameter_list|)
value|(strcmp ((NAME), FAKE_LABEL_NAME) == 0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Positive values of TC_FX_SIZE_SLACK allow a target to define    fixups that far past the end of a frag.  Having such fixups    is of course most most likely a bug in setting fx_size correctly.    A negative value disables the fixup check entirely, which is    appropriate for something like the Renesas / SuperH SH_COUNT    reloc.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|TC_FX_SIZE_SLACK
end_ifndef

begin_define
define|#
directive|define
name|TC_FX_SIZE_SLACK
parameter_list|(
name|FIX
parameter_list|)
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Used to control final evaluation of expressions.  */
end_comment

begin_decl_stmt
name|int
name|finalize_syms
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|symbol_table_frozen
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|symbolS
modifier|*
name|abs_section_sym
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Remember the value of dot when parsing expressions.  */
end_comment

begin_decl_stmt
name|addressT
name|dot_value
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Relocs generated by ".reloc" pseudo.  */
end_comment

begin_decl_stmt
name|struct
name|reloc_list
modifier|*
name|reloc_list
decl_stmt|;
end_decl_stmt

begin_function_decl
name|void
name|print_fixup
parameter_list|(
name|fixS
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* We generally attach relocs to frag chains.  However, after we have    chained these all together into a segment, any relocs we add after    that must be attached to a segment.  This will include relocs added    in md_estimate_size_for_relax, for example.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|frags_chained
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|n_fixups
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|RELOC_ENUM
value|enum bfd_reloc_code_real
end_define

begin_comment
comment|/* Create a fixS in obstack 'notes'.  */
end_comment

begin_function
specifier|static
name|fixS
modifier|*
name|fix_new_internal
parameter_list|(
name|fragS
modifier|*
name|frag
parameter_list|,
comment|/* Which frag?  */
name|int
name|where
parameter_list|,
comment|/* Where in that frag?  */
name|int
name|size
parameter_list|,
comment|/* 1, 2, or 4 usually.  */
name|symbolS
modifier|*
name|add_symbol
parameter_list|,
comment|/* X_add_symbol.  */
name|symbolS
modifier|*
name|sub_symbol
parameter_list|,
comment|/* X_op_symbol.  */
name|offsetT
name|offset
parameter_list|,
comment|/* X_add_number.  */
name|int
name|pcrel
parameter_list|,
comment|/* TRUE if PC-relative relocation.  */
name|RELOC_ENUM
name|r_type
name|ATTRIBUTE_UNUSED
comment|/* Relocation type.  */
parameter_list|)
block|{
name|fixS
modifier|*
name|fixP
decl_stmt|;
name|n_fixups
operator|++
expr_stmt|;
name|fixP
operator|=
name|obstack_alloc
argument_list|(
operator|&
name|notes
argument_list|,
sizeof|sizeof
argument_list|(
name|fixS
argument_list|)
argument_list|)
expr_stmt|;
name|fixP
operator|->
name|fx_frag
operator|=
name|frag
expr_stmt|;
name|fixP
operator|->
name|fx_where
operator|=
name|where
expr_stmt|;
name|fixP
operator|->
name|fx_size
operator|=
name|size
expr_stmt|;
comment|/* We've made fx_size a narrow field; check that it's wide enough.  */
if|if
condition|(
name|fixP
operator|->
name|fx_size
operator|!=
name|size
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"field fx_size too small to hold %d"
argument_list|)
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
name|fixP
operator|->
name|fx_addsy
operator|=
name|add_symbol
expr_stmt|;
name|fixP
operator|->
name|fx_subsy
operator|=
name|sub_symbol
expr_stmt|;
name|fixP
operator|->
name|fx_offset
operator|=
name|offset
expr_stmt|;
name|fixP
operator|->
name|fx_dot_value
operator|=
name|dot_value
expr_stmt|;
name|fixP
operator|->
name|fx_pcrel
operator|=
name|pcrel
expr_stmt|;
name|fixP
operator|->
name|fx_r_type
operator|=
name|r_type
expr_stmt|;
name|fixP
operator|->
name|fx_im_disp
operator|=
literal|0
expr_stmt|;
name|fixP
operator|->
name|fx_pcrel_adjust
operator|=
literal|0
expr_stmt|;
name|fixP
operator|->
name|fx_bit_fixP
operator|=
literal|0
expr_stmt|;
name|fixP
operator|->
name|fx_addnumber
operator|=
literal|0
expr_stmt|;
name|fixP
operator|->
name|fx_tcbit
operator|=
literal|0
expr_stmt|;
name|fixP
operator|->
name|fx_tcbit2
operator|=
literal|0
expr_stmt|;
name|fixP
operator|->
name|fx_done
operator|=
literal|0
expr_stmt|;
name|fixP
operator|->
name|fx_no_overflow
operator|=
literal|0
expr_stmt|;
name|fixP
operator|->
name|fx_signed
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|USING_CGEN
name|fixP
operator|->
name|fx_cgen
operator|.
name|insn
operator|=
name|NULL
expr_stmt|;
name|fixP
operator|->
name|fx_cgen
operator|.
name|opinfo
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TC_FIX_TYPE
name|TC_INIT_FIX_DATA
argument_list|(
name|fixP
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|as_where
argument_list|(
operator|&
name|fixP
operator|->
name|fx_file
argument_list|,
operator|&
name|fixP
operator|->
name|fx_line
argument_list|)
expr_stmt|;
comment|/* Usually, we want relocs sorted numerically, but while      comparing to older versions of gas that have relocs      reverse sorted, it is convenient to have this compile      time option.  xoxorich.  */
block|{
name|fixS
modifier|*
modifier|*
name|seg_fix_rootP
init|=
operator|(
name|frags_chained
condition|?
operator|&
name|seg_info
argument_list|(
name|now_seg
argument_list|)
operator|->
name|fix_root
else|:
operator|&
name|frchain_now
operator|->
name|fix_root
operator|)
decl_stmt|;
name|fixS
modifier|*
modifier|*
name|seg_fix_tailP
init|=
operator|(
name|frags_chained
condition|?
operator|&
name|seg_info
argument_list|(
name|now_seg
argument_list|)
operator|->
name|fix_tail
else|:
operator|&
name|frchain_now
operator|->
name|fix_tail
operator|)
decl_stmt|;
ifdef|#
directive|ifdef
name|REVERSE_SORT_RELOCS
name|fixP
operator|->
name|fx_next
operator|=
operator|*
name|seg_fix_rootP
expr_stmt|;
operator|*
name|seg_fix_rootP
operator|=
name|fixP
expr_stmt|;
else|#
directive|else
comment|/* REVERSE_SORT_RELOCS  */
name|fixP
operator|->
name|fx_next
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|*
name|seg_fix_tailP
condition|)
operator|(
operator|*
name|seg_fix_tailP
operator|)
operator|->
name|fx_next
operator|=
name|fixP
expr_stmt|;
else|else
operator|*
name|seg_fix_rootP
operator|=
name|fixP
expr_stmt|;
operator|*
name|seg_fix_tailP
operator|=
name|fixP
expr_stmt|;
endif|#
directive|endif
comment|/* REVERSE_SORT_RELOCS  */
block|}
return|return
name|fixP
return|;
block|}
end_function

begin_comment
comment|/* Create a fixup relative to a symbol (plus a constant).  */
end_comment

begin_function
name|fixS
modifier|*
name|fix_new
parameter_list|(
name|fragS
modifier|*
name|frag
parameter_list|,
comment|/* Which frag?  */
name|int
name|where
parameter_list|,
comment|/* Where in that frag?  */
name|int
name|size
parameter_list|,
comment|/* 1, 2, or 4 usually.  */
name|symbolS
modifier|*
name|add_symbol
parameter_list|,
comment|/* X_add_symbol.  */
name|offsetT
name|offset
parameter_list|,
comment|/* X_add_number.  */
name|int
name|pcrel
parameter_list|,
comment|/* TRUE if PC-relative relocation.  */
name|RELOC_ENUM
name|r_type
comment|/* Relocation type.  */
parameter_list|)
block|{
return|return
name|fix_new_internal
argument_list|(
name|frag
argument_list|,
name|where
argument_list|,
name|size
argument_list|,
name|add_symbol
argument_list|,
operator|(
name|symbolS
operator|*
operator|)
name|NULL
argument_list|,
name|offset
argument_list|,
name|pcrel
argument_list|,
name|r_type
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Create a fixup for an expression.  Currently we only support fixups    for difference expressions.  That is itself more than most object    file formats support anyhow.  */
end_comment

begin_function
name|fixS
modifier|*
name|fix_new_exp
parameter_list|(
name|fragS
modifier|*
name|frag
parameter_list|,
comment|/* Which frag?  */
name|int
name|where
parameter_list|,
comment|/* Where in that frag?  */
name|int
name|size
parameter_list|,
comment|/* 1, 2, or 4 usually.  */
name|expressionS
modifier|*
name|exp
parameter_list|,
comment|/* Expression.  */
name|int
name|pcrel
parameter_list|,
comment|/* TRUE if PC-relative relocation.  */
name|RELOC_ENUM
name|r_type
comment|/* Relocation type.  */
parameter_list|)
block|{
name|symbolS
modifier|*
name|add
init|=
name|NULL
decl_stmt|;
name|symbolS
modifier|*
name|sub
init|=
name|NULL
decl_stmt|;
name|offsetT
name|off
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|exp
operator|->
name|X_op
condition|)
block|{
case|case
name|O_absent
case|:
break|break;
case|case
name|O_register
case|:
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"register value used as expression"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|O_add
case|:
comment|/* This comes up when _GLOBAL_OFFSET_TABLE_+(.-L0) is read, if 	 the difference expression cannot immediately be reduced.  */
block|{
name|symbolS
modifier|*
name|stmp
init|=
name|make_expr_symbol
argument_list|(
name|exp
argument_list|)
decl_stmt|;
name|exp
operator|->
name|X_op
operator|=
name|O_symbol
expr_stmt|;
name|exp
operator|->
name|X_op_symbol
operator|=
literal|0
expr_stmt|;
name|exp
operator|->
name|X_add_symbol
operator|=
name|stmp
expr_stmt|;
name|exp
operator|->
name|X_add_number
operator|=
literal|0
expr_stmt|;
return|return
name|fix_new_exp
argument_list|(
name|frag
argument_list|,
name|where
argument_list|,
name|size
argument_list|,
name|exp
argument_list|,
name|pcrel
argument_list|,
name|r_type
argument_list|)
return|;
block|}
case|case
name|O_symbol_rva
case|:
name|add
operator|=
name|exp
operator|->
name|X_add_symbol
expr_stmt|;
name|off
operator|=
name|exp
operator|->
name|X_add_number
expr_stmt|;
name|r_type
operator|=
name|BFD_RELOC_RVA
expr_stmt|;
break|break;
case|case
name|O_uminus
case|:
name|sub
operator|=
name|exp
operator|->
name|X_add_symbol
expr_stmt|;
name|off
operator|=
name|exp
operator|->
name|X_add_number
expr_stmt|;
break|break;
case|case
name|O_subtract
case|:
name|sub
operator|=
name|exp
operator|->
name|X_op_symbol
expr_stmt|;
comment|/* Fall through.  */
case|case
name|O_symbol
case|:
name|add
operator|=
name|exp
operator|->
name|X_add_symbol
expr_stmt|;
comment|/* Fall through.  */
case|case
name|O_constant
case|:
name|off
operator|=
name|exp
operator|->
name|X_add_number
expr_stmt|;
break|break;
default|default:
name|add
operator|=
name|make_expr_symbol
argument_list|(
name|exp
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|fix_new_internal
argument_list|(
name|frag
argument_list|,
name|where
argument_list|,
name|size
argument_list|,
name|add
argument_list|,
name|sub
argument_list|,
name|off
argument_list|,
name|pcrel
argument_list|,
name|r_type
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Generic function to determine whether a fixup requires a relocation.  */
end_comment

begin_function
name|int
name|generic_force_reloc
parameter_list|(
name|fixS
modifier|*
name|fix
parameter_list|)
block|{
if|if
condition|(
name|fix
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_VTABLE_INHERIT
operator|||
name|fix
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_VTABLE_ENTRY
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|fix
operator|->
name|fx_addsy
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
return|return
name|S_FORCE_RELOC
argument_list|(
name|fix
operator|->
name|fx_addsy
argument_list|,
name|fix
operator|->
name|fx_subsy
operator|==
name|NULL
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Append a string onto another string, bumping the pointer along.  */
end_comment

begin_function
name|void
name|append
parameter_list|(
name|char
modifier|*
modifier|*
name|charPP
parameter_list|,
name|char
modifier|*
name|fromP
parameter_list|,
name|unsigned
name|long
name|length
parameter_list|)
block|{
comment|/* Don't trust memcpy() of 0 chars.  */
if|if
condition|(
name|length
operator|==
literal|0
condition|)
return|return;
name|memcpy
argument_list|(
operator|*
name|charPP
argument_list|,
name|fromP
argument_list|,
name|length
argument_list|)
expr_stmt|;
operator|*
name|charPP
operator|+=
name|length
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This routine records the largest alignment seen for each segment.    If the beginning of the segment is aligned on the worst-case    boundary, all of the other alignments within it will work.  At    least one object format really uses this info.  */
end_comment

begin_function
name|void
name|record_alignment
parameter_list|(
comment|/* Segment to which alignment pertains.  */
name|segT
name|seg
parameter_list|,
comment|/* Alignment, as a power of 2 (e.g., 1 => 2-byte 		     boundary, 2 => 4-byte boundary, etc.)  */
name|int
name|align
parameter_list|)
block|{
if|if
condition|(
name|seg
operator|==
name|absolute_section
condition|)
return|return;
if|if
condition|(
operator|(
name|unsigned
name|int
operator|)
name|align
operator|>
name|bfd_get_section_alignment
argument_list|(
name|stdoutput
argument_list|,
name|seg
argument_list|)
condition|)
operator|(
name|void
operator|)
name|bfd_set_section_alignment
argument_list|(
name|stdoutput
argument_list|,
name|seg
argument_list|,
name|align
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|get_recorded_alignment
parameter_list|(
name|segT
name|seg
parameter_list|)
block|{
if|if
condition|(
name|seg
operator|==
name|absolute_section
condition|)
return|return
literal|0
return|;
return|return
name|bfd_get_section_alignment
argument_list|(
name|stdoutput
argument_list|,
name|seg
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Reset the section indices after removing the gas created sections.  */
end_comment

begin_function
specifier|static
name|void
name|renumber_sections
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|asection
modifier|*
name|sec
parameter_list|,
name|void
modifier|*
name|countparg
parameter_list|)
block|{
name|int
modifier|*
name|countp
init|=
operator|(
name|int
operator|*
operator|)
name|countparg
decl_stmt|;
name|sec
operator|->
name|index
operator|=
operator|*
name|countp
expr_stmt|;
operator|++
operator|*
name|countp
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|fragS
modifier|*
name|chain_frchains_together_1
parameter_list|(
name|segT
name|section
parameter_list|,
name|struct
name|frchain
modifier|*
name|frchp
parameter_list|)
block|{
name|fragS
name|dummy
decl_stmt|,
modifier|*
name|prev_frag
init|=
operator|&
name|dummy
decl_stmt|;
name|fixS
name|fix_dummy
decl_stmt|,
modifier|*
name|prev_fix
init|=
operator|&
name|fix_dummy
decl_stmt|;
for|for
control|(
init|;
name|frchp
condition|;
name|frchp
operator|=
name|frchp
operator|->
name|frch_next
control|)
block|{
name|prev_frag
operator|->
name|fr_next
operator|=
name|frchp
operator|->
name|frch_root
expr_stmt|;
name|prev_frag
operator|=
name|frchp
operator|->
name|frch_last
expr_stmt|;
name|assert
argument_list|(
name|prev_frag
operator|->
name|fr_type
operator|!=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|frchp
operator|->
name|fix_root
operator|!=
operator|(
name|fixS
operator|*
operator|)
name|NULL
condition|)
block|{
if|if
condition|(
name|seg_info
argument_list|(
name|section
argument_list|)
operator|->
name|fix_root
operator|==
operator|(
name|fixS
operator|*
operator|)
name|NULL
condition|)
name|seg_info
argument_list|(
name|section
argument_list|)
operator|->
name|fix_root
operator|=
name|frchp
operator|->
name|fix_root
expr_stmt|;
name|prev_fix
operator|->
name|fx_next
operator|=
name|frchp
operator|->
name|fix_root
expr_stmt|;
name|seg_info
argument_list|(
name|section
argument_list|)
operator|->
name|fix_tail
operator|=
name|frchp
operator|->
name|fix_tail
expr_stmt|;
name|prev_fix
operator|=
name|frchp
operator|->
name|fix_tail
expr_stmt|;
block|}
block|}
name|assert
argument_list|(
name|prev_frag
operator|->
name|fr_type
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|prev_frag
operator|!=
operator|&
name|dummy
argument_list|)
expr_stmt|;
name|prev_frag
operator|->
name|fr_next
operator|=
literal|0
expr_stmt|;
return|return
name|prev_frag
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|chain_frchains_together
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|segT
name|section
parameter_list|,
name|void
modifier|*
name|xxx
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|segment_info_type
modifier|*
name|info
decl_stmt|;
comment|/* BFD may have introduced its own sections without using      subseg_new, so it is possible that seg_info is NULL.  */
name|info
operator|=
name|seg_info
argument_list|(
name|section
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|!=
operator|(
name|segment_info_type
operator|*
operator|)
name|NULL
condition|)
name|info
operator|->
name|frchainP
operator|->
name|frch_last
operator|=
name|chain_frchains_together_1
argument_list|(
name|section
argument_list|,
name|info
operator|->
name|frchainP
argument_list|)
expr_stmt|;
comment|/* Now that we've chained the frags together, we must add new fixups      to the segment, not to the frag chain.  */
name|frags_chained
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|cvt_frag_to_fill
parameter_list|(
name|segT
name|sec
name|ATTRIBUTE_UNUSED
parameter_list|,
name|fragS
modifier|*
name|fragP
parameter_list|)
block|{
switch|switch
condition|(
name|fragP
operator|->
name|fr_type
condition|)
block|{
case|case
name|rs_align
case|:
case|case
name|rs_align_code
case|:
case|case
name|rs_align_test
case|:
case|case
name|rs_org
case|:
case|case
name|rs_space
case|:
ifdef|#
directive|ifdef
name|HANDLE_ALIGN
name|HANDLE_ALIGN
argument_list|(
name|fragP
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|know
argument_list|(
name|fragP
operator|->
name|fr_next
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|fragP
operator|->
name|fr_offset
operator|=
operator|(
name|fragP
operator|->
name|fr_next
operator|->
name|fr_address
operator|-
name|fragP
operator|->
name|fr_address
operator|-
name|fragP
operator|->
name|fr_fix
operator|)
operator|/
name|fragP
operator|->
name|fr_var
expr_stmt|;
if|if
condition|(
name|fragP
operator|->
name|fr_offset
operator|<
literal|0
condition|)
block|{
name|as_bad_where
argument_list|(
name|fragP
operator|->
name|fr_file
argument_list|,
name|fragP
operator|->
name|fr_line
argument_list|,
name|_
argument_list|(
literal|"attempt to .org/.space backwards? (%ld)"
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|fragP
operator|->
name|fr_offset
argument_list|)
expr_stmt|;
name|fragP
operator|->
name|fr_offset
operator|=
literal|0
expr_stmt|;
block|}
name|fragP
operator|->
name|fr_type
operator|=
name|rs_fill
expr_stmt|;
break|break;
case|case
name|rs_fill
case|:
break|break;
case|case
name|rs_leb128
case|:
block|{
name|valueT
name|value
init|=
name|S_GET_VALUE
argument_list|(
name|fragP
operator|->
name|fr_symbol
argument_list|)
decl_stmt|;
name|int
name|size
decl_stmt|;
name|size
operator|=
name|output_leb128
argument_list|(
name|fragP
operator|->
name|fr_literal
operator|+
name|fragP
operator|->
name|fr_fix
argument_list|,
name|value
argument_list|,
name|fragP
operator|->
name|fr_subtype
argument_list|)
expr_stmt|;
name|fragP
operator|->
name|fr_fix
operator|+=
name|size
expr_stmt|;
name|fragP
operator|->
name|fr_type
operator|=
name|rs_fill
expr_stmt|;
name|fragP
operator|->
name|fr_var
operator|=
literal|0
expr_stmt|;
name|fragP
operator|->
name|fr_offset
operator|=
literal|0
expr_stmt|;
name|fragP
operator|->
name|fr_symbol
operator|=
name|NULL
expr_stmt|;
block|}
break|break;
case|case
name|rs_cfa
case|:
name|eh_frame_convert_frag
argument_list|(
name|fragP
argument_list|)
expr_stmt|;
break|break;
case|case
name|rs_dwarf2dbg
case|:
name|dwarf2dbg_convert_frag
argument_list|(
name|fragP
argument_list|)
expr_stmt|;
break|break;
case|case
name|rs_machine_dependent
case|:
name|md_convert_frag
argument_list|(
name|stdoutput
argument_list|,
name|sec
argument_list|,
name|fragP
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|fragP
operator|->
name|fr_next
operator|==
name|NULL
operator|||
operator|(
call|(
name|offsetT
call|)
argument_list|(
name|fragP
operator|->
name|fr_next
operator|->
name|fr_address
operator|-
name|fragP
operator|->
name|fr_address
argument_list|)
operator|==
name|fragP
operator|->
name|fr_fix
operator|)
argument_list|)
expr_stmt|;
comment|/* After md_convert_frag, we make the frag into a ".space 0". 	 md_convert_frag() should set up any fixSs and constants 	 required.  */
name|frag_wane
argument_list|(
name|fragP
argument_list|)
expr_stmt|;
break|break;
ifndef|#
directive|ifndef
name|WORKING_DOT_WORD
case|case
name|rs_broken_word
case|:
block|{
name|struct
name|broken_word
modifier|*
name|lie
decl_stmt|;
if|if
condition|(
name|fragP
operator|->
name|fr_subtype
condition|)
block|{
name|fragP
operator|->
name|fr_fix
operator|+=
name|md_short_jump_size
expr_stmt|;
for|for
control|(
name|lie
operator|=
operator|(
expr|struct
name|broken_word
operator|*
operator|)
operator|(
name|fragP
operator|->
name|fr_symbol
operator|)
init|;
name|lie
operator|&&
name|lie
operator|->
name|dispfrag
operator|==
name|fragP
condition|;
name|lie
operator|=
name|lie
operator|->
name|next_broken_word
control|)
if|if
condition|(
name|lie
operator|->
name|added
operator|==
literal|1
condition|)
name|fragP
operator|->
name|fr_fix
operator|+=
name|md_long_jump_size
expr_stmt|;
block|}
name|frag_wane
argument_list|(
name|fragP
argument_list|)
expr_stmt|;
block|}
break|break;
endif|#
directive|endif
default|default:
name|BAD_CASE
argument_list|(
name|fragP
operator|->
name|fr_type
argument_list|)
expr_stmt|;
break|break;
block|}
ifdef|#
directive|ifdef
name|md_frag_check
name|md_frag_check
argument_list|(
name|fragP
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_struct
struct|struct
name|relax_seg_info
block|{
name|int
name|pass
decl_stmt|;
name|int
name|changed
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|void
name|relax_seg
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|asection
modifier|*
name|sec
parameter_list|,
name|void
modifier|*
name|xxx
parameter_list|)
block|{
name|segment_info_type
modifier|*
name|seginfo
init|=
name|seg_info
argument_list|(
name|sec
argument_list|)
decl_stmt|;
name|struct
name|relax_seg_info
modifier|*
name|info
init|=
operator|(
expr|struct
name|relax_seg_info
operator|*
operator|)
name|xxx
decl_stmt|;
if|if
condition|(
name|seginfo
operator|&&
name|seginfo
operator|->
name|frchainP
operator|&&
name|relax_segment
argument_list|(
name|seginfo
operator|->
name|frchainP
operator|->
name|frch_root
argument_list|,
name|sec
argument_list|,
name|info
operator|->
name|pass
argument_list|)
condition|)
name|info
operator|->
name|changed
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|size_seg
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|asection
modifier|*
name|sec
parameter_list|,
name|void
modifier|*
name|xxx
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|flagword
name|flags
decl_stmt|;
name|fragS
modifier|*
name|fragp
decl_stmt|;
name|segment_info_type
modifier|*
name|seginfo
decl_stmt|;
name|int
name|x
decl_stmt|;
name|valueT
name|size
decl_stmt|,
name|newsize
decl_stmt|;
name|subseg_change
argument_list|(
name|sec
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|seginfo
operator|=
name|seg_info
argument_list|(
name|sec
argument_list|)
expr_stmt|;
if|if
condition|(
name|seginfo
operator|&&
name|seginfo
operator|->
name|frchainP
condition|)
block|{
for|for
control|(
name|fragp
operator|=
name|seginfo
operator|->
name|frchainP
operator|->
name|frch_root
init|;
name|fragp
condition|;
name|fragp
operator|=
name|fragp
operator|->
name|fr_next
control|)
name|cvt_frag_to_fill
argument_list|(
name|sec
argument_list|,
name|fragp
argument_list|)
expr_stmt|;
for|for
control|(
name|fragp
operator|=
name|seginfo
operator|->
name|frchainP
operator|->
name|frch_root
init|;
name|fragp
operator|->
name|fr_next
condition|;
name|fragp
operator|=
name|fragp
operator|->
name|fr_next
control|)
comment|/* Walk to last elt.  */
empty_stmt|;
name|size
operator|=
name|fragp
operator|->
name|fr_address
operator|+
name|fragp
operator|->
name|fr_fix
expr_stmt|;
block|}
else|else
name|size
operator|=
literal|0
expr_stmt|;
name|flags
operator|=
name|bfd_get_section_flags
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|>
literal|0
operator|&&
operator|!
name|seginfo
operator|->
name|bss
condition|)
name|flags
operator||=
name|SEC_HAS_CONTENTS
expr_stmt|;
name|flags
operator|&=
operator|~
name|SEC_RELOC
expr_stmt|;
name|x
operator|=
name|bfd_set_section_flags
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|newsize
operator|=
name|md_section_align
argument_list|(
name|sec
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|x
operator|=
name|bfd_set_section_size
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|newsize
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|x
argument_list|)
expr_stmt|;
comment|/* If the size had to be rounded up, add some padding in the last      non-empty frag.  */
name|assert
argument_list|(
name|newsize
operator|>=
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|!=
name|newsize
condition|)
block|{
name|fragS
modifier|*
name|last
init|=
name|seginfo
operator|->
name|frchainP
operator|->
name|frch_last
decl_stmt|;
name|fragp
operator|=
name|seginfo
operator|->
name|frchainP
operator|->
name|frch_root
expr_stmt|;
while|while
condition|(
name|fragp
operator|->
name|fr_next
operator|!=
name|last
condition|)
name|fragp
operator|=
name|fragp
operator|->
name|fr_next
expr_stmt|;
name|last
operator|->
name|fr_address
operator|=
name|size
expr_stmt|;
if|if
condition|(
operator|(
name|newsize
operator|-
name|size
operator|)
operator|%
name|fragp
operator|->
name|fr_var
operator|==
literal|0
condition|)
name|fragp
operator|->
name|fr_offset
operator|+=
operator|(
name|newsize
operator|-
name|size
operator|)
operator|/
name|fragp
operator|->
name|fr_var
expr_stmt|;
else|else
comment|/* If we hit this abort, it's likely due to subsegs_finish not 	   providing sufficient alignment on the last frag, and the 	   machine dependent code using alignment frags with fr_var 	   greater than 1.  */
name|abort
argument_list|()
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|tc_frob_section
name|tc_frob_section
argument_list|(
name|sec
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|obj_frob_section
name|obj_frob_section
argument_list|(
name|sec
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG2
end_ifdef

begin_function
specifier|static
name|void
name|dump_section_relocs
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|asection
modifier|*
name|sec
parameter_list|,
name|FILE
modifier|*
name|stream
parameter_list|)
block|{
name|segment_info_type
modifier|*
name|seginfo
init|=
name|seg_info
argument_list|(
name|sec
argument_list|)
decl_stmt|;
name|fixS
modifier|*
name|fixp
init|=
name|seginfo
operator|->
name|fix_root
decl_stmt|;
if|if
condition|(
operator|!
name|fixp
condition|)
return|return;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"sec %s relocs:\n"
argument_list|,
name|sec
operator|->
name|name
argument_list|)
expr_stmt|;
while|while
condition|(
name|fixp
condition|)
block|{
name|symbolS
modifier|*
name|s
init|=
name|fixp
operator|->
name|fx_addsy
decl_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"  %08lx: type %d "
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|fixp
argument_list|,
operator|(
name|int
operator|)
name|fixp
operator|->
name|fx_r_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"no sym\n"
argument_list|)
expr_stmt|;
else|else
block|{
name|print_symbol_value_1
argument_list|(
name|stream
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|fixp
operator|=
name|fixp
operator|->
name|fx_next
expr_stmt|;
block|}
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|dump_section_relocs
parameter_list|(
name|ABFD
parameter_list|,
name|SEC
parameter_list|,
name|STREAM
parameter_list|)
value|((void) 0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|EMIT_SECTION_SYMBOLS
end_ifndef

begin_define
define|#
directive|define
name|EMIT_SECTION_SYMBOLS
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Resolve U.A.OFFSET_SYM and U.A.SYM fields of RELOC_LIST entries,    and check for validity.  Convert RELOC_LIST from using U.A fields    to U.B fields.  */
end_comment

begin_function
specifier|static
name|void
name|resolve_reloc_expr_symbols
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|reloc_list
modifier|*
name|r
decl_stmt|;
for|for
control|(
name|r
operator|=
name|reloc_list
init|;
name|r
condition|;
name|r
operator|=
name|r
operator|->
name|next
control|)
block|{
name|expressionS
modifier|*
name|symval
decl_stmt|;
name|symbolS
modifier|*
name|sym
decl_stmt|;
name|bfd_vma
name|offset
decl_stmt|,
name|addend
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|reloc_howto_type
modifier|*
name|howto
decl_stmt|;
name|resolve_symbol_value
argument_list|(
name|r
operator|->
name|u
operator|.
name|a
operator|.
name|offset_sym
argument_list|)
expr_stmt|;
name|symval
operator|=
name|symbol_get_value_expression
argument_list|(
name|r
operator|->
name|u
operator|.
name|a
operator|.
name|offset_sym
argument_list|)
expr_stmt|;
name|offset
operator|=
literal|0
expr_stmt|;
name|sym
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|symval
operator|->
name|X_op
operator|==
name|O_constant
condition|)
name|sym
operator|=
name|r
operator|->
name|u
operator|.
name|a
operator|.
name|offset_sym
expr_stmt|;
elseif|else
if|if
condition|(
name|symval
operator|->
name|X_op
operator|==
name|O_symbol
condition|)
block|{
name|sym
operator|=
name|symval
operator|->
name|X_add_symbol
expr_stmt|;
name|offset
operator|=
name|symval
operator|->
name|X_add_number
expr_stmt|;
name|symval
operator|=
name|symbol_get_value_expression
argument_list|(
name|symval
operator|->
name|X_add_symbol
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sym
operator|==
name|NULL
operator|||
name|symval
operator|->
name|X_op
operator|!=
name|O_constant
operator|||
operator|(
name|sec
operator|=
name|S_GET_SEGMENT
argument_list|(
name|sym
argument_list|)
operator|)
operator|==
name|NULL
operator|||
operator|!
name|SEG_NORMAL
argument_list|(
name|sec
argument_list|)
condition|)
block|{
name|as_bad_where
argument_list|(
name|r
operator|->
name|file
argument_list|,
name|r
operator|->
name|line
argument_list|,
name|_
argument_list|(
literal|"invalid offset expression"
argument_list|)
argument_list|)
expr_stmt|;
name|sec
operator|=
name|NULL
expr_stmt|;
block|}
else|else
name|offset
operator|+=
name|S_GET_VALUE
argument_list|(
name|sym
argument_list|)
expr_stmt|;
name|sym
operator|=
name|NULL
expr_stmt|;
name|addend
operator|=
name|r
operator|->
name|u
operator|.
name|a
operator|.
name|addend
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|u
operator|.
name|a
operator|.
name|sym
operator|!=
name|NULL
condition|)
block|{
name|resolve_symbol_value
argument_list|(
name|r
operator|->
name|u
operator|.
name|a
operator|.
name|sym
argument_list|)
expr_stmt|;
name|symval
operator|=
name|symbol_get_value_expression
argument_list|(
name|r
operator|->
name|u
operator|.
name|a
operator|.
name|sym
argument_list|)
expr_stmt|;
if|if
condition|(
name|symval
operator|->
name|X_op
operator|==
name|O_constant
condition|)
name|sym
operator|=
name|r
operator|->
name|u
operator|.
name|a
operator|.
name|sym
expr_stmt|;
elseif|else
if|if
condition|(
name|symval
operator|->
name|X_op
operator|==
name|O_symbol
condition|)
block|{
name|sym
operator|=
name|symval
operator|->
name|X_add_symbol
expr_stmt|;
name|addend
operator|+=
name|symval
operator|->
name|X_add_number
expr_stmt|;
name|symval
operator|=
name|symbol_get_value_expression
argument_list|(
name|symval
operator|->
name|X_add_symbol
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|symval
operator|->
name|X_op
operator|!=
name|O_constant
condition|)
block|{
name|as_bad_where
argument_list|(
name|r
operator|->
name|file
argument_list|,
name|r
operator|->
name|line
argument_list|,
name|_
argument_list|(
literal|"invalid reloc expression"
argument_list|)
argument_list|)
expr_stmt|;
name|sec
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sym
operator|!=
name|NULL
condition|)
name|symbol_mark_used_in_reloc
argument_list|(
name|sym
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sym
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|abs_section_sym
operator|==
name|NULL
condition|)
name|abs_section_sym
operator|=
name|section_symbol
argument_list|(
name|absolute_section
argument_list|)
expr_stmt|;
name|sym
operator|=
name|abs_section_sym
expr_stmt|;
block|}
name|howto
operator|=
name|r
operator|->
name|u
operator|.
name|a
operator|.
name|howto
expr_stmt|;
name|r
operator|->
name|u
operator|.
name|b
operator|.
name|sec
operator|=
name|sec
expr_stmt|;
name|r
operator|->
name|u
operator|.
name|b
operator|.
name|s
operator|=
name|symbol_get_bfdsym
argument_list|(
name|sym
argument_list|)
expr_stmt|;
name|r
operator|->
name|u
operator|.
name|b
operator|.
name|r
operator|.
name|sym_ptr_ptr
operator|=
operator|&
name|r
operator|->
name|u
operator|.
name|b
operator|.
name|s
expr_stmt|;
name|r
operator|->
name|u
operator|.
name|b
operator|.
name|r
operator|.
name|address
operator|=
name|offset
expr_stmt|;
name|r
operator|->
name|u
operator|.
name|b
operator|.
name|r
operator|.
name|addend
operator|=
name|addend
expr_stmt|;
name|r
operator|->
name|u
operator|.
name|b
operator|.
name|r
operator|.
name|howto
operator|=
name|howto
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* This pass over fixups decides whether symbols can be replaced with    section symbols.  */
end_comment

begin_function
specifier|static
name|void
name|adjust_reloc_syms
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|asection
modifier|*
name|sec
parameter_list|,
name|void
modifier|*
name|xxx
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|segment_info_type
modifier|*
name|seginfo
init|=
name|seg_info
argument_list|(
name|sec
argument_list|)
decl_stmt|;
name|fixS
modifier|*
name|fixp
decl_stmt|;
if|if
condition|(
name|seginfo
operator|==
name|NULL
condition|)
return|return;
name|dump_section_relocs
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
for|for
control|(
name|fixp
operator|=
name|seginfo
operator|->
name|fix_root
init|;
name|fixp
condition|;
name|fixp
operator|=
name|fixp
operator|->
name|fx_next
control|)
if|if
condition|(
name|fixp
operator|->
name|fx_done
condition|)
comment|/* Ignore it.  */
empty_stmt|;
elseif|else
if|if
condition|(
name|fixp
operator|->
name|fx_addsy
condition|)
block|{
name|symbolS
modifier|*
name|sym
decl_stmt|;
name|asection
modifier|*
name|symsec
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG5
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n\nadjusting fixup:\n"
argument_list|)
expr_stmt|;
name|print_fixup
argument_list|(
name|fixp
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sym
operator|=
name|fixp
operator|->
name|fx_addsy
expr_stmt|;
comment|/* All symbols should have already been resolved at this 	   point.  It is possible to see unresolved expression 	   symbols, though, since they are not in the regular symbol 	   table.  */
name|resolve_symbol_value
argument_list|(
name|sym
argument_list|)
expr_stmt|;
if|if
condition|(
name|fixp
operator|->
name|fx_subsy
operator|!=
name|NULL
condition|)
name|resolve_symbol_value
argument_list|(
name|fixp
operator|->
name|fx_subsy
argument_list|)
expr_stmt|;
comment|/* If this symbol is equated to an undefined or common symbol, 	   convert the fixup to being against that symbol.  */
while|while
condition|(
name|symbol_equated_reloc_p
argument_list|(
name|sym
argument_list|)
operator|||
name|S_IS_WEAKREFR
argument_list|(
name|sym
argument_list|)
condition|)
block|{
name|symbolS
modifier|*
name|newsym
init|=
name|symbol_get_value_expression
argument_list|(
name|sym
argument_list|)
operator|->
name|X_add_symbol
decl_stmt|;
if|if
condition|(
name|sym
operator|==
name|newsym
condition|)
break|break;
name|fixp
operator|->
name|fx_offset
operator|+=
name|symbol_get_value_expression
argument_list|(
name|sym
argument_list|)
operator|->
name|X_add_number
expr_stmt|;
name|fixp
operator|->
name|fx_addsy
operator|=
name|newsym
expr_stmt|;
name|sym
operator|=
name|newsym
expr_stmt|;
block|}
if|if
condition|(
name|symbol_mri_common_p
argument_list|(
name|sym
argument_list|)
condition|)
block|{
name|fixp
operator|->
name|fx_offset
operator|+=
name|S_GET_VALUE
argument_list|(
name|sym
argument_list|)
expr_stmt|;
name|fixp
operator|->
name|fx_addsy
operator|=
name|symbol_get_value_expression
argument_list|(
name|sym
argument_list|)
operator|->
name|X_add_symbol
expr_stmt|;
continue|continue;
block|}
comment|/* If the symbol is undefined, common, weak, or global (ELF 	   shared libs), we can't replace it with the section symbol.  */
if|if
condition|(
name|S_FORCE_RELOC
argument_list|(
name|fixp
operator|->
name|fx_addsy
argument_list|,
literal|1
argument_list|)
condition|)
continue|continue;
comment|/* Is there some other (target cpu dependent) reason we can't adjust 	   this one?  (E.g. relocations involving function addresses on 	   the PA.  */
ifdef|#
directive|ifdef
name|tc_fix_adjustable
if|if
condition|(
operator|!
name|tc_fix_adjustable
argument_list|(
name|fixp
argument_list|)
condition|)
continue|continue;
endif|#
directive|endif
comment|/* Since we're reducing to section symbols, don't attempt to reduce 	   anything that's already using one.  */
if|if
condition|(
name|symbol_section_p
argument_list|(
name|sym
argument_list|)
condition|)
continue|continue;
name|symsec
operator|=
name|S_GET_SEGMENT
argument_list|(
name|sym
argument_list|)
expr_stmt|;
if|if
condition|(
name|symsec
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|bfd_is_abs_section
argument_list|(
name|symsec
argument_list|)
condition|)
block|{
comment|/* The fixup_segment routine normally will not use this 	       symbol in a relocation.  */
continue|continue;
block|}
comment|/* Don't try to reduce relocs which refer to non-local symbols 	   in .linkonce sections.  It can lead to confusion when a 	   debugging section refers to a .linkonce section.  I hope 	   this will always be correct.  */
if|if
condition|(
name|symsec
operator|!=
name|sec
operator|&&
operator|!
name|S_IS_LOCAL
argument_list|(
name|sym
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|symsec
operator|->
name|flags
operator|&
name|SEC_LINK_ONCE
operator|)
operator|!=
literal|0
operator|||
operator|(
name|IS_ELF
comment|/* The GNU toolchain uses an extension for ELF: a 		       section beginning with the magic string 		       .gnu.linkonce is a linkonce section.  */
operator|&&
name|strncmp
argument_list|(
name|segment_name
argument_list|(
name|symsec
argument_list|)
argument_list|,
literal|".gnu.linkonce"
argument_list|,
sizeof|sizeof
expr|".gnu.linkonce"
operator|-
literal|1
argument_list|)
operator|==
literal|0
operator|)
condition|)
continue|continue;
block|}
comment|/* Never adjust a reloc against local symbol in a merge section 	   with non-zero addend.  */
if|if
condition|(
operator|(
name|symsec
operator|->
name|flags
operator|&
name|SEC_MERGE
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|fixp
operator|->
name|fx_offset
operator|!=
literal|0
operator|||
name|fixp
operator|->
name|fx_subsy
operator|!=
name|NULL
operator|)
condition|)
continue|continue;
comment|/* Never adjust a reloc against TLS local symbol.  */
if|if
condition|(
operator|(
name|symsec
operator|->
name|flags
operator|&
name|SEC_THREAD_LOCAL
operator|)
operator|!=
literal|0
condition|)
continue|continue;
comment|/* We refetch the segment when calling section_symbol, rather 	   than using symsec, because S_GET_VALUE may wind up changing 	   the section when it calls resolve_symbol_value.  */
name|fixp
operator|->
name|fx_offset
operator|+=
name|S_GET_VALUE
argument_list|(
name|sym
argument_list|)
expr_stmt|;
name|fixp
operator|->
name|fx_addsy
operator|=
name|section_symbol
argument_list|(
name|S_GET_SEGMENT
argument_list|(
name|sym
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG5
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\nadjusted fixup:\n"
argument_list|)
expr_stmt|;
name|print_fixup
argument_list|(
name|fixp
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|dump_section_relocs
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* fixup_segment()     Go through all the fixS's in a segment and see which ones can be    handled now.  (These consist of fixS where we have since discovered    the value of a symbol, or the address of the frag involved.)    For each one, call md_apply_fix to put the fix into the frag data.     Result is a count of how many relocation structs will be needed to    handle the remaining fixS's that we couldn't completely handle here.    These will be output later by emit_relocations().  */
end_comment

begin_function
specifier|static
name|long
name|fixup_segment
parameter_list|(
name|fixS
modifier|*
name|fixP
parameter_list|,
name|segT
name|this_segment
parameter_list|)
block|{
name|long
name|seg_reloc_count
init|=
literal|0
decl_stmt|;
name|valueT
name|add_number
decl_stmt|;
name|fragS
modifier|*
name|fragP
decl_stmt|;
name|segT
name|add_symbol_segment
init|=
name|absolute_section
decl_stmt|;
if|if
condition|(
name|fixP
operator|!=
name|NULL
operator|&&
name|abs_section_sym
operator|==
name|NULL
condition|)
name|abs_section_sym
operator|=
name|section_symbol
argument_list|(
name|absolute_section
argument_list|)
expr_stmt|;
comment|/* If the linker is doing the relaxing, we must not do any fixups.       Well, strictly speaking that's not true -- we could do any that      are PC-relative and don't cross regions that could change size.      And for the i960 we might be able to turn callx/callj into bal      anyways in cases where we know the maximum displacement.  */
if|if
condition|(
name|linkrelax
operator|&&
name|TC_LINKRELAX_FIXUP
argument_list|(
name|this_segment
argument_list|)
condition|)
block|{
for|for
control|(
init|;
name|fixP
condition|;
name|fixP
operator|=
name|fixP
operator|->
name|fx_next
control|)
if|if
condition|(
operator|!
name|fixP
operator|->
name|fx_done
condition|)
block|{
if|if
condition|(
name|fixP
operator|->
name|fx_addsy
operator|==
name|NULL
condition|)
block|{
comment|/* There was no symbol required by this relocation. 		   However, BFD doesn't really handle relocations 		   without symbols well. So fake up a local symbol in 		   the absolute section.  */
name|fixP
operator|->
name|fx_addsy
operator|=
name|abs_section_sym
expr_stmt|;
block|}
name|symbol_mark_used_in_reloc
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
expr_stmt|;
if|if
condition|(
name|fixP
operator|->
name|fx_subsy
operator|!=
name|NULL
condition|)
name|symbol_mark_used_in_reloc
argument_list|(
name|fixP
operator|->
name|fx_subsy
argument_list|)
expr_stmt|;
name|seg_reloc_count
operator|++
expr_stmt|;
block|}
name|TC_ADJUST_RELOC_COUNT
argument_list|(
name|fixP
argument_list|,
name|seg_reloc_count
argument_list|)
expr_stmt|;
return|return
name|seg_reloc_count
return|;
block|}
for|for
control|(
init|;
name|fixP
condition|;
name|fixP
operator|=
name|fixP
operator|->
name|fx_next
control|)
block|{
ifdef|#
directive|ifdef
name|DEBUG5
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\nprocessing fixup:\n"
argument_list|)
expr_stmt|;
name|print_fixup
argument_list|(
name|fixP
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|fragP
operator|=
name|fixP
operator|->
name|fx_frag
expr_stmt|;
name|know
argument_list|(
name|fragP
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TC_VALIDATE_FIX
name|TC_VALIDATE_FIX
argument_list|(
name|fixP
argument_list|,
name|this_segment
argument_list|,
name|skip
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|add_number
operator|=
name|fixP
operator|->
name|fx_offset
expr_stmt|;
if|if
condition|(
name|fixP
operator|->
name|fx_addsy
operator|!=
name|NULL
condition|)
name|add_symbol_segment
operator|=
name|S_GET_SEGMENT
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
expr_stmt|;
if|if
condition|(
name|fixP
operator|->
name|fx_subsy
operator|!=
name|NULL
condition|)
block|{
name|segT
name|sub_symbol_segment
decl_stmt|;
name|resolve_symbol_value
argument_list|(
name|fixP
operator|->
name|fx_subsy
argument_list|)
expr_stmt|;
name|sub_symbol_segment
operator|=
name|S_GET_SEGMENT
argument_list|(
name|fixP
operator|->
name|fx_subsy
argument_list|)
expr_stmt|;
if|if
condition|(
name|fixP
operator|->
name|fx_addsy
operator|!=
name|NULL
operator|&&
name|sub_symbol_segment
operator|==
name|add_symbol_segment
operator|&&
operator|!
name|TC_FORCE_RELOCATION_SUB_SAME
argument_list|(
name|fixP
argument_list|,
name|add_symbol_segment
argument_list|)
condition|)
block|{
name|add_number
operator|+=
name|S_GET_VALUE
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
expr_stmt|;
name|add_number
operator|-=
name|S_GET_VALUE
argument_list|(
name|fixP
operator|->
name|fx_subsy
argument_list|)
expr_stmt|;
name|fixP
operator|->
name|fx_offset
operator|=
name|add_number
expr_stmt|;
name|fixP
operator|->
name|fx_addsy
operator|=
name|NULL
expr_stmt|;
name|fixP
operator|->
name|fx_subsy
operator|=
name|NULL
expr_stmt|;
ifdef|#
directive|ifdef
name|TC_M68K
comment|/* See the comment below about 68k weirdness.  */
name|fixP
operator|->
name|fx_pcrel
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|sub_symbol_segment
operator|==
name|absolute_section
operator|&&
operator|!
name|TC_FORCE_RELOCATION_SUB_ABS
argument_list|(
name|fixP
argument_list|)
condition|)
block|{
name|add_number
operator|-=
name|S_GET_VALUE
argument_list|(
name|fixP
operator|->
name|fx_subsy
argument_list|)
expr_stmt|;
name|fixP
operator|->
name|fx_offset
operator|=
name|add_number
expr_stmt|;
name|fixP
operator|->
name|fx_subsy
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sub_symbol_segment
operator|==
name|this_segment
operator|&&
operator|!
name|TC_FORCE_RELOCATION_SUB_LOCAL
argument_list|(
name|fixP
argument_list|)
condition|)
block|{
name|add_number
operator|-=
name|S_GET_VALUE
argument_list|(
name|fixP
operator|->
name|fx_subsy
argument_list|)
expr_stmt|;
name|fixP
operator|->
name|fx_offset
operator|=
operator|(
name|add_number
operator|+
name|fixP
operator|->
name|fx_dot_value
operator|+
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_address
operator|)
expr_stmt|;
comment|/* Make it pc-relative.  If the back-end code has not 		 selected a pc-relative reloc, cancel the adjustment 		 we do later on all pc-relative relocs.  */
if|if
condition|(
literal|0
ifdef|#
directive|ifdef
name|TC_M68K
comment|/* Do this for m68k even if it's already described 		     as pc-relative.  On the m68k, an operand of 		     "pc@(foo-.-2)" should address "foo" in a 		     pc-relative mode.  */
operator|||
literal|1
endif|#
directive|endif
operator|||
operator|!
name|fixP
operator|->
name|fx_pcrel
condition|)
name|add_number
operator|+=
name|MD_PCREL_FROM_SECTION
argument_list|(
name|fixP
argument_list|,
name|this_segment
argument_list|)
expr_stmt|;
name|fixP
operator|->
name|fx_subsy
operator|=
name|NULL
expr_stmt|;
name|fixP
operator|->
name|fx_pcrel
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|TC_VALIDATE_FIX_SUB
argument_list|(
name|fixP
argument_list|)
condition|)
block|{
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"can't resolve `%s' {%s section} - `%s' {%s section}"
argument_list|)
argument_list|,
name|fixP
operator|->
name|fx_addsy
condition|?
name|S_GET_NAME
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
else|:
literal|"0"
argument_list|,
name|segment_name
argument_list|(
name|add_symbol_segment
argument_list|)
argument_list|,
name|S_GET_NAME
argument_list|(
name|fixP
operator|->
name|fx_subsy
argument_list|)
argument_list|,
name|segment_name
argument_list|(
name|sub_symbol_segment
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|fixP
operator|->
name|fx_addsy
condition|)
block|{
if|if
condition|(
name|add_symbol_segment
operator|==
name|this_segment
operator|&&
operator|!
name|TC_FORCE_RELOCATION_LOCAL
argument_list|(
name|fixP
argument_list|)
condition|)
block|{
comment|/* This fixup was made when the symbol's segment was 		 SEG_UNKNOWN, but it is now in the local segment. 		 So we know how to do the address without relocation.  */
name|add_number
operator|+=
name|S_GET_VALUE
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
expr_stmt|;
name|fixP
operator|->
name|fx_offset
operator|=
name|add_number
expr_stmt|;
if|if
condition|(
name|fixP
operator|->
name|fx_pcrel
condition|)
name|add_number
operator|-=
name|MD_PCREL_FROM_SECTION
argument_list|(
name|fixP
argument_list|,
name|this_segment
argument_list|)
expr_stmt|;
name|fixP
operator|->
name|fx_addsy
operator|=
name|NULL
expr_stmt|;
name|fixP
operator|->
name|fx_pcrel
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|add_symbol_segment
operator|==
name|absolute_section
operator|&&
operator|!
name|TC_FORCE_RELOCATION_ABS
argument_list|(
name|fixP
argument_list|)
condition|)
block|{
name|add_number
operator|+=
name|S_GET_VALUE
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
expr_stmt|;
name|fixP
operator|->
name|fx_offset
operator|=
name|add_number
expr_stmt|;
name|fixP
operator|->
name|fx_addsy
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|add_symbol_segment
operator|!=
name|undefined_section
operator|&&
operator|!
name|bfd_is_com_section
argument_list|(
name|add_symbol_segment
argument_list|)
operator|&&
name|MD_APPLY_SYM_VALUE
argument_list|(
name|fixP
argument_list|)
condition|)
name|add_number
operator|+=
name|S_GET_VALUE
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fixP
operator|->
name|fx_pcrel
condition|)
block|{
name|add_number
operator|-=
name|MD_PCREL_FROM_SECTION
argument_list|(
name|fixP
argument_list|,
name|this_segment
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fixP
operator|->
name|fx_done
operator|&&
name|fixP
operator|->
name|fx_addsy
operator|==
name|NULL
condition|)
block|{
comment|/* There was no symbol required by this relocation. 		 However, BFD doesn't really handle relocations 		 without symbols well. So fake up a local symbol in 		 the absolute section.  */
name|fixP
operator|->
name|fx_addsy
operator|=
name|abs_section_sym
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|fixP
operator|->
name|fx_done
condition|)
name|md_apply_fix
argument_list|(
name|fixP
argument_list|,
operator|&
name|add_number
argument_list|,
name|this_segment
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fixP
operator|->
name|fx_done
condition|)
block|{
operator|++
name|seg_reloc_count
expr_stmt|;
if|if
condition|(
name|fixP
operator|->
name|fx_addsy
operator|==
name|NULL
condition|)
name|fixP
operator|->
name|fx_addsy
operator|=
name|abs_section_sym
expr_stmt|;
name|symbol_mark_used_in_reloc
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
expr_stmt|;
if|if
condition|(
name|fixP
operator|->
name|fx_subsy
operator|!=
name|NULL
condition|)
name|symbol_mark_used_in_reloc
argument_list|(
name|fixP
operator|->
name|fx_subsy
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|fixP
operator|->
name|fx_bit_fixP
operator|&&
operator|!
name|fixP
operator|->
name|fx_no_overflow
operator|&&
name|fixP
operator|->
name|fx_size
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|fixP
operator|->
name|fx_size
operator|<
sizeof|sizeof
argument_list|(
name|valueT
argument_list|)
condition|)
block|{
name|valueT
name|mask
decl_stmt|;
name|mask
operator|=
literal|0
expr_stmt|;
name|mask
operator|--
expr_stmt|;
comment|/* Set all bits to one.  */
name|mask
operator|<<=
name|fixP
operator|->
name|fx_size
operator|*
literal|8
operator|-
operator|(
name|fixP
operator|->
name|fx_signed
condition|?
literal|1
else|:
literal|0
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|add_number
operator|&
name|mask
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|add_number
operator|&
name|mask
operator|)
operator|!=
name|mask
condition|)
block|{
name|char
name|buf
index|[
literal|50
index|]
decl_stmt|,
name|buf2
index|[
literal|50
index|]
decl_stmt|;
name|sprint_value
argument_list|(
name|buf
argument_list|,
name|fragP
operator|->
name|fr_address
operator|+
name|fixP
operator|->
name|fx_where
argument_list|)
expr_stmt|;
if|if
condition|(
name|add_number
operator|>
literal|1000
condition|)
name|sprint_value
argument_list|(
name|buf2
argument_list|,
name|add_number
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|buf2
argument_list|,
literal|"%ld"
argument_list|,
operator|(
name|long
operator|)
name|add_number
argument_list|)
expr_stmt|;
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"value of %s too large for field of %d bytes at %s"
argument_list|)
argument_list|,
name|buf2
argument_list|,
name|fixP
operator|->
name|fx_size
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
comment|/* Generic error checking.  */
block|}
ifdef|#
directive|ifdef
name|WARN_SIGNED_OVERFLOW_WORD
comment|/* Warn if a .word value is too large when treated as a signed 	     number.  We already know it is not too negative.  This is to 	     catch over-large switches generated by gcc on the 68k.  */
if|if
condition|(
operator|!
name|flag_signed_overflow_ok
operator|&&
name|fixP
operator|->
name|fx_size
operator|==
literal|2
operator|&&
name|add_number
operator|>
literal|0x7fff
condition|)
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"signed .word overflow; switch may be too large; %ld at 0x%lx"
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|add_number
argument_list|,
call|(
name|long
call|)
argument_list|(
name|fragP
operator|->
name|fr_address
operator|+
name|fixP
operator|->
name|fx_where
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* Not a bit fix.  */
ifdef|#
directive|ifdef
name|TC_VALIDATE_FIX
name|skip
label|:
name|ATTRIBUTE_UNUSED_LABEL
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DEBUG5
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"result:\n"
argument_list|)
expr_stmt|;
name|print_fixup
argument_list|(
name|fixP
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* For each fixS in this segment.  */
name|TC_ADJUST_RELOC_COUNT
argument_list|(
name|fixP
argument_list|,
name|seg_reloc_count
argument_list|)
expr_stmt|;
return|return
name|seg_reloc_count
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|fix_segment
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|asection
modifier|*
name|sec
parameter_list|,
name|void
modifier|*
name|xxx
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|segment_info_type
modifier|*
name|seginfo
init|=
name|seg_info
argument_list|(
name|sec
argument_list|)
decl_stmt|;
name|fixup_segment
argument_list|(
name|seginfo
operator|->
name|fix_root
argument_list|,
name|sec
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|install_reloc
parameter_list|(
name|asection
modifier|*
name|sec
parameter_list|,
name|arelent
modifier|*
name|reloc
parameter_list|,
name|fragS
modifier|*
name|fragp
parameter_list|,
name|char
modifier|*
name|file
parameter_list|,
name|unsigned
name|int
name|line
parameter_list|)
block|{
name|char
modifier|*
name|err
decl_stmt|;
name|bfd_reloc_status_type
name|s
decl_stmt|;
name|s
operator|=
name|bfd_install_relocation
argument_list|(
name|stdoutput
argument_list|,
name|reloc
argument_list|,
name|fragp
operator|->
name|fr_literal
argument_list|,
name|fragp
operator|->
name|fr_address
argument_list|,
name|sec
argument_list|,
operator|&
name|err
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|s
condition|)
block|{
case|case
name|bfd_reloc_ok
case|:
break|break;
case|case
name|bfd_reloc_overflow
case|:
name|as_bad_where
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
name|_
argument_list|(
literal|"relocation overflow"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|bfd_reloc_outofrange
case|:
name|as_bad_where
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
name|_
argument_list|(
literal|"relocation out of range"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"%s:%u: bad return from bfd_install_relocation: %x"
argument_list|)
argument_list|,
name|file
argument_list|,
name|line
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|write_relocs
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|asection
modifier|*
name|sec
parameter_list|,
name|void
modifier|*
name|xxx
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|segment_info_type
modifier|*
name|seginfo
init|=
name|seg_info
argument_list|(
name|sec
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|unsigned
name|int
name|n
decl_stmt|;
name|struct
name|reloc_list
modifier|*
name|my_reloc_list
decl_stmt|,
modifier|*
modifier|*
name|rp
decl_stmt|,
modifier|*
name|r
decl_stmt|;
name|arelent
modifier|*
modifier|*
name|relocs
decl_stmt|;
name|fixS
modifier|*
name|fixp
decl_stmt|;
comment|/* If seginfo is NULL, we did not create this section; don't do      anything with it.  */
if|if
condition|(
name|seginfo
operator|==
name|NULL
condition|)
return|return;
name|n
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|fixp
operator|=
name|seginfo
operator|->
name|fix_root
init|;
name|fixp
condition|;
name|fixp
operator|=
name|fixp
operator|->
name|fx_next
control|)
if|if
condition|(
operator|!
name|fixp
operator|->
name|fx_done
condition|)
name|n
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|RELOC_EXPANSION_POSSIBLE
name|n
operator|*=
name|MAX_RELOC_EXPANSION
expr_stmt|;
endif|#
directive|endif
comment|/* Extract relocs for this section from reloc_list.  */
name|rp
operator|=
operator|&
name|reloc_list
expr_stmt|;
name|my_reloc_list
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
operator|(
name|r
operator|=
operator|*
name|rp
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|r
operator|->
name|u
operator|.
name|b
operator|.
name|sec
operator|==
name|sec
condition|)
block|{
operator|*
name|rp
operator|=
name|r
operator|->
name|next
expr_stmt|;
name|r
operator|->
name|next
operator|=
name|my_reloc_list
expr_stmt|;
name|my_reloc_list
operator|=
name|r
expr_stmt|;
name|n
operator|++
expr_stmt|;
block|}
else|else
name|rp
operator|=
operator|&
name|r
operator|->
name|next
expr_stmt|;
block|}
name|relocs
operator|=
name|xcalloc
argument_list|(
name|n
argument_list|,
sizeof|sizeof
argument_list|(
name|arelent
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|fixp
operator|=
name|seginfo
operator|->
name|fix_root
init|;
name|fixp
operator|!=
operator|(
name|fixS
operator|*
operator|)
name|NULL
condition|;
name|fixp
operator|=
name|fixp
operator|->
name|fx_next
control|)
block|{
name|int
name|j
decl_stmt|;
name|int
name|fx_size
decl_stmt|,
name|slack
decl_stmt|;
name|offsetT
name|loc
decl_stmt|;
if|if
condition|(
name|fixp
operator|->
name|fx_done
condition|)
continue|continue;
name|fx_size
operator|=
name|fixp
operator|->
name|fx_size
expr_stmt|;
name|slack
operator|=
name|TC_FX_SIZE_SLACK
argument_list|(
name|fixp
argument_list|)
expr_stmt|;
if|if
condition|(
name|slack
operator|>
literal|0
condition|)
name|fx_size
operator|=
name|fx_size
operator|>
name|slack
condition|?
name|fx_size
operator|-
name|slack
else|:
literal|0
expr_stmt|;
name|loc
operator|=
name|fixp
operator|->
name|fx_where
operator|+
name|fx_size
expr_stmt|;
if|if
condition|(
name|slack
operator|>=
literal|0
operator|&&
name|loc
operator|>
name|fixp
operator|->
name|fx_frag
operator|->
name|fr_fix
condition|)
name|as_bad_where
argument_list|(
name|fixp
operator|->
name|fx_file
argument_list|,
name|fixp
operator|->
name|fx_line
argument_list|,
name|_
argument_list|(
literal|"internal error: fixup not contained within frag"
argument_list|)
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|RELOC_EXPANSION_POSSIBLE
block|{
name|arelent
modifier|*
name|reloc
init|=
name|tc_gen_reloc
argument_list|(
name|sec
argument_list|,
name|fixp
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|reloc
condition|)
continue|continue;
name|relocs
index|[
name|i
operator|++
index|]
operator|=
name|reloc
expr_stmt|;
name|j
operator|=
literal|1
expr_stmt|;
block|}
else|#
directive|else
block|{
name|arelent
modifier|*
modifier|*
name|reloc
init|=
name|tc_gen_reloc
argument_list|(
name|sec
argument_list|,
name|fixp
argument_list|)
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|reloc
index|[
name|j
index|]
condition|;
name|j
operator|++
control|)
name|relocs
index|[
name|i
operator|++
index|]
operator|=
name|reloc
index|[
name|j
index|]
expr_stmt|;
block|}
endif|#
directive|endif
for|for
control|(
init|;
name|j
operator|!=
literal|0
condition|;
operator|--
name|j
control|)
name|install_reloc
argument_list|(
name|sec
argument_list|,
name|relocs
index|[
name|i
operator|-
name|j
index|]
argument_list|,
name|fixp
operator|->
name|fx_frag
argument_list|,
name|fixp
operator|->
name|fx_file
argument_list|,
name|fixp
operator|->
name|fx_line
argument_list|)
expr_stmt|;
block|}
name|n
operator|=
name|i
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG4
block|{
name|unsigned
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|nsyms
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|sympp
decl_stmt|;
name|sympp
operator|=
name|bfd_get_outsymbols
argument_list|(
name|stdoutput
argument_list|)
expr_stmt|;
name|nsyms
operator|=
name|bfd_get_symcount
argument_list|(
name|stdoutput
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
operator|(
operator|*
name|relocs
index|[
name|i
index|]
operator|->
name|sym_ptr_ptr
operator|)
operator|->
name|flags
operator|&
name|BSF_SECTION_SYM
operator|)
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|nsyms
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|sympp
index|[
name|j
index|]
operator|==
operator|*
name|relocs
index|[
name|i
index|]
operator|->
name|sym_ptr_ptr
condition|)
break|break;
if|if
condition|(
name|j
operator|==
name|nsyms
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
endif|#
directive|endif
for|for
control|(
name|r
operator|=
name|my_reloc_list
init|;
name|r
operator|!=
name|NULL
condition|;
name|r
operator|=
name|r
operator|->
name|next
control|)
block|{
name|fragS
modifier|*
name|f
decl_stmt|;
for|for
control|(
name|f
operator|=
name|seginfo
operator|->
name|frchainP
operator|->
name|frch_root
init|;
name|f
condition|;
name|f
operator|=
name|f
operator|->
name|fr_next
control|)
if|if
condition|(
name|f
operator|->
name|fr_address
operator|<=
name|r
operator|->
name|u
operator|.
name|b
operator|.
name|r
operator|.
name|address
operator|&&
name|r
operator|->
name|u
operator|.
name|b
operator|.
name|r
operator|.
name|address
operator|<
name|f
operator|->
name|fr_address
operator|+
name|f
operator|->
name|fr_fix
condition|)
break|break;
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
name|as_bad_where
argument_list|(
name|r
operator|->
name|file
argument_list|,
name|r
operator|->
name|line
argument_list|,
name|_
argument_list|(
literal|"reloc not within (fixed part of) section"
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|relocs
index|[
name|n
operator|++
index|]
operator|=
operator|&
name|r
operator|->
name|u
operator|.
name|b
operator|.
name|r
expr_stmt|;
name|install_reloc
argument_list|(
name|sec
argument_list|,
operator|&
name|r
operator|->
name|u
operator|.
name|b
operator|.
name|r
argument_list|,
name|f
argument_list|,
name|r
operator|->
name|file
argument_list|,
name|r
operator|->
name|line
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|n
condition|)
block|{
name|flagword
name|flags
init|=
name|bfd_get_section_flags
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
decl_stmt|;
name|flags
operator||=
name|SEC_RELOC
expr_stmt|;
name|bfd_set_section_flags
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|bfd_set_reloc
argument_list|(
name|stdoutput
argument_list|,
name|sec
argument_list|,
name|relocs
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|SET_SECTION_RELOCS
name|SET_SECTION_RELOCS
argument_list|(
name|sec
argument_list|,
name|relocs
argument_list|,
name|n
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DEBUG3
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|arelent
modifier|*
name|r
decl_stmt|;
name|asymbol
modifier|*
name|s
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"relocs for sec %s\n"
argument_list|,
name|sec
operator|->
name|name
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|r
operator|=
name|relocs
index|[
name|i
index|]
expr_stmt|;
name|s
operator|=
operator|*
name|r
operator|->
name|sym_ptr_ptr
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  reloc %2d @%p off %4lx : sym %-10s addend %lx\n"
argument_list|,
name|i
argument_list|,
name|r
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|r
operator|->
name|address
argument_list|,
name|s
operator|->
name|name
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|r
operator|->
name|addend
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|write_contents
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|asection
modifier|*
name|sec
parameter_list|,
name|void
modifier|*
name|xxx
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|segment_info_type
modifier|*
name|seginfo
init|=
name|seg_info
argument_list|(
name|sec
argument_list|)
decl_stmt|;
name|addressT
name|offset
init|=
literal|0
decl_stmt|;
name|fragS
modifier|*
name|f
decl_stmt|;
comment|/* Write out the frags.  */
if|if
condition|(
name|seginfo
operator|==
name|NULL
operator|||
operator|!
operator|(
name|bfd_get_section_flags
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
operator|&
name|SEC_HAS_CONTENTS
operator|)
condition|)
return|return;
for|for
control|(
name|f
operator|=
name|seginfo
operator|->
name|frchainP
operator|->
name|frch_root
init|;
name|f
condition|;
name|f
operator|=
name|f
operator|->
name|fr_next
control|)
block|{
name|int
name|x
decl_stmt|;
name|addressT
name|fill_size
decl_stmt|;
name|char
modifier|*
name|fill_literal
decl_stmt|;
name|offsetT
name|count
decl_stmt|;
name|assert
argument_list|(
name|f
operator|->
name|fr_type
operator|==
name|rs_fill
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|->
name|fr_fix
condition|)
block|{
name|x
operator|=
name|bfd_set_section_contents
argument_list|(
name|stdoutput
argument_list|,
name|sec
argument_list|,
name|f
operator|->
name|fr_literal
argument_list|,
operator|(
name|file_ptr
operator|)
name|offset
argument_list|,
operator|(
name|bfd_size_type
operator|)
name|f
operator|->
name|fr_fix
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|x
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"can't write %s: %s"
argument_list|)
argument_list|,
name|stdoutput
operator|->
name|filename
argument_list|,
name|bfd_errmsg
argument_list|(
name|bfd_get_error
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|f
operator|->
name|fr_fix
expr_stmt|;
block|}
name|fill_literal
operator|=
name|f
operator|->
name|fr_literal
operator|+
name|f
operator|->
name|fr_fix
expr_stmt|;
name|fill_size
operator|=
name|f
operator|->
name|fr_var
expr_stmt|;
name|count
operator|=
name|f
operator|->
name|fr_offset
expr_stmt|;
name|assert
argument_list|(
name|count
operator|>=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|fill_size
operator|&&
name|count
condition|)
block|{
name|char
name|buf
index|[
literal|256
index|]
decl_stmt|;
if|if
condition|(
name|fill_size
operator|>
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
condition|)
block|{
comment|/* Do it the old way. Can this ever happen?  */
while|while
condition|(
name|count
operator|--
condition|)
block|{
name|x
operator|=
name|bfd_set_section_contents
argument_list|(
name|stdoutput
argument_list|,
name|sec
argument_list|,
name|fill_literal
argument_list|,
operator|(
name|file_ptr
operator|)
name|offset
argument_list|,
operator|(
name|bfd_size_type
operator|)
name|fill_size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|x
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"can't write %s: %s"
argument_list|)
argument_list|,
name|stdoutput
operator|->
name|filename
argument_list|,
name|bfd_errmsg
argument_list|(
name|bfd_get_error
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|fill_size
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Build a buffer full of fill objects and output it as 		 often as necessary. This saves on the overhead of 		 potentially lots of bfd_set_section_contents calls.  */
name|int
name|n_per_buf
decl_stmt|,
name|i
decl_stmt|;
if|if
condition|(
name|fill_size
operator|==
literal|1
condition|)
block|{
name|n_per_buf
operator|=
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|buf
argument_list|,
operator|*
name|fill_literal
argument_list|,
name|n_per_buf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|char
modifier|*
name|bufp
decl_stmt|;
name|n_per_buf
operator|=
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
operator|/
name|fill_size
expr_stmt|;
for|for
control|(
name|i
operator|=
name|n_per_buf
operator|,
name|bufp
operator|=
name|buf
init|;
name|i
condition|;
name|i
operator|--
operator|,
name|bufp
operator|+=
name|fill_size
control|)
name|memcpy
argument_list|(
name|bufp
argument_list|,
name|fill_literal
argument_list|,
name|fill_size
argument_list|)
expr_stmt|;
block|}
for|for
control|(
init|;
name|count
operator|>
literal|0
condition|;
name|count
operator|-=
name|n_per_buf
control|)
block|{
name|n_per_buf
operator|=
name|n_per_buf
operator|>
name|count
condition|?
name|count
else|:
name|n_per_buf
expr_stmt|;
name|x
operator|=
name|bfd_set_section_contents
argument_list|(
name|stdoutput
argument_list|,
name|sec
argument_list|,
name|buf
argument_list|,
operator|(
name|file_ptr
operator|)
name|offset
argument_list|,
operator|(
name|bfd_size_type
operator|)
name|n_per_buf
operator|*
name|fill_size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|x
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"cannot write to output file"
argument_list|)
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|n_per_buf
operator|*
name|fill_size
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|merge_data_into_text
parameter_list|(
name|void
parameter_list|)
block|{
name|seg_info
argument_list|(
name|text_section
argument_list|)
operator|->
name|frchainP
operator|->
name|frch_last
operator|->
name|fr_next
operator|=
name|seg_info
argument_list|(
name|data_section
argument_list|)
operator|->
name|frchainP
operator|->
name|frch_root
expr_stmt|;
name|seg_info
argument_list|(
name|text_section
argument_list|)
operator|->
name|frchainP
operator|->
name|frch_last
operator|=
name|seg_info
argument_list|(
name|data_section
argument_list|)
operator|->
name|frchainP
operator|->
name|frch_last
expr_stmt|;
name|seg_info
argument_list|(
name|data_section
argument_list|)
operator|->
name|frchainP
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|set_symtab
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|nsyms
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|asympp
decl_stmt|;
name|symbolS
modifier|*
name|symp
decl_stmt|;
name|bfd_boolean
name|result
decl_stmt|;
comment|/* Count symbols.  We can't rely on a count made by the loop in      write_object_file, because *_frob_file may add a new symbol or      two.  */
name|nsyms
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|symp
operator|=
name|symbol_rootP
init|;
name|symp
condition|;
name|symp
operator|=
name|symbol_next
argument_list|(
name|symp
argument_list|)
control|)
name|nsyms
operator|++
expr_stmt|;
if|if
condition|(
name|nsyms
condition|)
block|{
name|int
name|i
decl_stmt|;
name|bfd_size_type
name|amt
init|=
operator|(
name|bfd_size_type
operator|)
name|nsyms
operator|*
sizeof|sizeof
argument_list|(
name|asymbol
operator|*
argument_list|)
decl_stmt|;
name|asympp
operator|=
name|bfd_alloc
argument_list|(
name|stdoutput
argument_list|,
name|amt
argument_list|)
expr_stmt|;
name|symp
operator|=
name|symbol_rootP
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nsyms
condition|;
name|i
operator|++
operator|,
name|symp
operator|=
name|symbol_next
argument_list|(
name|symp
argument_list|)
control|)
block|{
name|asympp
index|[
name|i
index|]
operator|=
name|symbol_get_bfdsym
argument_list|(
name|symp
argument_list|)
expr_stmt|;
name|symbol_mark_written
argument_list|(
name|symp
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|asympp
operator|=
literal|0
expr_stmt|;
name|result
operator|=
name|bfd_set_symtab
argument_list|(
name|stdoutput
argument_list|,
name|asympp
argument_list|,
name|nsyms
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|symbol_table_frozen
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Finish the subsegments.  After every sub-segment, we fake an    ".align ...".  This conforms to BSD4.2 brane-damage.  We then fake    ".fill 0" because that is the kind of frag that requires least    thought.  ".align" frags like to have a following frag since that    makes calculating their intended length trivial.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SUB_SEGMENT_ALIGN
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|HANDLE_ALIGN
end_ifdef

begin_comment
comment|/* The last subsegment gets an alignment corresponding to the alignment    of the section.  This allows proper nop-filling at the end of    code-bearing sections.  */
end_comment

begin_define
define|#
directive|define
name|SUB_SEGMENT_ALIGN
parameter_list|(
name|SEG
parameter_list|,
name|FRCHAIN
parameter_list|)
define|\
value|(!(FRCHAIN)->frch_next ? get_recorded_alignment (SEG) : 0)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|SUB_SEGMENT_ALIGN
parameter_list|(
name|SEG
parameter_list|,
name|FRCHAIN
parameter_list|)
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|subsegs_finish
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|frchain
modifier|*
name|frchainP
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
for|for
control|(
name|s
operator|=
name|stdoutput
operator|->
name|sections
init|;
name|s
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
block|{
name|segment_info_type
modifier|*
name|seginfo
init|=
name|seg_info
argument_list|(
name|s
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|seginfo
condition|)
continue|continue;
for|for
control|(
name|frchainP
operator|=
name|seginfo
operator|->
name|frchainP
init|;
name|frchainP
operator|!=
name|NULL
condition|;
name|frchainP
operator|=
name|frchainP
operator|->
name|frch_next
control|)
block|{
name|int
name|alignment
init|=
literal|0
decl_stmt|;
name|subseg_set
argument_list|(
name|s
argument_list|,
name|frchainP
operator|->
name|frch_subseg
argument_list|)
expr_stmt|;
comment|/* This now gets called even if we had errors.  In that case, 	     any alignment is meaningless, and, moreover, will look weird 	     if we are generating a listing.  */
if|if
condition|(
operator|!
name|had_errors
argument_list|()
condition|)
block|{
name|alignment
operator|=
name|SUB_SEGMENT_ALIGN
argument_list|(
name|now_seg
argument_list|,
name|frchainP
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|bfd_get_section_flags
argument_list|(
name|now_seg
operator|->
name|owner
argument_list|,
name|now_seg
argument_list|)
operator|&
name|SEC_MERGE
operator|)
operator|&&
name|now_seg
operator|->
name|entsize
condition|)
block|{
name|unsigned
name|int
name|entsize
init|=
name|now_seg
operator|->
name|entsize
decl_stmt|;
name|int
name|entalign
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|(
name|entsize
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
block|{
operator|++
name|entalign
expr_stmt|;
name|entsize
operator|>>=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|entalign
operator|>
name|alignment
condition|)
name|alignment
operator|=
name|entalign
expr_stmt|;
block|}
block|}
if|if
condition|(
name|subseg_text_p
argument_list|(
name|now_seg
argument_list|)
condition|)
name|frag_align_code
argument_list|(
name|alignment
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|frag_align
argument_list|(
name|alignment
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* frag_align will have left a new frag. 	     Use this last frag for an empty ".fill".  	     For this segment ... 	     Create a last frag. Do not leave a "being filled in frag".  */
name|frag_wane
argument_list|(
name|frag_now
argument_list|)
expr_stmt|;
name|frag_now
operator|->
name|fr_fix
operator|=
literal|0
expr_stmt|;
name|know
argument_list|(
name|frag_now
operator|->
name|fr_next
operator|==
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Write the object file.  */
end_comment

begin_function
name|void
name|write_object_file
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|relax_seg_info
name|rsi
decl_stmt|;
ifndef|#
directive|ifndef
name|WORKING_DOT_WORD
name|fragS
modifier|*
name|fragP
decl_stmt|;
comment|/* Track along all frags.  */
endif|#
directive|endif
comment|/* Do we really want to write it?  */
block|{
name|int
name|n_warns
decl_stmt|,
name|n_errs
decl_stmt|;
name|n_warns
operator|=
name|had_warnings
argument_list|()
expr_stmt|;
name|n_errs
operator|=
name|had_errors
argument_list|()
expr_stmt|;
comment|/* The -Z flag indicates that an object file should be generated,        regardless of warnings and errors.  */
if|if
condition|(
name|flag_always_generate_output
condition|)
block|{
if|if
condition|(
name|n_warns
operator|||
name|n_errs
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"%d error%s, %d warning%s, generating bad object file"
argument_list|)
argument_list|,
name|n_errs
argument_list|,
name|n_errs
operator|==
literal|1
condition|?
literal|""
else|:
literal|"s"
argument_list|,
name|n_warns
argument_list|,
name|n_warns
operator|==
literal|1
condition|?
literal|""
else|:
literal|"s"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|n_errs
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"%d error%s, %d warning%s, no object file generated"
argument_list|)
argument_list|,
name|n_errs
argument_list|,
name|n_errs
operator|==
literal|1
condition|?
literal|""
else|:
literal|"s"
argument_list|,
name|n_warns
argument_list|,
name|n_warns
operator|==
literal|1
condition|?
literal|""
else|:
literal|"s"
argument_list|)
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|OBJ_VMS
comment|/* Under VMS we try to be compatible with VAX-11 "C".  Thus, we call      a routine to check for the definition of the procedure "_main",      and if so -- fix it up so that it can be program entry point.  */
name|vms_check_for_main
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* OBJ_VMS  */
comment|/* From now on, we don't care about sub-segments.  Build one frag chain      for each segment. Linked thru fr_next.  */
comment|/* Remove the sections created by gas for its own purposes.  */
block|{
name|int
name|i
decl_stmt|;
name|bfd_section_list_remove
argument_list|(
name|stdoutput
argument_list|,
name|reg_section
argument_list|)
expr_stmt|;
name|bfd_section_list_remove
argument_list|(
name|stdoutput
argument_list|,
name|expr_section
argument_list|)
expr_stmt|;
name|stdoutput
operator|->
name|section_count
operator|-=
literal|2
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|bfd_map_over_sections
argument_list|(
name|stdoutput
argument_list|,
name|renumber_sections
argument_list|,
operator|&
name|i
argument_list|)
expr_stmt|;
block|}
name|bfd_map_over_sections
argument_list|(
name|stdoutput
argument_list|,
name|chain_frchains_together
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
comment|/* We have two segments. If user gave -R flag, then we must put the      data frags into the text segment. Do this before relaxing so      we know to take advantage of -R and make shorter addresses.  */
if|if
condition|(
name|flag_readonly_data_in_text
condition|)
block|{
name|merge_data_into_text
argument_list|()
expr_stmt|;
block|}
name|rsi
operator|.
name|pass
operator|=
literal|0
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
ifndef|#
directive|ifndef
name|WORKING_DOT_WORD
comment|/* We need to reset the markers in the broken word list and 	 associated frags between calls to relax_segment (via 	 relax_seg).  Since the broken word list is global, we do it 	 once per round, rather than locally in relax_segment for each 	 segment.  */
name|struct
name|broken_word
modifier|*
name|brokp
decl_stmt|;
for|for
control|(
name|brokp
operator|=
name|broken_words
init|;
name|brokp
operator|!=
operator|(
expr|struct
name|broken_word
operator|*
operator|)
name|NULL
condition|;
name|brokp
operator|=
name|brokp
operator|->
name|next_broken_word
control|)
block|{
name|brokp
operator|->
name|added
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|brokp
operator|->
name|dispfrag
operator|!=
operator|(
name|fragS
operator|*
operator|)
name|NULL
operator|&&
name|brokp
operator|->
name|dispfrag
operator|->
name|fr_type
operator|==
name|rs_broken_word
condition|)
name|brokp
operator|->
name|dispfrag
operator|->
name|fr_subtype
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
name|rsi
operator|.
name|changed
operator|=
literal|0
expr_stmt|;
name|bfd_map_over_sections
argument_list|(
name|stdoutput
argument_list|,
name|relax_seg
argument_list|,
operator|&
name|rsi
argument_list|)
expr_stmt|;
name|rsi
operator|.
name|pass
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|rsi
operator|.
name|changed
condition|)
break|break;
block|}
comment|/* Note - Most ports will use the default value of      TC_FINALIZE_SYMS_BEFORE_SIZE_SEG, which 1.  This will force      local symbols to be resolved, removing their frag information.      Some ports however, will not have finished relaxing all of      their frags and will still need the local symbol frag      information.  These ports can set      TC_FINALIZE_SYMS_BEFORE_SIZE_SEG to 0.  */
name|finalize_syms
operator|=
name|TC_FINALIZE_SYMS_BEFORE_SIZE_SEG
expr_stmt|;
name|bfd_map_over_sections
argument_list|(
name|stdoutput
argument_list|,
name|size_seg
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
comment|/* Relaxation has completed.  Freeze all syms.  */
name|finalize_syms
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|md_post_relax_hook
name|md_post_relax_hook
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|WORKING_DOT_WORD
block|{
name|struct
name|broken_word
modifier|*
name|lie
decl_stmt|;
name|struct
name|broken_word
modifier|*
modifier|*
name|prevP
decl_stmt|;
name|prevP
operator|=
operator|&
name|broken_words
expr_stmt|;
for|for
control|(
name|lie
operator|=
name|broken_words
init|;
name|lie
condition|;
name|lie
operator|=
name|lie
operator|->
name|next_broken_word
control|)
if|if
condition|(
operator|!
name|lie
operator|->
name|added
condition|)
block|{
name|expressionS
name|exp
decl_stmt|;
name|subseg_change
argument_list|(
name|lie
operator|->
name|seg
argument_list|,
name|lie
operator|->
name|subseg
argument_list|)
expr_stmt|;
name|exp
operator|.
name|X_op
operator|=
name|O_subtract
expr_stmt|;
name|exp
operator|.
name|X_add_symbol
operator|=
name|lie
operator|->
name|add
expr_stmt|;
name|exp
operator|.
name|X_op_symbol
operator|=
name|lie
operator|->
name|sub
expr_stmt|;
name|exp
operator|.
name|X_add_number
operator|=
name|lie
operator|->
name|addnum
expr_stmt|;
ifdef|#
directive|ifdef
name|TC_CONS_FIX_NEW
name|TC_CONS_FIX_NEW
argument_list|(
name|lie
operator|->
name|frag
argument_list|,
name|lie
operator|->
name|word_goes_here
operator|-
name|lie
operator|->
name|frag
operator|->
name|fr_literal
argument_list|,
literal|2
argument_list|,
operator|&
name|exp
argument_list|)
expr_stmt|;
else|#
directive|else
name|fix_new_exp
argument_list|(
name|lie
operator|->
name|frag
argument_list|,
name|lie
operator|->
name|word_goes_here
operator|-
name|lie
operator|->
name|frag
operator|->
name|fr_literal
argument_list|,
literal|2
argument_list|,
operator|&
name|exp
argument_list|,
literal|0
argument_list|,
name|BFD_RELOC_16
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|*
name|prevP
operator|=
name|lie
operator|->
name|next_broken_word
expr_stmt|;
block|}
else|else
name|prevP
operator|=
operator|&
operator|(
name|lie
operator|->
name|next_broken_word
operator|)
expr_stmt|;
for|for
control|(
name|lie
operator|=
name|broken_words
init|;
name|lie
condition|;
control|)
block|{
name|struct
name|broken_word
modifier|*
name|untruth
decl_stmt|;
name|char
modifier|*
name|table_ptr
decl_stmt|;
name|addressT
name|table_addr
decl_stmt|;
name|addressT
name|from_addr
decl_stmt|,
name|to_addr
decl_stmt|;
name|int
name|n
decl_stmt|,
name|m
decl_stmt|;
name|subseg_change
argument_list|(
name|lie
operator|->
name|seg
argument_list|,
name|lie
operator|->
name|subseg
argument_list|)
expr_stmt|;
name|fragP
operator|=
name|lie
operator|->
name|dispfrag
expr_stmt|;
comment|/* Find out how many broken_words go here.  */
name|n
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|untruth
operator|=
name|lie
init|;
name|untruth
operator|&&
name|untruth
operator|->
name|dispfrag
operator|==
name|fragP
condition|;
name|untruth
operator|=
name|untruth
operator|->
name|next_broken_word
control|)
if|if
condition|(
name|untruth
operator|->
name|added
operator|==
literal|1
condition|)
name|n
operator|++
expr_stmt|;
name|table_ptr
operator|=
name|lie
operator|->
name|dispfrag
operator|->
name|fr_opcode
expr_stmt|;
name|table_addr
operator|=
operator|(
name|lie
operator|->
name|dispfrag
operator|->
name|fr_address
operator|+
operator|(
name|table_ptr
operator|-
name|lie
operator|->
name|dispfrag
operator|->
name|fr_literal
operator|)
operator|)
expr_stmt|;
comment|/* Create the jump around the long jumps.  This is a short 	   jump from table_ptr+0 to table_ptr+n*long_jump_size.  */
name|from_addr
operator|=
name|table_addr
expr_stmt|;
name|to_addr
operator|=
name|table_addr
operator|+
name|md_short_jump_size
operator|+
name|n
operator|*
name|md_long_jump_size
expr_stmt|;
name|md_create_short_jump
argument_list|(
name|table_ptr
argument_list|,
name|from_addr
argument_list|,
name|to_addr
argument_list|,
name|lie
operator|->
name|dispfrag
argument_list|,
name|lie
operator|->
name|add
argument_list|)
expr_stmt|;
name|table_ptr
operator|+=
name|md_short_jump_size
expr_stmt|;
name|table_addr
operator|+=
name|md_short_jump_size
expr_stmt|;
for|for
control|(
name|m
operator|=
literal|0
init|;
name|lie
operator|&&
name|lie
operator|->
name|dispfrag
operator|==
name|fragP
condition|;
name|m
operator|++
operator|,
name|lie
operator|=
name|lie
operator|->
name|next_broken_word
control|)
block|{
if|if
condition|(
name|lie
operator|->
name|added
operator|==
literal|2
condition|)
continue|continue;
comment|/* Patch the jump table.  */
comment|/* This is the offset from ??? to table_ptr+0.  */
name|to_addr
operator|=
name|table_addr
operator|-
name|S_GET_VALUE
argument_list|(
name|lie
operator|->
name|sub
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TC_CHECK_ADJUSTED_BROKEN_DOT_WORD
name|TC_CHECK_ADJUSTED_BROKEN_DOT_WORD
argument_list|(
name|to_addr
argument_list|,
name|lie
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|md_number_to_chars
argument_list|(
name|lie
operator|->
name|word_goes_here
argument_list|,
name|to_addr
argument_list|,
literal|2
argument_list|)
expr_stmt|;
for|for
control|(
name|untruth
operator|=
name|lie
operator|->
name|next_broken_word
init|;
name|untruth
operator|&&
name|untruth
operator|->
name|dispfrag
operator|==
name|fragP
condition|;
name|untruth
operator|=
name|untruth
operator|->
name|next_broken_word
control|)
block|{
if|if
condition|(
name|untruth
operator|->
name|use_jump
operator|==
name|lie
condition|)
name|md_number_to_chars
argument_list|(
name|untruth
operator|->
name|word_goes_here
argument_list|,
name|to_addr
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
comment|/* Install the long jump.  */
comment|/* This is a long jump from table_ptr+0 to the final target.  */
name|from_addr
operator|=
name|table_addr
expr_stmt|;
name|to_addr
operator|=
name|S_GET_VALUE
argument_list|(
name|lie
operator|->
name|add
argument_list|)
operator|+
name|lie
operator|->
name|addnum
expr_stmt|;
name|md_create_long_jump
argument_list|(
name|table_ptr
argument_list|,
name|from_addr
argument_list|,
name|to_addr
argument_list|,
name|lie
operator|->
name|dispfrag
argument_list|,
name|lie
operator|->
name|add
argument_list|)
expr_stmt|;
name|table_ptr
operator|+=
name|md_long_jump_size
expr_stmt|;
name|table_addr
operator|+=
name|md_long_jump_size
expr_stmt|;
block|}
block|}
block|}
endif|#
directive|endif
comment|/* not WORKING_DOT_WORD  */
comment|/* Resolve symbol values.  This needs to be done before processing      the relocations.  */
if|if
condition|(
name|symbol_rootP
condition|)
block|{
name|symbolS
modifier|*
name|symp
decl_stmt|;
for|for
control|(
name|symp
operator|=
name|symbol_rootP
init|;
name|symp
condition|;
name|symp
operator|=
name|symbol_next
argument_list|(
name|symp
argument_list|)
control|)
name|resolve_symbol_value
argument_list|(
name|symp
argument_list|)
expr_stmt|;
block|}
name|resolve_local_symbol_values
argument_list|()
expr_stmt|;
name|resolve_reloc_expr_symbols
argument_list|()
expr_stmt|;
name|PROGRESS
argument_list|(
literal|1
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|tc_frob_file_before_adjust
name|tc_frob_file_before_adjust
argument_list|()
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|obj_frob_file_before_adjust
name|obj_frob_file_before_adjust
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|bfd_map_over_sections
argument_list|(
name|stdoutput
argument_list|,
name|adjust_reloc_syms
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|tc_frob_file_before_fix
name|tc_frob_file_before_fix
argument_list|()
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|obj_frob_file_before_fix
name|obj_frob_file_before_fix
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|bfd_map_over_sections
argument_list|(
name|stdoutput
argument_list|,
name|fix_segment
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
comment|/* Set up symbol table, and write it out.  */
if|if
condition|(
name|symbol_rootP
condition|)
block|{
name|symbolS
modifier|*
name|symp
decl_stmt|;
name|bfd_boolean
name|skip_next_symbol
init|=
name|FALSE
decl_stmt|;
for|for
control|(
name|symp
operator|=
name|symbol_rootP
init|;
name|symp
condition|;
name|symp
operator|=
name|symbol_next
argument_list|(
name|symp
argument_list|)
control|)
block|{
name|int
name|punt
init|=
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
if|if
condition|(
name|skip_next_symbol
condition|)
block|{
comment|/* Don't do anything besides moving the value of the 		 symbol from the GAS value-field to the BFD value-field.  */
name|symbol_get_bfdsym
argument_list|(
name|symp
argument_list|)
operator|->
name|value
operator|=
name|S_GET_VALUE
argument_list|(
name|symp
argument_list|)
expr_stmt|;
name|skip_next_symbol
operator|=
name|FALSE
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|symbol_mri_common_p
argument_list|(
name|symp
argument_list|)
condition|)
block|{
if|if
condition|(
name|S_IS_EXTERNAL
argument_list|(
name|symp
argument_list|)
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"%s: global symbols not supported in common sections"
argument_list|)
argument_list|,
name|S_GET_NAME
argument_list|(
name|symp
argument_list|)
argument_list|)
expr_stmt|;
name|symbol_remove
argument_list|(
name|symp
argument_list|,
operator|&
name|symbol_rootP
argument_list|,
operator|&
name|symbol_lastP
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|name
operator|=
name|S_GET_NAME
argument_list|(
name|symp
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
condition|)
block|{
specifier|const
name|char
modifier|*
name|name2
init|=
name|decode_local_label_name
argument_list|(
operator|(
name|char
operator|*
operator|)
name|S_GET_NAME
argument_list|(
name|symp
argument_list|)
argument_list|)
decl_stmt|;
comment|/* They only differ if `name' is a fb or dollar local 		 label name.  */
if|if
condition|(
name|name2
operator|!=
name|name
operator|&&
operator|!
name|S_IS_DEFINED
argument_list|(
name|symp
argument_list|)
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"local label `%s' is not defined"
argument_list|)
argument_list|,
name|name2
argument_list|)
expr_stmt|;
block|}
comment|/* Do it again, because adjust_reloc_syms might introduce 	     more symbols.  They'll probably only be section symbols, 	     but they'll still need to have the values computed.  */
name|resolve_symbol_value
argument_list|(
name|symp
argument_list|)
expr_stmt|;
comment|/* Skip symbols which were equated to undefined or common 	     symbols.  */
if|if
condition|(
name|symbol_equated_reloc_p
argument_list|(
name|symp
argument_list|)
operator|||
name|S_IS_WEAKREFR
argument_list|(
name|symp
argument_list|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|name
init|=
name|S_GET_NAME
argument_list|(
name|symp
argument_list|)
decl_stmt|;
if|if
condition|(
name|S_IS_COMMON
argument_list|(
name|symp
argument_list|)
operator|&&
operator|!
name|TC_FAKE_LABEL
argument_list|(
name|name
argument_list|)
operator|&&
operator|!
name|S_IS_WEAKREFR
argument_list|(
name|symp
argument_list|)
operator|&&
operator|(
operator|!
name|S_IS_EXTERNAL
argument_list|(
name|symp
argument_list|)
operator|||
name|S_IS_LOCAL
argument_list|(
name|symp
argument_list|)
operator|)
condition|)
block|{
name|expressionS
modifier|*
name|e
init|=
name|symbol_get_value_expression
argument_list|(
name|symp
argument_list|)
decl_stmt|;
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Local symbol `%s' can't be equated to common symbol `%s'"
argument_list|)
argument_list|,
name|name
argument_list|,
name|S_GET_NAME
argument_list|(
name|e
operator|->
name|X_add_symbol
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|symbol_remove
argument_list|(
name|symp
argument_list|,
operator|&
name|symbol_rootP
argument_list|,
operator|&
name|symbol_lastP
argument_list|)
expr_stmt|;
continue|continue;
block|}
ifdef|#
directive|ifdef
name|obj_frob_symbol
name|obj_frob_symbol
argument_list|(
name|symp
argument_list|,
name|punt
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|tc_frob_symbol
if|if
condition|(
operator|!
name|punt
operator|||
name|symbol_used_in_reloc_p
argument_list|(
name|symp
argument_list|)
condition|)
name|tc_frob_symbol
argument_list|(
name|symp
argument_list|,
name|punt
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* If we don't want to keep this symbol, splice it out of 	     the chain now.  If EMIT_SECTION_SYMBOLS is 0, we never 	     want section symbols.  Otherwise, we skip local symbols 	     and symbols that the frob_symbol macros told us to punt, 	     but we keep such symbols if they are used in relocs.  */
if|if
condition|(
name|symp
operator|==
name|abs_section_sym
operator|||
operator|(
operator|!
name|EMIT_SECTION_SYMBOLS
operator|&&
name|symbol_section_p
argument_list|(
name|symp
argument_list|)
operator|)
comment|/* Note that S_IS_EXTERNAL and S_IS_LOCAL are not always 		 opposites.  Sometimes the former checks flags and the 		 latter examines the name...  */
operator|||
operator|(
operator|!
name|S_IS_EXTERNAL
argument_list|(
name|symp
argument_list|)
operator|&&
operator|(
name|punt
operator|||
name|S_IS_LOCAL
argument_list|(
name|symp
argument_list|)
operator|||
operator|(
name|S_IS_WEAKREFD
argument_list|(
name|symp
argument_list|)
operator|&&
operator|!
name|symbol_used_p
argument_list|(
name|symp
argument_list|)
operator|)
operator|)
operator|&&
operator|!
name|symbol_used_in_reloc_p
argument_list|(
name|symp
argument_list|)
operator|)
condition|)
block|{
name|symbol_remove
argument_list|(
name|symp
argument_list|,
operator|&
name|symbol_rootP
argument_list|,
operator|&
name|symbol_lastP
argument_list|)
expr_stmt|;
comment|/* After symbol_remove, symbol_next(symp) still returns 		 the one that came after it in the chain.  So we don't 		 need to do any extra cleanup work here.  */
continue|continue;
block|}
comment|/* Make sure we really got a value for the symbol.  */
if|if
condition|(
operator|!
name|symbol_resolved_p
argument_list|(
name|symp
argument_list|)
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"can't resolve value for symbol `%s'"
argument_list|)
argument_list|,
name|S_GET_NAME
argument_list|(
name|symp
argument_list|)
argument_list|)
expr_stmt|;
name|symbol_mark_resolved
argument_list|(
name|symp
argument_list|)
expr_stmt|;
block|}
comment|/* Set the value into the BFD symbol.  Up til now the value 	     has only been kept in the gas symbolS struct.  */
name|symbol_get_bfdsym
argument_list|(
name|symp
argument_list|)
operator|->
name|value
operator|=
name|S_GET_VALUE
argument_list|(
name|symp
argument_list|)
expr_stmt|;
comment|/* A warning construct is a warning symbol followed by the 	     symbol warned about.  Don't let anything object-format or 	     target-specific muck with it; it's ready for output.  */
if|if
condition|(
name|symbol_get_bfdsym
argument_list|(
name|symp
argument_list|)
operator|->
name|flags
operator|&
name|BSF_WARNING
condition|)
name|skip_next_symbol
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
name|PROGRESS
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* Now do any format-specific adjustments to the symbol table, such      as adding file symbols.  */
ifdef|#
directive|ifdef
name|tc_adjust_symtab
name|tc_adjust_symtab
argument_list|()
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|obj_adjust_symtab
name|obj_adjust_symtab
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* Now that all the sizes are known, and contents correct, we can      start writing to the file.  */
name|set_symtab
argument_list|()
expr_stmt|;
comment|/* If *_frob_file changes the symbol value at this point, it is      responsible for moving the changed value into symp->bsym->value      as well.  Hopefully all symbol value changing can be done in      *_frob_symbol.  */
ifdef|#
directive|ifdef
name|tc_frob_file
name|tc_frob_file
argument_list|()
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|obj_frob_file
name|obj_frob_file
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|bfd_map_over_sections
argument_list|(
name|stdoutput
argument_list|,
name|write_relocs
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|tc_frob_file_after_relocs
name|tc_frob_file_after_relocs
argument_list|()
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|obj_frob_file_after_relocs
name|obj_frob_file_after_relocs
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|bfd_map_over_sections
argument_list|(
name|stdoutput
argument_list|,
name|write_contents
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|TC_GENERIC_RELAX_TABLE
end_ifdef

begin_comment
comment|/* Relax a fragment by scanning TC_GENERIC_RELAX_TABLE.  */
end_comment

begin_function
name|long
name|relax_frag
parameter_list|(
name|segT
name|segment
parameter_list|,
name|fragS
modifier|*
name|fragP
parameter_list|,
name|long
name|stretch
parameter_list|)
block|{
specifier|const
name|relax_typeS
modifier|*
name|this_type
decl_stmt|;
specifier|const
name|relax_typeS
modifier|*
name|start_type
decl_stmt|;
name|relax_substateT
name|next_state
decl_stmt|;
name|relax_substateT
name|this_state
decl_stmt|;
name|offsetT
name|growth
decl_stmt|;
name|offsetT
name|aim
decl_stmt|;
name|addressT
name|target
decl_stmt|;
name|addressT
name|address
decl_stmt|;
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
specifier|const
name|relax_typeS
modifier|*
name|table
decl_stmt|;
name|target
operator|=
name|fragP
operator|->
name|fr_offset
expr_stmt|;
name|address
operator|=
name|fragP
operator|->
name|fr_address
expr_stmt|;
name|table
operator|=
name|TC_GENERIC_RELAX_TABLE
expr_stmt|;
name|this_state
operator|=
name|fragP
operator|->
name|fr_subtype
expr_stmt|;
name|start_type
operator|=
name|this_type
operator|=
name|table
operator|+
name|this_state
expr_stmt|;
name|symbolP
operator|=
name|fragP
operator|->
name|fr_symbol
expr_stmt|;
if|if
condition|(
name|symbolP
condition|)
block|{
name|fragS
modifier|*
name|sym_frag
decl_stmt|;
name|sym_frag
operator|=
name|symbol_get_frag
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|DIFF_EXPR_OK
name|know
argument_list|(
name|sym_frag
operator|!=
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|know
argument_list|(
name|S_GET_SEGMENT
argument_list|(
name|symbolP
argument_list|)
operator|!=
name|absolute_section
operator|||
name|sym_frag
operator|==
operator|&
name|zero_address_frag
argument_list|)
expr_stmt|;
name|target
operator|+=
name|S_GET_VALUE
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
comment|/* If frag has yet to be reached on this pass, 	 assume it will move by STRETCH just as we did. 	 If this is not so, it will be because some frag 	 between grows, and that will force another pass.  */
if|if
condition|(
name|stretch
operator|!=
literal|0
operator|&&
name|sym_frag
operator|->
name|relax_marker
operator|!=
name|fragP
operator|->
name|relax_marker
operator|&&
name|S_GET_SEGMENT
argument_list|(
name|symbolP
argument_list|)
operator|==
name|segment
condition|)
block|{
name|target
operator|+=
name|stretch
expr_stmt|;
block|}
block|}
name|aim
operator|=
name|target
operator|-
name|address
operator|-
name|fragP
operator|->
name|fr_fix
expr_stmt|;
ifdef|#
directive|ifdef
name|TC_PCREL_ADJUST
comment|/* Currently only the ns32k family needs this.  */
name|aim
operator|+=
name|TC_PCREL_ADJUST
argument_list|(
name|fragP
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|md_prepare_relax_scan
comment|/* Formerly called M68K_AIM_KLUDGE.  */
name|md_prepare_relax_scan
argument_list|(
name|fragP
argument_list|,
name|address
argument_list|,
name|aim
argument_list|,
name|this_state
argument_list|,
name|this_type
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|aim
operator|<
literal|0
condition|)
block|{
comment|/* Look backwards.  */
for|for
control|(
name|next_state
operator|=
name|this_type
operator|->
name|rlx_more
init|;
name|next_state
condition|;
control|)
if|if
condition|(
name|aim
operator|>=
name|this_type
operator|->
name|rlx_backward
condition|)
name|next_state
operator|=
literal|0
expr_stmt|;
else|else
block|{
comment|/* Grow to next state.  */
name|this_state
operator|=
name|next_state
expr_stmt|;
name|this_type
operator|=
name|table
operator|+
name|this_state
expr_stmt|;
name|next_state
operator|=
name|this_type
operator|->
name|rlx_more
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Look forwards.  */
for|for
control|(
name|next_state
operator|=
name|this_type
operator|->
name|rlx_more
init|;
name|next_state
condition|;
control|)
if|if
condition|(
name|aim
operator|<=
name|this_type
operator|->
name|rlx_forward
condition|)
name|next_state
operator|=
literal|0
expr_stmt|;
else|else
block|{
comment|/* Grow to next state.  */
name|this_state
operator|=
name|next_state
expr_stmt|;
name|this_type
operator|=
name|table
operator|+
name|this_state
expr_stmt|;
name|next_state
operator|=
name|this_type
operator|->
name|rlx_more
expr_stmt|;
block|}
block|}
name|growth
operator|=
name|this_type
operator|->
name|rlx_length
operator|-
name|start_type
operator|->
name|rlx_length
expr_stmt|;
if|if
condition|(
name|growth
operator|!=
literal|0
condition|)
name|fragP
operator|->
name|fr_subtype
operator|=
name|this_state
expr_stmt|;
return|return
name|growth
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* defined (TC_GENERIC_RELAX_TABLE)  */
end_comment

begin_comment
comment|/* Relax_align. Advance location counter to next address that has 'alignment'    lowest order bits all 0s, return size of adjustment made.  */
end_comment

begin_function
specifier|static
name|relax_addressT
name|relax_align
parameter_list|(
specifier|register
name|relax_addressT
name|address
parameter_list|,
comment|/* Address now.  */
specifier|register
name|int
name|alignment
comment|/* Alignment (binary).  */
parameter_list|)
block|{
name|relax_addressT
name|mask
decl_stmt|;
name|relax_addressT
name|new_address
decl_stmt|;
name|mask
operator|=
operator|~
operator|(
operator|(
operator|~
literal|0
operator|)
operator|<<
name|alignment
operator|)
expr_stmt|;
name|new_address
operator|=
operator|(
name|address
operator|+
name|mask
operator|)
operator|&
operator|(
operator|~
name|mask
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|LINKER_RELAXING_SHRINKS_ONLY
if|if
condition|(
name|linkrelax
condition|)
comment|/* We must provide lots of padding, so the linker can discard it        when needed.  The linker will not add extra space, ever.  */
name|new_address
operator|+=
operator|(
literal|1
operator|<<
name|alignment
operator|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|new_address
operator|-
name|address
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Now we have a segment, not a crowd of sub-segments, we can make    fr_address values.     Relax the frags.     After this, all frags in this segment have addresses that are correct    within the segment. Since segments live in different file addresses,    these frag addresses may not be the same as final object-file    addresses.  */
end_comment

begin_function
name|int
name|relax_segment
parameter_list|(
name|struct
name|frag
modifier|*
name|segment_frag_root
parameter_list|,
name|segT
name|segment
parameter_list|,
name|int
name|pass
parameter_list|)
block|{
name|unsigned
name|long
name|frag_count
decl_stmt|;
name|struct
name|frag
modifier|*
name|fragP
decl_stmt|;
name|relax_addressT
name|address
decl_stmt|;
name|int
name|ret
decl_stmt|;
comment|/* In case md_estimate_size_before_relax() wants to make fixSs.  */
name|subseg_change
argument_list|(
name|segment
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* For each frag in segment: count and store  (a 1st guess of)      fr_address.  */
name|address
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|frag_count
operator|=
literal|0
operator|,
name|fragP
operator|=
name|segment_frag_root
init|;
name|fragP
condition|;
name|fragP
operator|=
name|fragP
operator|->
name|fr_next
operator|,
name|frag_count
operator|++
control|)
block|{
name|fragP
operator|->
name|relax_marker
operator|=
literal|0
expr_stmt|;
name|fragP
operator|->
name|fr_address
operator|=
name|address
expr_stmt|;
name|address
operator|+=
name|fragP
operator|->
name|fr_fix
expr_stmt|;
switch|switch
condition|(
name|fragP
operator|->
name|fr_type
condition|)
block|{
case|case
name|rs_fill
case|:
name|address
operator|+=
name|fragP
operator|->
name|fr_offset
operator|*
name|fragP
operator|->
name|fr_var
expr_stmt|;
break|break;
case|case
name|rs_align
case|:
case|case
name|rs_align_code
case|:
case|case
name|rs_align_test
case|:
block|{
name|addressT
name|offset
init|=
name|relax_align
argument_list|(
name|address
argument_list|,
operator|(
name|int
operator|)
name|fragP
operator|->
name|fr_offset
argument_list|)
decl_stmt|;
if|if
condition|(
name|fragP
operator|->
name|fr_subtype
operator|!=
literal|0
operator|&&
name|offset
operator|>
name|fragP
operator|->
name|fr_subtype
condition|)
name|offset
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|offset
operator|%
name|fragP
operator|->
name|fr_var
operator|!=
literal|0
condition|)
block|{
name|as_bad_where
argument_list|(
name|fragP
operator|->
name|fr_file
argument_list|,
name|fragP
operator|->
name|fr_line
argument_list|,
name|_
argument_list|(
literal|"alignment padding (%lu bytes) not a multiple of %ld"
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|offset
argument_list|,
operator|(
name|long
operator|)
name|fragP
operator|->
name|fr_var
argument_list|)
expr_stmt|;
name|offset
operator|-=
operator|(
name|offset
operator|%
name|fragP
operator|->
name|fr_var
operator|)
expr_stmt|;
block|}
name|address
operator|+=
name|offset
expr_stmt|;
block|}
break|break;
case|case
name|rs_org
case|:
case|case
name|rs_space
case|:
comment|/* Assume .org is nugatory. It will grow with 1st relax.  */
break|break;
case|case
name|rs_machine_dependent
case|:
comment|/* If fr_symbol is an expression, this call to 	     resolve_symbol_value sets up the correct segment, which will 	     likely be needed in md_estimate_size_before_relax.  */
if|if
condition|(
name|fragP
operator|->
name|fr_symbol
condition|)
name|resolve_symbol_value
argument_list|(
name|fragP
operator|->
name|fr_symbol
argument_list|)
expr_stmt|;
name|address
operator|+=
name|md_estimate_size_before_relax
argument_list|(
name|fragP
argument_list|,
name|segment
argument_list|)
expr_stmt|;
break|break;
ifndef|#
directive|ifndef
name|WORKING_DOT_WORD
comment|/* Broken words don't concern us yet.  */
case|case
name|rs_broken_word
case|:
break|break;
endif|#
directive|endif
case|case
name|rs_leb128
case|:
comment|/* Initial guess is always 1; doing otherwise can result in 	     stable solutions that are larger than the minimum.  */
name|address
operator|+=
name|fragP
operator|->
name|fr_offset
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|rs_cfa
case|:
name|address
operator|+=
name|eh_frame_estimate_size_before_relax
argument_list|(
name|fragP
argument_list|)
expr_stmt|;
break|break;
case|case
name|rs_dwarf2dbg
case|:
name|address
operator|+=
name|dwarf2dbg_estimate_size_before_relax
argument_list|(
name|fragP
argument_list|)
expr_stmt|;
break|break;
default|default:
name|BAD_CASE
argument_list|(
name|fragP
operator|->
name|fr_type
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|/* Do relax().  */
block|{
name|unsigned
name|long
name|max_iterations
decl_stmt|;
comment|/* Cumulative address adjustment.  */
name|offsetT
name|stretch
decl_stmt|;
comment|/* Have we made any adjustment this pass?  We can't just test        stretch because one piece of code may have grown and another        shrank.  */
name|int
name|stretched
decl_stmt|;
comment|/* Most horrible, but gcc may give us some exception data that        is impossible to assemble, of the form         .align 4        .byte 0, 0        .uleb128 end - start        start:        .space 128*128 - 1        .align 4        end:         If the leb128 is two bytes in size, then end-start is 128*128,        which requires a three byte leb128.  If the leb128 is three        bytes in size, then end-start is 128*128-1, which requires a        two byte leb128.  We work around this dilemma by inserting        an extra 4 bytes of alignment just after the .align.  This        works because the data after the align is accessed relative to        the end label.         This counter is used in a tiny state machine to detect        whether a leb128 followed by an align is impossible to        relax.  */
name|int
name|rs_leb128_fudge
init|=
literal|0
decl_stmt|;
comment|/* We want to prevent going into an infinite loop where one frag grows        depending upon the location of a symbol which is in turn moved by        the growing frag.  eg:  	 foo = . 	 .org foo+16 	 foo = .         So we dictate that this algorithm can be at most O2.  */
name|max_iterations
operator|=
name|frag_count
operator|*
name|frag_count
expr_stmt|;
comment|/* Check for overflow.  */
if|if
condition|(
name|max_iterations
operator|<
name|frag_count
condition|)
name|max_iterations
operator|=
name|frag_count
expr_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|stretch
operator|=
literal|0
expr_stmt|;
name|stretched
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|fragP
operator|=
name|segment_frag_root
init|;
name|fragP
condition|;
name|fragP
operator|=
name|fragP
operator|->
name|fr_next
control|)
block|{
name|offsetT
name|growth
init|=
literal|0
decl_stmt|;
name|addressT
name|was_address
decl_stmt|;
name|offsetT
name|offset
decl_stmt|;
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
name|fragP
operator|->
name|relax_marker
operator|^=
literal|1
expr_stmt|;
name|was_address
operator|=
name|fragP
operator|->
name|fr_address
expr_stmt|;
name|address
operator|=
name|fragP
operator|->
name|fr_address
operator|+=
name|stretch
expr_stmt|;
name|symbolP
operator|=
name|fragP
operator|->
name|fr_symbol
expr_stmt|;
name|offset
operator|=
name|fragP
operator|->
name|fr_offset
expr_stmt|;
switch|switch
condition|(
name|fragP
operator|->
name|fr_type
condition|)
block|{
case|case
name|rs_fill
case|:
comment|/* .fill never relaxes.  */
name|growth
operator|=
literal|0
expr_stmt|;
break|break;
ifndef|#
directive|ifndef
name|WORKING_DOT_WORD
comment|/* JF:  This is RMS's idea.  I do *NOT* want to be blamed 		   for it I do not want to write it.  I do not want to have 		   anything to do with it.  This is not the proper way to 		   implement this misfeature.  */
case|case
name|rs_broken_word
case|:
block|{
name|struct
name|broken_word
modifier|*
name|lie
decl_stmt|;
name|struct
name|broken_word
modifier|*
name|untruth
decl_stmt|;
comment|/* Yes this is ugly (storing the broken_word pointer 		     in the symbol slot).  Still, this whole chunk of 		     code is ugly, and I don't feel like doing anything 		     about it.  Think of it as stubbornness in action.  */
name|growth
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|lie
operator|=
operator|(
expr|struct
name|broken_word
operator|*
operator|)
operator|(
name|fragP
operator|->
name|fr_symbol
operator|)
init|;
name|lie
operator|&&
name|lie
operator|->
name|dispfrag
operator|==
name|fragP
condition|;
name|lie
operator|=
name|lie
operator|->
name|next_broken_word
control|)
block|{
if|if
condition|(
name|lie
operator|->
name|added
condition|)
continue|continue;
name|offset
operator|=
operator|(
name|S_GET_VALUE
argument_list|(
name|lie
operator|->
name|add
argument_list|)
operator|+
name|lie
operator|->
name|addnum
operator|-
name|S_GET_VALUE
argument_list|(
name|lie
operator|->
name|sub
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|offset
operator|<=
operator|-
literal|32768
operator|||
name|offset
operator|>=
literal|32767
condition|)
block|{
if|if
condition|(
name|flag_warn_displacement
condition|)
block|{
name|char
name|buf
index|[
literal|50
index|]
decl_stmt|;
name|sprint_value
argument_list|(
name|buf
argument_list|,
operator|(
name|addressT
operator|)
name|lie
operator|->
name|addnum
argument_list|)
expr_stmt|;
name|as_warn_where
argument_list|(
name|fragP
operator|->
name|fr_file
argument_list|,
name|fragP
operator|->
name|fr_line
argument_list|,
name|_
argument_list|(
literal|".word %s-%s+%s didn't fit"
argument_list|)
argument_list|,
name|S_GET_NAME
argument_list|(
name|lie
operator|->
name|add
argument_list|)
argument_list|,
name|S_GET_NAME
argument_list|(
name|lie
operator|->
name|sub
argument_list|)
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
name|lie
operator|->
name|added
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|fragP
operator|->
name|fr_subtype
operator|==
literal|0
condition|)
block|{
name|fragP
operator|->
name|fr_subtype
operator|++
expr_stmt|;
name|growth
operator|+=
name|md_short_jump_size
expr_stmt|;
block|}
for|for
control|(
name|untruth
operator|=
name|lie
operator|->
name|next_broken_word
init|;
name|untruth
operator|&&
name|untruth
operator|->
name|dispfrag
operator|==
name|lie
operator|->
name|dispfrag
condition|;
name|untruth
operator|=
name|untruth
operator|->
name|next_broken_word
control|)
if|if
condition|(
operator|(
name|symbol_get_frag
argument_list|(
name|untruth
operator|->
name|add
argument_list|)
operator|==
name|symbol_get_frag
argument_list|(
name|lie
operator|->
name|add
argument_list|)
operator|)
operator|&&
operator|(
name|S_GET_VALUE
argument_list|(
name|untruth
operator|->
name|add
argument_list|)
operator|==
name|S_GET_VALUE
argument_list|(
name|lie
operator|->
name|add
argument_list|)
operator|)
condition|)
block|{
name|untruth
operator|->
name|added
operator|=
literal|2
expr_stmt|;
name|untruth
operator|->
name|use_jump
operator|=
name|lie
expr_stmt|;
block|}
name|growth
operator|+=
name|md_long_jump_size
expr_stmt|;
block|}
block|}
break|break;
block|}
comment|/* case rs_broken_word  */
endif|#
directive|endif
case|case
name|rs_align
case|:
case|case
name|rs_align_code
case|:
case|case
name|rs_align_test
case|:
block|{
name|addressT
name|oldoff
decl_stmt|,
name|newoff
decl_stmt|;
name|oldoff
operator|=
name|relax_align
argument_list|(
name|was_address
operator|+
name|fragP
operator|->
name|fr_fix
argument_list|,
operator|(
name|int
operator|)
name|offset
argument_list|)
expr_stmt|;
name|newoff
operator|=
name|relax_align
argument_list|(
name|address
operator|+
name|fragP
operator|->
name|fr_fix
argument_list|,
operator|(
name|int
operator|)
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|fragP
operator|->
name|fr_subtype
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|oldoff
operator|>
name|fragP
operator|->
name|fr_subtype
condition|)
name|oldoff
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|newoff
operator|>
name|fragP
operator|->
name|fr_subtype
condition|)
name|newoff
operator|=
literal|0
expr_stmt|;
block|}
name|growth
operator|=
name|newoff
operator|-
name|oldoff
expr_stmt|;
comment|/* If this align happens to follow a leb128 and 		     we have determined that the leb128 is bouncing 		     in size, then break the cycle by inserting an 		     extra alignment.  */
if|if
condition|(
name|growth
operator|<
literal|0
operator|&&
operator|(
name|rs_leb128_fudge
operator|&
literal|16
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|rs_leb128_fudge
operator|&
literal|15
operator|)
operator|>=
literal|2
condition|)
block|{
name|segment_info_type
modifier|*
name|seginfo
init|=
name|seg_info
argument_list|(
name|segment
argument_list|)
decl_stmt|;
name|struct
name|obstack
modifier|*
name|ob
init|=
operator|&
name|seginfo
operator|->
name|frchainP
operator|->
name|frch_obstack
decl_stmt|;
name|struct
name|frag
modifier|*
name|newf
decl_stmt|;
name|newf
operator|=
name|frag_alloc
argument_list|(
name|ob
argument_list|)
expr_stmt|;
name|obstack_blank_fast
argument_list|(
name|ob
argument_list|,
name|fragP
operator|->
name|fr_var
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|obstack_finish
argument_list|(
name|ob
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|newf
argument_list|,
name|fragP
argument_list|,
name|SIZEOF_STRUCT_FRAG
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|newf
operator|->
name|fr_literal
argument_list|,
name|fragP
operator|->
name|fr_literal
operator|+
name|fragP
operator|->
name|fr_fix
argument_list|,
name|fragP
operator|->
name|fr_var
argument_list|)
expr_stmt|;
name|newf
operator|->
name|fr_type
operator|=
name|rs_fill
expr_stmt|;
name|newf
operator|->
name|fr_fix
operator|=
literal|0
expr_stmt|;
name|newf
operator|->
name|fr_offset
operator|=
operator|(
operator|(
operator|(
name|offsetT
operator|)
literal|1
operator|<<
name|fragP
operator|->
name|fr_offset
operator|)
operator|/
name|fragP
operator|->
name|fr_var
operator|)
expr_stmt|;
if|if
condition|(
name|newf
operator|->
name|fr_offset
operator|*
name|newf
operator|->
name|fr_var
operator|!=
operator|(
name|offsetT
operator|)
literal|1
operator|<<
name|fragP
operator|->
name|fr_offset
condition|)
block|{
name|newf
operator|->
name|fr_offset
operator|=
operator|(
name|offsetT
operator|)
literal|1
operator|<<
name|fragP
operator|->
name|fr_offset
expr_stmt|;
name|newf
operator|->
name|fr_var
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Include growth of new frag, because rs_fill 			 frags don't normally grow.  */
name|growth
operator|+=
name|newf
operator|->
name|fr_offset
operator|*
name|newf
operator|->
name|fr_var
expr_stmt|;
comment|/* The new frag address is newoff.  Adjust this 			 for the amount we'll add when we process the 			 new frag.  */
name|newf
operator|->
name|fr_address
operator|=
name|newoff
operator|-
name|stretch
operator|-
name|growth
expr_stmt|;
name|newf
operator|->
name|relax_marker
operator|^=
literal|1
expr_stmt|;
name|fragP
operator|->
name|fr_next
operator|=
name|newf
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"padding added"
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
break|break;
case|case
name|rs_org
case|:
block|{
name|addressT
name|target
init|=
name|offset
decl_stmt|;
name|addressT
name|after
decl_stmt|;
if|if
condition|(
name|symbolP
condition|)
block|{
comment|/* Convert from an actual address to an octet offset 			 into the section.  Here it is assumed that the 			 section's VMA is zero, and can omit subtracting it 			 from the symbol's value to get the address offset.  */
name|know
argument_list|(
name|S_GET_SEGMENT
argument_list|(
name|symbolP
argument_list|)
operator|->
name|vma
operator|==
literal|0
argument_list|)
expr_stmt|;
name|target
operator|+=
name|S_GET_VALUE
argument_list|(
name|symbolP
argument_list|)
operator|*
name|OCTETS_PER_BYTE
expr_stmt|;
block|}
name|know
argument_list|(
name|fragP
operator|->
name|fr_next
argument_list|)
expr_stmt|;
name|after
operator|=
name|fragP
operator|->
name|fr_next
operator|->
name|fr_address
expr_stmt|;
name|growth
operator|=
name|target
operator|-
name|after
expr_stmt|;
if|if
condition|(
name|growth
operator|<
literal|0
condition|)
block|{
name|growth
operator|=
literal|0
expr_stmt|;
comment|/* Don't error on first few frag relax passes. 			 The symbol might be an expression involving 			 symbol values from other sections.  If those 			 sections have not yet been processed their 			 frags will all have zero addresses, so we 			 will calculate incorrect values for them.  The 			 number of passes we allow before giving an 			 error is somewhat arbitrary.  It should be at 			 least one, with larger values requiring 			 increasingly contrived dependencies between 			 frags to trigger a false error.  */
if|if
condition|(
name|pass
operator|<
literal|2
condition|)
block|{
comment|/* Force another pass.  */
name|ret
operator|=
literal|1
expr_stmt|;
break|break;
block|}
comment|/* Growth may be negative, but variable part of frag 			 cannot have fewer than 0 chars.  That is, we can't 			 .org backwards.  */
name|as_bad_where
argument_list|(
name|fragP
operator|->
name|fr_file
argument_list|,
name|fragP
operator|->
name|fr_line
argument_list|,
name|_
argument_list|(
literal|"attempt to move .org backwards"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We've issued an error message.  Change the 			 frag to avoid cascading errors.  */
name|fragP
operator|->
name|fr_type
operator|=
name|rs_align
expr_stmt|;
name|fragP
operator|->
name|fr_subtype
operator|=
literal|0
expr_stmt|;
name|fragP
operator|->
name|fr_offset
operator|=
literal|0
expr_stmt|;
name|fragP
operator|->
name|fr_fix
operator|=
name|after
operator|-
name|was_address
expr_stmt|;
break|break;
block|}
comment|/* This is an absolute growth factor  */
name|growth
operator|-=
name|stretch
expr_stmt|;
break|break;
block|}
case|case
name|rs_space
case|:
name|growth
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|symbolP
condition|)
block|{
name|offsetT
name|amount
decl_stmt|;
name|amount
operator|=
name|S_GET_VALUE
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
if|if
condition|(
name|S_GET_SEGMENT
argument_list|(
name|symbolP
argument_list|)
operator|!=
name|absolute_section
operator|||
name|S_IS_COMMON
argument_list|(
name|symbolP
argument_list|)
operator|||
operator|!
name|S_IS_DEFINED
argument_list|(
name|symbolP
argument_list|)
condition|)
block|{
name|as_bad_where
argument_list|(
name|fragP
operator|->
name|fr_file
argument_list|,
name|fragP
operator|->
name|fr_line
argument_list|,
name|_
argument_list|(
literal|".space specifies non-absolute value"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Prevent repeat of this error message.  */
name|fragP
operator|->
name|fr_symbol
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|amount
operator|<
literal|0
condition|)
block|{
comment|/* Don't error on first few frag relax passes. 			   See rs_org comment for a longer explanation.  */
if|if
condition|(
name|pass
operator|<
literal|2
condition|)
block|{
name|ret
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|as_warn_where
argument_list|(
name|fragP
operator|->
name|fr_file
argument_list|,
name|fragP
operator|->
name|fr_line
argument_list|,
name|_
argument_list|(
literal|".space or .fill with negative value, ignored"
argument_list|)
argument_list|)
expr_stmt|;
name|fragP
operator|->
name|fr_symbol
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|growth
operator|=
operator|(
name|was_address
operator|+
name|fragP
operator|->
name|fr_fix
operator|+
name|amount
operator|-
name|fragP
operator|->
name|fr_next
operator|->
name|fr_address
operator|)
expr_stmt|;
block|}
break|break;
case|case
name|rs_machine_dependent
case|:
ifdef|#
directive|ifdef
name|md_relax_frag
name|growth
operator|=
name|md_relax_frag
argument_list|(
name|segment
argument_list|,
name|fragP
argument_list|,
name|stretch
argument_list|)
expr_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|TC_GENERIC_RELAX_TABLE
comment|/* The default way to relax a frag is to look through 		   TC_GENERIC_RELAX_TABLE.  */
name|growth
operator|=
name|relax_frag
argument_list|(
name|segment
argument_list|,
name|fragP
argument_list|,
name|stretch
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* TC_GENERIC_RELAX_TABLE  */
endif|#
directive|endif
break|break;
case|case
name|rs_leb128
case|:
block|{
name|valueT
name|value
decl_stmt|;
name|offsetT
name|size
decl_stmt|;
name|value
operator|=
name|resolve_symbol_value
argument_list|(
name|fragP
operator|->
name|fr_symbol
argument_list|)
expr_stmt|;
name|size
operator|=
name|sizeof_leb128
argument_list|(
name|value
argument_list|,
name|fragP
operator|->
name|fr_subtype
argument_list|)
expr_stmt|;
name|growth
operator|=
name|size
operator|-
name|fragP
operator|->
name|fr_offset
expr_stmt|;
name|fragP
operator|->
name|fr_offset
operator|=
name|size
expr_stmt|;
block|}
break|break;
case|case
name|rs_cfa
case|:
name|growth
operator|=
name|eh_frame_relax_frag
argument_list|(
name|fragP
argument_list|)
expr_stmt|;
break|break;
case|case
name|rs_dwarf2dbg
case|:
name|growth
operator|=
name|dwarf2dbg_relax_frag
argument_list|(
name|fragP
argument_list|)
expr_stmt|;
break|break;
default|default:
name|BAD_CASE
argument_list|(
name|fragP
operator|->
name|fr_type
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|growth
condition|)
block|{
name|stretch
operator|+=
name|growth
expr_stmt|;
name|stretched
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|fragP
operator|->
name|fr_type
operator|==
name|rs_leb128
condition|)
name|rs_leb128_fudge
operator|+=
literal|16
expr_stmt|;
elseif|else
if|if
condition|(
name|fragP
operator|->
name|fr_type
operator|==
name|rs_align
operator|&&
operator|(
name|rs_leb128_fudge
operator|&
literal|16
operator|)
operator|!=
literal|0
operator|&&
name|stretch
operator|==
literal|0
condition|)
name|rs_leb128_fudge
operator|+=
literal|16
expr_stmt|;
else|else
name|rs_leb128_fudge
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|stretch
operator|==
literal|0
operator|&&
operator|(
name|rs_leb128_fudge
operator|&
literal|16
operator|)
operator|==
literal|0
operator|&&
operator|(
name|rs_leb128_fudge
operator|&
operator|-
literal|16
operator|)
operator|!=
literal|0
condition|)
name|rs_leb128_fudge
operator|+=
literal|1
expr_stmt|;
else|else
name|rs_leb128_fudge
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Until nothing further to relax.  */
do|while
condition|(
name|stretched
operator|&&
operator|--
name|max_iterations
condition|)
do|;
if|if
condition|(
name|stretched
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"Infinite loop encountered whilst attempting to compute the addresses of symbols in section %s"
argument_list|)
argument_list|,
name|segment_name
argument_list|(
name|segment
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|fragP
operator|=
name|segment_frag_root
init|;
name|fragP
condition|;
name|fragP
operator|=
name|fragP
operator|->
name|fr_next
control|)
if|if
condition|(
name|fragP
operator|->
name|last_fr_address
operator|!=
name|fragP
operator|->
name|fr_address
condition|)
block|{
name|fragP
operator|->
name|last_fr_address
operator|=
name|fragP
operator|->
name|fr_address
expr_stmt|;
name|ret
operator|=
literal|1
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_function
name|void
name|number_to_chars_bigendian
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|valueT
name|val
parameter_list|,
name|int
name|n
parameter_list|)
block|{
if|if
condition|(
name|n
operator|<=
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
while|while
condition|(
name|n
operator|--
condition|)
block|{
name|buf
index|[
name|n
index|]
operator|=
name|val
operator|&
literal|0xff
expr_stmt|;
name|val
operator|>>=
literal|8
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|number_to_chars_littleendian
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|valueT
name|val
parameter_list|,
name|int
name|n
parameter_list|)
block|{
if|if
condition|(
name|n
operator|<=
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
while|while
condition|(
name|n
operator|--
condition|)
block|{
operator|*
name|buf
operator|++
operator|=
name|val
operator|&
literal|0xff
expr_stmt|;
name|val
operator|>>=
literal|8
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|write_print_statistics
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"fixups: %d\n"
argument_list|,
name|n_fixups
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* For debugging.  */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|indent_level
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|print_fixup
parameter_list|(
name|fixS
modifier|*
name|fixp
parameter_list|)
block|{
name|indent_level
operator|=
literal|1
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"fix %lx %s:%d"
argument_list|,
operator|(
name|long
operator|)
name|fixp
argument_list|,
name|fixp
operator|->
name|fx_file
argument_list|,
name|fixp
operator|->
name|fx_line
argument_list|)
expr_stmt|;
if|if
condition|(
name|fixp
operator|->
name|fx_pcrel
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" pcrel"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fixp
operator|->
name|fx_pcrel_adjust
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" pcrel_adjust=%d"
argument_list|,
name|fixp
operator|->
name|fx_pcrel_adjust
argument_list|)
expr_stmt|;
if|if
condition|(
name|fixp
operator|->
name|fx_im_disp
condition|)
block|{
ifdef|#
directive|ifdef
name|TC_NS32K
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" im_disp=%d"
argument_list|,
name|fixp
operator|->
name|fx_im_disp
argument_list|)
expr_stmt|;
else|#
directive|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" im_disp"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|fixp
operator|->
name|fx_tcbit
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" tcbit"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fixp
operator|->
name|fx_done
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" done"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n    size=%d frag=%lx where=%ld offset=%lx addnumber=%lx"
argument_list|,
name|fixp
operator|->
name|fx_size
argument_list|,
operator|(
name|long
operator|)
name|fixp
operator|->
name|fx_frag
argument_list|,
operator|(
name|long
operator|)
name|fixp
operator|->
name|fx_where
argument_list|,
operator|(
name|long
operator|)
name|fixp
operator|->
name|fx_offset
argument_list|,
operator|(
name|long
operator|)
name|fixp
operator|->
name|fx_addnumber
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n    %s (%d)"
argument_list|,
name|bfd_get_reloc_code_name
argument_list|(
name|fixp
operator|->
name|fx_r_type
argument_list|)
argument_list|,
name|fixp
operator|->
name|fx_r_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|fixp
operator|->
name|fx_addsy
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n   +<"
argument_list|)
expr_stmt|;
name|print_symbol_value_1
argument_list|(
name|stderr
argument_list|,
name|fixp
operator|->
name|fx_addsy
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|">"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fixp
operator|->
name|fx_subsy
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n   -<"
argument_list|)
expr_stmt|;
name|print_symbol_value_1
argument_list|(
name|stderr
argument_list|,
name|fixp
operator|->
name|fx_subsy
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|">"
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TC_FIX_DATA_PRINT
name|TC_FIX_DATA_PRINT
argument_list|(
name|stderr
argument_list|,
name|fixp
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

end_unit

