begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* write.c - emit .o file    Copyright (C) 1986, 87, 90, 91, 92, 93, 94, 95, 96, 1997    Free Software Foundation, Inc.     This file is part of GAS, the GNU Assembler.     GAS is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     GAS is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with GAS; see the file COPYING.  If not, write to the Free    Software Foundation, 59 Temple Place - Suite 330, Boston, MA    02111-1307, USA.  */
end_comment

begin_comment
comment|/* This thing should be set up to do byteordering correctly.  But... */
end_comment

begin_include
include|#
directive|include
file|"as.h"
end_include

begin_include
include|#
directive|include
file|"subsegs.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_include
include|#
directive|include
file|"output-file.h"
end_include

begin_comment
comment|/* This looks like a good idea.  Let's try turning it on always, for now.  */
end_comment

begin_undef
undef|#
directive|undef
name|BFD_FAST_SECTION_FILL
end_undef

begin_define
define|#
directive|define
name|BFD_FAST_SECTION_FILL
end_define

begin_comment
comment|/* The NOP_OPCODE is for the alignment fill value.  Fill it with a nop    instruction so that the disassembler does not choke on it.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|NOP_OPCODE
end_ifndef

begin_define
define|#
directive|define
name|NOP_OPCODE
value|0x00
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|TC_ADJUST_RELOC_COUNT
end_ifndef

begin_define
define|#
directive|define
name|TC_ADJUST_RELOC_COUNT
parameter_list|(
name|FIXP
parameter_list|,
name|COUNT
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|TC_FORCE_RELOCATION
end_ifndef

begin_define
define|#
directive|define
name|TC_FORCE_RELOCATION
parameter_list|(
name|FIXP
parameter_list|)
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|TC_FORCE_RELOCATION_SECTION
end_ifndef

begin_define
define|#
directive|define
name|TC_FORCE_RELOCATION_SECTION
parameter_list|(
name|FIXP
parameter_list|,
name|SEG
parameter_list|)
value|TC_FORCE_RELOCATION(FIXP)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|MD_PCREL_FROM_SECTION
end_ifndef

begin_define
define|#
directive|define
name|MD_PCREL_FROM_SECTION
parameter_list|(
name|FIXP
parameter_list|,
name|SEC
parameter_list|)
value|md_pcrel_from(FIXP)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|WORKING_DOT_WORD
end_ifndef

begin_decl_stmt
specifier|extern
name|CONST
name|int
name|md_short_jump_size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|CONST
name|int
name|md_long_jump_size
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|int
name|symbol_table_frozen
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|print_fixup
name|PARAMS
argument_list|(
operator|(
name|fixS
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|BFD_ASSEMBLER
end_ifdef

begin_decl_stmt
specifier|static
name|void
name|renumber_sections
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* We generally attach relocs to frag chains.  However, after we have    chained these all together into a segment, any relocs we add after    that must be attached to a segment.  This will include relocs added    in md_estimate_size_for_relax, for example.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|frags_chained
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|BFD_ASSEMBLER
end_ifndef

begin_ifndef
ifndef|#
directive|ifndef
name|MANY_SEGMENTS
end_ifndef

begin_decl_stmt
name|struct
name|frag
modifier|*
name|text_frag_root
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|frag
modifier|*
name|data_frag_root
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|frag
modifier|*
name|bss_frag_root
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|frag
modifier|*
name|text_last_frag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Last frag in segment. */
end_comment

begin_decl_stmt
name|struct
name|frag
modifier|*
name|data_last_frag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Last frag in segment. */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|frag
modifier|*
name|bss_last_frag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Last frag in segment. */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|BFD
end_ifndef

begin_decl_stmt
specifier|static
name|object_headers
name|headers
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|long
name|string_byte_count
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|next_object_file_charP
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Tracks object file bytes. */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|OBJ_VMS
end_ifndef

begin_decl_stmt
name|int
name|magic_number_for_object_file
init|=
name|DEFAULT_MAGIC_NUMBER_FOR_OBJECT_FILE
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* BFD_ASSEMBLER */
end_comment

begin_decl_stmt
specifier|static
name|int
name|n_fixups
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|BFD_ASSEMBLER
end_ifdef

begin_decl_stmt
specifier|static
name|fixS
modifier|*
name|fix_new_internal
name|PARAMS
argument_list|(
operator|(
name|fragS
operator|*
operator|,
name|int
name|where
operator|,
name|int
name|size
operator|,
name|symbolS
operator|*
name|add
operator|,
name|symbolS
operator|*
name|sub
operator|,
name|offsetT
name|offset
operator|,
name|int
name|pcrel
operator|,
name|bfd_reloc_code_real_type
name|r_type
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|static
name|fixS
modifier|*
name|fix_new_internal
name|PARAMS
argument_list|(
operator|(
name|fragS
operator|*
operator|,
name|int
name|where
operator|,
name|int
name|size
operator|,
name|symbolS
operator|*
name|add
operator|,
name|symbolS
operator|*
name|sub
operator|,
name|offsetT
name|offset
operator|,
name|int
name|pcrel
operator|,
name|int
name|r_type
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|BFD_ASSEMBLER
argument_list|)
operator|||
operator|(
operator|!
name|defined
argument_list|(
name|BFD
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|OBJ_VMS
argument_list|)
operator|)
end_if

begin_decl_stmt
specifier|static
name|long
name|fixup_segment
name|PARAMS
argument_list|(
operator|(
name|fixS
operator|*
name|fixP
operator|,
name|segT
name|this_segment_type
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|relax_addressT
name|relax_align
name|PARAMS
argument_list|(
operator|(
name|relax_addressT
name|addr
operator|,
name|int
name|align
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|defined
argument_list|(
name|BFD_ASSEMBLER
argument_list|)
operator|||
operator|!
name|defined
argument_list|(
name|BFD
argument_list|)
end_if

begin_decl_stmt
specifier|static
name|fragS
modifier|*
name|chain_frchains_together_1
name|PARAMS
argument_list|(
operator|(
name|segT
operator|,
expr|struct
name|frchain
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|BFD_ASSEMBLER
end_ifdef

begin_decl_stmt
specifier|static
name|void
name|chain_frchains_together
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|segT
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|cvt_frag_to_fill
name|PARAMS
argument_list|(
operator|(
name|segT
operator|,
name|fragS
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|relax_and_size_seg
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|adjust_reloc_syms
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|write_relocs
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|write_contents
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|set_symtab
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|BFD_ASSEMBLER
argument_list|)
operator|||
operator|(
operator|!
name|defined
argument_list|(
name|BFD
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|OBJ_AOUT
argument_list|)
operator|)
end_if

begin_decl_stmt
specifier|static
name|void
name|merge_data_into_text
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|BFD_ASSEMBLER
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|BFD
argument_list|)
end_if

begin_decl_stmt
specifier|static
name|void
name|cvt_frag_to_fill
name|PARAMS
argument_list|(
operator|(
name|object_headers
operator|*
operator|,
name|segT
operator|,
name|fragS
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|remove_subsegs
name|PARAMS
argument_list|(
operator|(
name|frchainS
operator|*
operator|,
name|int
operator|,
name|fragS
operator|*
operator|*
operator|,
name|fragS
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|relax_and_size_all_segments
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  *			fix_new()  *  * Create a fixS in obstack 'notes'.  */
end_comment

begin_function
specifier|static
name|fixS
modifier|*
name|fix_new_internal
parameter_list|(
name|frag
parameter_list|,
name|where
parameter_list|,
name|size
parameter_list|,
name|add_symbol
parameter_list|,
name|sub_symbol
parameter_list|,
name|offset
parameter_list|,
name|pcrel
parameter_list|,
name|r_type
parameter_list|)
name|fragS
modifier|*
name|frag
decl_stmt|;
comment|/* Which frag? */
name|int
name|where
decl_stmt|;
comment|/* Where in that frag? */
name|int
name|size
decl_stmt|;
comment|/* 1, 2, or 4 usually. */
name|symbolS
modifier|*
name|add_symbol
decl_stmt|;
comment|/* X_add_symbol. */
name|symbolS
modifier|*
name|sub_symbol
decl_stmt|;
comment|/* X_op_symbol. */
name|offsetT
name|offset
decl_stmt|;
comment|/* X_add_number. */
name|int
name|pcrel
decl_stmt|;
comment|/* TRUE if PC-relative relocation. */
ifdef|#
directive|ifdef
name|BFD_ASSEMBLER
name|bfd_reloc_code_real_type
name|r_type
decl_stmt|;
comment|/* Relocation type */
else|#
directive|else
name|int
name|r_type
decl_stmt|;
comment|/* Relocation type */
endif|#
directive|endif
block|{
name|fixS
modifier|*
name|fixP
decl_stmt|;
name|n_fixups
operator|++
expr_stmt|;
name|fixP
operator|=
operator|(
name|fixS
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|notes
argument_list|,
sizeof|sizeof
argument_list|(
name|fixS
argument_list|)
argument_list|)
expr_stmt|;
name|fixP
operator|->
name|fx_frag
operator|=
name|frag
expr_stmt|;
name|fixP
operator|->
name|fx_where
operator|=
name|where
expr_stmt|;
name|fixP
operator|->
name|fx_size
operator|=
name|size
expr_stmt|;
comment|/* We've made fx_size a narrow field; check that it's wide enough.  */
if|if
condition|(
name|fixP
operator|->
name|fx_size
operator|!=
name|size
condition|)
block|{
name|as_bad
argument_list|(
literal|"field fx_size too small to hold %d"
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
name|fixP
operator|->
name|fx_addsy
operator|=
name|add_symbol
expr_stmt|;
name|fixP
operator|->
name|fx_subsy
operator|=
name|sub_symbol
expr_stmt|;
name|fixP
operator|->
name|fx_offset
operator|=
name|offset
expr_stmt|;
name|fixP
operator|->
name|fx_pcrel
operator|=
name|pcrel
expr_stmt|;
name|fixP
operator|->
name|fx_plt
operator|=
literal|0
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|NEED_FX_R_TYPE
argument_list|)
operator|||
name|defined
argument_list|(
name|BFD_ASSEMBLER
argument_list|)
name|fixP
operator|->
name|fx_r_type
operator|=
name|r_type
expr_stmt|;
endif|#
directive|endif
name|fixP
operator|->
name|fx_im_disp
operator|=
literal|0
expr_stmt|;
name|fixP
operator|->
name|fx_pcrel_adjust
operator|=
literal|0
expr_stmt|;
name|fixP
operator|->
name|fx_bit_fixP
operator|=
literal|0
expr_stmt|;
name|fixP
operator|->
name|fx_addnumber
operator|=
literal|0
expr_stmt|;
name|fixP
operator|->
name|fx_tcbit
operator|=
literal|0
expr_stmt|;
name|fixP
operator|->
name|fx_done
operator|=
literal|0
expr_stmt|;
name|fixP
operator|->
name|fx_no_overflow
operator|=
literal|0
expr_stmt|;
name|fixP
operator|->
name|fx_signed
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|TC_FIX_TYPE
name|TC_INIT_FIX_DATA
argument_list|(
name|fixP
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|as_where
argument_list|(
operator|&
name|fixP
operator|->
name|fx_file
argument_list|,
operator|&
name|fixP
operator|->
name|fx_line
argument_list|)
expr_stmt|;
comment|/* Usually, we want relocs sorted numerically, but while      comparing to older versions of gas that have relocs      reverse sorted, it is convenient to have this compile      time option.  xoxorich. */
block|{
ifdef|#
directive|ifdef
name|BFD_ASSEMBLER
name|fixS
modifier|*
modifier|*
name|seg_fix_rootP
init|=
operator|(
name|frags_chained
condition|?
operator|&
name|seg_info
argument_list|(
name|now_seg
argument_list|)
operator|->
name|fix_root
else|:
operator|&
name|frchain_now
operator|->
name|fix_root
operator|)
decl_stmt|;
name|fixS
modifier|*
modifier|*
name|seg_fix_tailP
init|=
operator|(
name|frags_chained
condition|?
operator|&
name|seg_info
argument_list|(
name|now_seg
argument_list|)
operator|->
name|fix_tail
else|:
operator|&
name|frchain_now
operator|->
name|fix_tail
operator|)
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|REVERSE_SORT_RELOCS
name|fixP
operator|->
name|fx_next
operator|=
operator|*
name|seg_fix_rootP
expr_stmt|;
operator|*
name|seg_fix_rootP
operator|=
name|fixP
expr_stmt|;
else|#
directive|else
comment|/* REVERSE_SORT_RELOCS */
name|fixP
operator|->
name|fx_next
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|*
name|seg_fix_tailP
condition|)
operator|(
operator|*
name|seg_fix_tailP
operator|)
operator|->
name|fx_next
operator|=
name|fixP
expr_stmt|;
else|else
operator|*
name|seg_fix_rootP
operator|=
name|fixP
expr_stmt|;
operator|*
name|seg_fix_tailP
operator|=
name|fixP
expr_stmt|;
endif|#
directive|endif
comment|/* REVERSE_SORT_RELOCS */
block|}
return|return
name|fixP
return|;
block|}
end_function

begin_comment
comment|/* Create a fixup relative to a symbol (plus a constant).  */
end_comment

begin_function
name|fixS
modifier|*
name|fix_new
parameter_list|(
name|frag
parameter_list|,
name|where
parameter_list|,
name|size
parameter_list|,
name|add_symbol
parameter_list|,
name|offset
parameter_list|,
name|pcrel
parameter_list|,
name|r_type
parameter_list|)
name|fragS
modifier|*
name|frag
decl_stmt|;
comment|/* Which frag? */
name|int
name|where
decl_stmt|;
comment|/* Where in that frag? */
name|int
name|size
decl_stmt|;
comment|/* 1, 2, or 4 usually. */
name|symbolS
modifier|*
name|add_symbol
decl_stmt|;
comment|/* X_add_symbol. */
name|offsetT
name|offset
decl_stmt|;
comment|/* X_add_number. */
name|int
name|pcrel
decl_stmt|;
comment|/* TRUE if PC-relative relocation. */
ifdef|#
directive|ifdef
name|BFD_ASSEMBLER
name|bfd_reloc_code_real_type
name|r_type
decl_stmt|;
comment|/* Relocation type */
else|#
directive|else
name|int
name|r_type
decl_stmt|;
comment|/* Relocation type */
endif|#
directive|endif
block|{
return|return
name|fix_new_internal
argument_list|(
name|frag
argument_list|,
name|where
argument_list|,
name|size
argument_list|,
name|add_symbol
argument_list|,
operator|(
name|symbolS
operator|*
operator|)
name|NULL
argument_list|,
name|offset
argument_list|,
name|pcrel
argument_list|,
name|r_type
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Create a fixup for an expression.  Currently we only support fixups    for difference expressions.  That is itself more than most object    file formats support anyhow.  */
end_comment

begin_function
name|fixS
modifier|*
name|fix_new_exp
parameter_list|(
name|frag
parameter_list|,
name|where
parameter_list|,
name|size
parameter_list|,
name|exp
parameter_list|,
name|pcrel
parameter_list|,
name|r_type
parameter_list|)
name|fragS
modifier|*
name|frag
decl_stmt|;
comment|/* Which frag? */
name|int
name|where
decl_stmt|;
comment|/* Where in that frag? */
name|int
name|size
decl_stmt|;
comment|/* 1, 2, or 4 usually. */
name|expressionS
modifier|*
name|exp
decl_stmt|;
comment|/* Expression.  */
name|int
name|pcrel
decl_stmt|;
comment|/* TRUE if PC-relative relocation. */
ifdef|#
directive|ifdef
name|BFD_ASSEMBLER
name|bfd_reloc_code_real_type
name|r_type
decl_stmt|;
comment|/* Relocation type */
else|#
directive|else
name|int
name|r_type
decl_stmt|;
comment|/* Relocation type */
endif|#
directive|endif
block|{
name|symbolS
modifier|*
name|add
init|=
name|NULL
decl_stmt|;
name|symbolS
modifier|*
name|sub
init|=
name|NULL
decl_stmt|;
name|offsetT
name|off
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|exp
operator|->
name|X_op
condition|)
block|{
case|case
name|O_absent
case|:
break|break;
case|case
name|O_add
case|:
comment|/* This comes up when _GLOBAL_OFFSET_TABLE_+(.-L0) is read, if 	 the difference expression cannot immediately be reduced.  */
block|{
name|symbolS
modifier|*
name|stmp
init|=
name|make_expr_symbol
argument_list|(
name|exp
argument_list|)
decl_stmt|;
name|exp
operator|->
name|X_op
operator|=
name|O_symbol
expr_stmt|;
name|exp
operator|->
name|X_op_symbol
operator|=
literal|0
expr_stmt|;
name|exp
operator|->
name|X_add_symbol
operator|=
name|stmp
expr_stmt|;
name|exp
operator|->
name|X_add_number
operator|=
literal|0
expr_stmt|;
return|return
name|fix_new_exp
argument_list|(
name|frag
argument_list|,
name|where
argument_list|,
name|size
argument_list|,
name|exp
argument_list|,
name|pcrel
argument_list|,
name|r_type
argument_list|)
return|;
block|}
case|case
name|O_symbol_rva
case|:
name|add
operator|=
name|exp
operator|->
name|X_add_symbol
expr_stmt|;
name|off
operator|=
name|exp
operator|->
name|X_add_number
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|BFD_ASSEMBLER
argument_list|)
name|r_type
operator|=
name|BFD_RELOC_RVA
expr_stmt|;
else|#
directive|else
if|#
directive|if
name|defined
argument_list|(
name|TC_RVA_RELOC
argument_list|)
name|r_type
operator|=
name|TC_RVA_RELOC
expr_stmt|;
else|#
directive|else
name|as_fatal
argument_list|(
literal|"rva not supported"
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
break|break;
case|case
name|O_uminus
case|:
name|sub
operator|=
name|exp
operator|->
name|X_add_symbol
expr_stmt|;
name|off
operator|=
name|exp
operator|->
name|X_add_number
expr_stmt|;
break|break;
case|case
name|O_subtract
case|:
name|sub
operator|=
name|exp
operator|->
name|X_op_symbol
expr_stmt|;
comment|/* Fall through.  */
case|case
name|O_symbol
case|:
name|add
operator|=
name|exp
operator|->
name|X_add_symbol
expr_stmt|;
comment|/* Fall through.   */
case|case
name|O_constant
case|:
name|off
operator|=
name|exp
operator|->
name|X_add_number
expr_stmt|;
break|break;
default|default:
name|add
operator|=
name|make_expr_symbol
argument_list|(
name|exp
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|fix_new_internal
argument_list|(
name|frag
argument_list|,
name|where
argument_list|,
name|size
argument_list|,
name|add
argument_list|,
name|sub
argument_list|,
name|off
argument_list|,
name|pcrel
argument_list|,
name|r_type
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Append a string onto another string, bumping the pointer along.  */
end_comment

begin_function
name|void
name|append
parameter_list|(
name|charPP
parameter_list|,
name|fromP
parameter_list|,
name|length
parameter_list|)
name|char
modifier|*
modifier|*
name|charPP
decl_stmt|;
name|char
modifier|*
name|fromP
decl_stmt|;
name|unsigned
name|long
name|length
decl_stmt|;
block|{
comment|/* Don't trust memcpy() of 0 chars. */
if|if
condition|(
name|length
operator|==
literal|0
condition|)
return|return;
name|memcpy
argument_list|(
operator|*
name|charPP
argument_list|,
name|fromP
argument_list|,
name|length
argument_list|)
expr_stmt|;
operator|*
name|charPP
operator|+=
name|length
expr_stmt|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|BFD_ASSEMBLER
end_ifndef

begin_decl_stmt
name|int
name|section_alignment
index|[
name|SEG_MAXIMUM_ORDINAL
index|]
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * This routine records the largest alignment seen for each segment.  * If the beginning of the segment is aligned on the worst-case  * boundary, all of the other alignments within it will work.  At  * least one object format really uses this info.  */
end_comment

begin_function
name|void
name|record_alignment
parameter_list|(
name|seg
parameter_list|,
name|align
parameter_list|)
comment|/* Segment to which alignment pertains */
name|segT
name|seg
decl_stmt|;
comment|/* Alignment, as a power of 2 (e.g., 1 => 2-byte boundary, 2 => 4-byte 	boundary, etc.)  */
name|int
name|align
decl_stmt|;
block|{
if|if
condition|(
name|seg
operator|==
name|absolute_section
condition|)
return|return;
ifdef|#
directive|ifdef
name|BFD_ASSEMBLER
if|if
condition|(
name|align
operator|>
name|bfd_get_section_alignment
argument_list|(
name|stdoutput
argument_list|,
name|seg
argument_list|)
condition|)
name|bfd_set_section_alignment
argument_list|(
name|stdoutput
argument_list|,
name|seg
argument_list|,
name|align
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|align
operator|>
name|section_alignment
index|[
operator|(
name|int
operator|)
name|seg
index|]
condition|)
name|section_alignment
index|[
operator|(
name|int
operator|)
name|seg
index|]
operator|=
name|align
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|BFD_ASSEMBLER
end_ifdef

begin_comment
comment|/* Reset the section indices after removing the gas created sections.  */
end_comment

begin_function
specifier|static
name|void
name|renumber_sections
parameter_list|(
name|abfd
parameter_list|,
name|sec
parameter_list|,
name|countparg
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|PTR
name|countparg
decl_stmt|;
block|{
name|int
modifier|*
name|countp
init|=
operator|(
name|int
operator|*
operator|)
name|countparg
decl_stmt|;
name|sec
operator|->
name|index
operator|=
operator|*
name|countp
expr_stmt|;
operator|++
operator|*
name|countp
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* defined (BFD_ASSEMBLER) */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|BFD_ASSEMBLER
argument_list|)
operator|||
operator|!
name|defined
argument_list|(
name|BFD
argument_list|)
end_if

begin_function
specifier|static
name|fragS
modifier|*
name|chain_frchains_together_1
parameter_list|(
name|section
parameter_list|,
name|frchp
parameter_list|)
name|segT
name|section
decl_stmt|;
name|struct
name|frchain
modifier|*
name|frchp
decl_stmt|;
block|{
name|fragS
name|dummy
decl_stmt|,
modifier|*
name|prev_frag
init|=
operator|&
name|dummy
decl_stmt|;
ifdef|#
directive|ifdef
name|BFD_ASSEMBLER
name|fixS
name|fix_dummy
decl_stmt|,
modifier|*
name|prev_fix
init|=
operator|&
name|fix_dummy
decl_stmt|;
endif|#
directive|endif
for|for
control|(
init|;
name|frchp
operator|&&
name|frchp
operator|->
name|frch_seg
operator|==
name|section
condition|;
name|frchp
operator|=
name|frchp
operator|->
name|frch_next
control|)
block|{
name|prev_frag
operator|->
name|fr_next
operator|=
name|frchp
operator|->
name|frch_root
expr_stmt|;
name|prev_frag
operator|=
name|frchp
operator|->
name|frch_last
expr_stmt|;
name|assert
argument_list|(
name|prev_frag
operator|->
name|fr_type
operator|!=
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|BFD_ASSEMBLER
if|if
condition|(
name|frchp
operator|->
name|fix_root
operator|!=
operator|(
name|fixS
operator|*
operator|)
name|NULL
condition|)
block|{
if|if
condition|(
name|seg_info
argument_list|(
name|section
argument_list|)
operator|->
name|fix_root
operator|==
operator|(
name|fixS
operator|*
operator|)
name|NULL
condition|)
name|seg_info
argument_list|(
name|section
argument_list|)
operator|->
name|fix_root
operator|=
name|frchp
operator|->
name|fix_root
expr_stmt|;
name|prev_fix
operator|->
name|fx_next
operator|=
name|frchp
operator|->
name|fix_root
expr_stmt|;
name|seg_info
argument_list|(
name|section
argument_list|)
operator|->
name|fix_tail
operator|=
name|frchp
operator|->
name|fix_tail
expr_stmt|;
name|prev_fix
operator|=
name|frchp
operator|->
name|fix_tail
expr_stmt|;
block|}
endif|#
directive|endif
block|}
name|assert
argument_list|(
name|prev_frag
operator|->
name|fr_type
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|prev_frag
operator|->
name|fr_next
operator|=
literal|0
expr_stmt|;
return|return
name|prev_frag
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|BFD_ASSEMBLER
end_ifdef

begin_function
specifier|static
name|void
name|chain_frchains_together
parameter_list|(
name|abfd
parameter_list|,
name|section
parameter_list|,
name|xxx
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
comment|/* unused */
name|segT
name|section
decl_stmt|;
name|PTR
name|xxx
decl_stmt|;
comment|/* unused */
block|{
name|segment_info_type
modifier|*
name|info
decl_stmt|;
comment|/* BFD may have introduced its own sections without using      subseg_new, so it is possible that seg_info is NULL.  */
name|info
operator|=
name|seg_info
argument_list|(
name|section
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|!=
operator|(
name|segment_info_type
operator|*
operator|)
name|NULL
condition|)
name|info
operator|->
name|frchainP
operator|->
name|frch_last
operator|=
name|chain_frchains_together_1
argument_list|(
name|section
argument_list|,
name|info
operator|->
name|frchainP
argument_list|)
expr_stmt|;
comment|/* Now that we've chained the frags together, we must add new fixups      to the segment, not to the frag chain.  */
name|frags_chained
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|BFD
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|BFD_ASSEMBLER
argument_list|)
end_if

begin_function
specifier|static
name|void
name|remove_subsegs
parameter_list|(
name|head
parameter_list|,
name|seg
parameter_list|,
name|root
parameter_list|,
name|last
parameter_list|)
name|frchainS
modifier|*
name|head
decl_stmt|;
name|int
name|seg
decl_stmt|;
name|fragS
modifier|*
modifier|*
name|root
decl_stmt|;
name|fragS
modifier|*
modifier|*
name|last
decl_stmt|;
block|{
operator|*
name|root
operator|=
name|head
operator|->
name|frch_root
expr_stmt|;
operator|*
name|last
operator|=
name|chain_frchains_together_1
argument_list|(
name|seg
argument_list|,
name|head
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* BFD */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|BFD_ASSEMBLER
argument_list|)
operator|||
operator|!
name|defined
argument_list|(
name|BFD
argument_list|)
end_if

begin_ifdef
ifdef|#
directive|ifdef
name|BFD_ASSEMBLER
end_ifdef

begin_function
specifier|static
name|void
name|cvt_frag_to_fill
parameter_list|(
name|sec
parameter_list|,
name|fragP
parameter_list|)
name|segT
name|sec
decl_stmt|;
name|fragS
modifier|*
name|fragP
decl_stmt|;
else|#
directive|else
function|static void cvt_frag_to_fill
parameter_list|(
name|headersP
parameter_list|,
name|sec
parameter_list|,
name|fragP
parameter_list|)
name|object_headers
modifier|*
name|headersP
decl_stmt|;
name|segT
name|sec
decl_stmt|;
name|fragS
modifier|*
name|fragP
decl_stmt|;
endif|#
directive|endif
block|{
switch|switch
condition|(
name|fragP
operator|->
name|fr_type
condition|)
block|{
case|case
name|rs_align
case|:
case|case
name|rs_align_code
case|:
case|case
name|rs_org
case|:
case|case
name|rs_space
case|:
ifdef|#
directive|ifdef
name|HANDLE_ALIGN
name|HANDLE_ALIGN
argument_list|(
name|fragP
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|know
argument_list|(
name|fragP
operator|->
name|fr_next
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|fragP
operator|->
name|fr_offset
operator|=
operator|(
name|fragP
operator|->
name|fr_next
operator|->
name|fr_address
operator|-
name|fragP
operator|->
name|fr_address
operator|-
name|fragP
operator|->
name|fr_fix
operator|)
operator|/
name|fragP
operator|->
name|fr_var
expr_stmt|;
if|if
condition|(
name|fragP
operator|->
name|fr_offset
operator|<
literal|0
condition|)
block|{
name|as_bad
argument_list|(
literal|"attempt to .org/.space backwards? (%ld)"
argument_list|,
operator|(
name|long
operator|)
name|fragP
operator|->
name|fr_offset
argument_list|)
expr_stmt|;
block|}
name|fragP
operator|->
name|fr_type
operator|=
name|rs_fill
expr_stmt|;
break|break;
case|case
name|rs_fill
case|:
break|break;
case|case
name|rs_machine_dependent
case|:
ifdef|#
directive|ifdef
name|BFD_ASSEMBLER
name|md_convert_frag
argument_list|(
name|stdoutput
argument_list|,
name|sec
argument_list|,
name|fragP
argument_list|)
expr_stmt|;
else|#
directive|else
name|md_convert_frag
argument_list|(
name|headersP
argument_list|,
name|sec
argument_list|,
name|fragP
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|assert
argument_list|(
name|fragP
operator|->
name|fr_next
operator|==
name|NULL
operator|||
operator|(
name|fragP
operator|->
name|fr_next
operator|->
name|fr_address
operator|-
name|fragP
operator|->
name|fr_address
operator|==
name|fragP
operator|->
name|fr_fix
operator|)
argument_list|)
expr_stmt|;
comment|/*        * After md_convert_frag, we make the frag into a ".space 0".        * Md_convert_frag() should set up any fixSs and constants        * required.        */
name|frag_wane
argument_list|(
name|fragP
argument_list|)
expr_stmt|;
break|break;
ifndef|#
directive|ifndef
name|WORKING_DOT_WORD
case|case
name|rs_broken_word
case|:
block|{
name|struct
name|broken_word
modifier|*
name|lie
decl_stmt|;
if|if
condition|(
name|fragP
operator|->
name|fr_subtype
condition|)
block|{
name|fragP
operator|->
name|fr_fix
operator|+=
name|md_short_jump_size
expr_stmt|;
for|for
control|(
name|lie
operator|=
operator|(
expr|struct
name|broken_word
operator|*
operator|)
operator|(
name|fragP
operator|->
name|fr_symbol
operator|)
init|;
name|lie
operator|&&
name|lie
operator|->
name|dispfrag
operator|==
name|fragP
condition|;
name|lie
operator|=
name|lie
operator|->
name|next_broken_word
control|)
if|if
condition|(
name|lie
operator|->
name|added
operator|==
literal|1
condition|)
name|fragP
operator|->
name|fr_fix
operator|+=
name|md_long_jump_size
expr_stmt|;
block|}
name|frag_wane
argument_list|(
name|fragP
argument_list|)
expr_stmt|;
block|}
break|break;
endif|#
directive|endif
default|default:
name|BAD_CASE
argument_list|(
name|fragP
operator|->
name|fr_type
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* defined (BFD_ASSEMBLER) || !defined (BFD) */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|BFD_ASSEMBLER
end_ifdef

begin_function
specifier|static
name|void
name|relax_and_size_seg
parameter_list|(
name|abfd
parameter_list|,
name|sec
parameter_list|,
name|xxx
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|PTR
name|xxx
decl_stmt|;
block|{
name|flagword
name|flags
decl_stmt|;
name|fragS
modifier|*
name|fragp
decl_stmt|;
name|segment_info_type
modifier|*
name|seginfo
decl_stmt|;
name|int
name|x
decl_stmt|;
name|valueT
name|size
decl_stmt|,
name|newsize
decl_stmt|;
name|subseg_change
argument_list|(
name|sec
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|flags
operator|=
name|bfd_get_section_flags
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
expr_stmt|;
name|seginfo
operator|=
name|seg_info
argument_list|(
name|sec
argument_list|)
expr_stmt|;
if|if
condition|(
name|seginfo
operator|&&
name|seginfo
operator|->
name|frchainP
condition|)
block|{
name|relax_segment
argument_list|(
name|seginfo
operator|->
name|frchainP
operator|->
name|frch_root
argument_list|,
name|sec
argument_list|)
expr_stmt|;
for|for
control|(
name|fragp
operator|=
name|seginfo
operator|->
name|frchainP
operator|->
name|frch_root
init|;
name|fragp
condition|;
name|fragp
operator|=
name|fragp
operator|->
name|fr_next
control|)
name|cvt_frag_to_fill
argument_list|(
name|sec
argument_list|,
name|fragp
argument_list|)
expr_stmt|;
for|for
control|(
name|fragp
operator|=
name|seginfo
operator|->
name|frchainP
operator|->
name|frch_root
init|;
name|fragp
operator|->
name|fr_next
condition|;
name|fragp
operator|=
name|fragp
operator|->
name|fr_next
control|)
comment|/* walk to last elt */
empty_stmt|;
name|size
operator|=
name|fragp
operator|->
name|fr_address
operator|+
name|fragp
operator|->
name|fr_fix
expr_stmt|;
block|}
else|else
name|size
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|size
operator|>
literal|0
operator|&&
operator|!
name|seginfo
operator|->
name|bss
condition|)
name|flags
operator||=
name|SEC_HAS_CONTENTS
expr_stmt|;
comment|/* @@ This is just an approximation.  */
if|if
condition|(
name|seginfo
operator|&&
name|seginfo
operator|->
name|fix_root
condition|)
name|flags
operator||=
name|SEC_RELOC
expr_stmt|;
else|else
name|flags
operator|&=
operator|~
name|SEC_RELOC
expr_stmt|;
name|x
operator|=
name|bfd_set_section_flags
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|x
operator|==
name|true
argument_list|)
expr_stmt|;
name|newsize
operator|=
name|md_section_align
argument_list|(
name|sec
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|x
operator|=
name|bfd_set_section_size
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|newsize
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|x
operator|==
name|true
argument_list|)
expr_stmt|;
comment|/* If the size had to be rounded up, add some padding in the last      non-empty frag.  */
name|assert
argument_list|(
name|newsize
operator|>=
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|!=
name|newsize
condition|)
block|{
name|fragS
modifier|*
name|last
init|=
name|seginfo
operator|->
name|frchainP
operator|->
name|frch_last
decl_stmt|;
name|fragp
operator|=
name|seginfo
operator|->
name|frchainP
operator|->
name|frch_root
expr_stmt|;
while|while
condition|(
name|fragp
operator|->
name|fr_next
operator|!=
name|last
condition|)
name|fragp
operator|=
name|fragp
operator|->
name|fr_next
expr_stmt|;
name|last
operator|->
name|fr_address
operator|=
name|size
expr_stmt|;
name|fragp
operator|->
name|fr_offset
operator|+=
name|newsize
operator|-
name|size
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|tc_frob_section
name|tc_frob_section
argument_list|(
name|sec
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|obj_frob_section
name|obj_frob_section
argument_list|(
name|sec
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG2
end_ifdef

begin_function
specifier|static
name|void
name|dump_section_relocs
parameter_list|(
name|abfd
parameter_list|,
name|sec
parameter_list|,
name|stream_
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|char
modifier|*
name|stream_
decl_stmt|;
block|{
name|FILE
modifier|*
name|stream
init|=
operator|(
name|FILE
operator|*
operator|)
name|stream_
decl_stmt|;
name|segment_info_type
modifier|*
name|seginfo
init|=
name|seg_info
argument_list|(
name|sec
argument_list|)
decl_stmt|;
name|fixS
modifier|*
name|fixp
init|=
name|seginfo
operator|->
name|fix_root
decl_stmt|;
if|if
condition|(
operator|!
name|fixp
condition|)
return|return;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"sec %s relocs:\n"
argument_list|,
name|sec
operator|->
name|name
argument_list|)
expr_stmt|;
while|while
condition|(
name|fixp
condition|)
block|{
name|symbolS
modifier|*
name|s
init|=
name|fixp
operator|->
name|fx_addsy
decl_stmt|;
if|if
condition|(
name|s
condition|)
block|{
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"  %08x: %s(%s"
argument_list|,
name|fixp
argument_list|,
name|S_GET_NAME
argument_list|(
name|s
argument_list|)
argument_list|,
name|s
operator|->
name|bsym
operator|->
name|section
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|bsym
operator|->
name|flags
operator|&
name|BSF_SECTION_SYM
condition|)
block|{
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|" section sym"
argument_list|)
expr_stmt|;
if|if
condition|(
name|S_GET_VALUE
argument_list|(
name|s
argument_list|)
condition|)
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"+%x"
argument_list|,
name|S_GET_VALUE
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"+%x"
argument_list|,
name|S_GET_VALUE
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|")+%x\n"
argument_list|,
name|fixp
operator|->
name|fx_offset
argument_list|)
expr_stmt|;
block|}
else|else
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"  %08x: type %d no sym\n"
argument_list|,
name|fixp
argument_list|,
name|fixp
operator|->
name|fx_r_type
argument_list|)
expr_stmt|;
name|fixp
operator|=
name|fixp
operator|->
name|fx_next
expr_stmt|;
block|}
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|dump_section_relocs
parameter_list|(
name|ABFD
parameter_list|,
name|SEC
parameter_list|,
name|STREAM
parameter_list|)
value|((void) 0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|EMIT_SECTION_SYMBOLS
end_ifndef

begin_define
define|#
directive|define
name|EMIT_SECTION_SYMBOLS
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|adjust_reloc_syms
parameter_list|(
name|abfd
parameter_list|,
name|sec
parameter_list|,
name|xxx
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|PTR
name|xxx
decl_stmt|;
block|{
name|segment_info_type
modifier|*
name|seginfo
init|=
name|seg_info
argument_list|(
name|sec
argument_list|)
decl_stmt|;
name|fixS
modifier|*
name|fixp
decl_stmt|;
if|if
condition|(
name|seginfo
operator|==
name|NULL
condition|)
return|return;
name|dump_section_relocs
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
for|for
control|(
name|fixp
operator|=
name|seginfo
operator|->
name|fix_root
init|;
name|fixp
condition|;
name|fixp
operator|=
name|fixp
operator|->
name|fx_next
control|)
if|if
condition|(
name|fixp
operator|->
name|fx_done
condition|)
comment|/* ignore it */
empty_stmt|;
elseif|else
if|if
condition|(
name|fixp
operator|->
name|fx_addsy
condition|)
block|{
name|symbolS
modifier|*
name|sym
decl_stmt|;
name|asection
modifier|*
name|symsec
decl_stmt|;
name|reduce_fixup
label|:
ifdef|#
directive|ifdef
name|DEBUG5
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n\nadjusting fixup:\n"
argument_list|)
expr_stmt|;
name|print_fixup
argument_list|(
name|fixp
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sym
operator|=
name|fixp
operator|->
name|fx_addsy
expr_stmt|;
comment|/* All symbols should have already been resolved at this 	   point.  It is possible to see unresolved expression 	   symbols, though, since they are not in the regular symbol 	   table.  */
if|if
condition|(
name|sym
operator|!=
name|NULL
operator|&&
operator|!
name|sym
operator|->
name|sy_resolved
condition|)
name|resolve_symbol_value
argument_list|(
name|sym
argument_list|)
expr_stmt|;
if|if
condition|(
name|fixp
operator|->
name|fx_subsy
operator|!=
name|NULL
operator|&&
operator|!
name|fixp
operator|->
name|fx_subsy
operator|->
name|sy_resolved
condition|)
name|resolve_symbol_value
argument_list|(
name|fixp
operator|->
name|fx_subsy
argument_list|)
expr_stmt|;
comment|/* If this symbol is equated to an undefined symbol, convert            the fixup to being against that symbol.  */
if|if
condition|(
name|sym
operator|->
name|sy_value
operator|.
name|X_op
operator|==
name|O_symbol
operator|&&
operator|(
operator|!
name|S_IS_DEFINED
argument_list|(
name|sym
argument_list|)
operator|||
name|S_IS_COMMON
argument_list|(
name|sym
argument_list|)
operator|)
condition|)
block|{
name|fixp
operator|->
name|fx_offset
operator|+=
name|sym
operator|->
name|sy_value
operator|.
name|X_add_number
expr_stmt|;
name|sym
operator|=
name|sym
operator|->
name|sy_value
operator|.
name|X_add_symbol
expr_stmt|;
name|fixp
operator|->
name|fx_addsy
operator|=
name|sym
expr_stmt|;
block|}
name|symsec
operator|=
name|S_GET_SEGMENT
argument_list|(
name|sym
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
operator|!=
name|NULL
operator|&&
name|sym
operator|->
name|sy_mri_common
condition|)
block|{
comment|/* These symbols are handled specially in fixup_segment.  */
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|bfd_is_abs_section
argument_list|(
name|symsec
argument_list|)
condition|)
block|{
comment|/* The fixup_segment routine will not use this symbol in a                relocation unless TC_FORCE_RELOCATION returns 1.  */
if|if
condition|(
name|TC_FORCE_RELOCATION
argument_list|(
name|fixp
argument_list|)
condition|)
block|{
name|fixp
operator|->
name|fx_addsy
operator|->
name|sy_used_in_reloc
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|UNDEFINED_DIFFERENCE_OK
if|if
condition|(
name|fixp
operator|->
name|fx_subsy
operator|!=
name|NULL
condition|)
name|fixp
operator|->
name|fx_subsy
operator|->
name|sy_used_in_reloc
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
block|}
goto|goto
name|done
goto|;
block|}
comment|/* If it's one of these sections, assume the symbol is 	   definitely going to be output.  The code in 	   md_estimate_size_before_relax in tc-mips.c uses this test 	   as well, so if you change this code you should look at that 	   code.  */
if|if
condition|(
name|bfd_is_und_section
argument_list|(
name|symsec
argument_list|)
operator|||
name|bfd_is_com_section
argument_list|(
name|symsec
argument_list|)
condition|)
block|{
name|fixp
operator|->
name|fx_addsy
operator|->
name|sy_used_in_reloc
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|UNDEFINED_DIFFERENCE_OK
comment|/* We have the difference of an undefined symbol and some 	       other symbol.  Make sure to mark the other symbol as used 	       in a relocation so that it will always be output.  */
if|if
condition|(
name|fixp
operator|->
name|fx_subsy
condition|)
name|fixp
operator|->
name|fx_subsy
operator|->
name|sy_used_in_reloc
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
goto|goto
name|done
goto|;
block|}
comment|/* Don't try to reduce relocs which refer to .linkonce            sections.  It can lead to confusion when a debugging            section refers to a .linkonce section.  I hope this will            always be correct.  */
if|if
condition|(
name|symsec
operator|!=
name|sec
condition|)
block|{
name|boolean
name|linkonce
decl_stmt|;
name|linkonce
operator|=
name|false
expr_stmt|;
ifdef|#
directive|ifdef
name|BFD_ASSEMBLER
if|if
condition|(
operator|(
name|bfd_get_section_flags
argument_list|(
name|stdoutput
argument_list|,
name|symsec
argument_list|)
operator|&
name|SEC_LINK_ONCE
operator|)
operator|!=
literal|0
condition|)
name|linkonce
operator|=
name|true
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|OBJ_ELF
comment|/* The GNU toolchain uses an extension for ELF: a section                beginning with the magic string .gnu.linkonce is a                linkonce section.  */
if|if
condition|(
name|strncmp
argument_list|(
name|segment_name
argument_list|(
name|symsec
argument_list|)
argument_list|,
literal|".gnu.linkonce"
argument_list|,
sizeof|sizeof
expr|".gnu.linkonce"
operator|-
literal|1
argument_list|)
operator|==
literal|0
condition|)
name|linkonce
operator|=
name|true
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|linkonce
condition|)
block|{
name|fixp
operator|->
name|fx_addsy
operator|->
name|sy_used_in_reloc
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|UNDEFINED_DIFFERENCE_OK
if|if
condition|(
name|fixp
operator|->
name|fx_subsy
operator|!=
name|NULL
condition|)
name|fixp
operator|->
name|fx_subsy
operator|->
name|sy_used_in_reloc
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
goto|goto
name|done
goto|;
block|}
block|}
comment|/* Since we're reducing to section symbols, don't attempt to reduce 	   anything that's already using one.  */
if|if
condition|(
name|sym
operator|->
name|bsym
operator|->
name|flags
operator|&
name|BSF_SECTION_SYM
condition|)
block|{
name|fixp
operator|->
name|fx_addsy
operator|->
name|sy_used_in_reloc
operator|=
literal|1
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* Is there some other reason we can't adjust this one?  (E.g., 	   call/bal links in i960-bout symbols.)  */
ifdef|#
directive|ifdef
name|obj_fix_adjustable
if|if
condition|(
operator|!
name|obj_fix_adjustable
argument_list|(
name|fixp
argument_list|)
condition|)
block|{
name|fixp
operator|->
name|fx_addsy
operator|->
name|sy_used_in_reloc
operator|=
literal|1
expr_stmt|;
goto|goto
name|done
goto|;
block|}
endif|#
directive|endif
comment|/* Is there some other (target cpu dependent) reason we can't adjust 	   this one?  (E.g. relocations involving function addresses on 	   the PA.  */
ifdef|#
directive|ifdef
name|tc_fix_adjustable
if|if
condition|(
operator|!
name|tc_fix_adjustable
argument_list|(
name|fixp
argument_list|)
condition|)
block|{
name|fixp
operator|->
name|fx_addsy
operator|->
name|sy_used_in_reloc
operator|=
literal|1
expr_stmt|;
goto|goto
name|done
goto|;
block|}
endif|#
directive|endif
comment|/* If the section symbol isn't going to be output, the relocs 	   at least should still work.  If not, figure out what to do 	   when we run into that case.  	   We refetch the segment when calling section_symbol, rather 	   than using symsec, because S_GET_VALUE may wind up changing 	   the section when it calls resolve_symbol_value. */
name|fixp
operator|->
name|fx_offset
operator|+=
name|S_GET_VALUE
argument_list|(
name|sym
argument_list|)
expr_stmt|;
name|fixp
operator|->
name|fx_addsy
operator|=
name|section_symbol
argument_list|(
name|S_GET_SEGMENT
argument_list|(
name|sym
argument_list|)
argument_list|)
expr_stmt|;
name|fixp
operator|->
name|fx_addsy
operator|->
name|sy_used_in_reloc
operator|=
literal|1
expr_stmt|;
name|done
label|:
empty_stmt|;
block|}
if|#
directive|if
literal|1
comment|/*def RELOC_REQUIRES_SYMBOL*/
else|else
block|{
comment|/* There was no symbol required by this relocation.  However, 	   BFD doesn't really handle relocations without symbols well. 	   (At least, the COFF support doesn't.)  So for now we fake up 	   a local symbol in the absolute section.  */
name|fixp
operator|->
name|fx_addsy
operator|=
name|section_symbol
argument_list|(
name|absolute_section
argument_list|)
expr_stmt|;
comment|/*	fixp->fx_addsy->sy_used_in_reloc = 1; */
block|}
endif|#
directive|endif
name|dump_section_relocs
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|write_relocs
parameter_list|(
name|abfd
parameter_list|,
name|sec
parameter_list|,
name|xxx
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|PTR
name|xxx
decl_stmt|;
block|{
name|segment_info_type
modifier|*
name|seginfo
init|=
name|seg_info
argument_list|(
name|sec
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
name|unsigned
name|int
name|n
decl_stmt|;
name|arelent
modifier|*
modifier|*
name|relocs
decl_stmt|;
name|fixS
modifier|*
name|fixp
decl_stmt|;
name|char
modifier|*
name|err
decl_stmt|;
comment|/* If seginfo is NULL, we did not create this section; don't do      anything with it.  */
if|if
condition|(
name|seginfo
operator|==
name|NULL
condition|)
return|return;
name|fixup_segment
argument_list|(
name|seginfo
operator|->
name|fix_root
argument_list|,
name|sec
argument_list|)
expr_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|fixp
operator|=
name|seginfo
operator|->
name|fix_root
init|;
name|fixp
condition|;
name|fixp
operator|=
name|fixp
operator|->
name|fx_next
control|)
name|n
operator|++
expr_stmt|;
ifndef|#
directive|ifndef
name|RELOC_EXPANSION_POSSIBLE
comment|/* Set up reloc information as well.  */
name|relocs
operator|=
operator|(
name|arelent
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|n
operator|*
sizeof|sizeof
argument_list|(
name|arelent
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|relocs
argument_list|,
literal|0
argument_list|,
name|n
operator|*
sizeof|sizeof
argument_list|(
name|arelent
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|fixp
operator|=
name|seginfo
operator|->
name|fix_root
init|;
name|fixp
operator|!=
operator|(
name|fixS
operator|*
operator|)
name|NULL
condition|;
name|fixp
operator|=
name|fixp
operator|->
name|fx_next
control|)
block|{
name|arelent
modifier|*
name|reloc
decl_stmt|;
name|bfd_reloc_status_type
name|s
decl_stmt|;
name|symbolS
modifier|*
name|sym
decl_stmt|;
if|if
condition|(
name|fixp
operator|->
name|fx_done
condition|)
block|{
name|n
operator|--
expr_stmt|;
continue|continue;
block|}
comment|/* If this is an undefined symbol which was equated to another          symbol, then use generate the reloc against the latter symbol          rather than the former.  */
name|sym
operator|=
name|fixp
operator|->
name|fx_addsy
expr_stmt|;
while|while
condition|(
name|sym
operator|->
name|sy_value
operator|.
name|X_op
operator|==
name|O_symbol
operator|&&
operator|(
operator|!
name|S_IS_DEFINED
argument_list|(
name|sym
argument_list|)
operator|||
name|S_IS_COMMON
argument_list|(
name|sym
argument_list|)
operator|)
condition|)
block|{
name|symbolS
modifier|*
name|n
decl_stmt|;
comment|/* We must avoid looping, as that can occur with a badly 	     written program.  */
name|n
operator|=
name|sym
operator|->
name|sy_value
operator|.
name|X_add_symbol
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|sym
condition|)
break|break;
name|fixp
operator|->
name|fx_offset
operator|+=
name|sym
operator|->
name|sy_value
operator|.
name|X_add_number
expr_stmt|;
name|sym
operator|=
name|n
expr_stmt|;
block|}
name|fixp
operator|->
name|fx_addsy
operator|=
name|sym
expr_stmt|;
name|reloc
operator|=
name|tc_gen_reloc
argument_list|(
name|sec
argument_list|,
name|fixp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|reloc
condition|)
block|{
name|n
operator|--
expr_stmt|;
continue|continue;
block|}
if|#
directive|if
literal|0
comment|/* This test is triggered inappropriately for the SH.  */
block|if (fixp->fx_where + fixp->fx_size> fixp->fx_frag->fr_fix + fixp->fx_frag->fr_offset) 	abort ();
endif|#
directive|endif
name|s
operator|=
name|bfd_install_relocation
argument_list|(
name|stdoutput
argument_list|,
name|reloc
argument_list|,
name|fixp
operator|->
name|fx_frag
operator|->
name|fr_literal
argument_list|,
name|fixp
operator|->
name|fx_frag
operator|->
name|fr_address
argument_list|,
name|sec
argument_list|,
operator|&
name|err
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|s
condition|)
block|{
case|case
name|bfd_reloc_ok
case|:
break|break;
case|case
name|bfd_reloc_overflow
case|:
name|as_bad_where
argument_list|(
name|fixp
operator|->
name|fx_file
argument_list|,
name|fixp
operator|->
name|fx_line
argument_list|,
literal|"relocation overflow"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|as_fatal
argument_list|(
literal|"%s:%u: bad return from bfd_install_relocation"
argument_list|,
name|fixp
operator|->
name|fx_file
argument_list|,
name|fixp
operator|->
name|fx_line
argument_list|)
expr_stmt|;
block|}
name|relocs
index|[
name|i
operator|++
index|]
operator|=
name|reloc
expr_stmt|;
block|}
else|#
directive|else
name|n
operator|=
name|n
operator|*
name|MAX_RELOC_EXPANSION
expr_stmt|;
comment|/* Set up reloc information as well.  */
name|relocs
operator|=
operator|(
name|arelent
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|n
operator|*
sizeof|sizeof
argument_list|(
name|arelent
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|fixp
operator|=
name|seginfo
operator|->
name|fix_root
init|;
name|fixp
operator|!=
operator|(
name|fixS
operator|*
operator|)
name|NULL
condition|;
name|fixp
operator|=
name|fixp
operator|->
name|fx_next
control|)
block|{
name|arelent
modifier|*
modifier|*
name|reloc
decl_stmt|;
name|char
modifier|*
name|data
decl_stmt|;
name|bfd_reloc_status_type
name|s
decl_stmt|;
name|symbolS
modifier|*
name|sym
decl_stmt|;
name|int
name|j
decl_stmt|;
if|if
condition|(
name|fixp
operator|->
name|fx_done
condition|)
block|{
name|n
operator|--
expr_stmt|;
continue|continue;
block|}
comment|/* If this is an undefined symbol which was equated to another          symbol, then use generate the reloc against the latter symbol          rather than the former.  */
name|sym
operator|=
name|fixp
operator|->
name|fx_addsy
expr_stmt|;
while|while
condition|(
name|sym
operator|->
name|sy_value
operator|.
name|X_op
operator|==
name|O_symbol
operator|&&
operator|(
operator|!
name|S_IS_DEFINED
argument_list|(
name|sym
argument_list|)
operator|||
name|S_IS_COMMON
argument_list|(
name|sym
argument_list|)
operator|)
condition|)
name|sym
operator|=
name|sym
operator|->
name|sy_value
operator|.
name|X_add_symbol
expr_stmt|;
name|fixp
operator|->
name|fx_addsy
operator|=
name|sym
expr_stmt|;
name|reloc
operator|=
name|tc_gen_reloc
argument_list|(
name|sec
argument_list|,
name|fixp
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|reloc
index|[
name|j
index|]
condition|;
name|j
operator|++
control|)
block|{
name|relocs
index|[
name|i
operator|++
index|]
operator|=
name|reloc
index|[
name|j
index|]
expr_stmt|;
name|assert
argument_list|(
name|i
operator|<=
name|n
argument_list|)
expr_stmt|;
block|}
name|data
operator|=
name|fixp
operator|->
name|fx_frag
operator|->
name|fr_literal
operator|+
name|fixp
operator|->
name|fx_where
expr_stmt|;
if|if
condition|(
name|fixp
operator|->
name|fx_where
operator|+
name|fixp
operator|->
name|fx_size
operator|>
name|fixp
operator|->
name|fx_frag
operator|->
name|fr_fix
operator|+
name|fixp
operator|->
name|fx_frag
operator|->
name|fr_offset
condition|)
name|as_bad_where
argument_list|(
name|fixp
operator|->
name|fx_file
argument_list|,
name|fixp
operator|->
name|fx_line
argument_list|,
literal|"internal error: fixup not contained within frag"
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|reloc
index|[
name|j
index|]
condition|;
name|j
operator|++
control|)
block|{
name|s
operator|=
name|bfd_install_relocation
argument_list|(
name|stdoutput
argument_list|,
name|reloc
index|[
name|j
index|]
argument_list|,
name|fixp
operator|->
name|fx_frag
operator|->
name|fr_literal
argument_list|,
name|fixp
operator|->
name|fx_frag
operator|->
name|fr_address
argument_list|,
name|sec
argument_list|,
operator|&
name|err
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|s
condition|)
block|{
case|case
name|bfd_reloc_ok
case|:
break|break;
case|case
name|bfd_reloc_overflow
case|:
name|as_bad_where
argument_list|(
name|fixp
operator|->
name|fx_file
argument_list|,
name|fixp
operator|->
name|fx_line
argument_list|,
literal|"relocation overflow"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|as_fatal
argument_list|(
literal|"%s:%u: bad return from bfd_install_relocation"
argument_list|,
name|fixp
operator|->
name|fx_file
argument_list|,
name|fixp
operator|->
name|fx_line
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|n
operator|=
name|i
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DEBUG4
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|nsyms
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|sympp
decl_stmt|;
name|sympp
operator|=
name|bfd_get_outsymbols
argument_list|(
name|stdoutput
argument_list|)
expr_stmt|;
name|nsyms
operator|=
name|bfd_get_symcount
argument_list|(
name|stdoutput
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
operator|(
operator|*
name|relocs
index|[
name|i
index|]
operator|->
name|sym_ptr_ptr
operator|)
operator|->
name|flags
operator|&
name|BSF_SECTION_SYM
operator|)
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|nsyms
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|sympp
index|[
name|j
index|]
operator|==
operator|*
name|relocs
index|[
name|i
index|]
operator|->
name|sym_ptr_ptr
condition|)
break|break;
if|if
condition|(
name|j
operator|==
name|nsyms
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
endif|#
directive|endif
if|if
condition|(
name|n
condition|)
name|bfd_set_reloc
argument_list|(
name|stdoutput
argument_list|,
name|sec
argument_list|,
name|relocs
argument_list|,
name|n
argument_list|)
expr_stmt|;
else|else
name|bfd_set_section_flags
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
operator|(
name|bfd_get_section_flags
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
operator|&
operator|(
name|flagword
operator|)
operator|~
name|SEC_RELOC
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG3
block|{
name|int
name|i
decl_stmt|;
name|arelent
modifier|*
name|r
decl_stmt|;
name|asymbol
modifier|*
name|s
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"relocs for sec %s\n"
argument_list|,
name|sec
operator|->
name|name
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|r
operator|=
name|relocs
index|[
name|i
index|]
expr_stmt|;
name|s
operator|=
operator|*
name|r
operator|->
name|sym_ptr_ptr
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  reloc %2d @%08x off %4x : sym %-10s addend %x\n"
argument_list|,
name|i
argument_list|,
name|r
argument_list|,
name|r
operator|->
name|address
argument_list|,
name|s
operator|->
name|name
argument_list|,
name|r
operator|->
name|addend
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|write_contents
parameter_list|(
name|abfd
parameter_list|,
name|sec
parameter_list|,
name|xxx
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|PTR
name|xxx
decl_stmt|;
block|{
name|segment_info_type
modifier|*
name|seginfo
init|=
name|seg_info
argument_list|(
name|sec
argument_list|)
decl_stmt|;
name|unsigned
name|long
name|offset
init|=
literal|0
decl_stmt|;
name|fragS
modifier|*
name|f
decl_stmt|;
comment|/* Write out the frags.  */
if|if
condition|(
name|seginfo
operator|==
name|NULL
operator|||
operator|!
operator|(
name|bfd_get_section_flags
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
operator|&
name|SEC_HAS_CONTENTS
operator|)
condition|)
return|return;
for|for
control|(
name|f
operator|=
name|seginfo
operator|->
name|frchainP
operator|->
name|frch_root
init|;
name|f
condition|;
name|f
operator|=
name|f
operator|->
name|fr_next
control|)
block|{
name|int
name|x
decl_stmt|;
name|unsigned
name|long
name|fill_size
decl_stmt|;
name|char
modifier|*
name|fill_literal
decl_stmt|;
name|long
name|count
decl_stmt|;
name|assert
argument_list|(
name|f
operator|->
name|fr_type
operator|==
name|rs_fill
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|->
name|fr_fix
condition|)
block|{
name|x
operator|=
name|bfd_set_section_contents
argument_list|(
name|stdoutput
argument_list|,
name|sec
argument_list|,
name|f
operator|->
name|fr_literal
argument_list|,
operator|(
name|file_ptr
operator|)
name|offset
argument_list|,
operator|(
name|bfd_size_type
operator|)
name|f
operator|->
name|fr_fix
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|==
name|false
condition|)
block|{
name|bfd_perror
argument_list|(
name|stdoutput
operator|->
name|filename
argument_list|)
expr_stmt|;
name|as_perror
argument_list|(
literal|"FATAL: Can't write %s"
argument_list|,
name|stdoutput
operator|->
name|filename
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
name|offset
operator|+=
name|f
operator|->
name|fr_fix
expr_stmt|;
block|}
name|fill_literal
operator|=
name|f
operator|->
name|fr_literal
operator|+
name|f
operator|->
name|fr_fix
expr_stmt|;
name|fill_size
operator|=
name|f
operator|->
name|fr_var
expr_stmt|;
name|count
operator|=
name|f
operator|->
name|fr_offset
expr_stmt|;
name|assert
argument_list|(
name|count
operator|>=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|fill_size
operator|&&
name|count
condition|)
block|{
name|char
name|buf
index|[
literal|256
index|]
decl_stmt|;
if|if
condition|(
name|fill_size
operator|>
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
condition|)
block|{
comment|/* Do it the old way. Can this ever happen? */
while|while
condition|(
name|count
operator|--
condition|)
block|{
name|x
operator|=
name|bfd_set_section_contents
argument_list|(
name|stdoutput
argument_list|,
name|sec
argument_list|,
name|fill_literal
argument_list|,
operator|(
name|file_ptr
operator|)
name|offset
argument_list|,
operator|(
name|bfd_size_type
operator|)
name|fill_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|==
name|false
condition|)
block|{
name|bfd_perror
argument_list|(
name|stdoutput
operator|->
name|filename
argument_list|)
expr_stmt|;
name|as_perror
argument_list|(
literal|"FATAL: Can't write %s"
argument_list|,
name|stdoutput
operator|->
name|filename
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
name|offset
operator|+=
name|fill_size
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Build a buffer full of fill objects and output it as 		 often as necessary. This saves on the overhead of 		 potentially lots of bfd_set_section_contents calls.  */
name|int
name|n_per_buf
decl_stmt|,
name|i
decl_stmt|;
if|if
condition|(
name|fill_size
operator|==
literal|1
condition|)
block|{
name|n_per_buf
operator|=
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|buf
argument_list|,
operator|*
name|fill_literal
argument_list|,
name|n_per_buf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|char
modifier|*
name|bufp
decl_stmt|;
name|n_per_buf
operator|=
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
operator|/
name|fill_size
expr_stmt|;
for|for
control|(
name|i
operator|=
name|n_per_buf
operator|,
name|bufp
operator|=
name|buf
init|;
name|i
condition|;
name|i
operator|--
operator|,
name|bufp
operator|+=
name|fill_size
control|)
name|memcpy
argument_list|(
name|bufp
argument_list|,
name|fill_literal
argument_list|,
name|fill_size
argument_list|)
expr_stmt|;
block|}
for|for
control|(
init|;
name|count
operator|>
literal|0
condition|;
name|count
operator|-=
name|n_per_buf
control|)
block|{
name|n_per_buf
operator|=
name|n_per_buf
operator|>
name|count
condition|?
name|count
else|:
name|n_per_buf
expr_stmt|;
name|x
operator|=
name|bfd_set_section_contents
argument_list|(
name|stdoutput
argument_list|,
name|sec
argument_list|,
name|buf
argument_list|,
operator|(
name|file_ptr
operator|)
name|offset
argument_list|,
operator|(
name|bfd_size_type
operator|)
name|n_per_buf
operator|*
name|fill_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|!=
name|true
condition|)
name|as_fatal
argument_list|(
literal|"Cannot write to output file."
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|n_per_buf
operator|*
name|fill_size
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|BFD_ASSEMBLER
argument_list|)
operator|||
operator|(
operator|!
name|defined
argument_list|(
name|BFD
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|OBJ_AOUT
argument_list|)
operator|)
end_if

begin_function
specifier|static
name|void
name|merge_data_into_text
parameter_list|()
block|{
if|#
directive|if
name|defined
argument_list|(
name|BFD_ASSEMBLER
argument_list|)
operator|||
name|defined
argument_list|(
name|MANY_SEGMENTS
argument_list|)
name|seg_info
argument_list|(
name|text_section
argument_list|)
operator|->
name|frchainP
operator|->
name|frch_last
operator|->
name|fr_next
operator|=
name|seg_info
argument_list|(
name|data_section
argument_list|)
operator|->
name|frchainP
operator|->
name|frch_root
expr_stmt|;
name|seg_info
argument_list|(
name|text_section
argument_list|)
operator|->
name|frchainP
operator|->
name|frch_last
operator|=
name|seg_info
argument_list|(
name|data_section
argument_list|)
operator|->
name|frchainP
operator|->
name|frch_last
expr_stmt|;
name|seg_info
argument_list|(
name|data_section
argument_list|)
operator|->
name|frchainP
operator|=
literal|0
expr_stmt|;
else|#
directive|else
name|fixS
modifier|*
name|tmp
decl_stmt|;
name|text_last_frag
operator|->
name|fr_next
operator|=
name|data_frag_root
expr_stmt|;
name|text_last_frag
operator|=
name|data_last_frag
expr_stmt|;
name|data_last_frag
operator|=
name|NULL
expr_stmt|;
name|data_frag_root
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|text_fix_root
condition|)
block|{
for|for
control|(
name|tmp
operator|=
name|text_fix_root
init|;
name|tmp
operator|->
name|fx_next
condition|;
name|tmp
operator|=
name|tmp
operator|->
name|fx_next
control|)
empty_stmt|;
empty_stmt|;
name|tmp
operator|->
name|fx_next
operator|=
name|data_fix_root
expr_stmt|;
name|text_fix_tail
operator|=
name|data_fix_tail
expr_stmt|;
block|}
else|else
name|text_fix_root
operator|=
name|data_fix_root
expr_stmt|;
name|data_fix_root
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* BFD_ASSEMBLER || (! BFD&& ! OBJ_AOUT) */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|BFD_ASSEMBLER
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|BFD
argument_list|)
end_if

begin_function
specifier|static
name|void
name|relax_and_size_all_segments
parameter_list|()
block|{
name|fragS
modifier|*
name|fragP
decl_stmt|;
name|relax_segment
argument_list|(
name|text_frag_root
argument_list|,
name|SEG_TEXT
argument_list|)
expr_stmt|;
name|relax_segment
argument_list|(
name|data_frag_root
argument_list|,
name|SEG_DATA
argument_list|)
expr_stmt|;
name|relax_segment
argument_list|(
name|bss_frag_root
argument_list|,
name|SEG_BSS
argument_list|)
expr_stmt|;
comment|/*    * Now the addresses of frags are correct within the segment.    */
name|know
argument_list|(
name|text_last_frag
operator|->
name|fr_type
operator|==
name|rs_fill
operator|&&
name|text_last_frag
operator|->
name|fr_offset
operator|==
literal|0
argument_list|)
expr_stmt|;
name|H_SET_TEXT_SIZE
argument_list|(
operator|&
name|headers
argument_list|,
name|text_last_frag
operator|->
name|fr_address
argument_list|)
expr_stmt|;
name|text_last_frag
operator|->
name|fr_address
operator|=
name|H_GET_TEXT_SIZE
argument_list|(
operator|&
name|headers
argument_list|)
expr_stmt|;
comment|/*    * Join the 2 segments into 1 huge segment.    * To do this, re-compute every rn_address in the SEG_DATA frags.    * Then join the data frags after the text frags.    *    * Determine a_data [length of data segment].    */
if|if
condition|(
name|data_frag_root
condition|)
block|{
specifier|register
name|relax_addressT
name|slide
decl_stmt|;
name|know
argument_list|(
operator|(
name|text_last_frag
operator|->
name|fr_type
operator|==
name|rs_fill
operator|)
operator|&&
operator|(
name|text_last_frag
operator|->
name|fr_offset
operator|==
literal|0
operator|)
argument_list|)
expr_stmt|;
name|H_SET_DATA_SIZE
argument_list|(
operator|&
name|headers
argument_list|,
name|data_last_frag
operator|->
name|fr_address
argument_list|)
expr_stmt|;
name|data_last_frag
operator|->
name|fr_address
operator|=
name|H_GET_DATA_SIZE
argument_list|(
operator|&
name|headers
argument_list|)
expr_stmt|;
name|slide
operator|=
name|H_GET_TEXT_SIZE
argument_list|(
operator|&
name|headers
argument_list|)
expr_stmt|;
comment|/*& in file of the data segment. */
ifdef|#
directive|ifdef
name|OBJ_BOUT
define|#
directive|define
name|RoundUp
parameter_list|(
name|N
parameter_list|,
name|S
parameter_list|)
value|(((N)+(S)-1)&-(S))
comment|/* For b.out: If the data section has a strict alignment 	 requirement, its load address in the .o file will be 	 rounded up from the size of the text section.  These 	 two values are *not* the same!  Similarly for the bss 	 section....  */
name|slide
operator|=
name|RoundUp
argument_list|(
name|slide
argument_list|,
literal|1
operator|<<
name|section_alignment
index|[
name|SEG_DATA
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|fragP
operator|=
name|data_frag_root
init|;
name|fragP
condition|;
name|fragP
operator|=
name|fragP
operator|->
name|fr_next
control|)
block|{
name|fragP
operator|->
name|fr_address
operator|+=
name|slide
expr_stmt|;
block|}
comment|/* for each data frag */
name|know
argument_list|(
name|text_last_frag
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|text_last_frag
operator|->
name|fr_next
operator|=
name|data_frag_root
expr_stmt|;
block|}
else|else
block|{
name|H_SET_DATA_SIZE
argument_list|(
operator|&
name|headers
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|OBJ_BOUT
comment|/* See above comments on b.out data section address.  */
block|{
name|long
name|bss_vma
decl_stmt|;
if|if
condition|(
name|data_last_frag
operator|==
literal|0
condition|)
name|bss_vma
operator|=
name|H_GET_TEXT_SIZE
argument_list|(
operator|&
name|headers
argument_list|)
expr_stmt|;
else|else
name|bss_vma
operator|=
name|data_last_frag
operator|->
name|fr_address
expr_stmt|;
name|bss_vma
operator|=
name|RoundUp
argument_list|(
name|bss_vma
argument_list|,
literal|1
operator|<<
name|section_alignment
index|[
name|SEG_BSS
index|]
argument_list|)
expr_stmt|;
name|bss_address_frag
operator|.
name|fr_address
operator|=
name|bss_vma
expr_stmt|;
block|}
else|#
directive|else
comment|/* ! OBJ_BOUT */
name|bss_address_frag
operator|.
name|fr_address
operator|=
operator|(
name|H_GET_TEXT_SIZE
argument_list|(
operator|&
name|headers
argument_list|)
operator|+
name|H_GET_DATA_SIZE
argument_list|(
operator|&
name|headers
argument_list|)
operator|)
expr_stmt|;
endif|#
directive|endif
comment|/* ! OBJ_BOUT */
comment|/* Slide all the frags */
if|if
condition|(
name|bss_frag_root
condition|)
block|{
name|relax_addressT
name|slide
init|=
name|bss_address_frag
operator|.
name|fr_address
decl_stmt|;
for|for
control|(
name|fragP
operator|=
name|bss_frag_root
init|;
name|fragP
condition|;
name|fragP
operator|=
name|fragP
operator|->
name|fr_next
control|)
block|{
name|fragP
operator|->
name|fr_address
operator|+=
name|slide
expr_stmt|;
block|}
comment|/* for each bss frag */
block|}
if|if
condition|(
name|bss_last_frag
condition|)
name|H_SET_BSS_SIZE
argument_list|(
operator|&
name|headers
argument_list|,
name|bss_last_frag
operator|->
name|fr_address
operator|-
name|bss_frag_root
operator|->
name|fr_address
argument_list|)
expr_stmt|;
else|else
name|H_SET_BSS_SIZE
argument_list|(
operator|&
name|headers
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ! BFD_ASSEMBLER&& ! BFD */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|BFD_ASSEMBLER
argument_list|)
operator|||
operator|!
name|defined
argument_list|(
name|BFD
argument_list|)
end_if

begin_ifdef
ifdef|#
directive|ifdef
name|BFD_ASSEMBLER
end_ifdef

begin_function
specifier|static
name|void
name|set_symtab
parameter_list|()
block|{
name|int
name|nsyms
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|asympp
decl_stmt|;
name|symbolS
modifier|*
name|symp
decl_stmt|;
name|boolean
name|result
decl_stmt|;
specifier|extern
name|PTR
name|bfd_alloc
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|size_t
operator|)
argument_list|)
decl_stmt|;
comment|/* Count symbols.  We can't rely on a count made by the loop in      write_object_file, because *_frob_file may add a new symbol or      two.  */
name|nsyms
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|symp
operator|=
name|symbol_rootP
init|;
name|symp
condition|;
name|symp
operator|=
name|symbol_next
argument_list|(
name|symp
argument_list|)
control|)
name|nsyms
operator|++
expr_stmt|;
if|if
condition|(
name|nsyms
condition|)
block|{
name|int
name|i
decl_stmt|;
name|asympp
operator|=
operator|(
name|asymbol
operator|*
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|stdoutput
argument_list|,
name|nsyms
operator|*
sizeof|sizeof
argument_list|(
name|asymbol
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|symp
operator|=
name|symbol_rootP
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nsyms
condition|;
name|i
operator|++
operator|,
name|symp
operator|=
name|symbol_next
argument_list|(
name|symp
argument_list|)
control|)
block|{
name|asympp
index|[
name|i
index|]
operator|=
name|symp
operator|->
name|bsym
expr_stmt|;
name|symp
operator|->
name|written
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
name|asympp
operator|=
literal|0
expr_stmt|;
name|result
operator|=
name|bfd_set_symtab
argument_list|(
name|stdoutput
argument_list|,
name|asympp
argument_list|,
name|nsyms
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|result
operator|==
name|true
argument_list|)
expr_stmt|;
name|symbol_table_frozen
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|write_object_file
parameter_list|()
block|{
name|struct
name|frchain
modifier|*
name|frchainP
decl_stmt|;
comment|/* Track along all frchains. */
if|#
directive|if
operator|!
name|defined
argument_list|(
name|BFD_ASSEMBLER
argument_list|)
operator|||
operator|!
name|defined
argument_list|(
name|WORKING_DOT_WORD
argument_list|)
name|fragS
modifier|*
name|fragP
decl_stmt|;
comment|/* Track along all frags. */
endif|#
directive|endif
comment|/* Do we really want to write it?  */
block|{
name|int
name|n_warns
decl_stmt|,
name|n_errs
decl_stmt|;
name|n_warns
operator|=
name|had_warnings
argument_list|()
expr_stmt|;
name|n_errs
operator|=
name|had_errors
argument_list|()
expr_stmt|;
comment|/* The -Z flag indicates that an object file should be generated,        regardless of warnings and errors.  */
if|if
condition|(
name|flag_always_generate_output
condition|)
block|{
if|if
condition|(
name|n_warns
operator|||
name|n_errs
condition|)
name|as_warn
argument_list|(
literal|"%d error%s, %d warning%s, generating bad object file.\n"
argument_list|,
name|n_errs
argument_list|,
name|n_errs
operator|==
literal|1
condition|?
literal|""
else|:
literal|"s"
argument_list|,
name|n_warns
argument_list|,
name|n_warns
operator|==
literal|1
condition|?
literal|""
else|:
literal|"s"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|n_errs
condition|)
name|as_fatal
argument_list|(
literal|"%d error%s, %d warning%s, no object file generated.\n"
argument_list|,
name|n_errs
argument_list|,
name|n_errs
operator|==
literal|1
condition|?
literal|""
else|:
literal|"s"
argument_list|,
name|n_warns
argument_list|,
name|n_warns
operator|==
literal|1
condition|?
literal|""
else|:
literal|"s"
argument_list|)
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|OBJ_VMS
comment|/* Under VMS we try to be compatible with VAX-11 "C".  Thus, we call      a routine to check for the definition of the procedure "_main",      and if so -- fix it up so that it can be program entry point. */
name|vms_check_for_main
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* OBJ_VMS */
comment|/* After every sub-segment, we fake an ".align ...". This conforms to      BSD4.2 brane-damage. We then fake ".fill 0" because that is the kind of      frag that requires least thought. ".align" frags like to have a      following frag since that makes calculating their intended length      trivial.       @@ Is this really necessary??  */
ifndef|#
directive|ifndef
name|SUB_SEGMENT_ALIGN
ifdef|#
directive|ifdef
name|BFD_ASSEMBLER
define|#
directive|define
name|SUB_SEGMENT_ALIGN
parameter_list|(
name|SEG
parameter_list|)
value|(0)
else|#
directive|else
define|#
directive|define
name|SUB_SEGMENT_ALIGN
parameter_list|(
name|SEG
parameter_list|)
value|(2)
endif|#
directive|endif
endif|#
directive|endif
for|for
control|(
name|frchainP
operator|=
name|frchain_root
init|;
name|frchainP
condition|;
name|frchainP
operator|=
name|frchainP
operator|->
name|frch_next
control|)
block|{
name|subseg_set
argument_list|(
name|frchainP
operator|->
name|frch_seg
argument_list|,
name|frchainP
operator|->
name|frch_subseg
argument_list|)
expr_stmt|;
name|frag_align
argument_list|(
name|SUB_SEGMENT_ALIGN
argument_list|(
name|now_seg
argument_list|)
argument_list|,
name|NOP_OPCODE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* frag_align will have left a new frag. 	 Use this last frag for an empty ".fill".  	 For this segment ... 	 Create a last frag. Do not leave a "being filled in frag".  */
name|frag_wane
argument_list|(
name|frag_now
argument_list|)
expr_stmt|;
name|frag_now
operator|->
name|fr_fix
operator|=
literal|0
expr_stmt|;
name|know
argument_list|(
name|frag_now
operator|->
name|fr_next
operator|==
name|NULL
argument_list|)
expr_stmt|;
block|}
comment|/* From now on, we don't care about sub-segments.  Build one frag chain      for each segment. Linked thru fr_next.  */
ifdef|#
directive|ifdef
name|BFD_ASSEMBLER
comment|/* Remove the sections created by gas for its own purposes.  */
block|{
name|asection
modifier|*
modifier|*
name|seclist
decl_stmt|,
modifier|*
name|sec
decl_stmt|;
name|int
name|i
decl_stmt|;
name|seclist
operator|=
operator|&
name|stdoutput
operator|->
name|sections
expr_stmt|;
while|while
condition|(
name|seclist
operator|&&
operator|*
name|seclist
condition|)
block|{
name|sec
operator|=
operator|*
name|seclist
expr_stmt|;
while|while
condition|(
name|sec
operator|==
name|reg_section
operator|||
name|sec
operator|==
name|expr_section
condition|)
block|{
name|sec
operator|=
name|sec
operator|->
name|next
expr_stmt|;
operator|*
name|seclist
operator|=
name|sec
expr_stmt|;
name|stdoutput
operator|->
name|section_count
operator|--
expr_stmt|;
if|if
condition|(
operator|!
name|sec
condition|)
break|break;
block|}
if|if
condition|(
operator|*
name|seclist
condition|)
name|seclist
operator|=
operator|&
operator|(
operator|*
name|seclist
operator|)
operator|->
name|next
expr_stmt|;
block|}
name|i
operator|=
literal|0
expr_stmt|;
name|bfd_map_over_sections
argument_list|(
name|stdoutput
argument_list|,
name|renumber_sections
argument_list|,
operator|&
name|i
argument_list|)
expr_stmt|;
block|}
name|bfd_map_over_sections
argument_list|(
name|stdoutput
argument_list|,
name|chain_frchains_together
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
name|remove_subsegs
argument_list|(
name|frchain_root
argument_list|,
name|SEG_TEXT
argument_list|,
operator|&
name|text_frag_root
argument_list|,
operator|&
name|text_last_frag
argument_list|)
expr_stmt|;
name|remove_subsegs
argument_list|(
name|data0_frchainP
argument_list|,
name|SEG_DATA
argument_list|,
operator|&
name|data_frag_root
argument_list|,
operator|&
name|data_last_frag
argument_list|)
expr_stmt|;
name|remove_subsegs
argument_list|(
name|bss0_frchainP
argument_list|,
name|SEG_BSS
argument_list|,
operator|&
name|bss_frag_root
argument_list|,
operator|&
name|bss_last_frag
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* We have two segments. If user gave -R flag, then we must put the      data frags into the text segment. Do this before relaxing so      we know to take advantage of -R and make shorter addresses.  */
if|#
directive|if
operator|!
name|defined
argument_list|(
name|OBJ_AOUT
argument_list|)
operator|||
name|defined
argument_list|(
name|BFD_ASSEMBLER
argument_list|)
if|if
condition|(
name|flag_readonly_data_in_text
condition|)
block|{
name|merge_data_into_text
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|BFD_ASSEMBLER
name|bfd_map_over_sections
argument_list|(
name|stdoutput
argument_list|,
name|relax_and_size_seg
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
name|relax_and_size_all_segments
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* BFD_ASSEMBLER */
ifndef|#
directive|ifndef
name|BFD_ASSEMBLER
comment|/*    *    * Crawl the symbol chain.    *    * For each symbol whose value depends on a frag, take the address of    * that frag and subsume it into the value of the symbol.    * After this, there is just one way to lookup a symbol value.    * Values are left in their final state for object file emission.    * We adjust the values of 'L' local symbols, even if we do    * not intend to emit them to the object file, because their values    * are needed for fix-ups.    *    * Unless we saw a -L flag, remove all symbols that begin with 'L'    * from the symbol chain.  (They are still pointed to by the fixes.)    *    * Count the remaining symbols.    * Assign a symbol number to each symbol.    * Count the number of string-table chars we will emit.    * Put this info into the headers as appropriate.    *    */
name|know
argument_list|(
name|zero_address_frag
operator|.
name|fr_address
operator|==
literal|0
argument_list|)
expr_stmt|;
name|string_byte_count
operator|=
sizeof|sizeof
argument_list|(
name|string_byte_count
argument_list|)
expr_stmt|;
name|obj_crawl_symbol_chain
argument_list|(
operator|&
name|headers
argument_list|)
expr_stmt|;
if|if
condition|(
name|string_byte_count
operator|==
sizeof|sizeof
argument_list|(
name|string_byte_count
argument_list|)
condition|)
name|string_byte_count
operator|=
literal|0
expr_stmt|;
name|H_SET_STRING_SIZE
argument_list|(
operator|&
name|headers
argument_list|,
name|string_byte_count
argument_list|)
expr_stmt|;
comment|/*    * Addresses of frags now reflect addresses we use in the object file.    * Symbol values are correct.    * Scan the frags, converting any ".org"s and ".align"s to ".fill"s.    * Also converting any machine-dependent frags using md_convert_frag();    */
name|subseg_change
argument_list|(
name|SEG_TEXT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|fragP
operator|=
name|text_frag_root
init|;
name|fragP
condition|;
name|fragP
operator|=
name|fragP
operator|->
name|fr_next
control|)
block|{
name|cvt_frag_to_fill
argument_list|(
operator|&
name|headers
argument_list|,
name|SEG_TEXT
argument_list|,
name|fragP
argument_list|)
expr_stmt|;
comment|/* Some assert macros don't work with # directives mixed in.  */
ifndef|#
directive|ifndef
name|NDEBUG
if|if
condition|(
operator|!
operator|(
name|fragP
operator|->
name|fr_next
operator|==
name|NULL
ifdef|#
directive|ifdef
name|OBJ_BOUT
operator|||
name|fragP
operator|->
name|fr_next
operator|==
name|data_frag_root
endif|#
directive|endif
operator|||
operator|(
operator|(
name|fragP
operator|->
name|fr_next
operator|->
name|fr_address
operator|-
name|fragP
operator|->
name|fr_address
operator|)
operator|==
operator|(
name|fragP
operator|->
name|fr_fix
operator|+
name|fragP
operator|->
name|fr_offset
operator|*
name|fragP
operator|->
name|fr_var
operator|)
operator|)
operator|)
condition|)
name|abort
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
endif|#
directive|endif
comment|/* ! BFD_ASSEMBLER */
ifndef|#
directive|ifndef
name|WORKING_DOT_WORD
block|{
name|struct
name|broken_word
modifier|*
name|lie
decl_stmt|;
name|struct
name|broken_word
modifier|*
modifier|*
name|prevP
decl_stmt|;
name|prevP
operator|=
operator|&
name|broken_words
expr_stmt|;
for|for
control|(
name|lie
operator|=
name|broken_words
init|;
name|lie
condition|;
name|lie
operator|=
name|lie
operator|->
name|next_broken_word
control|)
if|if
condition|(
operator|!
name|lie
operator|->
name|added
condition|)
block|{
name|expressionS
name|exp
decl_stmt|;
name|exp
operator|.
name|X_op
operator|=
name|O_subtract
expr_stmt|;
name|exp
operator|.
name|X_add_symbol
operator|=
name|lie
operator|->
name|add
expr_stmt|;
name|exp
operator|.
name|X_op_symbol
operator|=
name|lie
operator|->
name|sub
expr_stmt|;
name|exp
operator|.
name|X_add_number
operator|=
name|lie
operator|->
name|addnum
expr_stmt|;
ifdef|#
directive|ifdef
name|BFD_ASSEMBLER
ifdef|#
directive|ifdef
name|TC_CONS_FIX_NEW
name|TC_CONS_FIX_NEW
argument_list|(
name|lie
operator|->
name|frag
argument_list|,
name|lie
operator|->
name|word_goes_here
operator|-
name|lie
operator|->
name|frag
operator|->
name|fr_literal
argument_list|,
literal|2
argument_list|,
operator|&
name|exp
argument_list|)
expr_stmt|;
else|#
directive|else
name|fix_new_exp
argument_list|(
name|lie
operator|->
name|frag
argument_list|,
name|lie
operator|->
name|word_goes_here
operator|-
name|lie
operator|->
name|frag
operator|->
name|fr_literal
argument_list|,
literal|2
argument_list|,
operator|&
name|exp
argument_list|,
literal|0
argument_list|,
name|BFD_RELOC_16
argument_list|)
expr_stmt|;
endif|#
directive|endif
else|#
directive|else
if|#
directive|if
name|defined
argument_list|(
name|TC_SPARC
argument_list|)
operator|||
name|defined
argument_list|(
name|TC_A29K
argument_list|)
operator|||
name|defined
argument_list|(
name|NEED_FX_R_TYPE
argument_list|)
name|fix_new_exp
argument_list|(
name|lie
operator|->
name|frag
argument_list|,
name|lie
operator|->
name|word_goes_here
operator|-
name|lie
operator|->
name|frag
operator|->
name|fr_literal
argument_list|,
literal|2
argument_list|,
operator|&
name|exp
argument_list|,
literal|0
argument_list|,
name|NO_RELOC
argument_list|)
expr_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|TC_NS32K
name|fix_new_ns32k_exp
argument_list|(
name|lie
operator|->
name|frag
argument_list|,
name|lie
operator|->
name|word_goes_here
operator|-
name|lie
operator|->
name|frag
operator|->
name|fr_literal
argument_list|,
literal|2
argument_list|,
operator|&
name|exp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
name|fix_new_exp
argument_list|(
name|lie
operator|->
name|frag
argument_list|,
name|lie
operator|->
name|word_goes_here
operator|-
name|lie
operator|->
name|frag
operator|->
name|fr_literal
argument_list|,
literal|2
argument_list|,
operator|&
name|exp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* TC_NS32K */
endif|#
directive|endif
comment|/* TC_SPARC|TC_A29K|NEED_FX_R_TYPE */
endif|#
directive|endif
comment|/* BFD_ASSEMBLER */
operator|*
name|prevP
operator|=
name|lie
operator|->
name|next_broken_word
expr_stmt|;
block|}
else|else
name|prevP
operator|=
operator|&
operator|(
name|lie
operator|->
name|next_broken_word
operator|)
expr_stmt|;
for|for
control|(
name|lie
operator|=
name|broken_words
init|;
name|lie
condition|;
control|)
block|{
name|struct
name|broken_word
modifier|*
name|untruth
decl_stmt|;
name|char
modifier|*
name|table_ptr
decl_stmt|;
name|addressT
name|table_addr
decl_stmt|;
name|addressT
name|from_addr
decl_stmt|,
name|to_addr
decl_stmt|;
name|int
name|n
decl_stmt|,
name|m
decl_stmt|;
name|fragP
operator|=
name|lie
operator|->
name|dispfrag
expr_stmt|;
comment|/* Find out how many broken_words go here.  */
name|n
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|untruth
operator|=
name|lie
init|;
name|untruth
operator|&&
name|untruth
operator|->
name|dispfrag
operator|==
name|fragP
condition|;
name|untruth
operator|=
name|untruth
operator|->
name|next_broken_word
control|)
if|if
condition|(
name|untruth
operator|->
name|added
operator|==
literal|1
condition|)
name|n
operator|++
expr_stmt|;
name|table_ptr
operator|=
name|lie
operator|->
name|dispfrag
operator|->
name|fr_opcode
expr_stmt|;
name|table_addr
operator|=
name|lie
operator|->
name|dispfrag
operator|->
name|fr_address
operator|+
operator|(
name|table_ptr
operator|-
name|lie
operator|->
name|dispfrag
operator|->
name|fr_literal
operator|)
expr_stmt|;
comment|/* Create the jump around the long jumps.  This is a short 	   jump from table_ptr+0 to table_ptr+n*long_jump_size.  */
name|from_addr
operator|=
name|table_addr
expr_stmt|;
name|to_addr
operator|=
name|table_addr
operator|+
name|md_short_jump_size
operator|+
name|n
operator|*
name|md_long_jump_size
expr_stmt|;
name|md_create_short_jump
argument_list|(
name|table_ptr
argument_list|,
name|from_addr
argument_list|,
name|to_addr
argument_list|,
name|lie
operator|->
name|dispfrag
argument_list|,
name|lie
operator|->
name|add
argument_list|)
expr_stmt|;
name|table_ptr
operator|+=
name|md_short_jump_size
expr_stmt|;
name|table_addr
operator|+=
name|md_short_jump_size
expr_stmt|;
for|for
control|(
name|m
operator|=
literal|0
init|;
name|lie
operator|&&
name|lie
operator|->
name|dispfrag
operator|==
name|fragP
condition|;
name|m
operator|++
operator|,
name|lie
operator|=
name|lie
operator|->
name|next_broken_word
control|)
block|{
if|if
condition|(
name|lie
operator|->
name|added
operator|==
literal|2
condition|)
continue|continue;
comment|/* Patch the jump table */
comment|/* This is the offset from ??? to table_ptr+0 */
name|to_addr
operator|=
name|table_addr
operator|-
name|S_GET_VALUE
argument_list|(
name|lie
operator|->
name|sub
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|BFD_ASSEMBLER
name|to_addr
operator|-=
name|lie
operator|->
name|sub
operator|->
name|sy_frag
operator|->
name|fr_address
expr_stmt|;
endif|#
directive|endif
name|md_number_to_chars
argument_list|(
name|lie
operator|->
name|word_goes_here
argument_list|,
name|to_addr
argument_list|,
literal|2
argument_list|)
expr_stmt|;
for|for
control|(
name|untruth
operator|=
name|lie
operator|->
name|next_broken_word
init|;
name|untruth
operator|&&
name|untruth
operator|->
name|dispfrag
operator|==
name|fragP
condition|;
name|untruth
operator|=
name|untruth
operator|->
name|next_broken_word
control|)
block|{
if|if
condition|(
name|untruth
operator|->
name|use_jump
operator|==
name|lie
condition|)
name|md_number_to_chars
argument_list|(
name|untruth
operator|->
name|word_goes_here
argument_list|,
name|to_addr
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
comment|/* Install the long jump */
comment|/* this is a long jump from table_ptr+0 to the final target */
name|from_addr
operator|=
name|table_addr
expr_stmt|;
name|to_addr
operator|=
name|S_GET_VALUE
argument_list|(
name|lie
operator|->
name|add
argument_list|)
operator|+
name|lie
operator|->
name|addnum
expr_stmt|;
ifdef|#
directive|ifdef
name|BFD_ASSEMBLER
name|to_addr
operator|+=
name|lie
operator|->
name|add
operator|->
name|sy_frag
operator|->
name|fr_address
expr_stmt|;
endif|#
directive|endif
name|md_create_long_jump
argument_list|(
name|table_ptr
argument_list|,
name|from_addr
argument_list|,
name|to_addr
argument_list|,
name|lie
operator|->
name|dispfrag
argument_list|,
name|lie
operator|->
name|add
argument_list|)
expr_stmt|;
name|table_ptr
operator|+=
name|md_long_jump_size
expr_stmt|;
name|table_addr
operator|+=
name|md_long_jump_size
expr_stmt|;
block|}
block|}
block|}
endif|#
directive|endif
comment|/* not WORKING_DOT_WORD */
ifndef|#
directive|ifndef
name|BFD_ASSEMBLER
ifndef|#
directive|ifndef
name|OBJ_VMS
block|{
comment|/* not vms */
name|char
modifier|*
name|the_object_file
decl_stmt|;
name|long
name|object_file_size
decl_stmt|;
comment|/*      * Scan every FixS performing fixups. We had to wait until now to do      * this because md_convert_frag() may have made some fixSs.      */
name|int
name|trsize
decl_stmt|,
name|drsize
decl_stmt|;
name|subseg_change
argument_list|(
name|SEG_TEXT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|trsize
operator|=
name|md_reloc_size
operator|*
name|fixup_segment
argument_list|(
name|text_fix_root
argument_list|,
name|SEG_TEXT
argument_list|)
expr_stmt|;
name|subseg_change
argument_list|(
name|SEG_DATA
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|drsize
operator|=
name|md_reloc_size
operator|*
name|fixup_segment
argument_list|(
name|data_fix_root
argument_list|,
name|SEG_DATA
argument_list|)
expr_stmt|;
name|H_SET_RELOCATION_SIZE
argument_list|(
operator|&
name|headers
argument_list|,
name|trsize
argument_list|,
name|drsize
argument_list|)
expr_stmt|;
comment|/* FIXME move this stuff into the pre-write-hook */
name|H_SET_MAGIC_NUMBER
argument_list|(
operator|&
name|headers
argument_list|,
name|magic_number_for_object_file
argument_list|)
expr_stmt|;
name|H_SET_ENTRY_POINT
argument_list|(
operator|&
name|headers
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|obj_pre_write_hook
argument_list|(
operator|&
name|headers
argument_list|)
expr_stmt|;
comment|/* extra coff stuff */
name|object_file_size
operator|=
name|H_GET_FILE_SIZE
argument_list|(
operator|&
name|headers
argument_list|)
expr_stmt|;
name|next_object_file_charP
operator|=
name|the_object_file
operator|=
name|xmalloc
argument_list|(
name|object_file_size
argument_list|)
expr_stmt|;
name|output_file_create
argument_list|(
name|out_file_name
argument_list|)
expr_stmt|;
name|obj_header_append
argument_list|(
operator|&
name|next_object_file_charP
argument_list|,
operator|&
name|headers
argument_list|)
expr_stmt|;
name|know
argument_list|(
operator|(
name|next_object_file_charP
operator|-
name|the_object_file
operator|)
operator|==
name|H_GET_HEADER_SIZE
argument_list|(
operator|&
name|headers
argument_list|)
argument_list|)
expr_stmt|;
comment|/*      * Emit code.      */
for|for
control|(
name|fragP
operator|=
name|text_frag_root
init|;
name|fragP
condition|;
name|fragP
operator|=
name|fragP
operator|->
name|fr_next
control|)
block|{
specifier|register
name|long
name|count
decl_stmt|;
specifier|register
name|char
modifier|*
name|fill_literal
decl_stmt|;
specifier|register
name|long
name|fill_size
decl_stmt|;
name|PROGRESS
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|know
argument_list|(
name|fragP
operator|->
name|fr_type
operator|==
name|rs_fill
argument_list|)
expr_stmt|;
name|append
argument_list|(
operator|&
name|next_object_file_charP
argument_list|,
name|fragP
operator|->
name|fr_literal
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|fragP
operator|->
name|fr_fix
argument_list|)
expr_stmt|;
name|fill_literal
operator|=
name|fragP
operator|->
name|fr_literal
operator|+
name|fragP
operator|->
name|fr_fix
expr_stmt|;
name|fill_size
operator|=
name|fragP
operator|->
name|fr_var
expr_stmt|;
name|know
argument_list|(
name|fragP
operator|->
name|fr_offset
operator|>=
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|count
operator|=
name|fragP
operator|->
name|fr_offset
init|;
name|count
condition|;
name|count
operator|--
control|)
block|{
name|append
argument_list|(
operator|&
name|next_object_file_charP
argument_list|,
name|fill_literal
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|fill_size
argument_list|)
expr_stmt|;
block|}
comment|/* for each  */
block|}
comment|/* for each code frag. */
name|know
argument_list|(
operator|(
name|next_object_file_charP
operator|-
name|the_object_file
operator|)
operator|==
operator|(
name|H_GET_HEADER_SIZE
argument_list|(
operator|&
name|headers
argument_list|)
operator|+
name|H_GET_TEXT_SIZE
argument_list|(
operator|&
name|headers
argument_list|)
operator|+
name|H_GET_DATA_SIZE
argument_list|(
operator|&
name|headers
argument_list|)
operator|)
argument_list|)
expr_stmt|;
comment|/*      * Emit relocations.      */
name|obj_emit_relocations
argument_list|(
operator|&
name|next_object_file_charP
argument_list|,
name|text_fix_root
argument_list|,
operator|(
name|relax_addressT
operator|)
literal|0
argument_list|)
expr_stmt|;
name|know
argument_list|(
operator|(
name|next_object_file_charP
operator|-
name|the_object_file
operator|)
operator|==
operator|(
name|H_GET_HEADER_SIZE
argument_list|(
operator|&
name|headers
argument_list|)
operator|+
name|H_GET_TEXT_SIZE
argument_list|(
operator|&
name|headers
argument_list|)
operator|+
name|H_GET_DATA_SIZE
argument_list|(
operator|&
name|headers
argument_list|)
operator|+
name|H_GET_TEXT_RELOCATION_SIZE
argument_list|(
operator|&
name|headers
argument_list|)
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TC_I960
comment|/* Make addresses in data relocation directives relative to beginning of      * first data fragment, not end of last text fragment:  alignment of the      * start of the data segment may place a gap between the segments.      */
name|obj_emit_relocations
argument_list|(
operator|&
name|next_object_file_charP
argument_list|,
name|data_fix_root
argument_list|,
name|data0_frchainP
operator|->
name|frch_root
operator|->
name|fr_address
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* TC_I960 */
name|obj_emit_relocations
argument_list|(
operator|&
name|next_object_file_charP
argument_list|,
name|data_fix_root
argument_list|,
name|text_last_frag
operator|->
name|fr_address
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* TC_I960 */
name|know
argument_list|(
operator|(
name|next_object_file_charP
operator|-
name|the_object_file
operator|)
operator|==
operator|(
name|H_GET_HEADER_SIZE
argument_list|(
operator|&
name|headers
argument_list|)
operator|+
name|H_GET_TEXT_SIZE
argument_list|(
operator|&
name|headers
argument_list|)
operator|+
name|H_GET_DATA_SIZE
argument_list|(
operator|&
name|headers
argument_list|)
operator|+
name|H_GET_TEXT_RELOCATION_SIZE
argument_list|(
operator|&
name|headers
argument_list|)
operator|+
name|H_GET_DATA_RELOCATION_SIZE
argument_list|(
operator|&
name|headers
argument_list|)
operator|)
argument_list|)
expr_stmt|;
comment|/*      * Emit line number entries.      */
name|OBJ_EMIT_LINENO
argument_list|(
operator|&
name|next_object_file_charP
argument_list|,
name|lineno_rootP
argument_list|,
name|the_object_file
argument_list|)
expr_stmt|;
name|know
argument_list|(
operator|(
name|next_object_file_charP
operator|-
name|the_object_file
operator|)
operator|==
operator|(
name|H_GET_HEADER_SIZE
argument_list|(
operator|&
name|headers
argument_list|)
operator|+
name|H_GET_TEXT_SIZE
argument_list|(
operator|&
name|headers
argument_list|)
operator|+
name|H_GET_DATA_SIZE
argument_list|(
operator|&
name|headers
argument_list|)
operator|+
name|H_GET_TEXT_RELOCATION_SIZE
argument_list|(
operator|&
name|headers
argument_list|)
operator|+
name|H_GET_DATA_RELOCATION_SIZE
argument_list|(
operator|&
name|headers
argument_list|)
operator|+
name|H_GET_LINENO_SIZE
argument_list|(
operator|&
name|headers
argument_list|)
operator|)
argument_list|)
expr_stmt|;
comment|/*      * Emit symbols.      */
name|obj_emit_symbols
argument_list|(
operator|&
name|next_object_file_charP
argument_list|,
name|symbol_rootP
argument_list|)
expr_stmt|;
name|know
argument_list|(
operator|(
name|next_object_file_charP
operator|-
name|the_object_file
operator|)
operator|==
operator|(
name|H_GET_HEADER_SIZE
argument_list|(
operator|&
name|headers
argument_list|)
operator|+
name|H_GET_TEXT_SIZE
argument_list|(
operator|&
name|headers
argument_list|)
operator|+
name|H_GET_DATA_SIZE
argument_list|(
operator|&
name|headers
argument_list|)
operator|+
name|H_GET_TEXT_RELOCATION_SIZE
argument_list|(
operator|&
name|headers
argument_list|)
operator|+
name|H_GET_DATA_RELOCATION_SIZE
argument_list|(
operator|&
name|headers
argument_list|)
operator|+
name|H_GET_LINENO_SIZE
argument_list|(
operator|&
name|headers
argument_list|)
operator|+
name|H_GET_SYMBOL_TABLE_SIZE
argument_list|(
operator|&
name|headers
argument_list|)
operator|)
argument_list|)
expr_stmt|;
comment|/*      * Emit strings.      */
if|if
condition|(
name|string_byte_count
operator|>
literal|0
condition|)
block|{
name|obj_emit_strings
argument_list|(
operator|&
name|next_object_file_charP
argument_list|)
expr_stmt|;
block|}
comment|/* only if we have a string table */
ifdef|#
directive|ifdef
name|BFD_HEADERS
name|bfd_seek
argument_list|(
name|stdoutput
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bfd_write
argument_list|(
name|the_object_file
argument_list|,
literal|1
argument_list|,
name|object_file_size
argument_list|,
name|stdoutput
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* Write the data to the file */
name|output_file_append
argument_list|(
name|the_object_file
argument_list|,
name|object_file_size
argument_list|,
name|out_file_name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|the_object_file
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* non vms output */
else|#
directive|else
comment|/* OBJ_VMS */
comment|/*    *	Now do the VMS-dependent part of writing the object file    */
name|vms_write_object_file
argument_list|(
name|H_GET_TEXT_SIZE
argument_list|(
operator|&
name|headers
argument_list|)
argument_list|,
name|H_GET_DATA_SIZE
argument_list|(
operator|&
name|headers
argument_list|)
argument_list|,
name|H_GET_BSS_SIZE
argument_list|(
operator|&
name|headers
argument_list|)
argument_list|,
name|text_frag_root
argument_list|,
name|data_frag_root
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* OBJ_VMS */
else|#
directive|else
comment|/* BFD_ASSEMBLER */
comment|/* Resolve symbol values.  This needs to be done before processing      the relocations.  */
if|if
condition|(
name|symbol_rootP
condition|)
block|{
name|symbolS
modifier|*
name|symp
decl_stmt|;
for|for
control|(
name|symp
operator|=
name|symbol_rootP
init|;
name|symp
condition|;
name|symp
operator|=
name|symbol_next
argument_list|(
name|symp
argument_list|)
control|)
if|if
condition|(
operator|!
name|symp
operator|->
name|sy_resolved
condition|)
name|resolve_symbol_value
argument_list|(
name|symp
argument_list|)
expr_stmt|;
block|}
name|PROGRESS
argument_list|(
literal|1
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|tc_frob_file_before_adjust
name|tc_frob_file_before_adjust
argument_list|()
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|obj_frob_file_before_adjust
name|obj_frob_file_before_adjust
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|bfd_map_over_sections
argument_list|(
name|stdoutput
argument_list|,
name|adjust_reloc_syms
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
comment|/* Set up symbol table, and write it out.  */
if|if
condition|(
name|symbol_rootP
condition|)
block|{
name|symbolS
modifier|*
name|symp
decl_stmt|;
for|for
control|(
name|symp
operator|=
name|symbol_rootP
init|;
name|symp
condition|;
name|symp
operator|=
name|symbol_next
argument_list|(
name|symp
argument_list|)
control|)
block|{
name|int
name|punt
init|=
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
if|if
condition|(
name|symp
operator|->
name|sy_mri_common
condition|)
block|{
if|if
condition|(
name|S_IS_EXTERNAL
argument_list|(
name|symp
argument_list|)
condition|)
name|as_bad
argument_list|(
literal|"%s: global symbols not supported in common sections"
argument_list|,
name|S_GET_NAME
argument_list|(
name|symp
argument_list|)
argument_list|)
expr_stmt|;
name|symbol_remove
argument_list|(
name|symp
argument_list|,
operator|&
name|symbol_rootP
argument_list|,
operator|&
name|symbol_lastP
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|name
operator|=
name|S_GET_NAME
argument_list|(
name|symp
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
condition|)
block|{
specifier|const
name|char
modifier|*
name|name2
init|=
name|decode_local_label_name
argument_list|(
operator|(
name|char
operator|*
operator|)
name|S_GET_NAME
argument_list|(
name|symp
argument_list|)
argument_list|)
decl_stmt|;
comment|/* They only differ if `name' is a fb or dollar local 		 label name.  */
if|if
condition|(
name|name2
operator|!=
name|name
operator|&&
operator|!
name|S_IS_DEFINED
argument_list|(
name|symp
argument_list|)
condition|)
name|as_bad
argument_list|(
literal|"local label %s is not defined"
argument_list|,
name|name2
argument_list|)
expr_stmt|;
block|}
comment|/* Do it again, because adjust_reloc_syms might introduce 	     more symbols.  They'll probably only be section symbols, 	     but they'll still need to have the values computed.  */
if|if
condition|(
operator|!
name|symp
operator|->
name|sy_resolved
condition|)
block|{
if|if
condition|(
name|symp
operator|->
name|sy_value
operator|.
name|X_op
operator|==
name|O_constant
condition|)
block|{
comment|/* This is the normal case; skip the call.  */
name|S_SET_VALUE
argument_list|(
name|symp
argument_list|,
operator|(
name|S_GET_VALUE
argument_list|(
name|symp
argument_list|)
operator|+
name|symp
operator|->
name|sy_frag
operator|->
name|fr_address
operator|)
argument_list|)
expr_stmt|;
name|symp
operator|->
name|sy_resolved
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|resolve_symbol_value
argument_list|(
name|symp
argument_list|)
expr_stmt|;
block|}
comment|/* Skip symbols which were equated to undefined or common              symbols.  */
if|if
condition|(
name|symp
operator|->
name|sy_value
operator|.
name|X_op
operator|==
name|O_symbol
operator|&&
operator|(
operator|!
name|S_IS_DEFINED
argument_list|(
name|symp
argument_list|)
operator|||
name|S_IS_COMMON
argument_list|(
name|symp
argument_list|)
operator|)
condition|)
block|{
name|symbol_remove
argument_list|(
name|symp
argument_list|,
operator|&
name|symbol_rootP
argument_list|,
operator|&
name|symbol_lastP
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* So far, common symbols have been treated like undefined symbols. 	     Put them in the common section now.  */
if|if
condition|(
name|S_IS_DEFINED
argument_list|(
name|symp
argument_list|)
operator|==
literal|0
operator|&&
name|S_GET_VALUE
argument_list|(
name|symp
argument_list|)
operator|!=
literal|0
condition|)
name|S_SET_SEGMENT
argument_list|(
name|symp
argument_list|,
name|bfd_com_section_ptr
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|printf ("symbol `%s'\n\t@%x: value=%d flags=%x seg=%s\n", 		  S_GET_NAME (symp), symp, 		  S_GET_VALUE (symp), 		  symp->bsym->flags, 		  segment_name (symp->bsym->section));
endif|#
directive|endif
ifdef|#
directive|ifdef
name|obj_frob_symbol
name|obj_frob_symbol
argument_list|(
name|symp
argument_list|,
name|punt
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|tc_frob_symbol
if|if
condition|(
operator|!
name|punt
operator|||
name|symp
operator|->
name|sy_used_in_reloc
condition|)
name|tc_frob_symbol
argument_list|(
name|symp
argument_list|,
name|punt
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* If we don't want to keep this symbol, splice it out of 	     the chain now.  If EMIT_SECTION_SYMBOLS is 0, we never 	     want section symbols.  Otherwise, we skip local symbols 	     and symbols that the frob_symbol macros told us to punt, 	     but we keep such symbols if they are used in relocs.  */
if|if
condition|(
operator|(
operator|!
name|EMIT_SECTION_SYMBOLS
operator|&&
operator|(
name|symp
operator|->
name|bsym
operator|->
name|flags
operator|&
name|BSF_SECTION_SYM
operator|)
operator|!=
literal|0
operator|)
comment|/* Note that S_IS_EXTERN and S_IS_LOCAL are not always 		 opposites.  Sometimes the former checks flags and the 		 latter examines the name...  */
operator|||
operator|(
operator|!
name|S_IS_EXTERN
argument_list|(
name|symp
argument_list|)
operator|&&
operator|(
name|S_IS_LOCAL
argument_list|(
name|symp
argument_list|)
operator|||
name|punt
operator|)
operator|&&
operator|!
name|symp
operator|->
name|sy_used_in_reloc
operator|)
condition|)
block|{
name|symbol_remove
argument_list|(
name|symp
argument_list|,
operator|&
name|symbol_rootP
argument_list|,
operator|&
name|symbol_lastP
argument_list|)
expr_stmt|;
comment|/* After symbol_remove, symbol_next(symp) still returns 		 the one that came after it in the chain.  So we don't 		 need to do any extra cleanup work here.  */
continue|continue;
block|}
comment|/* Make sure we really got a value for the symbol.  */
if|if
condition|(
operator|!
name|symp
operator|->
name|sy_resolved
condition|)
block|{
name|as_bad
argument_list|(
literal|"can't resolve value for symbol \"%s\""
argument_list|,
name|S_GET_NAME
argument_list|(
name|symp
argument_list|)
argument_list|)
expr_stmt|;
name|symp
operator|->
name|sy_resolved
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Set the value into the BFD symbol.  Up til now the value 	     has only been kept in the gas symbolS struct.  */
name|symp
operator|->
name|bsym
operator|->
name|value
operator|=
name|S_GET_VALUE
argument_list|(
name|symp
argument_list|)
expr_stmt|;
block|}
block|}
name|PROGRESS
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* Now do any format-specific adjustments to the symbol table, such      as adding file symbols.  */
ifdef|#
directive|ifdef
name|tc_adjust_symtab
name|tc_adjust_symtab
argument_list|()
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|obj_adjust_symtab
name|obj_adjust_symtab
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* Now that all the sizes are known, and contents correct, we can      start writing to the file.  */
name|set_symtab
argument_list|()
expr_stmt|;
comment|/* If *_frob_file changes the symbol value at this point, it is      responsible for moving the changed value into symp->bsym->value      as well.  Hopefully all symbol value changing can be done in      *_frob_symbol.  */
ifdef|#
directive|ifdef
name|tc_frob_file
name|tc_frob_file
argument_list|()
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|obj_frob_file
name|obj_frob_file
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|bfd_map_over_sections
argument_list|(
name|stdoutput
argument_list|,
name|write_relocs
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|tc_frob_file_after_relocs
name|tc_frob_file_after_relocs
argument_list|()
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|obj_frob_file_after_relocs
name|obj_frob_file_after_relocs
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|bfd_map_over_sections
argument_list|(
name|stdoutput
argument_list|,
name|write_contents
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* BFD_ASSEMBLER */
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ! BFD */
end_comment

begin_comment
comment|/*  *			relax_segment()  *  * Now we have a segment, not a crowd of sub-segments, we can make fr_address  * values.  *  * Relax the frags.  *  * After this, all frags in this segment have addresses that are correct  * within the segment. Since segments live in different file addresses,  * these frag addresses may not be the same as final object-file addresses.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|TC_GENERIC_RELAX_TABLE
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|is_dnrange
name|PARAMS
argument_list|(
operator|(
name|fragS
operator|*
operator|,
name|fragS
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Subroutines of relax_segment.  */
end_comment

begin_function
specifier|static
name|int
name|is_dnrange
parameter_list|(
name|f1
parameter_list|,
name|f2
parameter_list|)
name|fragS
modifier|*
name|f1
decl_stmt|;
name|fragS
modifier|*
name|f2
decl_stmt|;
block|{
for|for
control|(
init|;
name|f1
condition|;
name|f1
operator|=
name|f1
operator|->
name|fr_next
control|)
if|if
condition|(
name|f1
operator|->
name|fr_next
operator|==
name|f2
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Relax a fragment by scanning TC_GENERIC_RELAX_TABLE.  */
end_comment

begin_function
name|long
name|relax_frag
parameter_list|(
name|fragP
parameter_list|,
name|stretch
parameter_list|)
name|fragS
modifier|*
name|fragP
decl_stmt|;
name|long
name|stretch
decl_stmt|;
block|{
specifier|const
name|relax_typeS
modifier|*
name|this_type
decl_stmt|;
specifier|const
name|relax_typeS
modifier|*
name|start_type
decl_stmt|;
name|relax_substateT
name|next_state
decl_stmt|;
name|relax_substateT
name|this_state
decl_stmt|;
name|long
name|aim
decl_stmt|,
name|target
decl_stmt|,
name|growth
decl_stmt|;
name|symbolS
modifier|*
name|symbolP
init|=
name|fragP
operator|->
name|fr_symbol
decl_stmt|;
name|long
name|offset
init|=
name|fragP
operator|->
name|fr_offset
decl_stmt|;
comment|/* Recompute was_address by undoing "+= stretch" done by relax_segment.  */
name|unsigned
name|long
name|was_address
init|=
name|fragP
operator|->
name|fr_address
operator|-
name|stretch
decl_stmt|;
name|unsigned
name|long
name|address
init|=
name|fragP
operator|->
name|fr_address
decl_stmt|;
specifier|const
name|relax_typeS
modifier|*
name|table
init|=
name|TC_GENERIC_RELAX_TABLE
decl_stmt|;
name|this_state
operator|=
name|fragP
operator|->
name|fr_subtype
expr_stmt|;
name|start_type
operator|=
name|this_type
operator|=
name|table
operator|+
name|this_state
expr_stmt|;
name|target
operator|=
name|offset
expr_stmt|;
if|if
condition|(
name|symbolP
condition|)
block|{
ifndef|#
directive|ifndef
name|DIFF_EXPR_OK
if|#
directive|if
operator|!
name|defined
argument_list|(
name|MANY_SEGMENTS
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|BFD_ASSEMBLER
argument_list|)
name|know
argument_list|(
operator|(
name|S_GET_SEGMENT
argument_list|(
name|symbolP
argument_list|)
operator|==
name|SEG_ABSOLUTE
operator|)
operator|||
operator|(
name|S_GET_SEGMENT
argument_list|(
name|symbolP
argument_list|)
operator|==
name|SEG_DATA
operator|)
operator|||
operator|(
name|S_GET_SEGMENT
argument_list|(
name|symbolP
argument_list|)
operator|==
name|SEG_BSS
operator|)
operator|||
operator|(
name|S_GET_SEGMENT
argument_list|(
name|symbolP
argument_list|)
operator|==
name|SEG_TEXT
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|know
argument_list|(
name|symbolP
operator|->
name|sy_frag
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|know
argument_list|(
operator|!
operator|(
name|S_GET_SEGMENT
argument_list|(
name|symbolP
argument_list|)
operator|==
name|absolute_section
operator|)
operator|||
name|symbolP
operator|->
name|sy_frag
operator|==
operator|&
name|zero_address_frag
argument_list|)
expr_stmt|;
name|target
operator|+=
name|S_GET_VALUE
argument_list|(
name|symbolP
argument_list|)
operator|+
name|symbolP
operator|->
name|sy_frag
operator|->
name|fr_address
expr_stmt|;
comment|/* If frag has yet to be reached on this pass, 	 assume it will move by STRETCH just as we did. 	 If this is not so, it will be because some frag 	 between grows, and that will force another pass.  	 Beware zero-length frags.  	 There should be a faster way to do this.  */
if|if
condition|(
name|symbolP
operator|->
name|sy_frag
operator|->
name|fr_address
operator|>=
name|was_address
operator|&&
name|is_dnrange
argument_list|(
name|fragP
argument_list|,
name|symbolP
operator|->
name|sy_frag
argument_list|)
condition|)
block|{
name|target
operator|+=
name|stretch
expr_stmt|;
block|}
block|}
name|aim
operator|=
name|target
operator|-
name|address
operator|-
name|fragP
operator|->
name|fr_fix
expr_stmt|;
ifdef|#
directive|ifdef
name|TC_PCREL_ADJUST
comment|/* Currently only the ns32k family needs this */
name|aim
operator|+=
name|TC_PCREL_ADJUST
argument_list|(
name|fragP
argument_list|)
expr_stmt|;
comment|/*#else*/
comment|/* This machine doesn't want to use pcrel_adjust.      In that case, pcrel_adjust should be zero.  */
comment|/*  assert (fragP->fr_targ.ns32k.pcrel_adjust == 0);*/
endif|#
directive|endif
ifdef|#
directive|ifdef
name|md_prepare_relax_scan
comment|/* formerly called M68K_AIM_KLUDGE */
name|md_prepare_relax_scan
argument_list|(
name|fragP
argument_list|,
name|address
argument_list|,
name|aim
argument_list|,
name|this_state
argument_list|,
name|this_type
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|aim
operator|<
literal|0
condition|)
block|{
comment|/* Look backwards. */
for|for
control|(
name|next_state
operator|=
name|this_type
operator|->
name|rlx_more
init|;
name|next_state
condition|;
control|)
if|if
condition|(
name|aim
operator|>=
name|this_type
operator|->
name|rlx_backward
condition|)
name|next_state
operator|=
literal|0
expr_stmt|;
else|else
block|{
comment|/* Grow to next state. */
name|this_state
operator|=
name|next_state
expr_stmt|;
name|this_type
operator|=
name|table
operator|+
name|this_state
expr_stmt|;
name|next_state
operator|=
name|this_type
operator|->
name|rlx_more
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Look forwards. */
for|for
control|(
name|next_state
operator|=
name|this_type
operator|->
name|rlx_more
init|;
name|next_state
condition|;
control|)
if|if
condition|(
name|aim
operator|<=
name|this_type
operator|->
name|rlx_forward
condition|)
name|next_state
operator|=
literal|0
expr_stmt|;
else|else
block|{
comment|/* Grow to next state. */
name|this_state
operator|=
name|next_state
expr_stmt|;
name|this_type
operator|=
name|table
operator|+
name|this_state
expr_stmt|;
name|next_state
operator|=
name|this_type
operator|->
name|rlx_more
expr_stmt|;
block|}
block|}
name|growth
operator|=
name|this_type
operator|->
name|rlx_length
operator|-
name|start_type
operator|->
name|rlx_length
expr_stmt|;
if|if
condition|(
name|growth
operator|!=
literal|0
condition|)
name|fragP
operator|->
name|fr_subtype
operator|=
name|this_state
expr_stmt|;
return|return
name|growth
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* defined (TC_GENERIC_RELAX_TABLE) */
end_comment

begin_comment
comment|/* Relax_align. Advance location counter to next address that has 'alignment'    lowest order bits all 0s, return size of adjustment made.  */
end_comment

begin_function
specifier|static
name|relax_addressT
name|relax_align
parameter_list|(
name|address
parameter_list|,
name|alignment
parameter_list|)
specifier|register
name|relax_addressT
name|address
decl_stmt|;
comment|/* Address now. */
specifier|register
name|int
name|alignment
decl_stmt|;
comment|/* Alignment (binary). */
block|{
name|relax_addressT
name|mask
decl_stmt|;
name|relax_addressT
name|new_address
decl_stmt|;
name|mask
operator|=
operator|~
operator|(
operator|(
operator|~
literal|0
operator|)
operator|<<
name|alignment
operator|)
expr_stmt|;
name|new_address
operator|=
operator|(
name|address
operator|+
name|mask
operator|)
operator|&
operator|(
operator|~
name|mask
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|LINKER_RELAXING_SHRINKS_ONLY
if|if
condition|(
name|linkrelax
condition|)
comment|/* We must provide lots of padding, so the linker can discard it        when needed.  The linker will not add extra space, ever.  */
name|new_address
operator|+=
operator|(
literal|1
operator|<<
name|alignment
operator|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|new_address
operator|-
name|address
operator|)
return|;
block|}
end_function

begin_function
name|void
name|relax_segment
parameter_list|(
name|segment_frag_root
parameter_list|,
name|segment
parameter_list|)
name|struct
name|frag
modifier|*
name|segment_frag_root
decl_stmt|;
name|segT
name|segment
decl_stmt|;
block|{
specifier|register
name|struct
name|frag
modifier|*
name|fragP
decl_stmt|;
specifier|register
name|relax_addressT
name|address
decl_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|MANY_SEGMENTS
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|BFD_ASSEMBLER
argument_list|)
name|know
argument_list|(
name|segment
operator|==
name|SEG_DATA
operator|||
name|segment
operator|==
name|SEG_TEXT
operator|||
name|segment
operator|==
name|SEG_BSS
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* In case md_estimate_size_before_relax() wants to make fixSs. */
name|subseg_change
argument_list|(
name|segment
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* For each frag in segment: count and store  (a 1st guess of)      fr_address.  */
name|address
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|fragP
operator|=
name|segment_frag_root
init|;
name|fragP
condition|;
name|fragP
operator|=
name|fragP
operator|->
name|fr_next
control|)
block|{
name|fragP
operator|->
name|fr_address
operator|=
name|address
expr_stmt|;
name|address
operator|+=
name|fragP
operator|->
name|fr_fix
expr_stmt|;
switch|switch
condition|(
name|fragP
operator|->
name|fr_type
condition|)
block|{
case|case
name|rs_fill
case|:
name|address
operator|+=
name|fragP
operator|->
name|fr_offset
operator|*
name|fragP
operator|->
name|fr_var
expr_stmt|;
break|break;
case|case
name|rs_align
case|:
case|case
name|rs_align_code
case|:
block|{
name|addressT
name|offset
init|=
name|relax_align
argument_list|(
name|address
argument_list|,
operator|(
name|int
operator|)
name|fragP
operator|->
name|fr_offset
argument_list|)
decl_stmt|;
if|if
condition|(
name|fragP
operator|->
name|fr_subtype
operator|!=
literal|0
operator|&&
name|offset
operator|>
name|fragP
operator|->
name|fr_subtype
condition|)
name|offset
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|offset
operator|%
name|fragP
operator|->
name|fr_var
operator|!=
literal|0
condition|)
block|{
name|as_bad
argument_list|(
literal|"alignment padding (%lu bytes) not a multiple of %ld"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|offset
argument_list|,
operator|(
name|long
operator|)
name|fragP
operator|->
name|fr_var
argument_list|)
expr_stmt|;
name|offset
operator|-=
operator|(
name|offset
operator|%
name|fragP
operator|->
name|fr_var
operator|)
expr_stmt|;
block|}
name|address
operator|+=
name|offset
expr_stmt|;
block|}
break|break;
case|case
name|rs_org
case|:
case|case
name|rs_space
case|:
comment|/* Assume .org is nugatory. It will grow with 1st relax.  */
break|break;
case|case
name|rs_machine_dependent
case|:
name|address
operator|+=
name|md_estimate_size_before_relax
argument_list|(
name|fragP
argument_list|,
name|segment
argument_list|)
expr_stmt|;
break|break;
ifndef|#
directive|ifndef
name|WORKING_DOT_WORD
comment|/* Broken words don't concern us yet */
case|case
name|rs_broken_word
case|:
break|break;
endif|#
directive|endif
default|default:
name|BAD_CASE
argument_list|(
name|fragP
operator|->
name|fr_type
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* switch(fr_type) */
block|}
comment|/* for each frag in the segment */
comment|/* Do relax().  */
block|{
name|long
name|stretch
decl_stmt|;
comment|/* May be any size, 0 or negative. */
comment|/* Cumulative number of addresses we have */
comment|/* relaxed this pass. */
comment|/* We may have relaxed more than one address. */
name|long
name|stretched
decl_stmt|;
comment|/* Have we stretched on this pass? */
comment|/* This is 'cuz stretch may be zero, when, in fact some piece of code        grew, and another shrank.  If a branch instruction doesn't fit anymore,        we could be scrod.  */
do|do
block|{
name|stretch
operator|=
name|stretched
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|fragP
operator|=
name|segment_frag_root
init|;
name|fragP
condition|;
name|fragP
operator|=
name|fragP
operator|->
name|fr_next
control|)
block|{
name|long
name|growth
init|=
literal|0
decl_stmt|;
name|addressT
name|was_address
decl_stmt|;
name|offsetT
name|offset
decl_stmt|;
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
name|was_address
operator|=
name|fragP
operator|->
name|fr_address
expr_stmt|;
name|address
operator|=
name|fragP
operator|->
name|fr_address
operator|+=
name|stretch
expr_stmt|;
name|symbolP
operator|=
name|fragP
operator|->
name|fr_symbol
expr_stmt|;
name|offset
operator|=
name|fragP
operator|->
name|fr_offset
expr_stmt|;
switch|switch
condition|(
name|fragP
operator|->
name|fr_type
condition|)
block|{
case|case
name|rs_fill
case|:
comment|/* .fill never relaxes. */
name|growth
operator|=
literal|0
expr_stmt|;
break|break;
ifndef|#
directive|ifndef
name|WORKING_DOT_WORD
comment|/* JF:  This is RMS's idea.  I do *NOT* want to be blamed 		   for it I do not want to write it.  I do not want to have 		   anything to do with it.  This is not the proper way to 		   implement this misfeature.  */
case|case
name|rs_broken_word
case|:
block|{
name|struct
name|broken_word
modifier|*
name|lie
decl_stmt|;
name|struct
name|broken_word
modifier|*
name|untruth
decl_stmt|;
comment|/* Yes this is ugly (storing the broken_word pointer 		     in the symbol slot).  Still, this whole chunk of 		     code is ugly, and I don't feel like doing anything 		     about it.  Think of it as stubbornness in action.  */
name|growth
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|lie
operator|=
operator|(
expr|struct
name|broken_word
operator|*
operator|)
operator|(
name|fragP
operator|->
name|fr_symbol
operator|)
init|;
name|lie
operator|&&
name|lie
operator|->
name|dispfrag
operator|==
name|fragP
condition|;
name|lie
operator|=
name|lie
operator|->
name|next_broken_word
control|)
block|{
if|if
condition|(
name|lie
operator|->
name|added
condition|)
continue|continue;
name|offset
operator|=
operator|(
name|lie
operator|->
name|add
operator|->
name|sy_frag
operator|->
name|fr_address
operator|+
name|S_GET_VALUE
argument_list|(
name|lie
operator|->
name|add
argument_list|)
operator|+
name|lie
operator|->
name|addnum
operator|-
operator|(
name|lie
operator|->
name|sub
operator|->
name|sy_frag
operator|->
name|fr_address
operator|+
name|S_GET_VALUE
argument_list|(
name|lie
operator|->
name|sub
argument_list|)
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|offset
operator|<=
operator|-
literal|32768
operator|||
name|offset
operator|>=
literal|32767
condition|)
block|{
if|if
condition|(
name|flag_warn_displacement
condition|)
block|{
name|char
name|buf
index|[
literal|50
index|]
decl_stmt|;
name|sprint_value
argument_list|(
name|buf
argument_list|,
operator|(
name|addressT
operator|)
name|lie
operator|->
name|addnum
argument_list|)
expr_stmt|;
name|as_warn
argument_list|(
literal|".word %s-%s+%s didn't fit"
argument_list|,
name|S_GET_NAME
argument_list|(
name|lie
operator|->
name|add
argument_list|)
argument_list|,
name|S_GET_NAME
argument_list|(
name|lie
operator|->
name|sub
argument_list|)
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
name|lie
operator|->
name|added
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|fragP
operator|->
name|fr_subtype
operator|==
literal|0
condition|)
block|{
name|fragP
operator|->
name|fr_subtype
operator|++
expr_stmt|;
name|growth
operator|+=
name|md_short_jump_size
expr_stmt|;
block|}
for|for
control|(
name|untruth
operator|=
name|lie
operator|->
name|next_broken_word
init|;
name|untruth
operator|&&
name|untruth
operator|->
name|dispfrag
operator|==
name|lie
operator|->
name|dispfrag
condition|;
name|untruth
operator|=
name|untruth
operator|->
name|next_broken_word
control|)
if|if
condition|(
operator|(
name|untruth
operator|->
name|add
operator|->
name|sy_frag
operator|==
name|lie
operator|->
name|add
operator|->
name|sy_frag
operator|)
operator|&&
name|S_GET_VALUE
argument_list|(
name|untruth
operator|->
name|add
argument_list|)
operator|==
name|S_GET_VALUE
argument_list|(
name|lie
operator|->
name|add
argument_list|)
condition|)
block|{
name|untruth
operator|->
name|added
operator|=
literal|2
expr_stmt|;
name|untruth
operator|->
name|use_jump
operator|=
name|lie
expr_stmt|;
block|}
name|growth
operator|+=
name|md_long_jump_size
expr_stmt|;
block|}
block|}
break|break;
block|}
comment|/* case rs_broken_word */
endif|#
directive|endif
case|case
name|rs_align
case|:
case|case
name|rs_align_code
case|:
block|{
name|addressT
name|oldoff
decl_stmt|,
name|newoff
decl_stmt|;
name|oldoff
operator|=
name|relax_align
argument_list|(
name|was_address
operator|+
name|fragP
operator|->
name|fr_fix
argument_list|,
operator|(
name|int
operator|)
name|offset
argument_list|)
expr_stmt|;
name|newoff
operator|=
name|relax_align
argument_list|(
name|address
operator|+
name|fragP
operator|->
name|fr_fix
argument_list|,
operator|(
name|int
operator|)
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|fragP
operator|->
name|fr_subtype
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|oldoff
operator|>
name|fragP
operator|->
name|fr_subtype
condition|)
name|oldoff
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|newoff
operator|>
name|fragP
operator|->
name|fr_subtype
condition|)
name|newoff
operator|=
literal|0
expr_stmt|;
block|}
name|growth
operator|=
name|newoff
operator|-
name|oldoff
expr_stmt|;
block|}
break|break;
case|case
name|rs_org
case|:
block|{
name|long
name|target
init|=
name|offset
decl_stmt|;
name|long
name|after
decl_stmt|;
if|if
condition|(
name|symbolP
condition|)
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|MANY_SEGMENTS
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|BFD_ASSEMBLER
argument_list|)
name|know
argument_list|(
operator|(
name|S_GET_SEGMENT
argument_list|(
name|symbolP
argument_list|)
operator|==
name|SEG_ABSOLUTE
operator|)
operator|||
operator|(
name|S_GET_SEGMENT
argument_list|(
name|symbolP
argument_list|)
operator|==
name|SEG_DATA
operator|)
operator|||
operator|(
name|S_GET_SEGMENT
argument_list|(
name|symbolP
argument_list|)
operator|==
name|SEG_TEXT
operator|)
operator|||
name|S_GET_SEGMENT
argument_list|(
name|symbolP
argument_list|)
operator|==
name|SEG_BSS
argument_list|)
expr_stmt|;
name|know
argument_list|(
name|symbolP
operator|->
name|sy_frag
argument_list|)
expr_stmt|;
name|know
argument_list|(
operator|!
operator|(
name|S_GET_SEGMENT
argument_list|(
name|symbolP
argument_list|)
operator|==
name|SEG_ABSOLUTE
operator|)
operator|||
operator|(
name|symbolP
operator|->
name|sy_frag
operator|==
operator|&
name|zero_address_frag
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|target
operator|+=
name|S_GET_VALUE
argument_list|(
name|symbolP
argument_list|)
operator|+
name|symbolP
operator|->
name|sy_frag
operator|->
name|fr_address
expr_stmt|;
block|}
comment|/* if we have a symbol */
name|know
argument_list|(
name|fragP
operator|->
name|fr_next
argument_list|)
expr_stmt|;
name|after
operator|=
name|fragP
operator|->
name|fr_next
operator|->
name|fr_address
expr_stmt|;
name|growth
operator|=
name|target
operator|-
name|after
expr_stmt|;
if|if
condition|(
name|growth
operator|<
literal|0
condition|)
block|{
comment|/* Growth may be negative, but variable part of frag 			 cannot have fewer than 0 chars.  That is, we can't 			 .org backwards. */
name|as_bad
argument_list|(
literal|"attempt to .org backwards ignored"
argument_list|)
expr_stmt|;
name|growth
operator|=
literal|0
expr_stmt|;
block|}
name|growth
operator|-=
name|stretch
expr_stmt|;
comment|/* This is an absolute growth factor */
break|break;
block|}
case|case
name|rs_space
case|:
if|if
condition|(
name|symbolP
condition|)
block|{
name|growth
operator|=
name|S_GET_VALUE
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
if|if
condition|(
name|symbolP
operator|->
name|sy_frag
operator|!=
operator|&
name|zero_address_frag
operator|||
name|S_IS_COMMON
argument_list|(
name|symbolP
argument_list|)
operator|||
operator|!
name|S_IS_DEFINED
argument_list|(
name|symbolP
argument_list|)
condition|)
name|as_bad_where
argument_list|(
name|fragP
operator|->
name|fr_file
argument_list|,
name|fragP
operator|->
name|fr_line
argument_list|,
literal|".space specifies non-absolute value"
argument_list|)
expr_stmt|;
name|fragP
operator|->
name|fr_symbol
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|growth
operator|<
literal|0
condition|)
block|{
name|as_warn
argument_list|(
literal|".space or .fill with negative value, ignored"
argument_list|)
expr_stmt|;
name|growth
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
name|growth
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|rs_machine_dependent
case|:
ifdef|#
directive|ifdef
name|md_relax_frag
name|growth
operator|=
name|md_relax_frag
argument_list|(
name|fragP
argument_list|,
name|stretch
argument_list|)
expr_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|TC_GENERIC_RELAX_TABLE
comment|/* The default way to relax a frag is to look through 		   TC_GENERIC_RELAX_TABLE.  */
name|growth
operator|=
name|relax_frag
argument_list|(
name|fragP
argument_list|,
name|stretch
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* TC_GENERIC_RELAX_TABLE */
endif|#
directive|endif
break|break;
default|default:
name|BAD_CASE
argument_list|(
name|fragP
operator|->
name|fr_type
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|growth
condition|)
block|{
name|stretch
operator|+=
name|growth
expr_stmt|;
name|stretched
operator|++
expr_stmt|;
block|}
block|}
comment|/* For each frag in the segment. */
block|}
do|while
condition|(
name|stretched
condition|)
do|;
comment|/* Until nothing further to relax. */
block|}
comment|/* do_relax */
comment|/*    * We now have valid fr_address'es for each frag.    */
comment|/*    * All fr_address's are correct, relative to their own segment.    * We have made all the fixS we will ever make.    */
block|}
end_function

begin_comment
comment|/* relax_segment() */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|BFD_ASSEMBLER
argument_list|)
operator|||
operator|(
operator|!
name|defined
argument_list|(
name|BFD
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|OBJ_VMS
argument_list|)
operator|)
end_if

begin_ifndef
ifndef|#
directive|ifndef
name|TC_RELOC_RTSYM_LOC_FIXUP
end_ifndef

begin_define
define|#
directive|define
name|TC_RELOC_RTSYM_LOC_FIXUP
parameter_list|(
name|X
parameter_list|)
value|(1)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* fixup_segment()     Go through all the fixS's in a segment and see which ones can be    handled now.  (These consist of fixS where we have since discovered    the value of a symbol, or the address of the frag involved.)    For each one, call md_apply_fix to put the fix into the frag data.     Result is a count of how many relocation structs will be needed to    handle the remaining fixS's that we couldn't completely handle here.    These will be output later by emit_relocations().  */
end_comment

begin_function
specifier|static
name|long
name|fixup_segment
parameter_list|(
name|fixP
parameter_list|,
name|this_segment_type
parameter_list|)
specifier|register
name|fixS
modifier|*
name|fixP
decl_stmt|;
name|segT
name|this_segment_type
decl_stmt|;
comment|/* N_TYPE bits for segment. */
block|{
name|long
name|seg_reloc_count
init|=
literal|0
decl_stmt|;
name|symbolS
modifier|*
name|add_symbolP
decl_stmt|;
name|symbolS
modifier|*
name|sub_symbolP
decl_stmt|;
name|valueT
name|add_number
decl_stmt|;
name|int
name|size
decl_stmt|;
name|char
modifier|*
name|place
decl_stmt|;
name|long
name|where
decl_stmt|;
name|int
name|pcrel
decl_stmt|,
name|plt
decl_stmt|;
name|fragS
modifier|*
name|fragP
decl_stmt|;
name|segT
name|add_symbol_segment
init|=
name|absolute_section
decl_stmt|;
comment|/* If the linker is doing the relaxing, we must not do any fixups.       Well, strictly speaking that's not true -- we could do any that are      PC-relative and don't cross regions that could change size.  And for the      i960 (the only machine for which we've got a relaxing linker right now),      we might be able to turn callx/callj into bal anyways in cases where we      know the maximum displacement.  */
if|if
condition|(
name|linkrelax
condition|)
block|{
for|for
control|(
init|;
name|fixP
condition|;
name|fixP
operator|=
name|fixP
operator|->
name|fx_next
control|)
name|seg_reloc_count
operator|++
expr_stmt|;
name|TC_ADJUST_RELOC_COUNT
argument_list|(
name|fixP
argument_list|,
name|seg_reloc_count
argument_list|)
expr_stmt|;
return|return
name|seg_reloc_count
return|;
block|}
for|for
control|(
init|;
name|fixP
condition|;
name|fixP
operator|=
name|fixP
operator|->
name|fx_next
control|)
block|{
ifdef|#
directive|ifdef
name|DEBUG5
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\nprocessing fixup:\n"
argument_list|)
expr_stmt|;
name|print_fixup
argument_list|(
name|fixP
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|fragP
operator|=
name|fixP
operator|->
name|fx_frag
expr_stmt|;
name|know
argument_list|(
name|fragP
argument_list|)
expr_stmt|;
name|where
operator|=
name|fixP
operator|->
name|fx_where
expr_stmt|;
name|place
operator|=
name|fragP
operator|->
name|fr_literal
operator|+
name|where
expr_stmt|;
name|size
operator|=
name|fixP
operator|->
name|fx_size
expr_stmt|;
name|add_symbolP
operator|=
name|fixP
operator|->
name|fx_addsy
expr_stmt|;
ifdef|#
directive|ifdef
name|TC_VALIDATE_FIX
name|TC_VALIDATE_FIX
argument_list|(
name|fixP
argument_list|,
name|this_segment_type
argument_list|,
name|skip
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sub_symbolP
operator|=
name|fixP
operator|->
name|fx_subsy
expr_stmt|;
name|add_number
operator|=
name|fixP
operator|->
name|fx_offset
expr_stmt|;
name|pcrel
operator|=
name|fixP
operator|->
name|fx_pcrel
expr_stmt|;
name|plt
operator|=
name|fixP
operator|->
name|fx_plt
expr_stmt|;
if|if
condition|(
name|add_symbolP
operator|!=
name|NULL
operator|&&
name|add_symbolP
operator|->
name|sy_mri_common
condition|)
block|{
name|know
argument_list|(
name|add_symbolP
operator|->
name|sy_value
operator|.
name|X_op
operator|==
name|O_symbol
argument_list|)
expr_stmt|;
name|add_number
operator|+=
name|S_GET_VALUE
argument_list|(
name|add_symbolP
argument_list|)
expr_stmt|;
name|fixP
operator|->
name|fx_offset
operator|=
name|add_number
expr_stmt|;
name|add_symbolP
operator|=
name|fixP
operator|->
name|fx_addsy
operator|=
name|add_symbolP
operator|->
name|sy_value
operator|.
name|X_add_symbol
expr_stmt|;
block|}
if|if
condition|(
name|add_symbolP
condition|)
name|add_symbol_segment
operator|=
name|S_GET_SEGMENT
argument_list|(
name|add_symbolP
argument_list|)
expr_stmt|;
if|if
condition|(
name|sub_symbolP
condition|)
block|{
name|resolve_symbol_value
argument_list|(
name|sub_symbolP
argument_list|)
expr_stmt|;
if|if
condition|(
name|add_symbolP
operator|==
name|NULL
operator|||
name|add_symbol_segment
operator|==
name|absolute_section
condition|)
block|{
if|if
condition|(
name|add_symbolP
operator|!=
name|NULL
condition|)
block|{
name|add_number
operator|+=
name|S_GET_VALUE
argument_list|(
name|add_symbolP
argument_list|)
expr_stmt|;
name|add_symbolP
operator|=
name|NULL
expr_stmt|;
name|fixP
operator|->
name|fx_addsy
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* It's just -sym */
if|if
condition|(
name|S_GET_SEGMENT
argument_list|(
name|sub_symbolP
argument_list|)
operator|==
name|absolute_section
condition|)
block|{
name|add_number
operator|-=
name|S_GET_VALUE
argument_list|(
name|sub_symbolP
argument_list|)
expr_stmt|;
name|fixP
operator|->
name|fx_subsy
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pcrel
operator|&&
name|S_GET_SEGMENT
argument_list|(
name|sub_symbolP
argument_list|)
operator|==
name|this_segment_type
condition|)
block|{
comment|/* Should try converting to a constant.  */
goto|goto
name|bad_sub_reloc
goto|;
block|}
else|else
name|bad_sub_reloc
label|:
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
literal|"Negative of non-absolute symbol %s"
argument_list|,
name|S_GET_NAME
argument_list|(
name|sub_symbolP
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|S_GET_SEGMENT
argument_list|(
name|sub_symbolP
argument_list|)
operator|==
name|add_symbol_segment
operator|&&
name|SEG_NORMAL
argument_list|(
name|add_symbol_segment
argument_list|)
condition|)
block|{
comment|/* Difference of 2 symbols from same segment. 		 Can't make difference of 2 undefineds: 'value' means 		 something different for N_UNDF. */
ifdef|#
directive|ifdef
name|TC_I960
comment|/* Makes no sense to use the difference of 2 arbitrary symbols 		 as the target of a call instruction.  */
if|if
condition|(
name|fixP
operator|->
name|fx_tcbit
condition|)
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
literal|"callj to difference of 2 symbols"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* TC_I960 */
name|add_number
operator|+=
name|S_GET_VALUE
argument_list|(
name|add_symbolP
argument_list|)
operator|-
name|S_GET_VALUE
argument_list|(
name|sub_symbolP
argument_list|)
expr_stmt|;
name|add_symbolP
operator|=
name|NULL
expr_stmt|;
name|pcrel
operator|=
literal|0
expr_stmt|;
comment|/* No further pcrel processing. */
comment|/* Let the target machine make the final determination 		 as to whether or not a relocation will be needed to 		 handle this fixup.  */
if|if
condition|(
operator|!
name|TC_FORCE_RELOCATION_SECTION
argument_list|(
name|fixP
argument_list|,
name|this_segment_type
argument_list|)
condition|)
block|{
name|fixP
operator|->
name|fx_pcrel
operator|=
literal|0
expr_stmt|;
name|fixP
operator|->
name|fx_addsy
operator|=
name|NULL
expr_stmt|;
name|fixP
operator|->
name|fx_subsy
operator|=
name|NULL
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Different segments in subtraction. */
name|know
argument_list|(
operator|!
operator|(
name|S_IS_EXTERNAL
argument_list|(
name|sub_symbolP
argument_list|)
operator|&&
operator|(
name|S_GET_SEGMENT
argument_list|(
name|sub_symbolP
argument_list|)
operator|==
name|absolute_section
operator|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|S_GET_SEGMENT
argument_list|(
name|sub_symbolP
argument_list|)
operator|==
name|absolute_section
operator|)
condition|)
name|add_number
operator|-=
name|S_GET_VALUE
argument_list|(
name|sub_symbolP
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DIFF_EXPR_OK
elseif|else
if|if
condition|(
name|S_GET_SEGMENT
argument_list|(
name|sub_symbolP
argument_list|)
operator|==
name|this_segment_type
if|#
directive|if
literal|0
comment|/* Do this even if it's already described as pc-relative.  For example, 	 on the m68k, an operand of "pc@(foo-.-2)" should address "foo" in a 	 pc-relative mode.  */
condition|&& pcrel
endif|#
directive|endif
condition|)
block|{
comment|/* Make it pc-relative.  */
name|add_number
operator|+=
operator|(
name|MD_PCREL_FROM_SECTION
argument_list|(
name|fixP
argument_list|,
name|this_segment_type
argument_list|)
operator|-
name|S_GET_VALUE
argument_list|(
name|sub_symbolP
argument_list|)
operator|)
expr_stmt|;
name|pcrel
operator|=
literal|1
expr_stmt|;
name|fixP
operator|->
name|fx_pcrel
operator|=
literal|1
expr_stmt|;
name|sub_symbolP
operator|=
literal|0
expr_stmt|;
name|fixP
operator|->
name|fx_subsy
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|UNDEFINED_DIFFERENCE_OK
comment|/* The PA needs this for PIC code generation.  We basically 		 don't want to do anything if we have the difference of two 		 symbols at this point.  */
elseif|else
if|if
condition|(
literal|1
condition|)
block|{
comment|/* Leave it alone.  */
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|BFD_ASSEMBLER
elseif|else
if|if
condition|(
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_GPREL32
operator|||
name|fixP
operator|->
name|fx_r_type
operator|==
name|BFD_RELOC_GPREL16
condition|)
block|{
comment|/* Leave it alone.  */
block|}
endif|#
directive|endif
else|else
block|{
name|char
name|buf
index|[
literal|50
index|]
decl_stmt|;
name|sprint_value
argument_list|(
name|buf
argument_list|,
name|fragP
operator|->
name|fr_address
operator|+
name|where
argument_list|)
expr_stmt|;
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
literal|"Can't emit reloc {- %s-seg symbol \"%s\"} @ file address %s."
argument_list|,
name|segment_name
argument_list|(
name|S_GET_SEGMENT
argument_list|(
name|sub_symbolP
argument_list|)
argument_list|)
argument_list|,
name|S_GET_NAME
argument_list|(
name|sub_symbolP
argument_list|)
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|add_symbolP
condition|)
block|{
if|if
condition|(
name|add_symbol_segment
operator|==
name|this_segment_type
operator|&&
name|pcrel
operator|&&
operator|!
name|plt
operator|&&
name|TC_RELOC_RTSYM_LOC_FIXUP
argument_list|(
name|fixP
argument_list|)
condition|)
block|{
comment|/* 	       * This fixup was made when the symbol's segment was 	       * SEG_UNKNOWN, but it is now in the local segment. 	       * So we know how to do the address without relocation. 	       */
ifdef|#
directive|ifdef
name|TC_I960
comment|/* reloc_callj() may replace a 'call' with a 'calls' or a 		 'bal', in which cases it modifies *fixP as appropriate. 		 In the case of a 'calls', no further work is required, 		 and *fixP has been set up to make the rest of the code 		 below a no-op. */
name|reloc_callj
argument_list|(
name|fixP
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* TC_I960 */
name|add_number
operator|+=
name|S_GET_VALUE
argument_list|(
name|add_symbolP
argument_list|)
expr_stmt|;
name|add_number
operator|-=
name|MD_PCREL_FROM_SECTION
argument_list|(
name|fixP
argument_list|,
name|this_segment_type
argument_list|)
expr_stmt|;
name|pcrel
operator|=
literal|0
expr_stmt|;
comment|/* Lie. Don't want further pcrel processing. */
comment|/* Let the target machine make the final determination 		 as to whether or not a relocation will be needed to 		 handle this fixup.  */
if|if
condition|(
operator|!
name|TC_FORCE_RELOCATION
argument_list|(
name|fixP
argument_list|)
condition|)
block|{
name|fixP
operator|->
name|fx_pcrel
operator|=
literal|0
expr_stmt|;
name|fixP
operator|->
name|fx_addsy
operator|=
name|NULL
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|add_symbol_segment
operator|==
name|absolute_section
operator|&&
operator|!
name|pcrel
condition|)
block|{
ifdef|#
directive|ifdef
name|TC_I960
comment|/* See comment about reloc_callj() above.  */
name|reloc_callj
argument_list|(
name|fixP
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* TC_I960 */
name|add_number
operator|+=
name|S_GET_VALUE
argument_list|(
name|add_symbolP
argument_list|)
expr_stmt|;
comment|/* Let the target machine make the final determination 		     as to whether or not a relocation will be needed to 		     handle this fixup.  */
if|if
condition|(
operator|!
name|TC_FORCE_RELOCATION
argument_list|(
name|fixP
argument_list|)
condition|)
block|{
name|fixP
operator|->
name|fx_addsy
operator|=
name|NULL
expr_stmt|;
name|add_symbolP
operator|=
name|NULL
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|add_symbol_segment
operator|==
name|undefined_section
ifdef|#
directive|ifdef
name|BFD_ASSEMBLER
operator|||
name|bfd_is_com_section
argument_list|(
name|add_symbol_segment
argument_list|)
endif|#
directive|endif
condition|)
block|{
ifdef|#
directive|ifdef
name|TC_I960
if|if
condition|(
operator|(
name|int
operator|)
name|fixP
operator|->
name|fx_bit_fixP
operator|==
literal|13
condition|)
block|{
comment|/* This is a COBR instruction.  They have only a 		       * 13-bit displacement and are only to be used 		       * for local branches: flag as error, don't generate 		       * relocation. 		       */
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
literal|"can't use COBR format with external label"
argument_list|)
expr_stmt|;
name|fixP
operator|->
name|fx_addsy
operator|=
name|NULL
expr_stmt|;
name|fixP
operator|->
name|fx_done
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
comment|/* COBR */
endif|#
directive|endif
comment|/* TC_I960 */
ifdef|#
directive|ifdef
name|OBJ_COFF
ifdef|#
directive|ifdef
name|TE_I386AIX
if|if
condition|(
name|S_IS_COMMON
argument_list|(
name|add_symbolP
argument_list|)
condition|)
name|add_number
operator|+=
name|S_GET_VALUE
argument_list|(
name|add_symbolP
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* TE_I386AIX */
endif|#
directive|endif
comment|/* OBJ_COFF */
operator|++
name|seg_reloc_count
expr_stmt|;
block|}
else|else
block|{
name|seg_reloc_count
operator|++
expr_stmt|;
if|#
directive|if
operator|!
operator|(
name|defined
argument_list|(
name|TC_M68K
argument_list|)
operator|&&
name|defined
argument_list|(
name|OBJ_ELF
argument_list|)
operator|)
if|#
directive|if
operator|!
name|defined
argument_list|(
name|TC_I386
argument_list|)
operator|||
operator|!
operator|(
name|defined
argument_list|(
name|OBJ_ELF
argument_list|)
operator|||
name|defined
argument_list|(
name|OBJ_COFF
argument_list|)
operator|)
name|add_number
operator|+=
name|S_GET_VALUE
argument_list|(
name|add_symbolP
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
block|}
block|}
block|}
if|if
condition|(
name|pcrel
condition|)
block|{
name|add_number
operator|-=
name|MD_PCREL_FROM_SECTION
argument_list|(
name|fixP
argument_list|,
name|this_segment_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|add_symbolP
operator|==
literal|0
condition|)
block|{
ifndef|#
directive|ifndef
name|BFD_ASSEMBLER
name|fixP
operator|->
name|fx_addsy
operator|=
operator|&
name|abs_symbol
expr_stmt|;
else|#
directive|else
name|fixP
operator|->
name|fx_addsy
operator|=
name|section_symbol
argument_list|(
name|absolute_section
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|fixP
operator|->
name|fx_addsy
operator|->
name|sy_used_in_reloc
operator|=
literal|1
expr_stmt|;
operator|++
name|seg_reloc_count
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|fixP
operator|->
name|fx_bit_fixP
operator|&&
operator|!
name|fixP
operator|->
name|fx_no_overflow
operator|&&
name|size
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|size
operator|<
sizeof|sizeof
argument_list|(
name|valueT
argument_list|)
condition|)
block|{
name|valueT
name|mask
decl_stmt|,
name|hibit
decl_stmt|;
comment|/* set all bits to one */
name|mask
operator|=
literal|0
expr_stmt|;
name|mask
operator|--
expr_stmt|;
comment|/* Technically, combining these produces an undefined result 		 if size is sizeof (valueT), though I think these two 		 half-way operations should both be defined.  And the 		 compiler should be able to combine them if it's valid on 		 the host architecture.  */
name|mask
operator|<<=
name|size
operator|*
literal|4
expr_stmt|;
name|mask
operator|<<=
name|size
operator|*
literal|4
expr_stmt|;
name|hibit
operator|=
operator|(
name|valueT
operator|)
literal|1
operator|<<
operator|(
name|size
operator|*
literal|8
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|add_number
operator|&
name|mask
operator|)
operator|!=
literal|0
operator|||
operator|(
name|fixP
operator|->
name|fx_signed
operator|&&
operator|(
name|add_number
operator|&
name|hibit
operator|)
operator|!=
literal|0
operator|)
operator|)
operator|&&
operator|(
operator|(
name|add_number
operator|&
name|mask
operator|)
operator|!=
name|mask
operator|||
operator|(
name|add_number
operator|&
name|hibit
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|char
name|buf
index|[
literal|50
index|]
decl_stmt|,
name|buf2
index|[
literal|50
index|]
decl_stmt|;
name|sprint_value
argument_list|(
name|buf
argument_list|,
name|fragP
operator|->
name|fr_address
operator|+
name|where
argument_list|)
expr_stmt|;
if|if
condition|(
name|add_number
operator|>
literal|1000
condition|)
name|sprint_value
argument_list|(
name|buf2
argument_list|,
name|add_number
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|buf2
argument_list|,
literal|"%ld"
argument_list|,
operator|(
name|long
operator|)
name|add_number
argument_list|)
expr_stmt|;
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
literal|"Value of %s too large for field of %d bytes at %s"
argument_list|,
name|buf2
argument_list|,
name|size
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
comment|/* generic error checking */
block|}
ifdef|#
directive|ifdef
name|WARN_SIGNED_OVERFLOW_WORD
comment|/* Warn if a .word value is too large when treated as a signed 	     number.  We already know it is not too negative.  This is to 	     catch over-large switches generated by gcc on the 68k.  */
if|if
condition|(
operator|!
name|flag_signed_overflow_ok
operator|&&
name|size
operator|==
literal|2
operator|&&
name|add_number
operator|>
literal|0x7fff
condition|)
name|as_bad_where
argument_list|(
name|fixP
operator|->
name|fx_file
argument_list|,
name|fixP
operator|->
name|fx_line
argument_list|,
literal|"Signed .word overflow; switch may be too large; %ld at 0x%lx"
argument_list|,
operator|(
name|long
operator|)
name|add_number
argument_list|,
call|(
name|unsigned
name|long
call|)
argument_list|(
name|fragP
operator|->
name|fr_address
operator|+
name|where
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* not a bit fix */
if|if
condition|(
operator|!
name|fixP
operator|->
name|fx_done
condition|)
block|{
ifdef|#
directive|ifdef
name|MD_APPLY_FIX3
name|md_apply_fix3
argument_list|(
name|fixP
argument_list|,
operator|&
name|add_number
argument_list|,
name|this_segment_type
argument_list|)
expr_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|BFD_ASSEMBLER
name|md_apply_fix
argument_list|(
name|fixP
argument_list|,
operator|&
name|add_number
argument_list|)
expr_stmt|;
else|#
directive|else
name|md_apply_fix
argument_list|(
name|fixP
argument_list|,
name|add_number
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
ifndef|#
directive|ifndef
name|TC_HANDLES_FX_DONE
comment|/* If the tc-* files haven't been converted, assume it's handling 	     it the old way, where a null fx_addsy means that the fix has 	     been applied completely, and no further work is needed.  */
if|if
condition|(
name|fixP
operator|->
name|fx_addsy
operator|==
literal|0
operator|&&
name|fixP
operator|->
name|fx_pcrel
operator|==
literal|0
condition|)
name|fixP
operator|->
name|fx_done
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
block|}
ifdef|#
directive|ifdef
name|TC_VALIDATE_FIX
name|skip
label|:
empty_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DEBUG5
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"result:\n"
argument_list|)
expr_stmt|;
name|print_fixup
argument_list|(
name|fixP
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* For each fixS in this segment. */
name|TC_ADJUST_RELOC_COUNT
argument_list|(
name|fixP
argument_list|,
name|seg_reloc_count
argument_list|)
expr_stmt|;
return|return
name|seg_reloc_count
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* defined (BFD_ASSEMBLER) || (!defined (BFD)&& !defined (OBJ_VMS)) */
end_comment

begin_function
name|void
name|number_to_chars_bigendian
parameter_list|(
name|buf
parameter_list|,
name|val
parameter_list|,
name|n
parameter_list|)
name|char
modifier|*
name|buf
decl_stmt|;
name|valueT
name|val
decl_stmt|;
name|int
name|n
decl_stmt|;
block|{
if|if
condition|(
name|n
operator|>
sizeof|sizeof
argument_list|(
name|val
argument_list|)
operator|||
name|n
operator|<=
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
while|while
condition|(
name|n
operator|--
condition|)
block|{
name|buf
index|[
name|n
index|]
operator|=
name|val
operator|&
literal|0xff
expr_stmt|;
name|val
operator|>>=
literal|8
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|number_to_chars_littleendian
parameter_list|(
name|buf
parameter_list|,
name|val
parameter_list|,
name|n
parameter_list|)
name|char
modifier|*
name|buf
decl_stmt|;
name|valueT
name|val
decl_stmt|;
name|int
name|n
decl_stmt|;
block|{
if|if
condition|(
name|n
operator|>
sizeof|sizeof
argument_list|(
name|val
argument_list|)
operator|||
name|n
operator|<=
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
while|while
condition|(
name|n
operator|--
condition|)
block|{
operator|*
name|buf
operator|++
operator|=
name|val
operator|&
literal|0xff
expr_stmt|;
name|val
operator|>>=
literal|8
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|write_print_statistics
parameter_list|(
name|file
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"fixups: %d\n"
argument_list|,
name|n_fixups
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* for debugging */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|indent_level
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|print_fixup
parameter_list|(
name|fixp
parameter_list|)
name|fixS
modifier|*
name|fixp
decl_stmt|;
block|{
name|indent_level
operator|=
literal|1
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"fix %lx %s:%d"
argument_list|,
operator|(
name|long
operator|)
name|fixp
argument_list|,
name|fixp
operator|->
name|fx_file
argument_list|,
name|fixp
operator|->
name|fx_line
argument_list|)
expr_stmt|;
if|if
condition|(
name|fixp
operator|->
name|fx_pcrel
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" pcrel"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fixp
operator|->
name|fx_pcrel_adjust
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" pcrel_adjust=%d"
argument_list|,
name|fixp
operator|->
name|fx_pcrel_adjust
argument_list|)
expr_stmt|;
if|if
condition|(
name|fixp
operator|->
name|fx_im_disp
condition|)
block|{
ifdef|#
directive|ifdef
name|TC_NS32K
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" im_disp=%d"
argument_list|,
name|fixp
operator|->
name|fx_im_disp
argument_list|)
expr_stmt|;
else|#
directive|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" im_disp"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|fixp
operator|->
name|fx_tcbit
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" tcbit"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fixp
operator|->
name|fx_done
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" done"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n    size=%d frag=%lx where=%ld offset=%lx addnumber=%lx"
argument_list|,
name|fixp
operator|->
name|fx_size
argument_list|,
operator|(
name|long
operator|)
name|fixp
operator|->
name|fx_frag
argument_list|,
operator|(
name|long
operator|)
name|fixp
operator|->
name|fx_where
argument_list|,
operator|(
name|long
operator|)
name|fixp
operator|->
name|fx_offset
argument_list|,
operator|(
name|long
operator|)
name|fixp
operator|->
name|fx_addnumber
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|BFD_ASSEMBLER
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n    %s (%d)"
argument_list|,
name|bfd_get_reloc_code_name
argument_list|(
name|fixp
operator|->
name|fx_r_type
argument_list|)
argument_list|,
name|fixp
operator|->
name|fx_r_type
argument_list|)
expr_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|NEED_FX_R_TYPE
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" r_type=%d"
argument_list|,
name|fixp
operator|->
name|fx_r_type
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
if|if
condition|(
name|fixp
operator|->
name|fx_addsy
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n   +<"
argument_list|)
expr_stmt|;
name|print_symbol_value_1
argument_list|(
name|stderr
argument_list|,
name|fixp
operator|->
name|fx_addsy
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|">"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fixp
operator|->
name|fx_subsy
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n   -<"
argument_list|)
expr_stmt|;
name|print_symbol_value_1
argument_list|(
name|stderr
argument_list|,
name|fixp
operator|->
name|fx_subsy
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|">"
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* end of write.c */
end_comment

end_unit

