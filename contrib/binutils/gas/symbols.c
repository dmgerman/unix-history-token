begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* symbols.c -symbol table-    Copyright (C) 1987, 90, 91, 92, 93, 94, 95, 96, 1997    Free Software Foundation, Inc.     This file is part of GAS, the GNU Assembler.     GAS is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     GAS is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with GAS; see the file COPYING.  If not, write to the Free    Software Foundation, 59 Temple Place - Suite 330, Boston, MA    02111-1307, USA.  */
end_comment

begin_comment
comment|/* #define DEBUG_SYMS / * to debug symbol list maintenance */
end_comment

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|"as.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_comment
comment|/* For "symbols.h" */
end_comment

begin_include
include|#
directive|include
file|"subsegs.h"
end_include

begin_comment
comment|/* This is non-zero if symbols are case sensitive, which is the    default.  */
end_comment

begin_decl_stmt
name|int
name|symbols_case_sensitive
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|WORKING_DOT_WORD
end_ifndef

begin_decl_stmt
specifier|extern
name|int
name|new_broken_words
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* symbol-name => struct symbol pointer */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|hash_control
modifier|*
name|sy_hash
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Below are commented in "symbols.h". */
end_comment

begin_decl_stmt
name|symbolS
modifier|*
name|symbol_rootP
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|symbolS
modifier|*
name|symbol_lastP
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|symbolS
name|abs_symbol
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG_SYMS
end_ifdef

begin_define
define|#
directive|define
name|debug_verify_symchain
value|verify_symbol_chain
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|debug_verify_symchain
parameter_list|(
name|root
parameter_list|,
name|last
parameter_list|)
value|((void) 0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|struct
name|obstack
name|notes
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|fb_label_init
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|dollar_label_instance
name|PARAMS
argument_list|(
operator|(
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|fb_label_instance
name|PARAMS
argument_list|(
operator|(
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* symbol_new()       Return a pointer to a new symbol.  Die if we can't make a new    symbol.  Fill in the symbol's values.  Add symbol to end of symbol    chain.      This function should be called in the general case of creating a    symbol.  However, if the output file symbol table has already been    set, and you are certain that this symbol won't be wanted in the    output file, you can call symbol_create.  */
end_comment

begin_function
name|symbolS
modifier|*
name|symbol_new
parameter_list|(
name|name
parameter_list|,
name|segment
parameter_list|,
name|valu
parameter_list|,
name|frag
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|segT
name|segment
decl_stmt|;
name|valueT
name|valu
decl_stmt|;
name|fragS
modifier|*
name|frag
decl_stmt|;
block|{
name|symbolS
modifier|*
name|symbolP
init|=
name|symbol_create
argument_list|(
name|name
argument_list|,
name|segment
argument_list|,
name|valu
argument_list|,
name|frag
argument_list|)
decl_stmt|;
comment|/*    * Link to end of symbol chain.    */
ifdef|#
directive|ifdef
name|BFD_ASSEMBLER
block|{
specifier|extern
name|int
name|symbol_table_frozen
decl_stmt|;
if|if
condition|(
name|symbol_table_frozen
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
name|symbol_append
argument_list|(
name|symbolP
argument_list|,
name|symbol_lastP
argument_list|,
operator|&
name|symbol_rootP
argument_list|,
operator|&
name|symbol_lastP
argument_list|)
expr_stmt|;
return|return
name|symbolP
return|;
block|}
end_function

begin_function
name|symbolS
modifier|*
name|symbol_create
parameter_list|(
name|name
parameter_list|,
name|segment
parameter_list|,
name|valu
parameter_list|,
name|frag
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
comment|/* It is copied, the caller can destroy/modify */
name|segT
name|segment
decl_stmt|;
comment|/* Segment identifier (SEG_<something>) */
name|valueT
name|valu
decl_stmt|;
comment|/* Symbol value */
name|fragS
modifier|*
name|frag
decl_stmt|;
comment|/* Associated fragment */
block|{
name|unsigned
name|int
name|name_length
decl_stmt|;
name|char
modifier|*
name|preserved_copy_of_name
decl_stmt|;
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
name|name_length
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
expr_stmt|;
comment|/* +1 for \0 */
name|obstack_grow
argument_list|(
operator|&
name|notes
argument_list|,
name|name
argument_list|,
name|name_length
argument_list|)
expr_stmt|;
name|preserved_copy_of_name
operator|=
name|obstack_finish
argument_list|(
operator|&
name|notes
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|STRIP_UNDERSCORE
if|if
condition|(
name|preserved_copy_of_name
index|[
literal|0
index|]
operator|==
literal|'_'
condition|)
name|preserved_copy_of_name
operator|++
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|tc_canonicalize_symbol_name
name|preserved_copy_of_name
operator|=
name|tc_canonicalize_symbol_name
argument_list|(
name|preserved_copy_of_name
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|symbols_case_sensitive
condition|)
block|{
name|unsigned
name|char
modifier|*
name|s
decl_stmt|;
for|for
control|(
name|s
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|preserved_copy_of_name
init|;
operator|*
name|s
operator|!=
literal|'\0'
condition|;
name|s
operator|++
control|)
if|if
condition|(
name|islower
argument_list|(
operator|*
name|s
argument_list|)
condition|)
operator|*
name|s
operator|=
name|toupper
argument_list|(
operator|*
name|s
argument_list|)
expr_stmt|;
block|}
name|symbolP
operator|=
operator|(
name|symbolS
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|notes
argument_list|,
sizeof|sizeof
argument_list|(
name|symbolS
argument_list|)
argument_list|)
expr_stmt|;
comment|/* symbol must be born in some fixed state.  This seems as good as any. */
name|memset
argument_list|(
name|symbolP
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|symbolS
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|BFD_ASSEMBLER
name|symbolP
operator|->
name|bsym
operator|=
name|bfd_make_empty_symbol
argument_list|(
name|stdoutput
argument_list|)
expr_stmt|;
if|if
condition|(
name|symbolP
operator|->
name|bsym
operator|==
name|NULL
condition|)
name|as_perror
argument_list|(
literal|"%s"
argument_list|,
literal|"bfd_make_empty_symbol"
argument_list|)
expr_stmt|;
name|symbolP
operator|->
name|bsym
operator|->
name|udata
operator|.
name|p
operator|=
operator|(
name|PTR
operator|)
name|symbolP
expr_stmt|;
endif|#
directive|endif
name|S_SET_NAME
argument_list|(
name|symbolP
argument_list|,
name|preserved_copy_of_name
argument_list|)
expr_stmt|;
name|S_SET_SEGMENT
argument_list|(
name|symbolP
argument_list|,
name|segment
argument_list|)
expr_stmt|;
name|S_SET_VALUE
argument_list|(
name|symbolP
argument_list|,
name|valu
argument_list|)
expr_stmt|;
name|symbol_clear_list_pointers
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
name|symbolP
operator|->
name|sy_frag
operator|=
name|frag
expr_stmt|;
ifndef|#
directive|ifndef
name|BFD_ASSEMBLER
name|symbolP
operator|->
name|sy_number
operator|=
operator|~
literal|0
expr_stmt|;
name|symbolP
operator|->
name|sy_name_offset
operator|=
operator|(
name|unsigned
name|int
operator|)
operator|~
literal|0
expr_stmt|;
endif|#
directive|endif
name|obj_symbol_new_hook
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|tc_symbol_new_hook
name|tc_symbol_new_hook
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|symbolP
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *			colon()  *  * We have just seen "<name>:".  * Creates a struct symbol unless it already exists.  *  * Gripes if we are redefining a symbol incompatibly (and ignores it).  *  */
end_comment

begin_function
name|symbolS
modifier|*
name|colon
parameter_list|(
name|sym_name
parameter_list|)
comment|/* just seen "x:" - rattle symbols& frags */
specifier|const
name|char
modifier|*
name|sym_name
decl_stmt|;
comment|/* symbol name, as a cannonical string */
comment|/* We copy this string: OK to alter later. */
block|{
specifier|register
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
comment|/* symbol we are working with */
comment|/* Sun local labels go out of scope whenever a non-local symbol is      defined.  */
if|if
condition|(
name|LOCAL_LABELS_DOLLAR
condition|)
block|{
name|int
name|local
decl_stmt|;
ifdef|#
directive|ifdef
name|BFD_ASSEMBLER
name|local
operator|=
name|bfd_is_local_label_name
argument_list|(
name|stdoutput
argument_list|,
name|sym_name
argument_list|)
expr_stmt|;
else|#
directive|else
name|local
operator|=
name|LOCAL_LABEL
argument_list|(
name|sym_name
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|local
condition|)
name|dollar_label_clear
argument_list|()
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|WORKING_DOT_WORD
if|if
condition|(
name|new_broken_words
condition|)
block|{
name|struct
name|broken_word
modifier|*
name|a
decl_stmt|;
name|int
name|possible_bytes
decl_stmt|;
name|fragS
modifier|*
name|frag_tmp
decl_stmt|;
name|char
modifier|*
name|frag_opcode
decl_stmt|;
specifier|extern
specifier|const
name|int
name|md_short_jump_size
decl_stmt|;
specifier|extern
specifier|const
name|int
name|md_long_jump_size
decl_stmt|;
name|possible_bytes
operator|=
operator|(
name|md_short_jump_size
operator|+
name|new_broken_words
operator|*
name|md_long_jump_size
operator|)
expr_stmt|;
name|frag_tmp
operator|=
name|frag_now
expr_stmt|;
name|frag_opcode
operator|=
name|frag_var
argument_list|(
name|rs_broken_word
argument_list|,
name|possible_bytes
argument_list|,
name|possible_bytes
argument_list|,
operator|(
name|relax_substateT
operator|)
literal|0
argument_list|,
operator|(
name|symbolS
operator|*
operator|)
name|broken_words
argument_list|,
operator|(
name|offsetT
operator|)
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* We want to store the pointer to where to insert the jump table in the 	 fr_opcode of the rs_broken_word frag.  This requires a little 	 hackery.  */
while|while
condition|(
name|frag_tmp
operator|&&
operator|(
name|frag_tmp
operator|->
name|fr_type
operator|!=
name|rs_broken_word
operator|||
name|frag_tmp
operator|->
name|fr_opcode
operator|)
condition|)
name|frag_tmp
operator|=
name|frag_tmp
operator|->
name|fr_next
expr_stmt|;
name|know
argument_list|(
name|frag_tmp
argument_list|)
expr_stmt|;
name|frag_tmp
operator|->
name|fr_opcode
operator|=
name|frag_opcode
expr_stmt|;
name|new_broken_words
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|a
operator|=
name|broken_words
init|;
name|a
operator|&&
name|a
operator|->
name|dispfrag
operator|==
literal|0
condition|;
name|a
operator|=
name|a
operator|->
name|next_broken_word
control|)
name|a
operator|->
name|dispfrag
operator|=
name|frag_tmp
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* WORKING_DOT_WORD */
if|if
condition|(
operator|(
name|symbolP
operator|=
name|symbol_find
argument_list|(
name|sym_name
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|RESOLVE_SYMBOL_REDEFINITION
if|if
condition|(
name|RESOLVE_SYMBOL_REDEFINITION
argument_list|(
name|symbolP
argument_list|)
condition|)
return|return
name|symbolP
return|;
endif|#
directive|endif
comment|/*        *	Now check for undefined symbols        */
if|if
condition|(
operator|!
name|S_IS_DEFINED
argument_list|(
name|symbolP
argument_list|)
operator|||
name|S_IS_COMMON
argument_list|(
name|symbolP
argument_list|)
condition|)
block|{
if|if
condition|(
name|S_GET_VALUE
argument_list|(
name|symbolP
argument_list|)
operator|==
literal|0
condition|)
block|{
name|symbolP
operator|->
name|sy_frag
operator|=
name|frag_now
expr_stmt|;
ifdef|#
directive|ifdef
name|OBJ_VMS
name|S_SET_OTHER
argument_list|(
name|symbolP
argument_list|,
name|const_flag
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|S_SET_VALUE
argument_list|(
name|symbolP
argument_list|,
operator|(
name|valueT
operator|)
name|frag_now_fix
argument_list|()
argument_list|)
expr_stmt|;
name|S_SET_SEGMENT
argument_list|(
name|symbolP
argument_list|,
name|now_seg
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|N_UNDF
name|know
argument_list|(
name|N_UNDF
operator|==
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* if we have one, it better be zero. */
block|}
else|else
block|{
comment|/* 	       *	There are still several cases to check: 	       *		A .comm/.lcomm symbol being redefined as 	       *			initialized data is OK 	       *		A .comm/.lcomm symbol being redefined with 	       *			a larger size is also OK 	       * 	       * This only used to be allowed on VMS gas, but Sun cc 	       * on the sparc also depends on it. 	       */
if|if
condition|(
operator|(
operator|(
operator|!
name|S_IS_DEBUG
argument_list|(
name|symbolP
argument_list|)
operator|&&
operator|(
operator|!
name|S_IS_DEFINED
argument_list|(
name|symbolP
argument_list|)
operator|||
name|S_IS_COMMON
argument_list|(
name|symbolP
argument_list|)
operator|)
operator|&&
name|S_IS_EXTERNAL
argument_list|(
name|symbolP
argument_list|)
operator|)
operator|||
name|S_GET_SEGMENT
argument_list|(
name|symbolP
argument_list|)
operator|==
name|bss_section
operator|)
operator|&&
operator|(
name|now_seg
operator|==
name|data_section
operator|||
name|now_seg
operator|==
name|S_GET_SEGMENT
argument_list|(
name|symbolP
argument_list|)
operator|)
condition|)
block|{
comment|/* 		   *	Select which of the 2 cases this is 		   */
if|if
condition|(
name|now_seg
operator|!=
name|data_section
condition|)
block|{
comment|/* 		       *   New .comm for prev .comm symbol. 		       *	If the new size is larger we just 		       *	change its value.  If the new size 		       *	is smaller, we ignore this symbol 		       */
if|if
condition|(
name|S_GET_VALUE
argument_list|(
name|symbolP
argument_list|)
operator|<
operator|(
operator|(
name|unsigned
operator|)
name|frag_now_fix
argument_list|()
operator|)
condition|)
block|{
name|S_SET_VALUE
argument_list|(
name|symbolP
argument_list|,
operator|(
name|valueT
operator|)
name|frag_now_fix
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* It is a .comm/.lcomm being converted to initialized 			 data.  */
name|symbolP
operator|->
name|sy_frag
operator|=
name|frag_now
expr_stmt|;
ifdef|#
directive|ifdef
name|OBJ_VMS
name|S_SET_OTHER
argument_list|(
name|symbolP
argument_list|,
name|const_flag
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|S_SET_VALUE
argument_list|(
name|symbolP
argument_list|,
operator|(
name|valueT
operator|)
name|frag_now_fix
argument_list|()
argument_list|)
expr_stmt|;
name|S_SET_SEGMENT
argument_list|(
name|symbolP
argument_list|,
name|now_seg
argument_list|)
expr_stmt|;
comment|/* keep N_EXT bit */
block|}
block|}
else|else
block|{
if|#
directive|if
name|defined
argument_list|(
name|S_GET_OTHER
argument_list|)
operator|&&
name|defined
argument_list|(
name|S_GET_DESC
argument_list|)
name|as_fatal
argument_list|(
literal|"Symbol \"%s\" is already defined as \"%s\"/%d.%d.%ld."
argument_list|,
name|sym_name
argument_list|,
name|segment_name
argument_list|(
name|S_GET_SEGMENT
argument_list|(
name|symbolP
argument_list|)
argument_list|)
argument_list|,
name|S_GET_OTHER
argument_list|(
name|symbolP
argument_list|)
argument_list|,
name|S_GET_DESC
argument_list|(
name|symbolP
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|S_GET_VALUE
argument_list|(
name|symbolP
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|as_fatal
argument_list|(
literal|"Symbol \"%s\" is already defined as \"%s\"/%ld."
argument_list|,
name|sym_name
argument_list|,
name|segment_name
argument_list|(
name|S_GET_SEGMENT
argument_list|(
name|symbolP
argument_list|)
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|S_GET_VALUE
argument_list|(
name|symbolP
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
comment|/* if the undefined symbol has no value */
block|}
else|else
block|{
comment|/* Don't blow up if the definition is the same */
if|if
condition|(
operator|!
operator|(
name|frag_now
operator|==
name|symbolP
operator|->
name|sy_frag
operator|&&
name|S_GET_VALUE
argument_list|(
name|symbolP
argument_list|)
operator|==
name|frag_now_fix
argument_list|()
operator|&&
name|S_GET_SEGMENT
argument_list|(
name|symbolP
argument_list|)
operator|==
name|now_seg
operator|)
condition|)
name|as_fatal
argument_list|(
literal|"Symbol %s already defined."
argument_list|,
name|sym_name
argument_list|)
expr_stmt|;
block|}
comment|/* if this symbol is not yet defined */
block|}
else|else
block|{
name|symbolP
operator|=
name|symbol_new
argument_list|(
name|sym_name
argument_list|,
name|now_seg
argument_list|,
operator|(
name|valueT
operator|)
name|frag_now_fix
argument_list|()
argument_list|,
name|frag_now
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|OBJ_VMS
name|S_SET_OTHER
argument_list|(
name|symbolP
argument_list|,
name|const_flag
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* OBJ_VMS */
name|symbol_table_insert
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
block|}
comment|/* if we have seen this symbol before */
if|if
condition|(
name|mri_common_symbol
operator|!=
name|NULL
condition|)
block|{
comment|/* This symbol is actually being defined within an MRI common          section.  This requires special handling.  */
name|symbolP
operator|->
name|sy_value
operator|.
name|X_op
operator|=
name|O_symbol
expr_stmt|;
name|symbolP
operator|->
name|sy_value
operator|.
name|X_add_symbol
operator|=
name|mri_common_symbol
expr_stmt|;
name|symbolP
operator|->
name|sy_value
operator|.
name|X_add_number
operator|=
name|S_GET_VALUE
argument_list|(
name|mri_common_symbol
argument_list|)
expr_stmt|;
name|symbolP
operator|->
name|sy_frag
operator|=
operator|&
name|zero_address_frag
expr_stmt|;
name|S_SET_SEGMENT
argument_list|(
name|symbolP
argument_list|,
name|expr_section
argument_list|)
expr_stmt|;
name|symbolP
operator|->
name|sy_mri_common
operator|=
literal|1
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|tc_frob_label
name|tc_frob_label
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|obj_frob_label
name|obj_frob_label
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|symbolP
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *			symbol_table_insert()  *  * Die if we can't insert the symbol.  *  */
end_comment

begin_function
name|void
name|symbol_table_insert
parameter_list|(
name|symbolP
parameter_list|)
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
block|{
specifier|register
specifier|const
name|char
modifier|*
name|error_string
decl_stmt|;
name|know
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
name|know
argument_list|(
name|S_GET_NAME
argument_list|(
name|symbolP
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error_string
operator|=
name|hash_jam
argument_list|(
name|sy_hash
argument_list|,
name|S_GET_NAME
argument_list|(
name|symbolP
argument_list|)
argument_list|,
operator|(
name|PTR
operator|)
name|symbolP
argument_list|)
operator|)
condition|)
block|{
name|as_fatal
argument_list|(
literal|"Inserting \"%s\" into symbol table failed: %s"
argument_list|,
name|S_GET_NAME
argument_list|(
name|symbolP
argument_list|)
argument_list|,
name|error_string
argument_list|)
expr_stmt|;
block|}
comment|/* on error */
block|}
end_function

begin_comment
comment|/* symbol_table_insert() */
end_comment

begin_escape
end_escape

begin_comment
comment|/*  *			symbol_find_or_make()  *  * If a symbol name does not exist, create it as undefined, and insert  * it into the symbol table. Return a pointer to it.  */
end_comment

begin_function
name|symbolS
modifier|*
name|symbol_find_or_make
parameter_list|(
name|name
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
specifier|register
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
name|symbolP
operator|=
name|symbol_find
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|symbolP
operator|==
name|NULL
condition|)
block|{
name|symbolP
operator|=
name|symbol_make
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|symbol_table_insert
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
block|}
comment|/* if symbol wasn't found */
return|return
operator|(
name|symbolP
operator|)
return|;
block|}
end_function

begin_comment
comment|/* symbol_find_or_make() */
end_comment

begin_function
name|symbolS
modifier|*
name|symbol_make
parameter_list|(
name|name
parameter_list|)
name|CONST
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
comment|/* Let the machine description default it, e.g. for register names. */
name|symbolP
operator|=
name|md_undefined_symbol
argument_list|(
operator|(
name|char
operator|*
operator|)
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|symbolP
condition|)
name|symbolP
operator|=
name|symbol_new
argument_list|(
name|name
argument_list|,
name|undefined_section
argument_list|,
operator|(
name|valueT
operator|)
literal|0
argument_list|,
operator|&
name|zero_address_frag
argument_list|)
expr_stmt|;
return|return
operator|(
name|symbolP
operator|)
return|;
block|}
end_function

begin_comment
comment|/* symbol_make() */
end_comment

begin_comment
comment|/*  *			symbol_find()  *  * Implement symbol table lookup.  * In:	A symbol's name as a string: '\0' can't be part of a symbol name.  * Out:	NULL if the name was not in the symbol table, else the address  *	of a struct symbol associated with that name.  */
end_comment

begin_function
name|symbolS
modifier|*
name|symbol_find
parameter_list|(
name|name
parameter_list|)
name|CONST
name|char
modifier|*
name|name
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|STRIP_UNDERSCORE
return|return
operator|(
name|symbol_find_base
argument_list|(
name|name
argument_list|,
literal|1
argument_list|)
operator|)
return|;
else|#
directive|else
comment|/* STRIP_UNDERSCORE */
return|return
operator|(
name|symbol_find_base
argument_list|(
name|name
argument_list|,
literal|0
argument_list|)
operator|)
return|;
endif|#
directive|endif
comment|/* STRIP_UNDERSCORE */
block|}
end_function

begin_comment
comment|/* symbol_find() */
end_comment

begin_function
name|symbolS
modifier|*
name|symbol_find_base
parameter_list|(
name|name
parameter_list|,
name|strip_underscore
parameter_list|)
name|CONST
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|strip_underscore
decl_stmt|;
block|{
if|if
condition|(
name|strip_underscore
operator|&&
operator|*
name|name
operator|==
literal|'_'
condition|)
name|name
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|tc_canonicalize_symbol_name
block|{
name|char
modifier|*
name|copy
decl_stmt|;
name|copy
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|copy
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|name
operator|=
name|tc_canonicalize_symbol_name
argument_list|(
name|copy
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
operator|!
name|symbols_case_sensitive
condition|)
block|{
name|unsigned
name|char
modifier|*
name|copy
decl_stmt|;
name|copy
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|name
operator|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|copy
expr_stmt|;
for|for
control|(
init|;
operator|*
name|copy
operator|!=
literal|'\0'
condition|;
name|copy
operator|++
control|)
if|if
condition|(
name|islower
argument_list|(
operator|*
name|copy
argument_list|)
condition|)
operator|*
name|copy
operator|=
name|toupper
argument_list|(
operator|*
name|copy
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
operator|(
name|symbolS
operator|*
operator|)
name|hash_find
argument_list|(
name|sy_hash
argument_list|,
name|name
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Once upon a time, symbols were kept in a singly linked list.  At  * least coff needs to be able to rearrange them from time to time, for  * which a doubly linked list is much more convenient.  Loic did these  * as macros which seemed dangerous to me so they're now functions.  * xoxorich.  */
end_comment

begin_comment
comment|/* Link symbol ADDME after symbol TARGET in the chain. */
end_comment

begin_function
name|void
name|symbol_append
parameter_list|(
name|addme
parameter_list|,
name|target
parameter_list|,
name|rootPP
parameter_list|,
name|lastPP
parameter_list|)
name|symbolS
modifier|*
name|addme
decl_stmt|;
name|symbolS
modifier|*
name|target
decl_stmt|;
name|symbolS
modifier|*
modifier|*
name|rootPP
decl_stmt|;
name|symbolS
modifier|*
modifier|*
name|lastPP
decl_stmt|;
block|{
if|if
condition|(
name|target
operator|==
name|NULL
condition|)
block|{
name|know
argument_list|(
operator|*
name|rootPP
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|know
argument_list|(
operator|*
name|lastPP
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|addme
operator|->
name|sy_next
operator|=
name|NULL
expr_stmt|;
ifdef|#
directive|ifdef
name|SYMBOLS_NEED_BACKPOINTERS
name|addme
operator|->
name|sy_previous
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
operator|*
name|rootPP
operator|=
name|addme
expr_stmt|;
operator|*
name|lastPP
operator|=
name|addme
expr_stmt|;
return|return;
block|}
comment|/* if the list is empty */
if|if
condition|(
name|target
operator|->
name|sy_next
operator|!=
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|SYMBOLS_NEED_BACKPOINTERS
name|target
operator|->
name|sy_next
operator|->
name|sy_previous
operator|=
name|addme
expr_stmt|;
endif|#
directive|endif
comment|/* SYMBOLS_NEED_BACKPOINTERS */
block|}
else|else
block|{
name|know
argument_list|(
operator|*
name|lastPP
operator|==
name|target
argument_list|)
expr_stmt|;
operator|*
name|lastPP
operator|=
name|addme
expr_stmt|;
block|}
comment|/* if we have a next */
name|addme
operator|->
name|sy_next
operator|=
name|target
operator|->
name|sy_next
expr_stmt|;
name|target
operator|->
name|sy_next
operator|=
name|addme
expr_stmt|;
ifdef|#
directive|ifdef
name|SYMBOLS_NEED_BACKPOINTERS
name|addme
operator|->
name|sy_previous
operator|=
name|target
expr_stmt|;
endif|#
directive|endif
comment|/* SYMBOLS_NEED_BACKPOINTERS */
name|debug_verify_symchain
argument_list|(
name|symbol_rootP
argument_list|,
name|symbol_lastP
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set the chain pointers of SYMBOL to null. */
end_comment

begin_function
name|void
name|symbol_clear_list_pointers
parameter_list|(
name|symbolP
parameter_list|)
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
block|{
name|symbolP
operator|->
name|sy_next
operator|=
name|NULL
expr_stmt|;
ifdef|#
directive|ifdef
name|SYMBOLS_NEED_BACKPOINTERS
name|symbolP
operator|->
name|sy_previous
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|SYMBOLS_NEED_BACKPOINTERS
end_ifdef

begin_comment
comment|/* Remove SYMBOLP from the list. */
end_comment

begin_function
name|void
name|symbol_remove
parameter_list|(
name|symbolP
parameter_list|,
name|rootPP
parameter_list|,
name|lastPP
parameter_list|)
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
name|symbolS
modifier|*
modifier|*
name|rootPP
decl_stmt|;
name|symbolS
modifier|*
modifier|*
name|lastPP
decl_stmt|;
block|{
if|if
condition|(
name|symbolP
operator|==
operator|*
name|rootPP
condition|)
block|{
operator|*
name|rootPP
operator|=
name|symbolP
operator|->
name|sy_next
expr_stmt|;
block|}
comment|/* if it was the root */
if|if
condition|(
name|symbolP
operator|==
operator|*
name|lastPP
condition|)
block|{
operator|*
name|lastPP
operator|=
name|symbolP
operator|->
name|sy_previous
expr_stmt|;
block|}
comment|/* if it was the tail */
if|if
condition|(
name|symbolP
operator|->
name|sy_next
operator|!=
name|NULL
condition|)
block|{
name|symbolP
operator|->
name|sy_next
operator|->
name|sy_previous
operator|=
name|symbolP
operator|->
name|sy_previous
expr_stmt|;
block|}
comment|/* if not last */
if|if
condition|(
name|symbolP
operator|->
name|sy_previous
operator|!=
name|NULL
condition|)
block|{
name|symbolP
operator|->
name|sy_previous
operator|->
name|sy_next
operator|=
name|symbolP
operator|->
name|sy_next
expr_stmt|;
block|}
comment|/* if not first */
name|debug_verify_symchain
argument_list|(
operator|*
name|rootPP
argument_list|,
operator|*
name|lastPP
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Link symbol ADDME before symbol TARGET in the chain. */
end_comment

begin_function
name|void
name|symbol_insert
parameter_list|(
name|addme
parameter_list|,
name|target
parameter_list|,
name|rootPP
parameter_list|,
name|lastPP
parameter_list|)
name|symbolS
modifier|*
name|addme
decl_stmt|;
name|symbolS
modifier|*
name|target
decl_stmt|;
name|symbolS
modifier|*
modifier|*
name|rootPP
decl_stmt|;
name|symbolS
modifier|*
modifier|*
name|lastPP
decl_stmt|;
block|{
if|if
condition|(
name|target
operator|->
name|sy_previous
operator|!=
name|NULL
condition|)
block|{
name|target
operator|->
name|sy_previous
operator|->
name|sy_next
operator|=
name|addme
expr_stmt|;
block|}
else|else
block|{
name|know
argument_list|(
operator|*
name|rootPP
operator|==
name|target
argument_list|)
expr_stmt|;
operator|*
name|rootPP
operator|=
name|addme
expr_stmt|;
block|}
comment|/* if not first */
name|addme
operator|->
name|sy_previous
operator|=
name|target
operator|->
name|sy_previous
expr_stmt|;
name|target
operator|->
name|sy_previous
operator|=
name|addme
expr_stmt|;
name|addme
operator|->
name|sy_next
operator|=
name|target
expr_stmt|;
name|debug_verify_symchain
argument_list|(
operator|*
name|rootPP
argument_list|,
operator|*
name|lastPP
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SYMBOLS_NEED_BACKPOINTERS */
end_comment

begin_function
name|void
name|verify_symbol_chain
parameter_list|(
name|rootP
parameter_list|,
name|lastP
parameter_list|)
name|symbolS
modifier|*
name|rootP
decl_stmt|;
name|symbolS
modifier|*
name|lastP
decl_stmt|;
block|{
name|symbolS
modifier|*
name|symbolP
init|=
name|rootP
decl_stmt|;
if|if
condition|(
name|symbolP
operator|==
name|NULL
condition|)
return|return;
for|for
control|(
init|;
name|symbol_next
argument_list|(
name|symbolP
argument_list|)
operator|!=
name|NULL
condition|;
name|symbolP
operator|=
name|symbol_next
argument_list|(
name|symbolP
argument_list|)
control|)
block|{
ifdef|#
directive|ifdef
name|SYMBOLS_NEED_BACKPOINTERS
name|assert
argument_list|(
name|symbolP
operator|->
name|sy_next
operator|->
name|sy_previous
operator|==
name|symbolP
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* Walk the list anyways, to make sure pointers are still good.  */
empty_stmt|;
endif|#
directive|endif
comment|/* SYMBOLS_NEED_BACKPOINTERS */
block|}
name|assert
argument_list|(
name|lastP
operator|==
name|symbolP
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|verify_symbol_chain_2
parameter_list|(
name|sym
parameter_list|)
name|symbolS
modifier|*
name|sym
decl_stmt|;
block|{
name|symbolS
modifier|*
name|p
init|=
name|sym
decl_stmt|,
modifier|*
name|n
init|=
name|sym
decl_stmt|;
ifdef|#
directive|ifdef
name|SYMBOLS_NEED_BACKPOINTERS
while|while
condition|(
name|symbol_previous
argument_list|(
name|p
argument_list|)
condition|)
name|p
operator|=
name|symbol_previous
argument_list|(
name|p
argument_list|)
expr_stmt|;
endif|#
directive|endif
while|while
condition|(
name|symbol_next
argument_list|(
name|n
argument_list|)
condition|)
name|n
operator|=
name|symbol_next
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|verify_symbol_chain
argument_list|(
name|p
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Resolve the value of a symbol.  This is called during the final    pass over the symbol table to resolve any symbols with complex    values.  */
end_comment

begin_function
name|void
name|resolve_symbol_value
parameter_list|(
name|symp
parameter_list|)
name|symbolS
modifier|*
name|symp
decl_stmt|;
block|{
name|int
name|resolved
decl_stmt|;
if|if
condition|(
name|symp
operator|->
name|sy_resolved
condition|)
return|return;
name|resolved
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|symp
operator|->
name|sy_resolving
condition|)
block|{
name|as_bad
argument_list|(
literal|"Symbol definition loop encountered at %s"
argument_list|,
name|S_GET_NAME
argument_list|(
name|symp
argument_list|)
argument_list|)
expr_stmt|;
name|S_SET_VALUE
argument_list|(
name|symp
argument_list|,
operator|(
name|valueT
operator|)
literal|0
argument_list|)
expr_stmt|;
name|resolved
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|offsetT
name|left
decl_stmt|,
name|right
decl_stmt|,
name|val
decl_stmt|;
name|segT
name|seg_left
decl_stmt|,
name|seg_right
decl_stmt|;
name|symp
operator|->
name|sy_resolving
operator|=
literal|1
expr_stmt|;
comment|/* Simplify addition or subtraction of a constant by folding the          constant into X_add_number.  */
if|if
condition|(
name|symp
operator|->
name|sy_value
operator|.
name|X_op
operator|==
name|O_add
operator|||
name|symp
operator|->
name|sy_value
operator|.
name|X_op
operator|==
name|O_subtract
condition|)
block|{
name|resolve_symbol_value
argument_list|(
name|symp
operator|->
name|sy_value
operator|.
name|X_add_symbol
argument_list|)
expr_stmt|;
name|resolve_symbol_value
argument_list|(
name|symp
operator|->
name|sy_value
operator|.
name|X_op_symbol
argument_list|)
expr_stmt|;
if|if
condition|(
name|S_GET_SEGMENT
argument_list|(
name|symp
operator|->
name|sy_value
operator|.
name|X_op_symbol
argument_list|)
operator|==
name|absolute_section
condition|)
block|{
name|right
operator|=
name|S_GET_VALUE
argument_list|(
name|symp
operator|->
name|sy_value
operator|.
name|X_op_symbol
argument_list|)
expr_stmt|;
if|if
condition|(
name|symp
operator|->
name|sy_value
operator|.
name|X_op
operator|==
name|O_add
condition|)
name|symp
operator|->
name|sy_value
operator|.
name|X_add_number
operator|+=
name|right
expr_stmt|;
else|else
name|symp
operator|->
name|sy_value
operator|.
name|X_add_number
operator|-=
name|right
expr_stmt|;
name|symp
operator|->
name|sy_value
operator|.
name|X_op
operator|=
name|O_symbol
expr_stmt|;
name|symp
operator|->
name|sy_value
operator|.
name|X_op_symbol
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|S_GET_SEGMENT
argument_list|(
name|symp
operator|->
name|sy_value
operator|.
name|X_add_symbol
argument_list|)
operator|==
name|absolute_section
operator|)
operator|&&
name|symp
operator|->
name|sy_value
operator|.
name|X_op
operator|==
name|O_add
condition|)
block|{
name|left
operator|=
name|S_GET_VALUE
argument_list|(
name|symp
operator|->
name|sy_value
operator|.
name|X_add_symbol
argument_list|)
expr_stmt|;
name|symp
operator|->
name|sy_value
operator|.
name|X_add_symbol
operator|=
name|symp
operator|->
name|sy_value
operator|.
name|X_op_symbol
expr_stmt|;
name|symp
operator|->
name|sy_value
operator|.
name|X_add_number
operator|+=
name|left
expr_stmt|;
name|symp
operator|->
name|sy_value
operator|.
name|X_op
operator|=
name|O_symbol
expr_stmt|;
name|symp
operator|->
name|sy_value
operator|.
name|X_op_symbol
operator|=
name|NULL
expr_stmt|;
block|}
block|}
switch|switch
condition|(
name|symp
operator|->
name|sy_value
operator|.
name|X_op
condition|)
block|{
case|case
name|O_absent
case|:
name|S_SET_VALUE
argument_list|(
name|symp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Fall through.  */
case|case
name|O_constant
case|:
name|S_SET_VALUE
argument_list|(
name|symp
argument_list|,
name|S_GET_VALUE
argument_list|(
name|symp
argument_list|)
operator|+
name|symp
operator|->
name|sy_frag
operator|->
name|fr_address
argument_list|)
expr_stmt|;
if|if
condition|(
name|S_GET_SEGMENT
argument_list|(
name|symp
argument_list|)
operator|==
name|expr_section
condition|)
name|S_SET_SEGMENT
argument_list|(
name|symp
argument_list|,
name|absolute_section
argument_list|)
expr_stmt|;
name|resolved
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|O_symbol
case|:
name|resolve_symbol_value
argument_list|(
name|symp
operator|->
name|sy_value
operator|.
name|X_add_symbol
argument_list|)
expr_stmt|;
if|if
condition|(
name|symp
operator|->
name|sy_mri_common
condition|)
block|{
comment|/* This is a symbol inside an MRI common section.  The                  relocation routines are going to handle it specially.                  Don't change the value.  */
name|S_SET_VALUE
argument_list|(
name|symp
argument_list|,
name|symp
operator|->
name|sy_value
operator|.
name|X_add_number
argument_list|)
expr_stmt|;
name|resolved
operator|=
name|symp
operator|->
name|sy_value
operator|.
name|X_add_symbol
operator|->
name|sy_resolved
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|symp
operator|->
name|sy_value
operator|.
name|X_add_number
operator|==
literal|0
condition|)
name|copy_symbol_attributes
argument_list|(
name|symp
argument_list|,
name|symp
operator|->
name|sy_value
operator|.
name|X_add_symbol
argument_list|)
expr_stmt|;
comment|/* If we have equated this symbol to an undefined symbol, we              keep X_op set to O_symbol, and we don't change              X_add_number.  This permits the routine which writes out              relocation to detect this case, and convert the              relocation to be against the symbol to which this symbol              is equated.  */
if|if
condition|(
operator|!
name|S_IS_DEFINED
argument_list|(
name|symp
operator|->
name|sy_value
operator|.
name|X_add_symbol
argument_list|)
operator|||
name|S_IS_COMMON
argument_list|(
name|symp
operator|->
name|sy_value
operator|.
name|X_add_symbol
argument_list|)
condition|)
block|{
name|symp
operator|->
name|sy_value
operator|.
name|X_op
operator|=
name|O_symbol
expr_stmt|;
name|S_SET_SEGMENT
argument_list|(
name|symp
argument_list|,
name|S_GET_SEGMENT
argument_list|(
name|symp
operator|->
name|sy_value
operator|.
name|X_add_symbol
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|S_SET_VALUE
argument_list|(
name|symp
argument_list|,
operator|(
name|symp
operator|->
name|sy_value
operator|.
name|X_add_number
operator|+
name|symp
operator|->
name|sy_frag
operator|->
name|fr_address
operator|+
name|S_GET_VALUE
argument_list|(
name|symp
operator|->
name|sy_value
operator|.
name|X_add_symbol
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|S_GET_SEGMENT
argument_list|(
name|symp
argument_list|)
operator|==
name|expr_section
operator|||
name|S_GET_SEGMENT
argument_list|(
name|symp
argument_list|)
operator|==
name|undefined_section
condition|)
name|S_SET_SEGMENT
argument_list|(
name|symp
argument_list|,
name|S_GET_SEGMENT
argument_list|(
name|symp
operator|->
name|sy_value
operator|.
name|X_add_symbol
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|resolved
operator|=
name|symp
operator|->
name|sy_value
operator|.
name|X_add_symbol
operator|->
name|sy_resolved
expr_stmt|;
break|break;
case|case
name|O_uminus
case|:
case|case
name|O_bit_not
case|:
case|case
name|O_logical_not
case|:
name|resolve_symbol_value
argument_list|(
name|symp
operator|->
name|sy_value
operator|.
name|X_add_symbol
argument_list|)
expr_stmt|;
if|if
condition|(
name|symp
operator|->
name|sy_value
operator|.
name|X_op
operator|==
name|O_uminus
condition|)
name|val
operator|=
operator|-
name|S_GET_VALUE
argument_list|(
name|symp
operator|->
name|sy_value
operator|.
name|X_add_symbol
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|symp
operator|->
name|sy_value
operator|.
name|X_op
operator|==
name|O_logical_not
condition|)
name|val
operator|=
operator|!
name|S_GET_VALUE
argument_list|(
name|symp
operator|->
name|sy_value
operator|.
name|X_add_symbol
argument_list|)
expr_stmt|;
else|else
name|val
operator|=
operator|~
name|S_GET_VALUE
argument_list|(
name|symp
operator|->
name|sy_value
operator|.
name|X_add_symbol
argument_list|)
expr_stmt|;
name|S_SET_VALUE
argument_list|(
name|symp
argument_list|,
operator|(
name|val
operator|+
name|symp
operator|->
name|sy_value
operator|.
name|X_add_number
operator|+
name|symp
operator|->
name|sy_frag
operator|->
name|fr_address
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|S_GET_SEGMENT
argument_list|(
name|symp
argument_list|)
operator|==
name|expr_section
operator|||
name|S_GET_SEGMENT
argument_list|(
name|symp
argument_list|)
operator|==
name|undefined_section
condition|)
name|S_SET_SEGMENT
argument_list|(
name|symp
argument_list|,
name|absolute_section
argument_list|)
expr_stmt|;
name|resolved
operator|=
name|symp
operator|->
name|sy_value
operator|.
name|X_add_symbol
operator|->
name|sy_resolved
expr_stmt|;
break|break;
case|case
name|O_multiply
case|:
case|case
name|O_divide
case|:
case|case
name|O_modulus
case|:
case|case
name|O_left_shift
case|:
case|case
name|O_right_shift
case|:
case|case
name|O_bit_inclusive_or
case|:
case|case
name|O_bit_or_not
case|:
case|case
name|O_bit_exclusive_or
case|:
case|case
name|O_bit_and
case|:
case|case
name|O_add
case|:
case|case
name|O_subtract
case|:
case|case
name|O_eq
case|:
case|case
name|O_ne
case|:
case|case
name|O_lt
case|:
case|case
name|O_le
case|:
case|case
name|O_ge
case|:
case|case
name|O_gt
case|:
case|case
name|O_logical_and
case|:
case|case
name|O_logical_or
case|:
name|resolve_symbol_value
argument_list|(
name|symp
operator|->
name|sy_value
operator|.
name|X_add_symbol
argument_list|)
expr_stmt|;
name|resolve_symbol_value
argument_list|(
name|symp
operator|->
name|sy_value
operator|.
name|X_op_symbol
argument_list|)
expr_stmt|;
name|seg_left
operator|=
name|S_GET_SEGMENT
argument_list|(
name|symp
operator|->
name|sy_value
operator|.
name|X_add_symbol
argument_list|)
expr_stmt|;
name|seg_right
operator|=
name|S_GET_SEGMENT
argument_list|(
name|symp
operator|->
name|sy_value
operator|.
name|X_op_symbol
argument_list|)
expr_stmt|;
name|left
operator|=
name|S_GET_VALUE
argument_list|(
name|symp
operator|->
name|sy_value
operator|.
name|X_add_symbol
argument_list|)
expr_stmt|;
name|right
operator|=
name|S_GET_VALUE
argument_list|(
name|symp
operator|->
name|sy_value
operator|.
name|X_op_symbol
argument_list|)
expr_stmt|;
comment|/* Subtraction is permitted if both operands are in the same 	     section.  Otherwise, both operands must be absolute.  We 	     already handled the case of addition or subtraction of a 	     constant above.  This will probably need to be changed 	     for an object file format which supports arbitrary 	     expressions, such as IEEE-695.  */
if|if
condition|(
operator|(
name|seg_left
operator|!=
name|absolute_section
operator|||
name|seg_right
operator|!=
name|absolute_section
operator|)
operator|&&
operator|(
name|symp
operator|->
name|sy_value
operator|.
name|X_op
operator|!=
name|O_subtract
operator|||
name|seg_left
operator|!=
name|seg_right
operator|)
condition|)
block|{
name|char
modifier|*
name|file
decl_stmt|;
name|unsigned
name|int
name|line
decl_stmt|;
if|if
condition|(
name|expr_symbol_where
argument_list|(
name|symp
argument_list|,
operator|&
name|file
argument_list|,
operator|&
name|line
argument_list|)
condition|)
block|{
if|if
condition|(
name|seg_left
operator|==
name|undefined_section
condition|)
name|as_bad_where
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
literal|"undefined symbol %s in operation"
argument_list|,
name|S_GET_NAME
argument_list|(
name|symp
operator|->
name|sy_value
operator|.
name|X_add_symbol
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|seg_right
operator|==
name|undefined_section
condition|)
name|as_bad_where
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
literal|"undefined symbol %s in operation"
argument_list|,
name|S_GET_NAME
argument_list|(
name|symp
operator|->
name|sy_value
operator|.
name|X_op_symbol
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|seg_left
operator|!=
name|undefined_section
operator|&&
name|seg_right
operator|!=
name|undefined_section
condition|)
name|as_bad_where
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
literal|"invalid section for operation"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|seg_left
operator|==
name|undefined_section
condition|)
name|as_bad
argument_list|(
literal|"undefined symbol %s in operation setting %s"
argument_list|,
name|S_GET_NAME
argument_list|(
name|symp
operator|->
name|sy_value
operator|.
name|X_add_symbol
argument_list|)
argument_list|,
name|S_GET_NAME
argument_list|(
name|symp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|seg_right
operator|==
name|undefined_section
condition|)
name|as_bad
argument_list|(
literal|"undefined symbol %s in operation setting %s"
argument_list|,
name|S_GET_NAME
argument_list|(
name|symp
operator|->
name|sy_value
operator|.
name|X_op_symbol
argument_list|)
argument_list|,
name|S_GET_NAME
argument_list|(
name|symp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|seg_left
operator|!=
name|undefined_section
operator|&&
name|seg_right
operator|!=
name|undefined_section
condition|)
name|as_bad
argument_list|(
literal|"invalid section for operation setting %s"
argument_list|,
name|S_GET_NAME
argument_list|(
name|symp
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
switch|switch
condition|(
name|symp
operator|->
name|sy_value
operator|.
name|X_op
condition|)
block|{
case|case
name|O_multiply
case|:
name|val
operator|=
name|left
operator|*
name|right
expr_stmt|;
break|break;
case|case
name|O_divide
case|:
name|val
operator|=
name|left
operator|/
name|right
expr_stmt|;
break|break;
case|case
name|O_modulus
case|:
name|val
operator|=
name|left
operator|%
name|right
expr_stmt|;
break|break;
case|case
name|O_left_shift
case|:
name|val
operator|=
name|left
operator|<<
name|right
expr_stmt|;
break|break;
case|case
name|O_right_shift
case|:
name|val
operator|=
name|left
operator|>>
name|right
expr_stmt|;
break|break;
case|case
name|O_bit_inclusive_or
case|:
name|val
operator|=
name|left
operator||
name|right
expr_stmt|;
break|break;
case|case
name|O_bit_or_not
case|:
name|val
operator|=
name|left
operator||
operator|~
name|right
expr_stmt|;
break|break;
case|case
name|O_bit_exclusive_or
case|:
name|val
operator|=
name|left
operator|^
name|right
expr_stmt|;
break|break;
case|case
name|O_bit_and
case|:
name|val
operator|=
name|left
operator|&
name|right
expr_stmt|;
break|break;
case|case
name|O_add
case|:
name|val
operator|=
name|left
operator|+
name|right
expr_stmt|;
break|break;
case|case
name|O_subtract
case|:
name|val
operator|=
name|left
operator|-
name|right
expr_stmt|;
break|break;
case|case
name|O_eq
case|:
name|val
operator|=
name|left
operator|==
name|right
condition|?
operator|~
operator|(
name|offsetT
operator|)
literal|0
else|:
literal|0
expr_stmt|;
case|case
name|O_ne
case|:
name|val
operator|=
name|left
operator|!=
name|right
condition|?
operator|~
operator|(
name|offsetT
operator|)
literal|0
else|:
literal|0
expr_stmt|;
case|case
name|O_lt
case|:
name|val
operator|=
name|left
operator|<
name|right
condition|?
operator|~
operator|(
name|offsetT
operator|)
literal|0
else|:
literal|0
expr_stmt|;
case|case
name|O_le
case|:
name|val
operator|=
name|left
operator|<=
name|right
condition|?
operator|~
operator|(
name|offsetT
operator|)
literal|0
else|:
literal|0
expr_stmt|;
case|case
name|O_ge
case|:
name|val
operator|=
name|left
operator|>=
name|right
condition|?
operator|~
operator|(
name|offsetT
operator|)
literal|0
else|:
literal|0
expr_stmt|;
case|case
name|O_gt
case|:
name|val
operator|=
name|left
operator|>
name|right
condition|?
operator|~
operator|(
name|offsetT
operator|)
literal|0
else|:
literal|0
expr_stmt|;
case|case
name|O_logical_and
case|:
name|val
operator|=
name|left
operator|&&
name|right
expr_stmt|;
break|break;
case|case
name|O_logical_or
case|:
name|val
operator|=
name|left
operator|||
name|right
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|S_SET_VALUE
argument_list|(
name|symp
argument_list|,
operator|(
name|symp
operator|->
name|sy_value
operator|.
name|X_add_number
operator|+
name|symp
operator|->
name|sy_frag
operator|->
name|fr_address
operator|+
name|val
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|S_GET_SEGMENT
argument_list|(
name|symp
argument_list|)
operator|==
name|expr_section
operator|||
name|S_GET_SEGMENT
argument_list|(
name|symp
argument_list|)
operator|==
name|undefined_section
condition|)
name|S_SET_SEGMENT
argument_list|(
name|symp
argument_list|,
name|absolute_section
argument_list|)
expr_stmt|;
name|resolved
operator|=
operator|(
name|symp
operator|->
name|sy_value
operator|.
name|X_add_symbol
operator|->
name|sy_resolved
operator|&&
name|symp
operator|->
name|sy_value
operator|.
name|X_op_symbol
operator|->
name|sy_resolved
operator|)
expr_stmt|;
break|break;
case|case
name|O_register
case|:
case|case
name|O_big
case|:
case|case
name|O_illegal
case|:
comment|/* Give an error (below) if not in expr_section.  We don't 	     want to worry about expr_section symbols, because they 	     are fictional (they are created as part of expression 	     resolution), and any problems may not actually mean 	     anything.  */
break|break;
block|}
block|}
comment|/* Don't worry if we can't resolve an expr_section symbol.  */
if|if
condition|(
name|resolved
condition|)
name|symp
operator|->
name|sy_resolved
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|S_GET_SEGMENT
argument_list|(
name|symp
argument_list|)
operator|!=
name|expr_section
condition|)
block|{
name|as_bad
argument_list|(
literal|"can't resolve value for symbol \"%s\""
argument_list|,
name|S_GET_NAME
argument_list|(
name|symp
argument_list|)
argument_list|)
expr_stmt|;
name|symp
operator|->
name|sy_resolved
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Dollar labels look like a number followed by a dollar sign.  Eg, "42$".    They are *really* local.  That is, they go out of scope whenever we see a    label that isn't local.  Also, like fb labels, there can be multiple    instances of a dollar label.  Therefor, we name encode each instance with    the instance number, keep a list of defined symbols separate from the real    symbol table, and we treat these buggers as a sparse array.  */
end_comment

begin_decl_stmt
specifier|static
name|long
modifier|*
name|dollar_labels
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
modifier|*
name|dollar_label_instances
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|dollar_label_defines
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|dollar_label_count
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|long
name|dollar_label_max
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|dollar_label_defined
parameter_list|(
name|label
parameter_list|)
name|long
name|label
decl_stmt|;
block|{
name|long
modifier|*
name|i
decl_stmt|;
name|know
argument_list|(
operator|(
name|dollar_labels
operator|!=
name|NULL
operator|)
operator|||
operator|(
name|dollar_label_count
operator|==
literal|0
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|dollar_labels
init|;
name|i
operator|<
name|dollar_labels
operator|+
name|dollar_label_count
condition|;
operator|++
name|i
control|)
if|if
condition|(
operator|*
name|i
operator|==
name|label
condition|)
return|return
name|dollar_label_defines
index|[
name|i
operator|-
name|dollar_labels
index|]
return|;
comment|/* if we get here, label isn't defined */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* dollar_label_defined() */
end_comment

begin_function
specifier|static
name|long
name|dollar_label_instance
parameter_list|(
name|label
parameter_list|)
name|long
name|label
decl_stmt|;
block|{
name|long
modifier|*
name|i
decl_stmt|;
name|know
argument_list|(
operator|(
name|dollar_labels
operator|!=
name|NULL
operator|)
operator|||
operator|(
name|dollar_label_count
operator|==
literal|0
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|dollar_labels
init|;
name|i
operator|<
name|dollar_labels
operator|+
name|dollar_label_count
condition|;
operator|++
name|i
control|)
if|if
condition|(
operator|*
name|i
operator|==
name|label
condition|)
return|return
operator|(
name|dollar_label_instances
index|[
name|i
operator|-
name|dollar_labels
index|]
operator|)
return|;
comment|/* If we get here, we haven't seen the label before, therefore its instance      count is zero.  */
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|dollar_label_clear
parameter_list|()
block|{
name|memset
argument_list|(
name|dollar_label_defines
argument_list|,
literal|'\0'
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|dollar_label_count
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|DOLLAR_LABEL_BUMP_BY
value|10
end_define

begin_function
name|void
name|define_dollar_label
parameter_list|(
name|label
parameter_list|)
name|long
name|label
decl_stmt|;
block|{
name|long
modifier|*
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|dollar_labels
init|;
name|i
operator|<
name|dollar_labels
operator|+
name|dollar_label_count
condition|;
operator|++
name|i
control|)
if|if
condition|(
operator|*
name|i
operator|==
name|label
condition|)
block|{
operator|++
name|dollar_label_instances
index|[
name|i
operator|-
name|dollar_labels
index|]
expr_stmt|;
name|dollar_label_defines
index|[
name|i
operator|-
name|dollar_labels
index|]
operator|=
literal|1
expr_stmt|;
return|return;
block|}
comment|/* if we get to here, we don't have label listed yet. */
if|if
condition|(
name|dollar_labels
operator|==
name|NULL
condition|)
block|{
name|dollar_labels
operator|=
operator|(
name|long
operator|*
operator|)
name|xmalloc
argument_list|(
name|DOLLAR_LABEL_BUMP_BY
operator|*
sizeof|sizeof
argument_list|(
name|long
argument_list|)
argument_list|)
expr_stmt|;
name|dollar_label_instances
operator|=
operator|(
name|long
operator|*
operator|)
name|xmalloc
argument_list|(
name|DOLLAR_LABEL_BUMP_BY
operator|*
sizeof|sizeof
argument_list|(
name|long
argument_list|)
argument_list|)
expr_stmt|;
name|dollar_label_defines
operator|=
name|xmalloc
argument_list|(
name|DOLLAR_LABEL_BUMP_BY
argument_list|)
expr_stmt|;
name|dollar_label_max
operator|=
name|DOLLAR_LABEL_BUMP_BY
expr_stmt|;
name|dollar_label_count
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dollar_label_count
operator|==
name|dollar_label_max
condition|)
block|{
name|dollar_label_max
operator|+=
name|DOLLAR_LABEL_BUMP_BY
expr_stmt|;
name|dollar_labels
operator|=
operator|(
name|long
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|dollar_labels
argument_list|,
name|dollar_label_max
operator|*
sizeof|sizeof
argument_list|(
name|long
argument_list|)
argument_list|)
expr_stmt|;
name|dollar_label_instances
operator|=
operator|(
name|long
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|dollar_label_instances
argument_list|,
name|dollar_label_max
operator|*
sizeof|sizeof
argument_list|(
name|long
argument_list|)
argument_list|)
expr_stmt|;
name|dollar_label_defines
operator|=
name|xrealloc
argument_list|(
name|dollar_label_defines
argument_list|,
name|dollar_label_max
argument_list|)
expr_stmt|;
block|}
comment|/* if we needed to grow */
name|dollar_labels
index|[
name|dollar_label_count
index|]
operator|=
name|label
expr_stmt|;
name|dollar_label_instances
index|[
name|dollar_label_count
index|]
operator|=
literal|1
expr_stmt|;
name|dollar_label_defines
index|[
name|dollar_label_count
index|]
operator|=
literal|1
expr_stmt|;
operator|++
name|dollar_label_count
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *			dollar_label_name()  *  * Caller must copy returned name: we re-use the area for the next name.  *  * The mth occurence of label n: is turned into the symbol "Ln^Am"  * where n is the label number and m is the instance number. "L" makes  * it a label discarded unless debugging and "^A"('\1') ensures no  * ordinary symbol SHOULD get the same name as a local label  * symbol. The first "4:" is "L4^A1" - the m numbers begin at 1.  *  * fb labels get the same treatment, except that ^B is used in place of ^A.  */
end_comment

begin_function
name|char
modifier|*
comment|/* Return local label name. */
name|dollar_label_name
parameter_list|(
name|n
parameter_list|,
name|augend
parameter_list|)
specifier|register
name|long
name|n
decl_stmt|;
comment|/* we just saw "n$:" : n a number */
specifier|register
name|int
name|augend
decl_stmt|;
comment|/* 0 for current instance, 1 for new instance */
block|{
name|long
name|i
decl_stmt|;
comment|/* Returned to caller, then copied.  used for created names ("4f") */
specifier|static
name|char
name|symbol_name_build
index|[
literal|24
index|]
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|char
modifier|*
name|q
decl_stmt|;
name|char
name|symbol_name_temporary
index|[
literal|20
index|]
decl_stmt|;
comment|/* build up a number, BACKWARDS */
name|know
argument_list|(
name|n
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|know
argument_list|(
name|augend
operator|==
literal|0
operator|||
name|augend
operator|==
literal|1
argument_list|)
expr_stmt|;
name|p
operator|=
name|symbol_name_build
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|'L'
expr_stmt|;
comment|/* Next code just does sprintf( {}, "%d", n); */
comment|/* label number */
name|q
operator|=
name|symbol_name_temporary
expr_stmt|;
for|for
control|(
operator|*
name|q
operator|++
operator|=
literal|0
operator|,
name|i
operator|=
name|n
init|;
name|i
condition|;
operator|++
name|q
control|)
block|{
operator|*
name|q
operator|=
name|i
operator|%
literal|10
operator|+
literal|'0'
expr_stmt|;
name|i
operator|/=
literal|10
expr_stmt|;
block|}
while|while
condition|(
operator|(
operator|*
name|p
operator|=
operator|*
operator|--
name|q
operator|)
operator|!=
literal|'\0'
condition|)
operator|++
name|p
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|1
expr_stmt|;
comment|/* ^A */
comment|/* instance number */
name|q
operator|=
name|symbol_name_temporary
expr_stmt|;
for|for
control|(
operator|*
name|q
operator|++
operator|=
literal|0
operator|,
name|i
operator|=
name|dollar_label_instance
argument_list|(
name|n
argument_list|)
operator|+
name|augend
init|;
name|i
condition|;
operator|++
name|q
control|)
block|{
operator|*
name|q
operator|=
name|i
operator|%
literal|10
operator|+
literal|'0'
expr_stmt|;
name|i
operator|/=
literal|10
expr_stmt|;
block|}
while|while
condition|(
operator|(
operator|*
name|p
operator|++
operator|=
operator|*
operator|--
name|q
operator|)
operator|!=
literal|'\0'
condition|)
empty_stmt|;
empty_stmt|;
comment|/* The label, as a '\0' ended string, starts at symbol_name_build. */
return|return
name|symbol_name_build
return|;
block|}
end_function

begin_comment
comment|/*  * Sombody else's idea of local labels. They are made by "n:" where n  * is any decimal digit. Refer to them with  *  "nb" for previous (backward) n:  *  or "nf" for next (forward) n:.  *  * We do a little better and let n be any number, not just a single digit, but  * since the other guy's assembler only does ten, we treat the first ten  * specially.  *  * Like someone else's assembler, we have one set of local label counters for  * entire assembly, not one set per (sub)segment like in most assemblers. This  * implies that one can refer to a label in another segment, and indeed some  * crufty compilers have done just that.  *  * Since there could be a LOT of these things, treat them as a sparse array.  */
end_comment

begin_define
define|#
directive|define
name|FB_LABEL_SPECIAL
value|(10)
end_define

begin_decl_stmt
specifier|static
name|long
name|fb_low_counter
index|[
name|FB_LABEL_SPECIAL
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
modifier|*
name|fb_labels
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
modifier|*
name|fb_label_instances
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|fb_label_count
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|fb_label_max
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* this must be more than FB_LABEL_SPECIAL */
end_comment

begin_define
define|#
directive|define
name|FB_LABEL_BUMP_BY
value|(FB_LABEL_SPECIAL + 6)
end_define

begin_function
specifier|static
name|void
name|fb_label_init
parameter_list|()
block|{
name|memset
argument_list|(
operator|(
name|void
operator|*
operator|)
name|fb_low_counter
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
name|fb_low_counter
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* fb_label_init() */
end_comment

begin_comment
comment|/* add one to the instance number of this fb label */
end_comment

begin_function
name|void
name|fb_label_instance_inc
parameter_list|(
name|label
parameter_list|)
name|long
name|label
decl_stmt|;
block|{
name|long
modifier|*
name|i
decl_stmt|;
if|if
condition|(
name|label
operator|<
name|FB_LABEL_SPECIAL
condition|)
block|{
operator|++
name|fb_low_counter
index|[
name|label
index|]
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|fb_labels
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|i
operator|=
name|fb_labels
operator|+
name|FB_LABEL_SPECIAL
init|;
name|i
operator|<
name|fb_labels
operator|+
name|fb_label_count
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
operator|*
name|i
operator|==
name|label
condition|)
block|{
operator|++
name|fb_label_instances
index|[
name|i
operator|-
name|fb_labels
index|]
expr_stmt|;
return|return;
block|}
comment|/* if we find it */
block|}
comment|/* for each existing label */
block|}
comment|/* if we get to here, we don't have label listed yet. */
if|if
condition|(
name|fb_labels
operator|==
name|NULL
condition|)
block|{
name|fb_labels
operator|=
operator|(
name|long
operator|*
operator|)
name|xmalloc
argument_list|(
name|FB_LABEL_BUMP_BY
operator|*
sizeof|sizeof
argument_list|(
name|long
argument_list|)
argument_list|)
expr_stmt|;
name|fb_label_instances
operator|=
operator|(
name|long
operator|*
operator|)
name|xmalloc
argument_list|(
name|FB_LABEL_BUMP_BY
operator|*
sizeof|sizeof
argument_list|(
name|long
argument_list|)
argument_list|)
expr_stmt|;
name|fb_label_max
operator|=
name|FB_LABEL_BUMP_BY
expr_stmt|;
name|fb_label_count
operator|=
name|FB_LABEL_SPECIAL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fb_label_count
operator|==
name|fb_label_max
condition|)
block|{
name|fb_label_max
operator|+=
name|FB_LABEL_BUMP_BY
expr_stmt|;
name|fb_labels
operator|=
operator|(
name|long
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|fb_labels
argument_list|,
name|fb_label_max
operator|*
sizeof|sizeof
argument_list|(
name|long
argument_list|)
argument_list|)
expr_stmt|;
name|fb_label_instances
operator|=
operator|(
name|long
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|fb_label_instances
argument_list|,
name|fb_label_max
operator|*
sizeof|sizeof
argument_list|(
name|long
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* if we needed to grow */
name|fb_labels
index|[
name|fb_label_count
index|]
operator|=
name|label
expr_stmt|;
name|fb_label_instances
index|[
name|fb_label_count
index|]
operator|=
literal|1
expr_stmt|;
operator|++
name|fb_label_count
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|long
name|fb_label_instance
parameter_list|(
name|label
parameter_list|)
name|long
name|label
decl_stmt|;
block|{
name|long
modifier|*
name|i
decl_stmt|;
if|if
condition|(
name|label
operator|<
name|FB_LABEL_SPECIAL
condition|)
block|{
return|return
operator|(
name|fb_low_counter
index|[
name|label
index|]
operator|)
return|;
block|}
if|if
condition|(
name|fb_labels
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|i
operator|=
name|fb_labels
operator|+
name|FB_LABEL_SPECIAL
init|;
name|i
operator|<
name|fb_labels
operator|+
name|fb_label_count
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
operator|*
name|i
operator|==
name|label
condition|)
block|{
return|return
operator|(
name|fb_label_instances
index|[
name|i
operator|-
name|fb_labels
index|]
operator|)
return|;
block|}
comment|/* if we find it */
block|}
comment|/* for each existing label */
block|}
comment|/* We didn't find the label, so this must be a reference to the      first instance.  */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  *			fb_label_name()  *  * Caller must copy returned name: we re-use the area for the next name.  *  * The mth occurence of label n: is turned into the symbol "Ln^Bm"  * where n is the label number and m is the instance number. "L" makes  * it a label discarded unless debugging and "^B"('\2') ensures no  * ordinary symbol SHOULD get the same name as a local label  * symbol. The first "4:" is "L4^B1" - the m numbers begin at 1.  *  * dollar labels get the same treatment, except that ^A is used in place of ^B. */
end_comment

begin_function
name|char
modifier|*
comment|/* Return local label name. */
name|fb_label_name
parameter_list|(
name|n
parameter_list|,
name|augend
parameter_list|)
name|long
name|n
decl_stmt|;
comment|/* we just saw "n:", "nf" or "nb" : n a number */
name|long
name|augend
decl_stmt|;
comment|/* 0 for nb, 1 for n:, nf */
block|{
name|long
name|i
decl_stmt|;
comment|/* Returned to caller, then copied.  used for created names ("4f") */
specifier|static
name|char
name|symbol_name_build
index|[
literal|24
index|]
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|char
modifier|*
name|q
decl_stmt|;
name|char
name|symbol_name_temporary
index|[
literal|20
index|]
decl_stmt|;
comment|/* build up a number, BACKWARDS */
name|know
argument_list|(
name|n
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|know
argument_list|(
name|augend
operator|==
literal|0
operator|||
name|augend
operator|==
literal|1
argument_list|)
expr_stmt|;
name|p
operator|=
name|symbol_name_build
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|'L'
expr_stmt|;
comment|/* Next code just does sprintf( {}, "%d", n); */
comment|/* label number */
name|q
operator|=
name|symbol_name_temporary
expr_stmt|;
for|for
control|(
operator|*
name|q
operator|++
operator|=
literal|0
operator|,
name|i
operator|=
name|n
init|;
name|i
condition|;
operator|++
name|q
control|)
block|{
operator|*
name|q
operator|=
name|i
operator|%
literal|10
operator|+
literal|'0'
expr_stmt|;
name|i
operator|/=
literal|10
expr_stmt|;
block|}
while|while
condition|(
operator|(
operator|*
name|p
operator|=
operator|*
operator|--
name|q
operator|)
operator|!=
literal|'\0'
condition|)
operator|++
name|p
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|2
expr_stmt|;
comment|/* ^B */
comment|/* instance number */
name|q
operator|=
name|symbol_name_temporary
expr_stmt|;
for|for
control|(
operator|*
name|q
operator|++
operator|=
literal|0
operator|,
name|i
operator|=
name|fb_label_instance
argument_list|(
name|n
argument_list|)
operator|+
name|augend
init|;
name|i
condition|;
operator|++
name|q
control|)
block|{
operator|*
name|q
operator|=
name|i
operator|%
literal|10
operator|+
literal|'0'
expr_stmt|;
name|i
operator|/=
literal|10
expr_stmt|;
block|}
while|while
condition|(
operator|(
operator|*
name|p
operator|++
operator|=
operator|*
operator|--
name|q
operator|)
operator|!=
literal|'\0'
condition|)
empty_stmt|;
empty_stmt|;
comment|/* The label, as a '\0' ended string, starts at symbol_name_build. */
return|return
operator|(
name|symbol_name_build
operator|)
return|;
block|}
end_function

begin_comment
comment|/* fb_label_name() */
end_comment

begin_comment
comment|/*  * decode name that may have been generated by foo_label_name() above.  If  * the name wasn't generated by foo_label_name(), then return it unaltered.  * This is used for error messages.  */
end_comment

begin_function
name|char
modifier|*
name|decode_local_label_name
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|symbol_decode
decl_stmt|;
name|int
name|label_number
decl_stmt|;
name|int
name|instance_number
decl_stmt|;
name|char
modifier|*
name|type
decl_stmt|;
specifier|const
name|char
modifier|*
name|message_format
init|=
literal|"\"%d\" (instance number %d of a %s label)"
decl_stmt|;
if|if
condition|(
name|s
index|[
literal|0
index|]
operator|!=
literal|'L'
condition|)
return|return
name|s
return|;
for|for
control|(
name|label_number
operator|=
literal|0
operator|,
name|p
operator|=
name|s
operator|+
literal|1
init|;
name|isdigit
argument_list|(
operator|*
name|p
argument_list|)
condition|;
operator|++
name|p
control|)
name|label_number
operator|=
operator|(
literal|10
operator|*
name|label_number
operator|)
operator|+
operator|*
name|p
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|1
condition|)
name|type
operator|=
literal|"dollar"
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|2
condition|)
name|type
operator|=
literal|"fb"
expr_stmt|;
else|else
return|return
name|s
return|;
for|for
control|(
name|instance_number
operator|=
literal|0
operator|,
name|p
operator|++
init|;
name|isdigit
argument_list|(
operator|*
name|p
argument_list|)
condition|;
operator|++
name|p
control|)
name|instance_number
operator|=
operator|(
literal|10
operator|*
name|instance_number
operator|)
operator|+
operator|*
name|p
operator|-
literal|'0'
expr_stmt|;
name|symbol_decode
operator|=
name|obstack_alloc
argument_list|(
operator|&
name|notes
argument_list|,
name|strlen
argument_list|(
name|message_format
argument_list|)
operator|+
literal|30
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|symbol_decode
argument_list|,
name|message_format
argument_list|,
name|label_number
argument_list|,
name|instance_number
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
name|symbol_decode
return|;
block|}
end_function

begin_comment
comment|/* Get the value of a symbol.  */
end_comment

begin_function
name|valueT
name|S_GET_VALUE
parameter_list|(
name|s
parameter_list|)
name|symbolS
modifier|*
name|s
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|s
operator|->
name|sy_resolved
operator|&&
operator|!
name|s
operator|->
name|sy_resolving
operator|&&
name|s
operator|->
name|sy_value
operator|.
name|X_op
operator|!=
name|O_constant
condition|)
name|resolve_symbol_value
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|sy_value
operator|.
name|X_op
operator|!=
name|O_constant
condition|)
block|{
specifier|static
name|symbolS
modifier|*
name|recur
decl_stmt|;
comment|/* FIXME: In non BFD assemblers, S_IS_DEFINED and S_IS_COMMON          may call S_GET_VALUE.  We use a static symbol to avoid the          immediate recursion.  */
if|if
condition|(
name|recur
operator|==
name|s
condition|)
return|return
operator|(
name|valueT
operator|)
name|s
operator|->
name|sy_value
operator|.
name|X_add_number
return|;
name|recur
operator|=
name|s
expr_stmt|;
if|if
condition|(
operator|!
name|s
operator|->
name|sy_resolved
operator|||
name|s
operator|->
name|sy_value
operator|.
name|X_op
operator|!=
name|O_symbol
operator|||
operator|(
name|S_IS_DEFINED
argument_list|(
name|s
argument_list|)
operator|&&
operator|!
name|S_IS_COMMON
argument_list|(
name|s
argument_list|)
operator|)
condition|)
name|as_bad
argument_list|(
literal|"Attempt to get value of unresolved symbol %s"
argument_list|,
name|S_GET_NAME
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
name|recur
operator|=
name|NULL
expr_stmt|;
block|}
return|return
operator|(
name|valueT
operator|)
name|s
operator|->
name|sy_value
operator|.
name|X_add_number
return|;
block|}
end_function

begin_comment
comment|/* Set the value of a symbol.  */
end_comment

begin_function
name|void
name|S_SET_VALUE
parameter_list|(
name|s
parameter_list|,
name|val
parameter_list|)
name|symbolS
modifier|*
name|s
decl_stmt|;
name|valueT
name|val
decl_stmt|;
block|{
name|s
operator|->
name|sy_value
operator|.
name|X_op
operator|=
name|O_constant
expr_stmt|;
name|s
operator|->
name|sy_value
operator|.
name|X_add_number
operator|=
operator|(
name|offsetT
operator|)
name|val
expr_stmt|;
name|s
operator|->
name|sy_value
operator|.
name|X_unsigned
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|void
name|copy_symbol_attributes
parameter_list|(
name|dest
parameter_list|,
name|src
parameter_list|)
name|symbolS
modifier|*
name|dest
decl_stmt|,
decl|*
name|src
decl_stmt|;
end_function

begin_block
block|{
ifdef|#
directive|ifdef
name|BFD_ASSEMBLER
comment|/* In an expression, transfer the settings of these flags.      The user can override later, of course.  */
define|#
directive|define
name|COPIED_SYMFLAGS
value|(BSF_FUNCTION)
name|dest
operator|->
name|bsym
operator|->
name|flags
operator||=
name|src
operator|->
name|bsym
operator|->
name|flags
operator|&
name|COPIED_SYMFLAGS
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|OBJ_COPY_SYMBOL_ATTRIBUTES
name|OBJ_COPY_SYMBOL_ATTRIBUTES
argument_list|(
name|dest
argument_list|,
name|src
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|BFD_ASSEMBLER
end_ifdef

begin_function
name|int
name|S_IS_EXTERNAL
parameter_list|(
name|s
parameter_list|)
name|symbolS
modifier|*
name|s
decl_stmt|;
block|{
name|flagword
name|flags
init|=
name|s
operator|->
name|bsym
operator|->
name|flags
decl_stmt|;
comment|/* sanity check */
if|if
condition|(
name|flags
operator|&
name|BSF_LOCAL
operator|&&
name|flags
operator|&
name|BSF_GLOBAL
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
operator|(
name|flags
operator|&
name|BSF_GLOBAL
operator|)
operator|!=
literal|0
return|;
block|}
end_function

begin_function
name|int
name|S_IS_WEAK
parameter_list|(
name|s
parameter_list|)
name|symbolS
modifier|*
name|s
decl_stmt|;
block|{
return|return
operator|(
name|s
operator|->
name|bsym
operator|->
name|flags
operator|&
name|BSF_WEAK
operator|)
operator|!=
literal|0
return|;
block|}
end_function

begin_function
name|int
name|S_IS_COMMON
parameter_list|(
name|s
parameter_list|)
name|symbolS
modifier|*
name|s
decl_stmt|;
block|{
return|return
name|bfd_is_com_section
argument_list|(
name|s
operator|->
name|bsym
operator|->
name|section
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|S_IS_DEFINED
parameter_list|(
name|s
parameter_list|)
name|symbolS
modifier|*
name|s
decl_stmt|;
block|{
return|return
name|s
operator|->
name|bsym
operator|->
name|section
operator|!=
name|undefined_section
return|;
block|}
end_function

begin_function
name|int
name|S_IS_DEBUG
parameter_list|(
name|s
parameter_list|)
name|symbolS
modifier|*
name|s
decl_stmt|;
block|{
if|if
condition|(
name|s
operator|->
name|bsym
operator|->
name|flags
operator|&
name|BSF_DEBUGGING
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|S_IS_LOCAL
parameter_list|(
name|s
parameter_list|)
name|symbolS
modifier|*
name|s
decl_stmt|;
block|{
name|flagword
name|flags
init|=
name|s
operator|->
name|bsym
operator|->
name|flags
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
comment|/* sanity check */
if|if
condition|(
name|flags
operator|&
name|BSF_LOCAL
operator|&&
name|flags
operator|&
name|BSF_GLOBAL
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|bfd_get_section
argument_list|(
name|s
operator|->
name|bsym
argument_list|)
operator|==
name|reg_section
condition|)
return|return
literal|1
return|;
name|name
operator|=
name|S_GET_NAME
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|name
operator|!=
name|NULL
operator|&&
operator|!
name|S_IS_DEBUG
argument_list|(
name|s
argument_list|)
operator|&&
operator|(
name|strchr
argument_list|(
name|name
argument_list|,
literal|'\001'
argument_list|)
operator|||
name|strchr
argument_list|(
name|name
argument_list|,
literal|'\002'
argument_list|)
operator|||
operator|(
operator|!
name|flag_keep_locals
operator|&&
operator|(
name|bfd_is_local_label
argument_list|(
name|stdoutput
argument_list|,
name|s
operator|->
name|bsym
argument_list|)
operator|||
operator|(
name|flag_mri
operator|&&
name|name
index|[
literal|0
index|]
operator|==
literal|'?'
operator|&&
name|name
index|[
literal|1
index|]
operator|==
literal|'?'
operator|)
operator|)
operator|)
operator|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|S_IS_EXTERN
parameter_list|(
name|s
parameter_list|)
name|symbolS
modifier|*
name|s
decl_stmt|;
block|{
return|return
name|S_IS_EXTERNAL
argument_list|(
name|s
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|S_IS_STABD
parameter_list|(
name|s
parameter_list|)
name|symbolS
modifier|*
name|s
decl_stmt|;
block|{
return|return
name|S_GET_NAME
argument_list|(
name|s
argument_list|)
operator|==
literal|0
return|;
block|}
end_function

begin_function
name|CONST
name|char
modifier|*
name|S_GET_NAME
parameter_list|(
name|s
parameter_list|)
name|symbolS
modifier|*
name|s
decl_stmt|;
block|{
return|return
name|s
operator|->
name|bsym
operator|->
name|name
return|;
block|}
end_function

begin_function
name|segT
name|S_GET_SEGMENT
parameter_list|(
name|s
parameter_list|)
name|symbolS
modifier|*
name|s
decl_stmt|;
block|{
return|return
name|s
operator|->
name|bsym
operator|->
name|section
return|;
block|}
end_function

begin_function
name|void
name|S_SET_SEGMENT
parameter_list|(
name|s
parameter_list|,
name|seg
parameter_list|)
name|symbolS
modifier|*
name|s
decl_stmt|;
name|segT
name|seg
decl_stmt|;
block|{
name|s
operator|->
name|bsym
operator|->
name|section
operator|=
name|seg
expr_stmt|;
block|}
end_function

begin_function
name|void
name|S_SET_EXTERNAL
parameter_list|(
name|s
parameter_list|)
name|symbolS
modifier|*
name|s
decl_stmt|;
block|{
if|if
condition|(
operator|(
name|s
operator|->
name|bsym
operator|->
name|flags
operator|&
name|BSF_WEAK
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* Let .weak override .global.  */
return|return;
block|}
name|s
operator|->
name|bsym
operator|->
name|flags
operator||=
name|BSF_GLOBAL
expr_stmt|;
name|s
operator|->
name|bsym
operator|->
name|flags
operator|&=
operator|~
operator|(
name|BSF_LOCAL
operator||
name|BSF_WEAK
operator|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|S_CLEAR_EXTERNAL
parameter_list|(
name|s
parameter_list|)
name|symbolS
modifier|*
name|s
decl_stmt|;
block|{
if|if
condition|(
operator|(
name|s
operator|->
name|bsym
operator|->
name|flags
operator|&
name|BSF_WEAK
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* Let .weak override.  */
return|return;
block|}
name|s
operator|->
name|bsym
operator|->
name|flags
operator||=
name|BSF_LOCAL
expr_stmt|;
name|s
operator|->
name|bsym
operator|->
name|flags
operator|&=
operator|~
operator|(
name|BSF_GLOBAL
operator||
name|BSF_WEAK
operator|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|S_SET_WEAK
parameter_list|(
name|s
parameter_list|)
name|symbolS
modifier|*
name|s
decl_stmt|;
block|{
name|s
operator|->
name|bsym
operator|->
name|flags
operator||=
name|BSF_WEAK
expr_stmt|;
name|s
operator|->
name|bsym
operator|->
name|flags
operator|&=
operator|~
operator|(
name|BSF_GLOBAL
operator||
name|BSF_LOCAL
operator|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|S_SET_NAME
parameter_list|(
name|s
parameter_list|,
name|name
parameter_list|)
name|symbolS
modifier|*
name|s
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|s
operator|->
name|bsym
operator|->
name|name
operator|=
name|name
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* BFD_ASSEMBLER */
end_comment

begin_function
name|void
name|symbol_begin
parameter_list|()
block|{
name|symbol_lastP
operator|=
name|NULL
expr_stmt|;
name|symbol_rootP
operator|=
name|NULL
expr_stmt|;
comment|/* In case we have 0 symbols (!!) */
name|sy_hash
operator|=
name|hash_new
argument_list|()
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
operator|&
name|abs_symbol
operator|)
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
name|abs_symbol
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|BFD_ASSEMBLER
if|#
directive|if
name|defined
argument_list|(
name|EMIT_SECTION_SYMBOLS
argument_list|)
operator|||
operator|!
name|defined
argument_list|(
name|RELOC_REQUIRES_SYMBOL
argument_list|)
name|abs_symbol
operator|.
name|bsym
operator|=
name|bfd_abs_section
operator|.
name|symbol
expr_stmt|;
endif|#
directive|endif
else|#
directive|else
comment|/* Can't initialise a union. Sigh. */
name|S_SET_SEGMENT
argument_list|(
operator|&
name|abs_symbol
argument_list|,
name|absolute_section
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|abs_symbol
operator|.
name|sy_value
operator|.
name|X_op
operator|=
name|O_constant
expr_stmt|;
name|abs_symbol
operator|.
name|sy_frag
operator|=
operator|&
name|zero_address_frag
expr_stmt|;
if|if
condition|(
name|LOCAL_LABELS_FB
condition|)
name|fb_label_init
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_decl_stmt
name|int
name|indent_level
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static void indent () {   printf ("%*s", indent_level * 4, ""); }
endif|#
directive|endif
end_endif

begin_function
name|void
name|print_symbol_value_1
parameter_list|(
name|file
parameter_list|,
name|sym
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|symbolS
modifier|*
name|sym
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|name
init|=
name|S_GET_NAME
argument_list|(
name|sym
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|name
operator|||
operator|!
name|name
index|[
literal|0
index|]
condition|)
name|name
operator|=
literal|"(unnamed)"
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"sym %lx %s"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|sym
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
operator|->
name|sy_frag
operator|!=
operator|&
name|zero_address_frag
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" frag %lx"
argument_list|,
operator|(
name|long
operator|)
name|sym
operator|->
name|sy_frag
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
operator|->
name|written
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" written"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
operator|->
name|sy_resolved
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" resolved"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sym
operator|->
name|sy_resolving
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" resolving"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
operator|->
name|sy_used_in_reloc
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" used-in-reloc"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
operator|->
name|sy_used
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" used"
argument_list|)
expr_stmt|;
if|if
condition|(
name|S_IS_LOCAL
argument_list|(
name|sym
argument_list|)
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" local"
argument_list|)
expr_stmt|;
if|if
condition|(
name|S_IS_EXTERN
argument_list|(
name|sym
argument_list|)
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" extern"
argument_list|)
expr_stmt|;
if|if
condition|(
name|S_IS_DEBUG
argument_list|(
name|sym
argument_list|)
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" debug"
argument_list|)
expr_stmt|;
if|if
condition|(
name|S_IS_DEFINED
argument_list|(
name|sym
argument_list|)
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" defined"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" %s"
argument_list|,
name|segment_name
argument_list|(
name|S_GET_SEGMENT
argument_list|(
name|sym
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
operator|->
name|sy_resolved
condition|)
block|{
name|segT
name|s
init|=
name|S_GET_SEGMENT
argument_list|(
name|sym
argument_list|)
decl_stmt|;
if|if
condition|(
name|s
operator|!=
name|undefined_section
operator|&&
name|s
operator|!=
name|expr_section
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" %lx"
argument_list|,
operator|(
name|long
operator|)
name|S_GET_VALUE
argument_list|(
name|sym
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|indent_level
operator|<
literal|8
operator|&&
name|S_GET_SEGMENT
argument_list|(
name|sym
argument_list|)
operator|!=
name|undefined_section
condition|)
block|{
name|indent_level
operator|++
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n%*s<"
argument_list|,
name|indent_level
operator|*
literal|4
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|print_expr_1
argument_list|(
name|file
argument_list|,
operator|&
name|sym
operator|->
name|sy_value
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|">"
argument_list|)
expr_stmt|;
name|indent_level
operator|--
expr_stmt|;
block|}
name|fflush
argument_list|(
name|file
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|print_symbol_value
parameter_list|(
name|sym
parameter_list|)
name|symbolS
modifier|*
name|sym
decl_stmt|;
block|{
name|indent_level
operator|=
literal|0
expr_stmt|;
name|print_symbol_value_1
argument_list|(
name|stderr
argument_list|,
name|sym
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|print_expr_1
parameter_list|(
name|file
parameter_list|,
name|exp
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|expressionS
modifier|*
name|exp
decl_stmt|;
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"expr %lx "
argument_list|,
operator|(
name|long
operator|)
name|exp
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|exp
operator|->
name|X_op
condition|)
block|{
case|case
name|O_illegal
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"illegal"
argument_list|)
expr_stmt|;
break|break;
case|case
name|O_absent
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"absent"
argument_list|)
expr_stmt|;
break|break;
case|case
name|O_constant
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"constant %lx"
argument_list|,
operator|(
name|long
operator|)
name|exp
operator|->
name|X_add_number
argument_list|)
expr_stmt|;
break|break;
case|case
name|O_symbol
case|:
name|indent_level
operator|++
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"symbol\n%*s<"
argument_list|,
name|indent_level
operator|*
literal|4
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|print_symbol_value_1
argument_list|(
name|file
argument_list|,
name|exp
operator|->
name|X_add_symbol
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|">"
argument_list|)
expr_stmt|;
name|maybe_print_addnum
label|:
if|if
condition|(
name|exp
operator|->
name|X_add_number
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n%*s%lx"
argument_list|,
name|indent_level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
operator|(
name|long
operator|)
name|exp
operator|->
name|X_add_number
argument_list|)
expr_stmt|;
name|indent_level
operator|--
expr_stmt|;
break|break;
case|case
name|O_register
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"register #%d"
argument_list|,
operator|(
name|int
operator|)
name|exp
operator|->
name|X_add_number
argument_list|)
expr_stmt|;
break|break;
case|case
name|O_big
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"big"
argument_list|)
expr_stmt|;
break|break;
case|case
name|O_uminus
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"uminus -<"
argument_list|)
expr_stmt|;
name|indent_level
operator|++
expr_stmt|;
name|print_symbol_value_1
argument_list|(
name|file
argument_list|,
name|exp
operator|->
name|X_add_symbol
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|">"
argument_list|)
expr_stmt|;
goto|goto
name|maybe_print_addnum
goto|;
case|case
name|O_bit_not
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"bit_not"
argument_list|)
expr_stmt|;
break|break;
case|case
name|O_multiply
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"multiply"
argument_list|)
expr_stmt|;
break|break;
case|case
name|O_divide
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"divide"
argument_list|)
expr_stmt|;
break|break;
case|case
name|O_modulus
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"modulus"
argument_list|)
expr_stmt|;
break|break;
case|case
name|O_left_shift
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"lshift"
argument_list|)
expr_stmt|;
break|break;
case|case
name|O_right_shift
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"rshift"
argument_list|)
expr_stmt|;
break|break;
case|case
name|O_bit_inclusive_or
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"bit_ior"
argument_list|)
expr_stmt|;
break|break;
case|case
name|O_bit_exclusive_or
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"bit_xor"
argument_list|)
expr_stmt|;
break|break;
case|case
name|O_bit_and
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"bit_and"
argument_list|)
expr_stmt|;
break|break;
case|case
name|O_eq
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"eq"
argument_list|)
expr_stmt|;
break|break;
case|case
name|O_ne
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"ne"
argument_list|)
expr_stmt|;
break|break;
case|case
name|O_lt
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"lt"
argument_list|)
expr_stmt|;
break|break;
case|case
name|O_le
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"le"
argument_list|)
expr_stmt|;
break|break;
case|case
name|O_ge
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"ge"
argument_list|)
expr_stmt|;
break|break;
case|case
name|O_gt
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"gt"
argument_list|)
expr_stmt|;
break|break;
case|case
name|O_logical_and
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"logical_and"
argument_list|)
expr_stmt|;
break|break;
case|case
name|O_logical_or
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"logical_or"
argument_list|)
expr_stmt|;
break|break;
case|case
name|O_add
case|:
name|indent_level
operator|++
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"add\n%*s<"
argument_list|,
name|indent_level
operator|*
literal|4
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|print_symbol_value_1
argument_list|(
name|file
argument_list|,
name|exp
operator|->
name|X_add_symbol
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|">\n%*s<"
argument_list|,
name|indent_level
operator|*
literal|4
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|print_symbol_value_1
argument_list|(
name|file
argument_list|,
name|exp
operator|->
name|X_op_symbol
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|">"
argument_list|)
expr_stmt|;
goto|goto
name|maybe_print_addnum
goto|;
case|case
name|O_subtract
case|:
name|indent_level
operator|++
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"subtract\n%*s<"
argument_list|,
name|indent_level
operator|*
literal|4
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|print_symbol_value_1
argument_list|(
name|file
argument_list|,
name|exp
operator|->
name|X_add_symbol
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|">\n%*s<"
argument_list|,
name|indent_level
operator|*
literal|4
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|print_symbol_value_1
argument_list|(
name|file
argument_list|,
name|exp
operator|->
name|X_op_symbol
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|">"
argument_list|)
expr_stmt|;
goto|goto
name|maybe_print_addnum
goto|;
default|default:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"{unknown opcode %d}"
argument_list|,
operator|(
name|int
operator|)
name|exp
operator|->
name|X_op
argument_list|)
expr_stmt|;
break|break;
block|}
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|print_expr
parameter_list|(
name|exp
parameter_list|)
name|expressionS
modifier|*
name|exp
decl_stmt|;
block|{
name|print_expr_1
argument_list|(
name|stderr
argument_list|,
name|exp
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|symbol_print_statistics
parameter_list|(
name|file
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
block|{
name|hash_print_statistics
argument_list|(
name|file
argument_list|,
literal|"symbol table"
argument_list|,
name|sy_hash
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* end of symbols.c */
end_comment

end_unit

