begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* symbols.c -symbol table-    Copyright 1987, 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998,    1999, 2000, 2001    Free Software Foundation, Inc.     This file is part of GAS, the GNU Assembler.     GAS is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     GAS is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with GAS; see the file COPYING.  If not, write to the Free    Software Foundation, 59 Temple Place - Suite 330, Boston, MA    02111-1307, USA.  */
end_comment

begin_comment
comment|/* #define DEBUG_SYMS / * to debug symbol list maintenance.  */
end_comment

begin_include
include|#
directive|include
file|"as.h"
end_include

begin_include
include|#
directive|include
file|"safe-ctype.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_comment
comment|/* For "symbols.h" */
end_comment

begin_include
include|#
directive|include
file|"subsegs.h"
end_include

begin_include
include|#
directive|include
file|"struc-symbol.h"
end_include

begin_comment
comment|/* This is non-zero if symbols are case sensitive, which is the    default.  */
end_comment

begin_decl_stmt
name|int
name|symbols_case_sensitive
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|WORKING_DOT_WORD
end_ifndef

begin_decl_stmt
specifier|extern
name|int
name|new_broken_words
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* symbol-name => struct symbol pointer */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|hash_control
modifier|*
name|sy_hash
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Table of local symbols.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|hash_control
modifier|*
name|local_hash
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Below are commented in "symbols.h".  */
end_comment

begin_decl_stmt
name|symbolS
modifier|*
name|symbol_rootP
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|symbolS
modifier|*
name|symbol_lastP
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|symbolS
name|abs_symbol
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG_SYMS
end_ifdef

begin_define
define|#
directive|define
name|debug_verify_symchain
value|verify_symbol_chain
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|debug_verify_symchain
parameter_list|(
name|root
parameter_list|,
name|last
parameter_list|)
value|((void) 0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|DOLLAR_LABEL_CHAR
value|'\001'
end_define

begin_define
define|#
directive|define
name|LOCAL_LABEL_CHAR
value|'\002'
end_define

begin_decl_stmt
name|struct
name|obstack
name|notes
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|save_symbol_name
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|fb_label_init
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|dollar_label_instance
name|PARAMS
argument_list|(
operator|(
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|fb_label_instance
name|PARAMS
argument_list|(
operator|(
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|print_binary
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
name|expressionS
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Return a pointer to a new symbol.  Die if we can't make a new    symbol.  Fill in the symbol's values.  Add symbol to end of symbol    chain.     This function should be called in the general case of creating a    symbol.  However, if the output file symbol table has already been    set, and you are certain that this symbol won't be wanted in the    output file, you can call symbol_create.  */
end_comment

begin_function
name|symbolS
modifier|*
name|symbol_new
parameter_list|(
name|name
parameter_list|,
name|segment
parameter_list|,
name|valu
parameter_list|,
name|frag
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|segT
name|segment
decl_stmt|;
name|valueT
name|valu
decl_stmt|;
name|fragS
modifier|*
name|frag
decl_stmt|;
block|{
name|symbolS
modifier|*
name|symbolP
init|=
name|symbol_create
argument_list|(
name|name
argument_list|,
name|segment
argument_list|,
name|valu
argument_list|,
name|frag
argument_list|)
decl_stmt|;
comment|/* Link to end of symbol chain.  */
ifdef|#
directive|ifdef
name|BFD_ASSEMBLER
block|{
specifier|extern
name|int
name|symbol_table_frozen
decl_stmt|;
if|if
condition|(
name|symbol_table_frozen
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
name|symbol_append
argument_list|(
name|symbolP
argument_list|,
name|symbol_lastP
argument_list|,
operator|&
name|symbol_rootP
argument_list|,
operator|&
name|symbol_lastP
argument_list|)
expr_stmt|;
return|return
name|symbolP
return|;
block|}
end_function

begin_comment
comment|/* Save a symbol name on a permanent obstack, and convert it according    to the object file format.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|save_symbol_name
parameter_list|(
name|name
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|unsigned
name|int
name|name_length
decl_stmt|;
name|char
modifier|*
name|ret
decl_stmt|;
name|name_length
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
expr_stmt|;
comment|/* +1 for \0.  */
name|obstack_grow
argument_list|(
operator|&
name|notes
argument_list|,
name|name
argument_list|,
name|name_length
argument_list|)
expr_stmt|;
name|ret
operator|=
name|obstack_finish
argument_list|(
operator|&
name|notes
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|STRIP_UNDERSCORE
if|if
condition|(
name|ret
index|[
literal|0
index|]
operator|==
literal|'_'
condition|)
operator|++
name|ret
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|tc_canonicalize_symbol_name
name|ret
operator|=
name|tc_canonicalize_symbol_name
argument_list|(
name|ret
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|symbols_case_sensitive
condition|)
block|{
name|char
modifier|*
name|s
decl_stmt|;
for|for
control|(
name|s
operator|=
name|ret
init|;
operator|*
name|s
operator|!=
literal|'\0'
condition|;
name|s
operator|++
control|)
operator|*
name|s
operator|=
name|TOUPPER
argument_list|(
operator|*
name|s
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_function
name|symbolS
modifier|*
name|symbol_create
parameter_list|(
name|name
parameter_list|,
name|segment
parameter_list|,
name|valu
parameter_list|,
name|frag
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
comment|/* It is copied, the caller can destroy/modify.  */
name|segT
name|segment
decl_stmt|;
comment|/* Segment identifier (SEG_<something>).  */
name|valueT
name|valu
decl_stmt|;
comment|/* Symbol value.  */
name|fragS
modifier|*
name|frag
decl_stmt|;
comment|/* Associated fragment.  */
block|{
name|char
modifier|*
name|preserved_copy_of_name
decl_stmt|;
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
name|preserved_copy_of_name
operator|=
name|save_symbol_name
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|symbolP
operator|=
operator|(
name|symbolS
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|notes
argument_list|,
sizeof|sizeof
argument_list|(
name|symbolS
argument_list|)
argument_list|)
expr_stmt|;
comment|/* symbol must be born in some fixed state.  This seems as good as any.  */
name|memset
argument_list|(
name|symbolP
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|symbolS
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|BFD_ASSEMBLER
name|symbolP
operator|->
name|bsym
operator|=
name|bfd_make_empty_symbol
argument_list|(
name|stdoutput
argument_list|)
expr_stmt|;
if|if
condition|(
name|symbolP
operator|->
name|bsym
operator|==
name|NULL
condition|)
name|as_perror
argument_list|(
literal|"%s"
argument_list|,
literal|"bfd_make_empty_symbol"
argument_list|)
expr_stmt|;
name|symbolP
operator|->
name|bsym
operator|->
name|udata
operator|.
name|p
operator|=
operator|(
name|PTR
operator|)
name|symbolP
expr_stmt|;
endif|#
directive|endif
name|S_SET_NAME
argument_list|(
name|symbolP
argument_list|,
name|preserved_copy_of_name
argument_list|)
expr_stmt|;
name|S_SET_SEGMENT
argument_list|(
name|symbolP
argument_list|,
name|segment
argument_list|)
expr_stmt|;
name|S_SET_VALUE
argument_list|(
name|symbolP
argument_list|,
name|valu
argument_list|)
expr_stmt|;
name|symbol_clear_list_pointers
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
name|symbolP
operator|->
name|sy_frag
operator|=
name|frag
expr_stmt|;
ifndef|#
directive|ifndef
name|BFD_ASSEMBLER
name|symbolP
operator|->
name|sy_number
operator|=
operator|~
literal|0
expr_stmt|;
name|symbolP
operator|->
name|sy_name_offset
operator|=
operator|(
name|unsigned
name|int
operator|)
operator|~
literal|0
expr_stmt|;
endif|#
directive|endif
name|obj_symbol_new_hook
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|tc_symbol_new_hook
name|tc_symbol_new_hook
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|symbolP
return|;
block|}
end_function

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|BFD_ASSEMBLER
end_ifdef

begin_comment
comment|/* Local symbol support.  If we can get away with it, we keep only a    small amount of information for local symbols.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|local_symbol
modifier|*
name|local_symbol_make
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
name|segT
operator|,
name|valueT
operator|,
name|fragS
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|symbolS
modifier|*
name|local_symbol_convert
name|PARAMS
argument_list|(
operator|(
expr|struct
name|local_symbol
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Used for statistics.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|long
name|local_symbol_count
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|long
name|local_symbol_conversion_count
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This macro is called with a symbol argument passed by reference.    It returns whether this is a local symbol.  If necessary, it    changes its argument to the real symbol.  */
end_comment

begin_define
define|#
directive|define
name|LOCAL_SYMBOL_CHECK
parameter_list|(
name|s
parameter_list|)
define|\
value|(s->bsym == NULL							\    ? (local_symbol_converted_p ((struct local_symbol *) s)		\       ? (s = local_symbol_get_real_symbol ((struct local_symbol *) s),	\ 	 0)								\       : 1)								\    : 0)
end_define

begin_comment
comment|/* Create a local symbol and insert it into the local hash table.  */
end_comment

begin_function
specifier|static
name|struct
name|local_symbol
modifier|*
name|local_symbol_make
parameter_list|(
name|name
parameter_list|,
name|section
parameter_list|,
name|value
parameter_list|,
name|frag
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|segT
name|section
decl_stmt|;
name|valueT
name|value
decl_stmt|;
name|fragS
modifier|*
name|frag
decl_stmt|;
block|{
name|char
modifier|*
name|name_copy
decl_stmt|;
name|struct
name|local_symbol
modifier|*
name|ret
decl_stmt|;
operator|++
name|local_symbol_count
expr_stmt|;
name|name_copy
operator|=
name|save_symbol_name
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|ret
operator|=
operator|(
expr|struct
name|local_symbol
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|notes
argument_list|,
sizeof|sizeof
expr|*
name|ret
argument_list|)
expr_stmt|;
name|ret
operator|->
name|lsy_marker
operator|=
name|NULL
expr_stmt|;
name|ret
operator|->
name|lsy_name
operator|=
name|name_copy
expr_stmt|;
name|ret
operator|->
name|lsy_section
operator|=
name|section
expr_stmt|;
name|local_symbol_set_frag
argument_list|(
name|ret
argument_list|,
name|frag
argument_list|)
expr_stmt|;
name|ret
operator|->
name|lsy_value
operator|=
name|value
expr_stmt|;
name|hash_jam
argument_list|(
name|local_hash
argument_list|,
name|name_copy
argument_list|,
operator|(
name|PTR
operator|)
name|ret
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Convert a local symbol into a real symbol.  Note that we do not    reclaim the space used by the local symbol.  */
end_comment

begin_function
specifier|static
name|symbolS
modifier|*
name|local_symbol_convert
parameter_list|(
name|locsym
parameter_list|)
name|struct
name|local_symbol
modifier|*
name|locsym
decl_stmt|;
block|{
name|symbolS
modifier|*
name|ret
decl_stmt|;
name|assert
argument_list|(
name|locsym
operator|->
name|lsy_marker
operator|==
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|local_symbol_converted_p
argument_list|(
name|locsym
argument_list|)
condition|)
return|return
name|local_symbol_get_real_symbol
argument_list|(
name|locsym
argument_list|)
return|;
operator|++
name|local_symbol_conversion_count
expr_stmt|;
name|ret
operator|=
name|symbol_new
argument_list|(
name|locsym
operator|->
name|lsy_name
argument_list|,
name|locsym
operator|->
name|lsy_section
argument_list|,
name|locsym
operator|->
name|lsy_value
argument_list|,
name|local_symbol_get_frag
argument_list|(
name|locsym
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|local_symbol_resolved_p
argument_list|(
name|locsym
argument_list|)
condition|)
name|ret
operator|->
name|sy_resolved
operator|=
literal|1
expr_stmt|;
comment|/* Local symbols are always either defined or used.  */
name|ret
operator|->
name|sy_used
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|TC_LOCAL_SYMFIELD_CONVERT
name|TC_LOCAL_SYMFIELD_CONVERT
argument_list|(
name|locsym
argument_list|,
name|ret
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|symbol_table_insert
argument_list|(
name|ret
argument_list|)
expr_stmt|;
name|local_symbol_mark_converted
argument_list|(
name|locsym
argument_list|)
expr_stmt|;
name|local_symbol_set_real_symbol
argument_list|(
name|locsym
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|hash_jam
argument_list|(
name|local_hash
argument_list|,
name|locsym
operator|->
name|lsy_name
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* ! BFD_ASSEMBLER */
end_comment

begin_define
define|#
directive|define
name|LOCAL_SYMBOL_CHECK
parameter_list|(
name|s
parameter_list|)
value|0
end_define

begin_define
define|#
directive|define
name|local_symbol_convert
parameter_list|(
name|s
parameter_list|)
value|((symbolS *) s)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ! BFD_ASSEMBLER */
end_comment

begin_escape
end_escape

begin_comment
comment|/* We have just seen "<name>:".    Creates a struct symbol unless it already exists.     Gripes if we are redefining a symbol incompatibly (and ignores it).  */
end_comment

begin_function
name|symbolS
modifier|*
name|colon
parameter_list|(
name|sym_name
parameter_list|)
comment|/* Just seen "x:" - rattle symbols& frags.  */
specifier|const
name|char
modifier|*
name|sym_name
decl_stmt|;
comment|/* Symbol name, as a cannonical string.  */
comment|/* We copy this string: OK to alter later.  */
block|{
specifier|register
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
comment|/* Symbol we are working with.  */
comment|/* Sun local labels go out of scope whenever a non-local symbol is      defined.  */
if|if
condition|(
name|LOCAL_LABELS_DOLLAR
condition|)
block|{
name|int
name|local
decl_stmt|;
ifdef|#
directive|ifdef
name|BFD_ASSEMBLER
name|local
operator|=
name|bfd_is_local_label_name
argument_list|(
name|stdoutput
argument_list|,
name|sym_name
argument_list|)
expr_stmt|;
else|#
directive|else
name|local
operator|=
name|LOCAL_LABEL
argument_list|(
name|sym_name
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|local
condition|)
name|dollar_label_clear
argument_list|()
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|WORKING_DOT_WORD
if|if
condition|(
name|new_broken_words
condition|)
block|{
name|struct
name|broken_word
modifier|*
name|a
decl_stmt|;
name|int
name|possible_bytes
decl_stmt|;
name|fragS
modifier|*
name|frag_tmp
decl_stmt|;
name|char
modifier|*
name|frag_opcode
decl_stmt|;
specifier|extern
specifier|const
name|int
name|md_short_jump_size
decl_stmt|;
specifier|extern
specifier|const
name|int
name|md_long_jump_size
decl_stmt|;
name|possible_bytes
operator|=
operator|(
name|md_short_jump_size
operator|+
name|new_broken_words
operator|*
name|md_long_jump_size
operator|)
expr_stmt|;
name|frag_tmp
operator|=
name|frag_now
expr_stmt|;
name|frag_opcode
operator|=
name|frag_var
argument_list|(
name|rs_broken_word
argument_list|,
name|possible_bytes
argument_list|,
name|possible_bytes
argument_list|,
operator|(
name|relax_substateT
operator|)
literal|0
argument_list|,
operator|(
name|symbolS
operator|*
operator|)
name|broken_words
argument_list|,
operator|(
name|offsetT
operator|)
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* We want to store the pointer to where to insert the jump 	 table in the fr_opcode of the rs_broken_word frag.  This 	 requires a little hackery.  */
while|while
condition|(
name|frag_tmp
operator|&&
operator|(
name|frag_tmp
operator|->
name|fr_type
operator|!=
name|rs_broken_word
operator|||
name|frag_tmp
operator|->
name|fr_opcode
operator|)
condition|)
name|frag_tmp
operator|=
name|frag_tmp
operator|->
name|fr_next
expr_stmt|;
name|know
argument_list|(
name|frag_tmp
argument_list|)
expr_stmt|;
name|frag_tmp
operator|->
name|fr_opcode
operator|=
name|frag_opcode
expr_stmt|;
name|new_broken_words
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|a
operator|=
name|broken_words
init|;
name|a
operator|&&
name|a
operator|->
name|dispfrag
operator|==
literal|0
condition|;
name|a
operator|=
name|a
operator|->
name|next_broken_word
control|)
name|a
operator|->
name|dispfrag
operator|=
name|frag_tmp
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* WORKING_DOT_WORD */
if|if
condition|(
operator|(
name|symbolP
operator|=
name|symbol_find
argument_list|(
name|sym_name
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|RESOLVE_SYMBOL_REDEFINITION
if|if
condition|(
name|RESOLVE_SYMBOL_REDEFINITION
argument_list|(
name|symbolP
argument_list|)
condition|)
return|return
name|symbolP
return|;
endif|#
directive|endif
comment|/* Now check for undefined symbols.  */
if|if
condition|(
name|LOCAL_SYMBOL_CHECK
argument_list|(
name|symbolP
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|BFD_ASSEMBLER
name|struct
name|local_symbol
modifier|*
name|locsym
init|=
operator|(
expr|struct
name|local_symbol
operator|*
operator|)
name|symbolP
decl_stmt|;
if|if
condition|(
name|locsym
operator|->
name|lsy_section
operator|!=
name|undefined_section
operator|&&
operator|(
name|local_symbol_get_frag
argument_list|(
name|locsym
argument_list|)
operator|!=
name|frag_now
operator|||
name|locsym
operator|->
name|lsy_section
operator|!=
name|now_seg
operator|||
name|locsym
operator|->
name|lsy_value
operator|!=
name|frag_now_fix
argument_list|()
operator|)
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"symbol `%s' is already defined"
argument_list|)
argument_list|,
name|sym_name
argument_list|)
expr_stmt|;
return|return
name|symbolP
return|;
block|}
name|locsym
operator|->
name|lsy_section
operator|=
name|now_seg
expr_stmt|;
name|local_symbol_set_frag
argument_list|(
name|locsym
argument_list|,
name|frag_now
argument_list|)
expr_stmt|;
name|locsym
operator|->
name|lsy_value
operator|=
name|frag_now_fix
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
operator|!
name|S_IS_DEFINED
argument_list|(
name|symbolP
argument_list|)
operator|||
name|S_IS_COMMON
argument_list|(
name|symbolP
argument_list|)
condition|)
block|{
if|if
condition|(
name|S_GET_VALUE
argument_list|(
name|symbolP
argument_list|)
operator|==
literal|0
condition|)
block|{
name|symbolP
operator|->
name|sy_frag
operator|=
name|frag_now
expr_stmt|;
ifdef|#
directive|ifdef
name|OBJ_VMS
name|S_SET_OTHER
argument_list|(
name|symbolP
argument_list|,
name|const_flag
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|S_SET_VALUE
argument_list|(
name|symbolP
argument_list|,
operator|(
name|valueT
operator|)
name|frag_now_fix
argument_list|()
argument_list|)
expr_stmt|;
name|S_SET_SEGMENT
argument_list|(
name|symbolP
argument_list|,
name|now_seg
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|N_UNDF
name|know
argument_list|(
name|N_UNDF
operator|==
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* if we have one, it better be zero.  */
block|}
else|else
block|{
comment|/* There are still several cases to check:  		 A .comm/.lcomm symbol being redefined as initialized 		 data is OK  		 A .comm/.lcomm symbol being redefined with a larger 		 size is also OK  		 This only used to be allowed on VMS gas, but Sun cc 		 on the sparc also depends on it.  */
if|if
condition|(
operator|(
operator|(
operator|!
name|S_IS_DEBUG
argument_list|(
name|symbolP
argument_list|)
operator|&&
operator|(
operator|!
name|S_IS_DEFINED
argument_list|(
name|symbolP
argument_list|)
operator|||
name|S_IS_COMMON
argument_list|(
name|symbolP
argument_list|)
operator|)
operator|&&
name|S_IS_EXTERNAL
argument_list|(
name|symbolP
argument_list|)
operator|)
operator|||
name|S_GET_SEGMENT
argument_list|(
name|symbolP
argument_list|)
operator|==
name|bss_section
operator|)
operator|&&
operator|(
name|now_seg
operator|==
name|data_section
operator|||
name|now_seg
operator|==
name|S_GET_SEGMENT
argument_list|(
name|symbolP
argument_list|)
operator|)
condition|)
block|{
comment|/* Select which of the 2 cases this is.  */
if|if
condition|(
name|now_seg
operator|!=
name|data_section
condition|)
block|{
comment|/* New .comm for prev .comm symbol.  			 If the new size is larger we just change its 			 value.  If the new size is smaller, we ignore 			 this symbol.  */
if|if
condition|(
name|S_GET_VALUE
argument_list|(
name|symbolP
argument_list|)
operator|<
operator|(
operator|(
name|unsigned
operator|)
name|frag_now_fix
argument_list|()
operator|)
condition|)
block|{
name|S_SET_VALUE
argument_list|(
name|symbolP
argument_list|,
operator|(
name|valueT
operator|)
name|frag_now_fix
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* It is a .comm/.lcomm being converted to initialized 			 data.  */
name|symbolP
operator|->
name|sy_frag
operator|=
name|frag_now
expr_stmt|;
ifdef|#
directive|ifdef
name|OBJ_VMS
name|S_SET_OTHER
argument_list|(
name|symbolP
argument_list|,
name|const_flag
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|S_SET_VALUE
argument_list|(
name|symbolP
argument_list|,
operator|(
name|valueT
operator|)
name|frag_now_fix
argument_list|()
argument_list|)
expr_stmt|;
name|S_SET_SEGMENT
argument_list|(
name|symbolP
argument_list|,
name|now_seg
argument_list|)
expr_stmt|;
comment|/* Keep N_EXT bit.  */
block|}
block|}
else|else
block|{
if|#
directive|if
operator|(
operator|!
name|defined
argument_list|(
name|OBJ_AOUT
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|OBJ_MAYBE_AOUT
argument_list|)
expr|\
operator|&&
operator|!
name|defined
argument_list|(
name|OBJ_BOUT
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|OBJ_MAYBE_BOUT
argument_list|)
operator|)
specifier|static
specifier|const
name|char
modifier|*
name|od_buf
init|=
literal|""
decl_stmt|;
else|#
directive|else
name|char
name|od_buf
index|[
literal|100
index|]
decl_stmt|;
name|od_buf
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
ifdef|#
directive|ifdef
name|BFD_ASSEMBLER
if|if
condition|(
name|OUTPUT_FLAVOR
operator|==
name|bfd_target_aout_flavour
condition|)
endif|#
directive|endif
name|sprintf
argument_list|(
name|od_buf
argument_list|,
literal|"%d.%d."
argument_list|,
name|S_GET_OTHER
argument_list|(
name|symbolP
argument_list|)
argument_list|,
name|S_GET_DESC
argument_list|(
name|symbolP
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"symbol `%s' is already defined as \"%s\"/%s%ld"
argument_list|)
argument_list|,
name|sym_name
argument_list|,
name|segment_name
argument_list|(
name|S_GET_SEGMENT
argument_list|(
name|symbolP
argument_list|)
argument_list|)
argument_list|,
name|od_buf
argument_list|,
operator|(
name|long
operator|)
name|S_GET_VALUE
argument_list|(
name|symbolP
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* if the undefined symbol has no value  */
block|}
else|else
block|{
comment|/* Don't blow up if the definition is the same.  */
if|if
condition|(
operator|!
operator|(
name|frag_now
operator|==
name|symbolP
operator|->
name|sy_frag
operator|&&
name|S_GET_VALUE
argument_list|(
name|symbolP
argument_list|)
operator|==
name|frag_now_fix
argument_list|()
operator|&&
name|S_GET_SEGMENT
argument_list|(
name|symbolP
argument_list|)
operator|==
name|now_seg
operator|)
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"symbol `%s' is already defined"
argument_list|)
argument_list|,
name|sym_name
argument_list|)
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|BFD_ASSEMBLER
elseif|else
if|if
condition|(
operator|!
name|flag_keep_locals
operator|&&
name|bfd_is_local_label_name
argument_list|(
name|stdoutput
argument_list|,
name|sym_name
argument_list|)
condition|)
block|{
name|symbolP
operator|=
operator|(
name|symbolS
operator|*
operator|)
name|local_symbol_make
argument_list|(
name|sym_name
argument_list|,
name|now_seg
argument_list|,
operator|(
name|valueT
operator|)
name|frag_now_fix
argument_list|()
argument_list|,
name|frag_now
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* BFD_ASSEMBLER */
else|else
block|{
name|symbolP
operator|=
name|symbol_new
argument_list|(
name|sym_name
argument_list|,
name|now_seg
argument_list|,
operator|(
name|valueT
operator|)
name|frag_now_fix
argument_list|()
argument_list|,
name|frag_now
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|OBJ_VMS
name|S_SET_OTHER
argument_list|(
name|symbolP
argument_list|,
name|const_flag
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* OBJ_VMS */
name|symbol_table_insert
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mri_common_symbol
operator|!=
name|NULL
condition|)
block|{
comment|/* This symbol is actually being defined within an MRI common          section.  This requires special handling.  */
if|if
condition|(
name|LOCAL_SYMBOL_CHECK
argument_list|(
name|symbolP
argument_list|)
condition|)
name|symbolP
operator|=
name|local_symbol_convert
argument_list|(
operator|(
expr|struct
name|local_symbol
operator|*
operator|)
name|symbolP
argument_list|)
expr_stmt|;
name|symbolP
operator|->
name|sy_value
operator|.
name|X_op
operator|=
name|O_symbol
expr_stmt|;
name|symbolP
operator|->
name|sy_value
operator|.
name|X_add_symbol
operator|=
name|mri_common_symbol
expr_stmt|;
name|symbolP
operator|->
name|sy_value
operator|.
name|X_add_number
operator|=
name|S_GET_VALUE
argument_list|(
name|mri_common_symbol
argument_list|)
expr_stmt|;
name|symbolP
operator|->
name|sy_frag
operator|=
operator|&
name|zero_address_frag
expr_stmt|;
name|S_SET_SEGMENT
argument_list|(
name|symbolP
argument_list|,
name|expr_section
argument_list|)
expr_stmt|;
name|symbolP
operator|->
name|sy_mri_common
operator|=
literal|1
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|tc_frob_label
name|tc_frob_label
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|obj_frob_label
name|obj_frob_label
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|symbolP
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Die if we can't insert the symbol.  */
end_comment

begin_function
name|void
name|symbol_table_insert
parameter_list|(
name|symbolP
parameter_list|)
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
block|{
specifier|register
specifier|const
name|char
modifier|*
name|error_string
decl_stmt|;
name|know
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
name|know
argument_list|(
name|S_GET_NAME
argument_list|(
name|symbolP
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOCAL_SYMBOL_CHECK
argument_list|(
name|symbolP
argument_list|)
condition|)
block|{
name|error_string
operator|=
name|hash_jam
argument_list|(
name|local_hash
argument_list|,
name|S_GET_NAME
argument_list|(
name|symbolP
argument_list|)
argument_list|,
operator|(
name|PTR
operator|)
name|symbolP
argument_list|)
expr_stmt|;
if|if
condition|(
name|error_string
operator|!=
name|NULL
condition|)
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"inserting \"%s\" into symbol table failed: %s"
argument_list|)
argument_list|,
name|S_GET_NAME
argument_list|(
name|symbolP
argument_list|)
argument_list|,
name|error_string
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|error_string
operator|=
name|hash_jam
argument_list|(
name|sy_hash
argument_list|,
name|S_GET_NAME
argument_list|(
name|symbolP
argument_list|)
argument_list|,
operator|(
name|PTR
operator|)
name|symbolP
argument_list|)
operator|)
condition|)
block|{
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"inserting \"%s\" into symbol table failed: %s"
argument_list|)
argument_list|,
name|S_GET_NAME
argument_list|(
name|symbolP
argument_list|)
argument_list|,
name|error_string
argument_list|)
expr_stmt|;
block|}
comment|/* on error  */
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* If a symbol name does not exist, create it as undefined, and insert    it into the symbol table.  Return a pointer to it.  */
end_comment

begin_function
name|symbolS
modifier|*
name|symbol_find_or_make
parameter_list|(
name|name
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
specifier|register
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
name|symbolP
operator|=
name|symbol_find
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|symbolP
operator|==
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|BFD_ASSEMBLER
if|if
condition|(
operator|!
name|flag_keep_locals
operator|&&
name|bfd_is_local_label_name
argument_list|(
name|stdoutput
argument_list|,
name|name
argument_list|)
condition|)
block|{
name|symbolP
operator|=
name|md_undefined_symbol
argument_list|(
operator|(
name|char
operator|*
operator|)
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|symbolP
operator|!=
name|NULL
condition|)
return|return
name|symbolP
return|;
name|symbolP
operator|=
operator|(
name|symbolS
operator|*
operator|)
name|local_symbol_make
argument_list|(
name|name
argument_list|,
name|undefined_section
argument_list|,
operator|(
name|valueT
operator|)
literal|0
argument_list|,
operator|&
name|zero_address_frag
argument_list|)
expr_stmt|;
return|return
name|symbolP
return|;
block|}
endif|#
directive|endif
name|symbolP
operator|=
name|symbol_make
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|symbol_table_insert
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
block|}
comment|/* if symbol wasn't found */
return|return
operator|(
name|symbolP
operator|)
return|;
block|}
end_function

begin_function
name|symbolS
modifier|*
name|symbol_make
parameter_list|(
name|name
parameter_list|)
name|CONST
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
comment|/* Let the machine description default it, e.g. for register names.  */
name|symbolP
operator|=
name|md_undefined_symbol
argument_list|(
operator|(
name|char
operator|*
operator|)
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|symbolP
condition|)
name|symbolP
operator|=
name|symbol_new
argument_list|(
name|name
argument_list|,
name|undefined_section
argument_list|,
operator|(
name|valueT
operator|)
literal|0
argument_list|,
operator|&
name|zero_address_frag
argument_list|)
expr_stmt|;
return|return
operator|(
name|symbolP
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Implement symbol table lookup.    In:	A symbol's name as a string: '\0' can't be part of a symbol name.    Out:	NULL if the name was not in the symbol table, else the address    of a struct symbol associated with that name.  */
end_comment

begin_function
name|symbolS
modifier|*
name|symbol_find
parameter_list|(
name|name
parameter_list|)
name|CONST
name|char
modifier|*
name|name
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|STRIP_UNDERSCORE
return|return
operator|(
name|symbol_find_base
argument_list|(
name|name
argument_list|,
literal|1
argument_list|)
operator|)
return|;
else|#
directive|else
comment|/* STRIP_UNDERSCORE */
return|return
operator|(
name|symbol_find_base
argument_list|(
name|name
argument_list|,
literal|0
argument_list|)
operator|)
return|;
endif|#
directive|endif
comment|/* STRIP_UNDERSCORE */
block|}
end_function

begin_function
name|symbolS
modifier|*
name|symbol_find_base
parameter_list|(
name|name
parameter_list|,
name|strip_underscore
parameter_list|)
name|CONST
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|strip_underscore
decl_stmt|;
block|{
if|if
condition|(
name|strip_underscore
operator|&&
operator|*
name|name
operator|==
literal|'_'
condition|)
name|name
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|tc_canonicalize_symbol_name
block|{
name|char
modifier|*
name|copy
decl_stmt|;
name|size_t
name|len
init|=
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
decl_stmt|;
name|copy
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|copy
argument_list|,
name|name
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|name
operator|=
name|tc_canonicalize_symbol_name
argument_list|(
name|copy
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
operator|!
name|symbols_case_sensitive
condition|)
block|{
name|char
modifier|*
name|copy
decl_stmt|;
specifier|const
name|char
modifier|*
name|orig
decl_stmt|;
name|unsigned
name|char
name|c
decl_stmt|;
name|orig
operator|=
name|name
expr_stmt|;
name|name
operator|=
name|copy
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|orig
operator|++
operator|)
operator|!=
literal|'\0'
condition|)
block|{
operator|*
name|copy
operator|++
operator|=
name|TOUPPER
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
operator|*
name|copy
operator|=
literal|'\0'
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|BFD_ASSEMBLER
block|{
name|struct
name|local_symbol
modifier|*
name|locsym
decl_stmt|;
name|locsym
operator|=
operator|(
expr|struct
name|local_symbol
operator|*
operator|)
name|hash_find
argument_list|(
name|local_hash
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|locsym
operator|!=
name|NULL
condition|)
return|return
operator|(
name|symbolS
operator|*
operator|)
name|locsym
return|;
block|}
endif|#
directive|endif
return|return
operator|(
operator|(
name|symbolS
operator|*
operator|)
name|hash_find
argument_list|(
name|sy_hash
argument_list|,
name|name
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Once upon a time, symbols were kept in a singly linked list.  At    least coff needs to be able to rearrange them from time to time, for    which a doubly linked list is much more convenient.  Loic did these    as macros which seemed dangerous to me so they're now functions.    xoxorich.  */
end_comment

begin_comment
comment|/* Link symbol ADDME after symbol TARGET in the chain.  */
end_comment

begin_function
name|void
name|symbol_append
parameter_list|(
name|addme
parameter_list|,
name|target
parameter_list|,
name|rootPP
parameter_list|,
name|lastPP
parameter_list|)
name|symbolS
modifier|*
name|addme
decl_stmt|;
name|symbolS
modifier|*
name|target
decl_stmt|;
name|symbolS
modifier|*
modifier|*
name|rootPP
decl_stmt|;
name|symbolS
modifier|*
modifier|*
name|lastPP
decl_stmt|;
block|{
if|if
condition|(
name|LOCAL_SYMBOL_CHECK
argument_list|(
name|addme
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|target
operator|!=
name|NULL
operator|&&
name|LOCAL_SYMBOL_CHECK
argument_list|(
name|target
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|target
operator|==
name|NULL
condition|)
block|{
name|know
argument_list|(
operator|*
name|rootPP
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|know
argument_list|(
operator|*
name|lastPP
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|addme
operator|->
name|sy_next
operator|=
name|NULL
expr_stmt|;
ifdef|#
directive|ifdef
name|SYMBOLS_NEED_BACKPOINTERS
name|addme
operator|->
name|sy_previous
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
operator|*
name|rootPP
operator|=
name|addme
expr_stmt|;
operator|*
name|lastPP
operator|=
name|addme
expr_stmt|;
return|return;
block|}
comment|/* if the list is empty  */
if|if
condition|(
name|target
operator|->
name|sy_next
operator|!=
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|SYMBOLS_NEED_BACKPOINTERS
name|target
operator|->
name|sy_next
operator|->
name|sy_previous
operator|=
name|addme
expr_stmt|;
endif|#
directive|endif
comment|/* SYMBOLS_NEED_BACKPOINTERS */
block|}
else|else
block|{
name|know
argument_list|(
operator|*
name|lastPP
operator|==
name|target
argument_list|)
expr_stmt|;
operator|*
name|lastPP
operator|=
name|addme
expr_stmt|;
block|}
comment|/* if we have a next  */
name|addme
operator|->
name|sy_next
operator|=
name|target
operator|->
name|sy_next
expr_stmt|;
name|target
operator|->
name|sy_next
operator|=
name|addme
expr_stmt|;
ifdef|#
directive|ifdef
name|SYMBOLS_NEED_BACKPOINTERS
name|addme
operator|->
name|sy_previous
operator|=
name|target
expr_stmt|;
endif|#
directive|endif
comment|/* SYMBOLS_NEED_BACKPOINTERS */
name|debug_verify_symchain
argument_list|(
name|symbol_rootP
argument_list|,
name|symbol_lastP
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set the chain pointers of SYMBOL to null.  */
end_comment

begin_function
name|void
name|symbol_clear_list_pointers
parameter_list|(
name|symbolP
parameter_list|)
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
block|{
if|if
condition|(
name|LOCAL_SYMBOL_CHECK
argument_list|(
name|symbolP
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
name|symbolP
operator|->
name|sy_next
operator|=
name|NULL
expr_stmt|;
ifdef|#
directive|ifdef
name|SYMBOLS_NEED_BACKPOINTERS
name|symbolP
operator|->
name|sy_previous
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|SYMBOLS_NEED_BACKPOINTERS
end_ifdef

begin_comment
comment|/* Remove SYMBOLP from the list.  */
end_comment

begin_function
name|void
name|symbol_remove
parameter_list|(
name|symbolP
parameter_list|,
name|rootPP
parameter_list|,
name|lastPP
parameter_list|)
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
name|symbolS
modifier|*
modifier|*
name|rootPP
decl_stmt|;
name|symbolS
modifier|*
modifier|*
name|lastPP
decl_stmt|;
block|{
if|if
condition|(
name|LOCAL_SYMBOL_CHECK
argument_list|(
name|symbolP
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|symbolP
operator|==
operator|*
name|rootPP
condition|)
block|{
operator|*
name|rootPP
operator|=
name|symbolP
operator|->
name|sy_next
expr_stmt|;
block|}
comment|/* if it was the root  */
if|if
condition|(
name|symbolP
operator|==
operator|*
name|lastPP
condition|)
block|{
operator|*
name|lastPP
operator|=
name|symbolP
operator|->
name|sy_previous
expr_stmt|;
block|}
comment|/* if it was the tail  */
if|if
condition|(
name|symbolP
operator|->
name|sy_next
operator|!=
name|NULL
condition|)
block|{
name|symbolP
operator|->
name|sy_next
operator|->
name|sy_previous
operator|=
name|symbolP
operator|->
name|sy_previous
expr_stmt|;
block|}
comment|/* if not last  */
if|if
condition|(
name|symbolP
operator|->
name|sy_previous
operator|!=
name|NULL
condition|)
block|{
name|symbolP
operator|->
name|sy_previous
operator|->
name|sy_next
operator|=
name|symbolP
operator|->
name|sy_next
expr_stmt|;
block|}
comment|/* if not first  */
name|debug_verify_symchain
argument_list|(
operator|*
name|rootPP
argument_list|,
operator|*
name|lastPP
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Link symbol ADDME before symbol TARGET in the chain.  */
end_comment

begin_function
name|void
name|symbol_insert
parameter_list|(
name|addme
parameter_list|,
name|target
parameter_list|,
name|rootPP
parameter_list|,
name|lastPP
parameter_list|)
name|symbolS
modifier|*
name|addme
decl_stmt|;
name|symbolS
modifier|*
name|target
decl_stmt|;
name|symbolS
modifier|*
modifier|*
name|rootPP
decl_stmt|;
name|symbolS
modifier|*
modifier|*
name|lastPP
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
if|if
condition|(
name|LOCAL_SYMBOL_CHECK
argument_list|(
name|addme
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|LOCAL_SYMBOL_CHECK
argument_list|(
name|target
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|target
operator|->
name|sy_previous
operator|!=
name|NULL
condition|)
block|{
name|target
operator|->
name|sy_previous
operator|->
name|sy_next
operator|=
name|addme
expr_stmt|;
block|}
else|else
block|{
name|know
argument_list|(
operator|*
name|rootPP
operator|==
name|target
argument_list|)
expr_stmt|;
operator|*
name|rootPP
operator|=
name|addme
expr_stmt|;
block|}
comment|/* if not first  */
name|addme
operator|->
name|sy_previous
operator|=
name|target
operator|->
name|sy_previous
expr_stmt|;
name|target
operator|->
name|sy_previous
operator|=
name|addme
expr_stmt|;
name|addme
operator|->
name|sy_next
operator|=
name|target
expr_stmt|;
name|debug_verify_symchain
argument_list|(
operator|*
name|rootPP
argument_list|,
operator|*
name|lastPP
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SYMBOLS_NEED_BACKPOINTERS */
end_comment

begin_function
name|void
name|verify_symbol_chain
parameter_list|(
name|rootP
parameter_list|,
name|lastP
parameter_list|)
name|symbolS
modifier|*
name|rootP
decl_stmt|;
name|symbolS
modifier|*
name|lastP
decl_stmt|;
block|{
name|symbolS
modifier|*
name|symbolP
init|=
name|rootP
decl_stmt|;
if|if
condition|(
name|symbolP
operator|==
name|NULL
condition|)
return|return;
for|for
control|(
init|;
name|symbol_next
argument_list|(
name|symbolP
argument_list|)
operator|!=
name|NULL
condition|;
name|symbolP
operator|=
name|symbol_next
argument_list|(
name|symbolP
argument_list|)
control|)
block|{
ifdef|#
directive|ifdef
name|BFD_ASSEMBLER
name|assert
argument_list|(
name|symbolP
operator|->
name|bsym
operator|!=
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SYMBOLS_NEED_BACKPOINTERS
name|assert
argument_list|(
name|symbolP
operator|->
name|sy_next
operator|->
name|sy_previous
operator|==
name|symbolP
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* Walk the list anyways, to make sure pointers are still good.  */
empty_stmt|;
endif|#
directive|endif
comment|/* SYMBOLS_NEED_BACKPOINTERS */
block|}
name|assert
argument_list|(
name|lastP
operator|==
name|symbolP
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|verify_symbol_chain_2
parameter_list|(
name|sym
parameter_list|)
name|symbolS
modifier|*
name|sym
decl_stmt|;
block|{
name|symbolS
modifier|*
name|p
init|=
name|sym
decl_stmt|,
modifier|*
name|n
init|=
name|sym
decl_stmt|;
ifdef|#
directive|ifdef
name|SYMBOLS_NEED_BACKPOINTERS
while|while
condition|(
name|symbol_previous
argument_list|(
name|p
argument_list|)
condition|)
name|p
operator|=
name|symbol_previous
argument_list|(
name|p
argument_list|)
expr_stmt|;
endif|#
directive|endif
while|while
condition|(
name|symbol_next
argument_list|(
name|n
argument_list|)
condition|)
name|n
operator|=
name|symbol_next
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|verify_symbol_chain
argument_list|(
name|p
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Resolve the value of a symbol.  This is called during the final    pass over the symbol table to resolve any symbols with complex    values.  */
end_comment

begin_function
name|valueT
name|resolve_symbol_value
parameter_list|(
name|symp
parameter_list|)
name|symbolS
modifier|*
name|symp
decl_stmt|;
block|{
name|int
name|resolved
decl_stmt|;
name|valueT
name|final_val
decl_stmt|;
name|segT
name|final_seg
decl_stmt|;
ifdef|#
directive|ifdef
name|BFD_ASSEMBLER
if|if
condition|(
name|LOCAL_SYMBOL_CHECK
argument_list|(
name|symp
argument_list|)
condition|)
block|{
name|struct
name|local_symbol
modifier|*
name|locsym
init|=
operator|(
expr|struct
name|local_symbol
operator|*
operator|)
name|symp
decl_stmt|;
name|final_val
operator|=
name|locsym
operator|->
name|lsy_value
expr_stmt|;
if|if
condition|(
name|local_symbol_resolved_p
argument_list|(
name|locsym
argument_list|)
condition|)
return|return
name|final_val
return|;
name|final_val
operator|+=
name|local_symbol_get_frag
argument_list|(
name|locsym
argument_list|)
operator|->
name|fr_address
operator|/
name|OCTETS_PER_BYTE
expr_stmt|;
if|if
condition|(
name|finalize_syms
condition|)
block|{
name|locsym
operator|->
name|lsy_value
operator|=
name|final_val
expr_stmt|;
name|local_symbol_mark_resolved
argument_list|(
name|locsym
argument_list|)
expr_stmt|;
block|}
return|return
name|final_val
return|;
block|}
endif|#
directive|endif
if|if
condition|(
name|symp
operator|->
name|sy_resolved
condition|)
block|{
if|if
condition|(
name|symp
operator|->
name|sy_value
operator|.
name|X_op
operator|==
name|O_constant
condition|)
return|return
operator|(
name|valueT
operator|)
name|symp
operator|->
name|sy_value
operator|.
name|X_add_number
return|;
else|else
return|return
literal|0
return|;
block|}
name|resolved
operator|=
literal|0
expr_stmt|;
name|final_seg
operator|=
name|S_GET_SEGMENT
argument_list|(
name|symp
argument_list|)
expr_stmt|;
if|if
condition|(
name|symp
operator|->
name|sy_resolving
condition|)
block|{
if|if
condition|(
name|finalize_syms
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"symbol definition loop encountered at `%s'"
argument_list|)
argument_list|,
name|S_GET_NAME
argument_list|(
name|symp
argument_list|)
argument_list|)
expr_stmt|;
name|final_val
operator|=
literal|0
expr_stmt|;
name|resolved
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|symbolS
modifier|*
name|add_symbol
decl_stmt|,
modifier|*
name|op_symbol
decl_stmt|;
name|offsetT
name|left
decl_stmt|,
name|right
decl_stmt|;
name|segT
name|seg_left
decl_stmt|,
name|seg_right
decl_stmt|;
name|operatorT
name|op
decl_stmt|;
name|symp
operator|->
name|sy_resolving
operator|=
literal|1
expr_stmt|;
comment|/* Help out with CSE.  */
name|add_symbol
operator|=
name|symp
operator|->
name|sy_value
operator|.
name|X_add_symbol
expr_stmt|;
name|op_symbol
operator|=
name|symp
operator|->
name|sy_value
operator|.
name|X_op_symbol
expr_stmt|;
name|final_val
operator|=
name|symp
operator|->
name|sy_value
operator|.
name|X_add_number
expr_stmt|;
name|op
operator|=
name|symp
operator|->
name|sy_value
operator|.
name|X_op
expr_stmt|;
switch|switch
condition|(
name|op
condition|)
block|{
default|default:
name|BAD_CASE
argument_list|(
name|op
argument_list|)
expr_stmt|;
break|break;
case|case
name|O_absent
case|:
name|final_val
operator|=
literal|0
expr_stmt|;
comment|/* Fall through.  */
case|case
name|O_constant
case|:
name|final_val
operator|+=
name|symp
operator|->
name|sy_frag
operator|->
name|fr_address
operator|/
name|OCTETS_PER_BYTE
expr_stmt|;
if|if
condition|(
name|final_seg
operator|==
name|expr_section
condition|)
name|final_seg
operator|=
name|absolute_section
expr_stmt|;
name|resolved
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|O_symbol
case|:
case|case
name|O_symbol_rva
case|:
name|left
operator|=
name|resolve_symbol_value
argument_list|(
name|add_symbol
argument_list|)
expr_stmt|;
name|seg_left
operator|=
name|S_GET_SEGMENT
argument_list|(
name|add_symbol
argument_list|)
expr_stmt|;
if|if
condition|(
name|finalize_syms
condition|)
name|symp
operator|->
name|sy_value
operator|.
name|X_op_symbol
operator|=
name|NULL
expr_stmt|;
name|do_symbol
label|:
if|if
condition|(
name|symp
operator|->
name|sy_mri_common
condition|)
block|{
comment|/* This is a symbol inside an MRI common section.  The 		 relocation routines are going to handle it specially. 		 Don't change the value.  */
name|resolved
operator|=
name|symbol_resolved_p
argument_list|(
name|add_symbol
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|finalize_syms
operator|&&
name|final_val
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|LOCAL_SYMBOL_CHECK
argument_list|(
name|add_symbol
argument_list|)
condition|)
name|add_symbol
operator|=
name|local_symbol_convert
argument_list|(
operator|(
expr|struct
name|local_symbol
operator|*
operator|)
name|add_symbol
argument_list|)
expr_stmt|;
name|copy_symbol_attributes
argument_list|(
name|symp
argument_list|,
name|add_symbol
argument_list|)
expr_stmt|;
block|}
comment|/* If we have equated this symbol to an undefined or common 	     symbol, keep X_op set to O_symbol, and don't change 	     X_add_number.  This permits the routine which writes out 	     relocation to detect this case, and convert the 	     relocation to be against the symbol to which this symbol 	     is equated.  */
if|if
condition|(
operator|!
name|S_IS_DEFINED
argument_list|(
name|add_symbol
argument_list|)
operator|||
name|S_IS_COMMON
argument_list|(
name|add_symbol
argument_list|)
condition|)
block|{
if|if
condition|(
name|finalize_syms
condition|)
block|{
name|symp
operator|->
name|sy_value
operator|.
name|X_op
operator|=
name|O_symbol
expr_stmt|;
name|symp
operator|->
name|sy_value
operator|.
name|X_add_symbol
operator|=
name|add_symbol
expr_stmt|;
name|symp
operator|->
name|sy_value
operator|.
name|X_add_number
operator|=
name|final_val
expr_stmt|;
comment|/* Use X_op_symbol as a flag.  */
name|symp
operator|->
name|sy_value
operator|.
name|X_op_symbol
operator|=
name|add_symbol
expr_stmt|;
name|final_seg
operator|=
name|seg_left
expr_stmt|;
block|}
name|final_val
operator|=
literal|0
expr_stmt|;
name|resolved
operator|=
name|symbol_resolved_p
argument_list|(
name|add_symbol
argument_list|)
expr_stmt|;
name|symp
operator|->
name|sy_resolving
operator|=
literal|0
expr_stmt|;
goto|goto
name|exit_dont_set_value
goto|;
block|}
elseif|else
if|if
condition|(
name|finalize_syms
operator|&&
name|final_seg
operator|==
name|expr_section
operator|&&
name|seg_left
operator|!=
name|expr_section
condition|)
block|{
comment|/* If the symbol is an expression symbol, do similarly 		 as for undefined and common syms above.  Handles 		 "sym +/- expr" where "expr" cannot be evaluated 		 immediately, and we want relocations to be against 		 "sym", eg. because it is weak.  */
name|symp
operator|->
name|sy_value
operator|.
name|X_op
operator|=
name|O_symbol
expr_stmt|;
name|symp
operator|->
name|sy_value
operator|.
name|X_add_symbol
operator|=
name|add_symbol
expr_stmt|;
name|symp
operator|->
name|sy_value
operator|.
name|X_add_number
operator|=
name|final_val
expr_stmt|;
name|symp
operator|->
name|sy_value
operator|.
name|X_op_symbol
operator|=
name|add_symbol
expr_stmt|;
name|final_seg
operator|=
name|seg_left
expr_stmt|;
name|final_val
operator|+=
name|symp
operator|->
name|sy_frag
operator|->
name|fr_address
operator|+
name|left
expr_stmt|;
name|resolved
operator|=
name|symbol_resolved_p
argument_list|(
name|add_symbol
argument_list|)
expr_stmt|;
name|symp
operator|->
name|sy_resolving
operator|=
literal|0
expr_stmt|;
goto|goto
name|exit_dont_set_value
goto|;
block|}
else|else
block|{
name|final_val
operator|+=
name|symp
operator|->
name|sy_frag
operator|->
name|fr_address
operator|+
name|left
expr_stmt|;
if|if
condition|(
name|final_seg
operator|==
name|expr_section
operator|||
name|final_seg
operator|==
name|undefined_section
condition|)
name|final_seg
operator|=
name|seg_left
expr_stmt|;
block|}
name|resolved
operator|=
name|symbol_resolved_p
argument_list|(
name|add_symbol
argument_list|)
expr_stmt|;
break|break;
case|case
name|O_uminus
case|:
case|case
name|O_bit_not
case|:
case|case
name|O_logical_not
case|:
name|left
operator|=
name|resolve_symbol_value
argument_list|(
name|add_symbol
argument_list|)
expr_stmt|;
name|seg_left
operator|=
name|S_GET_SEGMENT
argument_list|(
name|add_symbol
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|==
name|O_uminus
condition|)
name|left
operator|=
operator|-
name|left
expr_stmt|;
elseif|else
if|if
condition|(
name|op
operator|==
name|O_logical_not
condition|)
name|left
operator|=
operator|!
name|left
expr_stmt|;
else|else
name|left
operator|=
operator|~
name|left
expr_stmt|;
name|final_val
operator|+=
name|left
operator|+
name|symp
operator|->
name|sy_frag
operator|->
name|fr_address
expr_stmt|;
if|if
condition|(
name|final_seg
operator|==
name|expr_section
operator|||
name|final_seg
operator|==
name|undefined_section
condition|)
name|final_seg
operator|=
name|seg_left
expr_stmt|;
name|resolved
operator|=
name|symbol_resolved_p
argument_list|(
name|add_symbol
argument_list|)
expr_stmt|;
break|break;
case|case
name|O_multiply
case|:
case|case
name|O_divide
case|:
case|case
name|O_modulus
case|:
case|case
name|O_left_shift
case|:
case|case
name|O_right_shift
case|:
case|case
name|O_bit_inclusive_or
case|:
case|case
name|O_bit_or_not
case|:
case|case
name|O_bit_exclusive_or
case|:
case|case
name|O_bit_and
case|:
case|case
name|O_add
case|:
case|case
name|O_subtract
case|:
case|case
name|O_eq
case|:
case|case
name|O_ne
case|:
case|case
name|O_lt
case|:
case|case
name|O_le
case|:
case|case
name|O_ge
case|:
case|case
name|O_gt
case|:
case|case
name|O_logical_and
case|:
case|case
name|O_logical_or
case|:
name|left
operator|=
name|resolve_symbol_value
argument_list|(
name|add_symbol
argument_list|)
expr_stmt|;
name|right
operator|=
name|resolve_symbol_value
argument_list|(
name|op_symbol
argument_list|)
expr_stmt|;
name|seg_left
operator|=
name|S_GET_SEGMENT
argument_list|(
name|add_symbol
argument_list|)
expr_stmt|;
name|seg_right
operator|=
name|S_GET_SEGMENT
argument_list|(
name|op_symbol
argument_list|)
expr_stmt|;
comment|/* Simplify addition or subtraction of a constant by folding the 	     constant into X_add_number.  */
if|if
condition|(
name|op
operator|==
name|O_add
condition|)
block|{
if|if
condition|(
name|seg_right
operator|==
name|absolute_section
condition|)
block|{
name|final_val
operator|+=
name|right
expr_stmt|;
goto|goto
name|do_symbol
goto|;
block|}
elseif|else
if|if
condition|(
name|seg_left
operator|==
name|absolute_section
condition|)
block|{
name|final_val
operator|+=
name|left
expr_stmt|;
name|add_symbol
operator|=
name|op_symbol
expr_stmt|;
name|left
operator|=
name|right
expr_stmt|;
name|seg_left
operator|=
name|seg_right
expr_stmt|;
goto|goto
name|do_symbol
goto|;
block|}
block|}
elseif|else
if|if
condition|(
name|op
operator|==
name|O_subtract
condition|)
block|{
if|if
condition|(
name|seg_right
operator|==
name|absolute_section
condition|)
block|{
name|final_val
operator|-=
name|right
expr_stmt|;
goto|goto
name|do_symbol
goto|;
block|}
block|}
comment|/* Equality and non-equality tests are permitted on anything. 	     Subtraction, and other comparison operators are permitted if 	     both operands are in the same section.  Otherwise, both 	     operands must be absolute.  We already handled the case of 	     addition or subtraction of a constant above.  This will 	     probably need to be changed for an object file format which 	     supports arbitrary expressions, such as IEEE-695.  	     Don't emit messages unless we're finalizing the symbol value, 	     otherwise we may get the same message multiple times.  */
if|if
condition|(
operator|(
name|op
operator|==
name|O_eq
operator|||
name|op
operator|==
name|O_ne
operator|)
operator|||
operator|(
operator|(
name|op
operator|==
name|O_subtract
operator|||
name|op
operator|==
name|O_lt
operator|||
name|op
operator|==
name|O_le
operator|||
name|op
operator|==
name|O_ge
operator|||
name|op
operator|==
name|O_gt
operator|)
operator|&&
name|seg_left
operator|==
name|seg_right
operator|&&
operator|(
name|seg_left
operator|!=
name|undefined_section
operator|||
name|add_symbol
operator|==
name|op_symbol
operator|)
operator|)
operator|||
operator|(
name|seg_left
operator|==
name|absolute_section
operator|&&
name|seg_right
operator|==
name|absolute_section
operator|)
condition|)
block|{
if|if
condition|(
name|final_seg
operator|==
name|expr_section
operator|||
name|final_seg
operator|==
name|undefined_section
condition|)
name|final_seg
operator|=
name|absolute_section
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|finalize_syms
condition|)
block|{
name|char
modifier|*
name|file
decl_stmt|;
name|unsigned
name|int
name|line
decl_stmt|;
if|if
condition|(
name|expr_symbol_where
argument_list|(
name|symp
argument_list|,
operator|&
name|file
argument_list|,
operator|&
name|line
argument_list|)
condition|)
block|{
if|if
condition|(
name|seg_left
operator|==
name|undefined_section
condition|)
name|as_bad_where
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
name|_
argument_list|(
literal|"undefined symbol `%s' in operation"
argument_list|)
argument_list|,
name|S_GET_NAME
argument_list|(
name|symp
operator|->
name|sy_value
operator|.
name|X_add_symbol
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|seg_right
operator|==
name|undefined_section
condition|)
name|as_bad_where
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
name|_
argument_list|(
literal|"undefined symbol `%s' in operation"
argument_list|)
argument_list|,
name|S_GET_NAME
argument_list|(
name|symp
operator|->
name|sy_value
operator|.
name|X_op_symbol
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|seg_left
operator|!=
name|undefined_section
operator|&&
name|seg_right
operator|!=
name|undefined_section
condition|)
name|as_bad_where
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
name|_
argument_list|(
literal|"invalid section for operation"
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|seg_left
operator|==
name|undefined_section
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"undefined symbol `%s' in operation setting `%s'"
argument_list|)
argument_list|,
name|S_GET_NAME
argument_list|(
name|symp
operator|->
name|sy_value
operator|.
name|X_add_symbol
argument_list|)
argument_list|,
name|S_GET_NAME
argument_list|(
name|symp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|seg_right
operator|==
name|undefined_section
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"undefined symbol `%s' in operation setting `%s'"
argument_list|)
argument_list|,
name|S_GET_NAME
argument_list|(
name|symp
operator|->
name|sy_value
operator|.
name|X_op_symbol
argument_list|)
argument_list|,
name|S_GET_NAME
argument_list|(
name|symp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|seg_left
operator|!=
name|undefined_section
operator|&&
name|seg_right
operator|!=
name|undefined_section
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"invalid section for operation setting `%s'"
argument_list|)
argument_list|,
name|S_GET_NAME
argument_list|(
name|symp
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Prevent the error propagating.  */
if|if
condition|(
name|final_seg
operator|==
name|expr_section
operator|||
name|final_seg
operator|==
name|undefined_section
condition|)
name|final_seg
operator|=
name|absolute_section
expr_stmt|;
block|}
comment|/* Check for division by zero.  */
if|if
condition|(
operator|(
name|op
operator|==
name|O_divide
operator|||
name|op
operator|==
name|O_modulus
operator|)
operator|&&
name|right
operator|==
literal|0
condition|)
block|{
comment|/* If seg_right is not absolute_section, then we've 		 already issued a warning about using a bad symbol.  */
if|if
condition|(
name|seg_right
operator|==
name|absolute_section
operator|&&
name|finalize_syms
condition|)
block|{
name|char
modifier|*
name|file
decl_stmt|;
name|unsigned
name|int
name|line
decl_stmt|;
if|if
condition|(
name|expr_symbol_where
argument_list|(
name|symp
argument_list|,
operator|&
name|file
argument_list|,
operator|&
name|line
argument_list|)
condition|)
name|as_bad_where
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
name|_
argument_list|(
literal|"division by zero"
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"division by zero when setting `%s'"
argument_list|)
argument_list|,
name|S_GET_NAME
argument_list|(
name|symp
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|right
operator|=
literal|1
expr_stmt|;
block|}
switch|switch
condition|(
name|symp
operator|->
name|sy_value
operator|.
name|X_op
condition|)
block|{
case|case
name|O_multiply
case|:
name|left
operator|*=
name|right
expr_stmt|;
break|break;
case|case
name|O_divide
case|:
name|left
operator|/=
name|right
expr_stmt|;
break|break;
case|case
name|O_modulus
case|:
name|left
operator|%=
name|right
expr_stmt|;
break|break;
case|case
name|O_left_shift
case|:
name|left
operator|<<=
name|right
expr_stmt|;
break|break;
case|case
name|O_right_shift
case|:
name|left
operator|>>=
name|right
expr_stmt|;
break|break;
case|case
name|O_bit_inclusive_or
case|:
name|left
operator||=
name|right
expr_stmt|;
break|break;
case|case
name|O_bit_or_not
case|:
name|left
operator||=
operator|~
name|right
expr_stmt|;
break|break;
case|case
name|O_bit_exclusive_or
case|:
name|left
operator|^=
name|right
expr_stmt|;
break|break;
case|case
name|O_bit_and
case|:
name|left
operator|&=
name|right
expr_stmt|;
break|break;
case|case
name|O_add
case|:
name|left
operator|+=
name|right
expr_stmt|;
break|break;
case|case
name|O_subtract
case|:
name|left
operator|-=
name|right
expr_stmt|;
break|break;
case|case
name|O_eq
case|:
case|case
name|O_ne
case|:
name|left
operator|=
operator|(
name|left
operator|==
name|right
operator|&&
name|seg_left
operator|==
name|seg_right
operator|&&
operator|(
name|seg_left
operator|!=
name|undefined_section
operator|||
name|add_symbol
operator|==
name|op_symbol
operator|)
condition|?
operator|~
operator|(
name|offsetT
operator|)
literal|0
else|:
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|symp
operator|->
name|sy_value
operator|.
name|X_op
operator|==
name|O_ne
condition|)
name|left
operator|=
operator|~
name|left
expr_stmt|;
break|break;
case|case
name|O_lt
case|:
name|left
operator|=
name|left
operator|<
name|right
condition|?
operator|~
operator|(
name|offsetT
operator|)
literal|0
else|:
literal|0
expr_stmt|;
break|break;
case|case
name|O_le
case|:
name|left
operator|=
name|left
operator|<=
name|right
condition|?
operator|~
operator|(
name|offsetT
operator|)
literal|0
else|:
literal|0
expr_stmt|;
break|break;
case|case
name|O_ge
case|:
name|left
operator|=
name|left
operator|>=
name|right
condition|?
operator|~
operator|(
name|offsetT
operator|)
literal|0
else|:
literal|0
expr_stmt|;
break|break;
case|case
name|O_gt
case|:
name|left
operator|=
name|left
operator|>
name|right
condition|?
operator|~
operator|(
name|offsetT
operator|)
literal|0
else|:
literal|0
expr_stmt|;
break|break;
case|case
name|O_logical_and
case|:
name|left
operator|=
name|left
operator|&&
name|right
expr_stmt|;
break|break;
case|case
name|O_logical_or
case|:
name|left
operator|=
name|left
operator|||
name|right
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|final_val
operator|+=
name|symp
operator|->
name|sy_frag
operator|->
name|fr_address
operator|+
name|left
expr_stmt|;
if|if
condition|(
name|final_seg
operator|==
name|expr_section
operator|||
name|final_seg
operator|==
name|undefined_section
condition|)
block|{
if|if
condition|(
name|seg_left
operator|==
name|undefined_section
operator|||
name|seg_right
operator|==
name|undefined_section
condition|)
name|final_seg
operator|=
name|undefined_section
expr_stmt|;
elseif|else
if|if
condition|(
name|seg_left
operator|==
name|absolute_section
condition|)
name|final_seg
operator|=
name|seg_right
expr_stmt|;
else|else
name|final_seg
operator|=
name|seg_left
expr_stmt|;
block|}
name|resolved
operator|=
operator|(
name|symbol_resolved_p
argument_list|(
name|add_symbol
argument_list|)
operator|&&
name|symbol_resolved_p
argument_list|(
name|op_symbol
argument_list|)
operator|)
expr_stmt|;
break|break;
case|case
name|O_register
case|:
case|case
name|O_big
case|:
case|case
name|O_illegal
case|:
comment|/* Give an error (below) if not in expr_section.  We don't 	     want to worry about expr_section symbols, because they 	     are fictional (they are created as part of expression 	     resolution), and any problems may not actually mean 	     anything.  */
break|break;
block|}
name|symp
operator|->
name|sy_resolving
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|finalize_syms
condition|)
name|S_SET_VALUE
argument_list|(
name|symp
argument_list|,
name|final_val
argument_list|)
expr_stmt|;
name|exit_dont_set_value
label|:
comment|/* Always set the segment, even if not finalizing the value.      The segment is used to determine whether a symbol is defined.  */
if|#
directive|if
name|defined
argument_list|(
name|OBJ_AOUT
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|BFD_ASSEMBLER
argument_list|)
comment|/* The old a.out backend does not handle S_SET_SEGMENT correctly      for a stab symbol, so we use this bad hack.  */
if|if
condition|(
name|final_seg
operator|!=
name|S_GET_SEGMENT
argument_list|(
name|symp
argument_list|)
condition|)
endif|#
directive|endif
name|S_SET_SEGMENT
argument_list|(
name|symp
argument_list|,
name|final_seg
argument_list|)
expr_stmt|;
comment|/* Don't worry if we can't resolve an expr_section symbol.  */
if|if
condition|(
name|finalize_syms
condition|)
block|{
if|if
condition|(
name|resolved
condition|)
name|symp
operator|->
name|sy_resolved
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|S_GET_SEGMENT
argument_list|(
name|symp
argument_list|)
operator|!=
name|expr_section
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"can't resolve value for symbol `%s'"
argument_list|)
argument_list|,
name|S_GET_NAME
argument_list|(
name|symp
argument_list|)
argument_list|)
expr_stmt|;
name|symp
operator|->
name|sy_resolved
operator|=
literal|1
expr_stmt|;
block|}
block|}
return|return
name|final_val
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|BFD_ASSEMBLER
end_ifdef

begin_decl_stmt
specifier|static
name|void
name|resolve_local_symbol
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A static function passed to hash_traverse.  */
end_comment

begin_function
specifier|static
name|void
name|resolve_local_symbol
parameter_list|(
name|key
parameter_list|,
name|value
parameter_list|)
specifier|const
name|char
modifier|*
name|key
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|PTR
name|value
decl_stmt|;
block|{
if|if
condition|(
name|value
operator|!=
name|NULL
condition|)
name|resolve_symbol_value
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Resolve all local symbols.  */
end_comment

begin_function
name|void
name|resolve_local_symbol_values
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|BFD_ASSEMBLER
name|hash_traverse
argument_list|(
name|local_hash
argument_list|,
name|resolve_local_symbol
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Dollar labels look like a number followed by a dollar sign.  Eg, "42$".    They are *really* local.  That is, they go out of scope whenever we see a    label that isn't local.  Also, like fb labels, there can be multiple    instances of a dollar label.  Therefor, we name encode each instance with    the instance number, keep a list of defined symbols separate from the real    symbol table, and we treat these buggers as a sparse array.  */
end_comment

begin_decl_stmt
specifier|static
name|long
modifier|*
name|dollar_labels
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
modifier|*
name|dollar_label_instances
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|dollar_label_defines
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|long
name|dollar_label_count
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|long
name|dollar_label_max
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|dollar_label_defined
parameter_list|(
name|label
parameter_list|)
name|long
name|label
decl_stmt|;
block|{
name|long
modifier|*
name|i
decl_stmt|;
name|know
argument_list|(
operator|(
name|dollar_labels
operator|!=
name|NULL
operator|)
operator|||
operator|(
name|dollar_label_count
operator|==
literal|0
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|dollar_labels
init|;
name|i
operator|<
name|dollar_labels
operator|+
name|dollar_label_count
condition|;
operator|++
name|i
control|)
if|if
condition|(
operator|*
name|i
operator|==
name|label
condition|)
return|return
name|dollar_label_defines
index|[
name|i
operator|-
name|dollar_labels
index|]
return|;
comment|/* If we get here, label isn't defined.  */
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|long
name|dollar_label_instance
parameter_list|(
name|label
parameter_list|)
name|long
name|label
decl_stmt|;
block|{
name|long
modifier|*
name|i
decl_stmt|;
name|know
argument_list|(
operator|(
name|dollar_labels
operator|!=
name|NULL
operator|)
operator|||
operator|(
name|dollar_label_count
operator|==
literal|0
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|dollar_labels
init|;
name|i
operator|<
name|dollar_labels
operator|+
name|dollar_label_count
condition|;
operator|++
name|i
control|)
if|if
condition|(
operator|*
name|i
operator|==
name|label
condition|)
return|return
operator|(
name|dollar_label_instances
index|[
name|i
operator|-
name|dollar_labels
index|]
operator|)
return|;
comment|/* If we get here, we haven't seen the label before.      Therefore its instance count is zero.  */
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|dollar_label_clear
parameter_list|()
block|{
name|memset
argument_list|(
name|dollar_label_defines
argument_list|,
literal|'\0'
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|dollar_label_count
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|DOLLAR_LABEL_BUMP_BY
value|10
end_define

begin_function
name|void
name|define_dollar_label
parameter_list|(
name|label
parameter_list|)
name|long
name|label
decl_stmt|;
block|{
name|long
modifier|*
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|dollar_labels
init|;
name|i
operator|<
name|dollar_labels
operator|+
name|dollar_label_count
condition|;
operator|++
name|i
control|)
if|if
condition|(
operator|*
name|i
operator|==
name|label
condition|)
block|{
operator|++
name|dollar_label_instances
index|[
name|i
operator|-
name|dollar_labels
index|]
expr_stmt|;
name|dollar_label_defines
index|[
name|i
operator|-
name|dollar_labels
index|]
operator|=
literal|1
expr_stmt|;
return|return;
block|}
comment|/* If we get to here, we don't have label listed yet.  */
if|if
condition|(
name|dollar_labels
operator|==
name|NULL
condition|)
block|{
name|dollar_labels
operator|=
operator|(
name|long
operator|*
operator|)
name|xmalloc
argument_list|(
name|DOLLAR_LABEL_BUMP_BY
operator|*
sizeof|sizeof
argument_list|(
name|long
argument_list|)
argument_list|)
expr_stmt|;
name|dollar_label_instances
operator|=
operator|(
name|long
operator|*
operator|)
name|xmalloc
argument_list|(
name|DOLLAR_LABEL_BUMP_BY
operator|*
sizeof|sizeof
argument_list|(
name|long
argument_list|)
argument_list|)
expr_stmt|;
name|dollar_label_defines
operator|=
name|xmalloc
argument_list|(
name|DOLLAR_LABEL_BUMP_BY
argument_list|)
expr_stmt|;
name|dollar_label_max
operator|=
name|DOLLAR_LABEL_BUMP_BY
expr_stmt|;
name|dollar_label_count
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dollar_label_count
operator|==
name|dollar_label_max
condition|)
block|{
name|dollar_label_max
operator|+=
name|DOLLAR_LABEL_BUMP_BY
expr_stmt|;
name|dollar_labels
operator|=
operator|(
name|long
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|dollar_labels
argument_list|,
name|dollar_label_max
operator|*
sizeof|sizeof
argument_list|(
name|long
argument_list|)
argument_list|)
expr_stmt|;
name|dollar_label_instances
operator|=
operator|(
name|long
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|dollar_label_instances
argument_list|,
name|dollar_label_max
operator|*
sizeof|sizeof
argument_list|(
name|long
argument_list|)
argument_list|)
expr_stmt|;
name|dollar_label_defines
operator|=
name|xrealloc
argument_list|(
name|dollar_label_defines
argument_list|,
name|dollar_label_max
argument_list|)
expr_stmt|;
block|}
comment|/* if we needed to grow  */
name|dollar_labels
index|[
name|dollar_label_count
index|]
operator|=
name|label
expr_stmt|;
name|dollar_label_instances
index|[
name|dollar_label_count
index|]
operator|=
literal|1
expr_stmt|;
name|dollar_label_defines
index|[
name|dollar_label_count
index|]
operator|=
literal|1
expr_stmt|;
operator|++
name|dollar_label_count
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Caller must copy returned name: we re-use the area for the next name.     The mth occurence of label n: is turned into the symbol "Ln^Am"    where n is the label number and m is the instance number. "L" makes    it a label discarded unless debugging and "^A"('\1') ensures no    ordinary symbol SHOULD get the same name as a local label    symbol. The first "4:" is "L4^A1" - the m numbers begin at 1.     fb labels get the same treatment, except that ^B is used in place    of ^A.  */
end_comment

begin_function
name|char
modifier|*
comment|/* Return local label name.  */
name|dollar_label_name
parameter_list|(
name|n
parameter_list|,
name|augend
parameter_list|)
specifier|register
name|long
name|n
decl_stmt|;
comment|/* we just saw "n$:" : n a number.  */
specifier|register
name|int
name|augend
decl_stmt|;
comment|/* 0 for current instance, 1 for new instance.  */
block|{
name|long
name|i
decl_stmt|;
comment|/* Returned to caller, then copied.  Used for created names ("4f").  */
specifier|static
name|char
name|symbol_name_build
index|[
literal|24
index|]
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|char
modifier|*
name|q
decl_stmt|;
name|char
name|symbol_name_temporary
index|[
literal|20
index|]
decl_stmt|;
comment|/* Build up a number, BACKWARDS.  */
name|know
argument_list|(
name|n
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|know
argument_list|(
name|augend
operator|==
literal|0
operator|||
name|augend
operator|==
literal|1
argument_list|)
expr_stmt|;
name|p
operator|=
name|symbol_name_build
expr_stmt|;
ifdef|#
directive|ifdef
name|LOCAL_LABEL_PREFIX
operator|*
name|p
operator|++
operator|=
name|LOCAL_LABEL_PREFIX
expr_stmt|;
endif|#
directive|endif
operator|*
name|p
operator|++
operator|=
literal|'L'
expr_stmt|;
comment|/* Next code just does sprintf( {}, "%d", n);  */
comment|/* Label number.  */
name|q
operator|=
name|symbol_name_temporary
expr_stmt|;
for|for
control|(
operator|*
name|q
operator|++
operator|=
literal|0
operator|,
name|i
operator|=
name|n
init|;
name|i
condition|;
operator|++
name|q
control|)
block|{
operator|*
name|q
operator|=
name|i
operator|%
literal|10
operator|+
literal|'0'
expr_stmt|;
name|i
operator|/=
literal|10
expr_stmt|;
block|}
while|while
condition|(
operator|(
operator|*
name|p
operator|=
operator|*
operator|--
name|q
operator|)
operator|!=
literal|'\0'
condition|)
operator|++
name|p
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|DOLLAR_LABEL_CHAR
expr_stmt|;
comment|/* ^A  */
comment|/* Instance number.  */
name|q
operator|=
name|symbol_name_temporary
expr_stmt|;
for|for
control|(
operator|*
name|q
operator|++
operator|=
literal|0
operator|,
name|i
operator|=
name|dollar_label_instance
argument_list|(
name|n
argument_list|)
operator|+
name|augend
init|;
name|i
condition|;
operator|++
name|q
control|)
block|{
operator|*
name|q
operator|=
name|i
operator|%
literal|10
operator|+
literal|'0'
expr_stmt|;
name|i
operator|/=
literal|10
expr_stmt|;
block|}
while|while
condition|(
operator|(
operator|*
name|p
operator|++
operator|=
operator|*
operator|--
name|q
operator|)
operator|!=
literal|'\0'
condition|)
empty_stmt|;
empty_stmt|;
comment|/* The label, as a '\0' ended string, starts at symbol_name_build.  */
return|return
name|symbol_name_build
return|;
block|}
end_function

begin_comment
comment|/* Sombody else's idea of local labels. They are made by "n:" where n    is any decimal digit. Refer to them with     "nb" for previous (backward) n:    or "nf" for next (forward) n:.     We do a little better and let n be any number, not just a single digit, but    since the other guy's assembler only does ten, we treat the first ten    specially.     Like someone else's assembler, we have one set of local label counters for    entire assembly, not one set per (sub)segment like in most assemblers. This    implies that one can refer to a label in another segment, and indeed some    crufty compilers have done just that.     Since there could be a LOT of these things, treat them as a sparse    array.  */
end_comment

begin_define
define|#
directive|define
name|FB_LABEL_SPECIAL
value|(10)
end_define

begin_decl_stmt
specifier|static
name|long
name|fb_low_counter
index|[
name|FB_LABEL_SPECIAL
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
modifier|*
name|fb_labels
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
modifier|*
name|fb_label_instances
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|fb_label_count
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|fb_label_max
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This must be more than FB_LABEL_SPECIAL.  */
end_comment

begin_define
define|#
directive|define
name|FB_LABEL_BUMP_BY
value|(FB_LABEL_SPECIAL + 6)
end_define

begin_function
specifier|static
name|void
name|fb_label_init
parameter_list|()
block|{
name|memset
argument_list|(
operator|(
name|void
operator|*
operator|)
name|fb_low_counter
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
name|fb_low_counter
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add one to the instance number of this fb label.  */
end_comment

begin_function
name|void
name|fb_label_instance_inc
parameter_list|(
name|label
parameter_list|)
name|long
name|label
decl_stmt|;
block|{
name|long
modifier|*
name|i
decl_stmt|;
if|if
condition|(
name|label
operator|<
name|FB_LABEL_SPECIAL
condition|)
block|{
operator|++
name|fb_low_counter
index|[
name|label
index|]
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|fb_labels
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|i
operator|=
name|fb_labels
operator|+
name|FB_LABEL_SPECIAL
init|;
name|i
operator|<
name|fb_labels
operator|+
name|fb_label_count
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
operator|*
name|i
operator|==
name|label
condition|)
block|{
operator|++
name|fb_label_instances
index|[
name|i
operator|-
name|fb_labels
index|]
expr_stmt|;
return|return;
block|}
comment|/* if we find it  */
block|}
comment|/* for each existing label  */
block|}
comment|/* If we get to here, we don't have label listed yet.  */
if|if
condition|(
name|fb_labels
operator|==
name|NULL
condition|)
block|{
name|fb_labels
operator|=
operator|(
name|long
operator|*
operator|)
name|xmalloc
argument_list|(
name|FB_LABEL_BUMP_BY
operator|*
sizeof|sizeof
argument_list|(
name|long
argument_list|)
argument_list|)
expr_stmt|;
name|fb_label_instances
operator|=
operator|(
name|long
operator|*
operator|)
name|xmalloc
argument_list|(
name|FB_LABEL_BUMP_BY
operator|*
sizeof|sizeof
argument_list|(
name|long
argument_list|)
argument_list|)
expr_stmt|;
name|fb_label_max
operator|=
name|FB_LABEL_BUMP_BY
expr_stmt|;
name|fb_label_count
operator|=
name|FB_LABEL_SPECIAL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fb_label_count
operator|==
name|fb_label_max
condition|)
block|{
name|fb_label_max
operator|+=
name|FB_LABEL_BUMP_BY
expr_stmt|;
name|fb_labels
operator|=
operator|(
name|long
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|fb_labels
argument_list|,
name|fb_label_max
operator|*
sizeof|sizeof
argument_list|(
name|long
argument_list|)
argument_list|)
expr_stmt|;
name|fb_label_instances
operator|=
operator|(
name|long
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|fb_label_instances
argument_list|,
name|fb_label_max
operator|*
sizeof|sizeof
argument_list|(
name|long
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* if we needed to grow  */
name|fb_labels
index|[
name|fb_label_count
index|]
operator|=
name|label
expr_stmt|;
name|fb_label_instances
index|[
name|fb_label_count
index|]
operator|=
literal|1
expr_stmt|;
operator|++
name|fb_label_count
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|long
name|fb_label_instance
parameter_list|(
name|label
parameter_list|)
name|long
name|label
decl_stmt|;
block|{
name|long
modifier|*
name|i
decl_stmt|;
if|if
condition|(
name|label
operator|<
name|FB_LABEL_SPECIAL
condition|)
block|{
return|return
operator|(
name|fb_low_counter
index|[
name|label
index|]
operator|)
return|;
block|}
if|if
condition|(
name|fb_labels
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|i
operator|=
name|fb_labels
operator|+
name|FB_LABEL_SPECIAL
init|;
name|i
operator|<
name|fb_labels
operator|+
name|fb_label_count
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
operator|*
name|i
operator|==
name|label
condition|)
block|{
return|return
operator|(
name|fb_label_instances
index|[
name|i
operator|-
name|fb_labels
index|]
operator|)
return|;
block|}
comment|/* if we find it  */
block|}
comment|/* for each existing label  */
block|}
comment|/* We didn't find the label, so this must be a reference to the      first instance.  */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Caller must copy returned name: we re-use the area for the next name.     The mth occurence of label n: is turned into the symbol "Ln^Bm"    where n is the label number and m is the instance number. "L" makes    it a label discarded unless debugging and "^B"('\2') ensures no    ordinary symbol SHOULD get the same name as a local label    symbol. The first "4:" is "L4^B1" - the m numbers begin at 1.     dollar labels get the same treatment, except that ^A is used in    place of ^B.  */
end_comment

begin_function
name|char
modifier|*
comment|/* Return local label name.  */
name|fb_label_name
parameter_list|(
name|n
parameter_list|,
name|augend
parameter_list|)
name|long
name|n
decl_stmt|;
comment|/* We just saw "n:", "nf" or "nb" : n a number.  */
name|long
name|augend
decl_stmt|;
comment|/* 0 for nb, 1 for n:, nf.  */
block|{
name|long
name|i
decl_stmt|;
comment|/* Returned to caller, then copied.  Used for created names ("4f").  */
specifier|static
name|char
name|symbol_name_build
index|[
literal|24
index|]
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|char
modifier|*
name|q
decl_stmt|;
name|char
name|symbol_name_temporary
index|[
literal|20
index|]
decl_stmt|;
comment|/* Build up a number, BACKWARDS.  */
name|know
argument_list|(
name|n
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|know
argument_list|(
name|augend
operator|==
literal|0
operator|||
name|augend
operator|==
literal|1
argument_list|)
expr_stmt|;
name|p
operator|=
name|symbol_name_build
expr_stmt|;
ifdef|#
directive|ifdef
name|LOCAL_LABEL_PREFIX
operator|*
name|p
operator|++
operator|=
name|LOCAL_LABEL_PREFIX
expr_stmt|;
endif|#
directive|endif
operator|*
name|p
operator|++
operator|=
literal|'L'
expr_stmt|;
comment|/* Next code just does sprintf( {}, "%d", n);  */
comment|/* Label number.  */
name|q
operator|=
name|symbol_name_temporary
expr_stmt|;
for|for
control|(
operator|*
name|q
operator|++
operator|=
literal|0
operator|,
name|i
operator|=
name|n
init|;
name|i
condition|;
operator|++
name|q
control|)
block|{
operator|*
name|q
operator|=
name|i
operator|%
literal|10
operator|+
literal|'0'
expr_stmt|;
name|i
operator|/=
literal|10
expr_stmt|;
block|}
while|while
condition|(
operator|(
operator|*
name|p
operator|=
operator|*
operator|--
name|q
operator|)
operator|!=
literal|'\0'
condition|)
operator|++
name|p
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|LOCAL_LABEL_CHAR
expr_stmt|;
comment|/* ^B  */
comment|/* Instance number.  */
name|q
operator|=
name|symbol_name_temporary
expr_stmt|;
for|for
control|(
operator|*
name|q
operator|++
operator|=
literal|0
operator|,
name|i
operator|=
name|fb_label_instance
argument_list|(
name|n
argument_list|)
operator|+
name|augend
init|;
name|i
condition|;
operator|++
name|q
control|)
block|{
operator|*
name|q
operator|=
name|i
operator|%
literal|10
operator|+
literal|'0'
expr_stmt|;
name|i
operator|/=
literal|10
expr_stmt|;
block|}
while|while
condition|(
operator|(
operator|*
name|p
operator|++
operator|=
operator|*
operator|--
name|q
operator|)
operator|!=
literal|'\0'
condition|)
empty_stmt|;
empty_stmt|;
comment|/* The label, as a '\0' ended string, starts at symbol_name_build.  */
return|return
operator|(
name|symbol_name_build
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Decode name that may have been generated by foo_label_name() above.    If the name wasn't generated by foo_label_name(), then return it    unaltered.  This is used for error messages.  */
end_comment

begin_function
name|char
modifier|*
name|decode_local_label_name
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|symbol_decode
decl_stmt|;
name|int
name|label_number
decl_stmt|;
name|int
name|instance_number
decl_stmt|;
name|char
modifier|*
name|type
decl_stmt|;
specifier|const
name|char
modifier|*
name|message_format
decl_stmt|;
name|int
name|index
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|LOCAL_LABEL_PREFIX
if|if
condition|(
name|s
index|[
name|index
index|]
operator|==
name|LOCAL_LABEL_PREFIX
condition|)
operator|++
name|index
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|s
index|[
name|index
index|]
operator|!=
literal|'L'
condition|)
return|return
name|s
return|;
for|for
control|(
name|label_number
operator|=
literal|0
operator|,
name|p
operator|=
name|s
operator|+
name|index
operator|+
literal|1
init|;
name|ISDIGIT
argument_list|(
operator|*
name|p
argument_list|)
condition|;
operator|++
name|p
control|)
name|label_number
operator|=
operator|(
literal|10
operator|*
name|label_number
operator|)
operator|+
operator|*
name|p
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
name|DOLLAR_LABEL_CHAR
condition|)
name|type
operator|=
literal|"dollar"
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
name|LOCAL_LABEL_CHAR
condition|)
name|type
operator|=
literal|"fb"
expr_stmt|;
else|else
return|return
name|s
return|;
for|for
control|(
name|instance_number
operator|=
literal|0
operator|,
name|p
operator|++
init|;
name|ISDIGIT
argument_list|(
operator|*
name|p
argument_list|)
condition|;
operator|++
name|p
control|)
name|instance_number
operator|=
operator|(
literal|10
operator|*
name|instance_number
operator|)
operator|+
operator|*
name|p
operator|-
literal|'0'
expr_stmt|;
name|message_format
operator|=
name|_
argument_list|(
literal|"\"%d\" (instance number %d of a %s label)"
argument_list|)
expr_stmt|;
name|symbol_decode
operator|=
name|obstack_alloc
argument_list|(
operator|&
name|notes
argument_list|,
name|strlen
argument_list|(
name|message_format
argument_list|)
operator|+
literal|30
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|symbol_decode
argument_list|,
name|message_format
argument_list|,
name|label_number
argument_list|,
name|instance_number
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
name|symbol_decode
return|;
block|}
end_function

begin_comment
comment|/* Get the value of a symbol.  */
end_comment

begin_function
name|valueT
name|S_GET_VALUE
parameter_list|(
name|s
parameter_list|)
name|symbolS
modifier|*
name|s
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|BFD_ASSEMBLER
if|if
condition|(
name|LOCAL_SYMBOL_CHECK
argument_list|(
name|s
argument_list|)
condition|)
return|return
name|resolve_symbol_value
argument_list|(
name|s
argument_list|)
return|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|s
operator|->
name|sy_resolved
condition|)
block|{
name|valueT
name|val
init|=
name|resolve_symbol_value
argument_list|(
name|s
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|finalize_syms
condition|)
return|return
name|val
return|;
block|}
if|if
condition|(
name|s
operator|->
name|sy_value
operator|.
name|X_op
operator|!=
name|O_constant
condition|)
block|{
specifier|static
name|symbolS
modifier|*
name|recur
decl_stmt|;
comment|/* FIXME: In non BFD assemblers, S_IS_DEFINED and S_IS_COMMON          may call S_GET_VALUE.  We use a static symbol to avoid the          immediate recursion.  */
if|if
condition|(
name|recur
operator|==
name|s
condition|)
return|return
operator|(
name|valueT
operator|)
name|s
operator|->
name|sy_value
operator|.
name|X_add_number
return|;
name|recur
operator|=
name|s
expr_stmt|;
if|if
condition|(
operator|!
name|s
operator|->
name|sy_resolved
operator|||
name|s
operator|->
name|sy_value
operator|.
name|X_op
operator|!=
name|O_symbol
operator|||
operator|(
name|S_IS_DEFINED
argument_list|(
name|s
argument_list|)
operator|&&
operator|!
name|S_IS_COMMON
argument_list|(
name|s
argument_list|)
operator|)
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"attempt to get value of unresolved symbol `%s'"
argument_list|)
argument_list|,
name|S_GET_NAME
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
name|recur
operator|=
name|NULL
expr_stmt|;
block|}
return|return
operator|(
name|valueT
operator|)
name|s
operator|->
name|sy_value
operator|.
name|X_add_number
return|;
block|}
end_function

begin_comment
comment|/* Set the value of a symbol.  */
end_comment

begin_function
name|void
name|S_SET_VALUE
parameter_list|(
name|s
parameter_list|,
name|val
parameter_list|)
name|symbolS
modifier|*
name|s
decl_stmt|;
name|valueT
name|val
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|BFD_ASSEMBLER
if|if
condition|(
name|LOCAL_SYMBOL_CHECK
argument_list|(
name|s
argument_list|)
condition|)
block|{
operator|(
operator|(
expr|struct
name|local_symbol
operator|*
operator|)
name|s
operator|)
operator|->
name|lsy_value
operator|=
name|val
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
name|s
operator|->
name|sy_value
operator|.
name|X_op
operator|=
name|O_constant
expr_stmt|;
name|s
operator|->
name|sy_value
operator|.
name|X_add_number
operator|=
operator|(
name|offsetT
operator|)
name|val
expr_stmt|;
name|s
operator|->
name|sy_value
operator|.
name|X_unsigned
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|void
name|copy_symbol_attributes
parameter_list|(
name|dest
parameter_list|,
name|src
parameter_list|)
name|symbolS
modifier|*
name|dest
decl_stmt|,
decl|*
name|src
decl_stmt|;
end_function

begin_block
block|{
if|if
condition|(
name|LOCAL_SYMBOL_CHECK
argument_list|(
name|dest
argument_list|)
condition|)
name|dest
operator|=
name|local_symbol_convert
argument_list|(
operator|(
expr|struct
name|local_symbol
operator|*
operator|)
name|dest
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOCAL_SYMBOL_CHECK
argument_list|(
name|src
argument_list|)
condition|)
name|src
operator|=
name|local_symbol_convert
argument_list|(
operator|(
expr|struct
name|local_symbol
operator|*
operator|)
name|src
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|BFD_ASSEMBLER
comment|/* In an expression, transfer the settings of these flags.      The user can override later, of course.  */
define|#
directive|define
name|COPIED_SYMFLAGS
value|(BSF_FUNCTION | BSF_OBJECT)
name|dest
operator|->
name|bsym
operator|->
name|flags
operator||=
name|src
operator|->
name|bsym
operator|->
name|flags
operator|&
name|COPIED_SYMFLAGS
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|OBJ_COPY_SYMBOL_ATTRIBUTES
name|OBJ_COPY_SYMBOL_ATTRIBUTES
argument_list|(
name|dest
argument_list|,
name|src
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|BFD_ASSEMBLER
end_ifdef

begin_function
name|int
name|S_IS_FUNCTION
parameter_list|(
name|s
parameter_list|)
name|symbolS
modifier|*
name|s
decl_stmt|;
block|{
name|flagword
name|flags
decl_stmt|;
if|if
condition|(
name|LOCAL_SYMBOL_CHECK
argument_list|(
name|s
argument_list|)
condition|)
return|return
literal|0
return|;
name|flags
operator|=
name|s
operator|->
name|bsym
operator|->
name|flags
expr_stmt|;
return|return
operator|(
name|flags
operator|&
name|BSF_FUNCTION
operator|)
operator|!=
literal|0
return|;
block|}
end_function

begin_function
name|int
name|S_IS_EXTERNAL
parameter_list|(
name|s
parameter_list|)
name|symbolS
modifier|*
name|s
decl_stmt|;
block|{
name|flagword
name|flags
decl_stmt|;
if|if
condition|(
name|LOCAL_SYMBOL_CHECK
argument_list|(
name|s
argument_list|)
condition|)
return|return
literal|0
return|;
name|flags
operator|=
name|s
operator|->
name|bsym
operator|->
name|flags
expr_stmt|;
comment|/* Sanity check.  */
if|if
condition|(
operator|(
name|flags
operator|&
name|BSF_LOCAL
operator|)
operator|&&
operator|(
name|flags
operator|&
name|BSF_GLOBAL
operator|)
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
operator|(
name|flags
operator|&
name|BSF_GLOBAL
operator|)
operator|!=
literal|0
return|;
block|}
end_function

begin_function
name|int
name|S_IS_WEAK
parameter_list|(
name|s
parameter_list|)
name|symbolS
modifier|*
name|s
decl_stmt|;
block|{
if|if
condition|(
name|LOCAL_SYMBOL_CHECK
argument_list|(
name|s
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
operator|(
name|s
operator|->
name|bsym
operator|->
name|flags
operator|&
name|BSF_WEAK
operator|)
operator|!=
literal|0
return|;
block|}
end_function

begin_function
name|int
name|S_IS_COMMON
parameter_list|(
name|s
parameter_list|)
name|symbolS
modifier|*
name|s
decl_stmt|;
block|{
if|if
condition|(
name|LOCAL_SYMBOL_CHECK
argument_list|(
name|s
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
name|bfd_is_com_section
argument_list|(
name|s
operator|->
name|bsym
operator|->
name|section
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|S_IS_DEFINED
parameter_list|(
name|s
parameter_list|)
name|symbolS
modifier|*
name|s
decl_stmt|;
block|{
if|if
condition|(
name|LOCAL_SYMBOL_CHECK
argument_list|(
name|s
argument_list|)
condition|)
return|return
operator|(
operator|(
expr|struct
name|local_symbol
operator|*
operator|)
name|s
operator|)
operator|->
name|lsy_section
operator|!=
name|undefined_section
return|;
return|return
name|s
operator|->
name|bsym
operator|->
name|section
operator|!=
name|undefined_section
return|;
block|}
end_function

begin_function
name|int
name|S_IS_DEBUG
parameter_list|(
name|s
parameter_list|)
name|symbolS
modifier|*
name|s
decl_stmt|;
block|{
if|if
condition|(
name|LOCAL_SYMBOL_CHECK
argument_list|(
name|s
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|s
operator|->
name|bsym
operator|->
name|flags
operator|&
name|BSF_DEBUGGING
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|S_IS_LOCAL
parameter_list|(
name|s
parameter_list|)
name|symbolS
modifier|*
name|s
decl_stmt|;
block|{
name|flagword
name|flags
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
if|if
condition|(
name|LOCAL_SYMBOL_CHECK
argument_list|(
name|s
argument_list|)
condition|)
return|return
literal|1
return|;
name|flags
operator|=
name|s
operator|->
name|bsym
operator|->
name|flags
expr_stmt|;
comment|/* Sanity check.  */
if|if
condition|(
operator|(
name|flags
operator|&
name|BSF_LOCAL
operator|)
operator|&&
operator|(
name|flags
operator|&
name|BSF_GLOBAL
operator|)
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|bfd_get_section
argument_list|(
name|s
operator|->
name|bsym
argument_list|)
operator|==
name|reg_section
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|flag_strip_local_absolute
operator|&&
operator|(
name|flags
operator|&
name|BSF_GLOBAL
operator|)
operator|==
literal|0
operator|&&
name|bfd_get_section
argument_list|(
name|s
operator|->
name|bsym
argument_list|)
operator|==
name|absolute_section
condition|)
return|return
literal|1
return|;
name|name
operator|=
name|S_GET_NAME
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|name
operator|!=
name|NULL
operator|&&
operator|!
name|S_IS_DEBUG
argument_list|(
name|s
argument_list|)
operator|&&
operator|(
name|strchr
argument_list|(
name|name
argument_list|,
name|DOLLAR_LABEL_CHAR
argument_list|)
operator|||
name|strchr
argument_list|(
name|name
argument_list|,
name|LOCAL_LABEL_CHAR
argument_list|)
operator|||
operator|(
operator|!
name|flag_keep_locals
operator|&&
operator|(
name|bfd_is_local_label
argument_list|(
name|stdoutput
argument_list|,
name|s
operator|->
name|bsym
argument_list|)
operator|||
operator|(
name|flag_mri
operator|&&
name|name
index|[
literal|0
index|]
operator|==
literal|'?'
operator|&&
name|name
index|[
literal|1
index|]
operator|==
literal|'?'
operator|)
operator|)
operator|)
operator|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|S_IS_EXTERN
parameter_list|(
name|s
parameter_list|)
name|symbolS
modifier|*
name|s
decl_stmt|;
block|{
return|return
name|S_IS_EXTERNAL
argument_list|(
name|s
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|S_IS_STABD
parameter_list|(
name|s
parameter_list|)
name|symbolS
modifier|*
name|s
decl_stmt|;
block|{
return|return
name|S_GET_NAME
argument_list|(
name|s
argument_list|)
operator|==
literal|0
return|;
block|}
end_function

begin_function
name|CONST
name|char
modifier|*
name|S_GET_NAME
parameter_list|(
name|s
parameter_list|)
name|symbolS
modifier|*
name|s
decl_stmt|;
block|{
if|if
condition|(
name|LOCAL_SYMBOL_CHECK
argument_list|(
name|s
argument_list|)
condition|)
return|return
operator|(
operator|(
expr|struct
name|local_symbol
operator|*
operator|)
name|s
operator|)
operator|->
name|lsy_name
return|;
return|return
name|s
operator|->
name|bsym
operator|->
name|name
return|;
block|}
end_function

begin_function
name|segT
name|S_GET_SEGMENT
parameter_list|(
name|s
parameter_list|)
name|symbolS
modifier|*
name|s
decl_stmt|;
block|{
if|if
condition|(
name|LOCAL_SYMBOL_CHECK
argument_list|(
name|s
argument_list|)
condition|)
return|return
operator|(
operator|(
expr|struct
name|local_symbol
operator|*
operator|)
name|s
operator|)
operator|->
name|lsy_section
return|;
return|return
name|s
operator|->
name|bsym
operator|->
name|section
return|;
block|}
end_function

begin_function
name|void
name|S_SET_SEGMENT
parameter_list|(
name|s
parameter_list|,
name|seg
parameter_list|)
name|symbolS
modifier|*
name|s
decl_stmt|;
name|segT
name|seg
decl_stmt|;
block|{
comment|/* Don't reassign section symbols.  The direct reason is to prevent seg      faults assigning back to const global symbols such as *ABS*, but it      shouldn't happen anyway.  */
if|if
condition|(
name|LOCAL_SYMBOL_CHECK
argument_list|(
name|s
argument_list|)
condition|)
block|{
if|if
condition|(
name|seg
operator|==
name|reg_section
condition|)
name|s
operator|=
name|local_symbol_convert
argument_list|(
operator|(
expr|struct
name|local_symbol
operator|*
operator|)
name|s
argument_list|)
expr_stmt|;
else|else
block|{
operator|(
operator|(
expr|struct
name|local_symbol
operator|*
operator|)
name|s
operator|)
operator|->
name|lsy_section
operator|=
name|seg
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
name|s
operator|->
name|bsym
operator|->
name|flags
operator|&
name|BSF_SECTION_SYM
condition|)
block|{
if|if
condition|(
name|s
operator|->
name|bsym
operator|->
name|section
operator|!=
name|seg
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
else|else
name|s
operator|->
name|bsym
operator|->
name|section
operator|=
name|seg
expr_stmt|;
block|}
end_function

begin_function
name|void
name|S_SET_EXTERNAL
parameter_list|(
name|s
parameter_list|)
name|symbolS
modifier|*
name|s
decl_stmt|;
block|{
if|if
condition|(
name|LOCAL_SYMBOL_CHECK
argument_list|(
name|s
argument_list|)
condition|)
name|s
operator|=
name|local_symbol_convert
argument_list|(
operator|(
expr|struct
name|local_symbol
operator|*
operator|)
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|s
operator|->
name|bsym
operator|->
name|flags
operator|&
name|BSF_WEAK
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* Let .weak override .global.  */
return|return;
block|}
if|if
condition|(
name|s
operator|->
name|bsym
operator|->
name|flags
operator|&
name|BSF_SECTION_SYM
condition|)
block|{
name|char
modifier|*
name|file
decl_stmt|;
name|unsigned
name|int
name|line
decl_stmt|;
comment|/* Do not reassign section symbols.  */
name|as_where
argument_list|(
operator|&
name|file
argument_list|,
operator|&
name|line
argument_list|)
expr_stmt|;
name|as_warn_where
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
name|_
argument_list|(
literal|"section symbols are already global"
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|s
operator|->
name|bsym
operator|->
name|flags
operator||=
name|BSF_GLOBAL
expr_stmt|;
name|s
operator|->
name|bsym
operator|->
name|flags
operator|&=
operator|~
operator|(
name|BSF_LOCAL
operator||
name|BSF_WEAK
operator|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|S_CLEAR_EXTERNAL
parameter_list|(
name|s
parameter_list|)
name|symbolS
modifier|*
name|s
decl_stmt|;
block|{
if|if
condition|(
name|LOCAL_SYMBOL_CHECK
argument_list|(
name|s
argument_list|)
condition|)
return|return;
if|if
condition|(
operator|(
name|s
operator|->
name|bsym
operator|->
name|flags
operator|&
name|BSF_WEAK
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* Let .weak override.  */
return|return;
block|}
name|s
operator|->
name|bsym
operator|->
name|flags
operator||=
name|BSF_LOCAL
expr_stmt|;
name|s
operator|->
name|bsym
operator|->
name|flags
operator|&=
operator|~
operator|(
name|BSF_GLOBAL
operator||
name|BSF_WEAK
operator|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|S_SET_WEAK
parameter_list|(
name|s
parameter_list|)
name|symbolS
modifier|*
name|s
decl_stmt|;
block|{
if|if
condition|(
name|LOCAL_SYMBOL_CHECK
argument_list|(
name|s
argument_list|)
condition|)
name|s
operator|=
name|local_symbol_convert
argument_list|(
operator|(
expr|struct
name|local_symbol
operator|*
operator|)
name|s
argument_list|)
expr_stmt|;
name|s
operator|->
name|bsym
operator|->
name|flags
operator||=
name|BSF_WEAK
expr_stmt|;
name|s
operator|->
name|bsym
operator|->
name|flags
operator|&=
operator|~
operator|(
name|BSF_GLOBAL
operator||
name|BSF_LOCAL
operator|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|S_SET_NAME
parameter_list|(
name|s
parameter_list|,
name|name
parameter_list|)
name|symbolS
modifier|*
name|s
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
block|{
if|if
condition|(
name|LOCAL_SYMBOL_CHECK
argument_list|(
name|s
argument_list|)
condition|)
block|{
operator|(
operator|(
expr|struct
name|local_symbol
operator|*
operator|)
name|s
operator|)
operator|->
name|lsy_name
operator|=
name|name
expr_stmt|;
return|return;
block|}
name|s
operator|->
name|bsym
operator|->
name|name
operator|=
name|name
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* BFD_ASSEMBLER */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|SYMBOLS_NEED_BACKPOINTERS
end_ifdef

begin_comment
comment|/* Return the previous symbol in a chain.  */
end_comment

begin_function
name|symbolS
modifier|*
name|symbol_previous
parameter_list|(
name|s
parameter_list|)
name|symbolS
modifier|*
name|s
decl_stmt|;
block|{
if|if
condition|(
name|LOCAL_SYMBOL_CHECK
argument_list|(
name|s
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
name|s
operator|->
name|sy_previous
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SYMBOLS_NEED_BACKPOINTERS */
end_comment

begin_comment
comment|/* Return the next symbol in a chain.  */
end_comment

begin_function
name|symbolS
modifier|*
name|symbol_next
parameter_list|(
name|s
parameter_list|)
name|symbolS
modifier|*
name|s
decl_stmt|;
block|{
if|if
condition|(
name|LOCAL_SYMBOL_CHECK
argument_list|(
name|s
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
name|s
operator|->
name|sy_next
return|;
block|}
end_function

begin_comment
comment|/* Return a pointer to the value of a symbol as an expression.  */
end_comment

begin_function
name|expressionS
modifier|*
name|symbol_get_value_expression
parameter_list|(
name|s
parameter_list|)
name|symbolS
modifier|*
name|s
decl_stmt|;
block|{
if|if
condition|(
name|LOCAL_SYMBOL_CHECK
argument_list|(
name|s
argument_list|)
condition|)
name|s
operator|=
name|local_symbol_convert
argument_list|(
operator|(
expr|struct
name|local_symbol
operator|*
operator|)
name|s
argument_list|)
expr_stmt|;
return|return
operator|&
name|s
operator|->
name|sy_value
return|;
block|}
end_function

begin_comment
comment|/* Set the value of a symbol to an expression.  */
end_comment

begin_function
name|void
name|symbol_set_value_expression
parameter_list|(
name|s
parameter_list|,
name|exp
parameter_list|)
name|symbolS
modifier|*
name|s
decl_stmt|;
specifier|const
name|expressionS
modifier|*
name|exp
decl_stmt|;
block|{
if|if
condition|(
name|LOCAL_SYMBOL_CHECK
argument_list|(
name|s
argument_list|)
condition|)
name|s
operator|=
name|local_symbol_convert
argument_list|(
operator|(
expr|struct
name|local_symbol
operator|*
operator|)
name|s
argument_list|)
expr_stmt|;
name|s
operator|->
name|sy_value
operator|=
operator|*
name|exp
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set the frag of a symbol.  */
end_comment

begin_function
name|void
name|symbol_set_frag
parameter_list|(
name|s
parameter_list|,
name|f
parameter_list|)
name|symbolS
modifier|*
name|s
decl_stmt|;
name|fragS
modifier|*
name|f
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|BFD_ASSEMBLER
if|if
condition|(
name|LOCAL_SYMBOL_CHECK
argument_list|(
name|s
argument_list|)
condition|)
block|{
name|local_symbol_set_frag
argument_list|(
operator|(
expr|struct
name|local_symbol
operator|*
operator|)
name|s
argument_list|,
name|f
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
name|s
operator|->
name|sy_frag
operator|=
name|f
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the frag of a symbol.  */
end_comment

begin_function
name|fragS
modifier|*
name|symbol_get_frag
parameter_list|(
name|s
parameter_list|)
name|symbolS
modifier|*
name|s
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|BFD_ASSEMBLER
if|if
condition|(
name|LOCAL_SYMBOL_CHECK
argument_list|(
name|s
argument_list|)
condition|)
return|return
name|local_symbol_get_frag
argument_list|(
operator|(
expr|struct
name|local_symbol
operator|*
operator|)
name|s
argument_list|)
return|;
endif|#
directive|endif
return|return
name|s
operator|->
name|sy_frag
return|;
block|}
end_function

begin_comment
comment|/* Mark a symbol as having been used.  */
end_comment

begin_function
name|void
name|symbol_mark_used
parameter_list|(
name|s
parameter_list|)
name|symbolS
modifier|*
name|s
decl_stmt|;
block|{
if|if
condition|(
name|LOCAL_SYMBOL_CHECK
argument_list|(
name|s
argument_list|)
condition|)
return|return;
name|s
operator|->
name|sy_used
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Clear the mark of whether a symbol has been used.  */
end_comment

begin_function
name|void
name|symbol_clear_used
parameter_list|(
name|s
parameter_list|)
name|symbolS
modifier|*
name|s
decl_stmt|;
block|{
if|if
condition|(
name|LOCAL_SYMBOL_CHECK
argument_list|(
name|s
argument_list|)
condition|)
name|s
operator|=
name|local_symbol_convert
argument_list|(
operator|(
expr|struct
name|local_symbol
operator|*
operator|)
name|s
argument_list|)
expr_stmt|;
name|s
operator|->
name|sy_used
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return whether a symbol has been used.  */
end_comment

begin_function
name|int
name|symbol_used_p
parameter_list|(
name|s
parameter_list|)
name|symbolS
modifier|*
name|s
decl_stmt|;
block|{
if|if
condition|(
name|LOCAL_SYMBOL_CHECK
argument_list|(
name|s
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
name|s
operator|->
name|sy_used
return|;
block|}
end_function

begin_comment
comment|/* Mark a symbol as having been used in a reloc.  */
end_comment

begin_function
name|void
name|symbol_mark_used_in_reloc
parameter_list|(
name|s
parameter_list|)
name|symbolS
modifier|*
name|s
decl_stmt|;
block|{
if|if
condition|(
name|LOCAL_SYMBOL_CHECK
argument_list|(
name|s
argument_list|)
condition|)
name|s
operator|=
name|local_symbol_convert
argument_list|(
operator|(
expr|struct
name|local_symbol
operator|*
operator|)
name|s
argument_list|)
expr_stmt|;
name|s
operator|->
name|sy_used_in_reloc
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Clear the mark of whether a symbol has been used in a reloc.  */
end_comment

begin_function
name|void
name|symbol_clear_used_in_reloc
parameter_list|(
name|s
parameter_list|)
name|symbolS
modifier|*
name|s
decl_stmt|;
block|{
if|if
condition|(
name|LOCAL_SYMBOL_CHECK
argument_list|(
name|s
argument_list|)
condition|)
return|return;
name|s
operator|->
name|sy_used_in_reloc
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return whether a symbol has been used in a reloc.  */
end_comment

begin_function
name|int
name|symbol_used_in_reloc_p
parameter_list|(
name|s
parameter_list|)
name|symbolS
modifier|*
name|s
decl_stmt|;
block|{
if|if
condition|(
name|LOCAL_SYMBOL_CHECK
argument_list|(
name|s
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
name|s
operator|->
name|sy_used_in_reloc
return|;
block|}
end_function

begin_comment
comment|/* Mark a symbol as an MRI common symbol.  */
end_comment

begin_function
name|void
name|symbol_mark_mri_common
parameter_list|(
name|s
parameter_list|)
name|symbolS
modifier|*
name|s
decl_stmt|;
block|{
if|if
condition|(
name|LOCAL_SYMBOL_CHECK
argument_list|(
name|s
argument_list|)
condition|)
name|s
operator|=
name|local_symbol_convert
argument_list|(
operator|(
expr|struct
name|local_symbol
operator|*
operator|)
name|s
argument_list|)
expr_stmt|;
name|s
operator|->
name|sy_mri_common
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Clear the mark of whether a symbol is an MRI common symbol.  */
end_comment

begin_function
name|void
name|symbol_clear_mri_common
parameter_list|(
name|s
parameter_list|)
name|symbolS
modifier|*
name|s
decl_stmt|;
block|{
if|if
condition|(
name|LOCAL_SYMBOL_CHECK
argument_list|(
name|s
argument_list|)
condition|)
return|return;
name|s
operator|->
name|sy_mri_common
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return whether a symbol is an MRI common symbol.  */
end_comment

begin_function
name|int
name|symbol_mri_common_p
parameter_list|(
name|s
parameter_list|)
name|symbolS
modifier|*
name|s
decl_stmt|;
block|{
if|if
condition|(
name|LOCAL_SYMBOL_CHECK
argument_list|(
name|s
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
name|s
operator|->
name|sy_mri_common
return|;
block|}
end_function

begin_comment
comment|/* Mark a symbol as having been written.  */
end_comment

begin_function
name|void
name|symbol_mark_written
parameter_list|(
name|s
parameter_list|)
name|symbolS
modifier|*
name|s
decl_stmt|;
block|{
if|if
condition|(
name|LOCAL_SYMBOL_CHECK
argument_list|(
name|s
argument_list|)
condition|)
return|return;
name|s
operator|->
name|written
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Clear the mark of whether a symbol has been written.  */
end_comment

begin_function
name|void
name|symbol_clear_written
parameter_list|(
name|s
parameter_list|)
name|symbolS
modifier|*
name|s
decl_stmt|;
block|{
if|if
condition|(
name|LOCAL_SYMBOL_CHECK
argument_list|(
name|s
argument_list|)
condition|)
return|return;
name|s
operator|->
name|written
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return whether a symbol has been written.  */
end_comment

begin_function
name|int
name|symbol_written_p
parameter_list|(
name|s
parameter_list|)
name|symbolS
modifier|*
name|s
decl_stmt|;
block|{
if|if
condition|(
name|LOCAL_SYMBOL_CHECK
argument_list|(
name|s
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
name|s
operator|->
name|written
return|;
block|}
end_function

begin_comment
comment|/* Mark a symbol has having been resolved.  */
end_comment

begin_function
name|void
name|symbol_mark_resolved
parameter_list|(
name|s
parameter_list|)
name|symbolS
modifier|*
name|s
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|BFD_ASSEMBLER
if|if
condition|(
name|LOCAL_SYMBOL_CHECK
argument_list|(
name|s
argument_list|)
condition|)
block|{
name|local_symbol_mark_resolved
argument_list|(
operator|(
expr|struct
name|local_symbol
operator|*
operator|)
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
name|s
operator|->
name|sy_resolved
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return whether a symbol has been resolved.  */
end_comment

begin_function
name|int
name|symbol_resolved_p
parameter_list|(
name|s
parameter_list|)
name|symbolS
modifier|*
name|s
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|BFD_ASSEMBLER
if|if
condition|(
name|LOCAL_SYMBOL_CHECK
argument_list|(
name|s
argument_list|)
condition|)
return|return
name|local_symbol_resolved_p
argument_list|(
operator|(
expr|struct
name|local_symbol
operator|*
operator|)
name|s
argument_list|)
return|;
endif|#
directive|endif
return|return
name|s
operator|->
name|sy_resolved
return|;
block|}
end_function

begin_comment
comment|/* Return whether a symbol is a section symbol.  */
end_comment

begin_function
name|int
name|symbol_section_p
parameter_list|(
name|s
parameter_list|)
name|symbolS
modifier|*
name|s
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
if|if
condition|(
name|LOCAL_SYMBOL_CHECK
argument_list|(
name|s
argument_list|)
condition|)
return|return
literal|0
return|;
ifdef|#
directive|ifdef
name|BFD_ASSEMBLER
return|return
operator|(
name|s
operator|->
name|bsym
operator|->
name|flags
operator|&
name|BSF_SECTION_SYM
operator|)
operator|!=
literal|0
return|;
else|#
directive|else
comment|/* FIXME.  */
return|return
literal|0
return|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Return whether a symbol is equated to another symbol.  */
end_comment

begin_function
name|int
name|symbol_equated_p
parameter_list|(
name|s
parameter_list|)
name|symbolS
modifier|*
name|s
decl_stmt|;
block|{
if|if
condition|(
name|LOCAL_SYMBOL_CHECK
argument_list|(
name|s
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
name|s
operator|->
name|sy_value
operator|.
name|X_op
operator|==
name|O_symbol
return|;
block|}
end_function

begin_comment
comment|/* Return whether a symbol is equated to another symbol, and should be    treated specially when writing out relocs.  */
end_comment

begin_function
name|int
name|symbol_equated_reloc_p
parameter_list|(
name|s
parameter_list|)
name|symbolS
modifier|*
name|s
decl_stmt|;
block|{
if|if
condition|(
name|LOCAL_SYMBOL_CHECK
argument_list|(
name|s
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* X_op_symbol, normally not used for O_symbol, is set by      resolve_symbol_value to flag expression syms that have been      equated.  */
return|return
operator|(
name|s
operator|->
name|sy_value
operator|.
name|X_op
operator|==
name|O_symbol
operator|&&
operator|(
operator|(
name|s
operator|->
name|sy_resolved
operator|&&
name|s
operator|->
name|sy_value
operator|.
name|X_op_symbol
operator|!=
name|NULL
operator|)
operator|||
operator|!
name|S_IS_DEFINED
argument_list|(
name|s
argument_list|)
operator|||
name|S_IS_COMMON
argument_list|(
name|s
argument_list|)
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return whether a symbol has a constant value.  */
end_comment

begin_function
name|int
name|symbol_constant_p
parameter_list|(
name|s
parameter_list|)
name|symbolS
modifier|*
name|s
decl_stmt|;
block|{
if|if
condition|(
name|LOCAL_SYMBOL_CHECK
argument_list|(
name|s
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
name|s
operator|->
name|sy_value
operator|.
name|X_op
operator|==
name|O_constant
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|BFD_ASSEMBLER
end_ifdef

begin_comment
comment|/* Return the BFD symbol for a symbol.  */
end_comment

begin_function
name|asymbol
modifier|*
name|symbol_get_bfdsym
parameter_list|(
name|s
parameter_list|)
name|symbolS
modifier|*
name|s
decl_stmt|;
block|{
if|if
condition|(
name|LOCAL_SYMBOL_CHECK
argument_list|(
name|s
argument_list|)
condition|)
name|s
operator|=
name|local_symbol_convert
argument_list|(
operator|(
expr|struct
name|local_symbol
operator|*
operator|)
name|s
argument_list|)
expr_stmt|;
return|return
name|s
operator|->
name|bsym
return|;
block|}
end_function

begin_comment
comment|/* Set the BFD symbol for a symbol.  */
end_comment

begin_function
name|void
name|symbol_set_bfdsym
parameter_list|(
name|s
parameter_list|,
name|bsym
parameter_list|)
name|symbolS
modifier|*
name|s
decl_stmt|;
name|asymbol
modifier|*
name|bsym
decl_stmt|;
block|{
if|if
condition|(
name|LOCAL_SYMBOL_CHECK
argument_list|(
name|s
argument_list|)
condition|)
name|s
operator|=
name|local_symbol_convert
argument_list|(
operator|(
expr|struct
name|local_symbol
operator|*
operator|)
name|s
argument_list|)
expr_stmt|;
name|s
operator|->
name|bsym
operator|=
name|bsym
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* BFD_ASSEMBLER */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|OBJ_SYMFIELD_TYPE
end_ifdef

begin_comment
comment|/* Get a pointer to the object format information for a symbol.  */
end_comment

begin_function
name|OBJ_SYMFIELD_TYPE
modifier|*
name|symbol_get_obj
parameter_list|(
name|s
parameter_list|)
name|symbolS
modifier|*
name|s
decl_stmt|;
block|{
if|if
condition|(
name|LOCAL_SYMBOL_CHECK
argument_list|(
name|s
argument_list|)
condition|)
name|s
operator|=
name|local_symbol_convert
argument_list|(
operator|(
expr|struct
name|local_symbol
operator|*
operator|)
name|s
argument_list|)
expr_stmt|;
return|return
operator|&
name|s
operator|->
name|sy_obj
return|;
block|}
end_function

begin_comment
comment|/* Set the object format information for a symbol.  */
end_comment

begin_function
name|void
name|symbol_set_obj
parameter_list|(
name|s
parameter_list|,
name|o
parameter_list|)
name|symbolS
modifier|*
name|s
decl_stmt|;
name|OBJ_SYMFIELD_TYPE
modifier|*
name|o
decl_stmt|;
block|{
if|if
condition|(
name|LOCAL_SYMBOL_CHECK
argument_list|(
name|s
argument_list|)
condition|)
name|s
operator|=
name|local_symbol_convert
argument_list|(
operator|(
expr|struct
name|local_symbol
operator|*
operator|)
name|s
argument_list|)
expr_stmt|;
name|s
operator|->
name|sy_obj
operator|=
operator|*
name|o
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* OBJ_SYMFIELD_TYPE */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|TC_SYMFIELD_TYPE
end_ifdef

begin_comment
comment|/* Get a pointer to the processor information for a symbol.  */
end_comment

begin_function
name|TC_SYMFIELD_TYPE
modifier|*
name|symbol_get_tc
parameter_list|(
name|s
parameter_list|)
name|symbolS
modifier|*
name|s
decl_stmt|;
block|{
if|if
condition|(
name|LOCAL_SYMBOL_CHECK
argument_list|(
name|s
argument_list|)
condition|)
name|s
operator|=
name|local_symbol_convert
argument_list|(
operator|(
expr|struct
name|local_symbol
operator|*
operator|)
name|s
argument_list|)
expr_stmt|;
return|return
operator|&
name|s
operator|->
name|sy_tc
return|;
block|}
end_function

begin_comment
comment|/* Set the processor information for a symbol.  */
end_comment

begin_function
name|void
name|symbol_set_tc
parameter_list|(
name|s
parameter_list|,
name|o
parameter_list|)
name|symbolS
modifier|*
name|s
decl_stmt|;
name|TC_SYMFIELD_TYPE
modifier|*
name|o
decl_stmt|;
block|{
if|if
condition|(
name|LOCAL_SYMBOL_CHECK
argument_list|(
name|s
argument_list|)
condition|)
name|s
operator|=
name|local_symbol_convert
argument_list|(
operator|(
expr|struct
name|local_symbol
operator|*
operator|)
name|s
argument_list|)
expr_stmt|;
name|s
operator|->
name|sy_tc
operator|=
operator|*
name|o
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* TC_SYMFIELD_TYPE */
end_comment

begin_function
name|void
name|symbol_begin
parameter_list|()
block|{
name|symbol_lastP
operator|=
name|NULL
expr_stmt|;
name|symbol_rootP
operator|=
name|NULL
expr_stmt|;
comment|/* In case we have 0 symbols (!!)  */
name|sy_hash
operator|=
name|hash_new
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|BFD_ASSEMBLER
name|local_hash
operator|=
name|hash_new
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
operator|&
name|abs_symbol
operator|)
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
name|abs_symbol
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|BFD_ASSEMBLER
if|#
directive|if
name|defined
argument_list|(
name|EMIT_SECTION_SYMBOLS
argument_list|)
operator|||
operator|!
name|defined
argument_list|(
name|RELOC_REQUIRES_SYMBOL
argument_list|)
name|abs_symbol
operator|.
name|bsym
operator|=
name|bfd_abs_section
operator|.
name|symbol
expr_stmt|;
endif|#
directive|endif
else|#
directive|else
comment|/* Can't initialise a union. Sigh.  */
name|S_SET_SEGMENT
argument_list|(
operator|&
name|abs_symbol
argument_list|,
name|absolute_section
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|abs_symbol
operator|.
name|sy_value
operator|.
name|X_op
operator|=
name|O_constant
expr_stmt|;
name|abs_symbol
operator|.
name|sy_frag
operator|=
operator|&
name|zero_address_frag
expr_stmt|;
if|if
condition|(
name|LOCAL_LABELS_FB
condition|)
name|fb_label_init
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_decl_stmt
name|int
name|indent_level
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Maximum indent level.    Available for modification inside a gdb session.  */
end_comment

begin_decl_stmt
name|int
name|max_indent_level
init|=
literal|8
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static void indent () {   printf ("%*s", indent_level * 4, ""); }
endif|#
directive|endif
end_endif

begin_function
name|void
name|print_symbol_value_1
parameter_list|(
name|file
parameter_list|,
name|sym
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|symbolS
modifier|*
name|sym
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|name
init|=
name|S_GET_NAME
argument_list|(
name|sym
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|name
operator|||
operator|!
name|name
index|[
literal|0
index|]
condition|)
name|name
operator|=
literal|"(unnamed)"
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"sym %lx %s"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|sym
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOCAL_SYMBOL_CHECK
argument_list|(
name|sym
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|BFD_ASSEMBLER
name|struct
name|local_symbol
modifier|*
name|locsym
init|=
operator|(
expr|struct
name|local_symbol
operator|*
operator|)
name|sym
decl_stmt|;
if|if
condition|(
name|local_symbol_get_frag
argument_list|(
name|locsym
argument_list|)
operator|!=
operator|&
name|zero_address_frag
operator|&&
name|local_symbol_get_frag
argument_list|(
name|locsym
argument_list|)
operator|!=
name|NULL
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" frag %lx"
argument_list|,
operator|(
name|long
operator|)
name|local_symbol_get_frag
argument_list|(
name|locsym
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|local_symbol_resolved_p
argument_list|(
name|locsym
argument_list|)
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" resolved"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" local"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
if|if
condition|(
name|sym
operator|->
name|sy_frag
operator|!=
operator|&
name|zero_address_frag
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" frag %lx"
argument_list|,
operator|(
name|long
operator|)
name|sym
operator|->
name|sy_frag
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
operator|->
name|written
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" written"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
operator|->
name|sy_resolved
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" resolved"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sym
operator|->
name|sy_resolving
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" resolving"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
operator|->
name|sy_used_in_reloc
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" used-in-reloc"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
operator|->
name|sy_used
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" used"
argument_list|)
expr_stmt|;
if|if
condition|(
name|S_IS_LOCAL
argument_list|(
name|sym
argument_list|)
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" local"
argument_list|)
expr_stmt|;
if|if
condition|(
name|S_IS_EXTERN
argument_list|(
name|sym
argument_list|)
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" extern"
argument_list|)
expr_stmt|;
if|if
condition|(
name|S_IS_DEBUG
argument_list|(
name|sym
argument_list|)
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" debug"
argument_list|)
expr_stmt|;
if|if
condition|(
name|S_IS_DEFINED
argument_list|(
name|sym
argument_list|)
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" defined"
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" %s"
argument_list|,
name|segment_name
argument_list|(
name|S_GET_SEGMENT
argument_list|(
name|sym
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|symbol_resolved_p
argument_list|(
name|sym
argument_list|)
condition|)
block|{
name|segT
name|s
init|=
name|S_GET_SEGMENT
argument_list|(
name|sym
argument_list|)
decl_stmt|;
if|if
condition|(
name|s
operator|!=
name|undefined_section
operator|&&
name|s
operator|!=
name|expr_section
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" %lx"
argument_list|,
operator|(
name|long
operator|)
name|S_GET_VALUE
argument_list|(
name|sym
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|indent_level
operator|<
name|max_indent_level
operator|&&
name|S_GET_SEGMENT
argument_list|(
name|sym
argument_list|)
operator|!=
name|undefined_section
condition|)
block|{
name|indent_level
operator|++
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n%*s<"
argument_list|,
name|indent_level
operator|*
literal|4
argument_list|,
literal|""
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|BFD_ASSEMBLER
if|if
condition|(
name|LOCAL_SYMBOL_CHECK
argument_list|(
name|sym
argument_list|)
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"constant %lx"
argument_list|,
call|(
name|long
call|)
argument_list|(
operator|(
expr|struct
name|local_symbol
operator|*
operator|)
name|sym
argument_list|)
operator|->
name|lsy_value
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|print_expr_1
argument_list|(
name|file
argument_list|,
operator|&
name|sym
operator|->
name|sy_value
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|">"
argument_list|)
expr_stmt|;
name|indent_level
operator|--
expr_stmt|;
block|}
name|fflush
argument_list|(
name|file
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|print_symbol_value
parameter_list|(
name|sym
parameter_list|)
name|symbolS
modifier|*
name|sym
decl_stmt|;
block|{
name|indent_level
operator|=
literal|0
expr_stmt|;
name|print_symbol_value_1
argument_list|(
name|stderr
argument_list|,
name|sym
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|print_binary
parameter_list|(
name|file
parameter_list|,
name|name
parameter_list|,
name|exp
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|expressionS
modifier|*
name|exp
decl_stmt|;
block|{
name|indent_level
operator|++
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s\n%*s<"
argument_list|,
name|name
argument_list|,
name|indent_level
operator|*
literal|4
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|print_symbol_value_1
argument_list|(
name|file
argument_list|,
name|exp
operator|->
name|X_add_symbol
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|">\n%*s<"
argument_list|,
name|indent_level
operator|*
literal|4
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|print_symbol_value_1
argument_list|(
name|file
argument_list|,
name|exp
operator|->
name|X_op_symbol
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|">"
argument_list|)
expr_stmt|;
name|indent_level
operator|--
expr_stmt|;
block|}
end_function

begin_function
name|void
name|print_expr_1
parameter_list|(
name|file
parameter_list|,
name|exp
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|expressionS
modifier|*
name|exp
decl_stmt|;
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"expr %lx "
argument_list|,
operator|(
name|long
operator|)
name|exp
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|exp
operator|->
name|X_op
condition|)
block|{
case|case
name|O_illegal
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"illegal"
argument_list|)
expr_stmt|;
break|break;
case|case
name|O_absent
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"absent"
argument_list|)
expr_stmt|;
break|break;
case|case
name|O_constant
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"constant %lx"
argument_list|,
operator|(
name|long
operator|)
name|exp
operator|->
name|X_add_number
argument_list|)
expr_stmt|;
break|break;
case|case
name|O_symbol
case|:
name|indent_level
operator|++
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"symbol\n%*s<"
argument_list|,
name|indent_level
operator|*
literal|4
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|print_symbol_value_1
argument_list|(
name|file
argument_list|,
name|exp
operator|->
name|X_add_symbol
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|">"
argument_list|)
expr_stmt|;
name|maybe_print_addnum
label|:
if|if
condition|(
name|exp
operator|->
name|X_add_number
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n%*s%lx"
argument_list|,
name|indent_level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
operator|(
name|long
operator|)
name|exp
operator|->
name|X_add_number
argument_list|)
expr_stmt|;
name|indent_level
operator|--
expr_stmt|;
break|break;
case|case
name|O_register
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"register #%d"
argument_list|,
operator|(
name|int
operator|)
name|exp
operator|->
name|X_add_number
argument_list|)
expr_stmt|;
break|break;
case|case
name|O_big
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"big"
argument_list|)
expr_stmt|;
break|break;
case|case
name|O_uminus
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"uminus -<"
argument_list|)
expr_stmt|;
name|indent_level
operator|++
expr_stmt|;
name|print_symbol_value_1
argument_list|(
name|file
argument_list|,
name|exp
operator|->
name|X_add_symbol
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|">"
argument_list|)
expr_stmt|;
goto|goto
name|maybe_print_addnum
goto|;
case|case
name|O_bit_not
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"bit_not"
argument_list|)
expr_stmt|;
break|break;
case|case
name|O_multiply
case|:
name|print_binary
argument_list|(
name|file
argument_list|,
literal|"multiply"
argument_list|,
name|exp
argument_list|)
expr_stmt|;
break|break;
case|case
name|O_divide
case|:
name|print_binary
argument_list|(
name|file
argument_list|,
literal|"divide"
argument_list|,
name|exp
argument_list|)
expr_stmt|;
break|break;
case|case
name|O_modulus
case|:
name|print_binary
argument_list|(
name|file
argument_list|,
literal|"modulus"
argument_list|,
name|exp
argument_list|)
expr_stmt|;
break|break;
case|case
name|O_left_shift
case|:
name|print_binary
argument_list|(
name|file
argument_list|,
literal|"lshift"
argument_list|,
name|exp
argument_list|)
expr_stmt|;
break|break;
case|case
name|O_right_shift
case|:
name|print_binary
argument_list|(
name|file
argument_list|,
literal|"rshift"
argument_list|,
name|exp
argument_list|)
expr_stmt|;
break|break;
case|case
name|O_bit_inclusive_or
case|:
name|print_binary
argument_list|(
name|file
argument_list|,
literal|"bit_ior"
argument_list|,
name|exp
argument_list|)
expr_stmt|;
break|break;
case|case
name|O_bit_exclusive_or
case|:
name|print_binary
argument_list|(
name|file
argument_list|,
literal|"bit_xor"
argument_list|,
name|exp
argument_list|)
expr_stmt|;
break|break;
case|case
name|O_bit_and
case|:
name|print_binary
argument_list|(
name|file
argument_list|,
literal|"bit_and"
argument_list|,
name|exp
argument_list|)
expr_stmt|;
break|break;
case|case
name|O_eq
case|:
name|print_binary
argument_list|(
name|file
argument_list|,
literal|"eq"
argument_list|,
name|exp
argument_list|)
expr_stmt|;
break|break;
case|case
name|O_ne
case|:
name|print_binary
argument_list|(
name|file
argument_list|,
literal|"ne"
argument_list|,
name|exp
argument_list|)
expr_stmt|;
break|break;
case|case
name|O_lt
case|:
name|print_binary
argument_list|(
name|file
argument_list|,
literal|"lt"
argument_list|,
name|exp
argument_list|)
expr_stmt|;
break|break;
case|case
name|O_le
case|:
name|print_binary
argument_list|(
name|file
argument_list|,
literal|"le"
argument_list|,
name|exp
argument_list|)
expr_stmt|;
break|break;
case|case
name|O_ge
case|:
name|print_binary
argument_list|(
name|file
argument_list|,
literal|"ge"
argument_list|,
name|exp
argument_list|)
expr_stmt|;
break|break;
case|case
name|O_gt
case|:
name|print_binary
argument_list|(
name|file
argument_list|,
literal|"gt"
argument_list|,
name|exp
argument_list|)
expr_stmt|;
break|break;
case|case
name|O_logical_and
case|:
name|print_binary
argument_list|(
name|file
argument_list|,
literal|"logical_and"
argument_list|,
name|exp
argument_list|)
expr_stmt|;
break|break;
case|case
name|O_logical_or
case|:
name|print_binary
argument_list|(
name|file
argument_list|,
literal|"logical_or"
argument_list|,
name|exp
argument_list|)
expr_stmt|;
break|break;
case|case
name|O_add
case|:
name|indent_level
operator|++
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"add\n%*s<"
argument_list|,
name|indent_level
operator|*
literal|4
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|print_symbol_value_1
argument_list|(
name|file
argument_list|,
name|exp
operator|->
name|X_add_symbol
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|">\n%*s<"
argument_list|,
name|indent_level
operator|*
literal|4
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|print_symbol_value_1
argument_list|(
name|file
argument_list|,
name|exp
operator|->
name|X_op_symbol
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|">"
argument_list|)
expr_stmt|;
goto|goto
name|maybe_print_addnum
goto|;
case|case
name|O_subtract
case|:
name|indent_level
operator|++
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"subtract\n%*s<"
argument_list|,
name|indent_level
operator|*
literal|4
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|print_symbol_value_1
argument_list|(
name|file
argument_list|,
name|exp
operator|->
name|X_add_symbol
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|">\n%*s<"
argument_list|,
name|indent_level
operator|*
literal|4
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|print_symbol_value_1
argument_list|(
name|file
argument_list|,
name|exp
operator|->
name|X_op_symbol
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|">"
argument_list|)
expr_stmt|;
goto|goto
name|maybe_print_addnum
goto|;
default|default:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"{unknown opcode %d}"
argument_list|,
operator|(
name|int
operator|)
name|exp
operator|->
name|X_op
argument_list|)
expr_stmt|;
break|break;
block|}
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|print_expr
parameter_list|(
name|exp
parameter_list|)
name|expressionS
modifier|*
name|exp
decl_stmt|;
block|{
name|print_expr_1
argument_list|(
name|stderr
argument_list|,
name|exp
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|symbol_print_statistics
parameter_list|(
name|file
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
block|{
name|hash_print_statistics
argument_list|(
name|file
argument_list|,
literal|"symbol table"
argument_list|,
name|sy_hash
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|BFD_ASSEMBLER
name|hash_print_statistics
argument_list|(
name|file
argument_list|,
literal|"mini local symbol table"
argument_list|,
name|local_hash
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%lu mini local symbols created, %lu converted\n"
argument_list|,
name|local_symbol_count
argument_list|,
name|local_symbol_conversion_count
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

end_unit

