begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* output-file.c -  Deal with the output file    Copyright 1987, 1990, 1991, 1992, 1993, 1994, 1996, 1998, 1999    Free Software Foundation, Inc.     This file is part of GAS, the GNU Assembler.     GAS is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     GAS is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with GAS; see the file COPYING.  If not, write to    the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"as.h"
end_include

begin_include
include|#
directive|include
file|"output-file.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|BFD_HEADERS
end_ifdef

begin_define
define|#
directive|define
name|USE_BFD
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|BFD_ASSEMBLER
end_ifdef

begin_define
define|#
directive|define
name|USE_BFD
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|TARGET_MACH
end_ifndef

begin_define
define|#
directive|define
name|TARGET_MACH
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|USE_BFD
end_ifdef

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_decl_stmt
name|bfd
modifier|*
name|stdoutput
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|output_file_create
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'-'
operator|&&
name|name
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
block|{
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"Can't open a bfd on stdout %s "
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|stdoutput
operator|=
name|bfd_openw
argument_list|(
name|name
argument_list|,
name|TARGET_FORMAT
argument_list|)
operator|)
condition|)
block|{
name|as_perror
argument_list|(
name|_
argument_list|(
literal|"FATAL: Can't create %s"
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
name|bfd_set_format
argument_list|(
name|stdoutput
argument_list|,
name|bfd_object
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|BFD_ASSEMBLER
name|bfd_set_arch_mach
argument_list|(
name|stdoutput
argument_list|,
name|TARGET_ARCH
argument_list|,
name|TARGET_MACH
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|flag_traditional_format
condition|)
name|stdoutput
operator|->
name|flags
operator||=
name|BFD_TRADITIONAL_FORMAT
expr_stmt|;
block|}
end_function

begin_function
name|void
name|output_file_close
parameter_list|(
name|filename
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|BFD_ASSEMBLER
comment|/* Close the bfd.  */
if|if
condition|(
name|bfd_close
argument_list|(
name|stdoutput
argument_list|)
operator|==
literal|0
condition|)
block|{
name|bfd_perror
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|as_perror
argument_list|(
name|_
argument_list|(
literal|"FATAL: Can't close %s\n"
argument_list|)
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
comment|/* Close the bfd without getting bfd to write out anything by itself */
if|if
condition|(
name|bfd_close_all_done
argument_list|(
name|stdoutput
argument_list|)
operator|==
literal|0
condition|)
block|{
name|as_perror
argument_list|(
name|_
argument_list|(
literal|"FATAL: Can't close %s\n"
argument_list|)
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|stdoutput
operator|=
name|NULL
expr_stmt|;
comment|/* Trust nobody! */
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|BFD_ASSEMBLER
end_ifndef

begin_function
name|void
name|output_file_append
parameter_list|(
name|where
parameter_list|,
name|length
parameter_list|,
name|filename
parameter_list|)
name|char
modifier|*
name|where
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|long
name|length
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|char
modifier|*
name|filename
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|stdoutput
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|output_file_create
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'-'
operator|&&
name|name
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
block|{
name|stdoutput
operator|=
name|stdout
expr_stmt|;
return|return;
block|}
name|stdoutput
operator|=
name|fopen
argument_list|(
name|name
argument_list|,
literal|"wb"
argument_list|)
expr_stmt|;
comment|/* Some systems don't grok "b" in fopen modes.  */
if|if
condition|(
name|stdoutput
operator|==
name|NULL
condition|)
name|stdoutput
operator|=
name|fopen
argument_list|(
name|name
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|stdoutput
operator|==
name|NULL
condition|)
block|{
name|as_perror
argument_list|(
name|_
argument_list|(
literal|"FATAL: Can't create %s"
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|output_file_close
parameter_list|(
name|filename
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
block|{
if|if
condition|(
name|EOF
operator|==
name|fclose
argument_list|(
name|stdoutput
argument_list|)
condition|)
block|{
name|as_perror
argument_list|(
name|_
argument_list|(
literal|"FATAL: Can't close %s"
argument_list|)
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
name|stdoutput
operator|=
name|NULL
expr_stmt|;
comment|/* Trust nobody! */
block|}
end_function

begin_function
name|void
name|output_file_append
parameter_list|(
name|where
parameter_list|,
name|length
parameter_list|,
name|filename
parameter_list|)
name|char
modifier|*
name|where
decl_stmt|;
name|long
name|length
decl_stmt|;
name|char
modifier|*
name|filename
decl_stmt|;
block|{
for|for
control|(
init|;
name|length
condition|;
name|length
operator|--
operator|,
name|where
operator|++
control|)
block|{
operator|(
name|void
operator|)
name|putc
argument_list|(
operator|*
name|where
argument_list|,
name|stdoutput
argument_list|)
expr_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|stdoutput
argument_list|)
condition|)
comment|/* if ( EOF == (putc( *where, stdoutput )) ) */
block|{
name|as_perror
argument_list|(
name|_
argument_list|(
literal|"Failed to emit an object byte"
argument_list|)
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|as_fatal
argument_list|(
name|_
argument_list|(
literal|"Can't continue"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* end of output-file.c */
end_comment

end_unit

