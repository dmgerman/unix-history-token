begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* sb.c - string buffer manipulation routines    Copyright 1994, 1995, 2000, 2003 Free Software Foundation, Inc.     Written by Steve and Judy Chamberlain of Cygnus Support,       sac@cygnus.com     This file is part of GAS, the GNU Assembler.     GAS is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     GAS is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with GAS; see the file COPYING.  If not, write to the Free    Software Foundation, 51 Franklin Street - Fifth Floor, Boston, MA    02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_STDLIB_H
end_ifdef

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_STRING_H
end_ifdef

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<strings.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"libiberty.h"
end_include

begin_include
include|#
directive|include
file|"sb.h"
end_include

begin_include
include|#
directive|include
file|"as.h"
end_include

begin_comment
comment|/* These routines are about manipulating strings.     They are managed in things called `sb's which is an abbreviation    for string buffers.  An sb has to be created, things can be glued    on to it, and at the end of it's life it should be freed.  The    contents should never be pointed at whilst it is still growing,    since it could be moved at any time     eg:    sb_new (&foo);    sb_grow... (&foo,...);    use foo->ptr[*];    sb_kill (&foo);  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|dsize
init|=
literal|5
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|sb_check
parameter_list|(
name|sb
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Statistics of sb structures.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|string_count
index|[
name|sb_max_power_two
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Free list of sb structures.  */
end_comment

begin_decl_stmt
specifier|static
name|sb_list_vector
name|free_list
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Initializes an sb.  */
end_comment

begin_function
specifier|static
name|void
name|sb_build
parameter_list|(
name|sb
modifier|*
name|ptr
parameter_list|,
name|int
name|size
parameter_list|)
block|{
comment|/* See if we can find one to allocate.  */
name|sb_element
modifier|*
name|e
decl_stmt|;
if|if
condition|(
name|size
operator|>
name|sb_max_power_two
condition|)
name|abort
argument_list|()
expr_stmt|;
name|e
operator|=
name|free_list
operator|.
name|size
index|[
name|size
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|e
condition|)
block|{
comment|/* Nothing there, allocate one and stick into the free list.  */
name|e
operator|=
operator|(
name|sb_element
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|sb_element
argument_list|)
operator|+
operator|(
literal|1
operator|<<
name|size
operator|)
argument_list|)
expr_stmt|;
name|e
operator|->
name|next
operator|=
name|free_list
operator|.
name|size
index|[
name|size
index|]
expr_stmt|;
name|e
operator|->
name|size
operator|=
literal|1
operator|<<
name|size
expr_stmt|;
name|free_list
operator|.
name|size
index|[
name|size
index|]
operator|=
name|e
expr_stmt|;
name|string_count
index|[
name|size
index|]
operator|++
expr_stmt|;
block|}
comment|/* Remove from free list.  */
name|free_list
operator|.
name|size
index|[
name|size
index|]
operator|=
name|e
operator|->
name|next
expr_stmt|;
comment|/* Copy into callers world.  */
name|ptr
operator|->
name|ptr
operator|=
name|e
operator|->
name|data
expr_stmt|;
name|ptr
operator|->
name|pot
operator|=
name|size
expr_stmt|;
name|ptr
operator|->
name|len
operator|=
literal|0
expr_stmt|;
name|ptr
operator|->
name|item
operator|=
name|e
expr_stmt|;
block|}
end_function

begin_function
name|void
name|sb_new
parameter_list|(
name|sb
modifier|*
name|ptr
parameter_list|)
block|{
name|sb_build
argument_list|(
name|ptr
argument_list|,
name|dsize
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Deallocate the sb at ptr.  */
end_comment

begin_function
name|void
name|sb_kill
parameter_list|(
name|sb
modifier|*
name|ptr
parameter_list|)
block|{
comment|/* Return item to free list.  */
name|ptr
operator|->
name|item
operator|->
name|next
operator|=
name|free_list
operator|.
name|size
index|[
name|ptr
operator|->
name|pot
index|]
expr_stmt|;
name|free_list
operator|.
name|size
index|[
name|ptr
operator|->
name|pot
index|]
operator|=
name|ptr
operator|->
name|item
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add the sb at s to the end of the sb at ptr.  */
end_comment

begin_function
name|void
name|sb_add_sb
parameter_list|(
name|sb
modifier|*
name|ptr
parameter_list|,
name|sb
modifier|*
name|s
parameter_list|)
block|{
name|sb_check
argument_list|(
name|ptr
argument_list|,
name|s
operator|->
name|len
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|ptr
operator|->
name|ptr
operator|+
name|ptr
operator|->
name|len
argument_list|,
name|s
operator|->
name|ptr
argument_list|,
name|s
operator|->
name|len
argument_list|)
expr_stmt|;
name|ptr
operator|->
name|len
operator|+=
name|s
operator|->
name|len
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Helper for sb_scrub_and_add_sb.  */
end_comment

begin_decl_stmt
specifier|static
name|sb
modifier|*
name|sb_to_scrub
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|scrub_position
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|scrub_from_sb
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|buflen
parameter_list|)
block|{
name|int
name|copy
decl_stmt|;
name|copy
operator|=
name|sb_to_scrub
operator|->
name|len
operator|-
operator|(
name|scrub_position
operator|-
name|sb_to_scrub
operator|->
name|ptr
operator|)
expr_stmt|;
if|if
condition|(
name|copy
operator|>
name|buflen
condition|)
name|copy
operator|=
name|buflen
expr_stmt|;
name|memcpy
argument_list|(
name|buf
argument_list|,
name|scrub_position
argument_list|,
name|copy
argument_list|)
expr_stmt|;
name|scrub_position
operator|+=
name|copy
expr_stmt|;
return|return
name|copy
return|;
block|}
end_function

begin_comment
comment|/* Run the sb at s through do_scrub_chars and add the result to the sb    at ptr.  */
end_comment

begin_function
name|void
name|sb_scrub_and_add_sb
parameter_list|(
name|sb
modifier|*
name|ptr
parameter_list|,
name|sb
modifier|*
name|s
parameter_list|)
block|{
name|sb_to_scrub
operator|=
name|s
expr_stmt|;
name|scrub_position
operator|=
name|s
operator|->
name|ptr
expr_stmt|;
name|sb_check
argument_list|(
name|ptr
argument_list|,
name|s
operator|->
name|len
argument_list|)
expr_stmt|;
name|ptr
operator|->
name|len
operator|+=
name|do_scrub_chars
argument_list|(
name|scrub_from_sb
argument_list|,
name|ptr
operator|->
name|ptr
operator|+
name|ptr
operator|->
name|len
argument_list|,
name|s
operator|->
name|len
argument_list|)
expr_stmt|;
name|sb_to_scrub
operator|=
literal|0
expr_stmt|;
name|scrub_position
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Make sure that the sb at ptr has room for another len characters,    and grow it if it doesn't.  */
end_comment

begin_function
specifier|static
name|void
name|sb_check
parameter_list|(
name|sb
modifier|*
name|ptr
parameter_list|,
name|int
name|len
parameter_list|)
block|{
if|if
condition|(
name|ptr
operator|->
name|len
operator|+
name|len
operator|>=
literal|1
operator|<<
name|ptr
operator|->
name|pot
condition|)
block|{
name|sb
name|tmp
decl_stmt|;
name|int
name|pot
init|=
name|ptr
operator|->
name|pot
decl_stmt|;
while|while
condition|(
name|ptr
operator|->
name|len
operator|+
name|len
operator|>=
literal|1
operator|<<
name|pot
condition|)
name|pot
operator|++
expr_stmt|;
name|sb_build
argument_list|(
operator|&
name|tmp
argument_list|,
name|pot
argument_list|)
expr_stmt|;
name|sb_add_sb
argument_list|(
operator|&
name|tmp
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
name|sb_kill
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
operator|*
name|ptr
operator|=
name|tmp
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Make the sb at ptr point back to the beginning.  */
end_comment

begin_function
name|void
name|sb_reset
parameter_list|(
name|sb
modifier|*
name|ptr
parameter_list|)
block|{
name|ptr
operator|->
name|len
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add character c to the end of the sb at ptr.  */
end_comment

begin_function
name|void
name|sb_add_char
parameter_list|(
name|sb
modifier|*
name|ptr
parameter_list|,
name|int
name|c
parameter_list|)
block|{
name|sb_check
argument_list|(
name|ptr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ptr
operator|->
name|ptr
index|[
name|ptr
operator|->
name|len
operator|++
index|]
operator|=
name|c
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add null terminated string s to the end of sb at ptr.  */
end_comment

begin_function
name|void
name|sb_add_string
parameter_list|(
name|sb
modifier|*
name|ptr
parameter_list|,
specifier|const
name|char
modifier|*
name|s
parameter_list|)
block|{
name|int
name|len
init|=
name|strlen
argument_list|(
name|s
argument_list|)
decl_stmt|;
name|sb_check
argument_list|(
name|ptr
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|ptr
operator|->
name|ptr
operator|+
name|ptr
operator|->
name|len
argument_list|,
name|s
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|ptr
operator|->
name|len
operator|+=
name|len
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add string at s of length len to sb at ptr */
end_comment

begin_function
name|void
name|sb_add_buffer
parameter_list|(
name|sb
modifier|*
name|ptr
parameter_list|,
specifier|const
name|char
modifier|*
name|s
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|sb_check
argument_list|(
name|ptr
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|ptr
operator|->
name|ptr
operator|+
name|ptr
operator|->
name|len
argument_list|,
name|s
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|ptr
operator|->
name|len
operator|+=
name|len
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Like sb_name, but don't include the null byte in the string.  */
end_comment

begin_function
name|char
modifier|*
name|sb_terminate
parameter_list|(
name|sb
modifier|*
name|in
parameter_list|)
block|{
name|sb_add_char
argument_list|(
name|in
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|--
name|in
operator|->
name|len
expr_stmt|;
return|return
name|in
operator|->
name|ptr
return|;
block|}
end_function

begin_comment
comment|/* Start at the index idx into the string in sb at ptr and skip    whitespace. return the index of the first non whitespace character.  */
end_comment

begin_function
name|int
name|sb_skip_white
parameter_list|(
name|int
name|idx
parameter_list|,
name|sb
modifier|*
name|ptr
parameter_list|)
block|{
while|while
condition|(
name|idx
operator|<
name|ptr
operator|->
name|len
operator|&&
operator|(
name|ptr
operator|->
name|ptr
index|[
name|idx
index|]
operator|==
literal|' '
operator|||
name|ptr
operator|->
name|ptr
index|[
name|idx
index|]
operator|==
literal|'\t'
operator|)
condition|)
name|idx
operator|++
expr_stmt|;
return|return
name|idx
return|;
block|}
end_function

begin_comment
comment|/* Start at the index idx into the sb at ptr. skips whitespace,    a comma and any following whitespace. returns the index of the    next character.  */
end_comment

begin_function
name|int
name|sb_skip_comma
parameter_list|(
name|int
name|idx
parameter_list|,
name|sb
modifier|*
name|ptr
parameter_list|)
block|{
while|while
condition|(
name|idx
operator|<
name|ptr
operator|->
name|len
operator|&&
operator|(
name|ptr
operator|->
name|ptr
index|[
name|idx
index|]
operator|==
literal|' '
operator|||
name|ptr
operator|->
name|ptr
index|[
name|idx
index|]
operator|==
literal|'\t'
operator|)
condition|)
name|idx
operator|++
expr_stmt|;
if|if
condition|(
name|idx
operator|<
name|ptr
operator|->
name|len
operator|&&
name|ptr
operator|->
name|ptr
index|[
name|idx
index|]
operator|==
literal|','
condition|)
name|idx
operator|++
expr_stmt|;
while|while
condition|(
name|idx
operator|<
name|ptr
operator|->
name|len
operator|&&
operator|(
name|ptr
operator|->
name|ptr
index|[
name|idx
index|]
operator|==
literal|' '
operator|||
name|ptr
operator|->
name|ptr
index|[
name|idx
index|]
operator|==
literal|'\t'
operator|)
condition|)
name|idx
operator|++
expr_stmt|;
return|return
name|idx
return|;
block|}
end_function

end_unit

