begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* sb.c - string buffer manipulation routines    Copyright 1994, 1995, 2000 Free Software Foundation, Inc.     Written by Steve and Judy Chamberlain of Cygnus Support,       sac@cygnus.com     This file is part of GAS, the GNU Assembler.     GAS is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     GAS is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with GAS; see the file COPYING.  If not, write to the Free    Software Foundation, 59 Temple Place - Suite 330, Boston, MA    02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_STDLIB_H
end_ifdef

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_STRING_H
end_ifdef

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<strings.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"libiberty.h"
end_include

begin_include
include|#
directive|include
file|"sb.h"
end_include

begin_comment
comment|/* These routines are about manipulating strings.     They are managed in things called `sb's which is an abbreviation    for string buffers.  An sb has to be created, things can be glued    on to it, and at the end of it's life it should be freed.  The    contents should never be pointed at whilst it is still growing,    since it could be moved at any time     eg:    sb_new (&foo);    sb_grow... (&foo,...);    use foo->ptr[*];    sb_kill (&foo);  */
end_comment

begin_define
define|#
directive|define
name|dsize
value|5
end_define

begin_decl_stmt
specifier|static
name|void
name|sb_check
name|PARAMS
argument_list|(
operator|(
name|sb
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Statistics of sb structures.  */
end_comment

begin_decl_stmt
name|int
name|string_count
index|[
name|sb_max_power_two
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Free list of sb structures.  */
end_comment

begin_decl_stmt
specifier|static
name|sb_list_vector
name|free_list
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* initializes an sb.  */
end_comment

begin_function
name|void
name|sb_build
parameter_list|(
name|ptr
parameter_list|,
name|size
parameter_list|)
name|sb
modifier|*
name|ptr
decl_stmt|;
name|int
name|size
decl_stmt|;
block|{
comment|/* see if we can find one to allocate */
name|sb_element
modifier|*
name|e
decl_stmt|;
if|if
condition|(
name|size
operator|>
name|sb_max_power_two
condition|)
name|abort
argument_list|()
expr_stmt|;
name|e
operator|=
name|free_list
operator|.
name|size
index|[
name|size
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|e
condition|)
block|{
comment|/* nothing there, allocate one and stick into the free list */
name|e
operator|=
operator|(
name|sb_element
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|sb_element
argument_list|)
operator|+
operator|(
literal|1
operator|<<
name|size
operator|)
argument_list|)
expr_stmt|;
name|e
operator|->
name|next
operator|=
name|free_list
operator|.
name|size
index|[
name|size
index|]
expr_stmt|;
name|e
operator|->
name|size
operator|=
literal|1
operator|<<
name|size
expr_stmt|;
name|free_list
operator|.
name|size
index|[
name|size
index|]
operator|=
name|e
expr_stmt|;
name|string_count
index|[
name|size
index|]
operator|++
expr_stmt|;
block|}
comment|/* remove from free list */
name|free_list
operator|.
name|size
index|[
name|size
index|]
operator|=
name|e
operator|->
name|next
expr_stmt|;
comment|/* copy into callers world */
name|ptr
operator|->
name|ptr
operator|=
name|e
operator|->
name|data
expr_stmt|;
name|ptr
operator|->
name|pot
operator|=
name|size
expr_stmt|;
name|ptr
operator|->
name|len
operator|=
literal|0
expr_stmt|;
name|ptr
operator|->
name|item
operator|=
name|e
expr_stmt|;
block|}
end_function

begin_function
name|void
name|sb_new
parameter_list|(
name|ptr
parameter_list|)
name|sb
modifier|*
name|ptr
decl_stmt|;
block|{
name|sb_build
argument_list|(
name|ptr
argument_list|,
name|dsize
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* deallocate the sb at ptr */
end_comment

begin_function
name|void
name|sb_kill
parameter_list|(
name|ptr
parameter_list|)
name|sb
modifier|*
name|ptr
decl_stmt|;
block|{
comment|/* return item to free list */
name|ptr
operator|->
name|item
operator|->
name|next
operator|=
name|free_list
operator|.
name|size
index|[
name|ptr
operator|->
name|pot
index|]
expr_stmt|;
name|free_list
operator|.
name|size
index|[
name|ptr
operator|->
name|pot
index|]
operator|=
name|ptr
operator|->
name|item
expr_stmt|;
block|}
end_function

begin_comment
comment|/* add the sb at s to the end of the sb at ptr */
end_comment

begin_function
name|void
name|sb_add_sb
parameter_list|(
name|ptr
parameter_list|,
name|s
parameter_list|)
name|sb
modifier|*
name|ptr
decl_stmt|;
name|sb
modifier|*
name|s
decl_stmt|;
block|{
name|sb_check
argument_list|(
name|ptr
argument_list|,
name|s
operator|->
name|len
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|ptr
operator|->
name|ptr
operator|+
name|ptr
operator|->
name|len
argument_list|,
name|s
operator|->
name|ptr
argument_list|,
name|s
operator|->
name|len
argument_list|)
expr_stmt|;
name|ptr
operator|->
name|len
operator|+=
name|s
operator|->
name|len
expr_stmt|;
block|}
end_function

begin_comment
comment|/* make sure that the sb at ptr has room for another len characters,    and grow it if it doesn't.  */
end_comment

begin_function
specifier|static
name|void
name|sb_check
parameter_list|(
name|ptr
parameter_list|,
name|len
parameter_list|)
name|sb
modifier|*
name|ptr
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
if|if
condition|(
name|ptr
operator|->
name|len
operator|+
name|len
operator|>=
literal|1
operator|<<
name|ptr
operator|->
name|pot
condition|)
block|{
name|sb
name|tmp
decl_stmt|;
name|int
name|pot
init|=
name|ptr
operator|->
name|pot
decl_stmt|;
while|while
condition|(
name|ptr
operator|->
name|len
operator|+
name|len
operator|>=
literal|1
operator|<<
name|pot
condition|)
name|pot
operator|++
expr_stmt|;
name|sb_build
argument_list|(
operator|&
name|tmp
argument_list|,
name|pot
argument_list|)
expr_stmt|;
name|sb_add_sb
argument_list|(
operator|&
name|tmp
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
name|sb_kill
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
operator|*
name|ptr
operator|=
name|tmp
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* make the sb at ptr point back to the beginning.  */
end_comment

begin_function
name|void
name|sb_reset
parameter_list|(
name|ptr
parameter_list|)
name|sb
modifier|*
name|ptr
decl_stmt|;
block|{
name|ptr
operator|->
name|len
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* add character c to the end of the sb at ptr.  */
end_comment

begin_function
name|void
name|sb_add_char
parameter_list|(
name|ptr
parameter_list|,
name|c
parameter_list|)
name|sb
modifier|*
name|ptr
decl_stmt|;
name|int
name|c
decl_stmt|;
block|{
name|sb_check
argument_list|(
name|ptr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ptr
operator|->
name|ptr
index|[
name|ptr
operator|->
name|len
operator|++
index|]
operator|=
name|c
expr_stmt|;
block|}
end_function

begin_comment
comment|/* add null terminated string s to the end of sb at ptr.  */
end_comment

begin_function
name|void
name|sb_add_string
parameter_list|(
name|ptr
parameter_list|,
name|s
parameter_list|)
name|sb
modifier|*
name|ptr
decl_stmt|;
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|int
name|len
init|=
name|strlen
argument_list|(
name|s
argument_list|)
decl_stmt|;
name|sb_check
argument_list|(
name|ptr
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|ptr
operator|->
name|ptr
operator|+
name|ptr
operator|->
name|len
argument_list|,
name|s
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|ptr
operator|->
name|len
operator|+=
name|len
expr_stmt|;
block|}
end_function

begin_comment
comment|/* add string at s of length len to sb at ptr */
end_comment

begin_function
name|void
name|sb_add_buffer
parameter_list|(
name|ptr
parameter_list|,
name|s
parameter_list|,
name|len
parameter_list|)
name|sb
modifier|*
name|ptr
decl_stmt|;
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|sb_check
argument_list|(
name|ptr
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|ptr
operator|->
name|ptr
operator|+
name|ptr
operator|->
name|len
argument_list|,
name|s
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|ptr
operator|->
name|len
operator|+=
name|len
expr_stmt|;
block|}
end_function

begin_comment
comment|/* print the sb at ptr to the output file */
end_comment

begin_function
name|void
name|sb_print
parameter_list|(
name|outfile
parameter_list|,
name|ptr
parameter_list|)
name|FILE
modifier|*
name|outfile
decl_stmt|;
name|sb
modifier|*
name|ptr
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|int
name|nc
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ptr
operator|->
name|len
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|nc
condition|)
block|{
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|","
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"%d"
argument_list|,
name|ptr
operator|->
name|ptr
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|nc
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|sb_print_at
parameter_list|(
name|outfile
parameter_list|,
name|idx
parameter_list|,
name|ptr
parameter_list|)
name|FILE
modifier|*
name|outfile
decl_stmt|;
name|int
name|idx
decl_stmt|;
name|sb
modifier|*
name|ptr
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|idx
init|;
name|i
operator|<
name|ptr
operator|->
name|len
condition|;
name|i
operator|++
control|)
name|putc
argument_list|(
name|ptr
operator|->
name|ptr
index|[
name|i
index|]
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* put a null at the end of the sb at in and return the start of the    string, so that it can be used as an arg to printf %s.  */
end_comment

begin_function
name|char
modifier|*
name|sb_name
parameter_list|(
name|in
parameter_list|)
name|sb
modifier|*
name|in
decl_stmt|;
block|{
comment|/* stick a null on the end of the string */
name|sb_add_char
argument_list|(
name|in
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|in
operator|->
name|ptr
return|;
block|}
end_function

begin_comment
comment|/* like sb_name, but don't include the null byte in the string.  */
end_comment

begin_function
name|char
modifier|*
name|sb_terminate
parameter_list|(
name|in
parameter_list|)
name|sb
modifier|*
name|in
decl_stmt|;
block|{
name|sb_add_char
argument_list|(
name|in
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|--
name|in
operator|->
name|len
expr_stmt|;
return|return
name|in
operator|->
name|ptr
return|;
block|}
end_function

begin_comment
comment|/* start at the index idx into the string in sb at ptr and skip    whitespace. return the index of the first non whitespace character */
end_comment

begin_function
name|int
name|sb_skip_white
parameter_list|(
name|idx
parameter_list|,
name|ptr
parameter_list|)
name|int
name|idx
decl_stmt|;
name|sb
modifier|*
name|ptr
decl_stmt|;
block|{
while|while
condition|(
name|idx
operator|<
name|ptr
operator|->
name|len
operator|&&
operator|(
name|ptr
operator|->
name|ptr
index|[
name|idx
index|]
operator|==
literal|' '
operator|||
name|ptr
operator|->
name|ptr
index|[
name|idx
index|]
operator|==
literal|'\t'
operator|)
condition|)
name|idx
operator|++
expr_stmt|;
return|return
name|idx
return|;
block|}
end_function

begin_comment
comment|/* start at the index idx into the sb at ptr. skips whitespace,    a comma and any following whitespace. returnes the index of the    next character.  */
end_comment

begin_function
name|int
name|sb_skip_comma
parameter_list|(
name|idx
parameter_list|,
name|ptr
parameter_list|)
name|int
name|idx
decl_stmt|;
name|sb
modifier|*
name|ptr
decl_stmt|;
block|{
while|while
condition|(
name|idx
operator|<
name|ptr
operator|->
name|len
operator|&&
operator|(
name|ptr
operator|->
name|ptr
index|[
name|idx
index|]
operator|==
literal|' '
operator|||
name|ptr
operator|->
name|ptr
index|[
name|idx
index|]
operator|==
literal|'\t'
operator|)
condition|)
name|idx
operator|++
expr_stmt|;
if|if
condition|(
name|idx
operator|<
name|ptr
operator|->
name|len
operator|&&
name|ptr
operator|->
name|ptr
index|[
name|idx
index|]
operator|==
literal|','
condition|)
name|idx
operator|++
expr_stmt|;
while|while
condition|(
name|idx
operator|<
name|ptr
operator|->
name|len
operator|&&
operator|(
name|ptr
operator|->
name|ptr
index|[
name|idx
index|]
operator|==
literal|' '
operator|||
name|ptr
operator|->
name|ptr
index|[
name|idx
index|]
operator|==
literal|'\t'
operator|)
condition|)
name|idx
operator|++
expr_stmt|;
return|return
name|idx
return|;
block|}
end_function

end_unit

