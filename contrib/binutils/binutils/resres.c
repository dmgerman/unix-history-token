begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* resres.c: read_res_file and write_res_file implementation for windres.    Copyright 1998, 1999 Free Software Foundation, Inc.    Written by Anders Norlander<anorland@hem2.passagen.se>.     This file is part of GNU Binutils.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA    02111-1307, USA.  */
end_comment

begin_comment
comment|/* FIXME: This file does not work correctly in a cross configuration.    It assumes that it can use fread and fwrite to read and write    integers.  It does no swapping.  */
end_comment

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"bucomm.h"
end_include

begin_include
include|#
directive|include
file|"libiberty.h"
end_include

begin_include
include|#
directive|include
file|"windres.h"
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_struct
struct|struct
name|res_hdr
block|{
name|unsigned
name|long
name|data_size
decl_stmt|;
name|unsigned
name|long
name|header_size
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|void
name|write_res_directory
name|PARAMS
argument_list|(
operator|(
specifier|const
expr|struct
name|res_directory
operator|*
operator|,
specifier|const
expr|struct
name|res_id
operator|*
operator|,
specifier|const
expr|struct
name|res_id
operator|*
operator|,
name|int
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|write_res_resource
name|PARAMS
argument_list|(
operator|(
specifier|const
expr|struct
name|res_id
operator|*
operator|,
specifier|const
expr|struct
name|res_id
operator|*
operator|,
specifier|const
expr|struct
name|res_resource
operator|*
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|write_res_bin
name|PARAMS
argument_list|(
operator|(
specifier|const
expr|struct
name|res_resource
operator|*
operator|,
specifier|const
expr|struct
name|res_id
operator|*
operator|,
specifier|const
expr|struct
name|res_id
operator|*
operator|,
specifier|const
expr|struct
name|res_res_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|write_res_id
name|PARAMS
argument_list|(
operator|(
specifier|const
expr|struct
name|res_id
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|write_res_info
name|PARAMS
argument_list|(
operator|(
specifier|const
expr|struct
name|res_res_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|write_res_data
name|PARAMS
argument_list|(
operator|(
specifier|const
name|void
operator|*
operator|,
name|size_t
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|write_res_header
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|long
operator|,
specifier|const
expr|struct
name|res_id
operator|*
operator|,
specifier|const
expr|struct
name|res_id
operator|*
operator|,
specifier|const
expr|struct
name|res_res_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|read_resource_entry
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|read_res_data
name|PARAMS
argument_list|(
operator|(
name|void
operator|*
operator|,
name|size_t
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|read_res_id
name|PARAMS
argument_list|(
operator|(
expr|struct
name|res_id
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unichar
modifier|*
name|read_unistring
name|PARAMS
argument_list|(
operator|(
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|skip_null_resource
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|long
name|get_id_size
name|PARAMS
argument_list|(
operator|(
specifier|const
expr|struct
name|res_id
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|res_align_file
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|res_add_resource
name|PARAMS
argument_list|(
operator|(
expr|struct
name|res_resource
operator|*
operator|,
specifier|const
expr|struct
name|res_id
operator|*
operator|,
specifier|const
expr|struct
name|res_id
operator|*
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|res_append_resource
name|PARAMS
argument_list|(
operator|(
expr|struct
name|res_directory
operator|*
operator|*
operator|,
expr|struct
name|res_resource
operator|*
operator|,
name|int
operator|,
specifier|const
expr|struct
name|res_id
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|res_directory
modifier|*
name|resources
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|fres
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|filename
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|program_name
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Read resource file */
end_comment

begin_function
name|struct
name|res_directory
modifier|*
name|read_res_file
parameter_list|(
name|fn
parameter_list|)
specifier|const
name|char
modifier|*
name|fn
decl_stmt|;
block|{
name|filename
operator|=
name|fn
expr_stmt|;
name|fres
operator|=
name|fopen
argument_list|(
name|filename
argument_list|,
literal|"rb"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fres
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
literal|"can't open `%s' for output: %s"
argument_list|,
name|filename
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|skip_null_resource
argument_list|()
expr_stmt|;
while|while
condition|(
name|read_resource_entry
argument_list|()
condition|)
empty_stmt|;
name|fclose
argument_list|(
name|fres
argument_list|)
expr_stmt|;
return|return
name|resources
return|;
block|}
end_function

begin_comment
comment|/* Write resource file */
end_comment

begin_function
name|void
name|write_res_file
parameter_list|(
name|fn
parameter_list|,
name|resdir
parameter_list|)
specifier|const
name|char
modifier|*
name|fn
decl_stmt|;
specifier|const
name|struct
name|res_directory
modifier|*
name|resdir
decl_stmt|;
block|{
name|int
name|language
decl_stmt|;
specifier|static
specifier|const
name|unsigned
name|char
name|sign
index|[]
init|=
block|{
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x20
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0xFF
block|,
literal|0xFF
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0xFF
block|,
literal|0xFF
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|}
decl_stmt|;
name|long
name|fpos
decl_stmt|;
name|filename
operator|=
name|fn
expr_stmt|;
name|fres
operator|=
name|fopen
argument_list|(
name|filename
argument_list|,
literal|"wb"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fres
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
literal|"can't open `%s' for output: %s"
argument_list|,
name|filename
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Write 32 bit resource signature */
name|write_res_data
argument_list|(
name|sign
argument_list|,
sizeof|sizeof
argument_list|(
name|sign
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* write resources */
name|language
operator|=
operator|-
literal|1
expr_stmt|;
name|write_res_directory
argument_list|(
name|resdir
argument_list|,
operator|(
specifier|const
expr|struct
name|res_id
operator|*
operator|)
name|NULL
argument_list|,
operator|(
specifier|const
expr|struct
name|res_id
operator|*
operator|)
name|NULL
argument_list|,
operator|&
name|language
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* end file on DWORD boundary */
name|fpos
operator|=
name|ftell
argument_list|(
name|fres
argument_list|)
expr_stmt|;
if|if
condition|(
name|fpos
operator|%
literal|4
condition|)
name|write_res_data
argument_list|(
name|sign
argument_list|,
name|fpos
operator|%
literal|4
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|fres
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Read a resource entry, returns 0 when all resources are read */
end_comment

begin_function
specifier|static
name|int
name|read_resource_entry
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|res_id
name|type
decl_stmt|;
name|struct
name|res_id
name|name
decl_stmt|;
name|struct
name|res_res_info
name|resinfo
decl_stmt|;
name|struct
name|res_hdr
name|reshdr
decl_stmt|;
name|long
name|version
decl_stmt|;
name|void
modifier|*
name|buff
decl_stmt|;
name|struct
name|res_resource
modifier|*
name|r
decl_stmt|;
name|res_align_file
argument_list|()
expr_stmt|;
comment|/* Read header */
if|if
condition|(
name|fread
argument_list|(
operator|&
name|reshdr
argument_list|,
sizeof|sizeof
argument_list|(
name|reshdr
argument_list|)
argument_list|,
literal|1
argument_list|,
name|fres
argument_list|)
operator|!=
literal|1
condition|)
return|return
literal|0
return|;
comment|/* read resource type */
name|read_res_id
argument_list|(
operator|&
name|type
argument_list|)
expr_stmt|;
comment|/* read resource id */
name|read_res_id
argument_list|(
operator|&
name|name
argument_list|)
expr_stmt|;
name|res_align_file
argument_list|()
expr_stmt|;
comment|/* Read additional resource header */
name|read_res_data
argument_list|(
operator|&
name|resinfo
operator|.
name|version
argument_list|,
sizeof|sizeof
argument_list|(
name|resinfo
operator|.
name|version
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|read_res_data
argument_list|(
operator|&
name|resinfo
operator|.
name|memflags
argument_list|,
sizeof|sizeof
argument_list|(
name|resinfo
operator|.
name|memflags
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|read_res_data
argument_list|(
operator|&
name|resinfo
operator|.
name|language
argument_list|,
sizeof|sizeof
argument_list|(
name|resinfo
operator|.
name|language
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|read_res_data
argument_list|(
operator|&
name|version
argument_list|,
sizeof|sizeof
argument_list|(
name|version
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|read_res_data
argument_list|(
operator|&
name|resinfo
operator|.
name|characteristics
argument_list|,
sizeof|sizeof
argument_list|(
name|resinfo
operator|.
name|characteristics
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|res_align_file
argument_list|()
expr_stmt|;
comment|/* Allocate buffer for data */
name|buff
operator|=
name|res_alloc
argument_list|(
name|reshdr
operator|.
name|data_size
argument_list|)
expr_stmt|;
comment|/* Read data */
name|read_res_data
argument_list|(
name|buff
argument_list|,
name|reshdr
operator|.
name|data_size
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Convert binary data to resource */
name|r
operator|=
name|bin_to_res
argument_list|(
name|type
argument_list|,
name|buff
argument_list|,
name|reshdr
operator|.
name|data_size
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|r
operator|->
name|res_info
operator|=
name|resinfo
expr_stmt|;
comment|/* Add resource to resource directory */
name|res_add_resource
argument_list|(
name|r
argument_list|,
operator|&
name|type
argument_list|,
operator|&
name|name
argument_list|,
name|resinfo
operator|.
name|language
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* write resource directory to binary resource file */
end_comment

begin_function
specifier|static
name|void
name|write_res_directory
parameter_list|(
name|rd
parameter_list|,
name|type
parameter_list|,
name|name
parameter_list|,
name|language
parameter_list|,
name|level
parameter_list|)
specifier|const
name|struct
name|res_directory
modifier|*
name|rd
decl_stmt|;
specifier|const
name|struct
name|res_id
modifier|*
name|type
decl_stmt|;
specifier|const
name|struct
name|res_id
modifier|*
name|name
decl_stmt|;
name|int
modifier|*
name|language
decl_stmt|;
name|int
name|level
decl_stmt|;
block|{
specifier|const
name|struct
name|res_entry
modifier|*
name|re
decl_stmt|;
for|for
control|(
name|re
operator|=
name|rd
operator|->
name|entries
init|;
name|re
operator|!=
name|NULL
condition|;
name|re
operator|=
name|re
operator|->
name|next
control|)
block|{
switch|switch
condition|(
name|level
condition|)
block|{
case|case
literal|1
case|:
comment|/* If we're at level 1, the key of this resource is the 	     type.  This normally duplicates the information we have 	     stored with the resource itself, but we need to remember 	     the type if this is a user define resource type.  */
name|type
operator|=
operator|&
name|re
operator|->
name|id
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|/* If we're at level 2, the key of this resource is the name 	     we are going to use in the rc printout. */
name|name
operator|=
operator|&
name|re
operator|->
name|id
expr_stmt|;
break|break;
case|case
literal|3
case|:
comment|/* If we're at level 3, then this key represents a language. 	     Use it to update the current language.  */
if|if
condition|(
operator|!
name|re
operator|->
name|id
operator|.
name|named
operator|&&
name|re
operator|->
name|id
operator|.
name|u
operator|.
name|id
operator|!=
operator|(
name|unsigned
name|long
operator|)
operator|*
name|language
operator|&&
operator|(
name|re
operator|->
name|id
operator|.
name|u
operator|.
name|id
operator|&
literal|0xffff
operator|)
operator|==
name|re
operator|->
name|id
operator|.
name|u
operator|.
name|id
condition|)
block|{
operator|*
name|language
operator|=
name|re
operator|->
name|id
operator|.
name|u
operator|.
name|id
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
if|if
condition|(
name|re
operator|->
name|subdir
condition|)
name|write_res_directory
argument_list|(
name|re
operator|->
name|u
operator|.
name|dir
argument_list|,
name|type
argument_list|,
name|name
argument_list|,
name|language
argument_list|,
name|level
operator|+
literal|1
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|level
operator|==
literal|3
condition|)
block|{
comment|/* This is the normal case: the three levels are 	         TYPE/NAME/LANGUAGE.  NAME will have been set at level 	         2, and represents the name to use.  We probably just 	         set LANGUAGE, and it will probably match what the 	         resource itself records if anything.  */
name|write_res_resource
argument_list|(
name|type
argument_list|,
name|name
argument_list|,
name|re
operator|->
name|u
operator|.
name|res
argument_list|,
name|language
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"// Resource at unexpected level %d\n"
argument_list|,
name|level
argument_list|)
expr_stmt|;
name|write_res_resource
argument_list|(
name|type
argument_list|,
operator|(
expr|struct
name|res_id
operator|*
operator|)
name|NULL
argument_list|,
name|re
operator|->
name|u
operator|.
name|res
argument_list|,
name|language
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|write_res_resource
parameter_list|(
name|type
parameter_list|,
name|name
parameter_list|,
name|res
parameter_list|,
name|language
parameter_list|)
specifier|const
name|struct
name|res_id
modifier|*
name|type
decl_stmt|;
specifier|const
name|struct
name|res_id
modifier|*
name|name
decl_stmt|;
specifier|const
name|struct
name|res_resource
modifier|*
name|res
decl_stmt|;
name|int
modifier|*
name|language
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|int
name|rt
decl_stmt|;
switch|switch
condition|(
name|res
operator|->
name|type
condition|)
block|{
default|default:
name|abort
argument_list|()
expr_stmt|;
case|case
name|RES_TYPE_ACCELERATOR
case|:
name|rt
operator|=
name|RT_ACCELERATOR
expr_stmt|;
break|break;
case|case
name|RES_TYPE_BITMAP
case|:
name|rt
operator|=
name|RT_BITMAP
expr_stmt|;
break|break;
case|case
name|RES_TYPE_CURSOR
case|:
name|rt
operator|=
name|RT_CURSOR
expr_stmt|;
break|break;
case|case
name|RES_TYPE_GROUP_CURSOR
case|:
name|rt
operator|=
name|RT_GROUP_CURSOR
expr_stmt|;
break|break;
case|case
name|RES_TYPE_DIALOG
case|:
name|rt
operator|=
name|RT_DIALOG
expr_stmt|;
break|break;
case|case
name|RES_TYPE_FONT
case|:
name|rt
operator|=
name|RT_FONT
expr_stmt|;
break|break;
case|case
name|RES_TYPE_FONTDIR
case|:
name|rt
operator|=
name|RT_FONTDIR
expr_stmt|;
break|break;
case|case
name|RES_TYPE_ICON
case|:
name|rt
operator|=
name|RT_ICON
expr_stmt|;
break|break;
case|case
name|RES_TYPE_GROUP_ICON
case|:
name|rt
operator|=
name|RT_GROUP_ICON
expr_stmt|;
break|break;
case|case
name|RES_TYPE_MENU
case|:
name|rt
operator|=
name|RT_MENU
expr_stmt|;
break|break;
case|case
name|RES_TYPE_MESSAGETABLE
case|:
name|rt
operator|=
name|RT_MESSAGETABLE
expr_stmt|;
break|break;
case|case
name|RES_TYPE_RCDATA
case|:
name|rt
operator|=
name|RT_RCDATA
expr_stmt|;
break|break;
case|case
name|RES_TYPE_STRINGTABLE
case|:
name|rt
operator|=
name|RT_STRING
expr_stmt|;
break|break;
case|case
name|RES_TYPE_USERDATA
case|:
name|rt
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|RES_TYPE_VERSIONINFO
case|:
name|rt
operator|=
name|RT_VERSION
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|rt
operator|!=
literal|0
operator|&&
name|type
operator|!=
name|NULL
operator|&&
operator|(
name|type
operator|->
name|named
operator|||
name|type
operator|->
name|u
operator|.
name|id
operator|!=
operator|(
name|unsigned
name|long
operator|)
name|rt
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"// Unexpected resource type mismatch: "
argument_list|)
expr_stmt|;
name|res_id_print
argument_list|(
name|stderr
argument_list|,
operator|*
name|type
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" != %d"
argument_list|,
name|rt
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
name|write_res_bin
argument_list|(
name|res
argument_list|,
name|type
argument_list|,
name|name
argument_list|,
operator|&
name|res
operator|->
name|res_info
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* Write a resource in binary resource format */
end_comment

begin_function
specifier|static
name|void
name|write_res_bin
parameter_list|(
name|res
parameter_list|,
name|type
parameter_list|,
name|name
parameter_list|,
name|resinfo
parameter_list|)
specifier|const
name|struct
name|res_resource
modifier|*
name|res
decl_stmt|;
specifier|const
name|struct
name|res_id
modifier|*
name|type
decl_stmt|;
specifier|const
name|struct
name|res_id
modifier|*
name|name
decl_stmt|;
specifier|const
name|struct
name|res_res_info
modifier|*
name|resinfo
decl_stmt|;
block|{
name|unsigned
name|long
name|datasize
init|=
literal|0
decl_stmt|;
specifier|const
name|struct
name|bindata
modifier|*
name|bin_rep
decl_stmt|,
modifier|*
name|data
decl_stmt|;
name|bin_rep
operator|=
name|res_to_bin
argument_list|(
name|res
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|data
operator|=
name|bin_rep
init|;
name|data
operator|!=
name|NULL
condition|;
name|data
operator|=
name|data
operator|->
name|next
control|)
name|datasize
operator|+=
name|data
operator|->
name|length
expr_stmt|;
name|write_res_header
argument_list|(
name|datasize
argument_list|,
name|type
argument_list|,
name|name
argument_list|,
name|resinfo
argument_list|)
expr_stmt|;
for|for
control|(
name|data
operator|=
name|bin_rep
init|;
name|data
operator|!=
name|NULL
condition|;
name|data
operator|=
name|data
operator|->
name|next
control|)
name|write_res_data
argument_list|(
name|data
operator|->
name|data
argument_list|,
name|data
operator|->
name|length
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Get number of bytes needed to store an id in binary format */
end_comment

begin_function
specifier|static
name|unsigned
name|long
name|get_id_size
parameter_list|(
name|id
parameter_list|)
specifier|const
name|struct
name|res_id
modifier|*
name|id
decl_stmt|;
block|{
if|if
condition|(
name|id
operator|->
name|named
condition|)
return|return
sizeof|sizeof
argument_list|(
name|unichar
argument_list|)
operator|*
operator|(
name|id
operator|->
name|u
operator|.
name|n
operator|.
name|length
operator|+
literal|1
operator|)
return|;
else|else
return|return
sizeof|sizeof
argument_list|(
name|unichar
argument_list|)
operator|*
literal|2
return|;
block|}
end_function

begin_comment
comment|/* Write a resource header */
end_comment

begin_function
specifier|static
name|void
name|write_res_header
parameter_list|(
name|datasize
parameter_list|,
name|type
parameter_list|,
name|name
parameter_list|,
name|resinfo
parameter_list|)
name|unsigned
name|long
name|datasize
decl_stmt|;
specifier|const
name|struct
name|res_id
modifier|*
name|type
decl_stmt|;
specifier|const
name|struct
name|res_id
modifier|*
name|name
decl_stmt|;
specifier|const
name|struct
name|res_res_info
modifier|*
name|resinfo
decl_stmt|;
block|{
name|struct
name|res_hdr
name|reshdr
decl_stmt|;
name|reshdr
operator|.
name|data_size
operator|=
name|datasize
expr_stmt|;
name|reshdr
operator|.
name|header_size
operator|=
literal|24
operator|+
name|get_id_size
argument_list|(
name|type
argument_list|)
operator|+
name|get_id_size
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|res_align_file
argument_list|()
expr_stmt|;
name|write_res_data
argument_list|(
operator|&
name|reshdr
argument_list|,
sizeof|sizeof
argument_list|(
name|reshdr
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|write_res_id
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|write_res_id
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|res_align_file
argument_list|()
expr_stmt|;
name|write_res_info
argument_list|(
name|resinfo
argument_list|)
expr_stmt|;
name|res_align_file
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Write data to file, abort on failure */
end_comment

begin_function
specifier|static
name|void
name|write_res_data
parameter_list|(
name|data
parameter_list|,
name|size
parameter_list|,
name|count
parameter_list|)
specifier|const
name|void
modifier|*
name|data
decl_stmt|;
name|size_t
name|size
decl_stmt|;
name|int
name|count
decl_stmt|;
block|{
if|if
condition|(
name|fwrite
argument_list|(
name|data
argument_list|,
name|size
argument_list|,
name|count
argument_list|,
name|fres
argument_list|)
operator|!=
operator|(
name|size_t
operator|)
name|count
condition|)
name|fatal
argument_list|(
literal|"%s: could not write to file"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Read data from file, abort on failure */
end_comment

begin_function
specifier|static
name|void
name|read_res_data
parameter_list|(
name|data
parameter_list|,
name|size
parameter_list|,
name|count
parameter_list|)
name|void
modifier|*
name|data
decl_stmt|;
name|size_t
name|size
decl_stmt|;
name|int
name|count
decl_stmt|;
block|{
if|if
condition|(
name|fread
argument_list|(
name|data
argument_list|,
name|size
argument_list|,
name|count
argument_list|,
name|fres
argument_list|)
operator|!=
operator|(
name|size_t
operator|)
name|count
condition|)
name|fatal
argument_list|(
literal|"%s: unexpected end of file"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Write a resource id */
end_comment

begin_function
specifier|static
name|void
name|write_res_id
parameter_list|(
name|id
parameter_list|)
specifier|const
name|struct
name|res_id
modifier|*
name|id
decl_stmt|;
block|{
if|if
condition|(
name|id
operator|->
name|named
condition|)
block|{
name|unsigned
name|long
name|len
init|=
name|id
operator|->
name|u
operator|.
name|n
operator|.
name|length
decl_stmt|;
name|unichar
name|null_term
init|=
literal|0
decl_stmt|;
name|write_res_data
argument_list|(
name|id
operator|->
name|u
operator|.
name|n
operator|.
name|name
argument_list|,
name|len
operator|*
sizeof|sizeof
argument_list|(
name|unichar
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|write_res_data
argument_list|(
operator|&
name|null_term
argument_list|,
sizeof|sizeof
argument_list|(
name|null_term
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|unsigned
name|short
name|i
init|=
literal|0xFFFF
decl_stmt|;
name|write_res_data
argument_list|(
operator|&
name|i
argument_list|,
sizeof|sizeof
argument_list|(
name|i
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|i
operator|=
name|id
operator|->
name|u
operator|.
name|id
expr_stmt|;
name|write_res_data
argument_list|(
operator|&
name|i
argument_list|,
sizeof|sizeof
argument_list|(
name|i
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Write resource info */
end_comment

begin_function
specifier|static
name|void
name|write_res_info
parameter_list|(
name|info
parameter_list|)
specifier|const
name|struct
name|res_res_info
modifier|*
name|info
decl_stmt|;
block|{
name|write_res_data
argument_list|(
operator|&
name|info
operator|->
name|version
argument_list|,
sizeof|sizeof
argument_list|(
name|info
operator|->
name|version
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|write_res_data
argument_list|(
operator|&
name|info
operator|->
name|memflags
argument_list|,
sizeof|sizeof
argument_list|(
name|info
operator|->
name|memflags
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|write_res_data
argument_list|(
operator|&
name|info
operator|->
name|language
argument_list|,
sizeof|sizeof
argument_list|(
name|info
operator|->
name|language
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|write_res_data
argument_list|(
operator|&
name|info
operator|->
name|version
argument_list|,
sizeof|sizeof
argument_list|(
name|info
operator|->
name|version
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|write_res_data
argument_list|(
operator|&
name|info
operator|->
name|characteristics
argument_list|,
sizeof|sizeof
argument_list|(
name|info
operator|->
name|characteristics
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* read a resource identifier */
end_comment

begin_function
name|void
name|read_res_id
parameter_list|(
name|id
parameter_list|)
name|struct
name|res_id
modifier|*
name|id
decl_stmt|;
block|{
name|unsigned
name|short
name|ord
decl_stmt|;
name|unichar
modifier|*
name|id_s
init|=
name|NULL
decl_stmt|;
name|int
name|len
decl_stmt|;
name|read_res_data
argument_list|(
operator|&
name|ord
argument_list|,
sizeof|sizeof
argument_list|(
name|ord
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ord
operator|==
literal|0xFFFF
condition|)
comment|/* an ordinal id */
block|{
name|read_res_data
argument_list|(
operator|&
name|ord
argument_list|,
sizeof|sizeof
argument_list|(
name|ord
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|id
operator|->
name|named
operator|=
literal|0
expr_stmt|;
name|id
operator|->
name|u
operator|.
name|id
operator|=
name|ord
expr_stmt|;
block|}
else|else
comment|/* named id */
block|{
if|if
condition|(
name|fseek
argument_list|(
name|fres
argument_list|,
operator|-
sizeof|sizeof
argument_list|(
name|ord
argument_list|)
argument_list|,
name|SEEK_CUR
argument_list|)
operator|!=
literal|0
condition|)
name|fatal
argument_list|(
literal|"%s: %s: could not seek in file"
argument_list|,
name|program_name
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|id_s
operator|=
name|read_unistring
argument_list|(
operator|&
name|len
argument_list|)
expr_stmt|;
name|id
operator|->
name|named
operator|=
literal|1
expr_stmt|;
name|id
operator|->
name|u
operator|.
name|n
operator|.
name|length
operator|=
name|len
expr_stmt|;
name|id
operator|->
name|u
operator|.
name|n
operator|.
name|name
operator|=
name|id_s
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Read a null terminated UNICODE string */
end_comment

begin_function
specifier|static
name|unichar
modifier|*
name|read_unistring
parameter_list|(
name|len
parameter_list|)
name|int
modifier|*
name|len
decl_stmt|;
block|{
name|unichar
modifier|*
name|s
decl_stmt|;
name|unichar
name|c
decl_stmt|;
name|unichar
modifier|*
name|p
decl_stmt|;
name|int
name|l
decl_stmt|;
operator|*
name|len
operator|=
literal|0
expr_stmt|;
name|l
operator|=
literal|0
expr_stmt|;
comment|/* there are hardly any names longer than 256 characters */
name|p
operator|=
name|s
operator|=
operator|(
name|unichar
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|unichar
argument_list|)
operator|*
literal|256
argument_list|)
expr_stmt|;
do|do
block|{
name|read_res_data
argument_list|(
operator|&
name|c
argument_list|,
sizeof|sizeof
argument_list|(
name|c
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|0
condition|)
name|l
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|c
operator|!=
literal|0
condition|)
do|;
operator|*
name|len
operator|=
name|l
expr_stmt|;
return|return
name|s
return|;
block|}
end_function

begin_comment
comment|/* align file on DWORD boundary */
end_comment

begin_function
specifier|static
name|void
name|res_align_file
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|fseek
argument_list|(
name|fres
argument_list|,
name|ftell
argument_list|(
name|fres
argument_list|)
operator|%
literal|4
argument_list|,
name|SEEK_CUR
argument_list|)
operator|!=
literal|0
condition|)
name|fatal
argument_list|(
literal|"%s: %s: unable to align file"
argument_list|,
name|program_name
argument_list|,
name|filename
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Check if file is a win32 binary resource file, if so    skip past the null resource. Returns 0 if successful, -1 on    error.  */
end_comment

begin_function
specifier|static
name|void
name|skip_null_resource
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|res_hdr
name|reshdr
init|=
block|{
literal|0
block|,
literal|0
block|}
decl_stmt|;
name|read_res_data
argument_list|(
operator|&
name|reshdr
argument_list|,
sizeof|sizeof
argument_list|(
name|reshdr
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|reshdr
operator|.
name|data_size
operator|!=
literal|0
operator|)
operator|||
operator|(
name|reshdr
operator|.
name|header_size
operator|!=
literal|0x20
operator|)
condition|)
goto|goto
name|skip_err
goto|;
comment|/* Subtract size of HeaderSize and DataSize */
if|if
condition|(
name|fseek
argument_list|(
name|fres
argument_list|,
name|reshdr
operator|.
name|header_size
operator|-
literal|8
argument_list|,
name|SEEK_CUR
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|skip_err
goto|;
return|return;
name|skip_err
label|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: %s: Not a valid WIN32 resource file\n"
argument_list|,
name|program_name
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|xexit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add a resource to resource directory */
end_comment

begin_function
name|void
name|res_add_resource
parameter_list|(
name|r
parameter_list|,
name|type
parameter_list|,
name|id
parameter_list|,
name|language
parameter_list|,
name|dupok
parameter_list|)
name|struct
name|res_resource
modifier|*
name|r
decl_stmt|;
specifier|const
name|struct
name|res_id
modifier|*
name|type
decl_stmt|;
specifier|const
name|struct
name|res_id
modifier|*
name|id
decl_stmt|;
name|int
name|language
decl_stmt|;
name|int
name|dupok
decl_stmt|;
block|{
name|struct
name|res_id
name|a
index|[
literal|3
index|]
decl_stmt|;
name|a
index|[
literal|0
index|]
operator|=
operator|*
name|type
expr_stmt|;
name|a
index|[
literal|1
index|]
operator|=
operator|*
name|id
expr_stmt|;
name|a
index|[
literal|2
index|]
operator|.
name|named
operator|=
literal|0
expr_stmt|;
name|a
index|[
literal|2
index|]
operator|.
name|u
operator|.
name|id
operator|=
name|language
expr_stmt|;
name|res_append_resource
argument_list|(
operator|&
name|resources
argument_list|,
name|r
argument_list|,
literal|3
argument_list|,
name|a
argument_list|,
name|dupok
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Append a resource to resource directory.    This is just copied from define_resource    and modified to add an existing resource.  */
end_comment

begin_function
name|void
name|res_append_resource
parameter_list|(
name|resources
parameter_list|,
name|resource
parameter_list|,
name|cids
parameter_list|,
name|ids
parameter_list|,
name|dupok
parameter_list|)
name|struct
name|res_directory
modifier|*
modifier|*
name|resources
decl_stmt|;
name|struct
name|res_resource
modifier|*
name|resource
decl_stmt|;
name|int
name|cids
decl_stmt|;
specifier|const
name|struct
name|res_id
modifier|*
name|ids
decl_stmt|;
name|int
name|dupok
decl_stmt|;
block|{
name|struct
name|res_entry
modifier|*
name|re
init|=
name|NULL
decl_stmt|;
name|int
name|i
decl_stmt|;
name|assert
argument_list|(
name|cids
operator|>
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cids
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|res_entry
modifier|*
modifier|*
name|pp
decl_stmt|;
if|if
condition|(
operator|*
name|resources
operator|==
name|NULL
condition|)
block|{
specifier|static
name|unsigned
name|long
name|timeval
decl_stmt|;
comment|/* Use the same timestamp for every resource created in a 	     single run.  */
if|if
condition|(
name|timeval
operator|==
literal|0
condition|)
name|timeval
operator|=
name|time
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
operator|*
name|resources
operator|=
operator|(
operator|(
expr|struct
name|res_directory
operator|*
operator|)
name|res_alloc
argument_list|(
sizeof|sizeof
expr|*
operator|*
name|resources
argument_list|)
operator|)
expr_stmt|;
operator|(
operator|*
name|resources
operator|)
operator|->
name|characteristics
operator|=
literal|0
expr_stmt|;
operator|(
operator|*
name|resources
operator|)
operator|->
name|time
operator|=
name|timeval
expr_stmt|;
operator|(
operator|*
name|resources
operator|)
operator|->
name|major
operator|=
literal|0
expr_stmt|;
operator|(
operator|*
name|resources
operator|)
operator|->
name|minor
operator|=
literal|0
expr_stmt|;
operator|(
operator|*
name|resources
operator|)
operator|->
name|entries
operator|=
name|NULL
expr_stmt|;
block|}
for|for
control|(
name|pp
operator|=
operator|&
operator|(
operator|*
name|resources
operator|)
operator|->
name|entries
init|;
operator|*
name|pp
operator|!=
name|NULL
condition|;
name|pp
operator|=
operator|&
operator|(
operator|*
name|pp
operator|)
operator|->
name|next
control|)
if|if
condition|(
name|res_id_cmp
argument_list|(
operator|(
operator|*
name|pp
operator|)
operator|->
name|id
argument_list|,
name|ids
index|[
name|i
index|]
argument_list|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
operator|*
name|pp
operator|!=
name|NULL
condition|)
name|re
operator|=
operator|*
name|pp
expr_stmt|;
else|else
block|{
name|re
operator|=
operator|(
expr|struct
name|res_entry
operator|*
operator|)
name|res_alloc
argument_list|(
sizeof|sizeof
expr|*
name|re
argument_list|)
expr_stmt|;
name|re
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|re
operator|->
name|id
operator|=
name|ids
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|+
literal|1
operator|)
operator|<
name|cids
condition|)
block|{
name|re
operator|->
name|subdir
operator|=
literal|1
expr_stmt|;
name|re
operator|->
name|u
operator|.
name|dir
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|re
operator|->
name|subdir
operator|=
literal|0
expr_stmt|;
name|re
operator|->
name|u
operator|.
name|res
operator|=
name|NULL
expr_stmt|;
block|}
operator|*
name|pp
operator|=
name|re
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|i
operator|+
literal|1
operator|)
operator|<
name|cids
condition|)
block|{
if|if
condition|(
operator|!
name|re
operator|->
name|subdir
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: "
argument_list|,
name|program_name
argument_list|)
expr_stmt|;
name|res_ids_print
argument_list|(
name|stderr
argument_list|,
name|i
argument_list|,
name|ids
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|": expected to be a directory\n"
argument_list|)
expr_stmt|;
name|xexit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|resources
operator|=
operator|&
name|re
operator|->
name|u
operator|.
name|dir
expr_stmt|;
block|}
block|}
if|if
condition|(
name|re
operator|->
name|subdir
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: "
argument_list|,
name|program_name
argument_list|)
expr_stmt|;
name|res_ids_print
argument_list|(
name|stderr
argument_list|,
name|cids
argument_list|,
name|ids
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|": expected to be a leaf\n"
argument_list|)
expr_stmt|;
name|xexit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|re
operator|->
name|u
operator|.
name|res
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|dupok
condition|)
return|return;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: warning: "
argument_list|,
name|program_name
argument_list|)
expr_stmt|;
name|res_ids_print
argument_list|(
name|stderr
argument_list|,
name|cids
argument_list|,
name|ids
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|": duplicate value\n"
argument_list|)
expr_stmt|;
block|}
name|re
operator|->
name|u
operator|.
name|res
operator|=
name|resource
expr_stmt|;
block|}
end_function

end_unit

