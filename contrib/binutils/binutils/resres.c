begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* resres.c: read_res_file and write_res_file implementation for windres.    Copyright 1998, 1999, 2001, 2002, 2007    Free Software Foundation, Inc.    Written by Anders Norlander<anorland@hem2.passagen.se>.    Rewritten by Kai Tietz, Onevision.     This file is part of GNU Binutils.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA    02110-1301, USA.  */
end_comment

begin_comment
comment|/* FIXME: This file does not work correctly in a cross configuration.    It assumes that it can use fread and fwrite to read and write    integers.  It does no swapping.  */
end_comment

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"bucomm.h"
end_include

begin_include
include|#
directive|include
file|"libiberty.h"
end_include

begin_include
include|#
directive|include
file|"windres.h"
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_function_decl
specifier|static
name|rc_uint_type
name|write_res_directory
parameter_list|(
name|windres_bfd
modifier|*
parameter_list|,
name|rc_uint_type
parameter_list|,
specifier|const
name|rc_res_directory
modifier|*
parameter_list|,
specifier|const
name|rc_res_id
modifier|*
parameter_list|,
specifier|const
name|rc_res_id
modifier|*
parameter_list|,
name|rc_uint_type
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rc_uint_type
name|write_res_resource
parameter_list|(
name|windres_bfd
modifier|*
parameter_list|,
name|rc_uint_type
parameter_list|,
specifier|const
name|rc_res_id
modifier|*
parameter_list|,
specifier|const
name|rc_res_id
modifier|*
parameter_list|,
specifier|const
name|rc_res_resource
modifier|*
parameter_list|,
name|rc_uint_type
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rc_uint_type
name|write_res_bin
parameter_list|(
name|windres_bfd
modifier|*
parameter_list|,
name|rc_uint_type
parameter_list|,
specifier|const
name|rc_res_resource
modifier|*
parameter_list|,
specifier|const
name|rc_res_id
modifier|*
parameter_list|,
specifier|const
name|rc_res_id
modifier|*
parameter_list|,
specifier|const
name|rc_res_res_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rc_uint_type
name|write_res_id
parameter_list|(
name|windres_bfd
modifier|*
parameter_list|,
name|rc_uint_type
parameter_list|,
specifier|const
name|rc_res_id
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rc_uint_type
name|write_res_info
parameter_list|(
name|windres_bfd
modifier|*
parameter_list|,
name|rc_uint_type
parameter_list|,
specifier|const
name|rc_res_res_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rc_uint_type
name|write_res_data_hdr
parameter_list|(
name|windres_bfd
modifier|*
parameter_list|,
name|rc_uint_type
parameter_list|,
name|res_hdr
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rc_uint_type
name|write_res_header
parameter_list|(
name|windres_bfd
modifier|*
parameter_list|,
name|rc_uint_type
parameter_list|,
name|rc_uint_type
parameter_list|,
specifier|const
name|rc_res_id
modifier|*
parameter_list|,
specifier|const
name|rc_res_id
modifier|*
parameter_list|,
specifier|const
name|rc_res_res_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|read_resource_entry
parameter_list|(
name|windres_bfd
modifier|*
parameter_list|,
name|rc_uint_type
modifier|*
parameter_list|,
name|rc_uint_type
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|read_res_data
parameter_list|(
name|windres_bfd
modifier|*
parameter_list|,
name|rc_uint_type
modifier|*
parameter_list|,
name|rc_uint_type
parameter_list|,
name|void
modifier|*
parameter_list|,
name|rc_uint_type
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|read_res_data_hdr
parameter_list|(
name|windres_bfd
modifier|*
parameter_list|,
name|rc_uint_type
modifier|*
parameter_list|,
name|rc_uint_type
parameter_list|,
name|res_hdr
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|read_res_id
parameter_list|(
name|windres_bfd
modifier|*
parameter_list|,
name|rc_uint_type
modifier|*
parameter_list|,
name|rc_uint_type
parameter_list|,
name|rc_res_id
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|unichar
modifier|*
name|read_unistring
parameter_list|(
name|windres_bfd
modifier|*
parameter_list|,
name|rc_uint_type
modifier|*
parameter_list|,
name|rc_uint_type
parameter_list|,
name|rc_uint_type
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|skip_null_resource
parameter_list|(
name|windres_bfd
modifier|*
parameter_list|,
name|rc_uint_type
modifier|*
parameter_list|,
name|rc_uint_type
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|probe_binary
parameter_list|(
name|windres_bfd
modifier|*
name|wrbfd
parameter_list|,
name|rc_uint_type
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|unsigned
name|long
name|get_id_size
parameter_list|(
specifier|const
name|rc_res_id
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|res_add_resource
parameter_list|(
name|rc_res_resource
modifier|*
parameter_list|,
specifier|const
name|rc_res_id
modifier|*
parameter_list|,
specifier|const
name|rc_res_id
modifier|*
parameter_list|,
name|rc_uint_type
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|res_append_resource
parameter_list|(
name|rc_res_directory
modifier|*
modifier|*
parameter_list|,
name|rc_res_resource
modifier|*
parameter_list|,
name|int
parameter_list|,
specifier|const
name|rc_res_id
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|rc_res_directory
modifier|*
name|resources
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|filename
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|program_name
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Read resource file */
end_comment

begin_function
name|rc_res_directory
modifier|*
name|read_res_file
parameter_list|(
specifier|const
name|char
modifier|*
name|fn
parameter_list|)
block|{
name|rc_uint_type
name|off
decl_stmt|,
name|flen
decl_stmt|;
name|windres_bfd
name|wrbfd
decl_stmt|;
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|filename
operator|=
name|fn
expr_stmt|;
name|flen
operator|=
operator|(
name|rc_uint_type
operator|)
name|get_file_size
argument_list|(
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|flen
condition|)
name|fatal
argument_list|(
literal|"can't open '%s' for input."
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|abfd
operator|=
name|windres_open_as_binary
argument_list|(
name|filename
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|sec
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".data"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sec
operator|==
name|NULL
condition|)
name|bfd_fatal
argument_list|(
literal|"bfd_get_section_by_name"
argument_list|)
expr_stmt|;
name|set_windres_bfd
argument_list|(
operator|&
name|wrbfd
argument_list|,
name|abfd
argument_list|,
name|sec
argument_list|,
operator|(
name|target_is_bigendian
condition|?
name|WR_KIND_BFD_BIN_B
else|:
name|WR_KIND_BFD_BIN_L
operator|)
argument_list|)
expr_stmt|;
name|off
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|probe_binary
argument_list|(
operator|&
name|wrbfd
argument_list|,
name|flen
argument_list|)
condition|)
name|set_windres_bfd_endianess
argument_list|(
operator|&
name|wrbfd
argument_list|,
operator|!
name|target_is_bigendian
argument_list|)
expr_stmt|;
name|skip_null_resource
argument_list|(
operator|&
name|wrbfd
argument_list|,
operator|&
name|off
argument_list|,
name|flen
argument_list|)
expr_stmt|;
while|while
condition|(
name|read_resource_entry
argument_list|(
operator|&
name|wrbfd
argument_list|,
operator|&
name|off
argument_list|,
name|flen
argument_list|)
condition|)
empty_stmt|;
name|bfd_close
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
return|return
name|resources
return|;
block|}
end_function

begin_comment
comment|/* Write resource file */
end_comment

begin_function
name|void
name|write_res_file
parameter_list|(
specifier|const
name|char
modifier|*
name|fn
parameter_list|,
specifier|const
name|rc_res_directory
modifier|*
name|resdir
parameter_list|)
block|{
name|asection
modifier|*
name|sec
decl_stmt|;
name|rc_uint_type
name|language
decl_stmt|;
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|windres_bfd
name|wrbfd
decl_stmt|;
name|unsigned
name|long
name|sec_length
init|=
literal|0
decl_stmt|,
name|sec_length_wrote
decl_stmt|;
specifier|static
specifier|const
name|bfd_byte
name|sign
index|[]
init|=
block|{
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x20
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0xFF
block|,
literal|0xFF
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0xFF
block|,
literal|0xFF
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|}
decl_stmt|;
name|filename
operator|=
name|fn
expr_stmt|;
name|abfd
operator|=
name|windres_open_as_binary
argument_list|(
name|filename
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sec
operator|=
name|bfd_make_section
argument_list|(
name|abfd
argument_list|,
literal|".data"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sec
operator|==
name|NULL
condition|)
name|bfd_fatal
argument_list|(
literal|"bfd_make_section"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_set_section_flags
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
operator|(
name|SEC_HAS_CONTENTS
operator||
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_DATA
operator|)
argument_list|)
condition|)
name|bfd_fatal
argument_list|(
literal|"bfd_set_section_flags"
argument_list|)
expr_stmt|;
comment|/* Requiring this is probably a bug in BFD.  */
name|sec
operator|->
name|output_section
operator|=
name|sec
expr_stmt|;
name|set_windres_bfd
argument_list|(
operator|&
name|wrbfd
argument_list|,
name|abfd
argument_list|,
name|sec
argument_list|,
operator|(
name|target_is_bigendian
condition|?
name|WR_KIND_BFD_BIN_B
else|:
name|WR_KIND_BFD_BIN_L
operator|)
argument_list|)
expr_stmt|;
name|language
operator|=
operator|-
literal|1
expr_stmt|;
name|sec_length
operator|=
name|write_res_directory
argument_list|(
operator|(
name|windres_bfd
operator|*
operator|)
name|NULL
argument_list|,
literal|0x20UL
argument_list|,
name|resdir
argument_list|,
operator|(
specifier|const
name|rc_res_id
operator|*
operator|)
name|NULL
argument_list|,
operator|(
specifier|const
name|rc_res_id
operator|*
operator|)
name|NULL
argument_list|,
operator|&
name|language
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_set_section_size
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
operator|(
name|sec_length
operator|+
literal|3
operator|)
operator|&
operator|~
literal|3
argument_list|)
condition|)
name|bfd_fatal
argument_list|(
literal|"bfd_set_section_size"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sec_length
operator|&
literal|3
operator|)
operator|!=
literal|0
condition|)
name|set_windres_bfd_content
argument_list|(
operator|&
name|wrbfd
argument_list|,
name|sign
argument_list|,
name|sec_length
argument_list|,
literal|4
operator|-
operator|(
name|sec_length
operator|&
literal|3
operator|)
argument_list|)
expr_stmt|;
name|set_windres_bfd_content
argument_list|(
operator|&
name|wrbfd
argument_list|,
name|sign
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|sign
argument_list|)
argument_list|)
expr_stmt|;
name|language
operator|=
operator|-
literal|1
expr_stmt|;
name|sec_length_wrote
operator|=
name|write_res_directory
argument_list|(
operator|&
name|wrbfd
argument_list|,
literal|0x20UL
argument_list|,
name|resdir
argument_list|,
operator|(
specifier|const
name|rc_res_id
operator|*
operator|)
name|NULL
argument_list|,
operator|(
specifier|const
name|rc_res_id
operator|*
operator|)
name|NULL
argument_list|,
operator|&
name|language
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|sec_length
operator|!=
name|sec_length_wrote
condition|)
name|fatal
argument_list|(
literal|"res write failed with different sizes (%lu/%lu)."
argument_list|,
operator|(
name|long
operator|)
name|sec_length
argument_list|,
operator|(
name|long
operator|)
name|sec_length_wrote
argument_list|)
expr_stmt|;
name|bfd_close
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* Read a resource entry, returns 0 when all resources are read */
end_comment

begin_function
specifier|static
name|int
name|read_resource_entry
parameter_list|(
name|windres_bfd
modifier|*
name|wrbfd
parameter_list|,
name|rc_uint_type
modifier|*
name|off
parameter_list|,
name|rc_uint_type
name|omax
parameter_list|)
block|{
name|rc_res_id
name|type
decl_stmt|;
name|rc_res_id
name|name
decl_stmt|;
name|rc_res_res_info
name|resinfo
decl_stmt|;
name|res_hdr
name|reshdr
decl_stmt|;
name|void
modifier|*
name|buff
decl_stmt|;
name|rc_res_resource
modifier|*
name|r
decl_stmt|;
name|struct
name|bin_res_info
name|l
decl_stmt|;
name|off
index|[
literal|0
index|]
operator|=
operator|(
name|off
index|[
literal|0
index|]
operator|+
literal|3
operator|)
operator|&
operator|~
literal|3
expr_stmt|;
comment|/* Read header */
if|if
condition|(
operator|(
name|off
index|[
literal|0
index|]
operator|+
literal|8
operator|)
operator|>
name|omax
condition|)
return|return
literal|0
return|;
name|read_res_data_hdr
argument_list|(
name|wrbfd
argument_list|,
name|off
argument_list|,
name|omax
argument_list|,
operator|&
name|reshdr
argument_list|)
expr_stmt|;
comment|/* read resource type */
name|read_res_id
argument_list|(
name|wrbfd
argument_list|,
name|off
argument_list|,
name|omax
argument_list|,
operator|&
name|type
argument_list|)
expr_stmt|;
comment|/* read resource id */
name|read_res_id
argument_list|(
name|wrbfd
argument_list|,
name|off
argument_list|,
name|omax
argument_list|,
operator|&
name|name
argument_list|)
expr_stmt|;
name|off
index|[
literal|0
index|]
operator|=
operator|(
name|off
index|[
literal|0
index|]
operator|+
literal|3
operator|)
operator|&
operator|~
literal|3
expr_stmt|;
comment|/* Read additional resource header */
name|read_res_data
argument_list|(
name|wrbfd
argument_list|,
name|off
argument_list|,
name|omax
argument_list|,
operator|&
name|l
argument_list|,
name|BIN_RES_INFO_SIZE
argument_list|)
expr_stmt|;
name|resinfo
operator|.
name|version
operator|=
name|windres_get_32
argument_list|(
name|wrbfd
argument_list|,
name|l
operator|.
name|version
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|resinfo
operator|.
name|memflags
operator|=
name|windres_get_16
argument_list|(
name|wrbfd
argument_list|,
name|l
operator|.
name|memflags
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|resinfo
operator|.
name|language
operator|=
name|windres_get_16
argument_list|(
name|wrbfd
argument_list|,
name|l
operator|.
name|language
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* resinfo.version2 = windres_get_32 (wrbfd, l.version2, 4); */
name|resinfo
operator|.
name|characteristics
operator|=
name|windres_get_32
argument_list|(
name|wrbfd
argument_list|,
name|l
operator|.
name|characteristics
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|off
index|[
literal|0
index|]
operator|=
operator|(
name|off
index|[
literal|0
index|]
operator|+
literal|3
operator|)
operator|&
operator|~
literal|3
expr_stmt|;
comment|/* Allocate buffer for data */
name|buff
operator|=
name|res_alloc
argument_list|(
name|reshdr
operator|.
name|data_size
argument_list|)
expr_stmt|;
comment|/* Read data */
name|read_res_data
argument_list|(
name|wrbfd
argument_list|,
name|off
argument_list|,
name|omax
argument_list|,
name|buff
argument_list|,
name|reshdr
operator|.
name|data_size
argument_list|)
expr_stmt|;
comment|/* Convert binary data to resource */
name|r
operator|=
name|bin_to_res
argument_list|(
name|wrbfd
argument_list|,
name|type
argument_list|,
name|buff
argument_list|,
name|reshdr
operator|.
name|data_size
argument_list|)
expr_stmt|;
name|r
operator|->
name|res_info
operator|=
name|resinfo
expr_stmt|;
comment|/* Add resource to resource directory */
name|res_add_resource
argument_list|(
name|r
argument_list|,
operator|&
name|type
argument_list|,
operator|&
name|name
argument_list|,
name|resinfo
operator|.
name|language
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* write resource directory to binary resource file */
end_comment

begin_function
specifier|static
name|rc_uint_type
name|write_res_directory
parameter_list|(
name|windres_bfd
modifier|*
name|wrbfd
parameter_list|,
name|rc_uint_type
name|off
parameter_list|,
specifier|const
name|rc_res_directory
modifier|*
name|rd
parameter_list|,
specifier|const
name|rc_res_id
modifier|*
name|type
parameter_list|,
specifier|const
name|rc_res_id
modifier|*
name|name
parameter_list|,
name|rc_uint_type
modifier|*
name|language
parameter_list|,
name|int
name|level
parameter_list|)
block|{
specifier|const
name|rc_res_entry
modifier|*
name|re
decl_stmt|;
for|for
control|(
name|re
operator|=
name|rd
operator|->
name|entries
init|;
name|re
operator|!=
name|NULL
condition|;
name|re
operator|=
name|re
operator|->
name|next
control|)
block|{
switch|switch
condition|(
name|level
condition|)
block|{
case|case
literal|1
case|:
comment|/* If we're at level 1, the key of this resource is the 	     type.  This normally duplicates the information we have 	     stored with the resource itself, but we need to remember 	     the type if this is a user define resource type.  */
name|type
operator|=
operator|&
name|re
operator|->
name|id
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|/* If we're at level 2, the key of this resource is the name 	     we are going to use in the rc printout.  */
name|name
operator|=
operator|&
name|re
operator|->
name|id
expr_stmt|;
break|break;
case|case
literal|3
case|:
comment|/* If we're at level 3, then this key represents a language. 	     Use it to update the current language.  */
if|if
condition|(
operator|!
name|re
operator|->
name|id
operator|.
name|named
operator|&&
name|re
operator|->
name|id
operator|.
name|u
operator|.
name|id
operator|!=
operator|(
name|unsigned
name|long
operator|)
operator|*
name|language
operator|&&
operator|(
name|re
operator|->
name|id
operator|.
name|u
operator|.
name|id
operator|&
literal|0xffff
operator|)
operator|==
name|re
operator|->
name|id
operator|.
name|u
operator|.
name|id
condition|)
block|{
operator|*
name|language
operator|=
name|re
operator|->
name|id
operator|.
name|u
operator|.
name|id
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
if|if
condition|(
name|re
operator|->
name|subdir
condition|)
name|off
operator|=
name|write_res_directory
argument_list|(
name|wrbfd
argument_list|,
name|off
argument_list|,
name|re
operator|->
name|u
operator|.
name|dir
argument_list|,
name|type
argument_list|,
name|name
argument_list|,
name|language
argument_list|,
name|level
operator|+
literal|1
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|level
operator|==
literal|3
condition|)
block|{
comment|/* This is the normal case: the three levels are 	         TYPE/NAME/LANGUAGE.  NAME will have been set at level 	         2, and represents the name to use.  We probably just 	         set LANGUAGE, and it will probably match what the 	         resource itself records if anything.  */
name|off
operator|=
name|write_res_resource
argument_list|(
name|wrbfd
argument_list|,
name|off
argument_list|,
name|type
argument_list|,
name|name
argument_list|,
name|re
operator|->
name|u
operator|.
name|res
argument_list|,
name|language
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"// Resource at unexpected level %d\n"
argument_list|,
name|level
argument_list|)
expr_stmt|;
name|off
operator|=
name|write_res_resource
argument_list|(
name|wrbfd
argument_list|,
name|off
argument_list|,
name|type
argument_list|,
operator|(
name|rc_res_id
operator|*
operator|)
name|NULL
argument_list|,
name|re
operator|->
name|u
operator|.
name|res
argument_list|,
name|language
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|off
return|;
block|}
end_function

begin_function
specifier|static
name|rc_uint_type
name|write_res_resource
parameter_list|(
name|windres_bfd
modifier|*
name|wrbfd
parameter_list|,
name|rc_uint_type
name|off
parameter_list|,
specifier|const
name|rc_res_id
modifier|*
name|type
parameter_list|,
specifier|const
name|rc_res_id
modifier|*
name|name
parameter_list|,
specifier|const
name|rc_res_resource
modifier|*
name|res
parameter_list|,
name|rc_uint_type
modifier|*
name|language
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|int
name|rt
decl_stmt|;
switch|switch
condition|(
name|res
operator|->
name|type
condition|)
block|{
default|default:
name|abort
argument_list|()
expr_stmt|;
case|case
name|RES_TYPE_ACCELERATOR
case|:
name|rt
operator|=
name|RT_ACCELERATOR
expr_stmt|;
break|break;
case|case
name|RES_TYPE_BITMAP
case|:
name|rt
operator|=
name|RT_BITMAP
expr_stmt|;
break|break;
case|case
name|RES_TYPE_CURSOR
case|:
name|rt
operator|=
name|RT_CURSOR
expr_stmt|;
break|break;
case|case
name|RES_TYPE_GROUP_CURSOR
case|:
name|rt
operator|=
name|RT_GROUP_CURSOR
expr_stmt|;
break|break;
case|case
name|RES_TYPE_DIALOG
case|:
name|rt
operator|=
name|RT_DIALOG
expr_stmt|;
break|break;
case|case
name|RES_TYPE_FONT
case|:
name|rt
operator|=
name|RT_FONT
expr_stmt|;
break|break;
case|case
name|RES_TYPE_FONTDIR
case|:
name|rt
operator|=
name|RT_FONTDIR
expr_stmt|;
break|break;
case|case
name|RES_TYPE_ICON
case|:
name|rt
operator|=
name|RT_ICON
expr_stmt|;
break|break;
case|case
name|RES_TYPE_GROUP_ICON
case|:
name|rt
operator|=
name|RT_GROUP_ICON
expr_stmt|;
break|break;
case|case
name|RES_TYPE_MENU
case|:
name|rt
operator|=
name|RT_MENU
expr_stmt|;
break|break;
case|case
name|RES_TYPE_MESSAGETABLE
case|:
name|rt
operator|=
name|RT_MESSAGETABLE
expr_stmt|;
break|break;
case|case
name|RES_TYPE_RCDATA
case|:
name|rt
operator|=
name|RT_RCDATA
expr_stmt|;
break|break;
case|case
name|RES_TYPE_STRINGTABLE
case|:
name|rt
operator|=
name|RT_STRING
expr_stmt|;
break|break;
case|case
name|RES_TYPE_USERDATA
case|:
name|rt
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|RES_TYPE_VERSIONINFO
case|:
name|rt
operator|=
name|RT_VERSION
expr_stmt|;
break|break;
case|case
name|RES_TYPE_TOOLBAR
case|:
name|rt
operator|=
name|RT_TOOLBAR
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|rt
operator|!=
literal|0
operator|&&
name|type
operator|!=
name|NULL
operator|&&
operator|(
name|type
operator|->
name|named
operator|||
name|type
operator|->
name|u
operator|.
name|id
operator|!=
operator|(
name|unsigned
name|long
operator|)
name|rt
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"// Unexpected resource type mismatch: "
argument_list|)
expr_stmt|;
name|res_id_print
argument_list|(
name|stderr
argument_list|,
operator|*
name|type
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" != %d"
argument_list|,
name|rt
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
return|return
name|write_res_bin
argument_list|(
name|wrbfd
argument_list|,
name|off
argument_list|,
name|res
argument_list|,
name|type
argument_list|,
name|name
argument_list|,
operator|&
name|res
operator|->
name|res_info
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Write a resource in binary resource format */
end_comment

begin_function
specifier|static
name|rc_uint_type
name|write_res_bin
parameter_list|(
name|windres_bfd
modifier|*
name|wrbfd
parameter_list|,
name|rc_uint_type
name|off
parameter_list|,
specifier|const
name|rc_res_resource
modifier|*
name|res
parameter_list|,
specifier|const
name|rc_res_id
modifier|*
name|type
parameter_list|,
specifier|const
name|rc_res_id
modifier|*
name|name
parameter_list|,
specifier|const
name|rc_res_res_info
modifier|*
name|resinfo
parameter_list|)
block|{
name|rc_uint_type
name|noff
decl_stmt|;
name|rc_uint_type
name|datasize
init|=
literal|0
decl_stmt|;
name|noff
operator|=
name|res_to_bin
argument_list|(
operator|(
name|windres_bfd
operator|*
operator|)
name|NULL
argument_list|,
name|off
argument_list|,
name|res
argument_list|)
expr_stmt|;
name|datasize
operator|=
name|noff
operator|-
name|off
expr_stmt|;
name|off
operator|=
name|write_res_header
argument_list|(
name|wrbfd
argument_list|,
name|off
argument_list|,
name|datasize
argument_list|,
name|type
argument_list|,
name|name
argument_list|,
name|resinfo
argument_list|)
expr_stmt|;
return|return
name|res_to_bin
argument_list|(
name|wrbfd
argument_list|,
name|off
argument_list|,
name|res
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Get number of bytes needed to store an id in binary format */
end_comment

begin_function
specifier|static
name|unsigned
name|long
name|get_id_size
parameter_list|(
name|id
parameter_list|)
specifier|const
name|rc_res_id
modifier|*
name|id
decl_stmt|;
block|{
if|if
condition|(
name|id
operator|->
name|named
condition|)
return|return
sizeof|sizeof
argument_list|(
name|unichar
argument_list|)
operator|*
operator|(
name|id
operator|->
name|u
operator|.
name|n
operator|.
name|length
operator|+
literal|1
operator|)
return|;
else|else
return|return
sizeof|sizeof
argument_list|(
name|unichar
argument_list|)
operator|*
literal|2
return|;
block|}
end_function

begin_comment
comment|/* Write a resource header */
end_comment

begin_function
specifier|static
name|rc_uint_type
name|write_res_header
parameter_list|(
name|windres_bfd
modifier|*
name|wrbfd
parameter_list|,
name|rc_uint_type
name|off
parameter_list|,
name|rc_uint_type
name|datasize
parameter_list|,
specifier|const
name|rc_res_id
modifier|*
name|type
parameter_list|,
specifier|const
name|rc_res_id
modifier|*
name|name
parameter_list|,
specifier|const
name|rc_res_res_info
modifier|*
name|resinfo
parameter_list|)
block|{
name|res_hdr
name|reshdr
decl_stmt|;
name|reshdr
operator|.
name|data_size
operator|=
name|datasize
expr_stmt|;
name|reshdr
operator|.
name|header_size
operator|=
literal|24
operator|+
name|get_id_size
argument_list|(
name|type
argument_list|)
operator|+
name|get_id_size
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|reshdr
operator|.
name|header_size
operator|=
operator|(
name|reshdr
operator|.
name|header_size
operator|+
literal|3
operator|)
operator|&
operator|~
literal|3
expr_stmt|;
name|off
operator|=
operator|(
name|off
operator|+
literal|3
operator|)
operator|&
operator|~
literal|3
expr_stmt|;
name|off
operator|=
name|write_res_data_hdr
argument_list|(
name|wrbfd
argument_list|,
name|off
argument_list|,
operator|&
name|reshdr
argument_list|)
expr_stmt|;
name|off
operator|=
name|write_res_id
argument_list|(
name|wrbfd
argument_list|,
name|off
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|off
operator|=
name|write_res_id
argument_list|(
name|wrbfd
argument_list|,
name|off
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|off
operator|=
operator|(
name|off
operator|+
literal|3
operator|)
operator|&
operator|~
literal|3
expr_stmt|;
name|off
operator|=
name|write_res_info
argument_list|(
name|wrbfd
argument_list|,
name|off
argument_list|,
name|resinfo
argument_list|)
expr_stmt|;
name|off
operator|=
operator|(
name|off
operator|+
literal|3
operator|)
operator|&
operator|~
literal|3
expr_stmt|;
return|return
name|off
return|;
block|}
end_function

begin_function
specifier|static
name|rc_uint_type
name|write_res_data_hdr
parameter_list|(
name|windres_bfd
modifier|*
name|wrbfd
parameter_list|,
name|rc_uint_type
name|off
parameter_list|,
name|res_hdr
modifier|*
name|hdr
parameter_list|)
block|{
if|if
condition|(
name|wrbfd
condition|)
block|{
name|struct
name|bin_res_hdr
name|brh
decl_stmt|;
name|windres_put_32
argument_list|(
name|wrbfd
argument_list|,
name|brh
operator|.
name|data_size
argument_list|,
name|hdr
operator|->
name|data_size
argument_list|)
expr_stmt|;
name|windres_put_32
argument_list|(
name|wrbfd
argument_list|,
name|brh
operator|.
name|header_size
argument_list|,
name|hdr
operator|->
name|header_size
argument_list|)
expr_stmt|;
name|set_windres_bfd_content
argument_list|(
name|wrbfd
argument_list|,
operator|&
name|brh
argument_list|,
name|off
argument_list|,
name|BIN_RES_HDR_SIZE
argument_list|)
expr_stmt|;
block|}
return|return
name|off
operator|+
name|BIN_RES_HDR_SIZE
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|read_res_data_hdr
parameter_list|(
name|windres_bfd
modifier|*
name|wrbfd
parameter_list|,
name|rc_uint_type
modifier|*
name|off
parameter_list|,
name|rc_uint_type
name|omax
parameter_list|,
name|res_hdr
modifier|*
name|reshdr
parameter_list|)
block|{
name|struct
name|bin_res_hdr
name|brh
decl_stmt|;
if|if
condition|(
operator|(
name|off
index|[
literal|0
index|]
operator|+
name|BIN_RES_HDR_SIZE
operator|)
operator|>
name|omax
condition|)
name|fatal
argument_list|(
literal|"%s: unexpected end of file %ld/%ld"
argument_list|,
name|filename
argument_list|,
operator|(
name|long
operator|)
name|off
index|[
literal|0
index|]
argument_list|,
operator|(
name|long
operator|)
name|omax
argument_list|)
expr_stmt|;
name|get_windres_bfd_content
argument_list|(
name|wrbfd
argument_list|,
operator|&
name|brh
argument_list|,
name|off
index|[
literal|0
index|]
argument_list|,
name|BIN_RES_HDR_SIZE
argument_list|)
expr_stmt|;
name|reshdr
operator|->
name|data_size
operator|=
name|windres_get_32
argument_list|(
name|wrbfd
argument_list|,
name|brh
operator|.
name|data_size
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|reshdr
operator|->
name|header_size
operator|=
name|windres_get_32
argument_list|(
name|wrbfd
argument_list|,
name|brh
operator|.
name|header_size
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|off
index|[
literal|0
index|]
operator|+=
name|BIN_RES_HDR_SIZE
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Read data from file, abort on failure */
end_comment

begin_function
specifier|static
name|void
name|read_res_data
parameter_list|(
name|windres_bfd
modifier|*
name|wrbfd
parameter_list|,
name|rc_uint_type
modifier|*
name|off
parameter_list|,
name|rc_uint_type
name|omax
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|rc_uint_type
name|size
parameter_list|)
block|{
if|if
condition|(
operator|(
name|off
index|[
literal|0
index|]
operator|+
name|size
operator|)
operator|>
name|omax
condition|)
name|fatal
argument_list|(
literal|"%s: unexpected end of file %ld/%ld %ld"
argument_list|,
name|filename
argument_list|,
operator|(
name|long
operator|)
name|off
index|[
literal|0
index|]
argument_list|,
operator|(
name|long
operator|)
name|omax
argument_list|,
operator|(
name|long
operator|)
name|size
argument_list|)
expr_stmt|;
name|get_windres_bfd_content
argument_list|(
name|wrbfd
argument_list|,
name|data
argument_list|,
name|off
index|[
literal|0
index|]
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|off
index|[
literal|0
index|]
operator|+=
name|size
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Write a resource id */
end_comment

begin_function
specifier|static
name|rc_uint_type
name|write_res_id
parameter_list|(
name|windres_bfd
modifier|*
name|wrbfd
parameter_list|,
name|rc_uint_type
name|off
parameter_list|,
specifier|const
name|rc_res_id
modifier|*
name|id
parameter_list|)
block|{
if|if
condition|(
name|id
operator|->
name|named
condition|)
block|{
name|rc_uint_type
name|len
init|=
operator|(
operator|(
operator|(
name|bfd_signed_vma
operator|)
name|id
operator|->
name|u
operator|.
name|n
operator|.
name|length
operator|<
literal|0
condition|?
literal|0
else|:
name|id
operator|->
name|u
operator|.
name|n
operator|.
name|length
operator|)
operator|+
literal|1
operator|)
decl_stmt|;
if|if
condition|(
name|wrbfd
condition|)
block|{
name|rc_uint_type
name|i
decl_stmt|;
name|bfd_byte
modifier|*
name|d
init|=
operator|(
name|bfd_byte
operator|*
operator|)
name|xmalloc
argument_list|(
name|len
operator|*
sizeof|sizeof
argument_list|(
name|unichar
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|len
operator|-
literal|1
operator|)
condition|;
name|i
operator|++
control|)
name|windres_put_16
argument_list|(
name|wrbfd
argument_list|,
name|d
operator|+
operator|(
name|i
operator|*
sizeof|sizeof
argument_list|(
name|unichar
argument_list|)
operator|)
argument_list|,
name|id
operator|->
name|u
operator|.
name|n
operator|.
name|name
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|windres_put_16
argument_list|(
name|wrbfd
argument_list|,
name|d
operator|+
operator|(
name|i
operator|*
sizeof|sizeof
argument_list|(
name|unichar
argument_list|)
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|set_windres_bfd_content
argument_list|(
name|wrbfd
argument_list|,
name|d
argument_list|,
name|off
argument_list|,
operator|(
name|len
operator|*
sizeof|sizeof
argument_list|(
name|unichar
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
name|off
operator|+=
operator|(
name|len
operator|*
sizeof|sizeof
argument_list|(
name|unichar
argument_list|)
operator|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|wrbfd
condition|)
block|{
name|struct
name|bin_res_id
name|bid
decl_stmt|;
name|windres_put_16
argument_list|(
name|wrbfd
argument_list|,
name|bid
operator|.
name|sig
argument_list|,
literal|0xffff
argument_list|)
expr_stmt|;
name|windres_put_16
argument_list|(
name|wrbfd
argument_list|,
name|bid
operator|.
name|id
argument_list|,
name|id
operator|->
name|u
operator|.
name|id
argument_list|)
expr_stmt|;
name|set_windres_bfd_content
argument_list|(
name|wrbfd
argument_list|,
operator|&
name|bid
argument_list|,
name|off
argument_list|,
name|BIN_RES_ID
argument_list|)
expr_stmt|;
block|}
name|off
operator|+=
name|BIN_RES_ID
expr_stmt|;
block|}
return|return
name|off
return|;
block|}
end_function

begin_comment
comment|/* Write resource info */
end_comment

begin_function
specifier|static
name|rc_uint_type
name|write_res_info
parameter_list|(
name|windres_bfd
modifier|*
name|wrbfd
parameter_list|,
name|rc_uint_type
name|off
parameter_list|,
specifier|const
name|rc_res_res_info
modifier|*
name|info
parameter_list|)
block|{
if|if
condition|(
name|wrbfd
condition|)
block|{
name|struct
name|bin_res_info
name|l
decl_stmt|;
name|windres_put_32
argument_list|(
name|wrbfd
argument_list|,
name|l
operator|.
name|version
argument_list|,
name|info
operator|->
name|version
argument_list|)
expr_stmt|;
name|windres_put_16
argument_list|(
name|wrbfd
argument_list|,
name|l
operator|.
name|memflags
argument_list|,
name|info
operator|->
name|memflags
argument_list|)
expr_stmt|;
name|windres_put_16
argument_list|(
name|wrbfd
argument_list|,
name|l
operator|.
name|language
argument_list|,
name|info
operator|->
name|language
argument_list|)
expr_stmt|;
name|windres_put_32
argument_list|(
name|wrbfd
argument_list|,
name|l
operator|.
name|version2
argument_list|,
name|info
operator|->
name|version
argument_list|)
expr_stmt|;
name|windres_put_32
argument_list|(
name|wrbfd
argument_list|,
name|l
operator|.
name|characteristics
argument_list|,
name|info
operator|->
name|characteristics
argument_list|)
expr_stmt|;
name|set_windres_bfd_content
argument_list|(
name|wrbfd
argument_list|,
operator|&
name|l
argument_list|,
name|off
argument_list|,
name|BIN_RES_INFO_SIZE
argument_list|)
expr_stmt|;
block|}
return|return
name|off
operator|+
name|BIN_RES_INFO_SIZE
return|;
block|}
end_function

begin_comment
comment|/* read a resource identifier */
end_comment

begin_function
specifier|static
name|void
name|read_res_id
parameter_list|(
name|windres_bfd
modifier|*
name|wrbfd
parameter_list|,
name|rc_uint_type
modifier|*
name|off
parameter_list|,
name|rc_uint_type
name|omax
parameter_list|,
name|rc_res_id
modifier|*
name|id
parameter_list|)
block|{
name|struct
name|bin_res_id
name|bid
decl_stmt|;
name|unsigned
name|short
name|ord
decl_stmt|;
name|unichar
modifier|*
name|id_s
init|=
name|NULL
decl_stmt|;
name|rc_uint_type
name|len
decl_stmt|;
name|read_res_data
argument_list|(
name|wrbfd
argument_list|,
name|off
argument_list|,
name|omax
argument_list|,
operator|&
name|bid
argument_list|,
name|BIN_RES_ID
operator|-
literal|2
argument_list|)
expr_stmt|;
name|ord
operator|=
operator|(
name|unsigned
name|short
operator|)
name|windres_get_16
argument_list|(
name|wrbfd
argument_list|,
name|bid
operator|.
name|sig
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|ord
operator|==
literal|0xFFFF
condition|)
comment|/* an ordinal id */
block|{
name|read_res_data
argument_list|(
name|wrbfd
argument_list|,
name|off
argument_list|,
name|omax
argument_list|,
name|bid
operator|.
name|id
argument_list|,
name|BIN_RES_ID
operator|-
literal|2
argument_list|)
expr_stmt|;
name|id
operator|->
name|named
operator|=
literal|0
expr_stmt|;
name|id
operator|->
name|u
operator|.
name|id
operator|=
name|windres_get_16
argument_list|(
name|wrbfd
argument_list|,
name|bid
operator|.
name|id
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* named id */
block|{
name|off
index|[
literal|0
index|]
operator|-=
literal|2
expr_stmt|;
name|id_s
operator|=
name|read_unistring
argument_list|(
name|wrbfd
argument_list|,
name|off
argument_list|,
name|omax
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
name|id
operator|->
name|named
operator|=
literal|1
expr_stmt|;
name|id
operator|->
name|u
operator|.
name|n
operator|.
name|length
operator|=
name|len
expr_stmt|;
name|id
operator|->
name|u
operator|.
name|n
operator|.
name|name
operator|=
name|id_s
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Read a null terminated UNICODE string */
end_comment

begin_function
specifier|static
name|unichar
modifier|*
name|read_unistring
parameter_list|(
name|windres_bfd
modifier|*
name|wrbfd
parameter_list|,
name|rc_uint_type
modifier|*
name|off
parameter_list|,
name|rc_uint_type
name|omax
parameter_list|,
name|rc_uint_type
modifier|*
name|len
parameter_list|)
block|{
name|unichar
modifier|*
name|s
decl_stmt|;
name|bfd_byte
name|d
index|[
literal|2
index|]
decl_stmt|;
name|unichar
name|c
decl_stmt|;
name|unichar
modifier|*
name|p
decl_stmt|;
name|rc_uint_type
name|l
decl_stmt|;
name|rc_uint_type
name|soff
init|=
name|off
index|[
literal|0
index|]
decl_stmt|;
do|do
block|{
name|read_res_data
argument_list|(
name|wrbfd
argument_list|,
operator|&
name|soff
argument_list|,
name|omax
argument_list|,
name|d
argument_list|,
sizeof|sizeof
argument_list|(
name|unichar
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|=
name|windres_get_16
argument_list|(
name|wrbfd
argument_list|,
name|d
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|c
operator|!=
literal|0
condition|)
do|;
name|l
operator|=
operator|(
operator|(
name|soff
operator|-
name|off
index|[
literal|0
index|]
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|unichar
argument_list|)
operator|)
expr_stmt|;
comment|/* there are hardly any names longer than 256 characters, but anyway. */
name|p
operator|=
name|s
operator|=
operator|(
name|unichar
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|unichar
argument_list|)
operator|*
name|l
argument_list|)
expr_stmt|;
do|do
block|{
name|read_res_data
argument_list|(
name|wrbfd
argument_list|,
name|off
argument_list|,
name|omax
argument_list|,
name|d
argument_list|,
sizeof|sizeof
argument_list|(
name|unichar
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|=
name|windres_get_16
argument_list|(
name|wrbfd
argument_list|,
name|d
argument_list|,
literal|2
argument_list|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|c
expr_stmt|;
block|}
do|while
condition|(
name|c
operator|!=
literal|0
condition|)
do|;
operator|*
name|len
operator|=
name|l
operator|-
literal|1
expr_stmt|;
return|return
name|s
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|probe_binary
parameter_list|(
name|windres_bfd
modifier|*
name|wrbfd
parameter_list|,
name|rc_uint_type
name|omax
parameter_list|)
block|{
name|rc_uint_type
name|off
decl_stmt|;
name|res_hdr
name|reshdr
decl_stmt|;
name|off
operator|=
literal|0
expr_stmt|;
name|read_res_data_hdr
argument_list|(
name|wrbfd
argument_list|,
operator|&
name|off
argument_list|,
name|omax
argument_list|,
operator|&
name|reshdr
argument_list|)
expr_stmt|;
if|if
condition|(
name|reshdr
operator|.
name|data_size
operator|!=
literal|0
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|(
name|reshdr
operator|.
name|header_size
operator|!=
literal|0x20
operator|&&
operator|!
name|target_is_bigendian
operator|)
operator|||
operator|(
name|reshdr
operator|.
name|header_size
operator|!=
literal|0x20000000
operator|&&
name|target_is_bigendian
operator|)
condition|)
return|return
literal|1
return|;
comment|/* Subtract size of HeaderSize. DataSize has to be zero. */
name|off
operator|+=
literal|0x20
operator|-
name|BIN_RES_HDR_SIZE
expr_stmt|;
if|if
condition|(
operator|(
name|off
operator|+
name|BIN_RES_HDR_SIZE
operator|)
operator|>=
name|omax
condition|)
return|return
literal|1
return|;
name|read_res_data_hdr
argument_list|(
name|wrbfd
argument_list|,
operator|&
name|off
argument_list|,
name|omax
argument_list|,
operator|&
name|reshdr
argument_list|)
expr_stmt|;
comment|/* off is advanced by BIN_RES_HDR_SIZE in read_res_data_hdr()      which is part of reshdr.header_size. We shouldn't take it      into account twice.  */
if|if
condition|(
operator|(
name|off
operator|-
name|BIN_RES_HDR_SIZE
operator|+
name|reshdr
operator|.
name|data_size
operator|+
name|reshdr
operator|.
name|header_size
operator|)
operator|>
name|omax
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Check if file is a win32 binary resource file, if so    skip past the null resource. Returns 0 if successful, -1 on    error.  */
end_comment

begin_function
specifier|static
name|void
name|skip_null_resource
parameter_list|(
name|windres_bfd
modifier|*
name|wrbfd
parameter_list|,
name|rc_uint_type
modifier|*
name|off
parameter_list|,
name|rc_uint_type
name|omax
parameter_list|)
block|{
name|res_hdr
name|reshdr
decl_stmt|;
name|read_res_data_hdr
argument_list|(
name|wrbfd
argument_list|,
name|off
argument_list|,
name|omax
argument_list|,
operator|&
name|reshdr
argument_list|)
expr_stmt|;
if|if
condition|(
name|reshdr
operator|.
name|data_size
operator|!=
literal|0
condition|)
goto|goto
name|skip_err
goto|;
if|if
condition|(
operator|(
name|reshdr
operator|.
name|header_size
operator|!=
literal|0x20
operator|&&
operator|!
name|target_is_bigendian
operator|)
operator|||
operator|(
name|reshdr
operator|.
name|header_size
operator|!=
literal|0x20000000
operator|&&
name|target_is_bigendian
operator|)
condition|)
goto|goto
name|skip_err
goto|;
comment|/* Subtract size of HeaderSize. DataSize has to be zero. */
name|off
index|[
literal|0
index|]
operator|+=
literal|0x20
operator|-
name|BIN_RES_HDR_SIZE
expr_stmt|;
if|if
condition|(
name|off
index|[
literal|0
index|]
operator|>=
name|omax
condition|)
goto|goto
name|skip_err
goto|;
return|return;
name|skip_err
label|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: %s: Not a valid WIN32 resource file\n"
argument_list|,
name|program_name
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|xexit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add a resource to resource directory */
end_comment

begin_function
specifier|static
name|void
name|res_add_resource
parameter_list|(
name|rc_res_resource
modifier|*
name|r
parameter_list|,
specifier|const
name|rc_res_id
modifier|*
name|type
parameter_list|,
specifier|const
name|rc_res_id
modifier|*
name|id
parameter_list|,
name|rc_uint_type
name|language
parameter_list|,
name|int
name|dupok
parameter_list|)
block|{
name|rc_res_id
name|a
index|[
literal|3
index|]
decl_stmt|;
name|a
index|[
literal|0
index|]
operator|=
operator|*
name|type
expr_stmt|;
name|a
index|[
literal|1
index|]
operator|=
operator|*
name|id
expr_stmt|;
name|a
index|[
literal|2
index|]
operator|.
name|named
operator|=
literal|0
expr_stmt|;
name|a
index|[
literal|2
index|]
operator|.
name|u
operator|.
name|id
operator|=
name|language
expr_stmt|;
name|res_append_resource
argument_list|(
operator|&
name|resources
argument_list|,
name|r
argument_list|,
literal|3
argument_list|,
name|a
argument_list|,
name|dupok
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Append a resource to resource directory.    This is just copied from define_resource    and modified to add an existing resource.  */
end_comment

begin_function
specifier|static
name|void
name|res_append_resource
parameter_list|(
name|rc_res_directory
modifier|*
modifier|*
name|resources
parameter_list|,
name|rc_res_resource
modifier|*
name|resource
parameter_list|,
name|int
name|cids
parameter_list|,
specifier|const
name|rc_res_id
modifier|*
name|ids
parameter_list|,
name|int
name|dupok
parameter_list|)
block|{
name|rc_res_entry
modifier|*
name|re
init|=
name|NULL
decl_stmt|;
name|int
name|i
decl_stmt|;
name|assert
argument_list|(
name|cids
operator|>
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cids
condition|;
name|i
operator|++
control|)
block|{
name|rc_res_entry
modifier|*
modifier|*
name|pp
decl_stmt|;
if|if
condition|(
operator|*
name|resources
operator|==
name|NULL
condition|)
block|{
specifier|static
name|unsigned
name|long
name|timeval
decl_stmt|;
comment|/* Use the same timestamp for every resource created in a 	     single run.  */
if|if
condition|(
name|timeval
operator|==
literal|0
condition|)
name|timeval
operator|=
name|time
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
operator|*
name|resources
operator|=
operator|(
operator|(
name|rc_res_directory
operator|*
operator|)
name|res_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|rc_res_directory
argument_list|)
argument_list|)
operator|)
expr_stmt|;
operator|(
operator|*
name|resources
operator|)
operator|->
name|characteristics
operator|=
literal|0
expr_stmt|;
operator|(
operator|*
name|resources
operator|)
operator|->
name|time
operator|=
name|timeval
expr_stmt|;
operator|(
operator|*
name|resources
operator|)
operator|->
name|major
operator|=
literal|0
expr_stmt|;
operator|(
operator|*
name|resources
operator|)
operator|->
name|minor
operator|=
literal|0
expr_stmt|;
operator|(
operator|*
name|resources
operator|)
operator|->
name|entries
operator|=
name|NULL
expr_stmt|;
block|}
for|for
control|(
name|pp
operator|=
operator|&
operator|(
operator|*
name|resources
operator|)
operator|->
name|entries
init|;
operator|*
name|pp
operator|!=
name|NULL
condition|;
name|pp
operator|=
operator|&
operator|(
operator|*
name|pp
operator|)
operator|->
name|next
control|)
if|if
condition|(
name|res_id_cmp
argument_list|(
operator|(
operator|*
name|pp
operator|)
operator|->
name|id
argument_list|,
name|ids
index|[
name|i
index|]
argument_list|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
operator|*
name|pp
operator|!=
name|NULL
condition|)
name|re
operator|=
operator|*
name|pp
expr_stmt|;
else|else
block|{
name|re
operator|=
operator|(
name|rc_res_entry
operator|*
operator|)
name|res_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|rc_res_entry
argument_list|)
argument_list|)
expr_stmt|;
name|re
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|re
operator|->
name|id
operator|=
name|ids
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|+
literal|1
operator|)
operator|<
name|cids
condition|)
block|{
name|re
operator|->
name|subdir
operator|=
literal|1
expr_stmt|;
name|re
operator|->
name|u
operator|.
name|dir
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|re
operator|->
name|subdir
operator|=
literal|0
expr_stmt|;
name|re
operator|->
name|u
operator|.
name|res
operator|=
name|NULL
expr_stmt|;
block|}
operator|*
name|pp
operator|=
name|re
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|i
operator|+
literal|1
operator|)
operator|<
name|cids
condition|)
block|{
if|if
condition|(
operator|!
name|re
operator|->
name|subdir
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: "
argument_list|,
name|program_name
argument_list|)
expr_stmt|;
name|res_ids_print
argument_list|(
name|stderr
argument_list|,
name|i
argument_list|,
name|ids
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|": expected to be a directory\n"
argument_list|)
expr_stmt|;
name|xexit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|resources
operator|=
operator|&
name|re
operator|->
name|u
operator|.
name|dir
expr_stmt|;
block|}
block|}
if|if
condition|(
name|re
operator|->
name|subdir
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: "
argument_list|,
name|program_name
argument_list|)
expr_stmt|;
name|res_ids_print
argument_list|(
name|stderr
argument_list|,
name|cids
argument_list|,
name|ids
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|": expected to be a leaf\n"
argument_list|)
expr_stmt|;
name|xexit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|re
operator|->
name|u
operator|.
name|res
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|dupok
condition|)
return|return;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: warning: "
argument_list|,
name|program_name
argument_list|)
expr_stmt|;
name|res_ids_print
argument_list|(
name|stderr
argument_list|,
name|cids
argument_list|,
name|ids
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|": duplicate value\n"
argument_list|)
expr_stmt|;
block|}
name|re
operator|->
name|u
operator|.
name|res
operator|=
name|resource
expr_stmt|;
block|}
end_function

end_unit

