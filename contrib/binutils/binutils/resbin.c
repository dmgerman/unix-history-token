begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* resbin.c -- manipulate the Windows binary resource format.    Copyright 1997, 1998, 1999 Free Software Foundation, Inc.    Written by Ian Lance Taylor, Cygnus Support.     This file is part of GNU Binutils.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA    02111-1307, USA.  */
end_comment

begin_comment
comment|/* This file contains functions to convert between the binary resource    format and the internal structures that we want to use.  The same    binary resource format is used in both res and COFF files.  */
end_comment

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"bucomm.h"
end_include

begin_include
include|#
directive|include
file|"libiberty.h"
end_include

begin_include
include|#
directive|include
file|"windres.h"
end_include

begin_comment
comment|/* Macros to swap in values.  */
end_comment

begin_define
define|#
directive|define
name|get_16
parameter_list|(
name|be
parameter_list|,
name|s
parameter_list|)
value|((be) ? bfd_getb16 (s) : bfd_getl16 (s))
end_define

begin_define
define|#
directive|define
name|get_32
parameter_list|(
name|be
parameter_list|,
name|s
parameter_list|)
value|((be) ? bfd_getb32 (s) : bfd_getl32 (s))
end_define

begin_comment
comment|/* Local functions.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|toosmall
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unichar
modifier|*
name|get_unicode
name|PARAMS
argument_list|(
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|,
name|unsigned
name|long
operator|,
name|int
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|get_resid
name|PARAMS
argument_list|(
operator|(
expr|struct
name|res_id
operator|*
operator|,
specifier|const
name|unsigned
name|char
operator|*
operator|,
name|unsigned
name|long
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|res_resource
modifier|*
name|bin_to_res_generic
name|PARAMS
argument_list|(
operator|(
expr|enum
name|res_type
operator|,
specifier|const
name|unsigned
name|char
operator|*
operator|,
name|unsigned
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|res_resource
modifier|*
name|bin_to_res_cursor
name|PARAMS
argument_list|(
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|,
name|unsigned
name|long
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|res_resource
modifier|*
name|bin_to_res_menu
name|PARAMS
argument_list|(
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|,
name|unsigned
name|long
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|menuitem
modifier|*
name|bin_to_res_menuitems
name|PARAMS
argument_list|(
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|,
name|unsigned
name|long
operator|,
name|int
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|menuitem
modifier|*
name|bin_to_res_menuexitems
name|PARAMS
argument_list|(
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|,
name|unsigned
name|long
operator|,
name|int
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|res_resource
modifier|*
name|bin_to_res_dialog
name|PARAMS
argument_list|(
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|,
name|unsigned
name|long
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|res_resource
modifier|*
name|bin_to_res_string
name|PARAMS
argument_list|(
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|,
name|unsigned
name|long
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|res_resource
modifier|*
name|bin_to_res_fontdir
name|PARAMS
argument_list|(
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|,
name|unsigned
name|long
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|res_resource
modifier|*
name|bin_to_res_accelerators
name|PARAMS
argument_list|(
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|,
name|unsigned
name|long
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|res_resource
modifier|*
name|bin_to_res_rcdata
name|PARAMS
argument_list|(
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|,
name|unsigned
name|long
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|res_resource
modifier|*
name|bin_to_res_group_cursor
name|PARAMS
argument_list|(
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|,
name|unsigned
name|long
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|res_resource
modifier|*
name|bin_to_res_group_icon
name|PARAMS
argument_list|(
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|,
name|unsigned
name|long
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|res_resource
modifier|*
name|bin_to_res_version
name|PARAMS
argument_list|(
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|,
name|unsigned
name|long
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|res_resource
modifier|*
name|bin_to_res_userdata
name|PARAMS
argument_list|(
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|,
name|unsigned
name|long
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Given a resource type ID, a pointer to data, a length, return a    res_resource structure which represents that resource.  The caller    is responsible for initializing the res_info and coff_info fields    of the returned structure.  */
end_comment

begin_function
name|struct
name|res_resource
modifier|*
name|bin_to_res
parameter_list|(
name|type
parameter_list|,
name|data
parameter_list|,
name|length
parameter_list|,
name|big_endian
parameter_list|)
name|struct
name|res_id
name|type
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|data
decl_stmt|;
name|unsigned
name|long
name|length
decl_stmt|;
name|int
name|big_endian
decl_stmt|;
block|{
if|if
condition|(
name|type
operator|.
name|named
condition|)
return|return
name|bin_to_res_userdata
argument_list|(
name|data
argument_list|,
name|length
argument_list|,
name|big_endian
argument_list|)
return|;
else|else
block|{
switch|switch
condition|(
name|type
operator|.
name|u
operator|.
name|id
condition|)
block|{
default|default:
return|return
name|bin_to_res_userdata
argument_list|(
name|data
argument_list|,
name|length
argument_list|,
name|big_endian
argument_list|)
return|;
case|case
name|RT_CURSOR
case|:
return|return
name|bin_to_res_cursor
argument_list|(
name|data
argument_list|,
name|length
argument_list|,
name|big_endian
argument_list|)
return|;
case|case
name|RT_BITMAP
case|:
return|return
name|bin_to_res_generic
argument_list|(
name|RES_TYPE_BITMAP
argument_list|,
name|data
argument_list|,
name|length
argument_list|)
return|;
case|case
name|RT_ICON
case|:
return|return
name|bin_to_res_generic
argument_list|(
name|RES_TYPE_ICON
argument_list|,
name|data
argument_list|,
name|length
argument_list|)
return|;
case|case
name|RT_MENU
case|:
return|return
name|bin_to_res_menu
argument_list|(
name|data
argument_list|,
name|length
argument_list|,
name|big_endian
argument_list|)
return|;
case|case
name|RT_DIALOG
case|:
return|return
name|bin_to_res_dialog
argument_list|(
name|data
argument_list|,
name|length
argument_list|,
name|big_endian
argument_list|)
return|;
case|case
name|RT_STRING
case|:
return|return
name|bin_to_res_string
argument_list|(
name|data
argument_list|,
name|length
argument_list|,
name|big_endian
argument_list|)
return|;
case|case
name|RT_FONTDIR
case|:
return|return
name|bin_to_res_fontdir
argument_list|(
name|data
argument_list|,
name|length
argument_list|,
name|big_endian
argument_list|)
return|;
case|case
name|RT_FONT
case|:
return|return
name|bin_to_res_generic
argument_list|(
name|RES_TYPE_FONT
argument_list|,
name|data
argument_list|,
name|length
argument_list|)
return|;
case|case
name|RT_ACCELERATOR
case|:
return|return
name|bin_to_res_accelerators
argument_list|(
name|data
argument_list|,
name|length
argument_list|,
name|big_endian
argument_list|)
return|;
case|case
name|RT_RCDATA
case|:
return|return
name|bin_to_res_rcdata
argument_list|(
name|data
argument_list|,
name|length
argument_list|,
name|big_endian
argument_list|)
return|;
case|case
name|RT_MESSAGETABLE
case|:
return|return
name|bin_to_res_generic
argument_list|(
name|RES_TYPE_MESSAGETABLE
argument_list|,
name|data
argument_list|,
name|length
argument_list|)
return|;
case|case
name|RT_GROUP_CURSOR
case|:
return|return
name|bin_to_res_group_cursor
argument_list|(
name|data
argument_list|,
name|length
argument_list|,
name|big_endian
argument_list|)
return|;
case|case
name|RT_GROUP_ICON
case|:
return|return
name|bin_to_res_group_icon
argument_list|(
name|data
argument_list|,
name|length
argument_list|,
name|big_endian
argument_list|)
return|;
case|case
name|RT_VERSION
case|:
return|return
name|bin_to_res_version
argument_list|(
name|data
argument_list|,
name|length
argument_list|,
name|big_endian
argument_list|)
return|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Give an error if the binary data is too small.  */
end_comment

begin_function
specifier|static
name|void
name|toosmall
parameter_list|(
name|msg
parameter_list|)
specifier|const
name|char
modifier|*
name|msg
decl_stmt|;
block|{
name|fatal
argument_list|(
name|_
argument_list|(
literal|"%s: not enough binary data"
argument_list|)
argument_list|,
name|msg
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Swap in a NULL terminated unicode string.  */
end_comment

begin_function
specifier|static
name|unichar
modifier|*
name|get_unicode
parameter_list|(
name|data
parameter_list|,
name|length
parameter_list|,
name|big_endian
parameter_list|,
name|retlen
parameter_list|)
specifier|const
name|unsigned
name|char
modifier|*
name|data
decl_stmt|;
name|unsigned
name|long
name|length
decl_stmt|;
name|int
name|big_endian
decl_stmt|;
name|int
modifier|*
name|retlen
decl_stmt|;
block|{
name|int
name|c
decl_stmt|,
name|i
decl_stmt|;
name|unichar
modifier|*
name|ret
decl_stmt|;
name|c
operator|=
literal|0
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|length
operator|<
operator|(
name|unsigned
name|long
operator|)
name|c
operator|*
literal|2
operator|+
literal|2
condition|)
name|toosmall
argument_list|(
name|_
argument_list|(
literal|"null terminated unicode string"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|get_16
argument_list|(
name|big_endian
argument_list|,
name|data
operator|+
name|c
operator|*
literal|2
argument_list|)
operator|==
literal|0
condition|)
break|break;
operator|++
name|c
expr_stmt|;
block|}
name|ret
operator|=
operator|(
name|unichar
operator|*
operator|)
name|res_alloc
argument_list|(
operator|(
name|c
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|unichar
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|c
condition|;
name|i
operator|++
control|)
name|ret
index|[
name|i
index|]
operator|=
name|get_16
argument_list|(
name|big_endian
argument_list|,
name|data
operator|+
name|i
operator|*
literal|2
argument_list|)
expr_stmt|;
name|ret
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|retlen
operator|!=
name|NULL
condition|)
operator|*
name|retlen
operator|=
name|c
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Get a resource identifier.  This returns the number of bytes used.  */
end_comment

begin_function
specifier|static
name|int
name|get_resid
parameter_list|(
name|id
parameter_list|,
name|data
parameter_list|,
name|length
parameter_list|,
name|big_endian
parameter_list|)
name|struct
name|res_id
modifier|*
name|id
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|data
decl_stmt|;
name|unsigned
name|long
name|length
decl_stmt|;
name|int
name|big_endian
decl_stmt|;
block|{
name|int
name|first
decl_stmt|;
if|if
condition|(
name|length
operator|<
literal|2
condition|)
name|toosmall
argument_list|(
name|_
argument_list|(
literal|"resource ID"
argument_list|)
argument_list|)
expr_stmt|;
name|first
operator|=
name|get_16
argument_list|(
name|big_endian
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|first
operator|==
literal|0xffff
condition|)
block|{
if|if
condition|(
name|length
operator|<
literal|4
condition|)
name|toosmall
argument_list|(
name|_
argument_list|(
literal|"resource ID"
argument_list|)
argument_list|)
expr_stmt|;
name|id
operator|->
name|named
operator|=
literal|0
expr_stmt|;
name|id
operator|->
name|u
operator|.
name|id
operator|=
name|get_16
argument_list|(
name|big_endian
argument_list|,
name|data
operator|+
literal|2
argument_list|)
expr_stmt|;
return|return
literal|4
return|;
block|}
else|else
block|{
name|id
operator|->
name|named
operator|=
literal|1
expr_stmt|;
name|id
operator|->
name|u
operator|.
name|n
operator|.
name|name
operator|=
name|get_unicode
argument_list|(
name|data
argument_list|,
name|length
argument_list|,
name|big_endian
argument_list|,
operator|&
name|id
operator|->
name|u
operator|.
name|n
operator|.
name|length
argument_list|)
expr_stmt|;
return|return
name|id
operator|->
name|u
operator|.
name|n
operator|.
name|length
operator|*
literal|2
operator|+
literal|2
return|;
block|}
block|}
end_function

begin_comment
comment|/* Convert a resource which just stores uninterpreted data from    binary.  */
end_comment

begin_function
name|struct
name|res_resource
modifier|*
name|bin_to_res_generic
parameter_list|(
name|type
parameter_list|,
name|data
parameter_list|,
name|length
parameter_list|)
name|enum
name|res_type
name|type
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|data
decl_stmt|;
name|unsigned
name|long
name|length
decl_stmt|;
block|{
name|struct
name|res_resource
modifier|*
name|r
decl_stmt|;
name|r
operator|=
operator|(
expr|struct
name|res_resource
operator|*
operator|)
name|res_alloc
argument_list|(
sizeof|sizeof
expr|*
name|r
argument_list|)
expr_stmt|;
name|r
operator|->
name|type
operator|=
name|type
expr_stmt|;
name|r
operator|->
name|u
operator|.
name|data
operator|.
name|data
operator|=
name|data
expr_stmt|;
name|r
operator|->
name|u
operator|.
name|data
operator|.
name|length
operator|=
name|length
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/* Convert a cursor resource from binary.  */
end_comment

begin_function
name|struct
name|res_resource
modifier|*
name|bin_to_res_cursor
parameter_list|(
name|data
parameter_list|,
name|length
parameter_list|,
name|big_endian
parameter_list|)
specifier|const
name|unsigned
name|char
modifier|*
name|data
decl_stmt|;
name|unsigned
name|long
name|length
decl_stmt|;
name|int
name|big_endian
decl_stmt|;
block|{
name|struct
name|cursor
modifier|*
name|c
decl_stmt|;
name|struct
name|res_resource
modifier|*
name|r
decl_stmt|;
if|if
condition|(
name|length
operator|<
literal|4
condition|)
name|toosmall
argument_list|(
name|_
argument_list|(
literal|"cursor"
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|=
operator|(
expr|struct
name|cursor
operator|*
operator|)
name|res_alloc
argument_list|(
sizeof|sizeof
expr|*
name|c
argument_list|)
expr_stmt|;
name|c
operator|->
name|xhotspot
operator|=
name|get_16
argument_list|(
name|big_endian
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|c
operator|->
name|yhotspot
operator|=
name|get_16
argument_list|(
name|big_endian
argument_list|,
name|data
operator|+
literal|2
argument_list|)
expr_stmt|;
name|c
operator|->
name|length
operator|=
name|length
operator|-
literal|4
expr_stmt|;
name|c
operator|->
name|data
operator|=
name|data
operator|+
literal|4
expr_stmt|;
name|r
operator|=
operator|(
expr|struct
name|res_resource
operator|*
operator|)
name|res_alloc
argument_list|(
sizeof|sizeof
expr|*
name|r
argument_list|)
expr_stmt|;
name|r
operator|->
name|type
operator|=
name|RES_TYPE_CURSOR
expr_stmt|;
name|r
operator|->
name|u
operator|.
name|cursor
operator|=
name|c
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/* Convert a menu resource from binary.  */
end_comment

begin_function
name|struct
name|res_resource
modifier|*
name|bin_to_res_menu
parameter_list|(
name|data
parameter_list|,
name|length
parameter_list|,
name|big_endian
parameter_list|)
specifier|const
name|unsigned
name|char
modifier|*
name|data
decl_stmt|;
name|unsigned
name|long
name|length
decl_stmt|;
name|int
name|big_endian
decl_stmt|;
block|{
name|struct
name|res_resource
modifier|*
name|r
decl_stmt|;
name|struct
name|menu
modifier|*
name|m
decl_stmt|;
name|int
name|version
decl_stmt|,
name|read
decl_stmt|;
name|r
operator|=
operator|(
expr|struct
name|res_resource
operator|*
operator|)
name|res_alloc
argument_list|(
sizeof|sizeof
expr|*
name|r
argument_list|)
expr_stmt|;
name|r
operator|->
name|type
operator|=
name|RES_TYPE_MENU
expr_stmt|;
name|m
operator|=
operator|(
expr|struct
name|menu
operator|*
operator|)
name|res_alloc
argument_list|(
sizeof|sizeof
expr|*
name|m
argument_list|)
expr_stmt|;
name|r
operator|->
name|u
operator|.
name|menu
operator|=
name|m
expr_stmt|;
if|if
condition|(
name|length
operator|<
literal|2
condition|)
name|toosmall
argument_list|(
name|_
argument_list|(
literal|"menu header"
argument_list|)
argument_list|)
expr_stmt|;
name|version
operator|=
name|get_16
argument_list|(
name|big_endian
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|version
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|length
operator|<
literal|4
condition|)
name|toosmall
argument_list|(
name|_
argument_list|(
literal|"menu header"
argument_list|)
argument_list|)
expr_stmt|;
name|m
operator|->
name|help
operator|=
literal|0
expr_stmt|;
name|m
operator|->
name|items
operator|=
name|bin_to_res_menuitems
argument_list|(
name|data
operator|+
literal|4
argument_list|,
name|length
operator|-
literal|4
argument_list|,
name|big_endian
argument_list|,
operator|&
name|read
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|version
operator|==
literal|1
condition|)
block|{
name|unsigned
name|int
name|offset
decl_stmt|;
if|if
condition|(
name|length
operator|<
literal|8
condition|)
name|toosmall
argument_list|(
name|_
argument_list|(
literal|"menuex header"
argument_list|)
argument_list|)
expr_stmt|;
name|m
operator|->
name|help
operator|=
name|get_32
argument_list|(
name|big_endian
argument_list|,
name|data
operator|+
literal|4
argument_list|)
expr_stmt|;
name|offset
operator|=
name|get_16
argument_list|(
name|big_endian
argument_list|,
name|data
operator|+
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|+
literal|4
operator|>=
name|length
condition|)
name|toosmall
argument_list|(
name|_
argument_list|(
literal|"menuex offset"
argument_list|)
argument_list|)
expr_stmt|;
name|m
operator|->
name|items
operator|=
name|bin_to_res_menuexitems
argument_list|(
name|data
operator|+
literal|4
operator|+
name|offset
argument_list|,
name|length
operator|-
operator|(
literal|4
operator|+
name|offset
operator|)
argument_list|,
name|big_endian
argument_list|,
operator|&
name|read
argument_list|)
expr_stmt|;
block|}
else|else
name|fatal
argument_list|(
name|_
argument_list|(
literal|"unsupported menu version %d"
argument_list|)
argument_list|,
name|version
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/* Convert menu items from binary.  */
end_comment

begin_function
specifier|static
name|struct
name|menuitem
modifier|*
name|bin_to_res_menuitems
parameter_list|(
name|data
parameter_list|,
name|length
parameter_list|,
name|big_endian
parameter_list|,
name|read
parameter_list|)
specifier|const
name|unsigned
name|char
modifier|*
name|data
decl_stmt|;
name|unsigned
name|long
name|length
decl_stmt|;
name|int
name|big_endian
decl_stmt|;
name|int
modifier|*
name|read
decl_stmt|;
block|{
name|struct
name|menuitem
modifier|*
name|first
decl_stmt|,
modifier|*
modifier|*
name|pp
decl_stmt|;
name|first
operator|=
name|NULL
expr_stmt|;
name|pp
operator|=
operator|&
name|first
expr_stmt|;
operator|*
name|read
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|length
operator|>
literal|0
condition|)
block|{
name|int
name|flags
decl_stmt|,
name|slen
decl_stmt|,
name|itemlen
decl_stmt|;
name|unsigned
name|int
name|stroff
decl_stmt|;
name|struct
name|menuitem
modifier|*
name|mi
decl_stmt|;
if|if
condition|(
name|length
operator|<
literal|4
condition|)
name|toosmall
argument_list|(
name|_
argument_list|(
literal|"menuitem header"
argument_list|)
argument_list|)
expr_stmt|;
name|mi
operator|=
operator|(
expr|struct
name|menuitem
operator|*
operator|)
name|res_alloc
argument_list|(
sizeof|sizeof
expr|*
name|mi
argument_list|)
expr_stmt|;
name|mi
operator|->
name|state
operator|=
literal|0
expr_stmt|;
name|mi
operator|->
name|help
operator|=
literal|0
expr_stmt|;
name|flags
operator|=
name|get_16
argument_list|(
name|big_endian
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|mi
operator|->
name|type
operator|=
name|flags
operator|&
operator|~
operator|(
name|MENUITEM_POPUP
operator||
name|MENUITEM_ENDMENU
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|MENUITEM_POPUP
operator|)
operator|==
literal|0
condition|)
name|stroff
operator|=
literal|4
expr_stmt|;
else|else
name|stroff
operator|=
literal|2
expr_stmt|;
if|if
condition|(
name|length
operator|<
name|stroff
operator|+
literal|2
condition|)
name|toosmall
argument_list|(
name|_
argument_list|(
literal|"menuitem header"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|get_16
argument_list|(
name|big_endian
argument_list|,
name|data
operator|+
name|stroff
argument_list|)
operator|==
literal|0
condition|)
block|{
name|slen
operator|=
literal|0
expr_stmt|;
name|mi
operator|->
name|text
operator|=
name|NULL
expr_stmt|;
block|}
else|else
name|mi
operator|->
name|text
operator|=
name|get_unicode
argument_list|(
name|data
operator|+
name|stroff
argument_list|,
name|length
operator|-
name|stroff
argument_list|,
name|big_endian
argument_list|,
operator|&
name|slen
argument_list|)
expr_stmt|;
name|itemlen
operator|=
name|stroff
operator|+
name|slen
operator|*
literal|2
operator|+
literal|2
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|MENUITEM_POPUP
operator|)
operator|==
literal|0
condition|)
block|{
name|mi
operator|->
name|popup
operator|=
name|NULL
expr_stmt|;
name|mi
operator|->
name|id
operator|=
name|get_16
argument_list|(
name|big_endian
argument_list|,
name|data
operator|+
literal|2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|subread
decl_stmt|;
name|mi
operator|->
name|id
operator|=
literal|0
expr_stmt|;
name|mi
operator|->
name|popup
operator|=
name|bin_to_res_menuitems
argument_list|(
name|data
operator|+
name|itemlen
argument_list|,
name|length
operator|-
name|itemlen
argument_list|,
name|big_endian
argument_list|,
operator|&
name|subread
argument_list|)
expr_stmt|;
name|itemlen
operator|+=
name|subread
expr_stmt|;
block|}
name|mi
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
operator|*
name|pp
operator|=
name|mi
expr_stmt|;
name|pp
operator|=
operator|&
name|mi
operator|->
name|next
expr_stmt|;
name|data
operator|+=
name|itemlen
expr_stmt|;
name|length
operator|-=
name|itemlen
expr_stmt|;
operator|*
name|read
operator|+=
name|itemlen
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|MENUITEM_ENDMENU
operator|)
operator|!=
literal|0
condition|)
return|return
name|first
return|;
block|}
return|return
name|first
return|;
block|}
end_function

begin_comment
comment|/* Convert menuex items from binary.  */
end_comment

begin_function
specifier|static
name|struct
name|menuitem
modifier|*
name|bin_to_res_menuexitems
parameter_list|(
name|data
parameter_list|,
name|length
parameter_list|,
name|big_endian
parameter_list|,
name|read
parameter_list|)
specifier|const
name|unsigned
name|char
modifier|*
name|data
decl_stmt|;
name|unsigned
name|long
name|length
decl_stmt|;
name|int
name|big_endian
decl_stmt|;
name|int
modifier|*
name|read
decl_stmt|;
block|{
name|struct
name|menuitem
modifier|*
name|first
decl_stmt|,
modifier|*
modifier|*
name|pp
decl_stmt|;
name|first
operator|=
name|NULL
expr_stmt|;
name|pp
operator|=
operator|&
name|first
expr_stmt|;
operator|*
name|read
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|length
operator|>
literal|0
condition|)
block|{
name|int
name|flags
decl_stmt|,
name|slen
decl_stmt|;
name|unsigned
name|int
name|itemlen
decl_stmt|;
name|struct
name|menuitem
modifier|*
name|mi
decl_stmt|;
if|if
condition|(
name|length
operator|<
literal|14
condition|)
name|toosmall
argument_list|(
name|_
argument_list|(
literal|"menuitem header"
argument_list|)
argument_list|)
expr_stmt|;
name|mi
operator|=
operator|(
expr|struct
name|menuitem
operator|*
operator|)
name|res_alloc
argument_list|(
sizeof|sizeof
expr|*
name|mi
argument_list|)
expr_stmt|;
name|mi
operator|->
name|type
operator|=
name|get_32
argument_list|(
name|big_endian
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|mi
operator|->
name|state
operator|=
name|get_32
argument_list|(
name|big_endian
argument_list|,
name|data
operator|+
literal|4
argument_list|)
expr_stmt|;
name|mi
operator|->
name|id
operator|=
name|get_16
argument_list|(
name|big_endian
argument_list|,
name|data
operator|+
literal|8
argument_list|)
expr_stmt|;
name|flags
operator|=
name|get_16
argument_list|(
name|big_endian
argument_list|,
name|data
operator|+
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|get_16
argument_list|(
name|big_endian
argument_list|,
name|data
operator|+
literal|12
argument_list|)
operator|==
literal|0
condition|)
block|{
name|slen
operator|=
literal|0
expr_stmt|;
name|mi
operator|->
name|text
operator|=
name|NULL
expr_stmt|;
block|}
else|else
name|mi
operator|->
name|text
operator|=
name|get_unicode
argument_list|(
name|data
operator|+
literal|12
argument_list|,
name|length
operator|-
literal|12
argument_list|,
name|big_endian
argument_list|,
operator|&
name|slen
argument_list|)
expr_stmt|;
name|itemlen
operator|=
literal|12
operator|+
name|slen
operator|*
literal|2
operator|+
literal|2
expr_stmt|;
name|itemlen
operator|=
operator|(
name|itemlen
operator|+
literal|3
operator|)
operator|&
operator|~
literal|3
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
block|{
name|mi
operator|->
name|popup
operator|=
name|NULL
expr_stmt|;
name|mi
operator|->
name|help
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|int
name|subread
decl_stmt|;
if|if
condition|(
name|length
operator|<
name|itemlen
operator|+
literal|4
condition|)
name|toosmall
argument_list|(
name|_
argument_list|(
literal|"menuitem"
argument_list|)
argument_list|)
expr_stmt|;
name|mi
operator|->
name|help
operator|=
name|get_32
argument_list|(
name|big_endian
argument_list|,
name|data
operator|+
name|itemlen
argument_list|)
expr_stmt|;
name|itemlen
operator|+=
literal|4
expr_stmt|;
name|mi
operator|->
name|popup
operator|=
name|bin_to_res_menuexitems
argument_list|(
name|data
operator|+
name|itemlen
argument_list|,
name|length
operator|-
name|itemlen
argument_list|,
name|big_endian
argument_list|,
operator|&
name|subread
argument_list|)
expr_stmt|;
name|itemlen
operator|+=
name|subread
expr_stmt|;
block|}
name|mi
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
operator|*
name|pp
operator|=
name|mi
expr_stmt|;
name|pp
operator|=
operator|&
name|mi
operator|->
name|next
expr_stmt|;
name|data
operator|+=
name|itemlen
expr_stmt|;
name|length
operator|-=
name|itemlen
expr_stmt|;
operator|*
name|read
operator|+=
name|itemlen
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
literal|0x80
operator|)
operator|!=
literal|0
condition|)
return|return
name|first
return|;
block|}
return|return
name|first
return|;
block|}
end_function

begin_comment
comment|/* Convert a dialog resource from binary.  */
end_comment

begin_function
specifier|static
name|struct
name|res_resource
modifier|*
name|bin_to_res_dialog
parameter_list|(
name|data
parameter_list|,
name|length
parameter_list|,
name|big_endian
parameter_list|)
specifier|const
name|unsigned
name|char
modifier|*
name|data
decl_stmt|;
name|unsigned
name|long
name|length
decl_stmt|;
name|int
name|big_endian
decl_stmt|;
block|{
name|int
name|version
decl_stmt|;
name|struct
name|dialog
modifier|*
name|d
decl_stmt|;
name|int
name|c
decl_stmt|,
name|sublen
decl_stmt|,
name|i
decl_stmt|;
name|unsigned
name|int
name|off
decl_stmt|;
name|struct
name|dialog_control
modifier|*
modifier|*
name|pp
decl_stmt|;
name|struct
name|res_resource
modifier|*
name|r
decl_stmt|;
if|if
condition|(
name|length
operator|<
literal|18
condition|)
name|toosmall
argument_list|(
name|_
argument_list|(
literal|"dialog header"
argument_list|)
argument_list|)
expr_stmt|;
name|d
operator|=
operator|(
expr|struct
name|dialog
operator|*
operator|)
name|res_alloc
argument_list|(
sizeof|sizeof
expr|*
name|d
argument_list|)
expr_stmt|;
name|version
operator|=
name|get_16
argument_list|(
name|big_endian
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|version
operator|!=
literal|1
condition|)
block|{
name|d
operator|->
name|ex
operator|=
name|NULL
expr_stmt|;
name|d
operator|->
name|style
operator|=
name|get_32
argument_list|(
name|big_endian
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|d
operator|->
name|exstyle
operator|=
name|get_32
argument_list|(
name|big_endian
argument_list|,
name|data
operator|+
literal|4
argument_list|)
expr_stmt|;
name|off
operator|=
literal|8
expr_stmt|;
block|}
else|else
block|{
name|int
name|signature
decl_stmt|;
name|signature
operator|=
name|get_16
argument_list|(
name|big_endian
argument_list|,
name|data
operator|+
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|signature
operator|!=
literal|0xffff
condition|)
name|fatal
argument_list|(
name|_
argument_list|(
literal|"unexpected dialog signature %d"
argument_list|)
argument_list|,
name|signature
argument_list|)
expr_stmt|;
name|d
operator|->
name|ex
operator|=
operator|(
expr|struct
name|dialog_ex
operator|*
operator|)
name|res_alloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|dialog_ex
argument_list|)
argument_list|)
expr_stmt|;
name|d
operator|->
name|ex
operator|->
name|help
operator|=
name|get_32
argument_list|(
name|big_endian
argument_list|,
name|data
operator|+
literal|4
argument_list|)
expr_stmt|;
name|d
operator|->
name|exstyle
operator|=
name|get_32
argument_list|(
name|big_endian
argument_list|,
name|data
operator|+
literal|8
argument_list|)
expr_stmt|;
name|d
operator|->
name|style
operator|=
name|get_32
argument_list|(
name|big_endian
argument_list|,
name|data
operator|+
literal|12
argument_list|)
expr_stmt|;
name|off
operator|=
literal|16
expr_stmt|;
block|}
if|if
condition|(
name|length
operator|<
name|off
operator|+
literal|10
condition|)
name|toosmall
argument_list|(
name|_
argument_list|(
literal|"dialog header"
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|=
name|get_16
argument_list|(
name|big_endian
argument_list|,
name|data
operator|+
name|off
argument_list|)
expr_stmt|;
name|d
operator|->
name|x
operator|=
name|get_16
argument_list|(
name|big_endian
argument_list|,
name|data
operator|+
name|off
operator|+
literal|2
argument_list|)
expr_stmt|;
name|d
operator|->
name|y
operator|=
name|get_16
argument_list|(
name|big_endian
argument_list|,
name|data
operator|+
name|off
operator|+
literal|4
argument_list|)
expr_stmt|;
name|d
operator|->
name|width
operator|=
name|get_16
argument_list|(
name|big_endian
argument_list|,
name|data
operator|+
name|off
operator|+
literal|6
argument_list|)
expr_stmt|;
name|d
operator|->
name|height
operator|=
name|get_16
argument_list|(
name|big_endian
argument_list|,
name|data
operator|+
name|off
operator|+
literal|8
argument_list|)
expr_stmt|;
name|off
operator|+=
literal|10
expr_stmt|;
name|sublen
operator|=
name|get_resid
argument_list|(
operator|&
name|d
operator|->
name|menu
argument_list|,
name|data
operator|+
name|off
argument_list|,
name|length
operator|-
name|off
argument_list|,
name|big_endian
argument_list|)
expr_stmt|;
name|off
operator|+=
name|sublen
expr_stmt|;
name|sublen
operator|=
name|get_resid
argument_list|(
operator|&
name|d
operator|->
name|class
argument_list|,
name|data
operator|+
name|off
argument_list|,
name|length
operator|-
name|off
argument_list|,
name|big_endian
argument_list|)
expr_stmt|;
name|off
operator|+=
name|sublen
expr_stmt|;
name|d
operator|->
name|caption
operator|=
name|get_unicode
argument_list|(
name|data
operator|+
name|off
argument_list|,
name|length
operator|-
name|off
argument_list|,
name|big_endian
argument_list|,
operator|&
name|sublen
argument_list|)
expr_stmt|;
name|off
operator|+=
name|sublen
operator|*
literal|2
operator|+
literal|2
expr_stmt|;
if|if
condition|(
operator|(
name|d
operator|->
name|style
operator|&
name|DS_SETFONT
operator|)
operator|==
literal|0
condition|)
block|{
name|d
operator|->
name|pointsize
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|font
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|ex
operator|!=
name|NULL
condition|)
block|{
name|d
operator|->
name|ex
operator|->
name|weight
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|ex
operator|->
name|italic
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|length
operator|<
name|off
operator|+
literal|2
condition|)
name|toosmall
argument_list|(
name|_
argument_list|(
literal|"dialog font point size"
argument_list|)
argument_list|)
expr_stmt|;
name|d
operator|->
name|pointsize
operator|=
name|get_16
argument_list|(
name|big_endian
argument_list|,
name|data
operator|+
name|off
argument_list|)
expr_stmt|;
name|off
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|ex
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|length
operator|<
name|off
operator|+
literal|4
condition|)
name|toosmall
argument_list|(
name|_
argument_list|(
literal|"dialogex font information"
argument_list|)
argument_list|)
expr_stmt|;
name|d
operator|->
name|ex
operator|->
name|weight
operator|=
name|get_16
argument_list|(
name|big_endian
argument_list|,
name|data
operator|+
name|off
argument_list|)
expr_stmt|;
name|d
operator|->
name|ex
operator|->
name|italic
operator|=
name|get_16
argument_list|(
name|big_endian
argument_list|,
name|data
operator|+
name|off
operator|+
literal|2
argument_list|)
expr_stmt|;
name|off
operator|+=
literal|4
expr_stmt|;
block|}
name|d
operator|->
name|font
operator|=
name|get_unicode
argument_list|(
name|data
operator|+
name|off
argument_list|,
name|length
operator|-
name|off
argument_list|,
name|big_endian
argument_list|,
operator|&
name|sublen
argument_list|)
expr_stmt|;
name|off
operator|+=
name|sublen
operator|*
literal|2
operator|+
literal|2
expr_stmt|;
block|}
name|d
operator|->
name|controls
operator|=
name|NULL
expr_stmt|;
name|pp
operator|=
operator|&
name|d
operator|->
name|controls
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|c
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|dialog_control
modifier|*
name|dc
decl_stmt|;
name|int
name|datalen
decl_stmt|;
name|off
operator|=
operator|(
name|off
operator|+
literal|3
operator|)
operator|&
operator|~
literal|3
expr_stmt|;
name|dc
operator|=
operator|(
expr|struct
name|dialog_control
operator|*
operator|)
name|res_alloc
argument_list|(
sizeof|sizeof
expr|*
name|dc
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|ex
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|length
operator|<
name|off
operator|+
literal|8
condition|)
name|toosmall
argument_list|(
name|_
argument_list|(
literal|"dialog control"
argument_list|)
argument_list|)
expr_stmt|;
name|dc
operator|->
name|style
operator|=
name|get_32
argument_list|(
name|big_endian
argument_list|,
name|data
operator|+
name|off
argument_list|)
expr_stmt|;
name|dc
operator|->
name|exstyle
operator|=
name|get_32
argument_list|(
name|big_endian
argument_list|,
name|data
operator|+
name|off
operator|+
literal|4
argument_list|)
expr_stmt|;
name|dc
operator|->
name|help
operator|=
literal|0
expr_stmt|;
name|off
operator|+=
literal|8
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|length
operator|<
name|off
operator|+
literal|12
condition|)
name|toosmall
argument_list|(
name|_
argument_list|(
literal|"dialogex control"
argument_list|)
argument_list|)
expr_stmt|;
name|dc
operator|->
name|help
operator|=
name|get_32
argument_list|(
name|big_endian
argument_list|,
name|data
operator|+
name|off
argument_list|)
expr_stmt|;
name|dc
operator|->
name|exstyle
operator|=
name|get_32
argument_list|(
name|big_endian
argument_list|,
name|data
operator|+
name|off
operator|+
literal|4
argument_list|)
expr_stmt|;
name|dc
operator|->
name|style
operator|=
name|get_32
argument_list|(
name|big_endian
argument_list|,
name|data
operator|+
name|off
operator|+
literal|8
argument_list|)
expr_stmt|;
name|off
operator|+=
literal|12
expr_stmt|;
block|}
if|if
condition|(
name|length
operator|<
name|off
operator|+
literal|10
condition|)
name|toosmall
argument_list|(
name|_
argument_list|(
literal|"dialog control"
argument_list|)
argument_list|)
expr_stmt|;
name|dc
operator|->
name|x
operator|=
name|get_16
argument_list|(
name|big_endian
argument_list|,
name|data
operator|+
name|off
argument_list|)
expr_stmt|;
name|dc
operator|->
name|y
operator|=
name|get_16
argument_list|(
name|big_endian
argument_list|,
name|data
operator|+
name|off
operator|+
literal|2
argument_list|)
expr_stmt|;
name|dc
operator|->
name|width
operator|=
name|get_16
argument_list|(
name|big_endian
argument_list|,
name|data
operator|+
name|off
operator|+
literal|4
argument_list|)
expr_stmt|;
name|dc
operator|->
name|height
operator|=
name|get_16
argument_list|(
name|big_endian
argument_list|,
name|data
operator|+
name|off
operator|+
literal|6
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|ex
operator|!=
name|NULL
condition|)
name|dc
operator|->
name|id
operator|=
name|get_32
argument_list|(
name|big_endian
argument_list|,
name|data
operator|+
name|off
operator|+
literal|8
argument_list|)
expr_stmt|;
else|else
name|dc
operator|->
name|id
operator|=
name|get_16
argument_list|(
name|big_endian
argument_list|,
name|data
operator|+
name|off
operator|+
literal|8
argument_list|)
expr_stmt|;
name|off
operator|+=
literal|10
operator|+
operator|(
name|d
operator|->
name|ex
operator|!=
name|NULL
condition|?
literal|2
else|:
literal|0
operator|)
expr_stmt|;
name|sublen
operator|=
name|get_resid
argument_list|(
operator|&
name|dc
operator|->
name|class
argument_list|,
name|data
operator|+
name|off
argument_list|,
name|length
operator|-
name|off
argument_list|,
name|big_endian
argument_list|)
expr_stmt|;
name|off
operator|+=
name|sublen
expr_stmt|;
name|sublen
operator|=
name|get_resid
argument_list|(
operator|&
name|dc
operator|->
name|text
argument_list|,
name|data
operator|+
name|off
argument_list|,
name|length
operator|-
name|off
argument_list|,
name|big_endian
argument_list|)
expr_stmt|;
name|off
operator|+=
name|sublen
expr_stmt|;
if|if
condition|(
name|length
operator|<
name|off
operator|+
literal|2
condition|)
name|toosmall
argument_list|(
name|_
argument_list|(
literal|"dialog control end"
argument_list|)
argument_list|)
expr_stmt|;
name|datalen
operator|=
name|get_16
argument_list|(
name|big_endian
argument_list|,
name|data
operator|+
name|off
argument_list|)
expr_stmt|;
name|off
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|datalen
operator|==
literal|0
condition|)
name|dc
operator|->
name|data
operator|=
name|NULL
expr_stmt|;
else|else
block|{
name|off
operator|=
operator|(
name|off
operator|+
literal|3
operator|)
operator|&
operator|~
literal|3
expr_stmt|;
if|if
condition|(
name|length
operator|<
name|off
operator|+
name|datalen
condition|)
name|toosmall
argument_list|(
name|_
argument_list|(
literal|"dialog control data"
argument_list|)
argument_list|)
expr_stmt|;
name|dc
operator|->
name|data
operator|=
operator|(
operator|(
expr|struct
name|rcdata_item
operator|*
operator|)
name|res_alloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|rcdata_item
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|dc
operator|->
name|data
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|dc
operator|->
name|data
operator|->
name|type
operator|=
name|RCDATA_BUFFER
expr_stmt|;
name|dc
operator|->
name|data
operator|->
name|u
operator|.
name|buffer
operator|.
name|length
operator|=
name|datalen
expr_stmt|;
name|dc
operator|->
name|data
operator|->
name|u
operator|.
name|buffer
operator|.
name|data
operator|=
name|data
operator|+
name|off
expr_stmt|;
name|off
operator|+=
name|datalen
expr_stmt|;
block|}
name|dc
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
operator|*
name|pp
operator|=
name|dc
expr_stmt|;
name|pp
operator|=
operator|&
name|dc
operator|->
name|next
expr_stmt|;
block|}
name|r
operator|=
operator|(
expr|struct
name|res_resource
operator|*
operator|)
name|res_alloc
argument_list|(
sizeof|sizeof
expr|*
name|r
argument_list|)
expr_stmt|;
name|r
operator|->
name|type
operator|=
name|RES_TYPE_DIALOG
expr_stmt|;
name|r
operator|->
name|u
operator|.
name|dialog
operator|=
name|d
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/* Convert a stringtable resource from binary.  */
end_comment

begin_function
specifier|static
name|struct
name|res_resource
modifier|*
name|bin_to_res_string
parameter_list|(
name|data
parameter_list|,
name|length
parameter_list|,
name|big_endian
parameter_list|)
specifier|const
name|unsigned
name|char
modifier|*
name|data
decl_stmt|;
name|unsigned
name|long
name|length
decl_stmt|;
name|int
name|big_endian
decl_stmt|;
block|{
name|struct
name|stringtable
modifier|*
name|st
decl_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|res_resource
modifier|*
name|r
decl_stmt|;
name|st
operator|=
operator|(
expr|struct
name|stringtable
operator|*
operator|)
name|res_alloc
argument_list|(
sizeof|sizeof
expr|*
name|st
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
block|{
name|unsigned
name|int
name|slen
decl_stmt|;
if|if
condition|(
name|length
operator|<
literal|2
condition|)
name|toosmall
argument_list|(
name|_
argument_list|(
literal|"stringtable string length"
argument_list|)
argument_list|)
expr_stmt|;
name|slen
operator|=
name|get_16
argument_list|(
name|big_endian
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|st
operator|->
name|strings
index|[
name|i
index|]
operator|.
name|length
operator|=
name|slen
expr_stmt|;
if|if
condition|(
name|slen
operator|>
literal|0
condition|)
block|{
name|unichar
modifier|*
name|s
decl_stmt|;
name|unsigned
name|int
name|j
decl_stmt|;
if|if
condition|(
name|length
operator|<
literal|2
operator|+
literal|2
operator|*
name|slen
condition|)
name|toosmall
argument_list|(
name|_
argument_list|(
literal|"stringtable string"
argument_list|)
argument_list|)
expr_stmt|;
name|s
operator|=
operator|(
name|unichar
operator|*
operator|)
name|res_alloc
argument_list|(
name|slen
operator|*
sizeof|sizeof
argument_list|(
name|unichar
argument_list|)
argument_list|)
expr_stmt|;
name|st
operator|->
name|strings
index|[
name|i
index|]
operator|.
name|string
operator|=
name|s
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|slen
condition|;
name|j
operator|++
control|)
name|s
index|[
name|j
index|]
operator|=
name|get_16
argument_list|(
name|big_endian
argument_list|,
name|data
operator|+
literal|2
operator|+
name|j
operator|*
literal|2
argument_list|)
expr_stmt|;
block|}
name|data
operator|+=
literal|2
operator|+
literal|2
operator|*
name|slen
expr_stmt|;
name|length
operator|-=
literal|2
operator|+
literal|2
operator|*
name|slen
expr_stmt|;
block|}
name|r
operator|=
operator|(
expr|struct
name|res_resource
operator|*
operator|)
name|res_alloc
argument_list|(
sizeof|sizeof
expr|*
name|r
argument_list|)
expr_stmt|;
name|r
operator|->
name|type
operator|=
name|RES_TYPE_STRINGTABLE
expr_stmt|;
name|r
operator|->
name|u
operator|.
name|stringtable
operator|=
name|st
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/* Convert a fontdir resource from binary.  */
end_comment

begin_function
specifier|static
name|struct
name|res_resource
modifier|*
name|bin_to_res_fontdir
parameter_list|(
name|data
parameter_list|,
name|length
parameter_list|,
name|big_endian
parameter_list|)
specifier|const
name|unsigned
name|char
modifier|*
name|data
decl_stmt|;
name|unsigned
name|long
name|length
decl_stmt|;
name|int
name|big_endian
decl_stmt|;
block|{
name|int
name|c
decl_stmt|,
name|i
decl_stmt|;
name|struct
name|fontdir
modifier|*
name|first
decl_stmt|,
modifier|*
modifier|*
name|pp
decl_stmt|;
name|struct
name|res_resource
modifier|*
name|r
decl_stmt|;
if|if
condition|(
name|length
operator|<
literal|2
condition|)
name|toosmall
argument_list|(
name|_
argument_list|(
literal|"fontdir header"
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|=
name|get_16
argument_list|(
name|big_endian
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|first
operator|=
name|NULL
expr_stmt|;
name|pp
operator|=
operator|&
name|first
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|c
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|fontdir
modifier|*
name|fd
decl_stmt|;
name|unsigned
name|int
name|off
decl_stmt|;
if|if
condition|(
name|length
operator|<
literal|56
condition|)
name|toosmall
argument_list|(
name|_
argument_list|(
literal|"fontdir"
argument_list|)
argument_list|)
expr_stmt|;
name|fd
operator|=
operator|(
expr|struct
name|fontdir
operator|*
operator|)
name|res_alloc
argument_list|(
sizeof|sizeof
expr|*
name|fd
argument_list|)
expr_stmt|;
name|fd
operator|->
name|index
operator|=
name|get_16
argument_list|(
name|big_endian
argument_list|,
name|data
argument_list|)
expr_stmt|;
comment|/* To work out the length of the fontdir data, we must get the          length of the device name and face name strings, even though          we don't store them in the fontdir structure.  The          documentation says that these are NULL terminated char          strings, not Unicode strings.  */
name|off
operator|=
literal|56
expr_stmt|;
while|while
condition|(
name|off
operator|<
name|length
operator|&&
name|data
index|[
name|off
index|]
operator|!=
literal|'\0'
condition|)
operator|++
name|off
expr_stmt|;
if|if
condition|(
name|off
operator|>=
name|length
condition|)
name|toosmall
argument_list|(
name|_
argument_list|(
literal|"fontdir device name"
argument_list|)
argument_list|)
expr_stmt|;
operator|++
name|off
expr_stmt|;
while|while
condition|(
name|off
operator|<
name|length
operator|&&
name|data
index|[
name|off
index|]
operator|!=
literal|'\0'
condition|)
operator|++
name|off
expr_stmt|;
if|if
condition|(
name|off
operator|>=
name|length
condition|)
name|toosmall
argument_list|(
name|_
argument_list|(
literal|"fontdir face name"
argument_list|)
argument_list|)
expr_stmt|;
operator|++
name|off
expr_stmt|;
name|fd
operator|->
name|length
operator|=
name|off
expr_stmt|;
name|fd
operator|->
name|data
operator|=
name|data
expr_stmt|;
name|fd
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
operator|*
name|pp
operator|=
name|fd
expr_stmt|;
name|pp
operator|=
operator|&
name|fd
operator|->
name|next
expr_stmt|;
comment|/* The documentation does not indicate that any rounding is          required.  */
name|data
operator|+=
name|off
expr_stmt|;
name|length
operator|-=
name|off
expr_stmt|;
block|}
name|r
operator|=
operator|(
expr|struct
name|res_resource
operator|*
operator|)
name|res_alloc
argument_list|(
sizeof|sizeof
expr|*
name|r
argument_list|)
expr_stmt|;
name|r
operator|->
name|type
operator|=
name|RES_TYPE_FONTDIR
expr_stmt|;
name|r
operator|->
name|u
operator|.
name|fontdir
operator|=
name|first
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/* Convert an accelerators resource from binary.  */
end_comment

begin_function
specifier|static
name|struct
name|res_resource
modifier|*
name|bin_to_res_accelerators
parameter_list|(
name|data
parameter_list|,
name|length
parameter_list|,
name|big_endian
parameter_list|)
specifier|const
name|unsigned
name|char
modifier|*
name|data
decl_stmt|;
name|unsigned
name|long
name|length
decl_stmt|;
name|int
name|big_endian
decl_stmt|;
block|{
name|struct
name|accelerator
modifier|*
name|first
decl_stmt|,
modifier|*
modifier|*
name|pp
decl_stmt|;
name|struct
name|res_resource
modifier|*
name|r
decl_stmt|;
name|first
operator|=
name|NULL
expr_stmt|;
name|pp
operator|=
operator|&
name|first
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|struct
name|accelerator
modifier|*
name|a
decl_stmt|;
if|if
condition|(
name|length
operator|<
literal|8
condition|)
name|toosmall
argument_list|(
name|_
argument_list|(
literal|"accelerator"
argument_list|)
argument_list|)
expr_stmt|;
name|a
operator|=
operator|(
expr|struct
name|accelerator
operator|*
operator|)
name|res_alloc
argument_list|(
sizeof|sizeof
expr|*
name|a
argument_list|)
expr_stmt|;
name|a
operator|->
name|flags
operator|=
name|get_16
argument_list|(
name|big_endian
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|a
operator|->
name|key
operator|=
name|get_16
argument_list|(
name|big_endian
argument_list|,
name|data
operator|+
literal|2
argument_list|)
expr_stmt|;
name|a
operator|->
name|id
operator|=
name|get_16
argument_list|(
name|big_endian
argument_list|,
name|data
operator|+
literal|4
argument_list|)
expr_stmt|;
name|a
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
operator|*
name|pp
operator|=
name|a
expr_stmt|;
name|pp
operator|=
operator|&
name|a
operator|->
name|next
expr_stmt|;
if|if
condition|(
operator|(
name|a
operator|->
name|flags
operator|&
name|ACC_LAST
operator|)
operator|!=
literal|0
condition|)
break|break;
name|data
operator|+=
literal|8
expr_stmt|;
name|length
operator|-=
literal|8
expr_stmt|;
block|}
name|r
operator|=
operator|(
expr|struct
name|res_resource
operator|*
operator|)
name|res_alloc
argument_list|(
sizeof|sizeof
expr|*
name|r
argument_list|)
expr_stmt|;
name|r
operator|->
name|type
operator|=
name|RES_TYPE_ACCELERATOR
expr_stmt|;
name|r
operator|->
name|u
operator|.
name|acc
operator|=
name|first
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/* Convert an rcdata resource from binary.  */
end_comment

begin_function
specifier|static
name|struct
name|res_resource
modifier|*
name|bin_to_res_rcdata
parameter_list|(
name|data
parameter_list|,
name|length
parameter_list|,
name|big_endian
parameter_list|)
specifier|const
name|unsigned
name|char
modifier|*
name|data
decl_stmt|;
name|unsigned
name|long
name|length
decl_stmt|;
name|int
name|big_endian
decl_stmt|;
block|{
name|struct
name|rcdata_item
modifier|*
name|ri
decl_stmt|;
name|struct
name|res_resource
modifier|*
name|r
decl_stmt|;
name|ri
operator|=
operator|(
expr|struct
name|rcdata_item
operator|*
operator|)
name|res_alloc
argument_list|(
sizeof|sizeof
expr|*
name|ri
argument_list|)
expr_stmt|;
name|ri
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|ri
operator|->
name|type
operator|=
name|RCDATA_BUFFER
expr_stmt|;
name|ri
operator|->
name|u
operator|.
name|buffer
operator|.
name|length
operator|=
name|length
expr_stmt|;
name|ri
operator|->
name|u
operator|.
name|buffer
operator|.
name|data
operator|=
name|data
expr_stmt|;
name|r
operator|=
operator|(
expr|struct
name|res_resource
operator|*
operator|)
name|res_alloc
argument_list|(
sizeof|sizeof
expr|*
name|r
argument_list|)
expr_stmt|;
name|r
operator|->
name|type
operator|=
name|RES_TYPE_RCDATA
expr_stmt|;
name|r
operator|->
name|u
operator|.
name|rcdata
operator|=
name|ri
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/* Convert a group cursor resource from binary.  */
end_comment

begin_function
specifier|static
name|struct
name|res_resource
modifier|*
name|bin_to_res_group_cursor
parameter_list|(
name|data
parameter_list|,
name|length
parameter_list|,
name|big_endian
parameter_list|)
specifier|const
name|unsigned
name|char
modifier|*
name|data
decl_stmt|;
name|unsigned
name|long
name|length
decl_stmt|;
name|int
name|big_endian
decl_stmt|;
block|{
name|int
name|type
decl_stmt|,
name|c
decl_stmt|,
name|i
decl_stmt|;
name|struct
name|group_cursor
modifier|*
name|first
decl_stmt|,
modifier|*
modifier|*
name|pp
decl_stmt|;
name|struct
name|res_resource
modifier|*
name|r
decl_stmt|;
if|if
condition|(
name|length
operator|<
literal|6
condition|)
name|toosmall
argument_list|(
name|_
argument_list|(
literal|"group cursor header"
argument_list|)
argument_list|)
expr_stmt|;
name|type
operator|=
name|get_16
argument_list|(
name|big_endian
argument_list|,
name|data
operator|+
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|!=
literal|2
condition|)
name|fatal
argument_list|(
name|_
argument_list|(
literal|"unexpected group cursor type %d"
argument_list|)
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|c
operator|=
name|get_16
argument_list|(
name|big_endian
argument_list|,
name|data
operator|+
literal|4
argument_list|)
expr_stmt|;
name|data
operator|+=
literal|6
expr_stmt|;
name|length
operator|-=
literal|6
expr_stmt|;
name|first
operator|=
name|NULL
expr_stmt|;
name|pp
operator|=
operator|&
name|first
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|c
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|group_cursor
modifier|*
name|gc
decl_stmt|;
if|if
condition|(
name|length
operator|<
literal|14
condition|)
name|toosmall
argument_list|(
name|_
argument_list|(
literal|"group cursor"
argument_list|)
argument_list|)
expr_stmt|;
name|gc
operator|=
operator|(
expr|struct
name|group_cursor
operator|*
operator|)
name|res_alloc
argument_list|(
sizeof|sizeof
expr|*
name|gc
argument_list|)
expr_stmt|;
name|gc
operator|->
name|width
operator|=
name|get_16
argument_list|(
name|big_endian
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|gc
operator|->
name|height
operator|=
name|get_16
argument_list|(
name|big_endian
argument_list|,
name|data
operator|+
literal|2
argument_list|)
expr_stmt|;
name|gc
operator|->
name|planes
operator|=
name|get_16
argument_list|(
name|big_endian
argument_list|,
name|data
operator|+
literal|4
argument_list|)
expr_stmt|;
name|gc
operator|->
name|bits
operator|=
name|get_16
argument_list|(
name|big_endian
argument_list|,
name|data
operator|+
literal|6
argument_list|)
expr_stmt|;
name|gc
operator|->
name|bytes
operator|=
name|get_32
argument_list|(
name|big_endian
argument_list|,
name|data
operator|+
literal|8
argument_list|)
expr_stmt|;
name|gc
operator|->
name|index
operator|=
name|get_16
argument_list|(
name|big_endian
argument_list|,
name|data
operator|+
literal|12
argument_list|)
expr_stmt|;
name|gc
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
operator|*
name|pp
operator|=
name|gc
expr_stmt|;
name|pp
operator|=
operator|&
name|gc
operator|->
name|next
expr_stmt|;
name|data
operator|+=
literal|14
expr_stmt|;
name|length
operator|-=
literal|14
expr_stmt|;
block|}
name|r
operator|=
operator|(
expr|struct
name|res_resource
operator|*
operator|)
name|res_alloc
argument_list|(
sizeof|sizeof
expr|*
name|r
argument_list|)
expr_stmt|;
name|r
operator|->
name|type
operator|=
name|RES_TYPE_GROUP_CURSOR
expr_stmt|;
name|r
operator|->
name|u
operator|.
name|group_cursor
operator|=
name|first
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/* Convert a group icon resource from binary.  */
end_comment

begin_function
specifier|static
name|struct
name|res_resource
modifier|*
name|bin_to_res_group_icon
parameter_list|(
name|data
parameter_list|,
name|length
parameter_list|,
name|big_endian
parameter_list|)
specifier|const
name|unsigned
name|char
modifier|*
name|data
decl_stmt|;
name|unsigned
name|long
name|length
decl_stmt|;
name|int
name|big_endian
decl_stmt|;
block|{
name|int
name|type
decl_stmt|,
name|c
decl_stmt|,
name|i
decl_stmt|;
name|struct
name|group_icon
modifier|*
name|first
decl_stmt|,
modifier|*
modifier|*
name|pp
decl_stmt|;
name|struct
name|res_resource
modifier|*
name|r
decl_stmt|;
if|if
condition|(
name|length
operator|<
literal|6
condition|)
name|toosmall
argument_list|(
name|_
argument_list|(
literal|"group icon header"
argument_list|)
argument_list|)
expr_stmt|;
name|type
operator|=
name|get_16
argument_list|(
name|big_endian
argument_list|,
name|data
operator|+
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|!=
literal|1
condition|)
name|fatal
argument_list|(
name|_
argument_list|(
literal|"unexpected group icon type %d"
argument_list|)
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|c
operator|=
name|get_16
argument_list|(
name|big_endian
argument_list|,
name|data
operator|+
literal|4
argument_list|)
expr_stmt|;
name|data
operator|+=
literal|6
expr_stmt|;
name|length
operator|-=
literal|6
expr_stmt|;
name|first
operator|=
name|NULL
expr_stmt|;
name|pp
operator|=
operator|&
name|first
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|c
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|group_icon
modifier|*
name|gi
decl_stmt|;
if|if
condition|(
name|length
operator|<
literal|14
condition|)
name|toosmall
argument_list|(
name|_
argument_list|(
literal|"group icon"
argument_list|)
argument_list|)
expr_stmt|;
name|gi
operator|=
operator|(
expr|struct
name|group_icon
operator|*
operator|)
name|res_alloc
argument_list|(
sizeof|sizeof
expr|*
name|gi
argument_list|)
expr_stmt|;
name|gi
operator|->
name|width
operator|=
name|data
index|[
literal|0
index|]
expr_stmt|;
name|gi
operator|->
name|height
operator|=
name|data
index|[
literal|1
index|]
expr_stmt|;
name|gi
operator|->
name|colors
operator|=
name|data
index|[
literal|2
index|]
expr_stmt|;
name|gi
operator|->
name|planes
operator|=
name|get_16
argument_list|(
name|big_endian
argument_list|,
name|data
operator|+
literal|4
argument_list|)
expr_stmt|;
name|gi
operator|->
name|bits
operator|=
name|get_16
argument_list|(
name|big_endian
argument_list|,
name|data
operator|+
literal|6
argument_list|)
expr_stmt|;
name|gi
operator|->
name|bytes
operator|=
name|get_32
argument_list|(
name|big_endian
argument_list|,
name|data
operator|+
literal|8
argument_list|)
expr_stmt|;
name|gi
operator|->
name|index
operator|=
name|get_16
argument_list|(
name|big_endian
argument_list|,
name|data
operator|+
literal|12
argument_list|)
expr_stmt|;
name|gi
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
operator|*
name|pp
operator|=
name|gi
expr_stmt|;
name|pp
operator|=
operator|&
name|gi
operator|->
name|next
expr_stmt|;
name|data
operator|+=
literal|14
expr_stmt|;
name|length
operator|-=
literal|14
expr_stmt|;
block|}
name|r
operator|=
operator|(
expr|struct
name|res_resource
operator|*
operator|)
name|res_alloc
argument_list|(
sizeof|sizeof
expr|*
name|r
argument_list|)
expr_stmt|;
name|r
operator|->
name|type
operator|=
name|RES_TYPE_GROUP_ICON
expr_stmt|;
name|r
operator|->
name|u
operator|.
name|group_icon
operator|=
name|first
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/* Extract data from a version header.  If KEY is not NULL, then the    key must be KEY; otherwise, the key is returned in *PKEY.  This    sets *LEN to the total length, *VALLEN to the value length, *TYPE    to the type, and *OFF to the offset to the children.  */
end_comment

begin_function
specifier|static
name|void
name|get_version_header
parameter_list|(
name|data
parameter_list|,
name|length
parameter_list|,
name|big_endian
parameter_list|,
name|key
parameter_list|,
name|pkey
parameter_list|,
name|len
parameter_list|,
name|vallen
parameter_list|,
name|type
parameter_list|,
name|off
parameter_list|)
specifier|const
name|unsigned
name|char
modifier|*
name|data
decl_stmt|;
name|unsigned
name|long
name|length
decl_stmt|;
name|int
name|big_endian
decl_stmt|;
specifier|const
name|char
modifier|*
name|key
decl_stmt|;
name|unichar
modifier|*
modifier|*
name|pkey
decl_stmt|;
name|int
modifier|*
name|len
decl_stmt|;
name|int
modifier|*
name|vallen
decl_stmt|;
name|int
modifier|*
name|type
decl_stmt|;
name|int
modifier|*
name|off
decl_stmt|;
block|{
if|if
condition|(
name|length
operator|<
literal|8
condition|)
name|toosmall
argument_list|(
name|key
argument_list|)
expr_stmt|;
operator|*
name|len
operator|=
name|get_16
argument_list|(
name|big_endian
argument_list|,
name|data
argument_list|)
expr_stmt|;
operator|*
name|vallen
operator|=
name|get_16
argument_list|(
name|big_endian
argument_list|,
name|data
operator|+
literal|2
argument_list|)
expr_stmt|;
operator|*
name|type
operator|=
name|get_16
argument_list|(
name|big_endian
argument_list|,
name|data
operator|+
literal|4
argument_list|)
expr_stmt|;
operator|*
name|off
operator|=
literal|6
expr_stmt|;
name|length
operator|-=
literal|6
expr_stmt|;
name|data
operator|+=
literal|6
expr_stmt|;
if|if
condition|(
name|key
operator|==
name|NULL
condition|)
block|{
name|int
name|sublen
decl_stmt|;
operator|*
name|pkey
operator|=
name|get_unicode
argument_list|(
name|data
argument_list|,
name|length
argument_list|,
name|big_endian
argument_list|,
operator|&
name|sublen
argument_list|)
expr_stmt|;
operator|*
name|off
operator|+=
name|sublen
operator|*
literal|2
operator|+
literal|2
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|length
operator|<
literal|2
condition|)
name|toosmall
argument_list|(
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|get_16
argument_list|(
name|big_endian
argument_list|,
name|data
argument_list|)
operator|!=
operator|(
name|unsigned
name|char
operator|)
operator|*
name|key
condition|)
name|fatal
argument_list|(
name|_
argument_list|(
literal|"unexpected version string"
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|off
operator|+=
literal|2
expr_stmt|;
name|length
operator|-=
literal|2
expr_stmt|;
name|data
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
operator|*
name|key
operator|==
literal|'\0'
condition|)
break|break;
operator|++
name|key
expr_stmt|;
block|}
block|}
operator|*
name|off
operator|=
operator|(
operator|*
name|off
operator|+
literal|3
operator|)
operator|&
operator|~
literal|3
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Convert a version resource from binary.  */
end_comment

begin_function
specifier|static
name|struct
name|res_resource
modifier|*
name|bin_to_res_version
parameter_list|(
name|data
parameter_list|,
name|length
parameter_list|,
name|big_endian
parameter_list|)
specifier|const
name|unsigned
name|char
modifier|*
name|data
decl_stmt|;
name|unsigned
name|long
name|length
decl_stmt|;
name|int
name|big_endian
decl_stmt|;
block|{
name|int
name|verlen
decl_stmt|,
name|vallen
decl_stmt|,
name|type
decl_stmt|,
name|off
decl_stmt|;
name|struct
name|fixed_versioninfo
modifier|*
name|fi
decl_stmt|;
name|struct
name|ver_info
modifier|*
name|first
decl_stmt|,
modifier|*
modifier|*
name|pp
decl_stmt|;
name|struct
name|versioninfo
modifier|*
name|v
decl_stmt|;
name|struct
name|res_resource
modifier|*
name|r
decl_stmt|;
name|get_version_header
argument_list|(
name|data
argument_list|,
name|length
argument_list|,
name|big_endian
argument_list|,
literal|"VS_VERSION_INFO"
argument_list|,
operator|(
name|unichar
operator|*
operator|)
name|NULL
argument_list|,
operator|&
name|verlen
argument_list|,
operator|&
name|vallen
argument_list|,
operator|&
name|type
argument_list|,
operator|&
name|off
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|unsigned
name|int
operator|)
name|verlen
operator|!=
name|length
condition|)
name|fatal
argument_list|(
name|_
argument_list|(
literal|"version length %d does not match resource length %lu"
argument_list|)
argument_list|,
name|verlen
argument_list|,
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|!=
literal|0
condition|)
name|fatal
argument_list|(
name|_
argument_list|(
literal|"unexpected version type %d"
argument_list|)
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|data
operator|+=
name|off
expr_stmt|;
name|length
operator|-=
name|off
expr_stmt|;
if|if
condition|(
name|vallen
operator|==
literal|0
condition|)
name|fi
operator|=
name|NULL
expr_stmt|;
else|else
block|{
name|unsigned
name|long
name|signature
decl_stmt|,
name|fiv
decl_stmt|;
if|if
condition|(
name|vallen
operator|!=
literal|52
condition|)
name|fatal
argument_list|(
name|_
argument_list|(
literal|"unexpected fixed version information length %d"
argument_list|)
argument_list|,
name|vallen
argument_list|)
expr_stmt|;
if|if
condition|(
name|length
operator|<
literal|52
condition|)
name|toosmall
argument_list|(
name|_
argument_list|(
literal|"fixed version info"
argument_list|)
argument_list|)
expr_stmt|;
name|signature
operator|=
name|get_32
argument_list|(
name|big_endian
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|signature
operator|!=
literal|0xfeef04bd
condition|)
name|fatal
argument_list|(
name|_
argument_list|(
literal|"unexpected fixed version signature %lu"
argument_list|)
argument_list|,
name|signature
argument_list|)
expr_stmt|;
name|fiv
operator|=
name|get_32
argument_list|(
name|big_endian
argument_list|,
name|data
operator|+
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|fiv
operator|!=
literal|0
operator|&&
name|fiv
operator|!=
literal|0x10000
condition|)
name|fatal
argument_list|(
name|_
argument_list|(
literal|"unexpected fixed version info version %lu"
argument_list|)
argument_list|,
name|fiv
argument_list|)
expr_stmt|;
name|fi
operator|=
operator|(
expr|struct
name|fixed_versioninfo
operator|*
operator|)
name|res_alloc
argument_list|(
sizeof|sizeof
expr|*
name|fi
argument_list|)
expr_stmt|;
name|fi
operator|->
name|file_version_ms
operator|=
name|get_32
argument_list|(
name|big_endian
argument_list|,
name|data
operator|+
literal|8
argument_list|)
expr_stmt|;
name|fi
operator|->
name|file_version_ls
operator|=
name|get_32
argument_list|(
name|big_endian
argument_list|,
name|data
operator|+
literal|12
argument_list|)
expr_stmt|;
name|fi
operator|->
name|product_version_ms
operator|=
name|get_32
argument_list|(
name|big_endian
argument_list|,
name|data
operator|+
literal|16
argument_list|)
expr_stmt|;
name|fi
operator|->
name|product_version_ls
operator|=
name|get_32
argument_list|(
name|big_endian
argument_list|,
name|data
operator|+
literal|20
argument_list|)
expr_stmt|;
name|fi
operator|->
name|file_flags_mask
operator|=
name|get_32
argument_list|(
name|big_endian
argument_list|,
name|data
operator|+
literal|24
argument_list|)
expr_stmt|;
name|fi
operator|->
name|file_flags
operator|=
name|get_32
argument_list|(
name|big_endian
argument_list|,
name|data
operator|+
literal|28
argument_list|)
expr_stmt|;
name|fi
operator|->
name|file_os
operator|=
name|get_32
argument_list|(
name|big_endian
argument_list|,
name|data
operator|+
literal|32
argument_list|)
expr_stmt|;
name|fi
operator|->
name|file_type
operator|=
name|get_32
argument_list|(
name|big_endian
argument_list|,
name|data
operator|+
literal|36
argument_list|)
expr_stmt|;
name|fi
operator|->
name|file_subtype
operator|=
name|get_32
argument_list|(
name|big_endian
argument_list|,
name|data
operator|+
literal|40
argument_list|)
expr_stmt|;
name|fi
operator|->
name|file_date_ms
operator|=
name|get_32
argument_list|(
name|big_endian
argument_list|,
name|data
operator|+
literal|44
argument_list|)
expr_stmt|;
name|fi
operator|->
name|file_date_ls
operator|=
name|get_32
argument_list|(
name|big_endian
argument_list|,
name|data
operator|+
literal|48
argument_list|)
expr_stmt|;
name|data
operator|+=
literal|52
expr_stmt|;
name|length
operator|-=
literal|52
expr_stmt|;
block|}
name|first
operator|=
name|NULL
expr_stmt|;
name|pp
operator|=
operator|&
name|first
expr_stmt|;
while|while
condition|(
name|length
operator|>
literal|0
condition|)
block|{
name|struct
name|ver_info
modifier|*
name|vi
decl_stmt|;
name|int
name|ch
decl_stmt|;
if|if
condition|(
name|length
operator|<
literal|8
condition|)
name|toosmall
argument_list|(
name|_
argument_list|(
literal|"version var info"
argument_list|)
argument_list|)
expr_stmt|;
name|vi
operator|=
operator|(
expr|struct
name|ver_info
operator|*
operator|)
name|res_alloc
argument_list|(
sizeof|sizeof
expr|*
name|vi
argument_list|)
expr_stmt|;
name|ch
operator|=
name|get_16
argument_list|(
name|big_endian
argument_list|,
name|data
operator|+
literal|6
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|==
literal|'S'
condition|)
block|{
name|struct
name|ver_stringinfo
modifier|*
modifier|*
name|ppvs
decl_stmt|;
name|vi
operator|->
name|type
operator|=
name|VERINFO_STRING
expr_stmt|;
name|get_version_header
argument_list|(
name|data
argument_list|,
name|length
argument_list|,
name|big_endian
argument_list|,
literal|"StringFileInfo"
argument_list|,
operator|(
name|unichar
operator|*
operator|)
name|NULL
argument_list|,
operator|&
name|verlen
argument_list|,
operator|&
name|vallen
argument_list|,
operator|&
name|type
argument_list|,
operator|&
name|off
argument_list|)
expr_stmt|;
if|if
condition|(
name|vallen
operator|!=
literal|0
condition|)
name|fatal
argument_list|(
name|_
argument_list|(
literal|"unexpected stringfileinfo value length %d"
argument_list|)
argument_list|,
name|vallen
argument_list|)
expr_stmt|;
name|data
operator|+=
name|off
expr_stmt|;
name|length
operator|-=
name|off
expr_stmt|;
name|get_version_header
argument_list|(
name|data
argument_list|,
name|length
argument_list|,
name|big_endian
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|,
operator|&
name|vi
operator|->
name|u
operator|.
name|string
operator|.
name|language
argument_list|,
operator|&
name|verlen
argument_list|,
operator|&
name|vallen
argument_list|,
operator|&
name|type
argument_list|,
operator|&
name|off
argument_list|)
expr_stmt|;
if|if
condition|(
name|vallen
operator|!=
literal|0
condition|)
name|fatal
argument_list|(
name|_
argument_list|(
literal|"unexpected version stringtable value length %d"
argument_list|)
argument_list|,
name|vallen
argument_list|)
expr_stmt|;
name|data
operator|+=
name|off
expr_stmt|;
name|length
operator|-=
name|off
expr_stmt|;
name|verlen
operator|-=
name|off
expr_stmt|;
name|vi
operator|->
name|u
operator|.
name|string
operator|.
name|strings
operator|=
name|NULL
expr_stmt|;
name|ppvs
operator|=
operator|&
name|vi
operator|->
name|u
operator|.
name|string
operator|.
name|strings
expr_stmt|;
comment|/* It's convenient to round verlen to a 4 byte alignment,              since we round the subvariables in the loop.  */
name|verlen
operator|=
operator|(
name|verlen
operator|+
literal|3
operator|)
operator|&
operator|~
literal|3
expr_stmt|;
while|while
condition|(
name|verlen
operator|>
literal|0
condition|)
block|{
name|struct
name|ver_stringinfo
modifier|*
name|vs
decl_stmt|;
name|int
name|subverlen
decl_stmt|,
name|vslen
decl_stmt|,
name|valoff
decl_stmt|;
name|vs
operator|=
operator|(
expr|struct
name|ver_stringinfo
operator|*
operator|)
name|res_alloc
argument_list|(
sizeof|sizeof
expr|*
name|vs
argument_list|)
expr_stmt|;
name|get_version_header
argument_list|(
name|data
argument_list|,
name|length
argument_list|,
name|big_endian
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|,
operator|&
name|vs
operator|->
name|key
argument_list|,
operator|&
name|subverlen
argument_list|,
operator|&
name|vallen
argument_list|,
operator|&
name|type
argument_list|,
operator|&
name|off
argument_list|)
expr_stmt|;
name|subverlen
operator|=
operator|(
name|subverlen
operator|+
literal|3
operator|)
operator|&
operator|~
literal|3
expr_stmt|;
name|data
operator|+=
name|off
expr_stmt|;
name|length
operator|-=
name|off
expr_stmt|;
name|vs
operator|->
name|value
operator|=
name|get_unicode
argument_list|(
name|data
argument_list|,
name|length
argument_list|,
name|big_endian
argument_list|,
operator|&
name|vslen
argument_list|)
expr_stmt|;
name|valoff
operator|=
name|vslen
operator|*
literal|2
operator|+
literal|2
expr_stmt|;
name|valoff
operator|=
operator|(
name|valoff
operator|+
literal|3
operator|)
operator|&
operator|~
literal|3
expr_stmt|;
if|if
condition|(
name|off
operator|+
name|valoff
operator|!=
name|subverlen
condition|)
name|fatal
argument_list|(
name|_
argument_list|(
literal|"unexpected version string length %d != %d + %d"
argument_list|)
argument_list|,
name|subverlen
argument_list|,
name|off
argument_list|,
name|valoff
argument_list|)
expr_stmt|;
name|vs
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
operator|*
name|ppvs
operator|=
name|vs
expr_stmt|;
name|ppvs
operator|=
operator|&
name|vs
operator|->
name|next
expr_stmt|;
name|data
operator|+=
name|valoff
expr_stmt|;
name|length
operator|-=
name|valoff
expr_stmt|;
if|if
condition|(
name|verlen
operator|<
name|subverlen
condition|)
name|fatal
argument_list|(
name|_
argument_list|(
literal|"unexpected version string length %d< %d"
argument_list|)
argument_list|,
name|verlen
argument_list|,
name|subverlen
argument_list|)
expr_stmt|;
name|verlen
operator|-=
name|subverlen
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|ch
operator|==
literal|'V'
condition|)
block|{
name|struct
name|ver_varinfo
modifier|*
modifier|*
name|ppvv
decl_stmt|;
name|vi
operator|->
name|type
operator|=
name|VERINFO_VAR
expr_stmt|;
name|get_version_header
argument_list|(
name|data
argument_list|,
name|length
argument_list|,
name|big_endian
argument_list|,
literal|"VarFileInfo"
argument_list|,
operator|(
name|unichar
operator|*
operator|)
name|NULL
argument_list|,
operator|&
name|verlen
argument_list|,
operator|&
name|vallen
argument_list|,
operator|&
name|type
argument_list|,
operator|&
name|off
argument_list|)
expr_stmt|;
if|if
condition|(
name|vallen
operator|!=
literal|0
condition|)
name|fatal
argument_list|(
name|_
argument_list|(
literal|"unexpected varfileinfo value length %d"
argument_list|)
argument_list|,
name|vallen
argument_list|)
expr_stmt|;
name|data
operator|+=
name|off
expr_stmt|;
name|length
operator|-=
name|off
expr_stmt|;
name|get_version_header
argument_list|(
name|data
argument_list|,
name|length
argument_list|,
name|big_endian
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|,
operator|&
name|vi
operator|->
name|u
operator|.
name|var
operator|.
name|key
argument_list|,
operator|&
name|verlen
argument_list|,
operator|&
name|vallen
argument_list|,
operator|&
name|type
argument_list|,
operator|&
name|off
argument_list|)
expr_stmt|;
name|data
operator|+=
name|off
expr_stmt|;
name|length
operator|-=
name|off
expr_stmt|;
name|vi
operator|->
name|u
operator|.
name|var
operator|.
name|var
operator|=
name|NULL
expr_stmt|;
name|ppvv
operator|=
operator|&
name|vi
operator|->
name|u
operator|.
name|var
operator|.
name|var
expr_stmt|;
while|while
condition|(
name|vallen
operator|>
literal|0
condition|)
block|{
name|struct
name|ver_varinfo
modifier|*
name|vv
decl_stmt|;
if|if
condition|(
name|length
operator|<
literal|4
condition|)
name|toosmall
argument_list|(
name|_
argument_list|(
literal|"version varfileinfo"
argument_list|)
argument_list|)
expr_stmt|;
name|vv
operator|=
operator|(
expr|struct
name|ver_varinfo
operator|*
operator|)
name|res_alloc
argument_list|(
sizeof|sizeof
expr|*
name|vv
argument_list|)
expr_stmt|;
name|vv
operator|->
name|language
operator|=
name|get_16
argument_list|(
name|big_endian
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|vv
operator|->
name|charset
operator|=
name|get_16
argument_list|(
name|big_endian
argument_list|,
name|data
operator|+
literal|2
argument_list|)
expr_stmt|;
name|vv
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
operator|*
name|ppvv
operator|=
name|vv
expr_stmt|;
name|ppvv
operator|=
operator|&
name|vv
operator|->
name|next
expr_stmt|;
name|data
operator|+=
literal|4
expr_stmt|;
name|length
operator|-=
literal|4
expr_stmt|;
if|if
condition|(
name|vallen
operator|<
literal|4
condition|)
name|fatal
argument_list|(
name|_
argument_list|(
literal|"unexpected version value length %d"
argument_list|)
argument_list|,
name|vallen
argument_list|)
expr_stmt|;
name|vallen
operator|-=
literal|4
expr_stmt|;
block|}
block|}
else|else
name|fatal
argument_list|(
name|_
argument_list|(
literal|"unexpected version string"
argument_list|)
argument_list|)
expr_stmt|;
name|vi
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
operator|*
name|pp
operator|=
name|vi
expr_stmt|;
name|pp
operator|=
operator|&
name|vi
operator|->
name|next
expr_stmt|;
block|}
name|v
operator|=
operator|(
expr|struct
name|versioninfo
operator|*
operator|)
name|res_alloc
argument_list|(
sizeof|sizeof
expr|*
name|v
argument_list|)
expr_stmt|;
name|v
operator|->
name|fixed
operator|=
name|fi
expr_stmt|;
name|v
operator|->
name|var
operator|=
name|first
expr_stmt|;
name|r
operator|=
operator|(
expr|struct
name|res_resource
operator|*
operator|)
name|res_alloc
argument_list|(
sizeof|sizeof
expr|*
name|r
argument_list|)
expr_stmt|;
name|r
operator|->
name|type
operator|=
name|RES_TYPE_VERSIONINFO
expr_stmt|;
name|r
operator|->
name|u
operator|.
name|versioninfo
operator|=
name|v
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/* Convert an arbitrary user defined resource from binary.  */
end_comment

begin_function
specifier|static
name|struct
name|res_resource
modifier|*
name|bin_to_res_userdata
parameter_list|(
name|data
parameter_list|,
name|length
parameter_list|,
name|big_endian
parameter_list|)
specifier|const
name|unsigned
name|char
modifier|*
name|data
decl_stmt|;
name|unsigned
name|long
name|length
decl_stmt|;
name|int
name|big_endian
decl_stmt|;
block|{
name|struct
name|rcdata_item
modifier|*
name|ri
decl_stmt|;
name|struct
name|res_resource
modifier|*
name|r
decl_stmt|;
name|ri
operator|=
operator|(
expr|struct
name|rcdata_item
operator|*
operator|)
name|res_alloc
argument_list|(
sizeof|sizeof
expr|*
name|ri
argument_list|)
expr_stmt|;
name|ri
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|ri
operator|->
name|type
operator|=
name|RCDATA_BUFFER
expr_stmt|;
name|ri
operator|->
name|u
operator|.
name|buffer
operator|.
name|length
operator|=
name|length
expr_stmt|;
name|ri
operator|->
name|u
operator|.
name|buffer
operator|.
name|data
operator|=
name|data
expr_stmt|;
name|r
operator|=
operator|(
expr|struct
name|res_resource
operator|*
operator|)
name|res_alloc
argument_list|(
sizeof|sizeof
expr|*
name|r
argument_list|)
expr_stmt|;
name|r
operator|->
name|type
operator|=
name|RES_TYPE_USERDATA
expr_stmt|;
name|r
operator|->
name|u
operator|.
name|rcdata
operator|=
name|ri
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Macros to swap out values.  */
end_comment

begin_define
define|#
directive|define
name|put_16
parameter_list|(
name|be
parameter_list|,
name|v
parameter_list|,
name|s
parameter_list|)
value|((be) ? bfd_putb16 ((v), (s)) : bfd_putl16 ((v), (s)))
end_define

begin_define
define|#
directive|define
name|put_32
parameter_list|(
name|be
parameter_list|,
name|v
parameter_list|,
name|s
parameter_list|)
value|((be) ? bfd_putb32 ((v), (s)) : bfd_putl32 ((v), (s)))
end_define

begin_comment
comment|/* Local functions used to convert resources to binary format.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|dword_align_bin
name|PARAMS
argument_list|(
operator|(
expr|struct
name|bindata
operator|*
operator|*
operator|*
operator|,
name|unsigned
name|long
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|bindata
modifier|*
name|resid_to_bin
name|PARAMS
argument_list|(
operator|(
expr|struct
name|res_id
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|bindata
modifier|*
name|unicode_to_bin
name|PARAMS
argument_list|(
operator|(
specifier|const
name|unichar
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|bindata
modifier|*
name|res_to_bin_accelerator
name|PARAMS
argument_list|(
operator|(
specifier|const
expr|struct
name|accelerator
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|bindata
modifier|*
name|res_to_bin_cursor
name|PARAMS
argument_list|(
operator|(
specifier|const
expr|struct
name|cursor
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|bindata
modifier|*
name|res_to_bin_group_cursor
name|PARAMS
argument_list|(
operator|(
specifier|const
expr|struct
name|group_cursor
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|bindata
modifier|*
name|res_to_bin_dialog
name|PARAMS
argument_list|(
operator|(
specifier|const
expr|struct
name|dialog
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|bindata
modifier|*
name|res_to_bin_fontdir
name|PARAMS
argument_list|(
operator|(
specifier|const
expr|struct
name|fontdir
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|bindata
modifier|*
name|res_to_bin_group_icon
name|PARAMS
argument_list|(
operator|(
specifier|const
expr|struct
name|group_icon
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|bindata
modifier|*
name|res_to_bin_menu
name|PARAMS
argument_list|(
operator|(
specifier|const
expr|struct
name|menu
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|bindata
modifier|*
name|res_to_bin_menuitems
name|PARAMS
argument_list|(
operator|(
specifier|const
expr|struct
name|menuitem
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|bindata
modifier|*
name|res_to_bin_menuexitems
name|PARAMS
argument_list|(
operator|(
specifier|const
expr|struct
name|menuitem
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|bindata
modifier|*
name|res_to_bin_rcdata
name|PARAMS
argument_list|(
operator|(
specifier|const
expr|struct
name|rcdata_item
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|bindata
modifier|*
name|res_to_bin_stringtable
name|PARAMS
argument_list|(
operator|(
specifier|const
expr|struct
name|stringtable
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|bindata
modifier|*
name|string_to_unicode_bin
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|bindata
modifier|*
name|res_to_bin_versioninfo
name|PARAMS
argument_list|(
operator|(
specifier|const
expr|struct
name|versioninfo
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|bindata
modifier|*
name|res_to_bin_generic
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|long
operator|,
specifier|const
name|unsigned
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Convert a resource to binary.  */
end_comment

begin_function
name|struct
name|bindata
modifier|*
name|res_to_bin
parameter_list|(
name|res
parameter_list|,
name|big_endian
parameter_list|)
specifier|const
name|struct
name|res_resource
modifier|*
name|res
decl_stmt|;
name|int
name|big_endian
decl_stmt|;
block|{
switch|switch
condition|(
name|res
operator|->
name|type
condition|)
block|{
default|default:
name|abort
argument_list|()
expr_stmt|;
case|case
name|RES_TYPE_BITMAP
case|:
case|case
name|RES_TYPE_FONT
case|:
case|case
name|RES_TYPE_ICON
case|:
case|case
name|RES_TYPE_MESSAGETABLE
case|:
return|return
name|res_to_bin_generic
argument_list|(
name|res
operator|->
name|u
operator|.
name|data
operator|.
name|length
argument_list|,
name|res
operator|->
name|u
operator|.
name|data
operator|.
name|data
argument_list|)
return|;
case|case
name|RES_TYPE_ACCELERATOR
case|:
return|return
name|res_to_bin_accelerator
argument_list|(
name|res
operator|->
name|u
operator|.
name|acc
argument_list|,
name|big_endian
argument_list|)
return|;
case|case
name|RES_TYPE_CURSOR
case|:
return|return
name|res_to_bin_cursor
argument_list|(
name|res
operator|->
name|u
operator|.
name|cursor
argument_list|,
name|big_endian
argument_list|)
return|;
case|case
name|RES_TYPE_GROUP_CURSOR
case|:
return|return
name|res_to_bin_group_cursor
argument_list|(
name|res
operator|->
name|u
operator|.
name|group_cursor
argument_list|,
name|big_endian
argument_list|)
return|;
case|case
name|RES_TYPE_DIALOG
case|:
return|return
name|res_to_bin_dialog
argument_list|(
name|res
operator|->
name|u
operator|.
name|dialog
argument_list|,
name|big_endian
argument_list|)
return|;
case|case
name|RES_TYPE_FONTDIR
case|:
return|return
name|res_to_bin_fontdir
argument_list|(
name|res
operator|->
name|u
operator|.
name|fontdir
argument_list|,
name|big_endian
argument_list|)
return|;
case|case
name|RES_TYPE_GROUP_ICON
case|:
return|return
name|res_to_bin_group_icon
argument_list|(
name|res
operator|->
name|u
operator|.
name|group_icon
argument_list|,
name|big_endian
argument_list|)
return|;
case|case
name|RES_TYPE_MENU
case|:
return|return
name|res_to_bin_menu
argument_list|(
name|res
operator|->
name|u
operator|.
name|menu
argument_list|,
name|big_endian
argument_list|)
return|;
case|case
name|RES_TYPE_RCDATA
case|:
return|return
name|res_to_bin_rcdata
argument_list|(
name|res
operator|->
name|u
operator|.
name|rcdata
argument_list|,
name|big_endian
argument_list|)
return|;
case|case
name|RES_TYPE_STRINGTABLE
case|:
return|return
name|res_to_bin_stringtable
argument_list|(
name|res
operator|->
name|u
operator|.
name|stringtable
argument_list|,
name|big_endian
argument_list|)
return|;
case|case
name|RES_TYPE_USERDATA
case|:
return|return
name|res_to_bin_rcdata
argument_list|(
name|res
operator|->
name|u
operator|.
name|rcdata
argument_list|,
name|big_endian
argument_list|)
return|;
case|case
name|RES_TYPE_VERSIONINFO
case|:
return|return
name|res_to_bin_versioninfo
argument_list|(
name|res
operator|->
name|u
operator|.
name|versioninfo
argument_list|,
name|big_endian
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* Align to a 32 bit boundary.  PPP points to the of a list of bindata    structures.  LENGTH points to the length of the structures.  If    necessary, this adds a new bindata to bring length up to a 32 bit    boundary.  It updates *PPP and *LENGTH.  */
end_comment

begin_function
specifier|static
name|void
name|dword_align_bin
parameter_list|(
name|ppp
parameter_list|,
name|length
parameter_list|)
name|struct
name|bindata
modifier|*
modifier|*
modifier|*
name|ppp
decl_stmt|;
name|unsigned
name|long
modifier|*
name|length
decl_stmt|;
block|{
name|int
name|add
decl_stmt|;
name|struct
name|bindata
modifier|*
name|d
decl_stmt|;
if|if
condition|(
operator|(
operator|*
name|length
operator|&
literal|3
operator|)
operator|==
literal|0
condition|)
return|return;
name|add
operator|=
literal|4
operator|-
operator|(
operator|*
name|length
operator|&
literal|3
operator|)
expr_stmt|;
name|d
operator|=
operator|(
expr|struct
name|bindata
operator|*
operator|)
name|reswr_alloc
argument_list|(
sizeof|sizeof
expr|*
name|d
argument_list|)
expr_stmt|;
name|d
operator|->
name|length
operator|=
name|add
expr_stmt|;
name|d
operator|->
name|data
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|reswr_alloc
argument_list|(
name|add
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|d
operator|->
name|data
argument_list|,
literal|0
argument_list|,
name|add
argument_list|)
expr_stmt|;
name|d
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
operator|*
operator|*
name|ppp
operator|=
name|d
expr_stmt|;
operator|*
name|ppp
operator|=
operator|&
operator|(
operator|*
operator|*
name|ppp
operator|)
operator|->
name|next
expr_stmt|;
operator|*
name|length
operator|+=
name|add
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Convert a resource ID to binary.  This always returns exactly one    bindata structure.  */
end_comment

begin_function
specifier|static
name|struct
name|bindata
modifier|*
name|resid_to_bin
parameter_list|(
name|id
parameter_list|,
name|big_endian
parameter_list|)
name|struct
name|res_id
name|id
decl_stmt|;
name|int
name|big_endian
decl_stmt|;
block|{
name|struct
name|bindata
modifier|*
name|d
decl_stmt|;
name|d
operator|=
operator|(
expr|struct
name|bindata
operator|*
operator|)
name|reswr_alloc
argument_list|(
sizeof|sizeof
expr|*
name|d
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|id
operator|.
name|named
condition|)
block|{
name|d
operator|->
name|length
operator|=
literal|4
expr_stmt|;
name|d
operator|->
name|data
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|reswr_alloc
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|put_16
argument_list|(
name|big_endian
argument_list|,
literal|0xffff
argument_list|,
name|d
operator|->
name|data
argument_list|)
expr_stmt|;
name|put_16
argument_list|(
name|big_endian
argument_list|,
name|id
operator|.
name|u
operator|.
name|id
argument_list|,
name|d
operator|->
name|data
operator|+
literal|2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|i
decl_stmt|;
name|d
operator|->
name|length
operator|=
name|id
operator|.
name|u
operator|.
name|n
operator|.
name|length
operator|*
literal|2
operator|+
literal|2
expr_stmt|;
name|d
operator|->
name|data
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|reswr_alloc
argument_list|(
name|d
operator|->
name|length
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|id
operator|.
name|u
operator|.
name|n
operator|.
name|length
condition|;
name|i
operator|++
control|)
name|put_16
argument_list|(
name|big_endian
argument_list|,
name|id
operator|.
name|u
operator|.
name|n
operator|.
name|name
index|[
name|i
index|]
argument_list|,
name|d
operator|->
name|data
operator|+
name|i
operator|*
literal|2
argument_list|)
expr_stmt|;
name|put_16
argument_list|(
name|big_endian
argument_list|,
literal|0
argument_list|,
name|d
operator|->
name|data
operator|+
name|i
operator|*
literal|2
argument_list|)
expr_stmt|;
block|}
name|d
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
return|return
name|d
return|;
block|}
end_function

begin_comment
comment|/* Convert a null terminated unicode string to binary.  This always    returns exactly one bindata structure.  */
end_comment

begin_function
specifier|static
name|struct
name|bindata
modifier|*
name|unicode_to_bin
parameter_list|(
name|str
parameter_list|,
name|big_endian
parameter_list|)
specifier|const
name|unichar
modifier|*
name|str
decl_stmt|;
name|int
name|big_endian
decl_stmt|;
block|{
name|int
name|len
decl_stmt|;
name|struct
name|bindata
modifier|*
name|d
decl_stmt|;
name|len
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|str
operator|!=
name|NULL
condition|)
block|{
specifier|const
name|unichar
modifier|*
name|s
decl_stmt|;
for|for
control|(
name|s
operator|=
name|str
init|;
operator|*
name|s
operator|!=
literal|0
condition|;
name|s
operator|++
control|)
operator|++
name|len
expr_stmt|;
block|}
name|d
operator|=
operator|(
expr|struct
name|bindata
operator|*
operator|)
name|reswr_alloc
argument_list|(
sizeof|sizeof
expr|*
name|d
argument_list|)
expr_stmt|;
name|d
operator|->
name|length
operator|=
name|len
operator|*
literal|2
operator|+
literal|2
expr_stmt|;
name|d
operator|->
name|data
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|reswr_alloc
argument_list|(
name|d
operator|->
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|str
operator|==
name|NULL
condition|)
name|put_16
argument_list|(
name|big_endian
argument_list|,
literal|0
argument_list|,
name|d
operator|->
name|data
argument_list|)
expr_stmt|;
else|else
block|{
specifier|const
name|unichar
modifier|*
name|s
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|s
operator|=
name|str
operator|,
name|i
operator|=
literal|0
init|;
operator|*
name|s
operator|!=
literal|0
condition|;
name|s
operator|++
operator|,
name|i
operator|++
control|)
name|put_16
argument_list|(
name|big_endian
argument_list|,
operator|*
name|s
argument_list|,
name|d
operator|->
name|data
operator|+
name|i
operator|*
literal|2
argument_list|)
expr_stmt|;
name|put_16
argument_list|(
name|big_endian
argument_list|,
literal|0
argument_list|,
name|d
operator|->
name|data
operator|+
name|i
operator|*
literal|2
argument_list|)
expr_stmt|;
block|}
name|d
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
return|return
name|d
return|;
block|}
end_function

begin_comment
comment|/* Convert an accelerator resource to binary.  */
end_comment

begin_function
specifier|static
name|struct
name|bindata
modifier|*
name|res_to_bin_accelerator
parameter_list|(
name|accelerators
parameter_list|,
name|big_endian
parameter_list|)
specifier|const
name|struct
name|accelerator
modifier|*
name|accelerators
decl_stmt|;
name|int
name|big_endian
decl_stmt|;
block|{
name|struct
name|bindata
modifier|*
name|first
decl_stmt|,
modifier|*
modifier|*
name|pp
decl_stmt|;
specifier|const
name|struct
name|accelerator
modifier|*
name|a
decl_stmt|;
name|first
operator|=
name|NULL
expr_stmt|;
name|pp
operator|=
operator|&
name|first
expr_stmt|;
for|for
control|(
name|a
operator|=
name|accelerators
init|;
name|a
operator|!=
name|NULL
condition|;
name|a
operator|=
name|a
operator|->
name|next
control|)
block|{
name|struct
name|bindata
modifier|*
name|d
decl_stmt|;
name|d
operator|=
operator|(
expr|struct
name|bindata
operator|*
operator|)
name|reswr_alloc
argument_list|(
sizeof|sizeof
expr|*
name|d
argument_list|)
expr_stmt|;
name|d
operator|->
name|length
operator|=
literal|8
expr_stmt|;
name|d
operator|->
name|data
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|reswr_alloc
argument_list|(
literal|8
argument_list|)
expr_stmt|;
name|put_16
argument_list|(
name|big_endian
argument_list|,
name|a
operator|->
name|flags
operator||
operator|(
name|a
operator|->
name|next
operator|!=
name|NULL
condition|?
literal|0
else|:
name|ACC_LAST
operator|)
argument_list|,
name|d
operator|->
name|data
argument_list|)
expr_stmt|;
name|put_16
argument_list|(
name|big_endian
argument_list|,
name|a
operator|->
name|key
argument_list|,
name|d
operator|->
name|data
operator|+
literal|2
argument_list|)
expr_stmt|;
name|put_16
argument_list|(
name|big_endian
argument_list|,
name|a
operator|->
name|id
argument_list|,
name|d
operator|->
name|data
operator|+
literal|4
argument_list|)
expr_stmt|;
name|put_16
argument_list|(
name|big_endian
argument_list|,
literal|0
argument_list|,
name|d
operator|->
name|data
operator|+
literal|8
argument_list|)
expr_stmt|;
name|d
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
operator|*
name|pp
operator|=
name|d
expr_stmt|;
name|pp
operator|=
operator|&
name|d
operator|->
name|next
expr_stmt|;
block|}
return|return
name|first
return|;
block|}
end_function

begin_comment
comment|/* Convert a cursor resource to binary.  */
end_comment

begin_function
specifier|static
name|struct
name|bindata
modifier|*
name|res_to_bin_cursor
parameter_list|(
name|c
parameter_list|,
name|big_endian
parameter_list|)
specifier|const
name|struct
name|cursor
modifier|*
name|c
decl_stmt|;
name|int
name|big_endian
decl_stmt|;
block|{
name|struct
name|bindata
modifier|*
name|d
decl_stmt|;
name|d
operator|=
operator|(
expr|struct
name|bindata
operator|*
operator|)
name|reswr_alloc
argument_list|(
sizeof|sizeof
expr|*
name|d
argument_list|)
expr_stmt|;
name|d
operator|->
name|length
operator|=
literal|4
expr_stmt|;
name|d
operator|->
name|data
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|reswr_alloc
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|put_16
argument_list|(
name|big_endian
argument_list|,
name|c
operator|->
name|xhotspot
argument_list|,
name|d
operator|->
name|data
argument_list|)
expr_stmt|;
name|put_16
argument_list|(
name|big_endian
argument_list|,
name|c
operator|->
name|yhotspot
argument_list|,
name|d
operator|->
name|data
operator|+
literal|2
argument_list|)
expr_stmt|;
name|d
operator|->
name|next
operator|=
operator|(
expr|struct
name|bindata
operator|*
operator|)
name|reswr_alloc
argument_list|(
sizeof|sizeof
expr|*
name|d
argument_list|)
expr_stmt|;
name|d
operator|->
name|next
operator|->
name|length
operator|=
name|c
operator|->
name|length
expr_stmt|;
name|d
operator|->
name|next
operator|->
name|data
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|c
operator|->
name|data
expr_stmt|;
name|d
operator|->
name|next
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
return|return
name|d
return|;
block|}
end_function

begin_comment
comment|/* Convert a group cursor resource to binary.  */
end_comment

begin_function
specifier|static
name|struct
name|bindata
modifier|*
name|res_to_bin_group_cursor
parameter_list|(
name|group_cursors
parameter_list|,
name|big_endian
parameter_list|)
specifier|const
name|struct
name|group_cursor
modifier|*
name|group_cursors
decl_stmt|;
name|int
name|big_endian
decl_stmt|;
block|{
name|struct
name|bindata
modifier|*
name|first
decl_stmt|,
modifier|*
modifier|*
name|pp
decl_stmt|;
name|int
name|c
decl_stmt|;
specifier|const
name|struct
name|group_cursor
modifier|*
name|gc
decl_stmt|;
name|first
operator|=
operator|(
expr|struct
name|bindata
operator|*
operator|)
name|reswr_alloc
argument_list|(
sizeof|sizeof
expr|*
name|first
argument_list|)
expr_stmt|;
name|first
operator|->
name|length
operator|=
literal|6
expr_stmt|;
name|first
operator|->
name|data
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|reswr_alloc
argument_list|(
literal|6
argument_list|)
expr_stmt|;
name|put_16
argument_list|(
name|big_endian
argument_list|,
literal|0
argument_list|,
name|first
operator|->
name|data
argument_list|)
expr_stmt|;
name|put_16
argument_list|(
name|big_endian
argument_list|,
literal|2
argument_list|,
name|first
operator|->
name|data
operator|+
literal|2
argument_list|)
expr_stmt|;
name|first
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|pp
operator|=
operator|&
name|first
operator|->
name|next
expr_stmt|;
name|c
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|gc
operator|=
name|group_cursors
init|;
name|gc
operator|!=
name|NULL
condition|;
name|gc
operator|=
name|gc
operator|->
name|next
control|)
block|{
name|struct
name|bindata
modifier|*
name|d
decl_stmt|;
operator|++
name|c
expr_stmt|;
name|d
operator|=
operator|(
expr|struct
name|bindata
operator|*
operator|)
name|reswr_alloc
argument_list|(
sizeof|sizeof
expr|*
name|d
argument_list|)
expr_stmt|;
name|d
operator|->
name|length
operator|=
literal|14
expr_stmt|;
name|d
operator|->
name|data
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|reswr_alloc
argument_list|(
literal|14
argument_list|)
expr_stmt|;
name|put_16
argument_list|(
name|big_endian
argument_list|,
name|gc
operator|->
name|width
argument_list|,
name|d
operator|->
name|data
argument_list|)
expr_stmt|;
name|put_16
argument_list|(
name|big_endian
argument_list|,
name|gc
operator|->
name|height
argument_list|,
name|d
operator|->
name|data
operator|+
literal|2
argument_list|)
expr_stmt|;
name|put_16
argument_list|(
name|big_endian
argument_list|,
name|gc
operator|->
name|planes
argument_list|,
name|d
operator|->
name|data
operator|+
literal|4
argument_list|)
expr_stmt|;
name|put_16
argument_list|(
name|big_endian
argument_list|,
name|gc
operator|->
name|bits
argument_list|,
name|d
operator|->
name|data
operator|+
literal|6
argument_list|)
expr_stmt|;
name|put_32
argument_list|(
name|big_endian
argument_list|,
name|gc
operator|->
name|bytes
argument_list|,
name|d
operator|->
name|data
operator|+
literal|8
argument_list|)
expr_stmt|;
name|put_16
argument_list|(
name|big_endian
argument_list|,
name|gc
operator|->
name|index
argument_list|,
name|d
operator|->
name|data
operator|+
literal|12
argument_list|)
expr_stmt|;
name|d
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
operator|*
name|pp
operator|=
name|d
expr_stmt|;
name|pp
operator|=
operator|&
name|d
operator|->
name|next
expr_stmt|;
block|}
name|put_16
argument_list|(
name|big_endian
argument_list|,
name|c
argument_list|,
name|first
operator|->
name|data
operator|+
literal|4
argument_list|)
expr_stmt|;
return|return
name|first
return|;
block|}
end_function

begin_comment
comment|/* Convert a dialog resource to binary.  */
end_comment

begin_function
specifier|static
name|struct
name|bindata
modifier|*
name|res_to_bin_dialog
parameter_list|(
name|dialog
parameter_list|,
name|big_endian
parameter_list|)
specifier|const
name|struct
name|dialog
modifier|*
name|dialog
decl_stmt|;
name|int
name|big_endian
decl_stmt|;
block|{
name|int
name|dialogex
decl_stmt|;
name|struct
name|bindata
modifier|*
name|first
decl_stmt|,
modifier|*
modifier|*
name|pp
decl_stmt|;
name|unsigned
name|long
name|length
decl_stmt|;
name|int
name|off
decl_stmt|,
name|c
decl_stmt|;
name|struct
name|dialog_control
modifier|*
name|dc
decl_stmt|;
name|dialogex
operator|=
name|extended_dialog
argument_list|(
name|dialog
argument_list|)
expr_stmt|;
name|first
operator|=
operator|(
expr|struct
name|bindata
operator|*
operator|)
name|reswr_alloc
argument_list|(
sizeof|sizeof
expr|*
name|first
argument_list|)
expr_stmt|;
name|first
operator|->
name|length
operator|=
name|dialogex
condition|?
literal|26
else|:
literal|18
expr_stmt|;
name|first
operator|->
name|data
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|reswr_alloc
argument_list|(
name|first
operator|->
name|length
argument_list|)
expr_stmt|;
name|length
operator|=
name|first
operator|->
name|length
expr_stmt|;
if|if
condition|(
operator|!
name|dialogex
condition|)
block|{
name|put_32
argument_list|(
name|big_endian
argument_list|,
name|dialog
operator|->
name|style
argument_list|,
name|first
operator|->
name|data
argument_list|)
expr_stmt|;
name|put_32
argument_list|(
name|big_endian
argument_list|,
name|dialog
operator|->
name|exstyle
argument_list|,
name|first
operator|->
name|data
operator|+
literal|4
argument_list|)
expr_stmt|;
name|off
operator|=
literal|8
expr_stmt|;
block|}
else|else
block|{
name|put_16
argument_list|(
name|big_endian
argument_list|,
literal|1
argument_list|,
name|first
operator|->
name|data
argument_list|)
expr_stmt|;
name|put_16
argument_list|(
name|big_endian
argument_list|,
literal|0xffff
argument_list|,
name|first
operator|->
name|data
operator|+
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|dialog
operator|->
name|ex
operator|==
name|NULL
condition|)
name|put_32
argument_list|(
name|big_endian
argument_list|,
literal|0
argument_list|,
name|first
operator|->
name|data
operator|+
literal|4
argument_list|)
expr_stmt|;
else|else
name|put_32
argument_list|(
name|big_endian
argument_list|,
name|dialog
operator|->
name|ex
operator|->
name|help
argument_list|,
name|first
operator|->
name|data
operator|+
literal|4
argument_list|)
expr_stmt|;
name|put_32
argument_list|(
name|big_endian
argument_list|,
name|dialog
operator|->
name|exstyle
argument_list|,
name|first
operator|->
name|data
operator|+
literal|8
argument_list|)
expr_stmt|;
name|put_32
argument_list|(
name|big_endian
argument_list|,
name|dialog
operator|->
name|style
argument_list|,
name|first
operator|->
name|data
operator|+
literal|12
argument_list|)
expr_stmt|;
name|off
operator|=
literal|16
expr_stmt|;
block|}
name|put_16
argument_list|(
name|big_endian
argument_list|,
name|dialog
operator|->
name|x
argument_list|,
name|first
operator|->
name|data
operator|+
name|off
operator|+
literal|2
argument_list|)
expr_stmt|;
name|put_16
argument_list|(
name|big_endian
argument_list|,
name|dialog
operator|->
name|y
argument_list|,
name|first
operator|->
name|data
operator|+
name|off
operator|+
literal|4
argument_list|)
expr_stmt|;
name|put_16
argument_list|(
name|big_endian
argument_list|,
name|dialog
operator|->
name|width
argument_list|,
name|first
operator|->
name|data
operator|+
name|off
operator|+
literal|6
argument_list|)
expr_stmt|;
name|put_16
argument_list|(
name|big_endian
argument_list|,
name|dialog
operator|->
name|height
argument_list|,
name|first
operator|->
name|data
operator|+
name|off
operator|+
literal|8
argument_list|)
expr_stmt|;
name|pp
operator|=
operator|&
name|first
operator|->
name|next
expr_stmt|;
operator|*
name|pp
operator|=
name|resid_to_bin
argument_list|(
name|dialog
operator|->
name|menu
argument_list|,
name|big_endian
argument_list|)
expr_stmt|;
name|length
operator|+=
operator|(
operator|*
name|pp
operator|)
operator|->
name|length
expr_stmt|;
name|pp
operator|=
operator|&
operator|(
operator|*
name|pp
operator|)
operator|->
name|next
expr_stmt|;
operator|*
name|pp
operator|=
name|resid_to_bin
argument_list|(
name|dialog
operator|->
name|class
argument_list|,
name|big_endian
argument_list|)
expr_stmt|;
name|length
operator|+=
operator|(
operator|*
name|pp
operator|)
operator|->
name|length
expr_stmt|;
name|pp
operator|=
operator|&
operator|(
operator|*
name|pp
operator|)
operator|->
name|next
expr_stmt|;
operator|*
name|pp
operator|=
name|unicode_to_bin
argument_list|(
name|dialog
operator|->
name|caption
argument_list|,
name|big_endian
argument_list|)
expr_stmt|;
name|length
operator|+=
operator|(
operator|*
name|pp
operator|)
operator|->
name|length
expr_stmt|;
name|pp
operator|=
operator|&
operator|(
operator|*
name|pp
operator|)
operator|->
name|next
expr_stmt|;
if|if
condition|(
operator|(
name|dialog
operator|->
name|style
operator|&
name|DS_SETFONT
operator|)
operator|!=
literal|0
condition|)
block|{
name|struct
name|bindata
modifier|*
name|d
decl_stmt|;
name|d
operator|=
operator|(
expr|struct
name|bindata
operator|*
operator|)
name|reswr_alloc
argument_list|(
sizeof|sizeof
expr|*
name|d
argument_list|)
expr_stmt|;
name|d
operator|->
name|length
operator|=
name|dialogex
condition|?
literal|6
else|:
literal|2
expr_stmt|;
name|d
operator|->
name|data
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|reswr_alloc
argument_list|(
name|d
operator|->
name|length
argument_list|)
expr_stmt|;
name|length
operator|+=
name|d
operator|->
name|length
expr_stmt|;
name|put_16
argument_list|(
name|big_endian
argument_list|,
name|dialog
operator|->
name|pointsize
argument_list|,
name|d
operator|->
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|dialogex
condition|)
block|{
if|if
condition|(
name|dialog
operator|->
name|ex
operator|==
name|NULL
condition|)
block|{
name|put_16
argument_list|(
name|big_endian
argument_list|,
literal|0
argument_list|,
name|d
operator|->
name|data
operator|+
literal|2
argument_list|)
expr_stmt|;
name|put_16
argument_list|(
name|big_endian
argument_list|,
literal|0
argument_list|,
name|d
operator|->
name|data
operator|+
literal|4
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|put_16
argument_list|(
name|big_endian
argument_list|,
name|dialog
operator|->
name|ex
operator|->
name|weight
argument_list|,
name|d
operator|->
name|data
operator|+
literal|2
argument_list|)
expr_stmt|;
name|put_16
argument_list|(
name|big_endian
argument_list|,
name|dialog
operator|->
name|ex
operator|->
name|italic
argument_list|,
name|d
operator|->
name|data
operator|+
literal|4
argument_list|)
expr_stmt|;
block|}
block|}
operator|*
name|pp
operator|=
name|d
expr_stmt|;
name|pp
operator|=
operator|&
name|d
operator|->
name|next
expr_stmt|;
operator|*
name|pp
operator|=
name|unicode_to_bin
argument_list|(
name|dialog
operator|->
name|font
argument_list|,
name|big_endian
argument_list|)
expr_stmt|;
name|length
operator|+=
operator|(
operator|*
name|pp
operator|)
operator|->
name|length
expr_stmt|;
name|pp
operator|=
operator|&
operator|(
operator|*
name|pp
operator|)
operator|->
name|next
expr_stmt|;
block|}
name|c
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|dc
operator|=
name|dialog
operator|->
name|controls
init|;
name|dc
operator|!=
name|NULL
condition|;
name|dc
operator|=
name|dc
operator|->
name|next
control|)
block|{
name|struct
name|bindata
modifier|*
name|d
decl_stmt|;
name|int
name|dcoff
decl_stmt|;
operator|++
name|c
expr_stmt|;
name|dword_align_bin
argument_list|(
operator|&
name|pp
argument_list|,
operator|&
name|length
argument_list|)
expr_stmt|;
name|d
operator|=
operator|(
expr|struct
name|bindata
operator|*
operator|)
name|reswr_alloc
argument_list|(
sizeof|sizeof
expr|*
name|d
argument_list|)
expr_stmt|;
name|d
operator|->
name|length
operator|=
name|dialogex
condition|?
literal|24
else|:
literal|18
expr_stmt|;
name|d
operator|->
name|data
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|reswr_alloc
argument_list|(
name|d
operator|->
name|length
argument_list|)
expr_stmt|;
name|length
operator|+=
name|d
operator|->
name|length
expr_stmt|;
if|if
condition|(
operator|!
name|dialogex
condition|)
block|{
name|put_32
argument_list|(
name|big_endian
argument_list|,
name|dc
operator|->
name|style
argument_list|,
name|d
operator|->
name|data
argument_list|)
expr_stmt|;
name|put_32
argument_list|(
name|big_endian
argument_list|,
name|dc
operator|->
name|exstyle
argument_list|,
name|d
operator|->
name|data
operator|+
literal|4
argument_list|)
expr_stmt|;
name|dcoff
operator|=
literal|8
expr_stmt|;
block|}
else|else
block|{
name|put_32
argument_list|(
name|big_endian
argument_list|,
name|dc
operator|->
name|help
argument_list|,
name|d
operator|->
name|data
argument_list|)
expr_stmt|;
name|put_32
argument_list|(
name|big_endian
argument_list|,
name|dc
operator|->
name|exstyle
argument_list|,
name|d
operator|->
name|data
operator|+
literal|4
argument_list|)
expr_stmt|;
name|put_32
argument_list|(
name|big_endian
argument_list|,
name|dc
operator|->
name|style
argument_list|,
name|d
operator|->
name|data
operator|+
literal|8
argument_list|)
expr_stmt|;
name|dcoff
operator|=
literal|12
expr_stmt|;
block|}
name|put_16
argument_list|(
name|big_endian
argument_list|,
name|dc
operator|->
name|x
argument_list|,
name|d
operator|->
name|data
operator|+
name|dcoff
argument_list|)
expr_stmt|;
name|put_16
argument_list|(
name|big_endian
argument_list|,
name|dc
operator|->
name|y
argument_list|,
name|d
operator|->
name|data
operator|+
name|dcoff
operator|+
literal|2
argument_list|)
expr_stmt|;
name|put_16
argument_list|(
name|big_endian
argument_list|,
name|dc
operator|->
name|width
argument_list|,
name|d
operator|->
name|data
operator|+
name|dcoff
operator|+
literal|4
argument_list|)
expr_stmt|;
name|put_16
argument_list|(
name|big_endian
argument_list|,
name|dc
operator|->
name|height
argument_list|,
name|d
operator|->
name|data
operator|+
name|dcoff
operator|+
literal|6
argument_list|)
expr_stmt|;
if|if
condition|(
name|dialogex
condition|)
name|put_32
argument_list|(
name|big_endian
argument_list|,
name|dc
operator|->
name|id
argument_list|,
name|d
operator|->
name|data
operator|+
name|dcoff
operator|+
literal|8
argument_list|)
expr_stmt|;
else|else
name|put_16
argument_list|(
name|big_endian
argument_list|,
name|dc
operator|->
name|id
argument_list|,
name|d
operator|->
name|data
operator|+
name|dcoff
operator|+
literal|8
argument_list|)
expr_stmt|;
operator|*
name|pp
operator|=
name|d
expr_stmt|;
name|pp
operator|=
operator|&
name|d
operator|->
name|next
expr_stmt|;
operator|*
name|pp
operator|=
name|resid_to_bin
argument_list|(
name|dc
operator|->
name|class
argument_list|,
name|big_endian
argument_list|)
expr_stmt|;
name|length
operator|+=
operator|(
operator|*
name|pp
operator|)
operator|->
name|length
expr_stmt|;
name|pp
operator|=
operator|&
operator|(
operator|*
name|pp
operator|)
operator|->
name|next
expr_stmt|;
operator|*
name|pp
operator|=
name|resid_to_bin
argument_list|(
name|dc
operator|->
name|text
argument_list|,
name|big_endian
argument_list|)
expr_stmt|;
name|length
operator|+=
operator|(
operator|*
name|pp
operator|)
operator|->
name|length
expr_stmt|;
name|pp
operator|=
operator|&
operator|(
operator|*
name|pp
operator|)
operator|->
name|next
expr_stmt|;
name|d
operator|=
operator|(
expr|struct
name|bindata
operator|*
operator|)
name|reswr_alloc
argument_list|(
sizeof|sizeof
expr|*
name|d
argument_list|)
expr_stmt|;
name|d
operator|->
name|length
operator|=
literal|2
expr_stmt|;
name|d
operator|->
name|data
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|reswr_alloc
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|length
operator|+=
literal|2
expr_stmt|;
name|d
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
operator|*
name|pp
operator|=
name|d
expr_stmt|;
name|pp
operator|=
operator|&
name|d
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|dc
operator|->
name|data
operator|==
name|NULL
condition|)
name|put_16
argument_list|(
name|big_endian
argument_list|,
literal|0
argument_list|,
name|d
operator|->
name|data
argument_list|)
expr_stmt|;
else|else
block|{
name|unsigned
name|long
name|sublen
decl_stmt|;
name|dword_align_bin
argument_list|(
operator|&
name|pp
argument_list|,
operator|&
name|length
argument_list|)
expr_stmt|;
operator|*
name|pp
operator|=
name|res_to_bin_rcdata
argument_list|(
name|dc
operator|->
name|data
argument_list|,
name|big_endian
argument_list|)
expr_stmt|;
name|sublen
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|pp
operator|!=
name|NULL
condition|)
block|{
name|sublen
operator|+=
operator|(
operator|*
name|pp
operator|)
operator|->
name|length
expr_stmt|;
name|pp
operator|=
operator|&
operator|(
operator|*
name|pp
operator|)
operator|->
name|next
expr_stmt|;
block|}
name|put_16
argument_list|(
name|big_endian
argument_list|,
name|sublen
argument_list|,
name|d
operator|->
name|data
argument_list|)
expr_stmt|;
name|length
operator|+=
name|sublen
expr_stmt|;
block|}
block|}
name|put_16
argument_list|(
name|big_endian
argument_list|,
name|c
argument_list|,
name|first
operator|->
name|data
operator|+
name|off
argument_list|)
expr_stmt|;
return|return
name|first
return|;
block|}
end_function

begin_comment
comment|/* Convert a fontdir resource to binary.  */
end_comment

begin_function
specifier|static
name|struct
name|bindata
modifier|*
name|res_to_bin_fontdir
parameter_list|(
name|fontdirs
parameter_list|,
name|big_endian
parameter_list|)
specifier|const
name|struct
name|fontdir
modifier|*
name|fontdirs
decl_stmt|;
name|int
name|big_endian
decl_stmt|;
block|{
name|struct
name|bindata
modifier|*
name|first
decl_stmt|,
modifier|*
modifier|*
name|pp
decl_stmt|;
name|int
name|c
decl_stmt|;
specifier|const
name|struct
name|fontdir
modifier|*
name|fd
decl_stmt|;
name|first
operator|=
operator|(
expr|struct
name|bindata
operator|*
operator|)
name|reswr_alloc
argument_list|(
sizeof|sizeof
expr|*
name|first
argument_list|)
expr_stmt|;
name|first
operator|->
name|length
operator|=
literal|2
expr_stmt|;
name|first
operator|->
name|data
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|reswr_alloc
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|first
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|pp
operator|=
operator|&
name|first
operator|->
name|next
expr_stmt|;
name|c
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|fd
operator|=
name|fontdirs
init|;
name|fd
operator|!=
name|NULL
condition|;
name|fd
operator|=
name|fd
operator|->
name|next
control|)
block|{
name|struct
name|bindata
modifier|*
name|d
decl_stmt|;
operator|++
name|c
expr_stmt|;
name|d
operator|=
operator|(
expr|struct
name|bindata
operator|*
operator|)
name|reswr_alloc
argument_list|(
sizeof|sizeof
expr|*
name|d
argument_list|)
expr_stmt|;
name|d
operator|->
name|length
operator|=
literal|2
expr_stmt|;
name|d
operator|->
name|data
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|reswr_alloc
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|put_16
argument_list|(
name|big_endian
argument_list|,
name|fd
operator|->
name|index
argument_list|,
name|d
operator|->
name|data
argument_list|)
expr_stmt|;
operator|*
name|pp
operator|=
name|d
expr_stmt|;
name|pp
operator|=
operator|&
name|d
operator|->
name|next
expr_stmt|;
name|d
operator|=
operator|(
expr|struct
name|bindata
operator|*
operator|)
name|reswr_alloc
argument_list|(
sizeof|sizeof
expr|*
name|d
argument_list|)
expr_stmt|;
name|d
operator|->
name|length
operator|=
name|fd
operator|->
name|length
expr_stmt|;
name|d
operator|->
name|data
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|fd
operator|->
name|data
expr_stmt|;
name|d
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
operator|*
name|pp
operator|=
name|d
expr_stmt|;
name|pp
operator|=
operator|&
name|d
operator|->
name|next
expr_stmt|;
block|}
name|put_16
argument_list|(
name|big_endian
argument_list|,
name|c
argument_list|,
name|first
operator|->
name|data
argument_list|)
expr_stmt|;
return|return
name|first
return|;
block|}
end_function

begin_comment
comment|/* Convert a group icon resource to binary.  */
end_comment

begin_function
specifier|static
name|struct
name|bindata
modifier|*
name|res_to_bin_group_icon
parameter_list|(
name|group_icons
parameter_list|,
name|big_endian
parameter_list|)
specifier|const
name|struct
name|group_icon
modifier|*
name|group_icons
decl_stmt|;
name|int
name|big_endian
decl_stmt|;
block|{
name|struct
name|bindata
modifier|*
name|first
decl_stmt|,
modifier|*
modifier|*
name|pp
decl_stmt|;
name|int
name|c
decl_stmt|;
specifier|const
name|struct
name|group_icon
modifier|*
name|gi
decl_stmt|;
name|first
operator|=
operator|(
expr|struct
name|bindata
operator|*
operator|)
name|reswr_alloc
argument_list|(
sizeof|sizeof
expr|*
name|first
argument_list|)
expr_stmt|;
name|first
operator|->
name|length
operator|=
literal|6
expr_stmt|;
name|first
operator|->
name|data
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|reswr_alloc
argument_list|(
literal|6
argument_list|)
expr_stmt|;
name|put_16
argument_list|(
name|big_endian
argument_list|,
literal|0
argument_list|,
name|first
operator|->
name|data
argument_list|)
expr_stmt|;
name|put_16
argument_list|(
name|big_endian
argument_list|,
literal|1
argument_list|,
name|first
operator|->
name|data
operator|+
literal|2
argument_list|)
expr_stmt|;
name|first
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|pp
operator|=
operator|&
name|first
operator|->
name|next
expr_stmt|;
name|c
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|gi
operator|=
name|group_icons
init|;
name|gi
operator|!=
name|NULL
condition|;
name|gi
operator|=
name|gi
operator|->
name|next
control|)
block|{
name|struct
name|bindata
modifier|*
name|d
decl_stmt|;
operator|++
name|c
expr_stmt|;
name|d
operator|=
operator|(
expr|struct
name|bindata
operator|*
operator|)
name|reswr_alloc
argument_list|(
sizeof|sizeof
expr|*
name|d
argument_list|)
expr_stmt|;
name|d
operator|->
name|length
operator|=
literal|14
expr_stmt|;
name|d
operator|->
name|data
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|reswr_alloc
argument_list|(
literal|14
argument_list|)
expr_stmt|;
name|d
operator|->
name|data
index|[
literal|0
index|]
operator|=
name|gi
operator|->
name|width
expr_stmt|;
name|d
operator|->
name|data
index|[
literal|1
index|]
operator|=
name|gi
operator|->
name|height
expr_stmt|;
name|d
operator|->
name|data
index|[
literal|2
index|]
operator|=
name|gi
operator|->
name|colors
expr_stmt|;
name|d
operator|->
name|data
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
name|put_16
argument_list|(
name|big_endian
argument_list|,
name|gi
operator|->
name|planes
argument_list|,
name|d
operator|->
name|data
operator|+
literal|4
argument_list|)
expr_stmt|;
name|put_16
argument_list|(
name|big_endian
argument_list|,
name|gi
operator|->
name|bits
argument_list|,
name|d
operator|->
name|data
operator|+
literal|6
argument_list|)
expr_stmt|;
name|put_32
argument_list|(
name|big_endian
argument_list|,
name|gi
operator|->
name|bytes
argument_list|,
name|d
operator|->
name|data
operator|+
literal|8
argument_list|)
expr_stmt|;
name|put_16
argument_list|(
name|big_endian
argument_list|,
name|gi
operator|->
name|index
argument_list|,
name|d
operator|->
name|data
operator|+
literal|12
argument_list|)
expr_stmt|;
name|d
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
operator|*
name|pp
operator|=
name|d
expr_stmt|;
name|pp
operator|=
operator|&
name|d
operator|->
name|next
expr_stmt|;
block|}
name|put_16
argument_list|(
name|big_endian
argument_list|,
name|c
argument_list|,
name|first
operator|->
name|data
operator|+
literal|4
argument_list|)
expr_stmt|;
return|return
name|first
return|;
block|}
end_function

begin_comment
comment|/* Convert a menu resource to binary.  */
end_comment

begin_function
specifier|static
name|struct
name|bindata
modifier|*
name|res_to_bin_menu
parameter_list|(
name|menu
parameter_list|,
name|big_endian
parameter_list|)
specifier|const
name|struct
name|menu
modifier|*
name|menu
decl_stmt|;
name|int
name|big_endian
decl_stmt|;
block|{
name|int
name|menuex
decl_stmt|;
name|struct
name|bindata
modifier|*
name|d
decl_stmt|;
name|menuex
operator|=
name|extended_menu
argument_list|(
name|menu
argument_list|)
expr_stmt|;
name|d
operator|=
operator|(
expr|struct
name|bindata
operator|*
operator|)
name|reswr_alloc
argument_list|(
sizeof|sizeof
expr|*
name|d
argument_list|)
expr_stmt|;
name|d
operator|->
name|length
operator|=
name|menuex
condition|?
literal|8
else|:
literal|4
expr_stmt|;
name|d
operator|->
name|data
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|reswr_alloc
argument_list|(
name|d
operator|->
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|menuex
condition|)
block|{
name|put_16
argument_list|(
name|big_endian
argument_list|,
literal|0
argument_list|,
name|d
operator|->
name|data
argument_list|)
expr_stmt|;
name|put_16
argument_list|(
name|big_endian
argument_list|,
literal|0
argument_list|,
name|d
operator|->
name|data
operator|+
literal|2
argument_list|)
expr_stmt|;
name|d
operator|->
name|next
operator|=
name|res_to_bin_menuitems
argument_list|(
name|menu
operator|->
name|items
argument_list|,
name|big_endian
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|put_16
argument_list|(
name|big_endian
argument_list|,
literal|1
argument_list|,
name|d
operator|->
name|data
argument_list|)
expr_stmt|;
name|put_16
argument_list|(
name|big_endian
argument_list|,
literal|4
argument_list|,
name|d
operator|->
name|data
operator|+
literal|2
argument_list|)
expr_stmt|;
name|put_32
argument_list|(
name|big_endian
argument_list|,
name|menu
operator|->
name|help
argument_list|,
name|d
operator|->
name|data
operator|+
literal|4
argument_list|)
expr_stmt|;
name|d
operator|->
name|next
operator|=
name|res_to_bin_menuexitems
argument_list|(
name|menu
operator|->
name|items
argument_list|,
name|big_endian
argument_list|)
expr_stmt|;
block|}
return|return
name|d
return|;
block|}
end_function

begin_comment
comment|/* Convert menu items to binary.  */
end_comment

begin_function
specifier|static
name|struct
name|bindata
modifier|*
name|res_to_bin_menuitems
parameter_list|(
name|items
parameter_list|,
name|big_endian
parameter_list|)
specifier|const
name|struct
name|menuitem
modifier|*
name|items
decl_stmt|;
name|int
name|big_endian
decl_stmt|;
block|{
name|struct
name|bindata
modifier|*
name|first
decl_stmt|,
modifier|*
modifier|*
name|pp
decl_stmt|;
specifier|const
name|struct
name|menuitem
modifier|*
name|mi
decl_stmt|;
name|first
operator|=
name|NULL
expr_stmt|;
name|pp
operator|=
operator|&
name|first
expr_stmt|;
for|for
control|(
name|mi
operator|=
name|items
init|;
name|mi
operator|!=
name|NULL
condition|;
name|mi
operator|=
name|mi
operator|->
name|next
control|)
block|{
name|struct
name|bindata
modifier|*
name|d
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|d
operator|=
operator|(
expr|struct
name|bindata
operator|*
operator|)
name|reswr_alloc
argument_list|(
sizeof|sizeof
expr|*
name|d
argument_list|)
expr_stmt|;
name|d
operator|->
name|length
operator|=
name|mi
operator|->
name|popup
operator|==
name|NULL
condition|?
literal|4
else|:
literal|2
expr_stmt|;
name|d
operator|->
name|data
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|reswr_alloc
argument_list|(
name|d
operator|->
name|length
argument_list|)
expr_stmt|;
name|flags
operator|=
name|mi
operator|->
name|type
expr_stmt|;
if|if
condition|(
name|mi
operator|->
name|next
operator|==
name|NULL
condition|)
name|flags
operator||=
name|MENUITEM_ENDMENU
expr_stmt|;
if|if
condition|(
name|mi
operator|->
name|popup
operator|!=
name|NULL
condition|)
name|flags
operator||=
name|MENUITEM_POPUP
expr_stmt|;
name|put_16
argument_list|(
name|big_endian
argument_list|,
name|flags
argument_list|,
name|d
operator|->
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|mi
operator|->
name|popup
operator|==
name|NULL
condition|)
name|put_16
argument_list|(
name|big_endian
argument_list|,
name|mi
operator|->
name|id
argument_list|,
name|d
operator|->
name|data
operator|+
literal|2
argument_list|)
expr_stmt|;
operator|*
name|pp
operator|=
name|d
expr_stmt|;
name|pp
operator|=
operator|&
name|d
operator|->
name|next
expr_stmt|;
operator|*
name|pp
operator|=
name|unicode_to_bin
argument_list|(
name|mi
operator|->
name|text
argument_list|,
name|big_endian
argument_list|)
expr_stmt|;
name|pp
operator|=
operator|&
operator|(
operator|*
name|pp
operator|)
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|mi
operator|->
name|popup
operator|!=
name|NULL
condition|)
block|{
operator|*
name|pp
operator|=
name|res_to_bin_menuitems
argument_list|(
name|mi
operator|->
name|popup
argument_list|,
name|big_endian
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|pp
operator|!=
name|NULL
condition|)
name|pp
operator|=
operator|&
operator|(
operator|*
name|pp
operator|)
operator|->
name|next
expr_stmt|;
block|}
block|}
return|return
name|first
return|;
block|}
end_function

begin_comment
comment|/* Convert menuex items to binary.  */
end_comment

begin_function
specifier|static
name|struct
name|bindata
modifier|*
name|res_to_bin_menuexitems
parameter_list|(
name|items
parameter_list|,
name|big_endian
parameter_list|)
specifier|const
name|struct
name|menuitem
modifier|*
name|items
decl_stmt|;
name|int
name|big_endian
decl_stmt|;
block|{
name|struct
name|bindata
modifier|*
name|first
decl_stmt|,
modifier|*
modifier|*
name|pp
decl_stmt|;
name|unsigned
name|long
name|length
decl_stmt|;
specifier|const
name|struct
name|menuitem
modifier|*
name|mi
decl_stmt|;
name|first
operator|=
name|NULL
expr_stmt|;
name|pp
operator|=
operator|&
name|first
expr_stmt|;
name|length
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|mi
operator|=
name|items
init|;
name|mi
operator|!=
name|NULL
condition|;
name|mi
operator|=
name|mi
operator|->
name|next
control|)
block|{
name|struct
name|bindata
modifier|*
name|d
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|dword_align_bin
argument_list|(
operator|&
name|pp
argument_list|,
operator|&
name|length
argument_list|)
expr_stmt|;
name|d
operator|=
operator|(
expr|struct
name|bindata
operator|*
operator|)
name|reswr_alloc
argument_list|(
sizeof|sizeof
expr|*
name|d
argument_list|)
expr_stmt|;
name|d
operator|->
name|length
operator|=
literal|12
expr_stmt|;
name|d
operator|->
name|data
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|reswr_alloc
argument_list|(
literal|12
argument_list|)
expr_stmt|;
name|length
operator|+=
literal|12
expr_stmt|;
name|put_32
argument_list|(
name|big_endian
argument_list|,
name|mi
operator|->
name|type
argument_list|,
name|d
operator|->
name|data
argument_list|)
expr_stmt|;
name|put_32
argument_list|(
name|big_endian
argument_list|,
name|mi
operator|->
name|state
argument_list|,
name|d
operator|->
name|data
operator|+
literal|4
argument_list|)
expr_stmt|;
name|put_16
argument_list|(
name|big_endian
argument_list|,
name|mi
operator|->
name|id
argument_list|,
name|d
operator|->
name|data
operator|+
literal|8
argument_list|)
expr_stmt|;
name|flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|mi
operator|->
name|next
operator|==
name|NULL
condition|)
name|flags
operator||=
literal|0x80
expr_stmt|;
if|if
condition|(
name|mi
operator|->
name|popup
operator|!=
name|NULL
condition|)
name|flags
operator||=
literal|1
expr_stmt|;
name|put_16
argument_list|(
name|big_endian
argument_list|,
name|flags
argument_list|,
name|d
operator|->
name|data
operator|+
literal|10
argument_list|)
expr_stmt|;
operator|*
name|pp
operator|=
name|d
expr_stmt|;
name|pp
operator|=
operator|&
name|d
operator|->
name|next
expr_stmt|;
operator|*
name|pp
operator|=
name|unicode_to_bin
argument_list|(
name|mi
operator|->
name|text
argument_list|,
name|big_endian
argument_list|)
expr_stmt|;
name|length
operator|+=
operator|(
operator|*
name|pp
operator|)
operator|->
name|length
expr_stmt|;
name|pp
operator|=
operator|&
operator|(
operator|*
name|pp
operator|)
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|mi
operator|->
name|popup
operator|!=
name|NULL
condition|)
block|{
name|dword_align_bin
argument_list|(
operator|&
name|pp
argument_list|,
operator|&
name|length
argument_list|)
expr_stmt|;
name|d
operator|=
operator|(
expr|struct
name|bindata
operator|*
operator|)
name|reswr_alloc
argument_list|(
sizeof|sizeof
expr|*
name|d
argument_list|)
expr_stmt|;
name|d
operator|->
name|length
operator|=
literal|4
expr_stmt|;
name|d
operator|->
name|data
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|reswr_alloc
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|put_32
argument_list|(
name|big_endian
argument_list|,
name|mi
operator|->
name|help
argument_list|,
name|d
operator|->
name|data
argument_list|)
expr_stmt|;
operator|*
name|pp
operator|=
name|d
expr_stmt|;
name|pp
operator|=
operator|&
name|d
operator|->
name|next
expr_stmt|;
operator|*
name|pp
operator|=
name|res_to_bin_menuexitems
argument_list|(
name|mi
operator|->
name|popup
argument_list|,
name|big_endian
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|pp
operator|!=
name|NULL
condition|)
block|{
name|length
operator|+=
operator|(
operator|*
name|pp
operator|)
operator|->
name|length
expr_stmt|;
name|pp
operator|=
operator|&
operator|(
operator|*
name|pp
operator|)
operator|->
name|next
expr_stmt|;
block|}
block|}
block|}
return|return
name|first
return|;
block|}
end_function

begin_comment
comment|/* Convert an rcdata resource to binary.  This is also used to convert    other information which happens to be stored in rcdata_item lists    to binary.  */
end_comment

begin_function
specifier|static
name|struct
name|bindata
modifier|*
name|res_to_bin_rcdata
parameter_list|(
name|items
parameter_list|,
name|big_endian
parameter_list|)
specifier|const
name|struct
name|rcdata_item
modifier|*
name|items
decl_stmt|;
name|int
name|big_endian
decl_stmt|;
block|{
name|struct
name|bindata
modifier|*
name|first
decl_stmt|,
modifier|*
modifier|*
name|pp
decl_stmt|;
specifier|const
name|struct
name|rcdata_item
modifier|*
name|ri
decl_stmt|;
name|first
operator|=
name|NULL
expr_stmt|;
name|pp
operator|=
operator|&
name|first
expr_stmt|;
for|for
control|(
name|ri
operator|=
name|items
init|;
name|ri
operator|!=
name|NULL
condition|;
name|ri
operator|=
name|ri
operator|->
name|next
control|)
block|{
name|struct
name|bindata
modifier|*
name|d
decl_stmt|;
name|d
operator|=
operator|(
expr|struct
name|bindata
operator|*
operator|)
name|reswr_alloc
argument_list|(
sizeof|sizeof
expr|*
name|d
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ri
operator|->
name|type
condition|)
block|{
default|default:
name|abort
argument_list|()
expr_stmt|;
case|case
name|RCDATA_WORD
case|:
name|d
operator|->
name|length
operator|=
literal|2
expr_stmt|;
name|d
operator|->
name|data
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|reswr_alloc
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|put_16
argument_list|(
name|big_endian
argument_list|,
name|ri
operator|->
name|u
operator|.
name|word
argument_list|,
name|d
operator|->
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|RCDATA_DWORD
case|:
name|d
operator|->
name|length
operator|=
literal|4
expr_stmt|;
name|d
operator|->
name|data
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|reswr_alloc
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|put_32
argument_list|(
name|big_endian
argument_list|,
name|ri
operator|->
name|u
operator|.
name|dword
argument_list|,
name|d
operator|->
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|RCDATA_STRING
case|:
name|d
operator|->
name|length
operator|=
name|ri
operator|->
name|u
operator|.
name|string
operator|.
name|length
expr_stmt|;
name|d
operator|->
name|data
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|ri
operator|->
name|u
operator|.
name|string
operator|.
name|s
expr_stmt|;
break|break;
case|case
name|RCDATA_WSTRING
case|:
block|{
name|unsigned
name|long
name|i
decl_stmt|;
name|d
operator|->
name|length
operator|=
name|ri
operator|->
name|u
operator|.
name|wstring
operator|.
name|length
operator|*
literal|2
expr_stmt|;
name|d
operator|->
name|data
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|reswr_alloc
argument_list|(
name|d
operator|->
name|length
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ri
operator|->
name|u
operator|.
name|wstring
operator|.
name|length
condition|;
name|i
operator|++
control|)
name|put_16
argument_list|(
name|big_endian
argument_list|,
name|ri
operator|->
name|u
operator|.
name|wstring
operator|.
name|w
index|[
name|i
index|]
argument_list|,
name|d
operator|->
name|data
operator|+
name|i
operator|*
literal|2
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|RCDATA_BUFFER
case|:
name|d
operator|->
name|length
operator|=
name|ri
operator|->
name|u
operator|.
name|buffer
operator|.
name|length
expr_stmt|;
name|d
operator|->
name|data
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|ri
operator|->
name|u
operator|.
name|buffer
operator|.
name|data
expr_stmt|;
break|break;
block|}
name|d
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
operator|*
name|pp
operator|=
name|d
expr_stmt|;
name|pp
operator|=
operator|&
name|d
operator|->
name|next
expr_stmt|;
block|}
return|return
name|first
return|;
block|}
end_function

begin_comment
comment|/* Convert a stringtable resource to binary.  */
end_comment

begin_function
specifier|static
name|struct
name|bindata
modifier|*
name|res_to_bin_stringtable
parameter_list|(
name|st
parameter_list|,
name|big_endian
parameter_list|)
specifier|const
name|struct
name|stringtable
modifier|*
name|st
decl_stmt|;
name|int
name|big_endian
decl_stmt|;
block|{
name|struct
name|bindata
modifier|*
name|first
decl_stmt|,
modifier|*
modifier|*
name|pp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|first
operator|=
name|NULL
expr_stmt|;
name|pp
operator|=
operator|&
name|first
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
block|{
name|int
name|slen
decl_stmt|,
name|j
decl_stmt|;
name|struct
name|bindata
modifier|*
name|d
decl_stmt|;
name|unichar
modifier|*
name|s
decl_stmt|;
name|slen
operator|=
name|st
operator|->
name|strings
index|[
name|i
index|]
operator|.
name|length
expr_stmt|;
name|s
operator|=
name|st
operator|->
name|strings
index|[
name|i
index|]
operator|.
name|string
expr_stmt|;
name|d
operator|=
operator|(
expr|struct
name|bindata
operator|*
operator|)
name|reswr_alloc
argument_list|(
sizeof|sizeof
expr|*
name|d
argument_list|)
expr_stmt|;
name|d
operator|->
name|length
operator|=
literal|2
operator|+
name|slen
operator|*
literal|2
expr_stmt|;
name|d
operator|->
name|data
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|reswr_alloc
argument_list|(
name|d
operator|->
name|length
argument_list|)
expr_stmt|;
name|put_16
argument_list|(
name|big_endian
argument_list|,
name|slen
argument_list|,
name|d
operator|->
name|data
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|slen
condition|;
name|j
operator|++
control|)
name|put_16
argument_list|(
name|big_endian
argument_list|,
name|s
index|[
name|j
index|]
argument_list|,
name|d
operator|->
name|data
operator|+
literal|2
operator|+
name|j
operator|*
literal|2
argument_list|)
expr_stmt|;
name|d
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
operator|*
name|pp
operator|=
name|d
expr_stmt|;
name|pp
operator|=
operator|&
name|d
operator|->
name|next
expr_stmt|;
block|}
return|return
name|first
return|;
block|}
end_function

begin_comment
comment|/* Convert an ASCII string to a unicode binary string.  This always    returns exactly one bindata structure.  */
end_comment

begin_function
specifier|static
name|struct
name|bindata
modifier|*
name|string_to_unicode_bin
parameter_list|(
name|s
parameter_list|,
name|big_endian
parameter_list|)
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|big_endian
decl_stmt|;
block|{
name|size_t
name|len
decl_stmt|,
name|i
decl_stmt|;
name|struct
name|bindata
modifier|*
name|d
decl_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|d
operator|=
operator|(
expr|struct
name|bindata
operator|*
operator|)
name|reswr_alloc
argument_list|(
sizeof|sizeof
expr|*
name|d
argument_list|)
expr_stmt|;
name|d
operator|->
name|length
operator|=
name|len
operator|*
literal|2
operator|+
literal|2
expr_stmt|;
name|d
operator|->
name|data
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|reswr_alloc
argument_list|(
name|d
operator|->
name|length
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
name|put_16
argument_list|(
name|big_endian
argument_list|,
name|s
index|[
name|i
index|]
argument_list|,
name|d
operator|->
name|data
operator|+
name|i
operator|*
literal|2
argument_list|)
expr_stmt|;
name|put_16
argument_list|(
name|big_endian
argument_list|,
literal|0
argument_list|,
name|d
operator|->
name|data
operator|+
name|i
operator|*
literal|2
argument_list|)
expr_stmt|;
name|d
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
return|return
name|d
return|;
block|}
end_function

begin_comment
comment|/* Convert a versioninfo resource to binary.  */
end_comment

begin_function
specifier|static
name|struct
name|bindata
modifier|*
name|res_to_bin_versioninfo
parameter_list|(
name|versioninfo
parameter_list|,
name|big_endian
parameter_list|)
specifier|const
name|struct
name|versioninfo
modifier|*
name|versioninfo
decl_stmt|;
name|int
name|big_endian
decl_stmt|;
block|{
name|struct
name|bindata
modifier|*
name|first
decl_stmt|,
modifier|*
modifier|*
name|pp
decl_stmt|;
name|unsigned
name|long
name|length
decl_stmt|;
name|struct
name|ver_info
modifier|*
name|vi
decl_stmt|;
name|first
operator|=
operator|(
expr|struct
name|bindata
operator|*
operator|)
name|reswr_alloc
argument_list|(
sizeof|sizeof
expr|*
name|first
argument_list|)
expr_stmt|;
name|first
operator|->
name|length
operator|=
literal|6
expr_stmt|;
name|first
operator|->
name|data
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|reswr_alloc
argument_list|(
literal|6
argument_list|)
expr_stmt|;
name|length
operator|=
literal|6
expr_stmt|;
if|if
condition|(
name|versioninfo
operator|->
name|fixed
operator|==
name|NULL
condition|)
name|put_16
argument_list|(
name|big_endian
argument_list|,
literal|0
argument_list|,
name|first
operator|->
name|data
operator|+
literal|2
argument_list|)
expr_stmt|;
else|else
name|put_16
argument_list|(
name|big_endian
argument_list|,
literal|52
argument_list|,
name|first
operator|->
name|data
operator|+
literal|2
argument_list|)
expr_stmt|;
name|put_16
argument_list|(
name|big_endian
argument_list|,
literal|0
argument_list|,
name|first
operator|->
name|data
operator|+
literal|4
argument_list|)
expr_stmt|;
name|pp
operator|=
operator|&
name|first
operator|->
name|next
expr_stmt|;
operator|*
name|pp
operator|=
name|string_to_unicode_bin
argument_list|(
literal|"VS_VERSION_INFO"
argument_list|,
name|big_endian
argument_list|)
expr_stmt|;
name|length
operator|+=
operator|(
operator|*
name|pp
operator|)
operator|->
name|length
expr_stmt|;
name|pp
operator|=
operator|&
operator|(
operator|*
name|pp
operator|)
operator|->
name|next
expr_stmt|;
name|dword_align_bin
argument_list|(
operator|&
name|pp
argument_list|,
operator|&
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|versioninfo
operator|->
name|fixed
operator|!=
name|NULL
condition|)
block|{
specifier|const
name|struct
name|fixed_versioninfo
modifier|*
name|fi
decl_stmt|;
name|struct
name|bindata
modifier|*
name|d
decl_stmt|;
name|d
operator|=
operator|(
expr|struct
name|bindata
operator|*
operator|)
name|reswr_alloc
argument_list|(
sizeof|sizeof
expr|*
name|d
argument_list|)
expr_stmt|;
name|d
operator|->
name|length
operator|=
literal|52
expr_stmt|;
name|d
operator|->
name|data
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|reswr_alloc
argument_list|(
literal|52
argument_list|)
expr_stmt|;
name|length
operator|+=
literal|52
expr_stmt|;
name|fi
operator|=
name|versioninfo
operator|->
name|fixed
expr_stmt|;
name|put_32
argument_list|(
name|big_endian
argument_list|,
literal|0xfeef04bd
argument_list|,
name|d
operator|->
name|data
argument_list|)
expr_stmt|;
name|put_32
argument_list|(
name|big_endian
argument_list|,
literal|0x10000
argument_list|,
name|d
operator|->
name|data
operator|+
literal|4
argument_list|)
expr_stmt|;
name|put_32
argument_list|(
name|big_endian
argument_list|,
name|fi
operator|->
name|file_version_ms
argument_list|,
name|d
operator|->
name|data
operator|+
literal|8
argument_list|)
expr_stmt|;
name|put_32
argument_list|(
name|big_endian
argument_list|,
name|fi
operator|->
name|file_version_ls
argument_list|,
name|d
operator|->
name|data
operator|+
literal|12
argument_list|)
expr_stmt|;
name|put_32
argument_list|(
name|big_endian
argument_list|,
name|fi
operator|->
name|product_version_ms
argument_list|,
name|d
operator|->
name|data
operator|+
literal|16
argument_list|)
expr_stmt|;
name|put_32
argument_list|(
name|big_endian
argument_list|,
name|fi
operator|->
name|product_version_ls
argument_list|,
name|d
operator|->
name|data
operator|+
literal|20
argument_list|)
expr_stmt|;
name|put_32
argument_list|(
name|big_endian
argument_list|,
name|fi
operator|->
name|file_flags_mask
argument_list|,
name|d
operator|->
name|data
operator|+
literal|24
argument_list|)
expr_stmt|;
name|put_32
argument_list|(
name|big_endian
argument_list|,
name|fi
operator|->
name|file_flags
argument_list|,
name|d
operator|->
name|data
operator|+
literal|28
argument_list|)
expr_stmt|;
name|put_32
argument_list|(
name|big_endian
argument_list|,
name|fi
operator|->
name|file_os
argument_list|,
name|d
operator|->
name|data
operator|+
literal|32
argument_list|)
expr_stmt|;
name|put_32
argument_list|(
name|big_endian
argument_list|,
name|fi
operator|->
name|file_type
argument_list|,
name|d
operator|->
name|data
operator|+
literal|36
argument_list|)
expr_stmt|;
name|put_32
argument_list|(
name|big_endian
argument_list|,
name|fi
operator|->
name|file_subtype
argument_list|,
name|d
operator|->
name|data
operator|+
literal|40
argument_list|)
expr_stmt|;
name|put_32
argument_list|(
name|big_endian
argument_list|,
name|fi
operator|->
name|file_date_ms
argument_list|,
name|d
operator|->
name|data
operator|+
literal|44
argument_list|)
expr_stmt|;
name|put_32
argument_list|(
name|big_endian
argument_list|,
name|fi
operator|->
name|file_date_ls
argument_list|,
name|d
operator|->
name|data
operator|+
literal|48
argument_list|)
expr_stmt|;
name|d
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
operator|*
name|pp
operator|=
name|d
expr_stmt|;
name|pp
operator|=
operator|&
name|d
operator|->
name|next
expr_stmt|;
block|}
for|for
control|(
name|vi
operator|=
name|versioninfo
operator|->
name|var
init|;
name|vi
operator|!=
name|NULL
condition|;
name|vi
operator|=
name|vi
operator|->
name|next
control|)
block|{
name|struct
name|bindata
modifier|*
name|vid
decl_stmt|;
name|unsigned
name|long
name|vilen
decl_stmt|;
name|dword_align_bin
argument_list|(
operator|&
name|pp
argument_list|,
operator|&
name|length
argument_list|)
expr_stmt|;
name|vid
operator|=
operator|(
expr|struct
name|bindata
operator|*
operator|)
name|reswr_alloc
argument_list|(
sizeof|sizeof
expr|*
name|vid
argument_list|)
expr_stmt|;
name|vid
operator|->
name|length
operator|=
literal|6
expr_stmt|;
name|vid
operator|->
name|data
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|reswr_alloc
argument_list|(
literal|6
argument_list|)
expr_stmt|;
name|length
operator|+=
literal|6
expr_stmt|;
name|vilen
operator|=
literal|6
expr_stmt|;
name|put_16
argument_list|(
name|big_endian
argument_list|,
literal|0
argument_list|,
name|vid
operator|->
name|data
operator|+
literal|2
argument_list|)
expr_stmt|;
name|put_16
argument_list|(
name|big_endian
argument_list|,
literal|0
argument_list|,
name|vid
operator|->
name|data
operator|+
literal|4
argument_list|)
expr_stmt|;
operator|*
name|pp
operator|=
name|vid
expr_stmt|;
name|pp
operator|=
operator|&
name|vid
operator|->
name|next
expr_stmt|;
switch|switch
condition|(
name|vi
operator|->
name|type
condition|)
block|{
default|default:
name|abort
argument_list|()
expr_stmt|;
case|case
name|VERINFO_STRING
case|:
block|{
name|unsigned
name|long
name|hold
decl_stmt|,
name|vslen
decl_stmt|;
name|struct
name|bindata
modifier|*
name|vsd
decl_stmt|;
specifier|const
name|struct
name|ver_stringinfo
modifier|*
name|vs
decl_stmt|;
operator|*
name|pp
operator|=
name|string_to_unicode_bin
argument_list|(
literal|"StringFileInfo"
argument_list|,
name|big_endian
argument_list|)
expr_stmt|;
name|length
operator|+=
operator|(
operator|*
name|pp
operator|)
operator|->
name|length
expr_stmt|;
name|vilen
operator|+=
operator|(
operator|*
name|pp
operator|)
operator|->
name|length
expr_stmt|;
name|pp
operator|=
operator|&
operator|(
operator|*
name|pp
operator|)
operator|->
name|next
expr_stmt|;
name|hold
operator|=
name|length
expr_stmt|;
name|dword_align_bin
argument_list|(
operator|&
name|pp
argument_list|,
operator|&
name|length
argument_list|)
expr_stmt|;
name|vilen
operator|+=
name|length
operator|-
name|hold
expr_stmt|;
name|vsd
operator|=
operator|(
expr|struct
name|bindata
operator|*
operator|)
name|reswr_alloc
argument_list|(
sizeof|sizeof
expr|*
name|vsd
argument_list|)
expr_stmt|;
name|vsd
operator|->
name|length
operator|=
literal|6
expr_stmt|;
name|vsd
operator|->
name|data
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|reswr_alloc
argument_list|(
literal|6
argument_list|)
expr_stmt|;
name|length
operator|+=
literal|6
expr_stmt|;
name|vilen
operator|+=
literal|6
expr_stmt|;
name|vslen
operator|=
literal|6
expr_stmt|;
name|put_16
argument_list|(
name|big_endian
argument_list|,
literal|0
argument_list|,
name|vsd
operator|->
name|data
operator|+
literal|2
argument_list|)
expr_stmt|;
name|put_16
argument_list|(
name|big_endian
argument_list|,
literal|0
argument_list|,
name|vsd
operator|->
name|data
operator|+
literal|4
argument_list|)
expr_stmt|;
operator|*
name|pp
operator|=
name|vsd
expr_stmt|;
name|pp
operator|=
operator|&
name|vsd
operator|->
name|next
expr_stmt|;
operator|*
name|pp
operator|=
name|unicode_to_bin
argument_list|(
name|vi
operator|->
name|u
operator|.
name|string
operator|.
name|language
argument_list|,
name|big_endian
argument_list|)
expr_stmt|;
name|length
operator|+=
operator|(
operator|*
name|pp
operator|)
operator|->
name|length
expr_stmt|;
name|vilen
operator|+=
operator|(
operator|*
name|pp
operator|)
operator|->
name|length
expr_stmt|;
name|vslen
operator|+=
operator|(
operator|*
name|pp
operator|)
operator|->
name|length
expr_stmt|;
name|pp
operator|=
operator|&
operator|(
operator|*
name|pp
operator|)
operator|->
name|next
expr_stmt|;
for|for
control|(
name|vs
operator|=
name|vi
operator|->
name|u
operator|.
name|string
operator|.
name|strings
init|;
name|vs
operator|!=
name|NULL
condition|;
name|vs
operator|=
name|vs
operator|->
name|next
control|)
block|{
name|struct
name|bindata
modifier|*
name|vssd
decl_stmt|;
name|unsigned
name|long
name|vsslen
decl_stmt|;
name|hold
operator|=
name|length
expr_stmt|;
name|dword_align_bin
argument_list|(
operator|&
name|pp
argument_list|,
operator|&
name|length
argument_list|)
expr_stmt|;
name|vilen
operator|+=
name|length
operator|-
name|hold
expr_stmt|;
name|vslen
operator|+=
name|length
operator|-
name|hold
expr_stmt|;
name|vssd
operator|=
operator|(
expr|struct
name|bindata
operator|*
operator|)
name|reswr_alloc
argument_list|(
sizeof|sizeof
expr|*
name|vssd
argument_list|)
expr_stmt|;
name|vssd
operator|->
name|length
operator|=
literal|6
expr_stmt|;
name|vssd
operator|->
name|data
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|reswr_alloc
argument_list|(
literal|6
argument_list|)
expr_stmt|;
name|length
operator|+=
literal|6
expr_stmt|;
name|vilen
operator|+=
literal|6
expr_stmt|;
name|vslen
operator|+=
literal|6
expr_stmt|;
name|vsslen
operator|=
literal|6
expr_stmt|;
name|put_16
argument_list|(
name|big_endian
argument_list|,
literal|1
argument_list|,
name|vssd
operator|->
name|data
operator|+
literal|4
argument_list|)
expr_stmt|;
operator|*
name|pp
operator|=
name|vssd
expr_stmt|;
name|pp
operator|=
operator|&
name|vssd
operator|->
name|next
expr_stmt|;
operator|*
name|pp
operator|=
name|unicode_to_bin
argument_list|(
name|vs
operator|->
name|key
argument_list|,
name|big_endian
argument_list|)
expr_stmt|;
name|length
operator|+=
operator|(
operator|*
name|pp
operator|)
operator|->
name|length
expr_stmt|;
name|vilen
operator|+=
operator|(
operator|*
name|pp
operator|)
operator|->
name|length
expr_stmt|;
name|vslen
operator|+=
operator|(
operator|*
name|pp
operator|)
operator|->
name|length
expr_stmt|;
name|vsslen
operator|+=
operator|(
operator|*
name|pp
operator|)
operator|->
name|length
expr_stmt|;
name|pp
operator|=
operator|&
operator|(
operator|*
name|pp
operator|)
operator|->
name|next
expr_stmt|;
name|hold
operator|=
name|length
expr_stmt|;
name|dword_align_bin
argument_list|(
operator|&
name|pp
argument_list|,
operator|&
name|length
argument_list|)
expr_stmt|;
name|vilen
operator|+=
name|length
operator|-
name|hold
expr_stmt|;
name|vslen
operator|+=
name|length
operator|-
name|hold
expr_stmt|;
name|vsslen
operator|+=
name|length
operator|-
name|hold
expr_stmt|;
operator|*
name|pp
operator|=
name|unicode_to_bin
argument_list|(
name|vs
operator|->
name|value
argument_list|,
name|big_endian
argument_list|)
expr_stmt|;
name|put_16
argument_list|(
name|big_endian
argument_list|,
operator|(
operator|*
name|pp
operator|)
operator|->
name|length
operator|/
literal|2
argument_list|,
name|vssd
operator|->
name|data
operator|+
literal|2
argument_list|)
expr_stmt|;
name|length
operator|+=
operator|(
operator|*
name|pp
operator|)
operator|->
name|length
expr_stmt|;
name|vilen
operator|+=
operator|(
operator|*
name|pp
operator|)
operator|->
name|length
expr_stmt|;
name|vslen
operator|+=
operator|(
operator|*
name|pp
operator|)
operator|->
name|length
expr_stmt|;
name|vsslen
operator|+=
operator|(
operator|*
name|pp
operator|)
operator|->
name|length
expr_stmt|;
name|pp
operator|=
operator|&
operator|(
operator|*
name|pp
operator|)
operator|->
name|next
expr_stmt|;
name|put_16
argument_list|(
name|big_endian
argument_list|,
name|vsslen
argument_list|,
name|vssd
operator|->
name|data
argument_list|)
expr_stmt|;
block|}
name|put_16
argument_list|(
name|big_endian
argument_list|,
name|vslen
argument_list|,
name|vsd
operator|->
name|data
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|VERINFO_VAR
case|:
block|{
name|unsigned
name|long
name|hold
decl_stmt|,
name|vvlen
decl_stmt|,
name|vvvlen
decl_stmt|;
name|struct
name|bindata
modifier|*
name|vvd
decl_stmt|;
specifier|const
name|struct
name|ver_varinfo
modifier|*
name|vv
decl_stmt|;
operator|*
name|pp
operator|=
name|string_to_unicode_bin
argument_list|(
literal|"VarFileInfo"
argument_list|,
name|big_endian
argument_list|)
expr_stmt|;
name|length
operator|+=
operator|(
operator|*
name|pp
operator|)
operator|->
name|length
expr_stmt|;
name|vilen
operator|+=
operator|(
operator|*
name|pp
operator|)
operator|->
name|length
expr_stmt|;
name|pp
operator|=
operator|&
operator|(
operator|*
name|pp
operator|)
operator|->
name|next
expr_stmt|;
name|hold
operator|=
name|length
expr_stmt|;
name|dword_align_bin
argument_list|(
operator|&
name|pp
argument_list|,
operator|&
name|length
argument_list|)
expr_stmt|;
name|vilen
operator|+=
name|length
operator|-
name|hold
expr_stmt|;
name|vvd
operator|=
operator|(
expr|struct
name|bindata
operator|*
operator|)
name|reswr_alloc
argument_list|(
sizeof|sizeof
expr|*
name|vvd
argument_list|)
expr_stmt|;
name|vvd
operator|->
name|length
operator|=
literal|6
expr_stmt|;
name|vvd
operator|->
name|data
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|reswr_alloc
argument_list|(
literal|6
argument_list|)
expr_stmt|;
name|length
operator|+=
literal|6
expr_stmt|;
name|vilen
operator|+=
literal|6
expr_stmt|;
name|vvlen
operator|=
literal|6
expr_stmt|;
name|put_16
argument_list|(
name|big_endian
argument_list|,
literal|0
argument_list|,
name|vvd
operator|->
name|data
operator|+
literal|4
argument_list|)
expr_stmt|;
operator|*
name|pp
operator|=
name|vvd
expr_stmt|;
name|pp
operator|=
operator|&
name|vvd
operator|->
name|next
expr_stmt|;
operator|*
name|pp
operator|=
name|unicode_to_bin
argument_list|(
name|vi
operator|->
name|u
operator|.
name|var
operator|.
name|key
argument_list|,
name|big_endian
argument_list|)
expr_stmt|;
name|length
operator|+=
operator|(
operator|*
name|pp
operator|)
operator|->
name|length
expr_stmt|;
name|vilen
operator|+=
operator|(
operator|*
name|pp
operator|)
operator|->
name|length
expr_stmt|;
name|vvlen
operator|+=
operator|(
operator|*
name|pp
operator|)
operator|->
name|length
expr_stmt|;
name|pp
operator|=
operator|&
operator|(
operator|*
name|pp
operator|)
operator|->
name|next
expr_stmt|;
name|hold
operator|=
name|length
expr_stmt|;
name|dword_align_bin
argument_list|(
operator|&
name|pp
argument_list|,
operator|&
name|length
argument_list|)
expr_stmt|;
name|vilen
operator|+=
name|length
operator|-
name|hold
expr_stmt|;
name|vvlen
operator|+=
name|length
operator|-
name|hold
expr_stmt|;
name|vvvlen
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|vv
operator|=
name|vi
operator|->
name|u
operator|.
name|var
operator|.
name|var
init|;
name|vv
operator|!=
name|NULL
condition|;
name|vv
operator|=
name|vv
operator|->
name|next
control|)
block|{
name|struct
name|bindata
modifier|*
name|vvsd
decl_stmt|;
name|vvsd
operator|=
operator|(
expr|struct
name|bindata
operator|*
operator|)
name|reswr_alloc
argument_list|(
sizeof|sizeof
expr|*
name|vvsd
argument_list|)
expr_stmt|;
name|vvsd
operator|->
name|length
operator|=
literal|4
expr_stmt|;
name|vvsd
operator|->
name|data
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|reswr_alloc
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|length
operator|+=
literal|4
expr_stmt|;
name|vilen
operator|+=
literal|4
expr_stmt|;
name|vvlen
operator|+=
literal|4
expr_stmt|;
name|vvvlen
operator|+=
literal|4
expr_stmt|;
name|put_16
argument_list|(
name|big_endian
argument_list|,
name|vv
operator|->
name|language
argument_list|,
name|vvsd
operator|->
name|data
argument_list|)
expr_stmt|;
name|put_16
argument_list|(
name|big_endian
argument_list|,
name|vv
operator|->
name|charset
argument_list|,
name|vvsd
operator|->
name|data
operator|+
literal|2
argument_list|)
expr_stmt|;
name|vvsd
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
operator|*
name|pp
operator|=
name|vvsd
expr_stmt|;
name|pp
operator|=
operator|&
name|vvsd
operator|->
name|next
expr_stmt|;
block|}
name|put_16
argument_list|(
name|big_endian
argument_list|,
name|vvlen
argument_list|,
name|vvd
operator|->
name|data
argument_list|)
expr_stmt|;
name|put_16
argument_list|(
name|big_endian
argument_list|,
name|vvvlen
argument_list|,
name|vvd
operator|->
name|data
operator|+
literal|2
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|put_16
argument_list|(
name|big_endian
argument_list|,
name|vilen
argument_list|,
name|vid
operator|->
name|data
argument_list|)
expr_stmt|;
block|}
name|put_16
argument_list|(
name|big_endian
argument_list|,
name|length
argument_list|,
name|first
operator|->
name|data
argument_list|)
expr_stmt|;
return|return
name|first
return|;
block|}
end_function

begin_comment
comment|/* Convert a generic resource to binary.  */
end_comment

begin_function
specifier|static
name|struct
name|bindata
modifier|*
name|res_to_bin_generic
parameter_list|(
name|length
parameter_list|,
name|data
parameter_list|)
name|unsigned
name|long
name|length
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|data
decl_stmt|;
block|{
name|struct
name|bindata
modifier|*
name|d
decl_stmt|;
name|d
operator|=
operator|(
expr|struct
name|bindata
operator|*
operator|)
name|reswr_alloc
argument_list|(
sizeof|sizeof
expr|*
name|d
argument_list|)
expr_stmt|;
name|d
operator|->
name|length
operator|=
name|length
expr_stmt|;
name|d
operator|->
name|data
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|data
expr_stmt|;
name|d
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
return|return
name|d
return|;
block|}
end_function

end_unit

