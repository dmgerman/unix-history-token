begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* rescoff.c -- read and write resources in Windows COFF files.    Copyright 1997, 1998, 1999, 2000 Free Software Foundation, Inc.    Written by Ian Lance Taylor, Cygnus Support.     This file is part of GNU Binutils.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA    02111-1307, USA.  */
end_comment

begin_comment
comment|/* This file contains function that read and write Windows resources    in COFF files.  */
end_comment

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"bucomm.h"
end_include

begin_include
include|#
directive|include
file|"libiberty.h"
end_include

begin_include
include|#
directive|include
file|"windres.h"
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_comment
comment|/* In order to use the address of a resource data entry, we need to    get the image base of the file.  Right now we extract it from    internal BFD information.  FIXME.  */
end_comment

begin_include
include|#
directive|include
file|"coff/internal.h"
end_include

begin_include
include|#
directive|include
file|"libcoff.h"
end_include

begin_comment
comment|/* Information we extract from the file.  */
end_comment

begin_struct
struct|struct
name|coff_file_info
block|{
comment|/* File name.  */
specifier|const
name|char
modifier|*
name|filename
decl_stmt|;
comment|/* Data read from the file.  */
specifier|const
name|bfd_byte
modifier|*
name|data
decl_stmt|;
comment|/* End of data read from file.  */
specifier|const
name|bfd_byte
modifier|*
name|data_end
decl_stmt|;
comment|/* Address of the resource section minus the image base of the file.  */
name|bfd_vma
name|secaddr
decl_stmt|;
comment|/* Non-zero if the file is big endian.  */
name|int
name|big_endian
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* A resource directory table in a COFF file.  */
end_comment

begin_struct
struct|struct
name|extern_res_directory
block|{
comment|/* Characteristics.  */
name|bfd_byte
name|characteristics
index|[
literal|4
index|]
decl_stmt|;
comment|/* Time stamp.  */
name|bfd_byte
name|time
index|[
literal|4
index|]
decl_stmt|;
comment|/* Major version number.  */
name|bfd_byte
name|major
index|[
literal|2
index|]
decl_stmt|;
comment|/* Minor version number.  */
name|bfd_byte
name|minor
index|[
literal|2
index|]
decl_stmt|;
comment|/* Number of named directory entries.  */
name|bfd_byte
name|name_count
index|[
literal|2
index|]
decl_stmt|;
comment|/* Number of directory entries with IDs.  */
name|bfd_byte
name|id_count
index|[
literal|2
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* A resource directory entry in a COFF file.  */
end_comment

begin_struct
struct|struct
name|extern_res_entry
block|{
comment|/* Name or ID.  */
name|bfd_byte
name|name
index|[
literal|4
index|]
decl_stmt|;
comment|/* Address of resource entry or subdirectory.  */
name|bfd_byte
name|rva
index|[
literal|4
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* A resource data entry in a COFF file.  */
end_comment

begin_struct
struct|struct
name|extern_res_data
block|{
comment|/* Address of resource data.  This is apparently a file relative      address, rather than a section offset.  */
name|bfd_byte
name|rva
index|[
literal|4
index|]
decl_stmt|;
comment|/* Size of resource data.  */
name|bfd_byte
name|size
index|[
literal|4
index|]
decl_stmt|;
comment|/* Code page.  */
name|bfd_byte
name|codepage
index|[
literal|4
index|]
decl_stmt|;
comment|/* Reserved.  */
name|bfd_byte
name|reserved
index|[
literal|4
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Macros to swap in values.  */
end_comment

begin_define
define|#
directive|define
name|getfi_16
parameter_list|(
name|fi
parameter_list|,
name|s
parameter_list|)
value|((fi)->big_endian ? bfd_getb16 (s) : bfd_getl16 (s))
end_define

begin_define
define|#
directive|define
name|getfi_32
parameter_list|(
name|fi
parameter_list|,
name|s
parameter_list|)
value|((fi)->big_endian ? bfd_getb32 (s) : bfd_getl32 (s))
end_define

begin_comment
comment|/* Local functions.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|overrun
name|PARAMS
argument_list|(
operator|(
specifier|const
expr|struct
name|coff_file_info
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|res_directory
modifier|*
name|read_coff_res_dir
name|PARAMS
argument_list|(
operator|(
specifier|const
name|bfd_byte
operator|*
operator|,
specifier|const
expr|struct
name|coff_file_info
operator|*
operator|,
specifier|const
expr|struct
name|res_id
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|res_resource
modifier|*
name|read_coff_data_entry
name|PARAMS
argument_list|(
operator|(
specifier|const
name|bfd_byte
operator|*
operator|,
specifier|const
expr|struct
name|coff_file_info
operator|*
operator|,
specifier|const
expr|struct
name|res_id
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Read the resources in a COFF file.  */
end_comment

begin_function
name|struct
name|res_directory
modifier|*
name|read_coff_rsrc
parameter_list|(
name|filename
parameter_list|,
name|target
parameter_list|)
specifier|const
name|char
modifier|*
name|filename
decl_stmt|;
specifier|const
name|char
modifier|*
name|target
decl_stmt|;
block|{
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|char
modifier|*
modifier|*
name|matching
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|bfd_size_type
name|size
decl_stmt|;
name|bfd_byte
modifier|*
name|data
decl_stmt|;
name|struct
name|coff_file_info
name|finfo
decl_stmt|;
if|if
condition|(
name|filename
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
name|_
argument_list|(
literal|"filename required for COFF input"
argument_list|)
argument_list|)
expr_stmt|;
name|abfd
operator|=
name|bfd_openr
argument_list|(
name|filename
argument_list|,
name|target
argument_list|)
expr_stmt|;
if|if
condition|(
name|abfd
operator|==
name|NULL
condition|)
name|bfd_fatal
argument_list|(
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_check_format_matches
argument_list|(
name|abfd
argument_list|,
name|bfd_object
argument_list|,
operator|&
name|matching
argument_list|)
condition|)
block|{
name|bfd_nonfatal
argument_list|(
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_get_error
argument_list|()
operator|==
name|bfd_error_file_ambiguously_recognized
condition|)
name|list_matching_formats
argument_list|(
name|matching
argument_list|)
expr_stmt|;
name|xexit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|sec
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".rsrc"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sec
operator|==
name|NULL
condition|)
block|{
name|fatal
argument_list|(
name|_
argument_list|(
literal|"%s: no resource section"
argument_list|)
argument_list|,
name|filename
argument_list|)
expr_stmt|;
block|}
name|size
operator|=
name|bfd_section_size
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
expr_stmt|;
name|data
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|res_alloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_get_section_contents
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|data
argument_list|,
literal|0
argument_list|,
name|size
argument_list|)
condition|)
name|bfd_fatal
argument_list|(
name|_
argument_list|(
literal|"can't read resource section"
argument_list|)
argument_list|)
expr_stmt|;
name|finfo
operator|.
name|filename
operator|=
name|filename
expr_stmt|;
name|finfo
operator|.
name|data
operator|=
name|data
expr_stmt|;
name|finfo
operator|.
name|data_end
operator|=
name|data
operator|+
name|size
expr_stmt|;
name|finfo
operator|.
name|secaddr
operator|=
operator|(
name|bfd_get_section_vma
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
operator|-
name|pe_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|pe_opthdr
operator|.
name|ImageBase
operator|)
expr_stmt|;
name|finfo
operator|.
name|big_endian
operator|=
name|bfd_big_endian
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|bfd_close
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
comment|/* Now just read in the top level resource directory.  Note that we      don't free data, since we create resource entries that point into      it.  If we ever want to free up the resource information we read,      this will have to be cleaned up.  */
return|return
name|read_coff_res_dir
argument_list|(
name|data
argument_list|,
operator|&
name|finfo
argument_list|,
operator|(
specifier|const
expr|struct
name|res_id
operator|*
operator|)
name|NULL
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Give an error if we are out of bounds.  */
end_comment

begin_function
specifier|static
name|void
name|overrun
parameter_list|(
name|finfo
parameter_list|,
name|msg
parameter_list|)
specifier|const
name|struct
name|coff_file_info
modifier|*
name|finfo
decl_stmt|;
specifier|const
name|char
modifier|*
name|msg
decl_stmt|;
block|{
name|fatal
argument_list|(
name|_
argument_list|(
literal|"%s: %s: address out of bounds"
argument_list|)
argument_list|,
name|finfo
operator|->
name|filename
argument_list|,
name|msg
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Read a resource directory.  */
end_comment

begin_function
specifier|static
name|struct
name|res_directory
modifier|*
name|read_coff_res_dir
parameter_list|(
name|data
parameter_list|,
name|finfo
parameter_list|,
name|type
parameter_list|,
name|level
parameter_list|)
specifier|const
name|bfd_byte
modifier|*
name|data
decl_stmt|;
specifier|const
name|struct
name|coff_file_info
modifier|*
name|finfo
decl_stmt|;
specifier|const
name|struct
name|res_id
modifier|*
name|type
decl_stmt|;
name|int
name|level
decl_stmt|;
block|{
specifier|const
name|struct
name|extern_res_directory
modifier|*
name|erd
decl_stmt|;
name|struct
name|res_directory
modifier|*
name|rd
decl_stmt|;
name|int
name|name_count
decl_stmt|,
name|id_count
decl_stmt|,
name|i
decl_stmt|;
name|struct
name|res_entry
modifier|*
modifier|*
name|pp
decl_stmt|;
specifier|const
name|struct
name|extern_res_entry
modifier|*
name|ere
decl_stmt|;
if|if
condition|(
call|(
name|size_t
call|)
argument_list|(
name|finfo
operator|->
name|data_end
operator|-
name|data
argument_list|)
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|extern_res_directory
argument_list|)
condition|)
name|overrun
argument_list|(
name|finfo
argument_list|,
name|_
argument_list|(
literal|"directory"
argument_list|)
argument_list|)
expr_stmt|;
name|erd
operator|=
operator|(
specifier|const
expr|struct
name|extern_res_directory
operator|*
operator|)
name|data
expr_stmt|;
name|rd
operator|=
operator|(
expr|struct
name|res_directory
operator|*
operator|)
name|res_alloc
argument_list|(
sizeof|sizeof
expr|*
name|rd
argument_list|)
expr_stmt|;
name|rd
operator|->
name|characteristics
operator|=
name|getfi_32
argument_list|(
name|finfo
argument_list|,
name|erd
operator|->
name|characteristics
argument_list|)
expr_stmt|;
name|rd
operator|->
name|time
operator|=
name|getfi_32
argument_list|(
name|finfo
argument_list|,
name|erd
operator|->
name|time
argument_list|)
expr_stmt|;
name|rd
operator|->
name|major
operator|=
name|getfi_16
argument_list|(
name|finfo
argument_list|,
name|erd
operator|->
name|major
argument_list|)
expr_stmt|;
name|rd
operator|->
name|minor
operator|=
name|getfi_16
argument_list|(
name|finfo
argument_list|,
name|erd
operator|->
name|minor
argument_list|)
expr_stmt|;
name|rd
operator|->
name|entries
operator|=
name|NULL
expr_stmt|;
name|name_count
operator|=
name|getfi_16
argument_list|(
name|finfo
argument_list|,
name|erd
operator|->
name|name_count
argument_list|)
expr_stmt|;
name|id_count
operator|=
name|getfi_16
argument_list|(
name|finfo
argument_list|,
name|erd
operator|->
name|id_count
argument_list|)
expr_stmt|;
name|pp
operator|=
operator|&
name|rd
operator|->
name|entries
expr_stmt|;
comment|/* The resource directory entries immediately follow the directory      table.  */
name|ere
operator|=
operator|(
specifier|const
expr|struct
name|extern_res_entry
operator|*
operator|)
operator|(
name|erd
operator|+
literal|1
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|name_count
condition|;
name|i
operator|++
operator|,
name|ere
operator|++
control|)
block|{
name|unsigned
name|long
name|name
decl_stmt|,
name|rva
decl_stmt|;
name|struct
name|res_entry
modifier|*
name|re
decl_stmt|;
specifier|const
name|bfd_byte
modifier|*
name|ers
decl_stmt|;
name|int
name|length
decl_stmt|,
name|j
decl_stmt|;
if|if
condition|(
operator|(
specifier|const
name|bfd_byte
operator|*
operator|)
name|ere
operator|>=
name|finfo
operator|->
name|data_end
condition|)
name|overrun
argument_list|(
name|finfo
argument_list|,
name|_
argument_list|(
literal|"named directory entry"
argument_list|)
argument_list|)
expr_stmt|;
name|name
operator|=
name|getfi_32
argument_list|(
name|finfo
argument_list|,
name|ere
operator|->
name|name
argument_list|)
expr_stmt|;
name|rva
operator|=
name|getfi_32
argument_list|(
name|finfo
argument_list|,
name|ere
operator|->
name|rva
argument_list|)
expr_stmt|;
comment|/* For some reason the high bit in NAME is set.  */
name|name
operator|&=
operator|~
literal|0x80000000
expr_stmt|;
if|if
condition|(
name|name
operator|>
call|(
name|size_t
call|)
argument_list|(
name|finfo
operator|->
name|data_end
operator|-
name|finfo
operator|->
name|data
argument_list|)
condition|)
name|overrun
argument_list|(
name|finfo
argument_list|,
name|_
argument_list|(
literal|"directory entry name"
argument_list|)
argument_list|)
expr_stmt|;
name|ers
operator|=
name|finfo
operator|->
name|data
operator|+
name|name
expr_stmt|;
name|re
operator|=
operator|(
expr|struct
name|res_entry
operator|*
operator|)
name|res_alloc
argument_list|(
sizeof|sizeof
expr|*
name|re
argument_list|)
expr_stmt|;
name|re
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|re
operator|->
name|id
operator|.
name|named
operator|=
literal|1
expr_stmt|;
name|length
operator|=
name|getfi_16
argument_list|(
name|finfo
argument_list|,
name|ers
argument_list|)
expr_stmt|;
name|re
operator|->
name|id
operator|.
name|u
operator|.
name|n
operator|.
name|length
operator|=
name|length
expr_stmt|;
name|re
operator|->
name|id
operator|.
name|u
operator|.
name|n
operator|.
name|name
operator|=
operator|(
name|unichar
operator|*
operator|)
name|res_alloc
argument_list|(
name|length
operator|*
sizeof|sizeof
argument_list|(
name|unichar
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|length
condition|;
name|j
operator|++
control|)
name|re
operator|->
name|id
operator|.
name|u
operator|.
name|n
operator|.
name|name
index|[
name|j
index|]
operator|=
name|getfi_16
argument_list|(
name|finfo
argument_list|,
name|ers
operator|+
name|j
operator|*
literal|2
operator|+
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|level
operator|==
literal|0
condition|)
name|type
operator|=
operator|&
name|re
operator|->
name|id
expr_stmt|;
if|if
condition|(
operator|(
name|rva
operator|&
literal|0x80000000
operator|)
operator|!=
literal|0
condition|)
block|{
name|rva
operator|&=
operator|~
literal|0x80000000
expr_stmt|;
if|if
condition|(
name|rva
operator|>=
call|(
name|size_t
call|)
argument_list|(
name|finfo
operator|->
name|data_end
operator|-
name|finfo
operator|->
name|data
argument_list|)
condition|)
name|overrun
argument_list|(
name|finfo
argument_list|,
name|_
argument_list|(
literal|"named subdirectory"
argument_list|)
argument_list|)
expr_stmt|;
name|re
operator|->
name|subdir
operator|=
literal|1
expr_stmt|;
name|re
operator|->
name|u
operator|.
name|dir
operator|=
name|read_coff_res_dir
argument_list|(
name|finfo
operator|->
name|data
operator|+
name|rva
argument_list|,
name|finfo
argument_list|,
name|type
argument_list|,
name|level
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|rva
operator|>=
call|(
name|size_t
call|)
argument_list|(
name|finfo
operator|->
name|data_end
operator|-
name|finfo
operator|->
name|data
argument_list|)
condition|)
name|overrun
argument_list|(
name|finfo
argument_list|,
name|_
argument_list|(
literal|"named resource"
argument_list|)
argument_list|)
expr_stmt|;
name|re
operator|->
name|subdir
operator|=
literal|0
expr_stmt|;
name|re
operator|->
name|u
operator|.
name|res
operator|=
name|read_coff_data_entry
argument_list|(
name|finfo
operator|->
name|data
operator|+
name|rva
argument_list|,
name|finfo
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
operator|*
name|pp
operator|=
name|re
expr_stmt|;
name|pp
operator|=
operator|&
name|re
operator|->
name|next
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|id_count
condition|;
name|i
operator|++
operator|,
name|ere
operator|++
control|)
block|{
name|unsigned
name|long
name|name
decl_stmt|,
name|rva
decl_stmt|;
name|struct
name|res_entry
modifier|*
name|re
decl_stmt|;
if|if
condition|(
operator|(
specifier|const
name|bfd_byte
operator|*
operator|)
name|ere
operator|>=
name|finfo
operator|->
name|data_end
condition|)
name|overrun
argument_list|(
name|finfo
argument_list|,
name|_
argument_list|(
literal|"ID directory entry"
argument_list|)
argument_list|)
expr_stmt|;
name|name
operator|=
name|getfi_32
argument_list|(
name|finfo
argument_list|,
name|ere
operator|->
name|name
argument_list|)
expr_stmt|;
name|rva
operator|=
name|getfi_32
argument_list|(
name|finfo
argument_list|,
name|ere
operator|->
name|rva
argument_list|)
expr_stmt|;
name|re
operator|=
operator|(
expr|struct
name|res_entry
operator|*
operator|)
name|res_alloc
argument_list|(
sizeof|sizeof
expr|*
name|re
argument_list|)
expr_stmt|;
name|re
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|re
operator|->
name|id
operator|.
name|named
operator|=
literal|0
expr_stmt|;
name|re
operator|->
name|id
operator|.
name|u
operator|.
name|id
operator|=
name|name
expr_stmt|;
if|if
condition|(
name|level
operator|==
literal|0
condition|)
name|type
operator|=
operator|&
name|re
operator|->
name|id
expr_stmt|;
if|if
condition|(
operator|(
name|rva
operator|&
literal|0x80000000
operator|)
operator|!=
literal|0
condition|)
block|{
name|rva
operator|&=
operator|~
literal|0x80000000
expr_stmt|;
if|if
condition|(
name|rva
operator|>=
call|(
name|size_t
call|)
argument_list|(
name|finfo
operator|->
name|data_end
operator|-
name|finfo
operator|->
name|data
argument_list|)
condition|)
name|overrun
argument_list|(
name|finfo
argument_list|,
name|_
argument_list|(
literal|"ID subdirectory"
argument_list|)
argument_list|)
expr_stmt|;
name|re
operator|->
name|subdir
operator|=
literal|1
expr_stmt|;
name|re
operator|->
name|u
operator|.
name|dir
operator|=
name|read_coff_res_dir
argument_list|(
name|finfo
operator|->
name|data
operator|+
name|rva
argument_list|,
name|finfo
argument_list|,
name|type
argument_list|,
name|level
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|rva
operator|>=
call|(
name|size_t
call|)
argument_list|(
name|finfo
operator|->
name|data_end
operator|-
name|finfo
operator|->
name|data
argument_list|)
condition|)
name|overrun
argument_list|(
name|finfo
argument_list|,
name|_
argument_list|(
literal|"ID resource"
argument_list|)
argument_list|)
expr_stmt|;
name|re
operator|->
name|subdir
operator|=
literal|0
expr_stmt|;
name|re
operator|->
name|u
operator|.
name|res
operator|=
name|read_coff_data_entry
argument_list|(
name|finfo
operator|->
name|data
operator|+
name|rva
argument_list|,
name|finfo
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
operator|*
name|pp
operator|=
name|re
expr_stmt|;
name|pp
operator|=
operator|&
name|re
operator|->
name|next
expr_stmt|;
block|}
return|return
name|rd
return|;
block|}
end_function

begin_comment
comment|/* Read a resource data entry.  */
end_comment

begin_function
specifier|static
name|struct
name|res_resource
modifier|*
name|read_coff_data_entry
parameter_list|(
name|data
parameter_list|,
name|finfo
parameter_list|,
name|type
parameter_list|)
specifier|const
name|bfd_byte
modifier|*
name|data
decl_stmt|;
specifier|const
name|struct
name|coff_file_info
modifier|*
name|finfo
decl_stmt|;
specifier|const
name|struct
name|res_id
modifier|*
name|type
decl_stmt|;
block|{
specifier|const
name|struct
name|extern_res_data
modifier|*
name|erd
decl_stmt|;
name|struct
name|res_resource
modifier|*
name|r
decl_stmt|;
name|unsigned
name|long
name|size
decl_stmt|,
name|rva
decl_stmt|;
specifier|const
name|bfd_byte
modifier|*
name|resdata
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
name|_
argument_list|(
literal|"resource type unknown"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
call|(
name|size_t
call|)
argument_list|(
name|finfo
operator|->
name|data_end
operator|-
name|data
argument_list|)
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|extern_res_data
argument_list|)
condition|)
name|overrun
argument_list|(
name|finfo
argument_list|,
name|_
argument_list|(
literal|"data entry"
argument_list|)
argument_list|)
expr_stmt|;
name|erd
operator|=
operator|(
specifier|const
expr|struct
name|extern_res_data
operator|*
operator|)
name|data
expr_stmt|;
name|size
operator|=
name|getfi_32
argument_list|(
name|finfo
argument_list|,
name|erd
operator|->
name|size
argument_list|)
expr_stmt|;
name|rva
operator|=
name|getfi_32
argument_list|(
name|finfo
argument_list|,
name|erd
operator|->
name|rva
argument_list|)
expr_stmt|;
if|if
condition|(
name|rva
operator|<
name|finfo
operator|->
name|secaddr
operator|||
name|rva
operator|-
name|finfo
operator|->
name|secaddr
operator|>=
call|(
name|size_t
call|)
argument_list|(
name|finfo
operator|->
name|data_end
operator|-
name|finfo
operator|->
name|data
argument_list|)
condition|)
name|overrun
argument_list|(
name|finfo
argument_list|,
name|_
argument_list|(
literal|"resource data"
argument_list|)
argument_list|)
expr_stmt|;
name|resdata
operator|=
name|finfo
operator|->
name|data
operator|+
operator|(
name|rva
operator|-
name|finfo
operator|->
name|secaddr
operator|)
expr_stmt|;
if|if
condition|(
name|size
operator|>
call|(
name|size_t
call|)
argument_list|(
name|finfo
operator|->
name|data_end
operator|-
name|resdata
argument_list|)
condition|)
name|overrun
argument_list|(
name|finfo
argument_list|,
name|_
argument_list|(
literal|"resource data size"
argument_list|)
argument_list|)
expr_stmt|;
name|r
operator|=
name|bin_to_res
argument_list|(
operator|*
name|type
argument_list|,
name|resdata
argument_list|,
name|size
argument_list|,
name|finfo
operator|->
name|big_endian
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|r
operator|->
name|res_info
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|res_res_info
argument_list|)
argument_list|)
expr_stmt|;
name|r
operator|->
name|coff_info
operator|.
name|codepage
operator|=
name|getfi_32
argument_list|(
name|finfo
argument_list|,
name|erd
operator|->
name|codepage
argument_list|)
expr_stmt|;
name|r
operator|->
name|coff_info
operator|.
name|reserved
operator|=
name|getfi_32
argument_list|(
name|finfo
argument_list|,
name|erd
operator|->
name|reserved
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This structure is used to build a list of bindata structures.  */
end_comment

begin_struct
struct|struct
name|bindata_build
block|{
comment|/* The data.  */
name|struct
name|bindata
modifier|*
name|d
decl_stmt|;
comment|/* The last structure we have added to the list.  */
name|struct
name|bindata
modifier|*
name|last
decl_stmt|;
comment|/* The size of the list as a whole.  */
name|unsigned
name|long
name|length
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* This structure keeps track of information as we build the directory    tree.  */
end_comment

begin_struct
struct|struct
name|coff_write_info
block|{
comment|/* These fields are based on the BFD.  */
comment|/* The BFD itself.  */
name|bfd
modifier|*
name|abfd
decl_stmt|;
comment|/* Non-zero if the file is big endian.  */
name|int
name|big_endian
decl_stmt|;
comment|/* Pointer to section symbol used to build RVA relocs.  */
name|asymbol
modifier|*
modifier|*
name|sympp
decl_stmt|;
comment|/* These fields are computed initially, and then not changed.  */
comment|/* Length of directory tables and entries.  */
name|unsigned
name|long
name|dirsize
decl_stmt|;
comment|/* Length of directory entry strings.  */
name|unsigned
name|long
name|dirstrsize
decl_stmt|;
comment|/* Length of resource data entries.  */
name|unsigned
name|long
name|dataentsize
decl_stmt|;
comment|/* These fields are updated as we add data.  */
comment|/* Directory tables and entries.  */
name|struct
name|bindata_build
name|dirs
decl_stmt|;
comment|/* Directory entry strings.  */
name|struct
name|bindata_build
name|dirstrs
decl_stmt|;
comment|/* Resource data entries.  */
name|struct
name|bindata_build
name|dataents
decl_stmt|;
comment|/* Actual resource data.  */
name|struct
name|bindata_build
name|resources
decl_stmt|;
comment|/* Relocations.  */
name|arelent
modifier|*
modifier|*
name|relocs
decl_stmt|;
comment|/* Number of relocations.  */
name|unsigned
name|int
name|reloc_count
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Macros to swap out values.  */
end_comment

begin_define
define|#
directive|define
name|putcwi_16
parameter_list|(
name|cwi
parameter_list|,
name|v
parameter_list|,
name|s
parameter_list|)
define|\
value|((cwi->big_endian) ? bfd_putb16 ((v), (s)) : bfd_putl16 ((v), (s)))
end_define

begin_define
define|#
directive|define
name|putcwi_32
parameter_list|(
name|cwi
parameter_list|,
name|v
parameter_list|,
name|s
parameter_list|)
define|\
value|((cwi->big_endian) ? bfd_putb32 ((v), (s)) : bfd_putl32 ((v), (s)))
end_define

begin_decl_stmt
specifier|static
name|void
name|coff_bin_sizes
name|PARAMS
argument_list|(
operator|(
specifier|const
expr|struct
name|res_directory
operator|*
operator|,
expr|struct
name|coff_write_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|char
modifier|*
name|coff_alloc
name|PARAMS
argument_list|(
operator|(
expr|struct
name|bindata_build
operator|*
operator|,
name|size_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|coff_to_bin
name|PARAMS
argument_list|(
operator|(
specifier|const
expr|struct
name|res_directory
operator|*
operator|,
expr|struct
name|coff_write_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|coff_res_to_bin
name|PARAMS
argument_list|(
operator|(
specifier|const
expr|struct
name|res_resource
operator|*
operator|,
expr|struct
name|coff_write_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Write resources to a COFF file.  RESOURCES should already be    sorted.     Right now we always create a new file.  Someday we should also    offer the ability to merge resources into an existing file.  This    would require doing the basic work of objcopy, just modifying or    adding the .rsrc section.  */
end_comment

begin_function
name|void
name|write_coff_file
parameter_list|(
name|filename
parameter_list|,
name|target
parameter_list|,
name|resources
parameter_list|)
specifier|const
name|char
modifier|*
name|filename
decl_stmt|;
specifier|const
name|char
modifier|*
name|target
decl_stmt|;
specifier|const
name|struct
name|res_directory
modifier|*
name|resources
decl_stmt|;
block|{
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|struct
name|coff_write_info
name|cwi
decl_stmt|;
name|struct
name|bindata
modifier|*
name|d
decl_stmt|;
name|unsigned
name|long
name|length
decl_stmt|,
name|offset
decl_stmt|;
if|if
condition|(
name|filename
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
name|_
argument_list|(
literal|"filename required for COFF output"
argument_list|)
argument_list|)
expr_stmt|;
name|abfd
operator|=
name|bfd_openw
argument_list|(
name|filename
argument_list|,
name|target
argument_list|)
expr_stmt|;
if|if
condition|(
name|abfd
operator|==
name|NULL
condition|)
name|bfd_fatal
argument_list|(
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_set_format
argument_list|(
name|abfd
argument_list|,
name|bfd_object
argument_list|)
condition|)
name|bfd_fatal
argument_list|(
literal|"bfd_set_format"
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
name|DLLTOOL_SH
if|if
condition|(
operator|!
name|bfd_set_arch_mach
argument_list|(
name|abfd
argument_list|,
name|bfd_arch_sh
argument_list|,
literal|0
argument_list|)
condition|)
name|bfd_fatal
argument_list|(
literal|"bfd_set_arch_mach(sh)"
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|defined
name|DLLTOOL_MIPS
if|if
condition|(
operator|!
name|bfd_set_arch_mach
argument_list|(
name|abfd
argument_list|,
name|bfd_arch_mips
argument_list|,
literal|0
argument_list|)
condition|)
name|bfd_fatal
argument_list|(
literal|"bfd_set_arch_mach(mips)"
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|defined
name|DLLTOOL_ARM
if|if
condition|(
operator|!
name|bfd_set_arch_mach
argument_list|(
name|abfd
argument_list|,
name|bfd_arch_arm
argument_list|,
literal|0
argument_list|)
condition|)
name|bfd_fatal
argument_list|(
literal|"bfd_set_arch_mach(arm)"
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* FIXME: This is obviously i386 specific.  */
if|if
condition|(
operator|!
name|bfd_set_arch_mach
argument_list|(
name|abfd
argument_list|,
name|bfd_arch_i386
argument_list|,
literal|0
argument_list|)
condition|)
name|bfd_fatal
argument_list|(
literal|"bfd_set_arch_mach(i386)"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|bfd_set_file_flags
argument_list|(
name|abfd
argument_list|,
name|HAS_SYMS
operator||
name|HAS_RELOC
argument_list|)
condition|)
name|bfd_fatal
argument_list|(
literal|"bfd_set_file_flags"
argument_list|)
expr_stmt|;
name|sec
operator|=
name|bfd_make_section
argument_list|(
name|abfd
argument_list|,
literal|".rsrc"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sec
operator|==
name|NULL
condition|)
name|bfd_fatal
argument_list|(
literal|"bfd_make_section"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_set_section_flags
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
operator|(
name|SEC_HAS_CONTENTS
operator||
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_DATA
operator|)
argument_list|)
condition|)
name|bfd_fatal
argument_list|(
literal|"bfd_set_section_flags"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_set_symtab
argument_list|(
name|abfd
argument_list|,
name|sec
operator|->
name|symbol_ptr_ptr
argument_list|,
literal|1
argument_list|)
condition|)
name|bfd_fatal
argument_list|(
literal|"bfd_set_symtab"
argument_list|)
expr_stmt|;
comment|/* Requiring this is probably a bug in BFD.  */
name|sec
operator|->
name|output_section
operator|=
name|sec
expr_stmt|;
comment|/* The order of data in the .rsrc section is        resource directory tables and entries        resource directory strings        resource data entries        actual resource data       We build these different types of data in different lists.  */
name|cwi
operator|.
name|abfd
operator|=
name|abfd
expr_stmt|;
name|cwi
operator|.
name|big_endian
operator|=
name|bfd_big_endian
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|cwi
operator|.
name|sympp
operator|=
name|sec
operator|->
name|symbol_ptr_ptr
expr_stmt|;
name|cwi
operator|.
name|dirsize
operator|=
literal|0
expr_stmt|;
name|cwi
operator|.
name|dirstrsize
operator|=
literal|0
expr_stmt|;
name|cwi
operator|.
name|dataentsize
operator|=
literal|0
expr_stmt|;
name|cwi
operator|.
name|dirs
operator|.
name|d
operator|=
name|NULL
expr_stmt|;
name|cwi
operator|.
name|dirs
operator|.
name|last
operator|=
name|NULL
expr_stmt|;
name|cwi
operator|.
name|dirs
operator|.
name|length
operator|=
literal|0
expr_stmt|;
name|cwi
operator|.
name|dirstrs
operator|.
name|d
operator|=
name|NULL
expr_stmt|;
name|cwi
operator|.
name|dirstrs
operator|.
name|last
operator|=
name|NULL
expr_stmt|;
name|cwi
operator|.
name|dirstrs
operator|.
name|length
operator|=
literal|0
expr_stmt|;
name|cwi
operator|.
name|dataents
operator|.
name|d
operator|=
name|NULL
expr_stmt|;
name|cwi
operator|.
name|dataents
operator|.
name|last
operator|=
name|NULL
expr_stmt|;
name|cwi
operator|.
name|dataents
operator|.
name|length
operator|=
literal|0
expr_stmt|;
name|cwi
operator|.
name|resources
operator|.
name|d
operator|=
name|NULL
expr_stmt|;
name|cwi
operator|.
name|resources
operator|.
name|last
operator|=
name|NULL
expr_stmt|;
name|cwi
operator|.
name|resources
operator|.
name|length
operator|=
literal|0
expr_stmt|;
name|cwi
operator|.
name|relocs
operator|=
name|NULL
expr_stmt|;
name|cwi
operator|.
name|reloc_count
operator|=
literal|0
expr_stmt|;
comment|/* Work out the sizes of the resource directory entries, so that we      know the various offsets we will need.  */
name|coff_bin_sizes
argument_list|(
name|resources
argument_list|,
operator|&
name|cwi
argument_list|)
expr_stmt|;
comment|/* Force the directory strings to be 32 bit aligned.  Every other      structure is 32 bit aligned anyhow.  */
name|cwi
operator|.
name|dirstrsize
operator|=
operator|(
name|cwi
operator|.
name|dirstrsize
operator|+
literal|3
operator|)
operator|&
operator|~
literal|3
expr_stmt|;
comment|/* Actually convert the resources to binary.  */
name|coff_to_bin
argument_list|(
name|resources
argument_list|,
operator|&
name|cwi
argument_list|)
expr_stmt|;
comment|/* Add another 2 bytes to the directory strings if needed for      alignment.  */
if|if
condition|(
operator|(
name|cwi
operator|.
name|dirstrs
operator|.
name|length
operator|&
literal|3
operator|)
operator|!=
literal|0
condition|)
block|{
name|unsigned
name|char
modifier|*
name|ex
decl_stmt|;
name|ex
operator|=
name|coff_alloc
argument_list|(
operator|&
name|cwi
operator|.
name|dirstrs
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|ex
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|ex
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Make sure that the data we built came out to the same size as we      calculated initially.  */
name|assert
argument_list|(
name|cwi
operator|.
name|dirs
operator|.
name|length
operator|==
name|cwi
operator|.
name|dirsize
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|cwi
operator|.
name|dirstrs
operator|.
name|length
operator|==
name|cwi
operator|.
name|dirstrsize
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|cwi
operator|.
name|dataents
operator|.
name|length
operator|==
name|cwi
operator|.
name|dataentsize
argument_list|)
expr_stmt|;
name|length
operator|=
operator|(
name|cwi
operator|.
name|dirsize
operator|+
name|cwi
operator|.
name|dirstrsize
operator|+
name|cwi
operator|.
name|dataentsize
operator|+
name|cwi
operator|.
name|resources
operator|.
name|length
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_set_section_size
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|length
argument_list|)
condition|)
name|bfd_fatal
argument_list|(
literal|"bfd_set_section_size"
argument_list|)
expr_stmt|;
name|bfd_set_reloc
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|cwi
operator|.
name|relocs
argument_list|,
name|cwi
operator|.
name|reloc_count
argument_list|)
expr_stmt|;
name|offset
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|d
operator|=
name|cwi
operator|.
name|dirs
operator|.
name|d
init|;
name|d
operator|!=
name|NULL
condition|;
name|d
operator|=
name|d
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|!
name|bfd_set_section_contents
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|d
operator|->
name|data
argument_list|,
name|offset
argument_list|,
name|d
operator|->
name|length
argument_list|)
condition|)
name|bfd_fatal
argument_list|(
literal|"bfd_set_section_contents"
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|d
operator|->
name|length
expr_stmt|;
block|}
for|for
control|(
name|d
operator|=
name|cwi
operator|.
name|dirstrs
operator|.
name|d
init|;
name|d
operator|!=
name|NULL
condition|;
name|d
operator|=
name|d
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|!
name|bfd_set_section_contents
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|d
operator|->
name|data
argument_list|,
name|offset
argument_list|,
name|d
operator|->
name|length
argument_list|)
condition|)
name|bfd_fatal
argument_list|(
literal|"bfd_set_section_contents"
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|d
operator|->
name|length
expr_stmt|;
block|}
for|for
control|(
name|d
operator|=
name|cwi
operator|.
name|dataents
operator|.
name|d
init|;
name|d
operator|!=
name|NULL
condition|;
name|d
operator|=
name|d
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|!
name|bfd_set_section_contents
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|d
operator|->
name|data
argument_list|,
name|offset
argument_list|,
name|d
operator|->
name|length
argument_list|)
condition|)
name|bfd_fatal
argument_list|(
literal|"bfd_set_section_contents"
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|d
operator|->
name|length
expr_stmt|;
block|}
for|for
control|(
name|d
operator|=
name|cwi
operator|.
name|resources
operator|.
name|d
init|;
name|d
operator|!=
name|NULL
condition|;
name|d
operator|=
name|d
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|!
name|bfd_set_section_contents
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|d
operator|->
name|data
argument_list|,
name|offset
argument_list|,
name|d
operator|->
name|length
argument_list|)
condition|)
name|bfd_fatal
argument_list|(
literal|"bfd_set_section_contents"
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|d
operator|->
name|length
expr_stmt|;
block|}
name|assert
argument_list|(
name|offset
operator|==
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_close
argument_list|(
name|abfd
argument_list|)
condition|)
name|bfd_fatal
argument_list|(
literal|"bfd_close"
argument_list|)
expr_stmt|;
comment|/* We allocated the relocs array using malloc.  */
name|free
argument_list|(
name|cwi
operator|.
name|relocs
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Work out the sizes of the various fixed size resource directory    entries.  This updates fields in CWI.  */
end_comment

begin_function
specifier|static
name|void
name|coff_bin_sizes
parameter_list|(
name|resdir
parameter_list|,
name|cwi
parameter_list|)
specifier|const
name|struct
name|res_directory
modifier|*
name|resdir
decl_stmt|;
name|struct
name|coff_write_info
modifier|*
name|cwi
decl_stmt|;
block|{
specifier|const
name|struct
name|res_entry
modifier|*
name|re
decl_stmt|;
name|cwi
operator|->
name|dirsize
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|extern_res_directory
argument_list|)
expr_stmt|;
for|for
control|(
name|re
operator|=
name|resdir
operator|->
name|entries
init|;
name|re
operator|!=
name|NULL
condition|;
name|re
operator|=
name|re
operator|->
name|next
control|)
block|{
name|cwi
operator|->
name|dirsize
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|extern_res_entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|re
operator|->
name|id
operator|.
name|named
condition|)
name|cwi
operator|->
name|dirstrsize
operator|+=
name|re
operator|->
name|id
operator|.
name|u
operator|.
name|n
operator|.
name|length
operator|*
literal|2
operator|+
literal|2
expr_stmt|;
if|if
condition|(
name|re
operator|->
name|subdir
condition|)
name|coff_bin_sizes
argument_list|(
name|re
operator|->
name|u
operator|.
name|dir
argument_list|,
name|cwi
argument_list|)
expr_stmt|;
else|else
name|cwi
operator|->
name|dataentsize
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|extern_res_data
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Allocate data for a particular list.  */
end_comment

begin_function
specifier|static
name|unsigned
name|char
modifier|*
name|coff_alloc
parameter_list|(
name|bb
parameter_list|,
name|size
parameter_list|)
name|struct
name|bindata_build
modifier|*
name|bb
decl_stmt|;
name|size_t
name|size
decl_stmt|;
block|{
name|struct
name|bindata
modifier|*
name|d
decl_stmt|;
name|d
operator|=
operator|(
expr|struct
name|bindata
operator|*
operator|)
name|reswr_alloc
argument_list|(
sizeof|sizeof
expr|*
name|d
argument_list|)
expr_stmt|;
name|d
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|d
operator|->
name|data
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|reswr_alloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|d
operator|->
name|length
operator|=
name|size
expr_stmt|;
if|if
condition|(
name|bb
operator|->
name|d
operator|==
name|NULL
condition|)
name|bb
operator|->
name|d
operator|=
name|d
expr_stmt|;
else|else
name|bb
operator|->
name|last
operator|->
name|next
operator|=
name|d
expr_stmt|;
name|bb
operator|->
name|last
operator|=
name|d
expr_stmt|;
name|bb
operator|->
name|length
operator|+=
name|size
expr_stmt|;
return|return
name|d
operator|->
name|data
return|;
block|}
end_function

begin_comment
comment|/* Convert the resource directory RESDIR to binary.  */
end_comment

begin_function
specifier|static
name|void
name|coff_to_bin
parameter_list|(
name|resdir
parameter_list|,
name|cwi
parameter_list|)
specifier|const
name|struct
name|res_directory
modifier|*
name|resdir
decl_stmt|;
name|struct
name|coff_write_info
modifier|*
name|cwi
decl_stmt|;
block|{
name|struct
name|extern_res_directory
modifier|*
name|erd
decl_stmt|;
name|int
name|ci
decl_stmt|,
name|cn
decl_stmt|;
specifier|const
name|struct
name|res_entry
modifier|*
name|e
decl_stmt|;
name|struct
name|extern_res_entry
modifier|*
name|ere
decl_stmt|;
comment|/* Write out the directory table.  */
name|erd
operator|=
operator|(
operator|(
expr|struct
name|extern_res_directory
operator|*
operator|)
name|coff_alloc
argument_list|(
operator|&
name|cwi
operator|->
name|dirs
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|erd
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|putcwi_32
argument_list|(
name|cwi
argument_list|,
name|resdir
operator|->
name|characteristics
argument_list|,
name|erd
operator|->
name|characteristics
argument_list|)
expr_stmt|;
name|putcwi_32
argument_list|(
name|cwi
argument_list|,
name|resdir
operator|->
name|time
argument_list|,
name|erd
operator|->
name|time
argument_list|)
expr_stmt|;
name|putcwi_16
argument_list|(
name|cwi
argument_list|,
name|resdir
operator|->
name|major
argument_list|,
name|erd
operator|->
name|major
argument_list|)
expr_stmt|;
name|putcwi_16
argument_list|(
name|cwi
argument_list|,
name|resdir
operator|->
name|minor
argument_list|,
name|erd
operator|->
name|minor
argument_list|)
expr_stmt|;
name|ci
operator|=
literal|0
expr_stmt|;
name|cn
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|e
operator|=
name|resdir
operator|->
name|entries
init|;
name|e
operator|!=
name|NULL
condition|;
name|e
operator|=
name|e
operator|->
name|next
control|)
block|{
if|if
condition|(
name|e
operator|->
name|id
operator|.
name|named
condition|)
operator|++
name|cn
expr_stmt|;
else|else
operator|++
name|ci
expr_stmt|;
block|}
name|putcwi_16
argument_list|(
name|cwi
argument_list|,
name|cn
argument_list|,
name|erd
operator|->
name|name_count
argument_list|)
expr_stmt|;
name|putcwi_16
argument_list|(
name|cwi
argument_list|,
name|ci
argument_list|,
name|erd
operator|->
name|id_count
argument_list|)
expr_stmt|;
comment|/* Write out the data entries.  Note that we allocate space for all      the entries before writing them out.  That permits a recursive      call to work correctly when writing out subdirectories.  */
name|ere
operator|=
operator|(
operator|(
expr|struct
name|extern_res_entry
operator|*
operator|)
name|coff_alloc
argument_list|(
operator|&
name|cwi
operator|->
name|dirs
argument_list|,
operator|(
name|ci
operator|+
name|cn
operator|)
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|ere
argument_list|)
argument_list|)
operator|)
expr_stmt|;
for|for
control|(
name|e
operator|=
name|resdir
operator|->
name|entries
init|;
name|e
operator|!=
name|NULL
condition|;
name|e
operator|=
name|e
operator|->
name|next
operator|,
name|ere
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|e
operator|->
name|id
operator|.
name|named
condition|)
name|putcwi_32
argument_list|(
name|cwi
argument_list|,
name|e
operator|->
name|id
operator|.
name|u
operator|.
name|id
argument_list|,
name|ere
operator|->
name|name
argument_list|)
expr_stmt|;
else|else
block|{
name|unsigned
name|char
modifier|*
name|str
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* For some reason existing files seem to have the high bit              set on the address of the name, although that is not              documented.  */
name|putcwi_32
argument_list|(
name|cwi
argument_list|,
literal|0x80000000
operator||
operator|(
name|cwi
operator|->
name|dirsize
operator|+
name|cwi
operator|->
name|dirstrs
operator|.
name|length
operator|)
argument_list|,
name|ere
operator|->
name|name
argument_list|)
expr_stmt|;
name|str
operator|=
name|coff_alloc
argument_list|(
operator|&
name|cwi
operator|->
name|dirstrs
argument_list|,
name|e
operator|->
name|id
operator|.
name|u
operator|.
name|n
operator|.
name|length
operator|*
literal|2
operator|+
literal|2
argument_list|)
expr_stmt|;
name|putcwi_16
argument_list|(
name|cwi
argument_list|,
name|e
operator|->
name|id
operator|.
name|u
operator|.
name|n
operator|.
name|length
argument_list|,
name|str
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|e
operator|->
name|id
operator|.
name|u
operator|.
name|n
operator|.
name|length
condition|;
name|i
operator|++
control|)
name|putcwi_16
argument_list|(
name|cwi
argument_list|,
name|e
operator|->
name|id
operator|.
name|u
operator|.
name|n
operator|.
name|name
index|[
name|i
index|]
argument_list|,
name|str
operator|+
name|i
operator|*
literal|2
operator|+
literal|2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|e
operator|->
name|subdir
condition|)
block|{
name|putcwi_32
argument_list|(
name|cwi
argument_list|,
literal|0x80000000
operator||
name|cwi
operator|->
name|dirs
operator|.
name|length
argument_list|,
name|ere
operator|->
name|rva
argument_list|)
expr_stmt|;
name|coff_to_bin
argument_list|(
name|e
operator|->
name|u
operator|.
name|dir
argument_list|,
name|cwi
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|putcwi_32
argument_list|(
name|cwi
argument_list|,
name|cwi
operator|->
name|dirsize
operator|+
name|cwi
operator|->
name|dirstrsize
operator|+
name|cwi
operator|->
name|dataents
operator|.
name|length
argument_list|,
name|ere
operator|->
name|rva
argument_list|)
expr_stmt|;
name|coff_res_to_bin
argument_list|(
name|e
operator|->
name|u
operator|.
name|res
argument_list|,
name|cwi
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Convert the resource RES to binary.  */
end_comment

begin_function
specifier|static
name|void
name|coff_res_to_bin
parameter_list|(
name|res
parameter_list|,
name|cwi
parameter_list|)
specifier|const
name|struct
name|res_resource
modifier|*
name|res
decl_stmt|;
name|struct
name|coff_write_info
modifier|*
name|cwi
decl_stmt|;
block|{
name|arelent
modifier|*
name|r
decl_stmt|;
name|struct
name|extern_res_data
modifier|*
name|erd
decl_stmt|;
name|struct
name|bindata
modifier|*
name|d
decl_stmt|;
name|unsigned
name|long
name|length
decl_stmt|;
comment|/* For some reason, although every other address is a section      offset, the address of the resource data itself is an RVA.  That      means that we need to generate a relocation for it.  We allocate      the relocs array using malloc so that we can use realloc.  FIXME:      This relocation handling is correct for the i386, but probably      not for any other target.  */
name|r
operator|=
operator|(
name|arelent
operator|*
operator|)
name|reswr_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|arelent
argument_list|)
argument_list|)
expr_stmt|;
name|r
operator|->
name|sym_ptr_ptr
operator|=
name|cwi
operator|->
name|sympp
expr_stmt|;
name|r
operator|->
name|address
operator|=
name|cwi
operator|->
name|dirsize
operator|+
name|cwi
operator|->
name|dirstrsize
operator|+
name|cwi
operator|->
name|dataents
operator|.
name|length
expr_stmt|;
name|r
operator|->
name|addend
operator|=
literal|0
expr_stmt|;
name|r
operator|->
name|howto
operator|=
name|bfd_reloc_type_lookup
argument_list|(
name|cwi
operator|->
name|abfd
argument_list|,
name|BFD_RELOC_RVA
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|howto
operator|==
name|NULL
condition|)
name|bfd_fatal
argument_list|(
name|_
argument_list|(
literal|"can't get BFD_RELOC_RVA relocation type"
argument_list|)
argument_list|)
expr_stmt|;
name|cwi
operator|->
name|relocs
operator|=
name|xrealloc
argument_list|(
name|cwi
operator|->
name|relocs
argument_list|,
operator|(
name|cwi
operator|->
name|reloc_count
operator|+
literal|2
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|arelent
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|cwi
operator|->
name|relocs
index|[
name|cwi
operator|->
name|reloc_count
index|]
operator|=
name|r
expr_stmt|;
name|cwi
operator|->
name|relocs
index|[
name|cwi
operator|->
name|reloc_count
operator|+
literal|1
index|]
operator|=
name|NULL
expr_stmt|;
operator|++
name|cwi
operator|->
name|reloc_count
expr_stmt|;
name|erd
operator|=
operator|(
expr|struct
name|extern_res_data
operator|*
operator|)
name|coff_alloc
argument_list|(
operator|&
name|cwi
operator|->
name|dataents
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|erd
argument_list|)
argument_list|)
expr_stmt|;
name|putcwi_32
argument_list|(
name|cwi
argument_list|,
operator|(
name|cwi
operator|->
name|dirsize
operator|+
name|cwi
operator|->
name|dirstrsize
operator|+
name|cwi
operator|->
name|dataentsize
operator|+
name|cwi
operator|->
name|resources
operator|.
name|length
operator|)
argument_list|,
name|erd
operator|->
name|rva
argument_list|)
expr_stmt|;
name|putcwi_32
argument_list|(
name|cwi
argument_list|,
name|res
operator|->
name|coff_info
operator|.
name|codepage
argument_list|,
name|erd
operator|->
name|codepage
argument_list|)
expr_stmt|;
name|putcwi_32
argument_list|(
name|cwi
argument_list|,
name|res
operator|->
name|coff_info
operator|.
name|reserved
argument_list|,
name|erd
operator|->
name|reserved
argument_list|)
expr_stmt|;
name|d
operator|=
name|res_to_bin
argument_list|(
name|res
argument_list|,
name|cwi
operator|->
name|big_endian
argument_list|)
expr_stmt|;
if|if
condition|(
name|cwi
operator|->
name|resources
operator|.
name|d
operator|==
name|NULL
condition|)
name|cwi
operator|->
name|resources
operator|.
name|d
operator|=
name|d
expr_stmt|;
else|else
name|cwi
operator|->
name|resources
operator|.
name|last
operator|->
name|next
operator|=
name|d
expr_stmt|;
name|length
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
name|d
operator|->
name|next
operator|!=
name|NULL
condition|;
name|d
operator|=
name|d
operator|->
name|next
control|)
name|length
operator|+=
name|d
operator|->
name|length
expr_stmt|;
name|length
operator|+=
name|d
operator|->
name|length
expr_stmt|;
name|cwi
operator|->
name|resources
operator|.
name|last
operator|=
name|d
expr_stmt|;
name|cwi
operator|->
name|resources
operator|.
name|length
operator|+=
name|length
expr_stmt|;
name|putcwi_32
argument_list|(
name|cwi
argument_list|,
name|length
argument_list|,
name|erd
operator|->
name|size
argument_list|)
expr_stmt|;
comment|/* Force the next resource to have 32 bit alignment.  */
if|if
condition|(
operator|(
name|length
operator|&
literal|3
operator|)
operator|!=
literal|0
condition|)
block|{
name|int
name|add
decl_stmt|;
name|unsigned
name|char
modifier|*
name|ex
decl_stmt|;
name|add
operator|=
literal|4
operator|-
operator|(
name|length
operator|&
literal|3
operator|)
expr_stmt|;
name|ex
operator|=
name|coff_alloc
argument_list|(
operator|&
name|cwi
operator|->
name|resources
argument_list|,
name|add
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|ex
argument_list|,
literal|0
argument_list|,
name|add
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

