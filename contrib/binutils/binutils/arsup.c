begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* arsup.c - Archive support for MRI compatibility    Copyright 1992, 1994, 1995, 1996, 1997, 2000    Free Software Foundation, Inc.  This file is part of GNU Binutils.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* Contributed by Steve Chamberlain    		  sac@cygnus.com  This file looks after requests from arparse.y, to provide the MRI style librarian command syntax + 1 word LIST  */
end_comment

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"arsup.h"
end_include

begin_include
include|#
directive|include
file|"libiberty.h"
end_include

begin_include
include|#
directive|include
file|"bucomm.h"
end_include

begin_include
include|#
directive|include
file|"filenames.h"
end_include

begin_decl_stmt
specifier|static
name|void
name|map_over_list
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|void
argument_list|(
operator|*
name|function
argument_list|)
argument_list|(
name|bfd
operator|*
argument_list|,
name|bfd
operator|*
argument_list|)
operator|,
expr|struct
name|list
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ar_directory_doer
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ar_addlib_doer
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|verbose
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|map_over_list
parameter_list|(
name|arch
parameter_list|,
name|function
parameter_list|,
name|list
parameter_list|)
name|bfd
modifier|*
name|arch
decl_stmt|;
function_decl|void
parameter_list|(
function_decl|*function
end_function_decl

begin_expr_stmt
unit|)
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|bfd
operator|*
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|struct
name|list
modifier|*
name|list
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|bfd
modifier|*
name|head
decl_stmt|;
if|if
condition|(
name|list
operator|==
name|NULL
condition|)
block|{
name|bfd
modifier|*
name|next
decl_stmt|;
name|head
operator|=
name|arch
operator|->
name|next
expr_stmt|;
while|while
condition|(
name|head
operator|!=
name|NULL
condition|)
block|{
name|next
operator|=
name|head
operator|->
name|next
expr_stmt|;
name|function
argument_list|(
name|head
argument_list|,
operator|(
name|bfd
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|head
operator|=
name|next
expr_stmt|;
block|}
block|}
else|else
block|{
name|struct
name|list
modifier|*
name|ptr
decl_stmt|;
comment|/* This may appear to be a baroque way of accomplishing what we 	 want.  however we have to iterate over the filenames in order 	 to notice where a filename is requested but does not exist in 	 the archive.  Ditto mapping over each file each time -- we 	 want to hack multiple references.  */
for|for
control|(
name|ptr
operator|=
name|list
init|;
name|ptr
condition|;
name|ptr
operator|=
name|ptr
operator|->
name|next
control|)
block|{
name|boolean
name|found
init|=
name|false
decl_stmt|;
name|bfd
modifier|*
name|prev
init|=
name|arch
decl_stmt|;
for|for
control|(
name|head
operator|=
name|arch
operator|->
name|next
init|;
name|head
condition|;
name|head
operator|=
name|head
operator|->
name|next
control|)
block|{
if|if
condition|(
name|head
operator|->
name|filename
operator|!=
name|NULL
operator|&&
name|FILENAME_CMP
argument_list|(
name|ptr
operator|->
name|name
argument_list|,
name|head
operator|->
name|filename
argument_list|)
operator|==
literal|0
condition|)
block|{
name|found
operator|=
name|true
expr_stmt|;
name|function
argument_list|(
name|head
argument_list|,
name|prev
argument_list|)
expr_stmt|;
block|}
name|prev
operator|=
name|head
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|found
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"No entry %s in archive.\n"
argument_list|)
argument_list|,
name|ptr
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_decl_stmt
name|FILE
modifier|*
name|outfile
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|void
name|ar_directory_doer
parameter_list|(
name|abfd
parameter_list|,
name|ignore
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|bfd
modifier|*
name|ignore
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|print_arelt_descr
argument_list|(
name|outfile
argument_list|,
name|abfd
argument_list|,
name|verbose
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ar_directory
parameter_list|(
name|ar_name
parameter_list|,
name|list
parameter_list|,
name|output
parameter_list|)
name|char
modifier|*
name|ar_name
decl_stmt|;
name|struct
name|list
modifier|*
name|list
decl_stmt|;
name|char
modifier|*
name|output
decl_stmt|;
block|{
name|bfd
modifier|*
name|arch
decl_stmt|;
name|arch
operator|=
name|open_inarch
argument_list|(
name|ar_name
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|output
condition|)
block|{
name|outfile
operator|=
name|fopen
argument_list|(
name|output
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|outfile
operator|==
literal|0
condition|)
block|{
name|outfile
operator|=
name|stdout
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"Can't open file %s\n"
argument_list|)
argument_list|,
name|output
argument_list|)
expr_stmt|;
name|output
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
name|outfile
operator|=
name|stdout
expr_stmt|;
name|map_over_list
argument_list|(
name|arch
argument_list|,
name|ar_directory_doer
argument_list|,
name|list
argument_list|)
expr_stmt|;
name|bfd_close
argument_list|(
name|arch
argument_list|)
expr_stmt|;
if|if
condition|(
name|output
condition|)
name|fclose
argument_list|(
name|outfile
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|DEFUN_VOID
parameter_list|(
name|prompt
parameter_list|)
block|{
specifier|extern
name|int
name|interactive
decl_stmt|;
if|if
condition|(
name|interactive
condition|)
block|{
name|printf
argument_list|(
literal|"AR>"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|maybequit
parameter_list|()
block|{
if|if
condition|(
operator|!
name|interactive
condition|)
name|xexit
argument_list|(
literal|9
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|bfd
modifier|*
name|obfd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|real_name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|DEFUN
argument_list|(
name|ar_open
argument_list|,
operator|(
name|name
operator|,
name|t
operator|)
argument_list|,
name|char
operator|*
name|name
name|AND
name|int
name|t
argument_list|)
block|{
name|char
modifier|*
name|tname
init|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|10
argument_list|)
decl_stmt|;
name|real_name
operator|=
name|name
expr_stmt|;
comment|/* Prepend tmp- to the beginning, to avoid file-name clashes after      truncation on filesystems with limited namespaces (DOS).  */
name|sprintf
argument_list|(
name|tname
argument_list|,
literal|"tmp-%s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|obfd
operator|=
name|bfd_openw
argument_list|(
name|tname
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|obfd
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"%s: Can't open output archive %s\n"
argument_list|)
argument_list|,
name|program_name
argument_list|,
name|tname
argument_list|)
expr_stmt|;
name|maybequit
argument_list|()
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|t
condition|)
block|{
name|bfd
modifier|*
modifier|*
name|ptr
decl_stmt|;
name|bfd
modifier|*
name|element
decl_stmt|;
name|bfd
modifier|*
name|ibfd
decl_stmt|;
name|ibfd
operator|=
name|bfd_openr
argument_list|(
name|name
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ibfd
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"%s: Can't open input archive %s\n"
argument_list|)
argument_list|,
name|program_name
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|maybequit
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|bfd_check_format
argument_list|(
name|ibfd
argument_list|,
name|bfd_archive
argument_list|)
operator|!=
name|true
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"%s: file %s is not an archive\n"
argument_list|)
argument_list|,
name|program_name
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|maybequit
argument_list|()
expr_stmt|;
return|return;
block|}
name|ptr
operator|=
operator|&
operator|(
name|obfd
operator|->
name|archive_head
operator|)
expr_stmt|;
name|element
operator|=
name|bfd_openr_next_archived_file
argument_list|(
name|ibfd
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
while|while
condition|(
name|element
condition|)
block|{
operator|*
name|ptr
operator|=
name|element
expr_stmt|;
name|ptr
operator|=
operator|&
name|element
operator|->
name|next
expr_stmt|;
name|element
operator|=
name|bfd_openr_next_archived_file
argument_list|(
name|ibfd
argument_list|,
name|element
argument_list|)
expr_stmt|;
block|}
block|}
name|bfd_set_format
argument_list|(
name|obfd
argument_list|,
name|bfd_archive
argument_list|)
expr_stmt|;
name|obfd
operator|->
name|has_armap
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_decl_stmt

begin_function
specifier|static
name|void
name|ar_addlib_doer
parameter_list|(
name|abfd
parameter_list|,
name|prev
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|bfd
modifier|*
name|prev
decl_stmt|;
block|{
comment|/* Add this module to the output bfd */
if|if
condition|(
name|prev
operator|!=
name|NULL
condition|)
name|prev
operator|->
name|next
operator|=
name|abfd
operator|->
name|next
expr_stmt|;
name|abfd
operator|->
name|next
operator|=
name|obfd
operator|->
name|archive_head
expr_stmt|;
name|obfd
operator|->
name|archive_head
operator|=
name|abfd
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ar_addlib
parameter_list|(
name|name
parameter_list|,
name|list
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|struct
name|list
modifier|*
name|list
decl_stmt|;
block|{
if|if
condition|(
name|obfd
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"%s: no output archive specified yet\n"
argument_list|)
argument_list|,
name|program_name
argument_list|)
expr_stmt|;
name|maybequit
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|bfd
modifier|*
name|arch
decl_stmt|;
name|arch
operator|=
name|open_inarch
argument_list|(
name|name
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|arch
operator|!=
name|NULL
condition|)
name|map_over_list
argument_list|(
name|arch
argument_list|,
name|ar_addlib_doer
argument_list|,
name|list
argument_list|)
expr_stmt|;
comment|/* Don't close the bfd, since it will make the elements disasppear */
block|}
block|}
end_function

begin_decl_stmt
name|void
name|DEFUN
argument_list|(
name|ar_addmod
argument_list|,
operator|(
name|list
operator|)
argument_list|,
expr|struct
name|list
operator|*
name|list
argument_list|)
block|{
if|if
condition|(
operator|!
name|obfd
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"%s: no open output archive\n"
argument_list|)
argument_list|,
name|program_name
argument_list|)
expr_stmt|;
name|maybequit
argument_list|()
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
name|list
condition|)
block|{
name|bfd
modifier|*
name|abfd
init|=
name|bfd_openr
argument_list|(
name|list
operator|->
name|name
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|abfd
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"%s: can't open file %s\n"
argument_list|)
argument_list|,
name|program_name
argument_list|,
name|list
operator|->
name|name
argument_list|)
expr_stmt|;
name|maybequit
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|abfd
operator|->
name|next
operator|=
name|obfd
operator|->
name|archive_head
expr_stmt|;
name|obfd
operator|->
name|archive_head
operator|=
name|abfd
expr_stmt|;
block|}
name|list
operator|=
name|list
operator|->
name|next
expr_stmt|;
block|}
block|}
block|}
end_decl_stmt

begin_function
name|void
name|DEFUN_VOID
parameter_list|(
name|ar_clear
parameter_list|)
block|{
if|if
condition|(
name|obfd
condition|)
name|obfd
operator|->
name|archive_head
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|void
name|DEFUN
argument_list|(
name|ar_delete
argument_list|,
operator|(
name|list
operator|)
argument_list|,
expr|struct
name|list
operator|*
name|list
argument_list|)
block|{
if|if
condition|(
operator|!
name|obfd
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"%s: no open output archive\n"
argument_list|)
argument_list|,
name|program_name
argument_list|)
expr_stmt|;
name|maybequit
argument_list|()
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
name|list
condition|)
block|{
comment|/* Find this name in the archive */
name|bfd
modifier|*
name|member
init|=
name|obfd
operator|->
name|archive_head
decl_stmt|;
name|bfd
modifier|*
modifier|*
name|prev
init|=
operator|&
operator|(
name|obfd
operator|->
name|archive_head
operator|)
decl_stmt|;
name|int
name|found
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|member
condition|)
block|{
if|if
condition|(
name|FILENAME_CMP
argument_list|(
name|member
operator|->
name|filename
argument_list|,
name|list
operator|->
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|prev
operator|=
name|member
operator|->
name|next
expr_stmt|;
name|found
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|prev
operator|=
operator|&
operator|(
name|member
operator|->
name|next
operator|)
expr_stmt|;
block|}
name|member
operator|=
name|member
operator|->
name|next
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|found
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"%s: can't find module file %s\n"
argument_list|)
argument_list|,
name|program_name
argument_list|,
name|list
operator|->
name|name
argument_list|)
expr_stmt|;
name|maybequit
argument_list|()
expr_stmt|;
block|}
name|list
operator|=
name|list
operator|->
name|next
expr_stmt|;
block|}
block|}
block|}
end_decl_stmt

begin_function
name|void
name|DEFUN_VOID
parameter_list|(
name|ar_save
parameter_list|)
block|{
if|if
condition|(
operator|!
name|obfd
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"%s: no open output archive\n"
argument_list|)
argument_list|,
name|program_name
argument_list|)
expr_stmt|;
name|maybequit
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|char
modifier|*
name|ofilename
init|=
name|xstrdup
argument_list|(
name|bfd_get_filename
argument_list|(
name|obfd
argument_list|)
argument_list|)
decl_stmt|;
name|bfd_close
argument_list|(
name|obfd
argument_list|)
expr_stmt|;
name|rename
argument_list|(
name|ofilename
argument_list|,
name|real_name
argument_list|)
expr_stmt|;
name|obfd
operator|=
literal|0
expr_stmt|;
name|free
argument_list|(
name|ofilename
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_decl_stmt
name|void
name|DEFUN
argument_list|(
name|ar_replace
argument_list|,
operator|(
name|list
operator|)
argument_list|,
expr|struct
name|list
operator|*
name|list
argument_list|)
block|{
if|if
condition|(
operator|!
name|obfd
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"%s: no open output archive\n"
argument_list|)
argument_list|,
name|program_name
argument_list|)
expr_stmt|;
name|maybequit
argument_list|()
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
name|list
condition|)
block|{
comment|/* Find this name in the archive */
name|bfd
modifier|*
name|member
init|=
name|obfd
operator|->
name|archive_head
decl_stmt|;
name|bfd
modifier|*
modifier|*
name|prev
init|=
operator|&
operator|(
name|obfd
operator|->
name|archive_head
operator|)
decl_stmt|;
name|int
name|found
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|member
condition|)
block|{
if|if
condition|(
name|FILENAME_CMP
argument_list|(
name|member
operator|->
name|filename
argument_list|,
name|list
operator|->
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Found the one to replace */
name|bfd
modifier|*
name|abfd
init|=
name|bfd_openr
argument_list|(
name|list
operator|->
name|name
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|abfd
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"%s: can't open file %s\n"
argument_list|)
argument_list|,
name|program_name
argument_list|,
name|list
operator|->
name|name
argument_list|)
expr_stmt|;
name|maybequit
argument_list|()
expr_stmt|;
block|}
else|else
block|{
operator|*
name|prev
operator|=
name|abfd
expr_stmt|;
name|abfd
operator|->
name|next
operator|=
name|member
operator|->
name|next
expr_stmt|;
name|found
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
name|prev
operator|=
operator|&
operator|(
name|member
operator|->
name|next
operator|)
expr_stmt|;
block|}
name|member
operator|=
name|member
operator|->
name|next
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|found
condition|)
block|{
name|bfd
modifier|*
name|abfd
init|=
name|bfd_openr
argument_list|(
name|list
operator|->
name|name
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"%s: can't find module file %s\n"
argument_list|)
argument_list|,
name|program_name
argument_list|,
name|list
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|abfd
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"%s: can't open file %s\n"
argument_list|)
argument_list|,
name|program_name
argument_list|,
name|list
operator|->
name|name
argument_list|)
expr_stmt|;
name|maybequit
argument_list|()
expr_stmt|;
block|}
else|else
block|{
operator|*
name|prev
operator|=
name|abfd
expr_stmt|;
block|}
block|}
name|list
operator|=
name|list
operator|->
name|next
expr_stmt|;
block|}
block|}
block|}
end_decl_stmt

begin_comment
comment|/* And I added this one */
end_comment

begin_function
name|void
name|DEFUN_VOID
parameter_list|(
name|ar_list
parameter_list|)
block|{
if|if
condition|(
operator|!
name|obfd
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"%s: no open output archive\n"
argument_list|)
argument_list|,
name|program_name
argument_list|)
expr_stmt|;
name|maybequit
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|outfile
operator|=
name|stdout
expr_stmt|;
name|verbose
operator|=
literal|1
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"Current open archive is %s\n"
argument_list|)
argument_list|,
name|bfd_get_filename
argument_list|(
name|obfd
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|abfd
operator|=
name|obfd
operator|->
name|archive_head
init|;
name|abfd
operator|!=
operator|(
name|bfd
operator|*
operator|)
name|NULL
condition|;
name|abfd
operator|=
name|abfd
operator|->
name|next
control|)
block|{
name|ar_directory_doer
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
name|DEFUN_VOID
parameter_list|(
name|ar_end
parameter_list|)
block|{
if|if
condition|(
name|obfd
condition|)
block|{
name|fclose
argument_list|(
operator|(
name|FILE
operator|*
operator|)
operator|(
name|obfd
operator|->
name|iostream
operator|)
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|bfd_get_filename
argument_list|(
name|obfd
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_decl_stmt
name|void
name|DEFUN
argument_list|(
name|ar_extract
argument_list|,
operator|(
name|list
operator|)
argument_list|,
expr|struct
name|list
operator|*
name|list
argument_list|)
block|{
if|if
condition|(
operator|!
name|obfd
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"%s: no open  archive\n"
argument_list|)
argument_list|,
name|program_name
argument_list|)
expr_stmt|;
name|maybequit
argument_list|()
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
name|list
condition|)
block|{
comment|/* Find this name in the archive */
name|bfd
modifier|*
name|member
init|=
name|obfd
operator|->
name|archive_head
decl_stmt|;
name|int
name|found
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|member
operator|&&
operator|!
name|found
condition|)
block|{
if|if
condition|(
name|FILENAME_CMP
argument_list|(
name|member
operator|->
name|filename
argument_list|,
name|list
operator|->
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
name|extract_file
argument_list|(
name|member
argument_list|)
expr_stmt|;
name|found
operator|=
literal|1
expr_stmt|;
block|}
name|member
operator|=
name|member
operator|->
name|next
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|found
condition|)
block|{
name|bfd_openr
argument_list|(
name|list
operator|->
name|name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"%s: can't find module file %s\n"
argument_list|)
argument_list|,
name|program_name
argument_list|,
name|list
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
name|list
operator|=
name|list
operator|->
name|next
expr_stmt|;
block|}
block|}
block|}
end_decl_stmt

end_unit

