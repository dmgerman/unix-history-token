begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* resrc.c -- read and write Windows rc files.    Copyright 1997, 1998 Free Software Foundation, Inc.    Written by Ian Lance Taylor, Cygnus Support.     This file is part of GNU Binutils.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA    02111-1307, USA.  */
end_comment

begin_comment
comment|/* This file contains functions that read and write Windows rc files.    These are text files that represent resources.  */
end_comment

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"bucomm.h"
end_include

begin_include
include|#
directive|include
file|"libiberty.h"
end_include

begin_include
include|#
directive|include
file|"windres.h"
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__CYGWIN32__
argument_list|)
end_if

begin_define
define|#
directive|define
name|popen
value|_popen
end_define

begin_define
define|#
directive|define
name|pclose
value|_pclose
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* The default preprocessor.  */
end_comment

begin_define
define|#
directive|define
name|DEFAULT_PREPROCESSOR
value|"gcc -E -xc-header -DRC_INVOKED"
end_define

begin_comment
comment|/* We read the directory entries in a cursor or icon file into    instances of this structure.  */
end_comment

begin_struct
struct|struct
name|icondir
block|{
comment|/* Width of image.  */
name|unsigned
name|char
name|width
decl_stmt|;
comment|/* Height of image.  */
name|unsigned
name|char
name|height
decl_stmt|;
comment|/* Number of colors in image.  */
name|unsigned
name|char
name|colorcount
decl_stmt|;
union|union
block|{
struct|struct
block|{
comment|/* Color planes.  */
name|unsigned
name|short
name|planes
decl_stmt|;
comment|/* Bits per pixel.  */
name|unsigned
name|short
name|bits
decl_stmt|;
block|}
name|icon
struct|;
struct|struct
block|{
comment|/* X coordinate of hotspot.  */
name|unsigned
name|short
name|xhotspot
decl_stmt|;
comment|/* Y coordinate of hotspot.  */
name|unsigned
name|short
name|yhotspot
decl_stmt|;
block|}
name|cursor
struct|;
block|}
name|u
union|;
comment|/* Bytes in image.  */
name|unsigned
name|long
name|bytes
decl_stmt|;
comment|/* File offset of image.  */
name|unsigned
name|long
name|offset
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* The name of the rc file we are reading.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|rc_filename
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The line number in the rc file.  */
end_comment

begin_decl_stmt
name|int
name|rc_lineno
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The pipe we are reading from, so that we can close it if we exit.  */
end_comment

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|cpp_pipe
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* As we read the rc file, we attach information to this structure.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|res_directory
modifier|*
name|resources
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The number of cursor resources we have written out.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|cursors
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The number of font resources we have written out.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|fonts
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Font directory information.  */
end_comment

begin_decl_stmt
name|struct
name|fontdir
modifier|*
name|fontdirs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Resource info to use for fontdirs.  */
end_comment

begin_decl_stmt
name|struct
name|res_res_info
name|fontdirs_resinfo
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The number of icon resources we have written out.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|icons
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Local functions.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|close_pipe
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|unexpected_eof
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|get_word
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|long
name|get_long
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|get_data
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|,
name|unsigned
name|char
operator|*
operator|,
name|unsigned
name|long
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|define_fontdirs
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Read an rc file.  */
end_comment

begin_function
name|struct
name|res_directory
modifier|*
name|read_rc_file
parameter_list|(
name|filename
parameter_list|,
name|preprocessor
parameter_list|,
name|preprocargs
parameter_list|,
name|language
parameter_list|)
specifier|const
name|char
modifier|*
name|filename
decl_stmt|;
specifier|const
name|char
modifier|*
name|preprocessor
decl_stmt|;
specifier|const
name|char
modifier|*
name|preprocargs
decl_stmt|;
name|int
name|language
decl_stmt|;
block|{
name|char
modifier|*
name|cmd
decl_stmt|;
if|if
condition|(
name|preprocessor
operator|==
name|NULL
condition|)
name|preprocessor
operator|=
name|DEFAULT_PREPROCESSOR
expr_stmt|;
if|if
condition|(
name|preprocargs
operator|==
name|NULL
condition|)
name|preprocargs
operator|=
literal|""
expr_stmt|;
if|if
condition|(
name|filename
operator|==
name|NULL
condition|)
name|filename
operator|=
literal|"-"
expr_stmt|;
name|cmd
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|preprocessor
argument_list|)
operator|+
name|strlen
argument_list|(
name|preprocargs
argument_list|)
operator|+
name|strlen
argument_list|(
name|filename
argument_list|)
operator|+
literal|10
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|cmd
argument_list|,
literal|"%s %s %s"
argument_list|,
name|preprocessor
argument_list|,
name|preprocargs
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|cpp_pipe
operator|=
name|popen
argument_list|(
name|cmd
argument_list|,
name|FOPEN_RT
argument_list|)
expr_stmt|;
if|if
condition|(
name|cpp_pipe
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
literal|"can't popen `%s': %s"
argument_list|,
name|cmd
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
name|xatexit
argument_list|(
name|close_pipe
argument_list|)
expr_stmt|;
name|rc_filename
operator|=
name|xstrdup
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|rc_lineno
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|language
operator|!=
operator|-
literal|1
condition|)
name|rcparse_set_language
argument_list|(
name|language
argument_list|)
expr_stmt|;
name|yyin
operator|=
name|cpp_pipe
expr_stmt|;
name|yyparse
argument_list|()
expr_stmt|;
if|if
condition|(
name|pclose
argument_list|(
name|cpp_pipe
argument_list|)
operator|!=
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: warning: preprocessor failed\n"
argument_list|,
name|program_name
argument_list|)
expr_stmt|;
name|cpp_pipe
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|fontdirs
operator|!=
name|NULL
condition|)
name|define_fontdirs
argument_list|()
expr_stmt|;
name|free
argument_list|(
name|rc_filename
argument_list|)
expr_stmt|;
name|rc_filename
operator|=
name|NULL
expr_stmt|;
return|return
name|resources
return|;
block|}
end_function

begin_comment
comment|/* Close the pipe if it is open.  This is called via xatexit.  */
end_comment

begin_function
name|void
name|close_pipe
parameter_list|()
block|{
if|if
condition|(
name|cpp_pipe
operator|!=
name|NULL
condition|)
name|pclose
argument_list|(
name|cpp_pipe
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Report an error while reading an rc file.  */
end_comment

begin_function
name|void
name|yyerror
parameter_list|(
name|msg
parameter_list|)
specifier|const
name|char
modifier|*
name|msg
decl_stmt|;
block|{
name|fatal
argument_list|(
literal|"%s:%d: %s"
argument_list|,
name|rc_filename
argument_list|,
name|rc_lineno
argument_list|,
name|msg
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Issue a warning while reading an rc file.  */
end_comment

begin_function
name|void
name|rcparse_warning
parameter_list|(
name|msg
parameter_list|)
specifier|const
name|char
modifier|*
name|msg
decl_stmt|;
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:%d: %s\n"
argument_list|,
name|rc_filename
argument_list|,
name|rc_lineno
argument_list|,
name|msg
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Die if we get an unexpected end of file.  */
end_comment

begin_function
specifier|static
name|void
name|unexpected_eof
parameter_list|(
name|msg
parameter_list|)
specifier|const
name|char
modifier|*
name|msg
decl_stmt|;
block|{
name|fatal
argument_list|(
literal|"%s: unexpected EOF"
argument_list|,
name|msg
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Read a 16 bit word from a file.  The data is assumed to be little    endian.  */
end_comment

begin_function
specifier|static
name|int
name|get_word
parameter_list|(
name|e
parameter_list|,
name|msg
parameter_list|)
name|FILE
modifier|*
name|e
decl_stmt|;
specifier|const
name|char
modifier|*
name|msg
decl_stmt|;
block|{
name|int
name|b1
decl_stmt|,
name|b2
decl_stmt|;
name|b1
operator|=
name|getc
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|b2
operator|=
name|getc
argument_list|(
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|feof
argument_list|(
name|e
argument_list|)
condition|)
name|unexpected_eof
argument_list|(
name|msg
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|b2
operator|&
literal|0xff
operator|)
operator|<<
literal|8
operator|)
operator||
operator|(
name|b1
operator|&
literal|0xff
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Read a 32 bit word from a file.  The data is assumed to be little    endian.  */
end_comment

begin_function
specifier|static
name|unsigned
name|long
name|get_long
parameter_list|(
name|e
parameter_list|,
name|msg
parameter_list|)
name|FILE
modifier|*
name|e
decl_stmt|;
specifier|const
name|char
modifier|*
name|msg
decl_stmt|;
block|{
name|int
name|b1
decl_stmt|,
name|b2
decl_stmt|,
name|b3
decl_stmt|,
name|b4
decl_stmt|;
name|b1
operator|=
name|getc
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|b2
operator|=
name|getc
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|b3
operator|=
name|getc
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|b4
operator|=
name|getc
argument_list|(
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|feof
argument_list|(
name|e
argument_list|)
condition|)
name|unexpected_eof
argument_list|(
name|msg
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
operator|(
operator|(
operator|(
operator|(
operator|(
name|b4
operator|&
literal|0xff
operator|)
operator|<<
literal|8
operator|)
operator||
operator|(
name|b3
operator|&
literal|0xff
operator|)
operator|)
operator|<<
literal|8
operator|)
operator||
operator|(
name|b2
operator|&
literal|0xff
operator|)
operator|)
operator|<<
literal|8
operator|)
operator||
operator|(
name|b1
operator|&
literal|0xff
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Read data from a file.  This is a wrapper to do error checking.  */
end_comment

begin_function
specifier|static
name|void
name|get_data
parameter_list|(
name|e
parameter_list|,
name|p
parameter_list|,
name|c
parameter_list|,
name|msg
parameter_list|)
name|FILE
modifier|*
name|e
decl_stmt|;
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
name|unsigned
name|long
name|c
decl_stmt|;
specifier|const
name|char
modifier|*
name|msg
decl_stmt|;
block|{
name|unsigned
name|long
name|got
decl_stmt|;
name|got
operator|=
name|fread
argument_list|(
name|p
argument_list|,
literal|1
argument_list|,
name|c
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|got
operator|==
name|c
condition|)
return|return;
name|fatal
argument_list|(
literal|"%s: read of %lu returned %lu"
argument_list|,
name|msg
argument_list|,
name|c
argument_list|,
name|got
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Define an accelerator resource.  */
end_comment

begin_function
name|void
name|define_accelerator
parameter_list|(
name|id
parameter_list|,
name|resinfo
parameter_list|,
name|data
parameter_list|)
name|struct
name|res_id
name|id
decl_stmt|;
specifier|const
name|struct
name|res_res_info
modifier|*
name|resinfo
decl_stmt|;
name|struct
name|accelerator
modifier|*
name|data
decl_stmt|;
block|{
name|struct
name|res_resource
modifier|*
name|r
decl_stmt|;
name|r
operator|=
name|define_standard_resource
argument_list|(
operator|&
name|resources
argument_list|,
name|RT_ACCELERATORS
argument_list|,
name|id
argument_list|,
name|resinfo
operator|->
name|language
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|r
operator|->
name|type
operator|=
name|RES_TYPE_ACCELERATOR
expr_stmt|;
name|r
operator|->
name|u
operator|.
name|acc
operator|=
name|data
expr_stmt|;
name|r
operator|->
name|res_info
operator|=
operator|*
name|resinfo
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Define a bitmap resource.  Bitmap data is stored in a file.  The    first 14 bytes of the file are a standard header, which is not    included in the resource data.  */
end_comment

begin_define
define|#
directive|define
name|BITMAP_SKIP
value|(14)
end_define

begin_function
name|void
name|define_bitmap
parameter_list|(
name|id
parameter_list|,
name|resinfo
parameter_list|,
name|filename
parameter_list|)
name|struct
name|res_id
name|id
decl_stmt|;
specifier|const
name|struct
name|res_res_info
modifier|*
name|resinfo
decl_stmt|;
specifier|const
name|char
modifier|*
name|filename
decl_stmt|;
block|{
name|FILE
modifier|*
name|e
decl_stmt|;
name|char
modifier|*
name|real_filename
decl_stmt|;
name|struct
name|stat
name|s
decl_stmt|;
name|unsigned
name|char
modifier|*
name|data
decl_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|res_resource
modifier|*
name|r
decl_stmt|;
name|e
operator|=
name|open_file_search
argument_list|(
name|filename
argument_list|,
name|FOPEN_RB
argument_list|,
literal|"bitmap file"
argument_list|,
operator|&
name|real_filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|real_filename
argument_list|,
operator|&
name|s
argument_list|)
operator|<
literal|0
condition|)
name|fatal
argument_list|(
literal|"stat failed on bitmap file `%s': %s"
argument_list|,
name|real_filename
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|data
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|res_alloc
argument_list|(
name|s
operator|.
name|st_size
operator|-
name|BITMAP_SKIP
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|BITMAP_SKIP
condition|;
name|i
operator|++
control|)
name|getc
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|get_data
argument_list|(
name|e
argument_list|,
name|data
argument_list|,
name|s
operator|.
name|st_size
operator|-
name|BITMAP_SKIP
argument_list|,
name|real_filename
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|real_filename
argument_list|)
expr_stmt|;
name|r
operator|=
name|define_standard_resource
argument_list|(
operator|&
name|resources
argument_list|,
name|RT_BITMAP
argument_list|,
name|id
argument_list|,
name|resinfo
operator|->
name|language
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|r
operator|->
name|type
operator|=
name|RES_TYPE_BITMAP
expr_stmt|;
name|r
operator|->
name|u
operator|.
name|data
operator|.
name|length
operator|=
name|s
operator|.
name|st_size
operator|-
name|BITMAP_SKIP
expr_stmt|;
name|r
operator|->
name|u
operator|.
name|data
operator|.
name|data
operator|=
name|data
expr_stmt|;
name|r
operator|->
name|res_info
operator|=
operator|*
name|resinfo
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Define a cursor resource.  A cursor file may contain a set of    bitmaps, each representing the same cursor at various different    resolutions.  They each get written out with a different ID.  The    real cursor resource is then a group resource which can be used to    select one of the actual cursors.  */
end_comment

begin_function
name|void
name|define_cursor
parameter_list|(
name|id
parameter_list|,
name|resinfo
parameter_list|,
name|filename
parameter_list|)
name|struct
name|res_id
name|id
decl_stmt|;
specifier|const
name|struct
name|res_res_info
modifier|*
name|resinfo
decl_stmt|;
specifier|const
name|char
modifier|*
name|filename
decl_stmt|;
block|{
name|FILE
modifier|*
name|e
decl_stmt|;
name|char
modifier|*
name|real_filename
decl_stmt|;
name|int
name|type
decl_stmt|,
name|count
decl_stmt|,
name|i
decl_stmt|;
name|struct
name|icondir
modifier|*
name|icondirs
decl_stmt|;
name|int
name|first_cursor
decl_stmt|;
name|struct
name|res_resource
modifier|*
name|r
decl_stmt|;
name|struct
name|group_cursor
modifier|*
name|first
decl_stmt|,
modifier|*
modifier|*
name|pp
decl_stmt|;
name|e
operator|=
name|open_file_search
argument_list|(
name|filename
argument_list|,
name|FOPEN_RB
argument_list|,
literal|"cursor file"
argument_list|,
operator|&
name|real_filename
argument_list|)
expr_stmt|;
comment|/* A cursor file is basically an icon file.  The start of the file      is a three word structure.  The first word is ignored.  The      second word is the type of data.  The third word is the number of      entries.  */
name|get_word
argument_list|(
name|e
argument_list|,
name|real_filename
argument_list|)
expr_stmt|;
name|type
operator|=
name|get_word
argument_list|(
name|e
argument_list|,
name|real_filename
argument_list|)
expr_stmt|;
name|count
operator|=
name|get_word
argument_list|(
name|e
argument_list|,
name|real_filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|!=
literal|2
condition|)
name|fatal
argument_list|(
literal|"cursor file `%s' does not contain cursor data"
argument_list|,
name|real_filename
argument_list|)
expr_stmt|;
comment|/* Read in the icon directory entries.  */
name|icondirs
operator|=
operator|(
expr|struct
name|icondir
operator|*
operator|)
name|xmalloc
argument_list|(
name|count
operator|*
sizeof|sizeof
expr|*
name|icondirs
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|icondirs
index|[
name|i
index|]
operator|.
name|width
operator|=
name|getc
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|icondirs
index|[
name|i
index|]
operator|.
name|height
operator|=
name|getc
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|icondirs
index|[
name|i
index|]
operator|.
name|colorcount
operator|=
name|getc
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|getc
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|icondirs
index|[
name|i
index|]
operator|.
name|u
operator|.
name|cursor
operator|.
name|xhotspot
operator|=
name|get_word
argument_list|(
name|e
argument_list|,
name|real_filename
argument_list|)
expr_stmt|;
name|icondirs
index|[
name|i
index|]
operator|.
name|u
operator|.
name|cursor
operator|.
name|yhotspot
operator|=
name|get_word
argument_list|(
name|e
argument_list|,
name|real_filename
argument_list|)
expr_stmt|;
name|icondirs
index|[
name|i
index|]
operator|.
name|bytes
operator|=
name|get_long
argument_list|(
name|e
argument_list|,
name|real_filename
argument_list|)
expr_stmt|;
name|icondirs
index|[
name|i
index|]
operator|.
name|offset
operator|=
name|get_long
argument_list|(
name|e
argument_list|,
name|real_filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|feof
argument_list|(
name|e
argument_list|)
condition|)
name|unexpected_eof
argument_list|(
name|real_filename
argument_list|)
expr_stmt|;
block|}
comment|/* Define each cursor as a unique resource.  */
name|first_cursor
operator|=
name|cursors
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|unsigned
name|char
modifier|*
name|data
decl_stmt|;
name|struct
name|res_id
name|name
decl_stmt|;
name|struct
name|cursor
modifier|*
name|c
decl_stmt|;
if|if
condition|(
name|fseek
argument_list|(
name|e
argument_list|,
name|icondirs
index|[
name|i
index|]
operator|.
name|offset
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
name|fatal
argument_list|(
literal|"%s: fseek to %lu failed: %s"
argument_list|,
name|real_filename
argument_list|,
name|icondirs
index|[
name|i
index|]
operator|.
name|offset
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|data
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|res_alloc
argument_list|(
name|icondirs
index|[
name|i
index|]
operator|.
name|bytes
argument_list|)
expr_stmt|;
name|get_data
argument_list|(
name|e
argument_list|,
name|data
argument_list|,
name|icondirs
index|[
name|i
index|]
operator|.
name|bytes
argument_list|,
name|real_filename
argument_list|)
expr_stmt|;
name|c
operator|=
operator|(
expr|struct
name|cursor
operator|*
operator|)
name|res_alloc
argument_list|(
sizeof|sizeof
expr|*
name|c
argument_list|)
expr_stmt|;
name|c
operator|->
name|xhotspot
operator|=
name|icondirs
index|[
name|i
index|]
operator|.
name|u
operator|.
name|cursor
operator|.
name|xhotspot
expr_stmt|;
name|c
operator|->
name|yhotspot
operator|=
name|icondirs
index|[
name|i
index|]
operator|.
name|u
operator|.
name|cursor
operator|.
name|yhotspot
expr_stmt|;
name|c
operator|->
name|length
operator|=
name|icondirs
index|[
name|i
index|]
operator|.
name|bytes
expr_stmt|;
name|c
operator|->
name|data
operator|=
name|data
expr_stmt|;
operator|++
name|cursors
expr_stmt|;
name|name
operator|.
name|named
operator|=
literal|0
expr_stmt|;
name|name
operator|.
name|u
operator|.
name|id
operator|=
name|cursors
expr_stmt|;
name|r
operator|=
name|define_standard_resource
argument_list|(
operator|&
name|resources
argument_list|,
name|RT_CURSOR
argument_list|,
name|name
argument_list|,
name|resinfo
operator|->
name|language
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|r
operator|->
name|type
operator|=
name|RES_TYPE_CURSOR
expr_stmt|;
name|r
operator|->
name|u
operator|.
name|cursor
operator|=
name|c
expr_stmt|;
name|r
operator|->
name|res_info
operator|=
operator|*
name|resinfo
expr_stmt|;
block|}
name|fclose
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|real_filename
argument_list|)
expr_stmt|;
comment|/* Define a cursor group resource.  */
name|first
operator|=
name|NULL
expr_stmt|;
name|pp
operator|=
operator|&
name|first
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|group_cursor
modifier|*
name|cg
decl_stmt|;
name|cg
operator|=
operator|(
expr|struct
name|group_cursor
operator|*
operator|)
name|res_alloc
argument_list|(
sizeof|sizeof
expr|*
name|cg
argument_list|)
expr_stmt|;
name|cg
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|cg
operator|->
name|width
operator|=
name|icondirs
index|[
name|i
index|]
operator|.
name|width
expr_stmt|;
name|cg
operator|->
name|height
operator|=
literal|2
operator|*
name|icondirs
index|[
name|i
index|]
operator|.
name|height
expr_stmt|;
comment|/* FIXME: What should these be set to?  */
name|cg
operator|->
name|planes
operator|=
literal|1
expr_stmt|;
name|cg
operator|->
name|bits
operator|=
literal|1
expr_stmt|;
name|cg
operator|->
name|bytes
operator|=
name|icondirs
index|[
name|i
index|]
operator|.
name|bytes
operator|+
literal|4
expr_stmt|;
name|cg
operator|->
name|index
operator|=
name|first_cursor
operator|+
name|i
operator|+
literal|1
expr_stmt|;
operator|*
name|pp
operator|=
name|cg
expr_stmt|;
name|pp
operator|=
operator|&
operator|(
operator|*
name|pp
operator|)
operator|->
name|next
expr_stmt|;
block|}
name|free
argument_list|(
name|icondirs
argument_list|)
expr_stmt|;
name|r
operator|=
name|define_standard_resource
argument_list|(
operator|&
name|resources
argument_list|,
name|RT_GROUP_CURSOR
argument_list|,
name|id
argument_list|,
name|resinfo
operator|->
name|language
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|r
operator|->
name|type
operator|=
name|RES_TYPE_GROUP_CURSOR
expr_stmt|;
name|r
operator|->
name|u
operator|.
name|group_cursor
operator|=
name|first
expr_stmt|;
name|r
operator|->
name|res_info
operator|=
operator|*
name|resinfo
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Define a dialog resource.  */
end_comment

begin_function
name|void
name|define_dialog
parameter_list|(
name|id
parameter_list|,
name|resinfo
parameter_list|,
name|dialog
parameter_list|)
name|struct
name|res_id
name|id
decl_stmt|;
specifier|const
name|struct
name|res_res_info
modifier|*
name|resinfo
decl_stmt|;
specifier|const
name|struct
name|dialog
modifier|*
name|dialog
decl_stmt|;
block|{
name|struct
name|dialog
modifier|*
name|copy
decl_stmt|;
name|struct
name|res_resource
modifier|*
name|r
decl_stmt|;
name|copy
operator|=
operator|(
expr|struct
name|dialog
operator|*
operator|)
name|res_alloc
argument_list|(
sizeof|sizeof
expr|*
name|copy
argument_list|)
expr_stmt|;
operator|*
name|copy
operator|=
operator|*
name|dialog
expr_stmt|;
name|r
operator|=
name|define_standard_resource
argument_list|(
operator|&
name|resources
argument_list|,
name|RT_DIALOG
argument_list|,
name|id
argument_list|,
name|resinfo
operator|->
name|language
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|r
operator|->
name|type
operator|=
name|RES_TYPE_DIALOG
expr_stmt|;
name|r
operator|->
name|u
operator|.
name|dialog
operator|=
name|copy
expr_stmt|;
name|r
operator|->
name|res_info
operator|=
operator|*
name|resinfo
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Define a dialog control.  This does not define a resource, but    merely allocates and fills in a structure.  */
end_comment

begin_function
name|struct
name|dialog_control
modifier|*
name|define_control
parameter_list|(
name|text
parameter_list|,
name|id
parameter_list|,
name|x
parameter_list|,
name|y
parameter_list|,
name|width
parameter_list|,
name|height
parameter_list|,
name|class
parameter_list|,
name|style
parameter_list|,
name|exstyle
parameter_list|)
specifier|const
name|char
modifier|*
name|text
decl_stmt|;
name|unsigned
name|long
name|id
decl_stmt|;
name|unsigned
name|long
name|x
decl_stmt|;
name|unsigned
name|long
name|y
decl_stmt|;
name|unsigned
name|long
name|width
decl_stmt|;
name|unsigned
name|long
name|height
decl_stmt|;
name|unsigned
name|long
name|class
decl_stmt|;
name|unsigned
name|long
name|style
decl_stmt|;
name|unsigned
name|long
name|exstyle
decl_stmt|;
block|{
name|struct
name|dialog_control
modifier|*
name|n
decl_stmt|;
name|n
operator|=
operator|(
expr|struct
name|dialog_control
operator|*
operator|)
name|res_alloc
argument_list|(
sizeof|sizeof
expr|*
name|n
argument_list|)
expr_stmt|;
name|n
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|n
operator|->
name|id
operator|=
name|id
expr_stmt|;
name|n
operator|->
name|style
operator|=
name|style
expr_stmt|;
name|n
operator|->
name|exstyle
operator|=
name|exstyle
expr_stmt|;
name|n
operator|->
name|x
operator|=
name|x
expr_stmt|;
name|n
operator|->
name|y
operator|=
name|y
expr_stmt|;
name|n
operator|->
name|width
operator|=
name|width
expr_stmt|;
name|n
operator|->
name|height
operator|=
name|height
expr_stmt|;
name|n
operator|->
name|class
operator|.
name|named
operator|=
literal|0
expr_stmt|;
name|n
operator|->
name|class
operator|.
name|u
operator|.
name|id
operator|=
name|class
expr_stmt|;
if|if
condition|(
name|text
operator|!=
name|NULL
condition|)
name|res_string_to_id
argument_list|(
operator|&
name|n
operator|->
name|text
argument_list|,
name|text
argument_list|)
expr_stmt|;
else|else
block|{
name|n
operator|->
name|text
operator|.
name|named
operator|=
literal|0
expr_stmt|;
name|n
operator|->
name|text
operator|.
name|u
operator|.
name|id
operator|=
literal|0
expr_stmt|;
block|}
name|n
operator|->
name|data
operator|=
name|NULL
expr_stmt|;
name|n
operator|->
name|help
operator|=
literal|0
expr_stmt|;
return|return
name|n
return|;
block|}
end_function

begin_comment
comment|/* Define a font resource.  */
end_comment

begin_function
name|void
name|define_font
parameter_list|(
name|id
parameter_list|,
name|resinfo
parameter_list|,
name|filename
parameter_list|)
name|struct
name|res_id
name|id
decl_stmt|;
specifier|const
name|struct
name|res_res_info
modifier|*
name|resinfo
decl_stmt|;
specifier|const
name|char
modifier|*
name|filename
decl_stmt|;
block|{
name|FILE
modifier|*
name|e
decl_stmt|;
name|char
modifier|*
name|real_filename
decl_stmt|;
name|struct
name|stat
name|s
decl_stmt|;
name|unsigned
name|char
modifier|*
name|data
decl_stmt|;
name|struct
name|res_resource
modifier|*
name|r
decl_stmt|;
name|long
name|offset
decl_stmt|;
name|long
name|fontdatalength
decl_stmt|;
name|unsigned
name|char
modifier|*
name|fontdata
decl_stmt|;
name|struct
name|fontdir
modifier|*
name|fd
decl_stmt|;
specifier|const
name|char
modifier|*
name|device
decl_stmt|,
modifier|*
name|face
decl_stmt|;
name|struct
name|fontdir
modifier|*
modifier|*
name|pp
decl_stmt|;
name|e
operator|=
name|open_file_search
argument_list|(
name|filename
argument_list|,
name|FOPEN_RB
argument_list|,
literal|"font file"
argument_list|,
operator|&
name|real_filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|real_filename
argument_list|,
operator|&
name|s
argument_list|)
operator|<
literal|0
condition|)
name|fatal
argument_list|(
literal|"stat failed on bitmap file `%s': %s"
argument_list|,
name|real_filename
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|data
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|res_alloc
argument_list|(
name|s
operator|.
name|st_size
argument_list|)
expr_stmt|;
name|get_data
argument_list|(
name|e
argument_list|,
name|data
argument_list|,
name|s
operator|.
name|st_size
argument_list|,
name|real_filename
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|real_filename
argument_list|)
expr_stmt|;
name|r
operator|=
name|define_standard_resource
argument_list|(
operator|&
name|resources
argument_list|,
name|RT_FONT
argument_list|,
name|id
argument_list|,
name|resinfo
operator|->
name|language
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|r
operator|->
name|type
operator|=
name|RES_TYPE_FONT
expr_stmt|;
name|r
operator|->
name|u
operator|.
name|data
operator|.
name|length
operator|=
name|s
operator|.
name|st_size
expr_stmt|;
name|r
operator|->
name|u
operator|.
name|data
operator|.
name|data
operator|=
name|data
expr_stmt|;
name|r
operator|->
name|res_info
operator|=
operator|*
name|resinfo
expr_stmt|;
comment|/* For each font resource, we must add an entry in the FONTDIR      resource.  The FONTDIR resource includes some strings in the font      file.  To find them, we have to do some magic on the data we have      read.  */
name|offset
operator|=
operator|(
operator|(
operator|(
operator|(
operator|(
operator|(
name|data
index|[
literal|47
index|]
operator|<<
literal|8
operator|)
operator||
name|data
index|[
literal|46
index|]
operator|)
operator|<<
literal|8
operator|)
operator||
name|data
index|[
literal|45
index|]
operator|)
operator|<<
literal|8
operator|)
operator||
name|data
index|[
literal|44
index|]
operator|)
expr_stmt|;
if|if
condition|(
name|offset
operator|>
literal|0
operator|&&
name|offset
operator|<
name|s
operator|.
name|st_size
condition|)
name|device
operator|=
operator|(
name|char
operator|*
operator|)
name|data
operator|+
name|offset
expr_stmt|;
else|else
name|device
operator|=
literal|""
expr_stmt|;
name|offset
operator|=
operator|(
operator|(
operator|(
operator|(
operator|(
operator|(
name|data
index|[
literal|51
index|]
operator|<<
literal|8
operator|)
operator||
name|data
index|[
literal|50
index|]
operator|)
operator|<<
literal|8
operator|)
operator||
name|data
index|[
literal|49
index|]
operator|)
operator|<<
literal|8
operator|)
operator||
name|data
index|[
literal|48
index|]
operator|)
expr_stmt|;
if|if
condition|(
name|offset
operator|>
literal|0
operator|&&
name|offset
operator|<
name|s
operator|.
name|st_size
condition|)
name|face
operator|=
operator|(
name|char
operator|*
operator|)
name|data
operator|+
name|offset
expr_stmt|;
else|else
name|face
operator|=
literal|""
expr_stmt|;
operator|++
name|fonts
expr_stmt|;
name|fontdatalength
operator|=
literal|58
operator|+
name|strlen
argument_list|(
name|device
argument_list|)
operator|+
name|strlen
argument_list|(
name|face
argument_list|)
expr_stmt|;
name|fontdata
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|res_alloc
argument_list|(
name|fontdatalength
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|fontdata
argument_list|,
name|data
argument_list|,
literal|56
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|fontdata
operator|+
literal|56
argument_list|,
name|device
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|fontdata
operator|+
literal|57
operator|+
name|strlen
argument_list|(
name|device
argument_list|)
argument_list|,
name|face
argument_list|)
expr_stmt|;
name|fd
operator|=
operator|(
expr|struct
name|fontdir
operator|*
operator|)
name|res_alloc
argument_list|(
sizeof|sizeof
expr|*
name|fd
argument_list|)
expr_stmt|;
name|fd
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|fd
operator|->
name|index
operator|=
name|fonts
expr_stmt|;
name|fd
operator|->
name|length
operator|=
name|fontdatalength
expr_stmt|;
name|fd
operator|->
name|data
operator|=
name|fontdata
expr_stmt|;
for|for
control|(
name|pp
operator|=
operator|&
name|fontdirs
init|;
operator|*
name|pp
operator|!=
name|NULL
condition|;
name|pp
operator|=
operator|&
operator|(
operator|*
name|pp
operator|)
operator|->
name|next
control|)
empty_stmt|;
operator|*
name|pp
operator|=
name|fd
expr_stmt|;
comment|/* For the single fontdirs resource, we always use the resource      information of the last font.  I don't know what else to do.  */
name|fontdirs_resinfo
operator|=
operator|*
name|resinfo
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Define the fontdirs resource.  This is called after the entire rc    file has been parsed, if any font resources were seen.  */
end_comment

begin_function
specifier|static
name|void
name|define_fontdirs
parameter_list|()
block|{
name|struct
name|res_resource
modifier|*
name|r
decl_stmt|;
name|struct
name|res_id
name|id
decl_stmt|;
name|id
operator|.
name|named
operator|=
literal|0
expr_stmt|;
name|id
operator|.
name|u
operator|.
name|id
operator|=
literal|1
expr_stmt|;
name|r
operator|=
name|define_standard_resource
argument_list|(
operator|&
name|resources
argument_list|,
name|RT_FONTDIR
argument_list|,
name|id
argument_list|,
literal|0x409
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|r
operator|->
name|type
operator|=
name|RES_TYPE_FONTDIR
expr_stmt|;
name|r
operator|->
name|u
operator|.
name|fontdir
operator|=
name|fontdirs
expr_stmt|;
name|r
operator|->
name|res_info
operator|=
name|fontdirs_resinfo
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Define an icon resource.  An icon file may contain a set of    bitmaps, each representing the same icon at various different    resolutions.  They each get written out with a different ID.  The    real icon resource is then a group resource which can be used to    select one of the actual icon bitmaps.  */
end_comment

begin_function
name|void
name|define_icon
parameter_list|(
name|id
parameter_list|,
name|resinfo
parameter_list|,
name|filename
parameter_list|)
name|struct
name|res_id
name|id
decl_stmt|;
specifier|const
name|struct
name|res_res_info
modifier|*
name|resinfo
decl_stmt|;
specifier|const
name|char
modifier|*
name|filename
decl_stmt|;
block|{
name|FILE
modifier|*
name|e
decl_stmt|;
name|char
modifier|*
name|real_filename
decl_stmt|;
name|int
name|type
decl_stmt|,
name|count
decl_stmt|,
name|i
decl_stmt|;
name|struct
name|icondir
modifier|*
name|icondirs
decl_stmt|;
name|int
name|first_icon
decl_stmt|;
name|struct
name|res_resource
modifier|*
name|r
decl_stmt|;
name|struct
name|group_icon
modifier|*
name|first
decl_stmt|,
modifier|*
modifier|*
name|pp
decl_stmt|;
name|e
operator|=
name|open_file_search
argument_list|(
name|filename
argument_list|,
name|FOPEN_RB
argument_list|,
literal|"icon file"
argument_list|,
operator|&
name|real_filename
argument_list|)
expr_stmt|;
comment|/* The start of an icon file is a three word structure.  The first      word is ignored.  The second word is the type of data.  The third      word is the number of entries.  */
name|get_word
argument_list|(
name|e
argument_list|,
name|real_filename
argument_list|)
expr_stmt|;
name|type
operator|=
name|get_word
argument_list|(
name|e
argument_list|,
name|real_filename
argument_list|)
expr_stmt|;
name|count
operator|=
name|get_word
argument_list|(
name|e
argument_list|,
name|real_filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|!=
literal|1
condition|)
name|fatal
argument_list|(
literal|"icon file `%s' does not contain icon data"
argument_list|,
name|real_filename
argument_list|)
expr_stmt|;
comment|/* Read in the icon directory entries.  */
name|icondirs
operator|=
operator|(
expr|struct
name|icondir
operator|*
operator|)
name|xmalloc
argument_list|(
name|count
operator|*
sizeof|sizeof
expr|*
name|icondirs
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|icondirs
index|[
name|i
index|]
operator|.
name|width
operator|=
name|getc
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|icondirs
index|[
name|i
index|]
operator|.
name|height
operator|=
name|getc
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|icondirs
index|[
name|i
index|]
operator|.
name|colorcount
operator|=
name|getc
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|getc
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|icondirs
index|[
name|i
index|]
operator|.
name|u
operator|.
name|icon
operator|.
name|planes
operator|=
name|get_word
argument_list|(
name|e
argument_list|,
name|real_filename
argument_list|)
expr_stmt|;
name|icondirs
index|[
name|i
index|]
operator|.
name|u
operator|.
name|icon
operator|.
name|bits
operator|=
name|get_word
argument_list|(
name|e
argument_list|,
name|real_filename
argument_list|)
expr_stmt|;
name|icondirs
index|[
name|i
index|]
operator|.
name|bytes
operator|=
name|get_long
argument_list|(
name|e
argument_list|,
name|real_filename
argument_list|)
expr_stmt|;
name|icondirs
index|[
name|i
index|]
operator|.
name|offset
operator|=
name|get_long
argument_list|(
name|e
argument_list|,
name|real_filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|feof
argument_list|(
name|e
argument_list|)
condition|)
name|unexpected_eof
argument_list|(
name|real_filename
argument_list|)
expr_stmt|;
block|}
comment|/* Define each icon as a unique resource.  */
name|first_icon
operator|=
name|icons
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|unsigned
name|char
modifier|*
name|data
decl_stmt|;
name|struct
name|res_id
name|name
decl_stmt|;
if|if
condition|(
name|fseek
argument_list|(
name|e
argument_list|,
name|icondirs
index|[
name|i
index|]
operator|.
name|offset
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
name|fatal
argument_list|(
literal|"%s: fseek to %lu failed: %s"
argument_list|,
name|real_filename
argument_list|,
name|icondirs
index|[
name|i
index|]
operator|.
name|offset
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|data
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|res_alloc
argument_list|(
name|icondirs
index|[
name|i
index|]
operator|.
name|bytes
argument_list|)
expr_stmt|;
name|get_data
argument_list|(
name|e
argument_list|,
name|data
argument_list|,
name|icondirs
index|[
name|i
index|]
operator|.
name|bytes
argument_list|,
name|real_filename
argument_list|)
expr_stmt|;
operator|++
name|icons
expr_stmt|;
name|name
operator|.
name|named
operator|=
literal|0
expr_stmt|;
name|name
operator|.
name|u
operator|.
name|id
operator|=
name|icons
expr_stmt|;
name|r
operator|=
name|define_standard_resource
argument_list|(
operator|&
name|resources
argument_list|,
name|RT_ICON
argument_list|,
name|name
argument_list|,
name|resinfo
operator|->
name|language
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|r
operator|->
name|type
operator|=
name|RES_TYPE_ICON
expr_stmt|;
name|r
operator|->
name|u
operator|.
name|data
operator|.
name|length
operator|=
name|icondirs
index|[
name|i
index|]
operator|.
name|bytes
expr_stmt|;
name|r
operator|->
name|u
operator|.
name|data
operator|.
name|data
operator|=
name|data
expr_stmt|;
name|r
operator|->
name|res_info
operator|=
operator|*
name|resinfo
expr_stmt|;
block|}
name|fclose
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|real_filename
argument_list|)
expr_stmt|;
comment|/* Define an icon group resource.  */
name|first
operator|=
name|NULL
expr_stmt|;
name|pp
operator|=
operator|&
name|first
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|group_icon
modifier|*
name|cg
decl_stmt|;
comment|/* For some reason, at least in some files the planes and bits          are zero.  We instead set them from the color.  This is          copied from rcl.  */
name|cg
operator|=
operator|(
expr|struct
name|group_icon
operator|*
operator|)
name|res_alloc
argument_list|(
sizeof|sizeof
expr|*
name|cg
argument_list|)
expr_stmt|;
name|cg
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|cg
operator|->
name|width
operator|=
name|icondirs
index|[
name|i
index|]
operator|.
name|width
expr_stmt|;
name|cg
operator|->
name|height
operator|=
name|icondirs
index|[
name|i
index|]
operator|.
name|height
expr_stmt|;
name|cg
operator|->
name|colors
operator|=
name|icondirs
index|[
name|i
index|]
operator|.
name|colorcount
expr_stmt|;
name|cg
operator|->
name|planes
operator|=
literal|1
expr_stmt|;
name|cg
operator|->
name|bits
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
literal|1
operator|<<
name|cg
operator|->
name|bits
operator|)
operator|<
name|cg
operator|->
name|colors
condition|)
operator|++
name|cg
operator|->
name|bits
expr_stmt|;
name|cg
operator|->
name|bytes
operator|=
name|icondirs
index|[
name|i
index|]
operator|.
name|bytes
expr_stmt|;
name|cg
operator|->
name|index
operator|=
name|first_icon
operator|+
name|i
operator|+
literal|1
expr_stmt|;
operator|*
name|pp
operator|=
name|cg
expr_stmt|;
name|pp
operator|=
operator|&
operator|(
operator|*
name|pp
operator|)
operator|->
name|next
expr_stmt|;
block|}
name|free
argument_list|(
name|icondirs
argument_list|)
expr_stmt|;
name|r
operator|=
name|define_standard_resource
argument_list|(
operator|&
name|resources
argument_list|,
name|RT_GROUP_ICON
argument_list|,
name|id
argument_list|,
name|resinfo
operator|->
name|language
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|r
operator|->
name|type
operator|=
name|RES_TYPE_GROUP_ICON
expr_stmt|;
name|r
operator|->
name|u
operator|.
name|group_icon
operator|=
name|first
expr_stmt|;
name|r
operator|->
name|res_info
operator|=
operator|*
name|resinfo
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Define a menu resource.  */
end_comment

begin_function
name|void
name|define_menu
parameter_list|(
name|id
parameter_list|,
name|resinfo
parameter_list|,
name|menuitems
parameter_list|)
name|struct
name|res_id
name|id
decl_stmt|;
specifier|const
name|struct
name|res_res_info
modifier|*
name|resinfo
decl_stmt|;
name|struct
name|menuitem
modifier|*
name|menuitems
decl_stmt|;
block|{
name|struct
name|menu
modifier|*
name|m
decl_stmt|;
name|struct
name|res_resource
modifier|*
name|r
decl_stmt|;
name|m
operator|=
operator|(
expr|struct
name|menu
operator|*
operator|)
name|res_alloc
argument_list|(
sizeof|sizeof
expr|*
name|m
argument_list|)
expr_stmt|;
name|m
operator|->
name|items
operator|=
name|menuitems
expr_stmt|;
name|m
operator|->
name|help
operator|=
literal|0
expr_stmt|;
name|r
operator|=
name|define_standard_resource
argument_list|(
operator|&
name|resources
argument_list|,
name|RT_MENU
argument_list|,
name|id
argument_list|,
name|resinfo
operator|->
name|language
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|r
operator|->
name|type
operator|=
name|RES_TYPE_MENU
expr_stmt|;
name|r
operator|->
name|u
operator|.
name|menu
operator|=
name|m
expr_stmt|;
name|r
operator|->
name|res_info
operator|=
operator|*
name|resinfo
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Define a menu item.  This does not define a resource, but merely    allocates and fills in a structure.  */
end_comment

begin_function
name|struct
name|menuitem
modifier|*
name|define_menuitem
parameter_list|(
name|text
parameter_list|,
name|menuid
parameter_list|,
name|type
parameter_list|,
name|state
parameter_list|,
name|help
parameter_list|,
name|menuitems
parameter_list|)
specifier|const
name|char
modifier|*
name|text
decl_stmt|;
name|int
name|menuid
decl_stmt|;
name|unsigned
name|long
name|type
decl_stmt|;
name|unsigned
name|long
name|state
decl_stmt|;
name|unsigned
name|long
name|help
decl_stmt|;
name|struct
name|menuitem
modifier|*
name|menuitems
decl_stmt|;
block|{
name|struct
name|menuitem
modifier|*
name|mi
decl_stmt|;
name|mi
operator|=
operator|(
expr|struct
name|menuitem
operator|*
operator|)
name|res_alloc
argument_list|(
sizeof|sizeof
expr|*
name|mi
argument_list|)
expr_stmt|;
name|mi
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|mi
operator|->
name|type
operator|=
name|type
expr_stmt|;
name|mi
operator|->
name|state
operator|=
name|state
expr_stmt|;
name|mi
operator|->
name|id
operator|=
name|menuid
expr_stmt|;
if|if
condition|(
name|text
operator|==
name|NULL
condition|)
name|mi
operator|->
name|text
operator|=
name|NULL
expr_stmt|;
else|else
name|unicode_from_ascii
argument_list|(
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|,
operator|&
name|mi
operator|->
name|text
argument_list|,
name|text
argument_list|)
expr_stmt|;
name|mi
operator|->
name|help
operator|=
name|help
expr_stmt|;
name|mi
operator|->
name|popup
operator|=
name|menuitems
expr_stmt|;
return|return
name|mi
return|;
block|}
end_function

begin_comment
comment|/* Define a messagetable resource.  */
end_comment

begin_function
name|void
name|define_messagetable
parameter_list|(
name|id
parameter_list|,
name|resinfo
parameter_list|,
name|filename
parameter_list|)
name|struct
name|res_id
name|id
decl_stmt|;
specifier|const
name|struct
name|res_res_info
modifier|*
name|resinfo
decl_stmt|;
specifier|const
name|char
modifier|*
name|filename
decl_stmt|;
block|{
name|FILE
modifier|*
name|e
decl_stmt|;
name|char
modifier|*
name|real_filename
decl_stmt|;
name|struct
name|stat
name|s
decl_stmt|;
name|unsigned
name|char
modifier|*
name|data
decl_stmt|;
name|struct
name|res_resource
modifier|*
name|r
decl_stmt|;
name|e
operator|=
name|open_file_search
argument_list|(
name|filename
argument_list|,
name|FOPEN_RB
argument_list|,
literal|"messagetable file"
argument_list|,
operator|&
name|real_filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|real_filename
argument_list|,
operator|&
name|s
argument_list|)
operator|<
literal|0
condition|)
name|fatal
argument_list|(
literal|"stat failed on bitmap file `%s': %s"
argument_list|,
name|real_filename
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|data
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|res_alloc
argument_list|(
name|s
operator|.
name|st_size
argument_list|)
expr_stmt|;
name|get_data
argument_list|(
name|e
argument_list|,
name|data
argument_list|,
name|s
operator|.
name|st_size
argument_list|,
name|real_filename
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|real_filename
argument_list|)
expr_stmt|;
name|r
operator|=
name|define_standard_resource
argument_list|(
operator|&
name|resources
argument_list|,
name|RT_MESSAGETABLE
argument_list|,
name|id
argument_list|,
name|resinfo
operator|->
name|language
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|r
operator|->
name|type
operator|=
name|RES_TYPE_MESSAGETABLE
expr_stmt|;
name|r
operator|->
name|u
operator|.
name|data
operator|.
name|length
operator|=
name|s
operator|.
name|st_size
expr_stmt|;
name|r
operator|->
name|u
operator|.
name|data
operator|.
name|data
operator|=
name|data
expr_stmt|;
name|r
operator|->
name|res_info
operator|=
operator|*
name|resinfo
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Define an rcdata resource.  */
end_comment

begin_function
name|void
name|define_rcdata
parameter_list|(
name|id
parameter_list|,
name|resinfo
parameter_list|,
name|data
parameter_list|)
name|struct
name|res_id
name|id
decl_stmt|;
specifier|const
name|struct
name|res_res_info
modifier|*
name|resinfo
decl_stmt|;
name|struct
name|rcdata_item
modifier|*
name|data
decl_stmt|;
block|{
name|struct
name|res_resource
modifier|*
name|r
decl_stmt|;
name|r
operator|=
name|define_standard_resource
argument_list|(
operator|&
name|resources
argument_list|,
name|RT_RCDATA
argument_list|,
name|id
argument_list|,
name|resinfo
operator|->
name|language
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|r
operator|->
name|type
operator|=
name|RES_TYPE_RCDATA
expr_stmt|;
name|r
operator|->
name|u
operator|.
name|rcdata
operator|=
name|data
expr_stmt|;
name|r
operator|->
name|res_info
operator|=
operator|*
name|resinfo
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Create an rcdata item holding a string.  */
end_comment

begin_function
name|struct
name|rcdata_item
modifier|*
name|define_rcdata_string
parameter_list|(
name|string
parameter_list|,
name|len
parameter_list|)
specifier|const
name|char
modifier|*
name|string
decl_stmt|;
name|unsigned
name|long
name|len
decl_stmt|;
block|{
name|struct
name|rcdata_item
modifier|*
name|ri
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
name|ri
operator|=
operator|(
expr|struct
name|rcdata_item
operator|*
operator|)
name|res_alloc
argument_list|(
sizeof|sizeof
expr|*
name|ri
argument_list|)
expr_stmt|;
name|ri
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|ri
operator|->
name|type
operator|=
name|RCDATA_STRING
expr_stmt|;
name|ri
operator|->
name|u
operator|.
name|string
operator|.
name|length
operator|=
name|len
expr_stmt|;
name|s
operator|=
operator|(
name|char
operator|*
operator|)
name|res_alloc
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|s
argument_list|,
name|string
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|ri
operator|->
name|u
operator|.
name|string
operator|.
name|s
operator|=
name|s
expr_stmt|;
return|return
name|ri
return|;
block|}
end_function

begin_comment
comment|/* Create an rcdata item holding a number.  */
end_comment

begin_function
name|struct
name|rcdata_item
modifier|*
name|define_rcdata_number
parameter_list|(
name|val
parameter_list|,
name|dword
parameter_list|)
name|unsigned
name|long
name|val
decl_stmt|;
name|int
name|dword
decl_stmt|;
block|{
name|struct
name|rcdata_item
modifier|*
name|ri
decl_stmt|;
name|ri
operator|=
operator|(
expr|struct
name|rcdata_item
operator|*
operator|)
name|res_alloc
argument_list|(
sizeof|sizeof
expr|*
name|ri
argument_list|)
expr_stmt|;
name|ri
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|ri
operator|->
name|type
operator|=
name|dword
condition|?
name|RCDATA_DWORD
else|:
name|RCDATA_WORD
expr_stmt|;
name|ri
operator|->
name|u
operator|.
name|word
operator|=
name|val
expr_stmt|;
return|return
name|ri
return|;
block|}
end_function

begin_comment
comment|/* Define a stringtable resource.  This is called for each string    which appears in a STRINGTABLE statement.  */
end_comment

begin_function
name|void
name|define_stringtable
parameter_list|(
name|resinfo
parameter_list|,
name|stringid
parameter_list|,
name|string
parameter_list|)
specifier|const
name|struct
name|res_res_info
modifier|*
name|resinfo
decl_stmt|;
name|unsigned
name|long
name|stringid
decl_stmt|;
specifier|const
name|char
modifier|*
name|string
decl_stmt|;
block|{
name|struct
name|res_id
name|id
decl_stmt|;
name|struct
name|res_resource
modifier|*
name|r
decl_stmt|;
name|id
operator|.
name|named
operator|=
literal|0
expr_stmt|;
name|id
operator|.
name|u
operator|.
name|id
operator|=
operator|(
name|stringid
operator|>>
literal|4
operator|)
operator|+
literal|1
expr_stmt|;
name|r
operator|=
name|define_standard_resource
argument_list|(
operator|&
name|resources
argument_list|,
name|RT_STRING
argument_list|,
name|id
argument_list|,
name|resinfo
operator|->
name|language
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|type
operator|==
name|RES_TYPE_UNINITIALIZED
condition|)
block|{
name|int
name|i
decl_stmt|;
name|r
operator|->
name|type
operator|=
name|RES_TYPE_STRINGTABLE
expr_stmt|;
name|r
operator|->
name|u
operator|.
name|stringtable
operator|=
operator|(
operator|(
expr|struct
name|stringtable
operator|*
operator|)
name|res_alloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|stringtable
argument_list|)
argument_list|)
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
block|{
name|r
operator|->
name|u
operator|.
name|stringtable
operator|->
name|strings
index|[
name|i
index|]
operator|.
name|length
operator|=
literal|0
expr_stmt|;
name|r
operator|->
name|u
operator|.
name|stringtable
operator|->
name|strings
index|[
name|i
index|]
operator|.
name|string
operator|=
name|NULL
expr_stmt|;
block|}
name|r
operator|->
name|res_info
operator|=
operator|*
name|resinfo
expr_stmt|;
block|}
name|unicode_from_ascii
argument_list|(
operator|&
name|r
operator|->
name|u
operator|.
name|stringtable
operator|->
name|strings
index|[
name|stringid
operator|&
literal|0xf
index|]
operator|.
name|length
argument_list|,
operator|&
name|r
operator|->
name|u
operator|.
name|stringtable
operator|->
name|strings
index|[
name|stringid
operator|&
literal|0xf
index|]
operator|.
name|string
argument_list|,
name|string
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Define a user data resource where the data is in the rc file.  */
end_comment

begin_function
name|void
name|define_user_data
parameter_list|(
name|id
parameter_list|,
name|type
parameter_list|,
name|resinfo
parameter_list|,
name|data
parameter_list|)
name|struct
name|res_id
name|id
decl_stmt|;
name|struct
name|res_id
name|type
decl_stmt|;
specifier|const
name|struct
name|res_res_info
modifier|*
name|resinfo
decl_stmt|;
name|struct
name|rcdata_item
modifier|*
name|data
decl_stmt|;
block|{
name|struct
name|res_id
name|ids
index|[
literal|3
index|]
decl_stmt|;
name|struct
name|res_resource
modifier|*
name|r
decl_stmt|;
name|ids
index|[
literal|0
index|]
operator|=
name|type
expr_stmt|;
name|ids
index|[
literal|1
index|]
operator|=
name|id
expr_stmt|;
name|ids
index|[
literal|2
index|]
operator|.
name|named
operator|=
literal|0
expr_stmt|;
name|ids
index|[
literal|2
index|]
operator|.
name|u
operator|.
name|id
operator|=
name|resinfo
operator|->
name|language
expr_stmt|;
name|r
operator|=
name|define_resource
argument_list|(
operator|&
name|resources
argument_list|,
literal|3
argument_list|,
name|ids
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|r
operator|->
name|type
operator|=
name|RES_TYPE_USERDATA
expr_stmt|;
name|r
operator|->
name|u
operator|.
name|userdata
operator|=
name|data
expr_stmt|;
name|r
operator|->
name|res_info
operator|=
operator|*
name|resinfo
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Define a user data resource where the data is in a file.  */
end_comment

begin_function
name|void
name|define_user_file
parameter_list|(
name|id
parameter_list|,
name|type
parameter_list|,
name|resinfo
parameter_list|,
name|filename
parameter_list|)
name|struct
name|res_id
name|id
decl_stmt|;
name|struct
name|res_id
name|type
decl_stmt|;
specifier|const
name|struct
name|res_res_info
modifier|*
name|resinfo
decl_stmt|;
specifier|const
name|char
modifier|*
name|filename
decl_stmt|;
block|{
name|FILE
modifier|*
name|e
decl_stmt|;
name|char
modifier|*
name|real_filename
decl_stmt|;
name|struct
name|stat
name|s
decl_stmt|;
name|unsigned
name|char
modifier|*
name|data
decl_stmt|;
name|struct
name|res_id
name|ids
index|[
literal|3
index|]
decl_stmt|;
name|struct
name|res_resource
modifier|*
name|r
decl_stmt|;
name|e
operator|=
name|open_file_search
argument_list|(
name|filename
argument_list|,
name|FOPEN_RB
argument_list|,
literal|"font file"
argument_list|,
operator|&
name|real_filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|real_filename
argument_list|,
operator|&
name|s
argument_list|)
operator|<
literal|0
condition|)
name|fatal
argument_list|(
literal|"stat failed on bitmap file `%s': %s"
argument_list|,
name|real_filename
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|data
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|res_alloc
argument_list|(
name|s
operator|.
name|st_size
argument_list|)
expr_stmt|;
name|get_data
argument_list|(
name|e
argument_list|,
name|data
argument_list|,
name|s
operator|.
name|st_size
argument_list|,
name|real_filename
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|real_filename
argument_list|)
expr_stmt|;
name|ids
index|[
literal|0
index|]
operator|=
name|type
expr_stmt|;
name|ids
index|[
literal|1
index|]
operator|=
name|id
expr_stmt|;
name|ids
index|[
literal|2
index|]
operator|.
name|named
operator|=
literal|0
expr_stmt|;
name|ids
index|[
literal|2
index|]
operator|.
name|u
operator|.
name|id
operator|=
name|resinfo
operator|->
name|language
expr_stmt|;
name|r
operator|=
name|define_resource
argument_list|(
operator|&
name|resources
argument_list|,
literal|3
argument_list|,
name|ids
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|r
operator|->
name|type
operator|=
name|RES_TYPE_USERDATA
expr_stmt|;
name|r
operator|->
name|u
operator|.
name|userdata
operator|=
operator|(
operator|(
expr|struct
name|rcdata_item
operator|*
operator|)
name|res_alloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|rcdata_item
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|r
operator|->
name|u
operator|.
name|userdata
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|r
operator|->
name|u
operator|.
name|userdata
operator|->
name|type
operator|=
name|RCDATA_BUFFER
expr_stmt|;
name|r
operator|->
name|u
operator|.
name|userdata
operator|->
name|u
operator|.
name|buffer
operator|.
name|length
operator|=
name|s
operator|.
name|st_size
expr_stmt|;
name|r
operator|->
name|u
operator|.
name|userdata
operator|->
name|u
operator|.
name|buffer
operator|.
name|data
operator|=
name|data
expr_stmt|;
name|r
operator|->
name|res_info
operator|=
operator|*
name|resinfo
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Define a versioninfo resource.  */
end_comment

begin_function
name|void
name|define_versioninfo
parameter_list|(
name|id
parameter_list|,
name|language
parameter_list|,
name|fixedverinfo
parameter_list|,
name|verinfo
parameter_list|)
name|struct
name|res_id
name|id
decl_stmt|;
name|int
name|language
decl_stmt|;
name|struct
name|fixed_versioninfo
modifier|*
name|fixedverinfo
decl_stmt|;
name|struct
name|ver_info
modifier|*
name|verinfo
decl_stmt|;
block|{
name|struct
name|res_resource
modifier|*
name|r
decl_stmt|;
name|r
operator|=
name|define_standard_resource
argument_list|(
operator|&
name|resources
argument_list|,
name|RT_VERSION
argument_list|,
name|id
argument_list|,
name|language
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|r
operator|->
name|type
operator|=
name|RES_TYPE_VERSIONINFO
expr_stmt|;
name|r
operator|->
name|u
operator|.
name|versioninfo
operator|=
operator|(
operator|(
expr|struct
name|versioninfo
operator|*
operator|)
name|res_alloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|versioninfo
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|r
operator|->
name|u
operator|.
name|versioninfo
operator|->
name|fixed
operator|=
name|fixedverinfo
expr_stmt|;
name|r
operator|->
name|u
operator|.
name|versioninfo
operator|->
name|var
operator|=
name|verinfo
expr_stmt|;
name|r
operator|->
name|res_info
operator|.
name|language
operator|=
name|language
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add string version info to a list of version information.  */
end_comment

begin_function
name|struct
name|ver_info
modifier|*
name|append_ver_stringfileinfo
parameter_list|(
name|verinfo
parameter_list|,
name|language
parameter_list|,
name|strings
parameter_list|)
name|struct
name|ver_info
modifier|*
name|verinfo
decl_stmt|;
specifier|const
name|char
modifier|*
name|language
decl_stmt|;
name|struct
name|ver_stringinfo
modifier|*
name|strings
decl_stmt|;
block|{
name|struct
name|ver_info
modifier|*
name|vi
decl_stmt|,
modifier|*
modifier|*
name|pp
decl_stmt|;
name|vi
operator|=
operator|(
expr|struct
name|ver_info
operator|*
operator|)
name|res_alloc
argument_list|(
sizeof|sizeof
expr|*
name|vi
argument_list|)
expr_stmt|;
name|vi
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|vi
operator|->
name|type
operator|=
name|VERINFO_STRING
expr_stmt|;
name|unicode_from_ascii
argument_list|(
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|,
operator|&
name|vi
operator|->
name|u
operator|.
name|string
operator|.
name|language
argument_list|,
name|language
argument_list|)
expr_stmt|;
name|vi
operator|->
name|u
operator|.
name|string
operator|.
name|strings
operator|=
name|strings
expr_stmt|;
for|for
control|(
name|pp
operator|=
operator|&
name|verinfo
init|;
operator|*
name|pp
operator|!=
name|NULL
condition|;
name|pp
operator|=
operator|&
operator|(
operator|*
name|pp
operator|)
operator|->
name|next
control|)
empty_stmt|;
operator|*
name|pp
operator|=
name|vi
expr_stmt|;
return|return
name|verinfo
return|;
block|}
end_function

begin_comment
comment|/* Add variable version info to a list of version information.  */
end_comment

begin_function
name|struct
name|ver_info
modifier|*
name|append_ver_varfileinfo
parameter_list|(
name|verinfo
parameter_list|,
name|key
parameter_list|,
name|var
parameter_list|)
name|struct
name|ver_info
modifier|*
name|verinfo
decl_stmt|;
specifier|const
name|char
modifier|*
name|key
decl_stmt|;
name|struct
name|ver_varinfo
modifier|*
name|var
decl_stmt|;
block|{
name|struct
name|ver_info
modifier|*
name|vi
decl_stmt|,
modifier|*
modifier|*
name|pp
decl_stmt|;
name|vi
operator|=
operator|(
expr|struct
name|ver_info
operator|*
operator|)
name|res_alloc
argument_list|(
sizeof|sizeof
expr|*
name|vi
argument_list|)
expr_stmt|;
name|vi
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|vi
operator|->
name|type
operator|=
name|VERINFO_VAR
expr_stmt|;
name|unicode_from_ascii
argument_list|(
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|,
operator|&
name|vi
operator|->
name|u
operator|.
name|var
operator|.
name|key
argument_list|,
name|key
argument_list|)
expr_stmt|;
name|vi
operator|->
name|u
operator|.
name|var
operator|.
name|var
operator|=
name|var
expr_stmt|;
for|for
control|(
name|pp
operator|=
operator|&
name|verinfo
init|;
operator|*
name|pp
operator|!=
name|NULL
condition|;
name|pp
operator|=
operator|&
operator|(
operator|*
name|pp
operator|)
operator|->
name|next
control|)
empty_stmt|;
operator|*
name|pp
operator|=
name|vi
expr_stmt|;
return|return
name|verinfo
return|;
block|}
end_function

begin_comment
comment|/* Append version string information to a list.  */
end_comment

begin_function
name|struct
name|ver_stringinfo
modifier|*
name|append_verval
parameter_list|(
name|strings
parameter_list|,
name|key
parameter_list|,
name|value
parameter_list|)
name|struct
name|ver_stringinfo
modifier|*
name|strings
decl_stmt|;
specifier|const
name|char
modifier|*
name|key
decl_stmt|;
specifier|const
name|char
modifier|*
name|value
decl_stmt|;
block|{
name|struct
name|ver_stringinfo
modifier|*
name|vs
decl_stmt|,
modifier|*
modifier|*
name|pp
decl_stmt|;
name|vs
operator|=
operator|(
expr|struct
name|ver_stringinfo
operator|*
operator|)
name|res_alloc
argument_list|(
sizeof|sizeof
expr|*
name|vs
argument_list|)
expr_stmt|;
name|vs
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|unicode_from_ascii
argument_list|(
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|,
operator|&
name|vs
operator|->
name|key
argument_list|,
name|key
argument_list|)
expr_stmt|;
name|unicode_from_ascii
argument_list|(
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|,
operator|&
name|vs
operator|->
name|value
argument_list|,
name|value
argument_list|)
expr_stmt|;
for|for
control|(
name|pp
operator|=
operator|&
name|strings
init|;
operator|*
name|pp
operator|!=
name|NULL
condition|;
name|pp
operator|=
operator|&
operator|(
operator|*
name|pp
operator|)
operator|->
name|next
control|)
empty_stmt|;
operator|*
name|pp
operator|=
name|vs
expr_stmt|;
return|return
name|strings
return|;
block|}
end_function

begin_comment
comment|/* Append version variable information to a list.  */
end_comment

begin_function
name|struct
name|ver_varinfo
modifier|*
name|append_vertrans
parameter_list|(
name|var
parameter_list|,
name|language
parameter_list|,
name|charset
parameter_list|)
name|struct
name|ver_varinfo
modifier|*
name|var
decl_stmt|;
name|unsigned
name|long
name|language
decl_stmt|;
name|unsigned
name|long
name|charset
decl_stmt|;
block|{
name|struct
name|ver_varinfo
modifier|*
name|vv
decl_stmt|,
modifier|*
modifier|*
name|pp
decl_stmt|;
name|vv
operator|=
operator|(
expr|struct
name|ver_varinfo
operator|*
operator|)
name|res_alloc
argument_list|(
sizeof|sizeof
expr|*
name|vv
argument_list|)
expr_stmt|;
name|vv
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|vv
operator|->
name|language
operator|=
name|language
expr_stmt|;
name|vv
operator|->
name|charset
operator|=
name|charset
expr_stmt|;
for|for
control|(
name|pp
operator|=
operator|&
name|var
init|;
operator|*
name|pp
operator|!=
name|NULL
condition|;
name|pp
operator|=
operator|&
operator|(
operator|*
name|pp
operator|)
operator|->
name|next
control|)
empty_stmt|;
operator|*
name|pp
operator|=
name|vv
expr_stmt|;
return|return
name|var
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Local functions used to write out an rc file.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|indent
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|write_rc_directory
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|,
specifier|const
expr|struct
name|res_directory
operator|*
operator|,
specifier|const
expr|struct
name|res_id
operator|*
operator|,
specifier|const
expr|struct
name|res_id
operator|*
operator|,
name|int
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|write_rc_subdir
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|,
specifier|const
expr|struct
name|res_entry
operator|*
operator|,
specifier|const
expr|struct
name|res_id
operator|*
operator|,
specifier|const
expr|struct
name|res_id
operator|*
operator|,
name|int
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|write_rc_resource
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|,
specifier|const
expr|struct
name|res_id
operator|*
operator|,
specifier|const
expr|struct
name|res_id
operator|*
operator|,
specifier|const
expr|struct
name|res_resource
operator|*
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|write_rc_accelerators
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|,
specifier|const
expr|struct
name|accelerator
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|write_rc_cursor
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|,
specifier|const
expr|struct
name|cursor
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|write_rc_group_cursor
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|,
specifier|const
expr|struct
name|group_cursor
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|write_rc_dialog
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|,
specifier|const
expr|struct
name|dialog
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|write_rc_dialog_control
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|,
specifier|const
expr|struct
name|dialog_control
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|write_rc_fontdir
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|,
specifier|const
expr|struct
name|fontdir
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|write_rc_group_icon
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|,
specifier|const
expr|struct
name|group_icon
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|write_rc_menu
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|,
specifier|const
expr|struct
name|menu
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|write_rc_menuitems
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|,
specifier|const
expr|struct
name|menuitem
operator|*
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|write_rc_rcdata
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|,
specifier|const
expr|struct
name|rcdata_item
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|write_rc_stringtable
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|,
specifier|const
expr|struct
name|res_id
operator|*
operator|,
specifier|const
expr|struct
name|stringtable
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|write_rc_versioninfo
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|,
specifier|const
expr|struct
name|versioninfo
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|write_rc_filedata
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|,
name|unsigned
name|long
operator|,
specifier|const
name|unsigned
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Indent a given number of spaces.  */
end_comment

begin_function
specifier|static
name|void
name|indent
parameter_list|(
name|e
parameter_list|,
name|c
parameter_list|)
name|FILE
modifier|*
name|e
decl_stmt|;
name|int
name|c
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|c
condition|;
name|i
operator|++
control|)
name|putc
argument_list|(
literal|' '
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Dump the resources we have read in the format of an rc file.     Actually, we don't use the format of an rc file, because it's way    too much of a pain--for example, we'd have to write icon resources    into a file and refer to that file.  We just generate a readable    format that kind of looks like an rc file, and is useful for    understanding the contents of a resource file.  Someday we may want    to generate an rc file which the rc compiler can read; if that day    comes, this code will have to be fixed up.  */
end_comment

begin_function
name|void
name|write_rc_file
parameter_list|(
name|filename
parameter_list|,
name|resources
parameter_list|)
specifier|const
name|char
modifier|*
name|filename
decl_stmt|;
specifier|const
name|struct
name|res_directory
modifier|*
name|resources
decl_stmt|;
block|{
name|FILE
modifier|*
name|e
decl_stmt|;
name|int
name|language
decl_stmt|;
if|if
condition|(
name|filename
operator|==
name|NULL
condition|)
name|e
operator|=
name|stdout
expr_stmt|;
else|else
block|{
name|e
operator|=
name|fopen
argument_list|(
name|filename
argument_list|,
name|FOPEN_WT
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
literal|"can't open `%s' for output: %s"
argument_list|,
name|filename
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|language
operator|=
operator|-
literal|1
expr_stmt|;
name|write_rc_directory
argument_list|(
name|e
argument_list|,
name|resources
argument_list|,
operator|(
specifier|const
expr|struct
name|res_id
operator|*
operator|)
name|NULL
argument_list|,
operator|(
specifier|const
expr|struct
name|res_id
operator|*
operator|)
name|NULL
argument_list|,
operator|&
name|language
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Write out a directory.  E is the file to write to.  RD is the    directory.  TYPE is a pointer to the level 1 ID which serves as the    resource type.  NAME is a pointer to the level 2 ID which serves as    an individual resource name.  LANGUAGE is a pointer to the current    language.  LEVEL is the level in the tree.  */
end_comment

begin_function
specifier|static
name|void
name|write_rc_directory
parameter_list|(
name|e
parameter_list|,
name|rd
parameter_list|,
name|type
parameter_list|,
name|name
parameter_list|,
name|language
parameter_list|,
name|level
parameter_list|)
name|FILE
modifier|*
name|e
decl_stmt|;
specifier|const
name|struct
name|res_directory
modifier|*
name|rd
decl_stmt|;
specifier|const
name|struct
name|res_id
modifier|*
name|type
decl_stmt|;
specifier|const
name|struct
name|res_id
modifier|*
name|name
decl_stmt|;
name|int
modifier|*
name|language
decl_stmt|;
name|int
name|level
decl_stmt|;
block|{
specifier|const
name|struct
name|res_entry
modifier|*
name|re
decl_stmt|;
comment|/* Print out some COFF information that rc files can't represent.  */
if|if
condition|(
name|rd
operator|->
name|time
operator|!=
literal|0
condition|)
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"// Time stamp: %lu\n"
argument_list|,
name|rd
operator|->
name|time
argument_list|)
expr_stmt|;
if|if
condition|(
name|rd
operator|->
name|characteristics
operator|!=
literal|0
condition|)
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"// Characteristics: %lu\n"
argument_list|,
name|rd
operator|->
name|characteristics
argument_list|)
expr_stmt|;
if|if
condition|(
name|rd
operator|->
name|major
operator|!=
literal|0
operator|||
name|rd
operator|->
name|minor
operator|!=
literal|0
condition|)
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"// Version: %d %d\n"
argument_list|,
name|rd
operator|->
name|major
argument_list|,
name|rd
operator|->
name|minor
argument_list|)
expr_stmt|;
for|for
control|(
name|re
operator|=
name|rd
operator|->
name|entries
init|;
name|re
operator|!=
name|NULL
condition|;
name|re
operator|=
name|re
operator|->
name|next
control|)
block|{
switch|switch
condition|(
name|level
condition|)
block|{
case|case
literal|1
case|:
comment|/* If we're at level 1, the key of this resource is the              type.  This normally duplicates the information we have              stored with the resource itself, but we need to remember              the type if this is a user define resource type.  */
name|type
operator|=
operator|&
name|re
operator|->
name|id
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|/* If we're at level 2, the key of this resource is the name 	     we are going to use in the rc printout. */
name|name
operator|=
operator|&
name|re
operator|->
name|id
expr_stmt|;
break|break;
case|case
literal|3
case|:
comment|/* If we're at level 3, then this key represents a language. 	     Use it to update the current language.  */
if|if
condition|(
operator|!
name|re
operator|->
name|id
operator|.
name|named
operator|&&
name|re
operator|->
name|id
operator|.
name|u
operator|.
name|id
operator|!=
operator|*
name|language
operator|&&
operator|(
name|re
operator|->
name|id
operator|.
name|u
operator|.
name|id
operator|&
literal|0xffff
operator|)
operator|==
name|re
operator|->
name|id
operator|.
name|u
operator|.
name|id
condition|)
block|{
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"LANGUAGE %lu, %lu\n"
argument_list|,
name|re
operator|->
name|id
operator|.
name|u
operator|.
name|id
operator|&
literal|0xff
argument_list|,
operator|(
name|re
operator|->
name|id
operator|.
name|u
operator|.
name|id
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
operator|*
name|language
operator|=
name|re
operator|->
name|id
operator|.
name|u
operator|.
name|id
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
if|if
condition|(
name|re
operator|->
name|subdir
condition|)
name|write_rc_subdir
argument_list|(
name|e
argument_list|,
name|re
argument_list|,
name|type
argument_list|,
name|name
argument_list|,
name|language
argument_list|,
name|level
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|level
operator|==
literal|3
condition|)
block|{
comment|/* This is the normal case: the three levels are                  TYPE/NAME/LANGUAGE.  NAME will have been set at level                  2, and represents the name to use.  We probably just                  set LANGUAGE, and it will probably match what the                  resource itself records if anything.  */
name|write_rc_resource
argument_list|(
name|e
argument_list|,
name|type
argument_list|,
name|name
argument_list|,
name|re
operator|->
name|u
operator|.
name|res
argument_list|,
name|language
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"// Resource at unexpected level %d\n"
argument_list|,
name|level
argument_list|)
expr_stmt|;
name|write_rc_resource
argument_list|(
name|e
argument_list|,
name|type
argument_list|,
operator|(
expr|struct
name|res_id
operator|*
operator|)
name|NULL
argument_list|,
name|re
operator|->
name|u
operator|.
name|res
argument_list|,
name|language
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* Write out a subdirectory entry.  E is the file to write to.  RE is    the subdirectory entry.  TYPE and NAME are pointers to higher level    IDs, or NULL.  LANGUAGE is a pointer to the current language.    LEVEL is the level in the tree.  */
end_comment

begin_function
specifier|static
name|void
name|write_rc_subdir
parameter_list|(
name|e
parameter_list|,
name|re
parameter_list|,
name|type
parameter_list|,
name|name
parameter_list|,
name|language
parameter_list|,
name|level
parameter_list|)
name|FILE
modifier|*
name|e
decl_stmt|;
specifier|const
name|struct
name|res_entry
modifier|*
name|re
decl_stmt|;
specifier|const
name|struct
name|res_id
modifier|*
name|type
decl_stmt|;
specifier|const
name|struct
name|res_id
modifier|*
name|name
decl_stmt|;
name|int
modifier|*
name|language
decl_stmt|;
name|int
name|level
decl_stmt|;
block|{
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|level
condition|)
block|{
case|case
literal|1
case|:
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"// Type: "
argument_list|)
expr_stmt|;
if|if
condition|(
name|re
operator|->
name|id
operator|.
name|named
condition|)
name|res_id_print
argument_list|(
name|e
argument_list|,
name|re
operator|->
name|id
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
block|{
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
switch|switch
condition|(
name|re
operator|->
name|id
operator|.
name|u
operator|.
name|id
condition|)
block|{
case|case
name|RT_CURSOR
case|:
name|s
operator|=
literal|"cursor"
expr_stmt|;
break|break;
case|case
name|RT_BITMAP
case|:
name|s
operator|=
literal|"bitmap"
expr_stmt|;
break|break;
case|case
name|RT_ICON
case|:
name|s
operator|=
literal|"icon"
expr_stmt|;
break|break;
case|case
name|RT_MENU
case|:
name|s
operator|=
literal|"menu"
expr_stmt|;
break|break;
case|case
name|RT_DIALOG
case|:
name|s
operator|=
literal|"dialog"
expr_stmt|;
break|break;
case|case
name|RT_STRING
case|:
name|s
operator|=
literal|"stringtable"
expr_stmt|;
break|break;
case|case
name|RT_FONTDIR
case|:
name|s
operator|=
literal|"fontdir"
expr_stmt|;
break|break;
case|case
name|RT_FONT
case|:
name|s
operator|=
literal|"font"
expr_stmt|;
break|break;
case|case
name|RT_ACCELERATORS
case|:
name|s
operator|=
literal|"accelerators"
expr_stmt|;
break|break;
case|case
name|RT_RCDATA
case|:
name|s
operator|=
literal|"rcdata"
expr_stmt|;
break|break;
case|case
name|RT_MESSAGETABLE
case|:
name|s
operator|=
literal|"messagetable"
expr_stmt|;
break|break;
case|case
name|RT_GROUP_CURSOR
case|:
name|s
operator|=
literal|"group cursor"
expr_stmt|;
break|break;
case|case
name|RT_GROUP_ICON
case|:
name|s
operator|=
literal|"group icon"
expr_stmt|;
break|break;
case|case
name|RT_VERSION
case|:
name|s
operator|=
literal|"version"
expr_stmt|;
break|break;
case|case
name|RT_DLGINCLUDE
case|:
name|s
operator|=
literal|"dlginclude"
expr_stmt|;
break|break;
case|case
name|RT_PLUGPLAY
case|:
name|s
operator|=
literal|"plugplay"
expr_stmt|;
break|break;
case|case
name|RT_VXD
case|:
name|s
operator|=
literal|"vxd"
expr_stmt|;
break|break;
case|case
name|RT_ANICURSOR
case|:
name|s
operator|=
literal|"anicursor"
expr_stmt|;
break|break;
case|case
name|RT_ANIICON
case|:
name|s
operator|=
literal|"aniicon"
expr_stmt|;
break|break;
default|default:
name|s
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|s
operator|!=
name|NULL
condition|)
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"%s"
argument_list|,
name|s
argument_list|)
expr_stmt|;
else|else
name|res_id_print
argument_list|(
name|e
argument_list|,
name|re
operator|->
name|id
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"// Name: "
argument_list|)
expr_stmt|;
name|res_id_print
argument_list|(
name|e
argument_list|,
name|re
operator|->
name|id
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"// Language: "
argument_list|)
expr_stmt|;
name|res_id_print
argument_list|(
name|e
argument_list|,
name|re
operator|->
name|id
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"// Level %d: "
argument_list|,
name|level
argument_list|)
expr_stmt|;
name|res_id_print
argument_list|(
name|e
argument_list|,
name|re
operator|->
name|id
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|write_rc_directory
argument_list|(
name|e
argument_list|,
name|re
operator|->
name|u
operator|.
name|dir
argument_list|,
name|type
argument_list|,
name|name
argument_list|,
name|language
argument_list|,
name|level
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Write out a single resource.  E is the file to write to.  TYPE is a    pointer to the type of the resource.  NAME is a pointer to the name    of the resource; it will be NULL if there is a level mismatch.  RES    is the resource data.  LANGUAGE is a pointer to the current    language.  */
end_comment

begin_function
specifier|static
name|void
name|write_rc_resource
parameter_list|(
name|e
parameter_list|,
name|type
parameter_list|,
name|name
parameter_list|,
name|res
parameter_list|,
name|language
parameter_list|)
name|FILE
modifier|*
name|e
decl_stmt|;
specifier|const
name|struct
name|res_id
modifier|*
name|type
decl_stmt|;
specifier|const
name|struct
name|res_id
modifier|*
name|name
decl_stmt|;
specifier|const
name|struct
name|res_resource
modifier|*
name|res
decl_stmt|;
name|int
modifier|*
name|language
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|rt
decl_stmt|;
name|int
name|menuex
init|=
literal|0
decl_stmt|;
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|res
operator|->
name|type
condition|)
block|{
default|default:
name|abort
argument_list|()
expr_stmt|;
case|case
name|RES_TYPE_ACCELERATOR
case|:
name|s
operator|=
literal|"ACCELERATOR"
expr_stmt|;
name|rt
operator|=
name|RT_ACCELERATORS
expr_stmt|;
break|break;
case|case
name|RES_TYPE_BITMAP
case|:
name|s
operator|=
literal|"BITMAP"
expr_stmt|;
name|rt
operator|=
name|RT_BITMAP
expr_stmt|;
break|break;
case|case
name|RES_TYPE_CURSOR
case|:
name|s
operator|=
literal|"CURSOR"
expr_stmt|;
name|rt
operator|=
name|RT_CURSOR
expr_stmt|;
break|break;
case|case
name|RES_TYPE_GROUP_CURSOR
case|:
name|s
operator|=
literal|"GROUP_CURSOR"
expr_stmt|;
name|rt
operator|=
name|RT_GROUP_CURSOR
expr_stmt|;
break|break;
case|case
name|RES_TYPE_DIALOG
case|:
if|if
condition|(
name|extended_dialog
argument_list|(
name|res
operator|->
name|u
operator|.
name|dialog
argument_list|)
condition|)
name|s
operator|=
literal|"DIALOGEX"
expr_stmt|;
else|else
name|s
operator|=
literal|"DIALOG"
expr_stmt|;
name|rt
operator|=
name|RT_DIALOG
expr_stmt|;
break|break;
case|case
name|RES_TYPE_FONT
case|:
name|s
operator|=
literal|"FONT"
expr_stmt|;
name|rt
operator|=
name|RT_FONT
expr_stmt|;
break|break;
case|case
name|RES_TYPE_FONTDIR
case|:
name|s
operator|=
literal|"FONTDIR"
expr_stmt|;
name|rt
operator|=
name|RT_FONTDIR
expr_stmt|;
break|break;
case|case
name|RES_TYPE_ICON
case|:
name|s
operator|=
literal|"ICON"
expr_stmt|;
name|rt
operator|=
name|RT_ICON
expr_stmt|;
break|break;
case|case
name|RES_TYPE_GROUP_ICON
case|:
name|s
operator|=
literal|"GROUP_ICON"
expr_stmt|;
name|rt
operator|=
name|RT_GROUP_ICON
expr_stmt|;
break|break;
case|case
name|RES_TYPE_MENU
case|:
if|if
condition|(
name|extended_menu
argument_list|(
name|res
operator|->
name|u
operator|.
name|menu
argument_list|)
condition|)
block|{
name|s
operator|=
literal|"MENUEX"
expr_stmt|;
name|menuex
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|s
operator|=
literal|"MENU"
expr_stmt|;
name|menuex
operator|=
literal|0
expr_stmt|;
block|}
name|rt
operator|=
name|RT_MENU
expr_stmt|;
break|break;
case|case
name|RES_TYPE_MESSAGETABLE
case|:
name|s
operator|=
literal|"MESSAGETABLE"
expr_stmt|;
name|rt
operator|=
name|RT_MESSAGETABLE
expr_stmt|;
break|break;
case|case
name|RES_TYPE_RCDATA
case|:
name|s
operator|=
literal|"RCDATA"
expr_stmt|;
name|rt
operator|=
name|RT_RCDATA
expr_stmt|;
break|break;
case|case
name|RES_TYPE_STRINGTABLE
case|:
name|s
operator|=
literal|"STRINGTABLE"
expr_stmt|;
name|rt
operator|=
name|RT_STRING
expr_stmt|;
break|break;
case|case
name|RES_TYPE_USERDATA
case|:
name|s
operator|=
name|NULL
expr_stmt|;
name|rt
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|RES_TYPE_VERSIONINFO
case|:
name|s
operator|=
literal|"VERSIONINFO"
expr_stmt|;
name|rt
operator|=
name|RT_VERSION
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|rt
operator|!=
literal|0
operator|&&
name|type
operator|!=
name|NULL
operator|&&
operator|(
name|type
operator|->
name|named
operator|||
name|type
operator|->
name|u
operator|.
name|id
operator|!=
name|rt
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"// Unexpected resource type mismatch: "
argument_list|)
expr_stmt|;
name|res_id_print
argument_list|(
name|e
argument_list|,
operator|*
name|type
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|e
argument_list|,
literal|" != %d"
argument_list|,
name|rt
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|res
operator|->
name|coff_info
operator|.
name|codepage
operator|!=
literal|0
condition|)
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"// Code page: %lu\n"
argument_list|,
name|res
operator|->
name|coff_info
operator|.
name|codepage
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|->
name|coff_info
operator|.
name|reserved
operator|!=
literal|0
condition|)
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"// COFF reserved value: %lu\n"
argument_list|,
name|res
operator|->
name|coff_info
operator|.
name|reserved
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|!=
name|NULL
condition|)
name|res_id_print
argument_list|(
name|e
argument_list|,
operator|*
name|name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"??Unknown-Name??"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|e
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
condition|)
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"%s"
argument_list|,
name|s
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|type
operator|!=
name|NULL
condition|)
name|res_id_print
argument_list|(
name|e
argument_list|,
operator|*
name|type
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"??Unknown-Type??"
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|->
name|res_info
operator|.
name|memflags
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|res
operator|->
name|res_info
operator|.
name|memflags
operator|&
name|MEMFLAG_MOVEABLE
operator|)
operator|!=
literal|0
condition|)
name|fprintf
argument_list|(
name|e
argument_list|,
literal|" MOVEABLE"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|res
operator|->
name|res_info
operator|.
name|memflags
operator|&
name|MEMFLAG_PURE
operator|)
operator|!=
literal|0
condition|)
name|fprintf
argument_list|(
name|e
argument_list|,
literal|" PURE"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|res
operator|->
name|res_info
operator|.
name|memflags
operator|&
name|MEMFLAG_PRELOAD
operator|)
operator|!=
literal|0
condition|)
name|fprintf
argument_list|(
name|e
argument_list|,
literal|" PRELOAD"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|res
operator|->
name|res_info
operator|.
name|memflags
operator|&
name|MEMFLAG_DISCARDABLE
operator|)
operator|!=
literal|0
condition|)
name|fprintf
argument_list|(
name|e
argument_list|,
literal|" DISCARDABLE"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|res
operator|->
name|type
operator|==
name|RES_TYPE_DIALOG
condition|)
block|{
name|fprintf
argument_list|(
name|e
argument_list|,
literal|" %d, %d, %d, %d"
argument_list|,
name|res
operator|->
name|u
operator|.
name|dialog
operator|->
name|x
argument_list|,
name|res
operator|->
name|u
operator|.
name|dialog
operator|->
name|y
argument_list|,
name|res
operator|->
name|u
operator|.
name|dialog
operator|->
name|width
argument_list|,
name|res
operator|->
name|u
operator|.
name|dialog
operator|->
name|height
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|->
name|u
operator|.
name|dialog
operator|->
name|ex
operator|!=
name|NULL
operator|&&
name|res
operator|->
name|u
operator|.
name|dialog
operator|->
name|ex
operator|->
name|help
operator|!=
literal|0
condition|)
name|fprintf
argument_list|(
name|e
argument_list|,
literal|", %lu"
argument_list|,
name|res
operator|->
name|u
operator|.
name|dialog
operator|->
name|ex
operator|->
name|help
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|res
operator|->
name|res_info
operator|.
name|language
operator|!=
literal|0
operator|&&
name|res
operator|->
name|res_info
operator|.
name|language
operator|!=
operator|*
name|language
operator|)
operator|||
name|res
operator|->
name|res_info
operator|.
name|characteristics
operator|!=
literal|0
operator|||
name|res
operator|->
name|res_info
operator|.
name|version
operator|!=
literal|0
condition|)
block|{
name|int
name|modifiers
decl_stmt|;
switch|switch
condition|(
name|res
operator|->
name|type
condition|)
block|{
case|case
name|RES_TYPE_ACCELERATOR
case|:
case|case
name|RES_TYPE_DIALOG
case|:
case|case
name|RES_TYPE_MENU
case|:
case|case
name|RES_TYPE_RCDATA
case|:
case|case
name|RES_TYPE_STRINGTABLE
case|:
name|modifiers
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
name|modifiers
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|res
operator|->
name|res_info
operator|.
name|language
operator|!=
literal|0
operator|&&
name|res
operator|->
name|res_info
operator|.
name|language
operator|!=
operator|*
name|language
condition|)
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"%sLANGUAGE %d, %d\n"
argument_list|,
name|modifiers
condition|?
literal|"// "
else|:
literal|""
argument_list|,
name|res
operator|->
name|res_info
operator|.
name|language
operator|&
literal|0xff
argument_list|,
operator|(
name|res
operator|->
name|res_info
operator|.
name|language
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|->
name|res_info
operator|.
name|characteristics
operator|!=
literal|0
condition|)
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"%sCHARACTERISTICS %lu\n"
argument_list|,
name|modifiers
condition|?
literal|"// "
else|:
literal|""
argument_list|,
name|res
operator|->
name|res_info
operator|.
name|characteristics
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|->
name|res_info
operator|.
name|version
operator|!=
literal|0
condition|)
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"%sVERSION %lu\n"
argument_list|,
name|modifiers
condition|?
literal|"// "
else|:
literal|""
argument_list|,
name|res
operator|->
name|res_info
operator|.
name|version
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|res
operator|->
name|type
condition|)
block|{
default|default:
name|abort
argument_list|()
expr_stmt|;
case|case
name|RES_TYPE_ACCELERATOR
case|:
name|write_rc_accelerators
argument_list|(
name|e
argument_list|,
name|res
operator|->
name|u
operator|.
name|acc
argument_list|)
expr_stmt|;
break|break;
case|case
name|RES_TYPE_CURSOR
case|:
name|write_rc_cursor
argument_list|(
name|e
argument_list|,
name|res
operator|->
name|u
operator|.
name|cursor
argument_list|)
expr_stmt|;
break|break;
case|case
name|RES_TYPE_GROUP_CURSOR
case|:
name|write_rc_group_cursor
argument_list|(
name|e
argument_list|,
name|res
operator|->
name|u
operator|.
name|group_cursor
argument_list|)
expr_stmt|;
break|break;
case|case
name|RES_TYPE_DIALOG
case|:
name|write_rc_dialog
argument_list|(
name|e
argument_list|,
name|res
operator|->
name|u
operator|.
name|dialog
argument_list|)
expr_stmt|;
break|break;
case|case
name|RES_TYPE_FONTDIR
case|:
name|write_rc_fontdir
argument_list|(
name|e
argument_list|,
name|res
operator|->
name|u
operator|.
name|fontdir
argument_list|)
expr_stmt|;
break|break;
case|case
name|RES_TYPE_GROUP_ICON
case|:
name|write_rc_group_icon
argument_list|(
name|e
argument_list|,
name|res
operator|->
name|u
operator|.
name|group_icon
argument_list|)
expr_stmt|;
break|break;
case|case
name|RES_TYPE_MENU
case|:
name|write_rc_menu
argument_list|(
name|e
argument_list|,
name|res
operator|->
name|u
operator|.
name|menu
argument_list|,
name|menuex
argument_list|)
expr_stmt|;
break|break;
case|case
name|RES_TYPE_RCDATA
case|:
name|write_rc_rcdata
argument_list|(
name|e
argument_list|,
name|res
operator|->
name|u
operator|.
name|rcdata
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|RES_TYPE_STRINGTABLE
case|:
name|write_rc_stringtable
argument_list|(
name|e
argument_list|,
name|name
argument_list|,
name|res
operator|->
name|u
operator|.
name|stringtable
argument_list|)
expr_stmt|;
break|break;
case|case
name|RES_TYPE_USERDATA
case|:
name|write_rc_rcdata
argument_list|(
name|e
argument_list|,
name|res
operator|->
name|u
operator|.
name|userdata
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|RES_TYPE_VERSIONINFO
case|:
name|write_rc_versioninfo
argument_list|(
name|e
argument_list|,
name|res
operator|->
name|u
operator|.
name|versioninfo
argument_list|)
expr_stmt|;
break|break;
case|case
name|RES_TYPE_BITMAP
case|:
case|case
name|RES_TYPE_FONT
case|:
case|case
name|RES_TYPE_ICON
case|:
case|case
name|RES_TYPE_MESSAGETABLE
case|:
name|write_rc_filedata
argument_list|(
name|e
argument_list|,
name|res
operator|->
name|u
operator|.
name|data
operator|.
name|length
argument_list|,
name|res
operator|->
name|u
operator|.
name|data
operator|.
name|data
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Write out accelerator information.  */
end_comment

begin_function
specifier|static
name|void
name|write_rc_accelerators
parameter_list|(
name|e
parameter_list|,
name|accelerators
parameter_list|)
name|FILE
modifier|*
name|e
decl_stmt|;
specifier|const
name|struct
name|accelerator
modifier|*
name|accelerators
decl_stmt|;
block|{
specifier|const
name|struct
name|accelerator
modifier|*
name|acc
decl_stmt|;
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"BEGIN\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|acc
operator|=
name|accelerators
init|;
name|acc
operator|!=
name|NULL
condition|;
name|acc
operator|=
name|acc
operator|->
name|next
control|)
block|{
name|int
name|printable
decl_stmt|;
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"  "
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|acc
operator|->
name|key
operator|&
literal|0x7f
operator|)
operator|==
name|acc
operator|->
name|key
operator|&&
name|isprint
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|acc
operator|->
name|key
argument_list|)
operator|&&
operator|(
name|acc
operator|->
name|flags
operator|&
name|ACC_VIRTKEY
operator|)
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"\"%c\""
argument_list|,
name|acc
operator|->
name|key
argument_list|)
expr_stmt|;
name|printable
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"%d"
argument_list|,
name|acc
operator|->
name|key
argument_list|)
expr_stmt|;
name|printable
operator|=
literal|0
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|e
argument_list|,
literal|", %d"
argument_list|,
name|acc
operator|->
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|printable
condition|)
block|{
if|if
condition|(
operator|(
name|acc
operator|->
name|flags
operator|&
name|ACC_VIRTKEY
operator|)
operator|!=
literal|0
condition|)
name|fprintf
argument_list|(
name|e
argument_list|,
literal|", VIRTKEY"
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|e
argument_list|,
literal|", ASCII"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|acc
operator|->
name|flags
operator|&
name|ACC_SHIFT
operator|)
operator|!=
literal|0
condition|)
name|fprintf
argument_list|(
name|e
argument_list|,
literal|", SHIFT"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|acc
operator|->
name|flags
operator|&
name|ACC_CONTROL
operator|)
operator|!=
literal|0
condition|)
name|fprintf
argument_list|(
name|e
argument_list|,
literal|", CONTROL"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|acc
operator|->
name|flags
operator|&
name|ACC_ALT
operator|)
operator|!=
literal|0
condition|)
name|fprintf
argument_list|(
name|e
argument_list|,
literal|", ALT"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"END\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Write out cursor information.  This would normally be in a separate    file, which the rc file would include.  */
end_comment

begin_function
specifier|static
name|void
name|write_rc_cursor
parameter_list|(
name|e
parameter_list|,
name|cursor
parameter_list|)
name|FILE
modifier|*
name|e
decl_stmt|;
specifier|const
name|struct
name|cursor
modifier|*
name|cursor
decl_stmt|;
block|{
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"// Hotspot: x: %d; y: %d\n"
argument_list|,
name|cursor
operator|->
name|xhotspot
argument_list|,
name|cursor
operator|->
name|yhotspot
argument_list|)
expr_stmt|;
name|write_rc_filedata
argument_list|(
name|e
argument_list|,
name|cursor
operator|->
name|length
argument_list|,
name|cursor
operator|->
name|data
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Write out group cursor data.  This would normally be built from the    cursor data.  */
end_comment

begin_function
specifier|static
name|void
name|write_rc_group_cursor
parameter_list|(
name|e
parameter_list|,
name|group_cursor
parameter_list|)
name|FILE
modifier|*
name|e
decl_stmt|;
specifier|const
name|struct
name|group_cursor
modifier|*
name|group_cursor
decl_stmt|;
block|{
specifier|const
name|struct
name|group_cursor
modifier|*
name|gc
decl_stmt|;
for|for
control|(
name|gc
operator|=
name|group_cursor
init|;
name|gc
operator|!=
name|NULL
condition|;
name|gc
operator|=
name|gc
operator|->
name|next
control|)
block|{
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"// width: %d; height %d; planes %d; bits %d\n"
argument_list|,
name|gc
operator|->
name|width
argument_list|,
name|gc
operator|->
name|height
argument_list|,
name|gc
operator|->
name|planes
argument_list|,
name|gc
operator|->
name|bits
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"// data bytes: %lu; index: %d\n"
argument_list|,
name|gc
operator|->
name|bytes
argument_list|,
name|gc
operator|->
name|index
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Write dialog data.  */
end_comment

begin_function
specifier|static
name|void
name|write_rc_dialog
parameter_list|(
name|e
parameter_list|,
name|dialog
parameter_list|)
name|FILE
modifier|*
name|e
decl_stmt|;
specifier|const
name|struct
name|dialog
modifier|*
name|dialog
decl_stmt|;
block|{
specifier|const
name|struct
name|dialog_control
modifier|*
name|control
decl_stmt|;
if|if
condition|(
name|dialog
operator|->
name|style
operator|!=
literal|0
condition|)
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"STYLE 0x%lx\n"
argument_list|,
name|dialog
operator|->
name|style
argument_list|)
expr_stmt|;
if|if
condition|(
name|dialog
operator|->
name|exstyle
operator|!=
literal|0
condition|)
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"EXSTYLE 0x%lx\n"
argument_list|,
name|dialog
operator|->
name|exstyle
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|dialog
operator|->
name|class
operator|.
name|named
operator|&&
name|dialog
operator|->
name|class
operator|.
name|u
operator|.
name|n
operator|.
name|length
operator|>
literal|0
operator|)
operator|||
name|dialog
operator|->
name|class
operator|.
name|u
operator|.
name|id
operator|!=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"CLASS "
argument_list|)
expr_stmt|;
name|res_id_print
argument_list|(
name|e
argument_list|,
name|dialog
operator|->
name|class
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dialog
operator|->
name|caption
operator|!=
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"CAPTION \""
argument_list|)
expr_stmt|;
name|unicode_print
argument_list|(
name|e
argument_list|,
name|dialog
operator|->
name|caption
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"\"\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|dialog
operator|->
name|menu
operator|.
name|named
operator|&&
name|dialog
operator|->
name|menu
operator|.
name|u
operator|.
name|n
operator|.
name|length
operator|>
literal|0
operator|)
operator|||
name|dialog
operator|->
name|menu
operator|.
name|u
operator|.
name|id
operator|!=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"MENU "
argument_list|)
expr_stmt|;
name|res_id_print
argument_list|(
name|e
argument_list|,
name|dialog
operator|->
name|menu
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dialog
operator|->
name|font
operator|!=
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"FONT %d, \""
argument_list|,
name|dialog
operator|->
name|pointsize
argument_list|)
expr_stmt|;
name|unicode_print
argument_list|(
name|e
argument_list|,
name|dialog
operator|->
name|font
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"\""
argument_list|)
expr_stmt|;
if|if
condition|(
name|dialog
operator|->
name|ex
operator|!=
name|NULL
operator|&&
operator|(
name|dialog
operator|->
name|ex
operator|->
name|weight
operator|!=
literal|0
operator|||
name|dialog
operator|->
name|ex
operator|->
name|italic
operator|!=
literal|0
operator|)
condition|)
name|fprintf
argument_list|(
name|e
argument_list|,
literal|", %d, %d"
argument_list|,
name|dialog
operator|->
name|ex
operator|->
name|weight
argument_list|,
name|dialog
operator|->
name|ex
operator|->
name|italic
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"BEGIN\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|control
operator|=
name|dialog
operator|->
name|controls
init|;
name|control
operator|!=
name|NULL
condition|;
name|control
operator|=
name|control
operator|->
name|next
control|)
name|write_rc_dialog_control
argument_list|(
name|e
argument_list|,
name|control
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"END\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* For each predefined control keyword, this table provides the class    and the style.  */
end_comment

begin_struct
struct|struct
name|control_info
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|unsigned
name|short
name|class
decl_stmt|;
name|unsigned
name|long
name|style
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|control_info
name|control_info
index|[]
init|=
block|{
block|{
literal|"AUTO3STATE"
block|,
name|CTL_BUTTON
block|,
name|BS_AUTO3STATE
block|}
block|,
block|{
literal|"AUTOCHECKBOX"
block|,
name|CTL_BUTTON
block|,
name|BS_AUTOCHECKBOX
block|}
block|,
block|{
literal|"AUTORADIOBUTTON"
block|,
name|CTL_BUTTON
block|,
name|BS_AUTORADIOBUTTON
block|}
block|,
block|{
literal|"CHECKBOX"
block|,
name|CTL_BUTTON
block|,
name|BS_CHECKBOX
block|}
block|,
block|{
literal|"COMBOBOX"
block|,
name|CTL_COMBOBOX
block|,
operator|(
name|unsigned
name|long
operator|)
operator|-
literal|1
block|}
block|,
block|{
literal|"CTEXT"
block|,
name|CTL_STATIC
block|,
name|SS_CENTER
block|}
block|,
block|{
literal|"DEFPUSHBUTTON"
block|,
name|CTL_BUTTON
block|,
name|BS_DEFPUSHBUTTON
block|}
block|,
block|{
literal|"EDITTEXT"
block|,
name|CTL_EDIT
block|,
operator|(
name|unsigned
name|long
operator|)
operator|-
literal|1
block|}
block|,
block|{
literal|"GROUPBOX"
block|,
name|CTL_BUTTON
block|,
name|BS_GROUPBOX
block|}
block|,
block|{
literal|"ICON"
block|,
name|CTL_STATIC
block|,
name|SS_ICON
block|}
block|,
block|{
literal|"LISTBOX"
block|,
name|CTL_LISTBOX
block|,
operator|(
name|unsigned
name|long
operator|)
operator|-
literal|1
block|}
block|,
block|{
literal|"LTEXT"
block|,
name|CTL_STATIC
block|,
name|SS_LEFT
block|}
block|,
block|{
literal|"PUSHBOX"
block|,
name|CTL_BUTTON
block|,
name|BS_PUSHBOX
block|}
block|,
block|{
literal|"PUSHBUTTON"
block|,
name|CTL_BUTTON
block|,
name|BS_PUSHBUTTON
block|}
block|,
block|{
literal|"RADIOBUTTON"
block|,
name|CTL_BUTTON
block|,
name|BS_RADIOBUTTON
block|}
block|,
block|{
literal|"RTEXT"
block|,
name|CTL_STATIC
block|,
name|SS_RIGHT
block|}
block|,
block|{
literal|"SCROLLBAR"
block|,
name|CTL_SCROLLBAR
block|,
operator|(
name|unsigned
name|long
operator|)
operator|-
literal|1
block|}
block|,
block|{
literal|"STATE3"
block|,
name|CTL_BUTTON
block|,
name|BS_3STATE
block|}
block|,
comment|/* It's important that USERBUTTON come after all the other button      types, so that it won't be matched too early.  */
block|{
literal|"USERBUTTON"
block|,
name|CTL_BUTTON
block|,
operator|(
name|unsigned
name|long
operator|)
operator|-
literal|1
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Write a dialog control.  */
end_comment

begin_function
specifier|static
name|void
name|write_rc_dialog_control
parameter_list|(
name|e
parameter_list|,
name|control
parameter_list|)
name|FILE
modifier|*
name|e
decl_stmt|;
specifier|const
name|struct
name|dialog_control
modifier|*
name|control
decl_stmt|;
block|{
specifier|const
name|struct
name|control_info
modifier|*
name|ci
decl_stmt|;
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"  "
argument_list|)
expr_stmt|;
if|if
condition|(
name|control
operator|->
name|class
operator|.
name|named
condition|)
name|ci
operator|=
name|NULL
expr_stmt|;
else|else
block|{
for|for
control|(
name|ci
operator|=
name|control_info
init|;
name|ci
operator|->
name|name
operator|!=
name|NULL
condition|;
operator|++
name|ci
control|)
if|if
condition|(
name|ci
operator|->
name|class
operator|==
name|control
operator|->
name|class
operator|.
name|u
operator|.
name|id
operator|&&
operator|(
name|ci
operator|->
name|style
operator|==
operator|(
name|unsigned
name|long
operator|)
operator|-
literal|1
operator|||
name|ci
operator|->
name|style
operator|==
operator|(
name|control
operator|->
name|style
operator|&
literal|0xff
operator|)
operator|)
condition|)
break|break;
block|}
if|if
condition|(
name|ci
operator|->
name|name
operator|!=
name|NULL
condition|)
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"%s"
argument_list|,
name|ci
operator|->
name|name
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"CONTROL"
argument_list|)
expr_stmt|;
if|if
condition|(
name|control
operator|->
name|text
operator|.
name|named
operator|||
name|control
operator|->
name|text
operator|.
name|u
operator|.
name|id
operator|!=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|e
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|res_id_print
argument_list|(
name|e
argument_list|,
name|control
operator|->
name|text
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|e
argument_list|,
literal|","
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|e
argument_list|,
literal|" %d, "
argument_list|,
name|control
operator|->
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|ci
operator|->
name|name
operator|==
name|NULL
condition|)
block|{
name|res_id_print
argument_list|(
name|e
argument_list|,
name|control
operator|->
name|class
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|e
argument_list|,
literal|", 0x%lx, "
argument_list|,
name|control
operator|->
name|style
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"%d, %d"
argument_list|,
name|control
operator|->
name|x
argument_list|,
name|control
operator|->
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
name|control
operator|->
name|style
operator|!=
name|SS_ICON
operator|||
name|control
operator|->
name|exstyle
operator|!=
literal|0
operator|||
name|control
operator|->
name|width
operator|!=
literal|0
operator|||
name|control
operator|->
name|height
operator|!=
literal|0
operator|||
name|control
operator|->
name|help
operator|!=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|e
argument_list|,
literal|", %d, %d"
argument_list|,
name|control
operator|->
name|width
argument_list|,
name|control
operator|->
name|height
argument_list|)
expr_stmt|;
comment|/* FIXME: We don't need to print the style if it is the default. 	 More importantly, in certain cases we actually need to turn 	 off parts of the forced style, by using NOT.  */
name|fprintf
argument_list|(
name|e
argument_list|,
literal|", 0x%lx"
argument_list|,
name|control
operator|->
name|style
argument_list|)
expr_stmt|;
if|if
condition|(
name|control
operator|->
name|exstyle
operator|!=
literal|0
operator|||
name|control
operator|->
name|help
operator|!=
literal|0
condition|)
name|fprintf
argument_list|(
name|e
argument_list|,
literal|", 0x%lx, %lu"
argument_list|,
name|control
operator|->
name|exstyle
argument_list|,
name|control
operator|->
name|help
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|control
operator|->
name|data
operator|!=
name|NULL
condition|)
name|write_rc_rcdata
argument_list|(
name|e
argument_list|,
name|control
operator|->
name|data
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Write out font directory data.  This would normally be built from    the font data.  */
end_comment

begin_function
specifier|static
name|void
name|write_rc_fontdir
parameter_list|(
name|e
parameter_list|,
name|fontdir
parameter_list|)
name|FILE
modifier|*
name|e
decl_stmt|;
specifier|const
name|struct
name|fontdir
modifier|*
name|fontdir
decl_stmt|;
block|{
specifier|const
name|struct
name|fontdir
modifier|*
name|fc
decl_stmt|;
for|for
control|(
name|fc
operator|=
name|fontdir
init|;
name|fc
operator|!=
name|NULL
condition|;
name|fc
operator|=
name|fc
operator|->
name|next
control|)
block|{
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"// Font index: %d\n"
argument_list|,
name|fc
operator|->
name|index
argument_list|)
expr_stmt|;
name|write_rc_filedata
argument_list|(
name|e
argument_list|,
name|fc
operator|->
name|length
argument_list|,
name|fc
operator|->
name|data
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Write out group icon data.  This would normally be built from the    icon data.  */
end_comment

begin_function
specifier|static
name|void
name|write_rc_group_icon
parameter_list|(
name|e
parameter_list|,
name|group_icon
parameter_list|)
name|FILE
modifier|*
name|e
decl_stmt|;
specifier|const
name|struct
name|group_icon
modifier|*
name|group_icon
decl_stmt|;
block|{
specifier|const
name|struct
name|group_icon
modifier|*
name|gi
decl_stmt|;
for|for
control|(
name|gi
operator|=
name|group_icon
init|;
name|gi
operator|!=
name|NULL
condition|;
name|gi
operator|=
name|gi
operator|->
name|next
control|)
block|{
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"// width: %d; height %d; colors: %d; planes %d; bits %d\n"
argument_list|,
name|gi
operator|->
name|width
argument_list|,
name|gi
operator|->
name|height
argument_list|,
name|gi
operator|->
name|colors
argument_list|,
name|gi
operator|->
name|planes
argument_list|,
name|gi
operator|->
name|bits
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"// data bytes: %lu; index: %d\n"
argument_list|,
name|gi
operator|->
name|bytes
argument_list|,
name|gi
operator|->
name|index
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Write out a menu resource.  */
end_comment

begin_function
specifier|static
name|void
name|write_rc_menu
parameter_list|(
name|e
parameter_list|,
name|menu
parameter_list|,
name|menuex
parameter_list|)
name|FILE
modifier|*
name|e
decl_stmt|;
specifier|const
name|struct
name|menu
modifier|*
name|menu
decl_stmt|;
name|int
name|menuex
decl_stmt|;
block|{
if|if
condition|(
name|menu
operator|->
name|help
operator|!=
literal|0
condition|)
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"// Help ID: %lu\n"
argument_list|,
name|menu
operator|->
name|help
argument_list|)
expr_stmt|;
name|write_rc_menuitems
argument_list|(
name|e
argument_list|,
name|menu
operator|->
name|items
argument_list|,
name|menuex
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Write out menuitems.  */
end_comment

begin_function
specifier|static
name|void
name|write_rc_menuitems
parameter_list|(
name|e
parameter_list|,
name|menuitems
parameter_list|,
name|menuex
parameter_list|,
name|ind
parameter_list|)
name|FILE
modifier|*
name|e
decl_stmt|;
specifier|const
name|struct
name|menuitem
modifier|*
name|menuitems
decl_stmt|;
name|int
name|menuex
decl_stmt|;
name|int
name|ind
decl_stmt|;
block|{
specifier|const
name|struct
name|menuitem
modifier|*
name|mi
decl_stmt|;
name|indent
argument_list|(
name|e
argument_list|,
name|ind
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"BEGIN\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|mi
operator|=
name|menuitems
init|;
name|mi
operator|!=
name|NULL
condition|;
name|mi
operator|=
name|mi
operator|->
name|next
control|)
block|{
name|indent
argument_list|(
name|e
argument_list|,
name|ind
operator|+
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|mi
operator|->
name|popup
operator|==
name|NULL
condition|)
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"MENUITEM"
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"POPUP"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|menuex
operator|&&
name|mi
operator|->
name|popup
operator|==
name|NULL
operator|&&
name|mi
operator|->
name|text
operator|==
name|NULL
operator|&&
name|mi
operator|->
name|type
operator|==
literal|0
operator|&&
name|mi
operator|->
name|id
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|e
argument_list|,
literal|" SEPARATOR\n"
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|mi
operator|->
name|text
operator|==
name|NULL
condition|)
name|fprintf
argument_list|(
name|e
argument_list|,
literal|" \"\""
argument_list|)
expr_stmt|;
else|else
block|{
name|fprintf
argument_list|(
name|e
argument_list|,
literal|" \""
argument_list|)
expr_stmt|;
name|unicode_print
argument_list|(
name|e
argument_list|,
name|mi
operator|->
name|text
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"\""
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|menuex
condition|)
block|{
if|if
condition|(
name|mi
operator|->
name|popup
operator|==
name|NULL
condition|)
name|fprintf
argument_list|(
name|e
argument_list|,
literal|", %d"
argument_list|,
name|mi
operator|->
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|mi
operator|->
name|type
operator|&
name|MENUITEM_CHECKED
operator|)
operator|!=
literal|0
condition|)
name|fprintf
argument_list|(
name|e
argument_list|,
literal|", CHECKED"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|mi
operator|->
name|type
operator|&
name|MENUITEM_GRAYED
operator|)
operator|!=
literal|0
condition|)
name|fprintf
argument_list|(
name|e
argument_list|,
literal|", GRAYED"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|mi
operator|->
name|type
operator|&
name|MENUITEM_HELP
operator|)
operator|!=
literal|0
condition|)
name|fprintf
argument_list|(
name|e
argument_list|,
literal|", HELP"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|mi
operator|->
name|type
operator|&
name|MENUITEM_INACTIVE
operator|)
operator|!=
literal|0
condition|)
name|fprintf
argument_list|(
name|e
argument_list|,
literal|", INACTIVE"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|mi
operator|->
name|type
operator|&
name|MENUITEM_MENUBARBREAK
operator|)
operator|!=
literal|0
condition|)
name|fprintf
argument_list|(
name|e
argument_list|,
literal|", MENUBARBREAK"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|mi
operator|->
name|type
operator|&
name|MENUITEM_MENUBREAK
operator|)
operator|!=
literal|0
condition|)
name|fprintf
argument_list|(
name|e
argument_list|,
literal|", MENUBREAK"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|mi
operator|->
name|id
operator|!=
literal|0
operator|||
name|mi
operator|->
name|type
operator|!=
literal|0
operator|||
name|mi
operator|->
name|state
operator|!=
literal|0
operator|||
name|mi
operator|->
name|help
operator|!=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|e
argument_list|,
literal|", %d"
argument_list|,
name|mi
operator|->
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|mi
operator|->
name|type
operator|!=
literal|0
operator|||
name|mi
operator|->
name|state
operator|!=
literal|0
operator|||
name|mi
operator|->
name|help
operator|!=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|e
argument_list|,
literal|", %lu"
argument_list|,
name|mi
operator|->
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|mi
operator|->
name|state
operator|!=
literal|0
operator|||
name|mi
operator|->
name|help
operator|!=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|e
argument_list|,
literal|", %lu"
argument_list|,
name|mi
operator|->
name|state
argument_list|)
expr_stmt|;
if|if
condition|(
name|mi
operator|->
name|help
operator|!=
literal|0
condition|)
name|fprintf
argument_list|(
name|e
argument_list|,
literal|", %lu"
argument_list|,
name|mi
operator|->
name|help
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|mi
operator|->
name|popup
operator|!=
name|NULL
condition|)
name|write_rc_menuitems
argument_list|(
name|e
argument_list|,
name|mi
operator|->
name|popup
argument_list|,
name|menuex
argument_list|,
name|ind
operator|+
literal|2
argument_list|)
expr_stmt|;
block|}
name|indent
argument_list|(
name|e
argument_list|,
name|ind
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"END\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Write out an rcdata resource.  This is also used for other types of    resources that need to print arbitrary data.  */
end_comment

begin_function
specifier|static
name|void
name|write_rc_rcdata
parameter_list|(
name|e
parameter_list|,
name|rcdata
parameter_list|,
name|ind
parameter_list|)
name|FILE
modifier|*
name|e
decl_stmt|;
specifier|const
name|struct
name|rcdata_item
modifier|*
name|rcdata
decl_stmt|;
name|int
name|ind
decl_stmt|;
block|{
specifier|const
name|struct
name|rcdata_item
modifier|*
name|ri
decl_stmt|;
name|indent
argument_list|(
name|e
argument_list|,
name|ind
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"BEGIN\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|ri
operator|=
name|rcdata
init|;
name|ri
operator|!=
name|NULL
condition|;
name|ri
operator|=
name|ri
operator|->
name|next
control|)
block|{
if|if
condition|(
name|ri
operator|->
name|type
operator|==
name|RCDATA_BUFFER
operator|&&
name|ri
operator|->
name|u
operator|.
name|buffer
operator|.
name|length
operator|==
literal|0
condition|)
continue|continue;
name|indent
argument_list|(
name|e
argument_list|,
name|ind
operator|+
literal|2
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ri
operator|->
name|type
condition|)
block|{
default|default:
name|abort
argument_list|()
expr_stmt|;
case|case
name|RCDATA_WORD
case|:
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"%d"
argument_list|,
name|ri
operator|->
name|u
operator|.
name|word
argument_list|)
expr_stmt|;
break|break;
case|case
name|RCDATA_DWORD
case|:
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"%luL"
argument_list|,
name|ri
operator|->
name|u
operator|.
name|dword
argument_list|)
expr_stmt|;
break|break;
case|case
name|RCDATA_STRING
case|:
block|{
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
name|unsigned
name|long
name|i
decl_stmt|;
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"\""
argument_list|)
expr_stmt|;
name|s
operator|=
name|ri
operator|->
name|u
operator|.
name|string
operator|.
name|s
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ri
operator|->
name|u
operator|.
name|string
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|isprint
argument_list|(
operator|*
name|s
argument_list|)
condition|)
name|putc
argument_list|(
operator|*
name|s
argument_list|,
name|e
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"\\%03o"
argument_list|,
operator|*
name|s
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"\""
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|RCDATA_WSTRING
case|:
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"L\""
argument_list|)
expr_stmt|;
name|unicode_print
argument_list|(
name|e
argument_list|,
name|ri
operator|->
name|u
operator|.
name|wstring
operator|.
name|w
argument_list|,
name|ri
operator|->
name|u
operator|.
name|wstring
operator|.
name|length
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"\""
argument_list|)
expr_stmt|;
break|break;
case|case
name|RCDATA_BUFFER
case|:
block|{
name|unsigned
name|long
name|i
decl_stmt|;
name|int
name|first
decl_stmt|;
comment|/* Assume little endian data.  */
name|first
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|+
literal|3
operator|<
name|ri
operator|->
name|u
operator|.
name|buffer
operator|.
name|length
condition|;
name|i
operator|+=
literal|4
control|)
block|{
name|unsigned
name|long
name|l
decl_stmt|;
name|l
operator|=
operator|(
operator|(
operator|(
operator|(
operator|(
operator|(
name|ri
operator|->
name|u
operator|.
name|buffer
operator|.
name|data
index|[
name|i
operator|+
literal|3
index|]
operator|<<
literal|8
operator|)
operator||
name|ri
operator|->
name|u
operator|.
name|buffer
operator|.
name|data
index|[
name|i
operator|+
literal|2
index|]
operator|)
operator|<<
literal|8
operator|)
operator||
name|ri
operator|->
name|u
operator|.
name|buffer
operator|.
name|data
index|[
name|i
operator|+
literal|1
index|]
operator|)
operator|<<
literal|8
operator|)
operator||
name|ri
operator|->
name|u
operator|.
name|buffer
operator|.
name|data
index|[
name|i
index|]
operator|)
expr_stmt|;
if|if
condition|(
name|first
condition|)
name|first
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|fprintf
argument_list|(
name|e
argument_list|,
literal|",\n"
argument_list|)
expr_stmt|;
name|indent
argument_list|(
name|e
argument_list|,
name|ind
operator|+
literal|2
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"%luL"
argument_list|,
name|l
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|+
literal|1
operator|<
name|ri
operator|->
name|u
operator|.
name|buffer
operator|.
name|length
condition|)
block|{
name|int
name|i
decl_stmt|;
name|i
operator|=
operator|(
name|ri
operator|->
name|u
operator|.
name|buffer
operator|.
name|data
index|[
name|i
operator|+
literal|1
index|]
operator|<<
literal|8
operator|)
operator||
name|ri
operator|->
name|u
operator|.
name|buffer
operator|.
name|data
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|first
condition|)
name|first
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|fprintf
argument_list|(
name|e
argument_list|,
literal|",\n"
argument_list|)
expr_stmt|;
name|indent
argument_list|(
name|e
argument_list|,
name|ind
operator|+
literal|2
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"%d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|i
operator|+=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|<
name|ri
operator|->
name|u
operator|.
name|buffer
operator|.
name|length
condition|)
block|{
if|if
condition|(
name|first
condition|)
name|first
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|fprintf
argument_list|(
name|e
argument_list|,
literal|",\n"
argument_list|)
expr_stmt|;
name|indent
argument_list|(
name|e
argument_list|,
name|ind
operator|+
literal|2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|ri
operator|->
name|u
operator|.
name|buffer
operator|.
name|data
index|[
name|i
index|]
operator|&
literal|0x7f
operator|)
operator|==
name|ri
operator|->
name|u
operator|.
name|buffer
operator|.
name|data
index|[
name|i
index|]
operator|&&
name|isprint
argument_list|(
name|ri
operator|->
name|u
operator|.
name|buffer
operator|.
name|data
index|[
name|i
index|]
argument_list|)
condition|)
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"\"%c\""
argument_list|,
name|ri
operator|->
name|u
operator|.
name|buffer
operator|.
name|data
index|[
name|i
index|]
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"\"\%03o\""
argument_list|,
name|ri
operator|->
name|u
operator|.
name|buffer
operator|.
name|data
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
if|if
condition|(
name|ri
operator|->
name|next
operator|!=
name|NULL
condition|)
name|fprintf
argument_list|(
name|e
argument_list|,
literal|","
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|indent
argument_list|(
name|e
argument_list|,
name|ind
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"END\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Write out a stringtable resource.  */
end_comment

begin_function
specifier|static
name|void
name|write_rc_stringtable
parameter_list|(
name|e
parameter_list|,
name|name
parameter_list|,
name|stringtable
parameter_list|)
name|FILE
modifier|*
name|e
decl_stmt|;
specifier|const
name|struct
name|res_id
modifier|*
name|name
decl_stmt|;
specifier|const
name|struct
name|stringtable
modifier|*
name|stringtable
decl_stmt|;
block|{
name|unsigned
name|long
name|offset
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|name
operator|!=
name|NULL
operator|&&
operator|!
name|name
operator|->
name|named
condition|)
name|offset
operator|=
operator|(
name|name
operator|->
name|u
operator|.
name|id
operator|-
literal|1
operator|)
operator|<<
literal|4
expr_stmt|;
else|else
block|{
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"// %s string table name\n"
argument_list|,
name|name
operator|==
name|NULL
condition|?
literal|"Missing"
else|:
literal|"Invalid"
argument_list|)
expr_stmt|;
name|offset
operator|=
literal|0
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"BEGIN\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|stringtable
operator|->
name|strings
index|[
name|i
index|]
operator|.
name|length
operator|!=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"  %lu, \""
argument_list|,
name|offset
operator|+
name|i
argument_list|)
expr_stmt|;
name|unicode_print
argument_list|(
name|e
argument_list|,
name|stringtable
operator|->
name|strings
index|[
name|i
index|]
operator|.
name|string
argument_list|,
name|stringtable
operator|->
name|strings
index|[
name|i
index|]
operator|.
name|length
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"\"\n"
argument_list|)
expr_stmt|;
block|}
block|}
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"END\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Write out a versioninfo resource.  */
end_comment

begin_function
specifier|static
name|void
name|write_rc_versioninfo
parameter_list|(
name|e
parameter_list|,
name|versioninfo
parameter_list|)
name|FILE
modifier|*
name|e
decl_stmt|;
specifier|const
name|struct
name|versioninfo
modifier|*
name|versioninfo
decl_stmt|;
block|{
specifier|const
name|struct
name|fixed_versioninfo
modifier|*
name|f
decl_stmt|;
specifier|const
name|struct
name|ver_info
modifier|*
name|vi
decl_stmt|;
name|f
operator|=
name|versioninfo
operator|->
name|fixed
expr_stmt|;
if|if
condition|(
name|f
operator|->
name|file_version_ms
operator|!=
literal|0
operator|||
name|f
operator|->
name|file_version_ls
operator|!=
literal|0
condition|)
name|fprintf
argument_list|(
name|e
argument_list|,
literal|" FILEVERSION %lu, %lu, %lu, %lu\n"
argument_list|,
operator|(
name|f
operator|->
name|file_version_ms
operator|>>
literal|16
operator|)
operator|&
literal|0xffff
argument_list|,
name|f
operator|->
name|file_version_ms
operator|&
literal|0xffff
argument_list|,
operator|(
name|f
operator|->
name|file_version_ls
operator|>>
literal|16
operator|)
operator|&
literal|0xffff
argument_list|,
name|f
operator|->
name|file_version_ls
operator|&
literal|0xffff
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|->
name|product_version_ms
operator|!=
literal|0
operator|||
name|f
operator|->
name|product_version_ls
operator|!=
literal|0
condition|)
name|fprintf
argument_list|(
name|e
argument_list|,
literal|" PRODUCTVERSION %lu, %lu, %lu, %lu\n"
argument_list|,
operator|(
name|f
operator|->
name|product_version_ms
operator|>>
literal|16
operator|)
operator|&
literal|0xffff
argument_list|,
name|f
operator|->
name|product_version_ms
operator|&
literal|0xffff
argument_list|,
operator|(
name|f
operator|->
name|product_version_ls
operator|>>
literal|16
operator|)
operator|&
literal|0xffff
argument_list|,
name|f
operator|->
name|product_version_ls
operator|&
literal|0xffff
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|->
name|file_flags_mask
operator|!=
literal|0
condition|)
name|fprintf
argument_list|(
name|e
argument_list|,
literal|" FILEFLAGSMASK 0x%lx\n"
argument_list|,
name|f
operator|->
name|file_flags_mask
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|->
name|file_flags
operator|!=
literal|0
condition|)
name|fprintf
argument_list|(
name|e
argument_list|,
literal|" FILEFLAGS 0x%lx\n"
argument_list|,
name|f
operator|->
name|file_flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|->
name|file_os
operator|!=
literal|0
condition|)
name|fprintf
argument_list|(
name|e
argument_list|,
literal|" FILEOS 0x%lx\n"
argument_list|,
name|f
operator|->
name|file_os
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|->
name|file_type
operator|!=
literal|0
condition|)
name|fprintf
argument_list|(
name|e
argument_list|,
literal|" FILETYPE 0x%lx\n"
argument_list|,
name|f
operator|->
name|file_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|->
name|file_subtype
operator|!=
literal|0
condition|)
name|fprintf
argument_list|(
name|e
argument_list|,
literal|" FILESUBTYPE 0x%lx\n"
argument_list|,
name|f
operator|->
name|file_subtype
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|->
name|file_date_ms
operator|!=
literal|0
operator|||
name|f
operator|->
name|file_date_ls
operator|!=
literal|0
condition|)
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"// Date: %lu, %lu\n"
argument_list|,
name|f
operator|->
name|file_date_ms
argument_list|,
name|f
operator|->
name|file_date_ls
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"BEGIN\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|vi
operator|=
name|versioninfo
operator|->
name|var
init|;
name|vi
operator|!=
name|NULL
condition|;
name|vi
operator|=
name|vi
operator|->
name|next
control|)
block|{
switch|switch
condition|(
name|vi
operator|->
name|type
condition|)
block|{
case|case
name|VERINFO_STRING
case|:
block|{
specifier|const
name|struct
name|ver_stringinfo
modifier|*
name|vs
decl_stmt|;
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"  BLOCK \"StringFileInfo\"\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"  BEGIN\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"    BLOCK \""
argument_list|)
expr_stmt|;
name|unicode_print
argument_list|(
name|e
argument_list|,
name|vi
operator|->
name|u
operator|.
name|string
operator|.
name|language
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"\"\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"    BEGIN\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|vs
operator|=
name|vi
operator|->
name|u
operator|.
name|string
operator|.
name|strings
init|;
name|vs
operator|!=
name|NULL
condition|;
name|vs
operator|=
name|vs
operator|->
name|next
control|)
block|{
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"      VALUE \""
argument_list|)
expr_stmt|;
name|unicode_print
argument_list|(
name|e
argument_list|,
name|vs
operator|->
name|key
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"\", \""
argument_list|)
expr_stmt|;
name|unicode_print
argument_list|(
name|e
argument_list|,
name|vs
operator|->
name|value
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"\"\n"
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"    END\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"  END\n"
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|VERINFO_VAR
case|:
block|{
specifier|const
name|struct
name|ver_varinfo
modifier|*
name|vv
decl_stmt|;
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"  BLOCK \"VarFileInfo\"\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"  BEGIN\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"    VALUE \""
argument_list|)
expr_stmt|;
name|unicode_print
argument_list|(
name|e
argument_list|,
name|vi
operator|->
name|u
operator|.
name|var
operator|.
name|key
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"\""
argument_list|)
expr_stmt|;
for|for
control|(
name|vv
operator|=
name|vi
operator|->
name|u
operator|.
name|var
operator|.
name|var
init|;
name|vv
operator|!=
name|NULL
condition|;
name|vv
operator|=
name|vv
operator|->
name|next
control|)
name|fprintf
argument_list|(
name|e
argument_list|,
literal|", 0x%x, %d"
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|vv
operator|->
name|language
argument_list|,
name|vv
operator|->
name|charset
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"\n  END\n"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"END\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Write out data which would normally be read from a file.  */
end_comment

begin_function
specifier|static
name|void
name|write_rc_filedata
parameter_list|(
name|e
parameter_list|,
name|length
parameter_list|,
name|data
parameter_list|)
name|FILE
modifier|*
name|e
decl_stmt|;
name|unsigned
name|long
name|length
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|data
decl_stmt|;
block|{
name|unsigned
name|long
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|+
literal|15
operator|<
name|length
condition|;
name|i
operator|+=
literal|16
control|)
block|{
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"// %4lx: "
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"%02x %02x %02x %02x %02x %02x %02x %02x "
argument_list|,
name|data
index|[
name|i
operator|+
literal|0
index|]
argument_list|,
name|data
index|[
name|i
operator|+
literal|1
index|]
argument_list|,
name|data
index|[
name|i
operator|+
literal|2
index|]
argument_list|,
name|data
index|[
name|i
operator|+
literal|3
index|]
argument_list|,
name|data
index|[
name|i
operator|+
literal|4
index|]
argument_list|,
name|data
index|[
name|i
operator|+
literal|5
index|]
argument_list|,
name|data
index|[
name|i
operator|+
literal|6
index|]
argument_list|,
name|data
index|[
name|i
operator|+
literal|7
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"%02x %02x %02x %02x %02x %02x %02x %02x\n"
argument_list|,
name|data
index|[
name|i
operator|+
literal|8
index|]
argument_list|,
name|data
index|[
name|i
operator|+
literal|9
index|]
argument_list|,
name|data
index|[
name|i
operator|+
literal|10
index|]
argument_list|,
name|data
index|[
name|i
operator|+
literal|11
index|]
argument_list|,
name|data
index|[
name|i
operator|+
literal|12
index|]
argument_list|,
name|data
index|[
name|i
operator|+
literal|13
index|]
argument_list|,
name|data
index|[
name|i
operator|+
literal|14
index|]
argument_list|,
name|data
index|[
name|i
operator|+
literal|15
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|<
name|length
condition|)
block|{
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"// %4lx:"
argument_list|,
name|i
argument_list|)
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|length
condition|)
block|{
name|fprintf
argument_list|(
name|e
argument_list|,
literal|" %02x"
argument_list|,
name|data
index|[
name|i
index|]
argument_list|)
expr_stmt|;
operator|++
name|i
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

