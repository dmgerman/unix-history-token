begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* ieee.c -- Read and write IEEE-695 debugging information.    Copyright 1996, 1998, 2000, 2001 Free Software Foundation, Inc.    Written by Ian Lance Taylor<ian@cygnus.com>.     This file is part of GNU Binutils.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA    02111-1307, USA.  */
end_comment

begin_comment
comment|/* This file reads and writes IEEE-695 debugging information.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"ieee.h"
end_include

begin_include
include|#
directive|include
file|"bucomm.h"
end_include

begin_include
include|#
directive|include
file|"libiberty.h"
end_include

begin_include
include|#
directive|include
file|"debug.h"
end_include

begin_include
include|#
directive|include
file|"budbg.h"
end_include

begin_include
include|#
directive|include
file|"filenames.h"
end_include

begin_comment
comment|/* This structure holds an entry on the block stack.  */
end_comment

begin_struct
struct|struct
name|ieee_block
block|{
comment|/* The kind of block.  */
name|int
name|kind
decl_stmt|;
comment|/* The source file name, for a BB5 block.  */
specifier|const
name|char
modifier|*
name|filename
decl_stmt|;
comment|/* The index of the function type, for a BB4 or BB6 block.  */
name|unsigned
name|int
name|fnindx
decl_stmt|;
comment|/* True if this function is being skipped.  */
name|boolean
name|skip
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* This structure is the block stack.  */
end_comment

begin_define
define|#
directive|define
name|BLOCKSTACK_SIZE
value|(16)
end_define

begin_struct
struct|struct
name|ieee_blockstack
block|{
comment|/* The stack pointer.  */
name|struct
name|ieee_block
modifier|*
name|bsp
decl_stmt|;
comment|/* The stack.  */
name|struct
name|ieee_block
name|stack
index|[
name|BLOCKSTACK_SIZE
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* This structure holds information for a variable.  */
end_comment

begin_struct
struct|struct
name|ieee_var
block|{
comment|/* Start of name.  */
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
comment|/* Length of name.  */
name|unsigned
name|long
name|namlen
decl_stmt|;
comment|/* Type.  */
name|debug_type
name|type
decl_stmt|;
comment|/* Slot if we make an indirect type.  */
name|debug_type
modifier|*
name|pslot
decl_stmt|;
comment|/* Kind of variable or function.  */
enum|enum
block|{
name|IEEE_UNKNOWN
block|,
name|IEEE_EXTERNAL
block|,
name|IEEE_GLOBAL
block|,
name|IEEE_STATIC
block|,
name|IEEE_LOCAL
block|,
name|IEEE_FUNCTION
block|}
name|kind
enum|;
block|}
struct|;
end_struct

begin_comment
comment|/* This structure holds all the variables.  */
end_comment

begin_struct
struct|struct
name|ieee_vars
block|{
comment|/* Number of slots allocated.  */
name|unsigned
name|int
name|alloc
decl_stmt|;
comment|/* Variables.  */
name|struct
name|ieee_var
modifier|*
name|vars
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* This structure holds information for a type.  We need this because    we don't want to represent bitfields as real types.  */
end_comment

begin_struct
struct|struct
name|ieee_type
block|{
comment|/* Type.  */
name|debug_type
name|type
decl_stmt|;
comment|/* Slot if this is type is referenced before it is defined.  */
name|debug_type
modifier|*
name|pslot
decl_stmt|;
comment|/* Slots for arguments if we make indirect types for them.  */
name|debug_type
modifier|*
name|arg_slots
decl_stmt|;
comment|/* If this is a bitfield, this is the size in bits.  If this is not      a bitfield, this is zero.  */
name|unsigned
name|long
name|bitsize
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* This structure holds all the type information.  */
end_comment

begin_struct
struct|struct
name|ieee_types
block|{
comment|/* Number of slots allocated.  */
name|unsigned
name|int
name|alloc
decl_stmt|;
comment|/* Types.  */
name|struct
name|ieee_type
modifier|*
name|types
decl_stmt|;
comment|/* Builtin types.  */
define|#
directive|define
name|BUILTIN_TYPE_COUNT
value|(60)
name|debug_type
name|builtins
index|[
name|BUILTIN_TYPE_COUNT
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* This structure holds a linked last of structs with their tag names,    so that we can convert them to C++ classes if necessary.  */
end_comment

begin_struct
struct|struct
name|ieee_tag
block|{
comment|/* Next tag.  */
name|struct
name|ieee_tag
modifier|*
name|next
decl_stmt|;
comment|/* This tag name.  */
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
comment|/* The type of the tag.  */
name|debug_type
name|type
decl_stmt|;
comment|/* The tagged type is an indirect type pointing at this slot.  */
name|debug_type
name|slot
decl_stmt|;
comment|/* This is an array of slots used when a field type is converted      into a indirect type, in case it needs to be later converted into      a reference type.  */
name|debug_type
modifier|*
name|fslots
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* This structure holds the information we pass around to the parsing    functions.  */
end_comment

begin_struct
struct|struct
name|ieee_info
block|{
comment|/* The debugging handle.  */
name|PTR
name|dhandle
decl_stmt|;
comment|/* The BFD.  */
name|bfd
modifier|*
name|abfd
decl_stmt|;
comment|/* The start of the bytes to be parsed.  */
specifier|const
name|bfd_byte
modifier|*
name|bytes
decl_stmt|;
comment|/* The end of the bytes to be parsed.  */
specifier|const
name|bfd_byte
modifier|*
name|pend
decl_stmt|;
comment|/* The block stack.  */
name|struct
name|ieee_blockstack
name|blockstack
decl_stmt|;
comment|/* Whether we have seen a BB1 or BB2.  */
name|boolean
name|saw_filename
decl_stmt|;
comment|/* The variables.  */
name|struct
name|ieee_vars
name|vars
decl_stmt|;
comment|/* The global variables, after a global typedef block.  */
name|struct
name|ieee_vars
modifier|*
name|global_vars
decl_stmt|;
comment|/* The types.  */
name|struct
name|ieee_types
name|types
decl_stmt|;
comment|/* The global types, after a global typedef block.  */
name|struct
name|ieee_types
modifier|*
name|global_types
decl_stmt|;
comment|/* The list of tagged structs.  */
name|struct
name|ieee_tag
modifier|*
name|tags
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Basic builtin types, not including the pointers.  */
end_comment

begin_enum
enum|enum
name|builtin_types
block|{
name|builtin_unknown
init|=
literal|0
block|,
name|builtin_void
init|=
literal|1
block|,
name|builtin_signed_char
init|=
literal|2
block|,
name|builtin_unsigned_char
init|=
literal|3
block|,
name|builtin_signed_short_int
init|=
literal|4
block|,
name|builtin_unsigned_short_int
init|=
literal|5
block|,
name|builtin_signed_long
init|=
literal|6
block|,
name|builtin_unsigned_long
init|=
literal|7
block|,
name|builtin_signed_long_long
init|=
literal|8
block|,
name|builtin_unsigned_long_long
init|=
literal|9
block|,
name|builtin_float
init|=
literal|10
block|,
name|builtin_double
init|=
literal|11
block|,
name|builtin_long_double
init|=
literal|12
block|,
name|builtin_long_long_double
init|=
literal|13
block|,
name|builtin_quoted_string
init|=
literal|14
block|,
name|builtin_instruction_address
init|=
literal|15
block|,
name|builtin_int
init|=
literal|16
block|,
name|builtin_unsigned
init|=
literal|17
block|,
name|builtin_unsigned_int
init|=
literal|18
block|,
name|builtin_char
init|=
literal|19
block|,
name|builtin_long
init|=
literal|20
block|,
name|builtin_short
init|=
literal|21
block|,
name|builtin_unsigned_short
init|=
literal|22
block|,
name|builtin_short_int
init|=
literal|23
block|,
name|builtin_signed_short
init|=
literal|24
block|,
name|builtin_bcd_float
init|=
literal|25
block|}
enum|;
end_enum

begin_comment
comment|/* These are the values found in the derivation flags of a 'b'    component record of a 'T' type extension record in a C++ pmisc    record.  These are bitmasks.  */
end_comment

begin_comment
comment|/* Set for a private base class, clear for a public base class.    Protected base classes are not supported.  */
end_comment

begin_define
define|#
directive|define
name|BASEFLAGS_PRIVATE
value|(0x1)
end_define

begin_comment
comment|/* Set for a virtual base class.  */
end_comment

begin_define
define|#
directive|define
name|BASEFLAGS_VIRTUAL
value|(0x2)
end_define

begin_comment
comment|/* Set for a friend class, clear for a base class.  */
end_comment

begin_define
define|#
directive|define
name|BASEFLAGS_FRIEND
value|(0x10)
end_define

begin_comment
comment|/* These are the values found in the specs flags of a 'd', 'm', or 'v'    component record of a 'T' type extension record in a C++ pmisc    record.  The same flags are used for a 'M' record in a C++ pmisc    record.  */
end_comment

begin_comment
comment|/* The lower two bits hold visibility information.  */
end_comment

begin_define
define|#
directive|define
name|CXXFLAGS_VISIBILITY
value|(0x3)
end_define

begin_comment
comment|/* This value in the lower two bits indicates a public member.  */
end_comment

begin_define
define|#
directive|define
name|CXXFLAGS_VISIBILITY_PUBLIC
value|(0x0)
end_define

begin_comment
comment|/* This value in the lower two bits indicates a private member.  */
end_comment

begin_define
define|#
directive|define
name|CXXFLAGS_VISIBILITY_PRIVATE
value|(0x1)
end_define

begin_comment
comment|/* This value in the lower two bits indicates a protected member.  */
end_comment

begin_define
define|#
directive|define
name|CXXFLAGS_VISIBILITY_PROTECTED
value|(0x2)
end_define

begin_comment
comment|/* Set for a static member.  */
end_comment

begin_define
define|#
directive|define
name|CXXFLAGS_STATIC
value|(0x4)
end_define

begin_comment
comment|/* Set for a virtual override.  */
end_comment

begin_define
define|#
directive|define
name|CXXFLAGS_OVERRIDE
value|(0x8)
end_define

begin_comment
comment|/* Set for a friend function.  */
end_comment

begin_define
define|#
directive|define
name|CXXFLAGS_FRIEND
value|(0x10)
end_define

begin_comment
comment|/* Set for a const function.  */
end_comment

begin_define
define|#
directive|define
name|CXXFLAGS_CONST
value|(0x20)
end_define

begin_comment
comment|/* Set for a volatile function.  */
end_comment

begin_define
define|#
directive|define
name|CXXFLAGS_VOLATILE
value|(0x40)
end_define

begin_comment
comment|/* Set for an overloaded function.  */
end_comment

begin_define
define|#
directive|define
name|CXXFLAGS_OVERLOADED
value|(0x80)
end_define

begin_comment
comment|/* Set for an operator function.  */
end_comment

begin_define
define|#
directive|define
name|CXXFLAGS_OPERATOR
value|(0x100)
end_define

begin_comment
comment|/* Set for a constructor or destructor.  */
end_comment

begin_define
define|#
directive|define
name|CXXFLAGS_CTORDTOR
value|(0x400)
end_define

begin_comment
comment|/* Set for a constructor.  */
end_comment

begin_define
define|#
directive|define
name|CXXFLAGS_CTOR
value|(0x200)
end_define

begin_comment
comment|/* Set for an inline function.  */
end_comment

begin_define
define|#
directive|define
name|CXXFLAGS_INLINE
value|(0x800)
end_define

begin_comment
comment|/* Local functions.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|ieee_error
name|PARAMS
argument_list|(
operator|(
expr|struct
name|ieee_info
operator|*
operator|,
specifier|const
name|bfd_byte
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ieee_eof
name|PARAMS
argument_list|(
operator|(
expr|struct
name|ieee_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|savestring
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
name|unsigned
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|ieee_read_number
name|PARAMS
argument_list|(
operator|(
expr|struct
name|ieee_info
operator|*
operator|,
specifier|const
name|bfd_byte
operator|*
operator|*
operator|,
name|bfd_vma
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|ieee_read_optional_number
name|PARAMS
argument_list|(
operator|(
expr|struct
name|ieee_info
operator|*
operator|,
specifier|const
name|bfd_byte
operator|*
operator|*
operator|,
name|bfd_vma
operator|*
operator|,
name|boolean
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|ieee_read_id
name|PARAMS
argument_list|(
operator|(
expr|struct
name|ieee_info
operator|*
operator|,
specifier|const
name|bfd_byte
operator|*
operator|*
operator|,
specifier|const
name|char
operator|*
operator|*
operator|,
name|unsigned
name|long
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|ieee_read_optional_id
name|PARAMS
argument_list|(
operator|(
expr|struct
name|ieee_info
operator|*
operator|,
specifier|const
name|bfd_byte
operator|*
operator|*
operator|,
specifier|const
name|char
operator|*
operator|*
operator|,
name|unsigned
name|long
operator|*
operator|,
name|boolean
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|ieee_read_expression
name|PARAMS
argument_list|(
operator|(
expr|struct
name|ieee_info
operator|*
operator|,
specifier|const
name|bfd_byte
operator|*
operator|*
operator|,
name|bfd_vma
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|debug_type
name|ieee_builtin_type
name|PARAMS
argument_list|(
operator|(
expr|struct
name|ieee_info
operator|*
operator|,
specifier|const
name|bfd_byte
operator|*
operator|,
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|ieee_alloc_type
name|PARAMS
argument_list|(
operator|(
expr|struct
name|ieee_info
operator|*
operator|,
name|unsigned
name|int
operator|,
name|boolean
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|ieee_read_type_index
name|PARAMS
argument_list|(
operator|(
expr|struct
name|ieee_info
operator|*
operator|,
specifier|const
name|bfd_byte
operator|*
operator|*
operator|,
name|debug_type
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ieee_regno_to_genreg
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ieee_genreg_to_regno
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|parse_ieee_bb
name|PARAMS
argument_list|(
operator|(
expr|struct
name|ieee_info
operator|*
operator|,
specifier|const
name|bfd_byte
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|parse_ieee_be
name|PARAMS
argument_list|(
operator|(
expr|struct
name|ieee_info
operator|*
operator|,
specifier|const
name|bfd_byte
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|parse_ieee_nn
name|PARAMS
argument_list|(
operator|(
expr|struct
name|ieee_info
operator|*
operator|,
specifier|const
name|bfd_byte
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|parse_ieee_ty
name|PARAMS
argument_list|(
operator|(
expr|struct
name|ieee_info
operator|*
operator|,
specifier|const
name|bfd_byte
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|parse_ieee_atn
name|PARAMS
argument_list|(
operator|(
expr|struct
name|ieee_info
operator|*
operator|,
specifier|const
name|bfd_byte
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|ieee_read_cxx_misc
name|PARAMS
argument_list|(
operator|(
expr|struct
name|ieee_info
operator|*
operator|,
specifier|const
name|bfd_byte
operator|*
operator|*
operator|,
name|unsigned
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|ieee_read_cxx_class
name|PARAMS
argument_list|(
operator|(
expr|struct
name|ieee_info
operator|*
operator|,
specifier|const
name|bfd_byte
operator|*
operator|*
operator|,
name|unsigned
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|ieee_read_cxx_defaults
name|PARAMS
argument_list|(
operator|(
expr|struct
name|ieee_info
operator|*
operator|,
specifier|const
name|bfd_byte
operator|*
operator|*
operator|,
name|unsigned
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|ieee_read_reference
name|PARAMS
argument_list|(
operator|(
expr|struct
name|ieee_info
operator|*
operator|,
specifier|const
name|bfd_byte
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|ieee_require_asn
name|PARAMS
argument_list|(
operator|(
expr|struct
name|ieee_info
operator|*
operator|,
specifier|const
name|bfd_byte
operator|*
operator|*
operator|,
name|bfd_vma
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|ieee_require_atn65
name|PARAMS
argument_list|(
operator|(
expr|struct
name|ieee_info
operator|*
operator|,
specifier|const
name|bfd_byte
operator|*
operator|*
operator|,
specifier|const
name|char
operator|*
operator|*
operator|,
name|unsigned
name|long
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Report an error in the IEEE debugging information.  */
end_comment

begin_function
specifier|static
name|void
name|ieee_error
parameter_list|(
name|info
parameter_list|,
name|p
parameter_list|,
name|s
parameter_list|)
name|struct
name|ieee_info
modifier|*
name|info
decl_stmt|;
specifier|const
name|bfd_byte
modifier|*
name|p
decl_stmt|;
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
block|{
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: 0x%lx: %s (0x%x)\n"
argument_list|,
name|bfd_get_filename
argument_list|(
name|info
operator|->
name|abfd
argument_list|)
argument_list|,
call|(
name|unsigned
name|long
call|)
argument_list|(
name|p
operator|-
name|info
operator|->
name|bytes
argument_list|)
argument_list|,
name|s
argument_list|,
operator|*
name|p
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: %s\n"
argument_list|,
name|bfd_get_filename
argument_list|(
name|info
operator|->
name|abfd
argument_list|)
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Report an unexpected EOF in the IEEE debugging information.  */
end_comment

begin_function
specifier|static
name|void
name|ieee_eof
parameter_list|(
name|info
parameter_list|)
name|struct
name|ieee_info
modifier|*
name|info
decl_stmt|;
block|{
name|ieee_error
argument_list|(
name|info
argument_list|,
operator|(
specifier|const
name|bfd_byte
operator|*
operator|)
name|NULL
argument_list|,
name|_
argument_list|(
literal|"unexpected end of debugging information"
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Save a string in memory.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|savestring
parameter_list|(
name|start
parameter_list|,
name|len
parameter_list|)
specifier|const
name|char
modifier|*
name|start
decl_stmt|;
name|unsigned
name|long
name|len
decl_stmt|;
block|{
name|char
modifier|*
name|ret
decl_stmt|;
name|ret
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|ret
argument_list|,
name|start
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|ret
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Read a number which must be present in an IEEE file.  */
end_comment

begin_function
specifier|static
name|boolean
name|ieee_read_number
parameter_list|(
name|info
parameter_list|,
name|pp
parameter_list|,
name|pv
parameter_list|)
name|struct
name|ieee_info
modifier|*
name|info
decl_stmt|;
specifier|const
name|bfd_byte
modifier|*
modifier|*
name|pp
decl_stmt|;
name|bfd_vma
modifier|*
name|pv
decl_stmt|;
block|{
return|return
name|ieee_read_optional_number
argument_list|(
name|info
argument_list|,
name|pp
argument_list|,
name|pv
argument_list|,
operator|(
name|boolean
operator|*
operator|)
name|NULL
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Read a number in an IEEE file.  If ppresent is not NULL, the number    need not be there. */
end_comment

begin_function
specifier|static
name|boolean
name|ieee_read_optional_number
parameter_list|(
name|info
parameter_list|,
name|pp
parameter_list|,
name|pv
parameter_list|,
name|ppresent
parameter_list|)
name|struct
name|ieee_info
modifier|*
name|info
decl_stmt|;
specifier|const
name|bfd_byte
modifier|*
modifier|*
name|pp
decl_stmt|;
name|bfd_vma
modifier|*
name|pv
decl_stmt|;
name|boolean
modifier|*
name|ppresent
decl_stmt|;
block|{
name|ieee_record_enum_type
name|b
decl_stmt|;
if|if
condition|(
operator|*
name|pp
operator|>=
name|info
operator|->
name|pend
condition|)
block|{
if|if
condition|(
name|ppresent
operator|!=
name|NULL
condition|)
block|{
operator|*
name|ppresent
operator|=
name|false
expr_stmt|;
return|return
name|true
return|;
block|}
name|ieee_eof
argument_list|(
name|info
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|b
operator|=
operator|(
name|ieee_record_enum_type
operator|)
operator|*
operator|*
name|pp
expr_stmt|;
operator|++
operator|*
name|pp
expr_stmt|;
if|if
condition|(
name|b
operator|<=
name|ieee_number_end_enum
condition|)
block|{
operator|*
name|pv
operator|=
operator|(
name|bfd_vma
operator|)
name|b
expr_stmt|;
if|if
condition|(
name|ppresent
operator|!=
name|NULL
condition|)
operator|*
name|ppresent
operator|=
name|true
expr_stmt|;
return|return
name|true
return|;
block|}
if|if
condition|(
name|b
operator|>=
name|ieee_number_repeat_start_enum
operator|&&
name|b
operator|<=
name|ieee_number_repeat_end_enum
condition|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|i
operator|=
operator|(
name|int
operator|)
name|b
operator|-
operator|(
name|int
operator|)
name|ieee_number_repeat_start_enum
expr_stmt|;
if|if
condition|(
operator|*
name|pp
operator|+
name|i
operator|-
literal|1
operator|>=
name|info
operator|->
name|pend
condition|)
block|{
name|ieee_eof
argument_list|(
name|info
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
operator|*
name|pv
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
operator|*
name|pv
operator|<<=
literal|8
expr_stmt|;
operator|*
name|pv
operator|+=
operator|*
operator|*
name|pp
expr_stmt|;
operator|++
operator|*
name|pp
expr_stmt|;
block|}
if|if
condition|(
name|ppresent
operator|!=
name|NULL
condition|)
operator|*
name|ppresent
operator|=
name|true
expr_stmt|;
return|return
name|true
return|;
block|}
if|if
condition|(
name|ppresent
operator|!=
name|NULL
condition|)
block|{
operator|--
operator|*
name|pp
expr_stmt|;
operator|*
name|ppresent
operator|=
name|false
expr_stmt|;
return|return
name|true
return|;
block|}
name|ieee_error
argument_list|(
name|info
argument_list|,
operator|*
name|pp
operator|-
literal|1
argument_list|,
name|_
argument_list|(
literal|"invalid number"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Read a required string from an IEEE file.  */
end_comment

begin_function
specifier|static
name|boolean
name|ieee_read_id
parameter_list|(
name|info
parameter_list|,
name|pp
parameter_list|,
name|pname
parameter_list|,
name|pnamlen
parameter_list|)
name|struct
name|ieee_info
modifier|*
name|info
decl_stmt|;
specifier|const
name|bfd_byte
modifier|*
modifier|*
name|pp
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|pname
decl_stmt|;
name|unsigned
name|long
modifier|*
name|pnamlen
decl_stmt|;
block|{
return|return
name|ieee_read_optional_id
argument_list|(
name|info
argument_list|,
name|pp
argument_list|,
name|pname
argument_list|,
name|pnamlen
argument_list|,
operator|(
name|boolean
operator|*
operator|)
name|NULL
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Read a string from an IEEE file.  If ppresent is not NULL, the    string is optional.  */
end_comment

begin_function
specifier|static
name|boolean
name|ieee_read_optional_id
parameter_list|(
name|info
parameter_list|,
name|pp
parameter_list|,
name|pname
parameter_list|,
name|pnamlen
parameter_list|,
name|ppresent
parameter_list|)
name|struct
name|ieee_info
modifier|*
name|info
decl_stmt|;
specifier|const
name|bfd_byte
modifier|*
modifier|*
name|pp
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|pname
decl_stmt|;
name|unsigned
name|long
modifier|*
name|pnamlen
decl_stmt|;
name|boolean
modifier|*
name|ppresent
decl_stmt|;
block|{
name|bfd_byte
name|b
decl_stmt|;
name|unsigned
name|long
name|len
decl_stmt|;
if|if
condition|(
operator|*
name|pp
operator|>=
name|info
operator|->
name|pend
condition|)
block|{
name|ieee_eof
argument_list|(
name|info
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|b
operator|=
operator|*
operator|*
name|pp
expr_stmt|;
operator|++
operator|*
name|pp
expr_stmt|;
if|if
condition|(
name|b
operator|<=
literal|0x7f
condition|)
name|len
operator|=
name|b
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|ieee_record_enum_type
operator|)
name|b
operator|==
name|ieee_extension_length_1_enum
condition|)
block|{
name|len
operator|=
operator|*
operator|*
name|pp
expr_stmt|;
operator|++
operator|*
name|pp
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|ieee_record_enum_type
operator|)
name|b
operator|==
name|ieee_extension_length_2_enum
condition|)
block|{
name|len
operator|=
operator|(
operator|*
operator|*
name|pp
operator|<<
literal|8
operator|)
operator|+
operator|(
operator|*
name|pp
operator|)
index|[
literal|1
index|]
expr_stmt|;
operator|*
name|pp
operator|+=
literal|2
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ppresent
operator|!=
name|NULL
condition|)
block|{
operator|--
operator|*
name|pp
expr_stmt|;
operator|*
name|ppresent
operator|=
name|false
expr_stmt|;
return|return
name|true
return|;
block|}
name|ieee_error
argument_list|(
name|info
argument_list|,
operator|*
name|pp
operator|-
literal|1
argument_list|,
name|_
argument_list|(
literal|"invalid string length"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
call|(
name|unsigned
name|long
call|)
argument_list|(
name|info
operator|->
name|pend
operator|-
operator|*
name|pp
argument_list|)
operator|<
name|len
condition|)
block|{
name|ieee_eof
argument_list|(
name|info
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
operator|*
name|pname
operator|=
operator|(
specifier|const
name|char
operator|*
operator|)
operator|*
name|pp
expr_stmt|;
operator|*
name|pnamlen
operator|=
name|len
expr_stmt|;
operator|*
name|pp
operator|+=
name|len
expr_stmt|;
if|if
condition|(
name|ppresent
operator|!=
name|NULL
condition|)
operator|*
name|ppresent
operator|=
name|true
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Read an expression from an IEEE file.  Since this code is only used    to parse debugging information, I haven't bothered to write a full    blown IEEE expression parser.  I've only thrown in the things I've    seen in debugging information.  This can be easily extended if    necessary.  */
end_comment

begin_function
specifier|static
name|boolean
name|ieee_read_expression
parameter_list|(
name|info
parameter_list|,
name|pp
parameter_list|,
name|pv
parameter_list|)
name|struct
name|ieee_info
modifier|*
name|info
decl_stmt|;
specifier|const
name|bfd_byte
modifier|*
modifier|*
name|pp
decl_stmt|;
name|bfd_vma
modifier|*
name|pv
decl_stmt|;
block|{
specifier|const
name|bfd_byte
modifier|*
name|expr_start
decl_stmt|;
define|#
directive|define
name|EXPR_STACK_SIZE
value|(10)
name|bfd_vma
name|expr_stack
index|[
name|EXPR_STACK_SIZE
index|]
decl_stmt|;
name|bfd_vma
modifier|*
name|esp
decl_stmt|;
name|expr_start
operator|=
operator|*
name|pp
expr_stmt|;
name|esp
operator|=
name|expr_stack
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
specifier|const
name|bfd_byte
modifier|*
name|start
decl_stmt|;
name|bfd_vma
name|val
decl_stmt|;
name|boolean
name|present
decl_stmt|;
name|ieee_record_enum_type
name|c
decl_stmt|;
name|start
operator|=
operator|*
name|pp
expr_stmt|;
if|if
condition|(
operator|!
name|ieee_read_optional_number
argument_list|(
name|info
argument_list|,
name|pp
argument_list|,
operator|&
name|val
argument_list|,
operator|&
name|present
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|present
condition|)
block|{
if|if
condition|(
name|esp
operator|-
name|expr_stack
operator|>=
name|EXPR_STACK_SIZE
condition|)
block|{
name|ieee_error
argument_list|(
name|info
argument_list|,
name|start
argument_list|,
name|_
argument_list|(
literal|"expression stack overflow"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
operator|*
name|esp
operator|++
operator|=
name|val
expr_stmt|;
continue|continue;
block|}
name|c
operator|=
operator|(
name|ieee_record_enum_type
operator|)
operator|*
operator|*
name|pp
expr_stmt|;
if|if
condition|(
name|c
operator|>=
name|ieee_module_beginning_enum
condition|)
break|break;
operator|++
operator|*
name|pp
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|ieee_comma
condition|)
break|break;
switch|switch
condition|(
name|c
condition|)
block|{
default|default:
name|ieee_error
argument_list|(
name|info
argument_list|,
name|start
argument_list|,
name|_
argument_list|(
literal|"unsupported IEEE expression operator"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|ieee_variable_R_enum
case|:
block|{
name|bfd_vma
name|indx
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
if|if
condition|(
operator|!
name|ieee_read_number
argument_list|(
name|info
argument_list|,
name|pp
argument_list|,
operator|&
name|indx
argument_list|)
condition|)
return|return
name|false
return|;
for|for
control|(
name|s
operator|=
name|info
operator|->
name|abfd
operator|->
name|sections
init|;
name|s
operator|!=
name|NULL
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
if|if
condition|(
operator|(
name|bfd_vma
operator|)
name|s
operator|->
name|target_index
operator|==
name|indx
condition|)
break|break;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
block|{
name|ieee_error
argument_list|(
name|info
argument_list|,
name|start
argument_list|,
name|_
argument_list|(
literal|"unknown section"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
name|esp
operator|-
name|expr_stack
operator|>=
name|EXPR_STACK_SIZE
condition|)
block|{
name|ieee_error
argument_list|(
name|info
argument_list|,
name|start
argument_list|,
name|_
argument_list|(
literal|"expression stack overflow"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
operator|*
name|esp
operator|++
operator|=
name|bfd_get_section_vma
argument_list|(
name|info
operator|->
name|abfd
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ieee_function_plus_enum
case|:
case|case
name|ieee_function_minus_enum
case|:
block|{
name|bfd_vma
name|v1
decl_stmt|,
name|v2
decl_stmt|;
if|if
condition|(
name|esp
operator|-
name|expr_stack
operator|<
literal|2
condition|)
block|{
name|ieee_error
argument_list|(
name|info
argument_list|,
name|start
argument_list|,
name|_
argument_list|(
literal|"expression stack underflow"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|v1
operator|=
operator|*
operator|--
name|esp
expr_stmt|;
name|v2
operator|=
operator|*
operator|--
name|esp
expr_stmt|;
operator|*
name|esp
operator|++
operator|=
name|v1
operator|+
name|v2
expr_stmt|;
block|}
break|break;
block|}
block|}
if|if
condition|(
name|esp
operator|-
literal|1
operator|!=
name|expr_stack
condition|)
block|{
name|ieee_error
argument_list|(
name|info
argument_list|,
name|expr_start
argument_list|,
name|_
argument_list|(
literal|"expression stack mismatch"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
operator|*
name|pv
operator|=
operator|*
operator|--
name|esp
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Return an IEEE builtin type.  */
end_comment

begin_function
specifier|static
name|debug_type
name|ieee_builtin_type
parameter_list|(
name|info
parameter_list|,
name|p
parameter_list|,
name|indx
parameter_list|)
name|struct
name|ieee_info
modifier|*
name|info
decl_stmt|;
specifier|const
name|bfd_byte
modifier|*
name|p
decl_stmt|;
name|unsigned
name|int
name|indx
decl_stmt|;
block|{
name|PTR
name|dhandle
decl_stmt|;
name|debug_type
name|type
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
if|if
condition|(
name|indx
operator|<
name|BUILTIN_TYPE_COUNT
operator|&&
name|info
operator|->
name|types
operator|.
name|builtins
index|[
name|indx
index|]
operator|!=
name|DEBUG_TYPE_NULL
condition|)
return|return
name|info
operator|->
name|types
operator|.
name|builtins
index|[
name|indx
index|]
return|;
name|dhandle
operator|=
name|info
operator|->
name|dhandle
expr_stmt|;
if|if
condition|(
name|indx
operator|>=
literal|32
operator|&&
name|indx
operator|<
literal|64
condition|)
block|{
name|type
operator|=
name|debug_make_pointer_type
argument_list|(
name|dhandle
argument_list|,
name|ieee_builtin_type
argument_list|(
name|info
argument_list|,
name|p
argument_list|,
name|indx
operator|-
literal|32
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|indx
operator|<
name|BUILTIN_TYPE_COUNT
argument_list|)
expr_stmt|;
name|info
operator|->
name|types
operator|.
name|builtins
index|[
name|indx
index|]
operator|=
name|type
expr_stmt|;
return|return
name|type
return|;
block|}
switch|switch
condition|(
operator|(
expr|enum
name|builtin_types
operator|)
name|indx
condition|)
block|{
default|default:
name|ieee_error
argument_list|(
name|info
argument_list|,
name|p
argument_list|,
name|_
argument_list|(
literal|"unknown builtin type"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
case|case
name|builtin_unknown
case|:
name|type
operator|=
name|debug_make_void_type
argument_list|(
name|dhandle
argument_list|)
expr_stmt|;
name|name
operator|=
name|NULL
expr_stmt|;
break|break;
case|case
name|builtin_void
case|:
name|type
operator|=
name|debug_make_void_type
argument_list|(
name|dhandle
argument_list|)
expr_stmt|;
name|name
operator|=
literal|"void"
expr_stmt|;
break|break;
case|case
name|builtin_signed_char
case|:
name|type
operator|=
name|debug_make_int_type
argument_list|(
name|dhandle
argument_list|,
literal|1
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|name
operator|=
literal|"signed char"
expr_stmt|;
break|break;
case|case
name|builtin_unsigned_char
case|:
name|type
operator|=
name|debug_make_int_type
argument_list|(
name|dhandle
argument_list|,
literal|1
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|name
operator|=
literal|"unsigned char"
expr_stmt|;
break|break;
case|case
name|builtin_signed_short_int
case|:
name|type
operator|=
name|debug_make_int_type
argument_list|(
name|dhandle
argument_list|,
literal|2
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|name
operator|=
literal|"signed short int"
expr_stmt|;
break|break;
case|case
name|builtin_unsigned_short_int
case|:
name|type
operator|=
name|debug_make_int_type
argument_list|(
name|dhandle
argument_list|,
literal|2
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|name
operator|=
literal|"unsigned short int"
expr_stmt|;
break|break;
case|case
name|builtin_signed_long
case|:
name|type
operator|=
name|debug_make_int_type
argument_list|(
name|dhandle
argument_list|,
literal|4
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|name
operator|=
literal|"signed long"
expr_stmt|;
break|break;
case|case
name|builtin_unsigned_long
case|:
name|type
operator|=
name|debug_make_int_type
argument_list|(
name|dhandle
argument_list|,
literal|4
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|name
operator|=
literal|"unsigned long"
expr_stmt|;
break|break;
case|case
name|builtin_signed_long_long
case|:
name|type
operator|=
name|debug_make_int_type
argument_list|(
name|dhandle
argument_list|,
literal|8
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|name
operator|=
literal|"signed long long"
expr_stmt|;
break|break;
case|case
name|builtin_unsigned_long_long
case|:
name|type
operator|=
name|debug_make_int_type
argument_list|(
name|dhandle
argument_list|,
literal|8
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|name
operator|=
literal|"unsigned long long"
expr_stmt|;
break|break;
case|case
name|builtin_float
case|:
name|type
operator|=
name|debug_make_float_type
argument_list|(
name|dhandle
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|name
operator|=
literal|"float"
expr_stmt|;
break|break;
case|case
name|builtin_double
case|:
name|type
operator|=
name|debug_make_float_type
argument_list|(
name|dhandle
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|name
operator|=
literal|"double"
expr_stmt|;
break|break;
case|case
name|builtin_long_double
case|:
comment|/* FIXME: The size for this type should depend upon the          processor.  */
name|type
operator|=
name|debug_make_float_type
argument_list|(
name|dhandle
argument_list|,
literal|12
argument_list|)
expr_stmt|;
name|name
operator|=
literal|"long double"
expr_stmt|;
break|break;
case|case
name|builtin_long_long_double
case|:
name|type
operator|=
name|debug_make_float_type
argument_list|(
name|dhandle
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|name
operator|=
literal|"long long double"
expr_stmt|;
break|break;
case|case
name|builtin_quoted_string
case|:
name|type
operator|=
name|debug_make_array_type
argument_list|(
name|dhandle
argument_list|,
name|ieee_builtin_type
argument_list|(
name|info
argument_list|,
name|p
argument_list|,
operator|(
operator|(
name|unsigned
name|int
operator|)
name|builtin_char
operator|)
argument_list|)
argument_list|,
name|ieee_builtin_type
argument_list|(
name|info
argument_list|,
name|p
argument_list|,
operator|(
operator|(
name|unsigned
name|int
operator|)
name|builtin_int
operator|)
argument_list|)
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|name
operator|=
literal|"QUOTED STRING"
expr_stmt|;
break|break;
case|case
name|builtin_instruction_address
case|:
comment|/* FIXME: This should be a code address.  */
name|type
operator|=
name|debug_make_int_type
argument_list|(
name|dhandle
argument_list|,
literal|4
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|name
operator|=
literal|"instruction address"
expr_stmt|;
break|break;
case|case
name|builtin_int
case|:
comment|/* FIXME: The size for this type should depend upon the          processor.  */
name|type
operator|=
name|debug_make_int_type
argument_list|(
name|dhandle
argument_list|,
literal|4
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|name
operator|=
literal|"int"
expr_stmt|;
break|break;
case|case
name|builtin_unsigned
case|:
comment|/* FIXME: The size for this type should depend upon the          processor.  */
name|type
operator|=
name|debug_make_int_type
argument_list|(
name|dhandle
argument_list|,
literal|4
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|name
operator|=
literal|"unsigned"
expr_stmt|;
break|break;
case|case
name|builtin_unsigned_int
case|:
comment|/* FIXME: The size for this type should depend upon the          processor.  */
name|type
operator|=
name|debug_make_int_type
argument_list|(
name|dhandle
argument_list|,
literal|4
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|name
operator|=
literal|"unsigned int"
expr_stmt|;
break|break;
case|case
name|builtin_char
case|:
name|type
operator|=
name|debug_make_int_type
argument_list|(
name|dhandle
argument_list|,
literal|1
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|name
operator|=
literal|"char"
expr_stmt|;
break|break;
case|case
name|builtin_long
case|:
name|type
operator|=
name|debug_make_int_type
argument_list|(
name|dhandle
argument_list|,
literal|4
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|name
operator|=
literal|"long"
expr_stmt|;
break|break;
case|case
name|builtin_short
case|:
name|type
operator|=
name|debug_make_int_type
argument_list|(
name|dhandle
argument_list|,
literal|2
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|name
operator|=
literal|"short"
expr_stmt|;
break|break;
case|case
name|builtin_unsigned_short
case|:
name|type
operator|=
name|debug_make_int_type
argument_list|(
name|dhandle
argument_list|,
literal|2
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|name
operator|=
literal|"unsigned short"
expr_stmt|;
break|break;
case|case
name|builtin_short_int
case|:
name|type
operator|=
name|debug_make_int_type
argument_list|(
name|dhandle
argument_list|,
literal|2
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|name
operator|=
literal|"short int"
expr_stmt|;
break|break;
case|case
name|builtin_signed_short
case|:
name|type
operator|=
name|debug_make_int_type
argument_list|(
name|dhandle
argument_list|,
literal|2
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|name
operator|=
literal|"signed short"
expr_stmt|;
break|break;
case|case
name|builtin_bcd_float
case|:
name|ieee_error
argument_list|(
name|info
argument_list|,
name|p
argument_list|,
name|_
argument_list|(
literal|"BCD float type not supported"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|DEBUG_TYPE_NULL
return|;
block|}
if|if
condition|(
name|name
operator|!=
name|NULL
condition|)
name|type
operator|=
name|debug_name_type
argument_list|(
name|dhandle
argument_list|,
name|name
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|indx
operator|<
name|BUILTIN_TYPE_COUNT
argument_list|)
expr_stmt|;
name|info
operator|->
name|types
operator|.
name|builtins
index|[
name|indx
index|]
operator|=
name|type
expr_stmt|;
return|return
name|type
return|;
block|}
end_function

begin_comment
comment|/* Allocate more space in the type table.  If ref is true, this is a    reference to the type; if it is not already defined, we should set    up an indirect type.  */
end_comment

begin_function
specifier|static
name|boolean
name|ieee_alloc_type
parameter_list|(
name|info
parameter_list|,
name|indx
parameter_list|,
name|ref
parameter_list|)
name|struct
name|ieee_info
modifier|*
name|info
decl_stmt|;
name|unsigned
name|int
name|indx
decl_stmt|;
name|boolean
name|ref
decl_stmt|;
block|{
name|unsigned
name|int
name|nalloc
decl_stmt|;
specifier|register
name|struct
name|ieee_type
modifier|*
name|t
decl_stmt|;
name|struct
name|ieee_type
modifier|*
name|tend
decl_stmt|;
if|if
condition|(
name|indx
operator|>=
name|info
operator|->
name|types
operator|.
name|alloc
condition|)
block|{
name|nalloc
operator|=
name|info
operator|->
name|types
operator|.
name|alloc
expr_stmt|;
if|if
condition|(
name|nalloc
operator|==
literal|0
condition|)
name|nalloc
operator|=
literal|4
expr_stmt|;
while|while
condition|(
name|indx
operator|>=
name|nalloc
condition|)
name|nalloc
operator|*=
literal|2
expr_stmt|;
name|info
operator|->
name|types
operator|.
name|types
operator|=
operator|(
operator|(
expr|struct
name|ieee_type
operator|*
operator|)
name|xrealloc
argument_list|(
name|info
operator|->
name|types
operator|.
name|types
argument_list|,
name|nalloc
operator|*
sizeof|sizeof
expr|*
name|info
operator|->
name|types
operator|.
name|types
argument_list|)
operator|)
expr_stmt|;
name|memset
argument_list|(
name|info
operator|->
name|types
operator|.
name|types
operator|+
name|info
operator|->
name|types
operator|.
name|alloc
argument_list|,
literal|0
argument_list|,
operator|(
name|nalloc
operator|-
name|info
operator|->
name|types
operator|.
name|alloc
operator|)
operator|*
sizeof|sizeof
expr|*
name|info
operator|->
name|types
operator|.
name|types
argument_list|)
expr_stmt|;
name|tend
operator|=
name|info
operator|->
name|types
operator|.
name|types
operator|+
name|nalloc
expr_stmt|;
for|for
control|(
name|t
operator|=
name|info
operator|->
name|types
operator|.
name|types
operator|+
name|info
operator|->
name|types
operator|.
name|alloc
init|;
name|t
operator|<
name|tend
condition|;
name|t
operator|++
control|)
name|t
operator|->
name|type
operator|=
name|DEBUG_TYPE_NULL
expr_stmt|;
name|info
operator|->
name|types
operator|.
name|alloc
operator|=
name|nalloc
expr_stmt|;
block|}
if|if
condition|(
name|ref
condition|)
block|{
name|t
operator|=
name|info
operator|->
name|types
operator|.
name|types
operator|+
name|indx
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|type
operator|==
name|NULL
condition|)
block|{
name|t
operator|->
name|pslot
operator|=
operator|(
name|debug_type
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
expr|*
name|t
operator|->
name|pslot
argument_list|)
expr_stmt|;
operator|*
name|t
operator|->
name|pslot
operator|=
name|DEBUG_TYPE_NULL
expr_stmt|;
name|t
operator|->
name|type
operator|=
name|debug_make_indirect_type
argument_list|(
name|info
operator|->
name|dhandle
argument_list|,
name|t
operator|->
name|pslot
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|type
operator|==
name|NULL
condition|)
return|return
name|false
return|;
block|}
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Read a type index and return the corresponding type.  */
end_comment

begin_function
specifier|static
name|boolean
name|ieee_read_type_index
parameter_list|(
name|info
parameter_list|,
name|pp
parameter_list|,
name|ptype
parameter_list|)
name|struct
name|ieee_info
modifier|*
name|info
decl_stmt|;
specifier|const
name|bfd_byte
modifier|*
modifier|*
name|pp
decl_stmt|;
name|debug_type
modifier|*
name|ptype
decl_stmt|;
block|{
specifier|const
name|bfd_byte
modifier|*
name|start
decl_stmt|;
name|bfd_vma
name|indx
decl_stmt|;
name|start
operator|=
operator|*
name|pp
expr_stmt|;
if|if
condition|(
operator|!
name|ieee_read_number
argument_list|(
name|info
argument_list|,
name|pp
argument_list|,
operator|&
name|indx
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|indx
operator|<
literal|256
condition|)
block|{
operator|*
name|ptype
operator|=
name|ieee_builtin_type
argument_list|(
name|info
argument_list|,
name|start
argument_list|,
name|indx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|ptype
operator|==
name|NULL
condition|)
return|return
name|false
return|;
return|return
name|true
return|;
block|}
name|indx
operator|-=
literal|256
expr_stmt|;
if|if
condition|(
operator|!
name|ieee_alloc_type
argument_list|(
name|info
argument_list|,
name|indx
argument_list|,
name|true
argument_list|)
condition|)
return|return
name|false
return|;
operator|*
name|ptype
operator|=
name|info
operator|->
name|types
operator|.
name|types
index|[
name|indx
index|]
operator|.
name|type
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Parse IEEE debugging information for a file.  This is passed the    bytes which compose the Debug Information Part of an IEEE file.  */
end_comment

begin_function
name|boolean
name|parse_ieee
parameter_list|(
name|dhandle
parameter_list|,
name|abfd
parameter_list|,
name|bytes
parameter_list|,
name|len
parameter_list|)
name|PTR
name|dhandle
decl_stmt|;
name|bfd
modifier|*
name|abfd
decl_stmt|;
specifier|const
name|bfd_byte
modifier|*
name|bytes
decl_stmt|;
name|bfd_size_type
name|len
decl_stmt|;
block|{
name|struct
name|ieee_info
name|info
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
specifier|const
name|bfd_byte
modifier|*
name|p
decl_stmt|,
modifier|*
name|pend
decl_stmt|;
name|info
operator|.
name|dhandle
operator|=
name|dhandle
expr_stmt|;
name|info
operator|.
name|abfd
operator|=
name|abfd
expr_stmt|;
name|info
operator|.
name|bytes
operator|=
name|bytes
expr_stmt|;
name|info
operator|.
name|pend
operator|=
name|bytes
operator|+
name|len
expr_stmt|;
name|info
operator|.
name|blockstack
operator|.
name|bsp
operator|=
name|info
operator|.
name|blockstack
operator|.
name|stack
expr_stmt|;
name|info
operator|.
name|saw_filename
operator|=
name|false
expr_stmt|;
name|info
operator|.
name|vars
operator|.
name|alloc
operator|=
literal|0
expr_stmt|;
name|info
operator|.
name|vars
operator|.
name|vars
operator|=
name|NULL
expr_stmt|;
name|info
operator|.
name|global_vars
operator|=
name|NULL
expr_stmt|;
name|info
operator|.
name|types
operator|.
name|alloc
operator|=
literal|0
expr_stmt|;
name|info
operator|.
name|types
operator|.
name|types
operator|=
name|NULL
expr_stmt|;
name|info
operator|.
name|global_types
operator|=
name|NULL
expr_stmt|;
name|info
operator|.
name|tags
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|BUILTIN_TYPE_COUNT
condition|;
name|i
operator|++
control|)
name|info
operator|.
name|types
operator|.
name|builtins
index|[
name|i
index|]
operator|=
name|DEBUG_TYPE_NULL
expr_stmt|;
name|p
operator|=
name|bytes
expr_stmt|;
name|pend
operator|=
name|info
operator|.
name|pend
expr_stmt|;
while|while
condition|(
name|p
operator|<
name|pend
condition|)
block|{
specifier|const
name|bfd_byte
modifier|*
name|record_start
decl_stmt|;
name|ieee_record_enum_type
name|c
decl_stmt|;
name|record_start
operator|=
name|p
expr_stmt|;
name|c
operator|=
operator|(
name|ieee_record_enum_type
operator|)
operator|*
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|ieee_at_record_enum
condition|)
name|c
operator|=
call|(
name|ieee_record_enum_type
call|)
argument_list|(
operator|(
operator|(
name|unsigned
name|int
operator|)
name|c
operator|<<
literal|8
operator|)
operator||
operator|*
name|p
operator|++
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|<=
name|ieee_number_repeat_end_enum
condition|)
block|{
name|ieee_error
argument_list|(
operator|&
name|info
argument_list|,
name|record_start
argument_list|,
name|_
argument_list|(
literal|"unexpected number"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
switch|switch
condition|(
name|c
condition|)
block|{
default|default:
name|ieee_error
argument_list|(
operator|&
name|info
argument_list|,
name|record_start
argument_list|,
name|_
argument_list|(
literal|"unexpected record type"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|false
return|;
case|case
name|ieee_bb_record_enum
case|:
if|if
condition|(
operator|!
name|parse_ieee_bb
argument_list|(
operator|&
name|info
argument_list|,
operator|&
name|p
argument_list|)
condition|)
return|return
name|false
return|;
break|break;
case|case
name|ieee_be_record_enum
case|:
if|if
condition|(
operator|!
name|parse_ieee_be
argument_list|(
operator|&
name|info
argument_list|,
operator|&
name|p
argument_list|)
condition|)
return|return
name|false
return|;
break|break;
case|case
name|ieee_nn_record
case|:
if|if
condition|(
operator|!
name|parse_ieee_nn
argument_list|(
operator|&
name|info
argument_list|,
operator|&
name|p
argument_list|)
condition|)
return|return
name|false
return|;
break|break;
case|case
name|ieee_ty_record_enum
case|:
if|if
condition|(
operator|!
name|parse_ieee_ty
argument_list|(
operator|&
name|info
argument_list|,
operator|&
name|p
argument_list|)
condition|)
return|return
name|false
return|;
break|break;
case|case
name|ieee_atn_record_enum
case|:
if|if
condition|(
operator|!
name|parse_ieee_atn
argument_list|(
operator|&
name|info
argument_list|,
operator|&
name|p
argument_list|)
condition|)
return|return
name|false
return|;
break|break;
block|}
block|}
if|if
condition|(
name|info
operator|.
name|blockstack
operator|.
name|bsp
operator|!=
name|info
operator|.
name|blockstack
operator|.
name|stack
condition|)
block|{
name|ieee_error
argument_list|(
operator|&
name|info
argument_list|,
operator|(
specifier|const
name|bfd_byte
operator|*
operator|)
name|NULL
argument_list|,
name|_
argument_list|(
literal|"blocks left on stack at end"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Handle an IEEE BB record.  */
end_comment

begin_function
specifier|static
name|boolean
name|parse_ieee_bb
parameter_list|(
name|info
parameter_list|,
name|pp
parameter_list|)
name|struct
name|ieee_info
modifier|*
name|info
decl_stmt|;
specifier|const
name|bfd_byte
modifier|*
modifier|*
name|pp
decl_stmt|;
block|{
specifier|const
name|bfd_byte
modifier|*
name|block_start
decl_stmt|;
name|bfd_byte
name|b
decl_stmt|;
name|bfd_vma
name|size
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|unsigned
name|long
name|namlen
decl_stmt|;
name|char
modifier|*
name|namcopy
init|=
name|NULL
decl_stmt|;
name|unsigned
name|int
name|fnindx
decl_stmt|;
name|boolean
name|skip
decl_stmt|;
name|block_start
operator|=
operator|*
name|pp
expr_stmt|;
name|b
operator|=
operator|*
operator|*
name|pp
expr_stmt|;
operator|++
operator|*
name|pp
expr_stmt|;
if|if
condition|(
operator|!
name|ieee_read_number
argument_list|(
name|info
argument_list|,
name|pp
argument_list|,
operator|&
name|size
argument_list|)
operator|||
operator|!
name|ieee_read_id
argument_list|(
name|info
argument_list|,
name|pp
argument_list|,
operator|&
name|name
argument_list|,
operator|&
name|namlen
argument_list|)
condition|)
return|return
name|false
return|;
name|fnindx
operator|=
operator|(
name|unsigned
name|int
operator|)
operator|-
literal|1
expr_stmt|;
name|skip
operator|=
name|false
expr_stmt|;
switch|switch
condition|(
name|b
condition|)
block|{
case|case
literal|1
case|:
comment|/* BB1: Type definitions local to a module.  */
name|namcopy
operator|=
name|savestring
argument_list|(
name|name
argument_list|,
name|namlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|namcopy
operator|==
name|NULL
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|!
name|debug_set_filename
argument_list|(
name|info
operator|->
name|dhandle
argument_list|,
name|namcopy
argument_list|)
condition|)
return|return
name|false
return|;
name|info
operator|->
name|saw_filename
operator|=
name|true
expr_stmt|;
comment|/* Discard any variables or types we may have seen before.  */
if|if
condition|(
name|info
operator|->
name|vars
operator|.
name|vars
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|info
operator|->
name|vars
operator|.
name|vars
argument_list|)
expr_stmt|;
name|info
operator|->
name|vars
operator|.
name|vars
operator|=
name|NULL
expr_stmt|;
name|info
operator|->
name|vars
operator|.
name|alloc
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|types
operator|.
name|types
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|info
operator|->
name|types
operator|.
name|types
argument_list|)
expr_stmt|;
name|info
operator|->
name|types
operator|.
name|types
operator|=
name|NULL
expr_stmt|;
name|info
operator|->
name|types
operator|.
name|alloc
operator|=
literal|0
expr_stmt|;
comment|/* Initialize the types to the global types.  */
if|if
condition|(
name|info
operator|->
name|global_types
operator|!=
name|NULL
condition|)
block|{
name|info
operator|->
name|types
operator|.
name|alloc
operator|=
name|info
operator|->
name|global_types
operator|->
name|alloc
expr_stmt|;
name|info
operator|->
name|types
operator|.
name|types
operator|=
operator|(
operator|(
expr|struct
name|ieee_type
operator|*
operator|)
name|xmalloc
argument_list|(
name|info
operator|->
name|types
operator|.
name|alloc
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|info
operator|->
name|types
operator|.
name|types
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|memcpy
argument_list|(
name|info
operator|->
name|types
operator|.
name|types
argument_list|,
name|info
operator|->
name|global_types
operator|->
name|types
argument_list|,
name|info
operator|->
name|types
operator|.
name|alloc
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|info
operator|->
name|types
operator|.
name|types
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|2
case|:
comment|/* BB2: Global type definitions.  The name is supposed to be 	 empty, but we don't check. */
if|if
condition|(
operator|!
name|debug_set_filename
argument_list|(
name|info
operator|->
name|dhandle
argument_list|,
literal|"*global*"
argument_list|)
condition|)
return|return
name|false
return|;
name|info
operator|->
name|saw_filename
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|3
case|:
comment|/* BB3: High level module block begin.  We don't have to do 	 anything here.  The name is supposed to be the same as for 	 the BB1, but we don't check.  */
break|break;
case|case
literal|4
case|:
comment|/* BB4: Global function.  */
block|{
name|bfd_vma
name|stackspace
decl_stmt|,
name|typindx
decl_stmt|,
name|offset
decl_stmt|;
name|debug_type
name|return_type
decl_stmt|;
if|if
condition|(
operator|!
name|ieee_read_number
argument_list|(
name|info
argument_list|,
name|pp
argument_list|,
operator|&
name|stackspace
argument_list|)
operator|||
operator|!
name|ieee_read_number
argument_list|(
name|info
argument_list|,
name|pp
argument_list|,
operator|&
name|typindx
argument_list|)
operator|||
operator|!
name|ieee_read_expression
argument_list|(
name|info
argument_list|,
name|pp
argument_list|,
operator|&
name|offset
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* We have no way to record the stack space.  FIXME.  */
if|if
condition|(
name|typindx
operator|<
literal|256
condition|)
block|{
name|return_type
operator|=
name|ieee_builtin_type
argument_list|(
name|info
argument_list|,
name|block_start
argument_list|,
name|typindx
argument_list|)
expr_stmt|;
if|if
condition|(
name|return_type
operator|==
name|DEBUG_TYPE_NULL
condition|)
return|return
name|false
return|;
block|}
else|else
block|{
name|typindx
operator|-=
literal|256
expr_stmt|;
if|if
condition|(
operator|!
name|ieee_alloc_type
argument_list|(
name|info
argument_list|,
name|typindx
argument_list|,
name|true
argument_list|)
condition|)
return|return
name|false
return|;
name|fnindx
operator|=
name|typindx
expr_stmt|;
name|return_type
operator|=
name|info
operator|->
name|types
operator|.
name|types
index|[
name|typindx
index|]
operator|.
name|type
expr_stmt|;
if|if
condition|(
name|debug_get_type_kind
argument_list|(
name|info
operator|->
name|dhandle
argument_list|,
name|return_type
argument_list|)
operator|==
name|DEBUG_KIND_FUNCTION
condition|)
name|return_type
operator|=
name|debug_get_return_type
argument_list|(
name|info
operator|->
name|dhandle
argument_list|,
name|return_type
argument_list|)
expr_stmt|;
block|}
name|namcopy
operator|=
name|savestring
argument_list|(
name|name
argument_list|,
name|namlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|namcopy
operator|==
name|NULL
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|!
name|debug_record_function
argument_list|(
name|info
operator|->
name|dhandle
argument_list|,
name|namcopy
argument_list|,
name|return_type
argument_list|,
name|true
argument_list|,
name|offset
argument_list|)
condition|)
return|return
name|false
return|;
block|}
break|break;
case|case
literal|5
case|:
comment|/* BB5: File name for source line numbers.  */
block|{
name|unsigned
name|int
name|i
decl_stmt|;
comment|/* We ignore the date and time.  FIXME.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|6
condition|;
name|i
operator|++
control|)
block|{
name|bfd_vma
name|ignore
decl_stmt|;
name|boolean
name|present
decl_stmt|;
if|if
condition|(
operator|!
name|ieee_read_optional_number
argument_list|(
name|info
argument_list|,
name|pp
argument_list|,
operator|&
name|ignore
argument_list|,
operator|&
name|present
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|!
name|present
condition|)
break|break;
block|}
name|namcopy
operator|=
name|savestring
argument_list|(
name|name
argument_list|,
name|namlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|namcopy
operator|==
name|NULL
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|!
name|debug_start_source
argument_list|(
name|info
operator|->
name|dhandle
argument_list|,
name|namcopy
argument_list|)
condition|)
return|return
name|false
return|;
block|}
break|break;
case|case
literal|6
case|:
comment|/* BB6: Local function or block.  */
block|{
name|bfd_vma
name|stackspace
decl_stmt|,
name|typindx
decl_stmt|,
name|offset
decl_stmt|;
if|if
condition|(
operator|!
name|ieee_read_number
argument_list|(
name|info
argument_list|,
name|pp
argument_list|,
operator|&
name|stackspace
argument_list|)
operator|||
operator|!
name|ieee_read_number
argument_list|(
name|info
argument_list|,
name|pp
argument_list|,
operator|&
name|typindx
argument_list|)
operator|||
operator|!
name|ieee_read_expression
argument_list|(
name|info
argument_list|,
name|pp
argument_list|,
operator|&
name|offset
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* We have no way to record the stack space.  FIXME.  */
if|if
condition|(
name|namlen
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|debug_start_block
argument_list|(
name|info
operator|->
name|dhandle
argument_list|,
name|offset
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* Change b to indicate that this is a block 	       rather than a function.  */
name|b
operator|=
literal|0x86
expr_stmt|;
block|}
else|else
block|{
comment|/* The MRI C++ compiler will output a fake function named 	       __XRYCPP to hold C++ debugging information.  We skip 	       that function.  This is not crucial, but it makes 	       converting from IEEE to other debug formats work 	       better.  */
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
literal|"__XRYCPP"
argument_list|,
name|namlen
argument_list|)
operator|==
literal|0
condition|)
name|skip
operator|=
name|true
expr_stmt|;
else|else
block|{
name|debug_type
name|return_type
decl_stmt|;
if|if
condition|(
name|typindx
operator|<
literal|256
condition|)
block|{
name|return_type
operator|=
name|ieee_builtin_type
argument_list|(
name|info
argument_list|,
name|block_start
argument_list|,
name|typindx
argument_list|)
expr_stmt|;
if|if
condition|(
name|return_type
operator|==
name|NULL
condition|)
return|return
name|false
return|;
block|}
else|else
block|{
name|typindx
operator|-=
literal|256
expr_stmt|;
if|if
condition|(
operator|!
name|ieee_alloc_type
argument_list|(
name|info
argument_list|,
name|typindx
argument_list|,
name|true
argument_list|)
condition|)
return|return
name|false
return|;
name|fnindx
operator|=
name|typindx
expr_stmt|;
name|return_type
operator|=
name|info
operator|->
name|types
operator|.
name|types
index|[
name|typindx
index|]
operator|.
name|type
expr_stmt|;
if|if
condition|(
name|debug_get_type_kind
argument_list|(
name|info
operator|->
name|dhandle
argument_list|,
name|return_type
argument_list|)
operator|==
name|DEBUG_KIND_FUNCTION
condition|)
name|return_type
operator|=
name|debug_get_return_type
argument_list|(
name|info
operator|->
name|dhandle
argument_list|,
name|return_type
argument_list|)
expr_stmt|;
block|}
name|namcopy
operator|=
name|savestring
argument_list|(
name|name
argument_list|,
name|namlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|namcopy
operator|==
name|NULL
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|!
name|debug_record_function
argument_list|(
name|info
operator|->
name|dhandle
argument_list|,
name|namcopy
argument_list|,
name|return_type
argument_list|,
name|false
argument_list|,
name|offset
argument_list|)
condition|)
return|return
name|false
return|;
block|}
block|}
block|}
break|break;
case|case
literal|10
case|:
comment|/* BB10: Assembler module scope.  In the normal case, we 	 completely ignore all this information.  FIXME.  */
block|{
specifier|const
name|char
modifier|*
name|inam
decl_stmt|,
modifier|*
name|vstr
decl_stmt|;
name|unsigned
name|long
name|inamlen
decl_stmt|,
name|vstrlen
decl_stmt|;
name|bfd_vma
name|tool_type
decl_stmt|;
name|boolean
name|present
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|info
operator|->
name|saw_filename
condition|)
block|{
name|namcopy
operator|=
name|savestring
argument_list|(
name|name
argument_list|,
name|namlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|namcopy
operator|==
name|NULL
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|!
name|debug_set_filename
argument_list|(
name|info
operator|->
name|dhandle
argument_list|,
name|namcopy
argument_list|)
condition|)
return|return
name|false
return|;
name|info
operator|->
name|saw_filename
operator|=
name|true
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|ieee_read_id
argument_list|(
name|info
argument_list|,
name|pp
argument_list|,
operator|&
name|inam
argument_list|,
operator|&
name|inamlen
argument_list|)
operator|||
operator|!
name|ieee_read_number
argument_list|(
name|info
argument_list|,
name|pp
argument_list|,
operator|&
name|tool_type
argument_list|)
operator|||
operator|!
name|ieee_read_optional_id
argument_list|(
name|info
argument_list|,
name|pp
argument_list|,
operator|&
name|vstr
argument_list|,
operator|&
name|vstrlen
argument_list|,
operator|&
name|present
argument_list|)
condition|)
return|return
name|false
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|6
condition|;
name|i
operator|++
control|)
block|{
name|bfd_vma
name|ignore
decl_stmt|;
if|if
condition|(
operator|!
name|ieee_read_optional_number
argument_list|(
name|info
argument_list|,
name|pp
argument_list|,
operator|&
name|ignore
argument_list|,
operator|&
name|present
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|!
name|present
condition|)
break|break;
block|}
block|}
break|break;
case|case
literal|11
case|:
comment|/* BB11: Module section.  We completely ignore all this 	 information.  FIXME.  */
block|{
name|bfd_vma
name|sectype
decl_stmt|,
name|secindx
decl_stmt|,
name|offset
decl_stmt|,
name|map
decl_stmt|;
name|boolean
name|present
decl_stmt|;
if|if
condition|(
operator|!
name|ieee_read_number
argument_list|(
name|info
argument_list|,
name|pp
argument_list|,
operator|&
name|sectype
argument_list|)
operator|||
operator|!
name|ieee_read_number
argument_list|(
name|info
argument_list|,
name|pp
argument_list|,
operator|&
name|secindx
argument_list|)
operator|||
operator|!
name|ieee_read_expression
argument_list|(
name|info
argument_list|,
name|pp
argument_list|,
operator|&
name|offset
argument_list|)
operator|||
operator|!
name|ieee_read_optional_number
argument_list|(
name|info
argument_list|,
name|pp
argument_list|,
operator|&
name|map
argument_list|,
operator|&
name|present
argument_list|)
condition|)
return|return
name|false
return|;
block|}
break|break;
default|default:
name|ieee_error
argument_list|(
name|info
argument_list|,
name|block_start
argument_list|,
name|_
argument_list|(
literal|"unknown BB type"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
comment|/* Push this block on the block stack.  */
if|if
condition|(
name|info
operator|->
name|blockstack
operator|.
name|bsp
operator|>=
name|info
operator|->
name|blockstack
operator|.
name|stack
operator|+
name|BLOCKSTACK_SIZE
condition|)
block|{
name|ieee_error
argument_list|(
name|info
argument_list|,
operator|(
specifier|const
name|bfd_byte
operator|*
operator|)
name|NULL
argument_list|,
name|_
argument_list|(
literal|"stack overflow"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|info
operator|->
name|blockstack
operator|.
name|bsp
operator|->
name|kind
operator|=
name|b
expr_stmt|;
if|if
condition|(
name|b
operator|==
literal|5
condition|)
name|info
operator|->
name|blockstack
operator|.
name|bsp
operator|->
name|filename
operator|=
name|namcopy
expr_stmt|;
name|info
operator|->
name|blockstack
operator|.
name|bsp
operator|->
name|fnindx
operator|=
name|fnindx
expr_stmt|;
name|info
operator|->
name|blockstack
operator|.
name|bsp
operator|->
name|skip
operator|=
name|skip
expr_stmt|;
operator|++
name|info
operator|->
name|blockstack
operator|.
name|bsp
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Handle an IEEE BE record.  */
end_comment

begin_function
specifier|static
name|boolean
name|parse_ieee_be
parameter_list|(
name|info
parameter_list|,
name|pp
parameter_list|)
name|struct
name|ieee_info
modifier|*
name|info
decl_stmt|;
specifier|const
name|bfd_byte
modifier|*
modifier|*
name|pp
decl_stmt|;
block|{
name|bfd_vma
name|offset
decl_stmt|;
if|if
condition|(
name|info
operator|->
name|blockstack
operator|.
name|bsp
operator|<=
name|info
operator|->
name|blockstack
operator|.
name|stack
condition|)
block|{
name|ieee_error
argument_list|(
name|info
argument_list|,
operator|*
name|pp
argument_list|,
name|_
argument_list|(
literal|"stack underflow"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
operator|--
name|info
operator|->
name|blockstack
operator|.
name|bsp
expr_stmt|;
switch|switch
condition|(
name|info
operator|->
name|blockstack
operator|.
name|bsp
operator|->
name|kind
condition|)
block|{
case|case
literal|2
case|:
comment|/* When we end the global typedefs block, we copy out the the          contents of info->vars.  This is because the variable indices          may be reused in the local blocks.  However, we need to          preserve them so that we can locate a function returning a          reference variable whose type is named in the global typedef          block.  */
name|info
operator|->
name|global_vars
operator|=
operator|(
operator|(
expr|struct
name|ieee_vars
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
expr|*
name|info
operator|->
name|global_vars
argument_list|)
operator|)
expr_stmt|;
name|info
operator|->
name|global_vars
operator|->
name|alloc
operator|=
name|info
operator|->
name|vars
operator|.
name|alloc
expr_stmt|;
name|info
operator|->
name|global_vars
operator|->
name|vars
operator|=
operator|(
operator|(
expr|struct
name|ieee_var
operator|*
operator|)
name|xmalloc
argument_list|(
name|info
operator|->
name|vars
operator|.
name|alloc
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|info
operator|->
name|vars
operator|.
name|vars
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|memcpy
argument_list|(
name|info
operator|->
name|global_vars
operator|->
name|vars
argument_list|,
name|info
operator|->
name|vars
operator|.
name|vars
argument_list|,
name|info
operator|->
name|vars
operator|.
name|alloc
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|info
operator|->
name|vars
operator|.
name|vars
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We also copy out the non builtin parts of info->types, since          the types are discarded when we start a new block.  */
name|info
operator|->
name|global_types
operator|=
operator|(
operator|(
expr|struct
name|ieee_types
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
expr|*
name|info
operator|->
name|global_types
argument_list|)
operator|)
expr_stmt|;
name|info
operator|->
name|global_types
operator|->
name|alloc
operator|=
name|info
operator|->
name|types
operator|.
name|alloc
expr_stmt|;
name|info
operator|->
name|global_types
operator|->
name|types
operator|=
operator|(
operator|(
expr|struct
name|ieee_type
operator|*
operator|)
name|xmalloc
argument_list|(
name|info
operator|->
name|types
operator|.
name|alloc
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|info
operator|->
name|types
operator|.
name|types
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|memcpy
argument_list|(
name|info
operator|->
name|global_types
operator|->
name|types
argument_list|,
name|info
operator|->
name|types
operator|.
name|types
argument_list|,
name|info
operator|->
name|types
operator|.
name|alloc
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|info
operator|->
name|types
operator|.
name|types
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|info
operator|->
name|global_types
operator|->
name|builtins
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|info
operator|->
name|global_types
operator|->
name|builtins
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
case|case
literal|6
case|:
if|if
condition|(
operator|!
name|ieee_read_expression
argument_list|(
name|info
argument_list|,
name|pp
argument_list|,
operator|&
name|offset
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|!
name|info
operator|->
name|blockstack
operator|.
name|bsp
operator|->
name|skip
condition|)
block|{
if|if
condition|(
operator|!
name|debug_end_function
argument_list|(
name|info
operator|->
name|dhandle
argument_list|,
name|offset
operator|+
literal|1
argument_list|)
condition|)
return|return
name|false
return|;
block|}
break|break;
case|case
literal|0x86
case|:
comment|/* This is BE6 when BB6 started a block rather than a local 	 function.  */
if|if
condition|(
operator|!
name|ieee_read_expression
argument_list|(
name|info
argument_list|,
name|pp
argument_list|,
operator|&
name|offset
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|!
name|debug_end_block
argument_list|(
name|info
operator|->
name|dhandle
argument_list|,
name|offset
operator|+
literal|1
argument_list|)
condition|)
return|return
name|false
return|;
break|break;
case|case
literal|5
case|:
comment|/* When we end a BB5, we look up the stack for the last BB5, if          there is one, so that we can call debug_start_source.  */
if|if
condition|(
name|info
operator|->
name|blockstack
operator|.
name|bsp
operator|>
name|info
operator|->
name|blockstack
operator|.
name|stack
condition|)
block|{
name|struct
name|ieee_block
modifier|*
name|bl
decl_stmt|;
name|bl
operator|=
name|info
operator|->
name|blockstack
operator|.
name|bsp
expr_stmt|;
do|do
block|{
operator|--
name|bl
expr_stmt|;
if|if
condition|(
name|bl
operator|->
name|kind
operator|==
literal|5
condition|)
block|{
if|if
condition|(
operator|!
name|debug_start_source
argument_list|(
name|info
operator|->
name|dhandle
argument_list|,
name|bl
operator|->
name|filename
argument_list|)
condition|)
return|return
name|false
return|;
break|break;
block|}
block|}
do|while
condition|(
name|bl
operator|!=
name|info
operator|->
name|blockstack
operator|.
name|stack
condition|)
do|;
block|}
break|break;
case|case
literal|11
case|:
if|if
condition|(
operator|!
name|ieee_read_expression
argument_list|(
name|info
argument_list|,
name|pp
argument_list|,
operator|&
name|offset
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* We just ignore the module size.  FIXME.  */
break|break;
default|default:
comment|/* Other block types do not have any trailing information.  */
break|break;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Parse an NN record.  */
end_comment

begin_function
specifier|static
name|boolean
name|parse_ieee_nn
parameter_list|(
name|info
parameter_list|,
name|pp
parameter_list|)
name|struct
name|ieee_info
modifier|*
name|info
decl_stmt|;
specifier|const
name|bfd_byte
modifier|*
modifier|*
name|pp
decl_stmt|;
block|{
specifier|const
name|bfd_byte
modifier|*
name|nn_start
decl_stmt|;
name|bfd_vma
name|varindx
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|unsigned
name|long
name|namlen
decl_stmt|;
name|nn_start
operator|=
operator|*
name|pp
expr_stmt|;
if|if
condition|(
operator|!
name|ieee_read_number
argument_list|(
name|info
argument_list|,
name|pp
argument_list|,
operator|&
name|varindx
argument_list|)
operator|||
operator|!
name|ieee_read_id
argument_list|(
name|info
argument_list|,
name|pp
argument_list|,
operator|&
name|name
argument_list|,
operator|&
name|namlen
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|varindx
operator|<
literal|32
condition|)
block|{
name|ieee_error
argument_list|(
name|info
argument_list|,
name|nn_start
argument_list|,
name|_
argument_list|(
literal|"illegal variable index"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|varindx
operator|-=
literal|32
expr_stmt|;
if|if
condition|(
name|varindx
operator|>=
name|info
operator|->
name|vars
operator|.
name|alloc
condition|)
block|{
name|unsigned
name|int
name|alloc
decl_stmt|;
name|alloc
operator|=
name|info
operator|->
name|vars
operator|.
name|alloc
expr_stmt|;
if|if
condition|(
name|alloc
operator|==
literal|0
condition|)
name|alloc
operator|=
literal|4
expr_stmt|;
while|while
condition|(
name|varindx
operator|>=
name|alloc
condition|)
name|alloc
operator|*=
literal|2
expr_stmt|;
name|info
operator|->
name|vars
operator|.
name|vars
operator|=
operator|(
operator|(
expr|struct
name|ieee_var
operator|*
operator|)
name|xrealloc
argument_list|(
name|info
operator|->
name|vars
operator|.
name|vars
argument_list|,
name|alloc
operator|*
sizeof|sizeof
expr|*
name|info
operator|->
name|vars
operator|.
name|vars
argument_list|)
operator|)
expr_stmt|;
name|memset
argument_list|(
name|info
operator|->
name|vars
operator|.
name|vars
operator|+
name|info
operator|->
name|vars
operator|.
name|alloc
argument_list|,
literal|0
argument_list|,
operator|(
name|alloc
operator|-
name|info
operator|->
name|vars
operator|.
name|alloc
operator|)
operator|*
sizeof|sizeof
expr|*
name|info
operator|->
name|vars
operator|.
name|vars
argument_list|)
expr_stmt|;
name|info
operator|->
name|vars
operator|.
name|alloc
operator|=
name|alloc
expr_stmt|;
block|}
name|info
operator|->
name|vars
operator|.
name|vars
index|[
name|varindx
index|]
operator|.
name|name
operator|=
name|name
expr_stmt|;
name|info
operator|->
name|vars
operator|.
name|vars
index|[
name|varindx
index|]
operator|.
name|namlen
operator|=
name|namlen
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Parse a TY record.  */
end_comment

begin_function
specifier|static
name|boolean
name|parse_ieee_ty
parameter_list|(
name|info
parameter_list|,
name|pp
parameter_list|)
name|struct
name|ieee_info
modifier|*
name|info
decl_stmt|;
specifier|const
name|bfd_byte
modifier|*
modifier|*
name|pp
decl_stmt|;
block|{
specifier|const
name|bfd_byte
modifier|*
name|ty_start
decl_stmt|,
modifier|*
name|ty_var_start
decl_stmt|,
modifier|*
name|ty_code_start
decl_stmt|;
name|bfd_vma
name|typeindx
decl_stmt|,
name|varindx
decl_stmt|,
name|tc
decl_stmt|;
name|PTR
name|dhandle
decl_stmt|;
name|boolean
name|tag
decl_stmt|,
name|typdef
decl_stmt|;
name|debug_type
modifier|*
name|arg_slots
decl_stmt|;
name|unsigned
name|long
name|type_bitsize
decl_stmt|;
name|debug_type
name|type
decl_stmt|;
name|ty_start
operator|=
operator|*
name|pp
expr_stmt|;
if|if
condition|(
operator|!
name|ieee_read_number
argument_list|(
name|info
argument_list|,
name|pp
argument_list|,
operator|&
name|typeindx
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|typeindx
operator|<
literal|256
condition|)
block|{
name|ieee_error
argument_list|(
name|info
argument_list|,
name|ty_start
argument_list|,
name|_
argument_list|(
literal|"illegal type index"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|typeindx
operator|-=
literal|256
expr_stmt|;
if|if
condition|(
operator|!
name|ieee_alloc_type
argument_list|(
name|info
argument_list|,
name|typeindx
argument_list|,
name|false
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|*
operator|*
name|pp
operator|!=
literal|0xce
condition|)
block|{
name|ieee_error
argument_list|(
name|info
argument_list|,
operator|*
name|pp
argument_list|,
name|_
argument_list|(
literal|"unknown TY code"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
operator|++
operator|*
name|pp
expr_stmt|;
name|ty_var_start
operator|=
operator|*
name|pp
expr_stmt|;
if|if
condition|(
operator|!
name|ieee_read_number
argument_list|(
name|info
argument_list|,
name|pp
argument_list|,
operator|&
name|varindx
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|varindx
operator|<
literal|32
condition|)
block|{
name|ieee_error
argument_list|(
name|info
argument_list|,
name|ty_var_start
argument_list|,
name|_
argument_list|(
literal|"illegal variable index"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|varindx
operator|-=
literal|32
expr_stmt|;
if|if
condition|(
name|varindx
operator|>=
name|info
operator|->
name|vars
operator|.
name|alloc
operator|||
name|info
operator|->
name|vars
operator|.
name|vars
index|[
name|varindx
index|]
operator|.
name|name
operator|==
name|NULL
condition|)
block|{
name|ieee_error
argument_list|(
name|info
argument_list|,
name|ty_var_start
argument_list|,
name|_
argument_list|(
literal|"undefined variable in TY"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|ty_code_start
operator|=
operator|*
name|pp
expr_stmt|;
if|if
condition|(
operator|!
name|ieee_read_number
argument_list|(
name|info
argument_list|,
name|pp
argument_list|,
operator|&
name|tc
argument_list|)
condition|)
return|return
name|false
return|;
name|dhandle
operator|=
name|info
operator|->
name|dhandle
expr_stmt|;
name|tag
operator|=
name|false
expr_stmt|;
name|typdef
operator|=
name|false
expr_stmt|;
name|arg_slots
operator|=
name|NULL
expr_stmt|;
name|type_bitsize
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|tc
condition|)
block|{
default|default:
name|ieee_error
argument_list|(
name|info
argument_list|,
name|ty_code_start
argument_list|,
name|_
argument_list|(
literal|"unknown TY code"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|false
return|;
case|case
literal|'!'
case|:
comment|/* Unknown type, with size.  We treat it as int.  FIXME.  */
block|{
name|bfd_vma
name|size
decl_stmt|;
if|if
condition|(
operator|!
name|ieee_read_number
argument_list|(
name|info
argument_list|,
name|pp
argument_list|,
operator|&
name|size
argument_list|)
condition|)
return|return
name|false
return|;
name|type
operator|=
name|debug_make_int_type
argument_list|(
name|dhandle
argument_list|,
name|size
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'A'
case|:
comment|/* Array.  */
case|case
literal|'a'
case|:
comment|/* FORTRAN array in column/row order.  FIXME: Not 		 distinguished from normal array.  */
block|{
name|debug_type
name|ele_type
decl_stmt|;
name|bfd_vma
name|lower
decl_stmt|,
name|upper
decl_stmt|;
if|if
condition|(
operator|!
name|ieee_read_type_index
argument_list|(
name|info
argument_list|,
name|pp
argument_list|,
operator|&
name|ele_type
argument_list|)
operator|||
operator|!
name|ieee_read_number
argument_list|(
name|info
argument_list|,
name|pp
argument_list|,
operator|&
name|lower
argument_list|)
operator|||
operator|!
name|ieee_read_number
argument_list|(
name|info
argument_list|,
name|pp
argument_list|,
operator|&
name|upper
argument_list|)
condition|)
return|return
name|false
return|;
name|type
operator|=
name|debug_make_array_type
argument_list|(
name|dhandle
argument_list|,
name|ele_type
argument_list|,
name|ieee_builtin_type
argument_list|(
name|info
argument_list|,
name|ty_code_start
argument_list|,
operator|(
operator|(
name|unsigned
name|int
operator|)
name|builtin_int
operator|)
argument_list|)
argument_list|,
operator|(
name|bfd_signed_vma
operator|)
name|lower
argument_list|,
operator|(
name|bfd_signed_vma
operator|)
name|upper
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'E'
case|:
comment|/* Simple enumeration.  */
block|{
name|bfd_vma
name|size
decl_stmt|;
name|unsigned
name|int
name|alloc
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|names
decl_stmt|;
name|unsigned
name|int
name|c
decl_stmt|;
name|bfd_signed_vma
modifier|*
name|vals
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|ieee_read_number
argument_list|(
name|info
argument_list|,
name|pp
argument_list|,
operator|&
name|size
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* FIXME: we ignore the enumeration size.  */
name|alloc
operator|=
literal|10
expr_stmt|;
name|names
operator|=
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|alloc
operator|*
sizeof|sizeof
expr|*
name|names
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|names
argument_list|,
literal|0
argument_list|,
name|alloc
operator|*
sizeof|sizeof
expr|*
name|names
argument_list|)
expr_stmt|;
name|c
operator|=
literal|0
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|unsigned
name|long
name|namlen
decl_stmt|;
name|boolean
name|present
decl_stmt|;
if|if
condition|(
operator|!
name|ieee_read_optional_id
argument_list|(
name|info
argument_list|,
name|pp
argument_list|,
operator|&
name|name
argument_list|,
operator|&
name|namlen
argument_list|,
operator|&
name|present
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|!
name|present
condition|)
break|break;
if|if
condition|(
name|c
operator|+
literal|1
operator|>=
name|alloc
condition|)
block|{
name|alloc
operator|+=
literal|10
expr_stmt|;
name|names
operator|=
operator|(
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
name|names
argument_list|,
name|alloc
operator|*
sizeof|sizeof
expr|*
name|names
argument_list|)
operator|)
expr_stmt|;
block|}
name|names
index|[
name|c
index|]
operator|=
name|savestring
argument_list|(
name|name
argument_list|,
name|namlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|names
index|[
name|c
index|]
operator|==
name|NULL
condition|)
return|return
name|false
return|;
operator|++
name|c
expr_stmt|;
block|}
name|names
index|[
name|c
index|]
operator|=
name|NULL
expr_stmt|;
name|vals
operator|=
operator|(
name|bfd_signed_vma
operator|*
operator|)
name|xmalloc
argument_list|(
name|c
operator|*
sizeof|sizeof
expr|*
name|vals
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|c
condition|;
name|i
operator|++
control|)
name|vals
index|[
name|i
index|]
operator|=
name|i
expr_stmt|;
name|type
operator|=
name|debug_make_enum_type
argument_list|(
name|dhandle
argument_list|,
name|names
argument_list|,
name|vals
argument_list|)
expr_stmt|;
name|tag
operator|=
name|true
expr_stmt|;
block|}
break|break;
case|case
literal|'G'
case|:
comment|/* Struct with bit fields.  */
block|{
name|bfd_vma
name|size
decl_stmt|;
name|unsigned
name|int
name|alloc
decl_stmt|;
name|debug_field
modifier|*
name|fields
decl_stmt|;
name|unsigned
name|int
name|c
decl_stmt|;
if|if
condition|(
operator|!
name|ieee_read_number
argument_list|(
name|info
argument_list|,
name|pp
argument_list|,
operator|&
name|size
argument_list|)
condition|)
return|return
name|false
return|;
name|alloc
operator|=
literal|10
expr_stmt|;
name|fields
operator|=
operator|(
name|debug_field
operator|*
operator|)
name|xmalloc
argument_list|(
name|alloc
operator|*
sizeof|sizeof
expr|*
name|fields
argument_list|)
expr_stmt|;
name|c
operator|=
literal|0
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|unsigned
name|long
name|namlen
decl_stmt|;
name|boolean
name|present
decl_stmt|;
name|debug_type
name|ftype
decl_stmt|;
name|bfd_vma
name|bitpos
decl_stmt|,
name|bitsize
decl_stmt|;
if|if
condition|(
operator|!
name|ieee_read_optional_id
argument_list|(
name|info
argument_list|,
name|pp
argument_list|,
operator|&
name|name
argument_list|,
operator|&
name|namlen
argument_list|,
operator|&
name|present
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|!
name|present
condition|)
break|break;
if|if
condition|(
operator|!
name|ieee_read_type_index
argument_list|(
name|info
argument_list|,
name|pp
argument_list|,
operator|&
name|ftype
argument_list|)
operator|||
operator|!
name|ieee_read_number
argument_list|(
name|info
argument_list|,
name|pp
argument_list|,
operator|&
name|bitpos
argument_list|)
operator|||
operator|!
name|ieee_read_number
argument_list|(
name|info
argument_list|,
name|pp
argument_list|,
operator|&
name|bitsize
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|c
operator|+
literal|1
operator|>=
name|alloc
condition|)
block|{
name|alloc
operator|+=
literal|10
expr_stmt|;
name|fields
operator|=
operator|(
operator|(
name|debug_field
operator|*
operator|)
name|xrealloc
argument_list|(
name|fields
argument_list|,
name|alloc
operator|*
sizeof|sizeof
expr|*
name|fields
argument_list|)
operator|)
expr_stmt|;
block|}
name|fields
index|[
name|c
index|]
operator|=
name|debug_make_field
argument_list|(
name|dhandle
argument_list|,
name|savestring
argument_list|(
name|name
argument_list|,
name|namlen
argument_list|)
argument_list|,
name|ftype
argument_list|,
name|bitpos
argument_list|,
name|bitsize
argument_list|,
name|DEBUG_VISIBILITY_PUBLIC
argument_list|)
expr_stmt|;
if|if
condition|(
name|fields
index|[
name|c
index|]
operator|==
name|NULL
condition|)
return|return
name|false
return|;
operator|++
name|c
expr_stmt|;
block|}
name|fields
index|[
name|c
index|]
operator|=
name|NULL
expr_stmt|;
name|type
operator|=
name|debug_make_struct_type
argument_list|(
name|dhandle
argument_list|,
name|true
argument_list|,
name|size
argument_list|,
name|fields
argument_list|)
expr_stmt|;
name|tag
operator|=
name|true
expr_stmt|;
block|}
break|break;
case|case
literal|'N'
case|:
comment|/* Enumeration.  */
block|{
name|unsigned
name|int
name|alloc
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|names
decl_stmt|;
name|bfd_signed_vma
modifier|*
name|vals
decl_stmt|;
name|unsigned
name|int
name|c
decl_stmt|;
name|alloc
operator|=
literal|10
expr_stmt|;
name|names
operator|=
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|alloc
operator|*
sizeof|sizeof
expr|*
name|names
argument_list|)
expr_stmt|;
name|vals
operator|=
operator|(
name|bfd_signed_vma
operator|*
operator|)
name|xmalloc
argument_list|(
name|alloc
operator|*
sizeof|sizeof
expr|*
name|names
argument_list|)
expr_stmt|;
name|c
operator|=
literal|0
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|unsigned
name|long
name|namlen
decl_stmt|;
name|boolean
name|present
decl_stmt|;
name|bfd_vma
name|val
decl_stmt|;
if|if
condition|(
operator|!
name|ieee_read_optional_id
argument_list|(
name|info
argument_list|,
name|pp
argument_list|,
operator|&
name|name
argument_list|,
operator|&
name|namlen
argument_list|,
operator|&
name|present
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|!
name|present
condition|)
break|break;
if|if
condition|(
operator|!
name|ieee_read_number
argument_list|(
name|info
argument_list|,
name|pp
argument_list|,
operator|&
name|val
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* If the length of the name is zero, then the value is                actually the size of the enum.  We ignore this                information.  FIXME.  */
if|if
condition|(
name|namlen
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|c
operator|+
literal|1
operator|>=
name|alloc
condition|)
block|{
name|alloc
operator|+=
literal|10
expr_stmt|;
name|names
operator|=
operator|(
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
name|names
argument_list|,
name|alloc
operator|*
sizeof|sizeof
expr|*
name|names
argument_list|)
operator|)
expr_stmt|;
name|vals
operator|=
operator|(
operator|(
name|bfd_signed_vma
operator|*
operator|)
name|xrealloc
argument_list|(
name|vals
argument_list|,
name|alloc
operator|*
sizeof|sizeof
expr|*
name|vals
argument_list|)
operator|)
expr_stmt|;
block|}
name|names
index|[
name|c
index|]
operator|=
name|savestring
argument_list|(
name|name
argument_list|,
name|namlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|names
index|[
name|c
index|]
operator|==
name|NULL
condition|)
return|return
name|false
return|;
name|vals
index|[
name|c
index|]
operator|=
operator|(
name|bfd_signed_vma
operator|)
name|val
expr_stmt|;
operator|++
name|c
expr_stmt|;
block|}
name|names
index|[
name|c
index|]
operator|=
name|NULL
expr_stmt|;
name|type
operator|=
name|debug_make_enum_type
argument_list|(
name|dhandle
argument_list|,
name|names
argument_list|,
name|vals
argument_list|)
expr_stmt|;
name|tag
operator|=
name|true
expr_stmt|;
block|}
break|break;
case|case
literal|'O'
case|:
comment|/* Small pointer.  We don't distinguish small and large 		 pointers.  FIXME.  */
case|case
literal|'P'
case|:
comment|/* Large pointer.  */
block|{
name|debug_type
name|t
decl_stmt|;
if|if
condition|(
operator|!
name|ieee_read_type_index
argument_list|(
name|info
argument_list|,
name|pp
argument_list|,
operator|&
name|t
argument_list|)
condition|)
return|return
name|false
return|;
name|type
operator|=
name|debug_make_pointer_type
argument_list|(
name|dhandle
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'R'
case|:
comment|/* Range.  */
block|{
name|bfd_vma
name|low
decl_stmt|,
name|high
decl_stmt|,
name|signedp
decl_stmt|,
name|size
decl_stmt|;
if|if
condition|(
operator|!
name|ieee_read_number
argument_list|(
name|info
argument_list|,
name|pp
argument_list|,
operator|&
name|low
argument_list|)
operator|||
operator|!
name|ieee_read_number
argument_list|(
name|info
argument_list|,
name|pp
argument_list|,
operator|&
name|high
argument_list|)
operator|||
operator|!
name|ieee_read_number
argument_list|(
name|info
argument_list|,
name|pp
argument_list|,
operator|&
name|signedp
argument_list|)
operator|||
operator|!
name|ieee_read_number
argument_list|(
name|info
argument_list|,
name|pp
argument_list|,
operator|&
name|size
argument_list|)
condition|)
return|return
name|false
return|;
name|type
operator|=
name|debug_make_range_type
argument_list|(
name|dhandle
argument_list|,
name|debug_make_int_type
argument_list|(
name|dhandle
argument_list|,
name|size
argument_list|,
operator|!
name|signedp
argument_list|)
argument_list|,
operator|(
name|bfd_signed_vma
operator|)
name|low
argument_list|,
operator|(
name|bfd_signed_vma
operator|)
name|high
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'S'
case|:
comment|/* Struct.  */
case|case
literal|'U'
case|:
comment|/* Union.  */
block|{
name|bfd_vma
name|size
decl_stmt|;
name|unsigned
name|int
name|alloc
decl_stmt|;
name|debug_field
modifier|*
name|fields
decl_stmt|;
name|unsigned
name|int
name|c
decl_stmt|;
if|if
condition|(
operator|!
name|ieee_read_number
argument_list|(
name|info
argument_list|,
name|pp
argument_list|,
operator|&
name|size
argument_list|)
condition|)
return|return
name|false
return|;
name|alloc
operator|=
literal|10
expr_stmt|;
name|fields
operator|=
operator|(
name|debug_field
operator|*
operator|)
name|xmalloc
argument_list|(
name|alloc
operator|*
sizeof|sizeof
expr|*
name|fields
argument_list|)
expr_stmt|;
name|c
operator|=
literal|0
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|unsigned
name|long
name|namlen
decl_stmt|;
name|boolean
name|present
decl_stmt|;
name|bfd_vma
name|tindx
decl_stmt|;
name|bfd_vma
name|offset
decl_stmt|;
name|debug_type
name|ftype
decl_stmt|;
name|bfd_vma
name|bitsize
decl_stmt|;
if|if
condition|(
operator|!
name|ieee_read_optional_id
argument_list|(
name|info
argument_list|,
name|pp
argument_list|,
operator|&
name|name
argument_list|,
operator|&
name|namlen
argument_list|,
operator|&
name|present
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|!
name|present
condition|)
break|break;
if|if
condition|(
operator|!
name|ieee_read_number
argument_list|(
name|info
argument_list|,
name|pp
argument_list|,
operator|&
name|tindx
argument_list|)
operator|||
operator|!
name|ieee_read_number
argument_list|(
name|info
argument_list|,
name|pp
argument_list|,
operator|&
name|offset
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|tindx
operator|<
literal|256
condition|)
block|{
name|ftype
operator|=
name|ieee_builtin_type
argument_list|(
name|info
argument_list|,
name|ty_code_start
argument_list|,
name|tindx
argument_list|)
expr_stmt|;
name|bitsize
operator|=
literal|0
expr_stmt|;
name|offset
operator|*=
literal|8
expr_stmt|;
block|}
else|else
block|{
name|struct
name|ieee_type
modifier|*
name|t
decl_stmt|;
name|tindx
operator|-=
literal|256
expr_stmt|;
if|if
condition|(
operator|!
name|ieee_alloc_type
argument_list|(
name|info
argument_list|,
name|tindx
argument_list|,
name|true
argument_list|)
condition|)
return|return
name|false
return|;
name|t
operator|=
name|info
operator|->
name|types
operator|.
name|types
operator|+
name|tindx
expr_stmt|;
name|ftype
operator|=
name|t
operator|->
name|type
expr_stmt|;
name|bitsize
operator|=
name|t
operator|->
name|bitsize
expr_stmt|;
if|if
condition|(
name|bitsize
operator|==
literal|0
condition|)
name|offset
operator|*=
literal|8
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|+
literal|1
operator|>=
name|alloc
condition|)
block|{
name|alloc
operator|+=
literal|10
expr_stmt|;
name|fields
operator|=
operator|(
operator|(
name|debug_field
operator|*
operator|)
name|xrealloc
argument_list|(
name|fields
argument_list|,
name|alloc
operator|*
sizeof|sizeof
expr|*
name|fields
argument_list|)
operator|)
expr_stmt|;
block|}
name|fields
index|[
name|c
index|]
operator|=
name|debug_make_field
argument_list|(
name|dhandle
argument_list|,
name|savestring
argument_list|(
name|name
argument_list|,
name|namlen
argument_list|)
argument_list|,
name|ftype
argument_list|,
name|offset
argument_list|,
name|bitsize
argument_list|,
name|DEBUG_VISIBILITY_PUBLIC
argument_list|)
expr_stmt|;
if|if
condition|(
name|fields
index|[
name|c
index|]
operator|==
name|NULL
condition|)
return|return
name|false
return|;
operator|++
name|c
expr_stmt|;
block|}
name|fields
index|[
name|c
index|]
operator|=
name|NULL
expr_stmt|;
name|type
operator|=
name|debug_make_struct_type
argument_list|(
name|dhandle
argument_list|,
name|tc
operator|==
literal|'S'
argument_list|,
name|size
argument_list|,
name|fields
argument_list|)
expr_stmt|;
name|tag
operator|=
name|true
expr_stmt|;
block|}
break|break;
case|case
literal|'T'
case|:
comment|/* Typedef.  */
if|if
condition|(
operator|!
name|ieee_read_type_index
argument_list|(
name|info
argument_list|,
name|pp
argument_list|,
operator|&
name|type
argument_list|)
condition|)
return|return
name|false
return|;
name|typdef
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'X'
case|:
comment|/* Procedure.  FIXME: This is an extern declaration, which we          have no way of representing.  */
block|{
name|bfd_vma
name|attr
decl_stmt|;
name|debug_type
name|rtype
decl_stmt|;
name|bfd_vma
name|nargs
decl_stmt|;
name|boolean
name|present
decl_stmt|;
name|struct
name|ieee_var
modifier|*
name|pv
decl_stmt|;
comment|/* FIXME: We ignore the attribute and the argument names.  */
if|if
condition|(
operator|!
name|ieee_read_number
argument_list|(
name|info
argument_list|,
name|pp
argument_list|,
operator|&
name|attr
argument_list|)
operator|||
operator|!
name|ieee_read_type_index
argument_list|(
name|info
argument_list|,
name|pp
argument_list|,
operator|&
name|rtype
argument_list|)
operator|||
operator|!
name|ieee_read_number
argument_list|(
name|info
argument_list|,
name|pp
argument_list|,
operator|&
name|nargs
argument_list|)
condition|)
return|return
name|false
return|;
do|do
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|unsigned
name|long
name|namlen
decl_stmt|;
if|if
condition|(
operator|!
name|ieee_read_optional_id
argument_list|(
name|info
argument_list|,
name|pp
argument_list|,
operator|&
name|name
argument_list|,
operator|&
name|namlen
argument_list|,
operator|&
name|present
argument_list|)
condition|)
return|return
name|false
return|;
block|}
do|while
condition|(
name|present
condition|)
do|;
name|pv
operator|=
name|info
operator|->
name|vars
operator|.
name|vars
operator|+
name|varindx
expr_stmt|;
name|pv
operator|->
name|kind
operator|=
name|IEEE_EXTERNAL
expr_stmt|;
if|if
condition|(
name|pv
operator|->
name|namlen
operator|>
literal|0
operator|&&
name|debug_get_type_kind
argument_list|(
name|dhandle
argument_list|,
name|rtype
argument_list|)
operator|==
name|DEBUG_KIND_POINTER
condition|)
block|{
comment|/* Set up the return type as an indirect type pointing to                the variable slot, so that we can change it to a                reference later if appropriate.  */
name|pv
operator|->
name|pslot
operator|=
operator|(
name|debug_type
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
expr|*
name|pv
operator|->
name|pslot
argument_list|)
expr_stmt|;
operator|*
name|pv
operator|->
name|pslot
operator|=
name|rtype
expr_stmt|;
name|rtype
operator|=
name|debug_make_indirect_type
argument_list|(
name|dhandle
argument_list|,
name|pv
operator|->
name|pslot
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
name|type
operator|=
name|debug_make_function_type
argument_list|(
name|dhandle
argument_list|,
name|rtype
argument_list|,
operator|(
name|debug_type
operator|*
operator|)
name|NULL
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'V'
case|:
comment|/* Void.  This is not documented, but the MRI compiler emits it.  */
name|type
operator|=
name|debug_make_void_type
argument_list|(
name|dhandle
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'Z'
case|:
comment|/* Array with 0 lower bound.  */
block|{
name|debug_type
name|etype
decl_stmt|;
name|bfd_vma
name|high
decl_stmt|;
if|if
condition|(
operator|!
name|ieee_read_type_index
argument_list|(
name|info
argument_list|,
name|pp
argument_list|,
operator|&
name|etype
argument_list|)
operator|||
operator|!
name|ieee_read_number
argument_list|(
name|info
argument_list|,
name|pp
argument_list|,
operator|&
name|high
argument_list|)
condition|)
return|return
name|false
return|;
name|type
operator|=
name|debug_make_array_type
argument_list|(
name|dhandle
argument_list|,
name|etype
argument_list|,
name|ieee_builtin_type
argument_list|(
name|info
argument_list|,
name|ty_code_start
argument_list|,
operator|(
operator|(
name|unsigned
name|int
operator|)
name|builtin_int
operator|)
argument_list|)
argument_list|,
literal|0
argument_list|,
operator|(
name|bfd_signed_vma
operator|)
name|high
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'c'
case|:
comment|/* Complex.  */
case|case
literal|'d'
case|:
comment|/* Double complex.  */
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|unsigned
name|long
name|namlen
decl_stmt|;
comment|/* FIXME: I don't know what the name means.  */
if|if
condition|(
operator|!
name|ieee_read_id
argument_list|(
name|info
argument_list|,
name|pp
argument_list|,
operator|&
name|name
argument_list|,
operator|&
name|namlen
argument_list|)
condition|)
return|return
name|false
return|;
name|type
operator|=
name|debug_make_complex_type
argument_list|(
name|dhandle
argument_list|,
name|tc
operator|==
literal|'c'
condition|?
literal|4
else|:
literal|8
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'f'
case|:
comment|/* Pascal file name.  FIXME.  */
name|ieee_error
argument_list|(
name|info
argument_list|,
name|ty_code_start
argument_list|,
name|_
argument_list|(
literal|"Pascal file name not supported"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|false
return|;
case|case
literal|'g'
case|:
comment|/* Bitfield type.  */
block|{
name|bfd_vma
name|signedp
decl_stmt|,
name|bitsize
decl_stmt|,
name|dummy
decl_stmt|;
specifier|const
name|bfd_byte
modifier|*
name|hold
decl_stmt|;
name|boolean
name|present
decl_stmt|;
if|if
condition|(
operator|!
name|ieee_read_number
argument_list|(
name|info
argument_list|,
name|pp
argument_list|,
operator|&
name|signedp
argument_list|)
operator|||
operator|!
name|ieee_read_number
argument_list|(
name|info
argument_list|,
name|pp
argument_list|,
operator|&
name|bitsize
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* I think the documentation says that there is a type index,            but some actual files do not have one.  */
name|hold
operator|=
operator|*
name|pp
expr_stmt|;
if|if
condition|(
operator|!
name|ieee_read_optional_number
argument_list|(
name|info
argument_list|,
name|pp
argument_list|,
operator|&
name|dummy
argument_list|,
operator|&
name|present
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|!
name|present
condition|)
block|{
comment|/* FIXME: This is just a guess.  */
name|type
operator|=
name|debug_make_int_type
argument_list|(
name|dhandle
argument_list|,
literal|4
argument_list|,
name|signedp
condition|?
name|false
else|:
name|true
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|pp
operator|=
name|hold
expr_stmt|;
if|if
condition|(
operator|!
name|ieee_read_type_index
argument_list|(
name|info
argument_list|,
name|pp
argument_list|,
operator|&
name|type
argument_list|)
condition|)
return|return
name|false
return|;
block|}
name|type_bitsize
operator|=
name|bitsize
expr_stmt|;
block|}
break|break;
case|case
literal|'n'
case|:
comment|/* Qualifier.  */
block|{
name|bfd_vma
name|kind
decl_stmt|;
name|debug_type
name|t
decl_stmt|;
if|if
condition|(
operator|!
name|ieee_read_number
argument_list|(
name|info
argument_list|,
name|pp
argument_list|,
operator|&
name|kind
argument_list|)
operator|||
operator|!
name|ieee_read_type_index
argument_list|(
name|info
argument_list|,
name|pp
argument_list|,
operator|&
name|t
argument_list|)
condition|)
return|return
name|false
return|;
switch|switch
condition|(
name|kind
condition|)
block|{
default|default:
name|ieee_error
argument_list|(
name|info
argument_list|,
name|ty_start
argument_list|,
name|_
argument_list|(
literal|"unsupported qualifer"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|false
return|;
case|case
literal|1
case|:
name|type
operator|=
name|debug_make_const_type
argument_list|(
name|dhandle
argument_list|,
name|t
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|type
operator|=
name|debug_make_volatile_type
argument_list|(
name|dhandle
argument_list|,
name|t
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
break|break;
case|case
literal|'s'
case|:
comment|/* Set.  */
block|{
name|bfd_vma
name|size
decl_stmt|;
name|debug_type
name|etype
decl_stmt|;
if|if
condition|(
operator|!
name|ieee_read_number
argument_list|(
name|info
argument_list|,
name|pp
argument_list|,
operator|&
name|size
argument_list|)
operator|||
operator|!
name|ieee_read_type_index
argument_list|(
name|info
argument_list|,
name|pp
argument_list|,
operator|&
name|etype
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* FIXME: We ignore the size.  */
name|type
operator|=
name|debug_make_set_type
argument_list|(
name|dhandle
argument_list|,
name|etype
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'x'
case|:
comment|/* Procedure with compiler dependencies.  */
block|{
name|struct
name|ieee_var
modifier|*
name|pv
decl_stmt|;
name|bfd_vma
name|attr
decl_stmt|,
name|frame_type
decl_stmt|,
name|push_mask
decl_stmt|,
name|nargs
decl_stmt|,
name|level
decl_stmt|,
name|father
decl_stmt|;
name|debug_type
name|rtype
decl_stmt|;
name|debug_type
modifier|*
name|arg_types
decl_stmt|;
name|boolean
name|varargs
decl_stmt|;
name|boolean
name|present
decl_stmt|;
comment|/* FIXME: We ignore some of this information.  */
name|pv
operator|=
name|info
operator|->
name|vars
operator|.
name|vars
operator|+
name|varindx
expr_stmt|;
if|if
condition|(
operator|!
name|ieee_read_number
argument_list|(
name|info
argument_list|,
name|pp
argument_list|,
operator|&
name|attr
argument_list|)
operator|||
operator|!
name|ieee_read_number
argument_list|(
name|info
argument_list|,
name|pp
argument_list|,
operator|&
name|frame_type
argument_list|)
operator|||
operator|!
name|ieee_read_number
argument_list|(
name|info
argument_list|,
name|pp
argument_list|,
operator|&
name|push_mask
argument_list|)
operator|||
operator|!
name|ieee_read_type_index
argument_list|(
name|info
argument_list|,
name|pp
argument_list|,
operator|&
name|rtype
argument_list|)
operator|||
operator|!
name|ieee_read_number
argument_list|(
name|info
argument_list|,
name|pp
argument_list|,
operator|&
name|nargs
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|nargs
operator|==
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
condition|)
block|{
name|arg_types
operator|=
name|NULL
expr_stmt|;
name|varargs
operator|=
name|false
expr_stmt|;
block|}
else|else
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|arg_types
operator|=
operator|(
operator|(
name|debug_type
operator|*
operator|)
name|xmalloc
argument_list|(
operator|(
name|nargs
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
expr|*
name|arg_types
argument_list|)
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nargs
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|ieee_read_type_index
argument_list|(
name|info
argument_list|,
name|pp
argument_list|,
name|arg_types
operator|+
name|i
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* If the last type is pointer to void, this is really a                varargs function.  */
name|varargs
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|nargs
operator|>
literal|0
condition|)
block|{
name|debug_type
name|last
decl_stmt|;
name|last
operator|=
name|arg_types
index|[
name|nargs
operator|-
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|debug_get_type_kind
argument_list|(
name|dhandle
argument_list|,
name|last
argument_list|)
operator|==
name|DEBUG_KIND_POINTER
operator|&&
operator|(
name|debug_get_type_kind
argument_list|(
name|dhandle
argument_list|,
name|debug_get_target_type
argument_list|(
name|dhandle
argument_list|,
name|last
argument_list|)
argument_list|)
operator|==
name|DEBUG_KIND_VOID
operator|)
condition|)
block|{
operator|--
name|nargs
expr_stmt|;
name|varargs
operator|=
name|true
expr_stmt|;
block|}
block|}
comment|/* If there are any pointer arguments, turn them into                indirect types in case we later need to convert them to                reference types.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nargs
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|debug_get_type_kind
argument_list|(
name|dhandle
argument_list|,
name|arg_types
index|[
name|i
index|]
argument_list|)
operator|==
name|DEBUG_KIND_POINTER
condition|)
block|{
if|if
condition|(
name|arg_slots
operator|==
name|NULL
condition|)
block|{
name|arg_slots
operator|=
operator|(
operator|(
name|debug_type
operator|*
operator|)
name|xmalloc
argument_list|(
name|nargs
operator|*
sizeof|sizeof
expr|*
name|arg_slots
argument_list|)
operator|)
expr_stmt|;
name|memset
argument_list|(
name|arg_slots
argument_list|,
literal|0
argument_list|,
name|nargs
operator|*
sizeof|sizeof
expr|*
name|arg_slots
argument_list|)
expr_stmt|;
block|}
name|arg_slots
index|[
name|i
index|]
operator|=
name|arg_types
index|[
name|i
index|]
expr_stmt|;
name|arg_types
index|[
name|i
index|]
operator|=
name|debug_make_indirect_type
argument_list|(
name|dhandle
argument_list|,
name|arg_slots
operator|+
name|i
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
name|arg_types
index|[
name|nargs
index|]
operator|=
name|DEBUG_TYPE_NULL
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|ieee_read_number
argument_list|(
name|info
argument_list|,
name|pp
argument_list|,
operator|&
name|level
argument_list|)
operator|||
operator|!
name|ieee_read_optional_number
argument_list|(
name|info
argument_list|,
name|pp
argument_list|,
operator|&
name|father
argument_list|,
operator|&
name|present
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* We can't distinguish between a global function and a static            function.  */
name|pv
operator|->
name|kind
operator|=
name|IEEE_FUNCTION
expr_stmt|;
if|if
condition|(
name|pv
operator|->
name|namlen
operator|>
literal|0
operator|&&
name|debug_get_type_kind
argument_list|(
name|dhandle
argument_list|,
name|rtype
argument_list|)
operator|==
name|DEBUG_KIND_POINTER
condition|)
block|{
comment|/* Set up the return type as an indirect type pointing to                the variable slot, so that we can change it to a                reference later if appropriate.  */
name|pv
operator|->
name|pslot
operator|=
operator|(
name|debug_type
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
expr|*
name|pv
operator|->
name|pslot
argument_list|)
expr_stmt|;
operator|*
name|pv
operator|->
name|pslot
operator|=
name|rtype
expr_stmt|;
name|rtype
operator|=
name|debug_make_indirect_type
argument_list|(
name|dhandle
argument_list|,
name|pv
operator|->
name|pslot
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
name|type
operator|=
name|debug_make_function_type
argument_list|(
name|dhandle
argument_list|,
name|rtype
argument_list|,
name|arg_types
argument_list|,
name|varargs
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
comment|/* Record the type in the table.  */
if|if
condition|(
name|type
operator|==
name|DEBUG_TYPE_NULL
condition|)
return|return
name|false
return|;
name|info
operator|->
name|vars
operator|.
name|vars
index|[
name|varindx
index|]
operator|.
name|type
operator|=
name|type
expr_stmt|;
if|if
condition|(
operator|(
name|tag
operator|||
name|typdef
operator|)
operator|&&
name|info
operator|->
name|vars
operator|.
name|vars
index|[
name|varindx
index|]
operator|.
name|namlen
operator|>
literal|0
condition|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|name
operator|=
name|savestring
argument_list|(
name|info
operator|->
name|vars
operator|.
name|vars
index|[
name|varindx
index|]
operator|.
name|name
argument_list|,
name|info
operator|->
name|vars
operator|.
name|vars
index|[
name|varindx
index|]
operator|.
name|namlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|typdef
condition|)
name|type
operator|=
name|debug_name_type
argument_list|(
name|dhandle
argument_list|,
name|name
argument_list|,
name|type
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|tc
operator|==
literal|'E'
operator|||
name|tc
operator|==
literal|'N'
condition|)
name|type
operator|=
name|debug_tag_type
argument_list|(
name|dhandle
argument_list|,
name|name
argument_list|,
name|type
argument_list|)
expr_stmt|;
else|else
block|{
name|struct
name|ieee_tag
modifier|*
name|it
decl_stmt|;
comment|/* We must allocate all struct tags as indirect types, so              that if we later see a definition of the tag as a C++              record we can update the indirect slot and automatically              change all the existing references.  */
name|it
operator|=
operator|(
expr|struct
name|ieee_tag
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
expr|*
name|it
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|it
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
expr|*
name|it
argument_list|)
expr_stmt|;
name|it
operator|->
name|next
operator|=
name|info
operator|->
name|tags
expr_stmt|;
name|info
operator|->
name|tags
operator|=
name|it
expr_stmt|;
name|it
operator|->
name|name
operator|=
name|name
expr_stmt|;
name|it
operator|->
name|slot
operator|=
name|type
expr_stmt|;
name|type
operator|=
name|debug_make_indirect_type
argument_list|(
name|dhandle
argument_list|,
operator|&
name|it
operator|->
name|slot
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|type
operator|=
name|debug_tag_type
argument_list|(
name|dhandle
argument_list|,
name|name
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|it
operator|->
name|type
operator|=
name|type
expr_stmt|;
block|}
if|if
condition|(
name|type
operator|==
name|NULL
condition|)
return|return
name|false
return|;
block|}
name|info
operator|->
name|types
operator|.
name|types
index|[
name|typeindx
index|]
operator|.
name|type
operator|=
name|type
expr_stmt|;
name|info
operator|->
name|types
operator|.
name|types
index|[
name|typeindx
index|]
operator|.
name|arg_slots
operator|=
name|arg_slots
expr_stmt|;
name|info
operator|->
name|types
operator|.
name|types
index|[
name|typeindx
index|]
operator|.
name|bitsize
operator|=
name|type_bitsize
expr_stmt|;
comment|/* We may have already allocated type as an indirect type pointing      to slot.  It does no harm to replace the indirect type with the      real type.  Filling in slot as well handles the indirect types      which are already hanging around.  */
if|if
condition|(
name|info
operator|->
name|types
operator|.
name|types
index|[
name|typeindx
index|]
operator|.
name|pslot
operator|!=
name|NULL
condition|)
operator|*
name|info
operator|->
name|types
operator|.
name|types
index|[
name|typeindx
index|]
operator|.
name|pslot
operator|=
name|type
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Parse an ATN record.  */
end_comment

begin_function
specifier|static
name|boolean
name|parse_ieee_atn
parameter_list|(
name|info
parameter_list|,
name|pp
parameter_list|)
name|struct
name|ieee_info
modifier|*
name|info
decl_stmt|;
specifier|const
name|bfd_byte
modifier|*
modifier|*
name|pp
decl_stmt|;
block|{
specifier|const
name|bfd_byte
modifier|*
name|atn_start
decl_stmt|,
modifier|*
name|atn_code_start
decl_stmt|;
name|bfd_vma
name|varindx
decl_stmt|;
name|struct
name|ieee_var
modifier|*
name|pvar
decl_stmt|;
name|debug_type
name|type
decl_stmt|;
name|bfd_vma
name|atn_code
decl_stmt|;
name|PTR
name|dhandle
decl_stmt|;
name|bfd_vma
name|v
decl_stmt|,
name|v2
decl_stmt|,
name|v3
decl_stmt|,
name|v4
decl_stmt|,
name|v5
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|unsigned
name|long
name|namlen
decl_stmt|;
name|char
modifier|*
name|namcopy
decl_stmt|;
name|boolean
name|present
decl_stmt|;
name|int
name|blocktype
decl_stmt|;
name|atn_start
operator|=
operator|*
name|pp
expr_stmt|;
if|if
condition|(
operator|!
name|ieee_read_number
argument_list|(
name|info
argument_list|,
name|pp
argument_list|,
operator|&
name|varindx
argument_list|)
operator|||
operator|!
name|ieee_read_type_index
argument_list|(
name|info
argument_list|,
name|pp
argument_list|,
operator|&
name|type
argument_list|)
condition|)
return|return
name|false
return|;
name|atn_code_start
operator|=
operator|*
name|pp
expr_stmt|;
if|if
condition|(
operator|!
name|ieee_read_number
argument_list|(
name|info
argument_list|,
name|pp
argument_list|,
operator|&
name|atn_code
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|varindx
operator|==
literal|0
condition|)
block|{
name|pvar
operator|=
name|NULL
expr_stmt|;
name|name
operator|=
literal|""
expr_stmt|;
name|namlen
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|varindx
operator|<
literal|32
condition|)
block|{
comment|/* The MRI compiler reportedly sometimes emits variable lifetime          information for a register.  We just ignore it.  */
if|if
condition|(
name|atn_code
operator|==
literal|9
condition|)
return|return
name|ieee_read_number
argument_list|(
name|info
argument_list|,
name|pp
argument_list|,
operator|&
name|v
argument_list|)
return|;
name|ieee_error
argument_list|(
name|info
argument_list|,
name|atn_start
argument_list|,
name|_
argument_list|(
literal|"illegal variable index"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
else|else
block|{
name|varindx
operator|-=
literal|32
expr_stmt|;
if|if
condition|(
name|varindx
operator|>=
name|info
operator|->
name|vars
operator|.
name|alloc
operator|||
name|info
operator|->
name|vars
operator|.
name|vars
index|[
name|varindx
index|]
operator|.
name|name
operator|==
name|NULL
condition|)
block|{
comment|/* The MRI compiler or linker sometimes omits the NN record              for a pmisc record.  */
if|if
condition|(
name|atn_code
operator|==
literal|62
condition|)
block|{
if|if
condition|(
name|varindx
operator|>=
name|info
operator|->
name|vars
operator|.
name|alloc
condition|)
block|{
name|unsigned
name|int
name|alloc
decl_stmt|;
name|alloc
operator|=
name|info
operator|->
name|vars
operator|.
name|alloc
expr_stmt|;
if|if
condition|(
name|alloc
operator|==
literal|0
condition|)
name|alloc
operator|=
literal|4
expr_stmt|;
while|while
condition|(
name|varindx
operator|>=
name|alloc
condition|)
name|alloc
operator|*=
literal|2
expr_stmt|;
name|info
operator|->
name|vars
operator|.
name|vars
operator|=
operator|(
operator|(
expr|struct
name|ieee_var
operator|*
operator|)
name|xrealloc
argument_list|(
name|info
operator|->
name|vars
operator|.
name|vars
argument_list|,
operator|(
name|alloc
operator|*
sizeof|sizeof
expr|*
name|info
operator|->
name|vars
operator|.
name|vars
operator|)
argument_list|)
operator|)
expr_stmt|;
name|memset
argument_list|(
name|info
operator|->
name|vars
operator|.
name|vars
operator|+
name|info
operator|->
name|vars
operator|.
name|alloc
argument_list|,
literal|0
argument_list|,
operator|(
operator|(
name|alloc
operator|-
name|info
operator|->
name|vars
operator|.
name|alloc
operator|)
operator|*
sizeof|sizeof
expr|*
name|info
operator|->
name|vars
operator|.
name|vars
operator|)
argument_list|)
expr_stmt|;
name|info
operator|->
name|vars
operator|.
name|alloc
operator|=
name|alloc
expr_stmt|;
block|}
name|pvar
operator|=
name|info
operator|->
name|vars
operator|.
name|vars
operator|+
name|varindx
expr_stmt|;
name|pvar
operator|->
name|name
operator|=
literal|""
expr_stmt|;
name|pvar
operator|->
name|namlen
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|ieee_error
argument_list|(
name|info
argument_list|,
name|atn_start
argument_list|,
name|_
argument_list|(
literal|"undefined variable in ATN"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
block|}
name|pvar
operator|=
name|info
operator|->
name|vars
operator|.
name|vars
operator|+
name|varindx
expr_stmt|;
name|pvar
operator|->
name|type
operator|=
name|type
expr_stmt|;
name|name
operator|=
name|pvar
operator|->
name|name
expr_stmt|;
name|namlen
operator|=
name|pvar
operator|->
name|namlen
expr_stmt|;
block|}
name|dhandle
operator|=
name|info
operator|->
name|dhandle
expr_stmt|;
comment|/* If we are going to call debug_record_variable with a pointer      type, change the type to an indirect type so that we can later      change it to a reference type if we encounter a C++ pmisc 'R'      record.  */
if|if
condition|(
name|pvar
operator|!=
name|NULL
operator|&&
name|type
operator|!=
name|DEBUG_TYPE_NULL
operator|&&
name|debug_get_type_kind
argument_list|(
name|dhandle
argument_list|,
name|type
argument_list|)
operator|==
name|DEBUG_KIND_POINTER
condition|)
block|{
switch|switch
condition|(
name|atn_code
condition|)
block|{
case|case
literal|1
case|:
case|case
literal|2
case|:
case|case
literal|3
case|:
case|case
literal|5
case|:
case|case
literal|8
case|:
case|case
literal|10
case|:
name|pvar
operator|->
name|pslot
operator|=
operator|(
name|debug_type
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
expr|*
name|pvar
operator|->
name|pslot
argument_list|)
expr_stmt|;
operator|*
name|pvar
operator|->
name|pslot
operator|=
name|type
expr_stmt|;
name|type
operator|=
name|debug_make_indirect_type
argument_list|(
name|dhandle
argument_list|,
name|pvar
operator|->
name|pslot
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|pvar
operator|->
name|type
operator|=
name|type
expr_stmt|;
break|break;
block|}
block|}
switch|switch
condition|(
name|atn_code
condition|)
block|{
default|default:
name|ieee_error
argument_list|(
name|info
argument_list|,
name|atn_code_start
argument_list|,
name|_
argument_list|(
literal|"unknown ATN type"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|false
return|;
case|case
literal|1
case|:
comment|/* Automatic variable.  */
if|if
condition|(
operator|!
name|ieee_read_number
argument_list|(
name|info
argument_list|,
name|pp
argument_list|,
operator|&
name|v
argument_list|)
condition|)
return|return
name|false
return|;
name|namcopy
operator|=
name|savestring
argument_list|(
name|name
argument_list|,
name|namlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|NULL
condition|)
name|type
operator|=
name|debug_make_void_type
argument_list|(
name|dhandle
argument_list|)
expr_stmt|;
if|if
condition|(
name|pvar
operator|!=
name|NULL
condition|)
name|pvar
operator|->
name|kind
operator|=
name|IEEE_LOCAL
expr_stmt|;
return|return
name|debug_record_variable
argument_list|(
name|dhandle
argument_list|,
name|namcopy
argument_list|,
name|type
argument_list|,
name|DEBUG_LOCAL
argument_list|,
name|v
argument_list|)
return|;
case|case
literal|2
case|:
comment|/* Register variable.  */
if|if
condition|(
operator|!
name|ieee_read_number
argument_list|(
name|info
argument_list|,
name|pp
argument_list|,
operator|&
name|v
argument_list|)
condition|)
return|return
name|false
return|;
name|namcopy
operator|=
name|savestring
argument_list|(
name|name
argument_list|,
name|namlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|NULL
condition|)
name|type
operator|=
name|debug_make_void_type
argument_list|(
name|dhandle
argument_list|)
expr_stmt|;
if|if
condition|(
name|pvar
operator|!=
name|NULL
condition|)
name|pvar
operator|->
name|kind
operator|=
name|IEEE_LOCAL
expr_stmt|;
return|return
name|debug_record_variable
argument_list|(
name|dhandle
argument_list|,
name|namcopy
argument_list|,
name|type
argument_list|,
name|DEBUG_REGISTER
argument_list|,
name|ieee_regno_to_genreg
argument_list|(
name|info
operator|->
name|abfd
argument_list|,
name|v
argument_list|)
argument_list|)
return|;
case|case
literal|3
case|:
comment|/* Static variable.  */
if|if
condition|(
operator|!
name|ieee_require_asn
argument_list|(
name|info
argument_list|,
name|pp
argument_list|,
operator|&
name|v
argument_list|)
condition|)
return|return
name|false
return|;
name|namcopy
operator|=
name|savestring
argument_list|(
name|name
argument_list|,
name|namlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|NULL
condition|)
name|type
operator|=
name|debug_make_void_type
argument_list|(
name|dhandle
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|blockstack
operator|.
name|bsp
operator|<=
name|info
operator|->
name|blockstack
operator|.
name|stack
condition|)
name|blocktype
operator|=
literal|0
expr_stmt|;
else|else
name|blocktype
operator|=
name|info
operator|->
name|blockstack
operator|.
name|bsp
index|[
operator|-
literal|1
index|]
operator|.
name|kind
expr_stmt|;
if|if
condition|(
name|pvar
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|blocktype
operator|==
literal|4
operator|||
name|blocktype
operator|==
literal|6
condition|)
name|pvar
operator|->
name|kind
operator|=
name|IEEE_LOCAL
expr_stmt|;
else|else
name|pvar
operator|->
name|kind
operator|=
name|IEEE_STATIC
expr_stmt|;
block|}
return|return
name|debug_record_variable
argument_list|(
name|dhandle
argument_list|,
name|namcopy
argument_list|,
name|type
argument_list|,
operator|(
name|blocktype
operator|==
literal|4
operator|||
name|blocktype
operator|==
literal|6
condition|?
name|DEBUG_LOCAL_STATIC
else|:
name|DEBUG_STATIC
operator|)
argument_list|,
name|v
argument_list|)
return|;
case|case
literal|4
case|:
comment|/* External function.  We don't currently record these.  FIXME.  */
if|if
condition|(
name|pvar
operator|!=
name|NULL
condition|)
name|pvar
operator|->
name|kind
operator|=
name|IEEE_EXTERNAL
expr_stmt|;
return|return
name|true
return|;
case|case
literal|5
case|:
comment|/* External variable.  We don't currently record these.  FIXME.  */
if|if
condition|(
name|pvar
operator|!=
name|NULL
condition|)
name|pvar
operator|->
name|kind
operator|=
name|IEEE_EXTERNAL
expr_stmt|;
return|return
name|true
return|;
case|case
literal|7
case|:
if|if
condition|(
operator|!
name|ieee_read_number
argument_list|(
name|info
argument_list|,
name|pp
argument_list|,
operator|&
name|v
argument_list|)
operator|||
operator|!
name|ieee_read_number
argument_list|(
name|info
argument_list|,
name|pp
argument_list|,
operator|&
name|v2
argument_list|)
operator|||
operator|!
name|ieee_read_optional_number
argument_list|(
name|info
argument_list|,
name|pp
argument_list|,
operator|&
name|v3
argument_list|,
operator|&
name|present
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|present
condition|)
block|{
if|if
condition|(
operator|!
name|ieee_read_optional_number
argument_list|(
name|info
argument_list|,
name|pp
argument_list|,
operator|&
name|v4
argument_list|,
operator|&
name|present
argument_list|)
condition|)
return|return
name|false
return|;
block|}
comment|/* We just ignore the two optional fields in v3 and v4, since          they are not defined.  */
if|if
condition|(
operator|!
name|ieee_require_asn
argument_list|(
name|info
argument_list|,
name|pp
argument_list|,
operator|&
name|v3
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* We have no way to record the column number.  FIXME.  */
return|return
name|debug_record_line
argument_list|(
name|dhandle
argument_list|,
name|v
argument_list|,
name|v3
argument_list|)
return|;
case|case
literal|8
case|:
comment|/* Global variable.  */
if|if
condition|(
operator|!
name|ieee_require_asn
argument_list|(
name|info
argument_list|,
name|pp
argument_list|,
operator|&
name|v
argument_list|)
condition|)
return|return
name|false
return|;
name|namcopy
operator|=
name|savestring
argument_list|(
name|name
argument_list|,
name|namlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|NULL
condition|)
name|type
operator|=
name|debug_make_void_type
argument_list|(
name|dhandle
argument_list|)
expr_stmt|;
if|if
condition|(
name|pvar
operator|!=
name|NULL
condition|)
name|pvar
operator|->
name|kind
operator|=
name|IEEE_GLOBAL
expr_stmt|;
return|return
name|debug_record_variable
argument_list|(
name|dhandle
argument_list|,
name|namcopy
argument_list|,
name|type
argument_list|,
name|DEBUG_GLOBAL
argument_list|,
name|v
argument_list|)
return|;
case|case
literal|9
case|:
comment|/* Variable lifetime information.  */
if|if
condition|(
operator|!
name|ieee_read_number
argument_list|(
name|info
argument_list|,
name|pp
argument_list|,
operator|&
name|v
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* We have no way to record this information.  FIXME.  */
return|return
name|true
return|;
case|case
literal|10
case|:
comment|/* Locked register.  The spec says that there are two required          fields, but at least on occasion the MRI compiler only emits          one.  */
if|if
condition|(
operator|!
name|ieee_read_number
argument_list|(
name|info
argument_list|,
name|pp
argument_list|,
operator|&
name|v
argument_list|)
operator|||
operator|!
name|ieee_read_optional_number
argument_list|(
name|info
argument_list|,
name|pp
argument_list|,
operator|&
name|v2
argument_list|,
operator|&
name|present
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* I think this means a variable that is both in a register and          a frame slot.  We ignore the frame slot.  FIXME.  */
name|namcopy
operator|=
name|savestring
argument_list|(
name|name
argument_list|,
name|namlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|NULL
condition|)
name|type
operator|=
name|debug_make_void_type
argument_list|(
name|dhandle
argument_list|)
expr_stmt|;
if|if
condition|(
name|pvar
operator|!=
name|NULL
condition|)
name|pvar
operator|->
name|kind
operator|=
name|IEEE_LOCAL
expr_stmt|;
return|return
name|debug_record_variable
argument_list|(
name|dhandle
argument_list|,
name|namcopy
argument_list|,
name|type
argument_list|,
name|DEBUG_REGISTER
argument_list|,
name|v
argument_list|)
return|;
case|case
literal|11
case|:
comment|/* Reserved for FORTRAN common.  */
name|ieee_error
argument_list|(
name|info
argument_list|,
name|atn_code_start
argument_list|,
name|_
argument_list|(
literal|"unsupported ATN11"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Return true to keep going.  */
return|return
name|true
return|;
case|case
literal|12
case|:
comment|/* Based variable.  */
name|v3
operator|=
literal|0
expr_stmt|;
name|v4
operator|=
literal|0x80
expr_stmt|;
name|v5
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|ieee_read_number
argument_list|(
name|info
argument_list|,
name|pp
argument_list|,
operator|&
name|v
argument_list|)
operator|||
operator|!
name|ieee_read_number
argument_list|(
name|info
argument_list|,
name|pp
argument_list|,
operator|&
name|v2
argument_list|)
operator|||
operator|!
name|ieee_read_optional_number
argument_list|(
name|info
argument_list|,
name|pp
argument_list|,
operator|&
name|v3
argument_list|,
operator|&
name|present
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|present
condition|)
block|{
if|if
condition|(
operator|!
name|ieee_read_optional_number
argument_list|(
name|info
argument_list|,
name|pp
argument_list|,
operator|&
name|v4
argument_list|,
operator|&
name|present
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|present
condition|)
block|{
if|if
condition|(
operator|!
name|ieee_read_optional_number
argument_list|(
name|info
argument_list|,
name|pp
argument_list|,
operator|&
name|v5
argument_list|,
operator|&
name|present
argument_list|)
condition|)
return|return
name|false
return|;
block|}
block|}
comment|/* We have no way to record this information.  FIXME.  */
name|ieee_error
argument_list|(
name|info
argument_list|,
name|atn_code_start
argument_list|,
name|_
argument_list|(
literal|"unsupported ATN12"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Return true to keep going.  */
return|return
name|true
return|;
case|case
literal|16
case|:
comment|/* Constant.  The description of this that I have is ambiguous,          so I'm not going to try to implement it.  */
if|if
condition|(
operator|!
name|ieee_read_number
argument_list|(
name|info
argument_list|,
name|pp
argument_list|,
operator|&
name|v
argument_list|)
operator|||
operator|!
name|ieee_read_optional_number
argument_list|(
name|info
argument_list|,
name|pp
argument_list|,
operator|&
name|v2
argument_list|,
operator|&
name|present
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|present
condition|)
block|{
if|if
condition|(
operator|!
name|ieee_read_optional_number
argument_list|(
name|info
argument_list|,
name|pp
argument_list|,
operator|&
name|v2
argument_list|,
operator|&
name|present
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|present
condition|)
block|{
if|if
condition|(
operator|!
name|ieee_read_optional_id
argument_list|(
name|info
argument_list|,
name|pp
argument_list|,
operator|&
name|name
argument_list|,
operator|&
name|namlen
argument_list|,
operator|&
name|present
argument_list|)
condition|)
return|return
name|false
return|;
block|}
block|}
if|if
condition|(
operator|(
name|ieee_record_enum_type
operator|)
operator|*
operator|*
name|pp
operator|==
name|ieee_e2_first_byte_enum
condition|)
block|{
if|if
condition|(
operator|!
name|ieee_require_asn
argument_list|(
name|info
argument_list|,
name|pp
argument_list|,
operator|&
name|v3
argument_list|)
condition|)
return|return
name|false
return|;
block|}
return|return
name|true
return|;
case|case
literal|19
case|:
comment|/* Static variable from assembler.  */
name|v2
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|ieee_read_number
argument_list|(
name|info
argument_list|,
name|pp
argument_list|,
operator|&
name|v
argument_list|)
operator|||
operator|!
name|ieee_read_optional_number
argument_list|(
name|info
argument_list|,
name|pp
argument_list|,
operator|&
name|v2
argument_list|,
operator|&
name|present
argument_list|)
operator|||
operator|!
name|ieee_require_asn
argument_list|(
name|info
argument_list|,
name|pp
argument_list|,
operator|&
name|v3
argument_list|)
condition|)
return|return
name|false
return|;
name|namcopy
operator|=
name|savestring
argument_list|(
name|name
argument_list|,
name|namlen
argument_list|)
expr_stmt|;
comment|/* We don't really handle this correctly.  FIXME.  */
return|return
name|debug_record_variable
argument_list|(
name|dhandle
argument_list|,
name|namcopy
argument_list|,
name|debug_make_void_type
argument_list|(
name|dhandle
argument_list|)
argument_list|,
name|v2
operator|!=
literal|0
condition|?
name|DEBUG_GLOBAL
else|:
name|DEBUG_STATIC
argument_list|,
name|v3
argument_list|)
return|;
case|case
literal|62
case|:
comment|/* Procedure miscellaneous information.  */
case|case
literal|63
case|:
comment|/* Variable miscellaneous information.  */
case|case
literal|64
case|:
comment|/* Module miscellaneous information.  */
if|if
condition|(
operator|!
name|ieee_read_number
argument_list|(
name|info
argument_list|,
name|pp
argument_list|,
operator|&
name|v
argument_list|)
operator|||
operator|!
name|ieee_read_number
argument_list|(
name|info
argument_list|,
name|pp
argument_list|,
operator|&
name|v2
argument_list|)
operator|||
operator|!
name|ieee_read_optional_id
argument_list|(
name|info
argument_list|,
name|pp
argument_list|,
operator|&
name|name
argument_list|,
operator|&
name|namlen
argument_list|,
operator|&
name|present
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|atn_code
operator|==
literal|62
operator|&&
name|v
operator|==
literal|80
condition|)
block|{
if|if
condition|(
name|present
condition|)
block|{
name|ieee_error
argument_list|(
name|info
argument_list|,
name|atn_code_start
argument_list|,
name|_
argument_list|(
literal|"unexpected string in C++ misc"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
return|return
name|ieee_read_cxx_misc
argument_list|(
name|info
argument_list|,
name|pp
argument_list|,
name|v2
argument_list|)
return|;
block|}
comment|/* We just ignore all of this stuff.  FIXME.  */
for|for
control|(
init|;
name|v2
operator|>
literal|0
condition|;
operator|--
name|v2
control|)
block|{
switch|switch
condition|(
operator|(
name|ieee_record_enum_type
operator|)
operator|*
operator|*
name|pp
condition|)
block|{
default|default:
name|ieee_error
argument_list|(
name|info
argument_list|,
operator|*
name|pp
argument_list|,
name|_
argument_list|(
literal|"bad misc record"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|false
return|;
case|case
name|ieee_at_record_enum
case|:
if|if
condition|(
operator|!
name|ieee_require_atn65
argument_list|(
name|info
argument_list|,
name|pp
argument_list|,
operator|&
name|name
argument_list|,
operator|&
name|namlen
argument_list|)
condition|)
return|return
name|false
return|;
break|break;
case|case
name|ieee_e2_first_byte_enum
case|:
if|if
condition|(
operator|!
name|ieee_require_asn
argument_list|(
name|info
argument_list|,
name|pp
argument_list|,
operator|&
name|v3
argument_list|)
condition|)
return|return
name|false
return|;
break|break;
block|}
block|}
return|return
name|true
return|;
block|}
comment|/*NOTREACHED*/
block|}
end_function

begin_comment
comment|/* Handle C++ debugging miscellaneous records.  This is called for    procedure miscellaneous records of type 80.  */
end_comment

begin_function
specifier|static
name|boolean
name|ieee_read_cxx_misc
parameter_list|(
name|info
parameter_list|,
name|pp
parameter_list|,
name|count
parameter_list|)
name|struct
name|ieee_info
modifier|*
name|info
decl_stmt|;
specifier|const
name|bfd_byte
modifier|*
modifier|*
name|pp
decl_stmt|;
name|unsigned
name|long
name|count
decl_stmt|;
block|{
specifier|const
name|bfd_byte
modifier|*
name|start
decl_stmt|;
name|bfd_vma
name|category
decl_stmt|;
name|start
operator|=
operator|*
name|pp
expr_stmt|;
comment|/* Get the category of C++ misc record.  */
if|if
condition|(
operator|!
name|ieee_require_asn
argument_list|(
name|info
argument_list|,
name|pp
argument_list|,
operator|&
name|category
argument_list|)
condition|)
return|return
name|false
return|;
operator|--
name|count
expr_stmt|;
switch|switch
condition|(
name|category
condition|)
block|{
default|default:
name|ieee_error
argument_list|(
name|info
argument_list|,
name|start
argument_list|,
name|_
argument_list|(
literal|"unrecognized C++ misc record"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|false
return|;
case|case
literal|'T'
case|:
if|if
condition|(
operator|!
name|ieee_read_cxx_class
argument_list|(
name|info
argument_list|,
name|pp
argument_list|,
name|count
argument_list|)
condition|)
return|return
name|false
return|;
break|break;
case|case
literal|'M'
case|:
block|{
name|bfd_vma
name|flags
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|unsigned
name|long
name|namlen
decl_stmt|;
comment|/* The IEEE spec indicates that the 'M' record only has a            flags field.  The MRI compiler also emits the name of the            function.  */
if|if
condition|(
operator|!
name|ieee_require_asn
argument_list|(
name|info
argument_list|,
name|pp
argument_list|,
operator|&
name|flags
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|*
name|pp
operator|<
name|info
operator|->
name|pend
operator|&&
operator|(
name|ieee_record_enum_type
operator|)
operator|*
operator|*
name|pp
operator|==
name|ieee_at_record_enum
condition|)
block|{
if|if
condition|(
operator|!
name|ieee_require_atn65
argument_list|(
name|info
argument_list|,
name|pp
argument_list|,
operator|&
name|name
argument_list|,
operator|&
name|namlen
argument_list|)
condition|)
return|return
name|false
return|;
block|}
comment|/* This is emitted for method functions, but I don't think we            care very much.  It might help if it told us useful            information like the class with which this function is            associated, but it doesn't, so it isn't helpful.  */
block|}
break|break;
case|case
literal|'B'
case|:
if|if
condition|(
operator|!
name|ieee_read_cxx_defaults
argument_list|(
name|info
argument_list|,
name|pp
argument_list|,
name|count
argument_list|)
condition|)
return|return
name|false
return|;
break|break;
case|case
literal|'z'
case|:
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|,
modifier|*
name|mangled
decl_stmt|,
modifier|*
name|class
decl_stmt|;
name|unsigned
name|long
name|namlen
decl_stmt|,
name|mangledlen
decl_stmt|,
name|classlen
decl_stmt|;
name|bfd_vma
name|control
decl_stmt|;
comment|/* Pointer to member.  */
if|if
condition|(
operator|!
name|ieee_require_atn65
argument_list|(
name|info
argument_list|,
name|pp
argument_list|,
operator|&
name|name
argument_list|,
operator|&
name|namlen
argument_list|)
operator|||
operator|!
name|ieee_require_atn65
argument_list|(
name|info
argument_list|,
name|pp
argument_list|,
operator|&
name|mangled
argument_list|,
operator|&
name|mangledlen
argument_list|)
operator|||
operator|!
name|ieee_require_atn65
argument_list|(
name|info
argument_list|,
name|pp
argument_list|,
operator|&
name|class
argument_list|,
operator|&
name|classlen
argument_list|)
operator|||
operator|!
name|ieee_require_asn
argument_list|(
name|info
argument_list|,
name|pp
argument_list|,
operator|&
name|control
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* FIXME: We should now track down name and change its type.  */
block|}
break|break;
case|case
literal|'R'
case|:
if|if
condition|(
operator|!
name|ieee_read_reference
argument_list|(
name|info
argument_list|,
name|pp
argument_list|)
condition|)
return|return
name|false
return|;
break|break;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Read a C++ class definition.  This is a pmisc type 80 record of    category 'T'.  */
end_comment

begin_function
specifier|static
name|boolean
name|ieee_read_cxx_class
parameter_list|(
name|info
parameter_list|,
name|pp
parameter_list|,
name|count
parameter_list|)
name|struct
name|ieee_info
modifier|*
name|info
decl_stmt|;
specifier|const
name|bfd_byte
modifier|*
modifier|*
name|pp
decl_stmt|;
name|unsigned
name|long
name|count
decl_stmt|;
block|{
specifier|const
name|bfd_byte
modifier|*
name|start
decl_stmt|;
name|bfd_vma
name|class
decl_stmt|;
specifier|const
name|char
modifier|*
name|tag
decl_stmt|;
name|unsigned
name|long
name|taglen
decl_stmt|;
name|struct
name|ieee_tag
modifier|*
name|it
decl_stmt|;
name|PTR
name|dhandle
decl_stmt|;
name|debug_field
modifier|*
name|fields
decl_stmt|;
name|unsigned
name|int
name|field_count
decl_stmt|,
name|field_alloc
decl_stmt|;
name|debug_baseclass
modifier|*
name|baseclasses
decl_stmt|;
name|unsigned
name|int
name|baseclasses_count
decl_stmt|,
name|baseclasses_alloc
decl_stmt|;
specifier|const
name|debug_field
modifier|*
name|structfields
decl_stmt|;
struct|struct
name|ieee_method
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|unsigned
name|long
name|namlen
decl_stmt|;
name|debug_method_variant
modifier|*
name|variants
decl_stmt|;
name|unsigned
name|count
decl_stmt|;
name|unsigned
name|int
name|alloc
decl_stmt|;
block|}
modifier|*
name|methods
struct|;
name|unsigned
name|int
name|methods_count
decl_stmt|,
name|methods_alloc
decl_stmt|;
name|debug_type
name|vptrbase
decl_stmt|;
name|boolean
name|ownvptr
decl_stmt|;
name|debug_method
modifier|*
name|dmethods
decl_stmt|;
name|start
operator|=
operator|*
name|pp
expr_stmt|;
if|if
condition|(
operator|!
name|ieee_require_asn
argument_list|(
name|info
argument_list|,
name|pp
argument_list|,
operator|&
name|class
argument_list|)
condition|)
return|return
name|false
return|;
operator|--
name|count
expr_stmt|;
if|if
condition|(
operator|!
name|ieee_require_atn65
argument_list|(
name|info
argument_list|,
name|pp
argument_list|,
operator|&
name|tag
argument_list|,
operator|&
name|taglen
argument_list|)
condition|)
return|return
name|false
return|;
operator|--
name|count
expr_stmt|;
comment|/* Find the C struct with this name.  */
for|for
control|(
name|it
operator|=
name|info
operator|->
name|tags
init|;
name|it
operator|!=
name|NULL
condition|;
name|it
operator|=
name|it
operator|->
name|next
control|)
if|if
condition|(
name|it
operator|->
name|name
index|[
literal|0
index|]
operator|==
name|tag
index|[
literal|0
index|]
operator|&&
name|strncmp
argument_list|(
name|it
operator|->
name|name
argument_list|,
name|tag
argument_list|,
name|taglen
argument_list|)
operator|==
literal|0
operator|&&
name|strlen
argument_list|(
name|it
operator|->
name|name
argument_list|)
operator|==
name|taglen
condition|)
break|break;
if|if
condition|(
name|it
operator|==
name|NULL
condition|)
block|{
name|ieee_error
argument_list|(
name|info
argument_list|,
name|start
argument_list|,
name|_
argument_list|(
literal|"undefined C++ object"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|dhandle
operator|=
name|info
operator|->
name|dhandle
expr_stmt|;
name|fields
operator|=
name|NULL
expr_stmt|;
name|field_count
operator|=
literal|0
expr_stmt|;
name|field_alloc
operator|=
literal|0
expr_stmt|;
name|baseclasses
operator|=
name|NULL
expr_stmt|;
name|baseclasses_count
operator|=
literal|0
expr_stmt|;
name|baseclasses_alloc
operator|=
literal|0
expr_stmt|;
name|methods
operator|=
name|NULL
expr_stmt|;
name|methods_count
operator|=
literal|0
expr_stmt|;
name|methods_alloc
operator|=
literal|0
expr_stmt|;
name|vptrbase
operator|=
name|DEBUG_TYPE_NULL
expr_stmt|;
name|ownvptr
operator|=
name|false
expr_stmt|;
name|structfields
operator|=
name|debug_get_fields
argument_list|(
name|dhandle
argument_list|,
name|it
operator|->
name|type
argument_list|)
expr_stmt|;
while|while
condition|(
name|count
operator|>
literal|0
condition|)
block|{
name|bfd_vma
name|id
decl_stmt|;
specifier|const
name|bfd_byte
modifier|*
name|spec_start
decl_stmt|;
name|spec_start
operator|=
operator|*
name|pp
expr_stmt|;
if|if
condition|(
operator|!
name|ieee_require_asn
argument_list|(
name|info
argument_list|,
name|pp
argument_list|,
operator|&
name|id
argument_list|)
condition|)
return|return
name|false
return|;
operator|--
name|count
expr_stmt|;
switch|switch
condition|(
name|id
condition|)
block|{
default|default:
name|ieee_error
argument_list|(
name|info
argument_list|,
name|spec_start
argument_list|,
name|_
argument_list|(
literal|"unrecognized C++ object spec"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|false
return|;
case|case
literal|'b'
case|:
block|{
name|bfd_vma
name|flags
decl_stmt|,
name|cinline
decl_stmt|;
specifier|const
name|char
modifier|*
name|basename
decl_stmt|,
modifier|*
name|fieldname
decl_stmt|;
name|unsigned
name|long
name|baselen
decl_stmt|,
name|fieldlen
decl_stmt|;
name|char
modifier|*
name|basecopy
decl_stmt|;
name|debug_type
name|basetype
decl_stmt|;
name|bfd_vma
name|bitpos
decl_stmt|;
name|boolean
name|virtualp
decl_stmt|;
name|enum
name|debug_visibility
name|visibility
decl_stmt|;
name|debug_baseclass
name|baseclass
decl_stmt|;
comment|/* This represents a base or friend class.  */
if|if
condition|(
operator|!
name|ieee_require_asn
argument_list|(
name|info
argument_list|,
name|pp
argument_list|,
operator|&
name|flags
argument_list|)
operator|||
operator|!
name|ieee_require_atn65
argument_list|(
name|info
argument_list|,
name|pp
argument_list|,
operator|&
name|basename
argument_list|,
operator|&
name|baselen
argument_list|)
operator|||
operator|!
name|ieee_require_asn
argument_list|(
name|info
argument_list|,
name|pp
argument_list|,
operator|&
name|cinline
argument_list|)
operator|||
operator|!
name|ieee_require_atn65
argument_list|(
name|info
argument_list|,
name|pp
argument_list|,
operator|&
name|fieldname
argument_list|,
operator|&
name|fieldlen
argument_list|)
condition|)
return|return
name|false
return|;
name|count
operator|-=
literal|4
expr_stmt|;
comment|/* We have no way of recording friend information, so we                just ignore it.  */
if|if
condition|(
operator|(
name|flags
operator|&
name|BASEFLAGS_FRIEND
operator|)
operator|!=
literal|0
condition|)
break|break;
comment|/* I assume that either all of the members of the                baseclass are included in the object, starting at the                beginning of the object, or that none of them are                included.  */
if|if
condition|(
operator|(
name|fieldlen
operator|==
literal|0
operator|)
operator|==
operator|(
name|cinline
operator|==
literal|0
operator|)
condition|)
block|{
name|ieee_error
argument_list|(
name|info
argument_list|,
name|start
argument_list|,
name|_
argument_list|(
literal|"unsupported C++ object type"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|basecopy
operator|=
name|savestring
argument_list|(
name|basename
argument_list|,
name|baselen
argument_list|)
expr_stmt|;
name|basetype
operator|=
name|debug_find_tagged_type
argument_list|(
name|dhandle
argument_list|,
name|basecopy
argument_list|,
name|DEBUG_KIND_ILLEGAL
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|basecopy
argument_list|)
expr_stmt|;
if|if
condition|(
name|basetype
operator|==
name|DEBUG_TYPE_NULL
condition|)
block|{
name|ieee_error
argument_list|(
name|info
argument_list|,
name|start
argument_list|,
name|_
argument_list|(
literal|"C++ base class not defined"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
name|fieldlen
operator|==
literal|0
condition|)
name|bitpos
operator|=
literal|0
expr_stmt|;
else|else
block|{
specifier|const
name|debug_field
modifier|*
name|pf
decl_stmt|;
if|if
condition|(
name|structfields
operator|==
name|NULL
condition|)
block|{
name|ieee_error
argument_list|(
name|info
argument_list|,
name|start
argument_list|,
name|_
argument_list|(
literal|"C++ object has no fields"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
for|for
control|(
name|pf
operator|=
name|structfields
init|;
operator|*
name|pf
operator|!=
name|DEBUG_FIELD_NULL
condition|;
name|pf
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|fname
decl_stmt|;
name|fname
operator|=
name|debug_get_field_name
argument_list|(
name|dhandle
argument_list|,
operator|*
name|pf
argument_list|)
expr_stmt|;
if|if
condition|(
name|fname
operator|==
name|NULL
condition|)
return|return
name|false
return|;
if|if
condition|(
name|fname
index|[
literal|0
index|]
operator|==
name|fieldname
index|[
literal|0
index|]
operator|&&
name|strncmp
argument_list|(
name|fname
argument_list|,
name|fieldname
argument_list|,
name|fieldlen
argument_list|)
operator|==
literal|0
operator|&&
name|strlen
argument_list|(
name|fname
argument_list|)
operator|==
name|fieldlen
condition|)
break|break;
block|}
if|if
condition|(
operator|*
name|pf
operator|==
name|DEBUG_FIELD_NULL
condition|)
block|{
name|ieee_error
argument_list|(
name|info
argument_list|,
name|start
argument_list|,
name|_
argument_list|(
literal|"C++ base class not found in container"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|bitpos
operator|=
name|debug_get_field_bitpos
argument_list|(
name|dhandle
argument_list|,
operator|*
name|pf
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|flags
operator|&
name|BASEFLAGS_VIRTUAL
operator|)
operator|!=
literal|0
condition|)
name|virtualp
operator|=
name|true
expr_stmt|;
else|else
name|virtualp
operator|=
name|false
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|BASEFLAGS_PRIVATE
operator|)
operator|!=
literal|0
condition|)
name|visibility
operator|=
name|DEBUG_VISIBILITY_PRIVATE
expr_stmt|;
else|else
name|visibility
operator|=
name|DEBUG_VISIBILITY_PUBLIC
expr_stmt|;
name|baseclass
operator|=
name|debug_make_baseclass
argument_list|(
name|dhandle
argument_list|,
name|basetype
argument_list|,
name|bitpos
argument_list|,
name|virtualp
argument_list|,
name|visibility
argument_list|)
expr_stmt|;
if|if
condition|(
name|baseclass
operator|==
name|DEBUG_BASECLASS_NULL
condition|)
return|return
name|false
return|;
if|if
condition|(
name|baseclasses_count
operator|+
literal|1
operator|>=
name|baseclasses_alloc
condition|)
block|{
name|baseclasses_alloc
operator|+=
literal|10
expr_stmt|;
name|baseclasses
operator|=
operator|(
operator|(
name|debug_baseclass
operator|*
operator|)
name|xrealloc
argument_list|(
name|baseclasses
argument_list|,
operator|(
name|baseclasses_alloc
operator|*
sizeof|sizeof
expr|*
name|baseclasses
operator|)
argument_list|)
operator|)
expr_stmt|;
block|}
name|baseclasses
index|[
name|baseclasses_count
index|]
operator|=
name|baseclass
expr_stmt|;
operator|++
name|baseclasses_count
expr_stmt|;
name|baseclasses
index|[
name|baseclasses_count
index|]
operator|=
name|DEBUG_BASECLASS_NULL
expr_stmt|;
block|}
break|break;
case|case
literal|'d'
case|:
block|{
name|bfd_vma
name|flags
decl_stmt|;
specifier|const
name|char
modifier|*
name|fieldname
decl_stmt|,
modifier|*
name|mangledname
decl_stmt|;
name|unsigned
name|long
name|fieldlen
decl_stmt|,
name|mangledlen
decl_stmt|;
name|char
modifier|*
name|fieldcopy
decl_stmt|;
name|boolean
name|staticp
decl_stmt|;
name|debug_type
name|ftype
decl_stmt|;
specifier|const
name|debug_field
modifier|*
name|pf
init|=
name|NULL
decl_stmt|;
name|enum
name|debug_visibility
name|visibility
decl_stmt|;
name|debug_field
name|field
decl_stmt|;
comment|/* This represents a data member.  */
if|if
condition|(
operator|!
name|ieee_require_asn
argument_list|(
name|info
argument_list|,
name|pp
argument_list|,
operator|&
name|flags
argument_list|)
operator|||
operator|!
name|ieee_require_atn65
argument_list|(
name|info
argument_list|,
name|pp
argument_list|,
operator|&
name|fieldname
argument_list|,
operator|&
name|fieldlen
argument_list|)
operator|||
operator|!
name|ieee_require_atn65
argument_list|(
name|info
argument_list|,
name|pp
argument_list|,
operator|&
name|mangledname
argument_list|,
operator|&
name|mangledlen
argument_list|)
condition|)
return|return
name|false
return|;
name|count
operator|-=
literal|3
expr_stmt|;
name|fieldcopy
operator|=
name|savestring
argument_list|(
name|fieldname
argument_list|,
name|fieldlen
argument_list|)
expr_stmt|;
name|staticp
operator|=
operator|(
name|flags
operator|&
name|CXXFLAGS_STATIC
operator|)
operator|!=
literal|0
condition|?
name|true
else|:
name|false
expr_stmt|;
if|if
condition|(
name|staticp
condition|)
block|{
name|struct
name|ieee_var
modifier|*
name|pv
decl_stmt|,
modifier|*
name|pvend
decl_stmt|;
comment|/* See if we can find a definition for this variable.  */
name|pv
operator|=
name|info
operator|->
name|vars
operator|.
name|vars
expr_stmt|;
name|pvend
operator|=
name|pv
operator|+
name|info
operator|->
name|vars
operator|.
name|alloc
expr_stmt|;
for|for
control|(
init|;
name|pv
operator|<
name|pvend
condition|;
name|pv
operator|++
control|)
if|if
condition|(
name|pv
operator|->
name|namlen
operator|==
name|mangledlen
operator|&&
name|strncmp
argument_list|(
name|pv
operator|->
name|name
argument_list|,
name|mangledname
argument_list|,
name|mangledlen
argument_list|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|pv
operator|<
name|pvend
condition|)
name|ftype
operator|=
name|pv
operator|->
name|type
expr_stmt|;
else|else
block|{
comment|/* This can happen if the variable is never used.  */
name|ftype
operator|=
name|ieee_builtin_type
argument_list|(
name|info
argument_list|,
name|start
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|builtin_void
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|unsigned
name|int
name|findx
decl_stmt|;
if|if
condition|(
name|structfields
operator|==
name|NULL
condition|)
block|{
name|ieee_error
argument_list|(
name|info
argument_list|,
name|start
argument_list|,
name|_
argument_list|(
literal|"C++ object has no fields"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
for|for
control|(
name|pf
operator|=
name|structfields
operator|,
name|findx
operator|=
literal|0
init|;
operator|*
name|pf
operator|!=
name|DEBUG_FIELD_NULL
condition|;
name|pf
operator|++
operator|,
name|findx
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|fname
decl_stmt|;
name|fname
operator|=
name|debug_get_field_name
argument_list|(
name|dhandle
argument_list|,
operator|*
name|pf
argument_list|)
expr_stmt|;
if|if
condition|(
name|fname
operator|==
name|NULL
condition|)
return|return
name|false
return|;
if|if
condition|(
name|fname
index|[
literal|0
index|]
operator|==
name|mangledname
index|[
literal|0
index|]
operator|&&
name|strncmp
argument_list|(
name|fname
argument_list|,
name|mangledname
argument_list|,
name|mangledlen
argument_list|)
operator|==
literal|0
operator|&&
name|strlen
argument_list|(
name|fname
argument_list|)
operator|==
name|mangledlen
condition|)
break|break;
block|}
if|if
condition|(
operator|*
name|pf
operator|==
name|DEBUG_FIELD_NULL
condition|)
block|{
name|ieee_error
argument_list|(
name|info
argument_list|,
name|start
argument_list|,
name|_
argument_list|(
literal|"C++ data member not found in container"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|ftype
operator|=
name|debug_get_field_type
argument_list|(
name|dhandle
argument_list|,
operator|*
name|pf
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug_get_type_kind
argument_list|(
name|dhandle
argument_list|,
name|ftype
argument_list|)
operator|==
name|DEBUG_KIND_POINTER
condition|)
block|{
comment|/* We might need to convert this field into a                        reference type later on, so make it an indirect                        type.  */
if|if
condition|(
name|it
operator|->
name|fslots
operator|==
name|NULL
condition|)
block|{
name|unsigned
name|int
name|fcnt
decl_stmt|;
specifier|const
name|debug_field
modifier|*
name|pfcnt
decl_stmt|;
name|fcnt
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|pfcnt
operator|=
name|structfields
init|;
operator|*
name|pfcnt
operator|!=
name|DEBUG_FIELD_NULL
condition|;
name|pfcnt
operator|++
control|)
operator|++
name|fcnt
expr_stmt|;
name|it
operator|->
name|fslots
operator|=
operator|(
operator|(
name|debug_type
operator|*
operator|)
name|xmalloc
argument_list|(
name|fcnt
operator|*
sizeof|sizeof
expr|*
name|it
operator|->
name|fslots
argument_list|)
operator|)
expr_stmt|;
name|memset
argument_list|(
name|it
operator|->
name|fslots
argument_list|,
literal|0
argument_list|,
name|fcnt
operator|*
sizeof|sizeof
expr|*
name|it
operator|->
name|fslots
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ftype
operator|==
name|DEBUG_TYPE_NULL
condition|)
return|return
name|false
return|;
name|it
operator|->
name|fslots
index|[
name|findx
index|]
operator|=
name|ftype
expr_stmt|;
name|ftype
operator|=
name|debug_make_indirect_type
argument_list|(
name|dhandle
argument_list|,
name|it
operator|->
name|fslots
operator|+
name|findx
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ftype
operator|==
name|DEBUG_TYPE_NULL
condition|)
return|return
name|false
return|;
switch|switch
condition|(
name|flags
operator|&
name|CXXFLAGS_VISIBILITY
condition|)
block|{
default|default:
name|ieee_error
argument_list|(
name|info
argument_list|,
name|start
argument_list|,
name|_
argument_list|(
literal|"unknown C++ visibility"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|false
return|;
case|case
name|CXXFLAGS_VISIBILITY_PUBLIC
case|:
name|visibility
operator|=
name|DEBUG_VISIBILITY_PUBLIC
expr_stmt|;
break|break;
case|case
name|CXXFLAGS_VISIBILITY_PRIVATE
case|:
name|visibility
operator|=
name|DEBUG_VISIBILITY_PRIVATE
expr_stmt|;
break|break;
case|case
name|CXXFLAGS_VISIBILITY_PROTECTED
case|:
name|visibility
operator|=
name|DEBUG_VISIBILITY_PROTECTED
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|staticp
condition|)
block|{
name|char
modifier|*
name|mangledcopy
decl_stmt|;
name|mangledcopy
operator|=
name|savestring
argument_list|(
name|mangledname
argument_list|,
name|mangledlen
argument_list|)
expr_stmt|;
name|field
operator|=
name|debug_make_static_member
argument_list|(
name|dhandle
argument_list|,
name|fieldcopy
argument_list|,
name|ftype
argument_list|,
name|mangledcopy
argument_list|,
name|visibility
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bfd_vma
name|bitpos
decl_stmt|,
name|bitsize
decl_stmt|;
name|bitpos
operator|=
name|debug_get_field_bitpos
argument_list|(
name|dhandle
argument_list|,
operator|*
name|pf
argument_list|)
expr_stmt|;
name|bitsize
operator|=
name|debug_get_field_bitsize
argument_list|(
name|dhandle
argument_list|,
operator|*
name|pf
argument_list|)
expr_stmt|;
if|if
condition|(
name|bitpos
operator|==
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
operator|||
name|bitsize
operator|==
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
condition|)
block|{
name|ieee_error
argument_list|(
name|info
argument_list|,
name|start
argument_list|,
name|_
argument_list|(
literal|"bad C++ field bit pos or size"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|field
operator|=
name|debug_make_field
argument_list|(
name|dhandle
argument_list|,
name|fieldcopy
argument_list|,
name|ftype
argument_list|,
name|bitpos
argument_list|,
name|bitsize
argument_list|,
name|visibility
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|field
operator|==
name|DEBUG_FIELD_NULL
condition|)
return|return
name|false
return|;
if|if
condition|(
name|field_count
operator|+
literal|1
operator|>=
name|field_alloc
condition|)
block|{
name|field_alloc
operator|+=
literal|10
expr_stmt|;
name|fields
operator|=
operator|(
operator|(
name|debug_field
operator|*
operator|)
name|xrealloc
argument_list|(
name|fields
argument_list|,
name|field_alloc
operator|*
sizeof|sizeof
expr|*
name|fields
argument_list|)
operator|)
expr_stmt|;
block|}
name|fields
index|[
name|field_count
index|]
operator|=
name|field
expr_stmt|;
operator|++
name|field_count
expr_stmt|;
name|fields
index|[
name|field_count
index|]
operator|=
name|DEBUG_FIELD_NULL
expr_stmt|;
block|}
break|break;
case|case
literal|'m'
case|:
case|case
literal|'v'
case|:
block|{
name|bfd_vma
name|flags
decl_stmt|,
name|voffset
decl_stmt|,
name|control
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|,
modifier|*
name|mangled
decl_stmt|;
name|unsigned
name|long
name|namlen
decl_stmt|,
name|mangledlen
decl_stmt|;
name|struct
name|ieee_var
modifier|*
name|pv
decl_stmt|,
modifier|*
name|pvend
decl_stmt|;
name|debug_type
name|type
decl_stmt|;
name|enum
name|debug_visibility
name|visibility
decl_stmt|;
name|boolean
name|constp
decl_stmt|,
name|volatilep
decl_stmt|;
name|char
modifier|*
name|mangledcopy
decl_stmt|;
name|debug_method_variant
name|mv
decl_stmt|;
name|struct
name|ieee_method
modifier|*
name|meth
decl_stmt|;
name|unsigned
name|int
name|im
decl_stmt|;
if|if
condition|(
operator|!
name|ieee_require_asn
argument_list|(
name|info
argument_list|,
name|pp
argument_list|,
operator|&
name|flags
argument_list|)
operator|||
operator|!
name|ieee_require_atn65
argument_list|(
name|info
argument_list|,
name|pp
argument_list|,
operator|&
name|name
argument_list|,
operator|&
name|namlen
argument_list|)
operator|||
operator|!
name|ieee_require_atn65
argument_list|(
name|info
argument_list|,
name|pp
argument_list|,
operator|&
name|mangled
argument_list|,
operator|&
name|mangledlen
argument_list|)
condition|)
return|return
name|false
return|;
name|count
operator|-=
literal|3
expr_stmt|;
if|if
condition|(
name|id
operator|!=
literal|'v'
condition|)
name|voffset
operator|=
literal|0
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|!
name|ieee_require_asn
argument_list|(
name|info
argument_list|,
name|pp
argument_list|,
operator|&
name|voffset
argument_list|)
condition|)
return|return
name|false
return|;
operator|--
name|count
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|ieee_require_asn
argument_list|(
name|info
argument_list|,
name|pp
argument_list|,
operator|&
name|control
argument_list|)
condition|)
return|return
name|false
return|;
operator|--
name|count
expr_stmt|;
comment|/* We just ignore the control information.  */
comment|/* We have no way to represent friend information, so we                just ignore it.  */
if|if
condition|(
operator|(
name|flags
operator|&
name|CXXFLAGS_FRIEND
operator|)
operator|!=
literal|0
condition|)
break|break;
comment|/* We should already have seen a type for the function.  */
name|pv
operator|=
name|info
operator|->
name|vars
operator|.
name|vars
expr_stmt|;
name|pvend
operator|=
name|pv
operator|+
name|info
operator|->
name|vars
operator|.
name|alloc
expr_stmt|;
for|for
control|(
init|;
name|pv
operator|<
name|pvend
condition|;
name|pv
operator|++
control|)
if|if
condition|(
name|pv
operator|->
name|namlen
operator|==
name|mangledlen
operator|&&
name|strncmp
argument_list|(
name|pv
operator|->
name|name
argument_list|,
name|mangled
argument_list|,
name|mangledlen
argument_list|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|pv
operator|>=
name|pvend
condition|)
block|{
comment|/* We won't have type information for this function if 		   it is not included in this file.  We don't try to 		   handle this case.  FIXME.  */
name|type
operator|=
operator|(
name|debug_make_function_type
argument_list|(
name|dhandle
argument_list|,
name|ieee_builtin_type
argument_list|(
name|info
argument_list|,
name|start
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|builtin_void
argument_list|)
argument_list|,
operator|(
name|debug_type
operator|*
operator|)
name|NULL
argument_list|,
name|false
argument_list|)
operator|)
expr_stmt|;
block|}
else|else
block|{
name|debug_type
name|return_type
decl_stmt|;
specifier|const
name|debug_type
modifier|*
name|arg_types
decl_stmt|;
name|boolean
name|varargs
decl_stmt|;
if|if
condition|(
name|debug_get_type_kind
argument_list|(
name|dhandle
argument_list|,
name|pv
operator|->
name|type
argument_list|)
operator|!=
name|DEBUG_KIND_FUNCTION
condition|)
block|{
name|ieee_error
argument_list|(
name|info
argument_list|,
name|start
argument_list|,
name|_
argument_list|(
literal|"bad type for C++ method function"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|return_type
operator|=
name|debug_get_return_type
argument_list|(
name|dhandle
argument_list|,
name|pv
operator|->
name|type
argument_list|)
expr_stmt|;
name|arg_types
operator|=
name|debug_get_parameter_types
argument_list|(
name|dhandle
argument_list|,
name|pv
operator|->
name|type
argument_list|,
operator|&
name|varargs
argument_list|)
expr_stmt|;
if|if
condition|(
name|return_type
operator|==
name|DEBUG_TYPE_NULL
operator|||
name|arg_types
operator|==
name|NULL
condition|)
block|{
name|ieee_error
argument_list|(
name|info
argument_list|,
name|start
argument_list|,
name|_
argument_list|(
literal|"no type information for C++ method function"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|type
operator|=
name|debug_make_method_type
argument_list|(
name|dhandle
argument_list|,
name|return_type
argument_list|,
name|it
operator|->
name|type
argument_list|,
operator|(
name|debug_type
operator|*
operator|)
name|arg_types
argument_list|,
name|varargs
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|type
operator|==
name|DEBUG_TYPE_NULL
condition|)
return|return
name|false
return|;
switch|switch
condition|(
name|flags
operator|&
name|CXXFLAGS_VISIBILITY
condition|)
block|{
default|default:
name|ieee_error
argument_list|(
name|info
argument_list|,
name|start
argument_list|,
name|_
argument_list|(
literal|"unknown C++ visibility"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|false
return|;
case|case
name|CXXFLAGS_VISIBILITY_PUBLIC
case|:
name|visibility
operator|=
name|DEBUG_VISIBILITY_PUBLIC
expr_stmt|;
break|break;
case|case
name|CXXFLAGS_VISIBILITY_PRIVATE
case|:
name|visibility
operator|=
name|DEBUG_VISIBILITY_PRIVATE
expr_stmt|;
break|break;
case|case
name|CXXFLAGS_VISIBILITY_PROTECTED
case|:
name|visibility
operator|=
name|DEBUG_VISIBILITY_PROTECTED
expr_stmt|;
break|break;
block|}
name|constp
operator|=
operator|(
name|flags
operator|&
name|CXXFLAGS_CONST
operator|)
operator|!=
literal|0
condition|?
name|true
else|:
name|false
expr_stmt|;
name|volatilep
operator|=
operator|(
name|flags
operator|&
name|CXXFLAGS_VOLATILE
operator|)
operator|!=
literal|0
condition|?
name|true
else|:
name|false
expr_stmt|;
name|mangledcopy
operator|=
name|savestring
argument_list|(
name|mangled
argument_list|,
name|mangledlen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|CXXFLAGS_STATIC
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|id
operator|==
literal|'v'
condition|)
block|{
name|ieee_error
argument_list|(
name|info
argument_list|,
name|start
argument_list|,
name|_
argument_list|(
literal|"C++ static virtual method"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|mv
operator|=
name|debug_make_static_method_variant
argument_list|(
name|dhandle
argument_list|,
name|mangledcopy
argument_list|,
name|type
argument_list|,
name|visibility
argument_list|,
name|constp
argument_list|,
name|volatilep
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|debug_type
name|vcontext
decl_stmt|;
if|if
condition|(
name|id
operator|!=
literal|'v'
condition|)
name|vcontext
operator|=
name|DEBUG_TYPE_NULL
expr_stmt|;
else|else
block|{
comment|/* FIXME: How can we calculate this correctly?  */
name|vcontext
operator|=
name|it
operator|->
name|type
expr_stmt|;
block|}
name|mv
operator|=
name|debug_make_method_variant
argument_list|(
name|dhandle
argument_list|,
name|mangledcopy
argument_list|,
name|type
argument_list|,
name|visibility
argument_list|,
name|constp
argument_list|,
name|volatilep
argument_list|,
name|voffset
argument_list|,
name|vcontext
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mv
operator|==
name|DEBUG_METHOD_VARIANT_NULL
condition|)
return|return
name|false
return|;
for|for
control|(
name|meth
operator|=
name|methods
operator|,
name|im
operator|=
literal|0
init|;
name|im
operator|<
name|methods_count
condition|;
name|meth
operator|++
operator|,
name|im
operator|++
control|)
if|if
condition|(
name|meth
operator|->
name|namlen
operator|==
name|namlen
operator|&&
name|strncmp
argument_list|(
name|meth
operator|->
name|name
argument_list|,
name|name
argument_list|,
name|namlen
argument_list|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|im
operator|>=
name|methods_count
condition|)
block|{
if|if
condition|(
name|methods_count
operator|>=
name|methods_alloc
condition|)
block|{
name|methods_alloc
operator|+=
literal|10
expr_stmt|;
name|methods
operator|=
operator|(
operator|(
expr|struct
name|ieee_method
operator|*
operator|)
name|xrealloc
argument_list|(
name|methods
argument_list|,
name|methods_alloc
operator|*
sizeof|sizeof
expr|*
name|methods
argument_list|)
operator|)
expr_stmt|;
block|}
name|methods
index|[
name|methods_count
index|]
operator|.
name|name
operator|=
name|name
expr_stmt|;
name|methods
index|[
name|methods_count
index|]
operator|.
name|namlen
operator|=
name|namlen
expr_stmt|;
name|methods
index|[
name|methods_count
index|]
operator|.
name|variants
operator|=
name|NULL
expr_stmt|;
name|methods
index|[
name|methods_count
index|]
operator|.
name|count
operator|=
literal|0
expr_stmt|;
name|methods
index|[
name|methods_count
index|]
operator|.
name|alloc
operator|=
literal|0
expr_stmt|;
name|meth
operator|=
name|methods
operator|+
name|methods_count
expr_stmt|;
operator|++
name|methods_count
expr_stmt|;
block|}
if|if
condition|(
name|meth
operator|->
name|count
operator|+
literal|1
operator|>=
name|meth
operator|->
name|alloc
condition|)
block|{
name|meth
operator|->
name|alloc
operator|+=
literal|10
expr_stmt|;
name|meth
operator|->
name|variants
operator|=
operator|(
operator|(
name|debug_method_variant
operator|*
operator|)
name|xrealloc
argument_list|(
name|meth
operator|->
name|variants
argument_list|,
operator|(
name|meth
operator|->
name|alloc
operator|*
sizeof|sizeof
expr|*
name|meth
operator|->
name|variants
operator|)
argument_list|)
operator|)
expr_stmt|;
block|}
name|meth
operator|->
name|variants
index|[
name|meth
operator|->
name|count
index|]
operator|=
name|mv
expr_stmt|;
operator|++
name|meth
operator|->
name|count
expr_stmt|;
name|meth
operator|->
name|variants
index|[
name|meth
operator|->
name|count
index|]
operator|=
name|DEBUG_METHOD_VARIANT_NULL
expr_stmt|;
block|}
break|break;
case|case
literal|'o'
case|:
block|{
name|bfd_vma
name|spec
decl_stmt|;
comment|/* We have no way to store this information, so we just 	       ignore it.  */
if|if
condition|(
operator|!
name|ieee_require_asn
argument_list|(
name|info
argument_list|,
name|pp
argument_list|,
operator|&
name|spec
argument_list|)
condition|)
return|return
name|false
return|;
operator|--
name|count
expr_stmt|;
if|if
condition|(
operator|(
name|spec
operator|&
literal|4
operator|)
operator|!=
literal|0
condition|)
block|{
specifier|const
name|char
modifier|*
name|filename
decl_stmt|;
name|unsigned
name|long
name|filenamlen
decl_stmt|;
name|bfd_vma
name|lineno
decl_stmt|;
if|if
condition|(
operator|!
name|ieee_require_atn65
argument_list|(
name|info
argument_list|,
name|pp
argument_list|,
operator|&
name|filename
argument_list|,
operator|&
name|filenamlen
argument_list|)
operator|||
operator|!
name|ieee_require_asn
argument_list|(
name|info
argument_list|,
name|pp
argument_list|,
operator|&
name|lineno
argument_list|)
condition|)
return|return
name|false
return|;
name|count
operator|-=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|spec
operator|&
literal|8
operator|)
operator|!=
literal|0
condition|)
block|{
specifier|const
name|char
modifier|*
name|mangled
decl_stmt|;
name|unsigned
name|long
name|mangledlen
decl_stmt|;
if|if
condition|(
operator|!
name|ieee_require_atn65
argument_list|(
name|info
argument_list|,
name|pp
argument_list|,
operator|&
name|mangled
argument_list|,
operator|&
name|mangledlen
argument_list|)
condition|)
return|return
name|false
return|;
operator|--
name|count
expr_stmt|;
block|}
else|else
block|{
name|ieee_error
argument_list|(
name|info
argument_list|,
name|start
argument_list|,
name|_
argument_list|(
literal|"unrecognized C++ object overhead spec"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
block|}
break|break;
case|case
literal|'z'
case|:
block|{
specifier|const
name|char
modifier|*
name|vname
decl_stmt|,
modifier|*
name|basename
decl_stmt|;
name|unsigned
name|long
name|vnamelen
decl_stmt|,
name|baselen
decl_stmt|;
name|bfd_vma
name|vsize
decl_stmt|,
name|control
decl_stmt|;
comment|/* A virtual table pointer.  */
if|if
condition|(
operator|!
name|ieee_require_atn65
argument_list|(
name|info
argument_list|,
name|pp
argument_list|,
operator|&
name|vname
argument_list|,
operator|&
name|vnamelen
argument_list|)
operator|||
operator|!
name|ieee_require_asn
argument_list|(
name|info
argument_list|,
name|pp
argument_list|,
operator|&
name|vsize
argument_list|)
operator|||
operator|!
name|ieee_require_atn65
argument_list|(
name|info
argument_list|,
name|pp
argument_list|,
operator|&
name|basename
argument_list|,
operator|&
name|baselen
argument_list|)
operator|||
operator|!
name|ieee_require_asn
argument_list|(
name|info
argument_list|,
name|pp
argument_list|,
operator|&
name|control
argument_list|)
condition|)
return|return
name|false
return|;
name|count
operator|-=
literal|4
expr_stmt|;
comment|/* We just ignore the control number.  We don't care what 	       the virtual table name is.  We have no way to store the 	       virtual table size, and I don't think we care anyhow.  */
comment|/* FIXME: We can't handle multiple virtual table pointers.  */
if|if
condition|(
name|baselen
operator|==
literal|0
condition|)
name|ownvptr
operator|=
name|true
expr_stmt|;
else|else
block|{
name|char
modifier|*
name|basecopy
decl_stmt|;
name|basecopy
operator|=
name|savestring
argument_list|(
name|basename
argument_list|,
name|baselen
argument_list|)
expr_stmt|;
name|vptrbase
operator|=
name|debug_find_tagged_type
argument_list|(
name|dhandle
argument_list|,
name|basecopy
argument_list|,
name|DEBUG_KIND_ILLEGAL
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|basecopy
argument_list|)
expr_stmt|;
if|if
condition|(
name|vptrbase
operator|==
name|DEBUG_TYPE_NULL
condition|)
block|{
name|ieee_error
argument_list|(
name|info
argument_list|,
name|start
argument_list|,
name|_
argument_list|(
literal|"undefined C++ vtable"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
block|}
block|}
break|break;
block|}
block|}
comment|/* Now that we have seen all the method variants, we can call      debug_make_method for each one.  */
if|if
condition|(
name|methods_count
operator|==
literal|0
condition|)
name|dmethods
operator|=
name|NULL
expr_stmt|;
else|else
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|dmethods
operator|=
operator|(
operator|(
name|debug_method
operator|*
operator|)
name|xmalloc
argument_list|(
operator|(
name|methods_count
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
expr|*
name|dmethods
argument_list|)
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|methods_count
condition|;
name|i
operator|++
control|)
block|{
name|char
modifier|*
name|namcopy
decl_stmt|;
name|namcopy
operator|=
name|savestring
argument_list|(
name|methods
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|methods
index|[
name|i
index|]
operator|.
name|namlen
argument_list|)
expr_stmt|;
name|dmethods
index|[
name|i
index|]
operator|=
name|debug_make_method
argument_list|(
name|dhandle
argument_list|,
name|namcopy
argument_list|,
name|methods
index|[
name|i
index|]
operator|.
name|variants
argument_list|)
expr_stmt|;
if|if
condition|(
name|dmethods
index|[
name|i
index|]
operator|==
name|DEBUG_METHOD_NULL
condition|)
return|return
name|false
return|;
block|}
name|dmethods
index|[
name|i
index|]
operator|=
name|DEBUG_METHOD_NULL
expr_stmt|;
name|free
argument_list|(
name|methods
argument_list|)
expr_stmt|;
block|}
comment|/* The struct type was created as an indirect type pointing at      it->slot.  We update it->slot to automatically update all      references to this struct.  */
name|it
operator|->
name|slot
operator|=
name|debug_make_object_type
argument_list|(
name|dhandle
argument_list|,
name|class
operator|!=
literal|'u'
argument_list|,
name|debug_get_type_size
argument_list|(
name|dhandle
argument_list|,
name|it
operator|->
name|slot
argument_list|)
argument_list|,
name|fields
argument_list|,
name|baseclasses
argument_list|,
name|dmethods
argument_list|,
name|vptrbase
argument_list|,
name|ownvptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|it
operator|->
name|slot
operator|==
name|DEBUG_TYPE_NULL
condition|)
return|return
name|false
return|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Read C++ default argument value and reference type information.  */
end_comment

begin_function
specifier|static
name|boolean
name|ieee_read_cxx_defaults
parameter_list|(
name|info
parameter_list|,
name|pp
parameter_list|,
name|count
parameter_list|)
name|struct
name|ieee_info
modifier|*
name|info
decl_stmt|;
specifier|const
name|bfd_byte
modifier|*
modifier|*
name|pp
decl_stmt|;
name|unsigned
name|long
name|count
decl_stmt|;
block|{
specifier|const
name|bfd_byte
modifier|*
name|start
decl_stmt|;
specifier|const
name|char
modifier|*
name|fnname
decl_stmt|;
name|unsigned
name|long
name|fnlen
decl_stmt|;
name|bfd_vma
name|defcount
decl_stmt|;
name|start
operator|=
operator|*
name|pp
expr_stmt|;
comment|/* Giving the function name before the argument count is an addendum      to the spec.  The function name is demangled, though, so this      record must always refer to the current function.  */
if|if
condition|(
name|info
operator|->
name|blockstack
operator|.
name|bsp
operator|<=
name|info
operator|->
name|blockstack
operator|.
name|stack
operator|||
name|info
operator|->
name|blockstack
operator|.
name|bsp
index|[
operator|-
literal|1
index|]
operator|.
name|fnindx
operator|==
operator|(
name|unsigned
name|int
operator|)
operator|-
literal|1
condition|)
block|{
name|ieee_error
argument_list|(
name|info
argument_list|,
name|start
argument_list|,
name|_
argument_list|(
literal|"C++ default values not in a function"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
operator|!
name|ieee_require_atn65
argument_list|(
name|info
argument_list|,
name|pp
argument_list|,
operator|&
name|fnname
argument_list|,
operator|&
name|fnlen
argument_list|)
operator|||
operator|!
name|ieee_require_asn
argument_list|(
name|info
argument_list|,
name|pp
argument_list|,
operator|&
name|defcount
argument_list|)
condition|)
return|return
name|false
return|;
name|count
operator|-=
literal|2
expr_stmt|;
while|while
condition|(
name|defcount
operator|--
operator|>
literal|0
condition|)
block|{
name|bfd_vma
name|type
decl_stmt|,
name|val
decl_stmt|;
specifier|const
name|char
modifier|*
name|strval
decl_stmt|;
name|unsigned
name|long
name|strvallen
decl_stmt|;
if|if
condition|(
operator|!
name|ieee_require_asn
argument_list|(
name|info
argument_list|,
name|pp
argument_list|,
operator|&
name|type
argument_list|)
condition|)
return|return
name|false
return|;
operator|--
name|count
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
literal|0
case|:
case|case
literal|4
case|:
break|break;
case|case
literal|1
case|:
case|case
literal|2
case|:
if|if
condition|(
operator|!
name|ieee_require_asn
argument_list|(
name|info
argument_list|,
name|pp
argument_list|,
operator|&
name|val
argument_list|)
condition|)
return|return
name|false
return|;
operator|--
name|count
expr_stmt|;
break|break;
case|case
literal|3
case|:
case|case
literal|7
case|:
if|if
condition|(
operator|!
name|ieee_require_atn65
argument_list|(
name|info
argument_list|,
name|pp
argument_list|,
operator|&
name|strval
argument_list|,
operator|&
name|strvallen
argument_list|)
condition|)
return|return
name|false
return|;
operator|--
name|count
expr_stmt|;
break|break;
default|default:
name|ieee_error
argument_list|(
name|info
argument_list|,
name|start
argument_list|,
name|_
argument_list|(
literal|"unrecognized C++ default type"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
comment|/* We have no way to record the default argument values, so we          just ignore them.  FIXME.  */
block|}
comment|/* Any remaining arguments are indices of parameters that are really      reference type.  */
if|if
condition|(
name|count
operator|>
literal|0
condition|)
block|{
name|PTR
name|dhandle
decl_stmt|;
name|debug_type
modifier|*
name|arg_slots
decl_stmt|;
name|dhandle
operator|=
name|info
operator|->
name|dhandle
expr_stmt|;
name|arg_slots
operator|=
name|info
operator|->
name|types
operator|.
name|types
index|[
name|info
operator|->
name|blockstack
operator|.
name|bsp
index|[
operator|-
literal|1
index|]
operator|.
name|fnindx
index|]
operator|.
name|arg_slots
expr_stmt|;
while|while
condition|(
name|count
operator|--
operator|>
literal|0
condition|)
block|{
name|bfd_vma
name|indx
decl_stmt|;
name|debug_type
name|target
decl_stmt|;
if|if
condition|(
operator|!
name|ieee_require_asn
argument_list|(
name|info
argument_list|,
name|pp
argument_list|,
operator|&
name|indx
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* The index is 1 based.  */
operator|--
name|indx
expr_stmt|;
if|if
condition|(
name|arg_slots
operator|==
name|NULL
operator|||
name|arg_slots
index|[
name|indx
index|]
operator|==
name|DEBUG_TYPE_NULL
operator|||
operator|(
name|debug_get_type_kind
argument_list|(
name|dhandle
argument_list|,
name|arg_slots
index|[
name|indx
index|]
argument_list|)
operator|!=
name|DEBUG_KIND_POINTER
operator|)
condition|)
block|{
name|ieee_error
argument_list|(
name|info
argument_list|,
name|start
argument_list|,
name|_
argument_list|(
literal|"reference parameter is not a pointer"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|target
operator|=
name|debug_get_target_type
argument_list|(
name|dhandle
argument_list|,
name|arg_slots
index|[
name|indx
index|]
argument_list|)
expr_stmt|;
name|arg_slots
index|[
name|indx
index|]
operator|=
name|debug_make_reference_type
argument_list|(
name|dhandle
argument_list|,
name|target
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg_slots
index|[
name|indx
index|]
operator|==
name|DEBUG_TYPE_NULL
condition|)
return|return
name|false
return|;
block|}
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Read a C++ reference definition.  */
end_comment

begin_function
specifier|static
name|boolean
name|ieee_read_reference
parameter_list|(
name|info
parameter_list|,
name|pp
parameter_list|)
name|struct
name|ieee_info
modifier|*
name|info
decl_stmt|;
specifier|const
name|bfd_byte
modifier|*
modifier|*
name|pp
decl_stmt|;
block|{
specifier|const
name|bfd_byte
modifier|*
name|start
decl_stmt|;
name|bfd_vma
name|flags
decl_stmt|;
specifier|const
name|char
modifier|*
name|class
decl_stmt|,
modifier|*
name|name
decl_stmt|;
name|unsigned
name|long
name|classlen
decl_stmt|,
name|namlen
decl_stmt|;
name|debug_type
modifier|*
name|pslot
decl_stmt|;
name|debug_type
name|target
decl_stmt|;
name|start
operator|=
operator|*
name|pp
expr_stmt|;
if|if
condition|(
operator|!
name|ieee_require_asn
argument_list|(
name|info
argument_list|,
name|pp
argument_list|,
operator|&
name|flags
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* Giving the class name before the member name is in an addendum to      the spec.  */
if|if
condition|(
name|flags
operator|==
literal|3
condition|)
block|{
if|if
condition|(
operator|!
name|ieee_require_atn65
argument_list|(
name|info
argument_list|,
name|pp
argument_list|,
operator|&
name|class
argument_list|,
operator|&
name|classlen
argument_list|)
condition|)
return|return
name|false
return|;
block|}
if|if
condition|(
operator|!
name|ieee_require_atn65
argument_list|(
name|info
argument_list|,
name|pp
argument_list|,
operator|&
name|name
argument_list|,
operator|&
name|namlen
argument_list|)
condition|)
return|return
name|false
return|;
name|pslot
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|flags
operator|!=
literal|3
condition|)
block|{
name|int
name|pass
decl_stmt|;
comment|/* We search from the last variable indices to the first in 	 hopes of finding local variables correctly.  We search the 	 local variables on the first pass, and the global variables 	 on the second.  FIXME: This probably won't work in all cases. 	 On the other hand, I don't know what will.  */
for|for
control|(
name|pass
operator|=
literal|0
init|;
name|pass
operator|<
literal|2
condition|;
name|pass
operator|++
control|)
block|{
name|struct
name|ieee_vars
modifier|*
name|vars
decl_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|ieee_var
modifier|*
name|pv
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|pass
operator|==
literal|0
condition|)
name|vars
operator|=
operator|&
name|info
operator|->
name|vars
expr_stmt|;
else|else
block|{
name|vars
operator|=
name|info
operator|->
name|global_vars
expr_stmt|;
if|if
condition|(
name|vars
operator|==
name|NULL
condition|)
break|break;
block|}
for|for
control|(
name|i
operator|=
operator|(
name|int
operator|)
name|vars
operator|->
name|alloc
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|boolean
name|found
decl_stmt|;
name|pv
operator|=
name|vars
operator|->
name|vars
operator|+
name|i
expr_stmt|;
if|if
condition|(
name|pv
operator|->
name|pslot
operator|==
name|NULL
operator|||
name|pv
operator|->
name|namlen
operator|!=
name|namlen
operator|||
name|strncmp
argument_list|(
name|pv
operator|->
name|name
argument_list|,
name|name
argument_list|,
name|namlen
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
name|found
operator|=
name|false
expr_stmt|;
switch|switch
condition|(
name|flags
condition|)
block|{
default|default:
name|ieee_error
argument_list|(
name|info
argument_list|,
name|start
argument_list|,
name|_
argument_list|(
literal|"unrecognized C++ reference type"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|false
return|;
case|case
literal|0
case|:
comment|/* Global variable or function.  */
if|if
condition|(
name|pv
operator|->
name|kind
operator|==
name|IEEE_GLOBAL
operator|||
name|pv
operator|->
name|kind
operator|==
name|IEEE_EXTERNAL
operator|||
name|pv
operator|->
name|kind
operator|==
name|IEEE_FUNCTION
condition|)
name|found
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|1
case|:
comment|/* Global static variable or function.  */
if|if
condition|(
name|pv
operator|->
name|kind
operator|==
name|IEEE_STATIC
operator|||
name|pv
operator|->
name|kind
operator|==
name|IEEE_FUNCTION
condition|)
name|found
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|/* Local variable.  */
if|if
condition|(
name|pv
operator|->
name|kind
operator|==
name|IEEE_LOCAL
condition|)
name|found
operator|=
name|true
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|found
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|>=
literal|0
condition|)
block|{
name|pslot
operator|=
name|pv
operator|->
name|pslot
expr_stmt|;
break|break;
block|}
block|}
block|}
else|else
block|{
name|struct
name|ieee_tag
modifier|*
name|it
decl_stmt|;
for|for
control|(
name|it
operator|=
name|info
operator|->
name|tags
init|;
name|it
operator|!=
name|NULL
condition|;
name|it
operator|=
name|it
operator|->
name|next
control|)
block|{
if|if
condition|(
name|it
operator|->
name|name
index|[
literal|0
index|]
operator|==
name|class
index|[
literal|0
index|]
operator|&&
name|strncmp
argument_list|(
name|it
operator|->
name|name
argument_list|,
name|class
argument_list|,
name|classlen
argument_list|)
operator|==
literal|0
operator|&&
name|strlen
argument_list|(
name|it
operator|->
name|name
argument_list|)
operator|==
name|classlen
condition|)
block|{
if|if
condition|(
name|it
operator|->
name|fslots
operator|!=
name|NULL
condition|)
block|{
specifier|const
name|debug_field
modifier|*
name|pf
decl_stmt|;
name|unsigned
name|int
name|findx
decl_stmt|;
name|pf
operator|=
name|debug_get_fields
argument_list|(
name|info
operator|->
name|dhandle
argument_list|,
name|it
operator|->
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|pf
operator|==
name|NULL
condition|)
block|{
name|ieee_error
argument_list|(
name|info
argument_list|,
name|start
argument_list|,
literal|"C++ reference in class with no fields"
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
for|for
control|(
name|findx
operator|=
literal|0
init|;
operator|*
name|pf
operator|!=
name|DEBUG_FIELD_NULL
condition|;
name|pf
operator|++
operator|,
name|findx
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|fname
decl_stmt|;
name|fname
operator|=
name|debug_get_field_name
argument_list|(
name|info
operator|->
name|dhandle
argument_list|,
operator|*
name|pf
argument_list|)
expr_stmt|;
if|if
condition|(
name|fname
operator|==
name|NULL
condition|)
return|return
name|false
return|;
if|if
condition|(
name|strncmp
argument_list|(
name|fname
argument_list|,
name|name
argument_list|,
name|namlen
argument_list|)
operator|==
literal|0
operator|&&
name|strlen
argument_list|(
name|fname
argument_list|)
operator|==
name|namlen
condition|)
block|{
name|pslot
operator|=
name|it
operator|->
name|fslots
operator|+
name|findx
expr_stmt|;
break|break;
block|}
block|}
block|}
break|break;
block|}
block|}
block|}
if|if
condition|(
name|pslot
operator|==
name|NULL
condition|)
block|{
name|ieee_error
argument_list|(
name|info
argument_list|,
name|start
argument_list|,
name|_
argument_list|(
literal|"C++ reference not found"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
comment|/* We allocated the type of the object as an indirect type pointing      to *pslot, which we can now update to be a reference type.  */
if|if
condition|(
name|debug_get_type_kind
argument_list|(
name|info
operator|->
name|dhandle
argument_list|,
operator|*
name|pslot
argument_list|)
operator|!=
name|DEBUG_KIND_POINTER
condition|)
block|{
name|ieee_error
argument_list|(
name|info
argument_list|,
name|start
argument_list|,
name|_
argument_list|(
literal|"C++ reference is not pointer"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|target
operator|=
name|debug_get_target_type
argument_list|(
name|info
operator|->
name|dhandle
argument_list|,
operator|*
name|pslot
argument_list|)
expr_stmt|;
operator|*
name|pslot
operator|=
name|debug_make_reference_type
argument_list|(
name|info
operator|->
name|dhandle
argument_list|,
name|target
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|pslot
operator|==
name|DEBUG_TYPE_NULL
condition|)
return|return
name|false
return|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Require an ASN record.  */
end_comment

begin_function
specifier|static
name|boolean
name|ieee_require_asn
parameter_list|(
name|info
parameter_list|,
name|pp
parameter_list|,
name|pv
parameter_list|)
name|struct
name|ieee_info
modifier|*
name|info
decl_stmt|;
specifier|const
name|bfd_byte
modifier|*
modifier|*
name|pp
decl_stmt|;
name|bfd_vma
modifier|*
name|pv
decl_stmt|;
block|{
specifier|const
name|bfd_byte
modifier|*
name|start
decl_stmt|;
name|ieee_record_enum_type
name|c
decl_stmt|;
name|bfd_vma
name|varindx
decl_stmt|;
name|start
operator|=
operator|*
name|pp
expr_stmt|;
name|c
operator|=
operator|(
name|ieee_record_enum_type
operator|)
operator|*
operator|*
name|pp
expr_stmt|;
if|if
condition|(
name|c
operator|!=
name|ieee_e2_first_byte_enum
condition|)
block|{
name|ieee_error
argument_list|(
name|info
argument_list|,
name|start
argument_list|,
name|_
argument_list|(
literal|"missing required ASN"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
operator|++
operator|*
name|pp
expr_stmt|;
name|c
operator|=
call|(
name|ieee_record_enum_type
call|)
argument_list|(
operator|(
operator|(
name|unsigned
name|int
operator|)
name|c
operator|<<
literal|8
operator|)
operator||
operator|*
operator|*
name|pp
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|!=
name|ieee_asn_record_enum
condition|)
block|{
name|ieee_error
argument_list|(
name|info
argument_list|,
name|start
argument_list|,
name|_
argument_list|(
literal|"missing required ASN"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
operator|++
operator|*
name|pp
expr_stmt|;
comment|/* Just ignore the variable index.  */
if|if
condition|(
operator|!
name|ieee_read_number
argument_list|(
name|info
argument_list|,
name|pp
argument_list|,
operator|&
name|varindx
argument_list|)
condition|)
return|return
name|false
return|;
return|return
name|ieee_read_expression
argument_list|(
name|info
argument_list|,
name|pp
argument_list|,
name|pv
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Require an ATN65 record.  */
end_comment

begin_function
specifier|static
name|boolean
name|ieee_require_atn65
parameter_list|(
name|info
parameter_list|,
name|pp
parameter_list|,
name|pname
parameter_list|,
name|pnamlen
parameter_list|)
name|struct
name|ieee_info
modifier|*
name|info
decl_stmt|;
specifier|const
name|bfd_byte
modifier|*
modifier|*
name|pp
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|pname
decl_stmt|;
name|unsigned
name|long
modifier|*
name|pnamlen
decl_stmt|;
block|{
specifier|const
name|bfd_byte
modifier|*
name|start
decl_stmt|;
name|ieee_record_enum_type
name|c
decl_stmt|;
name|bfd_vma
name|name_indx
decl_stmt|,
name|type_indx
decl_stmt|,
name|atn_code
decl_stmt|;
name|start
operator|=
operator|*
name|pp
expr_stmt|;
name|c
operator|=
operator|(
name|ieee_record_enum_type
operator|)
operator|*
operator|*
name|pp
expr_stmt|;
if|if
condition|(
name|c
operator|!=
name|ieee_at_record_enum
condition|)
block|{
name|ieee_error
argument_list|(
name|info
argument_list|,
name|start
argument_list|,
name|_
argument_list|(
literal|"missing required ATN65"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
operator|++
operator|*
name|pp
expr_stmt|;
name|c
operator|=
call|(
name|ieee_record_enum_type
call|)
argument_list|(
operator|(
operator|(
name|unsigned
name|int
operator|)
name|c
operator|<<
literal|8
operator|)
operator||
operator|*
operator|*
name|pp
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|!=
name|ieee_atn_record_enum
condition|)
block|{
name|ieee_error
argument_list|(
name|info
argument_list|,
name|start
argument_list|,
name|_
argument_list|(
literal|"missing required ATN65"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
operator|++
operator|*
name|pp
expr_stmt|;
if|if
condition|(
operator|!
name|ieee_read_number
argument_list|(
name|info
argument_list|,
name|pp
argument_list|,
operator|&
name|name_indx
argument_list|)
operator|||
operator|!
name|ieee_read_number
argument_list|(
name|info
argument_list|,
name|pp
argument_list|,
operator|&
name|type_indx
argument_list|)
operator|||
operator|!
name|ieee_read_number
argument_list|(
name|info
argument_list|,
name|pp
argument_list|,
operator|&
name|atn_code
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* Just ignore name_indx.  */
if|if
condition|(
name|type_indx
operator|!=
literal|0
operator|||
name|atn_code
operator|!=
literal|65
condition|)
block|{
name|ieee_error
argument_list|(
name|info
argument_list|,
name|start
argument_list|,
name|_
argument_list|(
literal|"bad ATN65 record"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
return|return
name|ieee_read_id
argument_list|(
name|info
argument_list|,
name|pp
argument_list|,
name|pname
argument_list|,
name|pnamlen
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Convert a register number in IEEE debugging information into a    generic register number.  */
end_comment

begin_function
specifier|static
name|int
name|ieee_regno_to_genreg
parameter_list|(
name|abfd
parameter_list|,
name|r
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|int
name|r
decl_stmt|;
block|{
switch|switch
condition|(
name|bfd_get_arch
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
case|case
name|bfd_arch_m68k
case|:
comment|/* For some reasons stabs adds 2 to the floating point register          numbers.  */
if|if
condition|(
name|r
operator|>=
literal|16
condition|)
name|r
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
name|bfd_arch_i960
case|:
comment|/* Stabs uses 0 to 15 for r0 to r15, 16 to 31 for g0 to g15, and          32 to 35 for fp0 to fp3.  */
operator|--
name|r
expr_stmt|;
break|break;
default|default:
break|break;
block|}
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/* Convert a generic register number to an IEEE specific one.  */
end_comment

begin_function
specifier|static
name|int
name|ieee_genreg_to_regno
parameter_list|(
name|abfd
parameter_list|,
name|r
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|int
name|r
decl_stmt|;
block|{
switch|switch
condition|(
name|bfd_get_arch
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
case|case
name|bfd_arch_m68k
case|:
comment|/* For some reason stabs add 2 to the floating point register          numbers.  */
if|if
condition|(
name|r
operator|>=
literal|18
condition|)
name|r
operator|-=
literal|2
expr_stmt|;
break|break;
case|case
name|bfd_arch_i960
case|:
comment|/* Stabs uses 0 to 15 for r0 to r15, 16 to 31 for g0 to g15, and          32 to 35 for fp0 to fp3.  */
operator|++
name|r
expr_stmt|;
break|break;
default|default:
break|break;
block|}
return|return
name|r
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* These routines build IEEE debugging information out of the generic    debugging information.  */
end_comment

begin_comment
comment|/* We build the IEEE debugging information byte by byte.  Rather than    waste time copying data around, we use a linked list of buffers to    hold the data.  */
end_comment

begin_define
define|#
directive|define
name|IEEE_BUFSIZE
value|(490)
end_define

begin_struct
struct|struct
name|ieee_buf
block|{
comment|/* Next buffer.  */
name|struct
name|ieee_buf
modifier|*
name|next
decl_stmt|;
comment|/* Number of data bytes in this buffer.  */
name|unsigned
name|int
name|c
decl_stmt|;
comment|/* Bytes.  */
name|bfd_byte
name|buf
index|[
name|IEEE_BUFSIZE
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* A list of buffers.  */
end_comment

begin_struct
struct|struct
name|ieee_buflist
block|{
comment|/* Head of list.  */
name|struct
name|ieee_buf
modifier|*
name|head
decl_stmt|;
comment|/* Tail--last buffer on list.  */
name|struct
name|ieee_buf
modifier|*
name|tail
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* In order to generate the BB11 blocks required by the HP emulator,    we keep track of ranges of addresses which correspond to a given    compilation unit.  */
end_comment

begin_struct
struct|struct
name|ieee_range
block|{
comment|/* Next range.  */
name|struct
name|ieee_range
modifier|*
name|next
decl_stmt|;
comment|/* Low address.  */
name|bfd_vma
name|low
decl_stmt|;
comment|/* High address.  */
name|bfd_vma
name|high
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* This structure holds information for a class on the type stack.  */
end_comment

begin_struct
struct|struct
name|ieee_type_class
block|{
comment|/* The name index in the debugging information.  */
name|unsigned
name|int
name|indx
decl_stmt|;
comment|/* The pmisc records for the class.  */
name|struct
name|ieee_buflist
name|pmiscbuf
decl_stmt|;
comment|/* The number of pmisc records.  */
name|unsigned
name|int
name|pmisccount
decl_stmt|;
comment|/* The name of the class holding the virtual table, if not this      class.  */
specifier|const
name|char
modifier|*
name|vclass
decl_stmt|;
comment|/* Whether this class holds its own virtual table.  */
name|boolean
name|ownvptr
decl_stmt|;
comment|/* The largest virtual table offset seen so far.  */
name|bfd_vma
name|voffset
decl_stmt|;
comment|/* The current method.  */
specifier|const
name|char
modifier|*
name|method
decl_stmt|;
comment|/* Additional pmisc records used to record fields of reference type.  */
name|struct
name|ieee_buflist
name|refs
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* This is how we store types for the writing routines.  Most types    are simply represented by a type index.  */
end_comment

begin_struct
struct|struct
name|ieee_write_type
block|{
comment|/* Type index.  */
name|unsigned
name|int
name|indx
decl_stmt|;
comment|/* The size of the type, if known.  */
name|unsigned
name|int
name|size
decl_stmt|;
comment|/* The name of the type, if any.  */
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
comment|/* If this is a function or method type, we build the type here, and      only add it to the output buffers if we need it.  */
name|struct
name|ieee_buflist
name|fndef
decl_stmt|;
comment|/* If this is a struct, this is where the struct definition is      built.  */
name|struct
name|ieee_buflist
name|strdef
decl_stmt|;
comment|/* If this is a class, this is where the class information is built.  */
name|struct
name|ieee_type_class
modifier|*
name|classdef
decl_stmt|;
comment|/* Whether the type is unsigned.  */
name|unsigned
name|int
name|unsignedp
range|:
literal|1
decl_stmt|;
comment|/* Whether this is a reference type.  */
name|unsigned
name|int
name|referencep
range|:
literal|1
decl_stmt|;
comment|/* Whether this is in the local type block.  */
name|unsigned
name|int
name|localp
range|:
literal|1
decl_stmt|;
comment|/* Whether this is a duplicate struct definition which we are      ignoring.  */
name|unsigned
name|int
name|ignorep
range|:
literal|1
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* This is the type stack used by the debug writing routines.  FIXME:    We could generate more efficient output if we remembered when we    have output a particular type before.  */
end_comment

begin_struct
struct|struct
name|ieee_type_stack
block|{
comment|/* Next entry on stack.  */
name|struct
name|ieee_type_stack
modifier|*
name|next
decl_stmt|;
comment|/* Type information.  */
name|struct
name|ieee_write_type
name|type
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* This is a list of associations between a name and some types.    These are used for typedefs and tags.  */
end_comment

begin_struct
struct|struct
name|ieee_name_type
block|{
comment|/* Next type for this name.  */
name|struct
name|ieee_name_type
modifier|*
name|next
decl_stmt|;
comment|/* ID number.  For a typedef, this is the index of the type to which      this name is typedefed.  */
name|unsigned
name|int
name|id
decl_stmt|;
comment|/* Type.  */
name|struct
name|ieee_write_type
name|type
decl_stmt|;
comment|/* If this is a tag which has not yet been defined, this is the      kind.  If the tag has been defined, this is DEBUG_KIND_ILLEGAL.  */
name|enum
name|debug_type_kind
name|kind
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* We use a hash table to associate names and types.  */
end_comment

begin_struct
struct|struct
name|ieee_name_type_hash_table
block|{
name|struct
name|bfd_hash_table
name|root
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|ieee_name_type_hash_entry
block|{
name|struct
name|bfd_hash_entry
name|root
decl_stmt|;
comment|/* Information for this name.  */
name|struct
name|ieee_name_type
modifier|*
name|types
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* This is a list of enums.  */
end_comment

begin_struct
struct|struct
name|ieee_defined_enum
block|{
comment|/* Next enum.  */
name|struct
name|ieee_defined_enum
modifier|*
name|next
decl_stmt|;
comment|/* Type index.  */
name|unsigned
name|int
name|indx
decl_stmt|;
comment|/* Whether this enum has been defined.  */
name|boolean
name|defined
decl_stmt|;
comment|/* Tag.  */
specifier|const
name|char
modifier|*
name|tag
decl_stmt|;
comment|/* Names.  */
specifier|const
name|char
modifier|*
modifier|*
name|names
decl_stmt|;
comment|/* Values.  */
name|bfd_signed_vma
modifier|*
name|vals
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* We keep a list of modified versions of types, so that we don't    output them more than once.  */
end_comment

begin_struct
struct|struct
name|ieee_modified_type
block|{
comment|/* Pointer to this type.  */
name|unsigned
name|int
name|pointer
decl_stmt|;
comment|/* Function with unknown arguments returning this type.  */
name|unsigned
name|int
name|function
decl_stmt|;
comment|/* Const version of this type.  */
name|unsigned
name|int
name|const_qualified
decl_stmt|;
comment|/* Volatile version of this type.  */
name|unsigned
name|int
name|volatile_qualified
decl_stmt|;
comment|/* List of arrays of this type of various bounds.  */
name|struct
name|ieee_modified_array_type
modifier|*
name|arrays
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* A list of arrays bounds.  */
end_comment

begin_struct
struct|struct
name|ieee_modified_array_type
block|{
comment|/* Next array bounds.  */
name|struct
name|ieee_modified_array_type
modifier|*
name|next
decl_stmt|;
comment|/* Type index with these bounds.  */
name|unsigned
name|int
name|indx
decl_stmt|;
comment|/* Low bound.  */
name|bfd_signed_vma
name|low
decl_stmt|;
comment|/* High bound.  */
name|bfd_signed_vma
name|high
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* This is a list of pending function parameter information.  We don't    output them until we see the first block.  */
end_comment

begin_struct
struct|struct
name|ieee_pending_parm
block|{
comment|/* Next pending parameter.  */
name|struct
name|ieee_pending_parm
modifier|*
name|next
decl_stmt|;
comment|/* Name.  */
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
comment|/* Type index.  */
name|unsigned
name|int
name|type
decl_stmt|;
comment|/* Whether the type is a reference.  */
name|boolean
name|referencep
decl_stmt|;
comment|/* Kind.  */
name|enum
name|debug_parm_kind
name|kind
decl_stmt|;
comment|/* Value.  */
name|bfd_vma
name|val
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* This is the handle passed down by debug_write.  */
end_comment

begin_struct
struct|struct
name|ieee_handle
block|{
comment|/* BFD we are writing to.  */
name|bfd
modifier|*
name|abfd
decl_stmt|;
comment|/* Whether we got an error in a subroutine called via traverse or      map_over_sections.  */
name|boolean
name|error
decl_stmt|;
comment|/* Current data buffer list.  */
name|struct
name|ieee_buflist
modifier|*
name|current
decl_stmt|;
comment|/* Current data buffer.  */
name|struct
name|ieee_buf
modifier|*
name|curbuf
decl_stmt|;
comment|/* Filename of current compilation unit.  */
specifier|const
name|char
modifier|*
name|filename
decl_stmt|;
comment|/* Module name of current compilation unit.  */
specifier|const
name|char
modifier|*
name|modname
decl_stmt|;
comment|/* List of buffer for global types.  */
name|struct
name|ieee_buflist
name|global_types
decl_stmt|;
comment|/* List of finished data buffers.  */
name|struct
name|ieee_buflist
name|data
decl_stmt|;
comment|/* List of buffers for typedefs in the current compilation unit.  */
name|struct
name|ieee_buflist
name|types
decl_stmt|;
comment|/* List of buffers for variables and functions in the current      compilation unit.  */
name|struct
name|ieee_buflist
name|vars
decl_stmt|;
comment|/* List of buffers for C++ class definitions in the current      compilation unit.  */
name|struct
name|ieee_buflist
name|cxx
decl_stmt|;
comment|/* List of buffers for line numbers in the current compilation unit.  */
name|struct
name|ieee_buflist
name|linenos
decl_stmt|;
comment|/* Ranges for the current compilation unit.  */
name|struct
name|ieee_range
modifier|*
name|ranges
decl_stmt|;
comment|/* Ranges for all debugging information.  */
name|struct
name|ieee_range
modifier|*
name|global_ranges
decl_stmt|;
comment|/* Nested pending ranges.  */
name|struct
name|ieee_range
modifier|*
name|pending_ranges
decl_stmt|;
comment|/* Type stack.  */
name|struct
name|ieee_type_stack
modifier|*
name|type_stack
decl_stmt|;
comment|/* Next unallocated type index.  */
name|unsigned
name|int
name|type_indx
decl_stmt|;
comment|/* Next unallocated name index.  */
name|unsigned
name|int
name|name_indx
decl_stmt|;
comment|/* Typedefs.  */
name|struct
name|ieee_name_type_hash_table
name|typedefs
decl_stmt|;
comment|/* Tags.  */
name|struct
name|ieee_name_type_hash_table
name|tags
decl_stmt|;
comment|/* Enums.  */
name|struct
name|ieee_defined_enum
modifier|*
name|enums
decl_stmt|;
comment|/* Modified versions of types.  */
name|struct
name|ieee_modified_type
modifier|*
name|modified
decl_stmt|;
comment|/* Number of entries allocated in modified.  */
name|unsigned
name|int
name|modified_alloc
decl_stmt|;
comment|/* 4 byte complex type.  */
name|unsigned
name|int
name|complex_float_index
decl_stmt|;
comment|/* 8 byte complex type.  */
name|unsigned
name|int
name|complex_double_index
decl_stmt|;
comment|/* The depth of block nesting.  This is 0 outside a function, and 1      just after start_function is called.  */
name|unsigned
name|int
name|block_depth
decl_stmt|;
comment|/* The name of the current function.  */
specifier|const
name|char
modifier|*
name|fnname
decl_stmt|;
comment|/* List of buffers for the type of the function we are currently      writing out.  */
name|struct
name|ieee_buflist
name|fntype
decl_stmt|;
comment|/* List of buffers for the parameters of the function we are      currently writing out.  */
name|struct
name|ieee_buflist
name|fnargs
decl_stmt|;
comment|/* Number of arguments written to fnargs.  */
name|unsigned
name|int
name|fnargcount
decl_stmt|;
comment|/* Pending function parameters.  */
name|struct
name|ieee_pending_parm
modifier|*
name|pending_parms
decl_stmt|;
comment|/* Current line number filename.  */
specifier|const
name|char
modifier|*
name|lineno_filename
decl_stmt|;
comment|/* Line number name index.  */
name|unsigned
name|int
name|lineno_name_indx
decl_stmt|;
comment|/* Filename of pending line number.  */
specifier|const
name|char
modifier|*
name|pending_lineno_filename
decl_stmt|;
comment|/* Pending line number.  */
name|unsigned
name|long
name|pending_lineno
decl_stmt|;
comment|/* Address of pending line number.  */
name|bfd_vma
name|pending_lineno_addr
decl_stmt|;
comment|/* Highest address seen at end of procedure.  */
name|bfd_vma
name|highaddr
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|boolean
name|ieee_init_buffer
name|PARAMS
argument_list|(
operator|(
expr|struct
name|ieee_handle
operator|*
operator|,
expr|struct
name|ieee_buflist
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|ieee_change_buffer
name|PARAMS
argument_list|(
operator|(
expr|struct
name|ieee_handle
operator|*
operator|,
expr|struct
name|ieee_buflist
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|ieee_append_buffer
name|PARAMS
argument_list|(
operator|(
expr|struct
name|ieee_handle
operator|*
operator|,
expr|struct
name|ieee_buflist
operator|*
operator|,
expr|struct
name|ieee_buflist
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|ieee_real_write_byte
name|PARAMS
argument_list|(
operator|(
expr|struct
name|ieee_handle
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|ieee_write_2bytes
name|PARAMS
argument_list|(
operator|(
expr|struct
name|ieee_handle
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|ieee_write_number
name|PARAMS
argument_list|(
operator|(
expr|struct
name|ieee_handle
operator|*
operator|,
name|bfd_vma
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|ieee_write_id
name|PARAMS
argument_list|(
operator|(
expr|struct
name|ieee_handle
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|ieee_write_asn
name|PARAMS
argument_list|(
operator|(
expr|struct
name|ieee_handle
operator|*
operator|,
name|unsigned
name|int
operator|,
name|bfd_vma
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|ieee_write_atn65
name|PARAMS
argument_list|(
operator|(
expr|struct
name|ieee_handle
operator|*
operator|,
name|unsigned
name|int
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|ieee_push_type
name|PARAMS
argument_list|(
operator|(
expr|struct
name|ieee_handle
operator|*
operator|,
name|unsigned
name|int
operator|,
name|unsigned
name|int
operator|,
name|boolean
operator|,
name|boolean
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|ieee_pop_type
name|PARAMS
argument_list|(
operator|(
expr|struct
name|ieee_handle
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ieee_pop_unused_type
name|PARAMS
argument_list|(
operator|(
expr|struct
name|ieee_handle
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|ieee_pop_type_used
name|PARAMS
argument_list|(
operator|(
expr|struct
name|ieee_handle
operator|*
operator|,
name|boolean
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|ieee_add_range
name|PARAMS
argument_list|(
operator|(
expr|struct
name|ieee_handle
operator|*
operator|,
name|boolean
operator|,
name|bfd_vma
operator|,
name|bfd_vma
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|ieee_start_range
name|PARAMS
argument_list|(
operator|(
expr|struct
name|ieee_handle
operator|*
operator|,
name|bfd_vma
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|ieee_end_range
name|PARAMS
argument_list|(
operator|(
expr|struct
name|ieee_handle
operator|*
operator|,
name|bfd_vma
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|ieee_define_type
name|PARAMS
argument_list|(
operator|(
expr|struct
name|ieee_handle
operator|*
operator|,
name|unsigned
name|int
operator|,
name|boolean
operator|,
name|boolean
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|ieee_define_named_type
name|PARAMS
argument_list|(
operator|(
expr|struct
name|ieee_handle
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
name|unsigned
name|int
operator|,
name|unsigned
name|int
operator|,
name|boolean
operator|,
name|boolean
operator|,
expr|struct
name|ieee_buflist
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|ieee_modified_type
modifier|*
name|ieee_get_modified_info
name|PARAMS
argument_list|(
operator|(
expr|struct
name|ieee_handle
operator|*
operator|,
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|bfd_hash_entry
modifier|*
name|ieee_name_type_newfunc
name|PARAMS
argument_list|(
operator|(
expr|struct
name|bfd_hash_entry
operator|*
operator|,
expr|struct
name|bfd_hash_table
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|ieee_write_undefined_tag
name|PARAMS
argument_list|(
operator|(
expr|struct
name|ieee_name_type_hash_entry
operator|*
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|ieee_finish_compilation_unit
name|PARAMS
argument_list|(
operator|(
expr|struct
name|ieee_handle
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ieee_add_bb11_blocks
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|ieee_add_bb11
name|PARAMS
argument_list|(
operator|(
expr|struct
name|ieee_handle
operator|*
operator|,
name|asection
operator|*
operator|,
name|bfd_vma
operator|,
name|bfd_vma
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|ieee_output_pending_parms
name|PARAMS
argument_list|(
operator|(
expr|struct
name|ieee_handle
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|ieee_vis_to_flags
name|PARAMS
argument_list|(
operator|(
expr|enum
name|debug_visibility
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|ieee_class_method_var
name|PARAMS
argument_list|(
operator|(
expr|struct
name|ieee_handle
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
expr|enum
name|debug_visibility
operator|,
name|boolean
operator|,
name|boolean
operator|,
name|boolean
operator|,
name|bfd_vma
operator|,
name|boolean
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|ieee_start_compilation_unit
name|PARAMS
argument_list|(
operator|(
name|PTR
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|ieee_start_source
name|PARAMS
argument_list|(
operator|(
name|PTR
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|ieee_empty_type
name|PARAMS
argument_list|(
operator|(
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|ieee_void_type
name|PARAMS
argument_list|(
operator|(
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|ieee_int_type
name|PARAMS
argument_list|(
operator|(
name|PTR
operator|,
name|unsigned
name|int
operator|,
name|boolean
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|ieee_float_type
name|PARAMS
argument_list|(
operator|(
name|PTR
operator|,
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|ieee_complex_type
name|PARAMS
argument_list|(
operator|(
name|PTR
operator|,
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|ieee_bool_type
name|PARAMS
argument_list|(
operator|(
name|PTR
operator|,
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|ieee_enum_type
name|PARAMS
argument_list|(
operator|(
name|PTR
operator|,
specifier|const
name|char
operator|*
operator|,
specifier|const
name|char
operator|*
operator|*
operator|,
name|bfd_signed_vma
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|ieee_pointer_type
name|PARAMS
argument_list|(
operator|(
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|ieee_function_type
name|PARAMS
argument_list|(
operator|(
name|PTR
operator|,
name|int
operator|,
name|boolean
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|ieee_reference_type
name|PARAMS
argument_list|(
operator|(
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|ieee_range_type
name|PARAMS
argument_list|(
operator|(
name|PTR
operator|,
name|bfd_signed_vma
operator|,
name|bfd_signed_vma
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|ieee_array_type
name|PARAMS
argument_list|(
operator|(
name|PTR
operator|,
name|bfd_signed_vma
operator|,
name|bfd_signed_vma
operator|,
name|boolean
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|ieee_set_type
name|PARAMS
argument_list|(
operator|(
name|PTR
operator|,
name|boolean
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|ieee_offset_type
name|PARAMS
argument_list|(
operator|(
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|ieee_method_type
name|PARAMS
argument_list|(
operator|(
name|PTR
operator|,
name|boolean
operator|,
name|int
operator|,
name|boolean
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|ieee_const_type
name|PARAMS
argument_list|(
operator|(
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|ieee_volatile_type
name|PARAMS
argument_list|(
operator|(
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|ieee_start_struct_type
name|PARAMS
argument_list|(
operator|(
name|PTR
operator|,
specifier|const
name|char
operator|*
operator|,
name|unsigned
name|int
operator|,
name|boolean
operator|,
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|ieee_struct_field
name|PARAMS
argument_list|(
operator|(
name|PTR
operator|,
specifier|const
name|char
operator|*
operator|,
name|bfd_vma
operator|,
name|bfd_vma
operator|,
expr|enum
name|debug_visibility
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|ieee_end_struct_type
name|PARAMS
argument_list|(
operator|(
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|ieee_start_class_type
name|PARAMS
argument_list|(
operator|(
name|PTR
operator|,
specifier|const
name|char
operator|*
operator|,
name|unsigned
name|int
operator|,
name|boolean
operator|,
name|unsigned
name|int
operator|,
name|boolean
operator|,
name|boolean
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|ieee_class_static_member
name|PARAMS
argument_list|(
operator|(
name|PTR
operator|,
specifier|const
name|char
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
expr|enum
name|debug_visibility
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|ieee_class_baseclass
name|PARAMS
argument_list|(
operator|(
name|PTR
operator|,
name|bfd_vma
operator|,
name|boolean
operator|,
expr|enum
name|debug_visibility
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|ieee_class_start_method
name|PARAMS
argument_list|(
operator|(
name|PTR
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|ieee_class_method_variant
name|PARAMS
argument_list|(
operator|(
name|PTR
operator|,
specifier|const
name|char
operator|*
operator|,
expr|enum
name|debug_visibility
operator|,
name|boolean
operator|,
name|boolean
operator|,
name|bfd_vma
operator|,
name|boolean
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|ieee_class_static_method_variant
name|PARAMS
argument_list|(
operator|(
name|PTR
operator|,
specifier|const
name|char
operator|*
operator|,
expr|enum
name|debug_visibility
operator|,
name|boolean
operator|,
name|boolean
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|ieee_class_end_method
name|PARAMS
argument_list|(
operator|(
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|ieee_end_class_type
name|PARAMS
argument_list|(
operator|(
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|ieee_typedef_type
name|PARAMS
argument_list|(
operator|(
name|PTR
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|ieee_tag_type
name|PARAMS
argument_list|(
operator|(
name|PTR
operator|,
specifier|const
name|char
operator|*
operator|,
name|unsigned
name|int
operator|,
expr|enum
name|debug_type_kind
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|ieee_typdef
name|PARAMS
argument_list|(
operator|(
name|PTR
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|ieee_tag
name|PARAMS
argument_list|(
operator|(
name|PTR
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|ieee_int_constant
name|PARAMS
argument_list|(
operator|(
name|PTR
operator|,
specifier|const
name|char
operator|*
operator|,
name|bfd_vma
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|ieee_float_constant
name|PARAMS
argument_list|(
operator|(
name|PTR
operator|,
specifier|const
name|char
operator|*
operator|,
name|double
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|ieee_typed_constant
name|PARAMS
argument_list|(
operator|(
name|PTR
operator|,
specifier|const
name|char
operator|*
operator|,
name|bfd_vma
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|ieee_variable
name|PARAMS
argument_list|(
operator|(
name|PTR
operator|,
specifier|const
name|char
operator|*
operator|,
expr|enum
name|debug_var_kind
operator|,
name|bfd_vma
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|ieee_start_function
name|PARAMS
argument_list|(
operator|(
name|PTR
operator|,
specifier|const
name|char
operator|*
operator|,
name|boolean
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|ieee_function_parameter
name|PARAMS
argument_list|(
operator|(
name|PTR
operator|,
specifier|const
name|char
operator|*
operator|,
expr|enum
name|debug_parm_kind
operator|,
name|bfd_vma
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|ieee_start_block
name|PARAMS
argument_list|(
operator|(
name|PTR
operator|,
name|bfd_vma
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|ieee_end_block
name|PARAMS
argument_list|(
operator|(
name|PTR
operator|,
name|bfd_vma
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|ieee_end_function
name|PARAMS
argument_list|(
operator|(
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|ieee_lineno
name|PARAMS
argument_list|(
operator|(
name|PTR
operator|,
specifier|const
name|char
operator|*
operator|,
name|unsigned
name|long
operator|,
name|bfd_vma
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|debug_write_fns
name|ieee_fns
init|=
block|{
name|ieee_start_compilation_unit
block|,
name|ieee_start_source
block|,
name|ieee_empty_type
block|,
name|ieee_void_type
block|,
name|ieee_int_type
block|,
name|ieee_float_type
block|,
name|ieee_complex_type
block|,
name|ieee_bool_type
block|,
name|ieee_enum_type
block|,
name|ieee_pointer_type
block|,
name|ieee_function_type
block|,
name|ieee_reference_type
block|,
name|ieee_range_type
block|,
name|ieee_array_type
block|,
name|ieee_set_type
block|,
name|ieee_offset_type
block|,
name|ieee_method_type
block|,
name|ieee_const_type
block|,
name|ieee_volatile_type
block|,
name|ieee_start_struct_type
block|,
name|ieee_struct_field
block|,
name|ieee_end_struct_type
block|,
name|ieee_start_class_type
block|,
name|ieee_class_static_member
block|,
name|ieee_class_baseclass
block|,
name|ieee_class_start_method
block|,
name|ieee_class_method_variant
block|,
name|ieee_class_static_method_variant
block|,
name|ieee_class_end_method
block|,
name|ieee_end_class_type
block|,
name|ieee_typedef_type
block|,
name|ieee_tag_type
block|,
name|ieee_typdef
block|,
name|ieee_tag
block|,
name|ieee_int_constant
block|,
name|ieee_float_constant
block|,
name|ieee_typed_constant
block|,
name|ieee_variable
block|,
name|ieee_start_function
block|,
name|ieee_function_parameter
block|,
name|ieee_start_block
block|,
name|ieee_end_block
block|,
name|ieee_end_function
block|,
name|ieee_lineno
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Initialize a buffer to be empty.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|boolean
name|ieee_init_buffer
parameter_list|(
name|info
parameter_list|,
name|buflist
parameter_list|)
name|struct
name|ieee_handle
modifier|*
name|info
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|struct
name|ieee_buflist
modifier|*
name|buflist
decl_stmt|;
block|{
name|buflist
operator|->
name|head
operator|=
name|NULL
expr_stmt|;
name|buflist
operator|->
name|tail
operator|=
name|NULL
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* See whether a buffer list has any data.  */
end_comment

begin_define
define|#
directive|define
name|ieee_buffer_emptyp
parameter_list|(
name|buflist
parameter_list|)
value|((buflist)->head == NULL)
end_define

begin_comment
comment|/* Change the current buffer to a specified buffer chain.  */
end_comment

begin_function
specifier|static
name|boolean
name|ieee_change_buffer
parameter_list|(
name|info
parameter_list|,
name|buflist
parameter_list|)
name|struct
name|ieee_handle
modifier|*
name|info
decl_stmt|;
name|struct
name|ieee_buflist
modifier|*
name|buflist
decl_stmt|;
block|{
if|if
condition|(
name|buflist
operator|->
name|head
operator|==
name|NULL
condition|)
block|{
name|struct
name|ieee_buf
modifier|*
name|buf
decl_stmt|;
name|buf
operator|=
operator|(
expr|struct
name|ieee_buf
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
expr|*
name|buf
argument_list|)
expr_stmt|;
name|buf
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|buf
operator|->
name|c
operator|=
literal|0
expr_stmt|;
name|buflist
operator|->
name|head
operator|=
name|buf
expr_stmt|;
name|buflist
operator|->
name|tail
operator|=
name|buf
expr_stmt|;
block|}
name|info
operator|->
name|current
operator|=
name|buflist
expr_stmt|;
name|info
operator|->
name|curbuf
operator|=
name|buflist
operator|->
name|tail
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Append a buffer chain.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|boolean
name|ieee_append_buffer
parameter_list|(
name|info
parameter_list|,
name|mainbuf
parameter_list|,
name|newbuf
parameter_list|)
name|struct
name|ieee_handle
modifier|*
name|info
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|struct
name|ieee_buflist
modifier|*
name|mainbuf
decl_stmt|;
name|struct
name|ieee_buflist
modifier|*
name|newbuf
decl_stmt|;
block|{
if|if
condition|(
name|newbuf
operator|->
name|head
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|mainbuf
operator|->
name|head
operator|==
name|NULL
condition|)
name|mainbuf
operator|->
name|head
operator|=
name|newbuf
operator|->
name|head
expr_stmt|;
else|else
name|mainbuf
operator|->
name|tail
operator|->
name|next
operator|=
name|newbuf
operator|->
name|head
expr_stmt|;
name|mainbuf
operator|->
name|tail
operator|=
name|newbuf
operator|->
name|tail
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Write a byte into the buffer.  We use a macro for speed and a    function for the complex cases.  */
end_comment

begin_define
define|#
directive|define
name|ieee_write_byte
parameter_list|(
name|info
parameter_list|,
name|b
parameter_list|)
define|\
value|((info)->curbuf->c< IEEE_BUFSIZE				\    ? ((info)->curbuf->buf[(info)->curbuf->c++] = (b), true)	\    : ieee_real_write_byte ((info), (b)))
end_define

begin_function
specifier|static
name|boolean
name|ieee_real_write_byte
parameter_list|(
name|info
parameter_list|,
name|b
parameter_list|)
name|struct
name|ieee_handle
modifier|*
name|info
decl_stmt|;
name|int
name|b
decl_stmt|;
block|{
if|if
condition|(
name|info
operator|->
name|curbuf
operator|->
name|c
operator|>=
name|IEEE_BUFSIZE
condition|)
block|{
name|struct
name|ieee_buf
modifier|*
name|n
decl_stmt|;
name|n
operator|=
operator|(
expr|struct
name|ieee_buf
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
expr|*
name|n
argument_list|)
expr_stmt|;
name|n
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|n
operator|->
name|c
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|current
operator|->
name|head
operator|==
name|NULL
condition|)
name|info
operator|->
name|current
operator|->
name|head
operator|=
name|n
expr_stmt|;
else|else
name|info
operator|->
name|current
operator|->
name|tail
operator|->
name|next
operator|=
name|n
expr_stmt|;
name|info
operator|->
name|current
operator|->
name|tail
operator|=
name|n
expr_stmt|;
name|info
operator|->
name|curbuf
operator|=
name|n
expr_stmt|;
block|}
name|info
operator|->
name|curbuf
operator|->
name|buf
index|[
name|info
operator|->
name|curbuf
operator|->
name|c
index|]
operator|=
name|b
expr_stmt|;
operator|++
name|info
operator|->
name|curbuf
operator|->
name|c
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Write out two bytes.  */
end_comment

begin_function
specifier|static
name|boolean
name|ieee_write_2bytes
parameter_list|(
name|info
parameter_list|,
name|i
parameter_list|)
name|struct
name|ieee_handle
modifier|*
name|info
decl_stmt|;
name|int
name|i
decl_stmt|;
block|{
return|return
operator|(
name|ieee_write_byte
argument_list|(
name|info
argument_list|,
name|i
operator|>>
literal|8
argument_list|)
operator|&&
name|ieee_write_byte
argument_list|(
name|info
argument_list|,
name|i
operator|&
literal|0xff
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Write out an integer.  */
end_comment

begin_function
specifier|static
name|boolean
name|ieee_write_number
parameter_list|(
name|info
parameter_list|,
name|v
parameter_list|)
name|struct
name|ieee_handle
modifier|*
name|info
decl_stmt|;
name|bfd_vma
name|v
decl_stmt|;
block|{
name|bfd_vma
name|t
decl_stmt|;
name|bfd_byte
name|ab
index|[
literal|20
index|]
decl_stmt|;
name|bfd_byte
modifier|*
name|p
decl_stmt|;
name|unsigned
name|int
name|c
decl_stmt|;
if|if
condition|(
name|v
operator|<=
operator|(
name|bfd_vma
operator|)
name|ieee_number_end_enum
condition|)
return|return
name|ieee_write_byte
argument_list|(
name|info
argument_list|,
operator|(
name|int
operator|)
name|v
argument_list|)
return|;
name|t
operator|=
name|v
expr_stmt|;
name|p
operator|=
name|ab
operator|+
sizeof|sizeof
name|ab
expr_stmt|;
while|while
condition|(
name|t
operator|!=
literal|0
condition|)
block|{
operator|*
operator|--
name|p
operator|=
name|t
operator|&
literal|0xff
expr_stmt|;
name|t
operator|>>=
literal|8
expr_stmt|;
block|}
name|c
operator|=
operator|(
name|ab
operator|+
literal|20
operator|)
operator|-
name|p
expr_stmt|;
if|if
condition|(
name|c
operator|>
call|(
name|unsigned
name|int
call|)
argument_list|(
name|ieee_number_repeat_end_enum
operator|-
name|ieee_number_repeat_start_enum
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"IEEE numeric overflow: 0x"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf_vma
argument_list|(
name|stderr
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
operator|!
name|ieee_write_byte
argument_list|(
name|info
argument_list|,
operator|(
name|int
operator|)
name|ieee_number_repeat_start_enum
operator|+
name|c
argument_list|)
condition|)
return|return
name|false
return|;
for|for
control|(
init|;
name|c
operator|>
literal|0
condition|;
operator|--
name|c
operator|,
operator|++
name|p
control|)
block|{
if|if
condition|(
operator|!
name|ieee_write_byte
argument_list|(
name|info
argument_list|,
operator|*
name|p
argument_list|)
condition|)
return|return
name|false
return|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Write out a string.  */
end_comment

begin_function
specifier|static
name|boolean
name|ieee_write_id
parameter_list|(
name|info
parameter_list|,
name|s
parameter_list|)
name|struct
name|ieee_handle
modifier|*
name|info
decl_stmt|;
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|unsigned
name|int
name|len
decl_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<=
literal|0x7f
condition|)
block|{
if|if
condition|(
operator|!
name|ieee_write_byte
argument_list|(
name|info
argument_list|,
name|len
argument_list|)
condition|)
return|return
name|false
return|;
block|}
elseif|else
if|if
condition|(
name|len
operator|<=
literal|0xff
condition|)
block|{
if|if
condition|(
operator|!
name|ieee_write_byte
argument_list|(
name|info
argument_list|,
operator|(
name|int
operator|)
name|ieee_extension_length_1_enum
argument_list|)
operator|||
operator|!
name|ieee_write_byte
argument_list|(
name|info
argument_list|,
name|len
argument_list|)
condition|)
return|return
name|false
return|;
block|}
elseif|else
if|if
condition|(
name|len
operator|<=
literal|0xffff
condition|)
block|{
if|if
condition|(
operator|!
name|ieee_write_byte
argument_list|(
name|info
argument_list|,
operator|(
name|int
operator|)
name|ieee_extension_length_2_enum
argument_list|)
operator|||
operator|!
name|ieee_write_2bytes
argument_list|(
name|info
argument_list|,
name|len
argument_list|)
condition|)
return|return
name|false
return|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"IEEE string length overflow: %u\n"
argument_list|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
for|for
control|(
init|;
operator|*
name|s
operator|!=
literal|'\0'
condition|;
name|s
operator|++
control|)
if|if
condition|(
operator|!
name|ieee_write_byte
argument_list|(
name|info
argument_list|,
operator|*
name|s
argument_list|)
condition|)
return|return
name|false
return|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Write out an ASN record.  */
end_comment

begin_function
specifier|static
name|boolean
name|ieee_write_asn
parameter_list|(
name|info
parameter_list|,
name|indx
parameter_list|,
name|val
parameter_list|)
name|struct
name|ieee_handle
modifier|*
name|info
decl_stmt|;
name|unsigned
name|int
name|indx
decl_stmt|;
name|bfd_vma
name|val
decl_stmt|;
block|{
return|return
operator|(
name|ieee_write_2bytes
argument_list|(
name|info
argument_list|,
operator|(
name|int
operator|)
name|ieee_asn_record_enum
argument_list|)
operator|&&
name|ieee_write_number
argument_list|(
name|info
argument_list|,
name|indx
argument_list|)
operator|&&
name|ieee_write_number
argument_list|(
name|info
argument_list|,
name|val
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Write out an ATN65 record.  */
end_comment

begin_function
specifier|static
name|boolean
name|ieee_write_atn65
parameter_list|(
name|info
parameter_list|,
name|indx
parameter_list|,
name|s
parameter_list|)
name|struct
name|ieee_handle
modifier|*
name|info
decl_stmt|;
name|unsigned
name|int
name|indx
decl_stmt|;
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
block|{
return|return
operator|(
name|ieee_write_2bytes
argument_list|(
name|info
argument_list|,
operator|(
name|int
operator|)
name|ieee_atn_record_enum
argument_list|)
operator|&&
name|ieee_write_number
argument_list|(
name|info
argument_list|,
name|indx
argument_list|)
operator|&&
name|ieee_write_number
argument_list|(
name|info
argument_list|,
literal|0
argument_list|)
operator|&&
name|ieee_write_number
argument_list|(
name|info
argument_list|,
literal|65
argument_list|)
operator|&&
name|ieee_write_id
argument_list|(
name|info
argument_list|,
name|s
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Push a type index onto the type stack.  */
end_comment

begin_function
specifier|static
name|boolean
name|ieee_push_type
parameter_list|(
name|info
parameter_list|,
name|indx
parameter_list|,
name|size
parameter_list|,
name|unsignedp
parameter_list|,
name|localp
parameter_list|)
name|struct
name|ieee_handle
modifier|*
name|info
decl_stmt|;
name|unsigned
name|int
name|indx
decl_stmt|;
name|unsigned
name|int
name|size
decl_stmt|;
name|boolean
name|unsignedp
decl_stmt|;
name|boolean
name|localp
decl_stmt|;
block|{
name|struct
name|ieee_type_stack
modifier|*
name|ts
decl_stmt|;
name|ts
operator|=
operator|(
expr|struct
name|ieee_type_stack
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
expr|*
name|ts
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|ts
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
expr|*
name|ts
argument_list|)
expr_stmt|;
name|ts
operator|->
name|type
operator|.
name|indx
operator|=
name|indx
expr_stmt|;
name|ts
operator|->
name|type
operator|.
name|size
operator|=
name|size
expr_stmt|;
name|ts
operator|->
name|type
operator|.
name|unsignedp
operator|=
name|unsignedp
expr_stmt|;
name|ts
operator|->
name|type
operator|.
name|localp
operator|=
name|localp
expr_stmt|;
name|ts
operator|->
name|next
operator|=
name|info
operator|->
name|type_stack
expr_stmt|;
name|info
operator|->
name|type_stack
operator|=
name|ts
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Pop a type index off the type stack.  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|ieee_pop_type
parameter_list|(
name|info
parameter_list|)
name|struct
name|ieee_handle
modifier|*
name|info
decl_stmt|;
block|{
return|return
name|ieee_pop_type_used
argument_list|(
name|info
argument_list|,
name|true
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Pop an unused type index off the type stack.  */
end_comment

begin_function
specifier|static
name|void
name|ieee_pop_unused_type
parameter_list|(
name|info
parameter_list|)
name|struct
name|ieee_handle
modifier|*
name|info
decl_stmt|;
block|{
operator|(
name|void
operator|)
name|ieee_pop_type_used
argument_list|(
name|info
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Pop a used or unused type index off the type stack.  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|ieee_pop_type_used
parameter_list|(
name|info
parameter_list|,
name|used
parameter_list|)
name|struct
name|ieee_handle
modifier|*
name|info
decl_stmt|;
name|boolean
name|used
decl_stmt|;
block|{
name|struct
name|ieee_type_stack
modifier|*
name|ts
decl_stmt|;
name|unsigned
name|int
name|ret
decl_stmt|;
name|ts
operator|=
name|info
operator|->
name|type_stack
expr_stmt|;
name|assert
argument_list|(
name|ts
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* If this is a function type, and we need it, we need to append the      actual definition to the typedef block now.  */
if|if
condition|(
name|used
operator|&&
operator|!
name|ieee_buffer_emptyp
argument_list|(
operator|&
name|ts
operator|->
name|type
operator|.
name|fndef
argument_list|)
condition|)
block|{
name|struct
name|ieee_buflist
modifier|*
name|buflist
decl_stmt|;
if|if
condition|(
name|ts
operator|->
name|type
operator|.
name|localp
condition|)
block|{
comment|/* Make sure we have started the types block.  */
if|if
condition|(
name|ieee_buffer_emptyp
argument_list|(
operator|&
name|info
operator|->
name|types
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|ieee_change_buffer
argument_list|(
name|info
argument_list|,
operator|&
name|info
operator|->
name|types
argument_list|)
operator|||
operator|!
name|ieee_write_byte
argument_list|(
name|info
argument_list|,
operator|(
name|int
operator|)
name|ieee_bb_record_enum
argument_list|)
operator|||
operator|!
name|ieee_write_byte
argument_list|(
name|info
argument_list|,
literal|1
argument_list|)
operator|||
operator|!
name|ieee_write_number
argument_list|(
name|info
argument_list|,
literal|0
argument_list|)
operator|||
operator|!
name|ieee_write_id
argument_list|(
name|info
argument_list|,
name|info
operator|->
name|modname
argument_list|)
condition|)
return|return
name|false
return|;
block|}
name|buflist
operator|=
operator|&
name|info
operator|->
name|types
expr_stmt|;
block|}
else|else
block|{
comment|/* Make sure we started the global type block.  */
if|if
condition|(
name|ieee_buffer_emptyp
argument_list|(
operator|&
name|info
operator|->
name|global_types
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|ieee_change_buffer
argument_list|(
name|info
argument_list|,
operator|&
name|info
operator|->
name|global_types
argument_list|)
operator|||
operator|!
name|ieee_write_byte
argument_list|(
name|info
argument_list|,
operator|(
name|int
operator|)
name|ieee_bb_record_enum
argument_list|)
operator|||
operator|!
name|ieee_write_byte
argument_list|(
name|info
argument_list|,
literal|2
argument_list|)
operator|||
operator|!
name|ieee_write_number
argument_list|(
name|info
argument_list|,
literal|0
argument_list|)
operator|||
operator|!
name|ieee_write_id
argument_list|(
name|info
argument_list|,
literal|""
argument_list|)
condition|)
return|return
name|false
return|;
block|}
name|buflist
operator|=
operator|&
name|info
operator|->
name|global_types
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|ieee_append_buffer
argument_list|(
name|info
argument_list|,
name|buflist
argument_list|,
operator|&
name|ts
operator|->
name|type
operator|.
name|fndef
argument_list|)
condition|)
return|return
name|false
return|;
block|}
name|ret
operator|=
name|ts
operator|->
name|type
operator|.
name|indx
expr_stmt|;
name|info
operator|->
name|type_stack
operator|=
name|ts
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|ts
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Add a range of bytes included in the current compilation unit.  */
end_comment

begin_function
specifier|static
name|boolean
name|ieee_add_range
parameter_list|(
name|info
parameter_list|,
name|global
parameter_list|,
name|low
parameter_list|,
name|high
parameter_list|)
name|struct
name|ieee_handle
modifier|*
name|info
decl_stmt|;
name|boolean
name|global
decl_stmt|;
name|bfd_vma
name|low
decl_stmt|;
name|bfd_vma
name|high
decl_stmt|;
block|{
name|struct
name|ieee_range
modifier|*
modifier|*
name|plist
decl_stmt|,
modifier|*
name|r
decl_stmt|,
modifier|*
modifier|*
name|pr
decl_stmt|;
if|if
condition|(
name|low
operator|==
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
operator|||
name|high
operator|==
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
operator|||
name|low
operator|==
name|high
condition|)
return|return
name|true
return|;
if|if
condition|(
name|global
condition|)
name|plist
operator|=
operator|&
name|info
operator|->
name|global_ranges
expr_stmt|;
else|else
name|plist
operator|=
operator|&
name|info
operator|->
name|ranges
expr_stmt|;
for|for
control|(
name|r
operator|=
operator|*
name|plist
init|;
name|r
operator|!=
name|NULL
condition|;
name|r
operator|=
name|r
operator|->
name|next
control|)
block|{
if|if
condition|(
name|high
operator|>=
name|r
operator|->
name|low
operator|&&
name|low
operator|<=
name|r
operator|->
name|high
condition|)
block|{
comment|/* The new range overlaps r.  */
if|if
condition|(
name|low
operator|<
name|r
operator|->
name|low
condition|)
name|r
operator|->
name|low
operator|=
name|low
expr_stmt|;
if|if
condition|(
name|high
operator|>
name|r
operator|->
name|high
condition|)
name|r
operator|->
name|high
operator|=
name|high
expr_stmt|;
name|pr
operator|=
operator|&
name|r
operator|->
name|next
expr_stmt|;
while|while
condition|(
operator|*
name|pr
operator|!=
name|NULL
operator|&&
operator|(
operator|*
name|pr
operator|)
operator|->
name|low
operator|<=
name|r
operator|->
name|high
condition|)
block|{
name|struct
name|ieee_range
modifier|*
name|n
decl_stmt|;
if|if
condition|(
operator|(
operator|*
name|pr
operator|)
operator|->
name|high
operator|>
name|r
operator|->
name|high
condition|)
name|r
operator|->
name|high
operator|=
operator|(
operator|*
name|pr
operator|)
operator|->
name|high
expr_stmt|;
name|n
operator|=
operator|(
operator|*
name|pr
operator|)
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
operator|*
name|pr
argument_list|)
expr_stmt|;
operator|*
name|pr
operator|=
name|n
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
block|}
name|r
operator|=
operator|(
expr|struct
name|ieee_range
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
expr|*
name|r
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|r
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
expr|*
name|r
argument_list|)
expr_stmt|;
name|r
operator|->
name|low
operator|=
name|low
expr_stmt|;
name|r
operator|->
name|high
operator|=
name|high
expr_stmt|;
comment|/* Store the ranges sorted by address.  */
for|for
control|(
name|pr
operator|=
name|plist
init|;
operator|*
name|pr
operator|!=
name|NULL
condition|;
name|pr
operator|=
operator|&
operator|(
operator|*
name|pr
operator|)
operator|->
name|next
control|)
if|if
condition|(
operator|(
operator|*
name|pr
operator|)
operator|->
name|low
operator|>
name|high
condition|)
break|break;
name|r
operator|->
name|next
operator|=
operator|*
name|pr
expr_stmt|;
operator|*
name|pr
operator|=
name|r
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Start a new range for which we only have the low address.  */
end_comment

begin_function
specifier|static
name|boolean
name|ieee_start_range
parameter_list|(
name|info
parameter_list|,
name|low
parameter_list|)
name|struct
name|ieee_handle
modifier|*
name|info
decl_stmt|;
name|bfd_vma
name|low
decl_stmt|;
block|{
name|struct
name|ieee_range
modifier|*
name|r
decl_stmt|;
name|r
operator|=
operator|(
expr|struct
name|ieee_range
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
expr|*
name|r
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|r
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
expr|*
name|r
argument_list|)
expr_stmt|;
name|r
operator|->
name|low
operator|=
name|low
expr_stmt|;
name|r
operator|->
name|next
operator|=
name|info
operator|->
name|pending_ranges
expr_stmt|;
name|info
operator|->
name|pending_ranges
operator|=
name|r
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Finish a range started by ieee_start_range.  */
end_comment

begin_function
specifier|static
name|boolean
name|ieee_end_range
parameter_list|(
name|info
parameter_list|,
name|high
parameter_list|)
name|struct
name|ieee_handle
modifier|*
name|info
decl_stmt|;
name|bfd_vma
name|high
decl_stmt|;
block|{
name|struct
name|ieee_range
modifier|*
name|r
decl_stmt|;
name|bfd_vma
name|low
decl_stmt|;
name|assert
argument_list|(
name|info
operator|->
name|pending_ranges
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|r
operator|=
name|info
operator|->
name|pending_ranges
expr_stmt|;
name|low
operator|=
name|r
operator|->
name|low
expr_stmt|;
name|info
operator|->
name|pending_ranges
operator|=
name|r
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|r
argument_list|)
expr_stmt|;
return|return
name|ieee_add_range
argument_list|(
name|info
argument_list|,
name|false
argument_list|,
name|low
argument_list|,
name|high
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Start defining a type.  */
end_comment

begin_function
specifier|static
name|boolean
name|ieee_define_type
parameter_list|(
name|info
parameter_list|,
name|size
parameter_list|,
name|unsignedp
parameter_list|,
name|localp
parameter_list|)
name|struct
name|ieee_handle
modifier|*
name|info
decl_stmt|;
name|unsigned
name|int
name|size
decl_stmt|;
name|boolean
name|unsignedp
decl_stmt|;
name|boolean
name|localp
decl_stmt|;
block|{
return|return
name|ieee_define_named_type
argument_list|(
name|info
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|unsigned
name|int
operator|)
operator|-
literal|1
argument_list|,
name|size
argument_list|,
name|unsignedp
argument_list|,
name|localp
argument_list|,
operator|(
expr|struct
name|ieee_buflist
operator|*
operator|)
name|NULL
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Start defining a named type.  */
end_comment

begin_function
specifier|static
name|boolean
name|ieee_define_named_type
parameter_list|(
name|info
parameter_list|,
name|name
parameter_list|,
name|indx
parameter_list|,
name|size
parameter_list|,
name|unsignedp
parameter_list|,
name|localp
parameter_list|,
name|buflist
parameter_list|)
name|struct
name|ieee_handle
modifier|*
name|info
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|unsigned
name|int
name|indx
decl_stmt|;
name|unsigned
name|int
name|size
decl_stmt|;
name|boolean
name|unsignedp
decl_stmt|;
name|boolean
name|localp
decl_stmt|;
name|struct
name|ieee_buflist
modifier|*
name|buflist
decl_stmt|;
block|{
name|unsigned
name|int
name|type_indx
decl_stmt|;
name|unsigned
name|int
name|name_indx
decl_stmt|;
if|if
condition|(
name|indx
operator|!=
operator|(
name|unsigned
name|int
operator|)
operator|-
literal|1
condition|)
name|type_indx
operator|=
name|indx
expr_stmt|;
else|else
block|{
name|type_indx
operator|=
name|info
operator|->
name|type_indx
expr_stmt|;
operator|++
name|info
operator|->
name|type_indx
expr_stmt|;
block|}
name|name_indx
operator|=
name|info
operator|->
name|name_indx
expr_stmt|;
operator|++
name|info
operator|->
name|name_indx
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
name|name
operator|=
literal|""
expr_stmt|;
comment|/* If we were given a buffer, use it; otherwise, use either the      local or the global type information, and make sure that the type      block is started.  */
if|if
condition|(
name|buflist
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|ieee_change_buffer
argument_list|(
name|info
argument_list|,
name|buflist
argument_list|)
condition|)
return|return
name|false
return|;
block|}
elseif|else
if|if
condition|(
name|localp
condition|)
block|{
if|if
condition|(
operator|!
name|ieee_buffer_emptyp
argument_list|(
operator|&
name|info
operator|->
name|types
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|ieee_change_buffer
argument_list|(
name|info
argument_list|,
operator|&
name|info
operator|->
name|types
argument_list|)
condition|)
return|return
name|false
return|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|ieee_change_buffer
argument_list|(
name|info
argument_list|,
operator|&
name|info
operator|->
name|types
argument_list|)
operator|||
operator|!
name|ieee_write_byte
argument_list|(
name|info
argument_list|,
operator|(
name|int
operator|)
name|ieee_bb_record_enum
argument_list|)
operator|||
operator|!
name|ieee_write_byte
argument_list|(
name|info
argument_list|,
literal|1
argument_list|)
operator|||
operator|!
name|ieee_write_number
argument_list|(
name|info
argument_list|,
literal|0
argument_list|)
operator|||
operator|!
name|ieee_write_id
argument_list|(
name|info
argument_list|,
name|info
operator|->
name|modname
argument_list|)
condition|)
return|return
name|false
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
name|ieee_buffer_emptyp
argument_list|(
operator|&
name|info
operator|->
name|global_types
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|ieee_change_buffer
argument_list|(
name|info
argument_list|,
operator|&
name|info
operator|->
name|global_types
argument_list|)
condition|)
return|return
name|false
return|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|ieee_change_buffer
argument_list|(
name|info
argument_list|,
operator|&
name|info
operator|->
name|global_types
argument_list|)
operator|||
operator|!
name|ieee_write_byte
argument_list|(
name|info
argument_list|,
operator|(
name|int
operator|)
name|ieee_bb_record_enum
argument_list|)
operator|||
operator|!
name|ieee_write_byte
argument_list|(
name|info
argument_list|,
literal|2
argument_list|)
operator|||
operator|!
name|ieee_write_number
argument_list|(
name|info
argument_list|,
literal|0
argument_list|)
operator|||
operator|!
name|ieee_write_id
argument_list|(
name|info
argument_list|,
literal|""
argument_list|)
condition|)
return|return
name|false
return|;
block|}
block|}
comment|/* Push the new type on the type stack, write out an NN record, and      write out the start of a TY record.  The caller will then finish      the TY record.  */
if|if
condition|(
operator|!
name|ieee_push_type
argument_list|(
name|info
argument_list|,
name|type_indx
argument_list|,
name|size
argument_list|,
name|unsignedp
argument_list|,
name|localp
argument_list|)
condition|)
return|return
name|false
return|;
return|return
operator|(
name|ieee_write_byte
argument_list|(
name|info
argument_list|,
operator|(
name|int
operator|)
name|ieee_nn_record
argument_list|)
operator|&&
name|ieee_write_number
argument_list|(
name|info
argument_list|,
name|name_indx
argument_list|)
operator|&&
name|ieee_write_id
argument_list|(
name|info
argument_list|,
name|name
argument_list|)
operator|&&
name|ieee_write_byte
argument_list|(
name|info
argument_list|,
operator|(
name|int
operator|)
name|ieee_ty_record_enum
argument_list|)
operator|&&
name|ieee_write_number
argument_list|(
name|info
argument_list|,
name|type_indx
argument_list|)
operator|&&
name|ieee_write_byte
argument_list|(
name|info
argument_list|,
literal|0xce
argument_list|)
operator|&&
name|ieee_write_number
argument_list|(
name|info
argument_list|,
name|name_indx
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Get an entry to the list of modified versions of a type.  */
end_comment

begin_function
specifier|static
name|struct
name|ieee_modified_type
modifier|*
name|ieee_get_modified_info
parameter_list|(
name|info
parameter_list|,
name|indx
parameter_list|)
name|struct
name|ieee_handle
modifier|*
name|info
decl_stmt|;
name|unsigned
name|int
name|indx
decl_stmt|;
block|{
if|if
condition|(
name|indx
operator|>=
name|info
operator|->
name|modified_alloc
condition|)
block|{
name|unsigned
name|int
name|nalloc
decl_stmt|;
name|nalloc
operator|=
name|info
operator|->
name|modified_alloc
expr_stmt|;
if|if
condition|(
name|nalloc
operator|==
literal|0
condition|)
name|nalloc
operator|=
literal|16
expr_stmt|;
while|while
condition|(
name|indx
operator|>=
name|nalloc
condition|)
name|nalloc
operator|*=
literal|2
expr_stmt|;
name|info
operator|->
name|modified
operator|=
operator|(
operator|(
expr|struct
name|ieee_modified_type
operator|*
operator|)
name|xrealloc
argument_list|(
name|info
operator|->
name|modified
argument_list|,
name|nalloc
operator|*
sizeof|sizeof
expr|*
name|info
operator|->
name|modified
argument_list|)
operator|)
expr_stmt|;
name|memset
argument_list|(
name|info
operator|->
name|modified
operator|+
name|info
operator|->
name|modified_alloc
argument_list|,
literal|0
argument_list|,
operator|(
name|nalloc
operator|-
name|info
operator|->
name|modified_alloc
operator|)
operator|*
sizeof|sizeof
expr|*
name|info
operator|->
name|modified
argument_list|)
expr_stmt|;
name|info
operator|->
name|modified_alloc
operator|=
name|nalloc
expr_stmt|;
block|}
return|return
name|info
operator|->
name|modified
operator|+
name|indx
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Routines for the hash table mapping names to types.  */
end_comment

begin_comment
comment|/* Initialize an entry in the hash table.  */
end_comment

begin_function
specifier|static
name|struct
name|bfd_hash_entry
modifier|*
name|ieee_name_type_newfunc
parameter_list|(
name|entry
parameter_list|,
name|table
parameter_list|,
name|string
parameter_list|)
name|struct
name|bfd_hash_entry
modifier|*
name|entry
decl_stmt|;
name|struct
name|bfd_hash_table
modifier|*
name|table
decl_stmt|;
specifier|const
name|char
modifier|*
name|string
decl_stmt|;
block|{
name|struct
name|ieee_name_type_hash_entry
modifier|*
name|ret
init|=
operator|(
expr|struct
name|ieee_name_type_hash_entry
operator|*
operator|)
name|entry
decl_stmt|;
comment|/* Allocate the structure if it has not already been allocated by a      subclass.  */
if|if
condition|(
name|ret
operator|==
name|NULL
condition|)
name|ret
operator|=
operator|(
operator|(
expr|struct
name|ieee_name_type_hash_entry
operator|*
operator|)
name|bfd_hash_allocate
argument_list|(
name|table
argument_list|,
sizeof|sizeof
expr|*
name|ret
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
comment|/* Call the allocation method of the superclass.  */
name|ret
operator|=
operator|(
operator|(
expr|struct
name|ieee_name_type_hash_entry
operator|*
operator|)
name|bfd_hash_newfunc
argument_list|(
operator|(
expr|struct
name|bfd_hash_entry
operator|*
operator|)
name|ret
argument_list|,
name|table
argument_list|,
name|string
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
comment|/* Set local fields.  */
name|ret
operator|->
name|types
operator|=
name|NULL
expr_stmt|;
block|}
return|return
operator|(
expr|struct
name|bfd_hash_entry
operator|*
operator|)
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Look up an entry in the hash table.  */
end_comment

begin_define
define|#
directive|define
name|ieee_name_type_hash_lookup
parameter_list|(
name|table
parameter_list|,
name|string
parameter_list|,
name|create
parameter_list|,
name|copy
parameter_list|)
define|\
value|((struct ieee_name_type_hash_entry *) \    bfd_hash_lookup (&(table)->root, (string), (create), (copy)))
end_define

begin_comment
comment|/* Traverse the hash table.  */
end_comment

begin_define
define|#
directive|define
name|ieee_name_type_hash_traverse
parameter_list|(
name|table
parameter_list|,
name|func
parameter_list|,
name|info
parameter_list|)
define|\
value|(bfd_hash_traverse							\    (&(table)->root,							\     (boolean (*) PARAMS ((struct bfd_hash_entry *, PTR))) (func),	\     (info)))
end_define

begin_escape
end_escape

begin_comment
comment|/* The general routine to write out IEEE debugging information.  */
end_comment

begin_function
name|boolean
name|write_ieee_debugging_info
parameter_list|(
name|abfd
parameter_list|,
name|dhandle
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|PTR
name|dhandle
decl_stmt|;
block|{
name|struct
name|ieee_handle
name|info
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
specifier|const
name|char
modifier|*
name|err
decl_stmt|;
name|struct
name|ieee_buf
modifier|*
name|b
decl_stmt|;
name|memset
argument_list|(
operator|&
name|info
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|info
argument_list|)
expr_stmt|;
name|info
operator|.
name|abfd
operator|=
name|abfd
expr_stmt|;
name|info
operator|.
name|type_indx
operator|=
literal|256
expr_stmt|;
name|info
operator|.
name|name_indx
operator|=
literal|32
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_hash_table_init
argument_list|(
operator|&
name|info
operator|.
name|typedefs
operator|.
name|root
argument_list|,
name|ieee_name_type_newfunc
argument_list|)
operator|||
operator|!
name|bfd_hash_table_init
argument_list|(
operator|&
name|info
operator|.
name|tags
operator|.
name|root
argument_list|,
name|ieee_name_type_newfunc
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|!
name|ieee_init_buffer
argument_list|(
operator|&
name|info
argument_list|,
operator|&
name|info
operator|.
name|global_types
argument_list|)
operator|||
operator|!
name|ieee_init_buffer
argument_list|(
operator|&
name|info
argument_list|,
operator|&
name|info
operator|.
name|data
argument_list|)
operator|||
operator|!
name|ieee_init_buffer
argument_list|(
operator|&
name|info
argument_list|,
operator|&
name|info
operator|.
name|types
argument_list|)
operator|||
operator|!
name|ieee_init_buffer
argument_list|(
operator|&
name|info
argument_list|,
operator|&
name|info
operator|.
name|vars
argument_list|)
operator|||
operator|!
name|ieee_init_buffer
argument_list|(
operator|&
name|info
argument_list|,
operator|&
name|info
operator|.
name|cxx
argument_list|)
operator|||
operator|!
name|ieee_init_buffer
argument_list|(
operator|&
name|info
argument_list|,
operator|&
name|info
operator|.
name|linenos
argument_list|)
operator|||
operator|!
name|ieee_init_buffer
argument_list|(
operator|&
name|info
argument_list|,
operator|&
name|info
operator|.
name|fntype
argument_list|)
operator|||
operator|!
name|ieee_init_buffer
argument_list|(
operator|&
name|info
argument_list|,
operator|&
name|info
operator|.
name|fnargs
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|!
name|debug_write
argument_list|(
name|dhandle
argument_list|,
operator|&
name|ieee_fns
argument_list|,
operator|(
name|PTR
operator|)
operator|&
name|info
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|info
operator|.
name|filename
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|ieee_finish_compilation_unit
argument_list|(
operator|&
name|info
argument_list|)
condition|)
return|return
name|false
return|;
block|}
comment|/* Put any undefined tags in the global typedef information.  */
name|info
operator|.
name|error
operator|=
name|false
expr_stmt|;
name|ieee_name_type_hash_traverse
argument_list|(
operator|&
name|info
operator|.
name|tags
argument_list|,
name|ieee_write_undefined_tag
argument_list|,
operator|(
name|PTR
operator|)
operator|&
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|.
name|error
condition|)
return|return
name|false
return|;
comment|/* Prepend the global typedef information to the other data.  */
if|if
condition|(
operator|!
name|ieee_buffer_emptyp
argument_list|(
operator|&
name|info
operator|.
name|global_types
argument_list|)
condition|)
block|{
comment|/* The HP debugger seems to have a bug in which it ignores the          last entry in the global types, so we add a dummy entry.  */
if|if
condition|(
operator|!
name|ieee_change_buffer
argument_list|(
operator|&
name|info
argument_list|,
operator|&
name|info
operator|.
name|global_types
argument_list|)
operator|||
operator|!
name|ieee_write_byte
argument_list|(
operator|&
name|info
argument_list|,
operator|(
name|int
operator|)
name|ieee_nn_record
argument_list|)
operator|||
operator|!
name|ieee_write_number
argument_list|(
operator|&
name|info
argument_list|,
name|info
operator|.
name|name_indx
argument_list|)
operator|||
operator|!
name|ieee_write_id
argument_list|(
operator|&
name|info
argument_list|,
literal|""
argument_list|)
operator|||
operator|!
name|ieee_write_byte
argument_list|(
operator|&
name|info
argument_list|,
operator|(
name|int
operator|)
name|ieee_ty_record_enum
argument_list|)
operator|||
operator|!
name|ieee_write_number
argument_list|(
operator|&
name|info
argument_list|,
name|info
operator|.
name|type_indx
argument_list|)
operator|||
operator|!
name|ieee_write_byte
argument_list|(
operator|&
name|info
argument_list|,
literal|0xce
argument_list|)
operator|||
operator|!
name|ieee_write_number
argument_list|(
operator|&
name|info
argument_list|,
name|info
operator|.
name|name_indx
argument_list|)
operator|||
operator|!
name|ieee_write_number
argument_list|(
operator|&
name|info
argument_list|,
literal|'P'
argument_list|)
operator|||
operator|!
name|ieee_write_number
argument_list|(
operator|&
name|info
argument_list|,
operator|(
name|int
operator|)
name|builtin_void
operator|+
literal|32
argument_list|)
operator|||
operator|!
name|ieee_write_byte
argument_list|(
operator|&
name|info
argument_list|,
operator|(
name|int
operator|)
name|ieee_be_record_enum
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|!
name|ieee_append_buffer
argument_list|(
operator|&
name|info
argument_list|,
operator|&
name|info
operator|.
name|global_types
argument_list|,
operator|&
name|info
operator|.
name|data
argument_list|)
condition|)
return|return
name|false
return|;
name|info
operator|.
name|data
operator|=
name|info
operator|.
name|global_types
expr_stmt|;
block|}
comment|/* Make sure that we have declare BB11 blocks for each range in the      file.  They are added to info->vars.  */
name|info
operator|.
name|error
operator|=
name|false
expr_stmt|;
if|if
condition|(
operator|!
name|ieee_init_buffer
argument_list|(
operator|&
name|info
argument_list|,
operator|&
name|info
operator|.
name|vars
argument_list|)
condition|)
return|return
name|false
return|;
name|bfd_map_over_sections
argument_list|(
name|abfd
argument_list|,
name|ieee_add_bb11_blocks
argument_list|,
operator|(
name|PTR
operator|)
operator|&
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|.
name|error
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|!
name|ieee_buffer_emptyp
argument_list|(
operator|&
name|info
operator|.
name|vars
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|ieee_change_buffer
argument_list|(
operator|&
name|info
argument_list|,
operator|&
name|info
operator|.
name|vars
argument_list|)
operator|||
operator|!
name|ieee_write_byte
argument_list|(
operator|&
name|info
argument_list|,
operator|(
name|int
operator|)
name|ieee_be_record_enum
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|!
name|ieee_append_buffer
argument_list|(
operator|&
name|info
argument_list|,
operator|&
name|info
operator|.
name|data
argument_list|,
operator|&
name|info
operator|.
name|vars
argument_list|)
condition|)
return|return
name|false
return|;
block|}
comment|/* Now all the data is in info.data.  Write it out to the BFD.  We      normally would need to worry about whether all the other sections      are set up yet, but the IEEE backend will handle this particular      case correctly regardless.  */
if|if
condition|(
name|ieee_buffer_emptyp
argument_list|(
operator|&
name|info
operator|.
name|data
argument_list|)
condition|)
block|{
comment|/* There is no debugging information.  */
return|return
name|true
return|;
block|}
name|err
operator|=
name|NULL
expr_stmt|;
name|s
operator|=
name|bfd_make_section
argument_list|(
name|abfd
argument_list|,
literal|".debug"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
name|err
operator|=
literal|"bfd_make_section"
expr_stmt|;
if|if
condition|(
name|err
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|bfd_set_section_flags
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
name|SEC_DEBUGGING
operator||
name|SEC_HAS_CONTENTS
argument_list|)
condition|)
name|err
operator|=
literal|"bfd_set_section_flags"
expr_stmt|;
block|}
if|if
condition|(
name|err
operator|==
name|NULL
condition|)
block|{
name|bfd_size_type
name|size
decl_stmt|;
name|size
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|b
operator|=
name|info
operator|.
name|data
operator|.
name|head
init|;
name|b
operator|!=
name|NULL
condition|;
name|b
operator|=
name|b
operator|->
name|next
control|)
name|size
operator|+=
name|b
operator|->
name|c
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_set_section_size
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
name|size
argument_list|)
condition|)
name|err
operator|=
literal|"bfd_set_section_size"
expr_stmt|;
block|}
if|if
condition|(
name|err
operator|==
name|NULL
condition|)
block|{
name|file_ptr
name|offset
decl_stmt|;
name|offset
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|b
operator|=
name|info
operator|.
name|data
operator|.
name|head
init|;
name|b
operator|!=
name|NULL
condition|;
name|b
operator|=
name|b
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|!
name|bfd_set_section_contents
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
name|b
operator|->
name|buf
argument_list|,
name|offset
argument_list|,
name|b
operator|->
name|c
argument_list|)
condition|)
block|{
name|err
operator|=
literal|"bfd_set_section_contents"
expr_stmt|;
break|break;
block|}
name|offset
operator|+=
name|b
operator|->
name|c
expr_stmt|;
block|}
block|}
if|if
condition|(
name|err
operator|!=
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: %s: %s\n"
argument_list|,
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|err
argument_list|,
name|bfd_errmsg
argument_list|(
name|bfd_get_error
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|bfd_hash_table_free
argument_list|(
operator|&
name|info
operator|.
name|typedefs
operator|.
name|root
argument_list|)
expr_stmt|;
name|bfd_hash_table_free
argument_list|(
operator|&
name|info
operator|.
name|tags
operator|.
name|root
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Write out information for an undefined tag.  This is called via    ieee_name_type_hash_traverse.  */
end_comment

begin_function
specifier|static
name|boolean
name|ieee_write_undefined_tag
parameter_list|(
name|h
parameter_list|,
name|p
parameter_list|)
name|struct
name|ieee_name_type_hash_entry
modifier|*
name|h
decl_stmt|;
name|PTR
name|p
decl_stmt|;
block|{
name|struct
name|ieee_handle
modifier|*
name|info
init|=
operator|(
expr|struct
name|ieee_handle
operator|*
operator|)
name|p
decl_stmt|;
name|struct
name|ieee_name_type
modifier|*
name|nt
decl_stmt|;
for|for
control|(
name|nt
operator|=
name|h
operator|->
name|types
init|;
name|nt
operator|!=
name|NULL
condition|;
name|nt
operator|=
name|nt
operator|->
name|next
control|)
block|{
name|unsigned
name|int
name|name_indx
decl_stmt|;
name|char
name|code
decl_stmt|;
if|if
condition|(
name|nt
operator|->
name|kind
operator|==
name|DEBUG_KIND_ILLEGAL
condition|)
continue|continue;
if|if
condition|(
name|ieee_buffer_emptyp
argument_list|(
operator|&
name|info
operator|->
name|global_types
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|ieee_change_buffer
argument_list|(
name|info
argument_list|,
operator|&
name|info
operator|->
name|global_types
argument_list|)
operator|||
operator|!
name|ieee_write_byte
argument_list|(
name|info
argument_list|,
operator|(
name|int
operator|)
name|ieee_bb_record_enum
argument_list|)
operator|||
operator|!
name|ieee_write_byte
argument_list|(
name|info
argument_list|,
literal|2
argument_list|)
operator|||
operator|!
name|ieee_write_number
argument_list|(
name|info
argument_list|,
literal|0
argument_list|)
operator|||
operator|!
name|ieee_write_id
argument_list|(
name|info
argument_list|,
literal|""
argument_list|)
condition|)
block|{
name|info
operator|->
name|error
operator|=
name|true
expr_stmt|;
return|return
name|false
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
name|ieee_change_buffer
argument_list|(
name|info
argument_list|,
operator|&
name|info
operator|->
name|global_types
argument_list|)
condition|)
block|{
name|info
operator|->
name|error
operator|=
name|true
expr_stmt|;
return|return
name|false
return|;
block|}
block|}
name|name_indx
operator|=
name|info
operator|->
name|name_indx
expr_stmt|;
operator|++
name|info
operator|->
name|name_indx
expr_stmt|;
if|if
condition|(
operator|!
name|ieee_write_byte
argument_list|(
name|info
argument_list|,
operator|(
name|int
operator|)
name|ieee_nn_record
argument_list|)
operator|||
operator|!
name|ieee_write_number
argument_list|(
name|info
argument_list|,
name|name_indx
argument_list|)
operator|||
operator|!
name|ieee_write_id
argument_list|(
name|info
argument_list|,
name|nt
operator|->
name|type
operator|.
name|name
argument_list|)
operator|||
operator|!
name|ieee_write_byte
argument_list|(
name|info
argument_list|,
operator|(
name|int
operator|)
name|ieee_ty_record_enum
argument_list|)
operator|||
operator|!
name|ieee_write_number
argument_list|(
name|info
argument_list|,
name|nt
operator|->
name|type
operator|.
name|indx
argument_list|)
operator|||
operator|!
name|ieee_write_byte
argument_list|(
name|info
argument_list|,
literal|0xce
argument_list|)
operator|||
operator|!
name|ieee_write_number
argument_list|(
name|info
argument_list|,
name|name_indx
argument_list|)
condition|)
block|{
name|info
operator|->
name|error
operator|=
name|true
expr_stmt|;
return|return
name|false
return|;
block|}
switch|switch
condition|(
name|nt
operator|->
name|kind
condition|)
block|{
default|default:
name|abort
argument_list|()
expr_stmt|;
name|info
operator|->
name|error
operator|=
name|true
expr_stmt|;
return|return
name|false
return|;
case|case
name|DEBUG_KIND_STRUCT
case|:
case|case
name|DEBUG_KIND_CLASS
case|:
name|code
operator|=
literal|'S'
expr_stmt|;
break|break;
case|case
name|DEBUG_KIND_UNION
case|:
case|case
name|DEBUG_KIND_UNION_CLASS
case|:
name|code
operator|=
literal|'U'
expr_stmt|;
break|break;
case|case
name|DEBUG_KIND_ENUM
case|:
name|code
operator|=
literal|'E'
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|ieee_write_number
argument_list|(
name|info
argument_list|,
name|code
argument_list|)
operator|||
operator|!
name|ieee_write_number
argument_list|(
name|info
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|info
operator|->
name|error
operator|=
name|true
expr_stmt|;
return|return
name|false
return|;
block|}
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Start writing out information for a compilation unit.  */
end_comment

begin_function
specifier|static
name|boolean
name|ieee_start_compilation_unit
parameter_list|(
name|p
parameter_list|,
name|filename
parameter_list|)
name|PTR
name|p
decl_stmt|;
specifier|const
name|char
modifier|*
name|filename
decl_stmt|;
block|{
name|struct
name|ieee_handle
modifier|*
name|info
init|=
operator|(
expr|struct
name|ieee_handle
operator|*
operator|)
name|p
decl_stmt|;
specifier|const
name|char
modifier|*
name|modname
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_DOS_BASED_FILE_SYSTEM
specifier|const
name|char
modifier|*
name|backslash
decl_stmt|;
endif|#
directive|endif
name|char
modifier|*
name|c
decl_stmt|,
modifier|*
name|s
decl_stmt|;
name|unsigned
name|int
name|nindx
decl_stmt|;
if|if
condition|(
name|info
operator|->
name|filename
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|ieee_finish_compilation_unit
argument_list|(
name|info
argument_list|)
condition|)
return|return
name|false
return|;
block|}
name|info
operator|->
name|filename
operator|=
name|filename
expr_stmt|;
name|modname
operator|=
name|strrchr
argument_list|(
name|filename
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_DOS_BASED_FILE_SYSTEM
comment|/* We could have a mixed forward/back slash case.  */
name|backslash
operator|=
name|strrchr
argument_list|(
name|filename
argument_list|,
literal|'\\'
argument_list|)
expr_stmt|;
if|if
condition|(
name|modname
operator|==
name|NULL
operator|||
operator|(
name|backslash
operator|!=
name|NULL
operator|&&
name|backslash
operator|>
name|modname
operator|)
condition|)
name|modname
operator|=
name|backslash
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|modname
operator|!=
name|NULL
condition|)
operator|++
name|modname
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_DOS_BASED_FILE_SYSTEM
elseif|else
if|if
condition|(
name|filename
index|[
literal|0
index|]
operator|&&
name|filename
index|[
literal|1
index|]
operator|==
literal|':'
condition|)
name|modname
operator|=
name|filename
operator|+
literal|2
expr_stmt|;
endif|#
directive|endif
else|else
name|modname
operator|=
name|filename
expr_stmt|;
name|c
operator|=
name|xstrdup
argument_list|(
name|modname
argument_list|)
expr_stmt|;
name|s
operator|=
name|strrchr
argument_list|(
name|c
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
condition|)
operator|*
name|s
operator|=
literal|'\0'
expr_stmt|;
name|info
operator|->
name|modname
operator|=
name|c
expr_stmt|;
if|if
condition|(
operator|!
name|ieee_init_buffer
argument_list|(
name|info
argument_list|,
operator|&
name|info
operator|->
name|types
argument_list|)
operator|||
operator|!
name|ieee_init_buffer
argument_list|(
name|info
argument_list|,
operator|&
name|info
operator|->
name|vars
argument_list|)
operator|||
operator|!
name|ieee_init_buffer
argument_list|(
name|info
argument_list|,
operator|&
name|info
operator|->
name|cxx
argument_list|)
operator|||
operator|!
name|ieee_init_buffer
argument_list|(
name|info
argument_list|,
operator|&
name|info
operator|->
name|linenos
argument_list|)
condition|)
return|return
name|false
return|;
name|info
operator|->
name|ranges
operator|=
name|NULL
expr_stmt|;
comment|/* Always include a BB1 and a BB3 block.  That is what the output of      the MRI linker seems to look like.  */
if|if
condition|(
operator|!
name|ieee_change_buffer
argument_list|(
name|info
argument_list|,
operator|&
name|info
operator|->
name|types
argument_list|)
operator|||
operator|!
name|ieee_write_byte
argument_list|(
name|info
argument_list|,
operator|(
name|int
operator|)
name|ieee_bb_record_enum
argument_list|)
operator|||
operator|!
name|ieee_write_byte
argument_list|(
name|info
argument_list|,
literal|1
argument_list|)
operator|||
operator|!
name|ieee_write_number
argument_list|(
name|info
argument_list|,
literal|0
argument_list|)
operator|||
operator|!
name|ieee_write_id
argument_list|(
name|info
argument_list|,
name|info
operator|->
name|modname
argument_list|)
condition|)
return|return
name|false
return|;
name|nindx
operator|=
name|info
operator|->
name|name_indx
expr_stmt|;
operator|++
name|info
operator|->
name|name_indx
expr_stmt|;
if|if
condition|(
operator|!
name|ieee_change_buffer
argument_list|(
name|info
argument_list|,
operator|&
name|info
operator|->
name|vars
argument_list|)
operator|||
operator|!
name|ieee_write_byte
argument_list|(
name|info
argument_list|,
operator|(
name|int
operator|)
name|ieee_bb_record_enum
argument_list|)
operator|||
operator|!
name|ieee_write_byte
argument_list|(
name|info
argument_list|,
literal|3
argument_list|)
operator|||
operator|!
name|ieee_write_number
argument_list|(
name|info
argument_list|,
literal|0
argument_list|)
operator|||
operator|!
name|ieee_write_id
argument_list|(
name|info
argument_list|,
name|info
operator|->
name|modname
argument_list|)
condition|)
return|return
name|false
return|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Finish up a compilation unit.  */
end_comment

begin_function
specifier|static
name|boolean
name|ieee_finish_compilation_unit
parameter_list|(
name|info
parameter_list|)
name|struct
name|ieee_handle
modifier|*
name|info
decl_stmt|;
block|{
name|struct
name|ieee_range
modifier|*
name|r
decl_stmt|;
if|if
condition|(
operator|!
name|ieee_buffer_emptyp
argument_list|(
operator|&
name|info
operator|->
name|types
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|ieee_change_buffer
argument_list|(
name|info
argument_list|,
operator|&
name|info
operator|->
name|types
argument_list|)
operator|||
operator|!
name|ieee_write_byte
argument_list|(
name|info
argument_list|,
operator|(
name|int
operator|)
name|ieee_be_record_enum
argument_list|)
condition|)
return|return
name|false
return|;
block|}
if|if
condition|(
operator|!
name|ieee_buffer_emptyp
argument_list|(
operator|&
name|info
operator|->
name|cxx
argument_list|)
condition|)
block|{
comment|/* Append any C++ information to the global function and          variable information.  */
name|assert
argument_list|(
operator|!
name|ieee_buffer_emptyp
argument_list|(
operator|&
name|info
operator|->
name|vars
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ieee_change_buffer
argument_list|(
name|info
argument_list|,
operator|&
name|info
operator|->
name|vars
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* We put the pmisc records in a dummy procedure, just as the          MRI compiler does.  */
if|if
condition|(
operator|!
name|ieee_write_byte
argument_list|(
name|info
argument_list|,
operator|(
name|int
operator|)
name|ieee_bb_record_enum
argument_list|)
operator|||
operator|!
name|ieee_write_byte
argument_list|(
name|info
argument_list|,
literal|6
argument_list|)
operator|||
operator|!
name|ieee_write_number
argument_list|(
name|info
argument_list|,
literal|0
argument_list|)
operator|||
operator|!
name|ieee_write_id
argument_list|(
name|info
argument_list|,
literal|"__XRYCPP"
argument_list|)
operator|||
operator|!
name|ieee_write_number
argument_list|(
name|info
argument_list|,
literal|0
argument_list|)
operator|||
operator|!
name|ieee_write_number
argument_list|(
name|info
argument_list|,
literal|0
argument_list|)
operator|||
operator|!
name|ieee_write_number
argument_list|(
name|info
argument_list|,
name|info
operator|->
name|highaddr
operator|-
literal|1
argument_list|)
operator|||
operator|!
name|ieee_append_buffer
argument_list|(
name|info
argument_list|,
operator|&
name|info
operator|->
name|vars
argument_list|,
operator|&
name|info
operator|->
name|cxx
argument_list|)
operator|||
operator|!
name|ieee_change_buffer
argument_list|(
name|info
argument_list|,
operator|&
name|info
operator|->
name|vars
argument_list|)
operator|||
operator|!
name|ieee_write_byte
argument_list|(
name|info
argument_list|,
operator|(
name|int
operator|)
name|ieee_be_record_enum
argument_list|)
operator|||
operator|!
name|ieee_write_number
argument_list|(
name|info
argument_list|,
name|info
operator|->
name|highaddr
operator|-
literal|1
argument_list|)
condition|)
return|return
name|false
return|;
block|}
if|if
condition|(
operator|!
name|ieee_buffer_emptyp
argument_list|(
operator|&
name|info
operator|->
name|vars
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|ieee_change_buffer
argument_list|(
name|info
argument_list|,
operator|&
name|info
operator|->
name|vars
argument_list|)
operator|||
operator|!
name|ieee_write_byte
argument_list|(
name|info
argument_list|,
operator|(
name|int
operator|)
name|ieee_be_record_enum
argument_list|)
condition|)
return|return
name|false
return|;
block|}
if|if
condition|(
name|info
operator|->
name|pending_lineno_filename
operator|!=
name|NULL
condition|)
block|{
comment|/* Force out the pending line number.  */
if|if
condition|(
operator|!
name|ieee_lineno
argument_list|(
operator|(
name|PTR
operator|)
name|info
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|0
argument_list|,
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
argument_list|)
condition|)
return|return
name|false
return|;
block|}
if|if
condition|(
operator|!
name|ieee_buffer_emptyp
argument_list|(
operator|&
name|info
operator|->
name|linenos
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|ieee_change_buffer
argument_list|(
name|info
argument_list|,
operator|&
name|info
operator|->
name|linenos
argument_list|)
operator|||
operator|!
name|ieee_write_byte
argument_list|(
name|info
argument_list|,
operator|(
name|int
operator|)
name|ieee_be_record_enum
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|info
operator|->
name|filename
argument_list|,
name|info
operator|->
name|lineno_filename
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* We were not in the main file.  We just closed the              included line number block, and now we must close the              main line number block.  */
if|if
condition|(
operator|!
name|ieee_write_byte
argument_list|(
name|info
argument_list|,
operator|(
name|int
operator|)
name|ieee_be_record_enum
argument_list|)
condition|)
return|return
name|false
return|;
block|}
block|}
if|if
condition|(
operator|!
name|ieee_append_buffer
argument_list|(
name|info
argument_list|,
operator|&
name|info
operator|->
name|data
argument_list|,
operator|&
name|info
operator|->
name|types
argument_list|)
operator|||
operator|!
name|ieee_append_buffer
argument_list|(
name|info
argument_list|,
operator|&
name|info
operator|->
name|data
argument_list|,
operator|&
name|info
operator|->
name|vars
argument_list|)
operator|||
operator|!
name|ieee_append_buffer
argument_list|(
name|info
argument_list|,
operator|&
name|info
operator|->
name|data
argument_list|,
operator|&
name|info
operator|->
name|linenos
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* Build BB10/BB11 blocks based on the ranges we recorded.  */
if|if
condition|(
operator|!
name|ieee_change_buffer
argument_list|(
name|info
argument_list|,
operator|&
name|info
operator|->
name|data
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|!
name|ieee_write_byte
argument_list|(
name|info
argument_list|,
operator|(
name|int
operator|)
name|ieee_bb_record_enum
argument_list|)
operator|||
operator|!
name|ieee_write_byte
argument_list|(
name|info
argument_list|,
literal|10
argument_list|)
operator|||
operator|!
name|ieee_write_number
argument_list|(
name|info
argument_list|,
literal|0
argument_list|)
operator|||
operator|!
name|ieee_write_id
argument_list|(
name|info
argument_list|,
name|info
operator|->
name|modname
argument_list|)
operator|||
operator|!
name|ieee_write_id
argument_list|(
name|info
argument_list|,
literal|""
argument_list|)
operator|||
operator|!
name|ieee_write_number
argument_list|(
name|info
argument_list|,
literal|0
argument_list|)
operator|||
operator|!
name|ieee_write_id
argument_list|(
name|info
argument_list|,
literal|"GNU objcopy"
argument_list|)
condition|)
return|return
name|false
return|;
for|for
control|(
name|r
operator|=
name|info
operator|->
name|ranges
init|;
name|r
operator|!=
name|NULL
condition|;
name|r
operator|=
name|r
operator|->
name|next
control|)
block|{
name|bfd_vma
name|low
decl_stmt|,
name|high
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
name|int
name|kind
decl_stmt|;
name|low
operator|=
name|r
operator|->
name|low
expr_stmt|;
name|high
operator|=
name|r
operator|->
name|high
expr_stmt|;
comment|/* Find the section corresponding to this range.  */
for|for
control|(
name|s
operator|=
name|info
operator|->
name|abfd
operator|->
name|sections
init|;
name|s
operator|!=
name|NULL
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
block|{
if|if
condition|(
name|bfd_get_section_vma
argument_list|(
name|info
operator|->
name|abfd
argument_list|,
name|s
argument_list|)
operator|<=
name|low
operator|&&
name|high
operator|<=
operator|(
name|bfd_get_section_vma
argument_list|(
name|info
operator|->
name|abfd
argument_list|,
name|s
argument_list|)
operator|+
name|bfd_section_size
argument_list|(
name|info
operator|->
name|abfd
argument_list|,
name|s
argument_list|)
operator|)
condition|)
break|break;
block|}
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
block|{
comment|/* Just ignore this range.  */
continue|continue;
block|}
comment|/* Coalesce ranges if it seems reasonable.  */
while|while
condition|(
name|r
operator|->
name|next
operator|!=
name|NULL
operator|&&
name|high
operator|+
literal|0x1000
operator|>=
name|r
operator|->
name|next
operator|->
name|low
operator|&&
operator|(
name|r
operator|->
name|next
operator|->
name|high
operator|<=
operator|(
name|bfd_get_section_vma
argument_list|(
name|info
operator|->
name|abfd
argument_list|,
name|s
argument_list|)
operator|+
name|bfd_section_size
argument_list|(
name|info
operator|->
name|abfd
argument_list|,
name|s
argument_list|)
operator|)
operator|)
condition|)
block|{
name|r
operator|=
name|r
operator|->
name|next
expr_stmt|;
name|high
operator|=
name|r
operator|->
name|high
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|s
operator|->
name|flags
operator|&
name|SEC_CODE
operator|)
operator|!=
literal|0
condition|)
name|kind
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|s
operator|->
name|flags
operator|&
name|SEC_READONLY
operator|)
operator|!=
literal|0
condition|)
name|kind
operator|=
literal|3
expr_stmt|;
else|else
name|kind
operator|=
literal|2
expr_stmt|;
if|if
condition|(
operator|!
name|ieee_write_byte
argument_list|(
name|info
argument_list|,
operator|(
name|int
operator|)
name|ieee_bb_record_enum
argument_list|)
operator|||
operator|!
name|ieee_write_byte
argument_list|(
name|info
argument_list|,
literal|11
argument_list|)
operator|||
operator|!
name|ieee_write_number
argument_list|(
name|info
argument_list|,
literal|0
argument_list|)
operator|||
operator|!
name|ieee_write_id
argument_list|(
name|info
argument_list|,
literal|""
argument_list|)
operator|||
operator|!
name|ieee_write_number
argument_list|(
name|info
argument_list|,
name|kind
argument_list|)
operator|||
operator|!
name|ieee_write_number
argument_list|(
name|info
argument_list|,
name|s
operator|->
name|index
operator|+
name|IEEE_SECTION_NUMBER_BASE
argument_list|)
operator|||
operator|!
name|ieee_write_number
argument_list|(
name|info
argument_list|,
name|low
argument_list|)
operator|||
operator|!
name|ieee_write_byte
argument_list|(
name|info
argument_list|,
operator|(
name|int
operator|)
name|ieee_be_record_enum
argument_list|)
operator|||
operator|!
name|ieee_write_number
argument_list|(
name|info
argument_list|,
name|high
operator|-
name|low
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* Add this range to the list of global ranges.  */
if|if
condition|(
operator|!
name|ieee_add_range
argument_list|(
name|info
argument_list|,
name|true
argument_list|,
name|low
argument_list|,
name|high
argument_list|)
condition|)
return|return
name|false
return|;
block|}
if|if
condition|(
operator|!
name|ieee_write_byte
argument_list|(
name|info
argument_list|,
operator|(
name|int
operator|)
name|ieee_be_record_enum
argument_list|)
condition|)
return|return
name|false
return|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Add BB11 blocks describing each range that we have not already    described.  */
end_comment

begin_function
specifier|static
name|void
name|ieee_add_bb11_blocks
parameter_list|(
name|abfd
parameter_list|,
name|sec
parameter_list|,
name|data
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|PTR
name|data
decl_stmt|;
block|{
name|struct
name|ieee_handle
modifier|*
name|info
init|=
operator|(
expr|struct
name|ieee_handle
operator|*
operator|)
name|data
decl_stmt|;
name|bfd_vma
name|low
decl_stmt|,
name|high
decl_stmt|;
name|struct
name|ieee_range
modifier|*
name|r
decl_stmt|;
name|low
operator|=
name|bfd_get_section_vma
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
expr_stmt|;
name|high
operator|=
name|low
operator|+
name|bfd_section_size
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
expr_stmt|;
comment|/* Find the first range at or after this section.  The ranges are      sorted by address.  */
for|for
control|(
name|r
operator|=
name|info
operator|->
name|global_ranges
init|;
name|r
operator|!=
name|NULL
condition|;
name|r
operator|=
name|r
operator|->
name|next
control|)
if|if
condition|(
name|r
operator|->
name|high
operator|>
name|low
condition|)
break|break;
while|while
condition|(
name|low
operator|<
name|high
condition|)
block|{
if|if
condition|(
name|r
operator|==
name|NULL
operator|||
name|r
operator|->
name|low
operator|>=
name|high
condition|)
block|{
if|if
condition|(
operator|!
name|ieee_add_bb11
argument_list|(
name|info
argument_list|,
name|sec
argument_list|,
name|low
argument_list|,
name|high
argument_list|)
condition|)
name|info
operator|->
name|error
operator|=
name|true
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|low
operator|<
name|r
operator|->
name|low
operator|&&
name|r
operator|->
name|low
operator|-
name|low
operator|>
literal|0x100
condition|)
block|{
if|if
condition|(
operator|!
name|ieee_add_bb11
argument_list|(
name|info
argument_list|,
name|sec
argument_list|,
name|low
argument_list|,
name|r
operator|->
name|low
argument_list|)
condition|)
block|{
name|info
operator|->
name|error
operator|=
name|true
expr_stmt|;
return|return;
block|}
block|}
name|low
operator|=
name|r
operator|->
name|high
expr_stmt|;
name|r
operator|=
name|r
operator|->
name|next
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Add a single BB11 block for a range.  We add it to info->vars.  */
end_comment

begin_function
specifier|static
name|boolean
name|ieee_add_bb11
parameter_list|(
name|info
parameter_list|,
name|sec
parameter_list|,
name|low
parameter_list|,
name|high
parameter_list|)
name|struct
name|ieee_handle
modifier|*
name|info
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|bfd_vma
name|low
decl_stmt|;
name|bfd_vma
name|high
decl_stmt|;
block|{
name|int
name|kind
decl_stmt|;
if|if
condition|(
operator|!
name|ieee_buffer_emptyp
argument_list|(
operator|&
name|info
operator|->
name|vars
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|ieee_change_buffer
argument_list|(
name|info
argument_list|,
operator|&
name|info
operator|->
name|vars
argument_list|)
condition|)
return|return
name|false
return|;
block|}
else|else
block|{
specifier|const
name|char
modifier|*
name|filename
decl_stmt|,
modifier|*
name|modname
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_DOS_BASED_FILE_SYSTEM
specifier|const
name|char
modifier|*
name|backslash
decl_stmt|;
endif|#
directive|endif
name|char
modifier|*
name|c
decl_stmt|,
modifier|*
name|s
decl_stmt|;
comment|/* Start the enclosing BB10 block.  */
name|filename
operator|=
name|bfd_get_filename
argument_list|(
name|info
operator|->
name|abfd
argument_list|)
expr_stmt|;
name|modname
operator|=
name|strrchr
argument_list|(
name|filename
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_DOS_BASED_FILE_SYSTEM
name|backslash
operator|=
name|strrchr
argument_list|(
name|filename
argument_list|,
literal|'\\'
argument_list|)
expr_stmt|;
if|if
condition|(
name|modname
operator|==
name|NULL
operator|||
operator|(
name|backslash
operator|!=
name|NULL
operator|&&
name|backslash
operator|>
name|modname
operator|)
condition|)
name|modname
operator|=
name|backslash
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|modname
operator|!=
name|NULL
condition|)
operator|++
name|modname
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_DOS_BASED_FILE_SYSTEM
elseif|else
if|if
condition|(
name|filename
index|[
literal|0
index|]
operator|&&
name|filename
index|[
literal|1
index|]
operator|==
literal|':'
condition|)
name|modname
operator|=
name|filename
operator|+
literal|2
expr_stmt|;
endif|#
directive|endif
else|else
name|modname
operator|=
name|filename
expr_stmt|;
name|c
operator|=
name|xstrdup
argument_list|(
name|modname
argument_list|)
expr_stmt|;
name|s
operator|=
name|strrchr
argument_list|(
name|c
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
condition|)
operator|*
name|s
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|!
name|ieee_change_buffer
argument_list|(
name|info
argument_list|,
operator|&
name|info
operator|->
name|vars
argument_list|)
operator|||
operator|!
name|ieee_write_byte
argument_list|(
name|info
argument_list|,
operator|(
name|int
operator|)
name|ieee_bb_record_enum
argument_list|)
operator|||
operator|!
name|ieee_write_byte
argument_list|(
name|info
argument_list|,
literal|10
argument_list|)
operator|||
operator|!
name|ieee_write_number
argument_list|(
name|info
argument_list|,
literal|0
argument_list|)
operator|||
operator|!
name|ieee_write_id
argument_list|(
name|info
argument_list|,
name|c
argument_list|)
operator|||
operator|!
name|ieee_write_id
argument_list|(
name|info
argument_list|,
literal|""
argument_list|)
operator|||
operator|!
name|ieee_write_number
argument_list|(
name|info
argument_list|,
literal|0
argument_list|)
operator|||
operator|!
name|ieee_write_id
argument_list|(
name|info
argument_list|,
literal|"GNU objcopy"
argument_list|)
condition|)
return|return
name|false
return|;
name|free
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|sec
operator|->
name|flags
operator|&
name|SEC_CODE
operator|)
operator|!=
literal|0
condition|)
name|kind
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|sec
operator|->
name|flags
operator|&
name|SEC_READONLY
operator|)
operator|!=
literal|0
condition|)
name|kind
operator|=
literal|3
expr_stmt|;
else|else
name|kind
operator|=
literal|2
expr_stmt|;
if|if
condition|(
operator|!
name|ieee_write_byte
argument_list|(
name|info
argument_list|,
operator|(
name|int
operator|)
name|ieee_bb_record_enum
argument_list|)
operator|||
operator|!
name|ieee_write_byte
argument_list|(
name|info
argument_list|,
literal|11
argument_list|)
operator|||
operator|!
name|ieee_write_number
argument_list|(
name|info
argument_list|,
literal|0
argument_list|)
operator|||
operator|!
name|ieee_write_id
argument_list|(
name|info
argument_list|,
literal|""
argument_list|)
operator|||
operator|!
name|ieee_write_number
argument_list|(
name|info
argument_list|,
name|kind
argument_list|)
operator|||
operator|!
name|ieee_write_number
argument_list|(
name|info
argument_list|,
name|sec
operator|->
name|index
operator|+
name|IEEE_SECTION_NUMBER_BASE
argument_list|)
operator|||
operator|!
name|ieee_write_number
argument_list|(
name|info
argument_list|,
name|low
argument_list|)
operator|||
operator|!
name|ieee_write_byte
argument_list|(
name|info
argument_list|,
operator|(
name|int
operator|)
name|ieee_be_record_enum
argument_list|)
operator|||
operator|!
name|ieee_write_number
argument_list|(
name|info
argument_list|,
name|high
operator|-
name|low
argument_list|)
condition|)
return|return
name|false
return|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Start recording information from a particular source file.  This is    used to record which file defined which types, variables, etc.  It    is not used for line numbers, since the lineno entry point passes    down the file name anyhow.  IEEE debugging information doesn't seem    to store this information anywhere.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|boolean
name|ieee_start_source
parameter_list|(
name|p
parameter_list|,
name|filename
parameter_list|)
name|PTR
name|p
name|ATTRIBUTE_UNUSED
decl_stmt|;
specifier|const
name|char
modifier|*
name|filename
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Make an empty type.  */
end_comment

begin_function
specifier|static
name|boolean
name|ieee_empty_type
parameter_list|(
name|p
parameter_list|)
name|PTR
name|p
decl_stmt|;
block|{
name|struct
name|ieee_handle
modifier|*
name|info
init|=
operator|(
expr|struct
name|ieee_handle
operator|*
operator|)
name|p
decl_stmt|;
return|return
name|ieee_push_type
argument_list|(
name|info
argument_list|,
operator|(
name|int
operator|)
name|builtin_unknown
argument_list|,
literal|0
argument_list|,
name|false
argument_list|,
name|false
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Make a void type.  */
end_comment

begin_function
specifier|static
name|boolean
name|ieee_void_type
parameter_list|(
name|p
parameter_list|)
name|PTR
name|p
decl_stmt|;
block|{
name|struct
name|ieee_handle
modifier|*
name|info
init|=
operator|(
expr|struct
name|ieee_handle
operator|*
operator|)
name|p
decl_stmt|;
return|return
name|ieee_push_type
argument_list|(
name|info
argument_list|,
operator|(
name|int
operator|)
name|builtin_void
argument_list|,
literal|0
argument_list|,
name|false
argument_list|,
name|false
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Make an integer type.  */
end_comment

begin_function
specifier|static
name|boolean
name|ieee_int_type
parameter_list|(
name|p
parameter_list|,
name|size
parameter_list|,
name|unsignedp
parameter_list|)
name|PTR
name|p
decl_stmt|;
name|unsigned
name|int
name|size
decl_stmt|;
name|boolean
name|unsignedp
decl_stmt|;
block|{
name|struct
name|ieee_handle
modifier|*
name|info
init|=
operator|(
expr|struct
name|ieee_handle
operator|*
operator|)
name|p
decl_stmt|;
name|unsigned
name|int
name|indx
decl_stmt|;
switch|switch
condition|(
name|size
condition|)
block|{
case|case
literal|1
case|:
name|indx
operator|=
operator|(
name|int
operator|)
name|builtin_signed_char
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|indx
operator|=
operator|(
name|int
operator|)
name|builtin_signed_short_int
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|indx
operator|=
operator|(
name|int
operator|)
name|builtin_signed_long
expr_stmt|;
break|break;
case|case
literal|8
case|:
name|indx
operator|=
operator|(
name|int
operator|)
name|builtin_signed_long_long
expr_stmt|;
break|break;
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"IEEE unsupported integer type size %u\n"
argument_list|)
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
name|unsignedp
condition|)
operator|++
name|indx
expr_stmt|;
return|return
name|ieee_push_type
argument_list|(
name|info
argument_list|,
name|indx
argument_list|,
name|size
argument_list|,
name|unsignedp
argument_list|,
name|false
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Make a floating point type.  */
end_comment

begin_function
specifier|static
name|boolean
name|ieee_float_type
parameter_list|(
name|p
parameter_list|,
name|size
parameter_list|)
name|PTR
name|p
decl_stmt|;
name|unsigned
name|int
name|size
decl_stmt|;
block|{
name|struct
name|ieee_handle
modifier|*
name|info
init|=
operator|(
expr|struct
name|ieee_handle
operator|*
operator|)
name|p
decl_stmt|;
name|unsigned
name|int
name|indx
decl_stmt|;
switch|switch
condition|(
name|size
condition|)
block|{
case|case
literal|4
case|:
name|indx
operator|=
operator|(
name|int
operator|)
name|builtin_float
expr_stmt|;
break|break;
case|case
literal|8
case|:
name|indx
operator|=
operator|(
name|int
operator|)
name|builtin_double
expr_stmt|;
break|break;
case|case
literal|12
case|:
comment|/* FIXME: This size really depends upon the processor.  */
name|indx
operator|=
operator|(
name|int
operator|)
name|builtin_long_double
expr_stmt|;
break|break;
case|case
literal|16
case|:
name|indx
operator|=
operator|(
name|int
operator|)
name|builtin_long_long_double
expr_stmt|;
break|break;
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"IEEE unsupported float type size %u\n"
argument_list|)
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
return|return
name|ieee_push_type
argument_list|(
name|info
argument_list|,
name|indx
argument_list|,
name|size
argument_list|,
name|false
argument_list|,
name|false
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Make a complex type.  */
end_comment

begin_function
specifier|static
name|boolean
name|ieee_complex_type
parameter_list|(
name|p
parameter_list|,
name|size
parameter_list|)
name|PTR
name|p
decl_stmt|;
name|unsigned
name|int
name|size
decl_stmt|;
block|{
name|struct
name|ieee_handle
modifier|*
name|info
init|=
operator|(
expr|struct
name|ieee_handle
operator|*
operator|)
name|p
decl_stmt|;
name|char
name|code
decl_stmt|;
switch|switch
condition|(
name|size
condition|)
block|{
case|case
literal|4
case|:
if|if
condition|(
name|info
operator|->
name|complex_float_index
operator|!=
literal|0
condition|)
return|return
name|ieee_push_type
argument_list|(
name|info
argument_list|,
name|info
operator|->
name|complex_float_index
argument_list|,
name|size
operator|*
literal|2
argument_list|,
name|false
argument_list|,
name|false
argument_list|)
return|;
name|code
operator|=
literal|'c'
expr_stmt|;
break|break;
case|case
literal|12
case|:
case|case
literal|16
case|:
comment|/* These cases can be output by gcc -gstabs.  Outputting the          wrong type is better than crashing.  */
case|case
literal|8
case|:
if|if
condition|(
name|info
operator|->
name|complex_double_index
operator|!=
literal|0
condition|)
return|return
name|ieee_push_type
argument_list|(
name|info
argument_list|,
name|info
operator|->
name|complex_double_index
argument_list|,
name|size
operator|*
literal|2
argument_list|,
name|false
argument_list|,
name|false
argument_list|)
return|;
name|code
operator|=
literal|'d'
expr_stmt|;
break|break;
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"IEEE unsupported complex type size %u\n"
argument_list|)
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
comment|/* FIXME: I don't know what the string is for.  */
if|if
condition|(
operator|!
name|ieee_define_type
argument_list|(
name|info
argument_list|,
name|size
operator|*
literal|2
argument_list|,
name|false
argument_list|,
name|false
argument_list|)
operator|||
operator|!
name|ieee_write_number
argument_list|(
name|info
argument_list|,
name|code
argument_list|)
operator|||
operator|!
name|ieee_write_id
argument_list|(
name|info
argument_list|,
literal|""
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|size
operator|==
literal|4
condition|)
name|info
operator|->
name|complex_float_index
operator|=
name|info
operator|->
name|type_stack
operator|->
name|type
operator|.
name|indx
expr_stmt|;
else|else
name|info
operator|->
name|complex_double_index
operator|=
name|info
operator|->
name|type_stack
operator|->
name|type
operator|.
name|indx
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Make a boolean type.  IEEE doesn't support these, so we just make    an integer type instead.  */
end_comment

begin_function
specifier|static
name|boolean
name|ieee_bool_type
parameter_list|(
name|p
parameter_list|,
name|size
parameter_list|)
name|PTR
name|p
decl_stmt|;
name|unsigned
name|int
name|size
decl_stmt|;
block|{
return|return
name|ieee_int_type
argument_list|(
name|p
argument_list|,
name|size
argument_list|,
name|true
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Make an enumeration.  */
end_comment

begin_function
specifier|static
name|boolean
name|ieee_enum_type
parameter_list|(
name|p
parameter_list|,
name|tag
parameter_list|,
name|names
parameter_list|,
name|vals
parameter_list|)
name|PTR
name|p
decl_stmt|;
specifier|const
name|char
modifier|*
name|tag
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|names
decl_stmt|;
name|bfd_signed_vma
modifier|*
name|vals
decl_stmt|;
block|{
name|struct
name|ieee_handle
modifier|*
name|info
init|=
operator|(
expr|struct
name|ieee_handle
operator|*
operator|)
name|p
decl_stmt|;
name|struct
name|ieee_defined_enum
modifier|*
name|e
decl_stmt|;
name|boolean
name|localp
decl_stmt|,
name|simple
decl_stmt|;
name|unsigned
name|int
name|indx
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
name|localp
operator|=
name|false
expr_stmt|;
name|indx
operator|=
operator|(
name|unsigned
name|int
operator|)
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|e
operator|=
name|info
operator|->
name|enums
init|;
name|e
operator|!=
name|NULL
condition|;
name|e
operator|=
name|e
operator|->
name|next
control|)
block|{
if|if
condition|(
name|tag
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|e
operator|->
name|tag
operator|!=
name|NULL
condition|)
continue|continue;
block|}
else|else
block|{
if|if
condition|(
name|e
operator|->
name|tag
operator|==
name|NULL
operator|||
name|tag
index|[
literal|0
index|]
operator|!=
name|e
operator|->
name|tag
index|[
literal|0
index|]
operator|||
name|strcmp
argument_list|(
name|tag
argument_list|,
name|e
operator|->
name|tag
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
block|}
if|if
condition|(
operator|!
name|e
operator|->
name|defined
condition|)
block|{
comment|/* This enum tag has been seen but not defined.  */
name|indx
operator|=
name|e
operator|->
name|indx
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|names
operator|!=
name|NULL
operator|&&
name|e
operator|->
name|names
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|names
index|[
name|i
index|]
operator|!=
name|NULL
operator|&&
name|e
operator|->
name|names
index|[
name|i
index|]
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|names
index|[
name|i
index|]
index|[
literal|0
index|]
operator|!=
name|e
operator|->
name|names
index|[
name|i
index|]
index|[
literal|0
index|]
operator|||
name|vals
index|[
name|i
index|]
operator|!=
name|e
operator|->
name|vals
index|[
name|i
index|]
operator|||
name|strcmp
argument_list|(
name|names
index|[
name|i
index|]
argument_list|,
name|e
operator|->
name|names
index|[
name|i
index|]
argument_list|)
operator|!=
literal|0
condition|)
break|break;
block|}
block|}
if|if
condition|(
operator|(
name|names
operator|==
name|NULL
operator|&&
name|e
operator|->
name|names
operator|==
name|NULL
operator|)
operator|||
operator|(
name|names
operator|!=
name|NULL
operator|&&
name|e
operator|->
name|names
operator|!=
name|NULL
operator|&&
name|names
index|[
name|i
index|]
operator|==
name|NULL
operator|&&
name|e
operator|->
name|names
index|[
name|i
index|]
operator|==
name|NULL
operator|)
condition|)
block|{
comment|/* We've seen this enum before.  */
return|return
name|ieee_push_type
argument_list|(
name|info
argument_list|,
name|e
operator|->
name|indx
argument_list|,
literal|0
argument_list|,
name|true
argument_list|,
name|false
argument_list|)
return|;
block|}
if|if
condition|(
name|tag
operator|!=
name|NULL
condition|)
block|{
comment|/* We've already seen an enum of the same name, so we must make 	     sure to output this one locally.  */
name|localp
operator|=
name|true
expr_stmt|;
break|break;
block|}
block|}
comment|/* If this is a simple enumeration, in which the values start at 0      and always increment by 1, we can use type E.  Otherwise we must      use type N.  */
name|simple
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|names
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|names
index|[
name|i
index|]
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|vals
index|[
name|i
index|]
operator|!=
name|i
condition|)
block|{
name|simple
operator|=
name|false
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|ieee_define_named_type
argument_list|(
name|info
argument_list|,
name|tag
argument_list|,
name|indx
argument_list|,
literal|0
argument_list|,
name|true
argument_list|,
name|localp
argument_list|,
operator|(
expr|struct
name|ieee_buflist
operator|*
operator|)
name|NULL
argument_list|)
operator|||
operator|!
name|ieee_write_number
argument_list|(
name|info
argument_list|,
name|simple
condition|?
literal|'E'
else|:
literal|'N'
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|simple
condition|)
block|{
comment|/* FIXME: This is supposed to be the enumeration size, but we          don't store that.  */
if|if
condition|(
operator|!
name|ieee_write_number
argument_list|(
name|info
argument_list|,
literal|4
argument_list|)
condition|)
return|return
name|false
return|;
block|}
if|if
condition|(
name|names
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|names
index|[
name|i
index|]
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|ieee_write_id
argument_list|(
name|info
argument_list|,
name|names
index|[
name|i
index|]
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|!
name|simple
condition|)
block|{
if|if
condition|(
operator|!
name|ieee_write_number
argument_list|(
name|info
argument_list|,
name|vals
index|[
name|i
index|]
argument_list|)
condition|)
return|return
name|false
return|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|localp
condition|)
block|{
if|if
condition|(
name|indx
operator|==
operator|(
name|unsigned
name|int
operator|)
operator|-
literal|1
condition|)
block|{
name|e
operator|=
operator|(
expr|struct
name|ieee_defined_enum
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
expr|*
name|e
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|e
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
expr|*
name|e
argument_list|)
expr_stmt|;
name|e
operator|->
name|indx
operator|=
name|info
operator|->
name|type_stack
operator|->
name|type
operator|.
name|indx
expr_stmt|;
name|e
operator|->
name|tag
operator|=
name|tag
expr_stmt|;
name|e
operator|->
name|next
operator|=
name|info
operator|->
name|enums
expr_stmt|;
name|info
operator|->
name|enums
operator|=
name|e
expr_stmt|;
block|}
name|e
operator|->
name|names
operator|=
name|names
expr_stmt|;
name|e
operator|->
name|vals
operator|=
name|vals
expr_stmt|;
name|e
operator|->
name|defined
operator|=
name|true
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Make a pointer type.  */
end_comment

begin_function
specifier|static
name|boolean
name|ieee_pointer_type
parameter_list|(
name|p
parameter_list|)
name|PTR
name|p
decl_stmt|;
block|{
name|struct
name|ieee_handle
modifier|*
name|info
init|=
operator|(
expr|struct
name|ieee_handle
operator|*
operator|)
name|p
decl_stmt|;
name|boolean
name|localp
decl_stmt|;
name|unsigned
name|int
name|indx
decl_stmt|;
name|struct
name|ieee_modified_type
modifier|*
name|m
init|=
name|NULL
decl_stmt|;
name|localp
operator|=
name|info
operator|->
name|type_stack
operator|->
name|type
operator|.
name|localp
expr_stmt|;
name|indx
operator|=
name|ieee_pop_type
argument_list|(
name|info
argument_list|)
expr_stmt|;
comment|/* A pointer to a simple builtin type can be obtained by adding 32.      FIXME: Will this be a short pointer, and will that matter?  */
if|if
condition|(
name|indx
operator|<
literal|32
condition|)
return|return
name|ieee_push_type
argument_list|(
name|info
argument_list|,
name|indx
operator|+
literal|32
argument_list|,
literal|0
argument_list|,
name|true
argument_list|,
name|false
argument_list|)
return|;
if|if
condition|(
operator|!
name|localp
condition|)
block|{
name|m
operator|=
name|ieee_get_modified_info
argument_list|(
name|p
argument_list|,
name|indx
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return
name|false
return|;
comment|/* FIXME: The size should depend upon the architecture.  */
if|if
condition|(
name|m
operator|->
name|pointer
operator|>
literal|0
condition|)
return|return
name|ieee_push_type
argument_list|(
name|info
argument_list|,
name|m
operator|->
name|pointer
argument_list|,
literal|4
argument_list|,
name|true
argument_list|,
name|false
argument_list|)
return|;
block|}
if|if
condition|(
operator|!
name|ieee_define_type
argument_list|(
name|info
argument_list|,
literal|4
argument_list|,
name|true
argument_list|,
name|localp
argument_list|)
operator|||
operator|!
name|ieee_write_number
argument_list|(
name|info
argument_list|,
literal|'P'
argument_list|)
operator|||
operator|!
name|ieee_write_number
argument_list|(
name|info
argument_list|,
name|indx
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|!
name|localp
condition|)
name|m
operator|->
name|pointer
operator|=
name|info
operator|->
name|type_stack
operator|->
name|type
operator|.
name|indx
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Make a function type.  This will be called for a method, but we    don't want to actually add it to the type table in that case.  We    handle this by defining the type in a private buffer, and only    adding that buffer to the typedef block if we are going to use it.  */
end_comment

begin_function
specifier|static
name|boolean
name|ieee_function_type
parameter_list|(
name|p
parameter_list|,
name|argcount
parameter_list|,
name|varargs
parameter_list|)
name|PTR
name|p
decl_stmt|;
name|int
name|argcount
decl_stmt|;
name|boolean
name|varargs
decl_stmt|;
block|{
name|struct
name|ieee_handle
modifier|*
name|info
init|=
operator|(
expr|struct
name|ieee_handle
operator|*
operator|)
name|p
decl_stmt|;
name|boolean
name|localp
decl_stmt|;
name|unsigned
name|int
modifier|*
name|args
init|=
name|NULL
decl_stmt|;
name|int
name|i
decl_stmt|;
name|unsigned
name|int
name|retindx
decl_stmt|;
name|struct
name|ieee_buflist
name|fndef
decl_stmt|;
name|struct
name|ieee_modified_type
modifier|*
name|m
decl_stmt|;
name|localp
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|argcount
operator|>
literal|0
condition|)
block|{
name|args
operator|=
operator|(
name|unsigned
name|int
operator|*
operator|)
name|xmalloc
argument_list|(
name|argcount
operator|*
sizeof|sizeof
expr|*
name|args
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|argcount
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|info
operator|->
name|type_stack
operator|->
name|type
operator|.
name|localp
condition|)
name|localp
operator|=
name|true
expr_stmt|;
name|args
index|[
name|i
index|]
operator|=
name|ieee_pop_type
argument_list|(
name|info
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|argcount
operator|<
literal|0
condition|)
name|varargs
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|type_stack
operator|->
name|type
operator|.
name|localp
condition|)
name|localp
operator|=
name|true
expr_stmt|;
name|retindx
operator|=
name|ieee_pop_type
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|m
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|argcount
operator|<
literal|0
operator|&&
operator|!
name|localp
condition|)
block|{
name|m
operator|=
name|ieee_get_modified_info
argument_list|(
name|p
argument_list|,
name|retindx
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return
name|false
return|;
if|if
condition|(
name|m
operator|->
name|function
operator|>
literal|0
condition|)
return|return
name|ieee_push_type
argument_list|(
name|info
argument_list|,
name|m
operator|->
name|function
argument_list|,
literal|0
argument_list|,
name|true
argument_list|,
name|false
argument_list|)
return|;
block|}
comment|/* An attribute of 0x41 means that the frame and push mask are      unknown.  */
if|if
condition|(
operator|!
name|ieee_init_buffer
argument_list|(
name|info
argument_list|,
operator|&
name|fndef
argument_list|)
operator|||
operator|!
name|ieee_define_named_type
argument_list|(
name|info
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|unsigned
name|int
operator|)
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
name|true
argument_list|,
name|localp
argument_list|,
operator|&
name|fndef
argument_list|)
operator|||
operator|!
name|ieee_write_number
argument_list|(
name|info
argument_list|,
literal|'x'
argument_list|)
operator|||
operator|!
name|ieee_write_number
argument_list|(
name|info
argument_list|,
literal|0x41
argument_list|)
operator|||
operator|!
name|ieee_write_number
argument_list|(
name|info
argument_list|,
literal|0
argument_list|)
operator|||
operator|!
name|ieee_write_number
argument_list|(
name|info
argument_list|,
literal|0
argument_list|)
operator|||
operator|!
name|ieee_write_number
argument_list|(
name|info
argument_list|,
name|retindx
argument_list|)
operator|||
operator|!
name|ieee_write_number
argument_list|(
name|info
argument_list|,
operator|(
name|bfd_vma
operator|)
name|argcount
operator|+
operator|(
name|varargs
condition|?
literal|1
else|:
literal|0
operator|)
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|argcount
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|argcount
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|ieee_write_number
argument_list|(
name|info
argument_list|,
name|args
index|[
name|i
index|]
argument_list|)
condition|)
return|return
name|false
return|;
name|free
argument_list|(
name|args
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|varargs
condition|)
block|{
comment|/* A varargs function is represented by writing out the last          argument as type void *, although this makes little sense.  */
if|if
condition|(
operator|!
name|ieee_write_number
argument_list|(
name|info
argument_list|,
operator|(
name|bfd_vma
operator|)
name|builtin_void
operator|+
literal|32
argument_list|)
condition|)
return|return
name|false
return|;
block|}
if|if
condition|(
operator|!
name|ieee_write_number
argument_list|(
name|info
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* We wrote the information into fndef, in case we don't need it.      It will be appended to info->types by ieee_pop_type.  */
name|info
operator|->
name|type_stack
operator|->
name|type
operator|.
name|fndef
operator|=
name|fndef
expr_stmt|;
if|if
condition|(
name|m
operator|!=
name|NULL
condition|)
name|m
operator|->
name|function
operator|=
name|info
operator|->
name|type_stack
operator|->
name|type
operator|.
name|indx
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Make a reference type.  */
end_comment

begin_function
specifier|static
name|boolean
name|ieee_reference_type
parameter_list|(
name|p
parameter_list|)
name|PTR
name|p
decl_stmt|;
block|{
name|struct
name|ieee_handle
modifier|*
name|info
init|=
operator|(
expr|struct
name|ieee_handle
operator|*
operator|)
name|p
decl_stmt|;
comment|/* IEEE appears to record a normal pointer type, and then use a      pmisc record to indicate that it is really a reference.  */
if|if
condition|(
operator|!
name|ieee_pointer_type
argument_list|(
name|p
argument_list|)
condition|)
return|return
name|false
return|;
name|info
operator|->
name|type_stack
operator|->
name|type
operator|.
name|referencep
operator|=
name|true
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Make a range type.  */
end_comment

begin_function
specifier|static
name|boolean
name|ieee_range_type
parameter_list|(
name|p
parameter_list|,
name|low
parameter_list|,
name|high
parameter_list|)
name|PTR
name|p
decl_stmt|;
name|bfd_signed_vma
name|low
decl_stmt|;
name|bfd_signed_vma
name|high
decl_stmt|;
block|{
name|struct
name|ieee_handle
modifier|*
name|info
init|=
operator|(
expr|struct
name|ieee_handle
operator|*
operator|)
name|p
decl_stmt|;
name|unsigned
name|int
name|size
decl_stmt|;
name|boolean
name|unsignedp
decl_stmt|,
name|localp
decl_stmt|;
name|size
operator|=
name|info
operator|->
name|type_stack
operator|->
name|type
operator|.
name|size
expr_stmt|;
name|unsignedp
operator|=
name|info
operator|->
name|type_stack
operator|->
name|type
operator|.
name|unsignedp
expr_stmt|;
name|localp
operator|=
name|info
operator|->
name|type_stack
operator|->
name|type
operator|.
name|localp
expr_stmt|;
name|ieee_pop_unused_type
argument_list|(
name|info
argument_list|)
expr_stmt|;
return|return
operator|(
name|ieee_define_type
argument_list|(
name|info
argument_list|,
name|size
argument_list|,
name|unsignedp
argument_list|,
name|localp
argument_list|)
operator|&&
name|ieee_write_number
argument_list|(
name|info
argument_list|,
literal|'R'
argument_list|)
operator|&&
name|ieee_write_number
argument_list|(
name|info
argument_list|,
operator|(
name|bfd_vma
operator|)
name|low
argument_list|)
operator|&&
name|ieee_write_number
argument_list|(
name|info
argument_list|,
operator|(
name|bfd_vma
operator|)
name|high
argument_list|)
operator|&&
name|ieee_write_number
argument_list|(
name|info
argument_list|,
name|unsignedp
condition|?
literal|0
else|:
literal|1
argument_list|)
operator|&&
name|ieee_write_number
argument_list|(
name|info
argument_list|,
name|size
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Make an array type.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|boolean
name|ieee_array_type
parameter_list|(
name|p
parameter_list|,
name|low
parameter_list|,
name|high
parameter_list|,
name|stringp
parameter_list|)
name|PTR
name|p
decl_stmt|;
name|bfd_signed_vma
name|low
decl_stmt|;
name|bfd_signed_vma
name|high
decl_stmt|;
name|boolean
name|stringp
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|struct
name|ieee_handle
modifier|*
name|info
init|=
operator|(
expr|struct
name|ieee_handle
operator|*
operator|)
name|p
decl_stmt|;
name|unsigned
name|int
name|eleindx
decl_stmt|;
name|boolean
name|localp
decl_stmt|;
name|unsigned
name|int
name|size
decl_stmt|;
name|struct
name|ieee_modified_type
modifier|*
name|m
init|=
name|NULL
decl_stmt|;
name|struct
name|ieee_modified_array_type
modifier|*
name|a
decl_stmt|;
comment|/* IEEE does not store the range, so we just ignore it.  */
name|ieee_pop_unused_type
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|localp
operator|=
name|info
operator|->
name|type_stack
operator|->
name|type
operator|.
name|localp
expr_stmt|;
name|size
operator|=
name|info
operator|->
name|type_stack
operator|->
name|type
operator|.
name|size
expr_stmt|;
name|eleindx
operator|=
name|ieee_pop_type
argument_list|(
name|info
argument_list|)
expr_stmt|;
comment|/* If we don't know the range, treat the size as exactly one      element.  */
if|if
condition|(
name|low
operator|<
name|high
condition|)
name|size
operator|*=
operator|(
name|high
operator|-
name|low
operator|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|localp
condition|)
block|{
name|m
operator|=
name|ieee_get_modified_info
argument_list|(
name|info
argument_list|,
name|eleindx
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return
name|false
return|;
for|for
control|(
name|a
operator|=
name|m
operator|->
name|arrays
init|;
name|a
operator|!=
name|NULL
condition|;
name|a
operator|=
name|a
operator|->
name|next
control|)
block|{
if|if
condition|(
name|a
operator|->
name|low
operator|==
name|low
operator|&&
name|a
operator|->
name|high
operator|==
name|high
condition|)
return|return
name|ieee_push_type
argument_list|(
name|info
argument_list|,
name|a
operator|->
name|indx
argument_list|,
name|size
argument_list|,
name|false
argument_list|,
name|false
argument_list|)
return|;
block|}
block|}
if|if
condition|(
operator|!
name|ieee_define_type
argument_list|(
name|info
argument_list|,
name|size
argument_list|,
name|false
argument_list|,
name|localp
argument_list|)
operator|||
operator|!
name|ieee_write_number
argument_list|(
name|info
argument_list|,
name|low
operator|==
literal|0
condition|?
literal|'Z'
else|:
literal|'C'
argument_list|)
operator|||
operator|!
name|ieee_write_number
argument_list|(
name|info
argument_list|,
name|eleindx
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|low
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|ieee_write_number
argument_list|(
name|info
argument_list|,
name|low
argument_list|)
condition|)
return|return
name|false
return|;
block|}
if|if
condition|(
operator|!
name|ieee_write_number
argument_list|(
name|info
argument_list|,
name|high
operator|+
literal|1
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|!
name|localp
condition|)
block|{
name|a
operator|=
operator|(
expr|struct
name|ieee_modified_array_type
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
expr|*
name|a
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|a
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
expr|*
name|a
argument_list|)
expr_stmt|;
name|a
operator|->
name|indx
operator|=
name|info
operator|->
name|type_stack
operator|->
name|type
operator|.
name|indx
expr_stmt|;
name|a
operator|->
name|low
operator|=
name|low
expr_stmt|;
name|a
operator|->
name|high
operator|=
name|high
expr_stmt|;
name|a
operator|->
name|next
operator|=
name|m
operator|->
name|arrays
expr_stmt|;
name|m
operator|->
name|arrays
operator|=
name|a
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Make a set type.  */
end_comment

begin_function
specifier|static
name|boolean
name|ieee_set_type
parameter_list|(
name|p
parameter_list|,
name|bitstringp
parameter_list|)
name|PTR
name|p
decl_stmt|;
name|boolean
name|bitstringp
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|struct
name|ieee_handle
modifier|*
name|info
init|=
operator|(
expr|struct
name|ieee_handle
operator|*
operator|)
name|p
decl_stmt|;
name|boolean
name|localp
decl_stmt|;
name|unsigned
name|int
name|eleindx
decl_stmt|;
name|localp
operator|=
name|info
operator|->
name|type_stack
operator|->
name|type
operator|.
name|localp
expr_stmt|;
name|eleindx
operator|=
name|ieee_pop_type
argument_list|(
name|info
argument_list|)
expr_stmt|;
comment|/* FIXME: We don't know the size, so we just use 4.  */
return|return
operator|(
name|ieee_define_type
argument_list|(
name|info
argument_list|,
literal|0
argument_list|,
name|true
argument_list|,
name|localp
argument_list|)
operator|&&
name|ieee_write_number
argument_list|(
name|info
argument_list|,
literal|'s'
argument_list|)
operator|&&
name|ieee_write_number
argument_list|(
name|info
argument_list|,
literal|4
argument_list|)
operator|&&
name|ieee_write_number
argument_list|(
name|info
argument_list|,
name|eleindx
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Make an offset type.  */
end_comment

begin_function
specifier|static
name|boolean
name|ieee_offset_type
parameter_list|(
name|p
parameter_list|)
name|PTR
name|p
decl_stmt|;
block|{
name|struct
name|ieee_handle
modifier|*
name|info
init|=
operator|(
expr|struct
name|ieee_handle
operator|*
operator|)
name|p
decl_stmt|;
name|unsigned
name|int
name|targetindx
decl_stmt|,
name|baseindx
decl_stmt|;
name|targetindx
operator|=
name|ieee_pop_type
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|baseindx
operator|=
name|ieee_pop_type
argument_list|(
name|info
argument_list|)
expr_stmt|;
comment|/* FIXME: The MRI C++ compiler does not appear to generate any      useful type information about an offset type.  It just records a      pointer to member as an integer.  The MRI/HP IEEE spec does      describe a pmisc record which can be used for a pointer to      member.  Unfortunately, it does not describe the target type,      which seems pretty important.  I'm going to punt this for now.  */
return|return
name|ieee_int_type
argument_list|(
name|p
argument_list|,
literal|4
argument_list|,
name|true
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Make a method type.  */
end_comment

begin_function
specifier|static
name|boolean
name|ieee_method_type
parameter_list|(
name|p
parameter_list|,
name|domain
parameter_list|,
name|argcount
parameter_list|,
name|varargs
parameter_list|)
name|PTR
name|p
decl_stmt|;
name|boolean
name|domain
decl_stmt|;
name|int
name|argcount
decl_stmt|;
name|boolean
name|varargs
decl_stmt|;
block|{
name|struct
name|ieee_handle
modifier|*
name|info
init|=
operator|(
expr|struct
name|ieee_handle
operator|*
operator|)
name|p
decl_stmt|;
comment|/* FIXME: The MRI/HP IEEE spec defines a pmisc record to use for a      method, but the definition is incomplete.  We just output an 'x'      type.  */
if|if
condition|(
name|domain
condition|)
name|ieee_pop_unused_type
argument_list|(
name|info
argument_list|)
expr_stmt|;
return|return
name|ieee_function_type
argument_list|(
name|p
argument_list|,
name|argcount
argument_list|,
name|varargs
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Make a const qualified type.  */
end_comment

begin_function
specifier|static
name|boolean
name|ieee_const_type
parameter_list|(
name|p
parameter_list|)
name|PTR
name|p
decl_stmt|;
block|{
name|struct
name|ieee_handle
modifier|*
name|info
init|=
operator|(
expr|struct
name|ieee_handle
operator|*
operator|)
name|p
decl_stmt|;
name|unsigned
name|int
name|size
decl_stmt|;
name|boolean
name|unsignedp
decl_stmt|,
name|localp
decl_stmt|;
name|unsigned
name|int
name|indx
decl_stmt|;
name|struct
name|ieee_modified_type
modifier|*
name|m
init|=
name|NULL
decl_stmt|;
name|size
operator|=
name|info
operator|->
name|type_stack
operator|->
name|type
operator|.
name|size
expr_stmt|;
name|unsignedp
operator|=
name|info
operator|->
name|type_stack
operator|->
name|type
operator|.
name|unsignedp
expr_stmt|;
name|localp
operator|=
name|info
operator|->
name|type_stack
operator|->
name|type
operator|.
name|localp
expr_stmt|;
name|indx
operator|=
name|ieee_pop_type
argument_list|(
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|localp
condition|)
block|{
name|m
operator|=
name|ieee_get_modified_info
argument_list|(
name|info
argument_list|,
name|indx
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return
name|false
return|;
if|if
condition|(
name|m
operator|->
name|const_qualified
operator|>
literal|0
condition|)
return|return
name|ieee_push_type
argument_list|(
name|info
argument_list|,
name|m
operator|->
name|const_qualified
argument_list|,
name|size
argument_list|,
name|unsignedp
argument_list|,
name|false
argument_list|)
return|;
block|}
if|if
condition|(
operator|!
name|ieee_define_type
argument_list|(
name|info
argument_list|,
name|size
argument_list|,
name|unsignedp
argument_list|,
name|localp
argument_list|)
operator|||
operator|!
name|ieee_write_number
argument_list|(
name|info
argument_list|,
literal|'n'
argument_list|)
operator|||
operator|!
name|ieee_write_number
argument_list|(
name|info
argument_list|,
literal|1
argument_list|)
operator|||
operator|!
name|ieee_write_number
argument_list|(
name|info
argument_list|,
name|indx
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|!
name|localp
condition|)
name|m
operator|->
name|const_qualified
operator|=
name|info
operator|->
name|type_stack
operator|->
name|type
operator|.
name|indx
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Make a volatile qualified type.  */
end_comment

begin_function
specifier|static
name|boolean
name|ieee_volatile_type
parameter_list|(
name|p
parameter_list|)
name|PTR
name|p
decl_stmt|;
block|{
name|struct
name|ieee_handle
modifier|*
name|info
init|=
operator|(
expr|struct
name|ieee_handle
operator|*
operator|)
name|p
decl_stmt|;
name|unsigned
name|int
name|size
decl_stmt|;
name|boolean
name|unsignedp
decl_stmt|,
name|localp
decl_stmt|;
name|unsigned
name|int
name|indx
decl_stmt|;
name|struct
name|ieee_modified_type
modifier|*
name|m
init|=
name|NULL
decl_stmt|;
name|size
operator|=
name|info
operator|->
name|type_stack
operator|->
name|type
operator|.
name|size
expr_stmt|;
name|unsignedp
operator|=
name|info
operator|->
name|type_stack
operator|->
name|type
operator|.
name|unsignedp
expr_stmt|;
name|localp
operator|=
name|info
operator|->
name|type_stack
operator|->
name|type
operator|.
name|localp
expr_stmt|;
name|indx
operator|=
name|ieee_pop_type
argument_list|(
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|localp
condition|)
block|{
name|m
operator|=
name|ieee_get_modified_info
argument_list|(
name|info
argument_list|,
name|indx
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return
name|false
return|;
if|if
condition|(
name|m
operator|->
name|volatile_qualified
operator|>
literal|0
condition|)
return|return
name|ieee_push_type
argument_list|(
name|info
argument_list|,
name|m
operator|->
name|volatile_qualified
argument_list|,
name|size
argument_list|,
name|unsignedp
argument_list|,
name|false
argument_list|)
return|;
block|}
if|if
condition|(
operator|!
name|ieee_define_type
argument_list|(
name|info
argument_list|,
name|size
argument_list|,
name|unsignedp
argument_list|,
name|localp
argument_list|)
operator|||
operator|!
name|ieee_write_number
argument_list|(
name|info
argument_list|,
literal|'n'
argument_list|)
operator|||
operator|!
name|ieee_write_number
argument_list|(
name|info
argument_list|,
literal|2
argument_list|)
operator|||
operator|!
name|ieee_write_number
argument_list|(
name|info
argument_list|,
name|indx
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|!
name|localp
condition|)
name|m
operator|->
name|volatile_qualified
operator|=
name|info
operator|->
name|type_stack
operator|->
name|type
operator|.
name|indx
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Convert an enum debug_visibility into a CXXFLAGS value.  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|ieee_vis_to_flags
parameter_list|(
name|visibility
parameter_list|)
name|enum
name|debug_visibility
name|visibility
decl_stmt|;
block|{
switch|switch
condition|(
name|visibility
condition|)
block|{
default|default:
name|abort
argument_list|()
expr_stmt|;
case|case
name|DEBUG_VISIBILITY_PUBLIC
case|:
return|return
name|CXXFLAGS_VISIBILITY_PUBLIC
return|;
case|case
name|DEBUG_VISIBILITY_PRIVATE
case|:
return|return
name|CXXFLAGS_VISIBILITY_PRIVATE
return|;
case|case
name|DEBUG_VISIBILITY_PROTECTED
case|:
return|return
name|CXXFLAGS_VISIBILITY_PROTECTED
return|;
block|}
comment|/*NOTREACHED*/
block|}
end_function

begin_comment
comment|/* Start defining a struct type.  We build it in the strdef field on    the stack, to avoid confusing type definitions required by the    fields with the struct type itself.  */
end_comment

begin_function
specifier|static
name|boolean
name|ieee_start_struct_type
parameter_list|(
name|p
parameter_list|,
name|tag
parameter_list|,
name|id
parameter_list|,
name|structp
parameter_list|,
name|size
parameter_list|)
name|PTR
name|p
decl_stmt|;
specifier|const
name|char
modifier|*
name|tag
decl_stmt|;
name|unsigned
name|int
name|id
decl_stmt|;
name|boolean
name|structp
decl_stmt|;
name|unsigned
name|int
name|size
decl_stmt|;
block|{
name|struct
name|ieee_handle
modifier|*
name|info
init|=
operator|(
expr|struct
name|ieee_handle
operator|*
operator|)
name|p
decl_stmt|;
name|boolean
name|localp
decl_stmt|,
name|ignorep
decl_stmt|;
name|boolean
name|copy
decl_stmt|;
name|char
name|ab
index|[
literal|20
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|look
decl_stmt|;
name|struct
name|ieee_name_type_hash_entry
modifier|*
name|h
decl_stmt|;
name|struct
name|ieee_name_type
modifier|*
name|nt
decl_stmt|,
modifier|*
name|ntlook
decl_stmt|;
name|struct
name|ieee_buflist
name|strdef
decl_stmt|;
name|localp
operator|=
name|false
expr_stmt|;
name|ignorep
operator|=
name|false
expr_stmt|;
comment|/* We need to create a tag for internal use even if we don't want      one for external use.  This will let us refer to an anonymous      struct.  */
if|if
condition|(
name|tag
operator|!=
name|NULL
condition|)
block|{
name|look
operator|=
name|tag
expr_stmt|;
name|copy
operator|=
name|false
expr_stmt|;
block|}
else|else
block|{
name|sprintf
argument_list|(
name|ab
argument_list|,
literal|"__anon%u"
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|look
operator|=
name|ab
expr_stmt|;
name|copy
operator|=
name|true
expr_stmt|;
block|}
comment|/* If we already have references to the tag, we must use the      existing type index.  */
name|h
operator|=
name|ieee_name_type_hash_lookup
argument_list|(
operator|&
name|info
operator|->
name|tags
argument_list|,
name|look
argument_list|,
name|true
argument_list|,
name|copy
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|==
name|NULL
condition|)
return|return
name|false
return|;
name|nt
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|ntlook
operator|=
name|h
operator|->
name|types
init|;
name|ntlook
operator|!=
name|NULL
condition|;
name|ntlook
operator|=
name|ntlook
operator|->
name|next
control|)
block|{
if|if
condition|(
name|ntlook
operator|->
name|id
operator|==
name|id
condition|)
name|nt
operator|=
name|ntlook
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|ntlook
operator|->
name|type
operator|.
name|localp
condition|)
block|{
comment|/* We are creating a duplicate definition of a globally 	     defined tag.  Force it to be local to avoid 	     confusion.  */
name|localp
operator|=
name|true
expr_stmt|;
block|}
block|}
if|if
condition|(
name|nt
operator|!=
name|NULL
condition|)
block|{
name|assert
argument_list|(
name|localp
operator|==
name|nt
operator|->
name|type
operator|.
name|localp
argument_list|)
expr_stmt|;
if|if
condition|(
name|nt
operator|->
name|kind
operator|==
name|DEBUG_KIND_ILLEGAL
operator|&&
operator|!
name|localp
condition|)
block|{
comment|/* We've already seen a global definition of the type.              Ignore this new definition.  */
name|ignorep
operator|=
name|true
expr_stmt|;
block|}
block|}
else|else
block|{
name|nt
operator|=
operator|(
expr|struct
name|ieee_name_type
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
expr|*
name|nt
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|nt
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
expr|*
name|nt
argument_list|)
expr_stmt|;
name|nt
operator|->
name|id
operator|=
name|id
expr_stmt|;
name|nt
operator|->
name|type
operator|.
name|name
operator|=
name|h
operator|->
name|root
operator|.
name|string
expr_stmt|;
name|nt
operator|->
name|next
operator|=
name|h
operator|->
name|types
expr_stmt|;
name|h
operator|->
name|types
operator|=
name|nt
expr_stmt|;
name|nt
operator|->
name|type
operator|.
name|indx
operator|=
name|info
operator|->
name|type_indx
expr_stmt|;
operator|++
name|info
operator|->
name|type_indx
expr_stmt|;
block|}
name|nt
operator|->
name|kind
operator|=
name|DEBUG_KIND_ILLEGAL
expr_stmt|;
if|if
condition|(
operator|!
name|ieee_init_buffer
argument_list|(
name|info
argument_list|,
operator|&
name|strdef
argument_list|)
operator|||
operator|!
name|ieee_define_named_type
argument_list|(
name|info
argument_list|,
name|tag
argument_list|,
name|nt
operator|->
name|type
operator|.
name|indx
argument_list|,
name|size
argument_list|,
name|true
argument_list|,
name|localp
argument_list|,
operator|&
name|strdef
argument_list|)
operator|||
operator|!
name|ieee_write_number
argument_list|(
name|info
argument_list|,
name|structp
condition|?
literal|'S'
else|:
literal|'U'
argument_list|)
operator|||
operator|!
name|ieee_write_number
argument_list|(
name|info
argument_list|,
name|size
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|!
name|ignorep
condition|)
block|{
specifier|const
name|char
modifier|*
name|hold
decl_stmt|;
comment|/* We never want nt->type.name to be NULL.  We want the rest of 	 the type to be the object set up on the type stack; it will 	 have a NULL name if tag is NULL.  */
name|hold
operator|=
name|nt
operator|->
name|type
operator|.
name|name
expr_stmt|;
name|nt
operator|->
name|type
operator|=
name|info
operator|->
name|type_stack
operator|->
name|type
expr_stmt|;
name|nt
operator|->
name|type
operator|.
name|name
operator|=
name|hold
expr_stmt|;
block|}
name|info
operator|->
name|type_stack
operator|->
name|type
operator|.
name|name
operator|=
name|tag
expr_stmt|;
name|info
operator|->
name|type_stack
operator|->
name|type
operator|.
name|strdef
operator|=
name|strdef
expr_stmt|;
name|info
operator|->
name|type_stack
operator|->
name|type
operator|.
name|ignorep
operator|=
name|ignorep
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Add a field to a struct.  */
end_comment

begin_function
specifier|static
name|boolean
name|ieee_struct_field
parameter_list|(
name|p
parameter_list|,
name|name
parameter_list|,
name|bitpos
parameter_list|,
name|bitsize
parameter_list|,
name|visibility
parameter_list|)
name|PTR
name|p
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|bfd_vma
name|bitpos
decl_stmt|;
name|bfd_vma
name|bitsize
decl_stmt|;
name|enum
name|debug_visibility
name|visibility
decl_stmt|;
block|{
name|struct
name|ieee_handle
modifier|*
name|info
init|=
operator|(
expr|struct
name|ieee_handle
operator|*
operator|)
name|p
decl_stmt|;
name|unsigned
name|int
name|size
decl_stmt|;
name|boolean
name|unsignedp
decl_stmt|;
name|boolean
name|referencep
decl_stmt|;
name|boolean
name|localp
decl_stmt|;
name|unsigned
name|int
name|indx
decl_stmt|;
name|bfd_vma
name|offset
decl_stmt|;
name|assert
argument_list|(
name|info
operator|->
name|type_stack
operator|!=
name|NULL
operator|&&
name|info
operator|->
name|type_stack
operator|->
name|next
operator|!=
name|NULL
operator|&&
operator|!
name|ieee_buffer_emptyp
argument_list|(
operator|&
name|info
operator|->
name|type_stack
operator|->
name|next
operator|->
name|type
operator|.
name|strdef
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If we are ignoring this struct definition, just pop and ignore      the type.  */
if|if
condition|(
name|info
operator|->
name|type_stack
operator|->
name|next
operator|->
name|type
operator|.
name|ignorep
condition|)
block|{
name|ieee_pop_unused_type
argument_list|(
name|info
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
name|size
operator|=
name|info
operator|->
name|type_stack
operator|->
name|type
operator|.
name|size
expr_stmt|;
name|unsignedp
operator|=
name|info
operator|->
name|type_stack
operator|->
name|type
operator|.
name|unsignedp
expr_stmt|;
name|referencep
operator|=
name|info
operator|->
name|type_stack
operator|->
name|type
operator|.
name|referencep
expr_stmt|;
name|localp
operator|=
name|info
operator|->
name|type_stack
operator|->
name|type
operator|.
name|localp
expr_stmt|;
name|indx
operator|=
name|ieee_pop_type
argument_list|(
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|localp
condition|)
name|info
operator|->
name|type_stack
operator|->
name|type
operator|.
name|localp
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|type_stack
operator|->
name|type
operator|.
name|classdef
operator|!=
name|NULL
condition|)
block|{
name|unsigned
name|int
name|flags
decl_stmt|;
name|unsigned
name|int
name|nindx
decl_stmt|;
comment|/* This is a class.  We must add a description of this field to          the class records we are building.  */
name|flags
operator|=
name|ieee_vis_to_flags
argument_list|(
name|visibility
argument_list|)
expr_stmt|;
name|nindx
operator|=
name|info
operator|->
name|type_stack
operator|->
name|type
operator|.
name|classdef
operator|->
name|indx
expr_stmt|;
if|if
condition|(
operator|!
name|ieee_change_buffer
argument_list|(
name|info
argument_list|,
operator|&
name|info
operator|->
name|type_stack
operator|->
name|type
operator|.
name|classdef
operator|->
name|pmiscbuf
argument_list|)
operator|||
operator|!
name|ieee_write_asn
argument_list|(
name|info
argument_list|,
name|nindx
argument_list|,
literal|'d'
argument_list|)
operator|||
operator|!
name|ieee_write_asn
argument_list|(
name|info
argument_list|,
name|nindx
argument_list|,
name|flags
argument_list|)
operator|||
operator|!
name|ieee_write_atn65
argument_list|(
name|info
argument_list|,
name|nindx
argument_list|,
name|name
argument_list|)
operator|||
operator|!
name|ieee_write_atn65
argument_list|(
name|info
argument_list|,
name|nindx
argument_list|,
name|name
argument_list|)
condition|)
return|return
name|false
return|;
name|info
operator|->
name|type_stack
operator|->
name|type
operator|.
name|classdef
operator|->
name|pmisccount
operator|+=
literal|4
expr_stmt|;
if|if
condition|(
name|referencep
condition|)
block|{
name|unsigned
name|int
name|nindx
decl_stmt|;
comment|/* We need to output a record recording that this field is              really of reference type.  We put this on the refs field              of classdef, so that it can be appended to the C++              records after the class is defined.  */
name|nindx
operator|=
name|info
operator|->
name|name_indx
expr_stmt|;
operator|++
name|info
operator|->
name|name_indx
expr_stmt|;
if|if
condition|(
operator|!
name|ieee_change_buffer
argument_list|(
name|info
argument_list|,
operator|&
name|info
operator|->
name|type_stack
operator|->
name|type
operator|.
name|classdef
operator|->
name|refs
argument_list|)
operator|||
operator|!
name|ieee_write_byte
argument_list|(
name|info
argument_list|,
operator|(
name|int
operator|)
name|ieee_nn_record
argument_list|)
operator|||
operator|!
name|ieee_write_number
argument_list|(
name|info
argument_list|,
name|nindx
argument_list|)
operator|||
operator|!
name|ieee_write_id
argument_list|(
name|info
argument_list|,
literal|""
argument_list|)
operator|||
operator|!
name|ieee_write_2bytes
argument_list|(
name|info
argument_list|,
operator|(
name|int
operator|)
name|ieee_atn_record_enum
argument_list|)
operator|||
operator|!
name|ieee_write_number
argument_list|(
name|info
argument_list|,
name|nindx
argument_list|)
operator|||
operator|!
name|ieee_write_number
argument_list|(
name|info
argument_list|,
literal|0
argument_list|)
operator|||
operator|!
name|ieee_write_number
argument_list|(
name|info
argument_list|,
literal|62
argument_list|)
operator|||
operator|!
name|ieee_write_number
argument_list|(
name|info
argument_list|,
literal|80
argument_list|)
operator|||
operator|!
name|ieee_write_number
argument_list|(
name|info
argument_list|,
literal|4
argument_list|)
operator|||
operator|!
name|ieee_write_asn
argument_list|(
name|info
argument_list|,
name|nindx
argument_list|,
literal|'R'
argument_list|)
operator|||
operator|!
name|ieee_write_asn
argument_list|(
name|info
argument_list|,
name|nindx
argument_list|,
literal|3
argument_list|)
operator|||
operator|!
name|ieee_write_atn65
argument_list|(
name|info
argument_list|,
name|nindx
argument_list|,
name|info
operator|->
name|type_stack
operator|->
name|type
operator|.
name|name
argument_list|)
operator|||
operator|!
name|ieee_write_atn65
argument_list|(
name|info
argument_list|,
name|nindx
argument_list|,
name|name
argument_list|)
condition|)
return|return
name|false
return|;
block|}
block|}
comment|/* If the bitsize doesn't match the expected size, we need to output      a bitfield type.  */
if|if
condition|(
name|size
operator|==
literal|0
operator|||
name|bitsize
operator|==
literal|0
operator|||
name|bitsize
operator|==
name|size
operator|*
literal|8
condition|)
name|offset
operator|=
name|bitpos
operator|/
literal|8
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|!
name|ieee_define_type
argument_list|(
name|info
argument_list|,
literal|0
argument_list|,
name|unsignedp
argument_list|,
name|info
operator|->
name|type_stack
operator|->
name|type
operator|.
name|localp
argument_list|)
operator|||
operator|!
name|ieee_write_number
argument_list|(
name|info
argument_list|,
literal|'g'
argument_list|)
operator|||
operator|!
name|ieee_write_number
argument_list|(
name|info
argument_list|,
name|unsignedp
condition|?
literal|0
else|:
literal|1
argument_list|)
operator|||
operator|!
name|ieee_write_number
argument_list|(
name|info
argument_list|,
name|bitsize
argument_list|)
operator|||
operator|!
name|ieee_write_number
argument_list|(
name|info
argument_list|,
name|indx
argument_list|)
condition|)
return|return
name|false
return|;
name|indx
operator|=
name|ieee_pop_type
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|offset
operator|=
name|bitpos
expr_stmt|;
block|}
comment|/* Switch to the struct we are building in order to output this      field definition.  */
return|return
operator|(
name|ieee_change_buffer
argument_list|(
name|info
argument_list|,
operator|&
name|info
operator|->
name|type_stack
operator|->
name|type
operator|.
name|strdef
argument_list|)
operator|&&
name|ieee_write_id
argument_list|(
name|info
argument_list|,
name|name
argument_list|)
operator|&&
name|ieee_write_number
argument_list|(
name|info
argument_list|,
name|indx
argument_list|)
operator|&&
name|ieee_write_number
argument_list|(
name|info
argument_list|,
name|offset
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Finish up a struct type.  */
end_comment

begin_function
specifier|static
name|boolean
name|ieee_end_struct_type
parameter_list|(
name|p
parameter_list|)
name|PTR
name|p
decl_stmt|;
block|{
name|struct
name|ieee_handle
modifier|*
name|info
init|=
operator|(
expr|struct
name|ieee_handle
operator|*
operator|)
name|p
decl_stmt|;
name|struct
name|ieee_buflist
modifier|*
name|pb
decl_stmt|;
name|assert
argument_list|(
name|info
operator|->
name|type_stack
operator|!=
name|NULL
operator|&&
operator|!
name|ieee_buffer_emptyp
argument_list|(
operator|&
name|info
operator|->
name|type_stack
operator|->
name|type
operator|.
name|strdef
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If we were ignoring this struct definition because it was a      duplicate defintion, just through away whatever bytes we have      accumulated.  Leave the type on the stack. */
if|if
condition|(
name|info
operator|->
name|type_stack
operator|->
name|type
operator|.
name|ignorep
condition|)
return|return
name|true
return|;
comment|/* If this is not a duplicate definition of this tag, then localp      will be false, and we can put it in the global type block.      FIXME: We should avoid outputting duplicate definitions which are      the same.  */
if|if
condition|(
operator|!
name|info
operator|->
name|type_stack
operator|->
name|type
operator|.
name|localp
condition|)
block|{
comment|/* Make sure we have started the global type block.  */
if|if
condition|(
name|ieee_buffer_emptyp
argument_list|(
operator|&
name|info
operator|->
name|global_types
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|ieee_change_buffer
argument_list|(
name|info
argument_list|,
operator|&
name|info
operator|->
name|global_types
argument_list|)
operator|||
operator|!
name|ieee_write_byte
argument_list|(
name|info
argument_list|,
operator|(
name|int
operator|)
name|ieee_bb_record_enum
argument_list|)
operator|||
operator|!
name|ieee_write_byte
argument_list|(
name|info
argument_list|,
literal|2
argument_list|)
operator|||
operator|!
name|ieee_write_number
argument_list|(
name|info
argument_list|,
literal|0
argument_list|)
operator|||
operator|!
name|ieee_write_id
argument_list|(
name|info
argument_list|,
literal|""
argument_list|)
condition|)
return|return
name|false
return|;
block|}
name|pb
operator|=
operator|&
name|info
operator|->
name|global_types
expr_stmt|;
block|}
else|else
block|{
comment|/* Make sure we have started the types block.  */
if|if
condition|(
name|ieee_buffer_emptyp
argument_list|(
operator|&
name|info
operator|->
name|types
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|ieee_change_buffer
argument_list|(
name|info
argument_list|,
operator|&
name|info
operator|->
name|types
argument_list|)
operator|||
operator|!
name|ieee_write_byte
argument_list|(
name|info
argument_list|,
operator|(
name|int
operator|)
name|ieee_bb_record_enum
argument_list|)
operator|||
operator|!
name|ieee_write_byte
argument_list|(
name|info
argument_list|,
literal|1
argument_list|)
operator|||
operator|!
name|ieee_write_number
argument_list|(
name|info
argument_list|,
literal|0
argument_list|)
operator|||
operator|!
name|ieee_write_id
argument_list|(
name|info
argument_list|,
name|info
operator|->
name|modname
argument_list|)
condition|)
return|return
name|false
return|;
block|}
name|pb
operator|=
operator|&
name|info
operator|->
name|types
expr_stmt|;
block|}
comment|/* Append the struct definition to the types.  */
if|if
condition|(
operator|!
name|ieee_append_buffer
argument_list|(
name|info
argument_list|,
name|pb
argument_list|,
operator|&
name|info
operator|->
name|type_stack
operator|->
name|type
operator|.
name|strdef
argument_list|)
operator|||
operator|!
name|ieee_init_buffer
argument_list|(
name|info
argument_list|,
operator|&
name|info
operator|->
name|type_stack
operator|->
name|type
operator|.
name|strdef
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* Leave the struct on the type stack.  */
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Start a class type.  */
end_comment

begin_function
specifier|static
name|boolean
name|ieee_start_class_type
parameter_list|(
name|p
parameter_list|,
name|tag
parameter_list|,
name|id
parameter_list|,
name|structp
parameter_list|,
name|size
parameter_list|,
name|vptr
parameter_list|,
name|ownvptr
parameter_list|)
name|PTR
name|p
decl_stmt|;
specifier|const
name|char
modifier|*
name|tag
decl_stmt|;
name|unsigned
name|int
name|id
decl_stmt|;
name|boolean
name|structp
decl_stmt|;
name|unsigned
name|int
name|size
decl_stmt|;
name|boolean
name|vptr
decl_stmt|;
name|boolean
name|ownvptr
decl_stmt|;
block|{
name|struct
name|ieee_handle
modifier|*
name|info
init|=
operator|(
expr|struct
name|ieee_handle
operator|*
operator|)
name|p
decl_stmt|;
specifier|const
name|char
modifier|*
name|vclass
decl_stmt|;
name|struct
name|ieee_buflist
name|pmiscbuf
decl_stmt|;
name|unsigned
name|int
name|indx
decl_stmt|;
name|struct
name|ieee_type_class
modifier|*
name|classdef
decl_stmt|;
comment|/* A C++ class is output as a C++ struct along with a set of pmisc      records describing the class.  */
comment|/* We need to have a name so that we can associate the struct and      the class.  */
if|if
condition|(
name|tag
operator|==
name|NULL
condition|)
block|{
name|char
modifier|*
name|t
decl_stmt|;
name|t
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|20
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|t
argument_list|,
literal|"__anon%u"
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|tag
operator|=
name|t
expr_stmt|;
block|}
comment|/* We can't write out the virtual table information until we have      finished the class, because we don't know the virtual table size.      We get the size from the largest voffset we see.  */
name|vclass
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|vptr
operator|&&
operator|!
name|ownvptr
condition|)
block|{
name|vclass
operator|=
name|info
operator|->
name|type_stack
operator|->
name|type
operator|.
name|name
expr_stmt|;
name|assert
argument_list|(
name|vclass
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* We don't call ieee_pop_unused_type, since the class should          get defined.  */
operator|(
name|void
operator|)
name|ieee_pop_type
argument_list|(
name|info
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|ieee_start_struct_type
argument_list|(
name|p
argument_list|,
name|tag
argument_list|,
name|id
argument_list|,
name|structp
argument_list|,
name|size
argument_list|)
condition|)
return|return
name|false
return|;
name|indx
operator|=
name|info
operator|->
name|name_indx
expr_stmt|;
operator|++
name|info
operator|->
name|name_indx
expr_stmt|;
comment|/* We write out pmisc records into the classdef field.  We will      write out the pmisc start after we know the number of records we      need.  */
if|if
condition|(
operator|!
name|ieee_init_buffer
argument_list|(
name|info
argument_list|,
operator|&
name|pmiscbuf
argument_list|)
operator|||
operator|!
name|ieee_change_buffer
argument_list|(
name|info
argument_list|,
operator|&
name|pmiscbuf
argument_list|)
operator|||
operator|!
name|ieee_write_asn
argument_list|(
name|info
argument_list|,
name|indx
argument_list|,
literal|'T'
argument_list|)
operator|||
operator|!
name|ieee_write_asn
argument_list|(
name|info
argument_list|,
name|indx
argument_list|,
name|structp
condition|?
literal|'o'
else|:
literal|'u'
argument_list|)
operator|||
operator|!
name|ieee_write_atn65
argument_list|(
name|info
argument_list|,
name|indx
argument_list|,
name|tag
argument_list|)
condition|)
return|return
name|false
return|;
name|classdef
operator|=
operator|(
expr|struct
name|ieee_type_class
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
expr|*
name|classdef
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|classdef
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
expr|*
name|classdef
argument_list|)
expr_stmt|;
name|classdef
operator|->
name|indx
operator|=
name|indx
expr_stmt|;
name|classdef
operator|->
name|pmiscbuf
operator|=
name|pmiscbuf
expr_stmt|;
name|classdef
operator|->
name|pmisccount
operator|=
literal|3
expr_stmt|;
name|classdef
operator|->
name|vclass
operator|=
name|vclass
expr_stmt|;
name|classdef
operator|->
name|ownvptr
operator|=
name|ownvptr
expr_stmt|;
name|info
operator|->
name|type_stack
operator|->
name|type
operator|.
name|classdef
operator|=
name|classdef
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Add a static member to a class.  */
end_comment

begin_function
specifier|static
name|boolean
name|ieee_class_static_member
parameter_list|(
name|p
parameter_list|,
name|name
parameter_list|,
name|physname
parameter_list|,
name|visibility
parameter_list|)
name|PTR
name|p
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
specifier|const
name|char
modifier|*
name|physname
decl_stmt|;
name|enum
name|debug_visibility
name|visibility
decl_stmt|;
block|{
name|struct
name|ieee_handle
modifier|*
name|info
init|=
operator|(
expr|struct
name|ieee_handle
operator|*
operator|)
name|p
decl_stmt|;
name|unsigned
name|int
name|flags
decl_stmt|;
name|unsigned
name|int
name|nindx
decl_stmt|;
comment|/* We don't care about the type.  Hopefully there will be a call to      ieee_variable declaring the physical name and the type, since      that is where an IEEE consumer must get the type.  */
name|ieee_pop_unused_type
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|info
operator|->
name|type_stack
operator|!=
name|NULL
operator|&&
name|info
operator|->
name|type_stack
operator|->
name|type
operator|.
name|classdef
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|flags
operator|=
name|ieee_vis_to_flags
argument_list|(
name|visibility
argument_list|)
expr_stmt|;
name|flags
operator||=
name|CXXFLAGS_STATIC
expr_stmt|;
name|nindx
operator|=
name|info
operator|->
name|type_stack
operator|->
name|type
operator|.
name|classdef
operator|->
name|indx
expr_stmt|;
if|if
condition|(
operator|!
name|ieee_change_buffer
argument_list|(
name|info
argument_list|,
operator|&
name|info
operator|->
name|type_stack
operator|->
name|type
operator|.
name|classdef
operator|->
name|pmiscbuf
argument_list|)
operator|||
operator|!
name|ieee_write_asn
argument_list|(
name|info
argument_list|,
name|nindx
argument_list|,
literal|'d'
argument_list|)
operator|||
operator|!
name|ieee_write_asn
argument_list|(
name|info
argument_list|,
name|nindx
argument_list|,
name|flags
argument_list|)
operator|||
operator|!
name|ieee_write_atn65
argument_list|(
name|info
argument_list|,
name|nindx
argument_list|,
name|name
argument_list|)
operator|||
operator|!
name|ieee_write_atn65
argument_list|(
name|info
argument_list|,
name|nindx
argument_list|,
name|physname
argument_list|)
condition|)
return|return
name|false
return|;
name|info
operator|->
name|type_stack
operator|->
name|type
operator|.
name|classdef
operator|->
name|pmisccount
operator|+=
literal|4
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Add a base class to a class.  */
end_comment

begin_function
specifier|static
name|boolean
name|ieee_class_baseclass
parameter_list|(
name|p
parameter_list|,
name|bitpos
parameter_list|,
name|virtual
parameter_list|,
name|visibility
parameter_list|)
name|PTR
name|p
decl_stmt|;
name|bfd_vma
name|bitpos
decl_stmt|;
name|boolean
name|virtual
decl_stmt|;
name|enum
name|debug_visibility
name|visibility
decl_stmt|;
block|{
name|struct
name|ieee_handle
modifier|*
name|info
init|=
operator|(
expr|struct
name|ieee_handle
operator|*
operator|)
name|p
decl_stmt|;
specifier|const
name|char
modifier|*
name|bname
decl_stmt|;
name|boolean
name|localp
decl_stmt|;
name|unsigned
name|int
name|bindx
decl_stmt|;
name|char
modifier|*
name|fname
decl_stmt|;
name|unsigned
name|int
name|flags
decl_stmt|;
name|unsigned
name|int
name|nindx
decl_stmt|;
name|assert
argument_list|(
name|info
operator|->
name|type_stack
operator|!=
name|NULL
operator|&&
name|info
operator|->
name|type_stack
operator|->
name|type
operator|.
name|name
operator|!=
name|NULL
operator|&&
name|info
operator|->
name|type_stack
operator|->
name|next
operator|!=
name|NULL
operator|&&
name|info
operator|->
name|type_stack
operator|->
name|next
operator|->
name|type
operator|.
name|classdef
operator|!=
name|NULL
operator|&&
operator|!
name|ieee_buffer_emptyp
argument_list|(
operator|&
name|info
operator|->
name|type_stack
operator|->
name|next
operator|->
name|type
operator|.
name|strdef
argument_list|)
argument_list|)
expr_stmt|;
name|bname
operator|=
name|info
operator|->
name|type_stack
operator|->
name|type
operator|.
name|name
expr_stmt|;
name|localp
operator|=
name|info
operator|->
name|type_stack
operator|->
name|type
operator|.
name|localp
expr_stmt|;
name|bindx
operator|=
name|ieee_pop_type
argument_list|(
name|info
argument_list|)
expr_stmt|;
comment|/* We are currently defining both a struct and a class.  We must      write out a field definition in the struct which holds the base      class.  The stabs debugging reader will create a field named      _vb$CLASS for a virtual base class, so we just use that.  FIXME:      we should not depend upon a detail of stabs debugging.  */
if|if
condition|(
name|virtual
condition|)
block|{
name|fname
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|bname
argument_list|)
operator|+
sizeof|sizeof
expr|"_vb$"
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|fname
argument_list|,
literal|"_vb$%s"
argument_list|,
name|bname
argument_list|)
expr_stmt|;
name|flags
operator|=
name|BASEFLAGS_VIRTUAL
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|localp
condition|)
name|info
operator|->
name|type_stack
operator|->
name|type
operator|.
name|localp
operator|=
name|true
expr_stmt|;
name|fname
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|bname
argument_list|)
operator|+
sizeof|sizeof
expr|"_b$"
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|fname
argument_list|,
literal|"_b$%s"
argument_list|,
name|bname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ieee_change_buffer
argument_list|(
name|info
argument_list|,
operator|&
name|info
operator|->
name|type_stack
operator|->
name|type
operator|.
name|strdef
argument_list|)
operator|||
operator|!
name|ieee_write_id
argument_list|(
name|info
argument_list|,
name|fname
argument_list|)
operator|||
operator|!
name|ieee_write_number
argument_list|(
name|info
argument_list|,
name|bindx
argument_list|)
operator|||
operator|!
name|ieee_write_number
argument_list|(
name|info
argument_list|,
name|bitpos
operator|/
literal|8
argument_list|)
condition|)
return|return
name|false
return|;
name|flags
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|visibility
operator|==
name|DEBUG_VISIBILITY_PRIVATE
condition|)
name|flags
operator||=
name|BASEFLAGS_PRIVATE
expr_stmt|;
name|nindx
operator|=
name|info
operator|->
name|type_stack
operator|->
name|type
operator|.
name|classdef
operator|->
name|indx
expr_stmt|;
if|if
condition|(
operator|!
name|ieee_change_buffer
argument_list|(
name|info
argument_list|,
operator|&
name|info
operator|->
name|type_stack
operator|->
name|type
operator|.
name|classdef
operator|->
name|pmiscbuf
argument_list|)
operator|||
operator|!
name|ieee_write_asn
argument_list|(
name|info
argument_list|,
name|nindx
argument_list|,
literal|'b'
argument_list|)
operator|||
operator|!
name|ieee_write_asn
argument_list|(
name|info
argument_list|,
name|nindx
argument_list|,
name|flags
argument_list|)
operator|||
operator|!
name|ieee_write_atn65
argument_list|(
name|info
argument_list|,
name|nindx
argument_list|,
name|bname
argument_list|)
operator|||
operator|!
name|ieee_write_asn
argument_list|(
name|info
argument_list|,
name|nindx
argument_list|,
literal|0
argument_list|)
operator|||
operator|!
name|ieee_write_atn65
argument_list|(
name|info
argument_list|,
name|nindx
argument_list|,
name|fname
argument_list|)
condition|)
return|return
name|false
return|;
name|info
operator|->
name|type_stack
operator|->
name|type
operator|.
name|classdef
operator|->
name|pmisccount
operator|+=
literal|5
expr_stmt|;
name|free
argument_list|(
name|fname
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Start building a method for a class.  */
end_comment

begin_function
specifier|static
name|boolean
name|ieee_class_start_method
parameter_list|(
name|p
parameter_list|,
name|name
parameter_list|)
name|PTR
name|p
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|struct
name|ieee_handle
modifier|*
name|info
init|=
operator|(
expr|struct
name|ieee_handle
operator|*
operator|)
name|p
decl_stmt|;
name|assert
argument_list|(
name|info
operator|->
name|type_stack
operator|!=
name|NULL
operator|&&
name|info
operator|->
name|type_stack
operator|->
name|type
operator|.
name|classdef
operator|!=
name|NULL
operator|&&
name|info
operator|->
name|type_stack
operator|->
name|type
operator|.
name|classdef
operator|->
name|method
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|info
operator|->
name|type_stack
operator|->
name|type
operator|.
name|classdef
operator|->
name|method
operator|=
name|name
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Define a new method variant, either static or not.  */
end_comment

begin_function
specifier|static
name|boolean
name|ieee_class_method_var
parameter_list|(
name|info
parameter_list|,
name|physname
parameter_list|,
name|visibility
parameter_list|,
name|staticp
parameter_list|,
name|constp
parameter_list|,
name|volatilep
parameter_list|,
name|voffset
parameter_list|,
name|context
parameter_list|)
name|struct
name|ieee_handle
modifier|*
name|info
decl_stmt|;
specifier|const
name|char
modifier|*
name|physname
decl_stmt|;
name|enum
name|debug_visibility
name|visibility
decl_stmt|;
name|boolean
name|staticp
decl_stmt|;
name|boolean
name|constp
decl_stmt|;
name|boolean
name|volatilep
decl_stmt|;
name|bfd_vma
name|voffset
decl_stmt|;
name|boolean
name|context
decl_stmt|;
block|{
name|unsigned
name|int
name|flags
decl_stmt|;
name|unsigned
name|int
name|nindx
decl_stmt|;
name|boolean
name|virtual
decl_stmt|;
comment|/* We don't need the type of the method.  An IEEE consumer which      wants the type must track down the function by the physical name      and get the type from that.  */
name|ieee_pop_unused_type
argument_list|(
name|info
argument_list|)
expr_stmt|;
comment|/* We don't use the context.  FIXME: We probably ought to use it to      adjust the voffset somehow, but I don't really know how.  */
if|if
condition|(
name|context
condition|)
name|ieee_pop_unused_type
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|info
operator|->
name|type_stack
operator|!=
name|NULL
operator|&&
name|info
operator|->
name|type_stack
operator|->
name|type
operator|.
name|classdef
operator|!=
name|NULL
operator|&&
name|info
operator|->
name|type_stack
operator|->
name|type
operator|.
name|classdef
operator|->
name|method
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|flags
operator|=
name|ieee_vis_to_flags
argument_list|(
name|visibility
argument_list|)
expr_stmt|;
comment|/* FIXME: We never set CXXFLAGS_OVERRIDE, CXXFLAGS_OPERATOR,      CXXFLAGS_CTORDTOR, CXXFLAGS_CTOR, or CXXFLAGS_INLINE.  */
if|if
condition|(
name|staticp
condition|)
name|flags
operator||=
name|CXXFLAGS_STATIC
expr_stmt|;
if|if
condition|(
name|constp
condition|)
name|flags
operator||=
name|CXXFLAGS_CONST
expr_stmt|;
if|if
condition|(
name|volatilep
condition|)
name|flags
operator||=
name|CXXFLAGS_VOLATILE
expr_stmt|;
name|nindx
operator|=
name|info
operator|->
name|type_stack
operator|->
name|type
operator|.
name|classdef
operator|->
name|indx
expr_stmt|;
name|virtual
operator|=
name|context
operator|||
name|voffset
operator|>
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|ieee_change_buffer
argument_list|(
name|info
argument_list|,
operator|&
name|info
operator|->
name|type_stack
operator|->
name|type
operator|.
name|classdef
operator|->
name|pmiscbuf
argument_list|)
operator|||
operator|!
name|ieee_write_asn
argument_list|(
name|info
argument_list|,
name|nindx
argument_list|,
name|virtual
condition|?
literal|'v'
else|:
literal|'m'
argument_list|)
operator|||
operator|!
name|ieee_write_asn
argument_list|(
name|info
argument_list|,
name|nindx
argument_list|,
name|flags
argument_list|)
operator|||
operator|!
name|ieee_write_atn65
argument_list|(
name|info
argument_list|,
name|nindx
argument_list|,
name|info
operator|->
name|type_stack
operator|->
name|type
operator|.
name|classdef
operator|->
name|method
argument_list|)
operator|||
operator|!
name|ieee_write_atn65
argument_list|(
name|info
argument_list|,
name|nindx
argument_list|,
name|physname
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|virtual
condition|)
block|{
if|if
condition|(
name|voffset
operator|>
name|info
operator|->
name|type_stack
operator|->
name|type
operator|.
name|classdef
operator|->
name|voffset
condition|)
name|info
operator|->
name|type_stack
operator|->
name|type
operator|.
name|classdef
operator|->
name|voffset
operator|=
name|voffset
expr_stmt|;
if|if
condition|(
operator|!
name|ieee_write_asn
argument_list|(
name|info
argument_list|,
name|nindx
argument_list|,
name|voffset
argument_list|)
condition|)
return|return
name|false
return|;
operator|++
name|info
operator|->
name|type_stack
operator|->
name|type
operator|.
name|classdef
operator|->
name|pmisccount
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|ieee_write_asn
argument_list|(
name|info
argument_list|,
name|nindx
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|false
return|;
name|info
operator|->
name|type_stack
operator|->
name|type
operator|.
name|classdef
operator|->
name|pmisccount
operator|+=
literal|5
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Define a new method variant.  */
end_comment

begin_function
specifier|static
name|boolean
name|ieee_class_method_variant
parameter_list|(
name|p
parameter_list|,
name|physname
parameter_list|,
name|visibility
parameter_list|,
name|constp
parameter_list|,
name|volatilep
parameter_list|,
name|voffset
parameter_list|,
name|context
parameter_list|)
name|PTR
name|p
decl_stmt|;
specifier|const
name|char
modifier|*
name|physname
decl_stmt|;
name|enum
name|debug_visibility
name|visibility
decl_stmt|;
name|boolean
name|constp
decl_stmt|;
name|boolean
name|volatilep
decl_stmt|;
name|bfd_vma
name|voffset
decl_stmt|;
name|boolean
name|context
decl_stmt|;
block|{
name|struct
name|ieee_handle
modifier|*
name|info
init|=
operator|(
expr|struct
name|ieee_handle
operator|*
operator|)
name|p
decl_stmt|;
return|return
name|ieee_class_method_var
argument_list|(
name|info
argument_list|,
name|physname
argument_list|,
name|visibility
argument_list|,
name|false
argument_list|,
name|constp
argument_list|,
name|volatilep
argument_list|,
name|voffset
argument_list|,
name|context
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Define a new static method variant.  */
end_comment

begin_function
specifier|static
name|boolean
name|ieee_class_static_method_variant
parameter_list|(
name|p
parameter_list|,
name|physname
parameter_list|,
name|visibility
parameter_list|,
name|constp
parameter_list|,
name|volatilep
parameter_list|)
name|PTR
name|p
decl_stmt|;
specifier|const
name|char
modifier|*
name|physname
decl_stmt|;
name|enum
name|debug_visibility
name|visibility
decl_stmt|;
name|boolean
name|constp
decl_stmt|;
name|boolean
name|volatilep
decl_stmt|;
block|{
name|struct
name|ieee_handle
modifier|*
name|info
init|=
operator|(
expr|struct
name|ieee_handle
operator|*
operator|)
name|p
decl_stmt|;
return|return
name|ieee_class_method_var
argument_list|(
name|info
argument_list|,
name|physname
argument_list|,
name|visibility
argument_list|,
name|true
argument_list|,
name|constp
argument_list|,
name|volatilep
argument_list|,
literal|0
argument_list|,
name|false
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Finish up a method.  */
end_comment

begin_function
specifier|static
name|boolean
name|ieee_class_end_method
parameter_list|(
name|p
parameter_list|)
name|PTR
name|p
decl_stmt|;
block|{
name|struct
name|ieee_handle
modifier|*
name|info
init|=
operator|(
expr|struct
name|ieee_handle
operator|*
operator|)
name|p
decl_stmt|;
name|assert
argument_list|(
name|info
operator|->
name|type_stack
operator|!=
name|NULL
operator|&&
name|info
operator|->
name|type_stack
operator|->
name|type
operator|.
name|classdef
operator|!=
name|NULL
operator|&&
name|info
operator|->
name|type_stack
operator|->
name|type
operator|.
name|classdef
operator|->
name|method
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|info
operator|->
name|type_stack
operator|->
name|type
operator|.
name|classdef
operator|->
name|method
operator|=
name|NULL
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Finish up a class.  */
end_comment

begin_function
specifier|static
name|boolean
name|ieee_end_class_type
parameter_list|(
name|p
parameter_list|)
name|PTR
name|p
decl_stmt|;
block|{
name|struct
name|ieee_handle
modifier|*
name|info
init|=
operator|(
expr|struct
name|ieee_handle
operator|*
operator|)
name|p
decl_stmt|;
name|unsigned
name|int
name|nindx
decl_stmt|;
name|assert
argument_list|(
name|info
operator|->
name|type_stack
operator|!=
name|NULL
operator|&&
name|info
operator|->
name|type_stack
operator|->
name|type
operator|.
name|classdef
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* If we were ignoring this class definition because it was a      duplicate definition, just through away whatever bytes we have      accumulated.  Leave the type on the stack.  */
if|if
condition|(
name|info
operator|->
name|type_stack
operator|->
name|type
operator|.
name|ignorep
condition|)
return|return
name|true
return|;
name|nindx
operator|=
name|info
operator|->
name|type_stack
operator|->
name|type
operator|.
name|classdef
operator|->
name|indx
expr_stmt|;
comment|/* If we have a virtual table, we can write out the information now.  */
if|if
condition|(
name|info
operator|->
name|type_stack
operator|->
name|type
operator|.
name|classdef
operator|->
name|vclass
operator|!=
name|NULL
operator|||
name|info
operator|->
name|type_stack
operator|->
name|type
operator|.
name|classdef
operator|->
name|ownvptr
condition|)
block|{
if|if
condition|(
operator|!
name|ieee_change_buffer
argument_list|(
name|info
argument_list|,
operator|&
name|info
operator|->
name|type_stack
operator|->
name|type
operator|.
name|classdef
operator|->
name|pmiscbuf
argument_list|)
operator|||
operator|!
name|ieee_write_asn
argument_list|(
name|info
argument_list|,
name|nindx
argument_list|,
literal|'z'
argument_list|)
operator|||
operator|!
name|ieee_write_atn65
argument_list|(
name|info
argument_list|,
name|nindx
argument_list|,
literal|""
argument_list|)
operator|||
operator|!
name|ieee_write_asn
argument_list|(
name|info
argument_list|,
name|nindx
argument_list|,
name|info
operator|->
name|type_stack
operator|->
name|type
operator|.
name|classdef
operator|->
name|voffset
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|info
operator|->
name|type_stack
operator|->
name|type
operator|.
name|classdef
operator|->
name|ownvptr
condition|)
block|{
if|if
condition|(
operator|!
name|ieee_write_atn65
argument_list|(
name|info
argument_list|,
name|nindx
argument_list|,
literal|""
argument_list|)
condition|)
return|return
name|false
return|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|ieee_write_atn65
argument_list|(
name|info
argument_list|,
name|nindx
argument_list|,
name|info
operator|->
name|type_stack
operator|->
name|type
operator|.
name|classdef
operator|->
name|vclass
argument_list|)
condition|)
return|return
name|false
return|;
block|}
if|if
condition|(
operator|!
name|ieee_write_asn
argument_list|(
name|info
argument_list|,
name|nindx
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|false
return|;
name|info
operator|->
name|type_stack
operator|->
name|type
operator|.
name|classdef
operator|->
name|pmisccount
operator|+=
literal|5
expr_stmt|;
block|}
comment|/* Now that we know the number of pmisc records, we can write out      the atn62 which starts the pmisc records, and append them to the      C++ buffers.  */
if|if
condition|(
operator|!
name|ieee_change_buffer
argument_list|(
name|info
argument_list|,
operator|&
name|info
operator|->
name|cxx
argument_list|)
operator|||
operator|!
name|ieee_write_byte
argument_list|(
name|info
argument_list|,
operator|(
name|int
operator|)
name|ieee_nn_record
argument_list|)
operator|||
operator|!
name|ieee_write_number
argument_list|(
name|info
argument_list|,
name|nindx
argument_list|)
operator|||
operator|!
name|ieee_write_id
argument_list|(
name|info
argument_list|,
literal|""
argument_list|)
operator|||
operator|!
name|ieee_write_2bytes
argument_list|(
name|info
argument_list|,
operator|(
name|int
operator|)
name|ieee_atn_record_enum
argument_list|)
operator|||
operator|!
name|ieee_write_number
argument_list|(
name|info
argument_list|,
name|nindx
argument_list|)
operator|||
operator|!
name|ieee_write_number
argument_list|(
name|info
argument_list|,
literal|0
argument_list|)
operator|||
operator|!
name|ieee_write_number
argument_list|(
name|info
argument_list|,
literal|62
argument_list|)
operator|||
operator|!
name|ieee_write_number
argument_list|(
name|info
argument_list|,
literal|80
argument_list|)
operator|||
operator|!
name|ieee_write_number
argument_list|(
name|info
argument_list|,
name|info
operator|->
name|type_stack
operator|->
name|type
operator|.
name|classdef
operator|->
name|pmisccount
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|!
name|ieee_append_buffer
argument_list|(
name|info
argument_list|,
operator|&
name|info
operator|->
name|cxx
argument_list|,
operator|&
name|info
operator|->
name|type_stack
operator|->
name|type
operator|.
name|classdef
operator|->
name|pmiscbuf
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|!
name|ieee_buffer_emptyp
argument_list|(
operator|&
name|info
operator|->
name|type_stack
operator|->
name|type
operator|.
name|classdef
operator|->
name|refs
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|ieee_append_buffer
argument_list|(
name|info
argument_list|,
operator|&
name|info
operator|->
name|cxx
argument_list|,
operator|&
name|info
operator|->
name|type_stack
operator|->
name|type
operator|.
name|classdef
operator|->
name|refs
argument_list|)
condition|)
return|return
name|false
return|;
block|}
return|return
name|ieee_end_struct_type
argument_list|(
name|p
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Push a previously seen typedef onto the type stack.  */
end_comment

begin_function
specifier|static
name|boolean
name|ieee_typedef_type
parameter_list|(
name|p
parameter_list|,
name|name
parameter_list|)
name|PTR
name|p
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|struct
name|ieee_handle
modifier|*
name|info
init|=
operator|(
expr|struct
name|ieee_handle
operator|*
operator|)
name|p
decl_stmt|;
name|struct
name|ieee_name_type_hash_entry
modifier|*
name|h
decl_stmt|;
name|struct
name|ieee_name_type
modifier|*
name|nt
decl_stmt|;
name|h
operator|=
name|ieee_name_type_hash_lookup
argument_list|(
operator|&
name|info
operator|->
name|typedefs
argument_list|,
name|name
argument_list|,
name|false
argument_list|,
name|false
argument_list|)
expr_stmt|;
comment|/* h should never be NULL, since that would imply that the generic      debugging code has asked for a typedef which it has not yet      defined.  */
name|assert
argument_list|(
name|h
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* We always use the most recently defined type for this name, which      will be the first one on the list.  */
name|nt
operator|=
name|h
operator|->
name|types
expr_stmt|;
if|if
condition|(
operator|!
name|ieee_push_type
argument_list|(
name|info
argument_list|,
name|nt
operator|->
name|type
operator|.
name|indx
argument_list|,
name|nt
operator|->
name|type
operator|.
name|size
argument_list|,
name|nt
operator|->
name|type
operator|.
name|unsignedp
argument_list|,
name|nt
operator|->
name|type
operator|.
name|localp
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* Copy over any other type information we may have.  */
name|info
operator|->
name|type_stack
operator|->
name|type
operator|=
name|nt
operator|->
name|type
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Push a tagged type onto the type stack.  */
end_comment

begin_function
specifier|static
name|boolean
name|ieee_tag_type
parameter_list|(
name|p
parameter_list|,
name|name
parameter_list|,
name|id
parameter_list|,
name|kind
parameter_list|)
name|PTR
name|p
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|unsigned
name|int
name|id
decl_stmt|;
name|enum
name|debug_type_kind
name|kind
decl_stmt|;
block|{
name|struct
name|ieee_handle
modifier|*
name|info
init|=
operator|(
expr|struct
name|ieee_handle
operator|*
operator|)
name|p
decl_stmt|;
name|boolean
name|localp
decl_stmt|;
name|boolean
name|copy
decl_stmt|;
name|char
name|ab
index|[
literal|20
index|]
decl_stmt|;
name|struct
name|ieee_name_type_hash_entry
modifier|*
name|h
decl_stmt|;
name|struct
name|ieee_name_type
modifier|*
name|nt
decl_stmt|;
if|if
condition|(
name|kind
operator|==
name|DEBUG_KIND_ENUM
condition|)
block|{
name|struct
name|ieee_defined_enum
modifier|*
name|e
decl_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
for|for
control|(
name|e
operator|=
name|info
operator|->
name|enums
init|;
name|e
operator|!=
name|NULL
condition|;
name|e
operator|=
name|e
operator|->
name|next
control|)
if|if
condition|(
name|e
operator|->
name|tag
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|e
operator|->
name|tag
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
return|return
name|ieee_push_type
argument_list|(
name|info
argument_list|,
name|e
operator|->
name|indx
argument_list|,
literal|0
argument_list|,
name|true
argument_list|,
name|false
argument_list|)
return|;
name|e
operator|=
operator|(
expr|struct
name|ieee_defined_enum
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
expr|*
name|e
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|e
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
expr|*
name|e
argument_list|)
expr_stmt|;
name|e
operator|->
name|indx
operator|=
name|info
operator|->
name|type_indx
expr_stmt|;
operator|++
name|info
operator|->
name|type_indx
expr_stmt|;
name|e
operator|->
name|tag
operator|=
name|name
expr_stmt|;
name|e
operator|->
name|defined
operator|=
name|false
expr_stmt|;
name|e
operator|->
name|next
operator|=
name|info
operator|->
name|enums
expr_stmt|;
name|info
operator|->
name|enums
operator|=
name|e
expr_stmt|;
return|return
name|ieee_push_type
argument_list|(
name|info
argument_list|,
name|e
operator|->
name|indx
argument_list|,
literal|0
argument_list|,
name|true
argument_list|,
name|false
argument_list|)
return|;
block|}
name|localp
operator|=
name|false
expr_stmt|;
name|copy
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
block|{
name|sprintf
argument_list|(
name|ab
argument_list|,
literal|"__anon%u"
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|name
operator|=
name|ab
expr_stmt|;
name|copy
operator|=
name|true
expr_stmt|;
block|}
name|h
operator|=
name|ieee_name_type_hash_lookup
argument_list|(
operator|&
name|info
operator|->
name|tags
argument_list|,
name|name
argument_list|,
name|true
argument_list|,
name|copy
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|==
name|NULL
condition|)
return|return
name|false
return|;
for|for
control|(
name|nt
operator|=
name|h
operator|->
name|types
init|;
name|nt
operator|!=
name|NULL
condition|;
name|nt
operator|=
name|nt
operator|->
name|next
control|)
block|{
if|if
condition|(
name|nt
operator|->
name|id
operator|==
name|id
condition|)
block|{
if|if
condition|(
operator|!
name|ieee_push_type
argument_list|(
name|info
argument_list|,
name|nt
operator|->
name|type
operator|.
name|indx
argument_list|,
name|nt
operator|->
name|type
operator|.
name|size
argument_list|,
name|nt
operator|->
name|type
operator|.
name|unsignedp
argument_list|,
name|nt
operator|->
name|type
operator|.
name|localp
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* Copy over any other type information we may have.  */
name|info
operator|->
name|type_stack
operator|->
name|type
operator|=
name|nt
operator|->
name|type
expr_stmt|;
return|return
name|true
return|;
block|}
if|if
condition|(
operator|!
name|nt
operator|->
name|type
operator|.
name|localp
condition|)
block|{
comment|/* This is a duplicate of a global type, so it must be              local. */
name|localp
operator|=
name|true
expr_stmt|;
block|}
block|}
name|nt
operator|=
operator|(
expr|struct
name|ieee_name_type
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
expr|*
name|nt
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|nt
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
expr|*
name|nt
argument_list|)
expr_stmt|;
name|nt
operator|->
name|id
operator|=
name|id
expr_stmt|;
name|nt
operator|->
name|type
operator|.
name|name
operator|=
name|h
operator|->
name|root
operator|.
name|string
expr_stmt|;
name|nt
operator|->
name|type
operator|.
name|indx
operator|=
name|info
operator|->
name|type_indx
expr_stmt|;
name|nt
operator|->
name|type
operator|.
name|localp
operator|=
name|localp
expr_stmt|;
operator|++
name|info
operator|->
name|type_indx
expr_stmt|;
name|nt
operator|->
name|kind
operator|=
name|kind
expr_stmt|;
name|nt
operator|->
name|next
operator|=
name|h
operator|->
name|types
expr_stmt|;
name|h
operator|->
name|types
operator|=
name|nt
expr_stmt|;
if|if
condition|(
operator|!
name|ieee_push_type
argument_list|(
name|info
argument_list|,
name|nt
operator|->
name|type
operator|.
name|indx
argument_list|,
literal|0
argument_list|,
name|false
argument_list|,
name|localp
argument_list|)
condition|)
return|return
name|false
return|;
name|info
operator|->
name|type_stack
operator|->
name|type
operator|.
name|name
operator|=
name|h
operator|->
name|root
operator|.
name|string
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Output a typedef.  */
end_comment

begin_function
specifier|static
name|boolean
name|ieee_typdef
parameter_list|(
name|p
parameter_list|,
name|name
parameter_list|)
name|PTR
name|p
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|struct
name|ieee_handle
modifier|*
name|info
init|=
operator|(
expr|struct
name|ieee_handle
operator|*
operator|)
name|p
decl_stmt|;
name|struct
name|ieee_write_type
name|type
decl_stmt|;
name|unsigned
name|int
name|indx
decl_stmt|;
name|boolean
name|found
decl_stmt|;
name|boolean
name|localp
decl_stmt|;
name|struct
name|ieee_name_type_hash_entry
modifier|*
name|h
decl_stmt|;
name|struct
name|ieee_name_type
modifier|*
name|nt
decl_stmt|;
name|type
operator|=
name|info
operator|->
name|type_stack
operator|->
name|type
expr_stmt|;
name|indx
operator|=
name|type
operator|.
name|indx
expr_stmt|;
comment|/* If this is a simple builtin type using a builtin name, we don't      want to output the typedef itself.  We also want to change the      type index to correspond to the name being used.  We recognize      names used in stabs debugging output even if they don't exactly      correspond to the names used for the IEEE builtin types.  */
name|found
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|indx
operator|<=
operator|(
name|unsigned
name|int
operator|)
name|builtin_bcd_float
condition|)
block|{
switch|switch
condition|(
operator|(
expr|enum
name|builtin_types
operator|)
name|indx
condition|)
block|{
default|default:
break|break;
case|case
name|builtin_void
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"void"
argument_list|)
operator|==
literal|0
condition|)
name|found
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|builtin_signed_char
case|:
case|case
name|builtin_char
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"signed char"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|indx
operator|=
operator|(
name|unsigned
name|int
operator|)
name|builtin_signed_char
expr_stmt|;
name|found
operator|=
name|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"char"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|indx
operator|=
operator|(
name|unsigned
name|int
operator|)
name|builtin_char
expr_stmt|;
name|found
operator|=
name|true
expr_stmt|;
block|}
break|break;
case|case
name|builtin_unsigned_char
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"unsigned char"
argument_list|)
operator|==
literal|0
condition|)
name|found
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|builtin_signed_short_int
case|:
case|case
name|builtin_short
case|:
case|case
name|builtin_short_int
case|:
case|case
name|builtin_signed_short
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"signed short int"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|indx
operator|=
operator|(
name|unsigned
name|int
operator|)
name|builtin_signed_short_int
expr_stmt|;
name|found
operator|=
name|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"short"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|indx
operator|=
operator|(
name|unsigned
name|int
operator|)
name|builtin_short
expr_stmt|;
name|found
operator|=
name|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"short int"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|indx
operator|=
operator|(
name|unsigned
name|int
operator|)
name|builtin_short_int
expr_stmt|;
name|found
operator|=
name|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"signed short"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|indx
operator|=
operator|(
name|unsigned
name|int
operator|)
name|builtin_signed_short
expr_stmt|;
name|found
operator|=
name|true
expr_stmt|;
block|}
break|break;
case|case
name|builtin_unsigned_short_int
case|:
case|case
name|builtin_unsigned_short
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"unsigned short int"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"short unsigned int"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|indx
operator|=
name|builtin_unsigned_short_int
expr_stmt|;
name|found
operator|=
name|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"unsigned short"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|indx
operator|=
name|builtin_unsigned_short
expr_stmt|;
name|found
operator|=
name|true
expr_stmt|;
block|}
break|break;
case|case
name|builtin_signed_long
case|:
case|case
name|builtin_int
case|:
comment|/* FIXME: Size depends upon architecture.  */
case|case
name|builtin_long
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"signed long"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|indx
operator|=
name|builtin_signed_long
expr_stmt|;
name|found
operator|=
name|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"int"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|indx
operator|=
name|builtin_int
expr_stmt|;
name|found
operator|=
name|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"long"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"long int"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|indx
operator|=
name|builtin_long
expr_stmt|;
name|found
operator|=
name|true
expr_stmt|;
block|}
break|break;
case|case
name|builtin_unsigned_long
case|:
case|case
name|builtin_unsigned
case|:
comment|/* FIXME: Size depends upon architecture.  */
case|case
name|builtin_unsigned_int
case|:
comment|/* FIXME: Like builtin_unsigned.  */
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"unsigned long"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"long unsigned int"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|indx
operator|=
name|builtin_unsigned_long
expr_stmt|;
name|found
operator|=
name|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"unsigned"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|indx
operator|=
name|builtin_unsigned
expr_stmt|;
name|found
operator|=
name|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"unsigned int"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|indx
operator|=
name|builtin_unsigned_int
expr_stmt|;
name|found
operator|=
name|true
expr_stmt|;
block|}
break|break;
case|case
name|builtin_signed_long_long
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"signed long long"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"long long int"
argument_list|)
operator|==
literal|0
condition|)
name|found
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|builtin_unsigned_long_long
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"unsigned long long"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"long long unsigned int"
argument_list|)
operator|==
literal|0
condition|)
name|found
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|builtin_float
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"float"
argument_list|)
operator|==
literal|0
condition|)
name|found
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|builtin_double
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"double"
argument_list|)
operator|==
literal|0
condition|)
name|found
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|builtin_long_double
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"long double"
argument_list|)
operator|==
literal|0
condition|)
name|found
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|builtin_long_long_double
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"long long double"
argument_list|)
operator|==
literal|0
condition|)
name|found
operator|=
name|true
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|found
condition|)
name|type
operator|.
name|indx
operator|=
name|indx
expr_stmt|;
block|}
name|h
operator|=
name|ieee_name_type_hash_lookup
argument_list|(
operator|&
name|info
operator|->
name|typedefs
argument_list|,
name|name
argument_list|,
name|true
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|==
name|NULL
condition|)
return|return
name|false
return|;
comment|/* See if we have already defined this type with this name.  */
name|localp
operator|=
name|type
operator|.
name|localp
expr_stmt|;
for|for
control|(
name|nt
operator|=
name|h
operator|->
name|types
init|;
name|nt
operator|!=
name|NULL
condition|;
name|nt
operator|=
name|nt
operator|->
name|next
control|)
block|{
if|if
condition|(
name|nt
operator|->
name|id
operator|==
name|indx
condition|)
block|{
comment|/* If this is a global definition, then we don't need to 	     do anything here.  */
if|if
condition|(
operator|!
name|nt
operator|->
name|type
operator|.
name|localp
condition|)
block|{
name|ieee_pop_unused_type
argument_list|(
name|info
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
block|}
else|else
block|{
comment|/* This is a duplicate definition, so make this one local.  */
name|localp
operator|=
name|true
expr_stmt|;
block|}
block|}
comment|/* We need to add a new typedef for this type.  */
name|nt
operator|=
operator|(
expr|struct
name|ieee_name_type
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
expr|*
name|nt
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|nt
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
expr|*
name|nt
argument_list|)
expr_stmt|;
name|nt
operator|->
name|id
operator|=
name|indx
expr_stmt|;
name|nt
operator|->
name|type
operator|=
name|type
expr_stmt|;
name|nt
operator|->
name|type
operator|.
name|name
operator|=
name|name
expr_stmt|;
name|nt
operator|->
name|type
operator|.
name|localp
operator|=
name|localp
expr_stmt|;
name|nt
operator|->
name|kind
operator|=
name|DEBUG_KIND_ILLEGAL
expr_stmt|;
name|nt
operator|->
name|next
operator|=
name|h
operator|->
name|types
expr_stmt|;
name|h
operator|->
name|types
operator|=
name|nt
expr_stmt|;
if|if
condition|(
name|found
condition|)
block|{
comment|/* This is one of the builtin typedefs, so we don't need to          actually define it.  */
name|ieee_pop_unused_type
argument_list|(
name|info
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
name|indx
operator|=
name|ieee_pop_type
argument_list|(
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ieee_define_named_type
argument_list|(
name|info
argument_list|,
name|name
argument_list|,
operator|(
name|unsigned
name|int
operator|)
operator|-
literal|1
argument_list|,
name|type
operator|.
name|size
argument_list|,
name|type
operator|.
name|unsignedp
argument_list|,
name|localp
argument_list|,
operator|(
expr|struct
name|ieee_buflist
operator|*
operator|)
name|NULL
argument_list|)
operator|||
operator|!
name|ieee_write_number
argument_list|(
name|info
argument_list|,
literal|'T'
argument_list|)
operator|||
operator|!
name|ieee_write_number
argument_list|(
name|info
argument_list|,
name|indx
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* Remove the type we just added to the type stack.  This should not      be ieee_pop_unused_type, since the type is used, we just don't      need it now.  */
operator|(
name|void
operator|)
name|ieee_pop_type
argument_list|(
name|info
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Output a tag for a type.  We don't have to do anything here.  */
end_comment

begin_function
specifier|static
name|boolean
name|ieee_tag
parameter_list|(
name|p
parameter_list|,
name|name
parameter_list|)
name|PTR
name|p
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|struct
name|ieee_handle
modifier|*
name|info
init|=
operator|(
expr|struct
name|ieee_handle
operator|*
operator|)
name|p
decl_stmt|;
comment|/* This should not be ieee_pop_unused_type, since we want the type      to be defined.  */
operator|(
name|void
operator|)
name|ieee_pop_type
argument_list|(
name|info
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Output an integer constant.  */
end_comment

begin_function
specifier|static
name|boolean
name|ieee_int_constant
parameter_list|(
name|p
parameter_list|,
name|name
parameter_list|,
name|val
parameter_list|)
name|PTR
name|p
name|ATTRIBUTE_UNUSED
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|bfd_vma
name|val
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
comment|/* FIXME.  */
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Output a floating point constant.  */
end_comment

begin_function
specifier|static
name|boolean
name|ieee_float_constant
parameter_list|(
name|p
parameter_list|,
name|name
parameter_list|,
name|val
parameter_list|)
name|PTR
name|p
name|ATTRIBUTE_UNUSED
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|double
name|val
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
comment|/* FIXME.  */
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Output a typed constant.  */
end_comment

begin_function
specifier|static
name|boolean
name|ieee_typed_constant
parameter_list|(
name|p
parameter_list|,
name|name
parameter_list|,
name|val
parameter_list|)
name|PTR
name|p
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|bfd_vma
name|val
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|struct
name|ieee_handle
modifier|*
name|info
init|=
operator|(
expr|struct
name|ieee_handle
operator|*
operator|)
name|p
decl_stmt|;
comment|/* FIXME.  */
name|ieee_pop_unused_type
argument_list|(
name|info
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Output a variable.  */
end_comment

begin_function
specifier|static
name|boolean
name|ieee_variable
parameter_list|(
name|p
parameter_list|,
name|name
parameter_list|,
name|kind
parameter_list|,
name|val
parameter_list|)
name|PTR
name|p
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|enum
name|debug_var_kind
name|kind
decl_stmt|;
name|bfd_vma
name|val
decl_stmt|;
block|{
name|struct
name|ieee_handle
modifier|*
name|info
init|=
operator|(
expr|struct
name|ieee_handle
operator|*
operator|)
name|p
decl_stmt|;
name|unsigned
name|int
name|name_indx
decl_stmt|;
name|unsigned
name|int
name|size
decl_stmt|;
name|boolean
name|referencep
decl_stmt|;
name|unsigned
name|int
name|type_indx
decl_stmt|;
name|boolean
name|asn
decl_stmt|;
name|int
name|refflag
decl_stmt|;
name|size
operator|=
name|info
operator|->
name|type_stack
operator|->
name|type
operator|.
name|size
expr_stmt|;
name|referencep
operator|=
name|info
operator|->
name|type_stack
operator|->
name|type
operator|.
name|referencep
expr_stmt|;
name|type_indx
operator|=
name|ieee_pop_type
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|!
name|ieee_buffer_emptyp
argument_list|(
operator|&
name|info
operator|->
name|vars
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ieee_change_buffer
argument_list|(
name|info
argument_list|,
operator|&
name|info
operator|->
name|vars
argument_list|)
condition|)
return|return
name|false
return|;
name|name_indx
operator|=
name|info
operator|->
name|name_indx
expr_stmt|;
operator|++
name|info
operator|->
name|name_indx
expr_stmt|;
comment|/* Write out an NN and an ATN record for this variable.  */
if|if
condition|(
operator|!
name|ieee_write_byte
argument_list|(
name|info
argument_list|,
operator|(
name|int
operator|)
name|ieee_nn_record
argument_list|)
operator|||
operator|!
name|ieee_write_number
argument_list|(
name|info
argument_list|,
name|name_indx
argument_list|)
operator|||
operator|!
name|ieee_write_id
argument_list|(
name|info
argument_list|,
name|name
argument_list|)
operator|||
operator|!
name|ieee_write_2bytes
argument_list|(
name|info
argument_list|,
operator|(
name|int
operator|)
name|ieee_atn_record_enum
argument_list|)
operator|||
operator|!
name|ieee_write_number
argument_list|(
name|info
argument_list|,
name|name_indx
argument_list|)
operator|||
operator|!
name|ieee_write_number
argument_list|(
name|info
argument_list|,
name|type_indx
argument_list|)
condition|)
return|return
name|false
return|;
switch|switch
condition|(
name|kind
condition|)
block|{
default|default:
name|abort
argument_list|()
expr_stmt|;
return|return
name|false
return|;
case|case
name|DEBUG_GLOBAL
case|:
if|if
condition|(
operator|!
name|ieee_write_number
argument_list|(
name|info
argument_list|,
literal|8
argument_list|)
operator|||
operator|!
name|ieee_add_range
argument_list|(
name|info
argument_list|,
name|false
argument_list|,
name|val
argument_list|,
name|val
operator|+
name|size
argument_list|)
condition|)
return|return
name|false
return|;
name|refflag
operator|=
literal|0
expr_stmt|;
name|asn
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|DEBUG_STATIC
case|:
if|if
condition|(
operator|!
name|ieee_write_number
argument_list|(
name|info
argument_list|,
literal|3
argument_list|)
operator|||
operator|!
name|ieee_add_range
argument_list|(
name|info
argument_list|,
name|false
argument_list|,
name|val
argument_list|,
name|val
operator|+
name|size
argument_list|)
condition|)
return|return
name|false
return|;
name|refflag
operator|=
literal|1
expr_stmt|;
name|asn
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|DEBUG_LOCAL_STATIC
case|:
if|if
condition|(
operator|!
name|ieee_write_number
argument_list|(
name|info
argument_list|,
literal|3
argument_list|)
operator|||
operator|!
name|ieee_add_range
argument_list|(
name|info
argument_list|,
name|false
argument_list|,
name|val
argument_list|,
name|val
operator|+
name|size
argument_list|)
condition|)
return|return
name|false
return|;
name|refflag
operator|=
literal|2
expr_stmt|;
name|asn
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|DEBUG_LOCAL
case|:
if|if
condition|(
operator|!
name|ieee_write_number
argument_list|(
name|info
argument_list|,
literal|1
argument_list|)
operator|||
operator|!
name|ieee_write_number
argument_list|(
name|info
argument_list|,
name|val
argument_list|)
condition|)
return|return
name|false
return|;
name|refflag
operator|=
literal|2
expr_stmt|;
name|asn
operator|=
name|false
expr_stmt|;
break|break;
case|case
name|DEBUG_REGISTER
case|:
if|if
condition|(
operator|!
name|ieee_write_number
argument_list|(
name|info
argument_list|,
literal|2
argument_list|)
operator|||
operator|!
name|ieee_write_number
argument_list|(
name|info
argument_list|,
name|ieee_genreg_to_regno
argument_list|(
name|info
operator|->
name|abfd
argument_list|,
name|val
argument_list|)
argument_list|)
condition|)
return|return
name|false
return|;
name|refflag
operator|=
literal|2
expr_stmt|;
name|asn
operator|=
name|false
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|asn
condition|)
block|{
if|if
condition|(
operator|!
name|ieee_write_asn
argument_list|(
name|info
argument_list|,
name|name_indx
argument_list|,
name|val
argument_list|)
condition|)
return|return
name|false
return|;
block|}
comment|/* If this is really a reference type, then we just output it with      pointer type, and must now output a C++ record indicating that it      is really reference type.  */
if|if
condition|(
name|referencep
condition|)
block|{
name|unsigned
name|int
name|nindx
decl_stmt|;
name|nindx
operator|=
name|info
operator|->
name|name_indx
expr_stmt|;
operator|++
name|info
operator|->
name|name_indx
expr_stmt|;
comment|/* If this is a global variable, we want to output the misc          record in the C++ misc record block.  Otherwise, we want to          output it just after the variable definition, which is where          the current buffer is.  */
if|if
condition|(
name|refflag
operator|!=
literal|2
condition|)
block|{
if|if
condition|(
operator|!
name|ieee_change_buffer
argument_list|(
name|info
argument_list|,
operator|&
name|info
operator|->
name|cxx
argument_list|)
condition|)
return|return
name|false
return|;
block|}
if|if
condition|(
operator|!
name|ieee_write_byte
argument_list|(
name|info
argument_list|,
operator|(
name|int
operator|)
name|ieee_nn_record
argument_list|)
operator|||
operator|!
name|ieee_write_number
argument_list|(
name|info
argument_list|,
name|nindx
argument_list|)
operator|||
operator|!
name|ieee_write_id
argument_list|(
name|info
argument_list|,
literal|""
argument_list|)
operator|||
operator|!
name|ieee_write_2bytes
argument_list|(
name|info
argument_list|,
operator|(
name|int
operator|)
name|ieee_atn_record_enum
argument_list|)
operator|||
operator|!
name|ieee_write_number
argument_list|(
name|info
argument_list|,
name|nindx
argument_list|)
operator|||
operator|!
name|ieee_write_number
argument_list|(
name|info
argument_list|,
literal|0
argument_list|)
operator|||
operator|!
name|ieee_write_number
argument_list|(
name|info
argument_list|,
literal|62
argument_list|)
operator|||
operator|!
name|ieee_write_number
argument_list|(
name|info
argument_list|,
literal|80
argument_list|)
operator|||
operator|!
name|ieee_write_number
argument_list|(
name|info
argument_list|,
literal|3
argument_list|)
operator|||
operator|!
name|ieee_write_asn
argument_list|(
name|info
argument_list|,
name|nindx
argument_list|,
literal|'R'
argument_list|)
operator|||
operator|!
name|ieee_write_asn
argument_list|(
name|info
argument_list|,
name|nindx
argument_list|,
name|refflag
argument_list|)
operator|||
operator|!
name|ieee_write_atn65
argument_list|(
name|info
argument_list|,
name|nindx
argument_list|,
name|name
argument_list|)
condition|)
return|return
name|false
return|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Start outputting information for a function.  */
end_comment

begin_function
specifier|static
name|boolean
name|ieee_start_function
parameter_list|(
name|p
parameter_list|,
name|name
parameter_list|,
name|global
parameter_list|)
name|PTR
name|p
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|boolean
name|global
decl_stmt|;
block|{
name|struct
name|ieee_handle
modifier|*
name|info
init|=
operator|(
expr|struct
name|ieee_handle
operator|*
operator|)
name|p
decl_stmt|;
name|boolean
name|referencep
decl_stmt|;
name|unsigned
name|int
name|retindx
decl_stmt|,
name|typeindx
decl_stmt|;
name|referencep
operator|=
name|info
operator|->
name|type_stack
operator|->
name|type
operator|.
name|referencep
expr_stmt|;
name|retindx
operator|=
name|ieee_pop_type
argument_list|(
name|info
argument_list|)
expr_stmt|;
comment|/* Besides recording a BB4 or BB6 block, we record the type of the      function in the BB1 typedef block.  We can't write out the full      type until we have seen all the parameters, so we accumulate it      in info->fntype and info->fnargs.  */
if|if
condition|(
operator|!
name|ieee_buffer_emptyp
argument_list|(
operator|&
name|info
operator|->
name|fntype
argument_list|)
condition|)
block|{
comment|/* FIXME: This might happen someday if we support nested          functions.  */
name|abort
argument_list|()
expr_stmt|;
block|}
name|info
operator|->
name|fnname
operator|=
name|name
expr_stmt|;
comment|/* An attribute of 0x40 means that the push mask is unknown.  */
if|if
condition|(
operator|!
name|ieee_define_named_type
argument_list|(
name|info
argument_list|,
name|name
argument_list|,
operator|(
name|unsigned
name|int
operator|)
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
name|false
argument_list|,
name|true
argument_list|,
operator|&
name|info
operator|->
name|fntype
argument_list|)
operator|||
operator|!
name|ieee_write_number
argument_list|(
name|info
argument_list|,
literal|'x'
argument_list|)
operator|||
operator|!
name|ieee_write_number
argument_list|(
name|info
argument_list|,
literal|0x40
argument_list|)
operator|||
operator|!
name|ieee_write_number
argument_list|(
name|info
argument_list|,
literal|0
argument_list|)
operator|||
operator|!
name|ieee_write_number
argument_list|(
name|info
argument_list|,
literal|0
argument_list|)
operator|||
operator|!
name|ieee_write_number
argument_list|(
name|info
argument_list|,
name|retindx
argument_list|)
condition|)
return|return
name|false
return|;
name|typeindx
operator|=
name|ieee_pop_type
argument_list|(
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ieee_init_buffer
argument_list|(
name|info
argument_list|,
operator|&
name|info
operator|->
name|fnargs
argument_list|)
condition|)
return|return
name|false
return|;
name|info
operator|->
name|fnargcount
operator|=
literal|0
expr_stmt|;
comment|/* If the function return value is actually a reference type, we      must add a record indicating that.  */
if|if
condition|(
name|referencep
condition|)
block|{
name|unsigned
name|int
name|nindx
decl_stmt|;
name|nindx
operator|=
name|info
operator|->
name|name_indx
expr_stmt|;
operator|++
name|info
operator|->
name|name_indx
expr_stmt|;
if|if
condition|(
operator|!
name|ieee_change_buffer
argument_list|(
name|info
argument_list|,
operator|&
name|info
operator|->
name|cxx
argument_list|)
operator|||
operator|!
name|ieee_write_byte
argument_list|(
name|info
argument_list|,
operator|(
name|int
operator|)
name|ieee_nn_record
argument_list|)
operator|||
operator|!
name|ieee_write_number
argument_list|(
name|info
argument_list|,
name|nindx
argument_list|)
operator|||
operator|!
name|ieee_write_id
argument_list|(
name|info
argument_list|,
literal|""
argument_list|)
operator|||
operator|!
name|ieee_write_2bytes
argument_list|(
name|info
argument_list|,
operator|(
name|int
operator|)
name|ieee_atn_record_enum
argument_list|)
operator|||
operator|!
name|ieee_write_number
argument_list|(
name|info
argument_list|,
name|nindx
argument_list|)
operator|||
operator|!
name|ieee_write_number
argument_list|(
name|info
argument_list|,
literal|0
argument_list|)
operator|||
operator|!
name|ieee_write_number
argument_list|(
name|info
argument_list|,
literal|62
argument_list|)
operator|||
operator|!
name|ieee_write_number
argument_list|(
name|info
argument_list|,
literal|80
argument_list|)
operator|||
operator|!
name|ieee_write_number
argument_list|(
name|info
argument_list|,
literal|3
argument_list|)
operator|||
operator|!
name|ieee_write_asn
argument_list|(
name|info
argument_list|,
name|nindx
argument_list|,
literal|'R'
argument_list|)
operator|||
operator|!
name|ieee_write_asn
argument_list|(
name|info
argument_list|,
name|nindx
argument_list|,
name|global
condition|?
literal|0
else|:
literal|1
argument_list|)
operator|||
operator|!
name|ieee_write_atn65
argument_list|(
name|info
argument_list|,
name|nindx
argument_list|,
name|name
argument_list|)
condition|)
return|return
name|false
return|;
block|}
name|assert
argument_list|(
operator|!
name|ieee_buffer_emptyp
argument_list|(
operator|&
name|info
operator|->
name|vars
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ieee_change_buffer
argument_list|(
name|info
argument_list|,
operator|&
name|info
operator|->
name|vars
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* The address is written out as the first block.  */
operator|++
name|info
operator|->
name|block_depth
expr_stmt|;
return|return
operator|(
name|ieee_write_byte
argument_list|(
name|info
argument_list|,
operator|(
name|int
operator|)
name|ieee_bb_record_enum
argument_list|)
operator|&&
name|ieee_write_byte
argument_list|(
name|info
argument_list|,
name|global
condition|?
literal|4
else|:
literal|6
argument_list|)
operator|&&
name|ieee_write_number
argument_list|(
name|info
argument_list|,
literal|0
argument_list|)
operator|&&
name|ieee_write_id
argument_list|(
name|info
argument_list|,
name|name
argument_list|)
operator|&&
name|ieee_write_number
argument_list|(
name|info
argument_list|,
literal|0
argument_list|)
operator|&&
name|ieee_write_number
argument_list|(
name|info
argument_list|,
name|typeindx
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Add a function parameter.  This will normally be called before the    first block, so we postpone them until we see the block.  */
end_comment

begin_function
specifier|static
name|boolean
name|ieee_function_parameter
parameter_list|(
name|p
parameter_list|,
name|name
parameter_list|,
name|kind
parameter_list|,
name|val
parameter_list|)
name|PTR
name|p
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|enum
name|debug_parm_kind
name|kind
decl_stmt|;
name|bfd_vma
name|val
decl_stmt|;
block|{
name|struct
name|ieee_handle
modifier|*
name|info
init|=
operator|(
expr|struct
name|ieee_handle
operator|*
operator|)
name|p
decl_stmt|;
name|struct
name|ieee_pending_parm
modifier|*
name|m
decl_stmt|,
modifier|*
modifier|*
name|pm
decl_stmt|;
name|assert
argument_list|(
name|info
operator|->
name|block_depth
operator|==
literal|1
argument_list|)
expr_stmt|;
name|m
operator|=
operator|(
expr|struct
name|ieee_pending_parm
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
expr|*
name|m
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|m
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
expr|*
name|m
argument_list|)
expr_stmt|;
name|m
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|m
operator|->
name|name
operator|=
name|name
expr_stmt|;
name|m
operator|->
name|referencep
operator|=
name|info
operator|->
name|type_stack
operator|->
name|type
operator|.
name|referencep
expr_stmt|;
name|m
operator|->
name|type
operator|=
name|ieee_pop_type
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|m
operator|->
name|kind
operator|=
name|kind
expr_stmt|;
name|m
operator|->
name|val
operator|=
name|val
expr_stmt|;
for|for
control|(
name|pm
operator|=
operator|&
name|info
operator|->
name|pending_parms
init|;
operator|*
name|pm
operator|!=
name|NULL
condition|;
name|pm
operator|=
operator|&
operator|(
operator|*
name|pm
operator|)
operator|->
name|next
control|)
empty_stmt|;
operator|*
name|pm
operator|=
name|m
expr_stmt|;
comment|/* Add the type to the fnargs list.  */
if|if
condition|(
operator|!
name|ieee_change_buffer
argument_list|(
name|info
argument_list|,
operator|&
name|info
operator|->
name|fnargs
argument_list|)
operator|||
operator|!
name|ieee_write_number
argument_list|(
name|info
argument_list|,
name|m
operator|->
name|type
argument_list|)
condition|)
return|return
name|false
return|;
operator|++
name|info
operator|->
name|fnargcount
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Output pending function parameters.  */
end_comment

begin_function
specifier|static
name|boolean
name|ieee_output_pending_parms
parameter_list|(
name|info
parameter_list|)
name|struct
name|ieee_handle
modifier|*
name|info
decl_stmt|;
block|{
name|struct
name|ieee_pending_parm
modifier|*
name|m
decl_stmt|;
name|unsigned
name|int
name|refcount
decl_stmt|;
name|refcount
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|m
operator|=
name|info
operator|->
name|pending_parms
init|;
name|m
operator|!=
name|NULL
condition|;
name|m
operator|=
name|m
operator|->
name|next
control|)
block|{
name|enum
name|debug_var_kind
name|vkind
decl_stmt|;
switch|switch
condition|(
name|m
operator|->
name|kind
condition|)
block|{
default|default:
name|abort
argument_list|()
expr_stmt|;
return|return
name|false
return|;
case|case
name|DEBUG_PARM_STACK
case|:
case|case
name|DEBUG_PARM_REFERENCE
case|:
name|vkind
operator|=
name|DEBUG_LOCAL
expr_stmt|;
break|break;
case|case
name|DEBUG_PARM_REG
case|:
case|case
name|DEBUG_PARM_REF_REG
case|:
name|vkind
operator|=
name|DEBUG_REGISTER
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|ieee_push_type
argument_list|(
name|info
argument_list|,
name|m
operator|->
name|type
argument_list|,
literal|0
argument_list|,
name|false
argument_list|,
name|false
argument_list|)
condition|)
return|return
name|false
return|;
name|info
operator|->
name|type_stack
operator|->
name|type
operator|.
name|referencep
operator|=
name|m
operator|->
name|referencep
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|referencep
condition|)
operator|++
name|refcount
expr_stmt|;
if|if
condition|(
operator|!
name|ieee_variable
argument_list|(
operator|(
name|PTR
operator|)
name|info
argument_list|,
name|m
operator|->
name|name
argument_list|,
name|vkind
argument_list|,
name|m
operator|->
name|val
argument_list|)
condition|)
return|return
name|false
return|;
block|}
comment|/* If there are any reference parameters, we need to output a      miscellaneous record indicating them.  */
if|if
condition|(
name|refcount
operator|>
literal|0
condition|)
block|{
name|unsigned
name|int
name|nindx
decl_stmt|,
name|varindx
decl_stmt|;
comment|/* FIXME: The MRI compiler outputs the demangled function name          here, but we are outputting the mangled name.  */
name|nindx
operator|=
name|info
operator|->
name|name_indx
expr_stmt|;
operator|++
name|info
operator|->
name|name_indx
expr_stmt|;
if|if
condition|(
operator|!
name|ieee_change_buffer
argument_list|(
name|info
argument_list|,
operator|&
name|info
operator|->
name|vars
argument_list|)
operator|||
operator|!
name|ieee_write_byte
argument_list|(
name|info
argument_list|,
operator|(
name|int
operator|)
name|ieee_nn_record
argument_list|)
operator|||
operator|!
name|ieee_write_number
argument_list|(
name|info
argument_list|,
name|nindx
argument_list|)
operator|||
operator|!
name|ieee_write_id
argument_list|(
name|info
argument_list|,
literal|""
argument_list|)
operator|||
operator|!
name|ieee_write_2bytes
argument_list|(
name|info
argument_list|,
operator|(
name|int
operator|)
name|ieee_atn_record_enum
argument_list|)
operator|||
operator|!
name|ieee_write_number
argument_list|(
name|info
argument_list|,
name|nindx
argument_list|)
operator|||
operator|!
name|ieee_write_number
argument_list|(
name|info
argument_list|,
literal|0
argument_list|)
operator|||
operator|!
name|ieee_write_number
argument_list|(
name|info
argument_list|,
literal|62
argument_list|)
operator|||
operator|!
name|ieee_write_number
argument_list|(
name|info
argument_list|,
literal|80
argument_list|)
operator|||
operator|!
name|ieee_write_number
argument_list|(
name|info
argument_list|,
name|refcount
operator|+
literal|3
argument_list|)
operator|||
operator|!
name|ieee_write_asn
argument_list|(
name|info
argument_list|,
name|nindx
argument_list|,
literal|'B'
argument_list|)
operator|||
operator|!
name|ieee_write_atn65
argument_list|(
name|info
argument_list|,
name|nindx
argument_list|,
name|info
operator|->
name|fnname
argument_list|)
operator|||
operator|!
name|ieee_write_asn
argument_list|(
name|info
argument_list|,
name|nindx
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|false
return|;
for|for
control|(
name|m
operator|=
name|info
operator|->
name|pending_parms
operator|,
name|varindx
operator|=
literal|1
init|;
name|m
operator|!=
name|NULL
condition|;
name|m
operator|=
name|m
operator|->
name|next
operator|,
name|varindx
operator|++
control|)
block|{
if|if
condition|(
name|m
operator|->
name|referencep
condition|)
block|{
if|if
condition|(
operator|!
name|ieee_write_asn
argument_list|(
name|info
argument_list|,
name|nindx
argument_list|,
name|varindx
argument_list|)
condition|)
return|return
name|false
return|;
block|}
block|}
block|}
name|m
operator|=
name|info
operator|->
name|pending_parms
expr_stmt|;
while|while
condition|(
name|m
operator|!=
name|NULL
condition|)
block|{
name|struct
name|ieee_pending_parm
modifier|*
name|next
decl_stmt|;
name|next
operator|=
name|m
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|m
operator|=
name|next
expr_stmt|;
block|}
name|info
operator|->
name|pending_parms
operator|=
name|NULL
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Start a block.  If this is the first block, we output the address    to finish the BB4 or BB6, and then output the function parameters.  */
end_comment

begin_function
specifier|static
name|boolean
name|ieee_start_block
parameter_list|(
name|p
parameter_list|,
name|addr
parameter_list|)
name|PTR
name|p
decl_stmt|;
name|bfd_vma
name|addr
decl_stmt|;
block|{
name|struct
name|ieee_handle
modifier|*
name|info
init|=
operator|(
expr|struct
name|ieee_handle
operator|*
operator|)
name|p
decl_stmt|;
if|if
condition|(
operator|!
name|ieee_change_buffer
argument_list|(
name|info
argument_list|,
operator|&
name|info
operator|->
name|vars
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|info
operator|->
name|block_depth
operator|==
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|ieee_write_number
argument_list|(
name|info
argument_list|,
name|addr
argument_list|)
operator|||
operator|!
name|ieee_output_pending_parms
argument_list|(
name|info
argument_list|)
condition|)
return|return
name|false
return|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|ieee_write_byte
argument_list|(
name|info
argument_list|,
operator|(
name|int
operator|)
name|ieee_bb_record_enum
argument_list|)
operator|||
operator|!
name|ieee_write_byte
argument_list|(
name|info
argument_list|,
literal|6
argument_list|)
operator|||
operator|!
name|ieee_write_number
argument_list|(
name|info
argument_list|,
literal|0
argument_list|)
operator|||
operator|!
name|ieee_write_id
argument_list|(
name|info
argument_list|,
literal|""
argument_list|)
operator|||
operator|!
name|ieee_write_number
argument_list|(
name|info
argument_list|,
literal|0
argument_list|)
operator|||
operator|!
name|ieee_write_number
argument_list|(
name|info
argument_list|,
literal|0
argument_list|)
operator|||
operator|!
name|ieee_write_number
argument_list|(
name|info
argument_list|,
name|addr
argument_list|)
condition|)
return|return
name|false
return|;
block|}
if|if
condition|(
operator|!
name|ieee_start_range
argument_list|(
name|info
argument_list|,
name|addr
argument_list|)
condition|)
return|return
name|false
return|;
operator|++
name|info
operator|->
name|block_depth
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* End a block.  */
end_comment

begin_function
specifier|static
name|boolean
name|ieee_end_block
parameter_list|(
name|p
parameter_list|,
name|addr
parameter_list|)
name|PTR
name|p
decl_stmt|;
name|bfd_vma
name|addr
decl_stmt|;
block|{
name|struct
name|ieee_handle
modifier|*
name|info
init|=
operator|(
expr|struct
name|ieee_handle
operator|*
operator|)
name|p
decl_stmt|;
comment|/* The address we are given is the end of the block, but IEEE seems      to want to the address of the last byte in the block, so we      subtract one.  */
if|if
condition|(
operator|!
name|ieee_change_buffer
argument_list|(
name|info
argument_list|,
operator|&
name|info
operator|->
name|vars
argument_list|)
operator|||
operator|!
name|ieee_write_byte
argument_list|(
name|info
argument_list|,
operator|(
name|int
operator|)
name|ieee_be_record_enum
argument_list|)
operator|||
operator|!
name|ieee_write_number
argument_list|(
name|info
argument_list|,
name|addr
operator|-
literal|1
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|!
name|ieee_end_range
argument_list|(
name|info
argument_list|,
name|addr
argument_list|)
condition|)
return|return
name|false
return|;
operator|--
name|info
operator|->
name|block_depth
expr_stmt|;
if|if
condition|(
name|addr
operator|>
name|info
operator|->
name|highaddr
condition|)
name|info
operator|->
name|highaddr
operator|=
name|addr
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* End a function.  */
end_comment

begin_function
specifier|static
name|boolean
name|ieee_end_function
parameter_list|(
name|p
parameter_list|)
name|PTR
name|p
decl_stmt|;
block|{
name|struct
name|ieee_handle
modifier|*
name|info
init|=
operator|(
expr|struct
name|ieee_handle
operator|*
operator|)
name|p
decl_stmt|;
name|assert
argument_list|(
name|info
operator|->
name|block_depth
operator|==
literal|1
argument_list|)
expr_stmt|;
operator|--
name|info
operator|->
name|block_depth
expr_stmt|;
comment|/* Now we can finish up fntype, and add it to the typdef section.      At this point, fntype is the 'x' type up to the argument count,      and fnargs is the argument types.  We must add the argument      count, and we must add the level.  FIXME: We don't record varargs      functions correctly.  In fact, stabs debugging does not give us      enough information to do so.  */
if|if
condition|(
operator|!
name|ieee_change_buffer
argument_list|(
name|info
argument_list|,
operator|&
name|info
operator|->
name|fntype
argument_list|)
operator|||
operator|!
name|ieee_write_number
argument_list|(
name|info
argument_list|,
name|info
operator|->
name|fnargcount
argument_list|)
operator|||
operator|!
name|ieee_change_buffer
argument_list|(
name|info
argument_list|,
operator|&
name|info
operator|->
name|fnargs
argument_list|)
operator|||
operator|!
name|ieee_write_number
argument_list|(
name|info
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* Make sure the typdef block has been started.  */
if|if
condition|(
name|ieee_buffer_emptyp
argument_list|(
operator|&
name|info
operator|->
name|types
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|ieee_change_buffer
argument_list|(
name|info
argument_list|,
operator|&
name|info
operator|->
name|types
argument_list|)
operator|||
operator|!
name|ieee_write_byte
argument_list|(
name|info
argument_list|,
operator|(
name|int
operator|)
name|ieee_bb_record_enum
argument_list|)
operator|||
operator|!
name|ieee_write_byte
argument_list|(
name|info
argument_list|,
literal|1
argument_list|)
operator|||
operator|!
name|ieee_write_number
argument_list|(
name|info
argument_list|,
literal|0
argument_list|)
operator|||
operator|!
name|ieee_write_id
argument_list|(
name|info
argument_list|,
name|info
operator|->
name|modname
argument_list|)
condition|)
return|return
name|false
return|;
block|}
if|if
condition|(
operator|!
name|ieee_append_buffer
argument_list|(
name|info
argument_list|,
operator|&
name|info
operator|->
name|types
argument_list|,
operator|&
name|info
operator|->
name|fntype
argument_list|)
operator|||
operator|!
name|ieee_append_buffer
argument_list|(
name|info
argument_list|,
operator|&
name|info
operator|->
name|types
argument_list|,
operator|&
name|info
operator|->
name|fnargs
argument_list|)
condition|)
return|return
name|false
return|;
name|info
operator|->
name|fnname
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|ieee_init_buffer
argument_list|(
name|info
argument_list|,
operator|&
name|info
operator|->
name|fntype
argument_list|)
operator|||
operator|!
name|ieee_init_buffer
argument_list|(
name|info
argument_list|,
operator|&
name|info
operator|->
name|fnargs
argument_list|)
condition|)
return|return
name|false
return|;
name|info
operator|->
name|fnargcount
operator|=
literal|0
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Record line number information.  */
end_comment

begin_function
specifier|static
name|boolean
name|ieee_lineno
parameter_list|(
name|p
parameter_list|,
name|filename
parameter_list|,
name|lineno
parameter_list|,
name|addr
parameter_list|)
name|PTR
name|p
decl_stmt|;
specifier|const
name|char
modifier|*
name|filename
decl_stmt|;
name|unsigned
name|long
name|lineno
decl_stmt|;
name|bfd_vma
name|addr
decl_stmt|;
block|{
name|struct
name|ieee_handle
modifier|*
name|info
init|=
operator|(
expr|struct
name|ieee_handle
operator|*
operator|)
name|p
decl_stmt|;
name|assert
argument_list|(
name|info
operator|->
name|filename
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* The HP simulator seems to get confused when more than one line is      listed for the same address, at least if they are in different      files.  We handle this by always listing the last line for a      given address, since that seems to be the one that gdb uses.  */
if|if
condition|(
name|info
operator|->
name|pending_lineno_filename
operator|!=
name|NULL
operator|&&
name|addr
operator|!=
name|info
operator|->
name|pending_lineno_addr
condition|)
block|{
comment|/* Make sure we have a line number block.  */
if|if
condition|(
operator|!
name|ieee_buffer_emptyp
argument_list|(
operator|&
name|info
operator|->
name|linenos
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|ieee_change_buffer
argument_list|(
name|info
argument_list|,
operator|&
name|info
operator|->
name|linenos
argument_list|)
condition|)
return|return
name|false
return|;
block|}
else|else
block|{
name|info
operator|->
name|lineno_name_indx
operator|=
name|info
operator|->
name|name_indx
expr_stmt|;
operator|++
name|info
operator|->
name|name_indx
expr_stmt|;
if|if
condition|(
operator|!
name|ieee_change_buffer
argument_list|(
name|info
argument_list|,
operator|&
name|info
operator|->
name|linenos
argument_list|)
operator|||
operator|!
name|ieee_write_byte
argument_list|(
name|info
argument_list|,
operator|(
name|int
operator|)
name|ieee_bb_record_enum
argument_list|)
operator|||
operator|!
name|ieee_write_byte
argument_list|(
name|info
argument_list|,
literal|5
argument_list|)
operator|||
operator|!
name|ieee_write_number
argument_list|(
name|info
argument_list|,
literal|0
argument_list|)
operator|||
operator|!
name|ieee_write_id
argument_list|(
name|info
argument_list|,
name|info
operator|->
name|filename
argument_list|)
operator|||
operator|!
name|ieee_write_byte
argument_list|(
name|info
argument_list|,
operator|(
name|int
operator|)
name|ieee_nn_record
argument_list|)
operator|||
operator|!
name|ieee_write_number
argument_list|(
name|info
argument_list|,
name|info
operator|->
name|lineno_name_indx
argument_list|)
operator|||
operator|!
name|ieee_write_id
argument_list|(
name|info
argument_list|,
literal|""
argument_list|)
condition|)
return|return
name|false
return|;
name|info
operator|->
name|lineno_filename
operator|=
name|info
operator|->
name|filename
expr_stmt|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|info
operator|->
name|pending_lineno_filename
argument_list|,
name|info
operator|->
name|lineno_filename
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|info
operator|->
name|filename
argument_list|,
name|info
operator|->
name|lineno_filename
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* We were not in the main file.  Close the block for the 		 included file.  */
if|if
condition|(
operator|!
name|ieee_write_byte
argument_list|(
name|info
argument_list|,
operator|(
name|int
operator|)
name|ieee_be_record_enum
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|info
operator|->
name|filename
argument_list|,
name|info
operator|->
name|pending_lineno_filename
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* We need a new NN record, and we aren't about to 		     output one.  */
name|info
operator|->
name|lineno_name_indx
operator|=
name|info
operator|->
name|name_indx
expr_stmt|;
operator|++
name|info
operator|->
name|name_indx
expr_stmt|;
if|if
condition|(
operator|!
name|ieee_write_byte
argument_list|(
name|info
argument_list|,
operator|(
name|int
operator|)
name|ieee_nn_record
argument_list|)
operator|||
operator|!
name|ieee_write_number
argument_list|(
name|info
argument_list|,
name|info
operator|->
name|lineno_name_indx
argument_list|)
operator|||
operator|!
name|ieee_write_id
argument_list|(
name|info
argument_list|,
literal|""
argument_list|)
condition|)
return|return
name|false
return|;
block|}
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|info
operator|->
name|filename
argument_list|,
name|info
operator|->
name|pending_lineno_filename
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* We are not changing to the main file.  Open a block for 		 the new included file.  */
name|info
operator|->
name|lineno_name_indx
operator|=
name|info
operator|->
name|name_indx
expr_stmt|;
operator|++
name|info
operator|->
name|name_indx
expr_stmt|;
if|if
condition|(
operator|!
name|ieee_write_byte
argument_list|(
name|info
argument_list|,
operator|(
name|int
operator|)
name|ieee_bb_record_enum
argument_list|)
operator|||
operator|!
name|ieee_write_byte
argument_list|(
name|info
argument_list|,
literal|5
argument_list|)
operator|||
operator|!
name|ieee_write_number
argument_list|(
name|info
argument_list|,
literal|0
argument_list|)
operator|||
operator|!
name|ieee_write_id
argument_list|(
name|info
argument_list|,
name|info
operator|->
name|pending_lineno_filename
argument_list|)
operator|||
operator|!
name|ieee_write_byte
argument_list|(
name|info
argument_list|,
operator|(
name|int
operator|)
name|ieee_nn_record
argument_list|)
operator|||
operator|!
name|ieee_write_number
argument_list|(
name|info
argument_list|,
name|info
operator|->
name|lineno_name_indx
argument_list|)
operator|||
operator|!
name|ieee_write_id
argument_list|(
name|info
argument_list|,
literal|""
argument_list|)
condition|)
return|return
name|false
return|;
block|}
name|info
operator|->
name|lineno_filename
operator|=
name|info
operator|->
name|pending_lineno_filename
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|ieee_write_2bytes
argument_list|(
name|info
argument_list|,
operator|(
name|int
operator|)
name|ieee_atn_record_enum
argument_list|)
operator|||
operator|!
name|ieee_write_number
argument_list|(
name|info
argument_list|,
name|info
operator|->
name|lineno_name_indx
argument_list|)
operator|||
operator|!
name|ieee_write_number
argument_list|(
name|info
argument_list|,
literal|0
argument_list|)
operator|||
operator|!
name|ieee_write_number
argument_list|(
name|info
argument_list|,
literal|7
argument_list|)
operator|||
operator|!
name|ieee_write_number
argument_list|(
name|info
argument_list|,
name|info
operator|->
name|pending_lineno
argument_list|)
operator|||
operator|!
name|ieee_write_number
argument_list|(
name|info
argument_list|,
literal|0
argument_list|)
operator|||
operator|!
name|ieee_write_asn
argument_list|(
name|info
argument_list|,
name|info
operator|->
name|lineno_name_indx
argument_list|,
name|info
operator|->
name|pending_lineno_addr
argument_list|)
condition|)
return|return
name|false
return|;
block|}
name|info
operator|->
name|pending_lineno_filename
operator|=
name|filename
expr_stmt|;
name|info
operator|->
name|pending_lineno
operator|=
name|lineno
expr_stmt|;
name|info
operator|->
name|pending_lineno_addr
operator|=
name|addr
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

end_unit

