begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* wrstabs.c -- Output stabs debugging information    Copyright 1996, 1997, 1998, 2000, 2001 Free Software Foundation, Inc.    Written by Ian Lance Taylor<ian@cygnus.com>.     This file is part of GNU Binutils.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA    02111-1307, USA.  */
end_comment

begin_comment
comment|/* This file contains code which writes out stabs debugging    information.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"bucomm.h"
end_include

begin_include
include|#
directive|include
file|"libiberty.h"
end_include

begin_include
include|#
directive|include
file|"safe-ctype.h"
end_include

begin_include
include|#
directive|include
file|"debug.h"
end_include

begin_include
include|#
directive|include
file|"budbg.h"
end_include

begin_comment
comment|/* Meaningless definition needs by aout64.h.  FIXME.  */
end_comment

begin_define
define|#
directive|define
name|BYTES_IN_WORD
value|4
end_define

begin_include
include|#
directive|include
file|"aout/aout64.h"
end_include

begin_include
include|#
directive|include
file|"aout/stab_gnu.h"
end_include

begin_comment
comment|/* The size of a stabs symbol.  This presumes 32 bit values.  */
end_comment

begin_define
define|#
directive|define
name|STAB_SYMBOL_SIZE
value|(12)
end_define

begin_comment
comment|/* An entry in a string hash table.  */
end_comment

begin_struct
struct|struct
name|string_hash_entry
block|{
name|struct
name|bfd_hash_entry
name|root
decl_stmt|;
comment|/* Next string in this table.  */
name|struct
name|string_hash_entry
modifier|*
name|next
decl_stmt|;
comment|/* Index in string table.  */
name|long
name|index
decl_stmt|;
comment|/* Size of type if this is a typedef.  */
name|unsigned
name|int
name|size
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* A string hash table.  */
end_comment

begin_struct
struct|struct
name|string_hash_table
block|{
name|struct
name|bfd_hash_table
name|table
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* The type stack.  Each element on the stack is a string.  */
end_comment

begin_struct
struct|struct
name|stab_type_stack
block|{
comment|/* The next element on the stack.  */
name|struct
name|stab_type_stack
modifier|*
name|next
decl_stmt|;
comment|/* This element as a string.  */
name|char
modifier|*
name|string
decl_stmt|;
comment|/* The type index of this element.  */
name|long
name|index
decl_stmt|;
comment|/* The size of the type.  */
name|unsigned
name|int
name|size
decl_stmt|;
comment|/* Whether type string defines a new type.  */
name|boolean
name|definition
decl_stmt|;
comment|/* String defining struct fields.  */
name|char
modifier|*
name|fields
decl_stmt|;
comment|/* NULL terminated array of strings defining base classes for a      class.  */
name|char
modifier|*
modifier|*
name|baseclasses
decl_stmt|;
comment|/* String defining class methods.  */
name|char
modifier|*
name|methods
decl_stmt|;
comment|/* String defining vtable pointer for a class.  */
name|char
modifier|*
name|vtable
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* This structure is used to keep track of type indices for tagged    types.  */
end_comment

begin_struct
struct|struct
name|stab_tag
block|{
comment|/* The type index.  */
name|long
name|index
decl_stmt|;
comment|/* The tag name.  */
specifier|const
name|char
modifier|*
name|tag
decl_stmt|;
comment|/* The kind of type.  This is set to DEBUG_KIND_ILLEGAL when the      type is defined.  */
name|enum
name|debug_type_kind
name|kind
decl_stmt|;
comment|/* The size of the struct.  */
name|unsigned
name|int
name|size
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* We remember various sorts of type indices.  They are not related,    but, for convenience, we keep all the information in this    structure.  */
end_comment

begin_struct
struct|struct
name|stab_type_cache
block|{
comment|/* The void type index.  */
name|long
name|void_type
decl_stmt|;
comment|/* Signed integer type indices, indexed by size - 1.  */
name|long
name|signed_integer_types
index|[
literal|8
index|]
decl_stmt|;
comment|/* Unsigned integer type indices, indexed by size - 1.  */
name|long
name|unsigned_integer_types
index|[
literal|8
index|]
decl_stmt|;
comment|/* Floating point types, indexed by size - 1.  */
name|long
name|float_types
index|[
literal|16
index|]
decl_stmt|;
comment|/* Pointers to types, indexed by the type index.  */
name|long
modifier|*
name|pointer_types
decl_stmt|;
name|size_t
name|pointer_types_alloc
decl_stmt|;
comment|/* Functions returning types, indexed by the type index.  */
name|long
modifier|*
name|function_types
decl_stmt|;
name|size_t
name|function_types_alloc
decl_stmt|;
comment|/* References to types, indexed by the type index.  */
name|long
modifier|*
name|reference_types
decl_stmt|;
name|size_t
name|reference_types_alloc
decl_stmt|;
comment|/* Struct/union/class type indices, indexed by the struct id.  */
name|struct
name|stab_tag
modifier|*
name|struct_types
decl_stmt|;
name|size_t
name|struct_types_alloc
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* This is the handle passed through debug_write.  */
end_comment

begin_struct
struct|struct
name|stab_write_handle
block|{
comment|/* The BFD.  */
name|bfd
modifier|*
name|abfd
decl_stmt|;
comment|/* This buffer holds the symbols.  */
name|bfd_byte
modifier|*
name|symbols
decl_stmt|;
name|size_t
name|symbols_size
decl_stmt|;
name|size_t
name|symbols_alloc
decl_stmt|;
comment|/* This is a list of hash table entries for the strings.  */
name|struct
name|string_hash_entry
modifier|*
name|strings
decl_stmt|;
comment|/* The last string hash table entry.  */
name|struct
name|string_hash_entry
modifier|*
name|last_string
decl_stmt|;
comment|/* The size of the strings.  */
name|size_t
name|strings_size
decl_stmt|;
comment|/* This hash table eliminates duplicate strings.  */
name|struct
name|string_hash_table
name|strhash
decl_stmt|;
comment|/* The type stack.  */
name|struct
name|stab_type_stack
modifier|*
name|type_stack
decl_stmt|;
comment|/* The next type index.  */
name|long
name|type_index
decl_stmt|;
comment|/* The type cache.  */
name|struct
name|stab_type_cache
name|type_cache
decl_stmt|;
comment|/* A mapping from typedef names to type indices.  */
name|struct
name|string_hash_table
name|typedef_hash
decl_stmt|;
comment|/* If this is not -1, it is the offset to the most recent N_SO      symbol, and the value of that symbol needs to be set.  */
name|long
name|so_offset
decl_stmt|;
comment|/* If this is not -1, it is the offset to the most recent N_FUN      symbol, and the value of that symbol needs to be set.  */
name|long
name|fun_offset
decl_stmt|;
comment|/* The last text section address seen.  */
name|bfd_vma
name|last_text_address
decl_stmt|;
comment|/* The block nesting depth.  */
name|unsigned
name|int
name|nesting
decl_stmt|;
comment|/* The function address.  */
name|bfd_vma
name|fnaddr
decl_stmt|;
comment|/* A pending LBRAC symbol.  */
name|bfd_vma
name|pending_lbrac
decl_stmt|;
comment|/* The current line number file name.  */
specifier|const
name|char
modifier|*
name|lineno_filename
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|bfd_hash_entry
modifier|*
name|string_hash_newfunc
name|PARAMS
argument_list|(
operator|(
expr|struct
name|bfd_hash_entry
operator|*
operator|,
expr|struct
name|bfd_hash_table
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|stab_write_symbol
name|PARAMS
argument_list|(
operator|(
expr|struct
name|stab_write_handle
operator|*
operator|,
name|int
operator|,
name|int
operator|,
name|bfd_vma
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|stab_push_string
name|PARAMS
argument_list|(
operator|(
expr|struct
name|stab_write_handle
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
name|long
operator|,
name|boolean
operator|,
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|stab_push_defined_type
name|PARAMS
argument_list|(
operator|(
expr|struct
name|stab_write_handle
operator|*
operator|,
name|long
operator|,
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|stab_pop_type
name|PARAMS
argument_list|(
operator|(
expr|struct
name|stab_write_handle
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|stab_modify_type
name|PARAMS
argument_list|(
operator|(
expr|struct
name|stab_write_handle
operator|*
operator|,
name|int
operator|,
name|unsigned
name|int
operator|,
name|long
operator|*
operator|*
operator|,
name|size_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|stab_get_struct_index
name|PARAMS
argument_list|(
operator|(
expr|struct
name|stab_write_handle
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
name|unsigned
name|int
operator|,
expr|enum
name|debug_type_kind
operator|,
name|unsigned
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|stab_class_method_var
name|PARAMS
argument_list|(
operator|(
expr|struct
name|stab_write_handle
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
expr|enum
name|debug_visibility
operator|,
name|boolean
operator|,
name|boolean
operator|,
name|boolean
operator|,
name|bfd_vma
operator|,
name|boolean
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|stab_start_compilation_unit
name|PARAMS
argument_list|(
operator|(
name|PTR
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|stab_start_source
name|PARAMS
argument_list|(
operator|(
name|PTR
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|stab_empty_type
name|PARAMS
argument_list|(
operator|(
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|stab_void_type
name|PARAMS
argument_list|(
operator|(
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|stab_int_type
name|PARAMS
argument_list|(
operator|(
name|PTR
operator|,
name|unsigned
name|int
operator|,
name|boolean
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|stab_float_type
name|PARAMS
argument_list|(
operator|(
name|PTR
operator|,
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|stab_complex_type
name|PARAMS
argument_list|(
operator|(
name|PTR
operator|,
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|stab_bool_type
name|PARAMS
argument_list|(
operator|(
name|PTR
operator|,
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|stab_enum_type
name|PARAMS
argument_list|(
operator|(
name|PTR
operator|,
specifier|const
name|char
operator|*
operator|,
specifier|const
name|char
operator|*
operator|*
operator|,
name|bfd_signed_vma
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|stab_pointer_type
name|PARAMS
argument_list|(
operator|(
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|stab_function_type
name|PARAMS
argument_list|(
operator|(
name|PTR
operator|,
name|int
operator|,
name|boolean
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|stab_reference_type
name|PARAMS
argument_list|(
operator|(
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|stab_range_type
name|PARAMS
argument_list|(
operator|(
name|PTR
operator|,
name|bfd_signed_vma
operator|,
name|bfd_signed_vma
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|stab_array_type
name|PARAMS
argument_list|(
operator|(
name|PTR
operator|,
name|bfd_signed_vma
operator|,
name|bfd_signed_vma
operator|,
name|boolean
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|stab_set_type
name|PARAMS
argument_list|(
operator|(
name|PTR
operator|,
name|boolean
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|stab_offset_type
name|PARAMS
argument_list|(
operator|(
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|stab_method_type
name|PARAMS
argument_list|(
operator|(
name|PTR
operator|,
name|boolean
operator|,
name|int
operator|,
name|boolean
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|stab_const_type
name|PARAMS
argument_list|(
operator|(
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|stab_volatile_type
name|PARAMS
argument_list|(
operator|(
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|stab_start_struct_type
name|PARAMS
argument_list|(
operator|(
name|PTR
operator|,
specifier|const
name|char
operator|*
operator|,
name|unsigned
name|int
operator|,
name|boolean
operator|,
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|stab_struct_field
name|PARAMS
argument_list|(
operator|(
name|PTR
operator|,
specifier|const
name|char
operator|*
operator|,
name|bfd_vma
operator|,
name|bfd_vma
operator|,
expr|enum
name|debug_visibility
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|stab_end_struct_type
name|PARAMS
argument_list|(
operator|(
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|stab_start_class_type
name|PARAMS
argument_list|(
operator|(
name|PTR
operator|,
specifier|const
name|char
operator|*
operator|,
name|unsigned
name|int
operator|,
name|boolean
operator|,
name|unsigned
name|int
operator|,
name|boolean
operator|,
name|boolean
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|stab_class_static_member
name|PARAMS
argument_list|(
operator|(
name|PTR
operator|,
specifier|const
name|char
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
expr|enum
name|debug_visibility
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|stab_class_baseclass
name|PARAMS
argument_list|(
operator|(
name|PTR
operator|,
name|bfd_vma
operator|,
name|boolean
operator|,
expr|enum
name|debug_visibility
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|stab_class_start_method
name|PARAMS
argument_list|(
operator|(
name|PTR
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|stab_class_method_variant
name|PARAMS
argument_list|(
operator|(
name|PTR
operator|,
specifier|const
name|char
operator|*
operator|,
expr|enum
name|debug_visibility
operator|,
name|boolean
operator|,
name|boolean
operator|,
name|bfd_vma
operator|,
name|boolean
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|stab_class_static_method_variant
name|PARAMS
argument_list|(
operator|(
name|PTR
operator|,
specifier|const
name|char
operator|*
operator|,
expr|enum
name|debug_visibility
operator|,
name|boolean
operator|,
name|boolean
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|stab_class_end_method
name|PARAMS
argument_list|(
operator|(
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|stab_end_class_type
name|PARAMS
argument_list|(
operator|(
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|stab_typedef_type
name|PARAMS
argument_list|(
operator|(
name|PTR
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|stab_tag_type
name|PARAMS
argument_list|(
operator|(
name|PTR
operator|,
specifier|const
name|char
operator|*
operator|,
name|unsigned
name|int
operator|,
expr|enum
name|debug_type_kind
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|stab_typdef
name|PARAMS
argument_list|(
operator|(
name|PTR
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|stab_tag
name|PARAMS
argument_list|(
operator|(
name|PTR
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|stab_int_constant
name|PARAMS
argument_list|(
operator|(
name|PTR
operator|,
specifier|const
name|char
operator|*
operator|,
name|bfd_vma
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|stab_float_constant
name|PARAMS
argument_list|(
operator|(
name|PTR
operator|,
specifier|const
name|char
operator|*
operator|,
name|double
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|stab_typed_constant
name|PARAMS
argument_list|(
operator|(
name|PTR
operator|,
specifier|const
name|char
operator|*
operator|,
name|bfd_vma
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|stab_variable
name|PARAMS
argument_list|(
operator|(
name|PTR
operator|,
specifier|const
name|char
operator|*
operator|,
expr|enum
name|debug_var_kind
operator|,
name|bfd_vma
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|stab_start_function
name|PARAMS
argument_list|(
operator|(
name|PTR
operator|,
specifier|const
name|char
operator|*
operator|,
name|boolean
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|stab_function_parameter
name|PARAMS
argument_list|(
operator|(
name|PTR
operator|,
specifier|const
name|char
operator|*
operator|,
expr|enum
name|debug_parm_kind
operator|,
name|bfd_vma
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|stab_start_block
name|PARAMS
argument_list|(
operator|(
name|PTR
operator|,
name|bfd_vma
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|stab_end_block
name|PARAMS
argument_list|(
operator|(
name|PTR
operator|,
name|bfd_vma
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|stab_end_function
name|PARAMS
argument_list|(
operator|(
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|stab_lineno
name|PARAMS
argument_list|(
operator|(
name|PTR
operator|,
specifier|const
name|char
operator|*
operator|,
name|unsigned
name|long
operator|,
name|bfd_vma
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|debug_write_fns
name|stab_fns
init|=
block|{
name|stab_start_compilation_unit
block|,
name|stab_start_source
block|,
name|stab_empty_type
block|,
name|stab_void_type
block|,
name|stab_int_type
block|,
name|stab_float_type
block|,
name|stab_complex_type
block|,
name|stab_bool_type
block|,
name|stab_enum_type
block|,
name|stab_pointer_type
block|,
name|stab_function_type
block|,
name|stab_reference_type
block|,
name|stab_range_type
block|,
name|stab_array_type
block|,
name|stab_set_type
block|,
name|stab_offset_type
block|,
name|stab_method_type
block|,
name|stab_const_type
block|,
name|stab_volatile_type
block|,
name|stab_start_struct_type
block|,
name|stab_struct_field
block|,
name|stab_end_struct_type
block|,
name|stab_start_class_type
block|,
name|stab_class_static_member
block|,
name|stab_class_baseclass
block|,
name|stab_class_start_method
block|,
name|stab_class_method_variant
block|,
name|stab_class_static_method_variant
block|,
name|stab_class_end_method
block|,
name|stab_end_class_type
block|,
name|stab_typedef_type
block|,
name|stab_tag_type
block|,
name|stab_typdef
block|,
name|stab_tag
block|,
name|stab_int_constant
block|,
name|stab_float_constant
block|,
name|stab_typed_constant
block|,
name|stab_variable
block|,
name|stab_start_function
block|,
name|stab_function_parameter
block|,
name|stab_start_block
block|,
name|stab_end_block
block|,
name|stab_end_function
block|,
name|stab_lineno
block|}
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Routine to create an entry in a string hash table.  */
end_comment

begin_function
specifier|static
name|struct
name|bfd_hash_entry
modifier|*
name|string_hash_newfunc
parameter_list|(
name|entry
parameter_list|,
name|table
parameter_list|,
name|string
parameter_list|)
name|struct
name|bfd_hash_entry
modifier|*
name|entry
decl_stmt|;
name|struct
name|bfd_hash_table
modifier|*
name|table
decl_stmt|;
specifier|const
name|char
modifier|*
name|string
decl_stmt|;
block|{
name|struct
name|string_hash_entry
modifier|*
name|ret
init|=
operator|(
expr|struct
name|string_hash_entry
operator|*
operator|)
name|entry
decl_stmt|;
comment|/* Allocate the structure if it has not already been allocated by a      subclass.  */
if|if
condition|(
name|ret
operator|==
operator|(
expr|struct
name|string_hash_entry
operator|*
operator|)
name|NULL
condition|)
name|ret
operator|=
operator|(
operator|(
expr|struct
name|string_hash_entry
operator|*
operator|)
name|bfd_hash_allocate
argument_list|(
name|table
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|string_hash_entry
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
operator|(
expr|struct
name|string_hash_entry
operator|*
operator|)
name|NULL
condition|)
return|return
name|NULL
return|;
comment|/* Call the allocation method of the superclass.  */
name|ret
operator|=
operator|(
operator|(
expr|struct
name|string_hash_entry
operator|*
operator|)
name|bfd_hash_newfunc
argument_list|(
operator|(
expr|struct
name|bfd_hash_entry
operator|*
operator|)
name|ret
argument_list|,
name|table
argument_list|,
name|string
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
comment|/* Initialize the local fields.  */
name|ret
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|ret
operator|->
name|index
operator|=
operator|-
literal|1
expr_stmt|;
name|ret
operator|->
name|size
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
expr|struct
name|bfd_hash_entry
operator|*
operator|)
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Look up an entry in a string hash table.  */
end_comment

begin_define
define|#
directive|define
name|string_hash_lookup
parameter_list|(
name|t
parameter_list|,
name|string
parameter_list|,
name|create
parameter_list|,
name|copy
parameter_list|)
define|\
value|((struct string_hash_entry *) \    bfd_hash_lookup (&(t)->table, (string), (create), (copy)))
end_define

begin_comment
comment|/* Add a symbol to the stabs debugging information we are building.  */
end_comment

begin_function
specifier|static
name|boolean
name|stab_write_symbol
parameter_list|(
name|info
parameter_list|,
name|type
parameter_list|,
name|desc
parameter_list|,
name|value
parameter_list|,
name|string
parameter_list|)
name|struct
name|stab_write_handle
modifier|*
name|info
decl_stmt|;
name|int
name|type
decl_stmt|;
name|int
name|desc
decl_stmt|;
name|bfd_vma
name|value
decl_stmt|;
specifier|const
name|char
modifier|*
name|string
decl_stmt|;
block|{
name|bfd_size_type
name|strx
decl_stmt|;
name|bfd_byte
name|sym
index|[
name|STAB_SYMBOL_SIZE
index|]
decl_stmt|;
if|if
condition|(
name|string
operator|==
name|NULL
condition|)
name|strx
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|struct
name|string_hash_entry
modifier|*
name|h
decl_stmt|;
name|h
operator|=
name|string_hash_lookup
argument_list|(
operator|&
name|info
operator|->
name|strhash
argument_list|,
name|string
argument_list|,
name|true
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|==
name|NULL
condition|)
block|{
name|non_fatal
argument_list|(
name|_
argument_list|(
literal|"string_hash_lookup failed: %s"
argument_list|)
argument_list|,
name|bfd_errmsg
argument_list|(
name|bfd_get_error
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
name|h
operator|->
name|index
operator|!=
operator|-
literal|1
condition|)
name|strx
operator|=
name|h
operator|->
name|index
expr_stmt|;
else|else
block|{
name|strx
operator|=
name|info
operator|->
name|strings_size
expr_stmt|;
name|h
operator|->
name|index
operator|=
name|strx
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|last_string
operator|==
name|NULL
condition|)
name|info
operator|->
name|strings
operator|=
name|h
expr_stmt|;
else|else
name|info
operator|->
name|last_string
operator|->
name|next
operator|=
name|h
expr_stmt|;
name|info
operator|->
name|last_string
operator|=
name|h
expr_stmt|;
name|info
operator|->
name|strings_size
operator|+=
name|strlen
argument_list|(
name|string
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
block|}
comment|/* This presumes 32 bit values.  */
name|bfd_put_32
argument_list|(
name|info
operator|->
name|abfd
argument_list|,
name|strx
argument_list|,
name|sym
argument_list|)
expr_stmt|;
name|bfd_put_8
argument_list|(
name|info
operator|->
name|abfd
argument_list|,
name|type
argument_list|,
name|sym
operator|+
literal|4
argument_list|)
expr_stmt|;
name|bfd_put_8
argument_list|(
name|info
operator|->
name|abfd
argument_list|,
literal|0
argument_list|,
name|sym
operator|+
literal|5
argument_list|)
expr_stmt|;
name|bfd_put_16
argument_list|(
name|info
operator|->
name|abfd
argument_list|,
name|desc
argument_list|,
name|sym
operator|+
literal|6
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|info
operator|->
name|abfd
argument_list|,
name|value
argument_list|,
name|sym
operator|+
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|symbols_size
operator|+
name|STAB_SYMBOL_SIZE
operator|>
name|info
operator|->
name|symbols_alloc
condition|)
block|{
name|info
operator|->
name|symbols_alloc
operator|*=
literal|2
expr_stmt|;
name|info
operator|->
name|symbols
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|xrealloc
argument_list|(
name|info
operator|->
name|symbols
argument_list|,
name|info
operator|->
name|symbols_alloc
argument_list|)
expr_stmt|;
block|}
name|memcpy
argument_list|(
name|info
operator|->
name|symbols
operator|+
name|info
operator|->
name|symbols_size
argument_list|,
name|sym
argument_list|,
name|STAB_SYMBOL_SIZE
argument_list|)
expr_stmt|;
name|info
operator|->
name|symbols_size
operator|+=
name|STAB_SYMBOL_SIZE
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Push a string on to the type stack.  */
end_comment

begin_function
specifier|static
name|boolean
name|stab_push_string
parameter_list|(
name|info
parameter_list|,
name|string
parameter_list|,
name|index
parameter_list|,
name|definition
parameter_list|,
name|size
parameter_list|)
name|struct
name|stab_write_handle
modifier|*
name|info
decl_stmt|;
specifier|const
name|char
modifier|*
name|string
decl_stmt|;
name|long
name|index
decl_stmt|;
name|boolean
name|definition
decl_stmt|;
name|unsigned
name|int
name|size
decl_stmt|;
block|{
name|struct
name|stab_type_stack
modifier|*
name|s
decl_stmt|;
name|s
operator|=
operator|(
expr|struct
name|stab_type_stack
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
expr|*
name|s
argument_list|)
expr_stmt|;
name|s
operator|->
name|string
operator|=
name|xstrdup
argument_list|(
name|string
argument_list|)
expr_stmt|;
name|s
operator|->
name|index
operator|=
name|index
expr_stmt|;
name|s
operator|->
name|definition
operator|=
name|definition
expr_stmt|;
name|s
operator|->
name|size
operator|=
name|size
expr_stmt|;
name|s
operator|->
name|fields
operator|=
name|NULL
expr_stmt|;
name|s
operator|->
name|baseclasses
operator|=
name|NULL
expr_stmt|;
name|s
operator|->
name|methods
operator|=
name|NULL
expr_stmt|;
name|s
operator|->
name|vtable
operator|=
name|NULL
expr_stmt|;
name|s
operator|->
name|next
operator|=
name|info
operator|->
name|type_stack
expr_stmt|;
name|info
operator|->
name|type_stack
operator|=
name|s
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Push a type index which has already been defined.  */
end_comment

begin_function
specifier|static
name|boolean
name|stab_push_defined_type
parameter_list|(
name|info
parameter_list|,
name|index
parameter_list|,
name|size
parameter_list|)
name|struct
name|stab_write_handle
modifier|*
name|info
decl_stmt|;
name|long
name|index
decl_stmt|;
name|unsigned
name|int
name|size
decl_stmt|;
block|{
name|char
name|buf
index|[
literal|20
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%ld"
argument_list|,
name|index
argument_list|)
expr_stmt|;
return|return
name|stab_push_string
argument_list|(
name|info
argument_list|,
name|buf
argument_list|,
name|index
argument_list|,
name|false
argument_list|,
name|size
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Pop a type off the type stack.  The caller is responsible for    freeing the string.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|stab_pop_type
parameter_list|(
name|info
parameter_list|)
name|struct
name|stab_write_handle
modifier|*
name|info
decl_stmt|;
block|{
name|struct
name|stab_type_stack
modifier|*
name|s
decl_stmt|;
name|char
modifier|*
name|ret
decl_stmt|;
name|s
operator|=
name|info
operator|->
name|type_stack
expr_stmt|;
name|assert
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|info
operator|->
name|type_stack
operator|=
name|s
operator|->
name|next
expr_stmt|;
name|ret
operator|=
name|s
operator|->
name|string
expr_stmt|;
name|free
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* The general routine to write out stabs in sections debugging    information.  This accumulates the stabs symbols and the strings in    two obstacks.  We can't easily write out the information as we go    along, because we need to know the section sizes before we can    write out the section contents.  ABFD is the BFD and DHANDLE is the    handle for the debugging information.  This sets *PSYMS to point to    the symbols, *PSYMSIZE the size of the symbols, *PSTRINGS to the    strings, and *PSTRINGSIZE to the size of the strings.  */
end_comment

begin_function
name|boolean
name|write_stabs_in_sections_debugging_info
parameter_list|(
name|abfd
parameter_list|,
name|dhandle
parameter_list|,
name|psyms
parameter_list|,
name|psymsize
parameter_list|,
name|pstrings
parameter_list|,
name|pstringsize
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|PTR
name|dhandle
decl_stmt|;
name|bfd_byte
modifier|*
modifier|*
name|psyms
decl_stmt|;
name|bfd_size_type
modifier|*
name|psymsize
decl_stmt|;
name|bfd_byte
modifier|*
modifier|*
name|pstrings
decl_stmt|;
name|bfd_size_type
modifier|*
name|pstringsize
decl_stmt|;
block|{
name|struct
name|stab_write_handle
name|info
decl_stmt|;
name|struct
name|string_hash_entry
modifier|*
name|h
decl_stmt|;
name|bfd_byte
modifier|*
name|p
decl_stmt|;
name|info
operator|.
name|abfd
operator|=
name|abfd
expr_stmt|;
name|info
operator|.
name|symbols_size
operator|=
literal|0
expr_stmt|;
name|info
operator|.
name|symbols_alloc
operator|=
literal|500
expr_stmt|;
name|info
operator|.
name|symbols
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|xmalloc
argument_list|(
name|info
operator|.
name|symbols_alloc
argument_list|)
expr_stmt|;
name|info
operator|.
name|strings
operator|=
name|NULL
expr_stmt|;
name|info
operator|.
name|last_string
operator|=
name|NULL
expr_stmt|;
comment|/* Reserve 1 byte for a null byte.  */
name|info
operator|.
name|strings_size
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_hash_table_init
argument_list|(
operator|&
name|info
operator|.
name|strhash
operator|.
name|table
argument_list|,
name|string_hash_newfunc
argument_list|)
operator|||
operator|!
name|bfd_hash_table_init
argument_list|(
operator|&
name|info
operator|.
name|typedef_hash
operator|.
name|table
argument_list|,
name|string_hash_newfunc
argument_list|)
condition|)
block|{
name|non_fatal
argument_list|(
literal|"bfd_hash_table_init_failed: %s"
argument_list|,
name|bfd_errmsg
argument_list|(
name|bfd_get_error
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|info
operator|.
name|type_stack
operator|=
name|NULL
expr_stmt|;
name|info
operator|.
name|type_index
operator|=
literal|1
expr_stmt|;
name|memset
argument_list|(
operator|&
name|info
operator|.
name|type_cache
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|info
operator|.
name|type_cache
argument_list|)
expr_stmt|;
name|info
operator|.
name|so_offset
operator|=
operator|-
literal|1
expr_stmt|;
name|info
operator|.
name|fun_offset
operator|=
operator|-
literal|1
expr_stmt|;
name|info
operator|.
name|last_text_address
operator|=
literal|0
expr_stmt|;
name|info
operator|.
name|nesting
operator|=
literal|0
expr_stmt|;
name|info
operator|.
name|fnaddr
operator|=
literal|0
expr_stmt|;
name|info
operator|.
name|pending_lbrac
operator|=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
expr_stmt|;
comment|/* The initial symbol holds the string size.  */
if|if
condition|(
operator|!
name|stab_write_symbol
argument_list|(
operator|&
name|info
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* Output an initial N_SO symbol.  */
name|info
operator|.
name|so_offset
operator|=
name|info
operator|.
name|symbols_size
expr_stmt|;
if|if
condition|(
operator|!
name|stab_write_symbol
argument_list|(
operator|&
name|info
argument_list|,
name|N_SO
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|!
name|debug_write
argument_list|(
name|dhandle
argument_list|,
operator|&
name|stab_fns
argument_list|,
operator|(
name|PTR
operator|)
operator|&
name|info
argument_list|)
condition|)
return|return
name|false
return|;
name|assert
argument_list|(
name|info
operator|.
name|pending_lbrac
operator|==
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* Output a trailing N_SO.  */
if|if
condition|(
operator|!
name|stab_write_symbol
argument_list|(
operator|&
name|info
argument_list|,
name|N_SO
argument_list|,
literal|0
argument_list|,
name|info
operator|.
name|last_text_address
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* Put the string size in the initial symbol.  */
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|info
operator|.
name|strings_size
argument_list|,
name|info
operator|.
name|symbols
operator|+
literal|8
argument_list|)
expr_stmt|;
operator|*
name|psyms
operator|=
name|info
operator|.
name|symbols
expr_stmt|;
operator|*
name|psymsize
operator|=
name|info
operator|.
name|symbols_size
expr_stmt|;
operator|*
name|pstringsize
operator|=
name|info
operator|.
name|strings_size
expr_stmt|;
operator|*
name|pstrings
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|xmalloc
argument_list|(
name|info
operator|.
name|strings_size
argument_list|)
expr_stmt|;
name|p
operator|=
operator|*
name|pstrings
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
name|h
operator|=
name|info
operator|.
name|strings
init|;
name|h
operator|!=
name|NULL
condition|;
name|h
operator|=
name|h
operator|->
name|next
control|)
block|{
name|strcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|p
argument_list|,
name|h
operator|->
name|root
operator|.
name|string
argument_list|)
expr_stmt|;
name|p
operator|+=
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|p
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Start writing out information for a compilation unit.  */
end_comment

begin_function
specifier|static
name|boolean
name|stab_start_compilation_unit
parameter_list|(
name|p
parameter_list|,
name|filename
parameter_list|)
name|PTR
name|p
decl_stmt|;
specifier|const
name|char
modifier|*
name|filename
decl_stmt|;
block|{
name|struct
name|stab_write_handle
modifier|*
name|info
init|=
operator|(
expr|struct
name|stab_write_handle
operator|*
operator|)
name|p
decl_stmt|;
comment|/* We would normally output an N_SO symbol here.  However, that      would force us to reset all of our type information.  I think we      will be better off just outputting an N_SOL symbol, and not      worrying about splitting information between files.  */
name|info
operator|->
name|lineno_filename
operator|=
name|filename
expr_stmt|;
return|return
name|stab_write_symbol
argument_list|(
name|info
argument_list|,
name|N_SOL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|filename
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Start writing out information for a particular source file.  */
end_comment

begin_function
specifier|static
name|boolean
name|stab_start_source
parameter_list|(
name|p
parameter_list|,
name|filename
parameter_list|)
name|PTR
name|p
decl_stmt|;
specifier|const
name|char
modifier|*
name|filename
decl_stmt|;
block|{
name|struct
name|stab_write_handle
modifier|*
name|info
init|=
operator|(
expr|struct
name|stab_write_handle
operator|*
operator|)
name|p
decl_stmt|;
comment|/* FIXME: The symbol's value is supposed to be the text section      address.  However, we would have to fill it in later, and gdb      doesn't care, so we don't bother with it.  */
name|info
operator|->
name|lineno_filename
operator|=
name|filename
expr_stmt|;
return|return
name|stab_write_symbol
argument_list|(
name|info
argument_list|,
name|N_SOL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|filename
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Push an empty type.  This shouldn't normally happen.  We just use a    void type.  */
end_comment

begin_function
specifier|static
name|boolean
name|stab_empty_type
parameter_list|(
name|p
parameter_list|)
name|PTR
name|p
decl_stmt|;
block|{
name|struct
name|stab_write_handle
modifier|*
name|info
init|=
operator|(
expr|struct
name|stab_write_handle
operator|*
operator|)
name|p
decl_stmt|;
comment|/* We don't call stab_void_type if the type is not yet defined,      because that might screw up the typedef.  */
if|if
condition|(
name|info
operator|->
name|type_cache
operator|.
name|void_type
operator|!=
literal|0
condition|)
return|return
name|stab_push_defined_type
argument_list|(
name|info
argument_list|,
name|info
operator|->
name|type_cache
operator|.
name|void_type
argument_list|,
literal|0
argument_list|)
return|;
else|else
block|{
name|long
name|index
decl_stmt|;
name|char
name|buf
index|[
literal|40
index|]
decl_stmt|;
name|index
operator|=
name|info
operator|->
name|type_index
expr_stmt|;
operator|++
name|info
operator|->
name|type_index
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%ld=%ld"
argument_list|,
name|index
argument_list|,
name|index
argument_list|)
expr_stmt|;
return|return
name|stab_push_string
argument_list|(
name|info
argument_list|,
name|buf
argument_list|,
name|index
argument_list|,
name|false
argument_list|,
literal|0
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* Push a void type.  */
end_comment

begin_function
specifier|static
name|boolean
name|stab_void_type
parameter_list|(
name|p
parameter_list|)
name|PTR
name|p
decl_stmt|;
block|{
name|struct
name|stab_write_handle
modifier|*
name|info
init|=
operator|(
expr|struct
name|stab_write_handle
operator|*
operator|)
name|p
decl_stmt|;
if|if
condition|(
name|info
operator|->
name|type_cache
operator|.
name|void_type
operator|!=
literal|0
condition|)
return|return
name|stab_push_defined_type
argument_list|(
name|info
argument_list|,
name|info
operator|->
name|type_cache
operator|.
name|void_type
argument_list|,
literal|0
argument_list|)
return|;
else|else
block|{
name|long
name|index
decl_stmt|;
name|char
name|buf
index|[
literal|40
index|]
decl_stmt|;
name|index
operator|=
name|info
operator|->
name|type_index
expr_stmt|;
operator|++
name|info
operator|->
name|type_index
expr_stmt|;
name|info
operator|->
name|type_cache
operator|.
name|void_type
operator|=
name|index
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%ld=%ld"
argument_list|,
name|index
argument_list|,
name|index
argument_list|)
expr_stmt|;
return|return
name|stab_push_string
argument_list|(
name|info
argument_list|,
name|buf
argument_list|,
name|index
argument_list|,
name|true
argument_list|,
literal|0
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* Push an integer type.  */
end_comment

begin_function
specifier|static
name|boolean
name|stab_int_type
parameter_list|(
name|p
parameter_list|,
name|size
parameter_list|,
name|unsignedp
parameter_list|)
name|PTR
name|p
decl_stmt|;
name|unsigned
name|int
name|size
decl_stmt|;
name|boolean
name|unsignedp
decl_stmt|;
block|{
name|struct
name|stab_write_handle
modifier|*
name|info
init|=
operator|(
expr|struct
name|stab_write_handle
operator|*
operator|)
name|p
decl_stmt|;
name|long
modifier|*
name|cache
decl_stmt|;
if|if
condition|(
name|size
operator|<=
literal|0
operator|||
operator|(
name|size
operator|>
sizeof|sizeof
argument_list|(
name|long
argument_list|)
operator|&&
name|size
operator|!=
literal|8
operator|)
condition|)
block|{
name|non_fatal
argument_list|(
name|_
argument_list|(
literal|"stab_int_type: bad size %u"
argument_list|)
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
name|unsignedp
condition|)
name|cache
operator|=
name|info
operator|->
name|type_cache
operator|.
name|signed_integer_types
expr_stmt|;
else|else
name|cache
operator|=
name|info
operator|->
name|type_cache
operator|.
name|unsigned_integer_types
expr_stmt|;
if|if
condition|(
name|cache
index|[
name|size
operator|-
literal|1
index|]
operator|!=
literal|0
condition|)
return|return
name|stab_push_defined_type
argument_list|(
name|info
argument_list|,
name|cache
index|[
name|size
operator|-
literal|1
index|]
argument_list|,
name|size
argument_list|)
return|;
else|else
block|{
name|long
name|index
decl_stmt|;
name|char
name|buf
index|[
literal|100
index|]
decl_stmt|;
name|index
operator|=
name|info
operator|->
name|type_index
expr_stmt|;
operator|++
name|info
operator|->
name|type_index
expr_stmt|;
name|cache
index|[
name|size
operator|-
literal|1
index|]
operator|=
name|index
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%ld=r%ld;"
argument_list|,
name|index
argument_list|,
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|unsignedp
condition|)
block|{
name|strcat
argument_list|(
name|buf
argument_list|,
literal|"0;"
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|<
sizeof|sizeof
argument_list|(
name|long
argument_list|)
condition|)
name|sprintf
argument_list|(
name|buf
operator|+
name|strlen
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"%ld;"
argument_list|,
operator|(
operator|(
name|long
operator|)
literal|1
operator|<<
operator|(
name|size
operator|*
literal|8
operator|)
operator|)
operator|-
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|size
operator|==
sizeof|sizeof
argument_list|(
name|long
argument_list|)
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|"-1;"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|size
operator|==
literal|8
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|"01777777777777777777777;"
argument_list|)
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|size
operator|<=
sizeof|sizeof
argument_list|(
name|long
argument_list|)
condition|)
name|sprintf
argument_list|(
name|buf
operator|+
name|strlen
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"%ld;%ld;"
argument_list|,
operator|(
name|long
operator|)
operator|-
operator|(
operator|(
name|unsigned
name|long
operator|)
literal|1
operator|<<
operator|(
name|size
operator|*
literal|8
operator|-
literal|1
operator|)
operator|)
argument_list|,
call|(
name|long
call|)
argument_list|(
operator|(
operator|(
name|unsigned
name|long
operator|)
literal|1
operator|<<
operator|(
name|size
operator|*
literal|8
operator|-
literal|1
operator|)
operator|)
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|size
operator|==
literal|8
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|"01000000000000000000000;0777777777777777777777;"
argument_list|)
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
return|return
name|stab_push_string
argument_list|(
name|info
argument_list|,
name|buf
argument_list|,
name|index
argument_list|,
name|true
argument_list|,
name|size
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* Push a floating point type.  */
end_comment

begin_function
specifier|static
name|boolean
name|stab_float_type
parameter_list|(
name|p
parameter_list|,
name|size
parameter_list|)
name|PTR
name|p
decl_stmt|;
name|unsigned
name|int
name|size
decl_stmt|;
block|{
name|struct
name|stab_write_handle
modifier|*
name|info
init|=
operator|(
expr|struct
name|stab_write_handle
operator|*
operator|)
name|p
decl_stmt|;
if|if
condition|(
name|size
operator|>
literal|0
operator|&&
name|size
operator|-
literal|1
operator|<
operator|(
sizeof|sizeof
name|info
operator|->
name|type_cache
operator|.
name|float_types
operator|/
sizeof|sizeof
name|info
operator|->
name|type_cache
operator|.
name|float_types
index|[
literal|0
index|]
operator|)
operator|&&
name|info
operator|->
name|type_cache
operator|.
name|float_types
index|[
name|size
operator|-
literal|1
index|]
operator|!=
literal|0
condition|)
return|return
name|stab_push_defined_type
argument_list|(
name|info
argument_list|,
name|info
operator|->
name|type_cache
operator|.
name|float_types
index|[
name|size
operator|-
literal|1
index|]
argument_list|,
name|size
argument_list|)
return|;
else|else
block|{
name|long
name|index
decl_stmt|;
name|char
modifier|*
name|int_type
decl_stmt|;
name|char
name|buf
index|[
literal|50
index|]
decl_stmt|;
comment|/* Floats are defined as a subrange of int.  */
if|if
condition|(
operator|!
name|stab_int_type
argument_list|(
name|info
argument_list|,
literal|4
argument_list|,
name|false
argument_list|)
condition|)
return|return
name|false
return|;
name|int_type
operator|=
name|stab_pop_type
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|index
operator|=
name|info
operator|->
name|type_index
expr_stmt|;
operator|++
name|info
operator|->
name|type_index
expr_stmt|;
if|if
condition|(
name|size
operator|>
literal|0
operator|&&
name|size
operator|-
literal|1
operator|<
operator|(
sizeof|sizeof
name|info
operator|->
name|type_cache
operator|.
name|float_types
operator|/
sizeof|sizeof
name|info
operator|->
name|type_cache
operator|.
name|float_types
index|[
literal|0
index|]
operator|)
condition|)
name|info
operator|->
name|type_cache
operator|.
name|float_types
index|[
name|size
operator|-
literal|1
index|]
operator|=
name|index
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%ld=r%s;%u;0;"
argument_list|,
name|index
argument_list|,
name|int_type
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|int_type
argument_list|)
expr_stmt|;
return|return
name|stab_push_string
argument_list|(
name|info
argument_list|,
name|buf
argument_list|,
name|index
argument_list|,
name|true
argument_list|,
name|size
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* Push a complex type.  */
end_comment

begin_function
specifier|static
name|boolean
name|stab_complex_type
parameter_list|(
name|p
parameter_list|,
name|size
parameter_list|)
name|PTR
name|p
decl_stmt|;
name|unsigned
name|int
name|size
decl_stmt|;
block|{
name|struct
name|stab_write_handle
modifier|*
name|info
init|=
operator|(
expr|struct
name|stab_write_handle
operator|*
operator|)
name|p
decl_stmt|;
name|char
name|buf
index|[
literal|50
index|]
decl_stmt|;
name|long
name|index
decl_stmt|;
name|index
operator|=
name|info
operator|->
name|type_index
expr_stmt|;
operator|++
name|info
operator|->
name|type_index
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%ld=r%ld;%u;0;"
argument_list|,
name|index
argument_list|,
name|index
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return
name|stab_push_string
argument_list|(
name|info
argument_list|,
name|buf
argument_list|,
name|index
argument_list|,
name|true
argument_list|,
name|size
operator|*
literal|2
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Push a boolean type.  We use an XCOFF predefined type, since gdb    always recognizes them.  */
end_comment

begin_function
specifier|static
name|boolean
name|stab_bool_type
parameter_list|(
name|p
parameter_list|,
name|size
parameter_list|)
name|PTR
name|p
decl_stmt|;
name|unsigned
name|int
name|size
decl_stmt|;
block|{
name|struct
name|stab_write_handle
modifier|*
name|info
init|=
operator|(
expr|struct
name|stab_write_handle
operator|*
operator|)
name|p
decl_stmt|;
name|long
name|index
decl_stmt|;
switch|switch
condition|(
name|size
condition|)
block|{
case|case
literal|1
case|:
name|index
operator|=
operator|-
literal|21
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|index
operator|=
operator|-
literal|22
expr_stmt|;
break|break;
default|default:
case|case
literal|4
case|:
name|index
operator|=
operator|-
literal|16
expr_stmt|;
break|break;
case|case
literal|8
case|:
name|index
operator|=
operator|-
literal|33
expr_stmt|;
break|break;
block|}
return|return
name|stab_push_defined_type
argument_list|(
name|info
argument_list|,
name|index
argument_list|,
name|size
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Push an enum type.  */
end_comment

begin_function
specifier|static
name|boolean
name|stab_enum_type
parameter_list|(
name|p
parameter_list|,
name|tag
parameter_list|,
name|names
parameter_list|,
name|vals
parameter_list|)
name|PTR
name|p
decl_stmt|;
specifier|const
name|char
modifier|*
name|tag
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|names
decl_stmt|;
name|bfd_signed_vma
modifier|*
name|vals
decl_stmt|;
block|{
name|struct
name|stab_write_handle
modifier|*
name|info
init|=
operator|(
expr|struct
name|stab_write_handle
operator|*
operator|)
name|p
decl_stmt|;
name|size_t
name|len
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|pn
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|long
name|index
init|=
literal|0
decl_stmt|;
name|bfd_signed_vma
modifier|*
name|pv
decl_stmt|;
if|if
condition|(
name|names
operator|==
name|NULL
condition|)
block|{
name|assert
argument_list|(
name|tag
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|10
operator|+
name|strlen
argument_list|(
name|tag
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"xe%s:"
argument_list|,
name|tag
argument_list|)
expr_stmt|;
comment|/* FIXME: The size is just a guess.  */
if|if
condition|(
operator|!
name|stab_push_string
argument_list|(
name|info
argument_list|,
name|buf
argument_list|,
literal|0
argument_list|,
name|false
argument_list|,
literal|4
argument_list|)
condition|)
return|return
name|false
return|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
name|len
operator|=
literal|10
expr_stmt|;
if|if
condition|(
name|tag
operator|!=
name|NULL
condition|)
name|len
operator|+=
name|strlen
argument_list|(
name|tag
argument_list|)
expr_stmt|;
for|for
control|(
name|pn
operator|=
name|names
init|;
operator|*
name|pn
operator|!=
name|NULL
condition|;
name|pn
operator|++
control|)
name|len
operator|+=
name|strlen
argument_list|(
operator|*
name|pn
argument_list|)
operator|+
literal|20
expr_stmt|;
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|tag
operator|==
name|NULL
condition|)
name|strcpy
argument_list|(
name|buf
argument_list|,
literal|"e"
argument_list|)
expr_stmt|;
else|else
block|{
name|index
operator|=
name|info
operator|->
name|type_index
expr_stmt|;
operator|++
name|info
operator|->
name|type_index
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s:T%ld=e"
argument_list|,
name|tag
argument_list|,
name|index
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|pn
operator|=
name|names
operator|,
name|pv
operator|=
name|vals
init|;
operator|*
name|pn
operator|!=
name|NULL
condition|;
name|pn
operator|++
operator|,
name|pv
operator|++
control|)
name|sprintf
argument_list|(
name|buf
operator|+
name|strlen
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"%s:%ld,"
argument_list|,
operator|*
name|pn
argument_list|,
operator|(
name|long
operator|)
operator|*
name|pv
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|buf
argument_list|,
literal|";"
argument_list|)
expr_stmt|;
if|if
condition|(
name|tag
operator|==
name|NULL
condition|)
block|{
comment|/* FIXME: The size is just a guess.  */
if|if
condition|(
operator|!
name|stab_push_string
argument_list|(
name|info
argument_list|,
name|buf
argument_list|,
literal|0
argument_list|,
name|false
argument_list|,
literal|4
argument_list|)
condition|)
return|return
name|false
return|;
block|}
else|else
block|{
comment|/* FIXME: The size is just a guess.  */
if|if
condition|(
operator|!
name|stab_write_symbol
argument_list|(
name|info
argument_list|,
name|N_LSYM
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|buf
argument_list|)
operator|||
operator|!
name|stab_push_defined_type
argument_list|(
name|info
argument_list|,
name|index
argument_list|,
literal|4
argument_list|)
condition|)
return|return
name|false
return|;
block|}
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Push a modification of the top type on the stack.  Cache the    results in CACHE and CACHE_ALLOC.  */
end_comment

begin_function
specifier|static
name|boolean
name|stab_modify_type
parameter_list|(
name|info
parameter_list|,
name|mod
parameter_list|,
name|size
parameter_list|,
name|cache
parameter_list|,
name|cache_alloc
parameter_list|)
name|struct
name|stab_write_handle
modifier|*
name|info
decl_stmt|;
name|int
name|mod
decl_stmt|;
name|unsigned
name|int
name|size
decl_stmt|;
name|long
modifier|*
modifier|*
name|cache
decl_stmt|;
name|size_t
modifier|*
name|cache_alloc
decl_stmt|;
block|{
name|long
name|targindex
decl_stmt|;
name|long
name|index
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|buf
decl_stmt|;
name|assert
argument_list|(
name|info
operator|->
name|type_stack
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|targindex
operator|=
name|info
operator|->
name|type_stack
operator|->
name|index
expr_stmt|;
if|if
condition|(
name|targindex
operator|<=
literal|0
operator|||
name|cache
operator|==
name|NULL
condition|)
block|{
name|boolean
name|definition
decl_stmt|;
comment|/* Either the target type has no index, or we aren't caching          this modifier.  Either way we have no way of recording the          new type, so we don't bother to define one.  */
name|definition
operator|=
name|info
operator|->
name|type_stack
operator|->
name|definition
expr_stmt|;
name|s
operator|=
name|stab_pop_type
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|s
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%c%s"
argument_list|,
name|mod
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|stab_push_string
argument_list|(
name|info
argument_list|,
name|buf
argument_list|,
literal|0
argument_list|,
name|definition
argument_list|,
name|size
argument_list|)
condition|)
return|return
name|false
return|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|size_t
operator|)
name|targindex
operator|>=
operator|*
name|cache_alloc
condition|)
block|{
name|size_t
name|alloc
decl_stmt|;
name|alloc
operator|=
operator|*
name|cache_alloc
expr_stmt|;
if|if
condition|(
name|alloc
operator|==
literal|0
condition|)
name|alloc
operator|=
literal|10
expr_stmt|;
while|while
condition|(
operator|(
name|size_t
operator|)
name|targindex
operator|>=
name|alloc
condition|)
name|alloc
operator|*=
literal|2
expr_stmt|;
operator|*
name|cache
operator|=
operator|(
name|long
operator|*
operator|)
name|xrealloc
argument_list|(
operator|*
name|cache
argument_list|,
name|alloc
operator|*
sizeof|sizeof
argument_list|(
name|long
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|*
name|cache
operator|+
operator|*
name|cache_alloc
argument_list|,
literal|0
argument_list|,
operator|(
name|alloc
operator|-
operator|*
name|cache_alloc
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|long
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|cache_alloc
operator|=
name|alloc
expr_stmt|;
block|}
name|index
operator|=
operator|(
operator|*
name|cache
operator|)
index|[
name|targindex
index|]
expr_stmt|;
if|if
condition|(
name|index
operator|!=
literal|0
operator|&&
operator|!
name|info
operator|->
name|type_stack
operator|->
name|definition
condition|)
block|{
comment|/* We have already defined a modification of this type, and              the entry on the type stack is not a definition, so we              can safely discard it (we may have a definition on the              stack, even if we already defined a modification, if it              is a struct which we did not define at the time it was              referenced).  */
name|free
argument_list|(
name|stab_pop_type
argument_list|(
name|info
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|stab_push_defined_type
argument_list|(
name|info
argument_list|,
name|index
argument_list|,
name|size
argument_list|)
condition|)
return|return
name|false
return|;
block|}
else|else
block|{
name|index
operator|=
name|info
operator|->
name|type_index
expr_stmt|;
operator|++
name|info
operator|->
name|type_index
expr_stmt|;
name|s
operator|=
name|stab_pop_type
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|s
argument_list|)
operator|+
literal|20
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%ld=%c%s"
argument_list|,
name|index
argument_list|,
name|mod
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|s
argument_list|)
expr_stmt|;
operator|(
operator|*
name|cache
operator|)
index|[
name|targindex
index|]
operator|=
name|index
expr_stmt|;
if|if
condition|(
operator|!
name|stab_push_string
argument_list|(
name|info
argument_list|,
name|buf
argument_list|,
name|index
argument_list|,
name|true
argument_list|,
name|size
argument_list|)
condition|)
return|return
name|false
return|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Push a pointer type.  */
end_comment

begin_function
specifier|static
name|boolean
name|stab_pointer_type
parameter_list|(
name|p
parameter_list|)
name|PTR
name|p
decl_stmt|;
block|{
name|struct
name|stab_write_handle
modifier|*
name|info
init|=
operator|(
expr|struct
name|stab_write_handle
operator|*
operator|)
name|p
decl_stmt|;
comment|/* FIXME: The size should depend upon the architecture.  */
return|return
name|stab_modify_type
argument_list|(
name|info
argument_list|,
literal|'*'
argument_list|,
literal|4
argument_list|,
operator|&
name|info
operator|->
name|type_cache
operator|.
name|pointer_types
argument_list|,
operator|&
name|info
operator|->
name|type_cache
operator|.
name|pointer_types_alloc
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Push a function type.  */
end_comment

begin_function
specifier|static
name|boolean
name|stab_function_type
parameter_list|(
name|p
parameter_list|,
name|argcount
parameter_list|,
name|varargs
parameter_list|)
name|PTR
name|p
decl_stmt|;
name|int
name|argcount
decl_stmt|;
name|boolean
name|varargs
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|struct
name|stab_write_handle
modifier|*
name|info
init|=
operator|(
expr|struct
name|stab_write_handle
operator|*
operator|)
name|p
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* We have no way to represent the argument types, so we just      discard them.  However, if they define new types, we must output      them.  We do this by producing empty typedefs.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|argcount
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|info
operator|->
name|type_stack
operator|->
name|definition
condition|)
name|free
argument_list|(
name|stab_pop_type
argument_list|(
name|info
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|buf
decl_stmt|;
name|s
operator|=
name|stab_pop_type
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|s
argument_list|)
operator|+
literal|3
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|":t%s"
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|stab_write_symbol
argument_list|(
name|info
argument_list|,
name|N_LSYM
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|buf
argument_list|)
condition|)
return|return
name|false
return|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|stab_modify_type
argument_list|(
name|info
argument_list|,
literal|'f'
argument_list|,
literal|0
argument_list|,
operator|&
name|info
operator|->
name|type_cache
operator|.
name|function_types
argument_list|,
operator|&
name|info
operator|->
name|type_cache
operator|.
name|function_types_alloc
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Push a reference type.  */
end_comment

begin_function
specifier|static
name|boolean
name|stab_reference_type
parameter_list|(
name|p
parameter_list|)
name|PTR
name|p
decl_stmt|;
block|{
name|struct
name|stab_write_handle
modifier|*
name|info
init|=
operator|(
expr|struct
name|stab_write_handle
operator|*
operator|)
name|p
decl_stmt|;
comment|/* FIXME: The size should depend upon the architecture.  */
return|return
name|stab_modify_type
argument_list|(
name|info
argument_list|,
literal|'&'
argument_list|,
literal|4
argument_list|,
operator|&
name|info
operator|->
name|type_cache
operator|.
name|reference_types
argument_list|,
operator|&
name|info
operator|->
name|type_cache
operator|.
name|reference_types_alloc
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Push a range type.  */
end_comment

begin_function
specifier|static
name|boolean
name|stab_range_type
parameter_list|(
name|p
parameter_list|,
name|low
parameter_list|,
name|high
parameter_list|)
name|PTR
name|p
decl_stmt|;
name|bfd_signed_vma
name|low
decl_stmt|;
name|bfd_signed_vma
name|high
decl_stmt|;
block|{
name|struct
name|stab_write_handle
modifier|*
name|info
init|=
operator|(
expr|struct
name|stab_write_handle
operator|*
operator|)
name|p
decl_stmt|;
name|boolean
name|definition
decl_stmt|;
name|unsigned
name|int
name|size
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|buf
decl_stmt|;
name|definition
operator|=
name|info
operator|->
name|type_stack
operator|->
name|definition
expr_stmt|;
name|size
operator|=
name|info
operator|->
name|type_stack
operator|->
name|size
expr_stmt|;
name|s
operator|=
name|stab_pop_type
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|s
argument_list|)
operator|+
literal|100
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"r%s;%ld;%ld;"
argument_list|,
name|s
argument_list|,
operator|(
name|long
operator|)
name|low
argument_list|,
operator|(
name|long
operator|)
name|high
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|stab_push_string
argument_list|(
name|info
argument_list|,
name|buf
argument_list|,
literal|0
argument_list|,
name|definition
argument_list|,
name|size
argument_list|)
condition|)
return|return
name|false
return|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Push an array type.  */
end_comment

begin_function
specifier|static
name|boolean
name|stab_array_type
parameter_list|(
name|p
parameter_list|,
name|low
parameter_list|,
name|high
parameter_list|,
name|stringp
parameter_list|)
name|PTR
name|p
decl_stmt|;
name|bfd_signed_vma
name|low
decl_stmt|;
name|bfd_signed_vma
name|high
decl_stmt|;
name|boolean
name|stringp
decl_stmt|;
block|{
name|struct
name|stab_write_handle
modifier|*
name|info
init|=
operator|(
expr|struct
name|stab_write_handle
operator|*
operator|)
name|p
decl_stmt|;
name|boolean
name|definition
decl_stmt|;
name|unsigned
name|int
name|element_size
decl_stmt|;
name|char
modifier|*
name|range
decl_stmt|,
modifier|*
name|element
decl_stmt|,
modifier|*
name|buf
decl_stmt|;
name|long
name|index
decl_stmt|;
name|unsigned
name|int
name|size
decl_stmt|;
name|definition
operator|=
name|info
operator|->
name|type_stack
operator|->
name|definition
expr_stmt|;
name|range
operator|=
name|stab_pop_type
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|definition
operator|=
name|definition
operator|||
name|info
operator|->
name|type_stack
operator|->
name|definition
expr_stmt|;
name|element_size
operator|=
name|info
operator|->
name|type_stack
operator|->
name|size
expr_stmt|;
name|element
operator|=
name|stab_pop_type
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|range
argument_list|)
operator|+
name|strlen
argument_list|(
name|element
argument_list|)
operator|+
literal|100
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|stringp
condition|)
block|{
name|index
operator|=
literal|0
expr_stmt|;
operator|*
name|buf
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
block|{
comment|/* We need to define a type in order to include the string          attribute.  */
name|index
operator|=
name|info
operator|->
name|type_index
expr_stmt|;
operator|++
name|info
operator|->
name|type_index
expr_stmt|;
name|definition
operator|=
name|true
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%ld=@S;"
argument_list|,
name|index
argument_list|)
expr_stmt|;
block|}
name|sprintf
argument_list|(
name|buf
operator|+
name|strlen
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"ar%s;%ld;%ld;%s"
argument_list|,
name|range
argument_list|,
operator|(
name|long
operator|)
name|low
argument_list|,
operator|(
name|long
operator|)
name|high
argument_list|,
name|element
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|range
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|element
argument_list|)
expr_stmt|;
if|if
condition|(
name|high
operator|<
name|low
condition|)
name|size
operator|=
literal|0
expr_stmt|;
else|else
name|size
operator|=
name|element_size
operator|*
operator|(
operator|(
name|high
operator|-
name|low
operator|)
operator|+
literal|1
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|stab_push_string
argument_list|(
name|info
argument_list|,
name|buf
argument_list|,
name|index
argument_list|,
name|definition
argument_list|,
name|size
argument_list|)
condition|)
return|return
name|false
return|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Push a set type.  */
end_comment

begin_function
specifier|static
name|boolean
name|stab_set_type
parameter_list|(
name|p
parameter_list|,
name|bitstringp
parameter_list|)
name|PTR
name|p
decl_stmt|;
name|boolean
name|bitstringp
decl_stmt|;
block|{
name|struct
name|stab_write_handle
modifier|*
name|info
init|=
operator|(
expr|struct
name|stab_write_handle
operator|*
operator|)
name|p
decl_stmt|;
name|boolean
name|definition
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|buf
decl_stmt|;
name|long
name|index
decl_stmt|;
name|definition
operator|=
name|info
operator|->
name|type_stack
operator|->
name|definition
expr_stmt|;
name|s
operator|=
name|stab_pop_type
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|s
argument_list|)
operator|+
literal|30
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bitstringp
condition|)
block|{
operator|*
name|buf
operator|=
literal|'\0'
expr_stmt|;
name|index
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* We need to define a type in order to include the string          attribute.  */
name|index
operator|=
name|info
operator|->
name|type_index
expr_stmt|;
operator|++
name|info
operator|->
name|type_index
expr_stmt|;
name|definition
operator|=
name|true
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%ld=@S;"
argument_list|,
name|index
argument_list|)
expr_stmt|;
block|}
name|sprintf
argument_list|(
name|buf
operator|+
name|strlen
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"S%s"
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|stab_push_string
argument_list|(
name|info
argument_list|,
name|buf
argument_list|,
name|index
argument_list|,
name|definition
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|false
return|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Push an offset type.  */
end_comment

begin_function
specifier|static
name|boolean
name|stab_offset_type
parameter_list|(
name|p
parameter_list|)
name|PTR
name|p
decl_stmt|;
block|{
name|struct
name|stab_write_handle
modifier|*
name|info
init|=
operator|(
expr|struct
name|stab_write_handle
operator|*
operator|)
name|p
decl_stmt|;
name|boolean
name|definition
decl_stmt|;
name|char
modifier|*
name|target
decl_stmt|,
modifier|*
name|base
decl_stmt|,
modifier|*
name|buf
decl_stmt|;
name|definition
operator|=
name|info
operator|->
name|type_stack
operator|->
name|definition
expr_stmt|;
name|target
operator|=
name|stab_pop_type
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|definition
operator|=
name|definition
operator|||
name|info
operator|->
name|type_stack
operator|->
name|definition
expr_stmt|;
name|base
operator|=
name|stab_pop_type
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|target
argument_list|)
operator|+
name|strlen
argument_list|(
name|base
argument_list|)
operator|+
literal|3
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"@%s,%s"
argument_list|,
name|base
argument_list|,
name|target
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|base
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|target
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|stab_push_string
argument_list|(
name|info
argument_list|,
name|buf
argument_list|,
literal|0
argument_list|,
name|definition
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|false
return|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Push a method type.  */
end_comment

begin_function
specifier|static
name|boolean
name|stab_method_type
parameter_list|(
name|p
parameter_list|,
name|domainp
parameter_list|,
name|argcount
parameter_list|,
name|varargs
parameter_list|)
name|PTR
name|p
decl_stmt|;
name|boolean
name|domainp
decl_stmt|;
name|int
name|argcount
decl_stmt|;
name|boolean
name|varargs
decl_stmt|;
block|{
name|struct
name|stab_write_handle
modifier|*
name|info
init|=
operator|(
expr|struct
name|stab_write_handle
operator|*
operator|)
name|p
decl_stmt|;
name|boolean
name|definition
decl_stmt|;
name|char
modifier|*
name|domain
decl_stmt|,
modifier|*
name|return_type
decl_stmt|,
modifier|*
name|buf
decl_stmt|;
name|char
modifier|*
modifier|*
name|args
decl_stmt|;
name|int
name|i
decl_stmt|;
name|size_t
name|len
decl_stmt|;
comment|/* We don't bother with stub method types, because that would      require a mangler for C++ argument types.  This will waste space      in the debugging output.  */
comment|/* We need a domain.  I'm not sure DOMAINP can ever be false,      anyhow.  */
if|if
condition|(
operator|!
name|domainp
condition|)
block|{
if|if
condition|(
operator|!
name|stab_empty_type
argument_list|(
name|p
argument_list|)
condition|)
return|return
name|false
return|;
block|}
name|definition
operator|=
name|info
operator|->
name|type_stack
operator|->
name|definition
expr_stmt|;
name|domain
operator|=
name|stab_pop_type
argument_list|(
name|info
argument_list|)
expr_stmt|;
comment|/* A non-varargs function is indicated by making the last parameter      type be void.  */
if|if
condition|(
name|argcount
operator|<
literal|0
condition|)
block|{
name|args
operator|=
name|NULL
expr_stmt|;
name|argcount
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|argcount
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|varargs
condition|)
name|args
operator|=
name|NULL
expr_stmt|;
else|else
block|{
name|args
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
literal|1
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|args
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|stab_empty_type
argument_list|(
name|p
argument_list|)
condition|)
return|return
name|false
return|;
name|definition
operator|=
name|definition
operator|||
name|info
operator|->
name|type_stack
operator|->
name|definition
expr_stmt|;
name|args
index|[
literal|0
index|]
operator|=
name|stab_pop_type
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|argcount
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
name|args
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
operator|(
name|argcount
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|args
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|argcount
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|definition
operator|=
name|definition
operator|||
name|info
operator|->
name|type_stack
operator|->
name|definition
expr_stmt|;
name|args
index|[
name|i
index|]
operator|=
name|stab_pop_type
argument_list|(
name|info
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|varargs
condition|)
block|{
if|if
condition|(
operator|!
name|stab_empty_type
argument_list|(
name|p
argument_list|)
condition|)
return|return
name|false
return|;
name|definition
operator|=
name|definition
operator|||
name|info
operator|->
name|type_stack
operator|->
name|definition
expr_stmt|;
name|args
index|[
name|argcount
index|]
operator|=
name|stab_pop_type
argument_list|(
name|info
argument_list|)
expr_stmt|;
operator|++
name|argcount
expr_stmt|;
block|}
block|}
name|definition
operator|=
name|definition
operator|||
name|info
operator|->
name|type_stack
operator|->
name|definition
expr_stmt|;
name|return_type
operator|=
name|stab_pop_type
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|domain
argument_list|)
operator|+
name|strlen
argument_list|(
name|return_type
argument_list|)
operator|+
literal|10
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|argcount
condition|;
name|i
operator|++
control|)
name|len
operator|+=
name|strlen
argument_list|(
name|args
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"#%s,%s"
argument_list|,
name|domain
argument_list|,
name|return_type
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|domain
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|return_type
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|argcount
condition|;
name|i
operator|++
control|)
block|{
name|strcat
argument_list|(
name|buf
argument_list|,
literal|","
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|buf
argument_list|,
name|args
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|args
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|strcat
argument_list|(
name|buf
argument_list|,
literal|";"
argument_list|)
expr_stmt|;
if|if
condition|(
name|args
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|stab_push_string
argument_list|(
name|info
argument_list|,
name|buf
argument_list|,
literal|0
argument_list|,
name|definition
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|false
return|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Push a const version of a type.  */
end_comment

begin_function
specifier|static
name|boolean
name|stab_const_type
parameter_list|(
name|p
parameter_list|)
name|PTR
name|p
decl_stmt|;
block|{
name|struct
name|stab_write_handle
modifier|*
name|info
init|=
operator|(
expr|struct
name|stab_write_handle
operator|*
operator|)
name|p
decl_stmt|;
return|return
name|stab_modify_type
argument_list|(
name|info
argument_list|,
literal|'k'
argument_list|,
name|info
operator|->
name|type_stack
operator|->
name|size
argument_list|,
operator|(
name|long
operator|*
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|size_t
operator|*
operator|)
name|NULL
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Push a volatile version of a type.  */
end_comment

begin_function
specifier|static
name|boolean
name|stab_volatile_type
parameter_list|(
name|p
parameter_list|)
name|PTR
name|p
decl_stmt|;
block|{
name|struct
name|stab_write_handle
modifier|*
name|info
init|=
operator|(
expr|struct
name|stab_write_handle
operator|*
operator|)
name|p
decl_stmt|;
return|return
name|stab_modify_type
argument_list|(
name|info
argument_list|,
literal|'B'
argument_list|,
name|info
operator|->
name|type_stack
operator|->
name|size
argument_list|,
operator|(
name|long
operator|*
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|size_t
operator|*
operator|)
name|NULL
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Get the type index to use for a struct/union/class ID.  This should    return -1 if it fails.  */
end_comment

begin_function
specifier|static
name|long
name|stab_get_struct_index
parameter_list|(
name|info
parameter_list|,
name|tag
parameter_list|,
name|id
parameter_list|,
name|kind
parameter_list|,
name|psize
parameter_list|)
name|struct
name|stab_write_handle
modifier|*
name|info
decl_stmt|;
specifier|const
name|char
modifier|*
name|tag
decl_stmt|;
name|unsigned
name|int
name|id
decl_stmt|;
name|enum
name|debug_type_kind
name|kind
decl_stmt|;
name|unsigned
name|int
modifier|*
name|psize
decl_stmt|;
block|{
if|if
condition|(
name|id
operator|>=
name|info
operator|->
name|type_cache
operator|.
name|struct_types_alloc
condition|)
block|{
name|size_t
name|alloc
decl_stmt|;
name|alloc
operator|=
name|info
operator|->
name|type_cache
operator|.
name|struct_types_alloc
expr_stmt|;
if|if
condition|(
name|alloc
operator|==
literal|0
condition|)
name|alloc
operator|=
literal|10
expr_stmt|;
while|while
condition|(
name|id
operator|>=
name|alloc
condition|)
name|alloc
operator|*=
literal|2
expr_stmt|;
name|info
operator|->
name|type_cache
operator|.
name|struct_types
operator|=
operator|(
expr|struct
name|stab_tag
operator|*
operator|)
name|xrealloc
argument_list|(
name|info
operator|->
name|type_cache
operator|.
name|struct_types
argument_list|,
name|alloc
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|stab_tag
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|info
operator|->
name|type_cache
operator|.
name|struct_types
operator|+
name|info
operator|->
name|type_cache
operator|.
name|struct_types_alloc
operator|)
argument_list|,
literal|0
argument_list|,
operator|(
operator|(
name|alloc
operator|-
name|info
operator|->
name|type_cache
operator|.
name|struct_types_alloc
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|stab_tag
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|info
operator|->
name|type_cache
operator|.
name|struct_types_alloc
operator|=
name|alloc
expr_stmt|;
block|}
if|if
condition|(
name|info
operator|->
name|type_cache
operator|.
name|struct_types
index|[
name|id
index|]
operator|.
name|index
operator|==
literal|0
condition|)
block|{
name|info
operator|->
name|type_cache
operator|.
name|struct_types
index|[
name|id
index|]
operator|.
name|index
operator|=
name|info
operator|->
name|type_index
expr_stmt|;
operator|++
name|info
operator|->
name|type_index
expr_stmt|;
name|info
operator|->
name|type_cache
operator|.
name|struct_types
index|[
name|id
index|]
operator|.
name|tag
operator|=
name|tag
expr_stmt|;
name|info
operator|->
name|type_cache
operator|.
name|struct_types
index|[
name|id
index|]
operator|.
name|kind
operator|=
name|kind
expr_stmt|;
block|}
if|if
condition|(
name|kind
operator|==
name|DEBUG_KIND_ILLEGAL
condition|)
block|{
comment|/* This is a definition of the struct.  */
name|info
operator|->
name|type_cache
operator|.
name|struct_types
index|[
name|id
index|]
operator|.
name|kind
operator|=
name|kind
expr_stmt|;
name|info
operator|->
name|type_cache
operator|.
name|struct_types
index|[
name|id
index|]
operator|.
name|size
operator|=
operator|*
name|psize
expr_stmt|;
block|}
else|else
operator|*
name|psize
operator|=
name|info
operator|->
name|type_cache
operator|.
name|struct_types
index|[
name|id
index|]
operator|.
name|size
expr_stmt|;
return|return
name|info
operator|->
name|type_cache
operator|.
name|struct_types
index|[
name|id
index|]
operator|.
name|index
return|;
block|}
end_function

begin_comment
comment|/* Start outputting a struct.  We ignore the tag, and handle it in    stab_tag.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|boolean
name|stab_start_struct_type
parameter_list|(
name|p
parameter_list|,
name|tag
parameter_list|,
name|id
parameter_list|,
name|structp
parameter_list|,
name|size
parameter_list|)
name|PTR
name|p
decl_stmt|;
specifier|const
name|char
modifier|*
name|tag
decl_stmt|;
name|unsigned
name|int
name|id
decl_stmt|;
name|boolean
name|structp
decl_stmt|;
name|unsigned
name|int
name|size
decl_stmt|;
block|{
name|struct
name|stab_write_handle
modifier|*
name|info
init|=
operator|(
expr|struct
name|stab_write_handle
operator|*
operator|)
name|p
decl_stmt|;
name|long
name|index
decl_stmt|;
name|boolean
name|definition
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|40
argument_list|)
expr_stmt|;
if|if
condition|(
name|id
operator|==
literal|0
condition|)
block|{
name|index
operator|=
literal|0
expr_stmt|;
operator|*
name|buf
operator|=
literal|'\0'
expr_stmt|;
name|definition
operator|=
name|false
expr_stmt|;
block|}
else|else
block|{
name|index
operator|=
name|stab_get_struct_index
argument_list|(
name|info
argument_list|,
name|tag
argument_list|,
name|id
argument_list|,
name|DEBUG_KIND_ILLEGAL
argument_list|,
operator|&
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|<
literal|0
condition|)
return|return
name|false
return|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%ld="
argument_list|,
name|index
argument_list|)
expr_stmt|;
name|definition
operator|=
name|true
expr_stmt|;
block|}
name|sprintf
argument_list|(
name|buf
operator|+
name|strlen
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"%c%u"
argument_list|,
name|structp
condition|?
literal|'s'
else|:
literal|'u'
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|stab_push_string
argument_list|(
name|info
argument_list|,
name|buf
argument_list|,
name|index
argument_list|,
name|definition
argument_list|,
name|size
argument_list|)
condition|)
return|return
name|false
return|;
name|info
operator|->
name|type_stack
operator|->
name|fields
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|type_stack
operator|->
name|fields
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Add a field to a struct.  */
end_comment

begin_function
specifier|static
name|boolean
name|stab_struct_field
parameter_list|(
name|p
parameter_list|,
name|name
parameter_list|,
name|bitpos
parameter_list|,
name|bitsize
parameter_list|,
name|visibility
parameter_list|)
name|PTR
name|p
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|bfd_vma
name|bitpos
decl_stmt|;
name|bfd_vma
name|bitsize
decl_stmt|;
name|enum
name|debug_visibility
name|visibility
decl_stmt|;
block|{
name|struct
name|stab_write_handle
modifier|*
name|info
init|=
operator|(
expr|struct
name|stab_write_handle
operator|*
operator|)
name|p
decl_stmt|;
name|boolean
name|definition
decl_stmt|;
name|unsigned
name|int
name|size
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|n
decl_stmt|;
specifier|const
name|char
modifier|*
name|vis
decl_stmt|;
name|definition
operator|=
name|info
operator|->
name|type_stack
operator|->
name|definition
expr_stmt|;
name|size
operator|=
name|info
operator|->
name|type_stack
operator|->
name|size
expr_stmt|;
name|s
operator|=
name|stab_pop_type
argument_list|(
name|info
argument_list|)
expr_stmt|;
comment|/* Add this field to the end of the current struct fields, which is      currently on the top of the stack.  */
name|assert
argument_list|(
name|info
operator|->
name|type_stack
operator|->
name|fields
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|n
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|info
operator|->
name|type_stack
operator|->
name|fields
argument_list|)
operator|+
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
name|strlen
argument_list|(
name|s
argument_list|)
operator|+
literal|50
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|visibility
condition|)
block|{
default|default:
name|abort
argument_list|()
expr_stmt|;
case|case
name|DEBUG_VISIBILITY_PUBLIC
case|:
name|vis
operator|=
literal|""
expr_stmt|;
break|break;
case|case
name|DEBUG_VISIBILITY_PRIVATE
case|:
name|vis
operator|=
literal|"/0"
expr_stmt|;
break|break;
case|case
name|DEBUG_VISIBILITY_PROTECTED
case|:
name|vis
operator|=
literal|"/1"
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|bitsize
operator|==
literal|0
condition|)
block|{
name|bitsize
operator|=
name|size
operator|*
literal|8
expr_stmt|;
if|if
condition|(
name|bitsize
operator|==
literal|0
condition|)
name|non_fatal
argument_list|(
name|_
argument_list|(
literal|"%s: warning: unknown size for field `%s' in struct"
argument_list|)
argument_list|,
name|bfd_get_filename
argument_list|(
name|info
operator|->
name|abfd
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
name|sprintf
argument_list|(
name|n
argument_list|,
literal|"%s%s:%s%s,%ld,%ld;"
argument_list|,
name|info
operator|->
name|type_stack
operator|->
name|fields
argument_list|,
name|name
argument_list|,
name|vis
argument_list|,
name|s
argument_list|,
operator|(
name|long
operator|)
name|bitpos
argument_list|,
operator|(
name|long
operator|)
name|bitsize
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|info
operator|->
name|type_stack
operator|->
name|fields
argument_list|)
expr_stmt|;
name|info
operator|->
name|type_stack
operator|->
name|fields
operator|=
name|n
expr_stmt|;
if|if
condition|(
name|definition
condition|)
name|info
operator|->
name|type_stack
operator|->
name|definition
operator|=
name|true
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Finish up a struct.  */
end_comment

begin_function
specifier|static
name|boolean
name|stab_end_struct_type
parameter_list|(
name|p
parameter_list|)
name|PTR
name|p
decl_stmt|;
block|{
name|struct
name|stab_write_handle
modifier|*
name|info
init|=
operator|(
expr|struct
name|stab_write_handle
operator|*
operator|)
name|p
decl_stmt|;
name|boolean
name|definition
decl_stmt|;
name|long
name|index
decl_stmt|;
name|unsigned
name|int
name|size
decl_stmt|;
name|char
modifier|*
name|fields
decl_stmt|,
modifier|*
name|first
decl_stmt|,
modifier|*
name|buf
decl_stmt|;
name|assert
argument_list|(
name|info
operator|->
name|type_stack
operator|!=
name|NULL
operator|&&
name|info
operator|->
name|type_stack
operator|->
name|fields
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|definition
operator|=
name|info
operator|->
name|type_stack
operator|->
name|definition
expr_stmt|;
name|index
operator|=
name|info
operator|->
name|type_stack
operator|->
name|index
expr_stmt|;
name|size
operator|=
name|info
operator|->
name|type_stack
operator|->
name|size
expr_stmt|;
name|fields
operator|=
name|info
operator|->
name|type_stack
operator|->
name|fields
expr_stmt|;
name|first
operator|=
name|stab_pop_type
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|first
argument_list|)
operator|+
name|strlen
argument_list|(
name|fields
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s%s;"
argument_list|,
name|first
argument_list|,
name|fields
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|first
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|fields
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|stab_push_string
argument_list|(
name|info
argument_list|,
name|buf
argument_list|,
name|index
argument_list|,
name|definition
argument_list|,
name|size
argument_list|)
condition|)
return|return
name|false
return|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Start outputting a class.  */
end_comment

begin_function
specifier|static
name|boolean
name|stab_start_class_type
parameter_list|(
name|p
parameter_list|,
name|tag
parameter_list|,
name|id
parameter_list|,
name|structp
parameter_list|,
name|size
parameter_list|,
name|vptr
parameter_list|,
name|ownvptr
parameter_list|)
name|PTR
name|p
decl_stmt|;
specifier|const
name|char
modifier|*
name|tag
decl_stmt|;
name|unsigned
name|int
name|id
decl_stmt|;
name|boolean
name|structp
decl_stmt|;
name|unsigned
name|int
name|size
decl_stmt|;
name|boolean
name|vptr
decl_stmt|;
name|boolean
name|ownvptr
decl_stmt|;
block|{
name|struct
name|stab_write_handle
modifier|*
name|info
init|=
operator|(
expr|struct
name|stab_write_handle
operator|*
operator|)
name|p
decl_stmt|;
name|boolean
name|definition
decl_stmt|;
name|char
modifier|*
name|vstring
decl_stmt|;
if|if
condition|(
operator|!
name|vptr
operator|||
name|ownvptr
condition|)
block|{
name|definition
operator|=
name|false
expr_stmt|;
name|vstring
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|definition
operator|=
name|info
operator|->
name|type_stack
operator|->
name|definition
expr_stmt|;
name|vstring
operator|=
name|stab_pop_type
argument_list|(
name|info
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|stab_start_struct_type
argument_list|(
name|p
argument_list|,
name|tag
argument_list|,
name|id
argument_list|,
name|structp
argument_list|,
name|size
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|vptr
condition|)
block|{
name|char
modifier|*
name|vtable
decl_stmt|;
if|if
condition|(
name|ownvptr
condition|)
block|{
name|assert
argument_list|(
name|info
operator|->
name|type_stack
operator|->
name|index
operator|>
literal|0
argument_list|)
expr_stmt|;
name|vtable
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|20
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|vtable
argument_list|,
literal|"~%%%ld"
argument_list|,
name|info
operator|->
name|type_stack
operator|->
name|index
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|vtable
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|vstring
argument_list|)
operator|+
literal|3
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|vtable
argument_list|,
literal|"~%%%s"
argument_list|,
name|vstring
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|vstring
argument_list|)
expr_stmt|;
block|}
name|info
operator|->
name|type_stack
operator|->
name|vtable
operator|=
name|vtable
expr_stmt|;
block|}
if|if
condition|(
name|definition
condition|)
name|info
operator|->
name|type_stack
operator|->
name|definition
operator|=
name|true
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Add a static member to the class on the type stack.  */
end_comment

begin_function
specifier|static
name|boolean
name|stab_class_static_member
parameter_list|(
name|p
parameter_list|,
name|name
parameter_list|,
name|physname
parameter_list|,
name|visibility
parameter_list|)
name|PTR
name|p
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
specifier|const
name|char
modifier|*
name|physname
decl_stmt|;
name|enum
name|debug_visibility
name|visibility
decl_stmt|;
block|{
name|struct
name|stab_write_handle
modifier|*
name|info
init|=
operator|(
expr|struct
name|stab_write_handle
operator|*
operator|)
name|p
decl_stmt|;
name|boolean
name|definition
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|n
decl_stmt|;
specifier|const
name|char
modifier|*
name|vis
decl_stmt|;
name|definition
operator|=
name|info
operator|->
name|type_stack
operator|->
name|definition
expr_stmt|;
name|s
operator|=
name|stab_pop_type
argument_list|(
name|info
argument_list|)
expr_stmt|;
comment|/* Add this field to the end of the current struct fields, which is      currently on the top of the stack.  */
name|assert
argument_list|(
name|info
operator|->
name|type_stack
operator|->
name|fields
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|n
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|info
operator|->
name|type_stack
operator|->
name|fields
argument_list|)
operator|+
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
name|strlen
argument_list|(
name|s
argument_list|)
operator|+
name|strlen
argument_list|(
name|physname
argument_list|)
operator|+
literal|10
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|visibility
condition|)
block|{
default|default:
name|abort
argument_list|()
expr_stmt|;
case|case
name|DEBUG_VISIBILITY_PUBLIC
case|:
name|vis
operator|=
literal|""
expr_stmt|;
break|break;
case|case
name|DEBUG_VISIBILITY_PRIVATE
case|:
name|vis
operator|=
literal|"/0"
expr_stmt|;
break|break;
case|case
name|DEBUG_VISIBILITY_PROTECTED
case|:
name|vis
operator|=
literal|"/1"
expr_stmt|;
break|break;
block|}
name|sprintf
argument_list|(
name|n
argument_list|,
literal|"%s%s:%s%s:%s;"
argument_list|,
name|info
operator|->
name|type_stack
operator|->
name|fields
argument_list|,
name|name
argument_list|,
name|vis
argument_list|,
name|s
argument_list|,
name|physname
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|info
operator|->
name|type_stack
operator|->
name|fields
argument_list|)
expr_stmt|;
name|info
operator|->
name|type_stack
operator|->
name|fields
operator|=
name|n
expr_stmt|;
if|if
condition|(
name|definition
condition|)
name|info
operator|->
name|type_stack
operator|->
name|definition
operator|=
name|true
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Add a base class to the class on the type stack.  */
end_comment

begin_function
specifier|static
name|boolean
name|stab_class_baseclass
parameter_list|(
name|p
parameter_list|,
name|bitpos
parameter_list|,
name|virtual
parameter_list|,
name|visibility
parameter_list|)
name|PTR
name|p
decl_stmt|;
name|bfd_vma
name|bitpos
decl_stmt|;
name|boolean
name|virtual
decl_stmt|;
name|enum
name|debug_visibility
name|visibility
decl_stmt|;
block|{
name|struct
name|stab_write_handle
modifier|*
name|info
init|=
operator|(
expr|struct
name|stab_write_handle
operator|*
operator|)
name|p
decl_stmt|;
name|boolean
name|definition
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|unsigned
name|int
name|c
decl_stmt|;
name|char
modifier|*
modifier|*
name|baseclasses
decl_stmt|;
name|definition
operator|=
name|info
operator|->
name|type_stack
operator|->
name|definition
expr_stmt|;
name|s
operator|=
name|stab_pop_type
argument_list|(
name|info
argument_list|)
expr_stmt|;
comment|/* Build the base class specifier.  */
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|s
argument_list|)
operator|+
literal|25
argument_list|)
expr_stmt|;
name|buf
index|[
literal|0
index|]
operator|=
name|virtual
condition|?
literal|'1'
else|:
literal|'0'
expr_stmt|;
switch|switch
condition|(
name|visibility
condition|)
block|{
default|default:
name|abort
argument_list|()
expr_stmt|;
case|case
name|DEBUG_VISIBILITY_PRIVATE
case|:
name|buf
index|[
literal|1
index|]
operator|=
literal|'0'
expr_stmt|;
break|break;
case|case
name|DEBUG_VISIBILITY_PROTECTED
case|:
name|buf
index|[
literal|1
index|]
operator|=
literal|'1'
expr_stmt|;
break|break;
case|case
name|DEBUG_VISIBILITY_PUBLIC
case|:
name|buf
index|[
literal|1
index|]
operator|=
literal|'2'
expr_stmt|;
break|break;
block|}
name|sprintf
argument_list|(
name|buf
operator|+
literal|2
argument_list|,
literal|"%ld,%s;"
argument_list|,
operator|(
name|long
operator|)
name|bitpos
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* Add the new baseclass to the existing ones.  */
name|assert
argument_list|(
name|info
operator|->
name|type_stack
operator|!=
name|NULL
operator|&&
name|info
operator|->
name|type_stack
operator|->
name|fields
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|type_stack
operator|->
name|baseclasses
operator|==
name|NULL
condition|)
name|c
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|c
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|info
operator|->
name|type_stack
operator|->
name|baseclasses
index|[
name|c
index|]
operator|!=
name|NULL
condition|)
operator|++
name|c
expr_stmt|;
block|}
name|baseclasses
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
name|info
operator|->
name|type_stack
operator|->
name|baseclasses
argument_list|,
operator|(
name|c
operator|+
literal|2
operator|)
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|baseclasses
argument_list|)
argument_list|)
expr_stmt|;
name|baseclasses
index|[
name|c
index|]
operator|=
name|buf
expr_stmt|;
name|baseclasses
index|[
name|c
operator|+
literal|1
index|]
operator|=
name|NULL
expr_stmt|;
name|info
operator|->
name|type_stack
operator|->
name|baseclasses
operator|=
name|baseclasses
expr_stmt|;
if|if
condition|(
name|definition
condition|)
name|info
operator|->
name|type_stack
operator|->
name|definition
operator|=
name|true
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Start adding a method to the class on the type stack.  */
end_comment

begin_function
specifier|static
name|boolean
name|stab_class_start_method
parameter_list|(
name|p
parameter_list|,
name|name
parameter_list|)
name|PTR
name|p
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|struct
name|stab_write_handle
modifier|*
name|info
init|=
operator|(
expr|struct
name|stab_write_handle
operator|*
operator|)
name|p
decl_stmt|;
name|char
modifier|*
name|m
decl_stmt|;
name|assert
argument_list|(
name|info
operator|->
name|type_stack
operator|!=
name|NULL
operator|&&
name|info
operator|->
name|type_stack
operator|->
name|fields
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|type_stack
operator|->
name|methods
operator|==
name|NULL
condition|)
block|{
name|m
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|3
argument_list|)
expr_stmt|;
operator|*
name|m
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
block|{
name|m
operator|=
operator|(
name|char
operator|*
operator|)
name|xrealloc
argument_list|(
name|info
operator|->
name|type_stack
operator|->
name|methods
argument_list|,
operator|(
name|strlen
argument_list|(
name|info
operator|->
name|type_stack
operator|->
name|methods
argument_list|)
operator|+
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|4
operator|)
argument_list|)
expr_stmt|;
block|}
name|sprintf
argument_list|(
name|m
operator|+
name|strlen
argument_list|(
name|m
argument_list|)
argument_list|,
literal|"%s::"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|info
operator|->
name|type_stack
operator|->
name|methods
operator|=
name|m
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Add a variant, either static or not, to the current method.  */
end_comment

begin_function
specifier|static
name|boolean
name|stab_class_method_var
parameter_list|(
name|info
parameter_list|,
name|physname
parameter_list|,
name|visibility
parameter_list|,
name|staticp
parameter_list|,
name|constp
parameter_list|,
name|volatilep
parameter_list|,
name|voffset
parameter_list|,
name|contextp
parameter_list|)
name|struct
name|stab_write_handle
modifier|*
name|info
decl_stmt|;
specifier|const
name|char
modifier|*
name|physname
decl_stmt|;
name|enum
name|debug_visibility
name|visibility
decl_stmt|;
name|boolean
name|staticp
decl_stmt|;
name|boolean
name|constp
decl_stmt|;
name|boolean
name|volatilep
decl_stmt|;
name|bfd_vma
name|voffset
decl_stmt|;
name|boolean
name|contextp
decl_stmt|;
block|{
name|boolean
name|definition
decl_stmt|;
name|char
modifier|*
name|type
decl_stmt|;
name|char
modifier|*
name|context
init|=
name|NULL
decl_stmt|;
name|char
name|visc
decl_stmt|,
name|qualc
decl_stmt|,
name|typec
decl_stmt|;
name|definition
operator|=
name|info
operator|->
name|type_stack
operator|->
name|definition
expr_stmt|;
name|type
operator|=
name|stab_pop_type
argument_list|(
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|contextp
condition|)
block|{
name|definition
operator|=
name|definition
operator|||
name|info
operator|->
name|type_stack
operator|->
name|definition
expr_stmt|;
name|context
operator|=
name|stab_pop_type
argument_list|(
name|info
argument_list|)
expr_stmt|;
block|}
name|assert
argument_list|(
name|info
operator|->
name|type_stack
operator|!=
name|NULL
operator|&&
name|info
operator|->
name|type_stack
operator|->
name|methods
operator|!=
name|NULL
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|visibility
condition|)
block|{
default|default:
name|abort
argument_list|()
expr_stmt|;
case|case
name|DEBUG_VISIBILITY_PRIVATE
case|:
name|visc
operator|=
literal|'0'
expr_stmt|;
break|break;
case|case
name|DEBUG_VISIBILITY_PROTECTED
case|:
name|visc
operator|=
literal|'1'
expr_stmt|;
break|break;
case|case
name|DEBUG_VISIBILITY_PUBLIC
case|:
name|visc
operator|=
literal|'2'
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|constp
condition|)
block|{
if|if
condition|(
name|volatilep
condition|)
name|qualc
operator|=
literal|'D'
expr_stmt|;
else|else
name|qualc
operator|=
literal|'B'
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|volatilep
condition|)
name|qualc
operator|=
literal|'C'
expr_stmt|;
else|else
name|qualc
operator|=
literal|'A'
expr_stmt|;
block|}
if|if
condition|(
name|staticp
condition|)
name|typec
operator|=
literal|'?'
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|contextp
condition|)
name|typec
operator|=
literal|'.'
expr_stmt|;
else|else
name|typec
operator|=
literal|'*'
expr_stmt|;
name|info
operator|->
name|type_stack
operator|->
name|methods
operator|=
operator|(
name|char
operator|*
operator|)
name|xrealloc
argument_list|(
name|info
operator|->
name|type_stack
operator|->
name|methods
argument_list|,
operator|(
name|strlen
argument_list|(
name|info
operator|->
name|type_stack
operator|->
name|methods
argument_list|)
operator|+
name|strlen
argument_list|(
name|type
argument_list|)
operator|+
name|strlen
argument_list|(
name|physname
argument_list|)
operator|+
operator|(
name|contextp
condition|?
name|strlen
argument_list|(
name|context
argument_list|)
else|:
literal|0
operator|)
operator|+
literal|40
operator|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|info
operator|->
name|type_stack
operator|->
name|methods
operator|+
name|strlen
argument_list|(
name|info
operator|->
name|type_stack
operator|->
name|methods
argument_list|)
argument_list|,
literal|"%s:%s;%c%c%c"
argument_list|,
name|type
argument_list|,
name|physname
argument_list|,
name|visc
argument_list|,
name|qualc
argument_list|,
name|typec
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|contextp
condition|)
block|{
name|sprintf
argument_list|(
name|info
operator|->
name|type_stack
operator|->
name|methods
operator|+
name|strlen
argument_list|(
name|info
operator|->
name|type_stack
operator|->
name|methods
argument_list|)
argument_list|,
literal|"%ld;%s;"
argument_list|,
operator|(
name|long
operator|)
name|voffset
argument_list|,
name|context
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|context
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|definition
condition|)
name|info
operator|->
name|type_stack
operator|->
name|definition
operator|=
name|true
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Add a variant to the current method.  */
end_comment

begin_function
specifier|static
name|boolean
name|stab_class_method_variant
parameter_list|(
name|p
parameter_list|,
name|physname
parameter_list|,
name|visibility
parameter_list|,
name|constp
parameter_list|,
name|volatilep
parameter_list|,
name|voffset
parameter_list|,
name|contextp
parameter_list|)
name|PTR
name|p
decl_stmt|;
specifier|const
name|char
modifier|*
name|physname
decl_stmt|;
name|enum
name|debug_visibility
name|visibility
decl_stmt|;
name|boolean
name|constp
decl_stmt|;
name|boolean
name|volatilep
decl_stmt|;
name|bfd_vma
name|voffset
decl_stmt|;
name|boolean
name|contextp
decl_stmt|;
block|{
name|struct
name|stab_write_handle
modifier|*
name|info
init|=
operator|(
expr|struct
name|stab_write_handle
operator|*
operator|)
name|p
decl_stmt|;
return|return
name|stab_class_method_var
argument_list|(
name|info
argument_list|,
name|physname
argument_list|,
name|visibility
argument_list|,
name|false
argument_list|,
name|constp
argument_list|,
name|volatilep
argument_list|,
name|voffset
argument_list|,
name|contextp
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Add a static variant to the current method.  */
end_comment

begin_function
specifier|static
name|boolean
name|stab_class_static_method_variant
parameter_list|(
name|p
parameter_list|,
name|physname
parameter_list|,
name|visibility
parameter_list|,
name|constp
parameter_list|,
name|volatilep
parameter_list|)
name|PTR
name|p
decl_stmt|;
specifier|const
name|char
modifier|*
name|physname
decl_stmt|;
name|enum
name|debug_visibility
name|visibility
decl_stmt|;
name|boolean
name|constp
decl_stmt|;
name|boolean
name|volatilep
decl_stmt|;
block|{
name|struct
name|stab_write_handle
modifier|*
name|info
init|=
operator|(
expr|struct
name|stab_write_handle
operator|*
operator|)
name|p
decl_stmt|;
return|return
name|stab_class_method_var
argument_list|(
name|info
argument_list|,
name|physname
argument_list|,
name|visibility
argument_list|,
name|true
argument_list|,
name|constp
argument_list|,
name|volatilep
argument_list|,
literal|0
argument_list|,
name|false
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Finish up a method.  */
end_comment

begin_function
specifier|static
name|boolean
name|stab_class_end_method
parameter_list|(
name|p
parameter_list|)
name|PTR
name|p
decl_stmt|;
block|{
name|struct
name|stab_write_handle
modifier|*
name|info
init|=
operator|(
expr|struct
name|stab_write_handle
operator|*
operator|)
name|p
decl_stmt|;
name|assert
argument_list|(
name|info
operator|->
name|type_stack
operator|!=
name|NULL
operator|&&
name|info
operator|->
name|type_stack
operator|->
name|methods
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* We allocated enough room on info->type_stack->methods to add the      trailing semicolon.  */
name|strcat
argument_list|(
name|info
operator|->
name|type_stack
operator|->
name|methods
argument_list|,
literal|";"
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Finish up a class.  */
end_comment

begin_function
specifier|static
name|boolean
name|stab_end_class_type
parameter_list|(
name|p
parameter_list|)
name|PTR
name|p
decl_stmt|;
block|{
name|struct
name|stab_write_handle
modifier|*
name|info
init|=
operator|(
expr|struct
name|stab_write_handle
operator|*
operator|)
name|p
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|unsigned
name|int
name|i
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|assert
argument_list|(
name|info
operator|->
name|type_stack
operator|!=
name|NULL
operator|&&
name|info
operator|->
name|type_stack
operator|->
name|fields
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* Work out the size we need to allocate for the class definition.  */
name|len
operator|=
operator|(
name|strlen
argument_list|(
name|info
operator|->
name|type_stack
operator|->
name|string
argument_list|)
operator|+
name|strlen
argument_list|(
name|info
operator|->
name|type_stack
operator|->
name|fields
argument_list|)
operator|+
literal|10
operator|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|type_stack
operator|->
name|baseclasses
operator|!=
name|NULL
condition|)
block|{
name|len
operator|+=
literal|20
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|info
operator|->
name|type_stack
operator|->
name|baseclasses
index|[
name|i
index|]
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
name|len
operator|+=
name|strlen
argument_list|(
name|info
operator|->
name|type_stack
operator|->
name|baseclasses
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|info
operator|->
name|type_stack
operator|->
name|methods
operator|!=
name|NULL
condition|)
name|len
operator|+=
name|strlen
argument_list|(
name|info
operator|->
name|type_stack
operator|->
name|methods
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|type_stack
operator|->
name|vtable
operator|!=
name|NULL
condition|)
name|len
operator|+=
name|strlen
argument_list|(
name|info
operator|->
name|type_stack
operator|->
name|vtable
argument_list|)
expr_stmt|;
comment|/* Build the class definition.  */
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|buf
argument_list|,
name|info
operator|->
name|type_stack
operator|->
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|type_stack
operator|->
name|baseclasses
operator|!=
name|NULL
condition|)
block|{
name|sprintf
argument_list|(
name|buf
operator|+
name|strlen
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"!%u,"
argument_list|,
name|i
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|info
operator|->
name|type_stack
operator|->
name|baseclasses
index|[
name|i
index|]
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
name|strcat
argument_list|(
name|buf
argument_list|,
name|info
operator|->
name|type_stack
operator|->
name|baseclasses
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|info
operator|->
name|type_stack
operator|->
name|baseclasses
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|info
operator|->
name|type_stack
operator|->
name|baseclasses
argument_list|)
expr_stmt|;
name|info
operator|->
name|type_stack
operator|->
name|baseclasses
operator|=
name|NULL
expr_stmt|;
block|}
name|strcat
argument_list|(
name|buf
argument_list|,
name|info
operator|->
name|type_stack
operator|->
name|fields
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|info
operator|->
name|type_stack
operator|->
name|fields
argument_list|)
expr_stmt|;
name|info
operator|->
name|type_stack
operator|->
name|fields
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|type_stack
operator|->
name|methods
operator|!=
name|NULL
condition|)
block|{
name|strcat
argument_list|(
name|buf
argument_list|,
name|info
operator|->
name|type_stack
operator|->
name|methods
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|info
operator|->
name|type_stack
operator|->
name|methods
argument_list|)
expr_stmt|;
name|info
operator|->
name|type_stack
operator|->
name|methods
operator|=
name|NULL
expr_stmt|;
block|}
name|strcat
argument_list|(
name|buf
argument_list|,
literal|";"
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|type_stack
operator|->
name|vtable
operator|!=
name|NULL
condition|)
block|{
name|strcat
argument_list|(
name|buf
argument_list|,
name|info
operator|->
name|type_stack
operator|->
name|vtable
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|info
operator|->
name|type_stack
operator|->
name|vtable
argument_list|)
expr_stmt|;
name|info
operator|->
name|type_stack
operator|->
name|vtable
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Replace the string on the top of the stack with the complete      class definition.  */
name|free
argument_list|(
name|info
operator|->
name|type_stack
operator|->
name|string
argument_list|)
expr_stmt|;
name|info
operator|->
name|type_stack
operator|->
name|string
operator|=
name|buf
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Push a typedef which was previously defined.  */
end_comment

begin_function
specifier|static
name|boolean
name|stab_typedef_type
parameter_list|(
name|p
parameter_list|,
name|name
parameter_list|)
name|PTR
name|p
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|struct
name|stab_write_handle
modifier|*
name|info
init|=
operator|(
expr|struct
name|stab_write_handle
operator|*
operator|)
name|p
decl_stmt|;
name|struct
name|string_hash_entry
modifier|*
name|h
decl_stmt|;
name|h
operator|=
name|string_hash_lookup
argument_list|(
operator|&
name|info
operator|->
name|typedef_hash
argument_list|,
name|name
argument_list|,
name|false
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|h
operator|!=
name|NULL
operator|&&
name|h
operator|->
name|index
operator|>
literal|0
argument_list|)
expr_stmt|;
return|return
name|stab_push_defined_type
argument_list|(
name|info
argument_list|,
name|h
operator|->
name|index
argument_list|,
name|h
operator|->
name|size
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Push a struct, union or class tag.  */
end_comment

begin_function
specifier|static
name|boolean
name|stab_tag_type
parameter_list|(
name|p
parameter_list|,
name|name
parameter_list|,
name|id
parameter_list|,
name|kind
parameter_list|)
name|PTR
name|p
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|unsigned
name|int
name|id
decl_stmt|;
name|enum
name|debug_type_kind
name|kind
decl_stmt|;
block|{
name|struct
name|stab_write_handle
modifier|*
name|info
init|=
operator|(
expr|struct
name|stab_write_handle
operator|*
operator|)
name|p
decl_stmt|;
name|long
name|index
decl_stmt|;
name|unsigned
name|int
name|size
decl_stmt|;
name|index
operator|=
name|stab_get_struct_index
argument_list|(
name|info
argument_list|,
name|name
argument_list|,
name|id
argument_list|,
name|kind
argument_list|,
operator|&
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|<
literal|0
condition|)
return|return
name|false
return|;
return|return
name|stab_push_defined_type
argument_list|(
name|info
argument_list|,
name|index
argument_list|,
name|size
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Define a typedef.  */
end_comment

begin_function
specifier|static
name|boolean
name|stab_typdef
parameter_list|(
name|p
parameter_list|,
name|name
parameter_list|)
name|PTR
name|p
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|struct
name|stab_write_handle
modifier|*
name|info
init|=
operator|(
expr|struct
name|stab_write_handle
operator|*
operator|)
name|p
decl_stmt|;
name|long
name|index
decl_stmt|;
name|unsigned
name|int
name|size
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|buf
decl_stmt|;
name|struct
name|string_hash_entry
modifier|*
name|h
decl_stmt|;
name|index
operator|=
name|info
operator|->
name|type_stack
operator|->
name|index
expr_stmt|;
name|size
operator|=
name|info
operator|->
name|type_stack
operator|->
name|size
expr_stmt|;
name|s
operator|=
name|stab_pop_type
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
name|strlen
argument_list|(
name|s
argument_list|)
operator|+
literal|20
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|>
literal|0
condition|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s:t%s"
argument_list|,
name|name
argument_list|,
name|s
argument_list|)
expr_stmt|;
else|else
block|{
name|index
operator|=
name|info
operator|->
name|type_index
expr_stmt|;
operator|++
name|info
operator|->
name|type_index
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s:t%ld=%s"
argument_list|,
name|name
argument_list|,
name|index
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|stab_write_symbol
argument_list|(
name|info
argument_list|,
name|N_LSYM
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|buf
argument_list|)
condition|)
return|return
name|false
return|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|h
operator|=
name|string_hash_lookup
argument_list|(
operator|&
name|info
operator|->
name|typedef_hash
argument_list|,
name|name
argument_list|,
name|true
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|==
name|NULL
condition|)
block|{
name|non_fatal
argument_list|(
name|_
argument_list|(
literal|"string_hash_lookup failed: %s"
argument_list|)
argument_list|,
name|bfd_errmsg
argument_list|(
name|bfd_get_error
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
comment|/* I don't think we care about redefinitions.  */
name|h
operator|->
name|index
operator|=
name|index
expr_stmt|;
name|h
operator|->
name|size
operator|=
name|size
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Define a tag.  */
end_comment

begin_function
specifier|static
name|boolean
name|stab_tag
parameter_list|(
name|p
parameter_list|,
name|tag
parameter_list|)
name|PTR
name|p
decl_stmt|;
specifier|const
name|char
modifier|*
name|tag
decl_stmt|;
block|{
name|struct
name|stab_write_handle
modifier|*
name|info
init|=
operator|(
expr|struct
name|stab_write_handle
operator|*
operator|)
name|p
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|buf
decl_stmt|;
name|s
operator|=
name|stab_pop_type
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|tag
argument_list|)
operator|+
name|strlen
argument_list|(
name|s
argument_list|)
operator|+
literal|3
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s:T%s"
argument_list|,
name|tag
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|stab_write_symbol
argument_list|(
name|info
argument_list|,
name|N_LSYM
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|buf
argument_list|)
condition|)
return|return
name|false
return|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Define an integer constant.  */
end_comment

begin_function
specifier|static
name|boolean
name|stab_int_constant
parameter_list|(
name|p
parameter_list|,
name|name
parameter_list|,
name|val
parameter_list|)
name|PTR
name|p
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|bfd_vma
name|val
decl_stmt|;
block|{
name|struct
name|stab_write_handle
modifier|*
name|info
init|=
operator|(
expr|struct
name|stab_write_handle
operator|*
operator|)
name|p
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|20
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s:c=i%ld"
argument_list|,
name|name
argument_list|,
operator|(
name|long
operator|)
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|stab_write_symbol
argument_list|(
name|info
argument_list|,
name|N_LSYM
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|buf
argument_list|)
condition|)
return|return
name|false
return|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Define a floating point constant.  */
end_comment

begin_function
specifier|static
name|boolean
name|stab_float_constant
parameter_list|(
name|p
parameter_list|,
name|name
parameter_list|,
name|val
parameter_list|)
name|PTR
name|p
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|double
name|val
decl_stmt|;
block|{
name|struct
name|stab_write_handle
modifier|*
name|info
init|=
operator|(
expr|struct
name|stab_write_handle
operator|*
operator|)
name|p
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|20
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s:c=f%g"
argument_list|,
name|name
argument_list|,
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|stab_write_symbol
argument_list|(
name|info
argument_list|,
name|N_LSYM
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|buf
argument_list|)
condition|)
return|return
name|false
return|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Define a typed constant.  */
end_comment

begin_function
specifier|static
name|boolean
name|stab_typed_constant
parameter_list|(
name|p
parameter_list|,
name|name
parameter_list|,
name|val
parameter_list|)
name|PTR
name|p
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|bfd_vma
name|val
decl_stmt|;
block|{
name|struct
name|stab_write_handle
modifier|*
name|info
init|=
operator|(
expr|struct
name|stab_write_handle
operator|*
operator|)
name|p
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|buf
decl_stmt|;
name|s
operator|=
name|stab_pop_type
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
name|strlen
argument_list|(
name|s
argument_list|)
operator|+
literal|20
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s:c=e%s,%ld"
argument_list|,
name|name
argument_list|,
name|s
argument_list|,
operator|(
name|long
operator|)
name|val
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|stab_write_symbol
argument_list|(
name|info
argument_list|,
name|N_LSYM
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|buf
argument_list|)
condition|)
return|return
name|false
return|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Record a variable.  */
end_comment

begin_function
specifier|static
name|boolean
name|stab_variable
parameter_list|(
name|p
parameter_list|,
name|name
parameter_list|,
name|kind
parameter_list|,
name|val
parameter_list|)
name|PTR
name|p
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|enum
name|debug_var_kind
name|kind
decl_stmt|;
name|bfd_vma
name|val
decl_stmt|;
block|{
name|struct
name|stab_write_handle
modifier|*
name|info
init|=
operator|(
expr|struct
name|stab_write_handle
operator|*
operator|)
name|p
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|buf
decl_stmt|;
name|int
name|stab_type
decl_stmt|;
specifier|const
name|char
modifier|*
name|kindstr
decl_stmt|;
name|s
operator|=
name|stab_pop_type
argument_list|(
name|info
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|kind
condition|)
block|{
default|default:
name|abort
argument_list|()
expr_stmt|;
case|case
name|DEBUG_GLOBAL
case|:
name|stab_type
operator|=
name|N_GSYM
expr_stmt|;
name|kindstr
operator|=
literal|"G"
expr_stmt|;
break|break;
case|case
name|DEBUG_STATIC
case|:
name|stab_type
operator|=
name|N_STSYM
expr_stmt|;
name|kindstr
operator|=
literal|"S"
expr_stmt|;
break|break;
case|case
name|DEBUG_LOCAL_STATIC
case|:
name|stab_type
operator|=
name|N_STSYM
expr_stmt|;
name|kindstr
operator|=
literal|"V"
expr_stmt|;
break|break;
case|case
name|DEBUG_LOCAL
case|:
name|stab_type
operator|=
name|N_LSYM
expr_stmt|;
name|kindstr
operator|=
literal|""
expr_stmt|;
comment|/* Make sure that this is a type reference or definition.  */
if|if
condition|(
operator|!
name|ISDIGIT
argument_list|(
operator|*
name|s
argument_list|)
condition|)
block|{
name|char
modifier|*
name|n
decl_stmt|;
name|long
name|index
decl_stmt|;
name|index
operator|=
name|info
operator|->
name|type_index
expr_stmt|;
operator|++
name|info
operator|->
name|type_index
expr_stmt|;
name|n
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|s
argument_list|)
operator|+
literal|20
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|n
argument_list|,
literal|"%ld=%s"
argument_list|,
name|index
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|s
operator|=
name|n
expr_stmt|;
block|}
break|break;
case|case
name|DEBUG_REGISTER
case|:
name|stab_type
operator|=
name|N_RSYM
expr_stmt|;
name|kindstr
operator|=
literal|"r"
expr_stmt|;
break|break;
block|}
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
name|strlen
argument_list|(
name|s
argument_list|)
operator|+
literal|3
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s:%s%s"
argument_list|,
name|name
argument_list|,
name|kindstr
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|stab_write_symbol
argument_list|(
name|info
argument_list|,
name|stab_type
argument_list|,
literal|0
argument_list|,
name|val
argument_list|,
name|buf
argument_list|)
condition|)
return|return
name|false
return|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Start outputting a function.  */
end_comment

begin_function
specifier|static
name|boolean
name|stab_start_function
parameter_list|(
name|p
parameter_list|,
name|name
parameter_list|,
name|globalp
parameter_list|)
name|PTR
name|p
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|boolean
name|globalp
decl_stmt|;
block|{
name|struct
name|stab_write_handle
modifier|*
name|info
init|=
operator|(
expr|struct
name|stab_write_handle
operator|*
operator|)
name|p
decl_stmt|;
name|char
modifier|*
name|rettype
decl_stmt|,
modifier|*
name|buf
decl_stmt|;
name|assert
argument_list|(
name|info
operator|->
name|nesting
operator|==
literal|0
operator|&&
name|info
operator|->
name|fun_offset
operator|==
operator|-
literal|1
argument_list|)
expr_stmt|;
name|rettype
operator|=
name|stab_pop_type
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
name|strlen
argument_list|(
name|rettype
argument_list|)
operator|+
literal|3
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s:%c%s"
argument_list|,
name|name
argument_list|,
name|globalp
condition|?
literal|'F'
else|:
literal|'f'
argument_list|,
name|rettype
argument_list|)
expr_stmt|;
comment|/* We don't know the value now, so we set it in start_block.  */
name|info
operator|->
name|fun_offset
operator|=
name|info
operator|->
name|symbols_size
expr_stmt|;
if|if
condition|(
operator|!
name|stab_write_symbol
argument_list|(
name|info
argument_list|,
name|N_FUN
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|buf
argument_list|)
condition|)
return|return
name|false
return|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Output a function parameter.  */
end_comment

begin_function
specifier|static
name|boolean
name|stab_function_parameter
parameter_list|(
name|p
parameter_list|,
name|name
parameter_list|,
name|kind
parameter_list|,
name|val
parameter_list|)
name|PTR
name|p
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|enum
name|debug_parm_kind
name|kind
decl_stmt|;
name|bfd_vma
name|val
decl_stmt|;
block|{
name|struct
name|stab_write_handle
modifier|*
name|info
init|=
operator|(
expr|struct
name|stab_write_handle
operator|*
operator|)
name|p
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|buf
decl_stmt|;
name|int
name|stab_type
decl_stmt|;
name|char
name|kindc
decl_stmt|;
name|s
operator|=
name|stab_pop_type
argument_list|(
name|info
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|kind
condition|)
block|{
default|default:
name|abort
argument_list|()
expr_stmt|;
case|case
name|DEBUG_PARM_STACK
case|:
name|stab_type
operator|=
name|N_PSYM
expr_stmt|;
name|kindc
operator|=
literal|'p'
expr_stmt|;
break|break;
case|case
name|DEBUG_PARM_REG
case|:
name|stab_type
operator|=
name|N_RSYM
expr_stmt|;
name|kindc
operator|=
literal|'P'
expr_stmt|;
break|break;
case|case
name|DEBUG_PARM_REFERENCE
case|:
name|stab_type
operator|=
name|N_PSYM
expr_stmt|;
name|kindc
operator|=
literal|'v'
expr_stmt|;
break|break;
case|case
name|DEBUG_PARM_REF_REG
case|:
name|stab_type
operator|=
name|N_RSYM
expr_stmt|;
name|kindc
operator|=
literal|'a'
expr_stmt|;
break|break;
block|}
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
name|strlen
argument_list|(
name|s
argument_list|)
operator|+
literal|3
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s:%c%s"
argument_list|,
name|name
argument_list|,
name|kindc
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|stab_write_symbol
argument_list|(
name|info
argument_list|,
name|stab_type
argument_list|,
literal|0
argument_list|,
name|val
argument_list|,
name|buf
argument_list|)
condition|)
return|return
name|false
return|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Start a block.  */
end_comment

begin_function
specifier|static
name|boolean
name|stab_start_block
parameter_list|(
name|p
parameter_list|,
name|addr
parameter_list|)
name|PTR
name|p
decl_stmt|;
name|bfd_vma
name|addr
decl_stmt|;
block|{
name|struct
name|stab_write_handle
modifier|*
name|info
init|=
operator|(
expr|struct
name|stab_write_handle
operator|*
operator|)
name|p
decl_stmt|;
comment|/* Fill in any slots which have been waiting for the first known      text address.  */
if|if
condition|(
name|info
operator|->
name|so_offset
operator|!=
operator|-
literal|1
condition|)
block|{
name|bfd_put_32
argument_list|(
name|info
operator|->
name|abfd
argument_list|,
name|addr
argument_list|,
name|info
operator|->
name|symbols
operator|+
name|info
operator|->
name|so_offset
operator|+
literal|8
argument_list|)
expr_stmt|;
name|info
operator|->
name|so_offset
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|info
operator|->
name|fun_offset
operator|!=
operator|-
literal|1
condition|)
block|{
name|bfd_put_32
argument_list|(
name|info
operator|->
name|abfd
argument_list|,
name|addr
argument_list|,
name|info
operator|->
name|symbols
operator|+
name|info
operator|->
name|fun_offset
operator|+
literal|8
argument_list|)
expr_stmt|;
name|info
operator|->
name|fun_offset
operator|=
operator|-
literal|1
expr_stmt|;
block|}
operator|++
name|info
operator|->
name|nesting
expr_stmt|;
comment|/* We will be called with a top level block surrounding the      function, but stabs information does not output that block, so we      ignore it.  */
if|if
condition|(
name|info
operator|->
name|nesting
operator|==
literal|1
condition|)
block|{
name|info
operator|->
name|fnaddr
operator|=
name|addr
expr_stmt|;
return|return
name|true
return|;
block|}
comment|/* We have to output the LBRAC symbol after any variables which are      declared inside the block.  We postpone the LBRAC until the next      start_block or end_block.  */
comment|/* If we have postponed an LBRAC, output it now.  */
if|if
condition|(
name|info
operator|->
name|pending_lbrac
operator|!=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|stab_write_symbol
argument_list|(
name|info
argument_list|,
name|N_LBRAC
argument_list|,
literal|0
argument_list|,
name|info
operator|->
name|pending_lbrac
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|)
condition|)
return|return
name|false
return|;
block|}
comment|/* Remember the address and output it later.  */
name|info
operator|->
name|pending_lbrac
operator|=
name|addr
operator|-
name|info
operator|->
name|fnaddr
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* End a block.  */
end_comment

begin_function
specifier|static
name|boolean
name|stab_end_block
parameter_list|(
name|p
parameter_list|,
name|addr
parameter_list|)
name|PTR
name|p
decl_stmt|;
name|bfd_vma
name|addr
decl_stmt|;
block|{
name|struct
name|stab_write_handle
modifier|*
name|info
init|=
operator|(
expr|struct
name|stab_write_handle
operator|*
operator|)
name|p
decl_stmt|;
if|if
condition|(
name|addr
operator|>
name|info
operator|->
name|last_text_address
condition|)
name|info
operator|->
name|last_text_address
operator|=
name|addr
expr_stmt|;
comment|/* If we have postponed an LBRAC, output it now.  */
if|if
condition|(
name|info
operator|->
name|pending_lbrac
operator|!=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|stab_write_symbol
argument_list|(
name|info
argument_list|,
name|N_LBRAC
argument_list|,
literal|0
argument_list|,
name|info
operator|->
name|pending_lbrac
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|)
condition|)
return|return
name|false
return|;
name|info
operator|->
name|pending_lbrac
operator|=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
expr_stmt|;
block|}
name|assert
argument_list|(
name|info
operator|->
name|nesting
operator|>
literal|0
argument_list|)
expr_stmt|;
operator|--
name|info
operator|->
name|nesting
expr_stmt|;
comment|/* We ignore the outermost block.  */
if|if
condition|(
name|info
operator|->
name|nesting
operator|==
literal|0
condition|)
return|return
name|true
return|;
return|return
name|stab_write_symbol
argument_list|(
name|info
argument_list|,
name|N_RBRAC
argument_list|,
literal|0
argument_list|,
name|addr
operator|-
name|info
operator|->
name|fnaddr
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* End a function.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|boolean
name|stab_end_function
parameter_list|(
name|p
parameter_list|)
name|PTR
name|p
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Output a line number.  */
end_comment

begin_function
specifier|static
name|boolean
name|stab_lineno
parameter_list|(
name|p
parameter_list|,
name|file
parameter_list|,
name|lineno
parameter_list|,
name|addr
parameter_list|)
name|PTR
name|p
decl_stmt|;
specifier|const
name|char
modifier|*
name|file
decl_stmt|;
name|unsigned
name|long
name|lineno
decl_stmt|;
name|bfd_vma
name|addr
decl_stmt|;
block|{
name|struct
name|stab_write_handle
modifier|*
name|info
init|=
operator|(
expr|struct
name|stab_write_handle
operator|*
operator|)
name|p
decl_stmt|;
name|assert
argument_list|(
name|info
operator|->
name|lineno_filename
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr
operator|>
name|info
operator|->
name|last_text_address
condition|)
name|info
operator|->
name|last_text_address
operator|=
name|addr
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|file
argument_list|,
name|info
operator|->
name|lineno_filename
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|stab_write_symbol
argument_list|(
name|info
argument_list|,
name|N_SOL
argument_list|,
literal|0
argument_list|,
name|addr
argument_list|,
name|file
argument_list|)
condition|)
return|return
name|false
return|;
name|info
operator|->
name|lineno_filename
operator|=
name|file
expr_stmt|;
block|}
return|return
name|stab_write_symbol
argument_list|(
name|info
argument_list|,
name|N_SLINE
argument_list|,
name|lineno
argument_list|,
name|addr
operator|-
name|info
operator|->
name|fnaddr
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|)
return|;
block|}
end_function

end_unit

