begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* objcopy.c -- copy object file from input to output, optionally massaging it.    Copyright (C) 1991, 92, 93, 94, 95, 96, 1997 Free Software Foundation, Inc.     This file is part of GNU Binutils.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_escape
end_escape

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"progress.h"
end_include

begin_include
include|#
directive|include
file|"bucomm.h"
end_include

begin_include
include|#
directive|include
file|"getopt.h"
end_include

begin_include
include|#
directive|include
file|"libiberty.h"
end_include

begin_include
include|#
directive|include
file|"budbg.h"
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_GOOD_UTIME_H
end_ifdef

begin_include
include|#
directive|include
file|<utime.h>
end_include

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* ! HAVE_GOOD_UTIME_H */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_UTIMES
end_ifdef

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_UTIMES */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ! HAVE_GOOD_UTIME_H */
end_comment

begin_decl_stmt
specifier|static
name|void
name|copy_usage
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|strip_usage
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|flagword
name|parse_flags
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|section_list
modifier|*
name|find_section_list
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
name|boolean
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|setup_section
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|copy_section
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|get_sections
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|compare_section_vma
name|PARAMS
argument_list|(
operator|(
specifier|const
name|PTR
operator|,
specifier|const
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|add_strip_symbol
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|is_strip_symbol
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|is_strip_section
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|filter_symbols
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|bfd
operator|*
operator|,
name|asymbol
operator|*
operator|*
operator|,
name|asymbol
operator|*
operator|*
operator|,
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mark_symbols_used_in_relocations
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|filter_bytes
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|bfd_size_type
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|write_debugging_info
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|PTR
operator|,
name|long
operator|*
operator|,
name|asymbol
operator|*
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|copy_object
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|copy_archive
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|bfd
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|copy_file
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|simple_copy
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|smart_rename
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|make_same_dates
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|strip_main
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|copy_main
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|nonfatal
parameter_list|(
name|s
parameter_list|)
value|{bfd_nonfatal(s); status = 1; return;}
end_define

begin_decl_stmt
specifier|static
name|asymbol
modifier|*
modifier|*
name|isympp
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Input symbols */
end_comment

begin_decl_stmt
specifier|static
name|asymbol
modifier|*
modifier|*
name|osympp
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Output symbols that survive stripping */
end_comment

begin_comment
comment|/* If `copy_byte'>= 0, copy only that byte of every `interleave' bytes.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|copy_byte
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|interleave
init|=
literal|4
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|verbose
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Print file and target names. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|status
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Exit status.  */
end_comment

begin_enum
enum|enum
name|strip_action
block|{
name|strip_undef
block|,
name|strip_none
block|,
comment|/* don't strip */
name|strip_debug
block|,
comment|/* strip all debugger symbols */
name|strip_unneeded
block|,
comment|/* strip unnecessary symbols */
name|strip_all
comment|/* strip all symbols */
block|}
enum|;
end_enum

begin_comment
comment|/* Which symbols to remove. */
end_comment

begin_decl_stmt
specifier|static
name|enum
name|strip_action
name|strip_symbols
decl_stmt|;
end_decl_stmt

begin_enum
enum|enum
name|locals_action
block|{
name|locals_undef
block|,
name|locals_start_L
block|,
comment|/* discard locals starting with L */
name|locals_all
comment|/* discard all locals */
block|}
enum|;
end_enum

begin_comment
comment|/* Which local symbols to remove.  Overrides strip_all.  */
end_comment

begin_decl_stmt
specifier|static
name|enum
name|locals_action
name|discard_locals
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Structure used to hold lists of sections and actions to take.  */
end_comment

begin_struct
struct|struct
name|section_list
block|{
comment|/* Next section to adjust.  */
name|struct
name|section_list
modifier|*
name|next
decl_stmt|;
comment|/* Section name.  */
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
comment|/* Whether this entry was used.  */
name|boolean
name|used
decl_stmt|;
comment|/* Whether to remove this section.  */
name|boolean
name|remove
decl_stmt|;
comment|/* Whether to adjust or set VMA.  */
enum|enum
block|{
name|ignore_vma
block|,
name|adjust_vma
block|,
name|set_vma
block|}
name|adjust
enum|;
comment|/* Amount to adjust by or set to.  */
name|bfd_vma
name|val
decl_stmt|;
comment|/* Whether to set the section flags.  */
name|boolean
name|set_flags
decl_stmt|;
comment|/* What to set the section flags to.  */
name|flagword
name|flags
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|section_list
modifier|*
name|adjust_sections
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|sections_removed
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Adjustments to the start address.  */
end_comment

begin_decl_stmt
specifier|static
name|bfd_vma
name|adjust_start
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|set_start_set
init|=
name|false
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_vma
name|set_start
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Adjustments to section VMA's.  */
end_comment

begin_decl_stmt
specifier|static
name|bfd_vma
name|adjust_section_vma
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Filling gaps between sections.  */
end_comment

begin_decl_stmt
specifier|static
name|boolean
name|gap_fill_set
init|=
name|false
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_byte
name|gap_fill
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pad to a given address.  */
end_comment

begin_decl_stmt
specifier|static
name|boolean
name|pad_to_set
init|=
name|false
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_vma
name|pad_to
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* List of sections to add.  */
end_comment

begin_struct
struct|struct
name|section_add
block|{
comment|/* Next section to add.  */
name|struct
name|section_add
modifier|*
name|next
decl_stmt|;
comment|/* Name of section to add.  */
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
comment|/* Name of file holding section contents.  */
specifier|const
name|char
modifier|*
name|filename
decl_stmt|;
comment|/* Size of file.  */
name|size_t
name|size
decl_stmt|;
comment|/* Contents of file.  */
name|bfd_byte
modifier|*
name|contents
decl_stmt|;
comment|/* BFD section, after it has been added.  */
name|asection
modifier|*
name|section
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|section_add
modifier|*
name|add_sections
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Whether to convert debugging information.  */
end_comment

begin_decl_stmt
specifier|static
name|boolean
name|convert_debugging
init|=
name|false
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Whether to change the leading character in symbol names.  */
end_comment

begin_decl_stmt
specifier|static
name|boolean
name|change_leading_char
init|=
name|false
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Whether to remove the leading character from global symbol names.  */
end_comment

begin_decl_stmt
specifier|static
name|boolean
name|remove_leading_char
init|=
name|false
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 150 isn't special; it's just an arbitrary non-ASCII char value.  */
end_comment

begin_define
define|#
directive|define
name|OPTION_ADD_SECTION
value|150
end_define

begin_define
define|#
directive|define
name|OPTION_ADJUST_START
value|(OPTION_ADD_SECTION + 1)
end_define

begin_define
define|#
directive|define
name|OPTION_ADJUST_VMA
value|(OPTION_ADJUST_START + 1)
end_define

begin_define
define|#
directive|define
name|OPTION_ADJUST_SECTION_VMA
value|(OPTION_ADJUST_VMA + 1)
end_define

begin_define
define|#
directive|define
name|OPTION_ADJUST_WARNINGS
value|(OPTION_ADJUST_SECTION_VMA + 1)
end_define

begin_define
define|#
directive|define
name|OPTION_CHANGE_LEADING_CHAR
value|(OPTION_ADJUST_WARNINGS + 1)
end_define

begin_define
define|#
directive|define
name|OPTION_DEBUGGING
value|(OPTION_CHANGE_LEADING_CHAR + 1)
end_define

begin_define
define|#
directive|define
name|OPTION_GAP_FILL
value|(OPTION_DEBUGGING + 1)
end_define

begin_define
define|#
directive|define
name|OPTION_NO_ADJUST_WARNINGS
value|(OPTION_GAP_FILL + 1)
end_define

begin_define
define|#
directive|define
name|OPTION_PAD_TO
value|(OPTION_NO_ADJUST_WARNINGS + 1)
end_define

begin_define
define|#
directive|define
name|OPTION_REMOVE_LEADING_CHAR
value|(OPTION_PAD_TO + 1)
end_define

begin_define
define|#
directive|define
name|OPTION_SET_SECTION_FLAGS
value|(OPTION_REMOVE_LEADING_CHAR + 1)
end_define

begin_define
define|#
directive|define
name|OPTION_SET_START
value|(OPTION_SET_SECTION_FLAGS + 1)
end_define

begin_define
define|#
directive|define
name|OPTION_STRIP_UNNEEDED
value|(OPTION_SET_START + 1)
end_define

begin_define
define|#
directive|define
name|OPTION_WEAKEN
value|(OPTION_STRIP_UNNEEDED + 1)
end_define

begin_comment
comment|/* Options to handle if running as "strip".  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|option
name|strip_options
index|[]
init|=
block|{
block|{
literal|"discard-all"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'x'
block|}
block|,
block|{
literal|"discard-locals"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'X'
block|}
block|,
block|{
literal|"format"
block|,
name|required_argument
block|,
literal|0
block|,
literal|'F'
block|}
block|,
comment|/* Obsolete */
block|{
literal|"help"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'h'
block|}
block|,
block|{
literal|"input-format"
block|,
name|required_argument
block|,
literal|0
block|,
literal|'I'
block|}
block|,
comment|/* Obsolete */
block|{
literal|"input-target"
block|,
name|required_argument
block|,
literal|0
block|,
literal|'I'
block|}
block|,
block|{
literal|"keep-symbol"
block|,
name|required_argument
block|,
literal|0
block|,
literal|'K'
block|}
block|,
block|{
literal|"output-format"
block|,
name|required_argument
block|,
literal|0
block|,
literal|'O'
block|}
block|,
comment|/* Obsolete */
block|{
literal|"output-target"
block|,
name|required_argument
block|,
literal|0
block|,
literal|'O'
block|}
block|,
block|{
literal|"preserve-dates"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'p'
block|}
block|,
block|{
literal|"remove-section"
block|,
name|required_argument
block|,
literal|0
block|,
literal|'R'
block|}
block|,
block|{
literal|"strip-all"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'s'
block|}
block|,
block|{
literal|"strip-debug"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'S'
block|}
block|,
block|{
literal|"strip-unneeded"
block|,
name|no_argument
block|,
literal|0
block|,
name|OPTION_STRIP_UNNEEDED
block|}
block|,
block|{
literal|"strip-symbol"
block|,
name|required_argument
block|,
literal|0
block|,
literal|'N'
block|}
block|,
block|{
literal|"target"
block|,
name|required_argument
block|,
literal|0
block|,
literal|'F'
block|}
block|,
block|{
literal|"verbose"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'v'
block|}
block|,
block|{
literal|"version"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'V'
block|}
block|,
block|{
literal|0
block|,
name|no_argument
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Options to handle if running as "objcopy".  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|option
name|copy_options
index|[]
init|=
block|{
block|{
literal|"add-section"
block|,
name|required_argument
block|,
literal|0
block|,
name|OPTION_ADD_SECTION
block|}
block|,
block|{
literal|"adjust-start"
block|,
name|required_argument
block|,
literal|0
block|,
name|OPTION_ADJUST_START
block|}
block|,
block|{
literal|"adjust-vma"
block|,
name|required_argument
block|,
literal|0
block|,
name|OPTION_ADJUST_VMA
block|}
block|,
block|{
literal|"adjust-section-vma"
block|,
name|required_argument
block|,
literal|0
block|,
name|OPTION_ADJUST_SECTION_VMA
block|}
block|,
block|{
literal|"adjust-warnings"
block|,
name|no_argument
block|,
literal|0
block|,
name|OPTION_ADJUST_WARNINGS
block|}
block|,
block|{
literal|"byte"
block|,
name|required_argument
block|,
literal|0
block|,
literal|'b'
block|}
block|,
block|{
literal|"change-leading-char"
block|,
name|no_argument
block|,
literal|0
block|,
name|OPTION_CHANGE_LEADING_CHAR
block|}
block|,
block|{
literal|"debugging"
block|,
name|no_argument
block|,
literal|0
block|,
name|OPTION_DEBUGGING
block|}
block|,
block|{
literal|"discard-all"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'x'
block|}
block|,
block|{
literal|"discard-locals"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'X'
block|}
block|,
block|{
literal|"format"
block|,
name|required_argument
block|,
literal|0
block|,
literal|'F'
block|}
block|,
comment|/* Obsolete */
block|{
literal|"gap-fill"
block|,
name|required_argument
block|,
literal|0
block|,
name|OPTION_GAP_FILL
block|}
block|,
block|{
literal|"help"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'h'
block|}
block|,
block|{
literal|"input-format"
block|,
name|required_argument
block|,
literal|0
block|,
literal|'I'
block|}
block|,
comment|/* Obsolete */
block|{
literal|"input-target"
block|,
name|required_argument
block|,
literal|0
block|,
literal|'I'
block|}
block|,
block|{
literal|"interleave"
block|,
name|required_argument
block|,
literal|0
block|,
literal|'i'
block|}
block|,
block|{
literal|"keep-symbol"
block|,
name|required_argument
block|,
literal|0
block|,
literal|'K'
block|}
block|,
block|{
literal|"no-adjust-warnings"
block|,
name|no_argument
block|,
literal|0
block|,
name|OPTION_NO_ADJUST_WARNINGS
block|}
block|,
block|{
literal|"output-format"
block|,
name|required_argument
block|,
literal|0
block|,
literal|'O'
block|}
block|,
comment|/* Obsolete */
block|{
literal|"output-target"
block|,
name|required_argument
block|,
literal|0
block|,
literal|'O'
block|}
block|,
block|{
literal|"pad-to"
block|,
name|required_argument
block|,
literal|0
block|,
name|OPTION_PAD_TO
block|}
block|,
block|{
literal|"preserve-dates"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'p'
block|}
block|,
block|{
literal|"remove-leading-char"
block|,
name|no_argument
block|,
literal|0
block|,
name|OPTION_REMOVE_LEADING_CHAR
block|}
block|,
block|{
literal|"remove-section"
block|,
name|required_argument
block|,
literal|0
block|,
literal|'R'
block|}
block|,
block|{
literal|"set-section-flags"
block|,
name|required_argument
block|,
literal|0
block|,
name|OPTION_SET_SECTION_FLAGS
block|}
block|,
block|{
literal|"set-start"
block|,
name|required_argument
block|,
literal|0
block|,
name|OPTION_SET_START
block|}
block|,
block|{
literal|"strip-all"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'S'
block|}
block|,
block|{
literal|"strip-debug"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'g'
block|}
block|,
block|{
literal|"strip-unneeded"
block|,
name|no_argument
block|,
literal|0
block|,
name|OPTION_STRIP_UNNEEDED
block|}
block|,
block|{
literal|"strip-symbol"
block|,
name|required_argument
block|,
literal|0
block|,
literal|'N'
block|}
block|,
block|{
literal|"target"
block|,
name|required_argument
block|,
literal|0
block|,
literal|'F'
block|}
block|,
block|{
literal|"verbose"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'v'
block|}
block|,
block|{
literal|"version"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'V'
block|}
block|,
block|{
literal|"weaken"
block|,
name|no_argument
block|,
literal|0
block|,
name|OPTION_WEAKEN
block|}
block|,
block|{
literal|0
block|,
name|no_argument
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* IMPORTS */
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|program_name
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This flag distinguishes between strip and objcopy:    1 means this is 'strip'; 0 means this is 'objcopy'.    -1 means if we should use argv[0] to decide. */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|is_strip
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|copy_usage
parameter_list|(
name|stream
parameter_list|,
name|exit_status
parameter_list|)
name|FILE
modifier|*
name|stream
decl_stmt|;
name|int
name|exit_status
decl_stmt|;
block|{
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\ Usage: %s [-vVSpgxX] [-I bfdname] [-O bfdname] [-F bfdname] [-b byte]\n\        [-R section] [-i interleave] [--interleave=interleave] [--byte=byte]\n\        [--input-target=bfdname] [--output-target=bfdname] [--target=bfdname]\n\        [--strip-all] [--strip-debug] [--strip-unneeded] [--discard-all]\n\        [--discard-locals] [--debugging] [--remove-section=section]\n"
argument_list|,
name|program_name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\        [--gap-fill=val] [--pad-to=address] [--preserve-dates]\n\        [--set-start=val] [--adjust-start=incr]\n\        [--adjust-vma=incr] [--adjust-section-vma=section{=,+,-}val]\n\        [--adjust-warnings] [--no-adjust-warnings]\n\        [--set-section-flags=section=flags] [--add-section=sectionname=filename]\n\        [--keep-symbol symbol] [-K symbol] [--strip-symbol symbol] [-N symbol]\n\        [--change-leading-char] [--remove-leading-char] [--weaken] [--verbose]\n\        [--version] [--help] in-file [out-file]\n"
argument_list|)
expr_stmt|;
name|list_supported_targets
argument_list|(
name|program_name
argument_list|,
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|exit_status
operator|==
literal|0
condition|)
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"Report bugs to bug-gnu-utils@prep.ai.mit.edu\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|exit_status
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|strip_usage
parameter_list|(
name|stream
parameter_list|,
name|exit_status
parameter_list|)
name|FILE
modifier|*
name|stream
decl_stmt|;
name|int
name|exit_status
decl_stmt|;
block|{
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\ Usage: %s [-vVsSpgxX] [-I bfdname] [-O bfdname] [-F bfdname] [-R section]\n\        [--input-target=bfdname] [--output-target=bfdname] [--target=bfdname]\n\        [--strip-all] [--strip-debug] [--strip-unneeded] [--discard-all]\n\        [--discard-locals] [--keep-symbol symbol] [-K symbol]\n\        [--strip-symbol symbol] [-N symbol] [--remove-section=section]\n\        [-o file] [--preserve-dates] [--verbose] [--version] [--help] file...\n"
argument_list|,
name|program_name
argument_list|)
expr_stmt|;
name|list_supported_targets
argument_list|(
name|program_name
argument_list|,
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|exit_status
operator|==
literal|0
condition|)
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"Report bugs to bug-gnu-utils@prep.ai.mit.edu\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|exit_status
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Parse section flags into a flagword, with a fatal error if the    string can't be parsed.  */
end_comment

begin_function
specifier|static
name|flagword
name|parse_flags
parameter_list|(
name|s
parameter_list|)
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|flagword
name|ret
decl_stmt|;
specifier|const
name|char
modifier|*
name|snext
decl_stmt|;
name|int
name|len
decl_stmt|;
name|ret
operator|=
name|SEC_NO_FLAGS
expr_stmt|;
do|do
block|{
name|snext
operator|=
name|strchr
argument_list|(
name|s
argument_list|,
literal|','
argument_list|)
expr_stmt|;
if|if
condition|(
name|snext
operator|==
name|NULL
condition|)
name|len
operator|=
name|strlen
argument_list|(
name|s
argument_list|)
expr_stmt|;
else|else
block|{
name|len
operator|=
name|snext
operator|-
name|s
expr_stmt|;
operator|++
name|snext
expr_stmt|;
block|}
define|#
directive|define
name|PARSE_FLAG
parameter_list|(
name|fname
parameter_list|,
name|fval
parameter_list|)
value|if (strncmp (fname, s, len) == 0) ret |= fval;
name|PARSE_FLAG
argument_list|(
literal|"alloc"
argument_list|,
name|SEC_ALLOC
argument_list|)
expr_stmt|;
name|PARSE_FLAG
argument_list|(
literal|"load"
argument_list|,
name|SEC_LOAD
argument_list|)
expr_stmt|;
name|PARSE_FLAG
argument_list|(
literal|"readonly"
argument_list|,
name|SEC_READONLY
argument_list|)
expr_stmt|;
name|PARSE_FLAG
argument_list|(
literal|"code"
argument_list|,
name|SEC_CODE
argument_list|)
expr_stmt|;
name|PARSE_FLAG
argument_list|(
literal|"data"
argument_list|,
name|SEC_DATA
argument_list|)
expr_stmt|;
name|PARSE_FLAG
argument_list|(
literal|"rom"
argument_list|,
name|SEC_ROM
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|PARSE_FLAG
name|s
operator|=
name|snext
expr_stmt|;
block|}
do|while
condition|(
name|s
operator|!=
name|NULL
condition|)
do|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Find and optionally add an entry in the adjust_sections list.  */
end_comment

begin_function
specifier|static
name|struct
name|section_list
modifier|*
name|find_section_list
parameter_list|(
name|name
parameter_list|,
name|add
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|boolean
name|add
decl_stmt|;
block|{
specifier|register
name|struct
name|section_list
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|adjust_sections
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|p
operator|->
name|name
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
return|return
name|p
return|;
if|if
condition|(
operator|!
name|add
condition|)
return|return
name|NULL
return|;
name|p
operator|=
operator|(
expr|struct
name|section_list
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|section_list
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|->
name|name
operator|=
name|name
expr_stmt|;
name|p
operator|->
name|used
operator|=
name|false
expr_stmt|;
name|p
operator|->
name|remove
operator|=
name|false
expr_stmt|;
name|p
operator|->
name|adjust
operator|=
name|ignore_vma
expr_stmt|;
name|p
operator|->
name|val
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|set_flags
operator|=
name|false
expr_stmt|;
name|p
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|next
operator|=
name|adjust_sections
expr_stmt|;
name|adjust_sections
operator|=
name|p
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_comment
comment|/* Make a list of symbols to explicitly strip out, or to keep.  A    linked list is good enough for a small number from the command    line, but this will slow things down a lot if many symbols are    being deleted. */
end_comment

begin_struct
struct|struct
name|symlist
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|struct
name|symlist
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* List of symbols to strip.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|symlist
modifier|*
name|strip_specific_list
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If this is false, we strip the symbols in strip_specific_list.    Otherwise, we keep only the symbols in the list.  */
end_comment

begin_decl_stmt
specifier|static
name|boolean
name|keep_symbols
init|=
name|false
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If this is true, we weaken global symbols (set BSF_WEAK).  */
end_comment

begin_decl_stmt
specifier|static
name|boolean
name|weaken
init|=
name|false
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Add a symbol to strip_specific_list.  */
end_comment

begin_function
specifier|static
name|void
name|add_strip_symbol
parameter_list|(
name|name
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|struct
name|symlist
modifier|*
name|tmp_list
decl_stmt|;
name|tmp_list
operator|=
operator|(
expr|struct
name|symlist
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|symlist
argument_list|)
argument_list|)
expr_stmt|;
name|tmp_list
operator|->
name|name
operator|=
name|name
expr_stmt|;
name|tmp_list
operator|->
name|next
operator|=
name|strip_specific_list
expr_stmt|;
name|strip_specific_list
operator|=
name|tmp_list
expr_stmt|;
block|}
end_function

begin_comment
comment|/* See whether a symbol should be stripped or kept based on    strip_specific_list and keep_symbols.  */
end_comment

begin_function
specifier|static
name|boolean
name|is_strip_symbol
parameter_list|(
name|name
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|struct
name|symlist
modifier|*
name|tmp_list
decl_stmt|;
for|for
control|(
name|tmp_list
operator|=
name|strip_specific_list
init|;
name|tmp_list
condition|;
name|tmp_list
operator|=
name|tmp_list
operator|->
name|next
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|tmp_list
operator|->
name|name
argument_list|)
operator|==
literal|0
condition|)
return|return
name|keep_symbols
condition|?
name|false
else|:
name|true
return|;
block|}
return|return
name|keep_symbols
return|;
block|}
end_function

begin_comment
comment|/* See if a section is being removed.  */
end_comment

begin_function
specifier|static
name|boolean
name|is_strip_section
parameter_list|(
name|abfd
parameter_list|,
name|sec
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
block|{
name|struct
name|section_list
modifier|*
name|p
decl_stmt|;
if|if
condition|(
operator|(
name|bfd_get_section_flags
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
operator|&
name|SEC_DEBUGGING
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|strip_symbols
operator|==
name|strip_debug
operator|||
name|strip_symbols
operator|==
name|strip_unneeded
operator|||
name|strip_symbols
operator|==
name|strip_all
operator|||
name|discard_locals
operator|==
name|locals_all
operator|||
name|convert_debugging
operator|)
condition|)
return|return
name|true
return|;
if|if
condition|(
operator|!
name|sections_removed
condition|)
return|return
name|false
return|;
name|p
operator|=
name|find_section_list
argument_list|(
name|bfd_get_section_name
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
argument_list|,
name|false
argument_list|)
expr_stmt|;
return|return
name|p
operator|!=
name|NULL
operator|&&
name|p
operator|->
name|remove
condition|?
name|true
else|:
name|false
return|;
block|}
end_function

begin_comment
comment|/* Choose which symbol entries to copy; put the result in OSYMS.    We don't copy in place, because that confuses the relocs.    Return the number of symbols to print.  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|filter_symbols
parameter_list|(
name|abfd
parameter_list|,
name|obfd
parameter_list|,
name|osyms
parameter_list|,
name|isyms
parameter_list|,
name|symcount
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|bfd
modifier|*
name|obfd
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|osyms
decl_stmt|,
decl|*
modifier|*
name|isyms
decl_stmt|;
end_function

begin_decl_stmt
name|long
name|symcount
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|asymbol
modifier|*
modifier|*
name|from
init|=
name|isyms
decl_stmt|,
modifier|*
modifier|*
name|to
init|=
name|osyms
decl_stmt|;
name|long
name|src_count
init|=
literal|0
decl_stmt|,
name|dst_count
init|=
literal|0
decl_stmt|;
for|for
control|(
init|;
name|src_count
operator|<
name|symcount
condition|;
name|src_count
operator|++
control|)
block|{
name|asymbol
modifier|*
name|sym
init|=
name|from
index|[
name|src_count
index|]
decl_stmt|;
name|flagword
name|flags
init|=
name|sym
operator|->
name|flags
decl_stmt|;
name|int
name|keep
decl_stmt|;
if|if
condition|(
name|change_leading_char
operator|&&
operator|(
name|bfd_get_symbol_leading_char
argument_list|(
name|abfd
argument_list|)
operator|!=
name|bfd_get_symbol_leading_char
argument_list|(
name|obfd
argument_list|)
operator|)
operator|&&
operator|(
name|bfd_get_symbol_leading_char
argument_list|(
name|abfd
argument_list|)
operator|==
literal|'\0'
operator|||
operator|(
name|bfd_asymbol_name
argument_list|(
name|sym
argument_list|)
index|[
literal|0
index|]
operator|==
name|bfd_get_symbol_leading_char
argument_list|(
name|abfd
argument_list|)
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|bfd_get_symbol_leading_char
argument_list|(
name|obfd
argument_list|)
operator|==
literal|'\0'
condition|)
name|bfd_asymbol_name
argument_list|(
name|sym
argument_list|)
operator|=
name|bfd_asymbol_name
argument_list|(
name|sym
argument_list|)
operator|+
literal|1
expr_stmt|;
else|else
block|{
name|char
modifier|*
name|n
decl_stmt|;
name|n
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|bfd_asymbol_name
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
name|n
index|[
literal|0
index|]
operator|=
name|bfd_get_symbol_leading_char
argument_list|(
name|obfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_get_symbol_leading_char
argument_list|(
name|abfd
argument_list|)
operator|==
literal|'\0'
condition|)
name|strcpy
argument_list|(
name|n
operator|+
literal|1
argument_list|,
name|bfd_asymbol_name
argument_list|(
name|sym
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|strcpy
argument_list|(
name|n
operator|+
literal|1
argument_list|,
name|bfd_asymbol_name
argument_list|(
name|sym
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|bfd_asymbol_name
argument_list|(
name|sym
argument_list|)
operator|=
name|n
expr_stmt|;
block|}
block|}
if|if
condition|(
name|remove_leading_char
operator|&&
operator|(
operator|(
name|flags
operator|&
name|BSF_GLOBAL
operator|)
operator|!=
literal|0
operator|||
operator|(
name|flags
operator|&
name|BSF_WEAK
operator|)
operator|!=
literal|0
operator|||
name|bfd_is_und_section
argument_list|(
name|bfd_get_section
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|||
name|bfd_is_com_section
argument_list|(
name|bfd_get_section
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|)
operator|&&
name|bfd_asymbol_name
argument_list|(
name|sym
argument_list|)
index|[
literal|0
index|]
operator|==
name|bfd_get_symbol_leading_char
argument_list|(
name|abfd
argument_list|)
condition|)
name|bfd_asymbol_name
argument_list|(
name|sym
argument_list|)
operator|=
name|bfd_asymbol_name
argument_list|(
name|sym
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|BSF_KEEP
operator|)
operator|!=
literal|0
condition|)
comment|/* Used in relocation.  */
name|keep
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|flags
operator|&
name|BSF_GLOBAL
operator|)
operator|!=
literal|0
comment|/* Global symbol.  */
operator|||
operator|(
name|flags
operator|&
name|BSF_WEAK
operator|)
operator|!=
literal|0
operator|||
name|bfd_is_und_section
argument_list|(
name|bfd_get_section
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|||
name|bfd_is_com_section
argument_list|(
name|bfd_get_section
argument_list|(
name|sym
argument_list|)
argument_list|)
condition|)
name|keep
operator|=
name|strip_symbols
operator|!=
name|strip_unneeded
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|flags
operator|&
name|BSF_DEBUGGING
operator|)
operator|!=
literal|0
condition|)
comment|/* Debugging symbol.  */
name|keep
operator|=
operator|(
name|strip_symbols
operator|!=
name|strip_debug
operator|&&
name|strip_symbols
operator|!=
name|strip_unneeded
operator|&&
operator|!
name|convert_debugging
operator|)
expr_stmt|;
else|else
comment|/* Local symbol.  */
name|keep
operator|=
operator|(
name|strip_symbols
operator|!=
name|strip_unneeded
operator|&&
operator|(
name|discard_locals
operator|!=
name|locals_all
operator|&&
operator|(
name|discard_locals
operator|!=
name|locals_start_L
operator|||
operator|!
name|bfd_is_local_label
argument_list|(
name|abfd
argument_list|,
name|sym
argument_list|)
operator|)
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|keep
operator|&&
name|is_strip_symbol
argument_list|(
name|bfd_asymbol_name
argument_list|(
name|sym
argument_list|)
argument_list|)
condition|)
name|keep
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|keep
operator|&&
name|is_strip_section
argument_list|(
name|abfd
argument_list|,
name|bfd_get_section
argument_list|(
name|sym
argument_list|)
argument_list|)
condition|)
name|keep
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|keep
operator|&&
name|weaken
operator|&&
operator|(
name|flags
operator|&
name|BSF_GLOBAL
operator|)
operator|!=
literal|0
condition|)
block|{
name|sym
operator|->
name|flags
operator|&=
operator|~
name|BSF_GLOBAL
expr_stmt|;
name|sym
operator|->
name|flags
operator||=
name|BSF_WEAK
expr_stmt|;
block|}
if|if
condition|(
name|keep
condition|)
name|to
index|[
name|dst_count
operator|++
index|]
operator|=
name|sym
expr_stmt|;
block|}
name|to
index|[
name|dst_count
index|]
operator|=
name|NULL
expr_stmt|;
return|return
name|dst_count
return|;
block|}
end_block

begin_comment
comment|/* Keep only every `copy_byte'th byte in MEMHUNK, which is *SIZE bytes long.    Adjust *SIZE.  */
end_comment

begin_function
specifier|static
name|void
name|filter_bytes
parameter_list|(
name|memhunk
parameter_list|,
name|size
parameter_list|)
name|char
modifier|*
name|memhunk
decl_stmt|;
name|bfd_size_type
modifier|*
name|size
decl_stmt|;
block|{
name|char
modifier|*
name|from
init|=
name|memhunk
operator|+
name|copy_byte
decl_stmt|,
modifier|*
name|to
init|=
name|memhunk
decl_stmt|,
modifier|*
name|end
init|=
name|memhunk
operator|+
operator|*
name|size
decl_stmt|;
for|for
control|(
init|;
name|from
operator|<
name|end
condition|;
name|from
operator|+=
name|interleave
control|)
operator|*
name|to
operator|++
operator|=
operator|*
name|from
expr_stmt|;
operator|*
name|size
operator|/=
name|interleave
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Copy object file IBFD onto OBFD.  */
end_comment

begin_function
specifier|static
name|void
name|copy_object
parameter_list|(
name|ibfd
parameter_list|,
name|obfd
parameter_list|)
name|bfd
modifier|*
name|ibfd
decl_stmt|;
name|bfd
modifier|*
name|obfd
decl_stmt|;
block|{
name|bfd_vma
name|start
decl_stmt|;
name|long
name|symcount
decl_stmt|;
name|asection
modifier|*
modifier|*
name|osections
init|=
name|NULL
decl_stmt|;
name|bfd_size_type
modifier|*
name|gaps
init|=
name|NULL
decl_stmt|;
name|bfd_size_type
name|max_gap
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|bfd_set_format
argument_list|(
name|obfd
argument_list|,
name|bfd_get_format
argument_list|(
name|ibfd
argument_list|)
argument_list|)
condition|)
block|{
name|nonfatal
argument_list|(
name|bfd_get_filename
argument_list|(
name|obfd
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|verbose
condition|)
name|printf
argument_list|(
literal|"copy from %s(%s) to %s(%s)\n"
argument_list|,
name|bfd_get_filename
argument_list|(
name|ibfd
argument_list|)
argument_list|,
name|bfd_get_target
argument_list|(
name|ibfd
argument_list|)
argument_list|,
name|bfd_get_filename
argument_list|(
name|obfd
argument_list|)
argument_list|,
name|bfd_get_target
argument_list|(
name|obfd
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|set_start_set
condition|)
name|start
operator|=
name|set_start
expr_stmt|;
else|else
name|start
operator|=
name|bfd_get_start_address
argument_list|(
name|ibfd
argument_list|)
expr_stmt|;
name|start
operator|+=
name|adjust_start
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_set_start_address
argument_list|(
name|obfd
argument_list|,
name|start
argument_list|)
operator|||
operator|!
name|bfd_set_file_flags
argument_list|(
name|obfd
argument_list|,
operator|(
name|bfd_get_file_flags
argument_list|(
name|ibfd
argument_list|)
operator|&
name|bfd_applicable_file_flags
argument_list|(
name|obfd
argument_list|)
operator|)
argument_list|)
condition|)
block|{
name|nonfatal
argument_list|(
name|bfd_get_filename
argument_list|(
name|ibfd
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Copy architecture of input file to output file */
if|if
condition|(
operator|!
name|bfd_set_arch_mach
argument_list|(
name|obfd
argument_list|,
name|bfd_get_arch
argument_list|(
name|ibfd
argument_list|)
argument_list|,
name|bfd_get_mach
argument_list|(
name|ibfd
argument_list|)
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Warning: Output file cannot represent architecture %s\n"
argument_list|,
name|bfd_printable_arch_mach
argument_list|(
name|bfd_get_arch
argument_list|(
name|ibfd
argument_list|)
argument_list|,
name|bfd_get_mach
argument_list|(
name|ibfd
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|bfd_set_format
argument_list|(
name|obfd
argument_list|,
name|bfd_get_format
argument_list|(
name|ibfd
argument_list|)
argument_list|)
condition|)
block|{
name|nonfatal
argument_list|(
name|bfd_get_filename
argument_list|(
name|ibfd
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|isympp
condition|)
name|free
argument_list|(
name|isympp
argument_list|)
expr_stmt|;
if|if
condition|(
name|osympp
operator|!=
name|isympp
condition|)
name|free
argument_list|(
name|osympp
argument_list|)
expr_stmt|;
comment|/* bfd mandates that all output sections be created and sizes set before      any output is done.  Thus, we traverse all sections multiple times.  */
name|bfd_map_over_sections
argument_list|(
name|ibfd
argument_list|,
name|setup_section
argument_list|,
operator|(
name|void
operator|*
operator|)
name|obfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|add_sections
operator|!=
name|NULL
condition|)
block|{
name|struct
name|section_add
modifier|*
name|padd
decl_stmt|;
name|struct
name|section_list
modifier|*
name|pset
decl_stmt|;
for|for
control|(
name|padd
operator|=
name|add_sections
init|;
name|padd
operator|!=
name|NULL
condition|;
name|padd
operator|=
name|padd
operator|->
name|next
control|)
block|{
name|padd
operator|->
name|section
operator|=
name|bfd_make_section
argument_list|(
name|obfd
argument_list|,
name|padd
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|padd
operator|->
name|section
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: can't create section `%s': %s\n"
argument_list|,
name|program_name
argument_list|,
name|padd
operator|->
name|name
argument_list|,
name|bfd_errmsg
argument_list|(
name|bfd_get_error
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|status
operator|=
literal|1
expr_stmt|;
return|return;
block|}
else|else
block|{
name|flagword
name|flags
decl_stmt|;
if|if
condition|(
operator|!
name|bfd_set_section_size
argument_list|(
name|obfd
argument_list|,
name|padd
operator|->
name|section
argument_list|,
name|padd
operator|->
name|size
argument_list|)
condition|)
name|nonfatal
argument_list|(
name|bfd_get_filename
argument_list|(
name|obfd
argument_list|)
argument_list|)
expr_stmt|;
name|pset
operator|=
name|find_section_list
argument_list|(
name|padd
operator|->
name|name
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|pset
operator|!=
name|NULL
condition|)
name|pset
operator|->
name|used
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|pset
operator|!=
name|NULL
operator|&&
name|pset
operator|->
name|set_flags
condition|)
name|flags
operator|=
name|pset
operator|->
name|flags
operator||
name|SEC_HAS_CONTENTS
expr_stmt|;
else|else
name|flags
operator|=
name|SEC_HAS_CONTENTS
operator||
name|SEC_READONLY
operator||
name|SEC_DATA
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_set_section_flags
argument_list|(
name|obfd
argument_list|,
name|padd
operator|->
name|section
argument_list|,
name|flags
argument_list|)
condition|)
name|nonfatal
argument_list|(
name|bfd_get_filename
argument_list|(
name|obfd
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pset
operator|!=
name|NULL
operator|&&
operator|(
name|pset
operator|->
name|adjust
operator|==
name|adjust_vma
operator|||
name|pset
operator|->
name|adjust
operator|==
name|set_vma
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|bfd_set_section_vma
argument_list|(
name|obfd
argument_list|,
name|padd
operator|->
name|section
argument_list|,
name|pset
operator|->
name|val
argument_list|)
condition|)
name|nonfatal
argument_list|(
name|bfd_get_filename
argument_list|(
name|obfd
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
if|if
condition|(
name|gap_fill_set
operator|||
name|pad_to_set
condition|)
block|{
name|asection
modifier|*
modifier|*
name|set
decl_stmt|;
name|unsigned
name|int
name|c
decl_stmt|,
name|i
decl_stmt|;
comment|/* We must fill in gaps between the sections and/or we must pad 	 the last section to a specified address.  We do this by 	 grabbing a list of the sections, sorting them by VMA, and 	 increasing the section sizes as required to fill the gaps. 	 We write out the gap contents below.  */
name|c
operator|=
name|bfd_count_sections
argument_list|(
name|obfd
argument_list|)
expr_stmt|;
name|osections
operator|=
operator|(
name|asection
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|c
operator|*
sizeof|sizeof
argument_list|(
name|asection
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|set
operator|=
name|osections
expr_stmt|;
name|bfd_map_over_sections
argument_list|(
name|obfd
argument_list|,
name|get_sections
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|set
argument_list|)
expr_stmt|;
name|qsort
argument_list|(
name|osections
argument_list|,
name|c
argument_list|,
sizeof|sizeof
argument_list|(
name|asection
operator|*
argument_list|)
argument_list|,
name|compare_section_vma
argument_list|)
expr_stmt|;
name|gaps
operator|=
operator|(
name|bfd_size_type
operator|*
operator|)
name|xmalloc
argument_list|(
name|c
operator|*
sizeof|sizeof
argument_list|(
name|bfd_size_type
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|gaps
argument_list|,
literal|0
argument_list|,
name|c
operator|*
sizeof|sizeof
argument_list|(
name|bfd_size_type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|gap_fill_set
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|c
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|flagword
name|flags
decl_stmt|;
name|bfd_size_type
name|size
decl_stmt|;
name|bfd_vma
name|gap_start
decl_stmt|,
name|gap_stop
decl_stmt|;
name|flags
operator|=
name|bfd_get_section_flags
argument_list|(
name|obfd
argument_list|,
name|osections
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|SEC_HAS_CONTENTS
operator|)
operator|==
literal|0
operator|||
operator|(
name|flags
operator|&
name|SEC_LOAD
operator|)
operator|==
literal|0
condition|)
continue|continue;
name|size
operator|=
name|bfd_section_size
argument_list|(
name|obfd
argument_list|,
name|osections
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|gap_start
operator|=
name|bfd_section_vma
argument_list|(
name|obfd
argument_list|,
name|osections
index|[
name|i
index|]
argument_list|)
operator|+
name|size
expr_stmt|;
name|gap_stop
operator|=
name|bfd_section_vma
argument_list|(
name|obfd
argument_list|,
name|osections
index|[
name|i
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|gap_start
operator|<
name|gap_stop
condition|)
block|{
if|if
condition|(
operator|!
name|bfd_set_section_size
argument_list|(
name|obfd
argument_list|,
name|osections
index|[
name|i
index|]
argument_list|,
name|size
operator|+
operator|(
name|gap_stop
operator|-
name|gap_start
operator|)
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: Can't fill gap after %s: %s\n"
argument_list|,
name|program_name
argument_list|,
name|bfd_get_section_name
argument_list|(
name|obfd
argument_list|,
name|osections
index|[
name|i
index|]
argument_list|)
argument_list|,
name|bfd_errmsg
argument_list|(
name|bfd_get_error
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|status
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|gaps
index|[
name|i
index|]
operator|=
name|gap_stop
operator|-
name|gap_start
expr_stmt|;
if|if
condition|(
name|max_gap
operator|<
name|gap_stop
operator|-
name|gap_start
condition|)
name|max_gap
operator|=
name|gap_stop
operator|-
name|gap_start
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|pad_to_set
condition|)
block|{
name|bfd_vma
name|vma
decl_stmt|;
name|bfd_size_type
name|size
decl_stmt|;
name|vma
operator|=
name|bfd_section_vma
argument_list|(
name|obfd
argument_list|,
name|osections
index|[
name|c
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
name|size
operator|=
name|bfd_section_size
argument_list|(
name|obfd
argument_list|,
name|osections
index|[
name|c
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|vma
operator|+
name|size
operator|<
name|pad_to
condition|)
block|{
if|if
condition|(
operator|!
name|bfd_set_section_size
argument_list|(
name|obfd
argument_list|,
name|osections
index|[
name|c
operator|-
literal|1
index|]
argument_list|,
name|pad_to
operator|-
name|vma
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: Can't add padding to %s: %s\n"
argument_list|,
name|program_name
argument_list|,
name|bfd_get_section_name
argument_list|(
name|obfd
argument_list|,
name|osections
index|[
name|c
operator|-
literal|1
index|]
argument_list|)
argument_list|,
name|bfd_errmsg
argument_list|(
name|bfd_get_error
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|status
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|gaps
index|[
name|c
operator|-
literal|1
index|]
operator|=
name|pad_to
operator|-
operator|(
name|vma
operator|+
name|size
operator|)
expr_stmt|;
if|if
condition|(
name|max_gap
operator|<
name|pad_to
operator|-
operator|(
name|vma
operator|+
name|size
operator|)
condition|)
name|max_gap
operator|=
name|pad_to
operator|-
operator|(
name|vma
operator|+
name|size
operator|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* Symbol filtering must happen after the output sections have      been created, but before their contents are set.  */
if|if
condition|(
name|strip_symbols
operator|==
name|strip_all
condition|)
block|{
name|osympp
operator|=
name|isympp
operator|=
name|NULL
expr_stmt|;
name|symcount
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|long
name|symsize
decl_stmt|;
name|PTR
name|dhandle
init|=
name|NULL
decl_stmt|;
name|symsize
operator|=
name|bfd_get_symtab_upper_bound
argument_list|(
name|ibfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|symsize
operator|<
literal|0
condition|)
block|{
name|nonfatal
argument_list|(
name|bfd_get_filename
argument_list|(
name|ibfd
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|osympp
operator|=
name|isympp
operator|=
operator|(
name|asymbol
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|symsize
argument_list|)
expr_stmt|;
name|symcount
operator|=
name|bfd_canonicalize_symtab
argument_list|(
name|ibfd
argument_list|,
name|isympp
argument_list|)
expr_stmt|;
if|if
condition|(
name|symcount
operator|<
literal|0
condition|)
block|{
name|nonfatal
argument_list|(
name|bfd_get_filename
argument_list|(
name|ibfd
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|convert_debugging
condition|)
name|dhandle
operator|=
name|read_debugging_info
argument_list|(
name|ibfd
argument_list|,
name|isympp
argument_list|,
name|symcount
argument_list|)
expr_stmt|;
if|if
condition|(
name|strip_symbols
operator|==
name|strip_debug
operator|||
name|strip_symbols
operator|==
name|strip_unneeded
operator|||
name|discard_locals
operator|!=
name|locals_undef
operator|||
name|strip_specific_list
operator|!=
name|NULL
operator|||
name|sections_removed
operator|||
name|convert_debugging
operator|||
name|change_leading_char
operator|||
name|remove_leading_char
operator|||
name|weaken
condition|)
block|{
comment|/* Mark symbols used in output relocations so that they 	     are kept, even if they are local labels or static symbols.  	     Note we iterate over the input sections examining their 	     relocations since the relocations for the output sections 	     haven't been set yet.  mark_symbols_used_in_relocations will 	     ignore input sections which have no corresponding output 	     section.  */
name|bfd_map_over_sections
argument_list|(
name|ibfd
argument_list|,
name|mark_symbols_used_in_relocations
argument_list|,
operator|(
name|PTR
operator|)
name|isympp
argument_list|)
expr_stmt|;
name|osympp
operator|=
operator|(
name|asymbol
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
operator|(
name|symcount
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|asymbol
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|symcount
operator|=
name|filter_symbols
argument_list|(
name|ibfd
argument_list|,
name|obfd
argument_list|,
name|osympp
argument_list|,
name|isympp
argument_list|,
name|symcount
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|convert_debugging
operator|&&
name|dhandle
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|write_debugging_info
argument_list|(
name|obfd
argument_list|,
name|dhandle
argument_list|,
operator|&
name|symcount
argument_list|,
operator|&
name|osympp
argument_list|)
condition|)
block|{
name|status
operator|=
literal|1
expr_stmt|;
return|return;
block|}
block|}
block|}
name|bfd_set_symtab
argument_list|(
name|obfd
argument_list|,
name|osympp
argument_list|,
name|symcount
argument_list|)
expr_stmt|;
comment|/* This has to happen after the symbol table has been set.  */
name|bfd_map_over_sections
argument_list|(
name|ibfd
argument_list|,
name|copy_section
argument_list|,
operator|(
name|void
operator|*
operator|)
name|obfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|add_sections
operator|!=
name|NULL
condition|)
block|{
name|struct
name|section_add
modifier|*
name|padd
decl_stmt|;
for|for
control|(
name|padd
operator|=
name|add_sections
init|;
name|padd
operator|!=
name|NULL
condition|;
name|padd
operator|=
name|padd
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|!
name|bfd_set_section_contents
argument_list|(
name|obfd
argument_list|,
name|padd
operator|->
name|section
argument_list|,
operator|(
name|PTR
operator|)
name|padd
operator|->
name|contents
argument_list|,
operator|(
name|file_ptr
operator|)
literal|0
argument_list|,
operator|(
name|bfd_size_type
operator|)
name|padd
operator|->
name|size
argument_list|)
condition|)
name|nonfatal
argument_list|(
name|bfd_get_filename
argument_list|(
name|obfd
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|gap_fill_set
operator|||
name|pad_to_set
condition|)
block|{
name|bfd_byte
modifier|*
name|buf
decl_stmt|;
name|int
name|c
decl_stmt|,
name|i
decl_stmt|;
comment|/* Fill in the gaps.  */
if|if
condition|(
name|max_gap
operator|>
literal|8192
condition|)
name|max_gap
operator|=
literal|8192
expr_stmt|;
name|buf
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|xmalloc
argument_list|(
name|max_gap
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|buf
argument_list|,
name|gap_fill
argument_list|,
operator|(
name|size_t
operator|)
name|max_gap
argument_list|)
expr_stmt|;
name|c
operator|=
name|bfd_count_sections
argument_list|(
name|obfd
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|c
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|gaps
index|[
name|i
index|]
operator|!=
literal|0
condition|)
block|{
name|bfd_size_type
name|left
decl_stmt|;
name|file_ptr
name|off
decl_stmt|;
name|left
operator|=
name|gaps
index|[
name|i
index|]
expr_stmt|;
name|off
operator|=
name|bfd_section_size
argument_list|(
name|obfd
argument_list|,
name|osections
index|[
name|i
index|]
argument_list|)
operator|-
name|left
expr_stmt|;
while|while
condition|(
name|left
operator|>
literal|0
condition|)
block|{
name|bfd_size_type
name|now
decl_stmt|;
if|if
condition|(
name|left
operator|>
literal|8192
condition|)
name|now
operator|=
literal|8192
expr_stmt|;
else|else
name|now
operator|=
name|left
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_set_section_contents
argument_list|(
name|obfd
argument_list|,
name|osections
index|[
name|i
index|]
argument_list|,
name|buf
argument_list|,
name|off
argument_list|,
name|now
argument_list|)
condition|)
block|{
name|nonfatal
argument_list|(
name|bfd_get_filename
argument_list|(
name|obfd
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|left
operator|-=
name|now
expr_stmt|;
name|off
operator|+=
name|now
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* Allow the BFD backend to copy any private data it understands      from the input BFD to the output BFD.  This is done last to      permit the routine to look at the filtered symbol table, which is      important for the ECOFF code at least.  */
if|if
condition|(
operator|!
name|bfd_copy_private_bfd_data
argument_list|(
name|ibfd
argument_list|,
name|obfd
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: %s: error copying private BFD data: %s\n"
argument_list|,
name|program_name
argument_list|,
name|bfd_get_filename
argument_list|(
name|obfd
argument_list|)
argument_list|,
name|bfd_errmsg
argument_list|(
name|bfd_get_error
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|status
operator|=
literal|1
expr_stmt|;
return|return;
block|}
block|}
end_function

begin_comment
comment|/* Read each archive element in turn from IBFD, copy the    contents to temp file, and keep the temp file handle.  */
end_comment

begin_function
specifier|static
name|void
name|copy_archive
parameter_list|(
name|ibfd
parameter_list|,
name|obfd
parameter_list|,
name|output_target
parameter_list|)
name|bfd
modifier|*
name|ibfd
decl_stmt|;
name|bfd
modifier|*
name|obfd
decl_stmt|;
specifier|const
name|char
modifier|*
name|output_target
decl_stmt|;
block|{
struct|struct
name|name_list
block|{
name|struct
name|name_list
modifier|*
name|next
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|bfd
modifier|*
name|obfd
decl_stmt|;
block|}
modifier|*
name|list
struct|,
modifier|*
name|l
struct|;
name|bfd
modifier|*
modifier|*
name|ptr
init|=
operator|&
name|obfd
operator|->
name|archive_head
decl_stmt|;
name|bfd
modifier|*
name|this_element
decl_stmt|;
name|char
modifier|*
name|dir
init|=
name|make_tempname
argument_list|(
name|bfd_get_filename
argument_list|(
name|obfd
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Make a temp directory to hold the contents.  */
if|if
condition|(
name|mkdir
argument_list|(
name|dir
argument_list|,
literal|0700
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|fatal
argument_list|(
literal|"cannot mkdir %s for archive copying (error: %s)"
argument_list|,
name|dir
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|obfd
operator|->
name|has_armap
operator|=
name|ibfd
operator|->
name|has_armap
expr_stmt|;
name|list
operator|=
name|NULL
expr_stmt|;
name|this_element
operator|=
name|bfd_openr_next_archived_file
argument_list|(
name|ibfd
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
while|while
condition|(
name|this_element
operator|!=
operator|(
name|bfd
operator|*
operator|)
name|NULL
condition|)
block|{
comment|/* Create an output file for this member.  */
name|char
modifier|*
name|output_name
init|=
name|concat
argument_list|(
name|dir
argument_list|,
literal|"/"
argument_list|,
name|bfd_get_filename
argument_list|(
name|this_element
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
decl_stmt|;
name|bfd
modifier|*
name|output_bfd
init|=
name|bfd_openw
argument_list|(
name|output_name
argument_list|,
name|output_target
argument_list|)
decl_stmt|;
name|bfd
modifier|*
name|last_element
decl_stmt|;
name|l
operator|=
operator|(
expr|struct
name|name_list
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|name_list
argument_list|)
argument_list|)
expr_stmt|;
name|l
operator|->
name|name
operator|=
name|output_name
expr_stmt|;
name|l
operator|->
name|next
operator|=
name|list
expr_stmt|;
name|list
operator|=
name|l
expr_stmt|;
if|if
condition|(
name|output_bfd
operator|==
operator|(
name|bfd
operator|*
operator|)
name|NULL
condition|)
block|{
name|nonfatal
argument_list|(
name|output_name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|bfd_set_format
argument_list|(
name|obfd
argument_list|,
name|bfd_get_format
argument_list|(
name|ibfd
argument_list|)
argument_list|)
condition|)
block|{
name|nonfatal
argument_list|(
name|bfd_get_filename
argument_list|(
name|obfd
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bfd_check_format
argument_list|(
name|this_element
argument_list|,
name|bfd_object
argument_list|)
operator|==
name|true
condition|)
block|{
name|copy_object
argument_list|(
name|this_element
argument_list|,
name|output_bfd
argument_list|)
expr_stmt|;
block|}
name|bfd_close
argument_list|(
name|output_bfd
argument_list|)
expr_stmt|;
comment|/* Open the newly output file and attach to our list.  */
name|output_bfd
operator|=
name|bfd_openr
argument_list|(
name|output_name
argument_list|,
name|output_target
argument_list|)
expr_stmt|;
name|l
operator|->
name|obfd
operator|=
name|output_bfd
expr_stmt|;
operator|*
name|ptr
operator|=
name|output_bfd
expr_stmt|;
name|ptr
operator|=
operator|&
name|output_bfd
operator|->
name|next
expr_stmt|;
name|last_element
operator|=
name|this_element
expr_stmt|;
name|this_element
operator|=
name|bfd_openr_next_archived_file
argument_list|(
name|ibfd
argument_list|,
name|last_element
argument_list|)
expr_stmt|;
name|bfd_close
argument_list|(
name|last_element
argument_list|)
expr_stmt|;
block|}
operator|*
name|ptr
operator|=
operator|(
name|bfd
operator|*
operator|)
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_close
argument_list|(
name|obfd
argument_list|)
condition|)
block|{
name|nonfatal
argument_list|(
name|bfd_get_filename
argument_list|(
name|obfd
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|bfd_close
argument_list|(
name|ibfd
argument_list|)
condition|)
block|{
name|nonfatal
argument_list|(
name|bfd_get_filename
argument_list|(
name|ibfd
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Delete all the files that we opened.  */
for|for
control|(
name|l
operator|=
name|list
init|;
name|l
operator|!=
name|NULL
condition|;
name|l
operator|=
name|l
operator|->
name|next
control|)
block|{
name|bfd_close
argument_list|(
name|l
operator|->
name|obfd
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|l
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
name|rmdir
argument_list|(
name|dir
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The top-level control.  */
end_comment

begin_function
specifier|static
name|void
name|copy_file
parameter_list|(
name|input_filename
parameter_list|,
name|output_filename
parameter_list|,
name|input_target
parameter_list|,
name|output_target
parameter_list|)
specifier|const
name|char
modifier|*
name|input_filename
decl_stmt|;
specifier|const
name|char
modifier|*
name|output_filename
decl_stmt|;
specifier|const
name|char
modifier|*
name|input_target
decl_stmt|;
specifier|const
name|char
modifier|*
name|output_target
decl_stmt|;
block|{
name|bfd
modifier|*
name|ibfd
decl_stmt|;
name|char
modifier|*
modifier|*
name|matching
decl_stmt|;
comment|/* To allow us to do "strip *" without dying on the first      non-object file, failures are nonfatal.  */
name|ibfd
operator|=
name|bfd_openr
argument_list|(
name|input_filename
argument_list|,
name|input_target
argument_list|)
expr_stmt|;
if|if
condition|(
name|ibfd
operator|==
name|NULL
condition|)
block|{
name|nonfatal
argument_list|(
name|input_filename
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bfd_check_format
argument_list|(
name|ibfd
argument_list|,
name|bfd_archive
argument_list|)
condition|)
block|{
name|bfd
modifier|*
name|obfd
decl_stmt|;
comment|/* bfd_get_target does not return the correct value until          bfd_check_format succeeds.  */
if|if
condition|(
name|output_target
operator|==
name|NULL
condition|)
name|output_target
operator|=
name|bfd_get_target
argument_list|(
name|ibfd
argument_list|)
expr_stmt|;
name|obfd
operator|=
name|bfd_openw
argument_list|(
name|output_filename
argument_list|,
name|output_target
argument_list|)
expr_stmt|;
if|if
condition|(
name|obfd
operator|==
name|NULL
condition|)
block|{
name|nonfatal
argument_list|(
name|output_filename
argument_list|)
expr_stmt|;
block|}
name|copy_archive
argument_list|(
name|ibfd
argument_list|,
name|obfd
argument_list|,
name|output_target
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bfd_check_format_matches
argument_list|(
name|ibfd
argument_list|,
name|bfd_object
argument_list|,
operator|&
name|matching
argument_list|)
condition|)
block|{
name|bfd
modifier|*
name|obfd
decl_stmt|;
comment|/* bfd_get_target does not return the correct value until          bfd_check_format succeeds.  */
if|if
condition|(
name|output_target
operator|==
name|NULL
condition|)
name|output_target
operator|=
name|bfd_get_target
argument_list|(
name|ibfd
argument_list|)
expr_stmt|;
name|obfd
operator|=
name|bfd_openw
argument_list|(
name|output_filename
argument_list|,
name|output_target
argument_list|)
expr_stmt|;
if|if
condition|(
name|obfd
operator|==
name|NULL
condition|)
block|{
name|nonfatal
argument_list|(
name|output_filename
argument_list|)
expr_stmt|;
block|}
name|copy_object
argument_list|(
name|ibfd
argument_list|,
name|obfd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_close
argument_list|(
name|obfd
argument_list|)
condition|)
block|{
name|nonfatal
argument_list|(
name|output_filename
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|bfd_close
argument_list|(
name|ibfd
argument_list|)
condition|)
block|{
name|nonfatal
argument_list|(
name|input_filename
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|bfd_nonfatal
argument_list|(
name|input_filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_get_error
argument_list|()
operator|==
name|bfd_error_file_ambiguously_recognized
condition|)
block|{
name|list_matching_formats
argument_list|(
name|matching
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|matching
argument_list|)
expr_stmt|;
block|}
name|status
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Create a section in OBFD with the same name and attributes    as ISECTION in IBFD.  */
end_comment

begin_function
specifier|static
name|void
name|setup_section
parameter_list|(
name|ibfd
parameter_list|,
name|isection
parameter_list|,
name|obfdarg
parameter_list|)
name|bfd
modifier|*
name|ibfd
decl_stmt|;
name|sec_ptr
name|isection
decl_stmt|;
name|PTR
name|obfdarg
decl_stmt|;
block|{
name|bfd
modifier|*
name|obfd
init|=
operator|(
name|bfd
operator|*
operator|)
name|obfdarg
decl_stmt|;
name|struct
name|section_list
modifier|*
name|p
decl_stmt|;
name|sec_ptr
name|osection
decl_stmt|;
name|bfd_vma
name|vma
decl_stmt|;
name|bfd_vma
name|lma
decl_stmt|;
name|flagword
name|flags
decl_stmt|;
name|char
modifier|*
name|err
decl_stmt|;
if|if
condition|(
operator|(
name|bfd_get_section_flags
argument_list|(
name|ibfd
argument_list|,
name|isection
argument_list|)
operator|&
name|SEC_DEBUGGING
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|strip_symbols
operator|==
name|strip_debug
operator|||
name|strip_symbols
operator|==
name|strip_unneeded
operator|||
name|strip_symbols
operator|==
name|strip_all
operator|||
name|discard_locals
operator|==
name|locals_all
operator|||
name|convert_debugging
operator|)
condition|)
return|return;
name|p
operator|=
name|find_section_list
argument_list|(
name|bfd_section_name
argument_list|(
name|ibfd
argument_list|,
name|isection
argument_list|)
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
name|p
operator|->
name|used
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
operator|&&
name|p
operator|->
name|remove
condition|)
return|return;
name|osection
operator|=
name|bfd_make_section_anyway
argument_list|(
name|obfd
argument_list|,
name|bfd_section_name
argument_list|(
name|ibfd
argument_list|,
name|isection
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|osection
operator|==
name|NULL
condition|)
block|{
name|err
operator|=
literal|"making"
expr_stmt|;
goto|goto
name|loser
goto|;
block|}
if|if
condition|(
operator|!
name|bfd_set_section_size
argument_list|(
name|obfd
argument_list|,
name|osection
argument_list|,
name|bfd_section_size
argument_list|(
name|ibfd
argument_list|,
name|isection
argument_list|)
argument_list|)
condition|)
block|{
name|err
operator|=
literal|"size"
expr_stmt|;
goto|goto
name|loser
goto|;
block|}
name|vma
operator|=
name|bfd_section_vma
argument_list|(
name|ibfd
argument_list|,
name|isection
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
operator|&&
name|p
operator|->
name|adjust
operator|==
name|adjust_vma
condition|)
name|vma
operator|+=
name|p
operator|->
name|val
expr_stmt|;
elseif|else
if|if
condition|(
name|p
operator|!=
name|NULL
operator|&&
name|p
operator|->
name|adjust
operator|==
name|set_vma
condition|)
name|vma
operator|=
name|p
operator|->
name|val
expr_stmt|;
else|else
name|vma
operator|+=
name|adjust_section_vma
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_set_section_vma
argument_list|(
name|obfd
argument_list|,
name|osection
argument_list|,
name|vma
argument_list|)
condition|)
block|{
name|err
operator|=
literal|"vma"
expr_stmt|;
goto|goto
name|loser
goto|;
block|}
name|lma
operator|=
name|isection
operator|->
name|lma
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
operator|&&
name|p
operator|->
name|adjust
operator|==
name|adjust_vma
condition|)
name|lma
operator|+=
name|p
operator|->
name|val
expr_stmt|;
elseif|else
if|if
condition|(
name|p
operator|!=
name|NULL
operator|&&
name|p
operator|->
name|adjust
operator|==
name|set_vma
condition|)
name|lma
operator|=
name|p
operator|->
name|val
expr_stmt|;
else|else
name|lma
operator|+=
name|adjust_section_vma
expr_stmt|;
name|osection
operator|->
name|lma
operator|=
name|lma
expr_stmt|;
if|if
condition|(
name|bfd_set_section_alignment
argument_list|(
name|obfd
argument_list|,
name|osection
argument_list|,
name|bfd_section_alignment
argument_list|(
name|ibfd
argument_list|,
name|isection
argument_list|)
argument_list|)
operator|==
name|false
condition|)
block|{
name|err
operator|=
literal|"alignment"
expr_stmt|;
goto|goto
name|loser
goto|;
block|}
name|flags
operator|=
name|bfd_get_section_flags
argument_list|(
name|ibfd
argument_list|,
name|isection
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
operator|&&
name|p
operator|->
name|set_flags
condition|)
name|flags
operator|=
name|p
operator|->
name|flags
operator||
operator|(
name|flags
operator|&
name|SEC_HAS_CONTENTS
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_set_section_flags
argument_list|(
name|obfd
argument_list|,
name|osection
argument_list|,
name|flags
argument_list|)
condition|)
block|{
name|err
operator|=
literal|"flags"
expr_stmt|;
goto|goto
name|loser
goto|;
block|}
comment|/* This used to be mangle_section; we do here to avoid using      bfd_get_section_by_name since some formats allow multiple      sections with the same name.  */
name|isection
operator|->
name|output_section
operator|=
name|osection
expr_stmt|;
name|isection
operator|->
name|output_offset
operator|=
literal|0
expr_stmt|;
comment|/* Allow the BFD backend to copy any private data it understands      from the input section to the output section.  */
if|if
condition|(
operator|!
name|bfd_copy_private_section_data
argument_list|(
name|ibfd
argument_list|,
name|isection
argument_list|,
name|obfd
argument_list|,
name|osection
argument_list|)
condition|)
block|{
name|err
operator|=
literal|"private data"
expr_stmt|;
goto|goto
name|loser
goto|;
block|}
comment|/* All went well */
return|return;
name|loser
label|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: %s: section `%s': error in %s: %s\n"
argument_list|,
name|program_name
argument_list|,
name|bfd_get_filename
argument_list|(
name|ibfd
argument_list|)
argument_list|,
name|bfd_section_name
argument_list|(
name|ibfd
argument_list|,
name|isection
argument_list|)
argument_list|,
name|err
argument_list|,
name|bfd_errmsg
argument_list|(
name|bfd_get_error
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|status
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Copy the data of input section ISECTION of IBFD    to an output section with the same name in OBFD.    If stripping then don't copy any relocation info.  */
end_comment

begin_function
specifier|static
name|void
name|copy_section
parameter_list|(
name|ibfd
parameter_list|,
name|isection
parameter_list|,
name|obfdarg
parameter_list|)
name|bfd
modifier|*
name|ibfd
decl_stmt|;
name|sec_ptr
name|isection
decl_stmt|;
name|PTR
name|obfdarg
decl_stmt|;
block|{
name|bfd
modifier|*
name|obfd
init|=
operator|(
name|bfd
operator|*
operator|)
name|obfdarg
decl_stmt|;
name|struct
name|section_list
modifier|*
name|p
decl_stmt|;
name|arelent
modifier|*
modifier|*
name|relpp
decl_stmt|;
name|long
name|relcount
decl_stmt|;
name|sec_ptr
name|osection
decl_stmt|;
name|bfd_size_type
name|size
decl_stmt|;
if|if
condition|(
operator|(
name|bfd_get_section_flags
argument_list|(
name|ibfd
argument_list|,
name|isection
argument_list|)
operator|&
name|SEC_DEBUGGING
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|strip_symbols
operator|==
name|strip_debug
operator|||
name|strip_symbols
operator|==
name|strip_unneeded
operator|||
name|strip_symbols
operator|==
name|strip_all
operator|||
name|discard_locals
operator|==
name|locals_all
operator|||
name|convert_debugging
operator|)
condition|)
block|{
return|return;
block|}
name|p
operator|=
name|find_section_list
argument_list|(
name|bfd_section_name
argument_list|(
name|ibfd
argument_list|,
name|isection
argument_list|)
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
operator|&&
name|p
operator|->
name|remove
condition|)
return|return;
name|osection
operator|=
name|isection
operator|->
name|output_section
expr_stmt|;
name|size
operator|=
name|bfd_get_section_size_before_reloc
argument_list|(
name|isection
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|==
literal|0
operator|||
name|osection
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|strip_symbols
operator|==
name|strip_all
condition|)
name|bfd_set_reloc
argument_list|(
name|obfd
argument_list|,
name|osection
argument_list|,
operator|(
name|arelent
operator|*
operator|*
operator|)
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
block|{
name|long
name|relsize
decl_stmt|;
name|relsize
operator|=
name|bfd_get_reloc_upper_bound
argument_list|(
name|ibfd
argument_list|,
name|isection
argument_list|)
expr_stmt|;
if|if
condition|(
name|relsize
operator|<
literal|0
condition|)
block|{
name|nonfatal
argument_list|(
name|bfd_get_filename
argument_list|(
name|ibfd
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|relsize
operator|==
literal|0
condition|)
name|bfd_set_reloc
argument_list|(
name|obfd
argument_list|,
name|osection
argument_list|,
operator|(
name|arelent
operator|*
operator|*
operator|)
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
block|{
name|relpp
operator|=
operator|(
name|arelent
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|relsize
argument_list|)
expr_stmt|;
name|relcount
operator|=
name|bfd_canonicalize_reloc
argument_list|(
name|ibfd
argument_list|,
name|isection
argument_list|,
name|relpp
argument_list|,
name|isympp
argument_list|)
expr_stmt|;
if|if
condition|(
name|relcount
operator|<
literal|0
condition|)
block|{
name|nonfatal
argument_list|(
name|bfd_get_filename
argument_list|(
name|ibfd
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|bfd_set_reloc
argument_list|(
name|obfd
argument_list|,
name|osection
argument_list|,
name|relpp
argument_list|,
name|relcount
argument_list|)
expr_stmt|;
block|}
block|}
name|isection
operator|->
name|_cooked_size
operator|=
name|isection
operator|->
name|_raw_size
expr_stmt|;
name|isection
operator|->
name|reloc_done
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|bfd_get_section_flags
argument_list|(
name|ibfd
argument_list|,
name|isection
argument_list|)
operator|&
name|SEC_HAS_CONTENTS
condition|)
block|{
name|PTR
name|memhunk
init|=
operator|(
name|PTR
operator|)
name|xmalloc
argument_list|(
operator|(
name|unsigned
operator|)
name|size
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|bfd_get_section_contents
argument_list|(
name|ibfd
argument_list|,
name|isection
argument_list|,
name|memhunk
argument_list|,
operator|(
name|file_ptr
operator|)
literal|0
argument_list|,
name|size
argument_list|)
condition|)
block|{
name|nonfatal
argument_list|(
name|bfd_get_filename
argument_list|(
name|ibfd
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|copy_byte
operator|>=
literal|0
condition|)
block|{
name|filter_bytes
argument_list|(
name|memhunk
argument_list|,
operator|&
name|size
argument_list|)
expr_stmt|;
comment|/* The section has gotten smaller. */
if|if
condition|(
operator|!
name|bfd_set_section_size
argument_list|(
name|obfd
argument_list|,
name|osection
argument_list|,
name|size
argument_list|)
condition|)
name|nonfatal
argument_list|(
name|bfd_get_filename
argument_list|(
name|obfd
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|bfd_set_section_contents
argument_list|(
name|obfd
argument_list|,
name|osection
argument_list|,
name|memhunk
argument_list|,
operator|(
name|file_ptr
operator|)
literal|0
argument_list|,
name|size
argument_list|)
condition|)
block|{
name|nonfatal
argument_list|(
name|bfd_get_filename
argument_list|(
name|obfd
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|memhunk
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Get all the sections.  This is used when --gap-fill or --pad-to is    used.  */
end_comment

begin_function
specifier|static
name|void
name|get_sections
parameter_list|(
name|obfd
parameter_list|,
name|osection
parameter_list|,
name|secppparg
parameter_list|)
name|bfd
modifier|*
name|obfd
decl_stmt|;
name|asection
modifier|*
name|osection
decl_stmt|;
name|PTR
name|secppparg
decl_stmt|;
block|{
name|asection
modifier|*
modifier|*
modifier|*
name|secppp
init|=
operator|(
name|asection
operator|*
operator|*
operator|*
operator|)
name|secppparg
decl_stmt|;
operator|*
operator|*
name|secppp
operator|=
name|osection
expr_stmt|;
operator|++
operator|(
operator|*
name|secppp
operator|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Sort sections by VMA.  This is called via qsort, and is used when    --gap-fill or --pad-to is used.  We force non loadable or empty    sections to the front, where they are easier to ignore.  */
end_comment

begin_function
specifier|static
name|int
name|compare_section_vma
parameter_list|(
name|arg1
parameter_list|,
name|arg2
parameter_list|)
specifier|const
name|PTR
name|arg1
decl_stmt|;
specifier|const
name|PTR
name|arg2
decl_stmt|;
block|{
specifier|const
name|asection
modifier|*
modifier|*
name|sec1
init|=
operator|(
specifier|const
name|asection
operator|*
operator|*
operator|)
name|arg1
decl_stmt|;
specifier|const
name|asection
modifier|*
modifier|*
name|sec2
init|=
operator|(
specifier|const
name|asection
operator|*
operator|*
operator|)
name|arg2
decl_stmt|;
name|flagword
name|flags1
decl_stmt|,
name|flags2
decl_stmt|;
comment|/* Sort non loadable sections to the front.  */
name|flags1
operator|=
operator|(
operator|*
name|sec1
operator|)
operator|->
name|flags
expr_stmt|;
name|flags2
operator|=
operator|(
operator|*
name|sec2
operator|)
operator|->
name|flags
expr_stmt|;
if|if
condition|(
operator|(
name|flags1
operator|&
name|SEC_HAS_CONTENTS
operator|)
operator|==
literal|0
operator|||
operator|(
name|flags1
operator|&
name|SEC_LOAD
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|flags2
operator|&
name|SEC_HAS_CONTENTS
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|flags2
operator|&
name|SEC_LOAD
operator|)
operator|!=
literal|0
condition|)
return|return
operator|-
literal|1
return|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|flags2
operator|&
name|SEC_HAS_CONTENTS
operator|)
operator|==
literal|0
operator|||
operator|(
name|flags2
operator|&
name|SEC_LOAD
operator|)
operator|==
literal|0
condition|)
return|return
literal|1
return|;
block|}
comment|/* Sort sections by VMA.  */
if|if
condition|(
operator|(
operator|*
name|sec1
operator|)
operator|->
name|vma
operator|>
operator|(
operator|*
name|sec2
operator|)
operator|->
name|vma
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
operator|(
operator|*
name|sec1
operator|)
operator|->
name|vma
operator|<
operator|(
operator|*
name|sec2
operator|)
operator|->
name|vma
condition|)
return|return
operator|-
literal|1
return|;
comment|/* Sort sections with the same VMA by size.  */
if|if
condition|(
operator|(
operator|*
name|sec1
operator|)
operator|->
name|_raw_size
operator|>
operator|(
operator|*
name|sec2
operator|)
operator|->
name|_raw_size
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
operator|(
operator|*
name|sec1
operator|)
operator|->
name|_raw_size
operator|<
operator|(
operator|*
name|sec2
operator|)
operator|->
name|_raw_size
condition|)
return|return
operator|-
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Mark all the symbols which will be used in output relocations with    the BSF_KEEP flag so that those symbols will not be stripped.     Ignore relocations which will not appear in the output file.  */
end_comment

begin_function
specifier|static
name|void
name|mark_symbols_used_in_relocations
parameter_list|(
name|ibfd
parameter_list|,
name|isection
parameter_list|,
name|symbolsarg
parameter_list|)
name|bfd
modifier|*
name|ibfd
decl_stmt|;
name|sec_ptr
name|isection
decl_stmt|;
name|PTR
name|symbolsarg
decl_stmt|;
block|{
name|asymbol
modifier|*
modifier|*
name|symbols
init|=
operator|(
name|asymbol
operator|*
operator|*
operator|)
name|symbolsarg
decl_stmt|;
name|long
name|relsize
decl_stmt|;
name|arelent
modifier|*
modifier|*
name|relpp
decl_stmt|;
name|long
name|relcount
decl_stmt|,
name|i
decl_stmt|;
comment|/* Ignore an input section with no corresponding output section.  */
if|if
condition|(
name|isection
operator|->
name|output_section
operator|==
name|NULL
condition|)
return|return;
name|relsize
operator|=
name|bfd_get_reloc_upper_bound
argument_list|(
name|ibfd
argument_list|,
name|isection
argument_list|)
expr_stmt|;
if|if
condition|(
name|relsize
operator|<
literal|0
condition|)
name|bfd_fatal
argument_list|(
name|bfd_get_filename
argument_list|(
name|ibfd
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|relsize
operator|==
literal|0
condition|)
return|return;
name|relpp
operator|=
operator|(
name|arelent
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|relsize
argument_list|)
expr_stmt|;
name|relcount
operator|=
name|bfd_canonicalize_reloc
argument_list|(
name|ibfd
argument_list|,
name|isection
argument_list|,
name|relpp
argument_list|,
name|symbols
argument_list|)
expr_stmt|;
if|if
condition|(
name|relcount
operator|<
literal|0
condition|)
name|bfd_fatal
argument_list|(
name|bfd_get_filename
argument_list|(
name|ibfd
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Examine each symbol used in a relocation.  If it's not one of the      special bfd section symbols, then mark it with BSF_KEEP.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|relcount
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|relpp
index|[
name|i
index|]
operator|->
name|sym_ptr_ptr
operator|!=
name|bfd_com_section_ptr
operator|->
name|symbol
operator|&&
operator|*
name|relpp
index|[
name|i
index|]
operator|->
name|sym_ptr_ptr
operator|!=
name|bfd_abs_section_ptr
operator|->
name|symbol
operator|&&
operator|*
name|relpp
index|[
name|i
index|]
operator|->
name|sym_ptr_ptr
operator|!=
name|bfd_und_section_ptr
operator|->
name|symbol
condition|)
operator|(
operator|*
name|relpp
index|[
name|i
index|]
operator|->
name|sym_ptr_ptr
operator|)
operator|->
name|flags
operator||=
name|BSF_KEEP
expr_stmt|;
block|}
if|if
condition|(
name|relpp
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|relpp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Write out debugging information.  */
end_comment

begin_function
specifier|static
name|boolean
name|write_debugging_info
parameter_list|(
name|obfd
parameter_list|,
name|dhandle
parameter_list|,
name|symcountp
parameter_list|,
name|symppp
parameter_list|)
name|bfd
modifier|*
name|obfd
decl_stmt|;
name|PTR
name|dhandle
decl_stmt|;
name|long
modifier|*
name|symcountp
decl_stmt|;
name|asymbol
modifier|*
modifier|*
modifier|*
name|symppp
decl_stmt|;
block|{
if|if
condition|(
name|bfd_get_flavour
argument_list|(
name|obfd
argument_list|)
operator|==
name|bfd_target_ieee_flavour
condition|)
return|return
name|write_ieee_debugging_info
argument_list|(
name|obfd
argument_list|,
name|dhandle
argument_list|)
return|;
if|if
condition|(
name|bfd_get_flavour
argument_list|(
name|obfd
argument_list|)
operator|==
name|bfd_target_coff_flavour
operator|||
name|bfd_get_flavour
argument_list|(
name|obfd
argument_list|)
operator|==
name|bfd_target_elf_flavour
condition|)
block|{
name|bfd_byte
modifier|*
name|syms
decl_stmt|,
modifier|*
name|strings
decl_stmt|;
name|bfd_size_type
name|symsize
decl_stmt|,
name|stringsize
decl_stmt|;
name|asection
modifier|*
name|stabsec
decl_stmt|,
modifier|*
name|stabstrsec
decl_stmt|;
if|if
condition|(
operator|!
name|write_stabs_in_sections_debugging_info
argument_list|(
name|obfd
argument_list|,
name|dhandle
argument_list|,
operator|&
name|syms
argument_list|,
operator|&
name|symsize
argument_list|,
operator|&
name|strings
argument_list|,
operator|&
name|stringsize
argument_list|)
condition|)
return|return
name|false
return|;
name|stabsec
operator|=
name|bfd_make_section
argument_list|(
name|obfd
argument_list|,
literal|".stab"
argument_list|)
expr_stmt|;
name|stabstrsec
operator|=
name|bfd_make_section
argument_list|(
name|obfd
argument_list|,
literal|".stabstr"
argument_list|)
expr_stmt|;
if|if
condition|(
name|stabsec
operator|==
name|NULL
operator|||
name|stabstrsec
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_size
argument_list|(
name|obfd
argument_list|,
name|stabsec
argument_list|,
name|symsize
argument_list|)
operator|||
operator|!
name|bfd_set_section_size
argument_list|(
name|obfd
argument_list|,
name|stabstrsec
argument_list|,
name|stringsize
argument_list|)
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|obfd
argument_list|,
name|stabsec
argument_list|,
literal|2
argument_list|)
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|obfd
argument_list|,
name|stabstrsec
argument_list|,
literal|0
argument_list|)
operator|||
operator|!
name|bfd_set_section_flags
argument_list|(
name|obfd
argument_list|,
name|stabsec
argument_list|,
operator|(
name|SEC_HAS_CONTENTS
operator||
name|SEC_READONLY
operator||
name|SEC_DEBUGGING
operator|)
argument_list|)
operator|||
operator|!
name|bfd_set_section_flags
argument_list|(
name|obfd
argument_list|,
name|stabstrsec
argument_list|,
operator|(
name|SEC_HAS_CONTENTS
operator||
name|SEC_READONLY
operator||
name|SEC_DEBUGGING
operator|)
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: can't create debugging section: %s\n"
argument_list|,
name|bfd_get_filename
argument_list|(
name|obfd
argument_list|)
argument_list|,
name|bfd_errmsg
argument_list|(
name|bfd_get_error
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
comment|/* We can get away with setting the section contents now because          the next thing the caller is going to do is copy over the          real sections.  We may someday have to split the contents          setting out of this function.  */
if|if
condition|(
operator|!
name|bfd_set_section_contents
argument_list|(
name|obfd
argument_list|,
name|stabsec
argument_list|,
name|syms
argument_list|,
operator|(
name|file_ptr
operator|)
literal|0
argument_list|,
name|symsize
argument_list|)
operator|||
operator|!
name|bfd_set_section_contents
argument_list|(
name|obfd
argument_list|,
name|stabstrsec
argument_list|,
name|strings
argument_list|,
operator|(
name|file_ptr
operator|)
literal|0
argument_list|,
name|stringsize
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: can't set debugging section contents: %s\n"
argument_list|,
name|bfd_get_filename
argument_list|(
name|obfd
argument_list|)
argument_list|,
name|bfd_errmsg
argument_list|(
name|bfd_get_error
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
return|return
name|true
return|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: don't know how to write debugging information for %s\n"
argument_list|,
name|bfd_get_filename
argument_list|(
name|obfd
argument_list|)
argument_list|,
name|bfd_get_target
argument_list|(
name|obfd
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* The number of bytes to copy at once.  */
end_comment

begin_define
define|#
directive|define
name|COPY_BUF
value|8192
end_define

begin_comment
comment|/* Copy file FROM to file TO, performing no translations.    Return 0 if ok, -1 if error.  */
end_comment

begin_function
specifier|static
name|int
name|simple_copy
parameter_list|(
name|from
parameter_list|,
name|to
parameter_list|)
specifier|const
name|char
modifier|*
name|from
decl_stmt|;
specifier|const
name|char
modifier|*
name|to
decl_stmt|;
block|{
name|int
name|fromfd
decl_stmt|,
name|tofd
decl_stmt|,
name|nread
decl_stmt|;
name|int
name|saved
decl_stmt|;
name|char
name|buf
index|[
name|COPY_BUF
index|]
decl_stmt|;
name|fromfd
operator|=
name|open
argument_list|(
name|from
argument_list|,
name|O_RDONLY
argument_list|)
expr_stmt|;
if|if
condition|(
name|fromfd
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
name|tofd
operator|=
name|creat
argument_list|(
name|to
argument_list|,
literal|0777
argument_list|)
expr_stmt|;
if|if
condition|(
name|tofd
operator|<
literal|0
condition|)
block|{
name|saved
operator|=
name|errno
expr_stmt|;
name|close
argument_list|(
name|fromfd
argument_list|)
expr_stmt|;
name|errno
operator|=
name|saved
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
while|while
condition|(
operator|(
name|nread
operator|=
name|read
argument_list|(
name|fromfd
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|write
argument_list|(
name|tofd
argument_list|,
name|buf
argument_list|,
name|nread
argument_list|)
operator|!=
name|nread
condition|)
block|{
name|saved
operator|=
name|errno
expr_stmt|;
name|close
argument_list|(
name|fromfd
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|tofd
argument_list|)
expr_stmt|;
name|errno
operator|=
name|saved
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
name|saved
operator|=
name|errno
expr_stmt|;
name|close
argument_list|(
name|fromfd
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|tofd
argument_list|)
expr_stmt|;
if|if
condition|(
name|nread
operator|<
literal|0
condition|)
block|{
name|errno
operator|=
name|saved
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|S_ISLNK
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|S_IFLNK
end_ifdef

begin_define
define|#
directive|define
name|S_ISLNK
parameter_list|(
name|m
parameter_list|)
value|(((m)& S_IFMT) == S_IFLNK)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|S_ISLNK
parameter_list|(
name|m
parameter_list|)
value|0
end_define

begin_define
define|#
directive|define
name|lstat
value|stat
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Rename FROM to TO, copying if TO is a link.    Assumes that TO already exists, because FROM is a temp file.    Return 0 if ok, -1 if error.  */
end_comment

begin_function
specifier|static
name|int
name|smart_rename
parameter_list|(
name|from
parameter_list|,
name|to
parameter_list|)
specifier|const
name|char
modifier|*
name|from
decl_stmt|;
specifier|const
name|char
modifier|*
name|to
decl_stmt|;
block|{
name|struct
name|stat
name|s
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|lstat
argument_list|(
name|to
argument_list|,
operator|&
name|s
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
comment|/* Use rename only if TO is not a symbolic link and has      only one hard link.  */
if|if
condition|(
operator|!
name|S_ISLNK
argument_list|(
name|s
operator|.
name|st_mode
argument_list|)
operator|&&
name|s
operator|.
name|st_nlink
operator|==
literal|1
condition|)
block|{
name|ret
operator|=
name|rename
argument_list|(
name|from
argument_list|,
name|to
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
block|{
comment|/* Try to preserve the permission bits and ownership of TO.              First get the mode right except for the setuid bit.  Then              change the ownership.  Then fix the setuid bit.  We do              the chmod before the chown because if the chown succeeds,              and we are a normal user, we won't be able to do the              chmod afterward.  We don't bother to fix the setuid bit              first because that might introduce a fleeting security              problem, and because the chown will clear the setuid bit              anyhow.  We only fix the setuid bit if the chown              succeeds, because we don't want to introduce an              unexpected setuid file owned by the user running objcopy.  */
name|chmod
argument_list|(
name|to
argument_list|,
name|s
operator|.
name|st_mode
operator|&
literal|0777
argument_list|)
expr_stmt|;
if|if
condition|(
name|chown
argument_list|(
name|to
argument_list|,
name|s
operator|.
name|st_uid
argument_list|,
name|s
operator|.
name|st_gid
argument_list|)
operator|>=
literal|0
condition|)
name|chmod
argument_list|(
name|to
argument_list|,
name|s
operator|.
name|st_mode
operator|&
literal|07777
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* We have to clean up here. */
name|int
name|saved
init|=
name|errno
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: %s: "
argument_list|,
name|program_name
argument_list|,
name|to
argument_list|)
expr_stmt|;
name|errno
operator|=
name|saved
expr_stmt|;
name|perror
argument_list|(
literal|"rename"
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|from
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|ret
operator|=
name|simple_copy
argument_list|(
name|from
argument_list|,
name|to
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
name|int
name|saved
init|=
name|errno
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: %s: "
argument_list|,
name|program_name
argument_list|,
name|to
argument_list|)
expr_stmt|;
name|errno
operator|=
name|saved
expr_stmt|;
name|perror
argument_list|(
literal|"simple_copy"
argument_list|)
expr_stmt|;
block|}
name|unlink
argument_list|(
name|from
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Set the date of the file DESTINATION to be the same as the date of    the file SOURCE.  */
end_comment

begin_function
specifier|static
name|void
name|make_same_dates
parameter_list|(
name|source
parameter_list|,
name|destination
parameter_list|)
specifier|const
name|char
modifier|*
name|source
decl_stmt|;
specifier|const
name|char
modifier|*
name|destination
decl_stmt|;
block|{
name|struct
name|stat
name|statbuf
decl_stmt|;
name|int
name|result
decl_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|source
argument_list|,
operator|&
name|statbuf
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: "
argument_list|,
name|source
argument_list|)
expr_stmt|;
name|perror
argument_list|(
literal|"cannot stat"
argument_list|)
expr_stmt|;
return|return;
block|}
block|{
ifdef|#
directive|ifdef
name|HAVE_GOOD_UTIME_H
name|struct
name|utimbuf
name|tb
decl_stmt|;
name|tb
operator|.
name|actime
operator|=
name|statbuf
operator|.
name|st_atime
expr_stmt|;
name|tb
operator|.
name|modtime
operator|=
name|statbuf
operator|.
name|st_mtime
expr_stmt|;
name|result
operator|=
name|utime
argument_list|(
name|destination
argument_list|,
operator|&
name|tb
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* ! HAVE_GOOD_UTIME_H */
ifndef|#
directive|ifndef
name|HAVE_UTIMES
name|long
name|tb
index|[
literal|2
index|]
decl_stmt|;
name|tb
index|[
literal|0
index|]
operator|=
name|statbuf
operator|.
name|st_atime
expr_stmt|;
name|tb
index|[
literal|1
index|]
operator|=
name|statbuf
operator|.
name|st_mtime
expr_stmt|;
name|result
operator|=
name|utime
argument_list|(
name|destination
argument_list|,
name|tb
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* HAVE_UTIMES */
name|struct
name|timeval
name|tv
index|[
literal|2
index|]
decl_stmt|;
name|tv
index|[
literal|0
index|]
operator|.
name|tv_sec
operator|=
name|statbuf
operator|.
name|st_atime
expr_stmt|;
name|tv
index|[
literal|0
index|]
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
name|tv
index|[
literal|1
index|]
operator|.
name|tv_sec
operator|=
name|statbuf
operator|.
name|st_mtime
expr_stmt|;
name|tv
index|[
literal|1
index|]
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
name|result
operator|=
name|utimes
argument_list|(
name|destination
argument_list|,
name|tv
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_UTIMES */
endif|#
directive|endif
comment|/* ! HAVE_GOOD_UTIME_H */
block|}
if|if
condition|(
name|result
operator|!=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: "
argument_list|,
name|destination
argument_list|)
expr_stmt|;
name|perror
argument_list|(
literal|"can not set time"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|strip_main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
name|char
modifier|*
name|input_target
init|=
name|NULL
decl_stmt|,
modifier|*
name|output_target
init|=
name|NULL
decl_stmt|;
name|boolean
name|show_version
init|=
name|false
decl_stmt|;
name|boolean
name|preserve_dates
init|=
name|false
decl_stmt|;
name|int
name|c
decl_stmt|,
name|i
decl_stmt|;
name|struct
name|section_list
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|output_file
init|=
name|NULL
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getopt_long
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"I:O:F:K:N:R:o:sSpgxXVv"
argument_list|,
name|strip_options
argument_list|,
operator|(
name|int
operator|*
operator|)
literal|0
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'I'
case|:
name|input_target
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'O'
case|:
name|output_target
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'F'
case|:
name|input_target
operator|=
name|output_target
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'R'
case|:
name|p
operator|=
name|find_section_list
argument_list|(
name|optarg
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|p
operator|->
name|remove
operator|=
name|true
expr_stmt|;
name|sections_removed
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|strip_symbols
operator|=
name|strip_all
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
case|case
literal|'g'
case|:
name|strip_symbols
operator|=
name|strip_debug
expr_stmt|;
break|break;
case|case
name|OPTION_STRIP_UNNEEDED
case|:
name|strip_symbols
operator|=
name|strip_unneeded
expr_stmt|;
break|break;
case|case
literal|'K'
case|:
if|if
condition|(
operator|!
name|keep_symbols
operator|&&
name|strip_specific_list
operator|!=
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: Can not specify both -K and -N\n"
argument_list|,
name|program_name
argument_list|)
expr_stmt|;
name|strip_usage
argument_list|(
name|stderr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|keep_symbols
operator|=
name|true
expr_stmt|;
name|add_strip_symbol
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'N'
case|:
if|if
condition|(
name|keep_symbols
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: Can not specify both -K and -N\n"
argument_list|,
name|program_name
argument_list|)
expr_stmt|;
name|strip_usage
argument_list|(
name|stderr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|add_strip_symbol
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
name|output_file
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|preserve_dates
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
name|discard_locals
operator|=
name|locals_all
expr_stmt|;
break|break;
case|case
literal|'X'
case|:
name|discard_locals
operator|=
name|locals_start_L
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
name|verbose
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'V'
case|:
name|show_version
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|0
case|:
break|break;
comment|/* we've been given a long option */
case|case
literal|'h'
case|:
name|strip_usage
argument_list|(
name|stdout
argument_list|,
literal|0
argument_list|)
expr_stmt|;
default|default:
name|strip_usage
argument_list|(
name|stderr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|show_version
condition|)
name|print_version
argument_list|(
literal|"strip"
argument_list|)
expr_stmt|;
comment|/* Default is to strip all symbols.  */
if|if
condition|(
name|strip_symbols
operator|==
name|strip_undef
operator|&&
name|discard_locals
operator|==
name|locals_undef
operator|&&
name|strip_specific_list
operator|==
name|NULL
condition|)
name|strip_symbols
operator|=
name|strip_all
expr_stmt|;
if|if
condition|(
name|output_target
operator|==
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
name|output_target
operator|=
name|input_target
expr_stmt|;
name|i
operator|=
name|optind
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|argc
operator|||
operator|(
name|output_file
operator|!=
name|NULL
operator|&&
operator|(
name|i
operator|+
literal|1
operator|)
operator|<
name|argc
operator|)
condition|)
name|strip_usage
argument_list|(
name|stderr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
name|int
name|hold_status
init|=
name|status
decl_stmt|;
name|char
modifier|*
name|tmpname
decl_stmt|;
if|if
condition|(
name|output_file
operator|!=
name|NULL
condition|)
name|tmpname
operator|=
name|output_file
expr_stmt|;
else|else
name|tmpname
operator|=
name|make_tempname
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|status
operator|=
literal|0
expr_stmt|;
name|copy_file
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
name|tmpname
argument_list|,
name|input_target
argument_list|,
name|output_target
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|preserve_dates
condition|)
name|make_same_dates
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
name|tmpname
argument_list|)
expr_stmt|;
if|if
condition|(
name|output_file
operator|==
name|NULL
condition|)
name|smart_rename
argument_list|(
name|tmpname
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|status
operator|=
name|hold_status
expr_stmt|;
block|}
else|else
name|unlink
argument_list|(
name|tmpname
argument_list|)
expr_stmt|;
if|if
condition|(
name|output_file
operator|==
name|NULL
condition|)
name|free
argument_list|(
name|tmpname
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|copy_main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
name|char
modifier|*
name|input_filename
init|=
name|NULL
decl_stmt|,
modifier|*
name|output_filename
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|input_target
init|=
name|NULL
decl_stmt|,
modifier|*
name|output_target
init|=
name|NULL
decl_stmt|;
name|boolean
name|show_version
init|=
name|false
decl_stmt|;
name|boolean
name|adjust_warn
init|=
name|true
decl_stmt|;
name|boolean
name|preserve_dates
init|=
name|false
decl_stmt|;
name|int
name|c
decl_stmt|;
name|struct
name|section_list
modifier|*
name|p
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getopt_long
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"b:i:I:K:N:s:O:d:F:R:SpgxXVv"
argument_list|,
name|copy_options
argument_list|,
operator|(
name|int
operator|*
operator|)
literal|0
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'b'
case|:
name|copy_byte
operator|=
name|atoi
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
if|if
condition|(
name|copy_byte
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: byte number must be non-negative\n"
argument_list|,
name|program_name
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'i'
case|:
name|interleave
operator|=
name|atoi
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
if|if
condition|(
name|interleave
operator|<
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: interleave must be positive\n"
argument_list|,
name|program_name
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'I'
case|:
case|case
literal|'s'
case|:
comment|/* "source" - 'I' is preferred */
name|input_target
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'O'
case|:
case|case
literal|'d'
case|:
comment|/* "destination" - 'O' is preferred */
name|output_target
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'F'
case|:
name|input_target
operator|=
name|output_target
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'R'
case|:
name|p
operator|=
name|find_section_list
argument_list|(
name|optarg
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|p
operator|->
name|remove
operator|=
name|true
expr_stmt|;
name|sections_removed
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
name|strip_symbols
operator|=
name|strip_all
expr_stmt|;
break|break;
case|case
literal|'g'
case|:
name|strip_symbols
operator|=
name|strip_debug
expr_stmt|;
break|break;
case|case
name|OPTION_STRIP_UNNEEDED
case|:
name|strip_symbols
operator|=
name|strip_unneeded
expr_stmt|;
break|break;
case|case
literal|'K'
case|:
if|if
condition|(
operator|!
name|keep_symbols
operator|&&
name|strip_specific_list
operator|!=
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: Can not specify both -K and -N\n"
argument_list|,
name|program_name
argument_list|)
expr_stmt|;
name|strip_usage
argument_list|(
name|stderr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|keep_symbols
operator|=
name|true
expr_stmt|;
name|add_strip_symbol
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'N'
case|:
if|if
condition|(
name|keep_symbols
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: Can not specify both -K and -N\n"
argument_list|,
name|program_name
argument_list|)
expr_stmt|;
name|strip_usage
argument_list|(
name|stderr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|add_strip_symbol
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|preserve_dates
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
name|discard_locals
operator|=
name|locals_all
expr_stmt|;
break|break;
case|case
literal|'X'
case|:
name|discard_locals
operator|=
name|locals_start_L
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
name|verbose
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'V'
case|:
name|show_version
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|OPTION_WEAKEN
case|:
name|weaken
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|OPTION_ADD_SECTION
case|:
block|{
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
name|struct
name|stat
name|st
decl_stmt|;
name|struct
name|section_add
modifier|*
name|pa
decl_stmt|;
name|int
name|len
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|FILE
modifier|*
name|f
decl_stmt|;
name|s
operator|=
name|strchr
argument_list|(
name|optarg
argument_list|,
literal|'='
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: bad format for --add-section NAME=FILENAME\n"
argument_list|,
name|program_name
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|stat
argument_list|(
name|s
operator|+
literal|1
argument_list|,
operator|&
name|st
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: "
argument_list|,
name|program_name
argument_list|)
expr_stmt|;
name|perror
argument_list|(
name|s
operator|+
literal|1
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|pa
operator|=
operator|(
expr|struct
name|section_add
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|section_add
argument_list|)
argument_list|)
expr_stmt|;
name|len
operator|=
name|s
operator|-
name|optarg
expr_stmt|;
name|name
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|name
argument_list|,
name|optarg
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|name
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
name|pa
operator|->
name|name
operator|=
name|name
expr_stmt|;
name|pa
operator|->
name|filename
operator|=
name|s
operator|+
literal|1
expr_stmt|;
name|pa
operator|->
name|size
operator|=
name|st
operator|.
name|st_size
expr_stmt|;
name|pa
operator|->
name|contents
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|xmalloc
argument_list|(
name|pa
operator|->
name|size
argument_list|)
expr_stmt|;
name|f
operator|=
name|fopen
argument_list|(
name|pa
operator|->
name|filename
argument_list|,
name|FOPEN_RB
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: "
argument_list|,
name|program_name
argument_list|)
expr_stmt|;
name|perror
argument_list|(
name|pa
operator|->
name|filename
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fread
argument_list|(
name|pa
operator|->
name|contents
argument_list|,
literal|1
argument_list|,
name|pa
operator|->
name|size
argument_list|,
name|f
argument_list|)
operator|==
literal|0
operator|||
name|ferror
argument_list|(
name|f
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: %s: fread failed\n"
argument_list|,
name|program_name
argument_list|,
name|pa
operator|->
name|filename
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|pa
operator|->
name|next
operator|=
name|add_sections
expr_stmt|;
name|add_sections
operator|=
name|pa
expr_stmt|;
block|}
break|break;
case|case
name|OPTION_ADJUST_START
case|:
name|adjust_start
operator|=
name|parse_vma
argument_list|(
name|optarg
argument_list|,
literal|"--adjust-start"
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPTION_ADJUST_SECTION_VMA
case|:
block|{
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|len
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|s
operator|=
name|strchr
argument_list|(
name|optarg
argument_list|,
literal|'='
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
block|{
name|s
operator|=
name|strchr
argument_list|(
name|optarg
argument_list|,
literal|'+'
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
block|{
name|s
operator|=
name|strchr
argument_list|(
name|optarg
argument_list|,
literal|'-'
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: bad format for --adjust-section-vma\n"
argument_list|,
name|program_name
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|len
operator|=
name|s
operator|-
name|optarg
expr_stmt|;
name|name
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|name
argument_list|,
name|optarg
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|name
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
name|p
operator|=
name|find_section_list
argument_list|(
name|name
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|p
operator|->
name|val
operator|=
name|parse_vma
argument_list|(
name|s
operator|+
literal|1
argument_list|,
literal|"--adjust-section-vma"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'='
condition|)
name|p
operator|->
name|adjust
operator|=
name|set_vma
expr_stmt|;
else|else
block|{
name|p
operator|->
name|adjust
operator|=
name|adjust_vma
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'-'
condition|)
name|p
operator|->
name|val
operator|=
operator|-
name|p
operator|->
name|val
expr_stmt|;
block|}
block|}
break|break;
case|case
name|OPTION_ADJUST_VMA
case|:
name|adjust_section_vma
operator|=
name|parse_vma
argument_list|(
name|optarg
argument_list|,
literal|"--adjust-vma"
argument_list|)
expr_stmt|;
name|adjust_start
operator|=
name|adjust_section_vma
expr_stmt|;
break|break;
case|case
name|OPTION_ADJUST_WARNINGS
case|:
name|adjust_warn
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|OPTION_CHANGE_LEADING_CHAR
case|:
name|change_leading_char
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|OPTION_DEBUGGING
case|:
name|convert_debugging
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|OPTION_GAP_FILL
case|:
block|{
name|bfd_vma
name|gap_fill_vma
decl_stmt|;
name|gap_fill_vma
operator|=
name|parse_vma
argument_list|(
name|optarg
argument_list|,
literal|"--gap-fill"
argument_list|)
expr_stmt|;
name|gap_fill
operator|=
operator|(
name|bfd_byte
operator|)
name|gap_fill_vma
expr_stmt|;
if|if
condition|(
operator|(
name|bfd_vma
operator|)
name|gap_fill
operator|!=
name|gap_fill_vma
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: warning: truncating gap-fill from 0x"
argument_list|,
name|program_name
argument_list|)
expr_stmt|;
name|fprintf_vma
argument_list|(
name|stderr
argument_list|,
name|gap_fill_vma
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"to 0x%x\n"
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|gap_fill
argument_list|)
expr_stmt|;
block|}
name|gap_fill_set
operator|=
name|true
expr_stmt|;
block|}
break|break;
case|case
name|OPTION_NO_ADJUST_WARNINGS
case|:
name|adjust_warn
operator|=
name|false
expr_stmt|;
break|break;
case|case
name|OPTION_PAD_TO
case|:
name|pad_to
operator|=
name|parse_vma
argument_list|(
name|optarg
argument_list|,
literal|"--pad-to"
argument_list|)
expr_stmt|;
name|pad_to_set
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|OPTION_REMOVE_LEADING_CHAR
case|:
name|remove_leading_char
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|OPTION_SET_SECTION_FLAGS
case|:
block|{
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|len
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|s
operator|=
name|strchr
argument_list|(
name|optarg
argument_list|,
literal|'='
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: bad format for --set-section-flags\n"
argument_list|,
name|program_name
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|len
operator|=
name|s
operator|-
name|optarg
expr_stmt|;
name|name
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|name
argument_list|,
name|optarg
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|name
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
name|p
operator|=
name|find_section_list
argument_list|(
name|name
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|p
operator|->
name|set_flags
operator|=
name|true
expr_stmt|;
name|p
operator|->
name|flags
operator|=
name|parse_flags
argument_list|(
name|s
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|OPTION_SET_START
case|:
name|set_start
operator|=
name|parse_vma
argument_list|(
name|optarg
argument_list|,
literal|"--set-start"
argument_list|)
expr_stmt|;
name|set_start_set
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|0
case|:
break|break;
comment|/* we've been given a long option */
case|case
literal|'h'
case|:
name|copy_usage
argument_list|(
name|stdout
argument_list|,
literal|0
argument_list|)
expr_stmt|;
default|default:
name|copy_usage
argument_list|(
name|stderr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|show_version
condition|)
name|print_version
argument_list|(
literal|"objcopy"
argument_list|)
expr_stmt|;
if|if
condition|(
name|copy_byte
operator|>=
name|interleave
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: byte number must be less than interleave\n"
argument_list|,
name|program_name
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|optind
operator|==
name|argc
operator|||
name|optind
operator|+
literal|2
operator|<
name|argc
condition|)
name|copy_usage
argument_list|(
name|stderr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|input_filename
operator|=
name|argv
index|[
name|optind
index|]
expr_stmt|;
if|if
condition|(
name|optind
operator|+
literal|1
operator|<
name|argc
condition|)
name|output_filename
operator|=
name|argv
index|[
name|optind
operator|+
literal|1
index|]
expr_stmt|;
comment|/* Default is to strip no symbols.  */
if|if
condition|(
name|strip_symbols
operator|==
name|strip_undef
operator|&&
name|discard_locals
operator|==
name|locals_undef
condition|)
name|strip_symbols
operator|=
name|strip_none
expr_stmt|;
if|if
condition|(
name|output_target
operator|==
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
name|output_target
operator|=
name|input_target
expr_stmt|;
comment|/* If there is no destination file then create a temp and rename      the result into the input.  */
if|if
condition|(
name|output_filename
operator|==
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
block|{
name|char
modifier|*
name|tmpname
init|=
name|make_tempname
argument_list|(
name|input_filename
argument_list|)
decl_stmt|;
name|copy_file
argument_list|(
name|input_filename
argument_list|,
name|tmpname
argument_list|,
name|input_target
argument_list|,
name|output_target
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|preserve_dates
condition|)
name|make_same_dates
argument_list|(
name|input_filename
argument_list|,
name|tmpname
argument_list|)
expr_stmt|;
name|smart_rename
argument_list|(
name|tmpname
argument_list|,
name|input_filename
argument_list|)
expr_stmt|;
block|}
else|else
name|unlink
argument_list|(
name|tmpname
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|copy_file
argument_list|(
name|input_filename
argument_list|,
name|output_filename
argument_list|,
name|input_target
argument_list|,
name|output_target
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
literal|0
operator|&&
name|preserve_dates
condition|)
name|make_same_dates
argument_list|(
name|input_filename
argument_list|,
name|output_filename
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|adjust_warn
condition|)
block|{
for|for
control|(
name|p
operator|=
name|adjust_sections
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|!
name|p
operator|->
name|used
operator|&&
name|p
operator|->
name|adjust
operator|!=
name|ignore_vma
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: warning: --adjust-section-vma %s%c0x"
argument_list|,
name|program_name
argument_list|,
name|p
operator|->
name|name
argument_list|,
name|p
operator|->
name|adjust
operator|==
name|set_vma
condition|?
literal|'='
else|:
literal|'+'
argument_list|)
expr_stmt|;
name|fprintf_vma
argument_list|(
name|stderr
argument_list|,
name|p
operator|->
name|val
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" never used\n"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
name|program_name
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
name|xmalloc_set_program_name
argument_list|(
name|program_name
argument_list|)
expr_stmt|;
name|START_PROGRESS
argument_list|(
name|program_name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|strip_symbols
operator|=
name|strip_undef
expr_stmt|;
name|discard_locals
operator|=
name|locals_undef
expr_stmt|;
name|bfd_init
argument_list|()
expr_stmt|;
name|set_default_bfd_target
argument_list|()
expr_stmt|;
if|if
condition|(
name|is_strip
operator|<
literal|0
condition|)
block|{
name|int
name|i
init|=
name|strlen
argument_list|(
name|program_name
argument_list|)
decl_stmt|;
name|is_strip
operator|=
operator|(
name|i
operator|>=
literal|5
operator|&&
name|strcmp
argument_list|(
name|program_name
operator|+
name|i
operator|-
literal|5
argument_list|,
literal|"strip"
argument_list|)
operator|==
literal|0
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|is_strip
condition|)
name|strip_main
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
else|else
name|copy_main
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
name|END_PROGRESS
argument_list|(
name|program_name
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

end_unit

