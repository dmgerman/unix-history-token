begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* objcopy.c -- copy object file from input to output, optionally massaging it.    Copyright 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000,    2001    Free Software Foundation, Inc.     This file is part of GNU Binutils.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA    02111-1307, USA.  */
end_comment

begin_escape
end_escape

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"progress.h"
end_include

begin_include
include|#
directive|include
file|"bucomm.h"
end_include

begin_include
include|#
directive|include
file|"getopt.h"
end_include

begin_include
include|#
directive|include
file|"libiberty.h"
end_include

begin_include
include|#
directive|include
file|"budbg.h"
end_include

begin_include
include|#
directive|include
file|"filenames.h"
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_comment
comment|/* A list of symbols to explicitly strip out, or to keep.  A linked    list is good enough for a small number from the command line, but    this will slow things down a lot if many symbols are being    deleted. */
end_comment

begin_struct
struct|struct
name|symlist
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|struct
name|symlist
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* A list to support redefine_sym.  */
end_comment

begin_struct
struct|struct
name|redefine_node
block|{
name|char
modifier|*
name|source
decl_stmt|;
name|char
modifier|*
name|target
decl_stmt|;
name|struct
name|redefine_node
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|void
name|copy_usage
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|strip_usage
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|flagword
name|parse_flags
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|section_list
modifier|*
name|find_section_list
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
name|boolean
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|setup_section
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|copy_section
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|get_sections
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|compare_section_lma
name|PARAMS
argument_list|(
operator|(
specifier|const
name|PTR
operator|,
specifier|const
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|add_specific_symbol
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
expr|struct
name|symlist
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|add_specific_symbols
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
expr|struct
name|symlist
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|is_specified_symbol
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
expr|struct
name|symlist
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|is_strip_section
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|filter_symbols
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|bfd
operator|*
operator|,
name|asymbol
operator|*
operator|*
operator|,
name|asymbol
operator|*
operator|*
operator|,
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mark_symbols_used_in_relocations
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|filter_bytes
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|bfd_size_type
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|write_debugging_info
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|PTR
operator|,
name|long
operator|*
operator|,
name|asymbol
operator|*
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|copy_object
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|copy_archive
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|bfd
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|copy_file
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|strip_main
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|copy_main
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|lookup_sym_redefinition
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|redefine_list_append
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|RETURN_NONFATAL
parameter_list|(
name|s
parameter_list|)
value|{bfd_nonfatal (s); status = 1; return;}
end_define

begin_decl_stmt
specifier|static
name|asymbol
modifier|*
modifier|*
name|isympp
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Input symbols */
end_comment

begin_decl_stmt
specifier|static
name|asymbol
modifier|*
modifier|*
name|osympp
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Output symbols that survive stripping */
end_comment

begin_comment
comment|/* If `copy_byte'>= 0, copy only that byte of every `interleave' bytes.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|copy_byte
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|interleave
init|=
literal|4
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|verbose
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Print file and target names. */
end_comment

begin_decl_stmt
specifier|static
name|boolean
name|preserve_dates
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Preserve input file timestamp.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|status
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Exit status.  */
end_comment

begin_enum
enum|enum
name|strip_action
block|{
name|STRIP_UNDEF
block|,
name|STRIP_NONE
block|,
comment|/* don't strip */
name|STRIP_DEBUG
block|,
comment|/* strip all debugger symbols */
name|STRIP_UNNEEDED
block|,
comment|/* strip unnecessary symbols */
name|STRIP_ALL
comment|/* strip all symbols */
block|}
enum|;
end_enum

begin_comment
comment|/* Which symbols to remove. */
end_comment

begin_decl_stmt
specifier|static
name|enum
name|strip_action
name|strip_symbols
decl_stmt|;
end_decl_stmt

begin_enum
enum|enum
name|locals_action
block|{
name|LOCALS_UNDEF
block|,
name|LOCALS_START_L
block|,
comment|/* discard locals starting with L */
name|LOCALS_ALL
comment|/* discard all locals */
block|}
enum|;
end_enum

begin_comment
comment|/* Which local symbols to remove.  Overrides STRIP_ALL.  */
end_comment

begin_decl_stmt
specifier|static
name|enum
name|locals_action
name|discard_locals
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* What kind of change to perform.  */
end_comment

begin_enum
enum|enum
name|change_action
block|{
name|CHANGE_IGNORE
block|,
name|CHANGE_MODIFY
block|,
name|CHANGE_SET
block|}
enum|;
end_enum

begin_comment
comment|/* Structure used to hold lists of sections and actions to take.  */
end_comment

begin_struct
struct|struct
name|section_list
block|{
name|struct
name|section_list
modifier|*
name|next
decl_stmt|;
comment|/* Next section to change.  */
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
comment|/* Section name.  */
name|boolean
name|used
decl_stmt|;
comment|/* Whether this entry was used.  */
name|boolean
name|remove
decl_stmt|;
comment|/* Whether to remove this section.  */
name|boolean
name|copy
decl_stmt|;
comment|/* Whether to copy this section.  */
name|enum
name|change_action
name|change_vma
decl_stmt|;
comment|/* Whether to change or set VMA.  */
name|bfd_vma
name|vma_val
decl_stmt|;
comment|/* Amount to change by or set to.  */
name|enum
name|change_action
name|change_lma
decl_stmt|;
comment|/* Whether to change or set LMA.  */
name|bfd_vma
name|lma_val
decl_stmt|;
comment|/* Amount to change by or set to.  */
name|boolean
name|set_flags
decl_stmt|;
comment|/* Whether to set the section flags.  */
name|flagword
name|flags
decl_stmt|;
comment|/* What to set the section flags to.  */
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|section_list
modifier|*
name|change_sections
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|sections_removed
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|sections_copied
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Changes to the start address.  */
end_comment

begin_decl_stmt
specifier|static
name|bfd_vma
name|change_start
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|set_start_set
init|=
name|false
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_vma
name|set_start
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Changes to section addresses.  */
end_comment

begin_decl_stmt
specifier|static
name|bfd_vma
name|change_section_address
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Filling gaps between sections.  */
end_comment

begin_decl_stmt
specifier|static
name|boolean
name|gap_fill_set
init|=
name|false
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_byte
name|gap_fill
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pad to a given address.  */
end_comment

begin_decl_stmt
specifier|static
name|boolean
name|pad_to_set
init|=
name|false
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_vma
name|pad_to
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* List of sections to add.  */
end_comment

begin_struct
struct|struct
name|section_add
block|{
comment|/* Next section to add.  */
name|struct
name|section_add
modifier|*
name|next
decl_stmt|;
comment|/* Name of section to add.  */
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
comment|/* Name of file holding section contents.  */
specifier|const
name|char
modifier|*
name|filename
decl_stmt|;
comment|/* Size of file.  */
name|size_t
name|size
decl_stmt|;
comment|/* Contents of file.  */
name|bfd_byte
modifier|*
name|contents
decl_stmt|;
comment|/* BFD section, after it has been added.  */
name|asection
modifier|*
name|section
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|section_add
modifier|*
name|add_sections
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Whether to convert debugging information.  */
end_comment

begin_decl_stmt
specifier|static
name|boolean
name|convert_debugging
init|=
name|false
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Whether to change the leading character in symbol names.  */
end_comment

begin_decl_stmt
specifier|static
name|boolean
name|change_leading_char
init|=
name|false
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Whether to remove the leading character from global symbol names.  */
end_comment

begin_decl_stmt
specifier|static
name|boolean
name|remove_leading_char
init|=
name|false
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* List of symbols to strip, keep, localize, keep-global, weaken,    or redefine.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|symlist
modifier|*
name|strip_specific_list
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|symlist
modifier|*
name|keep_specific_list
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|symlist
modifier|*
name|localize_specific_list
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|symlist
modifier|*
name|keepglobal_specific_list
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|symlist
modifier|*
name|weaken_specific_list
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|redefine_node
modifier|*
name|redefine_sym_list
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If this is true, we weaken global symbols (set BSF_WEAK).  */
end_comment

begin_decl_stmt
specifier|static
name|boolean
name|weaken
init|=
name|false
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 150 isn't special; it's just an arbitrary non-ASCII char value.  */
end_comment

begin_define
define|#
directive|define
name|OPTION_ADD_SECTION
value|150
end_define

begin_define
define|#
directive|define
name|OPTION_CHANGE_ADDRESSES
value|(OPTION_ADD_SECTION + 1)
end_define

begin_define
define|#
directive|define
name|OPTION_CHANGE_LEADING_CHAR
value|(OPTION_CHANGE_ADDRESSES + 1)
end_define

begin_define
define|#
directive|define
name|OPTION_CHANGE_START
value|(OPTION_CHANGE_LEADING_CHAR + 1)
end_define

begin_define
define|#
directive|define
name|OPTION_CHANGE_SECTION_ADDRESS
value|(OPTION_CHANGE_START + 1)
end_define

begin_define
define|#
directive|define
name|OPTION_CHANGE_SECTION_LMA
value|(OPTION_CHANGE_SECTION_ADDRESS + 1)
end_define

begin_define
define|#
directive|define
name|OPTION_CHANGE_SECTION_VMA
value|(OPTION_CHANGE_SECTION_LMA + 1)
end_define

begin_define
define|#
directive|define
name|OPTION_CHANGE_WARNINGS
value|(OPTION_CHANGE_SECTION_VMA + 1)
end_define

begin_define
define|#
directive|define
name|OPTION_DEBUGGING
value|(OPTION_CHANGE_WARNINGS + 1)
end_define

begin_define
define|#
directive|define
name|OPTION_GAP_FILL
value|(OPTION_DEBUGGING + 1)
end_define

begin_define
define|#
directive|define
name|OPTION_NO_CHANGE_WARNINGS
value|(OPTION_GAP_FILL + 1)
end_define

begin_define
define|#
directive|define
name|OPTION_PAD_TO
value|(OPTION_NO_CHANGE_WARNINGS + 1)
end_define

begin_define
define|#
directive|define
name|OPTION_REMOVE_LEADING_CHAR
value|(OPTION_PAD_TO + 1)
end_define

begin_define
define|#
directive|define
name|OPTION_SET_SECTION_FLAGS
value|(OPTION_REMOVE_LEADING_CHAR + 1)
end_define

begin_define
define|#
directive|define
name|OPTION_SET_START
value|(OPTION_SET_SECTION_FLAGS + 1)
end_define

begin_define
define|#
directive|define
name|OPTION_STRIP_UNNEEDED
value|(OPTION_SET_START + 1)
end_define

begin_define
define|#
directive|define
name|OPTION_WEAKEN
value|(OPTION_STRIP_UNNEEDED + 1)
end_define

begin_define
define|#
directive|define
name|OPTION_REDEFINE_SYM
value|(OPTION_WEAKEN + 1)
end_define

begin_define
define|#
directive|define
name|OPTION_SREC_LEN
value|(OPTION_REDEFINE_SYM + 1)
end_define

begin_define
define|#
directive|define
name|OPTION_SREC_FORCES3
value|(OPTION_SREC_LEN + 1)
end_define

begin_define
define|#
directive|define
name|OPTION_STRIP_SYMBOLS
value|(OPTION_SREC_FORCES3 + 1)
end_define

begin_define
define|#
directive|define
name|OPTION_KEEP_SYMBOLS
value|(OPTION_STRIP_SYMBOLS + 1)
end_define

begin_define
define|#
directive|define
name|OPTION_LOCALIZE_SYMBOLS
value|(OPTION_KEEP_SYMBOLS + 1)
end_define

begin_define
define|#
directive|define
name|OPTION_KEEPGLOBAL_SYMBOLS
value|(OPTION_LOCALIZE_SYMBOLS + 1)
end_define

begin_define
define|#
directive|define
name|OPTION_WEAKEN_SYMBOLS
value|(OPTION_KEEPGLOBAL_SYMBOLS + 1)
end_define

begin_comment
comment|/* Options to handle if running as "strip".  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|option
name|strip_options
index|[]
init|=
block|{
block|{
literal|"discard-all"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'x'
block|}
block|,
block|{
literal|"discard-locals"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'X'
block|}
block|,
block|{
literal|"format"
block|,
name|required_argument
block|,
literal|0
block|,
literal|'F'
block|}
block|,
comment|/* Obsolete */
block|{
literal|"help"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'h'
block|}
block|,
block|{
literal|"input-format"
block|,
name|required_argument
block|,
literal|0
block|,
literal|'I'
block|}
block|,
comment|/* Obsolete */
block|{
literal|"input-target"
block|,
name|required_argument
block|,
literal|0
block|,
literal|'I'
block|}
block|,
block|{
literal|"keep-symbol"
block|,
name|required_argument
block|,
literal|0
block|,
literal|'K'
block|}
block|,
block|{
literal|"output-format"
block|,
name|required_argument
block|,
literal|0
block|,
literal|'O'
block|}
block|,
comment|/* Obsolete */
block|{
literal|"output-target"
block|,
name|required_argument
block|,
literal|0
block|,
literal|'O'
block|}
block|,
block|{
literal|"output-file"
block|,
name|required_argument
block|,
literal|0
block|,
literal|'o'
block|}
block|,
block|{
literal|"preserve-dates"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'p'
block|}
block|,
block|{
literal|"remove-section"
block|,
name|required_argument
block|,
literal|0
block|,
literal|'R'
block|}
block|,
block|{
literal|"strip-all"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'s'
block|}
block|,
block|{
literal|"strip-debug"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'S'
block|}
block|,
block|{
literal|"strip-unneeded"
block|,
name|no_argument
block|,
literal|0
block|,
name|OPTION_STRIP_UNNEEDED
block|}
block|,
block|{
literal|"strip-symbol"
block|,
name|required_argument
block|,
literal|0
block|,
literal|'N'
block|}
block|,
block|{
literal|"target"
block|,
name|required_argument
block|,
literal|0
block|,
literal|'F'
block|}
block|,
block|{
literal|"verbose"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'v'
block|}
block|,
block|{
literal|"version"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'V'
block|}
block|,
block|{
literal|0
block|,
name|no_argument
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Options to handle if running as "objcopy".  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|option
name|copy_options
index|[]
init|=
block|{
block|{
literal|"add-section"
block|,
name|required_argument
block|,
literal|0
block|,
name|OPTION_ADD_SECTION
block|}
block|,
block|{
literal|"adjust-start"
block|,
name|required_argument
block|,
literal|0
block|,
name|OPTION_CHANGE_START
block|}
block|,
block|{
literal|"adjust-vma"
block|,
name|required_argument
block|,
literal|0
block|,
name|OPTION_CHANGE_ADDRESSES
block|}
block|,
block|{
literal|"adjust-section-vma"
block|,
name|required_argument
block|,
literal|0
block|,
name|OPTION_CHANGE_SECTION_ADDRESS
block|}
block|,
block|{
literal|"adjust-warnings"
block|,
name|no_argument
block|,
literal|0
block|,
name|OPTION_CHANGE_WARNINGS
block|}
block|,
block|{
literal|"byte"
block|,
name|required_argument
block|,
literal|0
block|,
literal|'b'
block|}
block|,
block|{
literal|"change-addresses"
block|,
name|required_argument
block|,
literal|0
block|,
name|OPTION_CHANGE_ADDRESSES
block|}
block|,
block|{
literal|"change-leading-char"
block|,
name|no_argument
block|,
literal|0
block|,
name|OPTION_CHANGE_LEADING_CHAR
block|}
block|,
block|{
literal|"change-section-address"
block|,
name|required_argument
block|,
literal|0
block|,
name|OPTION_CHANGE_SECTION_ADDRESS
block|}
block|,
block|{
literal|"change-section-lma"
block|,
name|required_argument
block|,
literal|0
block|,
name|OPTION_CHANGE_SECTION_LMA
block|}
block|,
block|{
literal|"change-section-vma"
block|,
name|required_argument
block|,
literal|0
block|,
name|OPTION_CHANGE_SECTION_VMA
block|}
block|,
block|{
literal|"change-start"
block|,
name|required_argument
block|,
literal|0
block|,
name|OPTION_CHANGE_START
block|}
block|,
block|{
literal|"change-warnings"
block|,
name|no_argument
block|,
literal|0
block|,
name|OPTION_CHANGE_WARNINGS
block|}
block|,
block|{
literal|"debugging"
block|,
name|no_argument
block|,
literal|0
block|,
name|OPTION_DEBUGGING
block|}
block|,
block|{
literal|"discard-all"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'x'
block|}
block|,
block|{
literal|"discard-locals"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'X'
block|}
block|,
block|{
literal|"only-section"
block|,
name|required_argument
block|,
literal|0
block|,
literal|'j'
block|}
block|,
block|{
literal|"format"
block|,
name|required_argument
block|,
literal|0
block|,
literal|'F'
block|}
block|,
comment|/* Obsolete */
block|{
literal|"gap-fill"
block|,
name|required_argument
block|,
literal|0
block|,
name|OPTION_GAP_FILL
block|}
block|,
block|{
literal|"help"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'h'
block|}
block|,
block|{
literal|"input-format"
block|,
name|required_argument
block|,
literal|0
block|,
literal|'I'
block|}
block|,
comment|/* Obsolete */
block|{
literal|"input-target"
block|,
name|required_argument
block|,
literal|0
block|,
literal|'I'
block|}
block|,
block|{
literal|"interleave"
block|,
name|required_argument
block|,
literal|0
block|,
literal|'i'
block|}
block|,
block|{
literal|"keep-symbol"
block|,
name|required_argument
block|,
literal|0
block|,
literal|'K'
block|}
block|,
block|{
literal|"no-adjust-warnings"
block|,
name|no_argument
block|,
literal|0
block|,
name|OPTION_NO_CHANGE_WARNINGS
block|}
block|,
block|{
literal|"no-change-warnings"
block|,
name|no_argument
block|,
literal|0
block|,
name|OPTION_NO_CHANGE_WARNINGS
block|}
block|,
block|{
literal|"output-format"
block|,
name|required_argument
block|,
literal|0
block|,
literal|'O'
block|}
block|,
comment|/* Obsolete */
block|{
literal|"output-target"
block|,
name|required_argument
block|,
literal|0
block|,
literal|'O'
block|}
block|,
block|{
literal|"pad-to"
block|,
name|required_argument
block|,
literal|0
block|,
name|OPTION_PAD_TO
block|}
block|,
block|{
literal|"preserve-dates"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'p'
block|}
block|,
block|{
literal|"localize-symbol"
block|,
name|required_argument
block|,
literal|0
block|,
literal|'L'
block|}
block|,
block|{
literal|"keep-global-symbol"
block|,
name|required_argument
block|,
literal|0
block|,
literal|'G'
block|}
block|,
block|{
literal|"remove-leading-char"
block|,
name|no_argument
block|,
literal|0
block|,
name|OPTION_REMOVE_LEADING_CHAR
block|}
block|,
block|{
literal|"remove-section"
block|,
name|required_argument
block|,
literal|0
block|,
literal|'R'
block|}
block|,
block|{
literal|"set-section-flags"
block|,
name|required_argument
block|,
literal|0
block|,
name|OPTION_SET_SECTION_FLAGS
block|}
block|,
block|{
literal|"set-start"
block|,
name|required_argument
block|,
literal|0
block|,
name|OPTION_SET_START
block|}
block|,
block|{
literal|"strip-all"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'S'
block|}
block|,
block|{
literal|"strip-debug"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'g'
block|}
block|,
block|{
literal|"strip-unneeded"
block|,
name|no_argument
block|,
literal|0
block|,
name|OPTION_STRIP_UNNEEDED
block|}
block|,
block|{
literal|"strip-symbol"
block|,
name|required_argument
block|,
literal|0
block|,
literal|'N'
block|}
block|,
block|{
literal|"target"
block|,
name|required_argument
block|,
literal|0
block|,
literal|'F'
block|}
block|,
block|{
literal|"verbose"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'v'
block|}
block|,
block|{
literal|"version"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'V'
block|}
block|,
block|{
literal|"weaken"
block|,
name|no_argument
block|,
literal|0
block|,
name|OPTION_WEAKEN
block|}
block|,
block|{
literal|"weaken-symbol"
block|,
name|required_argument
block|,
literal|0
block|,
literal|'W'
block|}
block|,
block|{
literal|"redefine-sym"
block|,
name|required_argument
block|,
literal|0
block|,
name|OPTION_REDEFINE_SYM
block|}
block|,
block|{
literal|"srec-len"
block|,
name|required_argument
block|,
literal|0
block|,
name|OPTION_SREC_LEN
block|}
block|,
block|{
literal|"srec-forceS3"
block|,
name|no_argument
block|,
literal|0
block|,
name|OPTION_SREC_FORCES3
block|}
block|,
block|{
literal|"keep-symbols"
block|,
name|required_argument
block|,
literal|0
block|,
name|OPTION_KEEP_SYMBOLS
block|}
block|,
block|{
literal|"strip-symbols"
block|,
name|required_argument
block|,
literal|0
block|,
name|OPTION_STRIP_SYMBOLS
block|}
block|,
block|{
literal|"keep-global-symbols"
block|,
name|required_argument
block|,
literal|0
block|,
name|OPTION_KEEPGLOBAL_SYMBOLS
block|}
block|,
block|{
literal|"localize-symbols"
block|,
name|required_argument
block|,
literal|0
block|,
name|OPTION_LOCALIZE_SYMBOLS
block|}
block|,
block|{
literal|"weaken-symbols"
block|,
name|required_argument
block|,
literal|0
block|,
name|OPTION_WEAKEN_SYMBOLS
block|}
block|,
block|{
literal|0
block|,
name|no_argument
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* IMPORTS */
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|program_name
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This flag distinguishes between strip and objcopy:    1 means this is 'strip'; 0 means this is 'objcopy'.    -1 means if we should use argv[0] to decide. */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|is_strip
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The maximum length of an S record.  This variable is declared in srec.c    and can be modified by the --srec-len parameter.  */
end_comment

begin_decl_stmt
specifier|extern
name|unsigned
name|int
name|Chunk
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Restrict the generation of Srecords to type S3 only.    This variable is declare in bfd/srec.c and can be toggled    on by the --srec-forceS3 command line switch.  */
end_comment

begin_decl_stmt
specifier|extern
name|boolean
name|S3Forced
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|copy_usage
parameter_list|(
name|stream
parameter_list|,
name|exit_status
parameter_list|)
name|FILE
modifier|*
name|stream
decl_stmt|;
name|int
name|exit_status
decl_stmt|;
block|{
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"Usage: %s<switches> in-file [out-file]\n"
argument_list|)
argument_list|,
name|program_name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|" The switches are:\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"\   -I --input-target<bfdname>      Assume input file is in format<bfdname>\n\   -O --output-target<bfdname>     Create an output file in format<bfdname>\n\   -F --target<bfdname>            Set both input and output format to<bfdname>\n\      --debugging                   Convert debugging information, if possible\n\   -p --preserve-dates              Copy modified/access timestamps to the output\n\   -j --only-section<name>         Only copy section<name> into the output\n\   -R --remove-section<name>       Remove section<name> from the output\n\   -S --strip-all                   Remove all symbol and relocation information\n\   -g --strip-debug                 Remove all debugging symbols\n\      --strip-unneeded              Remove all symbols not needed by relocations\n\   -N --strip-symbol<name>         Do not copy symbol<name>\n\   -K --keep-symbol<name>          Only copy symbol<name>\n\   -L --localize-symbol<name>      Force symbol<name> to be marked as a local\n\   -G --keep-global-symbol<name>   Localize all symbols except<name>\n\   -W --weaken-symbol<name>        Force symbol<name> to be marked as a weak\n\      --weaken                      Force all global symbols to be marked as weak\n\   -x --discard-all                 Remove all non-global symbols\n\   -X --discard-locals              Remove any compiler-generated symbols\n\   -i --interleave<number>         Only copy one out of every<number> bytes\n\   -b --byte<num>                  Select byte<num> in every interleaved block\n\      --gap-fill<val>              Fill gaps between sections with<val>\n\      --pad-to<addr>               Pad the last section up to address<addr>\n\      --set-start<addr>            Set the start address to<addr>\n\     {--change-start|--adjust-start}<incr>\n\                                    Add<incr> to the start address\n\     {--change-addresses|--adjust-vma}<incr>\n\                                    Add<incr> to LMA, VMA and start addresses\n\     {--change-section-address|--adjust-section-vma}<name>{=|+|-}<val>\n\                                    Change LMA and VMA of section<name> by<val>\n\      --change-section-lma<name>{=|+|-}<val>\n\                                    Change the LMA of section<name> by<val>\n\      --change-section-vma<name>{=|+|-}<val>\n\                                    Change the VMA of section<name> by<val>\n\     {--[no-]change-warnings|--[no-]adjust-warnings}\n\                                    Warn if a named section does not exist\n\      --set-section-flags<name>=<flags>\n\                                    Set section<name>'s properties to<flags>\n\      --add-section<name>=<file>   Add section<name> found in<file> to output\n\      --change-leading-char         Force output format's leading character style\n\      --remove-leading-char         Remove leading character from global symbols\n\      --redefine-sym<old>=<new>    Redefine symbol name<old> to<new>\n\      --srec-len<number>           Restrict the length of generated Srecords\n\      --srec-forceS3                Restrict the type of generated Srecords to S3\n\      --strip-symbols<file>        -N for all symbols listed in<file>\n\      --keep-symbols<file>         -K for all symbols listed in<file>\n\      --localize-symbols<file>     -L for all symbols listed in<file>\n\      --keep-global-symbols<file>  -G for all symbols listed in<file>\n\      --weaken-symbols<file>       -W for all symbols listed in<file>\n\   -v --verbose                     List all object files modified\n\   -V --version                     Display this program's version number\n\   -h --help                        Display this output\n\ "
argument_list|)
argument_list|)
expr_stmt|;
name|list_supported_targets
argument_list|(
name|program_name
argument_list|,
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|exit_status
operator|==
literal|0
condition|)
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"Report bugs to %s\n"
argument_list|)
argument_list|,
name|REPORT_BUGS_TO
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|exit_status
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|strip_usage
parameter_list|(
name|stream
parameter_list|,
name|exit_status
parameter_list|)
name|FILE
modifier|*
name|stream
decl_stmt|;
name|int
name|exit_status
decl_stmt|;
block|{
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"Usage: %s<switches> in-file(s)\n"
argument_list|)
argument_list|,
name|program_name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|" The switches are:\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"\   -I --input-target<bfdname>      Assume input file is in format<bfdname>\n\   -O --output-target<bfdname>     Create an output file in format<bfdname>\n\   -F --target<bfdname>            Set both input and output format to<bfdname>\n\   -p --preserve-dates              Copy modified/access timestamps to the output\n\   -R --remove-section<name>       Remove section<name> from the output\n\   -s --strip-all                   Remove all symbol and relocation information\n\   -g -S --strip-debug              Remove all debugging symbols\n\      --strip-unneeded              Remove all symbols not needed by relocations\n\   -N --strip-symbol<name>         Do not copy symbol<name>\n\   -K --keep-symbol<name>          Only copy symbol<name>\n\   -x --discard-all                 Remove all non-global symbols\n\   -X --discard-locals              Remove any compiler-generated symbols\n\   -v --verbose                     List all object files modified\n\   -V --version                     Display this program's version number\n\   -h --help                        Display this output\n\   -o<file>                        Place stripped output into<file>\n\ "
argument_list|)
argument_list|)
expr_stmt|;
name|list_supported_targets
argument_list|(
name|program_name
argument_list|,
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|exit_status
operator|==
literal|0
condition|)
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"Report bugs to %s\n"
argument_list|)
argument_list|,
name|REPORT_BUGS_TO
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|exit_status
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Parse section flags into a flagword, with a fatal error if the    string can't be parsed.  */
end_comment

begin_function
specifier|static
name|flagword
name|parse_flags
parameter_list|(
name|s
parameter_list|)
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|flagword
name|ret
decl_stmt|;
specifier|const
name|char
modifier|*
name|snext
decl_stmt|;
name|int
name|len
decl_stmt|;
name|ret
operator|=
name|SEC_NO_FLAGS
expr_stmt|;
do|do
block|{
name|snext
operator|=
name|strchr
argument_list|(
name|s
argument_list|,
literal|','
argument_list|)
expr_stmt|;
if|if
condition|(
name|snext
operator|==
name|NULL
condition|)
name|len
operator|=
name|strlen
argument_list|(
name|s
argument_list|)
expr_stmt|;
else|else
block|{
name|len
operator|=
name|snext
operator|-
name|s
expr_stmt|;
operator|++
name|snext
expr_stmt|;
block|}
if|if
condition|(
literal|0
condition|)
empty_stmt|;
define|#
directive|define
name|PARSE_FLAG
parameter_list|(
name|fname
parameter_list|,
name|fval
parameter_list|)
define|\
value|else if (strncasecmp (fname, s, len) == 0) ret |= fval
name|PARSE_FLAG
argument_list|(
literal|"alloc"
argument_list|,
name|SEC_ALLOC
argument_list|)
expr_stmt|;
name|PARSE_FLAG
argument_list|(
literal|"load"
argument_list|,
name|SEC_LOAD
argument_list|)
expr_stmt|;
name|PARSE_FLAG
argument_list|(
literal|"noload"
argument_list|,
name|SEC_NEVER_LOAD
argument_list|)
expr_stmt|;
name|PARSE_FLAG
argument_list|(
literal|"readonly"
argument_list|,
name|SEC_READONLY
argument_list|)
expr_stmt|;
name|PARSE_FLAG
argument_list|(
literal|"debug"
argument_list|,
name|SEC_DEBUGGING
argument_list|)
expr_stmt|;
name|PARSE_FLAG
argument_list|(
literal|"code"
argument_list|,
name|SEC_CODE
argument_list|)
expr_stmt|;
name|PARSE_FLAG
argument_list|(
literal|"data"
argument_list|,
name|SEC_DATA
argument_list|)
expr_stmt|;
name|PARSE_FLAG
argument_list|(
literal|"rom"
argument_list|,
name|SEC_ROM
argument_list|)
expr_stmt|;
name|PARSE_FLAG
argument_list|(
literal|"share"
argument_list|,
name|SEC_SHARED
argument_list|)
expr_stmt|;
name|PARSE_FLAG
argument_list|(
literal|"contents"
argument_list|,
name|SEC_HAS_CONTENTS
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|PARSE_FLAG
else|else
block|{
name|char
modifier|*
name|copy
decl_stmt|;
name|copy
operator|=
name|xmalloc
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|copy
argument_list|,
name|s
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|copy
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
name|non_fatal
argument_list|(
name|_
argument_list|(
literal|"unrecognized section flag `%s'"
argument_list|)
argument_list|,
name|copy
argument_list|)
expr_stmt|;
name|fatal
argument_list|(
name|_
argument_list|(
literal|"supported flags: %s"
argument_list|)
argument_list|,
literal|"alloc, load, noload, readonly, debug, code, data, rom, share, contents"
argument_list|)
expr_stmt|;
block|}
name|s
operator|=
name|snext
expr_stmt|;
block|}
do|while
condition|(
name|s
operator|!=
name|NULL
condition|)
do|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Find and optionally add an entry in the change_sections list.  */
end_comment

begin_function
specifier|static
name|struct
name|section_list
modifier|*
name|find_section_list
parameter_list|(
name|name
parameter_list|,
name|add
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|boolean
name|add
decl_stmt|;
block|{
specifier|register
name|struct
name|section_list
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|change_sections
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|p
operator|->
name|name
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
return|return
name|p
return|;
if|if
condition|(
operator|!
name|add
condition|)
return|return
name|NULL
return|;
name|p
operator|=
operator|(
expr|struct
name|section_list
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|section_list
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|->
name|name
operator|=
name|name
expr_stmt|;
name|p
operator|->
name|used
operator|=
name|false
expr_stmt|;
name|p
operator|->
name|remove
operator|=
name|false
expr_stmt|;
name|p
operator|->
name|copy
operator|=
name|false
expr_stmt|;
name|p
operator|->
name|change_vma
operator|=
name|CHANGE_IGNORE
expr_stmt|;
name|p
operator|->
name|change_lma
operator|=
name|CHANGE_IGNORE
expr_stmt|;
name|p
operator|->
name|vma_val
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|lma_val
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|set_flags
operator|=
name|false
expr_stmt|;
name|p
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|next
operator|=
name|change_sections
expr_stmt|;
name|change_sections
operator|=
name|p
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_comment
comment|/* Add a symbol to strip_specific_list.  */
end_comment

begin_function
specifier|static
name|void
name|add_specific_symbol
parameter_list|(
name|name
parameter_list|,
name|list
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|struct
name|symlist
modifier|*
modifier|*
name|list
decl_stmt|;
block|{
name|struct
name|symlist
modifier|*
name|tmp_list
decl_stmt|;
name|tmp_list
operator|=
operator|(
expr|struct
name|symlist
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|symlist
argument_list|)
argument_list|)
expr_stmt|;
name|tmp_list
operator|->
name|name
operator|=
name|name
expr_stmt|;
name|tmp_list
operator|->
name|next
operator|=
operator|*
name|list
expr_stmt|;
operator|*
name|list
operator|=
name|tmp_list
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add symbols listed in `filename' to strip_specific_list. */
end_comment

begin_define
define|#
directive|define
name|IS_WHITESPACE
parameter_list|(
name|c
parameter_list|)
value|((c) == ' ' || (c) == '\t')
end_define

begin_define
define|#
directive|define
name|IS_LINE_TERMINATOR
parameter_list|(
name|c
parameter_list|)
value|((c) == '\n' || (c) == '\r' || (c) == '\0')
end_define

begin_function
specifier|static
name|void
name|add_specific_symbols
parameter_list|(
name|filename
parameter_list|,
name|list
parameter_list|)
specifier|const
name|char
modifier|*
name|filename
decl_stmt|;
name|struct
name|symlist
modifier|*
modifier|*
name|list
decl_stmt|;
block|{
name|struct
name|stat
name|st
decl_stmt|;
name|FILE
modifier|*
name|f
decl_stmt|;
name|char
modifier|*
name|line
decl_stmt|;
name|char
modifier|*
name|buffer
decl_stmt|;
name|unsigned
name|int
name|line_count
decl_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|filename
argument_list|,
operator|&
name|st
argument_list|)
operator|<
literal|0
condition|)
name|fatal
argument_list|(
name|_
argument_list|(
literal|"cannot stat: %s: %s"
argument_list|)
argument_list|,
name|filename
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|st
operator|.
name|st_size
operator|==
literal|0
condition|)
return|return;
name|buffer
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|st
operator|.
name|st_size
operator|+
literal|2
argument_list|)
expr_stmt|;
name|f
operator|=
name|fopen
argument_list|(
name|filename
argument_list|,
name|FOPEN_RT
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
name|_
argument_list|(
literal|"cannot open: %s: %s"
argument_list|)
argument_list|,
name|filename
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fread
argument_list|(
name|buffer
argument_list|,
literal|1
argument_list|,
name|st
operator|.
name|st_size
argument_list|,
name|f
argument_list|)
operator|==
literal|0
operator|||
name|ferror
argument_list|(
name|f
argument_list|)
condition|)
name|fatal
argument_list|(
name|_
argument_list|(
literal|"%s: fread failed"
argument_list|)
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|buffer
index|[
name|st
operator|.
name|st_size
index|]
operator|=
literal|'\n'
expr_stmt|;
name|buffer
index|[
name|st
operator|.
name|st_size
operator|+
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|line_count
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|line
operator|=
name|buffer
init|;
operator|*
name|line
operator|!=
literal|'\0'
condition|;
name|line
operator|++
control|)
block|{
name|char
modifier|*
name|eol
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|name_end
decl_stmt|;
name|int
name|finished
init|=
name|false
decl_stmt|;
for|for
control|(
name|eol
operator|=
name|line
init|;
condition|;
name|eol
operator|++
control|)
block|{
switch|switch
condition|(
operator|*
name|eol
condition|)
block|{
case|case
literal|'\n'
case|:
operator|*
name|eol
operator|=
literal|'\0'
expr_stmt|;
comment|/* Cope with \n\r.  */
if|if
condition|(
name|eol
index|[
literal|1
index|]
operator|==
literal|'\r'
condition|)
operator|++
name|eol
expr_stmt|;
name|finished
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'\r'
case|:
operator|*
name|eol
operator|=
literal|'\0'
expr_stmt|;
comment|/* Cope with \r\n.  */
if|if
condition|(
name|eol
index|[
literal|1
index|]
operator|==
literal|'\n'
condition|)
operator|++
name|eol
expr_stmt|;
name|finished
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|0
case|:
name|finished
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'#'
case|:
comment|/* Line comment, Terminate the line here, in case a 		 name is present and then allow the rest of the 		 loop to find the real end of the line.  */
operator|*
name|eol
operator|=
literal|'\0'
expr_stmt|;
break|break;
default|default:
break|break;
block|}
if|if
condition|(
name|finished
condition|)
break|break;
block|}
comment|/* A name may now exist somewhere between 'line' and 'eol'. 	 Strip off leading whitespace and trailing whitespace, 	 then add it to the list.  */
for|for
control|(
name|name
operator|=
name|line
init|;
name|IS_WHITESPACE
argument_list|(
operator|*
name|name
argument_list|)
condition|;
name|name
operator|++
control|)
empty_stmt|;
for|for
control|(
name|name_end
operator|=
name|name
init|;
operator|(
operator|!
name|IS_WHITESPACE
argument_list|(
operator|*
name|name_end
argument_list|)
operator|)
operator|&&
operator|(
operator|!
name|IS_LINE_TERMINATOR
argument_list|(
operator|*
name|name_end
argument_list|)
operator|)
condition|;
name|name_end
operator|++
control|)
empty_stmt|;
if|if
condition|(
operator|!
name|IS_LINE_TERMINATOR
argument_list|(
operator|*
name|name_end
argument_list|)
condition|)
block|{
name|char
modifier|*
name|extra
decl_stmt|;
for|for
control|(
name|extra
operator|=
name|name_end
operator|+
literal|1
init|;
name|IS_WHITESPACE
argument_list|(
operator|*
name|extra
argument_list|)
condition|;
name|extra
operator|++
control|)
empty_stmt|;
if|if
condition|(
operator|!
name|IS_LINE_TERMINATOR
argument_list|(
operator|*
name|extra
argument_list|)
condition|)
name|non_fatal
argument_list|(
name|_
argument_list|(
literal|"Ignoring rubbish found on line %d of %s"
argument_list|)
argument_list|,
name|line_count
argument_list|,
name|filename
argument_list|)
expr_stmt|;
block|}
operator|*
name|name_end
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|name_end
operator|>
name|name
condition|)
name|add_specific_symbol
argument_list|(
name|name
argument_list|,
name|list
argument_list|)
expr_stmt|;
comment|/* Advance line pointer to end of line.  The 'eol ++' in the for 	 loop above will then advance us to the start of the next line.  */
name|line
operator|=
name|eol
expr_stmt|;
name|line_count
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* See whether a symbol should be stripped or kept based on    strip_specific_list and keep_symbols.  */
end_comment

begin_function
specifier|static
name|boolean
name|is_specified_symbol
parameter_list|(
name|name
parameter_list|,
name|list
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|struct
name|symlist
modifier|*
name|list
decl_stmt|;
block|{
name|struct
name|symlist
modifier|*
name|tmp_list
decl_stmt|;
for|for
control|(
name|tmp_list
operator|=
name|list
init|;
name|tmp_list
condition|;
name|tmp_list
operator|=
name|tmp_list
operator|->
name|next
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|tmp_list
operator|->
name|name
argument_list|)
operator|==
literal|0
condition|)
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* See if a section is being removed.  */
end_comment

begin_function
specifier|static
name|boolean
name|is_strip_section
parameter_list|(
name|abfd
parameter_list|,
name|sec
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
block|{
name|struct
name|section_list
modifier|*
name|p
decl_stmt|;
if|if
condition|(
operator|(
name|bfd_get_section_flags
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
operator|&
name|SEC_DEBUGGING
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|strip_symbols
operator|==
name|STRIP_DEBUG
operator|||
name|strip_symbols
operator|==
name|STRIP_UNNEEDED
operator|||
name|strip_symbols
operator|==
name|STRIP_ALL
operator|||
name|discard_locals
operator|==
name|LOCALS_ALL
operator|||
name|convert_debugging
operator|)
condition|)
return|return
name|true
return|;
if|if
condition|(
operator|!
name|sections_removed
operator|&&
operator|!
name|sections_copied
condition|)
return|return
name|false
return|;
name|p
operator|=
name|find_section_list
argument_list|(
name|bfd_get_section_name
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|sections_removed
operator|&&
name|p
operator|!=
name|NULL
operator|&&
name|p
operator|->
name|remove
condition|)
return|return
name|true
return|;
if|if
condition|(
name|sections_copied
operator|&&
operator|(
name|p
operator|==
name|NULL
operator|||
operator|!
name|p
operator|->
name|copy
operator|)
condition|)
return|return
name|true
return|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Choose which symbol entries to copy; put the result in OSYMS.    We don't copy in place, because that confuses the relocs.    Return the number of symbols to print.  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|filter_symbols
parameter_list|(
name|abfd
parameter_list|,
name|obfd
parameter_list|,
name|osyms
parameter_list|,
name|isyms
parameter_list|,
name|symcount
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|bfd
modifier|*
name|obfd
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|osyms
decl_stmt|,
decl|*
modifier|*
name|isyms
decl_stmt|;
end_function

begin_decl_stmt
name|long
name|symcount
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|asymbol
modifier|*
modifier|*
name|from
init|=
name|isyms
decl_stmt|,
modifier|*
modifier|*
name|to
init|=
name|osyms
decl_stmt|;
name|long
name|src_count
init|=
literal|0
decl_stmt|,
name|dst_count
init|=
literal|0
decl_stmt|;
name|int
name|relocatable
init|=
operator|(
name|abfd
operator|->
name|flags
operator|&
operator|(
name|HAS_RELOC
operator||
name|EXEC_P
operator||
name|DYNAMIC
operator|)
operator|)
operator|==
name|HAS_RELOC
decl_stmt|;
for|for
control|(
init|;
name|src_count
operator|<
name|symcount
condition|;
name|src_count
operator|++
control|)
block|{
name|asymbol
modifier|*
name|sym
init|=
name|from
index|[
name|src_count
index|]
decl_stmt|;
name|flagword
name|flags
init|=
name|sym
operator|->
name|flags
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
init|=
name|bfd_asymbol_name
argument_list|(
name|sym
argument_list|)
decl_stmt|;
name|int
name|keep
decl_stmt|;
if|if
condition|(
name|redefine_sym_list
condition|)
block|{
specifier|const
name|char
modifier|*
name|old_name
decl_stmt|,
modifier|*
name|new_name
decl_stmt|;
name|old_name
operator|=
name|bfd_asymbol_name
argument_list|(
name|sym
argument_list|)
expr_stmt|;
name|new_name
operator|=
name|lookup_sym_redefinition
argument_list|(
name|old_name
argument_list|)
expr_stmt|;
name|name
operator|=
name|bfd_asymbol_name
argument_list|(
name|sym
argument_list|)
operator|=
name|new_name
expr_stmt|;
block|}
if|if
condition|(
name|change_leading_char
operator|&&
operator|(
name|bfd_get_symbol_leading_char
argument_list|(
name|abfd
argument_list|)
operator|!=
name|bfd_get_symbol_leading_char
argument_list|(
name|obfd
argument_list|)
operator|)
operator|&&
operator|(
name|bfd_get_symbol_leading_char
argument_list|(
name|abfd
argument_list|)
operator|==
literal|'\0'
operator|||
operator|(
name|name
index|[
literal|0
index|]
operator|==
name|bfd_get_symbol_leading_char
argument_list|(
name|abfd
argument_list|)
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|bfd_get_symbol_leading_char
argument_list|(
name|obfd
argument_list|)
operator|==
literal|'\0'
condition|)
name|name
operator|=
name|bfd_asymbol_name
argument_list|(
name|sym
argument_list|)
operator|=
name|name
operator|+
literal|1
expr_stmt|;
else|else
block|{
name|char
modifier|*
name|n
decl_stmt|;
name|n
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
name|n
index|[
literal|0
index|]
operator|=
name|bfd_get_symbol_leading_char
argument_list|(
name|obfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_get_symbol_leading_char
argument_list|(
name|abfd
argument_list|)
operator|==
literal|'\0'
condition|)
name|strcpy
argument_list|(
name|n
operator|+
literal|1
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|else
name|strcpy
argument_list|(
name|n
operator|+
literal|1
argument_list|,
name|name
operator|+
literal|1
argument_list|)
expr_stmt|;
name|name
operator|=
name|bfd_asymbol_name
argument_list|(
name|sym
argument_list|)
operator|=
name|n
expr_stmt|;
block|}
block|}
if|if
condition|(
name|remove_leading_char
operator|&&
operator|(
operator|(
name|flags
operator|&
name|BSF_GLOBAL
operator|)
operator|!=
literal|0
operator|||
operator|(
name|flags
operator|&
name|BSF_WEAK
operator|)
operator|!=
literal|0
operator|||
name|bfd_is_und_section
argument_list|(
name|bfd_get_section
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|||
name|bfd_is_com_section
argument_list|(
name|bfd_get_section
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|)
operator|&&
name|name
index|[
literal|0
index|]
operator|==
name|bfd_get_symbol_leading_char
argument_list|(
name|abfd
argument_list|)
condition|)
name|name
operator|=
name|bfd_asymbol_name
argument_list|(
name|sym
argument_list|)
operator|=
name|name
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|strip_symbols
operator|==
name|STRIP_ALL
condition|)
name|keep
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|flags
operator|&
name|BSF_KEEP
operator|)
operator|!=
literal|0
comment|/* Used in relocation.  */
operator|||
operator|(
operator|(
name|flags
operator|&
name|BSF_SECTION_SYM
operator|)
operator|!=
literal|0
operator|&&
operator|(
operator|(
operator|*
name|bfd_get_section
argument_list|(
name|sym
argument_list|)
operator|->
name|symbol_ptr_ptr
operator|)
operator|->
name|flags
operator|&
name|BSF_KEEP
operator|)
operator|!=
literal|0
operator|)
condition|)
name|keep
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|relocatable
comment|/* Relocatable file. */
operator|&&
operator|(
name|flags
operator|&
operator|(
name|BSF_GLOBAL
operator||
name|BSF_WEAK
operator|)
operator|)
operator|!=
literal|0
condition|)
name|keep
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|bfd_decode_symclass
argument_list|(
name|sym
argument_list|)
operator|==
literal|'I'
condition|)
comment|/* Global symbols in $idata sections need to be retained 	   even if relocatable is false.  External users of the 	   library containing the $idata section may reference these 	   symbols.  */
name|keep
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|flags
operator|&
name|BSF_GLOBAL
operator|)
operator|!=
literal|0
comment|/* Global symbol.  */
operator|||
operator|(
name|flags
operator|&
name|BSF_WEAK
operator|)
operator|!=
literal|0
operator|||
name|bfd_is_und_section
argument_list|(
name|bfd_get_section
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|||
name|bfd_is_com_section
argument_list|(
name|bfd_get_section
argument_list|(
name|sym
argument_list|)
argument_list|)
condition|)
name|keep
operator|=
name|strip_symbols
operator|!=
name|STRIP_UNNEEDED
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|flags
operator|&
name|BSF_DEBUGGING
operator|)
operator|!=
literal|0
condition|)
comment|/* Debugging symbol.  */
name|keep
operator|=
operator|(
name|strip_symbols
operator|!=
name|STRIP_DEBUG
operator|&&
name|strip_symbols
operator|!=
name|STRIP_UNNEEDED
operator|&&
operator|!
name|convert_debugging
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|bfd_get_section
argument_list|(
name|sym
argument_list|)
operator|->
name|comdat
condition|)
comment|/* COMDAT sections store special information in local 	   symbols, so we cannot risk stripping any of them.  */
name|keep
operator|=
literal|1
expr_stmt|;
else|else
comment|/* Local symbol.  */
name|keep
operator|=
operator|(
name|strip_symbols
operator|!=
name|STRIP_UNNEEDED
operator|&&
operator|(
name|discard_locals
operator|!=
name|LOCALS_ALL
operator|&&
operator|(
name|discard_locals
operator|!=
name|LOCALS_START_L
operator|||
operator|!
name|bfd_is_local_label
argument_list|(
name|abfd
argument_list|,
name|sym
argument_list|)
operator|)
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|keep
operator|&&
name|is_specified_symbol
argument_list|(
name|name
argument_list|,
name|strip_specific_list
argument_list|)
condition|)
name|keep
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|keep
operator|&&
name|is_specified_symbol
argument_list|(
name|name
argument_list|,
name|keep_specific_list
argument_list|)
condition|)
name|keep
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|keep
operator|&&
name|is_strip_section
argument_list|(
name|abfd
argument_list|,
name|bfd_get_section
argument_list|(
name|sym
argument_list|)
argument_list|)
condition|)
name|keep
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|keep
operator|&&
operator|(
name|flags
operator|&
name|BSF_GLOBAL
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|weaken
operator|||
name|is_specified_symbol
argument_list|(
name|name
argument_list|,
name|weaken_specific_list
argument_list|)
operator|)
condition|)
block|{
name|sym
operator|->
name|flags
operator|&=
operator|~
name|BSF_GLOBAL
expr_stmt|;
name|sym
operator|->
name|flags
operator||=
name|BSF_WEAK
expr_stmt|;
block|}
if|if
condition|(
name|keep
operator|&&
operator|(
name|flags
operator|&
operator|(
name|BSF_GLOBAL
operator||
name|BSF_WEAK
operator|)
operator|)
operator|&&
operator|(
name|is_specified_symbol
argument_list|(
name|name
argument_list|,
name|localize_specific_list
argument_list|)
operator|||
operator|(
name|keepglobal_specific_list
operator|!=
name|NULL
operator|&&
operator|!
name|is_specified_symbol
argument_list|(
name|name
argument_list|,
name|keepglobal_specific_list
argument_list|)
operator|)
operator|)
condition|)
block|{
name|sym
operator|->
name|flags
operator|&=
operator|~
operator|(
name|BSF_GLOBAL
operator||
name|BSF_WEAK
operator|)
expr_stmt|;
name|sym
operator|->
name|flags
operator||=
name|BSF_LOCAL
expr_stmt|;
block|}
if|if
condition|(
name|keep
condition|)
name|to
index|[
name|dst_count
operator|++
index|]
operator|=
name|sym
expr_stmt|;
block|}
name|to
index|[
name|dst_count
index|]
operator|=
name|NULL
expr_stmt|;
return|return
name|dst_count
return|;
block|}
end_block

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|lookup_sym_redefinition
parameter_list|(
name|source
parameter_list|)
specifier|const
name|char
modifier|*
name|source
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|result
decl_stmt|;
name|struct
name|redefine_node
modifier|*
name|list
decl_stmt|;
name|result
operator|=
name|source
expr_stmt|;
for|for
control|(
name|list
operator|=
name|redefine_sym_list
init|;
name|list
operator|!=
name|NULL
condition|;
name|list
operator|=
name|list
operator|->
name|next
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|source
argument_list|,
name|list
operator|->
name|source
argument_list|)
operator|==
literal|0
condition|)
block|{
name|result
operator|=
name|list
operator|->
name|target
expr_stmt|;
break|break;
block|}
block|}
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Add a node to a symbol redefine list */
end_comment

begin_function
specifier|static
name|void
name|redefine_list_append
parameter_list|(
name|source
parameter_list|,
name|target
parameter_list|)
specifier|const
name|char
modifier|*
name|source
decl_stmt|;
specifier|const
name|char
modifier|*
name|target
decl_stmt|;
block|{
name|struct
name|redefine_node
modifier|*
modifier|*
name|p
decl_stmt|;
name|struct
name|redefine_node
modifier|*
name|list
decl_stmt|;
name|struct
name|redefine_node
modifier|*
name|new_node
decl_stmt|;
for|for
control|(
name|p
operator|=
operator|&
name|redefine_sym_list
init|;
operator|(
name|list
operator|=
operator|*
name|p
operator|)
operator|!=
name|NULL
condition|;
name|p
operator|=
operator|&
name|list
operator|->
name|next
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|source
argument_list|,
name|list
operator|->
name|source
argument_list|)
operator|==
literal|0
condition|)
block|{
name|fatal
argument_list|(
name|_
argument_list|(
literal|"%s: Multiple redefinition of symbol \"%s\""
argument_list|)
argument_list|,
literal|"--redefine-sym"
argument_list|,
name|source
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|target
argument_list|,
name|list
operator|->
name|target
argument_list|)
operator|==
literal|0
condition|)
block|{
name|fatal
argument_list|(
name|_
argument_list|(
literal|"%s: Symbol \"%s\" is target of more than one redefinition"
argument_list|)
argument_list|,
literal|"--redefine-sym"
argument_list|,
name|target
argument_list|)
expr_stmt|;
block|}
block|}
name|new_node
operator|=
operator|(
expr|struct
name|redefine_node
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|redefine_node
argument_list|)
argument_list|)
expr_stmt|;
name|new_node
operator|->
name|source
operator|=
name|strdup
argument_list|(
name|source
argument_list|)
expr_stmt|;
name|new_node
operator|->
name|target
operator|=
name|strdup
argument_list|(
name|target
argument_list|)
expr_stmt|;
name|new_node
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
operator|*
name|p
operator|=
name|new_node
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Keep only every `copy_byte'th byte in MEMHUNK, which is *SIZE bytes long.    Adjust *SIZE.  */
end_comment

begin_function
specifier|static
name|void
name|filter_bytes
parameter_list|(
name|memhunk
parameter_list|,
name|size
parameter_list|)
name|char
modifier|*
name|memhunk
decl_stmt|;
name|bfd_size_type
modifier|*
name|size
decl_stmt|;
block|{
name|char
modifier|*
name|from
init|=
name|memhunk
operator|+
name|copy_byte
decl_stmt|,
modifier|*
name|to
init|=
name|memhunk
decl_stmt|,
modifier|*
name|end
init|=
name|memhunk
operator|+
operator|*
name|size
decl_stmt|;
for|for
control|(
init|;
name|from
operator|<
name|end
condition|;
name|from
operator|+=
name|interleave
control|)
operator|*
name|to
operator|++
operator|=
operator|*
name|from
expr_stmt|;
if|if
condition|(
operator|*
name|size
operator|%
name|interleave
operator|>
operator|(
name|bfd_size_type
operator|)
name|copy_byte
condition|)
operator|*
name|size
operator|=
operator|(
operator|*
name|size
operator|/
name|interleave
operator|)
operator|+
literal|1
expr_stmt|;
else|else
operator|*
name|size
operator|/=
name|interleave
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Copy object file IBFD onto OBFD.  */
end_comment

begin_function
specifier|static
name|void
name|copy_object
parameter_list|(
name|ibfd
parameter_list|,
name|obfd
parameter_list|)
name|bfd
modifier|*
name|ibfd
decl_stmt|;
name|bfd
modifier|*
name|obfd
decl_stmt|;
block|{
name|bfd_vma
name|start
decl_stmt|;
name|long
name|symcount
decl_stmt|;
name|asection
modifier|*
modifier|*
name|osections
init|=
name|NULL
decl_stmt|;
name|bfd_size_type
modifier|*
name|gaps
init|=
name|NULL
decl_stmt|;
name|bfd_size_type
name|max_gap
init|=
literal|0
decl_stmt|;
name|long
name|symsize
decl_stmt|;
name|PTR
name|dhandle
decl_stmt|;
if|if
condition|(
name|ibfd
operator|->
name|xvec
operator|->
name|byteorder
operator|!=
name|obfd
operator|->
name|xvec
operator|->
name|byteorder
operator|&&
name|ibfd
operator|->
name|xvec
operator|->
name|byteorder
operator|!=
name|BFD_ENDIAN_UNKNOWN
operator|&&
name|obfd
operator|->
name|xvec
operator|->
name|byteorder
operator|!=
name|BFD_ENDIAN_UNKNOWN
condition|)
block|{
name|fatal
argument_list|(
name|_
argument_list|(
literal|"Unable to change endianness of input file(s)"
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|bfd_set_format
argument_list|(
name|obfd
argument_list|,
name|bfd_get_format
argument_list|(
name|ibfd
argument_list|)
argument_list|)
condition|)
name|RETURN_NONFATAL
argument_list|(
name|bfd_get_filename
argument_list|(
name|obfd
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
name|printf
argument_list|(
name|_
argument_list|(
literal|"copy from %s(%s) to %s(%s)\n"
argument_list|)
argument_list|,
name|bfd_get_filename
argument_list|(
name|ibfd
argument_list|)
argument_list|,
name|bfd_get_target
argument_list|(
name|ibfd
argument_list|)
argument_list|,
name|bfd_get_filename
argument_list|(
name|obfd
argument_list|)
argument_list|,
name|bfd_get_target
argument_list|(
name|obfd
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|set_start_set
condition|)
name|start
operator|=
name|set_start
expr_stmt|;
else|else
name|start
operator|=
name|bfd_get_start_address
argument_list|(
name|ibfd
argument_list|)
expr_stmt|;
name|start
operator|+=
name|change_start
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_set_start_address
argument_list|(
name|obfd
argument_list|,
name|start
argument_list|)
operator|||
operator|!
name|bfd_set_file_flags
argument_list|(
name|obfd
argument_list|,
operator|(
name|bfd_get_file_flags
argument_list|(
name|ibfd
argument_list|)
operator|&
name|bfd_applicable_file_flags
argument_list|(
name|obfd
argument_list|)
operator|)
argument_list|)
condition|)
name|RETURN_NONFATAL
argument_list|(
name|bfd_get_filename
argument_list|(
name|ibfd
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Copy architecture of input file to output file */
if|if
condition|(
operator|!
name|bfd_set_arch_mach
argument_list|(
name|obfd
argument_list|,
name|bfd_get_arch
argument_list|(
name|ibfd
argument_list|)
argument_list|,
name|bfd_get_mach
argument_list|(
name|ibfd
argument_list|)
argument_list|)
condition|)
name|non_fatal
argument_list|(
name|_
argument_list|(
literal|"Warning: Output file cannot represent architecture %s"
argument_list|)
argument_list|,
name|bfd_printable_arch_mach
argument_list|(
name|bfd_get_arch
argument_list|(
name|ibfd
argument_list|)
argument_list|,
name|bfd_get_mach
argument_list|(
name|ibfd
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_set_format
argument_list|(
name|obfd
argument_list|,
name|bfd_get_format
argument_list|(
name|ibfd
argument_list|)
argument_list|)
condition|)
name|RETURN_NONFATAL
argument_list|(
name|bfd_get_filename
argument_list|(
name|ibfd
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|isympp
condition|)
name|free
argument_list|(
name|isympp
argument_list|)
expr_stmt|;
if|if
condition|(
name|osympp
operator|!=
name|isympp
condition|)
name|free
argument_list|(
name|osympp
argument_list|)
expr_stmt|;
comment|/* BFD mandates that all output sections be created and sizes set before      any output is done.  Thus, we traverse all sections multiple times.  */
name|bfd_map_over_sections
argument_list|(
name|ibfd
argument_list|,
name|setup_section
argument_list|,
operator|(
name|void
operator|*
operator|)
name|obfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|add_sections
operator|!=
name|NULL
condition|)
block|{
name|struct
name|section_add
modifier|*
name|padd
decl_stmt|;
name|struct
name|section_list
modifier|*
name|pset
decl_stmt|;
for|for
control|(
name|padd
operator|=
name|add_sections
init|;
name|padd
operator|!=
name|NULL
condition|;
name|padd
operator|=
name|padd
operator|->
name|next
control|)
block|{
name|padd
operator|->
name|section
operator|=
name|bfd_make_section
argument_list|(
name|obfd
argument_list|,
name|padd
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|padd
operator|->
name|section
operator|==
name|NULL
condition|)
block|{
name|non_fatal
argument_list|(
name|_
argument_list|(
literal|"can't create section `%s': %s"
argument_list|)
argument_list|,
name|padd
operator|->
name|name
argument_list|,
name|bfd_errmsg
argument_list|(
name|bfd_get_error
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|status
operator|=
literal|1
expr_stmt|;
return|return;
block|}
else|else
block|{
name|flagword
name|flags
decl_stmt|;
if|if
condition|(
operator|!
name|bfd_set_section_size
argument_list|(
name|obfd
argument_list|,
name|padd
operator|->
name|section
argument_list|,
name|padd
operator|->
name|size
argument_list|)
condition|)
name|RETURN_NONFATAL
argument_list|(
name|bfd_get_filename
argument_list|(
name|obfd
argument_list|)
argument_list|)
expr_stmt|;
name|pset
operator|=
name|find_section_list
argument_list|(
name|padd
operator|->
name|name
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|pset
operator|!=
name|NULL
condition|)
name|pset
operator|->
name|used
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|pset
operator|!=
name|NULL
operator|&&
name|pset
operator|->
name|set_flags
condition|)
name|flags
operator|=
name|pset
operator|->
name|flags
operator||
name|SEC_HAS_CONTENTS
expr_stmt|;
else|else
name|flags
operator|=
name|SEC_HAS_CONTENTS
operator||
name|SEC_READONLY
operator||
name|SEC_DATA
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_set_section_flags
argument_list|(
name|obfd
argument_list|,
name|padd
operator|->
name|section
argument_list|,
name|flags
argument_list|)
condition|)
name|RETURN_NONFATAL
argument_list|(
name|bfd_get_filename
argument_list|(
name|obfd
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pset
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|pset
operator|->
name|change_vma
operator|!=
name|CHANGE_IGNORE
condition|)
if|if
condition|(
operator|!
name|bfd_set_section_vma
argument_list|(
name|obfd
argument_list|,
name|padd
operator|->
name|section
argument_list|,
name|pset
operator|->
name|vma_val
argument_list|)
condition|)
name|RETURN_NONFATAL
argument_list|(
name|bfd_get_filename
argument_list|(
name|obfd
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pset
operator|->
name|change_lma
operator|!=
name|CHANGE_IGNORE
condition|)
block|{
name|padd
operator|->
name|section
operator|->
name|lma
operator|=
name|pset
operator|->
name|lma_val
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_set_section_alignment
argument_list|(
name|obfd
argument_list|,
name|padd
operator|->
name|section
argument_list|,
name|bfd_section_alignment
argument_list|(
name|obfd
argument_list|,
name|padd
operator|->
name|section
argument_list|)
argument_list|)
condition|)
name|RETURN_NONFATAL
argument_list|(
name|bfd_get_filename
argument_list|(
name|obfd
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
if|if
condition|(
name|gap_fill_set
operator|||
name|pad_to_set
condition|)
block|{
name|asection
modifier|*
modifier|*
name|set
decl_stmt|;
name|unsigned
name|int
name|c
decl_stmt|,
name|i
decl_stmt|;
comment|/* We must fill in gaps between the sections and/or we must pad 	 the last section to a specified address.  We do this by 	 grabbing a list of the sections, sorting them by VMA, and 	 increasing the section sizes as required to fill the gaps. 	 We write out the gap contents below.  */
name|c
operator|=
name|bfd_count_sections
argument_list|(
name|obfd
argument_list|)
expr_stmt|;
name|osections
operator|=
operator|(
name|asection
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|c
operator|*
sizeof|sizeof
argument_list|(
name|asection
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|set
operator|=
name|osections
expr_stmt|;
name|bfd_map_over_sections
argument_list|(
name|obfd
argument_list|,
name|get_sections
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|set
argument_list|)
expr_stmt|;
name|qsort
argument_list|(
name|osections
argument_list|,
name|c
argument_list|,
sizeof|sizeof
argument_list|(
name|asection
operator|*
argument_list|)
argument_list|,
name|compare_section_lma
argument_list|)
expr_stmt|;
name|gaps
operator|=
operator|(
name|bfd_size_type
operator|*
operator|)
name|xmalloc
argument_list|(
name|c
operator|*
sizeof|sizeof
argument_list|(
name|bfd_size_type
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|gaps
argument_list|,
literal|0
argument_list|,
name|c
operator|*
sizeof|sizeof
argument_list|(
name|bfd_size_type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|gap_fill_set
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|c
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|flagword
name|flags
decl_stmt|;
name|bfd_size_type
name|size
decl_stmt|;
name|bfd_vma
name|gap_start
decl_stmt|,
name|gap_stop
decl_stmt|;
name|flags
operator|=
name|bfd_get_section_flags
argument_list|(
name|obfd
argument_list|,
name|osections
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|SEC_HAS_CONTENTS
operator|)
operator|==
literal|0
operator|||
operator|(
name|flags
operator|&
name|SEC_LOAD
operator|)
operator|==
literal|0
condition|)
continue|continue;
name|size
operator|=
name|bfd_section_size
argument_list|(
name|obfd
argument_list|,
name|osections
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|gap_start
operator|=
name|bfd_section_lma
argument_list|(
name|obfd
argument_list|,
name|osections
index|[
name|i
index|]
argument_list|)
operator|+
name|size
expr_stmt|;
name|gap_stop
operator|=
name|bfd_section_lma
argument_list|(
name|obfd
argument_list|,
name|osections
index|[
name|i
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|gap_start
operator|<
name|gap_stop
condition|)
block|{
if|if
condition|(
operator|!
name|bfd_set_section_size
argument_list|(
name|obfd
argument_list|,
name|osections
index|[
name|i
index|]
argument_list|,
name|size
operator|+
operator|(
name|gap_stop
operator|-
name|gap_start
operator|)
argument_list|)
condition|)
block|{
name|non_fatal
argument_list|(
name|_
argument_list|(
literal|"Can't fill gap after %s: %s"
argument_list|)
argument_list|,
name|bfd_get_section_name
argument_list|(
name|obfd
argument_list|,
name|osections
index|[
name|i
index|]
argument_list|)
argument_list|,
name|bfd_errmsg
argument_list|(
name|bfd_get_error
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|status
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|gaps
index|[
name|i
index|]
operator|=
name|gap_stop
operator|-
name|gap_start
expr_stmt|;
if|if
condition|(
name|max_gap
operator|<
name|gap_stop
operator|-
name|gap_start
condition|)
name|max_gap
operator|=
name|gap_stop
operator|-
name|gap_start
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|pad_to_set
condition|)
block|{
name|bfd_vma
name|lma
decl_stmt|;
name|bfd_size_type
name|size
decl_stmt|;
name|lma
operator|=
name|bfd_section_lma
argument_list|(
name|obfd
argument_list|,
name|osections
index|[
name|c
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
name|size
operator|=
name|bfd_section_size
argument_list|(
name|obfd
argument_list|,
name|osections
index|[
name|c
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|lma
operator|+
name|size
operator|<
name|pad_to
condition|)
block|{
if|if
condition|(
operator|!
name|bfd_set_section_size
argument_list|(
name|obfd
argument_list|,
name|osections
index|[
name|c
operator|-
literal|1
index|]
argument_list|,
name|pad_to
operator|-
name|lma
argument_list|)
condition|)
block|{
name|non_fatal
argument_list|(
name|_
argument_list|(
literal|"Can't add padding to %s: %s"
argument_list|)
argument_list|,
name|bfd_get_section_name
argument_list|(
name|obfd
argument_list|,
name|osections
index|[
name|c
operator|-
literal|1
index|]
argument_list|)
argument_list|,
name|bfd_errmsg
argument_list|(
name|bfd_get_error
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|status
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|gaps
index|[
name|c
operator|-
literal|1
index|]
operator|=
name|pad_to
operator|-
operator|(
name|lma
operator|+
name|size
operator|)
expr_stmt|;
if|if
condition|(
name|max_gap
operator|<
name|pad_to
operator|-
operator|(
name|lma
operator|+
name|size
operator|)
condition|)
name|max_gap
operator|=
name|pad_to
operator|-
operator|(
name|lma
operator|+
name|size
operator|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* Symbol filtering must happen after the output sections have      been created, but before their contents are set.  */
name|dhandle
operator|=
name|NULL
expr_stmt|;
name|symsize
operator|=
name|bfd_get_symtab_upper_bound
argument_list|(
name|ibfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|symsize
operator|<
literal|0
condition|)
name|RETURN_NONFATAL
argument_list|(
name|bfd_get_filename
argument_list|(
name|ibfd
argument_list|)
argument_list|)
expr_stmt|;
name|osympp
operator|=
name|isympp
operator|=
operator|(
name|asymbol
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|symsize
argument_list|)
expr_stmt|;
name|symcount
operator|=
name|bfd_canonicalize_symtab
argument_list|(
name|ibfd
argument_list|,
name|isympp
argument_list|)
expr_stmt|;
if|if
condition|(
name|symcount
operator|<
literal|0
condition|)
name|RETURN_NONFATAL
argument_list|(
name|bfd_get_filename
argument_list|(
name|ibfd
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|convert_debugging
condition|)
name|dhandle
operator|=
name|read_debugging_info
argument_list|(
name|ibfd
argument_list|,
name|isympp
argument_list|,
name|symcount
argument_list|)
expr_stmt|;
if|if
condition|(
name|strip_symbols
operator|==
name|STRIP_DEBUG
operator|||
name|strip_symbols
operator|==
name|STRIP_ALL
operator|||
name|strip_symbols
operator|==
name|STRIP_UNNEEDED
operator|||
name|discard_locals
operator|!=
name|LOCALS_UNDEF
operator|||
name|strip_specific_list
operator|!=
name|NULL
operator|||
name|keep_specific_list
operator|!=
name|NULL
operator|||
name|localize_specific_list
operator|!=
name|NULL
operator|||
name|keepglobal_specific_list
operator|!=
name|NULL
operator|||
name|weaken_specific_list
operator|!=
name|NULL
operator|||
name|sections_removed
operator|||
name|sections_copied
operator|||
name|convert_debugging
operator|||
name|change_leading_char
operator|||
name|remove_leading_char
operator|||
name|redefine_sym_list
operator|||
name|weaken
condition|)
block|{
comment|/* Mark symbols used in output relocations so that they 	 are kept, even if they are local labels or static symbols.  	 Note we iterate over the input sections examining their 	 relocations since the relocations for the output sections 	 haven't been set yet.  mark_symbols_used_in_relocations will 	 ignore input sections which have no corresponding output 	 section.  */
if|if
condition|(
name|strip_symbols
operator|!=
name|STRIP_ALL
condition|)
name|bfd_map_over_sections
argument_list|(
name|ibfd
argument_list|,
name|mark_symbols_used_in_relocations
argument_list|,
operator|(
name|PTR
operator|)
name|isympp
argument_list|)
expr_stmt|;
name|osympp
operator|=
operator|(
name|asymbol
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
operator|(
name|symcount
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|asymbol
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|symcount
operator|=
name|filter_symbols
argument_list|(
name|ibfd
argument_list|,
name|obfd
argument_list|,
name|osympp
argument_list|,
name|isympp
argument_list|,
name|symcount
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|convert_debugging
operator|&&
name|dhandle
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|write_debugging_info
argument_list|(
name|obfd
argument_list|,
name|dhandle
argument_list|,
operator|&
name|symcount
argument_list|,
operator|&
name|osympp
argument_list|)
condition|)
block|{
name|status
operator|=
literal|1
expr_stmt|;
return|return;
block|}
block|}
name|bfd_set_symtab
argument_list|(
name|obfd
argument_list|,
name|osympp
argument_list|,
name|symcount
argument_list|)
expr_stmt|;
comment|/* This has to happen after the symbol table has been set.  */
name|bfd_map_over_sections
argument_list|(
name|ibfd
argument_list|,
name|copy_section
argument_list|,
operator|(
name|void
operator|*
operator|)
name|obfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|add_sections
operator|!=
name|NULL
condition|)
block|{
name|struct
name|section_add
modifier|*
name|padd
decl_stmt|;
for|for
control|(
name|padd
operator|=
name|add_sections
init|;
name|padd
operator|!=
name|NULL
condition|;
name|padd
operator|=
name|padd
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|!
name|bfd_set_section_contents
argument_list|(
name|obfd
argument_list|,
name|padd
operator|->
name|section
argument_list|,
operator|(
name|PTR
operator|)
name|padd
operator|->
name|contents
argument_list|,
operator|(
name|file_ptr
operator|)
literal|0
argument_list|,
operator|(
name|bfd_size_type
operator|)
name|padd
operator|->
name|size
argument_list|)
condition|)
name|RETURN_NONFATAL
argument_list|(
name|bfd_get_filename
argument_list|(
name|obfd
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|gap_fill_set
operator|||
name|pad_to_set
condition|)
block|{
name|bfd_byte
modifier|*
name|buf
decl_stmt|;
name|int
name|c
decl_stmt|,
name|i
decl_stmt|;
comment|/* Fill in the gaps.  */
if|if
condition|(
name|max_gap
operator|>
literal|8192
condition|)
name|max_gap
operator|=
literal|8192
expr_stmt|;
name|buf
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|xmalloc
argument_list|(
name|max_gap
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|buf
argument_list|,
name|gap_fill
argument_list|,
operator|(
name|size_t
operator|)
name|max_gap
argument_list|)
expr_stmt|;
name|c
operator|=
name|bfd_count_sections
argument_list|(
name|obfd
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|c
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|gaps
index|[
name|i
index|]
operator|!=
literal|0
condition|)
block|{
name|bfd_size_type
name|left
decl_stmt|;
name|file_ptr
name|off
decl_stmt|;
name|left
operator|=
name|gaps
index|[
name|i
index|]
expr_stmt|;
name|off
operator|=
name|bfd_section_size
argument_list|(
name|obfd
argument_list|,
name|osections
index|[
name|i
index|]
argument_list|)
operator|-
name|left
expr_stmt|;
while|while
condition|(
name|left
operator|>
literal|0
condition|)
block|{
name|bfd_size_type
name|now
decl_stmt|;
if|if
condition|(
name|left
operator|>
literal|8192
condition|)
name|now
operator|=
literal|8192
expr_stmt|;
else|else
name|now
operator|=
name|left
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_set_section_contents
argument_list|(
name|obfd
argument_list|,
name|osections
index|[
name|i
index|]
argument_list|,
name|buf
argument_list|,
name|off
argument_list|,
name|now
argument_list|)
condition|)
name|RETURN_NONFATAL
argument_list|(
name|bfd_get_filename
argument_list|(
name|obfd
argument_list|)
argument_list|)
expr_stmt|;
name|left
operator|-=
name|now
expr_stmt|;
name|off
operator|+=
name|now
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* Allow the BFD backend to copy any private data it understands      from the input BFD to the output BFD.  This is done last to      permit the routine to look at the filtered symbol table, which is      important for the ECOFF code at least.  */
if|if
condition|(
operator|!
name|bfd_copy_private_bfd_data
argument_list|(
name|ibfd
argument_list|,
name|obfd
argument_list|)
condition|)
block|{
name|non_fatal
argument_list|(
name|_
argument_list|(
literal|"%s: error copying private BFD data: %s"
argument_list|)
argument_list|,
name|bfd_get_filename
argument_list|(
name|obfd
argument_list|)
argument_list|,
name|bfd_errmsg
argument_list|(
name|bfd_get_error
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|status
operator|=
literal|1
expr_stmt|;
return|return;
block|}
block|}
end_function

begin_comment
comment|/* Read each archive element in turn from IBFD, copy the    contents to temp file, and keep the temp file handle.  */
end_comment

begin_function
specifier|static
name|void
name|copy_archive
parameter_list|(
name|ibfd
parameter_list|,
name|obfd
parameter_list|,
name|output_target
parameter_list|)
name|bfd
modifier|*
name|ibfd
decl_stmt|;
name|bfd
modifier|*
name|obfd
decl_stmt|;
specifier|const
name|char
modifier|*
name|output_target
decl_stmt|;
block|{
struct|struct
name|name_list
block|{
name|struct
name|name_list
modifier|*
name|next
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|bfd
modifier|*
name|obfd
decl_stmt|;
block|}
modifier|*
name|list
struct|,
modifier|*
name|l
struct|;
name|bfd
modifier|*
modifier|*
name|ptr
init|=
operator|&
name|obfd
operator|->
name|archive_head
decl_stmt|;
name|bfd
modifier|*
name|this_element
decl_stmt|;
name|char
modifier|*
name|dir
init|=
name|make_tempname
argument_list|(
name|bfd_get_filename
argument_list|(
name|obfd
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Make a temp directory to hold the contents.  */
if|#
directive|if
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__CYGWIN32__
argument_list|)
if|if
condition|(
name|mkdir
argument_list|(
name|dir
argument_list|)
operator|!=
literal|0
condition|)
else|#
directive|else
if|if
condition|(
name|mkdir
argument_list|(
name|dir
argument_list|,
literal|0700
argument_list|)
operator|!=
literal|0
condition|)
endif|#
directive|endif
block|{
name|fatal
argument_list|(
name|_
argument_list|(
literal|"cannot mkdir %s for archive copying (error: %s)"
argument_list|)
argument_list|,
name|dir
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|obfd
operator|->
name|has_armap
operator|=
name|ibfd
operator|->
name|has_armap
expr_stmt|;
name|list
operator|=
name|NULL
expr_stmt|;
name|this_element
operator|=
name|bfd_openr_next_archived_file
argument_list|(
name|ibfd
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|status
operator|&&
name|this_element
operator|!=
operator|(
name|bfd
operator|*
operator|)
name|NULL
condition|)
block|{
comment|/* Create an output file for this member.  */
name|char
modifier|*
name|output_name
init|=
name|concat
argument_list|(
name|dir
argument_list|,
literal|"/"
argument_list|,
name|bfd_get_filename
argument_list|(
name|this_element
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
decl_stmt|;
name|bfd
modifier|*
name|output_bfd
init|=
name|bfd_openw
argument_list|(
name|output_name
argument_list|,
name|output_target
argument_list|)
decl_stmt|;
name|bfd
modifier|*
name|last_element
decl_stmt|;
name|struct
name|stat
name|buf
decl_stmt|;
name|int
name|stat_status
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|preserve_dates
condition|)
block|{
name|stat_status
operator|=
name|bfd_stat_arch_elt
argument_list|(
name|this_element
argument_list|,
operator|&
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat_status
operator|!=
literal|0
condition|)
name|non_fatal
argument_list|(
name|_
argument_list|(
literal|"internal stat error on %s"
argument_list|)
argument_list|,
name|bfd_get_filename
argument_list|(
name|this_element
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|l
operator|=
operator|(
expr|struct
name|name_list
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|name_list
argument_list|)
argument_list|)
expr_stmt|;
name|l
operator|->
name|name
operator|=
name|output_name
expr_stmt|;
name|l
operator|->
name|next
operator|=
name|list
expr_stmt|;
name|list
operator|=
name|l
expr_stmt|;
if|if
condition|(
name|output_bfd
operator|==
operator|(
name|bfd
operator|*
operator|)
name|NULL
condition|)
name|RETURN_NONFATAL
argument_list|(
name|output_name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_set_format
argument_list|(
name|obfd
argument_list|,
name|bfd_get_format
argument_list|(
name|ibfd
argument_list|)
argument_list|)
condition|)
name|RETURN_NONFATAL
argument_list|(
name|bfd_get_filename
argument_list|(
name|obfd
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_check_format
argument_list|(
name|this_element
argument_list|,
name|bfd_object
argument_list|)
operator|==
name|true
condition|)
name|copy_object
argument_list|(
name|this_element
argument_list|,
name|output_bfd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_close
argument_list|(
name|output_bfd
argument_list|)
condition|)
block|{
name|bfd_nonfatal
argument_list|(
name|bfd_get_filename
argument_list|(
name|output_bfd
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Error in new object file. Don't change archive. */
name|status
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|preserve_dates
operator|&&
name|stat_status
operator|==
literal|0
condition|)
name|set_times
argument_list|(
name|output_name
argument_list|,
operator|&
name|buf
argument_list|)
expr_stmt|;
comment|/* Open the newly output file and attach to our list.  */
name|output_bfd
operator|=
name|bfd_openr
argument_list|(
name|output_name
argument_list|,
name|output_target
argument_list|)
expr_stmt|;
name|l
operator|->
name|obfd
operator|=
name|output_bfd
expr_stmt|;
operator|*
name|ptr
operator|=
name|output_bfd
expr_stmt|;
name|ptr
operator|=
operator|&
name|output_bfd
operator|->
name|next
expr_stmt|;
name|last_element
operator|=
name|this_element
expr_stmt|;
name|this_element
operator|=
name|bfd_openr_next_archived_file
argument_list|(
name|ibfd
argument_list|,
name|last_element
argument_list|)
expr_stmt|;
name|bfd_close
argument_list|(
name|last_element
argument_list|)
expr_stmt|;
block|}
operator|*
name|ptr
operator|=
operator|(
name|bfd
operator|*
operator|)
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_close
argument_list|(
name|obfd
argument_list|)
condition|)
name|RETURN_NONFATAL
argument_list|(
name|bfd_get_filename
argument_list|(
name|obfd
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_close
argument_list|(
name|ibfd
argument_list|)
condition|)
name|RETURN_NONFATAL
argument_list|(
name|bfd_get_filename
argument_list|(
name|ibfd
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Delete all the files that we opened.  */
for|for
control|(
name|l
operator|=
name|list
init|;
name|l
operator|!=
name|NULL
condition|;
name|l
operator|=
name|l
operator|->
name|next
control|)
block|{
name|bfd_close
argument_list|(
name|l
operator|->
name|obfd
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|l
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
name|rmdir
argument_list|(
name|dir
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The top-level control.  */
end_comment

begin_function
specifier|static
name|void
name|copy_file
parameter_list|(
name|input_filename
parameter_list|,
name|output_filename
parameter_list|,
name|input_target
parameter_list|,
name|output_target
parameter_list|)
specifier|const
name|char
modifier|*
name|input_filename
decl_stmt|;
specifier|const
name|char
modifier|*
name|output_filename
decl_stmt|;
specifier|const
name|char
modifier|*
name|input_target
decl_stmt|;
specifier|const
name|char
modifier|*
name|output_target
decl_stmt|;
block|{
name|bfd
modifier|*
name|ibfd
decl_stmt|;
name|char
modifier|*
modifier|*
name|matching
decl_stmt|;
comment|/* To allow us to do "strip *" without dying on the first      non-object file, failures are nonfatal.  */
name|ibfd
operator|=
name|bfd_openr
argument_list|(
name|input_filename
argument_list|,
name|input_target
argument_list|)
expr_stmt|;
if|if
condition|(
name|ibfd
operator|==
name|NULL
condition|)
name|RETURN_NONFATAL
argument_list|(
name|input_filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_check_format
argument_list|(
name|ibfd
argument_list|,
name|bfd_archive
argument_list|)
condition|)
block|{
name|bfd
modifier|*
name|obfd
decl_stmt|;
comment|/* bfd_get_target does not return the correct value until          bfd_check_format succeeds.  */
if|if
condition|(
name|output_target
operator|==
name|NULL
condition|)
name|output_target
operator|=
name|bfd_get_target
argument_list|(
name|ibfd
argument_list|)
expr_stmt|;
name|obfd
operator|=
name|bfd_openw
argument_list|(
name|output_filename
argument_list|,
name|output_target
argument_list|)
expr_stmt|;
if|if
condition|(
name|obfd
operator|==
name|NULL
condition|)
name|RETURN_NONFATAL
argument_list|(
name|output_filename
argument_list|)
expr_stmt|;
name|copy_archive
argument_list|(
name|ibfd
argument_list|,
name|obfd
argument_list|,
name|output_target
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bfd_check_format_matches
argument_list|(
name|ibfd
argument_list|,
name|bfd_object
argument_list|,
operator|&
name|matching
argument_list|)
condition|)
block|{
name|bfd
modifier|*
name|obfd
decl_stmt|;
comment|/* bfd_get_target does not return the correct value until          bfd_check_format succeeds.  */
if|if
condition|(
name|output_target
operator|==
name|NULL
condition|)
name|output_target
operator|=
name|bfd_get_target
argument_list|(
name|ibfd
argument_list|)
expr_stmt|;
name|obfd
operator|=
name|bfd_openw
argument_list|(
name|output_filename
argument_list|,
name|output_target
argument_list|)
expr_stmt|;
if|if
condition|(
name|obfd
operator|==
name|NULL
condition|)
name|RETURN_NONFATAL
argument_list|(
name|output_filename
argument_list|)
expr_stmt|;
name|copy_object
argument_list|(
name|ibfd
argument_list|,
name|obfd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_close
argument_list|(
name|obfd
argument_list|)
condition|)
name|RETURN_NONFATAL
argument_list|(
name|output_filename
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_close
argument_list|(
name|ibfd
argument_list|)
condition|)
name|RETURN_NONFATAL
argument_list|(
name|input_filename
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bfd_nonfatal
argument_list|(
name|input_filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_get_error
argument_list|()
operator|==
name|bfd_error_file_ambiguously_recognized
condition|)
block|{
name|list_matching_formats
argument_list|(
name|matching
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|matching
argument_list|)
expr_stmt|;
block|}
name|status
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Create a section in OBFD with the same name and attributes    as ISECTION in IBFD.  */
end_comment

begin_function
specifier|static
name|void
name|setup_section
parameter_list|(
name|ibfd
parameter_list|,
name|isection
parameter_list|,
name|obfdarg
parameter_list|)
name|bfd
modifier|*
name|ibfd
decl_stmt|;
name|sec_ptr
name|isection
decl_stmt|;
name|PTR
name|obfdarg
decl_stmt|;
block|{
name|bfd
modifier|*
name|obfd
init|=
operator|(
name|bfd
operator|*
operator|)
name|obfdarg
decl_stmt|;
name|struct
name|section_list
modifier|*
name|p
decl_stmt|;
name|sec_ptr
name|osection
decl_stmt|;
name|bfd_size_type
name|size
decl_stmt|;
name|bfd_vma
name|vma
decl_stmt|;
name|bfd_vma
name|lma
decl_stmt|;
name|flagword
name|flags
decl_stmt|;
specifier|const
name|char
modifier|*
name|err
decl_stmt|;
if|if
condition|(
operator|(
name|bfd_get_section_flags
argument_list|(
name|ibfd
argument_list|,
name|isection
argument_list|)
operator|&
name|SEC_DEBUGGING
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|strip_symbols
operator|==
name|STRIP_DEBUG
operator|||
name|strip_symbols
operator|==
name|STRIP_UNNEEDED
operator|||
name|strip_symbols
operator|==
name|STRIP_ALL
operator|||
name|discard_locals
operator|==
name|LOCALS_ALL
operator|||
name|convert_debugging
operator|)
condition|)
return|return;
name|p
operator|=
name|find_section_list
argument_list|(
name|bfd_section_name
argument_list|(
name|ibfd
argument_list|,
name|isection
argument_list|)
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
name|p
operator|->
name|used
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|sections_removed
operator|&&
name|p
operator|!=
name|NULL
operator|&&
name|p
operator|->
name|remove
condition|)
return|return;
if|if
condition|(
name|sections_copied
operator|&&
operator|(
name|p
operator|==
name|NULL
operator|||
operator|!
name|p
operator|->
name|copy
operator|)
condition|)
return|return;
name|osection
operator|=
name|bfd_make_section_anyway
argument_list|(
name|obfd
argument_list|,
name|bfd_section_name
argument_list|(
name|ibfd
argument_list|,
name|isection
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|osection
operator|==
name|NULL
condition|)
block|{
name|err
operator|=
name|_
argument_list|(
literal|"making"
argument_list|)
expr_stmt|;
goto|goto
name|loser
goto|;
block|}
name|size
operator|=
name|bfd_section_size
argument_list|(
name|ibfd
argument_list|,
name|isection
argument_list|)
expr_stmt|;
if|if
condition|(
name|copy_byte
operator|>=
literal|0
condition|)
name|size
operator|=
operator|(
name|size
operator|+
name|interleave
operator|-
literal|1
operator|)
operator|/
name|interleave
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_set_section_size
argument_list|(
name|obfd
argument_list|,
name|osection
argument_list|,
name|size
argument_list|)
condition|)
block|{
name|err
operator|=
name|_
argument_list|(
literal|"size"
argument_list|)
expr_stmt|;
goto|goto
name|loser
goto|;
block|}
name|vma
operator|=
name|bfd_section_vma
argument_list|(
name|ibfd
argument_list|,
name|isection
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
operator|&&
name|p
operator|->
name|change_vma
operator|==
name|CHANGE_MODIFY
condition|)
name|vma
operator|+=
name|p
operator|->
name|vma_val
expr_stmt|;
elseif|else
if|if
condition|(
name|p
operator|!=
name|NULL
operator|&&
name|p
operator|->
name|change_vma
operator|==
name|CHANGE_SET
condition|)
name|vma
operator|=
name|p
operator|->
name|vma_val
expr_stmt|;
else|else
name|vma
operator|+=
name|change_section_address
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_set_section_vma
argument_list|(
name|obfd
argument_list|,
name|osection
argument_list|,
name|vma
argument_list|)
condition|)
block|{
name|err
operator|=
name|_
argument_list|(
literal|"vma"
argument_list|)
expr_stmt|;
goto|goto
name|loser
goto|;
block|}
name|lma
operator|=
name|isection
operator|->
name|lma
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|!=
name|NULL
operator|)
operator|&&
name|p
operator|->
name|change_lma
operator|!=
name|CHANGE_IGNORE
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|change_lma
operator|==
name|CHANGE_MODIFY
condition|)
name|lma
operator|+=
name|p
operator|->
name|lma_val
expr_stmt|;
elseif|else
if|if
condition|(
name|p
operator|->
name|change_lma
operator|==
name|CHANGE_SET
condition|)
name|lma
operator|=
name|p
operator|->
name|lma_val
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
else|else
name|lma
operator|+=
name|change_section_address
expr_stmt|;
name|osection
operator|->
name|lma
operator|=
name|lma
expr_stmt|;
comment|/* FIXME: This is probably not enough.  If we change the LMA we      may have to recompute the header for the file as well.  */
if|if
condition|(
name|bfd_set_section_alignment
argument_list|(
name|obfd
argument_list|,
name|osection
argument_list|,
name|bfd_section_alignment
argument_list|(
name|ibfd
argument_list|,
name|isection
argument_list|)
argument_list|)
operator|==
name|false
condition|)
block|{
name|err
operator|=
name|_
argument_list|(
literal|"alignment"
argument_list|)
expr_stmt|;
goto|goto
name|loser
goto|;
block|}
name|flags
operator|=
name|bfd_get_section_flags
argument_list|(
name|ibfd
argument_list|,
name|isection
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
operator|&&
name|p
operator|->
name|set_flags
condition|)
name|flags
operator|=
name|p
operator|->
name|flags
operator||
operator|(
name|flags
operator|&
name|SEC_HAS_CONTENTS
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_set_section_flags
argument_list|(
name|obfd
argument_list|,
name|osection
argument_list|,
name|flags
argument_list|)
condition|)
block|{
name|err
operator|=
name|_
argument_list|(
literal|"flags"
argument_list|)
expr_stmt|;
goto|goto
name|loser
goto|;
block|}
comment|/* This used to be mangle_section; we do here to avoid using      bfd_get_section_by_name since some formats allow multiple      sections with the same name.  */
name|isection
operator|->
name|output_section
operator|=
name|osection
expr_stmt|;
name|isection
operator|->
name|output_offset
operator|=
literal|0
expr_stmt|;
comment|/* Allow the BFD backend to copy any private data it understands      from the input section to the output section.  */
if|if
condition|(
operator|!
name|bfd_copy_private_section_data
argument_list|(
name|ibfd
argument_list|,
name|isection
argument_list|,
name|obfd
argument_list|,
name|osection
argument_list|)
condition|)
block|{
name|err
operator|=
name|_
argument_list|(
literal|"private data"
argument_list|)
expr_stmt|;
goto|goto
name|loser
goto|;
block|}
comment|/* All went well */
return|return;
name|loser
label|:
name|non_fatal
argument_list|(
name|_
argument_list|(
literal|"%s: section `%s': error in %s: %s"
argument_list|)
argument_list|,
name|bfd_get_filename
argument_list|(
name|ibfd
argument_list|)
argument_list|,
name|bfd_section_name
argument_list|(
name|ibfd
argument_list|,
name|isection
argument_list|)
argument_list|,
name|err
argument_list|,
name|bfd_errmsg
argument_list|(
name|bfd_get_error
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|status
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Copy the data of input section ISECTION of IBFD    to an output section with the same name in OBFD.    If stripping then don't copy any relocation info.  */
end_comment

begin_function
specifier|static
name|void
name|copy_section
parameter_list|(
name|ibfd
parameter_list|,
name|isection
parameter_list|,
name|obfdarg
parameter_list|)
name|bfd
modifier|*
name|ibfd
decl_stmt|;
name|sec_ptr
name|isection
decl_stmt|;
name|PTR
name|obfdarg
decl_stmt|;
block|{
name|bfd
modifier|*
name|obfd
init|=
operator|(
name|bfd
operator|*
operator|)
name|obfdarg
decl_stmt|;
name|struct
name|section_list
modifier|*
name|p
decl_stmt|;
name|arelent
modifier|*
modifier|*
name|relpp
decl_stmt|;
name|long
name|relcount
decl_stmt|;
name|sec_ptr
name|osection
decl_stmt|;
name|bfd_size_type
name|size
decl_stmt|;
name|long
name|relsize
decl_stmt|;
comment|/* If we have already failed earlier on, do not keep on generating      complaints now.  */
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
return|return;
if|if
condition|(
operator|(
name|bfd_get_section_flags
argument_list|(
name|ibfd
argument_list|,
name|isection
argument_list|)
operator|&
name|SEC_DEBUGGING
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|strip_symbols
operator|==
name|STRIP_DEBUG
operator|||
name|strip_symbols
operator|==
name|STRIP_UNNEEDED
operator|||
name|strip_symbols
operator|==
name|STRIP_ALL
operator|||
name|discard_locals
operator|==
name|LOCALS_ALL
operator|||
name|convert_debugging
operator|)
condition|)
block|{
return|return;
block|}
name|p
operator|=
name|find_section_list
argument_list|(
name|bfd_section_name
argument_list|(
name|ibfd
argument_list|,
name|isection
argument_list|)
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|sections_removed
operator|&&
name|p
operator|!=
name|NULL
operator|&&
name|p
operator|->
name|remove
condition|)
return|return;
if|if
condition|(
name|sections_copied
operator|&&
operator|(
name|p
operator|==
name|NULL
operator|||
operator|!
name|p
operator|->
name|copy
operator|)
condition|)
return|return;
name|osection
operator|=
name|isection
operator|->
name|output_section
expr_stmt|;
name|size
operator|=
name|bfd_get_section_size_before_reloc
argument_list|(
name|isection
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|==
literal|0
operator|||
name|osection
operator|==
literal|0
condition|)
return|return;
name|relsize
operator|=
name|bfd_get_reloc_upper_bound
argument_list|(
name|ibfd
argument_list|,
name|isection
argument_list|)
expr_stmt|;
if|if
condition|(
name|relsize
operator|<
literal|0
condition|)
name|RETURN_NONFATAL
argument_list|(
name|bfd_get_filename
argument_list|(
name|ibfd
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|relsize
operator|==
literal|0
condition|)
name|bfd_set_reloc
argument_list|(
name|obfd
argument_list|,
name|osection
argument_list|,
operator|(
name|arelent
operator|*
operator|*
operator|)
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
block|{
name|relpp
operator|=
operator|(
name|arelent
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|relsize
argument_list|)
expr_stmt|;
name|relcount
operator|=
name|bfd_canonicalize_reloc
argument_list|(
name|ibfd
argument_list|,
name|isection
argument_list|,
name|relpp
argument_list|,
name|isympp
argument_list|)
expr_stmt|;
if|if
condition|(
name|relcount
operator|<
literal|0
condition|)
name|RETURN_NONFATAL
argument_list|(
name|bfd_get_filename
argument_list|(
name|ibfd
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|strip_symbols
operator|==
name|STRIP_ALL
condition|)
block|{
comment|/* Remove relocations which are not in 	     keep_strip_specific_list. */
name|arelent
modifier|*
modifier|*
name|temp_relpp
decl_stmt|;
name|long
name|temp_relcount
init|=
literal|0
decl_stmt|;
name|long
name|i
decl_stmt|;
name|temp_relpp
operator|=
operator|(
name|arelent
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|relsize
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|relcount
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|is_specified_symbol
argument_list|(
name|bfd_asymbol_name
argument_list|(
operator|*
name|relpp
index|[
name|i
index|]
operator|->
name|sym_ptr_ptr
argument_list|)
argument_list|,
name|keep_specific_list
argument_list|)
condition|)
name|temp_relpp
index|[
name|temp_relcount
operator|++
index|]
operator|=
name|relpp
index|[
name|i
index|]
expr_stmt|;
name|relcount
operator|=
name|temp_relcount
expr_stmt|;
name|free
argument_list|(
name|relpp
argument_list|)
expr_stmt|;
name|relpp
operator|=
name|temp_relpp
expr_stmt|;
block|}
name|bfd_set_reloc
argument_list|(
name|obfd
argument_list|,
name|osection
argument_list|,
operator|(
name|relcount
operator|==
literal|0
condition|?
operator|(
name|arelent
operator|*
operator|*
operator|)
name|NULL
else|:
name|relpp
operator|)
argument_list|,
name|relcount
argument_list|)
expr_stmt|;
block|}
name|isection
operator|->
name|_cooked_size
operator|=
name|isection
operator|->
name|_raw_size
expr_stmt|;
name|isection
operator|->
name|reloc_done
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|bfd_get_section_flags
argument_list|(
name|ibfd
argument_list|,
name|isection
argument_list|)
operator|&
name|SEC_HAS_CONTENTS
condition|)
block|{
name|PTR
name|memhunk
init|=
operator|(
name|PTR
operator|)
name|xmalloc
argument_list|(
operator|(
name|unsigned
operator|)
name|size
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|bfd_get_section_contents
argument_list|(
name|ibfd
argument_list|,
name|isection
argument_list|,
name|memhunk
argument_list|,
operator|(
name|file_ptr
operator|)
literal|0
argument_list|,
name|size
argument_list|)
condition|)
name|RETURN_NONFATAL
argument_list|(
name|bfd_get_filename
argument_list|(
name|ibfd
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|copy_byte
operator|>=
literal|0
condition|)
name|filter_bytes
argument_list|(
name|memhunk
argument_list|,
operator|&
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_set_section_contents
argument_list|(
name|obfd
argument_list|,
name|osection
argument_list|,
name|memhunk
argument_list|,
operator|(
name|file_ptr
operator|)
literal|0
argument_list|,
name|size
argument_list|)
condition|)
name|RETURN_NONFATAL
argument_list|(
name|bfd_get_filename
argument_list|(
name|obfd
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|memhunk
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p
operator|!=
name|NULL
operator|&&
name|p
operator|->
name|set_flags
operator|&&
operator|(
name|p
operator|->
name|flags
operator|&
name|SEC_HAS_CONTENTS
operator|)
operator|!=
literal|0
condition|)
block|{
name|PTR
name|memhunk
init|=
operator|(
name|PTR
operator|)
name|xmalloc
argument_list|(
operator|(
name|unsigned
operator|)
name|size
argument_list|)
decl_stmt|;
comment|/* We don't permit the user to turn off the SEC_HAS_CONTENTS 	 flag--they can just remove the section entirely and add it 	 back again.  However, we do permit them to turn on the 	 SEC_HAS_CONTENTS flag, and take it to mean that the section 	 contents should be zeroed out.  */
name|memset
argument_list|(
name|memhunk
argument_list|,
literal|0
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_set_section_contents
argument_list|(
name|obfd
argument_list|,
name|osection
argument_list|,
name|memhunk
argument_list|,
operator|(
name|file_ptr
operator|)
literal|0
argument_list|,
name|size
argument_list|)
condition|)
name|RETURN_NONFATAL
argument_list|(
name|bfd_get_filename
argument_list|(
name|obfd
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|memhunk
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Get all the sections.  This is used when --gap-fill or --pad-to is    used.  */
end_comment

begin_function
specifier|static
name|void
name|get_sections
parameter_list|(
name|obfd
parameter_list|,
name|osection
parameter_list|,
name|secppparg
parameter_list|)
name|bfd
modifier|*
name|obfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|asection
modifier|*
name|osection
decl_stmt|;
name|PTR
name|secppparg
decl_stmt|;
block|{
name|asection
modifier|*
modifier|*
modifier|*
name|secppp
init|=
operator|(
name|asection
operator|*
operator|*
operator|*
operator|)
name|secppparg
decl_stmt|;
operator|*
operator|*
name|secppp
operator|=
name|osection
expr_stmt|;
operator|++
operator|(
operator|*
name|secppp
operator|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Sort sections by VMA.  This is called via qsort, and is used when    --gap-fill or --pad-to is used.  We force non loadable or empty    sections to the front, where they are easier to ignore.  */
end_comment

begin_function
specifier|static
name|int
name|compare_section_lma
parameter_list|(
name|arg1
parameter_list|,
name|arg2
parameter_list|)
specifier|const
name|PTR
name|arg1
decl_stmt|;
specifier|const
name|PTR
name|arg2
decl_stmt|;
block|{
specifier|const
name|asection
modifier|*
modifier|*
name|sec1
init|=
operator|(
specifier|const
name|asection
operator|*
operator|*
operator|)
name|arg1
decl_stmt|;
specifier|const
name|asection
modifier|*
modifier|*
name|sec2
init|=
operator|(
specifier|const
name|asection
operator|*
operator|*
operator|)
name|arg2
decl_stmt|;
name|flagword
name|flags1
decl_stmt|,
name|flags2
decl_stmt|;
comment|/* Sort non loadable sections to the front.  */
name|flags1
operator|=
operator|(
operator|*
name|sec1
operator|)
operator|->
name|flags
expr_stmt|;
name|flags2
operator|=
operator|(
operator|*
name|sec2
operator|)
operator|->
name|flags
expr_stmt|;
if|if
condition|(
operator|(
name|flags1
operator|&
name|SEC_HAS_CONTENTS
operator|)
operator|==
literal|0
operator|||
operator|(
name|flags1
operator|&
name|SEC_LOAD
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|flags2
operator|&
name|SEC_HAS_CONTENTS
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|flags2
operator|&
name|SEC_LOAD
operator|)
operator|!=
literal|0
condition|)
return|return
operator|-
literal|1
return|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|flags2
operator|&
name|SEC_HAS_CONTENTS
operator|)
operator|==
literal|0
operator|||
operator|(
name|flags2
operator|&
name|SEC_LOAD
operator|)
operator|==
literal|0
condition|)
return|return
literal|1
return|;
block|}
comment|/* Sort sections by LMA.  */
if|if
condition|(
operator|(
operator|*
name|sec1
operator|)
operator|->
name|lma
operator|>
operator|(
operator|*
name|sec2
operator|)
operator|->
name|lma
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
operator|(
operator|*
name|sec1
operator|)
operator|->
name|lma
operator|<
operator|(
operator|*
name|sec2
operator|)
operator|->
name|lma
condition|)
return|return
operator|-
literal|1
return|;
comment|/* Sort sections with the same LMA by size.  */
if|if
condition|(
operator|(
operator|*
name|sec1
operator|)
operator|->
name|_raw_size
operator|>
operator|(
operator|*
name|sec2
operator|)
operator|->
name|_raw_size
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
operator|(
operator|*
name|sec1
operator|)
operator|->
name|_raw_size
operator|<
operator|(
operator|*
name|sec2
operator|)
operator|->
name|_raw_size
condition|)
return|return
operator|-
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Mark all the symbols which will be used in output relocations with    the BSF_KEEP flag so that those symbols will not be stripped.     Ignore relocations which will not appear in the output file.  */
end_comment

begin_function
specifier|static
name|void
name|mark_symbols_used_in_relocations
parameter_list|(
name|ibfd
parameter_list|,
name|isection
parameter_list|,
name|symbolsarg
parameter_list|)
name|bfd
modifier|*
name|ibfd
decl_stmt|;
name|sec_ptr
name|isection
decl_stmt|;
name|PTR
name|symbolsarg
decl_stmt|;
block|{
name|asymbol
modifier|*
modifier|*
name|symbols
init|=
operator|(
name|asymbol
operator|*
operator|*
operator|)
name|symbolsarg
decl_stmt|;
name|long
name|relsize
decl_stmt|;
name|arelent
modifier|*
modifier|*
name|relpp
decl_stmt|;
name|long
name|relcount
decl_stmt|,
name|i
decl_stmt|;
comment|/* Ignore an input section with no corresponding output section.  */
if|if
condition|(
name|isection
operator|->
name|output_section
operator|==
name|NULL
condition|)
return|return;
name|relsize
operator|=
name|bfd_get_reloc_upper_bound
argument_list|(
name|ibfd
argument_list|,
name|isection
argument_list|)
expr_stmt|;
if|if
condition|(
name|relsize
operator|<
literal|0
condition|)
name|bfd_fatal
argument_list|(
name|bfd_get_filename
argument_list|(
name|ibfd
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|relsize
operator|==
literal|0
condition|)
return|return;
name|relpp
operator|=
operator|(
name|arelent
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|relsize
argument_list|)
expr_stmt|;
name|relcount
operator|=
name|bfd_canonicalize_reloc
argument_list|(
name|ibfd
argument_list|,
name|isection
argument_list|,
name|relpp
argument_list|,
name|symbols
argument_list|)
expr_stmt|;
if|if
condition|(
name|relcount
operator|<
literal|0
condition|)
name|bfd_fatal
argument_list|(
name|bfd_get_filename
argument_list|(
name|ibfd
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Examine each symbol used in a relocation.  If it's not one of the      special bfd section symbols, then mark it with BSF_KEEP.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|relcount
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|relpp
index|[
name|i
index|]
operator|->
name|sym_ptr_ptr
operator|!=
name|bfd_com_section_ptr
operator|->
name|symbol
operator|&&
operator|*
name|relpp
index|[
name|i
index|]
operator|->
name|sym_ptr_ptr
operator|!=
name|bfd_abs_section_ptr
operator|->
name|symbol
operator|&&
operator|*
name|relpp
index|[
name|i
index|]
operator|->
name|sym_ptr_ptr
operator|!=
name|bfd_und_section_ptr
operator|->
name|symbol
condition|)
operator|(
operator|*
name|relpp
index|[
name|i
index|]
operator|->
name|sym_ptr_ptr
operator|)
operator|->
name|flags
operator||=
name|BSF_KEEP
expr_stmt|;
block|}
if|if
condition|(
name|relpp
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|relpp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Write out debugging information.  */
end_comment

begin_function
specifier|static
name|boolean
name|write_debugging_info
parameter_list|(
name|obfd
parameter_list|,
name|dhandle
parameter_list|,
name|symcountp
parameter_list|,
name|symppp
parameter_list|)
name|bfd
modifier|*
name|obfd
decl_stmt|;
name|PTR
name|dhandle
decl_stmt|;
name|long
modifier|*
name|symcountp
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|asymbol
modifier|*
modifier|*
modifier|*
name|symppp
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
if|if
condition|(
name|bfd_get_flavour
argument_list|(
name|obfd
argument_list|)
operator|==
name|bfd_target_ieee_flavour
condition|)
return|return
name|write_ieee_debugging_info
argument_list|(
name|obfd
argument_list|,
name|dhandle
argument_list|)
return|;
if|if
condition|(
name|bfd_get_flavour
argument_list|(
name|obfd
argument_list|)
operator|==
name|bfd_target_coff_flavour
operator|||
name|bfd_get_flavour
argument_list|(
name|obfd
argument_list|)
operator|==
name|bfd_target_elf_flavour
condition|)
block|{
name|bfd_byte
modifier|*
name|syms
decl_stmt|,
modifier|*
name|strings
decl_stmt|;
name|bfd_size_type
name|symsize
decl_stmt|,
name|stringsize
decl_stmt|;
name|asection
modifier|*
name|stabsec
decl_stmt|,
modifier|*
name|stabstrsec
decl_stmt|;
if|if
condition|(
operator|!
name|write_stabs_in_sections_debugging_info
argument_list|(
name|obfd
argument_list|,
name|dhandle
argument_list|,
operator|&
name|syms
argument_list|,
operator|&
name|symsize
argument_list|,
operator|&
name|strings
argument_list|,
operator|&
name|stringsize
argument_list|)
condition|)
return|return
name|false
return|;
name|stabsec
operator|=
name|bfd_make_section
argument_list|(
name|obfd
argument_list|,
literal|".stab"
argument_list|)
expr_stmt|;
name|stabstrsec
operator|=
name|bfd_make_section
argument_list|(
name|obfd
argument_list|,
literal|".stabstr"
argument_list|)
expr_stmt|;
if|if
condition|(
name|stabsec
operator|==
name|NULL
operator|||
name|stabstrsec
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_size
argument_list|(
name|obfd
argument_list|,
name|stabsec
argument_list|,
name|symsize
argument_list|)
operator|||
operator|!
name|bfd_set_section_size
argument_list|(
name|obfd
argument_list|,
name|stabstrsec
argument_list|,
name|stringsize
argument_list|)
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|obfd
argument_list|,
name|stabsec
argument_list|,
literal|2
argument_list|)
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|obfd
argument_list|,
name|stabstrsec
argument_list|,
literal|0
argument_list|)
operator|||
operator|!
name|bfd_set_section_flags
argument_list|(
name|obfd
argument_list|,
name|stabsec
argument_list|,
operator|(
name|SEC_HAS_CONTENTS
operator||
name|SEC_READONLY
operator||
name|SEC_DEBUGGING
operator|)
argument_list|)
operator|||
operator|!
name|bfd_set_section_flags
argument_list|(
name|obfd
argument_list|,
name|stabstrsec
argument_list|,
operator|(
name|SEC_HAS_CONTENTS
operator||
name|SEC_READONLY
operator||
name|SEC_DEBUGGING
operator|)
argument_list|)
condition|)
block|{
name|non_fatal
argument_list|(
name|_
argument_list|(
literal|"%s: can't create debugging section: %s"
argument_list|)
argument_list|,
name|bfd_get_filename
argument_list|(
name|obfd
argument_list|)
argument_list|,
name|bfd_errmsg
argument_list|(
name|bfd_get_error
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
comment|/* We can get away with setting the section contents now because          the next thing the caller is going to do is copy over the          real sections.  We may someday have to split the contents          setting out of this function.  */
if|if
condition|(
operator|!
name|bfd_set_section_contents
argument_list|(
name|obfd
argument_list|,
name|stabsec
argument_list|,
name|syms
argument_list|,
operator|(
name|file_ptr
operator|)
literal|0
argument_list|,
name|symsize
argument_list|)
operator|||
operator|!
name|bfd_set_section_contents
argument_list|(
name|obfd
argument_list|,
name|stabstrsec
argument_list|,
name|strings
argument_list|,
operator|(
name|file_ptr
operator|)
literal|0
argument_list|,
name|stringsize
argument_list|)
condition|)
block|{
name|non_fatal
argument_list|(
name|_
argument_list|(
literal|"%s: can't set debugging section contents: %s"
argument_list|)
argument_list|,
name|bfd_get_filename
argument_list|(
name|obfd
argument_list|)
argument_list|,
name|bfd_errmsg
argument_list|(
name|bfd_get_error
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
return|return
name|true
return|;
block|}
name|non_fatal
argument_list|(
name|_
argument_list|(
literal|"%s: don't know how to write debugging information for %s"
argument_list|)
argument_list|,
name|bfd_get_filename
argument_list|(
name|obfd
argument_list|)
argument_list|,
name|bfd_get_target
argument_list|(
name|obfd
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|strip_main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
name|char
modifier|*
name|input_target
init|=
name|NULL
decl_stmt|,
modifier|*
name|output_target
init|=
name|NULL
decl_stmt|;
name|boolean
name|show_version
init|=
name|false
decl_stmt|;
name|int
name|c
decl_stmt|,
name|i
decl_stmt|;
name|struct
name|section_list
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|output_file
init|=
name|NULL
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getopt_long
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"I:O:F:K:N:R:o:sSpdgxXVv"
argument_list|,
name|strip_options
argument_list|,
operator|(
name|int
operator|*
operator|)
literal|0
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'I'
case|:
name|input_target
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'O'
case|:
name|output_target
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'F'
case|:
name|input_target
operator|=
name|output_target
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'R'
case|:
name|p
operator|=
name|find_section_list
argument_list|(
name|optarg
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|p
operator|->
name|remove
operator|=
name|true
expr_stmt|;
name|sections_removed
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|strip_symbols
operator|=
name|STRIP_ALL
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
case|case
literal|'g'
case|:
case|case
literal|'d'
case|:
comment|/* Historic BSD alias for -g.  Used by early NetBSD.  */
name|strip_symbols
operator|=
name|STRIP_DEBUG
expr_stmt|;
break|break;
case|case
name|OPTION_STRIP_UNNEEDED
case|:
name|strip_symbols
operator|=
name|STRIP_UNNEEDED
expr_stmt|;
break|break;
case|case
literal|'K'
case|:
name|add_specific_symbol
argument_list|(
name|optarg
argument_list|,
operator|&
name|keep_specific_list
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'N'
case|:
name|add_specific_symbol
argument_list|(
name|optarg
argument_list|,
operator|&
name|strip_specific_list
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
name|output_file
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|preserve_dates
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
name|discard_locals
operator|=
name|LOCALS_ALL
expr_stmt|;
break|break;
case|case
literal|'X'
case|:
name|discard_locals
operator|=
name|LOCALS_START_L
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
name|verbose
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'V'
case|:
name|show_version
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|0
case|:
break|break;
comment|/* we've been given a long option */
case|case
literal|'h'
case|:
name|strip_usage
argument_list|(
name|stdout
argument_list|,
literal|0
argument_list|)
expr_stmt|;
default|default:
name|strip_usage
argument_list|(
name|stderr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|show_version
condition|)
name|print_version
argument_list|(
literal|"strip"
argument_list|)
expr_stmt|;
comment|/* Default is to strip all symbols.  */
if|if
condition|(
name|strip_symbols
operator|==
name|STRIP_UNDEF
operator|&&
name|discard_locals
operator|==
name|LOCALS_UNDEF
operator|&&
name|strip_specific_list
operator|==
name|NULL
condition|)
name|strip_symbols
operator|=
name|STRIP_ALL
expr_stmt|;
if|if
condition|(
name|output_target
operator|==
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
name|output_target
operator|=
name|input_target
expr_stmt|;
name|i
operator|=
name|optind
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|argc
operator|||
operator|(
name|output_file
operator|!=
name|NULL
operator|&&
operator|(
name|i
operator|+
literal|1
operator|)
operator|<
name|argc
operator|)
condition|)
name|strip_usage
argument_list|(
name|stderr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
name|int
name|hold_status
init|=
name|status
decl_stmt|;
name|struct
name|stat
name|statbuf
decl_stmt|;
name|char
modifier|*
name|tmpname
decl_stmt|;
if|if
condition|(
name|preserve_dates
condition|)
block|{
if|if
condition|(
name|stat
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
operator|&
name|statbuf
argument_list|)
operator|<
literal|0
condition|)
block|{
name|non_fatal
argument_list|(
name|_
argument_list|(
literal|"%s: cannot stat: %s"
argument_list|)
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
if|if
condition|(
name|output_file
operator|!=
name|NULL
condition|)
name|tmpname
operator|=
name|output_file
expr_stmt|;
else|else
name|tmpname
operator|=
name|make_tempname
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|status
operator|=
literal|0
expr_stmt|;
name|copy_file
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
name|tmpname
argument_list|,
name|input_target
argument_list|,
name|output_target
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|preserve_dates
condition|)
name|set_times
argument_list|(
name|tmpname
argument_list|,
operator|&
name|statbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|output_file
operator|==
name|NULL
condition|)
name|smart_rename
argument_list|(
name|tmpname
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|,
name|preserve_dates
argument_list|)
expr_stmt|;
name|status
operator|=
name|hold_status
expr_stmt|;
block|}
else|else
name|unlink
argument_list|(
name|tmpname
argument_list|)
expr_stmt|;
if|if
condition|(
name|output_file
operator|==
name|NULL
condition|)
name|free
argument_list|(
name|tmpname
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|copy_main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
name|char
modifier|*
name|input_filename
init|=
name|NULL
decl_stmt|,
modifier|*
name|output_filename
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|input_target
init|=
name|NULL
decl_stmt|,
modifier|*
name|output_target
init|=
name|NULL
decl_stmt|;
name|boolean
name|show_version
init|=
name|false
decl_stmt|;
name|boolean
name|change_warn
init|=
name|true
decl_stmt|;
name|int
name|c
decl_stmt|;
name|struct
name|section_list
modifier|*
name|p
decl_stmt|;
name|struct
name|stat
name|statbuf
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getopt_long
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"b:i:I:j:K:N:s:O:d:F:L:G:R:SpgxXVvW:"
argument_list|,
name|copy_options
argument_list|,
operator|(
name|int
operator|*
operator|)
literal|0
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'b'
case|:
name|copy_byte
operator|=
name|atoi
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
if|if
condition|(
name|copy_byte
operator|<
literal|0
condition|)
name|fatal
argument_list|(
name|_
argument_list|(
literal|"byte number must be non-negative"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
name|interleave
operator|=
name|atoi
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
if|if
condition|(
name|interleave
operator|<
literal|1
condition|)
name|fatal
argument_list|(
name|_
argument_list|(
literal|"interleave must be positive"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'I'
case|:
case|case
literal|'s'
case|:
comment|/* "source" - 'I' is preferred */
name|input_target
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'O'
case|:
case|case
literal|'d'
case|:
comment|/* "destination" - 'O' is preferred */
name|output_target
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'F'
case|:
name|input_target
operator|=
name|output_target
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'j'
case|:
name|p
operator|=
name|find_section_list
argument_list|(
name|optarg
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|remove
condition|)
name|fatal
argument_list|(
name|_
argument_list|(
literal|"%s both copied and removed"
argument_list|)
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
name|p
operator|->
name|copy
operator|=
name|true
expr_stmt|;
name|sections_copied
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'R'
case|:
name|p
operator|=
name|find_section_list
argument_list|(
name|optarg
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|copy
condition|)
name|fatal
argument_list|(
name|_
argument_list|(
literal|"%s both copied and removed"
argument_list|)
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
name|p
operator|->
name|remove
operator|=
name|true
expr_stmt|;
name|sections_removed
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
name|strip_symbols
operator|=
name|STRIP_ALL
expr_stmt|;
break|break;
case|case
literal|'g'
case|:
name|strip_symbols
operator|=
name|STRIP_DEBUG
expr_stmt|;
break|break;
case|case
name|OPTION_STRIP_UNNEEDED
case|:
name|strip_symbols
operator|=
name|STRIP_UNNEEDED
expr_stmt|;
break|break;
case|case
literal|'K'
case|:
name|add_specific_symbol
argument_list|(
name|optarg
argument_list|,
operator|&
name|keep_specific_list
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'N'
case|:
name|add_specific_symbol
argument_list|(
name|optarg
argument_list|,
operator|&
name|strip_specific_list
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'L'
case|:
name|add_specific_symbol
argument_list|(
name|optarg
argument_list|,
operator|&
name|localize_specific_list
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'G'
case|:
name|add_specific_symbol
argument_list|(
name|optarg
argument_list|,
operator|&
name|keepglobal_specific_list
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'W'
case|:
name|add_specific_symbol
argument_list|(
name|optarg
argument_list|,
operator|&
name|weaken_specific_list
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|preserve_dates
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
name|discard_locals
operator|=
name|LOCALS_ALL
expr_stmt|;
break|break;
case|case
literal|'X'
case|:
name|discard_locals
operator|=
name|LOCALS_START_L
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
name|verbose
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'V'
case|:
name|show_version
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|OPTION_WEAKEN
case|:
name|weaken
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|OPTION_ADD_SECTION
case|:
block|{
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
name|struct
name|stat
name|st
decl_stmt|;
name|struct
name|section_add
modifier|*
name|pa
decl_stmt|;
name|int
name|len
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|FILE
modifier|*
name|f
decl_stmt|;
name|s
operator|=
name|strchr
argument_list|(
name|optarg
argument_list|,
literal|'='
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
name|_
argument_list|(
literal|"bad format for %s"
argument_list|)
argument_list|,
literal|"--add-section"
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|s
operator|+
literal|1
argument_list|,
operator|&
name|st
argument_list|)
operator|<
literal|0
condition|)
name|fatal
argument_list|(
name|_
argument_list|(
literal|"cannot stat: %s: %s"
argument_list|)
argument_list|,
name|s
operator|+
literal|1
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|pa
operator|=
operator|(
expr|struct
name|section_add
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|section_add
argument_list|)
argument_list|)
expr_stmt|;
name|len
operator|=
name|s
operator|-
name|optarg
expr_stmt|;
name|name
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|name
argument_list|,
name|optarg
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|name
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
name|pa
operator|->
name|name
operator|=
name|name
expr_stmt|;
name|pa
operator|->
name|filename
operator|=
name|s
operator|+
literal|1
expr_stmt|;
name|pa
operator|->
name|size
operator|=
name|st
operator|.
name|st_size
expr_stmt|;
name|pa
operator|->
name|contents
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|xmalloc
argument_list|(
name|pa
operator|->
name|size
argument_list|)
expr_stmt|;
name|f
operator|=
name|fopen
argument_list|(
name|pa
operator|->
name|filename
argument_list|,
name|FOPEN_RB
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
name|_
argument_list|(
literal|"cannot open: %s: %s"
argument_list|)
argument_list|,
name|pa
operator|->
name|filename
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fread
argument_list|(
name|pa
operator|->
name|contents
argument_list|,
literal|1
argument_list|,
name|pa
operator|->
name|size
argument_list|,
name|f
argument_list|)
operator|==
literal|0
operator|||
name|ferror
argument_list|(
name|f
argument_list|)
condition|)
name|fatal
argument_list|(
name|_
argument_list|(
literal|"%s: fread failed"
argument_list|)
argument_list|,
name|pa
operator|->
name|filename
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|pa
operator|->
name|next
operator|=
name|add_sections
expr_stmt|;
name|add_sections
operator|=
name|pa
expr_stmt|;
block|}
break|break;
case|case
name|OPTION_CHANGE_START
case|:
name|change_start
operator|=
name|parse_vma
argument_list|(
name|optarg
argument_list|,
literal|"--change-start"
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPTION_CHANGE_SECTION_ADDRESS
case|:
case|case
name|OPTION_CHANGE_SECTION_LMA
case|:
case|case
name|OPTION_CHANGE_SECTION_VMA
case|:
block|{
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|len
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|option
init|=
name|NULL
decl_stmt|;
name|bfd_vma
name|val
decl_stmt|;
name|enum
name|change_action
name|what
init|=
name|CHANGE_IGNORE
decl_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
name|OPTION_CHANGE_SECTION_ADDRESS
case|:
name|option
operator|=
literal|"--change-section-address"
expr_stmt|;
break|break;
case|case
name|OPTION_CHANGE_SECTION_LMA
case|:
name|option
operator|=
literal|"--change-section-lma"
expr_stmt|;
break|break;
case|case
name|OPTION_CHANGE_SECTION_VMA
case|:
name|option
operator|=
literal|"--change-section-vma"
expr_stmt|;
break|break;
block|}
name|s
operator|=
name|strchr
argument_list|(
name|optarg
argument_list|,
literal|'='
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
block|{
name|s
operator|=
name|strchr
argument_list|(
name|optarg
argument_list|,
literal|'+'
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
block|{
name|s
operator|=
name|strchr
argument_list|(
name|optarg
argument_list|,
literal|'-'
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
name|_
argument_list|(
literal|"bad format for %s"
argument_list|)
argument_list|,
name|option
argument_list|)
expr_stmt|;
block|}
block|}
name|len
operator|=
name|s
operator|-
name|optarg
expr_stmt|;
name|name
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|name
argument_list|,
name|optarg
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|name
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
name|p
operator|=
name|find_section_list
argument_list|(
name|name
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|val
operator|=
name|parse_vma
argument_list|(
name|s
operator|+
literal|1
argument_list|,
name|option
argument_list|)
expr_stmt|;
switch|switch
condition|(
operator|*
name|s
condition|)
block|{
case|case
literal|'='
case|:
name|what
operator|=
name|CHANGE_SET
expr_stmt|;
break|break;
case|case
literal|'-'
case|:
name|val
operator|=
operator|-
name|val
expr_stmt|;
comment|/* Drop through.  */
case|case
literal|'+'
case|:
name|what
operator|=
name|CHANGE_MODIFY
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|c
condition|)
block|{
case|case
name|OPTION_CHANGE_SECTION_ADDRESS
case|:
name|p
operator|->
name|change_vma
operator|=
name|what
expr_stmt|;
name|p
operator|->
name|vma_val
operator|=
name|val
expr_stmt|;
comment|/* Drop through.  */
case|case
name|OPTION_CHANGE_SECTION_LMA
case|:
name|p
operator|->
name|change_lma
operator|=
name|what
expr_stmt|;
name|p
operator|->
name|lma_val
operator|=
name|val
expr_stmt|;
break|break;
case|case
name|OPTION_CHANGE_SECTION_VMA
case|:
name|p
operator|->
name|change_vma
operator|=
name|what
expr_stmt|;
name|p
operator|->
name|vma_val
operator|=
name|val
expr_stmt|;
break|break;
block|}
block|}
break|break;
case|case
name|OPTION_CHANGE_ADDRESSES
case|:
name|change_section_address
operator|=
name|parse_vma
argument_list|(
name|optarg
argument_list|,
literal|"--change-addresses"
argument_list|)
expr_stmt|;
name|change_start
operator|=
name|change_section_address
expr_stmt|;
break|break;
case|case
name|OPTION_CHANGE_WARNINGS
case|:
name|change_warn
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|OPTION_CHANGE_LEADING_CHAR
case|:
name|change_leading_char
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|OPTION_DEBUGGING
case|:
name|convert_debugging
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|OPTION_GAP_FILL
case|:
block|{
name|bfd_vma
name|gap_fill_vma
decl_stmt|;
name|gap_fill_vma
operator|=
name|parse_vma
argument_list|(
name|optarg
argument_list|,
literal|"--gap-fill"
argument_list|)
expr_stmt|;
name|gap_fill
operator|=
operator|(
name|bfd_byte
operator|)
name|gap_fill_vma
expr_stmt|;
if|if
condition|(
operator|(
name|bfd_vma
operator|)
name|gap_fill
operator|!=
name|gap_fill_vma
condition|)
block|{
name|char
name|buff
index|[
literal|20
index|]
decl_stmt|;
name|sprintf_vma
argument_list|(
name|buff
argument_list|,
name|gap_fill_vma
argument_list|)
expr_stmt|;
name|non_fatal
argument_list|(
name|_
argument_list|(
literal|"Warning: truncating gap-fill from 0x%s to 0x%x"
argument_list|)
argument_list|,
name|buff
argument_list|,
name|gap_fill
argument_list|)
expr_stmt|;
block|}
name|gap_fill_set
operator|=
name|true
expr_stmt|;
block|}
break|break;
case|case
name|OPTION_NO_CHANGE_WARNINGS
case|:
name|change_warn
operator|=
name|false
expr_stmt|;
break|break;
case|case
name|OPTION_PAD_TO
case|:
name|pad_to
operator|=
name|parse_vma
argument_list|(
name|optarg
argument_list|,
literal|"--pad-to"
argument_list|)
expr_stmt|;
name|pad_to_set
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|OPTION_REMOVE_LEADING_CHAR
case|:
name|remove_leading_char
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|OPTION_REDEFINE_SYM
case|:
block|{
comment|/* Push this redefinition onto redefine_symbol_list.  */
name|int
name|len
decl_stmt|;
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
specifier|const
name|char
modifier|*
name|nextarg
decl_stmt|;
name|char
modifier|*
name|source
decl_stmt|,
modifier|*
name|target
decl_stmt|;
name|s
operator|=
name|strchr
argument_list|(
name|optarg
argument_list|,
literal|'='
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
block|{
name|fatal
argument_list|(
name|_
argument_list|(
literal|"bad format for %s"
argument_list|)
argument_list|,
literal|"--redefine-sym"
argument_list|)
expr_stmt|;
block|}
name|len
operator|=
name|s
operator|-
name|optarg
expr_stmt|;
name|source
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|source
argument_list|,
name|optarg
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|source
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
name|nextarg
operator|=
name|s
operator|+
literal|1
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|nextarg
argument_list|)
expr_stmt|;
name|target
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|target
argument_list|,
name|nextarg
argument_list|)
expr_stmt|;
name|redefine_list_append
argument_list|(
name|source
argument_list|,
name|target
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|source
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|target
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|OPTION_SET_SECTION_FLAGS
case|:
block|{
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|len
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|s
operator|=
name|strchr
argument_list|(
name|optarg
argument_list|,
literal|'='
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
name|_
argument_list|(
literal|"bad format for %s"
argument_list|)
argument_list|,
literal|"--set-section-flags"
argument_list|)
expr_stmt|;
name|len
operator|=
name|s
operator|-
name|optarg
expr_stmt|;
name|name
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|name
argument_list|,
name|optarg
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|name
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
name|p
operator|=
name|find_section_list
argument_list|(
name|name
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|p
operator|->
name|set_flags
operator|=
name|true
expr_stmt|;
name|p
operator|->
name|flags
operator|=
name|parse_flags
argument_list|(
name|s
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|OPTION_SET_START
case|:
name|set_start
operator|=
name|parse_vma
argument_list|(
name|optarg
argument_list|,
literal|"--set-start"
argument_list|)
expr_stmt|;
name|set_start_set
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|OPTION_SREC_LEN
case|:
name|Chunk
operator|=
name|parse_vma
argument_list|(
name|optarg
argument_list|,
literal|"--srec-len"
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPTION_SREC_FORCES3
case|:
name|S3Forced
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|OPTION_STRIP_SYMBOLS
case|:
name|add_specific_symbols
argument_list|(
name|optarg
argument_list|,
operator|&
name|strip_specific_list
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPTION_KEEP_SYMBOLS
case|:
name|add_specific_symbols
argument_list|(
name|optarg
argument_list|,
operator|&
name|keep_specific_list
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPTION_LOCALIZE_SYMBOLS
case|:
name|add_specific_symbols
argument_list|(
name|optarg
argument_list|,
operator|&
name|localize_specific_list
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPTION_KEEPGLOBAL_SYMBOLS
case|:
name|add_specific_symbols
argument_list|(
name|optarg
argument_list|,
operator|&
name|keepglobal_specific_list
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPTION_WEAKEN_SYMBOLS
case|:
name|add_specific_symbols
argument_list|(
name|optarg
argument_list|,
operator|&
name|weaken_specific_list
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0
case|:
break|break;
comment|/* we've been given a long option */
case|case
literal|'h'
case|:
name|copy_usage
argument_list|(
name|stdout
argument_list|,
literal|0
argument_list|)
expr_stmt|;
default|default:
name|copy_usage
argument_list|(
name|stderr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|show_version
condition|)
name|print_version
argument_list|(
literal|"objcopy"
argument_list|)
expr_stmt|;
if|if
condition|(
name|copy_byte
operator|>=
name|interleave
condition|)
name|fatal
argument_list|(
name|_
argument_list|(
literal|"byte number must be less than interleave"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|optind
operator|==
name|argc
operator|||
name|optind
operator|+
literal|2
operator|<
name|argc
condition|)
name|copy_usage
argument_list|(
name|stderr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|input_filename
operator|=
name|argv
index|[
name|optind
index|]
expr_stmt|;
if|if
condition|(
name|optind
operator|+
literal|1
operator|<
name|argc
condition|)
name|output_filename
operator|=
name|argv
index|[
name|optind
operator|+
literal|1
index|]
expr_stmt|;
comment|/* Default is to strip no symbols.  */
if|if
condition|(
name|strip_symbols
operator|==
name|STRIP_UNDEF
operator|&&
name|discard_locals
operator|==
name|LOCALS_UNDEF
condition|)
name|strip_symbols
operator|=
name|STRIP_NONE
expr_stmt|;
if|if
condition|(
name|output_target
operator|==
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
name|output_target
operator|=
name|input_target
expr_stmt|;
if|if
condition|(
name|preserve_dates
condition|)
if|if
condition|(
name|stat
argument_list|(
name|input_filename
argument_list|,
operator|&
name|statbuf
argument_list|)
operator|<
literal|0
condition|)
name|fatal
argument_list|(
name|_
argument_list|(
literal|"Cannot stat: %s: %s"
argument_list|)
argument_list|,
name|input_filename
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If there is no destination file then create a temp and rename      the result into the input.  */
if|if
condition|(
name|output_filename
operator|==
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
block|{
name|char
modifier|*
name|tmpname
init|=
name|make_tempname
argument_list|(
name|input_filename
argument_list|)
decl_stmt|;
name|copy_file
argument_list|(
name|input_filename
argument_list|,
name|tmpname
argument_list|,
name|input_target
argument_list|,
name|output_target
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|preserve_dates
condition|)
name|set_times
argument_list|(
name|tmpname
argument_list|,
operator|&
name|statbuf
argument_list|)
expr_stmt|;
name|smart_rename
argument_list|(
name|tmpname
argument_list|,
name|input_filename
argument_list|,
name|preserve_dates
argument_list|)
expr_stmt|;
block|}
else|else
name|unlink
argument_list|(
name|tmpname
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|copy_file
argument_list|(
name|input_filename
argument_list|,
name|output_filename
argument_list|,
name|input_target
argument_list|,
name|output_target
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
literal|0
operator|&&
name|preserve_dates
condition|)
name|set_times
argument_list|(
name|output_filename
argument_list|,
operator|&
name|statbuf
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|change_warn
condition|)
block|{
for|for
control|(
name|p
operator|=
name|change_sections
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|!
name|p
operator|->
name|used
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|change_vma
operator|!=
name|CHANGE_IGNORE
condition|)
block|{
name|char
name|buff
index|[
literal|20
index|]
decl_stmt|;
name|sprintf_vma
argument_list|(
name|buff
argument_list|,
name|p
operator|->
name|vma_val
argument_list|)
expr_stmt|;
comment|/* xgettext:c-format */
name|non_fatal
argument_list|(
name|_
argument_list|(
literal|"%s %s%c0x%s never used"
argument_list|)
argument_list|,
literal|"--change-section-vma"
argument_list|,
name|p
operator|->
name|name
argument_list|,
name|p
operator|->
name|change_vma
operator|==
name|CHANGE_SET
condition|?
literal|'='
else|:
literal|'+'
argument_list|,
name|buff
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|->
name|change_lma
operator|!=
name|CHANGE_IGNORE
condition|)
block|{
name|char
name|buff
index|[
literal|20
index|]
decl_stmt|;
name|sprintf_vma
argument_list|(
name|buff
argument_list|,
name|p
operator|->
name|lma_val
argument_list|)
expr_stmt|;
comment|/* xgettext:c-format */
name|non_fatal
argument_list|(
name|_
argument_list|(
literal|"%s %s%c0x%s never used"
argument_list|)
argument_list|,
literal|"--change-section-lma"
argument_list|,
name|p
operator|->
name|name
argument_list|,
name|p
operator|->
name|change_lma
operator|==
name|CHANGE_SET
condition|?
literal|'='
else|:
literal|'+'
argument_list|,
name|buff
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
if|#
directive|if
name|defined
argument_list|(
name|HAVE_SETLOCALE
argument_list|)
operator|&&
name|defined
argument_list|(
name|HAVE_LC_MESSAGES
argument_list|)
name|setlocale
argument_list|(
name|LC_MESSAGES
argument_list|,
literal|""
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|bindtextdomain
argument_list|(
name|PACKAGE
argument_list|,
name|LOCALEDIR
argument_list|)
expr_stmt|;
name|textdomain
argument_list|(
name|PACKAGE
argument_list|)
expr_stmt|;
name|program_name
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
name|xmalloc_set_program_name
argument_list|(
name|program_name
argument_list|)
expr_stmt|;
name|START_PROGRESS
argument_list|(
name|program_name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|strip_symbols
operator|=
name|STRIP_UNDEF
expr_stmt|;
name|discard_locals
operator|=
name|LOCALS_UNDEF
expr_stmt|;
name|bfd_init
argument_list|()
expr_stmt|;
name|set_default_bfd_target
argument_list|()
expr_stmt|;
if|if
condition|(
name|is_strip
operator|<
literal|0
condition|)
block|{
name|int
name|i
init|=
name|strlen
argument_list|(
name|program_name
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_DOS_BASED_FILE_SYSTEM
comment|/* Drop the .exe suffix, if any.  */
if|if
condition|(
name|i
operator|>
literal|4
operator|&&
name|FILENAME_CMP
argument_list|(
name|program_name
operator|+
name|i
operator|-
literal|4
argument_list|,
literal|".exe"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|i
operator|-=
literal|4
expr_stmt|;
name|program_name
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
endif|#
directive|endif
name|is_strip
operator|=
operator|(
name|i
operator|>=
literal|5
operator|&&
name|FILENAME_CMP
argument_list|(
name|program_name
operator|+
name|i
operator|-
literal|5
argument_list|,
literal|"strip"
argument_list|)
operator|==
literal|0
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|is_strip
condition|)
name|strip_main
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
else|else
name|copy_main
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
name|END_PROGRESS
argument_list|(
name|program_name
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

end_unit

