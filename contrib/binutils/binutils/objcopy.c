begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* objcopy.c -- copy object file from input to output, optionally massaging it.    Copyright 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000,    2001, 2002, 2003, 2004    Free Software Foundation, Inc.     This file is part of GNU Binutils.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA    02111-1307, USA.  */
end_comment

begin_escape
end_escape

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"progress.h"
end_include

begin_include
include|#
directive|include
file|"bucomm.h"
end_include

begin_include
include|#
directive|include
file|"getopt.h"
end_include

begin_include
include|#
directive|include
file|"libiberty.h"
end_include

begin_include
include|#
directive|include
file|"budbg.h"
end_include

begin_include
include|#
directive|include
file|"filenames.h"
end_include

begin_include
include|#
directive|include
file|"fnmatch.h"
end_include

begin_include
include|#
directive|include
file|"elf-bfd.h"
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_comment
comment|/* A list of symbols to explicitly strip out, or to keep.  A linked    list is good enough for a small number from the command line, but    this will slow things down a lot if many symbols are being    deleted.  */
end_comment

begin_struct
struct|struct
name|symlist
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|struct
name|symlist
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* A list to support redefine_sym.  */
end_comment

begin_struct
struct|struct
name|redefine_node
block|{
name|char
modifier|*
name|source
decl_stmt|;
name|char
modifier|*
name|target
decl_stmt|;
name|struct
name|redefine_node
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
struct|struct
name|section_rename
block|{
specifier|const
name|char
modifier|*
name|old_name
decl_stmt|;
specifier|const
name|char
modifier|*
name|new_name
decl_stmt|;
name|flagword
name|flags
decl_stmt|;
name|struct
name|section_rename
modifier|*
name|next
decl_stmt|;
block|}
name|section_rename
typedef|;
end_typedef

begin_comment
comment|/* List of sections to be renamed.  */
end_comment

begin_decl_stmt
specifier|static
name|section_rename
modifier|*
name|section_rename_list
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|RETURN_NONFATAL
parameter_list|(
name|s
parameter_list|)
value|{bfd_nonfatal (s); status = 1; return;}
end_define

begin_decl_stmt
specifier|static
name|asymbol
modifier|*
modifier|*
name|isympp
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Input symbols.  */
end_comment

begin_decl_stmt
specifier|static
name|asymbol
modifier|*
modifier|*
name|osympp
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Output symbols that survive stripping.  */
end_comment

begin_comment
comment|/* If `copy_byte'>= 0, copy only that byte of every `interleave' bytes.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|copy_byte
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|interleave
init|=
literal|4
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|verbose
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Print file and target names.  */
end_comment

begin_decl_stmt
specifier|static
name|bfd_boolean
name|preserve_dates
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Preserve input file timestamp.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|status
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Exit status.  */
end_comment

begin_enum
enum|enum
name|strip_action
block|{
name|STRIP_UNDEF
block|,
name|STRIP_NONE
block|,
comment|/* Don't strip.  */
name|STRIP_DEBUG
block|,
comment|/* Strip all debugger symbols.  */
name|STRIP_UNNEEDED
block|,
comment|/* Strip unnecessary symbols.  */
name|STRIP_NONDEBUG
block|,
comment|/* Strip everything but debug info.  */
name|STRIP_ALL
comment|/* Strip all symbols.  */
block|}
enum|;
end_enum

begin_comment
comment|/* Which symbols to remove.  */
end_comment

begin_decl_stmt
specifier|static
name|enum
name|strip_action
name|strip_symbols
decl_stmt|;
end_decl_stmt

begin_enum
enum|enum
name|locals_action
block|{
name|LOCALS_UNDEF
block|,
name|LOCALS_START_L
block|,
comment|/* Discard locals starting with L.  */
name|LOCALS_ALL
comment|/* Discard all locals.  */
block|}
enum|;
end_enum

begin_comment
comment|/* Which local symbols to remove.  Overrides STRIP_ALL.  */
end_comment

begin_decl_stmt
specifier|static
name|enum
name|locals_action
name|discard_locals
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* What kind of change to perform.  */
end_comment

begin_enum
enum|enum
name|change_action
block|{
name|CHANGE_IGNORE
block|,
name|CHANGE_MODIFY
block|,
name|CHANGE_SET
block|}
enum|;
end_enum

begin_comment
comment|/* Structure used to hold lists of sections and actions to take.  */
end_comment

begin_struct
struct|struct
name|section_list
block|{
name|struct
name|section_list
modifier|*
name|next
decl_stmt|;
comment|/* Next section to change.  */
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
comment|/* Section name.  */
name|bfd_boolean
name|used
decl_stmt|;
comment|/* Whether this entry was used.  */
name|bfd_boolean
name|remove
decl_stmt|;
comment|/* Whether to remove this section.  */
name|bfd_boolean
name|copy
decl_stmt|;
comment|/* Whether to copy this section.  */
name|enum
name|change_action
name|change_vma
decl_stmt|;
comment|/* Whether to change or set VMA.  */
name|bfd_vma
name|vma_val
decl_stmt|;
comment|/* Amount to change by or set to.  */
name|enum
name|change_action
name|change_lma
decl_stmt|;
comment|/* Whether to change or set LMA.  */
name|bfd_vma
name|lma_val
decl_stmt|;
comment|/* Amount to change by or set to.  */
name|bfd_boolean
name|set_flags
decl_stmt|;
comment|/* Whether to set the section flags.	 */
name|flagword
name|flags
decl_stmt|;
comment|/* What to set the section flags to.	 */
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|section_list
modifier|*
name|change_sections
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* TRUE if some sections are to be removed.  */
end_comment

begin_decl_stmt
specifier|static
name|bfd_boolean
name|sections_removed
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* TRUE if only some sections are to be copied.  */
end_comment

begin_decl_stmt
specifier|static
name|bfd_boolean
name|sections_copied
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Changes to the start address.  */
end_comment

begin_decl_stmt
specifier|static
name|bfd_vma
name|change_start
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|set_start_set
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_vma
name|set_start
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Changes to section addresses.  */
end_comment

begin_decl_stmt
specifier|static
name|bfd_vma
name|change_section_address
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Filling gaps between sections.  */
end_comment

begin_decl_stmt
specifier|static
name|bfd_boolean
name|gap_fill_set
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_byte
name|gap_fill
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pad to a given address.  */
end_comment

begin_decl_stmt
specifier|static
name|bfd_boolean
name|pad_to_set
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_vma
name|pad_to
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Use alternate machine code?  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|use_alt_mach_code
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Output BFD flags user wants to set or clear */
end_comment

begin_decl_stmt
specifier|static
name|flagword
name|bfd_flags_to_set
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|flagword
name|bfd_flags_to_clear
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* List of sections to add.  */
end_comment

begin_struct
struct|struct
name|section_add
block|{
comment|/* Next section to add.  */
name|struct
name|section_add
modifier|*
name|next
decl_stmt|;
comment|/* Name of section to add.  */
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
comment|/* Name of file holding section contents.  */
specifier|const
name|char
modifier|*
name|filename
decl_stmt|;
comment|/* Size of file.  */
name|size_t
name|size
decl_stmt|;
comment|/* Contents of file.  */
name|bfd_byte
modifier|*
name|contents
decl_stmt|;
comment|/* BFD section, after it has been added.  */
name|asection
modifier|*
name|section
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* List of sections to add to the output BFD.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|section_add
modifier|*
name|add_sections
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If non-NULL the argument to --add-gnu-debuglink.    This should be the filename to store in the .gnu_debuglink section.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|gnu_debuglink_filename
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Whether to convert debugging information.  */
end_comment

begin_decl_stmt
specifier|static
name|bfd_boolean
name|convert_debugging
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Whether to change the leading character in symbol names.  */
end_comment

begin_decl_stmt
specifier|static
name|bfd_boolean
name|change_leading_char
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Whether to remove the leading character from global symbol names.  */
end_comment

begin_decl_stmt
specifier|static
name|bfd_boolean
name|remove_leading_char
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Whether to permit wildcard in symbol comparison.  */
end_comment

begin_decl_stmt
specifier|static
name|bfd_boolean
name|wildcard
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* List of symbols to strip, keep, localize, keep-global, weaken,    or redefine.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|symlist
modifier|*
name|strip_specific_list
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|symlist
modifier|*
name|keep_specific_list
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|symlist
modifier|*
name|localize_specific_list
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|symlist
modifier|*
name|keepglobal_specific_list
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|symlist
modifier|*
name|weaken_specific_list
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|redefine_node
modifier|*
name|redefine_sym_list
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If this is TRUE, we weaken global symbols (set BSF_WEAK).  */
end_comment

begin_decl_stmt
specifier|static
name|bfd_boolean
name|weaken
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Prefix symbols/sections.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|prefix_symbols_string
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|prefix_sections_string
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|prefix_alloc_sections_string
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 150 isn't special; it's just an arbitrary non-ASCII char value.  */
end_comment

begin_enum
enum|enum
name|command_line_switch
block|{
name|OPTION_ADD_SECTION
init|=
literal|150
block|,
name|OPTION_CHANGE_ADDRESSES
block|,
name|OPTION_CHANGE_LEADING_CHAR
block|,
name|OPTION_CHANGE_START
block|,
name|OPTION_CHANGE_SECTION_ADDRESS
block|,
name|OPTION_CHANGE_SECTION_LMA
block|,
name|OPTION_CHANGE_SECTION_VMA
block|,
name|OPTION_CHANGE_WARNINGS
block|,
name|OPTION_DEBUGGING
block|,
name|OPTION_GAP_FILL
block|,
name|OPTION_NO_CHANGE_WARNINGS
block|,
name|OPTION_PAD_TO
block|,
name|OPTION_REMOVE_LEADING_CHAR
block|,
name|OPTION_SET_SECTION_FLAGS
block|,
name|OPTION_SET_START
block|,
name|OPTION_STRIP_UNNEEDED
block|,
name|OPTION_WEAKEN
block|,
name|OPTION_REDEFINE_SYM
block|,
name|OPTION_REDEFINE_SYMS
block|,
name|OPTION_SREC_LEN
block|,
name|OPTION_SREC_FORCES3
block|,
name|OPTION_STRIP_SYMBOLS
block|,
name|OPTION_KEEP_SYMBOLS
block|,
name|OPTION_LOCALIZE_SYMBOLS
block|,
name|OPTION_KEEPGLOBAL_SYMBOLS
block|,
name|OPTION_WEAKEN_SYMBOLS
block|,
name|OPTION_RENAME_SECTION
block|,
name|OPTION_ALT_MACH_CODE
block|,
name|OPTION_PREFIX_SYMBOLS
block|,
name|OPTION_PREFIX_SECTIONS
block|,
name|OPTION_PREFIX_ALLOC_SECTIONS
block|,
name|OPTION_FORMATS_INFO
block|,
name|OPTION_ADD_GNU_DEBUGLINK
block|,
name|OPTION_ONLY_KEEP_DEBUG
block|,
name|OPTION_READONLY_TEXT
block|,
name|OPTION_WRITABLE_TEXT
block|,
name|OPTION_PURE
block|,
name|OPTION_IMPURE
block|}
enum|;
end_enum

begin_comment
comment|/* Options to handle if running as "strip".  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|option
name|strip_options
index|[]
init|=
block|{
block|{
literal|"discard-all"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'x'
block|}
block|,
block|{
literal|"discard-locals"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'X'
block|}
block|,
block|{
literal|"format"
block|,
name|required_argument
block|,
literal|0
block|,
literal|'F'
block|}
block|,
comment|/* Obsolete */
block|{
literal|"help"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'h'
block|}
block|,
block|{
literal|"info"
block|,
name|no_argument
block|,
literal|0
block|,
name|OPTION_FORMATS_INFO
block|}
block|,
block|{
literal|"input-format"
block|,
name|required_argument
block|,
literal|0
block|,
literal|'I'
block|}
block|,
comment|/* Obsolete */
block|{
literal|"input-target"
block|,
name|required_argument
block|,
literal|0
block|,
literal|'I'
block|}
block|,
block|{
literal|"keep-symbol"
block|,
name|required_argument
block|,
literal|0
block|,
literal|'K'
block|}
block|,
block|{
literal|"only-keep-debug"
block|,
name|no_argument
block|,
literal|0
block|,
name|OPTION_ONLY_KEEP_DEBUG
block|}
block|,
block|{
literal|"output-format"
block|,
name|required_argument
block|,
literal|0
block|,
literal|'O'
block|}
block|,
comment|/* Obsolete */
block|{
literal|"output-target"
block|,
name|required_argument
block|,
literal|0
block|,
literal|'O'
block|}
block|,
block|{
literal|"output-file"
block|,
name|required_argument
block|,
literal|0
block|,
literal|'o'
block|}
block|,
block|{
literal|"preserve-dates"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'p'
block|}
block|,
block|{
literal|"remove-section"
block|,
name|required_argument
block|,
literal|0
block|,
literal|'R'
block|}
block|,
block|{
literal|"strip-all"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'s'
block|}
block|,
block|{
literal|"strip-debug"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'S'
block|}
block|,
block|{
literal|"strip-unneeded"
block|,
name|no_argument
block|,
literal|0
block|,
name|OPTION_STRIP_UNNEEDED
block|}
block|,
block|{
literal|"strip-symbol"
block|,
name|required_argument
block|,
literal|0
block|,
literal|'N'
block|}
block|,
block|{
literal|"target"
block|,
name|required_argument
block|,
literal|0
block|,
literal|'F'
block|}
block|,
block|{
literal|"verbose"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'v'
block|}
block|,
block|{
literal|"version"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'V'
block|}
block|,
block|{
literal|"wildcard"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'w'
block|}
block|,
block|{
literal|0
block|,
name|no_argument
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Options to handle if running as "objcopy".  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|option
name|copy_options
index|[]
init|=
block|{
block|{
literal|"add-gnu-debuglink"
block|,
name|required_argument
block|,
literal|0
block|,
name|OPTION_ADD_GNU_DEBUGLINK
block|}
block|,
block|{
literal|"add-section"
block|,
name|required_argument
block|,
literal|0
block|,
name|OPTION_ADD_SECTION
block|}
block|,
block|{
literal|"adjust-start"
block|,
name|required_argument
block|,
literal|0
block|,
name|OPTION_CHANGE_START
block|}
block|,
block|{
literal|"adjust-vma"
block|,
name|required_argument
block|,
literal|0
block|,
name|OPTION_CHANGE_ADDRESSES
block|}
block|,
block|{
literal|"adjust-section-vma"
block|,
name|required_argument
block|,
literal|0
block|,
name|OPTION_CHANGE_SECTION_ADDRESS
block|}
block|,
block|{
literal|"adjust-warnings"
block|,
name|no_argument
block|,
literal|0
block|,
name|OPTION_CHANGE_WARNINGS
block|}
block|,
block|{
literal|"alt-machine-code"
block|,
name|required_argument
block|,
literal|0
block|,
name|OPTION_ALT_MACH_CODE
block|}
block|,
block|{
literal|"binary-architecture"
block|,
name|required_argument
block|,
literal|0
block|,
literal|'B'
block|}
block|,
block|{
literal|"byte"
block|,
name|required_argument
block|,
literal|0
block|,
literal|'b'
block|}
block|,
block|{
literal|"change-addresses"
block|,
name|required_argument
block|,
literal|0
block|,
name|OPTION_CHANGE_ADDRESSES
block|}
block|,
block|{
literal|"change-leading-char"
block|,
name|no_argument
block|,
literal|0
block|,
name|OPTION_CHANGE_LEADING_CHAR
block|}
block|,
block|{
literal|"change-section-address"
block|,
name|required_argument
block|,
literal|0
block|,
name|OPTION_CHANGE_SECTION_ADDRESS
block|}
block|,
block|{
literal|"change-section-lma"
block|,
name|required_argument
block|,
literal|0
block|,
name|OPTION_CHANGE_SECTION_LMA
block|}
block|,
block|{
literal|"change-section-vma"
block|,
name|required_argument
block|,
literal|0
block|,
name|OPTION_CHANGE_SECTION_VMA
block|}
block|,
block|{
literal|"change-start"
block|,
name|required_argument
block|,
literal|0
block|,
name|OPTION_CHANGE_START
block|}
block|,
block|{
literal|"change-warnings"
block|,
name|no_argument
block|,
literal|0
block|,
name|OPTION_CHANGE_WARNINGS
block|}
block|,
block|{
literal|"debugging"
block|,
name|no_argument
block|,
literal|0
block|,
name|OPTION_DEBUGGING
block|}
block|,
block|{
literal|"discard-all"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'x'
block|}
block|,
block|{
literal|"discard-locals"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'X'
block|}
block|,
block|{
literal|"format"
block|,
name|required_argument
block|,
literal|0
block|,
literal|'F'
block|}
block|,
comment|/* Obsolete */
block|{
literal|"gap-fill"
block|,
name|required_argument
block|,
literal|0
block|,
name|OPTION_GAP_FILL
block|}
block|,
block|{
literal|"help"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'h'
block|}
block|,
block|{
literal|"impure"
block|,
name|no_argument
block|,
literal|0
block|,
name|OPTION_IMPURE
block|}
block|,
block|{
literal|"info"
block|,
name|no_argument
block|,
literal|0
block|,
name|OPTION_FORMATS_INFO
block|}
block|,
block|{
literal|"input-format"
block|,
name|required_argument
block|,
literal|0
block|,
literal|'I'
block|}
block|,
comment|/* Obsolete */
block|{
literal|"input-target"
block|,
name|required_argument
block|,
literal|0
block|,
literal|'I'
block|}
block|,
block|{
literal|"interleave"
block|,
name|required_argument
block|,
literal|0
block|,
literal|'i'
block|}
block|,
block|{
literal|"keep-global-symbol"
block|,
name|required_argument
block|,
literal|0
block|,
literal|'G'
block|}
block|,
block|{
literal|"keep-global-symbols"
block|,
name|required_argument
block|,
literal|0
block|,
name|OPTION_KEEPGLOBAL_SYMBOLS
block|}
block|,
block|{
literal|"keep-symbol"
block|,
name|required_argument
block|,
literal|0
block|,
literal|'K'
block|}
block|,
block|{
literal|"keep-symbols"
block|,
name|required_argument
block|,
literal|0
block|,
name|OPTION_KEEP_SYMBOLS
block|}
block|,
block|{
literal|"localize-symbol"
block|,
name|required_argument
block|,
literal|0
block|,
literal|'L'
block|}
block|,
block|{
literal|"localize-symbols"
block|,
name|required_argument
block|,
literal|0
block|,
name|OPTION_LOCALIZE_SYMBOLS
block|}
block|,
block|{
literal|"no-adjust-warnings"
block|,
name|no_argument
block|,
literal|0
block|,
name|OPTION_NO_CHANGE_WARNINGS
block|}
block|,
block|{
literal|"no-change-warnings"
block|,
name|no_argument
block|,
literal|0
block|,
name|OPTION_NO_CHANGE_WARNINGS
block|}
block|,
block|{
literal|"only-keep-debug"
block|,
name|no_argument
block|,
literal|0
block|,
name|OPTION_ONLY_KEEP_DEBUG
block|}
block|,
block|{
literal|"only-section"
block|,
name|required_argument
block|,
literal|0
block|,
literal|'j'
block|}
block|,
block|{
literal|"output-format"
block|,
name|required_argument
block|,
literal|0
block|,
literal|'O'
block|}
block|,
comment|/* Obsolete */
block|{
literal|"output-target"
block|,
name|required_argument
block|,
literal|0
block|,
literal|'O'
block|}
block|,
block|{
literal|"pad-to"
block|,
name|required_argument
block|,
literal|0
block|,
name|OPTION_PAD_TO
block|}
block|,
block|{
literal|"prefix-symbols"
block|,
name|required_argument
block|,
literal|0
block|,
name|OPTION_PREFIX_SYMBOLS
block|}
block|,
block|{
literal|"prefix-sections"
block|,
name|required_argument
block|,
literal|0
block|,
name|OPTION_PREFIX_SECTIONS
block|}
block|,
block|{
literal|"prefix-alloc-sections"
block|,
name|required_argument
block|,
literal|0
block|,
name|OPTION_PREFIX_ALLOC_SECTIONS
block|}
block|,
block|{
literal|"preserve-dates"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'p'
block|}
block|,
block|{
literal|"pure"
block|,
name|no_argument
block|,
literal|0
block|,
name|OPTION_PURE
block|}
block|,
block|{
literal|"readonly-text"
block|,
name|no_argument
block|,
literal|0
block|,
name|OPTION_READONLY_TEXT
block|}
block|,
block|{
literal|"redefine-sym"
block|,
name|required_argument
block|,
literal|0
block|,
name|OPTION_REDEFINE_SYM
block|}
block|,
block|{
literal|"redefine-syms"
block|,
name|required_argument
block|,
literal|0
block|,
name|OPTION_REDEFINE_SYMS
block|}
block|,
block|{
literal|"remove-leading-char"
block|,
name|no_argument
block|,
literal|0
block|,
name|OPTION_REMOVE_LEADING_CHAR
block|}
block|,
block|{
literal|"remove-section"
block|,
name|required_argument
block|,
literal|0
block|,
literal|'R'
block|}
block|,
block|{
literal|"rename-section"
block|,
name|required_argument
block|,
literal|0
block|,
name|OPTION_RENAME_SECTION
block|}
block|,
block|{
literal|"set-section-flags"
block|,
name|required_argument
block|,
literal|0
block|,
name|OPTION_SET_SECTION_FLAGS
block|}
block|,
block|{
literal|"set-start"
block|,
name|required_argument
block|,
literal|0
block|,
name|OPTION_SET_START
block|}
block|,
block|{
literal|"srec-len"
block|,
name|required_argument
block|,
literal|0
block|,
name|OPTION_SREC_LEN
block|}
block|,
block|{
literal|"srec-forceS3"
block|,
name|no_argument
block|,
literal|0
block|,
name|OPTION_SREC_FORCES3
block|}
block|,
block|{
literal|"strip-all"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'S'
block|}
block|,
block|{
literal|"strip-debug"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'g'
block|}
block|,
block|{
literal|"strip-unneeded"
block|,
name|no_argument
block|,
literal|0
block|,
name|OPTION_STRIP_UNNEEDED
block|}
block|,
block|{
literal|"strip-symbol"
block|,
name|required_argument
block|,
literal|0
block|,
literal|'N'
block|}
block|,
block|{
literal|"strip-symbols"
block|,
name|required_argument
block|,
literal|0
block|,
name|OPTION_STRIP_SYMBOLS
block|}
block|,
block|{
literal|"target"
block|,
name|required_argument
block|,
literal|0
block|,
literal|'F'
block|}
block|,
block|{
literal|"verbose"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'v'
block|}
block|,
block|{
literal|"version"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'V'
block|}
block|,
block|{
literal|"weaken"
block|,
name|no_argument
block|,
literal|0
block|,
name|OPTION_WEAKEN
block|}
block|,
block|{
literal|"weaken-symbol"
block|,
name|required_argument
block|,
literal|0
block|,
literal|'W'
block|}
block|,
block|{
literal|"weaken-symbols"
block|,
name|required_argument
block|,
literal|0
block|,
name|OPTION_WEAKEN_SYMBOLS
block|}
block|,
block|{
literal|"wildcard"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'w'
block|}
block|,
block|{
literal|"writable-text"
block|,
name|no_argument
block|,
literal|0
block|,
name|OPTION_WRITABLE_TEXT
block|}
block|,
block|{
literal|0
block|,
name|no_argument
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* IMPORTS */
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|program_name
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This flag distinguishes between strip and objcopy:    1 means this is 'strip'; 0 means this is 'objcopy'.    -1 means if we should use argv[0] to decide.  */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|is_strip
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The maximum length of an S record.  This variable is declared in srec.c    and can be modified by the --srec-len parameter.  */
end_comment

begin_decl_stmt
specifier|extern
name|unsigned
name|int
name|Chunk
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Restrict the generation of Srecords to type S3 only.    This variable is declare in bfd/srec.c and can be toggled    on by the --srec-forceS3 command line switch.  */
end_comment

begin_decl_stmt
specifier|extern
name|bfd_boolean
name|S3Forced
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Defined in bfd/binary.c.  Used to set architecture and machine of input    binary files.  */
end_comment

begin_decl_stmt
specifier|extern
name|enum
name|bfd_architecture
name|bfd_external_binary_architecture
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|unsigned
name|long
name|bfd_external_machine
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Forward declarations.  */
end_comment

begin_function_decl
specifier|static
name|void
name|setup_section
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|asection
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|copy_section
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|asection
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|get_sections
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|asection
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|compare_section_lma
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mark_symbols_used_in_relocations
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|asection
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bfd_boolean
name|write_debugging_info
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|,
name|long
modifier|*
parameter_list|,
name|asymbol
modifier|*
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|lookup_sym_redefinition
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_escape
end_escape

begin_function
specifier|static
name|void
name|copy_usage
parameter_list|(
name|FILE
modifier|*
name|stream
parameter_list|,
name|int
name|exit_status
parameter_list|)
block|{
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"Usage: %s [option(s)] in-file [out-file]\n"
argument_list|)
argument_list|,
name|program_name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|" Copies a binary file, possibly transforming it in the process\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|" The options are:\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"\   -I --input-target<bfdname>      Assume input file is in format<bfdname>\n\   -O --output-target<bfdname>     Create an output file in format<bfdname>\n\   -B --binary-architecture<arch>  Set arch of output file, when input is binary\n\   -F --target<bfdname>            Set both input and output format to<bfdname>\n\      --debugging                   Convert debugging information, if possible\n\   -p --preserve-dates              Copy modified/access timestamps to the output\n\   -j --only-section<name>         Only copy section<name> into the output\n\      --add-gnu-debuglink=<file>    Add section .gnu_debuglink linking to<file>\n\   -R --remove-section<name>       Remove section<name> from the output\n\   -S --strip-all                   Remove all symbol and relocation information\n\   -g --strip-debug                 Remove all debugging symbols& sections\n\      --strip-unneeded              Remove all symbols not needed by relocations\n\   -N --strip-symbol<name>         Do not copy symbol<name>\n\      --only-keep-debug             Strip everything but the debug information\n\   -K --keep-symbol<name>          Only copy symbol<name>\n\   -L --localize-symbol<name>      Force symbol<name> to be marked as a local\n\   -G --keep-global-symbol<name>   Localize all symbols except<name>\n\   -W --weaken-symbol<name>        Force symbol<name> to be marked as a weak\n\      --weaken                      Force all global symbols to be marked as weak\n\   -w --wildcard                    Permit wildcard in symbol comparasion\n\   -x --discard-all                 Remove all non-global symbols\n\   -X --discard-locals              Remove any compiler-generated symbols\n\   -i --interleave<number>         Only copy one out of every<number> bytes\n\   -b --byte<num>                  Select byte<num> in every interleaved block\n\      --gap-fill<val>              Fill gaps between sections with<val>\n\      --pad-to<addr>               Pad the last section up to address<addr>\n\      --set-start<addr>            Set the start address to<addr>\n\     {--change-start|--adjust-start}<incr>\n\                                    Add<incr> to the start address\n\     {--change-addresses|--adjust-vma}<incr>\n\                                    Add<incr> to LMA, VMA and start addresses\n\     {--change-section-address|--adjust-section-vma}<name>{=|+|-}<val>\n\                                    Change LMA and VMA of section<name> by<val>\n\      --change-section-lma<name>{=|+|-}<val>\n\                                    Change the LMA of section<name> by<val>\n\      --change-section-vma<name>{=|+|-}<val>\n\                                    Change the VMA of section<name> by<val>\n\     {--[no-]change-warnings|--[no-]adjust-warnings}\n\                                    Warn if a named section does not exist\n\      --set-section-flags<name>=<flags>\n\                                    Set section<name>'s properties to<flags>\n\      --add-section<name>=<file>   Add section<name> found in<file> to output\n\      --rename-section<old>=<new>[,<flags>] Rename section<old> to<new>\n\      --change-leading-char         Force output format's leading character style\n\      --remove-leading-char         Remove leading character from global symbols\n\      --redefine-sym<old>=<new>    Redefine symbol name<old> to<new>\n\      --redefine-syms<file>        --redefine-sym for all symbol pairs \n\                                      listed in<file>\n\      --srec-len<number>           Restrict the length of generated Srecords\n\      --srec-forceS3                Restrict the type of generated Srecords to S3\n\      --strip-symbols<file>        -N for all symbols listed in<file>\n\      --keep-symbols<file>         -K for all symbols listed in<file>\n\      --localize-symbols<file>     -L for all symbols listed in<file>\n\      --keep-global-symbols<file>  -G for all symbols listed in<file>\n\      --weaken-symbols<file>       -W for all symbols listed in<file>\n\      --alt-machine-code<index>    Use alternate machine code for output\n\      --writable-text               Mark the output text as writable\n\      --readonly-text               Make the output text write protected\n\      --pure                        Mark the output file as demand paged\n\      --impure                      Mark the output file as impure\n\      --prefix-symbols<prefix>     Add<prefix> to start of every symbol name\n\      --prefix-sections<prefix>    Add<prefix> to start of every section name\n\      --prefix-alloc-sections<prefix>\n\                                    Add<prefix> to start of every allocatable\n\                                      section name\n\   -v --verbose                     List all object files modified\n\   -V --version                     Display this program's version number\n\   -h --help                        Display this output\n\      --info                        List object formats& architectures supported\n\ "
argument_list|)
argument_list|)
expr_stmt|;
name|list_supported_targets
argument_list|(
name|program_name
argument_list|,
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|exit_status
operator|==
literal|0
condition|)
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"Report bugs to %s\n"
argument_list|)
argument_list|,
name|REPORT_BUGS_TO
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|exit_status
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|strip_usage
parameter_list|(
name|FILE
modifier|*
name|stream
parameter_list|,
name|int
name|exit_status
parameter_list|)
block|{
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"Usage: %s<option(s)> in-file(s)\n"
argument_list|)
argument_list|,
name|program_name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|" Removes symbols and sections from files\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|" The options are:\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"\   -I --input-target=<bfdname>      Assume input file is in format<bfdname>\n\   -O --output-target=<bfdname>     Create an output file in format<bfdname>\n\   -F --target=<bfdname>            Set both input and output format to<bfdname>\n\   -p --preserve-dates              Copy modified/access timestamps to the output\n\   -R --remove-section=<name>       Remove section<name> from the output\n\   -s --strip-all                   Remove all symbol and relocation information\n\   -g -S -d --strip-debug           Remove all debugging symbols& sections\n\      --strip-unneeded              Remove all symbols not needed by relocations\n\      --only-keep-debug             Strip everything but the debug information\n\   -N --strip-symbol=<name>         Do not copy symbol<name>\n\   -K --keep-symbol=<name>          Only copy symbol<name>\n\   -w --wildcard                    Permit wildcard in symbol comparasion\n\   -x --discard-all                 Remove all non-global symbols\n\   -X --discard-locals              Remove any compiler-generated symbols\n\   -v --verbose                     List all object files modified\n\   -V --version                     Display this program's version number\n\   -h --help                        Display this output\n\      --info                        List object formats& architectures supported\n\   -o<file>                        Place stripped output into<file>\n\ "
argument_list|)
argument_list|)
expr_stmt|;
name|list_supported_targets
argument_list|(
name|program_name
argument_list|,
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|exit_status
operator|==
literal|0
condition|)
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"Report bugs to %s\n"
argument_list|)
argument_list|,
name|REPORT_BUGS_TO
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|exit_status
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Parse section flags into a flagword, with a fatal error if the    string can't be parsed.  */
end_comment

begin_function
specifier|static
name|flagword
name|parse_flags
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|)
block|{
name|flagword
name|ret
decl_stmt|;
specifier|const
name|char
modifier|*
name|snext
decl_stmt|;
name|int
name|len
decl_stmt|;
name|ret
operator|=
name|SEC_NO_FLAGS
expr_stmt|;
do|do
block|{
name|snext
operator|=
name|strchr
argument_list|(
name|s
argument_list|,
literal|','
argument_list|)
expr_stmt|;
if|if
condition|(
name|snext
operator|==
name|NULL
condition|)
name|len
operator|=
name|strlen
argument_list|(
name|s
argument_list|)
expr_stmt|;
else|else
block|{
name|len
operator|=
name|snext
operator|-
name|s
expr_stmt|;
operator|++
name|snext
expr_stmt|;
block|}
if|if
condition|(
literal|0
condition|)
empty_stmt|;
define|#
directive|define
name|PARSE_FLAG
parameter_list|(
name|fname
parameter_list|,
name|fval
parameter_list|)
define|\
value|else if (strncasecmp (fname, s, len) == 0) ret |= fval
name|PARSE_FLAG
argument_list|(
literal|"alloc"
argument_list|,
name|SEC_ALLOC
argument_list|)
expr_stmt|;
name|PARSE_FLAG
argument_list|(
literal|"load"
argument_list|,
name|SEC_LOAD
argument_list|)
expr_stmt|;
name|PARSE_FLAG
argument_list|(
literal|"noload"
argument_list|,
name|SEC_NEVER_LOAD
argument_list|)
expr_stmt|;
name|PARSE_FLAG
argument_list|(
literal|"readonly"
argument_list|,
name|SEC_READONLY
argument_list|)
expr_stmt|;
name|PARSE_FLAG
argument_list|(
literal|"debug"
argument_list|,
name|SEC_DEBUGGING
argument_list|)
expr_stmt|;
name|PARSE_FLAG
argument_list|(
literal|"code"
argument_list|,
name|SEC_CODE
argument_list|)
expr_stmt|;
name|PARSE_FLAG
argument_list|(
literal|"data"
argument_list|,
name|SEC_DATA
argument_list|)
expr_stmt|;
name|PARSE_FLAG
argument_list|(
literal|"rom"
argument_list|,
name|SEC_ROM
argument_list|)
expr_stmt|;
name|PARSE_FLAG
argument_list|(
literal|"share"
argument_list|,
name|SEC_SHARED
argument_list|)
expr_stmt|;
name|PARSE_FLAG
argument_list|(
literal|"contents"
argument_list|,
name|SEC_HAS_CONTENTS
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|PARSE_FLAG
else|else
block|{
name|char
modifier|*
name|copy
decl_stmt|;
name|copy
operator|=
name|xmalloc
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|copy
argument_list|,
name|s
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|copy
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
name|non_fatal
argument_list|(
name|_
argument_list|(
literal|"unrecognized section flag `%s'"
argument_list|)
argument_list|,
name|copy
argument_list|)
expr_stmt|;
name|fatal
argument_list|(
name|_
argument_list|(
literal|"supported flags: %s"
argument_list|)
argument_list|,
literal|"alloc, load, noload, readonly, debug, code, data, rom, share, contents"
argument_list|)
expr_stmt|;
block|}
name|s
operator|=
name|snext
expr_stmt|;
block|}
do|while
condition|(
name|s
operator|!=
name|NULL
condition|)
do|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Find and optionally add an entry in the change_sections list.  */
end_comment

begin_function
specifier|static
name|struct
name|section_list
modifier|*
name|find_section_list
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|bfd_boolean
name|add
parameter_list|)
block|{
name|struct
name|section_list
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|change_sections
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|p
operator|->
name|name
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
return|return
name|p
return|;
if|if
condition|(
operator|!
name|add
condition|)
return|return
name|NULL
return|;
name|p
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|section_list
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|->
name|name
operator|=
name|name
expr_stmt|;
name|p
operator|->
name|used
operator|=
name|FALSE
expr_stmt|;
name|p
operator|->
name|remove
operator|=
name|FALSE
expr_stmt|;
name|p
operator|->
name|copy
operator|=
name|FALSE
expr_stmt|;
name|p
operator|->
name|change_vma
operator|=
name|CHANGE_IGNORE
expr_stmt|;
name|p
operator|->
name|change_lma
operator|=
name|CHANGE_IGNORE
expr_stmt|;
name|p
operator|->
name|vma_val
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|lma_val
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|set_flags
operator|=
name|FALSE
expr_stmt|;
name|p
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|next
operator|=
name|change_sections
expr_stmt|;
name|change_sections
operator|=
name|p
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_comment
comment|/* Add a symbol to strip_specific_list.  */
end_comment

begin_function
specifier|static
name|void
name|add_specific_symbol
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|struct
name|symlist
modifier|*
modifier|*
name|list
parameter_list|)
block|{
name|struct
name|symlist
modifier|*
name|tmp_list
decl_stmt|;
name|tmp_list
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|symlist
argument_list|)
argument_list|)
expr_stmt|;
name|tmp_list
operator|->
name|name
operator|=
name|name
expr_stmt|;
name|tmp_list
operator|->
name|next
operator|=
operator|*
name|list
expr_stmt|;
operator|*
name|list
operator|=
name|tmp_list
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add symbols listed in `filename' to strip_specific_list.  */
end_comment

begin_define
define|#
directive|define
name|IS_WHITESPACE
parameter_list|(
name|c
parameter_list|)
value|((c) == ' ' || (c) == '\t')
end_define

begin_define
define|#
directive|define
name|IS_LINE_TERMINATOR
parameter_list|(
name|c
parameter_list|)
value|((c) == '\n' || (c) == '\r' || (c) == '\0')
end_define

begin_function
specifier|static
name|void
name|add_specific_symbols
parameter_list|(
specifier|const
name|char
modifier|*
name|filename
parameter_list|,
name|struct
name|symlist
modifier|*
modifier|*
name|list
parameter_list|)
block|{
name|off_t
name|size
decl_stmt|;
name|FILE
modifier|*
name|f
decl_stmt|;
name|char
modifier|*
name|line
decl_stmt|;
name|char
modifier|*
name|buffer
decl_stmt|;
name|unsigned
name|int
name|line_count
decl_stmt|;
name|size
operator|=
name|get_file_size
argument_list|(
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|==
literal|0
condition|)
return|return;
name|buffer
operator|=
name|xmalloc
argument_list|(
name|size
operator|+
literal|2
argument_list|)
expr_stmt|;
name|f
operator|=
name|fopen
argument_list|(
name|filename
argument_list|,
name|FOPEN_RT
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
name|_
argument_list|(
literal|"cannot open '%s': %s"
argument_list|)
argument_list|,
name|filename
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fread
argument_list|(
name|buffer
argument_list|,
literal|1
argument_list|,
name|size
argument_list|,
name|f
argument_list|)
operator|==
literal|0
operator|||
name|ferror
argument_list|(
name|f
argument_list|)
condition|)
name|fatal
argument_list|(
name|_
argument_list|(
literal|"%s: fread failed"
argument_list|)
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|buffer
index|[
name|size
index|]
operator|=
literal|'\n'
expr_stmt|;
name|buffer
index|[
name|size
operator|+
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|line_count
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|line
operator|=
name|buffer
init|;
operator|*
name|line
operator|!=
literal|'\0'
condition|;
name|line
operator|++
control|)
block|{
name|char
modifier|*
name|eol
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|name_end
decl_stmt|;
name|int
name|finished
init|=
name|FALSE
decl_stmt|;
for|for
control|(
name|eol
operator|=
name|line
init|;
condition|;
name|eol
operator|++
control|)
block|{
switch|switch
condition|(
operator|*
name|eol
condition|)
block|{
case|case
literal|'\n'
case|:
operator|*
name|eol
operator|=
literal|'\0'
expr_stmt|;
comment|/* Cope with \n\r.  */
if|if
condition|(
name|eol
index|[
literal|1
index|]
operator|==
literal|'\r'
condition|)
operator|++
name|eol
expr_stmt|;
name|finished
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'\r'
case|:
operator|*
name|eol
operator|=
literal|'\0'
expr_stmt|;
comment|/* Cope with \r\n.  */
if|if
condition|(
name|eol
index|[
literal|1
index|]
operator|==
literal|'\n'
condition|)
operator|++
name|eol
expr_stmt|;
name|finished
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|0
case|:
name|finished
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'#'
case|:
comment|/* Line comment, Terminate the line here, in case a 		 name is present and then allow the rest of the 		 loop to find the real end of the line.  */
operator|*
name|eol
operator|=
literal|'\0'
expr_stmt|;
break|break;
default|default:
break|break;
block|}
if|if
condition|(
name|finished
condition|)
break|break;
block|}
comment|/* A name may now exist somewhere between 'line' and 'eol'. 	 Strip off leading whitespace and trailing whitespace, 	 then add it to the list.  */
for|for
control|(
name|name
operator|=
name|line
init|;
name|IS_WHITESPACE
argument_list|(
operator|*
name|name
argument_list|)
condition|;
name|name
operator|++
control|)
empty_stmt|;
for|for
control|(
name|name_end
operator|=
name|name
init|;
operator|(
operator|!
name|IS_WHITESPACE
argument_list|(
operator|*
name|name_end
argument_list|)
operator|)
operator|&&
operator|(
operator|!
name|IS_LINE_TERMINATOR
argument_list|(
operator|*
name|name_end
argument_list|)
operator|)
condition|;
name|name_end
operator|++
control|)
empty_stmt|;
if|if
condition|(
operator|!
name|IS_LINE_TERMINATOR
argument_list|(
operator|*
name|name_end
argument_list|)
condition|)
block|{
name|char
modifier|*
name|extra
decl_stmt|;
for|for
control|(
name|extra
operator|=
name|name_end
operator|+
literal|1
init|;
name|IS_WHITESPACE
argument_list|(
operator|*
name|extra
argument_list|)
condition|;
name|extra
operator|++
control|)
empty_stmt|;
if|if
condition|(
operator|!
name|IS_LINE_TERMINATOR
argument_list|(
operator|*
name|extra
argument_list|)
condition|)
name|non_fatal
argument_list|(
name|_
argument_list|(
literal|"Ignoring rubbish found on line %d of %s"
argument_list|)
argument_list|,
name|line_count
argument_list|,
name|filename
argument_list|)
expr_stmt|;
block|}
operator|*
name|name_end
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|name_end
operator|>
name|name
condition|)
name|add_specific_symbol
argument_list|(
name|name
argument_list|,
name|list
argument_list|)
expr_stmt|;
comment|/* Advance line pointer to end of line.  The 'eol ++' in the for 	 loop above will then advance us to the start of the next line.  */
name|line
operator|=
name|eol
expr_stmt|;
name|line_count
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* See whether a symbol should be stripped or kept based on    strip_specific_list and keep_symbols.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|is_specified_symbol
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|struct
name|symlist
modifier|*
name|list
parameter_list|)
block|{
name|struct
name|symlist
modifier|*
name|tmp_list
decl_stmt|;
if|if
condition|(
name|wildcard
condition|)
block|{
for|for
control|(
name|tmp_list
operator|=
name|list
init|;
name|tmp_list
condition|;
name|tmp_list
operator|=
name|tmp_list
operator|->
name|next
control|)
if|if
condition|(
operator|*
operator|(
name|tmp_list
operator|->
name|name
operator|)
operator|!=
literal|'!'
condition|)
block|{
if|if
condition|(
operator|!
name|fnmatch
argument_list|(
name|tmp_list
operator|->
name|name
argument_list|,
name|name
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|TRUE
return|;
block|}
else|else
block|{
if|if
condition|(
name|fnmatch
argument_list|(
name|tmp_list
operator|->
name|name
operator|+
literal|1
argument_list|,
name|name
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|TRUE
return|;
block|}
block|}
else|else
block|{
for|for
control|(
name|tmp_list
operator|=
name|list
init|;
name|tmp_list
condition|;
name|tmp_list
operator|=
name|tmp_list
operator|->
name|next
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|tmp_list
operator|->
name|name
argument_list|)
operator|==
literal|0
condition|)
return|return
name|TRUE
return|;
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* See if a section is being removed.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|is_strip_section
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|asection
modifier|*
name|sec
parameter_list|)
block|{
if|if
condition|(
name|sections_removed
operator|||
name|sections_copied
condition|)
block|{
name|struct
name|section_list
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|find_section_list
argument_list|(
name|bfd_get_section_name
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sections_removed
operator|&&
name|p
operator|!=
name|NULL
operator|&&
name|p
operator|->
name|remove
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|sections_copied
operator|&&
operator|(
name|p
operator|==
name|NULL
operator|||
operator|!
name|p
operator|->
name|copy
operator|)
condition|)
return|return
name|TRUE
return|;
block|}
if|if
condition|(
operator|(
name|bfd_get_section_flags
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
operator|&
name|SEC_DEBUGGING
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|strip_symbols
operator|==
name|STRIP_DEBUG
operator|||
name|strip_symbols
operator|==
name|STRIP_UNNEEDED
operator|||
name|strip_symbols
operator|==
name|STRIP_ALL
operator|||
name|discard_locals
operator|==
name|LOCALS_ALL
operator|||
name|convert_debugging
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|strip_symbols
operator|==
name|STRIP_NONDEBUG
condition|)
return|return
name|FALSE
return|;
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* Choose which symbol entries to copy; put the result in OSYMS.    We don't copy in place, because that confuses the relocs.    Return the number of symbols to print.  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|filter_symbols
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|bfd
modifier|*
name|obfd
parameter_list|,
name|asymbol
modifier|*
modifier|*
name|osyms
parameter_list|,
name|asymbol
modifier|*
modifier|*
name|isyms
parameter_list|,
name|long
name|symcount
parameter_list|)
block|{
name|asymbol
modifier|*
modifier|*
name|from
init|=
name|isyms
decl_stmt|,
modifier|*
modifier|*
name|to
init|=
name|osyms
decl_stmt|;
name|long
name|src_count
init|=
literal|0
decl_stmt|,
name|dst_count
init|=
literal|0
decl_stmt|;
name|int
name|relocatable
init|=
operator|(
name|abfd
operator|->
name|flags
operator|&
operator|(
name|HAS_RELOC
operator||
name|EXEC_P
operator||
name|DYNAMIC
operator|)
operator|)
operator|==
name|HAS_RELOC
decl_stmt|;
for|for
control|(
init|;
name|src_count
operator|<
name|symcount
condition|;
name|src_count
operator|++
control|)
block|{
name|asymbol
modifier|*
name|sym
init|=
name|from
index|[
name|src_count
index|]
decl_stmt|;
name|flagword
name|flags
init|=
name|sym
operator|->
name|flags
decl_stmt|;
name|char
modifier|*
name|name
init|=
operator|(
name|char
operator|*
operator|)
name|bfd_asymbol_name
argument_list|(
name|sym
argument_list|)
decl_stmt|;
name|int
name|keep
decl_stmt|;
name|bfd_boolean
name|undefined
decl_stmt|;
name|bfd_boolean
name|rem_leading_char
decl_stmt|;
name|bfd_boolean
name|add_leading_char
decl_stmt|;
name|undefined
operator|=
name|bfd_is_und_section
argument_list|(
name|bfd_get_section
argument_list|(
name|sym
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|redefine_sym_list
condition|)
block|{
name|char
modifier|*
name|old_name
decl_stmt|,
modifier|*
name|new_name
decl_stmt|;
name|old_name
operator|=
operator|(
name|char
operator|*
operator|)
name|bfd_asymbol_name
argument_list|(
name|sym
argument_list|)
expr_stmt|;
name|new_name
operator|=
operator|(
name|char
operator|*
operator|)
name|lookup_sym_redefinition
argument_list|(
name|old_name
argument_list|)
expr_stmt|;
name|bfd_asymbol_name
argument_list|(
name|sym
argument_list|)
operator|=
name|new_name
expr_stmt|;
name|name
operator|=
name|new_name
expr_stmt|;
block|}
comment|/* Check if we will remove the current leading character.  */
name|rem_leading_char
operator|=
operator|(
name|name
index|[
literal|0
index|]
operator|==
name|bfd_get_symbol_leading_char
argument_list|(
name|abfd
argument_list|)
operator|)
operator|&&
operator|(
name|change_leading_char
operator|||
operator|(
name|remove_leading_char
operator|&&
operator|(
operator|(
name|flags
operator|&
operator|(
name|BSF_GLOBAL
operator||
name|BSF_WEAK
operator|)
operator|)
operator|!=
literal|0
operator|||
name|undefined
operator|||
name|bfd_is_com_section
argument_list|(
name|bfd_get_section
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|)
operator|)
operator|)
expr_stmt|;
comment|/* Check if we will add a new leading character.  */
name|add_leading_char
operator|=
name|change_leading_char
operator|&&
operator|(
name|bfd_get_symbol_leading_char
argument_list|(
name|obfd
argument_list|)
operator|!=
literal|'\0'
operator|)
operator|&&
operator|(
name|bfd_get_symbol_leading_char
argument_list|(
name|abfd
argument_list|)
operator|==
literal|'\0'
operator|||
operator|(
name|name
index|[
literal|0
index|]
operator|==
name|bfd_get_symbol_leading_char
argument_list|(
name|abfd
argument_list|)
operator|)
operator|)
expr_stmt|;
comment|/* Short circuit for change_leading_char if we can do it in-place.  */
if|if
condition|(
name|rem_leading_char
operator|&&
name|add_leading_char
operator|&&
operator|!
name|prefix_symbols_string
condition|)
block|{
name|name
index|[
literal|0
index|]
operator|=
name|bfd_get_symbol_leading_char
argument_list|(
name|obfd
argument_list|)
expr_stmt|;
name|bfd_asymbol_name
argument_list|(
name|sym
argument_list|)
operator|=
name|name
expr_stmt|;
name|rem_leading_char
operator|=
name|FALSE
expr_stmt|;
name|add_leading_char
operator|=
name|FALSE
expr_stmt|;
block|}
comment|/* Remove leading char.  */
if|if
condition|(
name|rem_leading_char
condition|)
name|bfd_asymbol_name
argument_list|(
name|sym
argument_list|)
operator|=
operator|++
name|name
expr_stmt|;
comment|/* Add new leading char and/or prefix.  */
if|if
condition|(
name|add_leading_char
operator|||
name|prefix_symbols_string
condition|)
block|{
name|char
modifier|*
name|n
decl_stmt|,
modifier|*
name|ptr
decl_stmt|;
name|ptr
operator|=
name|n
operator|=
name|xmalloc
argument_list|(
literal|1
operator|+
name|strlen
argument_list|(
name|prefix_symbols_string
argument_list|)
operator|+
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|add_leading_char
condition|)
operator|*
name|ptr
operator|++
operator|=
name|bfd_get_symbol_leading_char
argument_list|(
name|obfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|prefix_symbols_string
condition|)
block|{
name|strcpy
argument_list|(
name|ptr
argument_list|,
name|prefix_symbols_string
argument_list|)
expr_stmt|;
name|ptr
operator|+=
name|strlen
argument_list|(
name|prefix_symbols_string
argument_list|)
expr_stmt|;
block|}
name|strcpy
argument_list|(
name|ptr
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|bfd_asymbol_name
argument_list|(
name|sym
argument_list|)
operator|=
name|n
expr_stmt|;
name|name
operator|=
name|n
expr_stmt|;
block|}
if|if
condition|(
name|strip_symbols
operator|==
name|STRIP_ALL
condition|)
name|keep
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|flags
operator|&
name|BSF_KEEP
operator|)
operator|!=
literal|0
comment|/* Used in relocation.  */
operator|||
operator|(
operator|(
name|flags
operator|&
name|BSF_SECTION_SYM
operator|)
operator|!=
literal|0
operator|&&
operator|(
operator|(
operator|*
name|bfd_get_section
argument_list|(
name|sym
argument_list|)
operator|->
name|symbol_ptr_ptr
operator|)
operator|->
name|flags
operator|&
name|BSF_KEEP
operator|)
operator|!=
literal|0
operator|)
condition|)
name|keep
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|relocatable
comment|/* Relocatable file.  */
operator|&&
operator|(
name|flags
operator|&
operator|(
name|BSF_GLOBAL
operator||
name|BSF_WEAK
operator|)
operator|)
operator|!=
literal|0
condition|)
name|keep
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|bfd_decode_symclass
argument_list|(
name|sym
argument_list|)
operator|==
literal|'I'
condition|)
comment|/* Global symbols in $idata sections need to be retained 	   even if relocatable is FALSE.  External users of the 	   library containing the $idata section may reference these 	   symbols.  */
name|keep
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|flags
operator|&
name|BSF_GLOBAL
operator|)
operator|!=
literal|0
comment|/* Global symbol.  */
operator|||
operator|(
name|flags
operator|&
name|BSF_WEAK
operator|)
operator|!=
literal|0
operator|||
name|undefined
operator|||
name|bfd_is_com_section
argument_list|(
name|bfd_get_section
argument_list|(
name|sym
argument_list|)
argument_list|)
condition|)
name|keep
operator|=
name|strip_symbols
operator|!=
name|STRIP_UNNEEDED
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|flags
operator|&
name|BSF_DEBUGGING
operator|)
operator|!=
literal|0
condition|)
comment|/* Debugging symbol.  */
name|keep
operator|=
operator|(
name|strip_symbols
operator|!=
name|STRIP_DEBUG
operator|&&
name|strip_symbols
operator|!=
name|STRIP_UNNEEDED
operator|&&
operator|!
name|convert_debugging
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|bfd_get_section
argument_list|(
name|sym
argument_list|)
operator|->
name|comdat
condition|)
comment|/* COMDAT sections store special information in local 	   symbols, so we cannot risk stripping any of them.  */
name|keep
operator|=
literal|1
expr_stmt|;
else|else
comment|/* Local symbol.  */
name|keep
operator|=
operator|(
name|strip_symbols
operator|!=
name|STRIP_UNNEEDED
operator|&&
operator|(
name|discard_locals
operator|!=
name|LOCALS_ALL
operator|&&
operator|(
name|discard_locals
operator|!=
name|LOCALS_START_L
operator|||
operator|!
name|bfd_is_local_label
argument_list|(
name|abfd
argument_list|,
name|sym
argument_list|)
operator|)
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|keep
operator|&&
name|is_specified_symbol
argument_list|(
name|name
argument_list|,
name|strip_specific_list
argument_list|)
condition|)
name|keep
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|keep
operator|&&
name|is_specified_symbol
argument_list|(
name|name
argument_list|,
name|keep_specific_list
argument_list|)
condition|)
name|keep
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|keep
operator|&&
name|is_strip_section
argument_list|(
name|abfd
argument_list|,
name|bfd_get_section
argument_list|(
name|sym
argument_list|)
argument_list|)
condition|)
name|keep
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|keep
operator|&&
operator|(
name|flags
operator|&
name|BSF_GLOBAL
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|weaken
operator|||
name|is_specified_symbol
argument_list|(
name|name
argument_list|,
name|weaken_specific_list
argument_list|)
operator|)
condition|)
block|{
name|sym
operator|->
name|flags
operator|&=
operator|~
name|BSF_GLOBAL
expr_stmt|;
name|sym
operator|->
name|flags
operator||=
name|BSF_WEAK
expr_stmt|;
block|}
if|if
condition|(
name|keep
operator|&&
operator|!
name|undefined
operator|&&
operator|(
name|flags
operator|&
operator|(
name|BSF_GLOBAL
operator||
name|BSF_WEAK
operator|)
operator|)
operator|&&
operator|(
name|is_specified_symbol
argument_list|(
name|name
argument_list|,
name|localize_specific_list
argument_list|)
operator|||
operator|(
name|keepglobal_specific_list
operator|!=
name|NULL
operator|&&
operator|!
name|is_specified_symbol
argument_list|(
name|name
argument_list|,
name|keepglobal_specific_list
argument_list|)
operator|)
operator|)
condition|)
block|{
name|sym
operator|->
name|flags
operator|&=
operator|~
operator|(
name|BSF_GLOBAL
operator||
name|BSF_WEAK
operator|)
expr_stmt|;
name|sym
operator|->
name|flags
operator||=
name|BSF_LOCAL
expr_stmt|;
block|}
if|if
condition|(
name|keep
condition|)
name|to
index|[
name|dst_count
operator|++
index|]
operator|=
name|sym
expr_stmt|;
block|}
name|to
index|[
name|dst_count
index|]
operator|=
name|NULL
expr_stmt|;
return|return
name|dst_count
return|;
block|}
end_function

begin_comment
comment|/* Find the redefined name of symbol SOURCE.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|lookup_sym_redefinition
parameter_list|(
specifier|const
name|char
modifier|*
name|source
parameter_list|)
block|{
name|struct
name|redefine_node
modifier|*
name|list
decl_stmt|;
for|for
control|(
name|list
operator|=
name|redefine_sym_list
init|;
name|list
operator|!=
name|NULL
condition|;
name|list
operator|=
name|list
operator|->
name|next
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|source
argument_list|,
name|list
operator|->
name|source
argument_list|)
operator|==
literal|0
condition|)
return|return
name|list
operator|->
name|target
return|;
return|return
name|source
return|;
block|}
end_function

begin_comment
comment|/* Add a node to a symbol redefine list.  */
end_comment

begin_function
specifier|static
name|void
name|redefine_list_append
parameter_list|(
specifier|const
name|char
modifier|*
name|cause
parameter_list|,
specifier|const
name|char
modifier|*
name|source
parameter_list|,
specifier|const
name|char
modifier|*
name|target
parameter_list|)
block|{
name|struct
name|redefine_node
modifier|*
modifier|*
name|p
decl_stmt|;
name|struct
name|redefine_node
modifier|*
name|list
decl_stmt|;
name|struct
name|redefine_node
modifier|*
name|new_node
decl_stmt|;
for|for
control|(
name|p
operator|=
operator|&
name|redefine_sym_list
init|;
operator|(
name|list
operator|=
operator|*
name|p
operator|)
operator|!=
name|NULL
condition|;
name|p
operator|=
operator|&
name|list
operator|->
name|next
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|source
argument_list|,
name|list
operator|->
name|source
argument_list|)
operator|==
literal|0
condition|)
name|fatal
argument_list|(
name|_
argument_list|(
literal|"%s: Multiple redefinition of symbol \"%s\""
argument_list|)
argument_list|,
name|cause
argument_list|,
name|source
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|target
argument_list|,
name|list
operator|->
name|target
argument_list|)
operator|==
literal|0
condition|)
name|fatal
argument_list|(
name|_
argument_list|(
literal|"%s: Symbol \"%s\" is target of more than one redefinition"
argument_list|)
argument_list|,
name|cause
argument_list|,
name|target
argument_list|)
expr_stmt|;
block|}
name|new_node
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|redefine_node
argument_list|)
argument_list|)
expr_stmt|;
name|new_node
operator|->
name|source
operator|=
name|strdup
argument_list|(
name|source
argument_list|)
expr_stmt|;
name|new_node
operator|->
name|target
operator|=
name|strdup
argument_list|(
name|target
argument_list|)
expr_stmt|;
name|new_node
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
operator|*
name|p
operator|=
name|new_node
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle the --redefine-syms option.  Read lines containing "old new"    from the file, and add them to the symbol redefine list.  */
end_comment

begin_function
specifier|static
name|void
name|add_redefine_syms_file
parameter_list|(
specifier|const
name|char
modifier|*
name|filename
parameter_list|)
block|{
name|FILE
modifier|*
name|file
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|size_t
name|bufsize
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|size_t
name|outsym_off
decl_stmt|;
name|int
name|c
decl_stmt|,
name|lineno
decl_stmt|;
name|file
operator|=
name|fopen
argument_list|(
name|filename
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|file
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
name|_
argument_list|(
literal|"couldn't open symbol redefinition file %s (error: %s)"
argument_list|)
argument_list|,
name|filename
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|bufsize
operator|=
literal|100
expr_stmt|;
name|buf
operator|=
name|xmalloc
argument_list|(
name|bufsize
argument_list|)
expr_stmt|;
name|lineno
operator|=
literal|1
expr_stmt|;
name|c
operator|=
name|getc
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|len
operator|=
literal|0
expr_stmt|;
name|outsym_off
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|c
operator|!=
name|EOF
condition|)
block|{
comment|/* Collect the input symbol name.  */
while|while
condition|(
operator|!
name|IS_WHITESPACE
argument_list|(
name|c
argument_list|)
operator|&&
operator|!
name|IS_LINE_TERMINATOR
argument_list|(
name|c
argument_list|)
operator|&&
name|c
operator|!=
name|EOF
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'#'
condition|)
goto|goto
name|comment
goto|;
name|buf
index|[
name|len
operator|++
index|]
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|len
operator|>=
name|bufsize
condition|)
block|{
name|bufsize
operator|*=
literal|2
expr_stmt|;
name|buf
operator|=
name|xrealloc
argument_list|(
name|buf
argument_list|,
name|bufsize
argument_list|)
expr_stmt|;
block|}
name|c
operator|=
name|getc
argument_list|(
name|file
argument_list|)
expr_stmt|;
block|}
name|buf
index|[
name|len
operator|++
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
break|break;
comment|/* Eat white space between the symbol names.  */
while|while
condition|(
name|IS_WHITESPACE
argument_list|(
name|c
argument_list|)
condition|)
name|c
operator|=
name|getc
argument_list|(
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'#'
operator|||
name|IS_LINE_TERMINATOR
argument_list|(
name|c
argument_list|)
condition|)
goto|goto
name|comment
goto|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
break|break;
comment|/* Collect the output symbol name.  */
name|outsym_off
operator|=
name|len
expr_stmt|;
while|while
condition|(
operator|!
name|IS_WHITESPACE
argument_list|(
name|c
argument_list|)
operator|&&
operator|!
name|IS_LINE_TERMINATOR
argument_list|(
name|c
argument_list|)
operator|&&
name|c
operator|!=
name|EOF
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'#'
condition|)
goto|goto
name|comment
goto|;
name|buf
index|[
name|len
operator|++
index|]
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|len
operator|>=
name|bufsize
condition|)
block|{
name|bufsize
operator|*=
literal|2
expr_stmt|;
name|buf
operator|=
name|xrealloc
argument_list|(
name|buf
argument_list|,
name|bufsize
argument_list|)
expr_stmt|;
block|}
name|c
operator|=
name|getc
argument_list|(
name|file
argument_list|)
expr_stmt|;
block|}
name|buf
index|[
name|len
operator|++
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
break|break;
comment|/* Eat white space at end of line.  */
while|while
condition|(
operator|!
name|IS_LINE_TERMINATOR
argument_list|(
name|c
argument_list|)
operator|&&
name|c
operator|!=
name|EOF
operator|&&
name|IS_WHITESPACE
argument_list|(
name|c
argument_list|)
condition|)
name|c
operator|=
name|getc
argument_list|(
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'#'
condition|)
goto|goto
name|comment
goto|;
comment|/* Handle \r\n.  */
if|if
condition|(
operator|(
name|c
operator|==
literal|'\r'
operator|&&
operator|(
name|c
operator|=
name|getc
argument_list|(
name|file
argument_list|)
operator|)
operator|==
literal|'\n'
operator|)
operator|||
name|c
operator|==
literal|'\n'
operator|||
name|c
operator|==
name|EOF
condition|)
block|{
name|end_of_line
label|:
comment|/* Append the redefinition to the list.  */
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
name|redefine_list_append
argument_list|(
name|filename
argument_list|,
operator|&
name|buf
index|[
literal|0
index|]
argument_list|,
operator|&
name|buf
index|[
name|outsym_off
index|]
argument_list|)
expr_stmt|;
name|lineno
operator|++
expr_stmt|;
name|len
operator|=
literal|0
expr_stmt|;
name|outsym_off
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
break|break;
name|c
operator|=
name|getc
argument_list|(
name|file
argument_list|)
expr_stmt|;
continue|continue;
block|}
else|else
name|fatal
argument_list|(
name|_
argument_list|(
literal|"%s: garbage at end of line %d"
argument_list|)
argument_list|,
name|filename
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
name|comment
label|:
if|if
condition|(
name|len
operator|!=
literal|0
operator|&&
operator|(
name|outsym_off
operator|==
literal|0
operator|||
name|outsym_off
operator|==
name|len
operator|)
condition|)
name|fatal
argument_list|(
name|_
argument_list|(
literal|"%s: missing new symbol name at line %d"
argument_list|)
argument_list|,
name|filename
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
name|buf
index|[
name|len
operator|++
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Eat the rest of the line and finish it.  */
while|while
condition|(
name|c
operator|!=
literal|'\n'
operator|&&
name|c
operator|!=
name|EOF
condition|)
name|c
operator|=
name|getc
argument_list|(
name|file
argument_list|)
expr_stmt|;
goto|goto
name|end_of_line
goto|;
block|}
if|if
condition|(
name|len
operator|!=
literal|0
condition|)
name|fatal
argument_list|(
name|_
argument_list|(
literal|"%s: premature end of file at line %d"
argument_list|)
argument_list|,
name|filename
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Copy object file IBFD onto OBFD.    Returns TRUE upon success, FALSE otherwise.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|copy_object
parameter_list|(
name|bfd
modifier|*
name|ibfd
parameter_list|,
name|bfd
modifier|*
name|obfd
parameter_list|)
block|{
name|bfd_vma
name|start
decl_stmt|;
name|long
name|symcount
decl_stmt|;
name|asection
modifier|*
modifier|*
name|osections
init|=
name|NULL
decl_stmt|;
name|asection
modifier|*
name|gnu_debuglink_section
init|=
name|NULL
decl_stmt|;
name|bfd_size_type
modifier|*
name|gaps
init|=
name|NULL
decl_stmt|;
name|bfd_size_type
name|max_gap
init|=
literal|0
decl_stmt|;
name|long
name|symsize
decl_stmt|;
name|void
modifier|*
name|dhandle
decl_stmt|;
name|enum
name|bfd_architecture
name|iarch
decl_stmt|;
name|unsigned
name|int
name|imach
decl_stmt|;
if|if
condition|(
name|ibfd
operator|->
name|xvec
operator|->
name|byteorder
operator|!=
name|obfd
operator|->
name|xvec
operator|->
name|byteorder
operator|&&
name|ibfd
operator|->
name|xvec
operator|->
name|byteorder
operator|!=
name|BFD_ENDIAN_UNKNOWN
operator|&&
name|obfd
operator|->
name|xvec
operator|->
name|byteorder
operator|!=
name|BFD_ENDIAN_UNKNOWN
condition|)
name|fatal
argument_list|(
name|_
argument_list|(
literal|"Unable to change endianness of input file(s)"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_set_format
argument_list|(
name|obfd
argument_list|,
name|bfd_get_format
argument_list|(
name|ibfd
argument_list|)
argument_list|)
condition|)
block|{
name|bfd_nonfatal
argument_list|(
name|bfd_get_filename
argument_list|(
name|obfd
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|verbose
condition|)
name|printf
argument_list|(
name|_
argument_list|(
literal|"copy from %s(%s) to %s(%s)\n"
argument_list|)
argument_list|,
name|bfd_get_filename
argument_list|(
name|ibfd
argument_list|)
argument_list|,
name|bfd_get_target
argument_list|(
name|ibfd
argument_list|)
argument_list|,
name|bfd_get_filename
argument_list|(
name|obfd
argument_list|)
argument_list|,
name|bfd_get_target
argument_list|(
name|obfd
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|set_start_set
condition|)
name|start
operator|=
name|set_start
expr_stmt|;
else|else
name|start
operator|=
name|bfd_get_start_address
argument_list|(
name|ibfd
argument_list|)
expr_stmt|;
name|start
operator|+=
name|change_start
expr_stmt|;
comment|/* Neither the start address nor the flags      need to be set for a core file.  */
if|if
condition|(
name|bfd_get_format
argument_list|(
name|obfd
argument_list|)
operator|!=
name|bfd_core
condition|)
block|{
name|flagword
name|flags
decl_stmt|;
name|flags
operator|=
name|bfd_get_file_flags
argument_list|(
name|ibfd
argument_list|)
expr_stmt|;
name|flags
operator||=
name|bfd_flags_to_set
expr_stmt|;
name|flags
operator|&=
operator|~
name|bfd_flags_to_clear
expr_stmt|;
name|flags
operator|&=
name|bfd_applicable_file_flags
argument_list|(
name|obfd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_set_start_address
argument_list|(
name|obfd
argument_list|,
name|start
argument_list|)
operator|||
operator|!
name|bfd_set_file_flags
argument_list|(
name|obfd
argument_list|,
name|flags
argument_list|)
condition|)
block|{
name|bfd_nonfatal
argument_list|(
name|bfd_get_filename
argument_list|(
name|ibfd
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
comment|/* Copy architecture of input file to output file.  */
name|iarch
operator|=
name|bfd_get_arch
argument_list|(
name|ibfd
argument_list|)
expr_stmt|;
name|imach
operator|=
name|bfd_get_mach
argument_list|(
name|ibfd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_set_arch_mach
argument_list|(
name|obfd
argument_list|,
name|iarch
argument_list|,
name|imach
argument_list|)
operator|&&
operator|(
name|ibfd
operator|->
name|target_defaulted
operator|||
name|bfd_get_arch
argument_list|(
name|ibfd
argument_list|)
operator|!=
name|bfd_get_arch
argument_list|(
name|obfd
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|bfd_get_arch
argument_list|(
name|ibfd
argument_list|)
operator|==
name|bfd_arch_unknown
condition|)
name|fatal
argument_list|(
name|_
argument_list|(
literal|"Unable to recognise the format of the input file %s"
argument_list|)
argument_list|,
name|bfd_get_filename
argument_list|(
name|ibfd
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|non_fatal
argument_list|(
name|_
argument_list|(
literal|"Warning: Output file cannot represent architecture %s"
argument_list|)
argument_list|,
name|bfd_printable_arch_mach
argument_list|(
name|bfd_get_arch
argument_list|(
name|ibfd
argument_list|)
argument_list|,
name|bfd_get_mach
argument_list|(
name|ibfd
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
if|if
condition|(
operator|!
name|bfd_set_format
argument_list|(
name|obfd
argument_list|,
name|bfd_get_format
argument_list|(
name|ibfd
argument_list|)
argument_list|)
condition|)
block|{
name|bfd_nonfatal
argument_list|(
name|bfd_get_filename
argument_list|(
name|ibfd
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|isympp
condition|)
name|free
argument_list|(
name|isympp
argument_list|)
expr_stmt|;
if|if
condition|(
name|osympp
operator|!=
name|isympp
condition|)
name|free
argument_list|(
name|osympp
argument_list|)
expr_stmt|;
comment|/* BFD mandates that all output sections be created and sizes set before      any output is done.  Thus, we traverse all sections multiple times.  */
name|bfd_map_over_sections
argument_list|(
name|ibfd
argument_list|,
name|setup_section
argument_list|,
name|obfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|add_sections
operator|!=
name|NULL
condition|)
block|{
name|struct
name|section_add
modifier|*
name|padd
decl_stmt|;
name|struct
name|section_list
modifier|*
name|pset
decl_stmt|;
for|for
control|(
name|padd
operator|=
name|add_sections
init|;
name|padd
operator|!=
name|NULL
condition|;
name|padd
operator|=
name|padd
operator|->
name|next
control|)
block|{
name|flagword
name|flags
decl_stmt|;
name|padd
operator|->
name|section
operator|=
name|bfd_make_section
argument_list|(
name|obfd
argument_list|,
name|padd
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|padd
operator|->
name|section
operator|==
name|NULL
condition|)
block|{
name|non_fatal
argument_list|(
name|_
argument_list|(
literal|"can't create section `%s': %s"
argument_list|)
argument_list|,
name|padd
operator|->
name|name
argument_list|,
name|bfd_errmsg
argument_list|(
name|bfd_get_error
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
operator|!
name|bfd_set_section_size
argument_list|(
name|obfd
argument_list|,
name|padd
operator|->
name|section
argument_list|,
name|padd
operator|->
name|size
argument_list|)
condition|)
block|{
name|bfd_nonfatal
argument_list|(
name|bfd_get_filename
argument_list|(
name|obfd
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|pset
operator|=
name|find_section_list
argument_list|(
name|padd
operator|->
name|name
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|pset
operator|!=
name|NULL
condition|)
name|pset
operator|->
name|used
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|pset
operator|!=
name|NULL
operator|&&
name|pset
operator|->
name|set_flags
condition|)
name|flags
operator|=
name|pset
operator|->
name|flags
operator||
name|SEC_HAS_CONTENTS
expr_stmt|;
else|else
name|flags
operator|=
name|SEC_HAS_CONTENTS
operator||
name|SEC_READONLY
operator||
name|SEC_DATA
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_set_section_flags
argument_list|(
name|obfd
argument_list|,
name|padd
operator|->
name|section
argument_list|,
name|flags
argument_list|)
condition|)
block|{
name|bfd_nonfatal
argument_list|(
name|bfd_get_filename
argument_list|(
name|obfd
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|pset
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|pset
operator|->
name|change_vma
operator|!=
name|CHANGE_IGNORE
condition|)
if|if
condition|(
operator|!
name|bfd_set_section_vma
argument_list|(
name|obfd
argument_list|,
name|padd
operator|->
name|section
argument_list|,
name|pset
operator|->
name|vma_val
argument_list|)
condition|)
block|{
name|bfd_nonfatal
argument_list|(
name|bfd_get_filename
argument_list|(
name|obfd
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|pset
operator|->
name|change_lma
operator|!=
name|CHANGE_IGNORE
condition|)
block|{
name|padd
operator|->
name|section
operator|->
name|lma
operator|=
name|pset
operator|->
name|lma_val
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_set_section_alignment
argument_list|(
name|obfd
argument_list|,
name|padd
operator|->
name|section
argument_list|,
name|bfd_section_alignment
argument_list|(
name|obfd
argument_list|,
name|padd
operator|->
name|section
argument_list|)
argument_list|)
condition|)
block|{
name|bfd_nonfatal
argument_list|(
name|bfd_get_filename
argument_list|(
name|obfd
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
block|}
block|}
block|}
if|if
condition|(
name|gnu_debuglink_filename
operator|!=
name|NULL
condition|)
block|{
name|gnu_debuglink_section
operator|=
name|bfd_create_gnu_debuglink_section
argument_list|(
name|obfd
argument_list|,
name|gnu_debuglink_filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|gnu_debuglink_section
operator|==
name|NULL
condition|)
block|{
name|bfd_nonfatal
argument_list|(
name|gnu_debuglink_filename
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
if|if
condition|(
name|bfd_count_sections
argument_list|(
name|obfd
argument_list|)
operator|==
literal|0
condition|)
block|{
name|non_fatal
argument_list|(
name|_
argument_list|(
literal|"there are no sections to be copied!"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|gap_fill_set
operator|||
name|pad_to_set
condition|)
block|{
name|asection
modifier|*
modifier|*
name|set
decl_stmt|;
name|unsigned
name|int
name|c
decl_stmt|,
name|i
decl_stmt|;
comment|/* We must fill in gaps between the sections and/or we must pad 	 the last section to a specified address.  We do this by 	 grabbing a list of the sections, sorting them by VMA, and 	 increasing the section sizes as required to fill the gaps. 	 We write out the gap contents below.  */
name|c
operator|=
name|bfd_count_sections
argument_list|(
name|obfd
argument_list|)
expr_stmt|;
name|osections
operator|=
name|xmalloc
argument_list|(
name|c
operator|*
sizeof|sizeof
argument_list|(
name|asection
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|set
operator|=
name|osections
expr_stmt|;
name|bfd_map_over_sections
argument_list|(
name|obfd
argument_list|,
name|get_sections
argument_list|,
operator|&
name|set
argument_list|)
expr_stmt|;
name|qsort
argument_list|(
name|osections
argument_list|,
name|c
argument_list|,
sizeof|sizeof
argument_list|(
name|asection
operator|*
argument_list|)
argument_list|,
name|compare_section_lma
argument_list|)
expr_stmt|;
name|gaps
operator|=
name|xmalloc
argument_list|(
name|c
operator|*
sizeof|sizeof
argument_list|(
name|bfd_size_type
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|gaps
argument_list|,
literal|0
argument_list|,
name|c
operator|*
sizeof|sizeof
argument_list|(
name|bfd_size_type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|gap_fill_set
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|c
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|flagword
name|flags
decl_stmt|;
name|bfd_size_type
name|size
decl_stmt|;
name|bfd_vma
name|gap_start
decl_stmt|,
name|gap_stop
decl_stmt|;
name|flags
operator|=
name|bfd_get_section_flags
argument_list|(
name|obfd
argument_list|,
name|osections
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|SEC_HAS_CONTENTS
operator|)
operator|==
literal|0
operator|||
operator|(
name|flags
operator|&
name|SEC_LOAD
operator|)
operator|==
literal|0
condition|)
continue|continue;
name|size
operator|=
name|bfd_section_size
argument_list|(
name|obfd
argument_list|,
name|osections
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|gap_start
operator|=
name|bfd_section_lma
argument_list|(
name|obfd
argument_list|,
name|osections
index|[
name|i
index|]
argument_list|)
operator|+
name|size
expr_stmt|;
name|gap_stop
operator|=
name|bfd_section_lma
argument_list|(
name|obfd
argument_list|,
name|osections
index|[
name|i
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|gap_start
operator|<
name|gap_stop
condition|)
block|{
if|if
condition|(
operator|!
name|bfd_set_section_size
argument_list|(
name|obfd
argument_list|,
name|osections
index|[
name|i
index|]
argument_list|,
name|size
operator|+
operator|(
name|gap_stop
operator|-
name|gap_start
operator|)
argument_list|)
condition|)
block|{
name|non_fatal
argument_list|(
name|_
argument_list|(
literal|"Can't fill gap after %s: %s"
argument_list|)
argument_list|,
name|bfd_get_section_name
argument_list|(
name|obfd
argument_list|,
name|osections
index|[
name|i
index|]
argument_list|)
argument_list|,
name|bfd_errmsg
argument_list|(
name|bfd_get_error
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|status
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|gaps
index|[
name|i
index|]
operator|=
name|gap_stop
operator|-
name|gap_start
expr_stmt|;
if|if
condition|(
name|max_gap
operator|<
name|gap_stop
operator|-
name|gap_start
condition|)
name|max_gap
operator|=
name|gap_stop
operator|-
name|gap_start
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|pad_to_set
condition|)
block|{
name|bfd_vma
name|lma
decl_stmt|;
name|bfd_size_type
name|size
decl_stmt|;
name|lma
operator|=
name|bfd_section_lma
argument_list|(
name|obfd
argument_list|,
name|osections
index|[
name|c
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
name|size
operator|=
name|bfd_section_size
argument_list|(
name|obfd
argument_list|,
name|osections
index|[
name|c
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|lma
operator|+
name|size
operator|<
name|pad_to
condition|)
block|{
if|if
condition|(
operator|!
name|bfd_set_section_size
argument_list|(
name|obfd
argument_list|,
name|osections
index|[
name|c
operator|-
literal|1
index|]
argument_list|,
name|pad_to
operator|-
name|lma
argument_list|)
condition|)
block|{
name|non_fatal
argument_list|(
name|_
argument_list|(
literal|"Can't add padding to %s: %s"
argument_list|)
argument_list|,
name|bfd_get_section_name
argument_list|(
name|obfd
argument_list|,
name|osections
index|[
name|c
operator|-
literal|1
index|]
argument_list|)
argument_list|,
name|bfd_errmsg
argument_list|(
name|bfd_get_error
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|status
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|gaps
index|[
name|c
operator|-
literal|1
index|]
operator|=
name|pad_to
operator|-
operator|(
name|lma
operator|+
name|size
operator|)
expr_stmt|;
if|if
condition|(
name|max_gap
operator|<
name|pad_to
operator|-
operator|(
name|lma
operator|+
name|size
operator|)
condition|)
name|max_gap
operator|=
name|pad_to
operator|-
operator|(
name|lma
operator|+
name|size
operator|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* Symbol filtering must happen after the output sections      have been created, but before their contents are set.  */
name|dhandle
operator|=
name|NULL
expr_stmt|;
name|symsize
operator|=
name|bfd_get_symtab_upper_bound
argument_list|(
name|ibfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|symsize
operator|<
literal|0
condition|)
block|{
name|bfd_nonfatal
argument_list|(
name|bfd_get_filename
argument_list|(
name|ibfd
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|osympp
operator|=
name|isympp
operator|=
name|xmalloc
argument_list|(
name|symsize
argument_list|)
expr_stmt|;
name|symcount
operator|=
name|bfd_canonicalize_symtab
argument_list|(
name|ibfd
argument_list|,
name|isympp
argument_list|)
expr_stmt|;
if|if
condition|(
name|symcount
operator|<
literal|0
condition|)
block|{
name|bfd_nonfatal
argument_list|(
name|bfd_get_filename
argument_list|(
name|ibfd
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|convert_debugging
condition|)
name|dhandle
operator|=
name|read_debugging_info
argument_list|(
name|ibfd
argument_list|,
name|isympp
argument_list|,
name|symcount
argument_list|)
expr_stmt|;
if|if
condition|(
name|strip_symbols
operator|==
name|STRIP_DEBUG
operator|||
name|strip_symbols
operator|==
name|STRIP_ALL
operator|||
name|strip_symbols
operator|==
name|STRIP_UNNEEDED
operator|||
name|strip_symbols
operator|==
name|STRIP_NONDEBUG
operator|||
name|discard_locals
operator|!=
name|LOCALS_UNDEF
operator|||
name|strip_specific_list
operator|!=
name|NULL
operator|||
name|keep_specific_list
operator|!=
name|NULL
operator|||
name|localize_specific_list
operator|!=
name|NULL
operator|||
name|keepglobal_specific_list
operator|!=
name|NULL
operator|||
name|weaken_specific_list
operator|!=
name|NULL
operator|||
name|prefix_symbols_string
operator|||
name|sections_removed
operator|||
name|sections_copied
operator|||
name|convert_debugging
operator|||
name|change_leading_char
operator|||
name|remove_leading_char
operator|||
name|redefine_sym_list
operator|||
name|weaken
condition|)
block|{
comment|/* Mark symbols used in output relocations so that they 	 are kept, even if they are local labels or static symbols.  	 Note we iterate over the input sections examining their 	 relocations since the relocations for the output sections 	 haven't been set yet.  mark_symbols_used_in_relocations will 	 ignore input sections which have no corresponding output 	 section.  */
if|if
condition|(
name|strip_symbols
operator|!=
name|STRIP_ALL
condition|)
name|bfd_map_over_sections
argument_list|(
name|ibfd
argument_list|,
name|mark_symbols_used_in_relocations
argument_list|,
name|isympp
argument_list|)
expr_stmt|;
name|osympp
operator|=
name|xmalloc
argument_list|(
operator|(
name|symcount
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|asymbol
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|symcount
operator|=
name|filter_symbols
argument_list|(
name|ibfd
argument_list|,
name|obfd
argument_list|,
name|osympp
argument_list|,
name|isympp
argument_list|,
name|symcount
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|convert_debugging
operator|&&
name|dhandle
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|write_debugging_info
argument_list|(
name|obfd
argument_list|,
name|dhandle
argument_list|,
operator|&
name|symcount
argument_list|,
operator|&
name|osympp
argument_list|)
condition|)
block|{
name|status
operator|=
literal|1
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
name|bfd_set_symtab
argument_list|(
name|obfd
argument_list|,
name|osympp
argument_list|,
name|symcount
argument_list|)
expr_stmt|;
comment|/* This has to happen after the symbol table has been set.  */
name|bfd_map_over_sections
argument_list|(
name|ibfd
argument_list|,
name|copy_section
argument_list|,
name|obfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|add_sections
operator|!=
name|NULL
condition|)
block|{
name|struct
name|section_add
modifier|*
name|padd
decl_stmt|;
for|for
control|(
name|padd
operator|=
name|add_sections
init|;
name|padd
operator|!=
name|NULL
condition|;
name|padd
operator|=
name|padd
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|!
name|bfd_set_section_contents
argument_list|(
name|obfd
argument_list|,
name|padd
operator|->
name|section
argument_list|,
name|padd
operator|->
name|contents
argument_list|,
literal|0
argument_list|,
name|padd
operator|->
name|size
argument_list|)
condition|)
block|{
name|bfd_nonfatal
argument_list|(
name|bfd_get_filename
argument_list|(
name|obfd
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
block|}
if|if
condition|(
name|gnu_debuglink_filename
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|bfd_fill_in_gnu_debuglink_section
argument_list|(
name|obfd
argument_list|,
name|gnu_debuglink_section
argument_list|,
name|gnu_debuglink_filename
argument_list|)
condition|)
block|{
name|bfd_nonfatal
argument_list|(
name|gnu_debuglink_filename
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
if|if
condition|(
name|gap_fill_set
operator|||
name|pad_to_set
condition|)
block|{
name|bfd_byte
modifier|*
name|buf
decl_stmt|;
name|int
name|c
decl_stmt|,
name|i
decl_stmt|;
comment|/* Fill in the gaps.  */
if|if
condition|(
name|max_gap
operator|>
literal|8192
condition|)
name|max_gap
operator|=
literal|8192
expr_stmt|;
name|buf
operator|=
name|xmalloc
argument_list|(
name|max_gap
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|buf
argument_list|,
name|gap_fill
argument_list|,
name|max_gap
argument_list|)
expr_stmt|;
name|c
operator|=
name|bfd_count_sections
argument_list|(
name|obfd
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|c
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|gaps
index|[
name|i
index|]
operator|!=
literal|0
condition|)
block|{
name|bfd_size_type
name|left
decl_stmt|;
name|file_ptr
name|off
decl_stmt|;
name|left
operator|=
name|gaps
index|[
name|i
index|]
expr_stmt|;
name|off
operator|=
name|bfd_section_size
argument_list|(
name|obfd
argument_list|,
name|osections
index|[
name|i
index|]
argument_list|)
operator|-
name|left
expr_stmt|;
while|while
condition|(
name|left
operator|>
literal|0
condition|)
block|{
name|bfd_size_type
name|now
decl_stmt|;
if|if
condition|(
name|left
operator|>
literal|8192
condition|)
name|now
operator|=
literal|8192
expr_stmt|;
else|else
name|now
operator|=
name|left
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_set_section_contents
argument_list|(
name|obfd
argument_list|,
name|osections
index|[
name|i
index|]
argument_list|,
name|buf
argument_list|,
name|off
argument_list|,
name|now
argument_list|)
condition|)
block|{
name|bfd_nonfatal
argument_list|(
name|bfd_get_filename
argument_list|(
name|obfd
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|left
operator|-=
name|now
expr_stmt|;
name|off
operator|+=
name|now
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* Allow the BFD backend to copy any private data it understands      from the input BFD to the output BFD.  This is done last to      permit the routine to look at the filtered symbol table, which is      important for the ECOFF code at least.  */
if|if
condition|(
name|bfd_get_flavour
argument_list|(
name|ibfd
argument_list|)
operator|==
name|bfd_target_elf_flavour
operator|&&
name|strip_symbols
operator|==
name|STRIP_NONDEBUG
condition|)
comment|/* Do not copy the private data when creating an ELF format        debug info file.  We do not want the program headers.  */
empty_stmt|;
elseif|else
if|if
condition|(
operator|!
name|bfd_copy_private_bfd_data
argument_list|(
name|ibfd
argument_list|,
name|obfd
argument_list|)
condition|)
block|{
name|non_fatal
argument_list|(
name|_
argument_list|(
literal|"%s: error copying private BFD data: %s"
argument_list|)
argument_list|,
name|bfd_get_filename
argument_list|(
name|obfd
argument_list|)
argument_list|,
name|bfd_errmsg
argument_list|(
name|bfd_get_error
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* Switch to the alternate machine code.  We have to do this at the      very end, because we only initialize the header when we create      the first section.  */
if|if
condition|(
name|use_alt_mach_code
operator|!=
literal|0
operator|&&
operator|!
name|bfd_alt_mach_code
argument_list|(
name|obfd
argument_list|,
name|use_alt_mach_code
argument_list|)
condition|)
name|non_fatal
argument_list|(
name|_
argument_list|(
literal|"unknown alternate machine code, ignored"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_undef
undef|#
directive|undef
name|MKDIR
end_undef

begin_if
if|#
directive|if
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__CYGWIN32__
argument_list|)
end_if

begin_define
define|#
directive|define
name|MKDIR
parameter_list|(
name|DIR
parameter_list|,
name|MODE
parameter_list|)
value|mkdir (DIR)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|MKDIR
parameter_list|(
name|DIR
parameter_list|,
name|MODE
parameter_list|)
value|mkdir (DIR, MODE)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Read each archive element in turn from IBFD, copy the    contents to temp file, and keep the temp file handle.  */
end_comment

begin_function
specifier|static
name|void
name|copy_archive
parameter_list|(
name|bfd
modifier|*
name|ibfd
parameter_list|,
name|bfd
modifier|*
name|obfd
parameter_list|,
specifier|const
name|char
modifier|*
name|output_target
parameter_list|)
block|{
struct|struct
name|name_list
block|{
name|struct
name|name_list
modifier|*
name|next
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|bfd
modifier|*
name|obfd
decl_stmt|;
block|}
modifier|*
name|list
struct|,
modifier|*
name|l
struct|;
name|bfd
modifier|*
modifier|*
name|ptr
init|=
operator|&
name|obfd
operator|->
name|archive_head
decl_stmt|;
name|bfd
modifier|*
name|this_element
decl_stmt|;
name|char
modifier|*
name|dir
init|=
name|make_tempname
argument_list|(
name|bfd_get_filename
argument_list|(
name|obfd
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Make a temp directory to hold the contents.  */
if|if
condition|(
name|MKDIR
argument_list|(
name|dir
argument_list|,
literal|0700
argument_list|)
operator|!=
literal|0
condition|)
name|fatal
argument_list|(
name|_
argument_list|(
literal|"cannot mkdir %s for archive copying (error: %s)"
argument_list|)
argument_list|,
name|dir
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|obfd
operator|->
name|has_armap
operator|=
name|ibfd
operator|->
name|has_armap
expr_stmt|;
name|list
operator|=
name|NULL
expr_stmt|;
name|this_element
operator|=
name|bfd_openr_next_archived_file
argument_list|(
name|ibfd
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_set_format
argument_list|(
name|obfd
argument_list|,
name|bfd_get_format
argument_list|(
name|ibfd
argument_list|)
argument_list|)
condition|)
name|RETURN_NONFATAL
argument_list|(
name|bfd_get_filename
argument_list|(
name|obfd
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|status
operator|&&
name|this_element
operator|!=
name|NULL
condition|)
block|{
name|char
modifier|*
name|output_name
decl_stmt|;
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|bfd
modifier|*
name|last_element
decl_stmt|;
name|struct
name|stat
name|buf
decl_stmt|;
name|int
name|stat_status
init|=
literal|0
decl_stmt|;
name|bfd_boolean
name|delete
init|=
name|TRUE
decl_stmt|;
comment|/* Create an output file for this member.  */
name|output_name
operator|=
name|concat
argument_list|(
name|dir
argument_list|,
literal|"/"
argument_list|,
name|bfd_get_filename
argument_list|(
name|this_element
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
comment|/* If the file already exists, make another temp dir.  */
if|if
condition|(
name|stat
argument_list|(
name|output_name
argument_list|,
operator|&
name|buf
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|output_name
operator|=
name|make_tempname
argument_list|(
name|output_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|MKDIR
argument_list|(
name|output_name
argument_list|,
literal|0700
argument_list|)
operator|!=
literal|0
condition|)
name|fatal
argument_list|(
name|_
argument_list|(
literal|"cannot mkdir %s for archive copying (error: %s)"
argument_list|)
argument_list|,
name|output_name
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|l
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|name_list
argument_list|)
argument_list|)
expr_stmt|;
name|l
operator|->
name|name
operator|=
name|output_name
expr_stmt|;
name|l
operator|->
name|next
operator|=
name|list
expr_stmt|;
name|l
operator|->
name|obfd
operator|=
name|NULL
expr_stmt|;
name|list
operator|=
name|l
expr_stmt|;
name|output_name
operator|=
name|concat
argument_list|(
name|output_name
argument_list|,
literal|"/"
argument_list|,
name|bfd_get_filename
argument_list|(
name|this_element
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
name|output_bfd
operator|=
name|bfd_openw
argument_list|(
name|output_name
argument_list|,
name|output_target
argument_list|)
expr_stmt|;
if|if
condition|(
name|preserve_dates
condition|)
block|{
name|stat_status
operator|=
name|bfd_stat_arch_elt
argument_list|(
name|this_element
argument_list|,
operator|&
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat_status
operator|!=
literal|0
condition|)
name|non_fatal
argument_list|(
name|_
argument_list|(
literal|"internal stat error on %s"
argument_list|)
argument_list|,
name|bfd_get_filename
argument_list|(
name|this_element
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|l
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|name_list
argument_list|)
argument_list|)
expr_stmt|;
name|l
operator|->
name|name
operator|=
name|output_name
expr_stmt|;
name|l
operator|->
name|next
operator|=
name|list
expr_stmt|;
name|list
operator|=
name|l
expr_stmt|;
if|if
condition|(
name|output_bfd
operator|==
name|NULL
condition|)
name|RETURN_NONFATAL
argument_list|(
name|output_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_check_format
argument_list|(
name|this_element
argument_list|,
name|bfd_object
argument_list|)
condition|)
name|delete
operator|=
operator|!
name|copy_object
argument_list|(
name|this_element
argument_list|,
name|output_bfd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_close
argument_list|(
name|output_bfd
argument_list|)
condition|)
block|{
name|bfd_nonfatal
argument_list|(
name|bfd_get_filename
argument_list|(
name|output_bfd
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Error in new object file. Don't change archive.  */
name|status
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|delete
condition|)
block|{
name|unlink
argument_list|(
name|output_name
argument_list|)
expr_stmt|;
name|status
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|preserve_dates
operator|&&
name|stat_status
operator|==
literal|0
condition|)
name|set_times
argument_list|(
name|output_name
argument_list|,
operator|&
name|buf
argument_list|)
expr_stmt|;
comment|/* Open the newly output file and attach to our list.  */
name|output_bfd
operator|=
name|bfd_openr
argument_list|(
name|output_name
argument_list|,
name|output_target
argument_list|)
expr_stmt|;
name|l
operator|->
name|obfd
operator|=
name|output_bfd
expr_stmt|;
operator|*
name|ptr
operator|=
name|output_bfd
expr_stmt|;
name|ptr
operator|=
operator|&
name|output_bfd
operator|->
name|next
expr_stmt|;
name|last_element
operator|=
name|this_element
expr_stmt|;
name|this_element
operator|=
name|bfd_openr_next_archived_file
argument_list|(
name|ibfd
argument_list|,
name|last_element
argument_list|)
expr_stmt|;
name|bfd_close
argument_list|(
name|last_element
argument_list|)
expr_stmt|;
block|}
block|}
operator|*
name|ptr
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_close
argument_list|(
name|obfd
argument_list|)
condition|)
name|RETURN_NONFATAL
argument_list|(
name|bfd_get_filename
argument_list|(
name|obfd
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_close
argument_list|(
name|ibfd
argument_list|)
condition|)
name|RETURN_NONFATAL
argument_list|(
name|bfd_get_filename
argument_list|(
name|ibfd
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Delete all the files that we opened.  */
for|for
control|(
name|l
operator|=
name|list
init|;
name|l
operator|!=
name|NULL
condition|;
name|l
operator|=
name|l
operator|->
name|next
control|)
block|{
if|if
condition|(
name|l
operator|->
name|obfd
operator|==
name|NULL
condition|)
name|rmdir
argument_list|(
name|l
operator|->
name|name
argument_list|)
expr_stmt|;
else|else
block|{
name|bfd_close
argument_list|(
name|l
operator|->
name|obfd
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|l
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
block|}
name|rmdir
argument_list|(
name|dir
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The top-level control.  */
end_comment

begin_function
specifier|static
name|void
name|copy_file
parameter_list|(
specifier|const
name|char
modifier|*
name|input_filename
parameter_list|,
specifier|const
name|char
modifier|*
name|output_filename
parameter_list|,
specifier|const
name|char
modifier|*
name|input_target
parameter_list|,
specifier|const
name|char
modifier|*
name|output_target
parameter_list|)
block|{
name|bfd
modifier|*
name|ibfd
decl_stmt|;
name|char
modifier|*
modifier|*
name|obj_matching
decl_stmt|;
name|char
modifier|*
modifier|*
name|core_matching
decl_stmt|;
if|if
condition|(
name|get_file_size
argument_list|(
name|input_filename
argument_list|)
operator|<
literal|1
condition|)
block|{
name|status
operator|=
literal|1
expr_stmt|;
return|return;
block|}
comment|/* To allow us to do "strip *" without dying on the first      non-object file, failures are nonfatal.  */
name|ibfd
operator|=
name|bfd_openr
argument_list|(
name|input_filename
argument_list|,
name|input_target
argument_list|)
expr_stmt|;
if|if
condition|(
name|ibfd
operator|==
name|NULL
condition|)
name|RETURN_NONFATAL
argument_list|(
name|input_filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_check_format
argument_list|(
name|ibfd
argument_list|,
name|bfd_archive
argument_list|)
condition|)
block|{
name|bfd
modifier|*
name|obfd
decl_stmt|;
comment|/* bfd_get_target does not return the correct value until          bfd_check_format succeeds.  */
if|if
condition|(
name|output_target
operator|==
name|NULL
condition|)
name|output_target
operator|=
name|bfd_get_target
argument_list|(
name|ibfd
argument_list|)
expr_stmt|;
name|obfd
operator|=
name|bfd_openw
argument_list|(
name|output_filename
argument_list|,
name|output_target
argument_list|)
expr_stmt|;
if|if
condition|(
name|obfd
operator|==
name|NULL
condition|)
name|RETURN_NONFATAL
argument_list|(
name|output_filename
argument_list|)
expr_stmt|;
name|copy_archive
argument_list|(
name|ibfd
argument_list|,
name|obfd
argument_list|,
name|output_target
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bfd_check_format_matches
argument_list|(
name|ibfd
argument_list|,
name|bfd_object
argument_list|,
operator|&
name|obj_matching
argument_list|)
condition|)
block|{
name|bfd
modifier|*
name|obfd
decl_stmt|;
name|bfd_boolean
name|delete
decl_stmt|;
name|do_copy
label|:
comment|/* bfd_get_target does not return the correct value until          bfd_check_format succeeds.  */
if|if
condition|(
name|output_target
operator|==
name|NULL
condition|)
name|output_target
operator|=
name|bfd_get_target
argument_list|(
name|ibfd
argument_list|)
expr_stmt|;
name|obfd
operator|=
name|bfd_openw
argument_list|(
name|output_filename
argument_list|,
name|output_target
argument_list|)
expr_stmt|;
if|if
condition|(
name|obfd
operator|==
name|NULL
condition|)
name|RETURN_NONFATAL
argument_list|(
name|output_filename
argument_list|)
expr_stmt|;
name|delete
operator|=
operator|!
name|copy_object
argument_list|(
name|ibfd
argument_list|,
name|obfd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_close
argument_list|(
name|obfd
argument_list|)
condition|)
name|RETURN_NONFATAL
argument_list|(
name|output_filename
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_close
argument_list|(
name|ibfd
argument_list|)
condition|)
name|RETURN_NONFATAL
argument_list|(
name|input_filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|delete
condition|)
block|{
name|unlink
argument_list|(
name|output_filename
argument_list|)
expr_stmt|;
name|status
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
name|bfd_error_type
name|obj_error
init|=
name|bfd_get_error
argument_list|()
decl_stmt|;
name|bfd_error_type
name|core_error
decl_stmt|;
if|if
condition|(
name|bfd_check_format_matches
argument_list|(
name|ibfd
argument_list|,
name|bfd_core
argument_list|,
operator|&
name|core_matching
argument_list|)
condition|)
block|{
comment|/* This probably can't happen..  */
if|if
condition|(
name|obj_error
operator|==
name|bfd_error_file_ambiguously_recognized
condition|)
name|free
argument_list|(
name|obj_matching
argument_list|)
expr_stmt|;
goto|goto
name|do_copy
goto|;
block|}
name|core_error
operator|=
name|bfd_get_error
argument_list|()
expr_stmt|;
comment|/* Report the object error in preference to the core error.  */
if|if
condition|(
name|obj_error
operator|!=
name|core_error
condition|)
name|bfd_set_error
argument_list|(
name|obj_error
argument_list|)
expr_stmt|;
name|bfd_nonfatal
argument_list|(
name|input_filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|obj_error
operator|==
name|bfd_error_file_ambiguously_recognized
condition|)
block|{
name|list_matching_formats
argument_list|(
name|obj_matching
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|obj_matching
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|core_error
operator|==
name|bfd_error_file_ambiguously_recognized
condition|)
block|{
name|list_matching_formats
argument_list|(
name|core_matching
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|core_matching
argument_list|)
expr_stmt|;
block|}
name|status
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Add a name to the section renaming list.  */
end_comment

begin_function
specifier|static
name|void
name|add_section_rename
parameter_list|(
specifier|const
name|char
modifier|*
name|old_name
parameter_list|,
specifier|const
name|char
modifier|*
name|new_name
parameter_list|,
name|flagword
name|flags
parameter_list|)
block|{
name|section_rename
modifier|*
name|rename
decl_stmt|;
comment|/* Check for conflicts first.  */
for|for
control|(
name|rename
operator|=
name|section_rename_list
init|;
name|rename
operator|!=
name|NULL
condition|;
name|rename
operator|=
name|rename
operator|->
name|next
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|rename
operator|->
name|old_name
argument_list|,
name|old_name
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Silently ignore duplicate definitions.  */
if|if
condition|(
name|strcmp
argument_list|(
name|rename
operator|->
name|new_name
argument_list|,
name|new_name
argument_list|)
operator|==
literal|0
operator|&&
name|rename
operator|->
name|flags
operator|==
name|flags
condition|)
return|return;
name|fatal
argument_list|(
name|_
argument_list|(
literal|"Multiple renames of section %s"
argument_list|)
argument_list|,
name|old_name
argument_list|)
expr_stmt|;
block|}
name|rename
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|rename
argument_list|)
argument_list|)
expr_stmt|;
name|rename
operator|->
name|old_name
operator|=
name|old_name
expr_stmt|;
name|rename
operator|->
name|new_name
operator|=
name|new_name
expr_stmt|;
name|rename
operator|->
name|flags
operator|=
name|flags
expr_stmt|;
name|rename
operator|->
name|next
operator|=
name|section_rename_list
expr_stmt|;
name|section_rename_list
operator|=
name|rename
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Check the section rename list for a new name of the input section    ISECTION.  Return the new name if one is found.    Also set RETURNED_FLAGS to the flags to be used for this section.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|find_section_rename
parameter_list|(
name|bfd
modifier|*
name|ibfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|sec_ptr
name|isection
parameter_list|,
name|flagword
modifier|*
name|returned_flags
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|old_name
init|=
name|bfd_section_name
argument_list|(
name|ibfd
argument_list|,
name|isection
argument_list|)
decl_stmt|;
name|section_rename
modifier|*
name|rename
decl_stmt|;
comment|/* Default to using the flags of the input section.  */
operator|*
name|returned_flags
operator|=
name|bfd_get_section_flags
argument_list|(
name|ibfd
argument_list|,
name|isection
argument_list|)
expr_stmt|;
for|for
control|(
name|rename
operator|=
name|section_rename_list
init|;
name|rename
operator|!=
name|NULL
condition|;
name|rename
operator|=
name|rename
operator|->
name|next
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|rename
operator|->
name|old_name
argument_list|,
name|old_name
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|rename
operator|->
name|flags
operator|!=
operator|(
name|flagword
operator|)
operator|-
literal|1
condition|)
operator|*
name|returned_flags
operator|=
name|rename
operator|->
name|flags
expr_stmt|;
return|return
name|rename
operator|->
name|new_name
return|;
block|}
return|return
name|old_name
return|;
block|}
end_function

begin_comment
comment|/* Create a section in OBFD with the same    name and attributes as ISECTION in IBFD.  */
end_comment

begin_function
specifier|static
name|void
name|setup_section
parameter_list|(
name|bfd
modifier|*
name|ibfd
parameter_list|,
name|sec_ptr
name|isection
parameter_list|,
name|void
modifier|*
name|obfdarg
parameter_list|)
block|{
name|bfd
modifier|*
name|obfd
init|=
name|obfdarg
decl_stmt|;
name|struct
name|section_list
modifier|*
name|p
decl_stmt|;
name|sec_ptr
name|osection
decl_stmt|;
name|bfd_size_type
name|size
decl_stmt|;
name|bfd_vma
name|vma
decl_stmt|;
name|bfd_vma
name|lma
decl_stmt|;
name|flagword
name|flags
decl_stmt|;
specifier|const
name|char
modifier|*
name|err
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|prefix
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|is_strip_section
argument_list|(
name|ibfd
argument_list|,
name|isection
argument_list|)
condition|)
return|return;
name|p
operator|=
name|find_section_list
argument_list|(
name|bfd_section_name
argument_list|(
name|ibfd
argument_list|,
name|isection
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
name|p
operator|->
name|used
operator|=
name|TRUE
expr_stmt|;
comment|/* Get the, possibly new, name of the output section.  */
name|name
operator|=
name|find_section_rename
argument_list|(
name|ibfd
argument_list|,
name|isection
argument_list|,
operator|&
name|flags
argument_list|)
expr_stmt|;
comment|/* Prefix sections.  */
if|if
condition|(
operator|(
name|prefix_alloc_sections_string
operator|)
operator|&&
operator|(
name|bfd_get_section_flags
argument_list|(
name|ibfd
argument_list|,
name|isection
argument_list|)
operator|&
name|SEC_ALLOC
operator|)
condition|)
name|prefix
operator|=
name|prefix_alloc_sections_string
expr_stmt|;
elseif|else
if|if
condition|(
name|prefix_sections_string
condition|)
name|prefix
operator|=
name|prefix_sections_string
expr_stmt|;
if|if
condition|(
name|prefix
condition|)
block|{
name|char
modifier|*
name|n
decl_stmt|;
name|n
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|prefix
argument_list|)
operator|+
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|n
argument_list|,
name|prefix
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|n
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|name
operator|=
name|n
expr_stmt|;
block|}
name|osection
operator|=
name|bfd_make_section_anyway
argument_list|(
name|obfd
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|osection
operator|==
name|NULL
condition|)
block|{
name|err
operator|=
name|_
argument_list|(
literal|"making"
argument_list|)
expr_stmt|;
goto|goto
name|loser
goto|;
block|}
name|size
operator|=
name|bfd_section_size
argument_list|(
name|ibfd
argument_list|,
name|isection
argument_list|)
expr_stmt|;
if|if
condition|(
name|copy_byte
operator|>=
literal|0
condition|)
name|size
operator|=
operator|(
name|size
operator|+
name|interleave
operator|-
literal|1
operator|)
operator|/
name|interleave
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_set_section_size
argument_list|(
name|obfd
argument_list|,
name|osection
argument_list|,
name|size
argument_list|)
condition|)
block|{
name|err
operator|=
name|_
argument_list|(
literal|"size"
argument_list|)
expr_stmt|;
goto|goto
name|loser
goto|;
block|}
name|vma
operator|=
name|bfd_section_vma
argument_list|(
name|ibfd
argument_list|,
name|isection
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
operator|&&
name|p
operator|->
name|change_vma
operator|==
name|CHANGE_MODIFY
condition|)
name|vma
operator|+=
name|p
operator|->
name|vma_val
expr_stmt|;
elseif|else
if|if
condition|(
name|p
operator|!=
name|NULL
operator|&&
name|p
operator|->
name|change_vma
operator|==
name|CHANGE_SET
condition|)
name|vma
operator|=
name|p
operator|->
name|vma_val
expr_stmt|;
else|else
name|vma
operator|+=
name|change_section_address
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_set_section_vma
argument_list|(
name|obfd
argument_list|,
name|osection
argument_list|,
name|vma
argument_list|)
condition|)
block|{
name|err
operator|=
name|_
argument_list|(
literal|"vma"
argument_list|)
expr_stmt|;
goto|goto
name|loser
goto|;
block|}
name|lma
operator|=
name|isection
operator|->
name|lma
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|!=
name|NULL
operator|)
operator|&&
name|p
operator|->
name|change_lma
operator|!=
name|CHANGE_IGNORE
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|change_lma
operator|==
name|CHANGE_MODIFY
condition|)
name|lma
operator|+=
name|p
operator|->
name|lma_val
expr_stmt|;
elseif|else
if|if
condition|(
name|p
operator|->
name|change_lma
operator|==
name|CHANGE_SET
condition|)
name|lma
operator|=
name|p
operator|->
name|lma_val
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
else|else
name|lma
operator|+=
name|change_section_address
expr_stmt|;
name|osection
operator|->
name|lma
operator|=
name|lma
expr_stmt|;
comment|/* FIXME: This is probably not enough.  If we change the LMA we      may have to recompute the header for the file as well.  */
if|if
condition|(
operator|!
name|bfd_set_section_alignment
argument_list|(
name|obfd
argument_list|,
name|osection
argument_list|,
name|bfd_section_alignment
argument_list|(
name|ibfd
argument_list|,
name|isection
argument_list|)
argument_list|)
condition|)
block|{
name|err
operator|=
name|_
argument_list|(
literal|"alignment"
argument_list|)
expr_stmt|;
goto|goto
name|loser
goto|;
block|}
if|if
condition|(
name|p
operator|!=
name|NULL
operator|&&
name|p
operator|->
name|set_flags
condition|)
name|flags
operator|=
name|p
operator|->
name|flags
operator||
operator|(
name|flags
operator|&
operator|(
name|SEC_HAS_CONTENTS
operator||
name|SEC_RELOC
operator|)
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strip_symbols
operator|==
name|STRIP_NONDEBUG
operator|&&
operator|(
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|!=
literal|0
condition|)
block|{
name|flags
operator|&=
operator|~
operator|(
name|SEC_HAS_CONTENTS
operator||
name|SEC_LOAD
operator|)
expr_stmt|;
if|if
condition|(
name|obfd
operator|->
name|xvec
operator|->
name|flavour
operator|==
name|bfd_target_elf_flavour
condition|)
name|elf_section_type
argument_list|(
name|osection
argument_list|)
operator|=
name|SHT_NOBITS
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|bfd_set_section_flags
argument_list|(
name|obfd
argument_list|,
name|osection
argument_list|,
name|flags
argument_list|)
condition|)
block|{
name|err
operator|=
name|_
argument_list|(
literal|"flags"
argument_list|)
expr_stmt|;
goto|goto
name|loser
goto|;
block|}
comment|/* Copy merge entity size.  */
name|osection
operator|->
name|entsize
operator|=
name|isection
operator|->
name|entsize
expr_stmt|;
comment|/* This used to be mangle_section; we do here to avoid using      bfd_get_section_by_name since some formats allow multiple      sections with the same name.  */
name|isection
operator|->
name|output_section
operator|=
name|osection
expr_stmt|;
name|isection
operator|->
name|output_offset
operator|=
literal|0
expr_stmt|;
comment|/* Allow the BFD backend to copy any private data it understands      from the input section to the output section.  */
if|if
condition|(
name|bfd_get_flavour
argument_list|(
name|ibfd
argument_list|)
operator|==
name|bfd_target_elf_flavour
operator|&&
name|strip_symbols
operator|==
name|STRIP_NONDEBUG
condition|)
comment|/* Do not copy the private data when creating an ELF format        debug info file.  We do not want the program headers.  */
empty_stmt|;
elseif|else
if|if
condition|(
operator|!
name|bfd_copy_private_section_data
argument_list|(
name|ibfd
argument_list|,
name|isection
argument_list|,
name|obfd
argument_list|,
name|osection
argument_list|)
condition|)
block|{
name|err
operator|=
name|_
argument_list|(
literal|"private data"
argument_list|)
expr_stmt|;
goto|goto
name|loser
goto|;
block|}
comment|/* All went well.  */
return|return;
name|loser
label|:
name|non_fatal
argument_list|(
name|_
argument_list|(
literal|"%s: section `%s': error in %s: %s"
argument_list|)
argument_list|,
name|bfd_get_filename
argument_list|(
name|ibfd
argument_list|)
argument_list|,
name|bfd_section_name
argument_list|(
name|ibfd
argument_list|,
name|isection
argument_list|)
argument_list|,
name|err
argument_list|,
name|bfd_errmsg
argument_list|(
name|bfd_get_error
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|status
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Copy the data of input section ISECTION of IBFD    to an output section with the same name in OBFD.    If stripping then don't copy any relocation info.  */
end_comment

begin_function
specifier|static
name|void
name|copy_section
parameter_list|(
name|bfd
modifier|*
name|ibfd
parameter_list|,
name|sec_ptr
name|isection
parameter_list|,
name|void
modifier|*
name|obfdarg
parameter_list|)
block|{
name|bfd
modifier|*
name|obfd
init|=
name|obfdarg
decl_stmt|;
name|struct
name|section_list
modifier|*
name|p
decl_stmt|;
name|arelent
modifier|*
modifier|*
name|relpp
decl_stmt|;
name|long
name|relcount
decl_stmt|;
name|sec_ptr
name|osection
decl_stmt|;
name|bfd_size_type
name|size
decl_stmt|;
name|long
name|relsize
decl_stmt|;
name|flagword
name|flags
decl_stmt|;
comment|/* If we have already failed earlier on,      do not keep on generating complaints now.  */
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
return|return;
if|if
condition|(
name|is_strip_section
argument_list|(
name|ibfd
argument_list|,
name|isection
argument_list|)
condition|)
return|return;
name|flags
operator|=
name|bfd_get_section_flags
argument_list|(
name|ibfd
argument_list|,
name|isection
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|SEC_GROUP
operator|)
operator|!=
literal|0
condition|)
return|return;
name|osection
operator|=
name|isection
operator|->
name|output_section
expr_stmt|;
name|size
operator|=
name|bfd_get_section_size_before_reloc
argument_list|(
name|isection
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|==
literal|0
operator|||
name|osection
operator|==
literal|0
condition|)
return|return;
name|p
operator|=
name|find_section_list
argument_list|(
name|bfd_get_section_name
argument_list|(
name|ibfd
argument_list|,
name|isection
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/* Core files do not need to be relocated.  */
if|if
condition|(
name|bfd_get_format
argument_list|(
name|obfd
argument_list|)
operator|==
name|bfd_core
condition|)
name|relsize
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|relsize
operator|=
name|bfd_get_reloc_upper_bound
argument_list|(
name|ibfd
argument_list|,
name|isection
argument_list|)
expr_stmt|;
if|if
condition|(
name|relsize
operator|<
literal|0
condition|)
block|{
comment|/* Do not complain if the target does not support relocations.  */
if|if
condition|(
name|relsize
operator|==
operator|-
literal|1
operator|&&
name|bfd_get_error
argument_list|()
operator|==
name|bfd_error_invalid_operation
condition|)
name|relsize
operator|=
literal|0
expr_stmt|;
else|else
name|RETURN_NONFATAL
argument_list|(
name|bfd_get_filename
argument_list|(
name|ibfd
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|relsize
operator|==
literal|0
condition|)
name|bfd_set_reloc
argument_list|(
name|obfd
argument_list|,
name|osection
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
block|{
name|relpp
operator|=
name|xmalloc
argument_list|(
name|relsize
argument_list|)
expr_stmt|;
name|relcount
operator|=
name|bfd_canonicalize_reloc
argument_list|(
name|ibfd
argument_list|,
name|isection
argument_list|,
name|relpp
argument_list|,
name|isympp
argument_list|)
expr_stmt|;
if|if
condition|(
name|relcount
operator|<
literal|0
condition|)
name|RETURN_NONFATAL
argument_list|(
name|bfd_get_filename
argument_list|(
name|ibfd
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|strip_symbols
operator|==
name|STRIP_ALL
condition|)
block|{
comment|/* Remove relocations which are not in 	     keep_strip_specific_list.  */
name|arelent
modifier|*
modifier|*
name|temp_relpp
decl_stmt|;
name|long
name|temp_relcount
init|=
literal|0
decl_stmt|;
name|long
name|i
decl_stmt|;
name|temp_relpp
operator|=
name|xmalloc
argument_list|(
name|relsize
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|relcount
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|is_specified_symbol
argument_list|(
name|bfd_asymbol_name
argument_list|(
operator|*
name|relpp
index|[
name|i
index|]
operator|->
name|sym_ptr_ptr
argument_list|)
argument_list|,
name|keep_specific_list
argument_list|)
condition|)
name|temp_relpp
index|[
name|temp_relcount
operator|++
index|]
operator|=
name|relpp
index|[
name|i
index|]
expr_stmt|;
name|relcount
operator|=
name|temp_relcount
expr_stmt|;
name|free
argument_list|(
name|relpp
argument_list|)
expr_stmt|;
name|relpp
operator|=
name|temp_relpp
expr_stmt|;
block|}
name|bfd_set_reloc
argument_list|(
name|obfd
argument_list|,
name|osection
argument_list|,
name|relcount
operator|==
literal|0
condition|?
name|NULL
else|:
name|relpp
argument_list|,
name|relcount
argument_list|)
expr_stmt|;
if|if
condition|(
name|relcount
operator|==
literal|0
condition|)
name|free
argument_list|(
name|relpp
argument_list|)
expr_stmt|;
block|}
name|isection
operator|->
name|_cooked_size
operator|=
name|isection
operator|->
name|_raw_size
expr_stmt|;
name|isection
operator|->
name|reloc_done
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|bfd_get_section_flags
argument_list|(
name|ibfd
argument_list|,
name|isection
argument_list|)
operator|&
name|SEC_HAS_CONTENTS
operator|&&
name|bfd_get_section_flags
argument_list|(
name|obfd
argument_list|,
name|osection
argument_list|)
operator|&
name|SEC_HAS_CONTENTS
condition|)
block|{
name|void
modifier|*
name|memhunk
init|=
name|xmalloc
argument_list|(
name|size
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|bfd_get_section_contents
argument_list|(
name|ibfd
argument_list|,
name|isection
argument_list|,
name|memhunk
argument_list|,
literal|0
argument_list|,
name|size
argument_list|)
condition|)
name|RETURN_NONFATAL
argument_list|(
name|bfd_get_filename
argument_list|(
name|ibfd
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|copy_byte
operator|>=
literal|0
condition|)
block|{
comment|/* Keep only every `copy_byte'th byte in MEMHUNK.  */
name|char
modifier|*
name|from
init|=
operator|(
name|char
operator|*
operator|)
name|memhunk
operator|+
name|copy_byte
decl_stmt|;
name|char
modifier|*
name|to
init|=
name|memhunk
decl_stmt|;
name|char
modifier|*
name|end
init|=
operator|(
name|char
operator|*
operator|)
name|memhunk
operator|+
name|size
decl_stmt|;
for|for
control|(
init|;
name|from
operator|<
name|end
condition|;
name|from
operator|+=
name|interleave
control|)
operator|*
name|to
operator|++
operator|=
operator|*
name|from
expr_stmt|;
name|size
operator|=
operator|(
name|size
operator|+
name|interleave
operator|-
literal|1
operator|-
name|copy_byte
operator|)
operator|/
name|interleave
expr_stmt|;
name|osection
operator|->
name|lma
operator|/=
name|interleave
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|bfd_set_section_contents
argument_list|(
name|obfd
argument_list|,
name|osection
argument_list|,
name|memhunk
argument_list|,
literal|0
argument_list|,
name|size
argument_list|)
condition|)
name|RETURN_NONFATAL
argument_list|(
name|bfd_get_filename
argument_list|(
name|obfd
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|memhunk
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p
operator|!=
name|NULL
operator|&&
name|p
operator|->
name|set_flags
operator|&&
operator|(
name|p
operator|->
name|flags
operator|&
name|SEC_HAS_CONTENTS
operator|)
operator|!=
literal|0
condition|)
block|{
name|void
modifier|*
name|memhunk
init|=
name|xmalloc
argument_list|(
name|size
argument_list|)
decl_stmt|;
comment|/* We don't permit the user to turn off the SEC_HAS_CONTENTS 	 flag--they can just remove the section entirely and add it 	 back again.  However, we do permit them to turn on the 	 SEC_HAS_CONTENTS flag, and take it to mean that the section 	 contents should be zeroed out.  */
name|memset
argument_list|(
name|memhunk
argument_list|,
literal|0
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_set_section_contents
argument_list|(
name|obfd
argument_list|,
name|osection
argument_list|,
name|memhunk
argument_list|,
literal|0
argument_list|,
name|size
argument_list|)
condition|)
name|RETURN_NONFATAL
argument_list|(
name|bfd_get_filename
argument_list|(
name|obfd
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|memhunk
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Get all the sections.  This is used when --gap-fill or --pad-to is    used.  */
end_comment

begin_function
specifier|static
name|void
name|get_sections
parameter_list|(
name|bfd
modifier|*
name|obfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|asection
modifier|*
name|osection
parameter_list|,
name|void
modifier|*
name|secppparg
parameter_list|)
block|{
name|asection
modifier|*
modifier|*
modifier|*
name|secppp
init|=
name|secppparg
decl_stmt|;
operator|*
operator|*
name|secppp
operator|=
name|osection
expr_stmt|;
operator|++
operator|(
operator|*
name|secppp
operator|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Sort sections by VMA.  This is called via qsort, and is used when    --gap-fill or --pad-to is used.  We force non loadable or empty    sections to the front, where they are easier to ignore.  */
end_comment

begin_function
specifier|static
name|int
name|compare_section_lma
parameter_list|(
specifier|const
name|void
modifier|*
name|arg1
parameter_list|,
specifier|const
name|void
modifier|*
name|arg2
parameter_list|)
block|{
specifier|const
name|asection
modifier|*
specifier|const
modifier|*
name|sec1
init|=
name|arg1
decl_stmt|;
specifier|const
name|asection
modifier|*
specifier|const
modifier|*
name|sec2
init|=
name|arg2
decl_stmt|;
name|flagword
name|flags1
decl_stmt|,
name|flags2
decl_stmt|;
comment|/* Sort non loadable sections to the front.  */
name|flags1
operator|=
operator|(
operator|*
name|sec1
operator|)
operator|->
name|flags
expr_stmt|;
name|flags2
operator|=
operator|(
operator|*
name|sec2
operator|)
operator|->
name|flags
expr_stmt|;
if|if
condition|(
operator|(
name|flags1
operator|&
name|SEC_HAS_CONTENTS
operator|)
operator|==
literal|0
operator|||
operator|(
name|flags1
operator|&
name|SEC_LOAD
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|flags2
operator|&
name|SEC_HAS_CONTENTS
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|flags2
operator|&
name|SEC_LOAD
operator|)
operator|!=
literal|0
condition|)
return|return
operator|-
literal|1
return|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|flags2
operator|&
name|SEC_HAS_CONTENTS
operator|)
operator|==
literal|0
operator|||
operator|(
name|flags2
operator|&
name|SEC_LOAD
operator|)
operator|==
literal|0
condition|)
return|return
literal|1
return|;
block|}
comment|/* Sort sections by LMA.  */
if|if
condition|(
operator|(
operator|*
name|sec1
operator|)
operator|->
name|lma
operator|>
operator|(
operator|*
name|sec2
operator|)
operator|->
name|lma
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
operator|(
operator|*
name|sec1
operator|)
operator|->
name|lma
operator|<
operator|(
operator|*
name|sec2
operator|)
operator|->
name|lma
condition|)
return|return
operator|-
literal|1
return|;
comment|/* Sort sections with the same LMA by size.  */
if|if
condition|(
operator|(
operator|*
name|sec1
operator|)
operator|->
name|_raw_size
operator|>
operator|(
operator|*
name|sec2
operator|)
operator|->
name|_raw_size
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
operator|(
operator|*
name|sec1
operator|)
operator|->
name|_raw_size
operator|<
operator|(
operator|*
name|sec2
operator|)
operator|->
name|_raw_size
condition|)
return|return
operator|-
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Mark all the symbols which will be used in output relocations with    the BSF_KEEP flag so that those symbols will not be stripped.     Ignore relocations which will not appear in the output file.  */
end_comment

begin_function
specifier|static
name|void
name|mark_symbols_used_in_relocations
parameter_list|(
name|bfd
modifier|*
name|ibfd
parameter_list|,
name|sec_ptr
name|isection
parameter_list|,
name|void
modifier|*
name|symbolsarg
parameter_list|)
block|{
name|asymbol
modifier|*
modifier|*
name|symbols
init|=
name|symbolsarg
decl_stmt|;
name|long
name|relsize
decl_stmt|;
name|arelent
modifier|*
modifier|*
name|relpp
decl_stmt|;
name|long
name|relcount
decl_stmt|,
name|i
decl_stmt|;
comment|/* Ignore an input section with no corresponding output section.  */
if|if
condition|(
name|isection
operator|->
name|output_section
operator|==
name|NULL
condition|)
return|return;
name|relsize
operator|=
name|bfd_get_reloc_upper_bound
argument_list|(
name|ibfd
argument_list|,
name|isection
argument_list|)
expr_stmt|;
if|if
condition|(
name|relsize
operator|<
literal|0
condition|)
block|{
comment|/* Do not complain if the target does not support relocations.  */
if|if
condition|(
name|relsize
operator|==
operator|-
literal|1
operator|&&
name|bfd_get_error
argument_list|()
operator|==
name|bfd_error_invalid_operation
condition|)
return|return;
name|bfd_fatal
argument_list|(
name|bfd_get_filename
argument_list|(
name|ibfd
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|relsize
operator|==
literal|0
condition|)
return|return;
name|relpp
operator|=
name|xmalloc
argument_list|(
name|relsize
argument_list|)
expr_stmt|;
name|relcount
operator|=
name|bfd_canonicalize_reloc
argument_list|(
name|ibfd
argument_list|,
name|isection
argument_list|,
name|relpp
argument_list|,
name|symbols
argument_list|)
expr_stmt|;
if|if
condition|(
name|relcount
operator|<
literal|0
condition|)
name|bfd_fatal
argument_list|(
name|bfd_get_filename
argument_list|(
name|ibfd
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Examine each symbol used in a relocation.  If it's not one of the      special bfd section symbols, then mark it with BSF_KEEP.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|relcount
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|relpp
index|[
name|i
index|]
operator|->
name|sym_ptr_ptr
operator|!=
name|bfd_com_section_ptr
operator|->
name|symbol
operator|&&
operator|*
name|relpp
index|[
name|i
index|]
operator|->
name|sym_ptr_ptr
operator|!=
name|bfd_abs_section_ptr
operator|->
name|symbol
operator|&&
operator|*
name|relpp
index|[
name|i
index|]
operator|->
name|sym_ptr_ptr
operator|!=
name|bfd_und_section_ptr
operator|->
name|symbol
condition|)
operator|(
operator|*
name|relpp
index|[
name|i
index|]
operator|->
name|sym_ptr_ptr
operator|)
operator|->
name|flags
operator||=
name|BSF_KEEP
expr_stmt|;
block|}
if|if
condition|(
name|relpp
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|relpp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Write out debugging information.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|write_debugging_info
parameter_list|(
name|bfd
modifier|*
name|obfd
parameter_list|,
name|void
modifier|*
name|dhandle
parameter_list|,
name|long
modifier|*
name|symcountp
name|ATTRIBUTE_UNUSED
parameter_list|,
name|asymbol
modifier|*
modifier|*
modifier|*
name|symppp
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
if|if
condition|(
name|bfd_get_flavour
argument_list|(
name|obfd
argument_list|)
operator|==
name|bfd_target_ieee_flavour
condition|)
return|return
name|write_ieee_debugging_info
argument_list|(
name|obfd
argument_list|,
name|dhandle
argument_list|)
return|;
if|if
condition|(
name|bfd_get_flavour
argument_list|(
name|obfd
argument_list|)
operator|==
name|bfd_target_coff_flavour
operator|||
name|bfd_get_flavour
argument_list|(
name|obfd
argument_list|)
operator|==
name|bfd_target_elf_flavour
condition|)
block|{
name|bfd_byte
modifier|*
name|syms
decl_stmt|,
modifier|*
name|strings
decl_stmt|;
name|bfd_size_type
name|symsize
decl_stmt|,
name|stringsize
decl_stmt|;
name|asection
modifier|*
name|stabsec
decl_stmt|,
modifier|*
name|stabstrsec
decl_stmt|;
if|if
condition|(
operator|!
name|write_stabs_in_sections_debugging_info
argument_list|(
name|obfd
argument_list|,
name|dhandle
argument_list|,
operator|&
name|syms
argument_list|,
operator|&
name|symsize
argument_list|,
operator|&
name|strings
argument_list|,
operator|&
name|stringsize
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|stabsec
operator|=
name|bfd_make_section
argument_list|(
name|obfd
argument_list|,
literal|".stab"
argument_list|)
expr_stmt|;
name|stabstrsec
operator|=
name|bfd_make_section
argument_list|(
name|obfd
argument_list|,
literal|".stabstr"
argument_list|)
expr_stmt|;
if|if
condition|(
name|stabsec
operator|==
name|NULL
operator|||
name|stabstrsec
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_size
argument_list|(
name|obfd
argument_list|,
name|stabsec
argument_list|,
name|symsize
argument_list|)
operator|||
operator|!
name|bfd_set_section_size
argument_list|(
name|obfd
argument_list|,
name|stabstrsec
argument_list|,
name|stringsize
argument_list|)
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|obfd
argument_list|,
name|stabsec
argument_list|,
literal|2
argument_list|)
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|obfd
argument_list|,
name|stabstrsec
argument_list|,
literal|0
argument_list|)
operator|||
operator|!
name|bfd_set_section_flags
argument_list|(
name|obfd
argument_list|,
name|stabsec
argument_list|,
operator|(
name|SEC_HAS_CONTENTS
operator||
name|SEC_READONLY
operator||
name|SEC_DEBUGGING
operator|)
argument_list|)
operator|||
operator|!
name|bfd_set_section_flags
argument_list|(
name|obfd
argument_list|,
name|stabstrsec
argument_list|,
operator|(
name|SEC_HAS_CONTENTS
operator||
name|SEC_READONLY
operator||
name|SEC_DEBUGGING
operator|)
argument_list|)
condition|)
block|{
name|non_fatal
argument_list|(
name|_
argument_list|(
literal|"%s: can't create debugging section: %s"
argument_list|)
argument_list|,
name|bfd_get_filename
argument_list|(
name|obfd
argument_list|)
argument_list|,
name|bfd_errmsg
argument_list|(
name|bfd_get_error
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* We can get away with setting the section contents now because          the next thing the caller is going to do is copy over the          real sections.  We may someday have to split the contents          setting out of this function.  */
if|if
condition|(
operator|!
name|bfd_set_section_contents
argument_list|(
name|obfd
argument_list|,
name|stabsec
argument_list|,
name|syms
argument_list|,
literal|0
argument_list|,
name|symsize
argument_list|)
operator|||
operator|!
name|bfd_set_section_contents
argument_list|(
name|obfd
argument_list|,
name|stabstrsec
argument_list|,
name|strings
argument_list|,
literal|0
argument_list|,
name|stringsize
argument_list|)
condition|)
block|{
name|non_fatal
argument_list|(
name|_
argument_list|(
literal|"%s: can't set debugging section contents: %s"
argument_list|)
argument_list|,
name|bfd_get_filename
argument_list|(
name|obfd
argument_list|)
argument_list|,
name|bfd_errmsg
argument_list|(
name|bfd_get_error
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
return|return
name|TRUE
return|;
block|}
name|non_fatal
argument_list|(
name|_
argument_list|(
literal|"%s: don't know how to write debugging information for %s"
argument_list|)
argument_list|,
name|bfd_get_filename
argument_list|(
name|obfd
argument_list|)
argument_list|,
name|bfd_get_target
argument_list|(
name|obfd
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|strip_main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
name|char
modifier|*
name|input_target
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|output_target
init|=
name|NULL
decl_stmt|;
name|bfd_boolean
name|show_version
init|=
name|FALSE
decl_stmt|;
name|bfd_boolean
name|formats_info
init|=
name|FALSE
decl_stmt|;
name|int
name|c
decl_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|section_list
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|output_file
init|=
name|NULL
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getopt_long
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"I:O:F:K:N:R:o:sSpdgxXHhVvw"
argument_list|,
name|strip_options
argument_list|,
operator|(
name|int
operator|*
operator|)
literal|0
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'I'
case|:
name|input_target
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'O'
case|:
name|output_target
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'F'
case|:
name|input_target
operator|=
name|output_target
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'R'
case|:
name|p
operator|=
name|find_section_list
argument_list|(
name|optarg
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|p
operator|->
name|remove
operator|=
name|TRUE
expr_stmt|;
name|sections_removed
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|strip_symbols
operator|=
name|STRIP_ALL
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
case|case
literal|'g'
case|:
case|case
literal|'d'
case|:
comment|/* Historic BSD alias for -g.  Used by early NetBSD.  */
name|strip_symbols
operator|=
name|STRIP_DEBUG
expr_stmt|;
break|break;
case|case
name|OPTION_STRIP_UNNEEDED
case|:
name|strip_symbols
operator|=
name|STRIP_UNNEEDED
expr_stmt|;
break|break;
case|case
literal|'K'
case|:
name|add_specific_symbol
argument_list|(
name|optarg
argument_list|,
operator|&
name|keep_specific_list
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'N'
case|:
name|add_specific_symbol
argument_list|(
name|optarg
argument_list|,
operator|&
name|strip_specific_list
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
name|output_file
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|preserve_dates
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
name|discard_locals
operator|=
name|LOCALS_ALL
expr_stmt|;
break|break;
case|case
literal|'X'
case|:
name|discard_locals
operator|=
name|LOCALS_START_L
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
name|verbose
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'V'
case|:
name|show_version
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|OPTION_FORMATS_INFO
case|:
name|formats_info
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|OPTION_ONLY_KEEP_DEBUG
case|:
name|strip_symbols
operator|=
name|STRIP_NONDEBUG
expr_stmt|;
break|break;
case|case
literal|0
case|:
comment|/* We've been given a long option.  */
break|break;
case|case
literal|'w'
case|:
name|wildcard
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'H'
case|:
case|case
literal|'h'
case|:
name|strip_usage
argument_list|(
name|stdout
argument_list|,
literal|0
argument_list|)
expr_stmt|;
default|default:
name|strip_usage
argument_list|(
name|stderr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|formats_info
condition|)
block|{
name|display_info
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|show_version
condition|)
name|print_version
argument_list|(
literal|"strip"
argument_list|)
expr_stmt|;
comment|/* Default is to strip all symbols.  */
if|if
condition|(
name|strip_symbols
operator|==
name|STRIP_UNDEF
operator|&&
name|discard_locals
operator|==
name|LOCALS_UNDEF
operator|&&
name|strip_specific_list
operator|==
name|NULL
condition|)
name|strip_symbols
operator|=
name|STRIP_ALL
expr_stmt|;
if|if
condition|(
name|output_target
operator|==
name|NULL
condition|)
name|output_target
operator|=
name|input_target
expr_stmt|;
name|i
operator|=
name|optind
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|argc
operator|||
operator|(
name|output_file
operator|!=
name|NULL
operator|&&
operator|(
name|i
operator|+
literal|1
operator|)
operator|<
name|argc
operator|)
condition|)
name|strip_usage
argument_list|(
name|stderr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
name|int
name|hold_status
init|=
name|status
decl_stmt|;
name|struct
name|stat
name|statbuf
decl_stmt|;
name|char
modifier|*
name|tmpname
decl_stmt|;
if|if
condition|(
name|get_file_size
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
operator|<
literal|1
condition|)
continue|continue;
if|if
condition|(
name|preserve_dates
condition|)
comment|/* No need to check the return value of stat(). 	   It has already been checked in get_file_size().  */
name|stat
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
operator|&
name|statbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|output_file
operator|!=
name|NULL
condition|)
name|tmpname
operator|=
name|output_file
expr_stmt|;
else|else
name|tmpname
operator|=
name|make_tempname
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|status
operator|=
literal|0
expr_stmt|;
name|copy_file
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
name|tmpname
argument_list|,
name|input_target
argument_list|,
name|output_target
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|preserve_dates
condition|)
name|set_times
argument_list|(
name|tmpname
argument_list|,
operator|&
name|statbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|output_file
operator|==
name|NULL
condition|)
name|smart_rename
argument_list|(
name|tmpname
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|,
name|preserve_dates
argument_list|)
expr_stmt|;
name|status
operator|=
name|hold_status
expr_stmt|;
block|}
else|else
name|unlink
argument_list|(
name|tmpname
argument_list|)
expr_stmt|;
if|if
condition|(
name|output_file
operator|==
name|NULL
condition|)
name|free
argument_list|(
name|tmpname
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|copy_main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
name|char
modifier|*
name|binary_architecture
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|input_filename
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|output_filename
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|input_target
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|output_target
init|=
name|NULL
decl_stmt|;
name|bfd_boolean
name|show_version
init|=
name|FALSE
decl_stmt|;
name|bfd_boolean
name|change_warn
init|=
name|TRUE
decl_stmt|;
name|bfd_boolean
name|formats_info
init|=
name|FALSE
decl_stmt|;
name|int
name|c
decl_stmt|;
name|struct
name|section_list
modifier|*
name|p
decl_stmt|;
name|struct
name|stat
name|statbuf
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getopt_long
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"b:B:i:I:j:K:N:s:O:d:F:L:G:R:SpgxXHhVvW:w"
argument_list|,
name|copy_options
argument_list|,
operator|(
name|int
operator|*
operator|)
literal|0
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'b'
case|:
name|copy_byte
operator|=
name|atoi
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
if|if
condition|(
name|copy_byte
operator|<
literal|0
condition|)
name|fatal
argument_list|(
name|_
argument_list|(
literal|"byte number must be non-negative"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'B'
case|:
name|binary_architecture
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
name|interleave
operator|=
name|atoi
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
if|if
condition|(
name|interleave
operator|<
literal|1
condition|)
name|fatal
argument_list|(
name|_
argument_list|(
literal|"interleave must be positive"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'I'
case|:
case|case
literal|'s'
case|:
comment|/* "source" - 'I' is preferred */
name|input_target
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'O'
case|:
case|case
literal|'d'
case|:
comment|/* "destination" - 'O' is preferred */
name|output_target
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'F'
case|:
name|input_target
operator|=
name|output_target
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'j'
case|:
name|p
operator|=
name|find_section_list
argument_list|(
name|optarg
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|remove
condition|)
name|fatal
argument_list|(
name|_
argument_list|(
literal|"%s both copied and removed"
argument_list|)
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
name|p
operator|->
name|copy
operator|=
name|TRUE
expr_stmt|;
name|sections_copied
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'R'
case|:
name|p
operator|=
name|find_section_list
argument_list|(
name|optarg
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|copy
condition|)
name|fatal
argument_list|(
name|_
argument_list|(
literal|"%s both copied and removed"
argument_list|)
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
name|p
operator|->
name|remove
operator|=
name|TRUE
expr_stmt|;
name|sections_removed
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
name|strip_symbols
operator|=
name|STRIP_ALL
expr_stmt|;
break|break;
case|case
literal|'g'
case|:
name|strip_symbols
operator|=
name|STRIP_DEBUG
expr_stmt|;
break|break;
case|case
name|OPTION_STRIP_UNNEEDED
case|:
name|strip_symbols
operator|=
name|STRIP_UNNEEDED
expr_stmt|;
break|break;
case|case
name|OPTION_ONLY_KEEP_DEBUG
case|:
name|strip_symbols
operator|=
name|STRIP_NONDEBUG
expr_stmt|;
break|break;
case|case
name|OPTION_ADD_GNU_DEBUGLINK
case|:
name|gnu_debuglink_filename
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'K'
case|:
name|add_specific_symbol
argument_list|(
name|optarg
argument_list|,
operator|&
name|keep_specific_list
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'N'
case|:
name|add_specific_symbol
argument_list|(
name|optarg
argument_list|,
operator|&
name|strip_specific_list
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'L'
case|:
name|add_specific_symbol
argument_list|(
name|optarg
argument_list|,
operator|&
name|localize_specific_list
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'G'
case|:
name|add_specific_symbol
argument_list|(
name|optarg
argument_list|,
operator|&
name|keepglobal_specific_list
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'W'
case|:
name|add_specific_symbol
argument_list|(
name|optarg
argument_list|,
operator|&
name|weaken_specific_list
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|preserve_dates
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
name|wildcard
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
name|discard_locals
operator|=
name|LOCALS_ALL
expr_stmt|;
break|break;
case|case
literal|'X'
case|:
name|discard_locals
operator|=
name|LOCALS_START_L
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
name|verbose
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'V'
case|:
name|show_version
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|OPTION_FORMATS_INFO
case|:
name|formats_info
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|OPTION_WEAKEN
case|:
name|weaken
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|OPTION_ADD_SECTION
case|:
block|{
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
name|off_t
name|size
decl_stmt|;
name|struct
name|section_add
modifier|*
name|pa
decl_stmt|;
name|int
name|len
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|FILE
modifier|*
name|f
decl_stmt|;
name|s
operator|=
name|strchr
argument_list|(
name|optarg
argument_list|,
literal|'='
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
name|_
argument_list|(
literal|"bad format for %s"
argument_list|)
argument_list|,
literal|"--add-section"
argument_list|)
expr_stmt|;
name|size
operator|=
name|get_file_size
argument_list|(
name|s
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|<
literal|1
condition|)
break|break;
name|pa
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|section_add
argument_list|)
argument_list|)
expr_stmt|;
name|len
operator|=
name|s
operator|-
name|optarg
expr_stmt|;
name|name
operator|=
name|xmalloc
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|name
argument_list|,
name|optarg
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|name
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
name|pa
operator|->
name|name
operator|=
name|name
expr_stmt|;
name|pa
operator|->
name|filename
operator|=
name|s
operator|+
literal|1
expr_stmt|;
name|pa
operator|->
name|size
operator|=
name|size
expr_stmt|;
name|pa
operator|->
name|contents
operator|=
name|xmalloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|f
operator|=
name|fopen
argument_list|(
name|pa
operator|->
name|filename
argument_list|,
name|FOPEN_RB
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
name|_
argument_list|(
literal|"cannot open: %s: %s"
argument_list|)
argument_list|,
name|pa
operator|->
name|filename
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fread
argument_list|(
name|pa
operator|->
name|contents
argument_list|,
literal|1
argument_list|,
name|pa
operator|->
name|size
argument_list|,
name|f
argument_list|)
operator|==
literal|0
operator|||
name|ferror
argument_list|(
name|f
argument_list|)
condition|)
name|fatal
argument_list|(
name|_
argument_list|(
literal|"%s: fread failed"
argument_list|)
argument_list|,
name|pa
operator|->
name|filename
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|pa
operator|->
name|next
operator|=
name|add_sections
expr_stmt|;
name|add_sections
operator|=
name|pa
expr_stmt|;
block|}
break|break;
case|case
name|OPTION_CHANGE_START
case|:
name|change_start
operator|=
name|parse_vma
argument_list|(
name|optarg
argument_list|,
literal|"--change-start"
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPTION_CHANGE_SECTION_ADDRESS
case|:
case|case
name|OPTION_CHANGE_SECTION_LMA
case|:
case|case
name|OPTION_CHANGE_SECTION_VMA
case|:
block|{
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|len
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|option
init|=
name|NULL
decl_stmt|;
name|bfd_vma
name|val
decl_stmt|;
name|enum
name|change_action
name|what
init|=
name|CHANGE_IGNORE
decl_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
name|OPTION_CHANGE_SECTION_ADDRESS
case|:
name|option
operator|=
literal|"--change-section-address"
expr_stmt|;
break|break;
case|case
name|OPTION_CHANGE_SECTION_LMA
case|:
name|option
operator|=
literal|"--change-section-lma"
expr_stmt|;
break|break;
case|case
name|OPTION_CHANGE_SECTION_VMA
case|:
name|option
operator|=
literal|"--change-section-vma"
expr_stmt|;
break|break;
block|}
name|s
operator|=
name|strchr
argument_list|(
name|optarg
argument_list|,
literal|'='
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
block|{
name|s
operator|=
name|strchr
argument_list|(
name|optarg
argument_list|,
literal|'+'
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
block|{
name|s
operator|=
name|strchr
argument_list|(
name|optarg
argument_list|,
literal|'-'
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
name|_
argument_list|(
literal|"bad format for %s"
argument_list|)
argument_list|,
name|option
argument_list|)
expr_stmt|;
block|}
block|}
name|len
operator|=
name|s
operator|-
name|optarg
expr_stmt|;
name|name
operator|=
name|xmalloc
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|name
argument_list|,
name|optarg
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|name
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
name|p
operator|=
name|find_section_list
argument_list|(
name|name
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|val
operator|=
name|parse_vma
argument_list|(
name|s
operator|+
literal|1
argument_list|,
name|option
argument_list|)
expr_stmt|;
switch|switch
condition|(
operator|*
name|s
condition|)
block|{
case|case
literal|'='
case|:
name|what
operator|=
name|CHANGE_SET
expr_stmt|;
break|break;
case|case
literal|'-'
case|:
name|val
operator|=
operator|-
name|val
expr_stmt|;
comment|/* Drop through.  */
case|case
literal|'+'
case|:
name|what
operator|=
name|CHANGE_MODIFY
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|c
condition|)
block|{
case|case
name|OPTION_CHANGE_SECTION_ADDRESS
case|:
name|p
operator|->
name|change_vma
operator|=
name|what
expr_stmt|;
name|p
operator|->
name|vma_val
operator|=
name|val
expr_stmt|;
comment|/* Drop through.  */
case|case
name|OPTION_CHANGE_SECTION_LMA
case|:
name|p
operator|->
name|change_lma
operator|=
name|what
expr_stmt|;
name|p
operator|->
name|lma_val
operator|=
name|val
expr_stmt|;
break|break;
case|case
name|OPTION_CHANGE_SECTION_VMA
case|:
name|p
operator|->
name|change_vma
operator|=
name|what
expr_stmt|;
name|p
operator|->
name|vma_val
operator|=
name|val
expr_stmt|;
break|break;
block|}
block|}
break|break;
case|case
name|OPTION_CHANGE_ADDRESSES
case|:
name|change_section_address
operator|=
name|parse_vma
argument_list|(
name|optarg
argument_list|,
literal|"--change-addresses"
argument_list|)
expr_stmt|;
name|change_start
operator|=
name|change_section_address
expr_stmt|;
break|break;
case|case
name|OPTION_CHANGE_WARNINGS
case|:
name|change_warn
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|OPTION_CHANGE_LEADING_CHAR
case|:
name|change_leading_char
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|OPTION_DEBUGGING
case|:
name|convert_debugging
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|OPTION_GAP_FILL
case|:
block|{
name|bfd_vma
name|gap_fill_vma
decl_stmt|;
name|gap_fill_vma
operator|=
name|parse_vma
argument_list|(
name|optarg
argument_list|,
literal|"--gap-fill"
argument_list|)
expr_stmt|;
name|gap_fill
operator|=
operator|(
name|bfd_byte
operator|)
name|gap_fill_vma
expr_stmt|;
if|if
condition|(
operator|(
name|bfd_vma
operator|)
name|gap_fill
operator|!=
name|gap_fill_vma
condition|)
block|{
name|char
name|buff
index|[
literal|20
index|]
decl_stmt|;
name|sprintf_vma
argument_list|(
name|buff
argument_list|,
name|gap_fill_vma
argument_list|)
expr_stmt|;
name|non_fatal
argument_list|(
name|_
argument_list|(
literal|"Warning: truncating gap-fill from 0x%s to 0x%x"
argument_list|)
argument_list|,
name|buff
argument_list|,
name|gap_fill
argument_list|)
expr_stmt|;
block|}
name|gap_fill_set
operator|=
name|TRUE
expr_stmt|;
block|}
break|break;
case|case
name|OPTION_NO_CHANGE_WARNINGS
case|:
name|change_warn
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
name|OPTION_PAD_TO
case|:
name|pad_to
operator|=
name|parse_vma
argument_list|(
name|optarg
argument_list|,
literal|"--pad-to"
argument_list|)
expr_stmt|;
name|pad_to_set
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|OPTION_REMOVE_LEADING_CHAR
case|:
name|remove_leading_char
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|OPTION_REDEFINE_SYM
case|:
block|{
comment|/* Push this redefinition onto redefine_symbol_list.  */
name|int
name|len
decl_stmt|;
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
specifier|const
name|char
modifier|*
name|nextarg
decl_stmt|;
name|char
modifier|*
name|source
decl_stmt|,
modifier|*
name|target
decl_stmt|;
name|s
operator|=
name|strchr
argument_list|(
name|optarg
argument_list|,
literal|'='
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
name|_
argument_list|(
literal|"bad format for %s"
argument_list|)
argument_list|,
literal|"--redefine-sym"
argument_list|)
expr_stmt|;
name|len
operator|=
name|s
operator|-
name|optarg
expr_stmt|;
name|source
operator|=
name|xmalloc
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|source
argument_list|,
name|optarg
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|source
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
name|nextarg
operator|=
name|s
operator|+
literal|1
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|nextarg
argument_list|)
expr_stmt|;
name|target
operator|=
name|xmalloc
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|target
argument_list|,
name|nextarg
argument_list|)
expr_stmt|;
name|redefine_list_append
argument_list|(
literal|"--redefine-sym"
argument_list|,
name|source
argument_list|,
name|target
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|source
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|target
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|OPTION_REDEFINE_SYMS
case|:
name|add_redefine_syms_file
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPTION_SET_SECTION_FLAGS
case|:
block|{
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|len
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|s
operator|=
name|strchr
argument_list|(
name|optarg
argument_list|,
literal|'='
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
name|_
argument_list|(
literal|"bad format for %s"
argument_list|)
argument_list|,
literal|"--set-section-flags"
argument_list|)
expr_stmt|;
name|len
operator|=
name|s
operator|-
name|optarg
expr_stmt|;
name|name
operator|=
name|xmalloc
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|name
argument_list|,
name|optarg
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|name
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
name|p
operator|=
name|find_section_list
argument_list|(
name|name
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|p
operator|->
name|set_flags
operator|=
name|TRUE
expr_stmt|;
name|p
operator|->
name|flags
operator|=
name|parse_flags
argument_list|(
name|s
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|OPTION_RENAME_SECTION
case|:
block|{
name|flagword
name|flags
decl_stmt|;
specifier|const
name|char
modifier|*
name|eq
decl_stmt|,
modifier|*
name|fl
decl_stmt|;
name|char
modifier|*
name|old_name
decl_stmt|;
name|char
modifier|*
name|new_name
decl_stmt|;
name|unsigned
name|int
name|len
decl_stmt|;
name|eq
operator|=
name|strchr
argument_list|(
name|optarg
argument_list|,
literal|'='
argument_list|)
expr_stmt|;
if|if
condition|(
name|eq
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
name|_
argument_list|(
literal|"bad format for %s"
argument_list|)
argument_list|,
literal|"--rename-section"
argument_list|)
expr_stmt|;
name|len
operator|=
name|eq
operator|-
name|optarg
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
name|fatal
argument_list|(
name|_
argument_list|(
literal|"bad format for %s"
argument_list|)
argument_list|,
literal|"--rename-section"
argument_list|)
expr_stmt|;
name|old_name
operator|=
name|xmalloc
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|old_name
argument_list|,
name|optarg
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|old_name
index|[
name|len
index|]
operator|=
literal|0
expr_stmt|;
name|eq
operator|++
expr_stmt|;
name|fl
operator|=
name|strchr
argument_list|(
name|eq
argument_list|,
literal|','
argument_list|)
expr_stmt|;
if|if
condition|(
name|fl
condition|)
block|{
name|flags
operator|=
name|parse_flags
argument_list|(
name|fl
operator|+
literal|1
argument_list|)
expr_stmt|;
name|len
operator|=
name|fl
operator|-
name|eq
expr_stmt|;
block|}
else|else
block|{
name|flags
operator|=
operator|-
literal|1
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|eq
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|len
operator|==
literal|0
condition|)
name|fatal
argument_list|(
name|_
argument_list|(
literal|"bad format for %s"
argument_list|)
argument_list|,
literal|"--rename-section"
argument_list|)
expr_stmt|;
name|new_name
operator|=
name|xmalloc
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|new_name
argument_list|,
name|eq
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|new_name
index|[
name|len
index|]
operator|=
literal|0
expr_stmt|;
name|add_section_rename
argument_list|(
name|old_name
argument_list|,
name|new_name
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|OPTION_SET_START
case|:
name|set_start
operator|=
name|parse_vma
argument_list|(
name|optarg
argument_list|,
literal|"--set-start"
argument_list|)
expr_stmt|;
name|set_start_set
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|OPTION_SREC_LEN
case|:
name|Chunk
operator|=
name|parse_vma
argument_list|(
name|optarg
argument_list|,
literal|"--srec-len"
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPTION_SREC_FORCES3
case|:
name|S3Forced
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|OPTION_STRIP_SYMBOLS
case|:
name|add_specific_symbols
argument_list|(
name|optarg
argument_list|,
operator|&
name|strip_specific_list
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPTION_KEEP_SYMBOLS
case|:
name|add_specific_symbols
argument_list|(
name|optarg
argument_list|,
operator|&
name|keep_specific_list
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPTION_LOCALIZE_SYMBOLS
case|:
name|add_specific_symbols
argument_list|(
name|optarg
argument_list|,
operator|&
name|localize_specific_list
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPTION_KEEPGLOBAL_SYMBOLS
case|:
name|add_specific_symbols
argument_list|(
name|optarg
argument_list|,
operator|&
name|keepglobal_specific_list
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPTION_WEAKEN_SYMBOLS
case|:
name|add_specific_symbols
argument_list|(
name|optarg
argument_list|,
operator|&
name|weaken_specific_list
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPTION_ALT_MACH_CODE
case|:
name|use_alt_mach_code
operator|=
name|atoi
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
if|if
condition|(
name|use_alt_mach_code
operator|<=
literal|0
condition|)
name|fatal
argument_list|(
name|_
argument_list|(
literal|"alternate machine code index must be positive"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPTION_PREFIX_SYMBOLS
case|:
name|prefix_symbols_string
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
name|OPTION_PREFIX_SECTIONS
case|:
name|prefix_sections_string
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
name|OPTION_PREFIX_ALLOC_SECTIONS
case|:
name|prefix_alloc_sections_string
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
name|OPTION_READONLY_TEXT
case|:
name|bfd_flags_to_set
operator||=
name|WP_TEXT
expr_stmt|;
name|bfd_flags_to_clear
operator|&=
operator|~
name|WP_TEXT
expr_stmt|;
break|break;
case|case
name|OPTION_WRITABLE_TEXT
case|:
name|bfd_flags_to_clear
operator||=
name|WP_TEXT
expr_stmt|;
name|bfd_flags_to_set
operator|&=
operator|~
name|WP_TEXT
expr_stmt|;
break|break;
case|case
name|OPTION_PURE
case|:
name|bfd_flags_to_set
operator||=
name|D_PAGED
expr_stmt|;
name|bfd_flags_to_clear
operator|&=
operator|~
name|D_PAGED
expr_stmt|;
break|break;
case|case
name|OPTION_IMPURE
case|:
name|bfd_flags_to_clear
operator||=
name|D_PAGED
expr_stmt|;
name|bfd_flags_to_set
operator|&=
operator|~
name|D_PAGED
expr_stmt|;
break|break;
case|case
literal|0
case|:
comment|/* We've been given a long option.  */
break|break;
case|case
literal|'H'
case|:
case|case
literal|'h'
case|:
name|copy_usage
argument_list|(
name|stdout
argument_list|,
literal|0
argument_list|)
expr_stmt|;
default|default:
name|copy_usage
argument_list|(
name|stderr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|formats_info
condition|)
block|{
name|display_info
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|show_version
condition|)
name|print_version
argument_list|(
literal|"objcopy"
argument_list|)
expr_stmt|;
if|if
condition|(
name|copy_byte
operator|>=
name|interleave
condition|)
name|fatal
argument_list|(
name|_
argument_list|(
literal|"byte number must be less than interleave"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|optind
operator|==
name|argc
operator|||
name|optind
operator|+
literal|2
operator|<
name|argc
condition|)
name|copy_usage
argument_list|(
name|stderr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|input_filename
operator|=
name|argv
index|[
name|optind
index|]
expr_stmt|;
if|if
condition|(
name|optind
operator|+
literal|1
operator|<
name|argc
condition|)
name|output_filename
operator|=
name|argv
index|[
name|optind
operator|+
literal|1
index|]
expr_stmt|;
comment|/* Default is to strip no symbols.  */
if|if
condition|(
name|strip_symbols
operator|==
name|STRIP_UNDEF
operator|&&
name|discard_locals
operator|==
name|LOCALS_UNDEF
condition|)
name|strip_symbols
operator|=
name|STRIP_NONE
expr_stmt|;
if|if
condition|(
name|output_target
operator|==
name|NULL
condition|)
name|output_target
operator|=
name|input_target
expr_stmt|;
if|if
condition|(
name|binary_architecture
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|input_target
operator|&&
name|strcmp
argument_list|(
name|input_target
argument_list|,
literal|"binary"
argument_list|)
operator|==
literal|0
condition|)
block|{
specifier|const
name|bfd_arch_info_type
modifier|*
name|temp_arch_info
decl_stmt|;
name|temp_arch_info
operator|=
name|bfd_scan_arch
argument_list|(
name|binary_architecture
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp_arch_info
operator|!=
name|NULL
condition|)
block|{
name|bfd_external_binary_architecture
operator|=
name|temp_arch_info
operator|->
name|arch
expr_stmt|;
name|bfd_external_machine
operator|=
name|temp_arch_info
operator|->
name|mach
expr_stmt|;
block|}
else|else
name|fatal
argument_list|(
name|_
argument_list|(
literal|"architecture %s unknown"
argument_list|)
argument_list|,
name|binary_architecture
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|non_fatal
argument_list|(
name|_
argument_list|(
literal|"Warning: input target 'binary' required for binary architecture parameter."
argument_list|)
argument_list|)
expr_stmt|;
name|non_fatal
argument_list|(
name|_
argument_list|(
literal|" Argument %s ignored"
argument_list|)
argument_list|,
name|binary_architecture
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|preserve_dates
condition|)
if|if
condition|(
name|stat
argument_list|(
name|input_filename
argument_list|,
operator|&
name|statbuf
argument_list|)
operator|<
literal|0
condition|)
name|fatal
argument_list|(
name|_
argument_list|(
literal|"warning: could not locate '%s'.  System error message: %s"
argument_list|)
argument_list|,
name|input_filename
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If there is no destination file, or the source and destination files      are the same, then create a temp and rename the result into the input.  */
if|if
condition|(
name|output_filename
operator|==
name|NULL
operator|||
name|strcmp
argument_list|(
name|input_filename
argument_list|,
name|output_filename
argument_list|)
operator|==
literal|0
condition|)
block|{
name|char
modifier|*
name|tmpname
init|=
name|make_tempname
argument_list|(
name|input_filename
argument_list|)
decl_stmt|;
name|copy_file
argument_list|(
name|input_filename
argument_list|,
name|tmpname
argument_list|,
name|input_target
argument_list|,
name|output_target
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|preserve_dates
condition|)
name|set_times
argument_list|(
name|tmpname
argument_list|,
operator|&
name|statbuf
argument_list|)
expr_stmt|;
name|smart_rename
argument_list|(
name|tmpname
argument_list|,
name|input_filename
argument_list|,
name|preserve_dates
argument_list|)
expr_stmt|;
block|}
else|else
name|unlink
argument_list|(
name|tmpname
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|copy_file
argument_list|(
name|input_filename
argument_list|,
name|output_filename
argument_list|,
name|input_target
argument_list|,
name|output_target
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
literal|0
operator|&&
name|preserve_dates
condition|)
name|set_times
argument_list|(
name|output_filename
argument_list|,
operator|&
name|statbuf
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|change_warn
condition|)
block|{
for|for
control|(
name|p
operator|=
name|change_sections
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|!
name|p
operator|->
name|used
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|change_vma
operator|!=
name|CHANGE_IGNORE
condition|)
block|{
name|char
name|buff
index|[
literal|20
index|]
decl_stmt|;
name|sprintf_vma
argument_list|(
name|buff
argument_list|,
name|p
operator|->
name|vma_val
argument_list|)
expr_stmt|;
comment|/* xgettext:c-format */
name|non_fatal
argument_list|(
name|_
argument_list|(
literal|"%s %s%c0x%s never used"
argument_list|)
argument_list|,
literal|"--change-section-vma"
argument_list|,
name|p
operator|->
name|name
argument_list|,
name|p
operator|->
name|change_vma
operator|==
name|CHANGE_SET
condition|?
literal|'='
else|:
literal|'+'
argument_list|,
name|buff
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|->
name|change_lma
operator|!=
name|CHANGE_IGNORE
condition|)
block|{
name|char
name|buff
index|[
literal|20
index|]
decl_stmt|;
name|sprintf_vma
argument_list|(
name|buff
argument_list|,
name|p
operator|->
name|lma_val
argument_list|)
expr_stmt|;
comment|/* xgettext:c-format */
name|non_fatal
argument_list|(
name|_
argument_list|(
literal|"%s %s%c0x%s never used"
argument_list|)
argument_list|,
literal|"--change-section-lma"
argument_list|,
name|p
operator|->
name|name
argument_list|,
name|p
operator|->
name|change_lma
operator|==
name|CHANGE_SET
condition|?
literal|'='
else|:
literal|'+'
argument_list|,
name|buff
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|HAVE_SETLOCALE
argument_list|)
operator|&&
name|defined
argument_list|(
name|HAVE_LC_MESSAGES
argument_list|)
name|setlocale
argument_list|(
name|LC_MESSAGES
argument_list|,
literal|""
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|HAVE_SETLOCALE
argument_list|)
name|setlocale
argument_list|(
name|LC_CTYPE
argument_list|,
literal|""
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|bindtextdomain
argument_list|(
name|PACKAGE
argument_list|,
name|LOCALEDIR
argument_list|)
expr_stmt|;
name|textdomain
argument_list|(
name|PACKAGE
argument_list|)
expr_stmt|;
name|program_name
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
name|xmalloc_set_program_name
argument_list|(
name|program_name
argument_list|)
expr_stmt|;
name|START_PROGRESS
argument_list|(
name|program_name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|strip_symbols
operator|=
name|STRIP_UNDEF
expr_stmt|;
name|discard_locals
operator|=
name|LOCALS_UNDEF
expr_stmt|;
name|bfd_init
argument_list|()
expr_stmt|;
name|set_default_bfd_target
argument_list|()
expr_stmt|;
if|if
condition|(
name|is_strip
operator|<
literal|0
condition|)
block|{
name|int
name|i
init|=
name|strlen
argument_list|(
name|program_name
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_DOS_BASED_FILE_SYSTEM
comment|/* Drop the .exe suffix, if any.  */
if|if
condition|(
name|i
operator|>
literal|4
operator|&&
name|FILENAME_CMP
argument_list|(
name|program_name
operator|+
name|i
operator|-
literal|4
argument_list|,
literal|".exe"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|i
operator|-=
literal|4
expr_stmt|;
name|program_name
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
endif|#
directive|endif
name|is_strip
operator|=
operator|(
name|i
operator|>=
literal|5
operator|&&
name|FILENAME_CMP
argument_list|(
name|program_name
operator|+
name|i
operator|-
literal|5
argument_list|,
literal|"strip"
argument_list|)
operator|==
literal|0
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|is_strip
condition|)
name|strip_main
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
else|else
name|copy_main
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
name|END_PROGRESS
argument_list|(
name|program_name
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

end_unit

