begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* strings -- print the strings of printable characters in files    Copyright 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001,    2002, 2003, 2004, 2005 Free Software Foundation, Inc.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA    02110-1301, USA.  */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Usage: strings [options] file...     Options:    --all    -a    -		Do not scan only the initialized data section of object files.     --print-file-name    -f		Print the name of the file before each string.     --bytes=min-len    -n min-len    -min-len	Print graphic char sequences, MIN-LEN or more bytes long, 		that are followed by a NUL or a newline.  Default is 4.     --radix={o,x,d}    -t {o,x,d}	Print the offset within the file before each string, 		in octal/hex/decimal.     -o		Like -to.  (Some other implementations have -o like -to, 		others like -td.  We chose one arbitrarily.)     --encoding={s,S,b,l,B,L}    -e {s,S,b,l,B,L} 		Select character encoding: 7-bit-character, 8-bit-character, 		bigendian 16-bit, littleendian 16-bit, bigendian 32-bit, 		littleendian 32-bit.     --target=BFDNAME 		Specify a non-default object file format.     --help    -h		Print the usage message on the standard output.     --version    -v		Print the program version number.     Written by Richard Stallman<rms@gnu.ai.mit.edu>    and David MacKenzie<djm@gnu.ai.mit.edu>.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"getopt.h"
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|"bucomm.h"
end_include

begin_include
include|#
directive|include
file|"libiberty.h"
end_include

begin_include
include|#
directive|include
file|"safe-ctype.h"
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_comment
comment|/* Some platforms need to put stdin into binary mode, to read     binary files.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SETMODE
end_ifdef

begin_ifndef
ifndef|#
directive|ifndef
name|O_BINARY
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|_O_BINARY
end_ifdef

begin_define
define|#
directive|define
name|O_BINARY
value|_O_BINARY
end_define

begin_define
define|#
directive|define
name|setmode
value|_setmode
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|O_BINARY
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|O_BINARY
end_if

begin_include
include|#
directive|include
file|<io.h>
end_include

begin_define
define|#
directive|define
name|SET_BINARY
parameter_list|(
name|f
parameter_list|)
value|do { if (!isatty (f)) setmode (f,O_BINARY); } while (0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|STRING_ISGRAPHIC
parameter_list|(
name|c
parameter_list|)
define|\
value|(   (c)>= 0 \&& (c)<= 255 \&& ((c) == '\t' || ISPRINT (c) || (encoding == 'S'&& (c)> 127)))
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|errno
end_ifndef

begin_decl_stmt
specifier|extern
name|int
name|errno
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* The BFD section flags that identify an initialized data section.  */
end_comment

begin_define
define|#
directive|define
name|DATA_FLAGS
value|(SEC_ALLOC | SEC_LOAD | SEC_HAS_CONTENTS)
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_FOPEN64
end_ifdef

begin_typedef
typedef|typedef
name|off64_t
name|file_off
typedef|;
end_typedef

begin_define
define|#
directive|define
name|file_open
parameter_list|(
name|s
parameter_list|,
name|m
parameter_list|)
value|fopen64(s, m)
end_define

begin_else
else|#
directive|else
end_else

begin_typedef
typedef|typedef
name|off_t
name|file_off
typedef|;
end_typedef

begin_define
define|#
directive|define
name|file_open
parameter_list|(
name|s
parameter_list|,
name|m
parameter_list|)
value|fopen(s, m)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_STAT64
end_ifdef

begin_typedef
typedef|typedef
name|struct
name|stat64
name|statbuf
typedef|;
end_typedef

begin_define
define|#
directive|define
name|file_stat
parameter_list|(
name|f
parameter_list|,
name|s
parameter_list|)
value|stat64(f, s)
end_define

begin_else
else|#
directive|else
end_else

begin_typedef
typedef|typedef
name|struct
name|stat
name|statbuf
typedef|;
end_typedef

begin_define
define|#
directive|define
name|file_stat
parameter_list|(
name|f
parameter_list|,
name|s
parameter_list|)
value|stat(f, s)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Radix for printing addresses (must be 8, 10 or 16).  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|address_radix
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Minimum length of sequence of graphic chars to trigger output.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|string_min
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* TRUE means print address within file for each string.  */
end_comment

begin_decl_stmt
specifier|static
name|bfd_boolean
name|print_addresses
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* TRUE means print filename for each string.  */
end_comment

begin_decl_stmt
specifier|static
name|bfd_boolean
name|print_filenames
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* TRUE means for object files scan only the data section.  */
end_comment

begin_decl_stmt
specifier|static
name|bfd_boolean
name|datasection_only
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* TRUE if we found an initialized data section in the current file.  */
end_comment

begin_decl_stmt
specifier|static
name|bfd_boolean
name|got_a_section
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The BFD object file format.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|target
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The character encoding format.  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|encoding
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|encoding_bytes
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|option
name|long_options
index|[]
init|=
block|{
block|{
literal|"all"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'a'
block|}
block|,
block|{
literal|"print-file-name"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'f'
block|}
block|,
block|{
literal|"bytes"
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'n'
block|}
block|,
block|{
literal|"radix"
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'t'
block|}
block|,
block|{
literal|"encoding"
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'e'
block|}
block|,
block|{
literal|"target"
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'T'
block|}
block|,
block|{
literal|"help"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'h'
block|}
block|,
block|{
literal|"version"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'v'
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Records the size of a named file so that we    do not repeatedly run bfd_stat() on it.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
specifier|const
name|char
modifier|*
name|filename
decl_stmt|;
name|bfd_size_type
name|filesize
decl_stmt|;
block|}
name|filename_and_size_t
typedef|;
end_typedef

begin_function_decl
specifier|static
name|void
name|strings_a_section
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|asection
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bfd_boolean
name|strings_object_file
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bfd_boolean
name|strings_file
parameter_list|(
name|char
modifier|*
name|file
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|integer_arg
parameter_list|(
name|char
modifier|*
name|s
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|print_strings
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|FILE
modifier|*
parameter_list|,
name|file_off
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|usage
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|long
name|get_char
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|file_off
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_escape
end_escape

begin_function_decl
name|int
name|main
parameter_list|(
name|int
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|int
name|optc
decl_stmt|;
name|int
name|exit_status
init|=
literal|0
decl_stmt|;
name|bfd_boolean
name|files_given
init|=
name|FALSE
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HAVE_SETLOCALE
argument_list|)
name|setlocale
argument_list|(
name|LC_ALL
argument_list|,
literal|""
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|bindtextdomain
argument_list|(
name|PACKAGE
argument_list|,
name|LOCALEDIR
argument_list|)
expr_stmt|;
name|textdomain
argument_list|(
name|PACKAGE
argument_list|)
expr_stmt|;
name|program_name
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
name|xmalloc_set_program_name
argument_list|(
name|program_name
argument_list|)
expr_stmt|;
name|expandargv
argument_list|(
operator|&
name|argc
argument_list|,
operator|&
name|argv
argument_list|)
expr_stmt|;
name|string_min
operator|=
operator|-
literal|1
expr_stmt|;
name|print_addresses
operator|=
name|FALSE
expr_stmt|;
name|print_filenames
operator|=
name|FALSE
expr_stmt|;
name|datasection_only
operator|=
name|TRUE
expr_stmt|;
name|target
operator|=
name|NULL
expr_stmt|;
name|encoding
operator|=
literal|'s'
expr_stmt|;
while|while
condition|(
operator|(
name|optc
operator|=
name|getopt_long
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"afhHn:ot:e:Vv0123456789"
argument_list|,
name|long_options
argument_list|,
operator|(
name|int
operator|*
operator|)
literal|0
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
switch|switch
condition|(
name|optc
condition|)
block|{
case|case
literal|'a'
case|:
name|datasection_only
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|print_filenames
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'H'
case|:
case|case
literal|'h'
case|:
name|usage
argument_list|(
name|stdout
argument_list|,
literal|0
argument_list|)
expr_stmt|;
case|case
literal|'n'
case|:
name|string_min
operator|=
name|integer_arg
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
if|if
condition|(
name|string_min
operator|<
literal|1
condition|)
name|fatal
argument_list|(
name|_
argument_list|(
literal|"invalid number %s"
argument_list|)
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
name|print_addresses
operator|=
name|TRUE
expr_stmt|;
name|address_radix
operator|=
literal|8
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|print_addresses
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|optarg
index|[
literal|1
index|]
operator|!=
literal|'\0'
condition|)
name|usage
argument_list|(
name|stderr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|optarg
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|'o'
case|:
name|address_radix
operator|=
literal|8
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|address_radix
operator|=
literal|10
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
name|address_radix
operator|=
literal|16
expr_stmt|;
break|break;
default|default:
name|usage
argument_list|(
name|stderr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'T'
case|:
name|target
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
if|if
condition|(
name|optarg
index|[
literal|1
index|]
operator|!=
literal|'\0'
condition|)
name|usage
argument_list|(
name|stderr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|encoding
operator|=
name|optarg
index|[
literal|0
index|]
expr_stmt|;
break|break;
case|case
literal|'V'
case|:
case|case
literal|'v'
case|:
name|print_version
argument_list|(
literal|"strings"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
name|usage
argument_list|(
name|stderr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
default|default:
if|if
condition|(
name|string_min
operator|<
literal|0
condition|)
name|string_min
operator|=
name|optc
operator|-
literal|'0'
expr_stmt|;
else|else
name|string_min
operator|=
name|string_min
operator|*
literal|10
operator|+
name|optc
operator|-
literal|'0'
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|string_min
operator|<
literal|0
condition|)
name|string_min
operator|=
literal|4
expr_stmt|;
switch|switch
condition|(
name|encoding
condition|)
block|{
case|case
literal|'S'
case|:
case|case
literal|'s'
case|:
name|encoding_bytes
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
case|case
literal|'l'
case|:
name|encoding_bytes
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|'B'
case|:
case|case
literal|'L'
case|:
name|encoding_bytes
operator|=
literal|4
expr_stmt|;
break|break;
default|default:
name|usage
argument_list|(
name|stderr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|bfd_init
argument_list|()
expr_stmt|;
name|set_default_bfd_target
argument_list|()
expr_stmt|;
if|if
condition|(
name|optind
operator|>=
name|argc
condition|)
block|{
name|datasection_only
operator|=
name|FALSE
expr_stmt|;
ifdef|#
directive|ifdef
name|SET_BINARY
name|SET_BINARY
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|print_strings
argument_list|(
literal|"{standard input}"
argument_list|,
name|stdin
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|files_given
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
init|;
name|optind
operator|<
name|argc
condition|;
operator|++
name|optind
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
name|optind
index|]
argument_list|,
literal|"-"
argument_list|)
operator|==
literal|0
condition|)
name|datasection_only
operator|=
name|FALSE
expr_stmt|;
else|else
block|{
name|files_given
operator|=
name|TRUE
expr_stmt|;
name|exit_status
operator||=
name|strings_file
argument_list|(
name|argv
index|[
name|optind
index|]
argument_list|)
operator|==
name|FALSE
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|files_given
condition|)
name|usage
argument_list|(
name|stderr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|exit_status
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Scan section SECT of the file ABFD, whose printable name is in    ARG->filename and whose size might be in ARG->filesize.  If it    contains initialized data set `got_a_section' and print the    strings in it.     FIXME: We ought to be able to return error codes/messages for    certain conditions.  */
end_comment

begin_function
specifier|static
name|void
name|strings_a_section
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|asection
modifier|*
name|sect
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|filename_and_size_t
modifier|*
name|filename_and_sizep
decl_stmt|;
name|bfd_size_type
modifier|*
name|filesizep
decl_stmt|;
name|bfd_size_type
name|sectsize
decl_stmt|;
name|void
modifier|*
name|mem
decl_stmt|;
if|if
condition|(
operator|(
name|sect
operator|->
name|flags
operator|&
name|DATA_FLAGS
operator|)
operator|!=
name|DATA_FLAGS
condition|)
return|return;
name|sectsize
operator|=
name|bfd_get_section_size
argument_list|(
name|sect
argument_list|)
expr_stmt|;
if|if
condition|(
name|sectsize
operator|<=
literal|0
condition|)
return|return;
comment|/* Get the size of the file.  This might have been cached for us.  */
name|filename_and_sizep
operator|=
operator|(
name|filename_and_size_t
operator|*
operator|)
name|arg
expr_stmt|;
name|filesizep
operator|=
operator|&
name|filename_and_sizep
operator|->
name|filesize
expr_stmt|;
if|if
condition|(
operator|*
name|filesizep
operator|==
literal|0
condition|)
block|{
name|struct
name|stat
name|st
decl_stmt|;
if|if
condition|(
name|bfd_stat
argument_list|(
name|abfd
argument_list|,
operator|&
name|st
argument_list|)
condition|)
return|return;
comment|/* Cache the result so that we do not repeatedly stat this file.  */
operator|*
name|filesizep
operator|=
name|st
operator|.
name|st_size
expr_stmt|;
block|}
comment|/* Compare the size of the section against the size of the file.      If the section is bigger then the file must be corrupt and      we should not try dumping it.  */
if|if
condition|(
name|sectsize
operator|>=
operator|*
name|filesizep
condition|)
return|return;
name|mem
operator|=
name|xmalloc
argument_list|(
name|sectsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_get_section_contents
argument_list|(
name|abfd
argument_list|,
name|sect
argument_list|,
name|mem
argument_list|,
operator|(
name|file_ptr
operator|)
literal|0
argument_list|,
name|sectsize
argument_list|)
condition|)
block|{
name|got_a_section
operator|=
name|TRUE
expr_stmt|;
name|print_strings
argument_list|(
name|filename_and_sizep
operator|->
name|filename
argument_list|,
name|NULL
argument_list|,
name|sect
operator|->
name|filepos
argument_list|,
literal|0
argument_list|,
name|sectsize
argument_list|,
name|mem
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|mem
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Scan all of the sections in FILE, and print the strings    in the initialized data section(s).     Return TRUE if successful,    FALSE if not (such as if FILE is not an object file).  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|strings_object_file
parameter_list|(
specifier|const
name|char
modifier|*
name|file
parameter_list|)
block|{
name|filename_and_size_t
name|filename_and_size
decl_stmt|;
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|abfd
operator|=
name|bfd_openr
argument_list|(
name|file
argument_list|,
name|target
argument_list|)
expr_stmt|;
if|if
condition|(
name|abfd
operator|==
name|NULL
condition|)
comment|/* Treat the file as a non-object file.  */
return|return
name|FALSE
return|;
comment|/* This call is mainly for its side effect of reading in the sections.      We follow the traditional behavior of `strings' in that we don't      complain if we don't recognize a file to be an object file.  */
if|if
condition|(
operator|!
name|bfd_check_format
argument_list|(
name|abfd
argument_list|,
name|bfd_object
argument_list|)
condition|)
block|{
name|bfd_close
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|got_a_section
operator|=
name|FALSE
expr_stmt|;
name|filename_and_size
operator|.
name|filename
operator|=
name|file
expr_stmt|;
name|filename_and_size
operator|.
name|filesize
operator|=
literal|0
expr_stmt|;
name|bfd_map_over_sections
argument_list|(
name|abfd
argument_list|,
name|strings_a_section
argument_list|,
operator|&
name|filename_and_size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_close
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
name|bfd_nonfatal
argument_list|(
name|file
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
return|return
name|got_a_section
return|;
block|}
end_function

begin_comment
comment|/* Print the strings in FILE.  Return TRUE if ok, FALSE if an error occurs.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|strings_file
parameter_list|(
name|char
modifier|*
name|file
parameter_list|)
block|{
name|statbuf
name|st
decl_stmt|;
if|if
condition|(
name|file_stat
argument_list|(
name|file
argument_list|,
operator|&
name|st
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|ENOENT
condition|)
name|non_fatal
argument_list|(
name|_
argument_list|(
literal|"'%s': No such file"
argument_list|)
argument_list|,
name|file
argument_list|)
expr_stmt|;
else|else
name|non_fatal
argument_list|(
name|_
argument_list|(
literal|"Warning: could not locate '%s'.  reason: %s"
argument_list|)
argument_list|,
name|file
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* If we weren't told to scan the whole file,      try to open it as an object file and only look at      initialized data sections.  If that fails, fall back to the      whole file.  */
if|if
condition|(
operator|!
name|datasection_only
operator|||
operator|!
name|strings_object_file
argument_list|(
name|file
argument_list|)
condition|)
block|{
name|FILE
modifier|*
name|stream
decl_stmt|;
name|stream
operator|=
name|file_open
argument_list|(
name|file
argument_list|,
name|FOPEN_RB
argument_list|)
expr_stmt|;
if|if
condition|(
name|stream
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: "
argument_list|,
name|program_name
argument_list|)
expr_stmt|;
name|perror
argument_list|(
name|file
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|print_strings
argument_list|(
name|file
argument_list|,
name|stream
argument_list|,
operator|(
name|file_off
operator|)
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|fclose
argument_list|(
name|stream
argument_list|)
operator|==
name|EOF
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: "
argument_list|,
name|program_name
argument_list|)
expr_stmt|;
name|perror
argument_list|(
name|file
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Read the next character, return EOF if none available.    Assume that STREAM is positioned so that the next byte read    is at address ADDRESS in the file.     If STREAM is NULL, do not read from it.    The caller can supply a buffer of characters    to be processed before the data in STREAM.    MAGIC is the address of the buffer and    MAGICCOUNT is how many characters are in it.  */
end_comment

begin_function
specifier|static
name|long
name|get_char
parameter_list|(
name|FILE
modifier|*
name|stream
parameter_list|,
name|file_off
modifier|*
name|address
parameter_list|,
name|int
modifier|*
name|magiccount
parameter_list|,
name|char
modifier|*
modifier|*
name|magic
parameter_list|)
block|{
name|int
name|c
decl_stmt|,
name|i
decl_stmt|;
name|long
name|r
init|=
name|EOF
decl_stmt|;
name|unsigned
name|char
name|buf
index|[
literal|4
index|]
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|encoding_bytes
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|magiccount
condition|)
block|{
operator|(
operator|*
name|magiccount
operator|)
operator|--
expr_stmt|;
name|c
operator|=
operator|*
operator|(
operator|*
name|magic
operator|)
operator|++
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|stream
operator|==
name|NULL
condition|)
return|return
name|EOF
return|;
comment|/* Only use getc_unlocked if we found a declaration for it. 	     Otherwise, libc is not thread safe by default, and we 	     should not use it.  */
if|#
directive|if
name|defined
argument_list|(
name|HAVE_GETC_UNLOCKED
argument_list|)
operator|&&
name|HAVE_DECL_GETC_UNLOCKED
name|c
operator|=
name|getc_unlocked
argument_list|(
name|stream
argument_list|)
expr_stmt|;
else|#
directive|else
name|c
operator|=
name|getc
argument_list|(
name|stream
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
return|return
name|EOF
return|;
block|}
operator|(
operator|*
name|address
operator|)
operator|++
expr_stmt|;
name|buf
index|[
name|i
index|]
operator|=
name|c
expr_stmt|;
block|}
switch|switch
condition|(
name|encoding
condition|)
block|{
case|case
literal|'S'
case|:
case|case
literal|'s'
case|:
name|r
operator|=
name|buf
index|[
literal|0
index|]
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
name|r
operator|=
operator|(
name|buf
index|[
literal|0
index|]
operator|<<
literal|8
operator|)
operator||
name|buf
index|[
literal|1
index|]
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|r
operator|=
name|buf
index|[
literal|0
index|]
operator||
operator|(
name|buf
index|[
literal|1
index|]
operator|<<
literal|8
operator|)
expr_stmt|;
break|break;
case|case
literal|'B'
case|:
name|r
operator|=
operator|(
operator|(
name|long
operator|)
name|buf
index|[
literal|0
index|]
operator|<<
literal|24
operator|)
operator||
operator|(
operator|(
name|long
operator|)
name|buf
index|[
literal|1
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
operator|(
name|long
operator|)
name|buf
index|[
literal|2
index|]
operator|<<
literal|8
operator|)
operator||
name|buf
index|[
literal|3
index|]
expr_stmt|;
break|break;
case|case
literal|'L'
case|:
name|r
operator|=
name|buf
index|[
literal|0
index|]
operator||
operator|(
operator|(
name|long
operator|)
name|buf
index|[
literal|1
index|]
operator|<<
literal|8
operator|)
operator||
operator|(
operator|(
name|long
operator|)
name|buf
index|[
literal|2
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
operator|(
name|long
operator|)
name|buf
index|[
literal|3
index|]
operator|<<
literal|24
operator|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|r
operator|==
name|EOF
condition|)
return|return
literal|0
return|;
return|return
name|r
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Find the strings in file FILENAME, read from STREAM.    Assume that STREAM is positioned so that the next byte read    is at address ADDRESS in the file.    Stop reading at address STOP_POINT in the file, if nonzero.     If STREAM is NULL, do not read from it.    The caller can supply a buffer of characters    to be processed before the data in STREAM.    MAGIC is the address of the buffer and    MAGICCOUNT is how many characters are in it.    Those characters come at address ADDRESS and the data in STREAM follow.  */
end_comment

begin_function
specifier|static
name|void
name|print_strings
parameter_list|(
specifier|const
name|char
modifier|*
name|filename
parameter_list|,
name|FILE
modifier|*
name|stream
parameter_list|,
name|file_off
name|address
parameter_list|,
name|int
name|stop_point
parameter_list|,
name|int
name|magiccount
parameter_list|,
name|char
modifier|*
name|magic
parameter_list|)
block|{
name|char
modifier|*
name|buf
init|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|char
argument_list|)
operator|*
operator|(
name|string_min
operator|+
literal|1
operator|)
argument_list|)
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|file_off
name|start
decl_stmt|;
name|int
name|i
decl_stmt|;
name|long
name|c
decl_stmt|;
comment|/* See if the next `string_min' chars are all graphic chars.  */
name|tryline
label|:
if|if
condition|(
name|stop_point
operator|&&
name|address
operator|>=
name|stop_point
condition|)
break|break;
name|start
operator|=
name|address
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|string_min
condition|;
name|i
operator|++
control|)
block|{
name|c
operator|=
name|get_char
argument_list|(
name|stream
argument_list|,
operator|&
name|address
argument_list|,
operator|&
name|magiccount
argument_list|,
operator|&
name|magic
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
return|return;
if|if
condition|(
operator|!
name|STRING_ISGRAPHIC
argument_list|(
name|c
argument_list|)
condition|)
comment|/* Found a non-graphic.  Try again starting with next char.  */
goto|goto
name|tryline
goto|;
name|buf
index|[
name|i
index|]
operator|=
name|c
expr_stmt|;
block|}
comment|/* We found a run of `string_min' graphic characters.  Print up 	 to the next non-graphic character.  */
if|if
condition|(
name|print_filenames
condition|)
name|printf
argument_list|(
literal|"%s: "
argument_list|,
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|print_addresses
condition|)
switch|switch
condition|(
name|address_radix
condition|)
block|{
case|case
literal|8
case|:
if|#
directive|if
name|__STDC_VERSION__
operator|>=
literal|199901L
operator|||
operator|(
name|defined
argument_list|(
name|__GNUC__
argument_list|)
operator|&&
name|__GNUC__
operator|>=
literal|2
operator|)
if|if
condition|(
sizeof|sizeof
argument_list|(
name|start
argument_list|)
operator|>
sizeof|sizeof
argument_list|(
name|long
argument_list|)
condition|)
name|printf
argument_list|(
literal|"%7Lo "
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|start
argument_list|)
expr_stmt|;
elseif|else
else|#
directive|else
if|#
directive|if
operator|!
name|BFD_HOST_64BIT_LONG
if|if
condition|(
name|start
operator|!=
operator|(
name|unsigned
name|long
operator|)
name|start
condition|)
name|printf
argument_list|(
literal|"++%7lo "
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|start
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
endif|#
directive|endif
name|printf
argument_list|(
literal|"%7lo "
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|start
argument_list|)
expr_stmt|;
break|break;
case|case
literal|10
case|:
if|#
directive|if
name|__STDC_VERSION__
operator|>=
literal|199901L
operator|||
operator|(
name|defined
argument_list|(
name|__GNUC__
argument_list|)
operator|&&
name|__GNUC__
operator|>=
literal|2
operator|)
if|if
condition|(
sizeof|sizeof
argument_list|(
name|start
argument_list|)
operator|>
sizeof|sizeof
argument_list|(
name|long
argument_list|)
condition|)
name|printf
argument_list|(
literal|"%7Ld "
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|start
argument_list|)
expr_stmt|;
elseif|else
else|#
directive|else
if|#
directive|if
operator|!
name|BFD_HOST_64BIT_LONG
if|if
condition|(
name|start
operator|!=
operator|(
name|unsigned
name|long
operator|)
name|start
condition|)
name|printf
argument_list|(
literal|"++%7ld "
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|start
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
endif|#
directive|endif
name|printf
argument_list|(
literal|"%7ld "
argument_list|,
operator|(
name|long
operator|)
name|start
argument_list|)
expr_stmt|;
break|break;
case|case
literal|16
case|:
if|#
directive|if
name|__STDC_VERSION__
operator|>=
literal|199901L
operator|||
operator|(
name|defined
argument_list|(
name|__GNUC__
argument_list|)
operator|&&
name|__GNUC__
operator|>=
literal|2
operator|)
if|if
condition|(
sizeof|sizeof
argument_list|(
name|start
argument_list|)
operator|>
sizeof|sizeof
argument_list|(
name|long
argument_list|)
condition|)
name|printf
argument_list|(
literal|"%7Lx "
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|start
argument_list|)
expr_stmt|;
elseif|else
else|#
directive|else
if|#
directive|if
operator|!
name|BFD_HOST_64BIT_LONG
if|if
condition|(
name|start
operator|!=
operator|(
name|unsigned
name|long
operator|)
name|start
condition|)
name|printf
argument_list|(
literal|"%lx%8.8lx "
argument_list|,
call|(
name|unsigned
name|long
call|)
argument_list|(
name|start
operator|>>
literal|32
argument_list|)
argument_list|,
call|(
name|unsigned
name|long
call|)
argument_list|(
name|start
operator|&
literal|0xffffffff
argument_list|)
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
endif|#
directive|endif
name|printf
argument_list|(
literal|"%7lx "
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|start
argument_list|)
expr_stmt|;
break|break;
block|}
name|buf
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
name|fputs
argument_list|(
name|buf
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|c
operator|=
name|get_char
argument_list|(
name|stream
argument_list|,
operator|&
name|address
argument_list|,
operator|&
name|magiccount
argument_list|,
operator|&
name|magic
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
break|break;
if|if
condition|(
operator|!
name|STRING_ISGRAPHIC
argument_list|(
name|c
argument_list|)
condition|)
break|break;
name|putchar
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Parse string S as an integer, using decimal radix by default,    but allowing octal and hex numbers as in C.  */
end_comment

begin_function
specifier|static
name|int
name|integer_arg
parameter_list|(
name|char
modifier|*
name|s
parameter_list|)
block|{
name|int
name|value
decl_stmt|;
name|int
name|radix
init|=
literal|10
decl_stmt|;
name|char
modifier|*
name|p
init|=
name|s
decl_stmt|;
name|int
name|c
decl_stmt|;
if|if
condition|(
operator|*
name|p
operator|!=
literal|'0'
condition|)
name|radix
operator|=
literal|10
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
operator|++
name|p
operator|==
literal|'x'
condition|)
block|{
name|radix
operator|=
literal|16
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
else|else
name|radix
operator|=
literal|8
expr_stmt|;
name|value
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
operator|(
name|c
operator|=
operator|*
name|p
operator|++
operator|)
operator|>=
literal|'0'
operator|&&
name|c
operator|<=
literal|'9'
operator|)
operator|||
operator|(
name|radix
operator|==
literal|16
operator|&&
operator|(
name|c
operator|&
operator|~
literal|40
operator|)
operator|>=
literal|'A'
operator|&&
operator|(
name|c
operator|&
operator|~
literal|40
operator|)
operator|<=
literal|'Z'
operator|)
condition|)
block|{
name|value
operator|*=
name|radix
expr_stmt|;
if|if
condition|(
name|c
operator|>=
literal|'0'
operator|&&
name|c
operator|<=
literal|'9'
condition|)
name|value
operator|+=
name|c
operator|-
literal|'0'
expr_stmt|;
else|else
name|value
operator|+=
operator|(
name|c
operator|&
operator|~
literal|40
operator|)
operator|-
literal|'A'
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|==
literal|'b'
condition|)
name|value
operator|*=
literal|512
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'B'
condition|)
name|value
operator|*=
literal|1024
expr_stmt|;
else|else
name|p
operator|--
expr_stmt|;
if|if
condition|(
operator|*
name|p
condition|)
name|fatal
argument_list|(
name|_
argument_list|(
literal|"invalid integer argument %s"
argument_list|)
argument_list|,
name|s
argument_list|)
expr_stmt|;
return|return
name|value
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|usage
parameter_list|(
name|FILE
modifier|*
name|stream
parameter_list|,
name|int
name|status
parameter_list|)
block|{
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"Usage: %s [option(s)] [file(s)]\n"
argument_list|)
argument_list|,
name|program_name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|" Display printable strings in [file(s)] (stdin by default)\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|" The options are:\n\   -a - --all                Scan the entire file, not just the data section\n\   -f --print-file-name      Print the name of the file before each string\n\   -n --bytes=[number]       Locate& print any NUL-terminated sequence of at\n\   -<number>                 least [number] characters (default 4).\n\   -t --radix={o,d,x}        Print the location of the string in base 8, 10 or 16\n\   -o                        An alias for --radix=o\n\   -T --target=<BFDNAME>     Specify the binary file format\n\   -e --encoding={s,S,b,l,B,L} Select character size and endianness:\n\                             s = 7-bit, S = 8-bit, {b,l} = 16-bit, {B,L} = 32-bit\n\   @<file>                   Read options from<file>\n\   -h --help                 Display this information\n\   -v --version              Print the program's version number\n"
argument_list|)
argument_list|)
expr_stmt|;
name|list_supported_targets
argument_list|(
name|program_name
argument_list|,
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
literal|0
condition|)
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"Report bugs to %s\n"
argument_list|)
argument_list|,
name|REPORT_BUGS_TO
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|status
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

