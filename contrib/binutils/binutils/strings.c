begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* strings -- print the strings of printable characters in files    Copyright (C) 1993, 94, 95, 96, 97, 98, 99, 2000    Free Software Foundation, Inc.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA    02111-1307, USA.  */
end_comment

begin_comment
comment|/* $FreeBSD$ */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Usage: strings [options] file...     Options:    --all    -a    -		Do not scan only the initialized data section of object files.     --print-file-name    -f		Print the name of the file before each string.     --bytes=min-len    -n min-len    -min-len	Print graphic char sequences, MIN-LEN or more bytes long, 		that are followed by a NUL or a newline.  Default is 4.     --radix={o,x,d}    -t {o,x,d}	Print the offset within the file before each string, 		in octal/hex/decimal.     -o		Like -to.  (Some other implementations have -o like -to, 		others like -td.  We chose one arbitrarily.)     --target=BFDNAME 		Specify a non-default object file format.     --help    -h		Print the usage message on the standard output.     --version    -v		Print the program version number.     Written by Richard Stallman<rms@gnu.ai.mit.edu>    and David MacKenzie<djm@gnu.ai.mit.edu>.  */
end_comment

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<getopt.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|"bucomm.h"
end_include

begin_include
include|#
directive|include
file|"libiberty.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|isascii
end_ifdef

begin_define
define|#
directive|define
name|isgraphic
parameter_list|(
name|c
parameter_list|)
value|(isascii (c)&& (isprint (c) || isblank (c)))
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|isgraphic
parameter_list|(
name|c
parameter_list|)
value|(isprint (c) || isblank (c))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|errno
end_ifndef

begin_decl_stmt
specifier|extern
name|int
name|errno
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* The BFD section flags that identify an initialized data section.  */
end_comment

begin_define
define|#
directive|define
name|DATA_FLAGS
value|(SEC_ALLOC | SEC_LOAD | SEC_HAS_CONTENTS)
end_define

begin_comment
comment|/* Radix for printing addresses (must be 8, 10 or 16).  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|address_radix
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Minimum length of sequence of graphic chars to trigger output.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|string_min
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* true means print address within file for each string.  */
end_comment

begin_decl_stmt
specifier|static
name|boolean
name|print_addresses
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* true means print filename for each string.  */
end_comment

begin_decl_stmt
specifier|static
name|boolean
name|print_filenames
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* true means for object files scan only the data section.  */
end_comment

begin_decl_stmt
specifier|static
name|boolean
name|datasection_only
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* true if we found an initialized data section in the current file.  */
end_comment

begin_decl_stmt
specifier|static
name|boolean
name|got_a_section
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The BFD object file format.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|target
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|option
name|long_options
index|[]
init|=
block|{
block|{
literal|"all"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'a'
block|}
block|,
block|{
literal|"print-file-name"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'f'
block|}
block|,
block|{
literal|"bytes"
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'n'
block|}
block|,
block|{
literal|"radix"
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'t'
block|}
block|,
block|{
literal|"target"
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'T'
block|}
block|,
block|{
literal|"help"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'h'
block|}
block|,
block|{
literal|"version"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'v'
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|strings_a_section
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|strings_object_file
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|strings_file
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
name|file
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|integer_arg
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
name|s
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|print_strings
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|filename
operator|,
name|FILE
operator|*
name|stream
operator|,
name|file_ptr
name|address
operator|,
name|int
name|stop_point
operator|,
name|int
name|magiccount
operator|,
name|char
operator|*
name|magic
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|usage
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
name|stream
operator|,
name|int
name|status
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_function
name|int
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|int
name|optc
decl_stmt|;
name|int
name|exit_status
init|=
literal|0
decl_stmt|;
name|boolean
name|files_given
init|=
name|false
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HAVE_SETLOCALE
argument_list|)
operator|&&
name|defined
argument_list|(
name|HAVE_LC_MESSAGES
argument_list|)
name|setlocale
argument_list|(
name|LC_MESSAGES
argument_list|,
literal|""
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|bindtextdomain
argument_list|(
name|PACKAGE
argument_list|,
name|LOCALEDIR
argument_list|)
expr_stmt|;
name|textdomain
argument_list|(
name|PACKAGE
argument_list|)
expr_stmt|;
name|program_name
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
name|xmalloc_set_program_name
argument_list|(
name|program_name
argument_list|)
expr_stmt|;
name|string_min
operator|=
operator|-
literal|1
expr_stmt|;
name|print_addresses
operator|=
name|false
expr_stmt|;
name|print_filenames
operator|=
name|false
expr_stmt|;
name|datasection_only
operator|=
name|true
expr_stmt|;
name|target
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
operator|(
name|optc
operator|=
name|getopt_long
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"afn:ot:v0123456789"
argument_list|,
name|long_options
argument_list|,
operator|(
name|int
operator|*
operator|)
literal|0
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
switch|switch
condition|(
name|optc
condition|)
block|{
case|case
literal|'a'
case|:
name|datasection_only
operator|=
name|false
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|print_filenames
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
name|usage
argument_list|(
name|stdout
argument_list|,
literal|0
argument_list|)
expr_stmt|;
case|case
literal|'n'
case|:
name|string_min
operator|=
name|integer_arg
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
if|if
condition|(
name|string_min
operator|<
literal|1
condition|)
block|{
name|fatal
argument_list|(
name|_
argument_list|(
literal|"invalid number %s"
argument_list|)
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'o'
case|:
name|print_addresses
operator|=
name|true
expr_stmt|;
name|address_radix
operator|=
literal|8
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|print_addresses
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|optarg
index|[
literal|1
index|]
operator|!=
literal|'\0'
condition|)
name|usage
argument_list|(
name|stderr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|optarg
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|'o'
case|:
name|address_radix
operator|=
literal|8
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|address_radix
operator|=
literal|10
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
name|address_radix
operator|=
literal|16
expr_stmt|;
break|break;
default|default:
name|usage
argument_list|(
name|stderr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'T'
case|:
name|target
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
name|print_version
argument_list|(
literal|"strings"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
name|usage
argument_list|(
name|stderr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
default|default:
if|if
condition|(
name|string_min
operator|<
literal|0
condition|)
name|string_min
operator|=
name|optc
operator|-
literal|'0'
expr_stmt|;
else|else
name|string_min
operator|=
name|string_min
operator|*
literal|10
operator|+
name|optc
operator|-
literal|'0'
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|string_min
operator|<
literal|0
condition|)
name|string_min
operator|=
literal|4
expr_stmt|;
name|bfd_init
argument_list|()
expr_stmt|;
name|set_default_bfd_target
argument_list|()
expr_stmt|;
if|if
condition|(
name|optind
operator|>=
name|argc
condition|)
block|{
name|datasection_only
operator|=
name|false
expr_stmt|;
name|print_strings
argument_list|(
literal|"{standard input}"
argument_list|,
name|stdin
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|files_given
operator|=
name|true
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
init|;
name|optind
operator|<
name|argc
condition|;
operator|++
name|optind
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
name|optind
index|]
argument_list|,
literal|"-"
argument_list|)
operator|==
literal|0
condition|)
name|datasection_only
operator|=
name|false
expr_stmt|;
else|else
block|{
name|files_given
operator|=
name|true
expr_stmt|;
name|exit_status
operator||=
operator|(
name|strings_file
argument_list|(
name|argv
index|[
name|optind
index|]
argument_list|)
operator|==
name|false
operator|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|files_given
operator|==
name|false
condition|)
name|usage
argument_list|(
name|stderr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|exit_status
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Scan section SECT of the file ABFD, whose printable name is FILE.    If it contains initialized data,    set `got_a_section' and print the strings in it.  */
end_comment

begin_function
specifier|static
name|void
name|strings_a_section
parameter_list|(
name|abfd
parameter_list|,
name|sect
parameter_list|,
name|filearg
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|sect
decl_stmt|;
name|PTR
name|filearg
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|file
init|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|filearg
decl_stmt|;
if|if
condition|(
operator|(
name|sect
operator|->
name|flags
operator|&
name|DATA_FLAGS
operator|)
operator|==
name|DATA_FLAGS
condition|)
block|{
name|bfd_size_type
name|sz
init|=
name|bfd_get_section_size_before_reloc
argument_list|(
name|sect
argument_list|)
decl_stmt|;
name|PTR
name|mem
init|=
name|xmalloc
argument_list|(
name|sz
argument_list|)
decl_stmt|;
if|if
condition|(
name|bfd_get_section_contents
argument_list|(
name|abfd
argument_list|,
name|sect
argument_list|,
name|mem
argument_list|,
operator|(
name|file_ptr
operator|)
literal|0
argument_list|,
name|sz
argument_list|)
condition|)
block|{
name|got_a_section
operator|=
name|true
expr_stmt|;
name|print_strings
argument_list|(
name|file
argument_list|,
operator|(
name|FILE
operator|*
operator|)
name|NULL
argument_list|,
name|sect
operator|->
name|filepos
argument_list|,
literal|0
argument_list|,
name|sz
argument_list|,
name|mem
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|mem
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Scan all of the sections in FILE, and print the strings    in the initialized data section(s).     Return true if successful,    false if not (such as if FILE is not an object file).  */
end_comment

begin_function
specifier|static
name|boolean
name|strings_object_file
parameter_list|(
name|file
parameter_list|)
specifier|const
name|char
modifier|*
name|file
decl_stmt|;
block|{
name|bfd
modifier|*
name|abfd
init|=
name|bfd_openr
argument_list|(
name|file
argument_list|,
name|target
argument_list|)
decl_stmt|;
if|if
condition|(
name|abfd
operator|==
name|NULL
condition|)
block|{
comment|/* Treat the file as a non-object file.  */
return|return
name|false
return|;
block|}
comment|/* This call is mainly for its side effect of reading in the sections.      We follow the traditional behavior of `strings' in that we don't      complain if we don't recognize a file to be an object file.  */
if|if
condition|(
name|bfd_check_format
argument_list|(
name|abfd
argument_list|,
name|bfd_object
argument_list|)
operator|==
name|false
condition|)
block|{
name|bfd_close
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|got_a_section
operator|=
name|false
expr_stmt|;
name|bfd_map_over_sections
argument_list|(
name|abfd
argument_list|,
name|strings_a_section
argument_list|,
operator|(
name|PTR
operator|)
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_close
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
name|bfd_nonfatal
argument_list|(
name|file
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
return|return
name|got_a_section
return|;
block|}
end_function

begin_comment
comment|/* Print the strings in FILE.  Return true if ok, false if an error occurs.  */
end_comment

begin_function
specifier|static
name|boolean
name|strings_file
parameter_list|(
name|file
parameter_list|)
name|char
modifier|*
name|file
decl_stmt|;
block|{
comment|/* If we weren't told to scan the whole file,      try to open it as an object file and only look at      initialized data sections.  If that fails, fall back to the      whole file.  */
if|if
condition|(
operator|!
name|datasection_only
operator|||
operator|!
name|strings_object_file
argument_list|(
name|file
argument_list|)
condition|)
block|{
name|FILE
modifier|*
name|stream
decl_stmt|;
name|stream
operator|=
name|fopen
argument_list|(
name|file
argument_list|,
literal|"rb"
argument_list|)
expr_stmt|;
comment|/* Not all systems permit "rb", so try "r" if it failed.  */
if|if
condition|(
name|stream
operator|==
name|NULL
condition|)
name|stream
operator|=
name|fopen
argument_list|(
name|file
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|stream
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: "
argument_list|,
name|program_name
argument_list|)
expr_stmt|;
name|perror
argument_list|(
name|file
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|print_strings
argument_list|(
name|file
argument_list|,
name|stream
argument_list|,
operator|(
name|file_ptr
operator|)
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|fclose
argument_list|(
name|stream
argument_list|)
operator|==
name|EOF
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: "
argument_list|,
name|program_name
argument_list|)
expr_stmt|;
name|perror
argument_list|(
name|file
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
block|}
return|return
name|true
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Find the strings in file FILENAME, read from STREAM.    Assume that STREAM is positioned so that the next byte read    is at address ADDRESS in the file.    Stop reading at address STOP_POINT in the file, if nonzero.     If STREAM is NULL, do not read from it.    The caller can supply a buffer of characters    to be processed before the data in STREAM.    MAGIC is the address of the buffer and    MAGICCOUNT is how many characters are in it.    Those characters come at address ADDRESS and the data in STREAM follow.  */
end_comment

begin_function
specifier|static
name|void
name|print_strings
parameter_list|(
name|filename
parameter_list|,
name|stream
parameter_list|,
name|address
parameter_list|,
name|stop_point
parameter_list|,
name|magiccount
parameter_list|,
name|magic
parameter_list|)
specifier|const
name|char
modifier|*
name|filename
decl_stmt|;
name|FILE
modifier|*
name|stream
decl_stmt|;
name|file_ptr
name|address
decl_stmt|;
name|int
name|stop_point
decl_stmt|;
name|int
name|magiccount
decl_stmt|;
name|char
modifier|*
name|magic
decl_stmt|;
block|{
name|char
modifier|*
name|buf
init|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|string_min
operator|+
literal|1
argument_list|)
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|file_ptr
name|start
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|c
decl_stmt|;
comment|/* See if the next `string_min' chars are all graphic chars.  */
name|tryline
label|:
if|if
condition|(
name|stop_point
operator|&&
name|address
operator|>=
name|stop_point
condition|)
break|break;
name|start
operator|=
name|address
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|string_min
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|magiccount
condition|)
block|{
name|magiccount
operator|--
expr_stmt|;
name|c
operator|=
operator|*
name|magic
operator|++
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|stream
operator|==
name|NULL
condition|)
return|return;
name|c
operator|=
name|getc
argument_list|(
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
return|return;
block|}
name|address
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|isgraphic
argument_list|(
name|c
argument_list|)
condition|)
comment|/* Found a non-graphic.  Try again starting with next char.  */
goto|goto
name|tryline
goto|;
name|buf
index|[
name|i
index|]
operator|=
name|c
expr_stmt|;
block|}
comment|/* We found a run of `string_min' graphic characters.  Print up          to the next non-graphic character.  */
if|if
condition|(
name|print_filenames
condition|)
name|printf
argument_list|(
literal|"%s: "
argument_list|,
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|print_addresses
condition|)
switch|switch
condition|(
name|address_radix
condition|)
block|{
case|case
literal|8
case|:
name|printf
argument_list|(
literal|"%7lo "
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|start
argument_list|)
expr_stmt|;
break|break;
case|case
literal|10
case|:
name|printf
argument_list|(
literal|"%7ld "
argument_list|,
operator|(
name|long
operator|)
name|start
argument_list|)
expr_stmt|;
break|break;
case|case
literal|16
case|:
name|printf
argument_list|(
literal|"%7lx "
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|start
argument_list|)
expr_stmt|;
break|break;
block|}
name|buf
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
name|fputs
argument_list|(
name|buf
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|magiccount
condition|)
block|{
name|magiccount
operator|--
expr_stmt|;
name|c
operator|=
operator|*
name|magic
operator|++
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|stream
operator|==
name|NULL
condition|)
break|break;
name|c
operator|=
name|getc
argument_list|(
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
break|break;
block|}
name|address
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|isgraphic
argument_list|(
name|c
argument_list|)
condition|)
break|break;
name|putchar
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Parse string S as an integer, using decimal radix by default,    but allowing octal and hex numbers as in C.  */
end_comment

begin_function
specifier|static
name|int
name|integer_arg
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|int
name|value
decl_stmt|;
name|int
name|radix
init|=
literal|10
decl_stmt|;
name|char
modifier|*
name|p
init|=
name|s
decl_stmt|;
name|int
name|c
decl_stmt|;
if|if
condition|(
operator|*
name|p
operator|!=
literal|'0'
condition|)
name|radix
operator|=
literal|10
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
operator|++
name|p
operator|==
literal|'x'
condition|)
block|{
name|radix
operator|=
literal|16
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
else|else
name|radix
operator|=
literal|8
expr_stmt|;
name|value
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
operator|(
name|c
operator|=
operator|*
name|p
operator|++
operator|)
operator|>=
literal|'0'
operator|&&
name|c
operator|<=
literal|'9'
operator|)
operator|||
operator|(
name|radix
operator|==
literal|16
operator|&&
operator|(
name|c
operator|&
operator|~
literal|40
operator|)
operator|>=
literal|'A'
operator|&&
operator|(
name|c
operator|&
operator|~
literal|40
operator|)
operator|<=
literal|'Z'
operator|)
condition|)
block|{
name|value
operator|*=
name|radix
expr_stmt|;
if|if
condition|(
name|c
operator|>=
literal|'0'
operator|&&
name|c
operator|<=
literal|'9'
condition|)
name|value
operator|+=
name|c
operator|-
literal|'0'
expr_stmt|;
else|else
name|value
operator|+=
operator|(
name|c
operator|&
operator|~
literal|40
operator|)
operator|-
literal|'A'
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|==
literal|'b'
condition|)
name|value
operator|*=
literal|512
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'B'
condition|)
name|value
operator|*=
literal|1024
expr_stmt|;
else|else
name|p
operator|--
expr_stmt|;
if|if
condition|(
operator|*
name|p
condition|)
block|{
name|fatal
argument_list|(
name|_
argument_list|(
literal|"invalid integer argument %s"
argument_list|)
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
return|return
name|value
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|usage
parameter_list|(
name|stream
parameter_list|,
name|status
parameter_list|)
name|FILE
modifier|*
name|stream
decl_stmt|;
name|int
name|status
decl_stmt|;
block|{
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"\ Usage: %s [-afov] [-n min-len] [-min-len] [-t {o,x,d}] [-]\n\        [--all] [--print-file-name] [--bytes=min-len] [--radix={o,x,d}]\n\        [--target=bfdname] [--help] [--version] file...\n"
argument_list|)
argument_list|,
name|program_name
argument_list|)
expr_stmt|;
name|list_supported_targets
argument_list|(
name|program_name
argument_list|,
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
literal|0
condition|)
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"Report bugs to %s\n"
argument_list|)
argument_list|,
name|REPORT_BUGS_TO
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|status
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

