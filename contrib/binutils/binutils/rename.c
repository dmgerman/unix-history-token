begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* rename.c -- rename a file, preserving symlinks.    Copyright 1999 Free Software Foundation, Inc.     This file is part of GNU Binutils.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA    02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"bucomm.h"
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_GOOD_UTIME_H
end_ifdef

begin_include
include|#
directive|include
file|<utime.h>
end_include

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* ! HAVE_GOOD_UTIME_H */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_UTIMES
end_ifdef

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_UTIMES */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ! HAVE_GOOD_UTIME_H */
end_comment

begin_comment
comment|/* We need to open the file in binary modes on system where that makes    a difference.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|O_BINARY
end_ifndef

begin_define
define|#
directive|define
name|O_BINARY
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|int
name|simple_copy
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The number of bytes to copy at once.  */
end_comment

begin_define
define|#
directive|define
name|COPY_BUF
value|8192
end_define

begin_comment
comment|/* Copy file FROM to file TO, performing no translations.    Return 0 if ok, -1 if error.  */
end_comment

begin_function
specifier|static
name|int
name|simple_copy
parameter_list|(
name|from
parameter_list|,
name|to
parameter_list|)
specifier|const
name|char
modifier|*
name|from
decl_stmt|;
specifier|const
name|char
modifier|*
name|to
decl_stmt|;
block|{
name|int
name|fromfd
decl_stmt|,
name|tofd
decl_stmt|,
name|nread
decl_stmt|;
name|int
name|saved
decl_stmt|;
name|char
name|buf
index|[
name|COPY_BUF
index|]
decl_stmt|;
name|fromfd
operator|=
name|open
argument_list|(
name|from
argument_list|,
name|O_RDONLY
operator||
name|O_BINARY
argument_list|)
expr_stmt|;
if|if
condition|(
name|fromfd
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
ifdef|#
directive|ifdef
name|O_CREAT
name|tofd
operator|=
name|open
argument_list|(
name|to
argument_list|,
name|O_CREAT
operator||
name|O_WRONLY
operator||
name|O_TRUNC
operator||
name|O_BINARY
argument_list|,
literal|0777
argument_list|)
expr_stmt|;
else|#
directive|else
name|tofd
operator|=
name|creat
argument_list|(
name|to
argument_list|,
literal|0777
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|tofd
operator|<
literal|0
condition|)
block|{
name|saved
operator|=
name|errno
expr_stmt|;
name|close
argument_list|(
name|fromfd
argument_list|)
expr_stmt|;
name|errno
operator|=
name|saved
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
while|while
condition|(
operator|(
name|nread
operator|=
name|read
argument_list|(
name|fromfd
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|write
argument_list|(
name|tofd
argument_list|,
name|buf
argument_list|,
name|nread
argument_list|)
operator|!=
name|nread
condition|)
block|{
name|saved
operator|=
name|errno
expr_stmt|;
name|close
argument_list|(
name|fromfd
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|tofd
argument_list|)
expr_stmt|;
name|errno
operator|=
name|saved
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
name|saved
operator|=
name|errno
expr_stmt|;
name|close
argument_list|(
name|fromfd
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|tofd
argument_list|)
expr_stmt|;
if|if
condition|(
name|nread
operator|<
literal|0
condition|)
block|{
name|errno
operator|=
name|saved
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Set the times of the file DESTINATION to be the same as those in    STATBUF.  */
end_comment

begin_function
name|void
name|set_times
parameter_list|(
name|destination
parameter_list|,
name|statbuf
parameter_list|)
specifier|const
name|char
modifier|*
name|destination
decl_stmt|;
specifier|const
name|struct
name|stat
modifier|*
name|statbuf
decl_stmt|;
block|{
name|int
name|result
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|HAVE_GOOD_UTIME_H
name|struct
name|utimbuf
name|tb
decl_stmt|;
name|tb
operator|.
name|actime
operator|=
name|statbuf
operator|->
name|st_atime
expr_stmt|;
name|tb
operator|.
name|modtime
operator|=
name|statbuf
operator|->
name|st_mtime
expr_stmt|;
name|result
operator|=
name|utime
argument_list|(
name|destination
argument_list|,
operator|&
name|tb
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* ! HAVE_GOOD_UTIME_H */
ifndef|#
directive|ifndef
name|HAVE_UTIMES
name|long
name|tb
index|[
literal|2
index|]
decl_stmt|;
name|tb
index|[
literal|0
index|]
operator|=
name|statbuf
operator|->
name|st_atime
expr_stmt|;
name|tb
index|[
literal|1
index|]
operator|=
name|statbuf
operator|->
name|st_mtime
expr_stmt|;
name|result
operator|=
name|utime
argument_list|(
name|destination
argument_list|,
name|tb
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* HAVE_UTIMES */
name|struct
name|timeval
name|tv
index|[
literal|2
index|]
decl_stmt|;
name|tv
index|[
literal|0
index|]
operator|.
name|tv_sec
operator|=
name|statbuf
operator|->
name|st_atime
expr_stmt|;
name|tv
index|[
literal|0
index|]
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
name|tv
index|[
literal|1
index|]
operator|.
name|tv_sec
operator|=
name|statbuf
operator|->
name|st_mtime
expr_stmt|;
name|tv
index|[
literal|1
index|]
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
name|result
operator|=
name|utimes
argument_list|(
name|destination
argument_list|,
name|tv
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_UTIMES */
endif|#
directive|endif
comment|/* ! HAVE_GOOD_UTIME_H */
block|}
if|if
condition|(
name|result
operator|!=
literal|0
condition|)
name|non_fatal
argument_list|(
name|_
argument_list|(
literal|"%s: cannot set time: %s"
argument_list|)
argument_list|,
name|destination
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|S_ISLNK
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|S_IFLNK
end_ifdef

begin_define
define|#
directive|define
name|S_ISLNK
parameter_list|(
name|m
parameter_list|)
value|(((m)& S_IFMT) == S_IFLNK)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|S_ISLNK
parameter_list|(
name|m
parameter_list|)
value|0
end_define

begin_define
define|#
directive|define
name|lstat
value|stat
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Rename FROM to TO, copying if TO is a link.    Return 0 if ok, -1 if error.  */
end_comment

begin_function
name|int
name|smart_rename
parameter_list|(
name|from
parameter_list|,
name|to
parameter_list|,
name|preserve_dates
parameter_list|)
specifier|const
name|char
modifier|*
name|from
decl_stmt|;
specifier|const
name|char
modifier|*
name|to
decl_stmt|;
name|int
name|preserve_dates
decl_stmt|;
block|{
name|boolean
name|exists
decl_stmt|;
name|struct
name|stat
name|s
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|exists
operator|=
name|lstat
argument_list|(
name|to
argument_list|,
operator|&
name|s
argument_list|)
operator|==
literal|0
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__CYGWIN32__
argument_list|)
comment|/* Win32, unlike unix, will not erase `to' in `rename(from, to)' but      fail instead.  Also, chown is not present.  */
if|if
condition|(
name|exists
condition|)
name|remove
argument_list|(
name|to
argument_list|)
expr_stmt|;
name|ret
operator|=
name|rename
argument_list|(
name|from
argument_list|,
name|to
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
comment|/* We have to clean up here. */
name|non_fatal
argument_list|(
name|_
argument_list|(
literal|"%s: rename: %s"
argument_list|)
argument_list|,
name|to
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|from
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
comment|/* Use rename only if TO is not a symbolic link and has      only one hard link.  */
if|if
condition|(
operator|!
name|exists
operator|||
operator|(
operator|!
name|S_ISLNK
argument_list|(
name|s
operator|.
name|st_mode
argument_list|)
operator|&&
name|s
operator|.
name|st_nlink
operator|==
literal|1
operator|)
condition|)
block|{
name|ret
operator|=
name|rename
argument_list|(
name|from
argument_list|,
name|to
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|exists
condition|)
block|{
comment|/* Try to preserve the permission bits and ownership of 		 TO.  First get the mode right except for the setuid 		 bit.  Then change the ownership.  Then fix the setuid 		 bit.  We do the chmod before the chown because if the 		 chown succeeds, and we are a normal user, we won't be 		 able to do the chmod afterward.  We don't bother to 		 fix the setuid bit first because that might introduce 		 a fleeting security problem, and because the chown 		 will clear the setuid bit anyhow.  We only fix the 		 setuid bit if the chown succeeds, because we don't 		 want to introduce an unexpected setuid file owned by 		 the user running objcopy.  */
name|chmod
argument_list|(
name|to
argument_list|,
name|s
operator|.
name|st_mode
operator|&
literal|0777
argument_list|)
expr_stmt|;
if|if
condition|(
name|chown
argument_list|(
name|to
argument_list|,
name|s
operator|.
name|st_uid
argument_list|,
name|s
operator|.
name|st_gid
argument_list|)
operator|>=
literal|0
condition|)
name|chmod
argument_list|(
name|to
argument_list|,
name|s
operator|.
name|st_mode
operator|&
literal|07777
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* We have to clean up here. */
name|non_fatal
argument_list|(
name|_
argument_list|(
literal|"%s: rename: %s"
argument_list|)
argument_list|,
name|to
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|from
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|ret
operator|=
name|simple_copy
argument_list|(
name|from
argument_list|,
name|to
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
name|non_fatal
argument_list|(
name|_
argument_list|(
literal|"%s: simple_copy: %s"
argument_list|)
argument_list|,
name|to
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|preserve_dates
condition|)
name|set_times
argument_list|(
name|to
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|from
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* _WIN32&& !__CYGWIN32__ */
return|return
name|ret
return|;
block|}
end_function

end_unit

