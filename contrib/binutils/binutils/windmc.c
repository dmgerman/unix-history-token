begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* windmc.c -- a program to compile Windows message files.    Copyright 2007    Free Software Foundation, Inc.    Written by Kai Tietz, Onevision.     This file is part of GNU Binutils.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA    02110-1301, USA.  */
end_comment

begin_comment
comment|/* This program can read and comile Windows message format.     It is based on information taken from the following sources:     * Microsoft documentation.     * The wmc program, written by Bertho A. Stultiens (BS). */
end_comment

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"getopt.h"
end_include

begin_include
include|#
directive|include
file|"bucomm.h"
end_include

begin_include
include|#
directive|include
file|"libiberty.h"
end_include

begin_include
include|#
directive|include
file|"safe-ctype.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_include
include|#
directive|include
file|"windmc.h"
end_include

begin_include
include|#
directive|include
file|"windint.h"
end_include

begin_comment
comment|/* Defines a message compiler element item with length and offset    information.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|mc_msg_item
block|{
name|rc_uint_type
name|res_len
decl_stmt|;
name|rc_uint_type
name|res_off
decl_stmt|;
name|struct
name|bin_messagetable_item
modifier|*
name|res
decl_stmt|;
block|}
name|mc_msg_item
typedef|;
end_typedef

begin_comment
comment|/* Defined in bfd/binary.c.  Used to set architecture and machine of input    binary files.  */
end_comment

begin_decl_stmt
specifier|extern
name|enum
name|bfd_architecture
name|bfd_external_binary_architecture
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|unsigned
name|long
name|bfd_external_machine
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|target_is_bigendian
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
modifier|*
name|def_target_arch
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Globals and static variable definitions. */
end_comment

begin_comment
comment|/* bfd global helper struct variable.  */
end_comment

begin_struct
specifier|static
struct|struct
block|{
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
block|}
name|mc_bfd
struct|;
end_struct

begin_comment
comment|/* Memory list.  */
end_comment

begin_decl_stmt
name|mc_node
modifier|*
name|mc_nodes
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|mc_node_lang
modifier|*
modifier|*
name|mc_nodes_lang
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|mc_nodes_lang_count
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|mc_keyword
modifier|*
modifier|*
name|mc_severity_codes
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|mc_severity_codes_count
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|mc_keyword
modifier|*
modifier|*
name|mc_facility_codes
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|mc_facility_codes_count
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* When we are building a resource tree, we allocate everything onto    an obstack, so that we can free it all at once if we want.  */
end_comment

begin_define
define|#
directive|define
name|obstack_chunk_alloc
value|xmalloc
end_define

begin_define
define|#
directive|define
name|obstack_chunk_free
value|free
end_define

begin_comment
comment|/* The resource building obstack.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|obstack
name|res_obstack
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Flag variables.  */
end_comment

begin_comment
comment|/* Set by -C. Set the default code page to be used for input text file.  */
end_comment

begin_decl_stmt
specifier|static
name|rc_uint_type
name|mcset_codepage_in
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set by -O. Set the default code page to be used for output text files.  */
end_comment

begin_decl_stmt
specifier|static
name|rc_uint_type
name|mcset_codepage_out
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set by -b. .BIN filename should have .mc filename_ included for uniqueness.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|mcset_prefix_bin
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The base name of the .mc file.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|mcset_mc_basename
init|=
literal|"unknown"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set by -e<ext>. Specify the extension for the header file.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|mcset_header_ext
init|=
literal|".h"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set by -h<path>. Gives the path of where to create the C include file.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|mcset_header_dir
init|=
literal|"./"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set by -r<path>. Gives the path of where to create the RC include file    and the binary message resource files it includes. */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|mcset_rc_dir
init|=
literal|"./"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Modified by -a& -u. By -u input file is unicode, by -a is ASCII (default).  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|mcset_text_in_is_unicode
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Modified by -A& -U. By -U bin file is unicode (default), by -A is ASCII.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|mcset_bin_out_is_unicode
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set by -c. Sets the Customer bit in all the message ID's.  */
end_comment

begin_decl_stmt
name|int
name|mcset_custom_bit
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set by -o. Generate OLE2 header file. Use HRESULT definition instead of    status code definition.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|mcset_use_hresult
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set by -m<msglen>. Generate a warning if the size of any message exceeds    maxmsglen characters.  */
end_comment

begin_decl_stmt
name|rc_uint_type
name|mcset_max_message_length
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set by -d. Sets message values in header to decimal initially.  */
end_comment

begin_decl_stmt
name|int
name|mcset_out_values_are_decimal
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set by -n. terminates all strings with null's in the message tables.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|mcset_automatic_null_termination
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The type used for message id output in header.  */
end_comment

begin_decl_stmt
name|unichar
modifier|*
name|mcset_msg_id_typedef
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set by -x path. Geberated debug C file for mapping ID's to text.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|mcset_dbg_dir
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* getopt long name definitions.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|option
name|long_options
index|[]
init|=
block|{
block|{
literal|"binprefix"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'b'
block|}
block|,
block|{
literal|"target"
block|,
name|required_argument
block|,
literal|0
block|,
literal|'F'
block|}
block|,
block|{
literal|"extension"
block|,
name|required_argument
block|,
literal|0
block|,
literal|'e'
block|}
block|,
block|{
literal|"headerdir"
block|,
name|required_argument
block|,
literal|0
block|,
literal|'h'
block|}
block|,
block|{
literal|"rcdir"
block|,
name|required_argument
block|,
literal|0
block|,
literal|'r'
block|}
block|,
block|{
literal|"verbose"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'v'
block|}
block|,
block|{
literal|"codepage_in"
block|,
name|required_argument
block|,
literal|0
block|,
literal|'C'
block|}
block|,
block|{
literal|"codepage_out"
block|,
name|required_argument
block|,
literal|0
block|,
literal|'O'
block|}
block|,
block|{
literal|"maxlength"
block|,
name|required_argument
block|,
literal|0
block|,
literal|'m'
block|}
block|,
block|{
literal|"ascii_in"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'a'
block|}
block|,
block|{
literal|"ascii_out"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'A'
block|}
block|,
block|{
literal|"unicode_in"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'u'
block|}
block|,
block|{
literal|"unicode_out"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'U'
block|}
block|,
block|{
literal|"customflag"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'c'
block|}
block|,
block|{
literal|"decimal_values"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'d'
block|}
block|,
block|{
literal|"hresult_use"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'o'
block|}
block|,
block|{
literal|"nullterminate"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'n'
block|}
block|,
block|{
literal|"xdbg"
block|,
name|required_argument
block|,
literal|0
block|,
literal|'x'
block|}
block|,
block|{
literal|"version"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'V'
block|}
block|,
block|{
literal|"help"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'H'
block|}
block|,
block|{
literal|0
block|,
name|no_argument
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Initialize the resource building obstack.  */
end_comment

begin_function
specifier|static
name|void
name|res_init
parameter_list|(
name|void
parameter_list|)
block|{
name|obstack_init
argument_list|(
operator|&
name|res_obstack
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Allocate space on the resource building obstack.  */
end_comment

begin_function
name|void
modifier|*
name|res_alloc
parameter_list|(
name|rc_uint_type
name|bytes
parameter_list|)
block|{
return|return
operator|(
name|void
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|res_obstack
argument_list|,
operator|(
name|size_t
operator|)
name|bytes
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|FILE
modifier|*
name|mc_create_path_text_file
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
specifier|const
name|char
modifier|*
name|ext
parameter_list|)
block|{
name|FILE
modifier|*
name|ret
decl_stmt|;
name|size_t
name|len
init|=
literal|1
decl_stmt|;
name|char
modifier|*
name|hsz
decl_stmt|;
name|len
operator|+=
operator|(
name|path
operator|!=
name|NULL
condition|?
name|strlen
argument_list|(
name|path
argument_list|)
else|:
literal|0
operator|)
expr_stmt|;
name|len
operator|+=
name|strlen
argument_list|(
name|mcset_mc_basename
argument_list|)
expr_stmt|;
name|len
operator|+=
operator|(
name|ext
operator|!=
name|NULL
condition|?
name|strlen
argument_list|(
name|ext
argument_list|)
else|:
literal|0
operator|)
expr_stmt|;
name|hsz
operator|=
name|xmalloc
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|hsz
argument_list|,
literal|"%s%s%s"
argument_list|,
operator|(
name|path
operator|!=
name|NULL
condition|?
name|path
else|:
literal|""
operator|)
argument_list|,
name|mcset_mc_basename
argument_list|,
operator|(
name|ext
operator|!=
name|NULL
condition|?
name|ext
else|:
literal|""
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ret
operator|=
name|fopen
argument_list|(
name|hsz
argument_list|,
literal|"wb"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
name|_
argument_list|(
literal|"can't create %s file ,%s' for output.\n"
argument_list|)
argument_list|,
operator|(
name|ext
condition|?
name|ext
else|:
literal|"text"
operator|)
argument_list|,
name|hsz
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|hsz
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|usage
parameter_list|(
name|FILE
modifier|*
name|stream
parameter_list|,
name|int
name|status
parameter_list|)
block|{
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"Usage: %s [option(s)] [input-file]\n"
argument_list|)
argument_list|,
name|program_name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|" The options are:\n\   -a --ascii_in                Read input file as ASCII file\n\   -A --ascii_out               Write binary messages as ASCII\n\   -b --binprefix               .bin filename is prefixed by .mc filename_ for uniqueness.\n\   -c --customflag              Set custom flags for messages\n\   -C --codepage_in=<val>       Set codepage when reading mc text file\n\   -d --decimal_values          Print values to text files decimal\n\   -e --extension=<extension>   Set header extension used on export header file\n\   -F --target<target>         Specify output target for endianess.\n\   -h --headerdir=<directory>   Set the export directory for headers\n\   -u --unicode_in              Read input file as UTF16 file\n\   -U --unicode_out             Write binary messages as UFT16\n\   -m --maxlength=<val>         Set the maximal allowed message length\n\   -n --nullterminate           Automatic add a zero termination to strings\n\   -o --hresult_use             Use HRESULT definition instead of status code definition\n\   -O --codepage_out=<val>      Set codepage used for writing text file\n\   -r --rcdir=<directory>       Set the export directory for rc files\n\   -x --xdbg=<directory>        Where to create the .dbg C include file\n\                                that maps message ID's to their symbolic name.\n\ "
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"\   -H --help                    Print this help message\n\   -v --verbose                 Verbose - tells you what it's doing\n\   -V --version                 Print version information\n"
argument_list|)
argument_list|)
expr_stmt|;
name|list_supported_targets
argument_list|(
name|program_name
argument_list|,
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|REPORT_BUGS_TO
index|[
literal|0
index|]
operator|&&
name|status
operator|==
literal|0
condition|)
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"Report bugs to %s\n"
argument_list|)
argument_list|,
name|REPORT_BUGS_TO
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|status
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|set_endianess
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
specifier|const
name|char
modifier|*
name|target
parameter_list|)
block|{
specifier|const
name|bfd_target
modifier|*
name|target_vec
decl_stmt|;
name|def_target_arch
operator|=
name|NULL
expr_stmt|;
name|target_vec
operator|=
name|bfd_find_target
argument_list|(
name|target
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|target_vec
condition|)
name|fatal
argument_list|(
literal|"Can't detect target endianess and architecture."
argument_list|)
expr_stmt|;
name|target_is_bigendian
operator|=
operator|(
operator|(
name|target_vec
operator|->
name|byteorder
operator|==
name|BFD_ENDIAN_BIG
operator|)
condition|?
literal|1
else|:
literal|0
operator|)
expr_stmt|;
block|{
specifier|const
name|char
modifier|*
name|tname
init|=
name|target_vec
operator|->
name|name
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|arch
init|=
name|bfd_arch_list
argument_list|()
decl_stmt|;
if|if
condition|(
name|arch
operator|&&
name|tname
condition|)
block|{
if|if
condition|(
name|strchr
argument_list|(
name|tname
argument_list|,
literal|'-'
argument_list|)
operator|!=
name|NULL
condition|)
name|tname
operator|=
name|strchr
argument_list|(
name|tname
argument_list|,
literal|'-'
argument_list|)
operator|+
literal|1
expr_stmt|;
while|while
condition|(
operator|*
name|arch
operator|!=
name|NULL
condition|)
block|{
specifier|const
name|char
modifier|*
name|in_a
init|=
name|strstr
argument_list|(
operator|*
name|arch
argument_list|,
name|tname
argument_list|)
decl_stmt|;
name|char
name|end_ch
init|=
operator|(
name|in_a
condition|?
name|in_a
index|[
name|strlen
argument_list|(
name|tname
argument_list|)
index|]
else|:
literal|0
operator|)
decl_stmt|;
if|if
condition|(
name|in_a
operator|&&
operator|(
name|in_a
operator|==
operator|*
name|arch
operator|||
name|in_a
index|[
operator|-
literal|1
index|]
operator|==
literal|':'
operator|)
operator|&&
name|end_ch
operator|==
literal|0
condition|)
block|{
name|def_target_arch
operator|=
operator|*
name|arch
expr_stmt|;
break|break;
block|}
name|arch
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|def_target_arch
condition|)
name|fatal
argument_list|(
literal|"Can't detect architecture."
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|probe_codepage
parameter_list|(
name|rc_uint_type
modifier|*
name|cp
parameter_list|,
name|int
modifier|*
name|is_uni
parameter_list|,
specifier|const
name|char
modifier|*
name|pswitch
parameter_list|,
name|int
name|defmode
parameter_list|)
block|{
if|if
condition|(
operator|*
name|is_uni
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
operator|*
name|cp
operator|!=
name|CP_UTF16
condition|)
operator|*
name|is_uni
operator|=
name|defmode
expr_stmt|;
else|else
operator|*
name|is_uni
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|is_uni
condition|)
block|{
if|if
condition|(
operator|*
name|cp
operator|!=
literal|0
operator|&&
operator|*
name|cp
operator|!=
name|CP_UTF16
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"%s: warning: "
argument_list|)
argument_list|,
name|program_name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"A codepage was specified switch ,%s' and UTF16.\n"
argument_list|)
argument_list|,
name|pswitch
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"\tcodepage settings are ignored.\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
operator|*
name|cp
operator|=
name|CP_UTF16
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
operator|*
name|cp
operator|==
name|CP_UTF16
condition|)
block|{
operator|*
name|is_uni
operator|=
literal|1
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
operator|*
name|cp
operator|==
literal|0
condition|)
operator|*
name|cp
operator|=
literal|1252
expr_stmt|;
if|if
condition|(
operator|!
name|unicode_is_valid_codepage
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
name|fatal
argument_list|(
literal|"Code page 0x%x is unknown."
argument_list|,
operator|(
name|unsigned
name|int
operator|)
operator|*
name|cp
argument_list|)
expr_stmt|;
operator|*
name|is_uni
operator|=
literal|0
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
name|mc_node
modifier|*
name|mc_add_node
parameter_list|(
name|void
parameter_list|)
block|{
name|mc_node
modifier|*
name|ret
decl_stmt|;
name|ret
operator|=
name|res_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|mc_node
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|ret
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|mc_node
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mc_nodes
condition|)
name|mc_nodes
operator|=
name|ret
expr_stmt|;
else|else
block|{
name|mc_node
modifier|*
name|h
init|=
name|mc_nodes
decl_stmt|;
while|while
condition|(
name|h
operator|->
name|next
operator|!=
name|NULL
condition|)
name|h
operator|=
name|h
operator|->
name|next
expr_stmt|;
name|h
operator|->
name|next
operator|=
name|ret
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_function
name|mc_node_lang
modifier|*
name|mc_add_node_lang
parameter_list|(
name|mc_node
modifier|*
name|root
parameter_list|,
specifier|const
name|mc_keyword
modifier|*
name|lang
parameter_list|,
name|rc_uint_type
name|vid
parameter_list|)
block|{
name|mc_node_lang
modifier|*
name|ret
decl_stmt|,
modifier|*
name|h
decl_stmt|,
modifier|*
name|p
decl_stmt|;
if|if
condition|(
operator|!
name|lang
operator|||
operator|!
name|root
condition|)
name|fatal
argument_list|(
name|_
argument_list|(
literal|"try to add a ill language."
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|res_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|mc_node_lang
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|ret
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|mc_node_lang
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|->
name|lang
operator|=
name|lang
expr_stmt|;
name|ret
operator|->
name|vid
operator|=
name|vid
expr_stmt|;
if|if
condition|(
operator|(
name|h
operator|=
name|root
operator|->
name|sub
operator|)
operator|==
name|NULL
condition|)
name|root
operator|->
name|sub
operator|=
name|ret
expr_stmt|;
else|else
block|{
name|p
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
name|h
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|h
operator|->
name|lang
operator|->
name|nval
operator|>
name|lang
operator|->
name|nval
condition|)
break|break;
if|if
condition|(
name|h
operator|->
name|lang
operator|->
name|nval
operator|==
name|lang
operator|->
name|nval
condition|)
block|{
if|if
condition|(
name|h
operator|->
name|vid
operator|>
name|vid
condition|)
break|break;
if|if
condition|(
name|h
operator|->
name|vid
operator|==
name|vid
condition|)
name|fatal
argument_list|(
literal|"double defined message id %ld.\n"
argument_list|,
operator|(
name|long
operator|)
name|vid
argument_list|)
expr_stmt|;
block|}
name|h
operator|=
operator|(
name|p
operator|=
name|h
operator|)
operator|->
name|next
expr_stmt|;
block|}
name|ret
operator|->
name|next
operator|=
name|h
expr_stmt|;
if|if
condition|(
operator|!
name|p
condition|)
name|root
operator|->
name|sub
operator|=
name|ret
expr_stmt|;
else|else
name|p
operator|->
name|next
operator|=
name|ret
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|convert_unicode_to_ACP
parameter_list|(
specifier|const
name|unichar
modifier|*
name|usz
parameter_list|)
block|{
name|char
modifier|*
name|s
decl_stmt|;
name|rc_uint_type
name|l
decl_stmt|;
if|if
condition|(
operator|!
name|usz
condition|)
return|return
name|NULL
return|;
name|codepage_from_unicode
argument_list|(
operator|&
name|l
argument_list|,
name|usz
argument_list|,
operator|&
name|s
argument_list|,
name|mcset_codepage_out
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|s
condition|)
name|fatal
argument_list|(
literal|"unicode string not mappable to ASCII codepage 0x%lx.\n"
argument_list|,
operator|(
name|long
operator|)
name|mcset_codepage_out
argument_list|)
expr_stmt|;
return|return
name|s
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|write_dbg_define
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
specifier|const
name|unichar
modifier|*
name|sym_name
parameter_list|,
specifier|const
name|unichar
modifier|*
name|typecast
parameter_list|)
block|{
name|char
modifier|*
name|sym
decl_stmt|;
if|if
condition|(
operator|!
name|sym_name
operator|||
name|sym_name
index|[
literal|0
index|]
operator|==
literal|0
condition|)
return|return;
name|sym
operator|=
name|convert_unicode_to_ACP
argument_list|(
name|sym_name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"  {("
argument_list|)
expr_stmt|;
if|if
condition|(
name|typecast
condition|)
name|unicode_print
argument_list|(
name|fp
argument_list|,
name|typecast
argument_list|,
name|unichar_len
argument_list|(
name|typecast
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"DWORD"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|") %s, \"%s\" },\n"
argument_list|,
name|sym
argument_list|,
name|sym
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|write_header_define
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
specifier|const
name|unichar
modifier|*
name|sym_name
parameter_list|,
name|rc_uint_type
name|vid
parameter_list|,
specifier|const
name|unichar
modifier|*
name|typecast
parameter_list|,
name|mc_node_lang
modifier|*
name|nl
parameter_list|)
block|{
name|char
modifier|*
name|sym
decl_stmt|;
name|char
modifier|*
name|tdef
init|=
name|NULL
decl_stmt|;
if|if
condition|(
operator|!
name|sym_name
operator|||
name|sym_name
index|[
literal|0
index|]
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|nl
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|mcset_out_values_are_decimal
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"//\n// MessageId: 0x%lu\n//\n"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|vid
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"//\n// MessageId: 0x%lx\n//\n"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|vid
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
name|sym
operator|=
name|convert_unicode_to_ACP
argument_list|(
name|sym_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|typecast
operator|&&
name|typecast
index|[
literal|0
index|]
operator|!=
literal|0
condition|)
name|tdef
operator|=
name|convert_unicode_to_ACP
argument_list|(
name|typecast
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"//\n// MessageId: %s\n//\n"
argument_list|,
name|sym
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mcset_out_values_are_decimal
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"#define %s %s%s%s 0x%lx\n\n"
argument_list|,
name|sym
argument_list|,
operator|(
name|tdef
condition|?
literal|"("
else|:
literal|""
operator|)
argument_list|,
operator|(
name|tdef
condition|?
name|tdef
else|:
literal|""
operator|)
argument_list|,
operator|(
name|tdef
condition|?
literal|")"
else|:
literal|""
operator|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|vid
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"#define %s %s%s%s 0x%lu\n\n"
argument_list|,
name|sym
argument_list|,
operator|(
name|tdef
condition|?
literal|"("
else|:
literal|""
operator|)
argument_list|,
operator|(
name|tdef
condition|?
name|tdef
else|:
literal|""
operator|)
argument_list|,
operator|(
name|tdef
condition|?
literal|")"
else|:
literal|""
operator|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|vid
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|sort_mc_node_lang
parameter_list|(
specifier|const
name|void
modifier|*
name|l
parameter_list|,
specifier|const
name|void
modifier|*
name|r
parameter_list|)
block|{
specifier|const
name|mc_node_lang
modifier|*
name|l1
init|=
operator|*
operator|(
operator|(
specifier|const
name|mc_node_lang
operator|*
operator|*
operator|)
name|l
operator|)
decl_stmt|;
specifier|const
name|mc_node_lang
modifier|*
name|r1
init|=
operator|*
operator|(
operator|(
specifier|const
name|mc_node_lang
operator|*
operator|*
operator|)
name|r
operator|)
decl_stmt|;
if|if
condition|(
name|l
operator|==
name|r
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|l1
operator|->
name|lang
operator|!=
name|r1
operator|->
name|lang
condition|)
block|{
if|if
condition|(
name|l1
operator|->
name|lang
operator|->
name|nval
operator|<
name|r1
operator|->
name|lang
operator|->
name|nval
condition|)
return|return
operator|-
literal|1
return|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|l1
operator|->
name|vid
operator|==
name|r1
operator|->
name|vid
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|l1
operator|->
name|vid
operator|<
name|r1
operator|->
name|vid
condition|)
return|return
operator|-
literal|1
return|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sort_keyword_by_nval
parameter_list|(
specifier|const
name|void
modifier|*
name|l
parameter_list|,
specifier|const
name|void
modifier|*
name|r
parameter_list|)
block|{
specifier|const
name|mc_keyword
modifier|*
name|l1
init|=
operator|*
operator|(
operator|(
specifier|const
name|mc_keyword
operator|*
operator|*
operator|)
name|l
operator|)
decl_stmt|;
specifier|const
name|mc_keyword
modifier|*
name|r1
init|=
operator|*
operator|(
operator|(
specifier|const
name|mc_keyword
operator|*
operator|*
operator|)
name|r
operator|)
decl_stmt|;
name|rc_uint_type
name|len1
decl_stmt|,
name|len2
decl_stmt|;
name|int
name|e
decl_stmt|;
if|if
condition|(
name|l
operator|==
name|r
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|l1
operator|->
name|nval
operator|!=
name|r1
operator|->
name|nval
condition|)
block|{
if|if
condition|(
name|l1
operator|->
name|nval
operator|<
name|r1
operator|->
name|nval
condition|)
return|return
operator|-
literal|1
return|;
return|return
literal|1
return|;
block|}
name|len1
operator|=
name|unichar_len
argument_list|(
name|l1
operator|->
name|usz
argument_list|)
expr_stmt|;
name|len2
operator|=
name|unichar_len
argument_list|(
name|r1
operator|->
name|usz
argument_list|)
expr_stmt|;
if|if
condition|(
name|len1
operator|<=
name|len2
condition|)
name|e
operator|=
name|memcmp
argument_list|(
name|l1
operator|->
name|usz
argument_list|,
name|r1
operator|->
name|usz
argument_list|,
sizeof|sizeof
argument_list|(
name|unichar
argument_list|)
operator|*
name|len1
argument_list|)
expr_stmt|;
else|else
name|e
operator|=
name|memcmp
argument_list|(
name|l1
operator|->
name|usz
argument_list|,
name|r1
operator|->
name|usz
argument_list|,
sizeof|sizeof
argument_list|(
name|unichar
argument_list|)
operator|*
name|len2
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
condition|)
return|return
name|e
return|;
if|if
condition|(
name|len1
operator|<
name|len2
condition|)
return|return
operator|-
literal|1
return|;
elseif|else
if|if
condition|(
name|len1
operator|>
name|len2
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_sorts
parameter_list|(
name|void
parameter_list|)
block|{
name|mc_node
modifier|*
name|h
decl_stmt|;
name|mc_node_lang
modifier|*
name|n
decl_stmt|;
specifier|const
name|mc_keyword
modifier|*
name|k
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Sort message by their language and id ascending.  */
name|mc_nodes_lang_count
operator|=
literal|0
expr_stmt|;
name|h
operator|=
name|mc_nodes
expr_stmt|;
while|while
condition|(
name|h
operator|!=
name|NULL
condition|)
block|{
name|n
operator|=
name|h
operator|->
name|sub
expr_stmt|;
while|while
condition|(
name|n
operator|!=
name|NULL
condition|)
block|{
name|mc_nodes_lang_count
operator|+=
literal|1
expr_stmt|;
name|n
operator|=
name|n
operator|->
name|next
expr_stmt|;
block|}
name|h
operator|=
name|h
operator|->
name|next
expr_stmt|;
block|}
if|if
condition|(
name|mc_nodes_lang_count
operator|!=
literal|0
condition|)
block|{
name|h
operator|=
name|mc_nodes
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|mc_nodes_lang
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|mc_node_lang
operator|*
argument_list|)
operator|*
name|mc_nodes_lang_count
argument_list|)
expr_stmt|;
while|while
condition|(
name|h
operator|!=
name|NULL
condition|)
block|{
name|n
operator|=
name|h
operator|->
name|sub
expr_stmt|;
while|while
condition|(
name|n
operator|!=
name|NULL
condition|)
block|{
name|mc_nodes_lang
index|[
name|i
operator|++
index|]
operator|=
name|n
expr_stmt|;
name|n
operator|=
name|n
operator|->
name|next
expr_stmt|;
block|}
name|h
operator|=
name|h
operator|->
name|next
expr_stmt|;
block|}
name|qsort
argument_list|(
name|mc_nodes_lang
argument_list|,
operator|(
name|size_t
operator|)
name|mc_nodes_lang_count
argument_list|,
sizeof|sizeof
argument_list|(
name|mc_node_lang
operator|*
argument_list|)
argument_list|,
name|sort_mc_node_lang
argument_list|)
expr_stmt|;
block|}
comment|/* Sort facility code definitions by there id ascending.  */
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|k
operator|=
name|enum_facility
argument_list|(
name|i
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
operator|++
name|i
expr_stmt|;
name|mc_facility_codes_count
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
block|{
name|mc_facility_codes
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|mc_keyword
operator|*
argument_list|)
operator|*
name|i
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|k
operator|=
name|enum_facility
argument_list|(
name|i
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|mc_facility_codes
index|[
name|i
operator|++
index|]
operator|=
operator|(
name|mc_keyword
operator|*
operator|)
name|k
expr_stmt|;
name|qsort
argument_list|(
name|mc_facility_codes
argument_list|,
operator|(
name|size_t
operator|)
name|mc_facility_codes_count
argument_list|,
sizeof|sizeof
argument_list|(
name|mc_keyword
operator|*
argument_list|)
argument_list|,
name|sort_keyword_by_nval
argument_list|)
expr_stmt|;
block|}
comment|/* Sort severity code definitions by there id ascending.  */
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|k
operator|=
name|enum_severity
argument_list|(
name|i
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
operator|++
name|i
expr_stmt|;
name|mc_severity_codes_count
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
block|{
name|mc_severity_codes
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|mc_keyword
operator|*
argument_list|)
operator|*
name|i
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|k
operator|=
name|enum_severity
argument_list|(
name|i
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|mc_severity_codes
index|[
name|i
operator|++
index|]
operator|=
operator|(
name|mc_keyword
operator|*
operator|)
name|k
expr_stmt|;
name|qsort
argument_list|(
name|mc_severity_codes
argument_list|,
operator|(
name|size_t
operator|)
name|mc_severity_codes_count
argument_list|,
sizeof|sizeof
argument_list|(
name|mc_keyword
operator|*
argument_list|)
argument_list|,
name|sort_keyword_by_nval
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|mc_get_block_count
parameter_list|(
name|mc_node_lang
modifier|*
modifier|*
name|nl
parameter_list|,
name|int
name|elems
parameter_list|)
block|{
name|rc_uint_type
name|exid
decl_stmt|;
name|int
name|i
decl_stmt|,
name|ret
decl_stmt|;
if|if
condition|(
operator|!
name|nl
condition|)
return|return
literal|0
return|;
name|i
operator|=
literal|0
expr_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|elems
condition|)
block|{
name|ret
operator|++
expr_stmt|;
name|exid
operator|=
name|nl
index|[
name|i
operator|++
index|]
operator|->
name|vid
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|elems
operator|&&
name|nl
index|[
name|i
index|]
operator|->
name|vid
operator|==
name|exid
operator|+
literal|1
condition|)
name|exid
operator|=
name|nl
index|[
name|i
operator|++
index|]
operator|->
name|vid
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|bfd
modifier|*
name|windmc_open_as_binary
parameter_list|(
specifier|const
name|char
modifier|*
name|filename
parameter_list|)
block|{
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|abfd
operator|=
name|bfd_openw
argument_list|(
name|filename
argument_list|,
literal|"binary"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|abfd
condition|)
name|fatal
argument_list|(
literal|"can't open `%s' for output"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
return|return
name|abfd
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|target_put_16
parameter_list|(
name|void
modifier|*
name|p
parameter_list|,
name|rc_uint_type
name|value
parameter_list|)
block|{
name|assert
argument_list|(
operator|!
operator|!
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|target_is_bigendian
condition|)
name|bfd_putb16
argument_list|(
name|value
argument_list|,
name|p
argument_list|)
expr_stmt|;
else|else
name|bfd_putl16
argument_list|(
name|value
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|target_put_32
parameter_list|(
name|void
modifier|*
name|p
parameter_list|,
name|rc_uint_type
name|value
parameter_list|)
block|{
name|assert
argument_list|(
operator|!
operator|!
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|target_is_bigendian
condition|)
name|bfd_putb32
argument_list|(
name|value
argument_list|,
name|p
argument_list|)
expr_stmt|;
else|else
name|bfd_putl32
argument_list|(
name|value
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|bin_messagetable_item
modifier|*
name|mc_generate_bin_item
parameter_list|(
name|mc_node_lang
modifier|*
name|n
parameter_list|,
name|rc_uint_type
modifier|*
name|res_len
parameter_list|)
block|{
name|struct
name|bin_messagetable_item
modifier|*
name|ret
init|=
name|NULL
decl_stmt|;
name|rc_uint_type
name|len
decl_stmt|;
operator|*
name|res_len
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|mcset_bin_out_is_unicode
operator|==
literal|1
condition|)
block|{
name|unichar
modifier|*
name|ht
init|=
name|n
operator|->
name|message
decl_stmt|;
name|rc_uint_type
name|txt_len
decl_stmt|;
name|txt_len
operator|=
name|unichar_len
argument_list|(
name|n
operator|->
name|message
argument_list|)
expr_stmt|;
if|if
condition|(
name|mcset_automatic_null_termination
operator|&&
name|txt_len
operator|!=
literal|0
condition|)
block|{
while|while
condition|(
name|txt_len
operator|>
literal|0
operator|&&
name|ht
index|[
name|txt_len
operator|-
literal|1
index|]
operator|>
literal|0
operator|&&
name|ht
index|[
name|txt_len
operator|-
literal|1
index|]
operator|<
literal|0x20
condition|)
name|ht
index|[
operator|--
name|txt_len
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|txt_len
operator|*=
sizeof|sizeof
argument_list|(
name|unichar
argument_list|)
expr_stmt|;
name|len
operator|=
name|BIN_MESSAGETABLE_ITEM_SIZE
operator|+
name|txt_len
operator|+
sizeof|sizeof
argument_list|(
name|unichar
argument_list|)
expr_stmt|;
name|ret
operator|=
name|res_alloc
argument_list|(
operator|(
name|len
operator|+
literal|3
operator|)
operator|&
operator|~
literal|3
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|ret
argument_list|,
literal|0
argument_list|,
operator|(
name|len
operator|+
literal|3
operator|)
operator|&
operator|~
literal|3
argument_list|)
expr_stmt|;
name|target_put_16
argument_list|(
name|ret
operator|->
name|length
argument_list|,
operator|(
name|len
operator|+
literal|3
operator|)
operator|&
operator|~
literal|3
argument_list|)
expr_stmt|;
name|target_put_16
argument_list|(
name|ret
operator|->
name|flags
argument_list|,
name|MESSAGE_RESOURCE_UNICODE
argument_list|)
expr_stmt|;
name|txt_len
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|ht
operator|!=
literal|0
condition|)
block|{
name|target_put_16
argument_list|(
name|ret
operator|->
name|data
operator|+
name|txt_len
argument_list|,
operator|*
name|ht
operator|++
argument_list|)
expr_stmt|;
name|txt_len
operator|+=
literal|2
expr_stmt|;
block|}
block|}
else|else
block|{
name|rc_uint_type
name|txt_len
decl_stmt|,
name|l
decl_stmt|;
name|char
modifier|*
name|cvt_txt
decl_stmt|;
name|codepage_from_unicode
argument_list|(
operator|&
name|l
argument_list|,
name|n
operator|->
name|message
argument_list|,
operator|&
name|cvt_txt
argument_list|,
name|n
operator|->
name|lang
operator|->
name|lang_info
operator|.
name|wincp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cvt_txt
condition|)
name|fatal
argument_list|(
literal|"Failed to convert message to language codepage.\n"
argument_list|)
expr_stmt|;
name|txt_len
operator|=
name|strlen
argument_list|(
name|cvt_txt
argument_list|)
expr_stmt|;
if|if
condition|(
name|mcset_automatic_null_termination
operator|&&
name|txt_len
operator|>
literal|0
condition|)
block|{
while|while
condition|(
name|txt_len
operator|>
literal|0
operator|&&
name|cvt_txt
index|[
name|txt_len
operator|-
literal|1
index|]
operator|>
literal|0
operator|&&
name|cvt_txt
index|[
name|txt_len
operator|-
literal|1
index|]
operator|<
literal|0x20
condition|)
name|cvt_txt
index|[
operator|--
name|txt_len
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|len
operator|=
name|BIN_MESSAGETABLE_ITEM_SIZE
operator|+
name|txt_len
operator|+
literal|1
expr_stmt|;
name|ret
operator|=
name|res_alloc
argument_list|(
operator|(
name|len
operator|+
literal|3
operator|)
operator|&
operator|~
literal|3
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|ret
argument_list|,
literal|0
argument_list|,
operator|(
name|len
operator|+
literal|3
operator|)
operator|&
operator|~
literal|3
argument_list|)
expr_stmt|;
name|target_put_16
argument_list|(
name|ret
operator|->
name|length
argument_list|,
operator|(
name|len
operator|+
literal|3
operator|)
operator|&
operator|~
literal|3
argument_list|)
expr_stmt|;
name|target_put_16
argument_list|(
name|ret
operator|->
name|flags
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|ret
operator|->
name|data
argument_list|,
name|cvt_txt
argument_list|)
expr_stmt|;
block|}
operator|*
name|res_len
operator|=
operator|(
name|len
operator|+
literal|3
operator|)
operator|&
operator|~
literal|3
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mc_write_blocks
parameter_list|(
name|struct
name|bin_messagetable
modifier|*
name|mtbl
parameter_list|,
name|mc_node_lang
modifier|*
modifier|*
name|nl
parameter_list|,
name|mc_msg_item
modifier|*
name|ml
parameter_list|,
name|int
name|elems
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|idx
init|=
literal|0
decl_stmt|;
name|rc_uint_type
name|exid
decl_stmt|;
if|if
condition|(
operator|!
name|nl
condition|)
return|return;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|elems
condition|)
block|{
name|target_put_32
argument_list|(
name|mtbl
operator|->
name|items
index|[
name|idx
index|]
operator|.
name|lowid
argument_list|,
name|nl
index|[
name|i
index|]
operator|->
name|vid
argument_list|)
expr_stmt|;
name|target_put_32
argument_list|(
name|mtbl
operator|->
name|items
index|[
name|idx
index|]
operator|.
name|highid
argument_list|,
name|nl
index|[
name|i
index|]
operator|->
name|vid
argument_list|)
expr_stmt|;
name|target_put_32
argument_list|(
name|mtbl
operator|->
name|items
index|[
name|idx
index|]
operator|.
name|offset
argument_list|,
name|ml
index|[
name|i
index|]
operator|.
name|res_off
argument_list|)
expr_stmt|;
name|exid
operator|=
name|nl
index|[
name|i
operator|++
index|]
operator|->
name|vid
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|elems
operator|&&
name|nl
index|[
name|i
index|]
operator|->
name|vid
operator|==
name|exid
operator|+
literal|1
condition|)
block|{
name|target_put_32
argument_list|(
name|mtbl
operator|->
name|items
index|[
name|idx
index|]
operator|.
name|highid
argument_list|,
name|nl
index|[
name|i
index|]
operator|->
name|vid
argument_list|)
expr_stmt|;
name|exid
operator|=
name|nl
index|[
name|i
operator|++
index|]
operator|->
name|vid
expr_stmt|;
block|}
operator|++
name|idx
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|set_windmc_bfd_content
parameter_list|(
specifier|const
name|void
modifier|*
name|data
parameter_list|,
name|rc_uint_type
name|off
parameter_list|,
name|rc_uint_type
name|length
parameter_list|)
block|{
if|if
condition|(
operator|!
name|bfd_set_section_contents
argument_list|(
name|mc_bfd
operator|.
name|abfd
argument_list|,
name|mc_bfd
operator|.
name|sec
argument_list|,
name|data
argument_list|,
name|off
argument_list|,
name|length
argument_list|)
condition|)
name|bfd_fatal
argument_list|(
literal|"bfd_set_section_contents"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|windmc_write_bin
parameter_list|(
specifier|const
name|char
modifier|*
name|filename
parameter_list|,
name|mc_node_lang
modifier|*
modifier|*
name|nl
parameter_list|,
name|int
name|elems
parameter_list|)
block|{
name|unsigned
name|long
name|sec_length
init|=
literal|1
decl_stmt|;
name|int
name|block_count
decl_stmt|,
name|i
decl_stmt|;
name|mc_msg_item
modifier|*
name|mi
decl_stmt|;
name|struct
name|bin_messagetable
modifier|*
name|mtbl
decl_stmt|;
name|rc_uint_type
name|dta_off
decl_stmt|,
name|dta_start
decl_stmt|;
if|if
condition|(
name|elems
operator|<=
literal|0
condition|)
return|return;
name|mc_bfd
operator|.
name|abfd
operator|=
name|windmc_open_as_binary
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|mc_bfd
operator|.
name|sec
operator|=
name|bfd_make_section
argument_list|(
name|mc_bfd
operator|.
name|abfd
argument_list|,
literal|".data"
argument_list|)
expr_stmt|;
if|if
condition|(
name|mc_bfd
operator|.
name|sec
operator|==
name|NULL
condition|)
name|bfd_fatal
argument_list|(
literal|"bfd_make_section"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_set_section_flags
argument_list|(
name|mc_bfd
operator|.
name|abfd
argument_list|,
name|mc_bfd
operator|.
name|sec
argument_list|,
operator|(
name|SEC_HAS_CONTENTS
operator||
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_DATA
operator|)
argument_list|)
condition|)
name|bfd_fatal
argument_list|(
literal|"bfd_set_section_flags"
argument_list|)
expr_stmt|;
comment|/* Requiring this is probably a bug in BFD.  */
name|mc_bfd
operator|.
name|sec
operator|->
name|output_section
operator|=
name|mc_bfd
operator|.
name|sec
expr_stmt|;
name|block_count
operator|=
name|mc_get_block_count
argument_list|(
name|nl
argument_list|,
name|elems
argument_list|)
expr_stmt|;
name|dta_off
operator|=
call|(
name|rc_uint_type
call|)
argument_list|(
operator|(
name|BIN_MESSAGETABLE_BLOCK_SIZE
operator|*
name|block_count
operator|)
operator|+
name|BIN_MESSAGETABLE_SIZE
operator|-
literal|4
argument_list|)
expr_stmt|;
name|dta_start
operator|=
name|dta_off
operator|=
operator|(
name|dta_off
operator|+
literal|3
operator|)
operator|&
operator|~
literal|3
expr_stmt|;
name|mi
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|mc_msg_item
argument_list|)
operator|*
name|elems
argument_list|)
expr_stmt|;
name|mtbl
operator|=
name|xmalloc
argument_list|(
name|dta_start
argument_list|)
expr_stmt|;
comment|/* Clear header region.  */
name|memset
argument_list|(
name|mtbl
argument_list|,
literal|0
argument_list|,
name|dta_start
argument_list|)
expr_stmt|;
name|target_put_32
argument_list|(
name|mtbl
operator|->
name|cblocks
argument_list|,
name|block_count
argument_list|)
expr_stmt|;
comment|/* Prepare items section for output.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|elems
condition|;
name|i
operator|++
control|)
block|{
name|mi
index|[
name|i
index|]
operator|.
name|res_off
operator|=
name|dta_off
expr_stmt|;
name|mi
index|[
name|i
index|]
operator|.
name|res
operator|=
name|mc_generate_bin_item
argument_list|(
name|nl
index|[
name|i
index|]
argument_list|,
operator|&
name|mi
index|[
name|i
index|]
operator|.
name|res_len
argument_list|)
expr_stmt|;
name|dta_off
operator|+=
name|mi
index|[
name|i
index|]
operator|.
name|res_len
expr_stmt|;
block|}
name|sec_length
operator|=
operator|(
name|dta_off
operator|+
literal|3
operator|)
operator|&
operator|~
literal|3
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_set_section_size
argument_list|(
name|mc_bfd
operator|.
name|abfd
argument_list|,
name|mc_bfd
operator|.
name|sec
argument_list|,
name|sec_length
argument_list|)
condition|)
name|bfd_fatal
argument_list|(
literal|"bfd_set_section_size"
argument_list|)
expr_stmt|;
comment|/* Make sure we write the complete block.  */
name|set_windmc_bfd_content
argument_list|(
literal|"\0"
argument_list|,
name|sec_length
operator|-
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Write block information.  */
name|mc_write_blocks
argument_list|(
name|mtbl
argument_list|,
name|nl
argument_list|,
name|mi
argument_list|,
name|elems
argument_list|)
expr_stmt|;
name|set_windmc_bfd_content
argument_list|(
name|mtbl
argument_list|,
literal|0
argument_list|,
name|dta_start
argument_list|)
expr_stmt|;
comment|/* Write items.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|elems
condition|;
name|i
operator|++
control|)
name|set_windmc_bfd_content
argument_list|(
name|mi
index|[
name|i
index|]
operator|.
name|res
argument_list|,
name|mi
index|[
name|i
index|]
operator|.
name|res_off
argument_list|,
name|mi
index|[
name|i
index|]
operator|.
name|res_len
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|mtbl
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|mi
argument_list|)
expr_stmt|;
name|bfd_close
argument_list|(
name|mc_bfd
operator|.
name|abfd
argument_list|)
expr_stmt|;
name|mc_bfd
operator|.
name|abfd
operator|=
name|NULL
expr_stmt|;
name|mc_bfd
operator|.
name|sec
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|write_bin
parameter_list|(
name|void
parameter_list|)
block|{
name|mc_node_lang
modifier|*
name|n
init|=
name|NULL
decl_stmt|;
name|int
name|i
decl_stmt|,
name|c
decl_stmt|;
if|if
condition|(
operator|!
name|mc_nodes_lang_count
condition|)
return|return;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|mc_nodes_lang_count
condition|)
block|{
name|char
modifier|*
name|nd
decl_stmt|;
name|char
modifier|*
name|filename
decl_stmt|;
if|if
condition|(
name|n
operator|&&
name|n
operator|->
name|lang
operator|==
name|mc_nodes_lang
index|[
name|i
index|]
operator|->
name|lang
condition|)
block|{
name|i
operator|++
expr_stmt|;
continue|continue;
block|}
name|n
operator|=
name|mc_nodes_lang
index|[
name|i
index|]
expr_stmt|;
name|c
operator|=
name|i
operator|+
literal|1
expr_stmt|;
while|while
condition|(
name|c
operator|<
name|mc_nodes_lang_count
operator|&&
name|n
operator|->
name|lang
operator|==
name|mc_nodes_lang
index|[
name|c
index|]
operator|->
name|lang
condition|)
name|c
operator|++
expr_stmt|;
name|nd
operator|=
name|convert_unicode_to_ACP
argument_list|(
name|n
operator|->
name|lang
operator|->
name|sval
argument_list|)
expr_stmt|;
comment|/* Prepare filename for binary output.  */
name|filename
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|nd
argument_list|)
operator|+
literal|4
operator|+
literal|1
operator|+
name|strlen
argument_list|(
name|mcset_mc_basename
argument_list|)
operator|+
literal|1
operator|+
name|strlen
argument_list|(
name|mcset_rc_dir
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|filename
argument_list|,
name|mcset_rc_dir
argument_list|)
expr_stmt|;
if|if
condition|(
name|mcset_prefix_bin
condition|)
name|sprintf
argument_list|(
name|filename
operator|+
name|strlen
argument_list|(
name|filename
argument_list|)
argument_list|,
literal|"%s_"
argument_list|,
name|mcset_mc_basename
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|filename
argument_list|,
name|nd
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|filename
argument_list|,
literal|".bin"
argument_list|)
expr_stmt|;
comment|/* Write message file.  */
name|windmc_write_bin
argument_list|(
name|filename
argument_list|,
operator|&
name|mc_nodes_lang
index|[
name|i
index|]
argument_list|,
operator|(
name|c
operator|-
name|i
operator|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|i
operator|=
name|c
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|write_rc
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
name|mc_node_lang
modifier|*
name|n
decl_stmt|;
name|int
name|i
decl_stmt|,
name|l
decl_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"/* Do not edit this file manually.\n"
literal|"   This file is autogenerated by windmc.  */\n\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mc_nodes_lang_count
condition|)
return|return;
name|n
operator|=
name|NULL
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|l
operator|=
literal|0
init|;
name|l
operator|<
name|mc_nodes_lang_count
condition|;
name|l
operator|++
control|)
block|{
if|if
condition|(
name|n
operator|&&
name|n
operator|->
name|lang
operator|==
name|mc_nodes_lang
index|[
name|l
index|]
operator|->
name|lang
condition|)
continue|continue;
operator|++
name|i
expr_stmt|;
name|n
operator|=
name|mc_nodes_lang
index|[
name|l
index|]
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\n// Country: %s\n// Language: %s\n#pragma code_page(%u)\n"
argument_list|,
name|n
operator|->
name|lang
operator|->
name|lang_info
operator|.
name|country
argument_list|,
name|n
operator|->
name|lang
operator|->
name|lang_info
operator|.
name|name
argument_list|,
operator|(
name|unsigned
operator|)
name|n
operator|->
name|lang
operator|->
name|lang_info
operator|.
name|wincp
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"LANGUAGE 0x%lx, 0x%lx\n"
argument_list|,
call|(
name|long
call|)
argument_list|(
name|n
operator|->
name|lang
operator|->
name|nval
operator|&
literal|0x3ff
argument_list|)
argument_list|,
call|(
name|long
call|)
argument_list|(
operator|(
name|n
operator|->
name|lang
operator|->
name|nval
operator|&
literal|0xffff
operator|)
operator|>>
literal|10
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"1 MESSAGETABLE \""
argument_list|)
expr_stmt|;
if|if
condition|(
name|mcset_prefix_bin
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%s_"
argument_list|,
name|mcset_mc_basename
argument_list|)
expr_stmt|;
name|unicode_print
argument_list|(
name|fp
argument_list|,
name|n
operator|->
name|lang
operator|->
name|sval
argument_list|,
name|unichar_len
argument_list|(
name|n
operator|->
name|lang
operator|->
name|sval
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|".bin\"\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|write_dbg
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
name|mc_node
modifier|*
name|h
decl_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"/* Do not edit this file manually.\n"
literal|"   This file is autogenerated by windmc.\n\n"
literal|"   This file maps each message ID value in to a text string that contains\n"
literal|"   the symbolic name used for it.  */\n\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"struct %sSymbolicName\n"
literal|"{\n  "
argument_list|,
name|mcset_mc_basename
argument_list|)
expr_stmt|;
if|if
condition|(
name|mcset_msg_id_typedef
condition|)
name|unicode_print
argument_list|(
name|fp
argument_list|,
name|mcset_msg_id_typedef
argument_list|,
name|unichar_len
argument_list|(
name|mcset_msg_id_typedef
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"DWORD"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|" MessageId;\n"
literal|"  char *SymbolicName;\n"
literal|"} %sSymbolicNames[] =\n"
literal|"{\n"
argument_list|,
name|mcset_mc_basename
argument_list|)
expr_stmt|;
name|h
operator|=
name|mc_nodes
expr_stmt|;
while|while
condition|(
name|h
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|h
operator|->
name|symbol
condition|)
name|write_dbg_define
argument_list|(
name|fp
argument_list|,
name|h
operator|->
name|symbol
argument_list|,
name|mcset_msg_id_typedef
argument_list|)
expr_stmt|;
name|h
operator|=
name|h
operator|->
name|next
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"  { ("
argument_list|)
expr_stmt|;
if|if
condition|(
name|mcset_msg_id_typedef
condition|)
name|unicode_print
argument_list|(
name|fp
argument_list|,
name|mcset_msg_id_typedef
argument_list|,
name|unichar_len
argument_list|(
name|mcset_msg_id_typedef
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"DWORD"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|") 0xffffffff, NULL }\n"
literal|"};\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|write_header
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|i
decl_stmt|;
specifier|const
name|mc_keyword
modifier|*
name|key
decl_stmt|;
name|mc_node
modifier|*
name|h
decl_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"/* Do not edit this file manually.\n"
literal|"   This file is autogenerated by windmc.  */\n\n"
literal|"//\n//  The values are 32 bit layed out as follows:\n//\n"
literal|"//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1\n"
literal|"//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0\n"
literal|"//  +---+-+-+-----------------------+-------------------------------+\n"
literal|"//  |Sev|C|R|     Facility          |               Code            |\n"
literal|"//  +---+-+-+-----------------------+-------------------------------+\n//\n"
literal|"//  where\n//\n"
literal|"//      C    - is the Customer code flag\n//\n"
literal|"//      R    - is a reserved bit\n//\n"
literal|"//      Code - is the facility's status code\n//\n"
argument_list|)
expr_stmt|;
name|h
operator|=
name|mc_nodes
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"//      Sev  - is the severity code\n//\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|mc_severity_codes_count
operator|!=
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|mc_severity_codes_count
condition|;
name|i
operator|++
control|)
block|{
name|key
operator|=
name|mc_severity_codes
index|[
name|i
index|]
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"//           %s - %02lx\n"
argument_list|,
name|convert_unicode_to_ACP
argument_list|(
name|key
operator|->
name|usz
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|key
operator|->
name|nval
argument_list|)
expr_stmt|;
if|if
condition|(
name|key
operator|->
name|sval
operator|&&
name|key
operator|->
name|sval
index|[
literal|0
index|]
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|mcset_out_values_are_decimal
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"#define %s 0x%lx\n"
argument_list|,
name|convert_unicode_to_ACP
argument_list|(
name|key
operator|->
name|sval
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|key
operator|->
name|nval
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"#define %s 0x%lu\n"
argument_list|,
name|convert_unicode_to_ACP
argument_list|(
name|key
operator|->
name|sval
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|key
operator|->
name|nval
argument_list|)
expr_stmt|;
block|}
block|}
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"//\n"
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"//      Facility - is the facility code\n//\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|mc_facility_codes_count
operator|!=
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|mc_facility_codes_count
condition|;
name|i
operator|++
control|)
block|{
name|key
operator|=
name|mc_facility_codes
index|[
name|i
index|]
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"//           %s - %04lx\n"
argument_list|,
name|convert_unicode_to_ACP
argument_list|(
name|key
operator|->
name|usz
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|key
operator|->
name|nval
argument_list|)
expr_stmt|;
if|if
condition|(
name|key
operator|->
name|sval
operator|&&
name|key
operator|->
name|sval
index|[
literal|0
index|]
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|mcset_out_values_are_decimal
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"#define %s 0x%lx\n"
argument_list|,
name|convert_unicode_to_ACP
argument_list|(
name|key
operator|->
name|sval
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|key
operator|->
name|nval
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"#define %s 0x%lu\n"
argument_list|,
name|convert_unicode_to_ACP
argument_list|(
name|key
operator|->
name|sval
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|key
operator|->
name|nval
argument_list|)
expr_stmt|;
block|}
block|}
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"//\n"
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
while|while
condition|(
name|h
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|h
operator|->
name|user_text
condition|)
block|{
name|s
operator|=
name|convert_unicode_to_ACP
argument_list|(
name|h
operator|->
name|user_text
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%s"
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|h
operator|->
name|symbol
condition|)
name|write_header_define
argument_list|(
name|fp
argument_list|,
name|h
operator|->
name|symbol
argument_list|,
name|h
operator|->
name|vid
argument_list|,
name|mcset_msg_id_typedef
argument_list|,
name|h
operator|->
name|sub
argument_list|)
expr_stmt|;
name|h
operator|=
name|h
operator|->
name|next
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|mc_unify_path
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|)
block|{
name|char
modifier|*
name|end
decl_stmt|;
name|char
modifier|*
name|hsz
decl_stmt|;
if|if
condition|(
operator|!
name|path
operator|||
operator|*
name|path
operator|==
literal|0
condition|)
return|return
literal|"./"
return|;
name|hsz
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|path
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|hsz
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|end
operator|=
name|hsz
operator|+
name|strlen
argument_list|(
name|hsz
argument_list|)
expr_stmt|;
if|if
condition|(
name|hsz
index|[
operator|-
literal|1
index|]
operator|!=
literal|'/'
operator|&&
name|hsz
index|[
operator|-
literal|1
index|]
operator|!=
literal|'\\'
condition|)
name|strcpy
argument_list|(
name|end
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|end
operator|=
name|strchr
argument_list|(
name|hsz
argument_list|,
literal|'\\'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
operator|*
name|end
operator|=
literal|'/'
expr_stmt|;
return|return
name|hsz
return|;
block|}
end_function

begin_function_decl
name|int
name|main
parameter_list|(
name|int
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|FILE
modifier|*
name|h_fp
decl_stmt|;
name|int
name|c
decl_stmt|;
name|char
modifier|*
name|target
decl_stmt|,
modifier|*
name|input_filename
decl_stmt|;
name|int
name|verbose
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HAVE_SETLOCALE
argument_list|)
operator|&&
name|defined
argument_list|(
name|HAVE_LC_MESSAGES
argument_list|)
name|setlocale
argument_list|(
name|LC_MESSAGES
argument_list|,
literal|""
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|HAVE_SETLOCALE
argument_list|)
name|setlocale
argument_list|(
name|LC_CTYPE
argument_list|,
literal|""
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|bindtextdomain
argument_list|(
name|PACKAGE
argument_list|,
name|LOCALEDIR
argument_list|)
expr_stmt|;
name|textdomain
argument_list|(
name|PACKAGE
argument_list|)
expr_stmt|;
name|program_name
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
name|xmalloc_set_program_name
argument_list|(
name|program_name
argument_list|)
expr_stmt|;
name|expandargv
argument_list|(
operator|&
name|argc
argument_list|,
operator|&
name|argv
argument_list|)
expr_stmt|;
name|bfd_init
argument_list|()
expr_stmt|;
name|set_default_bfd_target
argument_list|()
expr_stmt|;
name|target
operator|=
name|NULL
expr_stmt|;
name|verbose
operator|=
literal|0
expr_stmt|;
name|input_filename
operator|=
name|NULL
expr_stmt|;
name|res_init
argument_list|()
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getopt_long
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"C:F:O:h:e:m:r:x:aAbcdHunoUvV"
argument_list|,
name|long_options
argument_list|,
operator|(
name|int
operator|*
operator|)
literal|0
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'b'
case|:
name|mcset_prefix_bin
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
block|{
name|mcset_header_ext
operator|=
name|optarg
expr_stmt|;
if|if
condition|(
name|mcset_header_ext
index|[
literal|0
index|]
operator|!=
literal|'.'
operator|&&
name|mcset_header_ext
index|[
literal|0
index|]
operator|!=
literal|0
condition|)
block|{
name|char
modifier|*
name|hsz
init|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|mcset_header_ext
argument_list|)
operator|+
literal|2
argument_list|)
decl_stmt|;
name|sprintf
argument_list|(
name|hsz
argument_list|,
literal|".%s"
argument_list|,
name|mcset_header_ext
argument_list|)
expr_stmt|;
name|mcset_header_ext
operator|=
name|hsz
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|'h'
case|:
name|mcset_header_dir
operator|=
name|mc_unify_path
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|mcset_rc_dir
operator|=
name|mc_unify_path
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
name|mcset_text_in_is_unicode
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
if|if
condition|(
operator|*
name|optarg
operator|!=
literal|0
condition|)
name|mcset_dbg_dir
operator|=
name|mc_unify_path
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'A'
case|:
name|mcset_bin_out_is_unicode
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|mcset_out_values_are_decimal
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
name|mcset_text_in_is_unicode
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'U'
case|:
name|mcset_bin_out_is_unicode
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|mcset_custom_bit
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
name|mcset_automatic_null_termination
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
name|mcset_use_hresult
operator|=
literal|1
expr_stmt|;
name|fatal
argument_list|(
literal|"option -o is not implemented until yet.\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'F'
case|:
name|target
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
name|verbose
operator|++
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
name|mcset_max_message_length
operator|=
name|strtol
argument_list|(
name|optarg
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'C'
case|:
name|mcset_codepage_in
operator|=
name|strtol
argument_list|(
name|optarg
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'O'
case|:
name|mcset_codepage_out
operator|=
name|strtol
argument_list|(
name|optarg
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
case|case
literal|'H'
case|:
name|usage
argument_list|(
name|stdout
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'V'
case|:
name|print_version
argument_list|(
literal|"windmc"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|usage
argument_list|(
name|stderr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|input_filename
operator|==
name|NULL
operator|&&
name|optind
operator|<
name|argc
condition|)
block|{
name|input_filename
operator|=
name|argv
index|[
name|optind
index|]
expr_stmt|;
operator|++
name|optind
expr_stmt|;
block|}
name|set_endianess
argument_list|(
name|NULL
argument_list|,
name|target
argument_list|)
expr_stmt|;
if|if
condition|(
name|input_filename
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Error: No input file was specified.\n"
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|stderr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|mc_set_inputfile
argument_list|(
name|input_filename
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|probe_codepage
argument_list|(
operator|&
name|mcset_codepage_in
argument_list|,
operator|&
name|mcset_text_in_is_unicode
argument_list|,
literal|"codepage_in"
argument_list|,
literal|0
argument_list|)
condition|)
name|usage
argument_list|(
name|stderr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|mcset_codepage_out
operator|==
literal|0
condition|)
name|mcset_codepage_out
operator|=
literal|1252
expr_stmt|;
if|if
condition|(
operator|!
name|unicode_is_valid_codepage
argument_list|(
name|mcset_codepage_out
argument_list|)
condition|)
name|fatal
argument_list|(
literal|"Code page 0x%x is unknown."
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|mcset_codepage_out
argument_list|)
expr_stmt|;
if|if
condition|(
name|mcset_codepage_out
operator|==
name|CP_UTF16
condition|)
name|fatal
argument_list|(
literal|"UTF16 is no valid text output code page."
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"// Default target is %s and it is %s endian.\n"
argument_list|,
name|def_target_arch
argument_list|,
operator|(
name|target_is_bigendian
condition|?
literal|"big"
else|:
literal|"little"
operator|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"// Input codepage: 0x%x\n"
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|mcset_codepage_in
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"// Output codepage: 0x%x\n"
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|mcset_codepage_out
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|argc
operator|!=
name|optind
condition|)
name|usage
argument_list|(
name|stderr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Initialize mcset_mc_basename.  */
block|{
specifier|const
name|char
modifier|*
name|bn
decl_stmt|,
modifier|*
name|bn2
decl_stmt|;
name|char
modifier|*
name|hsz
decl_stmt|;
name|bn
operator|=
name|strrchr
argument_list|(
name|input_filename
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
name|bn2
operator|=
name|strrchr
argument_list|(
name|input_filename
argument_list|,
literal|'\\'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bn
condition|)
name|bn
operator|=
name|bn2
expr_stmt|;
if|if
condition|(
name|bn
operator|&&
name|bn2
operator|&&
name|bn
operator|<
name|bn2
condition|)
name|bn
operator|=
name|bn2
expr_stmt|;
if|if
condition|(
operator|!
name|bn
condition|)
name|bn
operator|=
name|input_filename
expr_stmt|;
else|else
name|bn
operator|++
expr_stmt|;
name|mcset_mc_basename
operator|=
name|hsz
operator|=
name|xstrdup
argument_list|(
name|bn
argument_list|)
expr_stmt|;
comment|/* Cut of right-hand extension.  */
if|if
condition|(
operator|(
name|hsz
operator|=
name|strrchr
argument_list|(
name|hsz
argument_list|,
literal|'.'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
operator|*
name|hsz
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Load the input file and do code page transformations to UTF16.  */
block|{
name|unichar
modifier|*
name|u
decl_stmt|;
name|rc_uint_type
name|ul
decl_stmt|;
name|char
modifier|*
name|buff
decl_stmt|;
name|long
name|flen
decl_stmt|;
name|FILE
modifier|*
name|fp
init|=
name|fopen
argument_list|(
name|input_filename
argument_list|,
literal|"rb"
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|fp
condition|)
name|fatal
argument_list|(
name|_
argument_list|(
literal|"unable to open file ,%s' for input.\n"
argument_list|)
argument_list|,
name|input_filename
argument_list|)
expr_stmt|;
name|fseek
argument_list|(
name|fp
argument_list|,
literal|0
argument_list|,
name|SEEK_END
argument_list|)
expr_stmt|;
name|flen
operator|=
name|ftell
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|fseek
argument_list|(
name|fp
argument_list|,
literal|0
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
name|buff
operator|=
name|malloc
argument_list|(
name|flen
operator|+
literal|3
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|buff
argument_list|,
literal|0
argument_list|,
name|flen
operator|+
literal|3
argument_list|)
expr_stmt|;
name|fread
argument_list|(
name|buff
argument_list|,
literal|1
argument_list|,
name|flen
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|mcset_text_in_is_unicode
operator|!=
literal|1
condition|)
block|{
name|unicode_from_codepage
argument_list|(
operator|&
name|ul
argument_list|,
operator|&
name|u
argument_list|,
name|buff
argument_list|,
name|mcset_codepage_in
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|u
condition|)
name|fatal
argument_list|(
literal|"Failed to convert input to UFT16\n"
argument_list|)
expr_stmt|;
name|mc_set_content
argument_list|(
name|u
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|flen
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
name|fatal
argument_list|(
name|_
argument_list|(
literal|"input file does not seems to be UFT16.\n"
argument_list|)
argument_list|)
expr_stmt|;
name|mc_set_content
argument_list|(
operator|(
name|unichar
operator|*
operator|)
name|buff
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|buff
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|yyparse
argument_list|()
condition|)
empty_stmt|;
name|do_sorts
argument_list|()
expr_stmt|;
name|h_fp
operator|=
name|mc_create_path_text_file
argument_list|(
name|mcset_header_dir
argument_list|,
name|mcset_header_ext
argument_list|)
expr_stmt|;
name|write_header
argument_list|(
name|h_fp
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|h_fp
argument_list|)
expr_stmt|;
name|h_fp
operator|=
name|mc_create_path_text_file
argument_list|(
name|mcset_rc_dir
argument_list|,
literal|".rc"
argument_list|)
expr_stmt|;
name|write_rc
argument_list|(
name|h_fp
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|h_fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|mcset_dbg_dir
operator|!=
name|NULL
condition|)
block|{
name|h_fp
operator|=
name|mc_create_path_text_file
argument_list|(
name|mcset_dbg_dir
argument_list|,
literal|".dbg"
argument_list|)
expr_stmt|;
name|write_dbg
argument_list|(
name|h_fp
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|h_fp
argument_list|)
expr_stmt|;
block|}
name|write_bin
argument_list|()
expr_stmt|;
if|if
condition|(
name|mc_nodes_lang
condition|)
name|free
argument_list|(
name|mc_nodes_lang
argument_list|)
expr_stmt|;
if|if
condition|(
name|mc_severity_codes
condition|)
name|free
argument_list|(
name|mc_severity_codes
argument_list|)
expr_stmt|;
if|if
condition|(
name|mc_facility_codes
condition|)
name|free
argument_list|(
name|mc_facility_codes
argument_list|)
expr_stmt|;
name|xexit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

end_unit

