begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* stabs.c -- Parse COFF debugging information    Copyright (C) 1996 Free Software Foundation, Inc.    Written by Ian Lance Taylor<ian@cygnus.com>.     This file is part of GNU Binutils.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA    02111-1307, USA.  */
end_comment

begin_comment
comment|/* This file contains code which parses COFF debugging information.  */
end_comment

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"coff/internal.h"
end_include

begin_include
include|#
directive|include
file|"bucomm.h"
end_include

begin_include
include|#
directive|include
file|"libiberty.h"
end_include

begin_include
include|#
directive|include
file|"demangle.h"
end_include

begin_include
include|#
directive|include
file|"debug.h"
end_include

begin_include
include|#
directive|include
file|"budbg.h"
end_include

begin_comment
comment|/* FIXME: We should not need this BFD internal file.  We need it for    the N_BTMASK, etc., values.  */
end_comment

begin_include
include|#
directive|include
file|"libcoff.h"
end_include

begin_comment
comment|/* These macros extract the right mask and shifts for this BFD.  They    assume that there is a local variable named ABFD.  This is so that    macros like ISFCN and DECREF, from coff/internal.h, will work    without modification.  */
end_comment

begin_define
define|#
directive|define
name|N_BTMASK
value|(coff_data (abfd)->local_n_btmask)
end_define

begin_define
define|#
directive|define
name|N_BTSHFT
value|(coff_data (abfd)->local_n_btshft)
end_define

begin_define
define|#
directive|define
name|N_TMASK
value|(coff_data (abfd)->local_n_tmask)
end_define

begin_define
define|#
directive|define
name|N_TSHIFT
value|(coff_data (abfd)->local_n_tshift)
end_define

begin_comment
comment|/* This structure is used to hold the symbols, as well as the current    location within the symbols.  */
end_comment

begin_struct
struct|struct
name|coff_symbols
block|{
comment|/* The symbols.  */
name|asymbol
modifier|*
modifier|*
name|syms
decl_stmt|;
comment|/* The number of symbols.  */
name|long
name|symcount
decl_stmt|;
comment|/* The index of the current symbol.  */
name|long
name|symno
decl_stmt|;
comment|/* The index of the current symbol in the COFF symbol table (where      each auxent counts as a symbol).  */
name|long
name|coff_symno
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* The largest basic type we are prepared to handle.  */
end_comment

begin_define
define|#
directive|define
name|T_MAX
value|(T_LNGDBL)
end_define

begin_comment
comment|/* This structure is used to hold slots.  */
end_comment

begin_struct
struct|struct
name|coff_slots
block|{
comment|/* Next set of slots.  */
name|struct
name|coff_slots
modifier|*
name|next
decl_stmt|;
comment|/* Slots.  */
define|#
directive|define
name|COFF_SLOTS
value|(16)
name|debug_type
name|slots
index|[
name|COFF_SLOTS
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* This structure is used to map symbol indices to types.  */
end_comment

begin_struct
struct|struct
name|coff_types
block|{
comment|/* Slots.  */
name|struct
name|coff_slots
modifier|*
name|slots
decl_stmt|;
comment|/* Basic types.  */
name|debug_type
name|basic
index|[
name|T_MAX
operator|+
literal|1
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|debug_type
modifier|*
name|coff_get_slot
name|PARAMS
argument_list|(
operator|(
expr|struct
name|coff_types
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|debug_type
name|parse_coff_type
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|coff_symbols
operator|*
operator|,
expr|struct
name|coff_types
operator|*
operator|,
name|long
operator|,
name|int
operator|,
expr|union
name|internal_auxent
operator|*
operator|,
name|boolean
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|debug_type
name|parse_coff_base_type
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|coff_symbols
operator|*
operator|,
expr|struct
name|coff_types
operator|*
operator|,
name|long
operator|,
name|int
operator|,
expr|union
name|internal_auxent
operator|*
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|debug_type
name|parse_coff_struct_type
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|coff_symbols
operator|*
operator|,
expr|struct
name|coff_types
operator|*
operator|,
name|int
operator|,
expr|union
name|internal_auxent
operator|*
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|debug_type
name|parse_coff_enum_type
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|coff_symbols
operator|*
operator|,
expr|struct
name|coff_types
operator|*
operator|,
expr|union
name|internal_auxent
operator|*
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|parse_coff_symbol
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|coff_types
operator|*
operator|,
name|asymbol
operator|*
operator|,
name|long
operator|,
expr|struct
name|internal_syment
operator|*
operator|,
name|PTR
operator|,
name|debug_type
operator|,
name|boolean
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Return the slot for a type.  */
end_comment

begin_function
specifier|static
name|debug_type
modifier|*
name|coff_get_slot
parameter_list|(
name|types
parameter_list|,
name|indx
parameter_list|)
name|struct
name|coff_types
modifier|*
name|types
decl_stmt|;
name|int
name|indx
decl_stmt|;
block|{
name|struct
name|coff_slots
modifier|*
modifier|*
name|pps
decl_stmt|;
name|pps
operator|=
operator|&
name|types
operator|->
name|slots
expr_stmt|;
while|while
condition|(
name|indx
operator|>=
name|COFF_SLOTS
condition|)
block|{
if|if
condition|(
operator|*
name|pps
operator|==
name|NULL
condition|)
block|{
operator|*
name|pps
operator|=
operator|(
expr|struct
name|coff_slots
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
expr|*
operator|*
name|pps
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|*
name|pps
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
expr|*
operator|*
name|pps
argument_list|)
expr_stmt|;
block|}
name|pps
operator|=
operator|&
operator|(
operator|*
name|pps
operator|)
operator|->
name|next
expr_stmt|;
name|indx
operator|-=
name|COFF_SLOTS
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|pps
operator|==
name|NULL
condition|)
block|{
operator|*
name|pps
operator|=
operator|(
expr|struct
name|coff_slots
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
expr|*
operator|*
name|pps
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|*
name|pps
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
expr|*
operator|*
name|pps
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
operator|*
name|pps
operator|)
operator|->
name|slots
operator|+
name|indx
return|;
block|}
end_function

begin_comment
comment|/* Parse a COFF type code in NTYPE.  */
end_comment

begin_function
specifier|static
name|debug_type
name|parse_coff_type
parameter_list|(
name|abfd
parameter_list|,
name|symbols
parameter_list|,
name|types
parameter_list|,
name|coff_symno
parameter_list|,
name|ntype
parameter_list|,
name|pauxent
parameter_list|,
name|useaux
parameter_list|,
name|dhandle
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|coff_symbols
modifier|*
name|symbols
decl_stmt|;
name|struct
name|coff_types
modifier|*
name|types
decl_stmt|;
name|long
name|coff_symno
decl_stmt|;
name|int
name|ntype
decl_stmt|;
name|union
name|internal_auxent
modifier|*
name|pauxent
decl_stmt|;
name|boolean
name|useaux
decl_stmt|;
name|PTR
name|dhandle
decl_stmt|;
block|{
name|debug_type
name|type
decl_stmt|;
if|if
condition|(
operator|(
name|ntype
operator|&
operator|~
name|N_BTMASK
operator|)
operator|!=
literal|0
condition|)
block|{
name|int
name|newtype
decl_stmt|;
name|newtype
operator|=
name|DECREF
argument_list|(
name|ntype
argument_list|)
expr_stmt|;
if|if
condition|(
name|ISPTR
argument_list|(
name|ntype
argument_list|)
condition|)
block|{
name|type
operator|=
name|parse_coff_type
argument_list|(
name|abfd
argument_list|,
name|symbols
argument_list|,
name|types
argument_list|,
name|coff_symno
argument_list|,
name|newtype
argument_list|,
name|pauxent
argument_list|,
name|useaux
argument_list|,
name|dhandle
argument_list|)
expr_stmt|;
name|type
operator|=
name|debug_make_pointer_type
argument_list|(
name|dhandle
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ISFCN
argument_list|(
name|ntype
argument_list|)
condition|)
block|{
name|type
operator|=
name|parse_coff_type
argument_list|(
name|abfd
argument_list|,
name|symbols
argument_list|,
name|types
argument_list|,
name|coff_symno
argument_list|,
name|newtype
argument_list|,
name|pauxent
argument_list|,
name|useaux
argument_list|,
name|dhandle
argument_list|)
expr_stmt|;
name|type
operator|=
name|debug_make_function_type
argument_list|(
name|dhandle
argument_list|,
name|type
argument_list|,
operator|(
name|debug_type
operator|*
operator|)
name|NULL
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ISARY
argument_list|(
name|ntype
argument_list|)
condition|)
block|{
name|int
name|n
decl_stmt|;
if|if
condition|(
name|pauxent
operator|==
name|NULL
condition|)
name|n
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|unsigned
name|short
modifier|*
name|dim
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* FIXME: If pauxent->x_sym.x_tagndx.l == 0, gdb sets                  the c_naux field of the syment to 0.  */
comment|/* Move the dimensions down, so that the next array                  picks up the next one.  */
name|dim
operator|=
name|pauxent
operator|->
name|x_sym
operator|.
name|x_fcnary
operator|.
name|x_ary
operator|.
name|x_dimen
expr_stmt|;
name|n
operator|=
name|dim
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|*
name|dim
operator|!=
literal|0
operator|&&
name|i
operator|<
name|DIMNUM
operator|-
literal|1
condition|;
name|i
operator|++
operator|,
name|dim
operator|++
control|)
operator|*
name|dim
operator|=
operator|*
operator|(
name|dim
operator|+
literal|1
operator|)
expr_stmt|;
operator|*
name|dim
operator|=
literal|0
expr_stmt|;
block|}
name|type
operator|=
name|parse_coff_type
argument_list|(
name|abfd
argument_list|,
name|symbols
argument_list|,
name|types
argument_list|,
name|coff_symno
argument_list|,
name|newtype
argument_list|,
name|pauxent
argument_list|,
name|false
argument_list|,
name|dhandle
argument_list|)
expr_stmt|;
name|type
operator|=
name|debug_make_array_type
argument_list|(
name|dhandle
argument_list|,
name|type
argument_list|,
name|parse_coff_base_type
argument_list|(
name|abfd
argument_list|,
name|symbols
argument_list|,
name|types
argument_list|,
name|coff_symno
argument_list|,
name|T_INT
argument_list|,
name|NULL
argument_list|,
name|dhandle
argument_list|)
argument_list|,
literal|0
argument_list|,
name|n
operator|-
literal|1
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: parse_coff_type: Bad type code 0x%x\n"
argument_list|,
name|program_name
argument_list|,
name|ntype
argument_list|)
expr_stmt|;
return|return
name|DEBUG_TYPE_NULL
return|;
block|}
return|return
name|type
return|;
block|}
if|if
condition|(
name|pauxent
operator|!=
name|NULL
operator|&&
name|pauxent
operator|->
name|x_sym
operator|.
name|x_tagndx
operator|.
name|l
operator|>
literal|0
condition|)
block|{
name|debug_type
modifier|*
name|slot
decl_stmt|;
comment|/* This is a reference to an existing type.  FIXME: gdb checks 	 that the class is not C_STRTAG, nor C_UNTAG, nor C_ENTAG.  */
name|slot
operator|=
name|coff_get_slot
argument_list|(
name|types
argument_list|,
name|pauxent
operator|->
name|x_sym
operator|.
name|x_tagndx
operator|.
name|l
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|slot
operator|!=
name|DEBUG_TYPE_NULL
condition|)
return|return
operator|*
name|slot
return|;
else|else
return|return
name|debug_make_indirect_type
argument_list|(
name|dhandle
argument_list|,
name|slot
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|)
return|;
block|}
comment|/* If the aux entry has already been used for something, useaux will      have been set to false, indicating that parse_coff_base_type      should not use it.  We need to do it this way, rather than simply      passing pauxent as NULL, because we need to be able handle      multiple array dimensions while still discarding pauxent after      having handled all of them.  */
if|if
condition|(
operator|!
name|useaux
condition|)
name|pauxent
operator|=
name|NULL
expr_stmt|;
return|return
name|parse_coff_base_type
argument_list|(
name|abfd
argument_list|,
name|symbols
argument_list|,
name|types
argument_list|,
name|coff_symno
argument_list|,
name|ntype
argument_list|,
name|pauxent
argument_list|,
name|dhandle
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Parse a basic COFF type in NTYPE.  */
end_comment

begin_function
specifier|static
name|debug_type
name|parse_coff_base_type
parameter_list|(
name|abfd
parameter_list|,
name|symbols
parameter_list|,
name|types
parameter_list|,
name|coff_symno
parameter_list|,
name|ntype
parameter_list|,
name|pauxent
parameter_list|,
name|dhandle
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|coff_symbols
modifier|*
name|symbols
decl_stmt|;
name|struct
name|coff_types
modifier|*
name|types
decl_stmt|;
name|long
name|coff_symno
decl_stmt|;
name|int
name|ntype
decl_stmt|;
name|union
name|internal_auxent
modifier|*
name|pauxent
decl_stmt|;
name|PTR
name|dhandle
decl_stmt|;
block|{
name|debug_type
name|ret
decl_stmt|;
name|boolean
name|set_basic
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|debug_type
modifier|*
name|slot
decl_stmt|;
if|if
condition|(
name|ntype
operator|>=
literal|0
operator|&&
name|ntype
operator|<=
name|T_MAX
operator|&&
name|types
operator|->
name|basic
index|[
name|ntype
index|]
operator|!=
name|DEBUG_TYPE_NULL
condition|)
return|return
name|types
operator|->
name|basic
index|[
name|ntype
index|]
return|;
name|set_basic
operator|=
name|true
expr_stmt|;
name|name
operator|=
name|NULL
expr_stmt|;
switch|switch
condition|(
name|ntype
condition|)
block|{
default|default:
name|ret
operator|=
name|debug_make_void_type
argument_list|(
name|dhandle
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_NULL
case|:
case|case
name|T_VOID
case|:
name|ret
operator|=
name|debug_make_void_type
argument_list|(
name|dhandle
argument_list|)
expr_stmt|;
name|name
operator|=
literal|"void"
expr_stmt|;
break|break;
case|case
name|T_CHAR
case|:
name|ret
operator|=
name|debug_make_int_type
argument_list|(
name|dhandle
argument_list|,
literal|1
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|name
operator|=
literal|"char"
expr_stmt|;
break|break;
case|case
name|T_SHORT
case|:
name|ret
operator|=
name|debug_make_int_type
argument_list|(
name|dhandle
argument_list|,
literal|2
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|name
operator|=
literal|"short"
expr_stmt|;
break|break;
case|case
name|T_INT
case|:
comment|/* FIXME: Perhaps the size should depend upon the architecture.  */
name|ret
operator|=
name|debug_make_int_type
argument_list|(
name|dhandle
argument_list|,
literal|4
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|name
operator|=
literal|"int"
expr_stmt|;
break|break;
case|case
name|T_LONG
case|:
name|ret
operator|=
name|debug_make_int_type
argument_list|(
name|dhandle
argument_list|,
literal|4
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|name
operator|=
literal|"long"
expr_stmt|;
break|break;
case|case
name|T_FLOAT
case|:
name|ret
operator|=
name|debug_make_float_type
argument_list|(
name|dhandle
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|name
operator|=
literal|"float"
expr_stmt|;
break|break;
case|case
name|T_DOUBLE
case|:
name|ret
operator|=
name|debug_make_float_type
argument_list|(
name|dhandle
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|name
operator|=
literal|"double"
expr_stmt|;
break|break;
case|case
name|T_LNGDBL
case|:
name|ret
operator|=
name|debug_make_float_type
argument_list|(
name|dhandle
argument_list|,
literal|12
argument_list|)
expr_stmt|;
name|name
operator|=
literal|"long double"
expr_stmt|;
break|break;
case|case
name|T_UCHAR
case|:
name|ret
operator|=
name|debug_make_int_type
argument_list|(
name|dhandle
argument_list|,
literal|1
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|name
operator|=
literal|"unsigned char"
expr_stmt|;
break|break;
case|case
name|T_USHORT
case|:
name|ret
operator|=
name|debug_make_int_type
argument_list|(
name|dhandle
argument_list|,
literal|2
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|name
operator|=
literal|"unsigned short"
expr_stmt|;
break|break;
case|case
name|T_UINT
case|:
name|ret
operator|=
name|debug_make_int_type
argument_list|(
name|dhandle
argument_list|,
literal|4
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|name
operator|=
literal|"unsigned int"
expr_stmt|;
break|break;
case|case
name|T_ULONG
case|:
name|ret
operator|=
name|debug_make_int_type
argument_list|(
name|dhandle
argument_list|,
literal|4
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|name
operator|=
literal|"unsigned long"
expr_stmt|;
break|break;
case|case
name|T_STRUCT
case|:
if|if
condition|(
name|pauxent
operator|==
name|NULL
condition|)
name|ret
operator|=
name|debug_make_struct_type
argument_list|(
name|dhandle
argument_list|,
name|true
argument_list|,
literal|0
argument_list|,
operator|(
name|debug_field
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
else|else
name|ret
operator|=
name|parse_coff_struct_type
argument_list|(
name|abfd
argument_list|,
name|symbols
argument_list|,
name|types
argument_list|,
name|ntype
argument_list|,
name|pauxent
argument_list|,
name|dhandle
argument_list|)
expr_stmt|;
name|slot
operator|=
name|coff_get_slot
argument_list|(
name|types
argument_list|,
name|coff_symno
argument_list|)
expr_stmt|;
operator|*
name|slot
operator|=
name|ret
expr_stmt|;
name|set_basic
operator|=
name|false
expr_stmt|;
break|break;
case|case
name|T_UNION
case|:
if|if
condition|(
name|pauxent
operator|==
name|NULL
condition|)
name|ret
operator|=
name|debug_make_struct_type
argument_list|(
name|dhandle
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
operator|(
name|debug_field
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
else|else
name|ret
operator|=
name|parse_coff_struct_type
argument_list|(
name|abfd
argument_list|,
name|symbols
argument_list|,
name|types
argument_list|,
name|ntype
argument_list|,
name|pauxent
argument_list|,
name|dhandle
argument_list|)
expr_stmt|;
name|slot
operator|=
name|coff_get_slot
argument_list|(
name|types
argument_list|,
name|coff_symno
argument_list|)
expr_stmt|;
operator|*
name|slot
operator|=
name|ret
expr_stmt|;
name|set_basic
operator|=
name|false
expr_stmt|;
break|break;
case|case
name|T_ENUM
case|:
if|if
condition|(
name|pauxent
operator|==
name|NULL
condition|)
name|ret
operator|=
name|debug_make_enum_type
argument_list|(
name|dhandle
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|bfd_signed_vma
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
else|else
name|ret
operator|=
name|parse_coff_enum_type
argument_list|(
name|abfd
argument_list|,
name|symbols
argument_list|,
name|types
argument_list|,
name|pauxent
argument_list|,
name|dhandle
argument_list|)
expr_stmt|;
name|slot
operator|=
name|coff_get_slot
argument_list|(
name|types
argument_list|,
name|coff_symno
argument_list|)
expr_stmt|;
operator|*
name|slot
operator|=
name|ret
expr_stmt|;
name|set_basic
operator|=
name|false
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|name
operator|!=
name|NULL
condition|)
name|ret
operator|=
name|debug_name_type
argument_list|(
name|dhandle
argument_list|,
name|name
argument_list|,
name|ret
argument_list|)
expr_stmt|;
if|if
condition|(
name|set_basic
operator|&&
name|ntype
operator|>=
literal|0
operator|&&
name|ntype
operator|<=
name|T_MAX
condition|)
name|types
operator|->
name|basic
index|[
name|ntype
index|]
operator|=
name|ret
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Parse a struct type.  */
end_comment

begin_function
specifier|static
name|debug_type
name|parse_coff_struct_type
parameter_list|(
name|abfd
parameter_list|,
name|symbols
parameter_list|,
name|types
parameter_list|,
name|ntype
parameter_list|,
name|pauxent
parameter_list|,
name|dhandle
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|coff_symbols
modifier|*
name|symbols
decl_stmt|;
name|struct
name|coff_types
modifier|*
name|types
decl_stmt|;
name|int
name|ntype
decl_stmt|;
name|union
name|internal_auxent
modifier|*
name|pauxent
decl_stmt|;
name|PTR
name|dhandle
decl_stmt|;
block|{
name|long
name|symend
decl_stmt|;
name|int
name|alloc
decl_stmt|;
name|debug_field
modifier|*
name|fields
decl_stmt|;
name|int
name|count
decl_stmt|;
name|boolean
name|done
decl_stmt|;
name|symend
operator|=
name|pauxent
operator|->
name|x_sym
operator|.
name|x_fcnary
operator|.
name|x_fcn
operator|.
name|x_endndx
operator|.
name|l
expr_stmt|;
name|alloc
operator|=
literal|10
expr_stmt|;
name|fields
operator|=
operator|(
name|debug_field
operator|*
operator|)
name|xmalloc
argument_list|(
name|alloc
operator|*
sizeof|sizeof
expr|*
name|fields
argument_list|)
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
name|done
operator|=
name|false
expr_stmt|;
while|while
condition|(
operator|!
name|done
operator|&&
name|symbols
operator|->
name|coff_symno
operator|<
name|symend
operator|&&
name|symbols
operator|->
name|symno
operator|<
name|symbols
operator|->
name|symcount
condition|)
block|{
name|asymbol
modifier|*
name|sym
decl_stmt|;
name|long
name|this_coff_symno
decl_stmt|;
name|struct
name|internal_syment
name|syment
decl_stmt|;
name|union
name|internal_auxent
name|auxent
decl_stmt|;
name|union
name|internal_auxent
modifier|*
name|psubaux
decl_stmt|;
name|bfd_vma
name|bitpos
init|=
literal|0
decl_stmt|,
name|bitsize
init|=
literal|0
decl_stmt|;
name|sym
operator|=
name|symbols
operator|->
name|syms
index|[
name|symbols
operator|->
name|symno
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_coff_get_syment
argument_list|(
name|abfd
argument_list|,
name|sym
argument_list|,
operator|&
name|syment
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: bfd_coff_get_syment failed: %s\n"
argument_list|,
name|program_name
argument_list|,
name|bfd_errmsg
argument_list|(
name|bfd_get_error
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|DEBUG_TYPE_NULL
return|;
block|}
name|this_coff_symno
operator|=
name|symbols
operator|->
name|coff_symno
expr_stmt|;
operator|++
name|symbols
operator|->
name|symno
expr_stmt|;
name|symbols
operator|->
name|coff_symno
operator|+=
literal|1
operator|+
name|syment
operator|.
name|n_numaux
expr_stmt|;
if|if
condition|(
name|syment
operator|.
name|n_numaux
operator|==
literal|0
condition|)
name|psubaux
operator|=
name|NULL
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|!
name|bfd_coff_get_auxent
argument_list|(
name|abfd
argument_list|,
name|sym
argument_list|,
literal|0
argument_list|,
operator|&
name|auxent
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: bfd_coff_get_auxent failed: %s\n"
argument_list|,
name|program_name
argument_list|,
name|bfd_errmsg
argument_list|(
name|bfd_get_error
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|DEBUG_TYPE_NULL
return|;
block|}
name|psubaux
operator|=
operator|&
name|auxent
expr_stmt|;
block|}
switch|switch
condition|(
name|syment
operator|.
name|n_sclass
condition|)
block|{
case|case
name|C_MOS
case|:
case|case
name|C_MOU
case|:
name|bitpos
operator|=
literal|8
operator|*
name|bfd_asymbol_value
argument_list|(
name|sym
argument_list|)
expr_stmt|;
name|bitsize
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|C_FIELD
case|:
name|bitpos
operator|=
name|bfd_asymbol_value
argument_list|(
name|sym
argument_list|)
expr_stmt|;
name|bitsize
operator|=
name|auxent
operator|.
name|x_sym
operator|.
name|x_misc
operator|.
name|x_lnsz
operator|.
name|x_size
expr_stmt|;
break|break;
case|case
name|C_EOS
case|:
name|done
operator|=
name|true
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|done
condition|)
block|{
name|debug_type
name|ftype
decl_stmt|;
name|debug_field
name|f
decl_stmt|;
name|ftype
operator|=
name|parse_coff_type
argument_list|(
name|abfd
argument_list|,
name|symbols
argument_list|,
name|types
argument_list|,
name|this_coff_symno
argument_list|,
name|syment
operator|.
name|n_type
argument_list|,
name|psubaux
argument_list|,
name|true
argument_list|,
name|dhandle
argument_list|)
expr_stmt|;
name|f
operator|=
name|debug_make_field
argument_list|(
name|dhandle
argument_list|,
name|bfd_asymbol_name
argument_list|(
name|sym
argument_list|)
argument_list|,
name|ftype
argument_list|,
name|bitpos
argument_list|,
name|bitsize
argument_list|,
name|DEBUG_VISIBILITY_PUBLIC
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|==
name|DEBUG_FIELD_NULL
condition|)
return|return
name|DEBUG_TYPE_NULL
return|;
if|if
condition|(
name|count
operator|+
literal|1
operator|>=
name|alloc
condition|)
block|{
name|alloc
operator|+=
literal|10
expr_stmt|;
name|fields
operator|=
operator|(
operator|(
name|debug_field
operator|*
operator|)
name|xrealloc
argument_list|(
name|fields
argument_list|,
name|alloc
operator|*
sizeof|sizeof
expr|*
name|fields
argument_list|)
operator|)
expr_stmt|;
block|}
name|fields
index|[
name|count
index|]
operator|=
name|f
expr_stmt|;
operator|++
name|count
expr_stmt|;
block|}
block|}
name|fields
index|[
name|count
index|]
operator|=
name|DEBUG_FIELD_NULL
expr_stmt|;
return|return
name|debug_make_struct_type
argument_list|(
name|dhandle
argument_list|,
name|ntype
operator|==
name|T_STRUCT
argument_list|,
name|pauxent
operator|->
name|x_sym
operator|.
name|x_misc
operator|.
name|x_lnsz
operator|.
name|x_size
argument_list|,
name|fields
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Parse an enum type.  */
end_comment

begin_function
specifier|static
name|debug_type
name|parse_coff_enum_type
parameter_list|(
name|abfd
parameter_list|,
name|symbols
parameter_list|,
name|types
parameter_list|,
name|pauxent
parameter_list|,
name|dhandle
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|coff_symbols
modifier|*
name|symbols
decl_stmt|;
name|struct
name|coff_types
modifier|*
name|types
decl_stmt|;
name|union
name|internal_auxent
modifier|*
name|pauxent
decl_stmt|;
name|PTR
name|dhandle
decl_stmt|;
block|{
name|long
name|symend
decl_stmt|;
name|int
name|alloc
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|names
decl_stmt|;
name|bfd_signed_vma
modifier|*
name|vals
decl_stmt|;
name|int
name|count
decl_stmt|;
name|boolean
name|done
decl_stmt|;
name|symend
operator|=
name|pauxent
operator|->
name|x_sym
operator|.
name|x_fcnary
operator|.
name|x_fcn
operator|.
name|x_endndx
operator|.
name|l
expr_stmt|;
name|alloc
operator|=
literal|10
expr_stmt|;
name|names
operator|=
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|alloc
operator|*
sizeof|sizeof
expr|*
name|names
argument_list|)
expr_stmt|;
name|vals
operator|=
operator|(
name|bfd_signed_vma
operator|*
operator|)
name|xmalloc
argument_list|(
name|alloc
operator|*
sizeof|sizeof
expr|*
name|vals
argument_list|)
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
name|done
operator|=
name|false
expr_stmt|;
while|while
condition|(
operator|!
name|done
operator|&&
name|symbols
operator|->
name|coff_symno
operator|<
name|symend
operator|&&
name|symbols
operator|->
name|symno
operator|<
name|symbols
operator|->
name|symcount
condition|)
block|{
name|asymbol
modifier|*
name|sym
decl_stmt|;
name|struct
name|internal_syment
name|syment
decl_stmt|;
name|sym
operator|=
name|symbols
operator|->
name|syms
index|[
name|symbols
operator|->
name|symno
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_coff_get_syment
argument_list|(
name|abfd
argument_list|,
name|sym
argument_list|,
operator|&
name|syment
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: bfd_coff_get_syment failed: %s\n"
argument_list|,
name|program_name
argument_list|,
name|bfd_errmsg
argument_list|(
name|bfd_get_error
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|DEBUG_TYPE_NULL
return|;
block|}
operator|++
name|symbols
operator|->
name|symno
expr_stmt|;
name|symbols
operator|->
name|coff_symno
operator|+=
literal|1
operator|+
name|syment
operator|.
name|n_numaux
expr_stmt|;
switch|switch
condition|(
name|syment
operator|.
name|n_sclass
condition|)
block|{
case|case
name|C_MOE
case|:
if|if
condition|(
name|count
operator|+
literal|1
operator|>=
name|alloc
condition|)
block|{
name|alloc
operator|+=
literal|10
expr_stmt|;
name|names
operator|=
operator|(
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
name|names
argument_list|,
name|alloc
operator|*
sizeof|sizeof
expr|*
name|names
argument_list|)
operator|)
expr_stmt|;
name|vals
operator|=
operator|(
operator|(
name|bfd_signed_vma
operator|*
operator|)
name|xrealloc
argument_list|(
name|vals
argument_list|,
name|alloc
operator|*
sizeof|sizeof
expr|*
name|vals
argument_list|)
operator|)
expr_stmt|;
block|}
name|names
index|[
name|count
index|]
operator|=
name|bfd_asymbol_name
argument_list|(
name|sym
argument_list|)
expr_stmt|;
name|vals
index|[
name|count
index|]
operator|=
name|bfd_asymbol_value
argument_list|(
name|sym
argument_list|)
expr_stmt|;
operator|++
name|count
expr_stmt|;
break|break;
case|case
name|C_EOS
case|:
name|done
operator|=
name|true
expr_stmt|;
break|break;
block|}
block|}
name|names
index|[
name|count
index|]
operator|=
name|NULL
expr_stmt|;
return|return
name|debug_make_enum_type
argument_list|(
name|dhandle
argument_list|,
name|names
argument_list|,
name|vals
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Handle a single COFF symbol.  */
end_comment

begin_function
specifier|static
name|boolean
name|parse_coff_symbol
parameter_list|(
name|abfd
parameter_list|,
name|types
parameter_list|,
name|sym
parameter_list|,
name|coff_symno
parameter_list|,
name|psyment
parameter_list|,
name|dhandle
parameter_list|,
name|type
parameter_list|,
name|within_function
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|coff_types
modifier|*
name|types
decl_stmt|;
name|asymbol
modifier|*
name|sym
decl_stmt|;
name|long
name|coff_symno
decl_stmt|;
name|struct
name|internal_syment
modifier|*
name|psyment
decl_stmt|;
name|PTR
name|dhandle
decl_stmt|;
name|debug_type
name|type
decl_stmt|;
name|boolean
name|within_function
decl_stmt|;
block|{
switch|switch
condition|(
name|psyment
operator|->
name|n_sclass
condition|)
block|{
case|case
name|C_NULL
case|:
break|break;
case|case
name|C_AUTO
case|:
if|if
condition|(
operator|!
name|debug_record_variable
argument_list|(
name|dhandle
argument_list|,
name|bfd_asymbol_name
argument_list|(
name|sym
argument_list|)
argument_list|,
name|type
argument_list|,
name|DEBUG_LOCAL
argument_list|,
name|bfd_asymbol_value
argument_list|(
name|sym
argument_list|)
argument_list|)
condition|)
return|return
name|false
return|;
break|break;
case|case
name|C_EXT
case|:
if|if
condition|(
operator|!
name|debug_record_variable
argument_list|(
name|dhandle
argument_list|,
name|bfd_asymbol_name
argument_list|(
name|sym
argument_list|)
argument_list|,
name|type
argument_list|,
name|DEBUG_GLOBAL
argument_list|,
name|bfd_asymbol_value
argument_list|(
name|sym
argument_list|)
argument_list|)
condition|)
return|return
name|false
return|;
break|break;
case|case
name|C_STAT
case|:
if|if
condition|(
operator|!
name|debug_record_variable
argument_list|(
name|dhandle
argument_list|,
name|bfd_asymbol_name
argument_list|(
name|sym
argument_list|)
argument_list|,
name|type
argument_list|,
operator|(
name|within_function
condition|?
name|DEBUG_LOCAL_STATIC
else|:
name|DEBUG_STATIC
operator|)
argument_list|,
name|bfd_asymbol_value
argument_list|(
name|sym
argument_list|)
argument_list|)
condition|)
return|return
name|false
return|;
break|break;
case|case
name|C_REG
case|:
comment|/* FIXME: We may need to convert the register number.  */
if|if
condition|(
operator|!
name|debug_record_variable
argument_list|(
name|dhandle
argument_list|,
name|bfd_asymbol_name
argument_list|(
name|sym
argument_list|)
argument_list|,
name|type
argument_list|,
name|DEBUG_REGISTER
argument_list|,
name|bfd_asymbol_value
argument_list|(
name|sym
argument_list|)
argument_list|)
condition|)
return|return
name|false
return|;
break|break;
case|case
name|C_LABEL
case|:
break|break;
case|case
name|C_ARG
case|:
if|if
condition|(
operator|!
name|debug_record_parameter
argument_list|(
name|dhandle
argument_list|,
name|bfd_asymbol_name
argument_list|(
name|sym
argument_list|)
argument_list|,
name|type
argument_list|,
name|DEBUG_PARM_STACK
argument_list|,
name|bfd_asymbol_value
argument_list|(
name|sym
argument_list|)
argument_list|)
condition|)
return|return
name|false
return|;
break|break;
case|case
name|C_REGPARM
case|:
comment|/* FIXME: We may need to convert the register number.  */
if|if
condition|(
operator|!
name|debug_record_parameter
argument_list|(
name|dhandle
argument_list|,
name|bfd_asymbol_name
argument_list|(
name|sym
argument_list|)
argument_list|,
name|type
argument_list|,
name|DEBUG_PARM_REG
argument_list|,
name|bfd_asymbol_value
argument_list|(
name|sym
argument_list|)
argument_list|)
condition|)
return|return
name|false
return|;
break|break;
case|case
name|C_TPDEF
case|:
name|type
operator|=
name|debug_name_type
argument_list|(
name|dhandle
argument_list|,
name|bfd_asymbol_name
argument_list|(
name|sym
argument_list|)
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|DEBUG_TYPE_NULL
condition|)
return|return
name|false
return|;
break|break;
case|case
name|C_STRTAG
case|:
case|case
name|C_UNTAG
case|:
case|case
name|C_ENTAG
case|:
block|{
name|debug_type
modifier|*
name|slot
decl_stmt|;
name|type
operator|=
name|debug_tag_type
argument_list|(
name|dhandle
argument_list|,
name|bfd_asymbol_name
argument_list|(
name|sym
argument_list|)
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|DEBUG_TYPE_NULL
condition|)
return|return
name|false
return|;
comment|/* Store the named type into the slot, so that references get            the name.  */
name|slot
operator|=
name|coff_get_slot
argument_list|(
name|types
argument_list|,
name|coff_symno
argument_list|)
expr_stmt|;
operator|*
name|slot
operator|=
name|type
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* This is the main routine.  It looks through all the symbols and    handles them.  */
end_comment

begin_function
name|boolean
name|parse_coff
parameter_list|(
name|abfd
parameter_list|,
name|syms
parameter_list|,
name|symcount
parameter_list|,
name|dhandle
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|syms
decl_stmt|;
name|long
name|symcount
decl_stmt|;
name|PTR
name|dhandle
decl_stmt|;
block|{
name|struct
name|coff_symbols
name|symbols
decl_stmt|;
name|struct
name|coff_types
name|types
decl_stmt|;
name|int
name|i
decl_stmt|;
name|long
name|next_c_file
decl_stmt|;
specifier|const
name|char
modifier|*
name|fnname
decl_stmt|;
name|int
name|fnclass
decl_stmt|;
name|int
name|fntype
decl_stmt|;
name|bfd_vma
name|fnend
decl_stmt|;
name|alent
modifier|*
name|linenos
decl_stmt|;
name|boolean
name|within_function
decl_stmt|;
name|long
name|this_coff_symno
decl_stmt|;
name|symbols
operator|.
name|syms
operator|=
name|syms
expr_stmt|;
name|symbols
operator|.
name|symcount
operator|=
name|symcount
expr_stmt|;
name|symbols
operator|.
name|symno
operator|=
literal|0
expr_stmt|;
name|symbols
operator|.
name|coff_symno
operator|=
literal|0
expr_stmt|;
name|types
operator|.
name|slots
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|T_MAX
condition|;
name|i
operator|++
control|)
name|types
operator|.
name|basic
index|[
name|i
index|]
operator|=
name|DEBUG_TYPE_NULL
expr_stmt|;
name|next_c_file
operator|=
operator|-
literal|1
expr_stmt|;
name|fnname
operator|=
name|NULL
expr_stmt|;
name|fnclass
operator|=
literal|0
expr_stmt|;
name|fntype
operator|=
literal|0
expr_stmt|;
name|fnend
operator|=
literal|0
expr_stmt|;
name|linenos
operator|=
name|NULL
expr_stmt|;
name|within_function
operator|=
name|false
expr_stmt|;
while|while
condition|(
name|symbols
operator|.
name|symno
operator|<
name|symcount
condition|)
block|{
name|asymbol
modifier|*
name|sym
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|struct
name|internal_syment
name|syment
decl_stmt|;
name|union
name|internal_auxent
name|auxent
decl_stmt|;
name|union
name|internal_auxent
modifier|*
name|paux
decl_stmt|;
name|debug_type
name|type
decl_stmt|;
name|sym
operator|=
name|syms
index|[
name|symbols
operator|.
name|symno
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_coff_get_syment
argument_list|(
name|abfd
argument_list|,
name|sym
argument_list|,
operator|&
name|syment
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: bfd_coff_get_syment failed: %s\n"
argument_list|,
name|program_name
argument_list|,
name|bfd_errmsg
argument_list|(
name|bfd_get_error
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|name
operator|=
name|bfd_asymbol_name
argument_list|(
name|sym
argument_list|)
expr_stmt|;
name|this_coff_symno
operator|=
name|symbols
operator|.
name|coff_symno
expr_stmt|;
operator|++
name|symbols
operator|.
name|symno
expr_stmt|;
name|symbols
operator|.
name|coff_symno
operator|+=
literal|1
operator|+
name|syment
operator|.
name|n_numaux
expr_stmt|;
comment|/* We only worry about the first auxent, because that is the 	 only one which is relevant for debugging information.  */
if|if
condition|(
name|syment
operator|.
name|n_numaux
operator|==
literal|0
condition|)
name|paux
operator|=
name|NULL
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|!
name|bfd_coff_get_auxent
argument_list|(
name|abfd
argument_list|,
name|sym
argument_list|,
literal|0
argument_list|,
operator|&
name|auxent
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: bfd_coff_get_auxent failed: %s\n"
argument_list|,
name|program_name
argument_list|,
name|bfd_errmsg
argument_list|(
name|bfd_get_error
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|paux
operator|=
operator|&
name|auxent
expr_stmt|;
block|}
if|if
condition|(
name|this_coff_symno
operator|==
name|next_c_file
operator|&&
name|syment
operator|.
name|n_sclass
operator|!=
name|C_FILE
condition|)
block|{
comment|/* The last C_FILE symbol points to the first external              symbol.  */
if|if
condition|(
operator|!
name|debug_set_filename
argument_list|(
name|dhandle
argument_list|,
literal|"*globals*"
argument_list|)
condition|)
return|return
name|false
return|;
block|}
switch|switch
condition|(
name|syment
operator|.
name|n_sclass
condition|)
block|{
case|case
name|C_EFCN
case|:
case|case
name|C_EXTDEF
case|:
case|case
name|C_ULABEL
case|:
case|case
name|C_USTATIC
case|:
case|case
name|C_LINE
case|:
case|case
name|C_ALIAS
case|:
case|case
name|C_HIDDEN
case|:
comment|/* Just ignore these classes.  */
break|break;
case|case
name|C_FILE
case|:
name|next_c_file
operator|=
name|syment
operator|.
name|n_value
expr_stmt|;
if|if
condition|(
operator|!
name|debug_set_filename
argument_list|(
name|dhandle
argument_list|,
name|name
argument_list|)
condition|)
return|return
name|false
return|;
break|break;
case|case
name|C_STAT
case|:
comment|/* Ignore static symbols with a type of T_NULL.  These              represent section entries.  */
if|if
condition|(
name|syment
operator|.
name|n_type
operator|==
name|T_NULL
condition|)
break|break;
comment|/* Fall through.  */
case|case
name|C_EXT
case|:
if|if
condition|(
name|ISFCN
argument_list|(
name|syment
operator|.
name|n_type
argument_list|)
condition|)
block|{
name|fnname
operator|=
name|name
expr_stmt|;
name|fnclass
operator|=
name|syment
operator|.
name|n_sclass
expr_stmt|;
name|fntype
operator|=
name|syment
operator|.
name|n_type
expr_stmt|;
if|if
condition|(
name|syment
operator|.
name|n_numaux
operator|>
literal|0
condition|)
name|fnend
operator|=
name|bfd_asymbol_value
argument_list|(
name|sym
argument_list|)
operator|+
name|auxent
operator|.
name|x_sym
operator|.
name|x_misc
operator|.
name|x_fsize
expr_stmt|;
else|else
name|fnend
operator|=
literal|0
expr_stmt|;
name|linenos
operator|=
name|BFD_SEND
argument_list|(
name|abfd
argument_list|,
name|_get_lineno
argument_list|,
operator|(
name|abfd
operator|,
name|sym
operator|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|type
operator|=
name|parse_coff_type
argument_list|(
name|abfd
argument_list|,
operator|&
name|symbols
argument_list|,
operator|&
name|types
argument_list|,
name|this_coff_symno
argument_list|,
name|syment
operator|.
name|n_type
argument_list|,
name|paux
argument_list|,
name|true
argument_list|,
name|dhandle
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|DEBUG_TYPE_NULL
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|!
name|parse_coff_symbol
argument_list|(
name|abfd
argument_list|,
operator|&
name|types
argument_list|,
name|sym
argument_list|,
name|this_coff_symno
argument_list|,
operator|&
name|syment
argument_list|,
name|dhandle
argument_list|,
name|type
argument_list|,
name|within_function
argument_list|)
condition|)
return|return
name|false
return|;
break|break;
case|case
name|C_FCN
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".bf"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|fnname
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: %ld: .bf without preceding function\n"
argument_list|,
name|program_name
argument_list|,
name|this_coff_symno
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|type
operator|=
name|parse_coff_type
argument_list|(
name|abfd
argument_list|,
operator|&
name|symbols
argument_list|,
operator|&
name|types
argument_list|,
name|this_coff_symno
argument_list|,
name|DECREF
argument_list|(
name|fntype
argument_list|)
argument_list|,
name|paux
argument_list|,
name|false
argument_list|,
name|dhandle
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|DEBUG_TYPE_NULL
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|!
name|debug_record_function
argument_list|(
name|dhandle
argument_list|,
name|fnname
argument_list|,
name|type
argument_list|,
name|fnclass
operator|==
name|C_EXT
argument_list|,
name|bfd_asymbol_value
argument_list|(
name|sym
argument_list|)
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|linenos
operator|!=
name|NULL
condition|)
block|{
name|int
name|base
decl_stmt|;
name|bfd_vma
name|addr
decl_stmt|;
if|if
condition|(
name|syment
operator|.
name|n_numaux
operator|==
literal|0
condition|)
name|base
operator|=
literal|0
expr_stmt|;
else|else
name|base
operator|=
name|auxent
operator|.
name|x_sym
operator|.
name|x_misc
operator|.
name|x_lnsz
operator|.
name|x_lnno
operator|-
literal|1
expr_stmt|;
name|addr
operator|=
name|bfd_get_section_vma
argument_list|(
name|abfd
argument_list|,
name|bfd_get_section
argument_list|(
name|sym
argument_list|)
argument_list|)
expr_stmt|;
operator|++
name|linenos
expr_stmt|;
while|while
condition|(
name|linenos
operator|->
name|line_number
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|debug_record_line
argument_list|(
name|dhandle
argument_list|,
name|linenos
operator|->
name|line_number
operator|+
name|base
argument_list|,
name|linenos
operator|->
name|u
operator|.
name|offset
operator|+
name|addr
argument_list|)
condition|)
return|return
name|false
return|;
operator|++
name|linenos
expr_stmt|;
block|}
block|}
name|fnname
operator|=
name|NULL
expr_stmt|;
name|linenos
operator|=
name|NULL
expr_stmt|;
name|fnclass
operator|=
literal|0
expr_stmt|;
name|fntype
operator|=
literal|0
expr_stmt|;
name|within_function
operator|=
name|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".ef"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|within_function
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: %ld: unexpected .ef\n"
argument_list|,
name|program_name
argument_list|,
name|this_coff_symno
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
name|bfd_asymbol_value
argument_list|(
name|sym
argument_list|)
operator|>
name|fnend
condition|)
name|fnend
operator|=
name|bfd_asymbol_value
argument_list|(
name|sym
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|debug_end_function
argument_list|(
name|dhandle
argument_list|,
name|fnend
argument_list|)
condition|)
return|return
name|false
return|;
name|fnend
operator|=
literal|0
expr_stmt|;
name|within_function
operator|=
name|false
expr_stmt|;
block|}
break|break;
case|case
name|C_BLOCK
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".bb"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|debug_start_block
argument_list|(
name|dhandle
argument_list|,
name|bfd_asymbol_value
argument_list|(
name|sym
argument_list|)
argument_list|)
condition|)
return|return
name|false
return|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".eb"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|debug_end_block
argument_list|(
name|dhandle
argument_list|,
name|bfd_asymbol_value
argument_list|(
name|sym
argument_list|)
argument_list|)
condition|)
return|return
name|false
return|;
block|}
break|break;
default|default:
name|type
operator|=
name|parse_coff_type
argument_list|(
name|abfd
argument_list|,
operator|&
name|symbols
argument_list|,
operator|&
name|types
argument_list|,
name|this_coff_symno
argument_list|,
name|syment
operator|.
name|n_type
argument_list|,
name|paux
argument_list|,
name|true
argument_list|,
name|dhandle
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|DEBUG_TYPE_NULL
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|!
name|parse_coff_symbol
argument_list|(
name|abfd
argument_list|,
operator|&
name|types
argument_list|,
name|sym
argument_list|,
name|this_coff_symno
argument_list|,
operator|&
name|syment
argument_list|,
name|dhandle
argument_list|,
name|type
argument_list|,
name|within_function
argument_list|)
condition|)
return|return
name|false
return|;
break|break;
block|}
block|}
return|return
name|true
return|;
block|}
end_function

end_unit

