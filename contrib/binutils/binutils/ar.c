begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* ar.c - Archive modify and extract.    Copyright 1991, 92, 93, 94, 95, 96, 97, 1998 Free Software Foundation, Inc.  This file is part of GNU Binutils.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_escape
end_escape

begin_comment
comment|/*    Bugs: should use getopt the way tar does (complete w/optional -) and    should have long options too. GNU ar used to check file against filesystem    in quick_update and replace operations (would check mtime). Doesn't warn    when name truncated. No way to specify pos_end. Error messages should be    more consistant. */
end_comment

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"libiberty.h"
end_include

begin_include
include|#
directive|include
file|"progress.h"
end_include

begin_include
include|#
directive|include
file|"bucomm.h"
end_include

begin_include
include|#
directive|include
file|"aout/ar.h"
end_include

begin_include
include|#
directive|include
file|"libbfd.h"
end_include

begin_include
include|#
directive|include
file|"arsup.h"
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_GOOD_UTIME_H
end_ifdef

begin_include
include|#
directive|include
file|<utime.h>
end_include

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* ! HAVE_GOOD_UTIME_H */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_UTIMES
end_ifdef

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_UTIMES */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ! HAVE_GOOD_UTIME_H */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__GO32___
end_ifdef

begin_define
define|#
directive|define
name|EXT_NAME_LEN
value|3
end_define

begin_comment
comment|/* bufflen of addition to name if it's MS-DOS */
end_comment

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|EXT_NAME_LEN
value|6
end_define

begin_comment
comment|/* ditto for *NIX */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|BUFSIZE
value|8192
end_define

begin_comment
comment|/* Kludge declaration from BFD!  This is ugly!  FIXME!  XXX */
end_comment

begin_decl_stmt
name|struct
name|ar_hdr
modifier|*
name|bfd_special_undocumented_glue
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|abfd
operator|,
specifier|const
name|char
operator|*
name|filename
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Static declarations */
end_comment

begin_decl_stmt
specifier|static
name|void
name|mri_emul
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|normalize
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|remove_output
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|map_over_members
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|bfd
operator|*
argument_list|)
operator|,
name|char
operator|*
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|print_contents
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|member
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|delete_members
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|char
operator|*
operator|*
name|files_to_delete
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static void do_quick_append PARAMS ((const char *archive_filename, 			 char **files_to_append));
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|void
name|move_members
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|char
operator|*
operator|*
name|files_to_move
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|replace_members
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|char
operator|*
operator|*
name|files_to_replace
operator|,
name|boolean
name|quick
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|print_descr
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|abfd
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|write_archive
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ranlib_only
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|archname
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ranlib_touch
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|archname
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|usage
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/** Globals and flags */
end_comment

begin_decl_stmt
name|int
name|mri_mode
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This flag distinguishes between ar and ranlib:    1 means this is 'ranlib'; 0 means this is 'ar'.    -1 means if we should use argv[0] to decide.  */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|is_ranlib
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means don't warn about creating the archive file if necessary.  */
end_comment

begin_decl_stmt
name|int
name|silent_create
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means describe each action performed.  */
end_comment

begin_decl_stmt
name|int
name|verbose
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means preserve dates of members when extracting them.  */
end_comment

begin_decl_stmt
name|int
name|preserve_dates
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means don't replace existing members whose dates are more recent    than the corresponding files.  */
end_comment

begin_decl_stmt
name|int
name|newer_only
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Controls the writing of an archive symbol table (in BSD: a __.SYMDEF    member).  -1 means we've been explicitly asked to not write a symbol table;    +1 means we've been explictly asked to write it;    0 is the default.    Traditionally, the default in BSD has been to not write the table.    However, for POSIX.2 compliance the default is now to write a symbol table    if any of the members are object files.  */
end_comment

begin_decl_stmt
name|int
name|write_armap
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means it's the name of an existing member; position new or moved    files with respect to this one.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|posname
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Sez how to use `posname': pos_before means position before that member.    pos_after means position after that member. pos_end means always at end.    pos_default means default appropriately. For the latter two, `posname'    should also be zero.  */
end_comment

begin_enum
enum|enum
name|pos
block|{
name|pos_default
block|,
name|pos_before
block|,
name|pos_after
block|,
name|pos_end
block|}
name|postype
init|=
name|pos_default
enum|;
end_enum

begin_decl_stmt
specifier|static
name|bfd
modifier|*
modifier|*
name|get_pos_bfd
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|*
operator|,
expr|enum
name|pos
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Whether to truncate names of files stored in the archive.  */
end_comment

begin_decl_stmt
specifier|static
name|boolean
name|ar_truncate
init|=
name|false
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|interactive
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|mri_emul
parameter_list|()
block|{
name|interactive
operator|=
name|isatty
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|)
expr_stmt|;
name|yyparse
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* If COUNT is 0, then FUNCTION is called once on each entry.  If nonzero,    COUNT is the length of the FILES chain; FUNCTION is called on each entry    whose name matches one in FILES.  */
end_comment

begin_function_decl
specifier|static
name|void
name|map_over_members
parameter_list|(
name|arch
parameter_list|,
name|function
parameter_list|,
name|files
parameter_list|,
name|count
parameter_list|)
name|bfd
modifier|*
name|arch
decl_stmt|;
function_decl|void
parameter_list|(
function_decl|*function
end_function_decl

begin_expr_stmt
unit|)
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|char
modifier|*
modifier|*
name|files
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|count
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|bfd
modifier|*
name|head
decl_stmt|;
if|if
condition|(
name|count
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|head
operator|=
name|arch
operator|->
name|next
init|;
name|head
condition|;
name|head
operator|=
name|head
operator|->
name|next
control|)
block|{
name|PROGRESS
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|function
argument_list|(
name|head
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
comment|/* This may appear to be a baroque way of accomplishing what we want.      However we have to iterate over the filenames in order to notice where      a filename is requested but does not exist in the archive.  Ditto      mapping over each file each time -- we want to hack multiple      references.  */
for|for
control|(
init|;
name|count
operator|>
literal|0
condition|;
name|files
operator|++
operator|,
name|count
operator|--
control|)
block|{
name|boolean
name|found
init|=
name|false
decl_stmt|;
for|for
control|(
name|head
operator|=
name|arch
operator|->
name|next
init|;
name|head
condition|;
name|head
operator|=
name|head
operator|->
name|next
control|)
block|{
name|PROGRESS
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|head
operator|->
name|filename
operator|==
name|NULL
condition|)
block|{
comment|/* Some archive formats don't get the filenames filled in 		 until the elements are opened.  */
name|struct
name|stat
name|buf
decl_stmt|;
name|bfd_stat_arch_elt
argument_list|(
name|head
argument_list|,
operator|&
name|buf
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|head
operator|->
name|filename
operator|!=
name|NULL
operator|)
operator|&&
operator|(
operator|!
name|strcmp
argument_list|(
operator|*
name|files
argument_list|,
name|head
operator|->
name|filename
argument_list|)
operator|)
condition|)
block|{
name|found
operator|=
name|true
expr_stmt|;
name|function
argument_list|(
name|head
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|found
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"no entry %s in archive\n"
argument_list|,
operator|*
name|files
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_escape
end_escape

begin_decl_stmt
name|boolean
name|operation_alters_arch
init|=
name|false
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|usage
parameter_list|(
name|help
parameter_list|)
name|int
name|help
decl_stmt|;
block|{
name|FILE
modifier|*
name|s
decl_stmt|;
name|s
operator|=
name|help
condition|?
name|stdout
else|:
name|stderr
expr_stmt|;
if|if
condition|(
operator|!
name|is_ranlib
condition|)
name|fprintf
argument_list|(
name|s
argument_list|,
literal|"\ Usage: %s [-]{dmpqrtx}[abcilosSuvV] [member-name] archive-file file...\n\        %s -M [<mri-script]\n"
argument_list|,
name|program_name
argument_list|,
name|program_name
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|s
argument_list|,
literal|"\ Usage: %s [-vV] archive\n"
argument_list|,
name|program_name
argument_list|)
expr_stmt|;
name|list_supported_targets
argument_list|(
name|program_name
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
if|if
condition|(
name|help
condition|)
name|fprintf
argument_list|(
name|s
argument_list|,
literal|"Report bugs to bug-gnu-utils@gnu.org\n"
argument_list|)
expr_stmt|;
name|xexit
argument_list|(
name|help
condition|?
literal|0
else|:
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Normalize a file name specified on the command line into a file    name which we will use in an archive.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|normalize
parameter_list|(
name|file
parameter_list|,
name|abfd
parameter_list|)
specifier|const
name|char
modifier|*
name|file
decl_stmt|;
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|filename
decl_stmt|;
name|filename
operator|=
name|strrchr
argument_list|(
name|file
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|filename
operator|!=
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
name|filename
operator|++
expr_stmt|;
else|else
name|filename
operator|=
name|file
expr_stmt|;
if|if
condition|(
name|ar_truncate
operator|&&
name|abfd
operator|!=
name|NULL
operator|&&
name|strlen
argument_list|(
name|filename
argument_list|)
operator|>
name|abfd
operator|->
name|xvec
operator|->
name|ar_max_namelen
condition|)
block|{
name|char
modifier|*
name|s
decl_stmt|;
comment|/* Space leak.  */
name|s
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|abfd
operator|->
name|xvec
operator|->
name|ar_max_namelen
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|s
argument_list|,
name|filename
argument_list|,
name|abfd
operator|->
name|xvec
operator|->
name|ar_max_namelen
argument_list|)
expr_stmt|;
name|s
index|[
name|abfd
operator|->
name|xvec
operator|->
name|ar_max_namelen
index|]
operator|=
literal|'\0'
expr_stmt|;
name|filename
operator|=
name|s
expr_stmt|;
block|}
return|return
name|filename
return|;
block|}
end_function

begin_comment
comment|/* Remove any output file.  This is only called via xatexit.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|output_filename
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|output_file
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd
modifier|*
name|output_bfd
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|remove_output
parameter_list|()
block|{
if|if
condition|(
name|output_filename
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|output_bfd
operator|!=
name|NULL
operator|&&
name|output_bfd
operator|->
name|iostream
operator|!=
name|NULL
condition|)
name|fclose
argument_list|(
operator|(
name|FILE
operator|*
operator|)
operator|(
name|output_bfd
operator|->
name|iostream
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|output_file
operator|!=
name|NULL
condition|)
name|fclose
argument_list|(
name|output_file
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|output_filename
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* The option parsing should be in its own function.    It will be when I have getopt working.  */
end_comment

begin_function
name|int
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|char
modifier|*
name|arg_ptr
decl_stmt|;
name|char
name|c
decl_stmt|;
enum|enum
block|{
name|none
init|=
literal|0
block|,
name|delete
block|,
name|replace
block|,
name|print_table
block|,
name|print_files
block|,
name|extract
block|,
name|move
block|,
name|quick_append
block|}
name|operation
init|=
name|none
enum|;
name|int
name|arg_index
decl_stmt|;
name|char
modifier|*
modifier|*
name|files
decl_stmt|;
name|char
modifier|*
name|inarch_filename
decl_stmt|;
name|int
name|show_version
decl_stmt|;
name|program_name
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
name|xmalloc_set_program_name
argument_list|(
name|program_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_ranlib
operator|<
literal|0
condition|)
block|{
name|char
modifier|*
name|temp
decl_stmt|;
name|temp
operator|=
name|strrchr
argument_list|(
name|program_name
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|==
name|NULL
condition|)
name|temp
operator|=
name|program_name
expr_stmt|;
else|else
operator|++
name|temp
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|temp
argument_list|)
operator|>=
literal|6
operator|&&
name|strcmp
argument_list|(
name|temp
operator|+
name|strlen
argument_list|(
name|temp
argument_list|)
operator|-
literal|6
argument_list|,
literal|"ranlib"
argument_list|)
operator|==
literal|0
condition|)
name|is_ranlib
operator|=
literal|1
expr_stmt|;
else|else
name|is_ranlib
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|argc
operator|>
literal|1
operator|&&
name|argv
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"--help"
argument_list|)
operator|==
literal|0
condition|)
name|usage
argument_list|(
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"--version"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|is_ranlib
condition|)
name|print_version
argument_list|(
literal|"ranlib"
argument_list|)
expr_stmt|;
else|else
name|print_version
argument_list|(
literal|"ar"
argument_list|)
expr_stmt|;
block|}
block|}
name|START_PROGRESS
argument_list|(
name|program_name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bfd_init
argument_list|()
expr_stmt|;
name|set_default_bfd_target
argument_list|()
expr_stmt|;
name|show_version
operator|=
literal|0
expr_stmt|;
name|xatexit
argument_list|(
name|remove_output
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_ranlib
condition|)
block|{
name|boolean
name|touch
init|=
name|false
decl_stmt|;
if|if
condition|(
name|argc
operator|<
literal|2
operator|||
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"--help"
argument_list|)
operator|==
literal|0
condition|)
name|usage
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"-V"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"-v"
argument_list|)
operator|==
literal|0
operator|||
name|strncmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"--v"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
name|print_version
argument_list|(
literal|"ranlib"
argument_list|)
expr_stmt|;
name|arg_index
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"-t"
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|++
name|arg_index
expr_stmt|;
name|touch
operator|=
name|true
expr_stmt|;
block|}
while|while
condition|(
name|arg_index
operator|<
name|argc
condition|)
block|{
if|if
condition|(
operator|!
name|touch
condition|)
name|ranlib_only
argument_list|(
name|argv
index|[
name|arg_index
index|]
argument_list|)
expr_stmt|;
else|else
name|ranlib_touch
argument_list|(
name|argv
index|[
name|arg_index
index|]
argument_list|)
expr_stmt|;
operator|++
name|arg_index
expr_stmt|;
block|}
name|xexit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|argc
operator|==
literal|2
operator|&&
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"-M"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|mri_emul
argument_list|()
expr_stmt|;
name|xexit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
name|usage
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|arg_ptr
operator|=
name|argv
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
operator|*
name|arg_ptr
operator|==
literal|'-'
condition|)
operator|++
name|arg_ptr
expr_stmt|;
comment|/* compatibility */
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|arg_ptr
operator|++
operator|)
operator|!=
literal|'\0'
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'d'
case|:
case|case
literal|'m'
case|:
case|case
literal|'p'
case|:
case|case
literal|'q'
case|:
case|case
literal|'r'
case|:
case|case
literal|'t'
case|:
case|case
literal|'x'
case|:
if|if
condition|(
name|operation
operator|!=
name|none
condition|)
name|fatal
argument_list|(
literal|"two different operation options specified"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'d'
case|:
name|operation
operator|=
name|delete
expr_stmt|;
name|operation_alters_arch
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
name|operation
operator|=
name|move
expr_stmt|;
name|operation_alters_arch
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|operation
operator|=
name|print_files
expr_stmt|;
break|break;
case|case
literal|'q'
case|:
name|operation
operator|=
name|quick_append
expr_stmt|;
name|operation_alters_arch
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|operation
operator|=
name|replace
expr_stmt|;
name|operation_alters_arch
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|operation
operator|=
name|print_table
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
name|operation
operator|=
name|extract
expr_stmt|;
break|break;
block|}
case|case
literal|'l'
case|:
break|break;
case|case
literal|'c'
case|:
name|silent_create
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
name|preserve_dates
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'V'
case|:
name|show_version
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|write_armap
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
name|write_armap
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
name|newer_only
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
name|verbose
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
name|postype
operator|=
name|pos_after
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
name|postype
operator|=
name|pos_before
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
name|postype
operator|=
name|pos_before
expr_stmt|;
break|break;
case|case
literal|'M'
case|:
name|mri_mode
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|ar_truncate
operator|=
name|true
expr_stmt|;
break|break;
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: illegal option -- %c\n"
argument_list|,
name|program_name
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|usage
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|show_version
condition|)
name|print_version
argument_list|(
literal|"ar"
argument_list|)
expr_stmt|;
if|if
condition|(
name|argc
operator|<
literal|3
condition|)
name|usage
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|mri_mode
condition|)
block|{
name|mri_emul
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|bfd
modifier|*
name|arch
decl_stmt|;
comment|/* We can't write an armap when using ar q, so just do ar r          instead.  */
if|if
condition|(
name|operation
operator|==
name|quick_append
operator|&&
name|write_armap
condition|)
name|operation
operator|=
name|replace
expr_stmt|;
if|if
condition|(
operator|(
name|operation
operator|==
name|none
operator|||
name|operation
operator|==
name|print_table
operator|)
operator|&&
name|write_armap
operator|==
literal|1
condition|)
block|{
name|ranlib_only
argument_list|(
name|argv
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|xexit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|operation
operator|==
name|none
condition|)
name|fatal
argument_list|(
literal|"no operation specified"
argument_list|)
expr_stmt|;
if|if
condition|(
name|newer_only
operator|&&
name|operation
operator|!=
name|replace
condition|)
name|fatal
argument_list|(
literal|"`u' is only meaningful with the `r' option."
argument_list|)
expr_stmt|;
name|arg_index
operator|=
literal|2
expr_stmt|;
if|if
condition|(
name|postype
operator|!=
name|pos_default
condition|)
name|posname
operator|=
name|argv
index|[
name|arg_index
operator|++
index|]
expr_stmt|;
name|inarch_filename
operator|=
name|argv
index|[
name|arg_index
operator|++
index|]
expr_stmt|;
name|files
operator|=
name|arg_index
operator|<
name|argc
condition|?
name|argv
operator|+
name|arg_index
else|:
name|NULL
expr_stmt|;
if|#
directive|if
literal|0
comment|/* We don't use do_quick_append any more.  Too many systems          expect ar to always rebuild the symbol table even when q is          used.  */
comment|/* We can't do a quick append if we need to construct an 	 extended name table, because do_quick_append won't be able to 	 rebuild the name table.  Unfortunately, at this point we 	 don't actually know the maximum name length permitted by this 	 object file format.  So, we guess.  FIXME.  */
block|if (operation == quick_append&& ! ar_truncate) 	{ 	  char **chk;  	  for (chk = files; chk != NULL&& *chk != '\0'; chk++) 	    { 	      if (strlen (normalize (*chk, (bfd *) NULL))> 14) 		{ 		  operation = replace; 		  break; 		} 	    } 	}        if (operation == quick_append) 	{
comment|/* Note that quick appending to a non-existent archive creates it, 	     even if there are no files to append. */
block|do_quick_append (inarch_filename, files); 	  xexit (0); 	}
endif|#
directive|endif
name|arch
operator|=
name|open_inarch
argument_list|(
name|inarch_filename
argument_list|,
name|files
operator|==
name|NULL
condition|?
operator|(
name|char
operator|*
operator|)
name|NULL
else|:
name|files
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|operation
condition|)
block|{
case|case
name|print_table
case|:
name|map_over_members
argument_list|(
name|arch
argument_list|,
name|print_descr
argument_list|,
name|files
argument_list|,
name|argc
operator|-
literal|3
argument_list|)
expr_stmt|;
break|break;
case|case
name|print_files
case|:
name|map_over_members
argument_list|(
name|arch
argument_list|,
name|print_contents
argument_list|,
name|files
argument_list|,
name|argc
operator|-
literal|3
argument_list|)
expr_stmt|;
break|break;
case|case
name|extract
case|:
name|map_over_members
argument_list|(
name|arch
argument_list|,
name|extract_file
argument_list|,
name|files
argument_list|,
name|argc
operator|-
literal|3
argument_list|)
expr_stmt|;
break|break;
case|case
name|delete
case|:
if|if
condition|(
name|files
operator|!=
name|NULL
condition|)
name|delete_members
argument_list|(
name|arch
argument_list|,
name|files
argument_list|)
expr_stmt|;
break|break;
case|case
name|move
case|:
if|if
condition|(
name|files
operator|!=
name|NULL
condition|)
name|move_members
argument_list|(
name|arch
argument_list|,
name|files
argument_list|)
expr_stmt|;
break|break;
case|case
name|replace
case|:
case|case
name|quick_append
case|:
if|if
condition|(
name|files
operator|!=
name|NULL
operator|||
name|write_armap
operator|>
literal|0
condition|)
name|replace_members
argument_list|(
name|arch
argument_list|,
name|files
argument_list|,
name|operation
operator|==
name|quick_append
argument_list|)
expr_stmt|;
break|break;
comment|/* Shouldn't happen! */
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: internal error -- this option not implemented\n"
argument_list|,
name|program_name
argument_list|)
expr_stmt|;
name|xexit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
name|END_PROGRESS
argument_list|(
name|program_name
argument_list|)
expr_stmt|;
name|xexit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|bfd
modifier|*
name|open_inarch
parameter_list|(
name|archive_filename
parameter_list|,
name|file
parameter_list|)
specifier|const
name|char
modifier|*
name|archive_filename
decl_stmt|;
specifier|const
name|char
modifier|*
name|file
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|target
decl_stmt|;
name|bfd
modifier|*
modifier|*
name|last_one
decl_stmt|;
name|bfd
modifier|*
name|next_one
decl_stmt|;
name|struct
name|stat
name|sbuf
decl_stmt|;
name|bfd
modifier|*
name|arch
decl_stmt|;
name|char
modifier|*
modifier|*
name|matching
decl_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_no_error
argument_list|)
expr_stmt|;
name|target
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|archive_filename
argument_list|,
operator|&
name|sbuf
argument_list|)
operator|!=
literal|0
condition|)
block|{
ifndef|#
directive|ifndef
name|__GO32__
comment|/* KLUDGE ALERT! Temporary fix until I figger why  * stat() is wrong ... think it's buried in GO32's IDT  * - Jax  */
if|if
condition|(
name|errno
operator|!=
name|ENOENT
condition|)
name|bfd_fatal
argument_list|(
name|archive_filename
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|operation_alters_arch
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: "
argument_list|,
name|program_name
argument_list|)
expr_stmt|;
name|perror
argument_list|(
name|archive_filename
argument_list|)
expr_stmt|;
name|maybequit
argument_list|()
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* Try to figure out the target to use for the archive from the          first object on the list.  */
if|if
condition|(
name|file
operator|!=
name|NULL
condition|)
block|{
name|bfd
modifier|*
name|obj
decl_stmt|;
name|obj
operator|=
name|bfd_openr
argument_list|(
name|file
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|obj
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|bfd_check_format
argument_list|(
name|obj
argument_list|,
name|bfd_object
argument_list|)
condition|)
name|target
operator|=
name|bfd_get_target
argument_list|(
name|obj
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|bfd_close
argument_list|(
name|obj
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Create an empty archive.  */
name|arch
operator|=
name|bfd_openw
argument_list|(
name|archive_filename
argument_list|,
name|target
argument_list|)
expr_stmt|;
if|if
condition|(
name|arch
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_format
argument_list|(
name|arch
argument_list|,
name|bfd_archive
argument_list|)
operator|||
operator|!
name|bfd_close
argument_list|(
name|arch
argument_list|)
condition|)
name|bfd_fatal
argument_list|(
name|archive_filename
argument_list|)
expr_stmt|;
block|}
name|arch
operator|=
name|bfd_openr
argument_list|(
name|archive_filename
argument_list|,
name|target
argument_list|)
expr_stmt|;
if|if
condition|(
name|arch
operator|==
name|NULL
condition|)
block|{
name|bloser
label|:
name|bfd_fatal
argument_list|(
name|archive_filename
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|bfd_check_format_matches
argument_list|(
name|arch
argument_list|,
name|bfd_archive
argument_list|,
operator|&
name|matching
argument_list|)
condition|)
block|{
name|bfd_nonfatal
argument_list|(
name|archive_filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_get_error
argument_list|()
operator|==
name|bfd_error_file_ambiguously_recognized
condition|)
block|{
name|list_matching_formats
argument_list|(
name|matching
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|matching
argument_list|)
expr_stmt|;
block|}
name|xexit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|last_one
operator|=
operator|&
operator|(
name|arch
operator|->
name|next
operator|)
expr_stmt|;
comment|/* Read all the contents right away, regardless.  */
for|for
control|(
name|next_one
operator|=
name|bfd_openr_next_archived_file
argument_list|(
name|arch
argument_list|,
name|NULL
argument_list|)
init|;
name|next_one
condition|;
name|next_one
operator|=
name|bfd_openr_next_archived_file
argument_list|(
name|arch
argument_list|,
name|next_one
argument_list|)
control|)
block|{
name|PROGRESS
argument_list|(
literal|1
argument_list|)
expr_stmt|;
operator|*
name|last_one
operator|=
name|next_one
expr_stmt|;
name|last_one
operator|=
operator|&
name|next_one
operator|->
name|next
expr_stmt|;
block|}
operator|*
name|last_one
operator|=
operator|(
name|bfd
operator|*
operator|)
name|NULL
expr_stmt|;
if|if
condition|(
name|bfd_get_error
argument_list|()
operator|!=
name|bfd_error_no_more_archived_files
condition|)
goto|goto
name|bloser
goto|;
return|return
name|arch
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|print_contents
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|int
name|ncopied
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|cbuf
init|=
name|xmalloc
argument_list|(
name|BUFSIZE
argument_list|)
decl_stmt|;
name|struct
name|stat
name|buf
decl_stmt|;
name|long
name|size
decl_stmt|;
if|if
condition|(
name|bfd_stat_arch_elt
argument_list|(
name|abfd
argument_list|,
operator|&
name|buf
argument_list|)
operator|!=
literal|0
condition|)
name|fatal
argument_list|(
literal|"internal stat error on %s"
argument_list|,
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
name|printf
argument_list|(
literal|"\n<member %s>\n\n"
argument_list|,
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
literal|0
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
name|size
operator|=
name|buf
operator|.
name|st_size
expr_stmt|;
while|while
condition|(
name|ncopied
operator|<
name|size
condition|)
block|{
name|int
name|nread
decl_stmt|;
name|int
name|tocopy
init|=
name|size
operator|-
name|ncopied
decl_stmt|;
if|if
condition|(
name|tocopy
operator|>
name|BUFSIZE
condition|)
name|tocopy
operator|=
name|BUFSIZE
expr_stmt|;
name|nread
operator|=
name|bfd_read
argument_list|(
name|cbuf
argument_list|,
literal|1
argument_list|,
name|tocopy
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
comment|/* oops -- broke 							   abstraction!  */
if|if
condition|(
name|nread
operator|!=
name|tocopy
condition|)
name|fatal
argument_list|(
literal|"%s is not a valid archive"
argument_list|,
name|bfd_get_filename
argument_list|(
name|bfd_my_archive
argument_list|(
name|abfd
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|fwrite
argument_list|(
name|cbuf
argument_list|,
literal|1
argument_list|,
name|nread
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|ncopied
operator|+=
name|tocopy
expr_stmt|;
block|}
name|free
argument_list|(
name|cbuf
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Extract a member of the archive into its own file.     We defer opening the new file until after we have read a BUFSIZ chunk of the    old one, since we know we have just read the archive header for the old    one.  Since most members are shorter than BUFSIZ, this means we will read    the old header, read the old data, write a new inode for the new file, and    write the new data, and be done. This 'optimization' is what comes from    sitting next to a bare disk and hearing it every time it seeks.  -- Gnu    Gilmore  */
end_comment

begin_function
name|void
name|extract_file
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|FILE
modifier|*
name|ostream
decl_stmt|;
name|char
modifier|*
name|cbuf
init|=
name|xmalloc
argument_list|(
name|BUFSIZE
argument_list|)
decl_stmt|;
name|int
name|nread
decl_stmt|,
name|tocopy
decl_stmt|;
name|int
name|ncopied
init|=
literal|0
decl_stmt|;
name|long
name|size
decl_stmt|;
name|struct
name|stat
name|buf
decl_stmt|;
if|if
condition|(
name|bfd_stat_arch_elt
argument_list|(
name|abfd
argument_list|,
operator|&
name|buf
argument_list|)
operator|!=
literal|0
condition|)
name|fatal
argument_list|(
literal|"internal stat error on %s"
argument_list|,
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
name|size
operator|=
name|buf
operator|.
name|st_size
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
name|printf
argument_list|(
literal|"x - %s\n"
argument_list|,
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
literal|0
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
name|ostream
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|size
operator|==
literal|0
condition|)
block|{
comment|/* Seems like an abstraction violation, eh?  Well it's OK! */
name|output_filename
operator|=
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|ostream
operator|=
name|fopen
argument_list|(
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|FOPEN_WB
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ostream
condition|)
block|{
name|perror
argument_list|(
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
name|xexit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|output_file
operator|=
name|ostream
expr_stmt|;
block|}
else|else
while|while
condition|(
name|ncopied
operator|<
name|size
condition|)
block|{
name|tocopy
operator|=
name|size
operator|-
name|ncopied
expr_stmt|;
if|if
condition|(
name|tocopy
operator|>
name|BUFSIZE
condition|)
name|tocopy
operator|=
name|BUFSIZE
expr_stmt|;
name|nread
operator|=
name|bfd_read
argument_list|(
name|cbuf
argument_list|,
literal|1
argument_list|,
name|tocopy
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|nread
operator|!=
name|tocopy
condition|)
name|fatal
argument_list|(
literal|"%s is not a valid archive"
argument_list|,
name|bfd_get_filename
argument_list|(
name|bfd_my_archive
argument_list|(
name|abfd
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* See comment above; this saves disk arm motion */
if|if
condition|(
operator|!
name|ostream
condition|)
block|{
comment|/* Seems like an abstraction violation, eh?  Well it's OK! */
name|output_filename
operator|=
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|ostream
operator|=
name|fopen
argument_list|(
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|FOPEN_WB
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ostream
condition|)
block|{
name|perror
argument_list|(
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
name|xexit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|output_file
operator|=
name|ostream
expr_stmt|;
block|}
name|fwrite
argument_list|(
name|cbuf
argument_list|,
literal|1
argument_list|,
name|nread
argument_list|,
name|ostream
argument_list|)
expr_stmt|;
name|ncopied
operator|+=
name|tocopy
expr_stmt|;
block|}
name|fclose
argument_list|(
name|ostream
argument_list|)
expr_stmt|;
name|output_file
operator|=
name|NULL
expr_stmt|;
name|output_filename
operator|=
name|NULL
expr_stmt|;
name|chmod
argument_list|(
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|buf
operator|.
name|st_mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|preserve_dates
condition|)
block|{
ifdef|#
directive|ifdef
name|HAVE_GOOD_UTIME_H
name|struct
name|utimbuf
name|tb
decl_stmt|;
name|tb
operator|.
name|actime
operator|=
name|buf
operator|.
name|st_mtime
expr_stmt|;
name|tb
operator|.
name|modtime
operator|=
name|buf
operator|.
name|st_mtime
expr_stmt|;
name|utime
argument_list|(
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|,
operator|&
name|tb
argument_list|)
expr_stmt|;
comment|/* FIXME check result */
else|#
directive|else
comment|/* ! HAVE_GOOD_UTIME_H */
ifndef|#
directive|ifndef
name|HAVE_UTIMES
name|long
name|tb
index|[
literal|2
index|]
decl_stmt|;
name|tb
index|[
literal|0
index|]
operator|=
name|buf
operator|.
name|st_mtime
expr_stmt|;
name|tb
index|[
literal|1
index|]
operator|=
name|buf
operator|.
name|st_mtime
expr_stmt|;
name|utime
argument_list|(
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|tb
argument_list|)
expr_stmt|;
comment|/* FIXME check result */
else|#
directive|else
comment|/* HAVE_UTIMES */
name|struct
name|timeval
name|tv
index|[
literal|2
index|]
decl_stmt|;
name|tv
index|[
literal|0
index|]
operator|.
name|tv_sec
operator|=
name|buf
operator|.
name|st_mtime
expr_stmt|;
name|tv
index|[
literal|0
index|]
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
name|tv
index|[
literal|1
index|]
operator|.
name|tv_sec
operator|=
name|buf
operator|.
name|st_mtime
expr_stmt|;
name|tv
index|[
literal|1
index|]
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
name|utimes
argument_list|(
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|tv
argument_list|)
expr_stmt|;
comment|/* FIXME check result */
endif|#
directive|endif
comment|/* HAVE_UTIMES */
endif|#
directive|endif
comment|/* ! HAVE_GOOD_UTIME_H */
block|}
name|free
argument_list|(
name|cbuf
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* We don't use this anymore.  Too many systems expect ar to rebuild    the symbol table even when q is used.  */
end_comment

begin_comment
comment|/* Just do it quickly; don't worry about dups, armap, or anything like that */
end_comment

begin_ifndef
unit|static void do_quick_append (archive_filename, files_to_append)      const char *archive_filename;      char **files_to_append; {   FILE *ofile, *ifile;   char *buf = xmalloc (BUFSIZE);   long tocopy, thistime;   bfd *temp;   struct stat sbuf;   boolean newfile = false;   bfd_set_error (bfd_error_no_error);    if (stat (archive_filename,&sbuf) != 0)     {
ifndef|#
directive|ifndef
name|__GO32__
end_ifndef

begin_comment
comment|/* KLUDGE ALERT! Temporary fix until I figger why  * stat() is wrong ... think it's buried in GO32's IDT  * - Jax  */
end_comment

begin_endif
unit|if (errno != ENOENT) 	bfd_fatal (archive_filename);
endif|#
directive|endif
end_endif

begin_comment
unit|newfile = true;     }    ofile = fopen (archive_filename, FOPEN_AUB);   if (ofile == NULL)     {       perror (program_name);       xexit (1);     }    temp = bfd_openr (archive_filename, NULL);   if (temp == NULL)     {       bfd_fatal (archive_filename);     }   if (newfile == false)     {       if (bfd_check_format (temp, bfd_archive) != true) 	fatal ("%s is not an archive", archive_filename);     }   else     {       fwrite (ARMAG, 1, SARMAG, ofile);       if (!silent_create) 	fprintf (stderr, "%s: creating %s\n", 		 program_name, archive_filename);     }    if (ar_truncate)     temp->flags |= BFD_TRADITIONAL_FORMAT;
comment|/* assume it's an achive, go straight to the end, sans $200 */
end_comment

begin_comment
unit|fseek (ofile, 0, 2);    for (; files_to_append&& *files_to_append; ++files_to_append)     {       struct ar_hdr *hdr = bfd_special_undocumented_glue (temp, *files_to_append);       if (hdr == NULL) 	{ 	  bfd_fatal (*files_to_append); 	}        BFD_SEND (temp, _bfd_truncate_arname, (temp, *files_to_append, (char *) hdr));        ifile = fopen (*files_to_append, FOPEN_RB);       if (ifile == NULL) 	{ 	  bfd_nonfatal (*files_to_append); 	}        if (stat (*files_to_append,&sbuf) != 0) 	{ 	  bfd_nonfatal (*files_to_append); 	}        tocopy = sbuf.st_size;
comment|/* XXX should do error-checking! */
end_comment

begin_endif
unit|fwrite (hdr, 1, sizeof (struct ar_hdr), ofile);        while (tocopy> 0) 	{ 	  thistime = tocopy; 	  if (thistime> BUFSIZE) 	    thistime = BUFSIZE; 	  fread (buf, 1, thistime, ifile); 	  fwrite (buf, 1, thistime, ofile); 	  tocopy -= thistime; 	}       fclose (ifile);       if ((sbuf.st_size % 2) == 1) 	putc ('\012', ofile);     }   fclose (ofile);   bfd_close (temp);   free (buf); }
endif|#
directive|endif
end_endif

begin_comment
comment|/* 0 */
end_comment

begin_function
specifier|static
name|void
name|write_archive
parameter_list|(
name|iarch
parameter_list|)
name|bfd
modifier|*
name|iarch
decl_stmt|;
block|{
name|bfd
modifier|*
name|obfd
decl_stmt|;
name|char
modifier|*
name|old_name
decl_stmt|,
modifier|*
name|new_name
decl_stmt|;
name|bfd
modifier|*
name|contents_head
init|=
name|iarch
operator|->
name|next
decl_stmt|;
name|old_name
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|bfd_get_filename
argument_list|(
name|iarch
argument_list|)
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|old_name
argument_list|,
name|bfd_get_filename
argument_list|(
name|iarch
argument_list|)
argument_list|)
expr_stmt|;
name|new_name
operator|=
name|make_tempname
argument_list|(
name|old_name
argument_list|)
expr_stmt|;
name|output_filename
operator|=
name|new_name
expr_stmt|;
name|obfd
operator|=
name|bfd_openw
argument_list|(
name|new_name
argument_list|,
name|bfd_get_target
argument_list|(
name|iarch
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|obfd
operator|==
name|NULL
condition|)
name|bfd_fatal
argument_list|(
name|old_name
argument_list|)
expr_stmt|;
name|output_bfd
operator|=
name|obfd
expr_stmt|;
name|bfd_set_format
argument_list|(
name|obfd
argument_list|,
name|bfd_archive
argument_list|)
expr_stmt|;
comment|/* Request writing the archive symbol table unless we've      been explicitly requested not to.  */
name|obfd
operator|->
name|has_armap
operator|=
name|write_armap
operator|>=
literal|0
expr_stmt|;
if|if
condition|(
name|ar_truncate
condition|)
block|{
comment|/* This should really use bfd_set_file_flags, but that rejects          archives.  */
name|obfd
operator|->
name|flags
operator||=
name|BFD_TRADITIONAL_FORMAT
expr_stmt|;
block|}
if|if
condition|(
name|bfd_set_archive_head
argument_list|(
name|obfd
argument_list|,
name|contents_head
argument_list|)
operator|!=
name|true
condition|)
name|bfd_fatal
argument_list|(
name|old_name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_close
argument_list|(
name|obfd
argument_list|)
condition|)
name|bfd_fatal
argument_list|(
name|old_name
argument_list|)
expr_stmt|;
name|output_bfd
operator|=
name|NULL
expr_stmt|;
name|output_filename
operator|=
name|NULL
expr_stmt|;
comment|/* We don't care if this fails; we might be creating the archive.  */
name|bfd_close
argument_list|(
name|iarch
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|old_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|rename
argument_list|(
name|new_name
argument_list|,
name|old_name
argument_list|)
operator|!=
literal|0
condition|)
name|bfd_fatal
argument_list|(
name|old_name
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return a pointer to the pointer to the entry which should be rplacd'd    into when altering.  DEFAULT_POS should be how to interpret pos_default,    and should be a pos value.  */
end_comment

begin_function
specifier|static
name|bfd
modifier|*
modifier|*
name|get_pos_bfd
parameter_list|(
name|contents
parameter_list|,
name|default_pos
parameter_list|,
name|default_posname
parameter_list|)
name|bfd
modifier|*
modifier|*
name|contents
decl_stmt|;
name|enum
name|pos
name|default_pos
decl_stmt|;
specifier|const
name|char
modifier|*
name|default_posname
decl_stmt|;
block|{
name|bfd
modifier|*
modifier|*
name|after_bfd
init|=
name|contents
decl_stmt|;
name|enum
name|pos
name|realpos
decl_stmt|;
specifier|const
name|char
modifier|*
name|realposname
decl_stmt|;
if|if
condition|(
name|postype
operator|==
name|pos_default
condition|)
block|{
name|realpos
operator|=
name|default_pos
expr_stmt|;
name|realposname
operator|=
name|default_posname
expr_stmt|;
block|}
else|else
block|{
name|realpos
operator|=
name|postype
expr_stmt|;
name|realposname
operator|=
name|posname
expr_stmt|;
block|}
if|if
condition|(
name|realpos
operator|==
name|pos_end
condition|)
block|{
while|while
condition|(
operator|*
name|after_bfd
condition|)
name|after_bfd
operator|=
operator|&
operator|(
operator|(
operator|*
name|after_bfd
operator|)
operator|->
name|next
operator|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
init|;
operator|*
name|after_bfd
condition|;
name|after_bfd
operator|=
operator|&
operator|(
operator|*
name|after_bfd
operator|)
operator|->
name|next
control|)
if|if
condition|(
name|strcmp
argument_list|(
operator|(
operator|*
name|after_bfd
operator|)
operator|->
name|filename
argument_list|,
name|realposname
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|realpos
operator|==
name|pos_after
condition|)
name|after_bfd
operator|=
operator|&
operator|(
operator|*
name|after_bfd
operator|)
operator|->
name|next
expr_stmt|;
break|break;
block|}
block|}
return|return
name|after_bfd
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|delete_members
parameter_list|(
name|arch
parameter_list|,
name|files_to_delete
parameter_list|)
name|bfd
modifier|*
name|arch
decl_stmt|;
name|char
modifier|*
modifier|*
name|files_to_delete
decl_stmt|;
block|{
name|bfd
modifier|*
modifier|*
name|current_ptr_ptr
decl_stmt|;
name|boolean
name|found
decl_stmt|;
name|boolean
name|something_changed
init|=
name|false
decl_stmt|;
for|for
control|(
init|;
operator|*
name|files_to_delete
operator|!=
name|NULL
condition|;
operator|++
name|files_to_delete
control|)
block|{
comment|/* In a.out systems, the armap is optional.  It's also called 	 __.SYMDEF.  So if the user asked to delete it, we should remember 	 that fact. This isn't quite right for COFF systems (where 	 __.SYMDEF might be regular member), but it's very unlikely 	 to be a problem.  FIXME */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
operator|*
name|files_to_delete
argument_list|,
literal|"__.SYMDEF"
argument_list|)
condition|)
block|{
name|arch
operator|->
name|has_armap
operator|=
name|false
expr_stmt|;
name|write_armap
operator|=
operator|-
literal|1
expr_stmt|;
continue|continue;
block|}
name|found
operator|=
name|false
expr_stmt|;
name|current_ptr_ptr
operator|=
operator|&
operator|(
name|arch
operator|->
name|next
operator|)
expr_stmt|;
while|while
condition|(
operator|*
name|current_ptr_ptr
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
operator|*
name|files_to_delete
argument_list|,
operator|(
operator|*
name|current_ptr_ptr
operator|)
operator|->
name|filename
argument_list|)
operator|==
literal|0
condition|)
block|{
name|found
operator|=
name|true
expr_stmt|;
name|something_changed
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
name|printf
argument_list|(
literal|"d - %s\n"
argument_list|,
operator|*
name|files_to_delete
argument_list|)
expr_stmt|;
operator|*
name|current_ptr_ptr
operator|=
operator|(
operator|(
operator|*
name|current_ptr_ptr
operator|)
operator|->
name|next
operator|)
expr_stmt|;
goto|goto
name|next_file
goto|;
block|}
else|else
block|{
name|current_ptr_ptr
operator|=
operator|&
operator|(
operator|(
operator|*
name|current_ptr_ptr
operator|)
operator|->
name|next
operator|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|verbose
operator|&&
name|found
operator|==
name|false
condition|)
block|{
name|printf
argument_list|(
literal|"No member named `%s'\n"
argument_list|,
operator|*
name|files_to_delete
argument_list|)
expr_stmt|;
block|}
name|next_file
label|:
empty_stmt|;
block|}
if|if
condition|(
name|something_changed
operator|==
name|true
condition|)
block|{
name|write_archive
argument_list|(
name|arch
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Reposition existing members within an archive */
end_comment

begin_function
specifier|static
name|void
name|move_members
parameter_list|(
name|arch
parameter_list|,
name|files_to_move
parameter_list|)
name|bfd
modifier|*
name|arch
decl_stmt|;
name|char
modifier|*
modifier|*
name|files_to_move
decl_stmt|;
block|{
name|bfd
modifier|*
modifier|*
name|after_bfd
decl_stmt|;
comment|/* New entries go after this one */
name|bfd
modifier|*
modifier|*
name|current_ptr_ptr
decl_stmt|;
comment|/* cdr pointer into contents */
for|for
control|(
init|;
operator|*
name|files_to_move
condition|;
operator|++
name|files_to_move
control|)
block|{
name|current_ptr_ptr
operator|=
operator|&
operator|(
name|arch
operator|->
name|next
operator|)
expr_stmt|;
while|while
condition|(
operator|*
name|current_ptr_ptr
condition|)
block|{
name|bfd
modifier|*
name|current_ptr
init|=
operator|*
name|current_ptr_ptr
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|normalize
argument_list|(
operator|*
name|files_to_move
argument_list|,
name|arch
argument_list|)
argument_list|,
name|current_ptr
operator|->
name|filename
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Move this file to the end of the list - first cut from 		 where it is.  */
name|bfd
modifier|*
name|link
decl_stmt|;
operator|*
name|current_ptr_ptr
operator|=
name|current_ptr
operator|->
name|next
expr_stmt|;
comment|/* Now glue to end */
name|after_bfd
operator|=
name|get_pos_bfd
argument_list|(
operator|&
name|arch
operator|->
name|next
argument_list|,
name|pos_end
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|link
operator|=
operator|*
name|after_bfd
expr_stmt|;
operator|*
name|after_bfd
operator|=
name|current_ptr
expr_stmt|;
name|current_ptr
operator|->
name|next
operator|=
name|link
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
name|printf
argument_list|(
literal|"m - %s\n"
argument_list|,
operator|*
name|files_to_move
argument_list|)
expr_stmt|;
goto|goto
name|next_file
goto|;
block|}
name|current_ptr_ptr
operator|=
operator|&
operator|(
operator|(
operator|*
name|current_ptr_ptr
operator|)
operator|->
name|next
operator|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: no entry %s in archive %s!\n"
argument_list|,
name|program_name
argument_list|,
operator|*
name|files_to_move
argument_list|,
name|arch
operator|->
name|filename
argument_list|)
expr_stmt|;
name|xexit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|next_file
label|:
empty_stmt|;
block|}
name|write_archive
argument_list|(
name|arch
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Ought to default to replacing in place, but this is existing practice!  */
end_comment

begin_function
specifier|static
name|void
name|replace_members
parameter_list|(
name|arch
parameter_list|,
name|files_to_move
parameter_list|,
name|quick
parameter_list|)
name|bfd
modifier|*
name|arch
decl_stmt|;
name|char
modifier|*
modifier|*
name|files_to_move
decl_stmt|;
name|boolean
name|quick
decl_stmt|;
block|{
name|boolean
name|changed
init|=
name|false
decl_stmt|;
name|bfd
modifier|*
modifier|*
name|after_bfd
decl_stmt|;
comment|/* New entries go after this one */
name|bfd
modifier|*
name|current
decl_stmt|;
name|bfd
modifier|*
modifier|*
name|current_ptr
decl_stmt|;
name|bfd
modifier|*
name|temp
decl_stmt|;
while|while
condition|(
name|files_to_move
operator|&&
operator|*
name|files_to_move
condition|)
block|{
if|if
condition|(
operator|!
name|quick
condition|)
block|{
name|current_ptr
operator|=
operator|&
name|arch
operator|->
name|next
expr_stmt|;
while|while
condition|(
operator|*
name|current_ptr
condition|)
block|{
name|current
operator|=
operator|*
name|current_ptr
expr_stmt|;
comment|/* For compatibility with existing ar programs, we 		 permit the same file to be added multiple times.  */
if|if
condition|(
name|strcmp
argument_list|(
name|normalize
argument_list|(
operator|*
name|files_to_move
argument_list|,
name|arch
argument_list|)
argument_list|,
name|normalize
argument_list|(
name|current
operator|->
name|filename
argument_list|,
name|arch
argument_list|)
argument_list|)
operator|==
literal|0
operator|&&
name|current
operator|->
name|arelt_data
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|newer_only
condition|)
block|{
name|struct
name|stat
name|fsbuf
decl_stmt|,
name|asbuf
decl_stmt|;
if|if
condition|(
name|stat
argument_list|(
operator|*
name|files_to_move
argument_list|,
operator|&
name|fsbuf
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|!=
name|ENOENT
condition|)
name|bfd_fatal
argument_list|(
operator|*
name|files_to_move
argument_list|)
expr_stmt|;
goto|goto
name|next_file
goto|;
block|}
if|if
condition|(
name|bfd_stat_arch_elt
argument_list|(
name|current
argument_list|,
operator|&
name|asbuf
argument_list|)
operator|!=
literal|0
condition|)
name|fatal
argument_list|(
literal|"internal stat error on %s"
argument_list|,
name|current
operator|->
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|fsbuf
operator|.
name|st_mtime
operator|<=
name|asbuf
operator|.
name|st_mtime
condition|)
goto|goto
name|next_file
goto|;
block|}
name|after_bfd
operator|=
name|get_pos_bfd
argument_list|(
operator|&
name|arch
operator|->
name|next
argument_list|,
name|pos_after
argument_list|,
name|current
operator|->
name|filename
argument_list|)
expr_stmt|;
name|temp
operator|=
operator|*
name|after_bfd
expr_stmt|;
operator|*
name|after_bfd
operator|=
name|bfd_openr
argument_list|(
operator|*
name|files_to_move
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|after_bfd
operator|==
operator|(
name|bfd
operator|*
operator|)
name|NULL
condition|)
block|{
name|bfd_fatal
argument_list|(
operator|*
name|files_to_move
argument_list|)
expr_stmt|;
block|}
operator|(
operator|*
name|after_bfd
operator|)
operator|->
name|next
operator|=
name|temp
expr_stmt|;
comment|/* snip out this entry from the chain */
operator|*
name|current_ptr
operator|=
operator|(
operator|*
name|current_ptr
operator|)
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
block|{
name|printf
argument_list|(
literal|"r - %s\n"
argument_list|,
operator|*
name|files_to_move
argument_list|)
expr_stmt|;
block|}
name|changed
operator|=
name|true
expr_stmt|;
goto|goto
name|next_file
goto|;
block|}
name|current_ptr
operator|=
operator|&
operator|(
name|current
operator|->
name|next
operator|)
expr_stmt|;
block|}
block|}
comment|/* Add to the end of the archive.  */
name|after_bfd
operator|=
name|get_pos_bfd
argument_list|(
operator|&
name|arch
operator|->
name|next
argument_list|,
name|pos_end
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|temp
operator|=
operator|*
name|after_bfd
expr_stmt|;
operator|*
name|after_bfd
operator|=
name|bfd_openr
argument_list|(
operator|*
name|files_to_move
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|after_bfd
operator|==
operator|(
name|bfd
operator|*
operator|)
name|NULL
condition|)
block|{
name|bfd_fatal
argument_list|(
operator|*
name|files_to_move
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|verbose
condition|)
block|{
name|printf
argument_list|(
literal|"a - %s\n"
argument_list|,
operator|*
name|files_to_move
argument_list|)
expr_stmt|;
block|}
operator|(
operator|*
name|after_bfd
operator|)
operator|->
name|next
operator|=
name|temp
expr_stmt|;
name|changed
operator|=
name|true
expr_stmt|;
name|next_file
label|:
empty_stmt|;
name|files_to_move
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|changed
condition|)
name|write_archive
argument_list|(
name|arch
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ranlib_only
parameter_list|(
name|archname
parameter_list|)
specifier|const
name|char
modifier|*
name|archname
decl_stmt|;
block|{
name|bfd
modifier|*
name|arch
decl_stmt|;
name|write_armap
operator|=
literal|1
expr_stmt|;
name|arch
operator|=
name|open_inarch
argument_list|(
name|archname
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|arch
operator|==
name|NULL
condition|)
name|xexit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|write_archive
argument_list|(
name|arch
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Update the timestamp of the symbol map of an archive.  */
end_comment

begin_function
specifier|static
name|void
name|ranlib_touch
parameter_list|(
name|archname
parameter_list|)
specifier|const
name|char
modifier|*
name|archname
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|__GO32__
comment|/* I don't think updating works on go32.  */
name|ranlib_only
argument_list|(
name|archname
argument_list|)
expr_stmt|;
else|#
directive|else
name|int
name|f
decl_stmt|;
name|bfd
modifier|*
name|arch
decl_stmt|;
name|char
modifier|*
modifier|*
name|matching
decl_stmt|;
name|f
operator|=
name|open
argument_list|(
name|archname
argument_list|,
name|O_RDWR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|<
literal|0
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_system_call
argument_list|)
expr_stmt|;
name|bfd_fatal
argument_list|(
name|archname
argument_list|)
expr_stmt|;
block|}
name|arch
operator|=
name|bfd_fdopenr
argument_list|(
name|archname
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|arch
operator|==
name|NULL
condition|)
name|bfd_fatal
argument_list|(
name|archname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_check_format_matches
argument_list|(
name|arch
argument_list|,
name|bfd_archive
argument_list|,
operator|&
name|matching
argument_list|)
condition|)
block|{
name|bfd_nonfatal
argument_list|(
name|archname
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_get_error
argument_list|()
operator|==
name|bfd_error_file_ambiguously_recognized
condition|)
block|{
name|list_matching_formats
argument_list|(
name|matching
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|matching
argument_list|)
expr_stmt|;
block|}
name|xexit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|bfd_has_map
argument_list|(
name|arch
argument_list|)
condition|)
name|fatal
argument_list|(
literal|"%s: no archive map to update"
argument_list|,
name|archname
argument_list|)
expr_stmt|;
name|bfd_update_armap_timestamp
argument_list|(
name|arch
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_close
argument_list|(
name|arch
argument_list|)
condition|)
name|bfd_fatal
argument_list|(
name|archname
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Things which are interesting to map over all or some of the files: */
end_comment

begin_function
specifier|static
name|void
name|print_descr
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|print_arelt_descr
argument_list|(
name|stdout
argument_list|,
name|abfd
argument_list|,
name|verbose
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

