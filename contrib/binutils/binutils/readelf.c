begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* readelf.c -- display contents of an ELF format file    Copyright 1998, 1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.     Originally developed by Eric Youngdale<eric@andante.jic.com>    Modifications by Nick Clifton<nickc@redhat.com>     This file is part of GNU Binutils.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA    02111-1307, USA.  */
end_comment

begin_escape
end_escape

begin_comment
comment|/* The difference between readelf and objdump:    Both programs are capabale of displaying the contents of ELF format files,   so why does the binutils project have two file dumpers ?    The reason is that objdump sees an ELF file through a BFD filter of the   world; if BFD has a bug where, say, it disagrees about a machine constant   in e_flags, then the odds are good that it will remain internally   consistent.  The linker sees it the BFD way, objdump sees it the BFD way,   GAS sees it the BFD way.  There was need for a tool to go find out what   the file actually says.    This is why the readelf program does not link against the BFD library - it   exists as an independent program to help verify the correct working of BFD.    There is also the case that readelf can provide more information about an   ELF file than is provided by objdump.  In particular it can display DWARF   debugging information which (at the moment) objdump cannot.  */
end_comment

begin_escape
end_escape

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_if
if|#
directive|if
name|__GNUC__
operator|>=
literal|2
end_if

begin_comment
comment|/* Define BFD64 here, even if our default architecture is 32 bit ELF    as this will allow us to read in and parse 64bit and 32bit ELF files.    Only do this if we believe that the compiler can support a 64 bit    data type.  For now we only rely on GCC being able to do this.  */
end_comment

begin_define
define|#
directive|define
name|BFD64
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"elf/common.h"
end_include

begin_include
include|#
directive|include
file|"elf/external.h"
end_include

begin_include
include|#
directive|include
file|"elf/internal.h"
end_include

begin_include
include|#
directive|include
file|"elf/dwarf2.h"
end_include

begin_comment
comment|/* The following headers use the elf/reloc-macros.h file to    automatically generate relocation recognition functions    such as elf_mips_reloc_type()  */
end_comment

begin_define
define|#
directive|define
name|RELOC_MACROS_GEN_FUNC
end_define

begin_include
include|#
directive|include
file|"elf/alpha.h"
end_include

begin_include
include|#
directive|include
file|"elf/arc.h"
end_include

begin_include
include|#
directive|include
file|"elf/arm.h"
end_include

begin_include
include|#
directive|include
file|"elf/avr.h"
end_include

begin_include
include|#
directive|include
file|"elf/cris.h"
end_include

begin_include
include|#
directive|include
file|"elf/d10v.h"
end_include

begin_include
include|#
directive|include
file|"elf/d30v.h"
end_include

begin_include
include|#
directive|include
file|"elf/dlx.h"
end_include

begin_include
include|#
directive|include
file|"elf/fr30.h"
end_include

begin_include
include|#
directive|include
file|"elf/frv.h"
end_include

begin_include
include|#
directive|include
file|"elf/h8.h"
end_include

begin_include
include|#
directive|include
file|"elf/hppa.h"
end_include

begin_include
include|#
directive|include
file|"elf/i386.h"
end_include

begin_include
include|#
directive|include
file|"elf/i370.h"
end_include

begin_include
include|#
directive|include
file|"elf/i860.h"
end_include

begin_include
include|#
directive|include
file|"elf/i960.h"
end_include

begin_include
include|#
directive|include
file|"elf/ia64.h"
end_include

begin_include
include|#
directive|include
file|"elf/ip2k.h"
end_include

begin_include
include|#
directive|include
file|"elf/m32r.h"
end_include

begin_include
include|#
directive|include
file|"elf/m68k.h"
end_include

begin_include
include|#
directive|include
file|"elf/m68hc11.h"
end_include

begin_include
include|#
directive|include
file|"elf/mcore.h"
end_include

begin_include
include|#
directive|include
file|"elf/mips.h"
end_include

begin_include
include|#
directive|include
file|"elf/mmix.h"
end_include

begin_include
include|#
directive|include
file|"elf/mn10200.h"
end_include

begin_include
include|#
directive|include
file|"elf/mn10300.h"
end_include

begin_include
include|#
directive|include
file|"elf/msp430.h"
end_include

begin_include
include|#
directive|include
file|"elf/or32.h"
end_include

begin_include
include|#
directive|include
file|"elf/pj.h"
end_include

begin_include
include|#
directive|include
file|"elf/ppc.h"
end_include

begin_include
include|#
directive|include
file|"elf/ppc64.h"
end_include

begin_include
include|#
directive|include
file|"elf/s390.h"
end_include

begin_include
include|#
directive|include
file|"elf/sh.h"
end_include

begin_include
include|#
directive|include
file|"elf/sparc.h"
end_include

begin_include
include|#
directive|include
file|"elf/v850.h"
end_include

begin_include
include|#
directive|include
file|"elf/vax.h"
end_include

begin_include
include|#
directive|include
file|"elf/x86-64.h"
end_include

begin_include
include|#
directive|include
file|"elf/xstormy16.h"
end_include

begin_include
include|#
directive|include
file|"elf/iq2000.h"
end_include

begin_include
include|#
directive|include
file|"elf/xtensa.h"
end_include

begin_include
include|#
directive|include
file|"aout/ar.h"
end_include

begin_include
include|#
directive|include
file|"bucomm.h"
end_include

begin_include
include|#
directive|include
file|"getopt.h"
end_include

begin_include
include|#
directive|include
file|"libiberty.h"
end_include

begin_decl_stmt
name|char
modifier|*
name|program_name
init|=
literal|"readelf"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|archive_file_offset
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|long
name|archive_file_size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|long
name|dynamic_addr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bfd_size_type
name|dynamic_size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|dynamic_strings
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|string_table
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|long
name|string_table_length
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|long
name|num_dynamic_syms
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Elf_Internal_Sym
modifier|*
name|dynamic_symbols
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Elf_Internal_Syminfo
modifier|*
name|dynamic_syminfo
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|long
name|dynamic_syminfo_offset
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|int
name|dynamic_syminfo_nent
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|program_interpreter
index|[
literal|64
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bfd_vma
name|dynamic_info
index|[
name|DT_ENCODING
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bfd_vma
name|version_info
index|[
literal|16
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Elf_Internal_Ehdr
name|elf_header
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Elf_Internal_Shdr
modifier|*
name|section_headers
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Elf_Internal_Phdr
modifier|*
name|program_headers
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Elf_Internal_Dyn
modifier|*
name|dynamic_segment
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Elf_Internal_Shdr
modifier|*
name|symtab_shndx_hdr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|show_name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|do_dynamic
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|do_syms
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|do_reloc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|do_sections
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|do_segments
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|do_unwind
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|do_using_dynamic
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|do_header
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|do_dump
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|do_version
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|do_wide
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|do_histogram
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|do_debugging
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|do_debug_info
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|do_debug_abbrevs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|do_debug_lines
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|do_debug_pubnames
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|do_debug_aranges
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|do_debug_frames
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|do_debug_frames_interp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|do_debug_macinfo
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|do_debug_str
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|do_debug_loc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|do_arch
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|do_notes
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|is_32bit_elf
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A dynamic array of flags indicating which sections require dumping.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|dump_sects
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|int
name|num_dump_sects
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|HEX_DUMP
value|(1<< 0)
end_define

begin_define
define|#
directive|define
name|DISASS_DUMP
value|(1<< 1)
end_define

begin_define
define|#
directive|define
name|DEBUG_DUMP
value|(1<< 2)
end_define

begin_comment
comment|/* How to rpint a vma value.  */
end_comment

begin_typedef
typedef|typedef
enum|enum
name|print_mode
block|{
name|HEX
block|,
name|DEC
block|,
name|DEC_5
block|,
name|UNSIGNED
block|,
name|PREFIX_HEX
block|,
name|FULL_HEX
block|,
name|LONG_HEX
block|}
name|print_mode
typedef|;
end_typedef

begin_function_decl
specifier|static
name|bfd_vma
function_decl|(
modifier|*
name|byte_get
function_decl|)
parameter_list|(
name|unsigned
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
function_decl|(
modifier|*
name|byte_put
function_decl|)
parameter_list|(
name|unsigned
name|char
modifier|*
parameter_list|,
name|bfd_vma
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_typedef
typedef|typedef
name|int
name|Elf32_Word
typedef|;
end_typedef

begin_define
define|#
directive|define
name|UNKNOWN
value|-1
end_define

begin_define
define|#
directive|define
name|SECTION_NAME
parameter_list|(
name|X
parameter_list|)
value|((X) == NULL ? "<none>" : \ 				 ((X)->sh_name>= string_table_length \ 				  ? "<corrupt>" : string_table + (X)->sh_name))
end_define

begin_comment
comment|/* Given st_shndx I, map to section_headers index.  */
end_comment

begin_define
define|#
directive|define
name|SECTION_HEADER_INDEX
parameter_list|(
name|I
parameter_list|)
define|\
value|((I)< SHN_LORESERVE					\    ? (I)						\    : ((I)<= SHN_HIRESERVE				\       ? 0						\       : (I) - (SHN_HIRESERVE + 1 - SHN_LORESERVE)))
end_define

begin_comment
comment|/* Reverse of the above.  */
end_comment

begin_define
define|#
directive|define
name|SECTION_HEADER_NUM
parameter_list|(
name|N
parameter_list|)
define|\
value|((N)< SHN_LORESERVE					\    ? (N)						\    : (N) + (SHN_HIRESERVE + 1 - SHN_LORESERVE))
end_define

begin_define
define|#
directive|define
name|SECTION_HEADER
parameter_list|(
name|I
parameter_list|)
value|(section_headers + SECTION_HEADER_INDEX (I))
end_define

begin_define
define|#
directive|define
name|DT_VERSIONTAGIDX
parameter_list|(
name|tag
parameter_list|)
value|(DT_VERNEEDNUM - (tag))
end_define

begin_comment
comment|/* Reverse order!  */
end_comment

begin_define
define|#
directive|define
name|BYTE_GET
parameter_list|(
name|field
parameter_list|)
value|byte_get (field, sizeof (field))
end_define

begin_comment
comment|/* If we can support a 64 bit data type then BFD64 should be defined    and sizeof (bfd_vma) == 8.  In this case when translating from an    external 8 byte field to an internal field, we can assume that the    internal field is also 8 bytes wide and so we can extract all the data.    If, however, BFD64 is not defined, then we must assume that the    internal data structure only has 4 byte wide fields that are the    equivalent of the 8 byte wide external counterparts, and so we must    truncate the data.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|BFD64
end_ifdef

begin_define
define|#
directive|define
name|BYTE_GET8
parameter_list|(
name|field
parameter_list|)
value|byte_get (field, -8)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|BYTE_GET8
parameter_list|(
name|field
parameter_list|)
value|byte_get (field, 8)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|NUM_ELEM
parameter_list|(
name|array
parameter_list|)
value|(sizeof (array) / sizeof ((array)[0]))
end_define

begin_define
define|#
directive|define
name|GET_ELF_SYMBOLS
parameter_list|(
name|file
parameter_list|,
name|section
parameter_list|)
define|\
value|(is_32bit_elf ? get_32bit_elf_symbols (file, section)	\    : get_64bit_elf_symbols (file, section))
end_define

begin_function
specifier|static
name|void
name|error
parameter_list|(
specifier|const
name|char
modifier|*
name|message
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|args
decl_stmt|;
name|va_start
argument_list|(
name|args
argument_list|,
name|message
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"%s: Error: "
argument_list|)
argument_list|,
name|program_name
argument_list|)
expr_stmt|;
name|vfprintf
argument_list|(
name|stderr
argument_list|,
name|message
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|warn
parameter_list|(
specifier|const
name|char
modifier|*
name|message
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|args
decl_stmt|;
name|va_start
argument_list|(
name|args
argument_list|,
name|message
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"%s: Warning: "
argument_list|)
argument_list|,
name|program_name
argument_list|)
expr_stmt|;
name|vfprintf
argument_list|(
name|stderr
argument_list|,
name|message
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
name|get_data
parameter_list|(
name|void
modifier|*
name|var
parameter_list|,
name|FILE
modifier|*
name|file
parameter_list|,
name|long
name|offset
parameter_list|,
name|size_t
name|size
parameter_list|,
specifier|const
name|char
modifier|*
name|reason
parameter_list|)
block|{
name|void
modifier|*
name|mvar
decl_stmt|;
if|if
condition|(
name|size
operator|==
literal|0
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|fseek
argument_list|(
name|file
argument_list|,
name|archive_file_offset
operator|+
name|offset
argument_list|,
name|SEEK_SET
argument_list|)
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"Unable to seek to 0x%x for %s\n"
argument_list|)
argument_list|,
name|archive_file_offset
operator|+
name|offset
argument_list|,
name|reason
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|mvar
operator|=
name|var
expr_stmt|;
if|if
condition|(
name|mvar
operator|==
name|NULL
condition|)
block|{
name|mvar
operator|=
name|malloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|mvar
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"Out of memory allocating 0x%x bytes for %s\n"
argument_list|)
argument_list|,
name|size
argument_list|,
name|reason
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
if|if
condition|(
name|fread
argument_list|(
name|mvar
argument_list|,
name|size
argument_list|,
literal|1
argument_list|,
name|file
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"Unable to read in 0x%x bytes of %s\n"
argument_list|)
argument_list|,
name|size
argument_list|,
name|reason
argument_list|)
expr_stmt|;
if|if
condition|(
name|mvar
operator|!=
name|var
condition|)
name|free
argument_list|(
name|mvar
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
name|mvar
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_vma
name|byte_get_little_endian
parameter_list|(
name|unsigned
name|char
modifier|*
name|field
parameter_list|,
name|int
name|size
parameter_list|)
block|{
switch|switch
condition|(
name|size
condition|)
block|{
case|case
literal|1
case|:
return|return
operator|*
name|field
return|;
case|case
literal|2
case|:
return|return
operator|(
call|(
name|unsigned
name|int
call|)
argument_list|(
name|field
index|[
literal|0
index|]
argument_list|)
operator|)
operator||
operator|(
operator|(
call|(
name|unsigned
name|int
call|)
argument_list|(
name|field
index|[
literal|1
index|]
argument_list|)
operator|)
operator|<<
literal|8
operator|)
return|;
ifndef|#
directive|ifndef
name|BFD64
case|case
literal|8
case|:
comment|/* We want to extract data from an 8 byte wide field and 	 place it into a 4 byte wide field.  Since this is a little 	 endian source we can just use the 4 byte extraction code.  */
comment|/* Fall through.  */
endif|#
directive|endif
case|case
literal|4
case|:
return|return
operator|(
call|(
name|unsigned
name|long
call|)
argument_list|(
name|field
index|[
literal|0
index|]
argument_list|)
operator|)
operator||
operator|(
operator|(
call|(
name|unsigned
name|long
call|)
argument_list|(
name|field
index|[
literal|1
index|]
argument_list|)
operator|)
operator|<<
literal|8
operator|)
operator||
operator|(
operator|(
call|(
name|unsigned
name|long
call|)
argument_list|(
name|field
index|[
literal|2
index|]
argument_list|)
operator|)
operator|<<
literal|16
operator|)
operator||
operator|(
operator|(
call|(
name|unsigned
name|long
call|)
argument_list|(
name|field
index|[
literal|3
index|]
argument_list|)
operator|)
operator|<<
literal|24
operator|)
return|;
ifdef|#
directive|ifdef
name|BFD64
case|case
literal|8
case|:
case|case
operator|-
literal|8
case|:
comment|/* This is a special case, generated by the BYTE_GET8 macro. 	 It means that we are loading an 8 byte value from a field 	 in an external structure into an 8 byte value in a field 	 in an internal structure.  */
return|return
operator|(
call|(
name|bfd_vma
call|)
argument_list|(
name|field
index|[
literal|0
index|]
argument_list|)
operator|)
operator||
operator|(
operator|(
call|(
name|bfd_vma
call|)
argument_list|(
name|field
index|[
literal|1
index|]
argument_list|)
operator|)
operator|<<
literal|8
operator|)
operator||
operator|(
operator|(
call|(
name|bfd_vma
call|)
argument_list|(
name|field
index|[
literal|2
index|]
argument_list|)
operator|)
operator|<<
literal|16
operator|)
operator||
operator|(
operator|(
call|(
name|bfd_vma
call|)
argument_list|(
name|field
index|[
literal|3
index|]
argument_list|)
operator|)
operator|<<
literal|24
operator|)
operator||
operator|(
operator|(
call|(
name|bfd_vma
call|)
argument_list|(
name|field
index|[
literal|4
index|]
argument_list|)
operator|)
operator|<<
literal|32
operator|)
operator||
operator|(
operator|(
call|(
name|bfd_vma
call|)
argument_list|(
name|field
index|[
literal|5
index|]
argument_list|)
operator|)
operator|<<
literal|40
operator|)
operator||
operator|(
operator|(
call|(
name|bfd_vma
call|)
argument_list|(
name|field
index|[
literal|6
index|]
argument_list|)
operator|)
operator|<<
literal|48
operator|)
operator||
operator|(
operator|(
call|(
name|bfd_vma
call|)
argument_list|(
name|field
index|[
literal|7
index|]
argument_list|)
operator|)
operator|<<
literal|56
operator|)
return|;
endif|#
directive|endif
default|default:
name|error
argument_list|(
name|_
argument_list|(
literal|"Unhandled data length: %d\n"
argument_list|)
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|bfd_vma
name|byte_get_signed
parameter_list|(
name|unsigned
name|char
modifier|*
name|field
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|bfd_vma
name|x
init|=
name|byte_get
argument_list|(
name|field
argument_list|,
name|size
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|size
condition|)
block|{
case|case
literal|1
case|:
return|return
operator|(
name|x
operator|^
literal|0x80
operator|)
operator|-
literal|0x80
return|;
case|case
literal|2
case|:
return|return
operator|(
name|x
operator|^
literal|0x8000
operator|)
operator|-
literal|0x8000
return|;
case|case
literal|4
case|:
return|return
operator|(
name|x
operator|^
literal|0x80000000
operator|)
operator|-
literal|0x80000000
return|;
case|case
literal|8
case|:
case|case
operator|-
literal|8
case|:
return|return
name|x
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|byte_put_little_endian
parameter_list|(
name|unsigned
name|char
modifier|*
name|field
parameter_list|,
name|bfd_vma
name|value
parameter_list|,
name|int
name|size
parameter_list|)
block|{
switch|switch
condition|(
name|size
condition|)
block|{
case|case
literal|8
case|:
name|field
index|[
literal|7
index|]
operator|=
operator|(
operator|(
operator|(
name|value
operator|>>
literal|24
operator|)
operator|>>
literal|24
operator|)
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
name|field
index|[
literal|6
index|]
operator|=
operator|(
operator|(
name|value
operator|>>
literal|24
operator|)
operator|>>
literal|24
operator|)
operator|&
literal|0xff
expr_stmt|;
name|field
index|[
literal|5
index|]
operator|=
operator|(
operator|(
name|value
operator|>>
literal|24
operator|)
operator|>>
literal|16
operator|)
operator|&
literal|0xff
expr_stmt|;
name|field
index|[
literal|4
index|]
operator|=
operator|(
operator|(
name|value
operator|>>
literal|24
operator|)
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
comment|/* Fall through.  */
case|case
literal|4
case|:
name|field
index|[
literal|3
index|]
operator|=
operator|(
name|value
operator|>>
literal|24
operator|)
operator|&
literal|0xff
expr_stmt|;
name|field
index|[
literal|2
index|]
operator|=
operator|(
name|value
operator|>>
literal|16
operator|)
operator|&
literal|0xff
expr_stmt|;
comment|/* Fall through.  */
case|case
literal|2
case|:
name|field
index|[
literal|1
index|]
operator|=
operator|(
name|value
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
comment|/* Fall through.  */
case|case
literal|1
case|:
name|field
index|[
literal|0
index|]
operator|=
name|value
operator|&
literal|0xff
expr_stmt|;
break|break;
default|default:
name|error
argument_list|(
name|_
argument_list|(
literal|"Unhandled data length: %d\n"
argument_list|)
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Print a VMA value.  */
end_comment

begin_function
specifier|static
name|void
name|print_vma
parameter_list|(
name|bfd_vma
name|vma
parameter_list|,
name|print_mode
name|mode
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|BFD64
if|if
condition|(
name|is_32bit_elf
condition|)
endif|#
directive|endif
block|{
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|FULL_HEX
case|:
name|printf
argument_list|(
literal|"0x"
argument_list|)
expr_stmt|;
comment|/* Drop through.  */
case|case
name|LONG_HEX
case|:
name|printf
argument_list|(
literal|"%8.8lx"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|vma
argument_list|)
expr_stmt|;
break|break;
case|case
name|DEC_5
case|:
if|if
condition|(
name|vma
operator|<=
literal|99999
condition|)
block|{
name|printf
argument_list|(
literal|"%5ld"
argument_list|,
operator|(
name|long
operator|)
name|vma
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Drop through.  */
case|case
name|PREFIX_HEX
case|:
name|printf
argument_list|(
literal|"0x"
argument_list|)
expr_stmt|;
comment|/* Drop through.  */
case|case
name|HEX
case|:
name|printf
argument_list|(
literal|"%lx"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|vma
argument_list|)
expr_stmt|;
break|break;
case|case
name|DEC
case|:
name|printf
argument_list|(
literal|"%ld"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|vma
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNSIGNED
case|:
name|printf
argument_list|(
literal|"%lu"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|vma
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
ifdef|#
directive|ifdef
name|BFD64
else|else
block|{
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|FULL_HEX
case|:
name|printf
argument_list|(
literal|"0x"
argument_list|)
expr_stmt|;
comment|/* Drop through.  */
case|case
name|LONG_HEX
case|:
name|printf_vma
argument_list|(
name|vma
argument_list|)
expr_stmt|;
break|break;
case|case
name|PREFIX_HEX
case|:
name|printf
argument_list|(
literal|"0x"
argument_list|)
expr_stmt|;
comment|/* Drop through.  */
case|case
name|HEX
case|:
if|#
directive|if
name|BFD_HOST_64BIT_LONG
name|printf
argument_list|(
literal|"%lx"
argument_list|,
name|vma
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|_bfd_int64_high
argument_list|(
name|vma
argument_list|)
condition|)
name|printf
argument_list|(
literal|"%lx%8.8lx"
argument_list|,
name|_bfd_int64_high
argument_list|(
name|vma
argument_list|)
argument_list|,
name|_bfd_int64_low
argument_list|(
name|vma
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%lx"
argument_list|,
name|_bfd_int64_low
argument_list|(
name|vma
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|DEC
case|:
if|#
directive|if
name|BFD_HOST_64BIT_LONG
name|printf
argument_list|(
literal|"%ld"
argument_list|,
name|vma
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|_bfd_int64_high
argument_list|(
name|vma
argument_list|)
condition|)
comment|/* ugg */
name|printf
argument_list|(
literal|"++%ld"
argument_list|,
name|_bfd_int64_low
argument_list|(
name|vma
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%ld"
argument_list|,
name|_bfd_int64_low
argument_list|(
name|vma
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|DEC_5
case|:
if|#
directive|if
name|BFD_HOST_64BIT_LONG
if|if
condition|(
name|vma
operator|<=
literal|99999
condition|)
name|printf
argument_list|(
literal|"%5ld"
argument_list|,
name|vma
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%#lx"
argument_list|,
name|vma
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|_bfd_int64_high
argument_list|(
name|vma
argument_list|)
condition|)
comment|/* ugg */
name|printf
argument_list|(
literal|"++%ld"
argument_list|,
name|_bfd_int64_low
argument_list|(
name|vma
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|vma
operator|<=
literal|99999
condition|)
name|printf
argument_list|(
literal|"%5ld"
argument_list|,
name|_bfd_int64_low
argument_list|(
name|vma
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%#lx"
argument_list|,
name|_bfd_int64_low
argument_list|(
name|vma
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|UNSIGNED
case|:
if|#
directive|if
name|BFD_HOST_64BIT_LONG
name|printf
argument_list|(
literal|"%lu"
argument_list|,
name|vma
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|_bfd_int64_high
argument_list|(
name|vma
argument_list|)
condition|)
comment|/* ugg */
name|printf
argument_list|(
literal|"++%lu"
argument_list|,
name|_bfd_int64_low
argument_list|(
name|vma
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%lu"
argument_list|,
name|_bfd_int64_low
argument_list|(
name|vma
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
block|}
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Display a symbol on stdout.  If do_wide is not true then    format the symbol to be at most WIDTH characters,    truncating as necessary.  If WIDTH is negative then    format the string to be exactly - WIDTH characters,    truncating or padding as necessary.  */
end_comment

begin_function
specifier|static
name|void
name|print_symbol
parameter_list|(
name|int
name|width
parameter_list|,
specifier|const
name|char
modifier|*
name|symbol
parameter_list|)
block|{
if|if
condition|(
name|do_wide
condition|)
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|symbol
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|width
operator|<
literal|0
condition|)
name|printf
argument_list|(
literal|"%-*.*s"
argument_list|,
name|width
argument_list|,
name|width
argument_list|,
name|symbol
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%-.*s"
argument_list|,
name|width
argument_list|,
name|symbol
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|bfd_vma
name|byte_get_big_endian
parameter_list|(
name|unsigned
name|char
modifier|*
name|field
parameter_list|,
name|int
name|size
parameter_list|)
block|{
switch|switch
condition|(
name|size
condition|)
block|{
case|case
literal|1
case|:
return|return
operator|*
name|field
return|;
case|case
literal|2
case|:
return|return
operator|(
call|(
name|unsigned
name|int
call|)
argument_list|(
name|field
index|[
literal|1
index|]
argument_list|)
operator|)
operator||
operator|(
operator|(
call|(
name|int
call|)
argument_list|(
name|field
index|[
literal|0
index|]
argument_list|)
operator|)
operator|<<
literal|8
operator|)
return|;
case|case
literal|4
case|:
return|return
operator|(
call|(
name|unsigned
name|long
call|)
argument_list|(
name|field
index|[
literal|3
index|]
argument_list|)
operator|)
operator||
operator|(
operator|(
call|(
name|unsigned
name|long
call|)
argument_list|(
name|field
index|[
literal|2
index|]
argument_list|)
operator|)
operator|<<
literal|8
operator|)
operator||
operator|(
operator|(
call|(
name|unsigned
name|long
call|)
argument_list|(
name|field
index|[
literal|1
index|]
argument_list|)
operator|)
operator|<<
literal|16
operator|)
operator||
operator|(
operator|(
call|(
name|unsigned
name|long
call|)
argument_list|(
name|field
index|[
literal|0
index|]
argument_list|)
operator|)
operator|<<
literal|24
operator|)
return|;
ifndef|#
directive|ifndef
name|BFD64
case|case
literal|8
case|:
comment|/* Although we are extracing data from an 8 byte wide field, we 	 are returning only 4 bytes of data.  */
return|return
operator|(
call|(
name|unsigned
name|long
call|)
argument_list|(
name|field
index|[
literal|7
index|]
argument_list|)
operator|)
operator||
operator|(
operator|(
call|(
name|unsigned
name|long
call|)
argument_list|(
name|field
index|[
literal|6
index|]
argument_list|)
operator|)
operator|<<
literal|8
operator|)
operator||
operator|(
operator|(
call|(
name|unsigned
name|long
call|)
argument_list|(
name|field
index|[
literal|5
index|]
argument_list|)
operator|)
operator|<<
literal|16
operator|)
operator||
operator|(
operator|(
call|(
name|unsigned
name|long
call|)
argument_list|(
name|field
index|[
literal|4
index|]
argument_list|)
operator|)
operator|<<
literal|24
operator|)
return|;
else|#
directive|else
case|case
literal|8
case|:
case|case
operator|-
literal|8
case|:
comment|/* This is a special case, generated by the BYTE_GET8 macro. 	 It means that we are loading an 8 byte value from a field 	 in an external structure into an 8 byte value in a field 	 in an internal structure.  */
return|return
operator|(
call|(
name|bfd_vma
call|)
argument_list|(
name|field
index|[
literal|7
index|]
argument_list|)
operator|)
operator||
operator|(
operator|(
call|(
name|bfd_vma
call|)
argument_list|(
name|field
index|[
literal|6
index|]
argument_list|)
operator|)
operator|<<
literal|8
operator|)
operator||
operator|(
operator|(
call|(
name|bfd_vma
call|)
argument_list|(
name|field
index|[
literal|5
index|]
argument_list|)
operator|)
operator|<<
literal|16
operator|)
operator||
operator|(
operator|(
call|(
name|bfd_vma
call|)
argument_list|(
name|field
index|[
literal|4
index|]
argument_list|)
operator|)
operator|<<
literal|24
operator|)
operator||
operator|(
operator|(
call|(
name|bfd_vma
call|)
argument_list|(
name|field
index|[
literal|3
index|]
argument_list|)
operator|)
operator|<<
literal|32
operator|)
operator||
operator|(
operator|(
call|(
name|bfd_vma
call|)
argument_list|(
name|field
index|[
literal|2
index|]
argument_list|)
operator|)
operator|<<
literal|40
operator|)
operator||
operator|(
operator|(
call|(
name|bfd_vma
call|)
argument_list|(
name|field
index|[
literal|1
index|]
argument_list|)
operator|)
operator|<<
literal|48
operator|)
operator||
operator|(
operator|(
call|(
name|bfd_vma
call|)
argument_list|(
name|field
index|[
literal|0
index|]
argument_list|)
operator|)
operator|<<
literal|56
operator|)
return|;
endif|#
directive|endif
default|default:
name|error
argument_list|(
name|_
argument_list|(
literal|"Unhandled data length: %d\n"
argument_list|)
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|byte_put_big_endian
parameter_list|(
name|unsigned
name|char
modifier|*
name|field
parameter_list|,
name|bfd_vma
name|value
parameter_list|,
name|int
name|size
parameter_list|)
block|{
switch|switch
condition|(
name|size
condition|)
block|{
case|case
literal|8
case|:
name|field
index|[
literal|7
index|]
operator|=
name|value
operator|&
literal|0xff
expr_stmt|;
name|field
index|[
literal|6
index|]
operator|=
operator|(
name|value
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
name|field
index|[
literal|5
index|]
operator|=
operator|(
name|value
operator|>>
literal|16
operator|)
operator|&
literal|0xff
expr_stmt|;
name|field
index|[
literal|4
index|]
operator|=
operator|(
name|value
operator|>>
literal|24
operator|)
operator|&
literal|0xff
expr_stmt|;
name|value
operator|>>=
literal|16
expr_stmt|;
name|value
operator|>>=
literal|16
expr_stmt|;
comment|/* Fall through.  */
case|case
literal|4
case|:
name|field
index|[
literal|3
index|]
operator|=
name|value
operator|&
literal|0xff
expr_stmt|;
name|field
index|[
literal|2
index|]
operator|=
operator|(
name|value
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
name|value
operator|>>=
literal|16
expr_stmt|;
comment|/* Fall through.  */
case|case
literal|2
case|:
name|field
index|[
literal|1
index|]
operator|=
name|value
operator|&
literal|0xff
expr_stmt|;
name|value
operator|>>=
literal|8
expr_stmt|;
comment|/* Fall through.  */
case|case
literal|1
case|:
name|field
index|[
literal|0
index|]
operator|=
name|value
operator|&
literal|0xff
expr_stmt|;
break|break;
default|default:
name|error
argument_list|(
name|_
argument_list|(
literal|"Unhandled data length: %d\n"
argument_list|)
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Guess the relocation size commonly used by the specific machines.  */
end_comment

begin_function
specifier|static
name|int
name|guess_is_rela
parameter_list|(
name|unsigned
name|long
name|e_machine
parameter_list|)
block|{
switch|switch
condition|(
name|e_machine
condition|)
block|{
comment|/* Targets that use REL relocations.  */
case|case
name|EM_ARM
case|:
case|case
name|EM_386
case|:
case|case
name|EM_486
case|:
case|case
name|EM_960
case|:
case|case
name|EM_DLX
case|:
case|case
name|EM_OPENRISC
case|:
case|case
name|EM_OR32
case|:
case|case
name|EM_CYGNUS_M32R
case|:
case|case
name|EM_D10V
case|:
case|case
name|EM_CYGNUS_D10V
case|:
case|case
name|EM_MIPS
case|:
case|case
name|EM_MIPS_RS3_LE
case|:
return|return
name|FALSE
return|;
comment|/* Targets that use RELA relocations.  */
case|case
name|EM_68K
case|:
case|case
name|EM_H8_300
case|:
case|case
name|EM_H8_300H
case|:
case|case
name|EM_H8S
case|:
case|case
name|EM_SPARC32PLUS
case|:
case|case
name|EM_SPARCV9
case|:
case|case
name|EM_SPARC
case|:
case|case
name|EM_PPC
case|:
case|case
name|EM_PPC64
case|:
case|case
name|EM_V850
case|:
case|case
name|EM_CYGNUS_V850
case|:
case|case
name|EM_D30V
case|:
case|case
name|EM_CYGNUS_D30V
case|:
case|case
name|EM_MN10200
case|:
case|case
name|EM_CYGNUS_MN10200
case|:
case|case
name|EM_MN10300
case|:
case|case
name|EM_CYGNUS_MN10300
case|:
case|case
name|EM_FR30
case|:
case|case
name|EM_CYGNUS_FR30
case|:
case|case
name|EM_CYGNUS_FRV
case|:
case|case
name|EM_SH
case|:
case|case
name|EM_ALPHA
case|:
case|case
name|EM_MCORE
case|:
case|case
name|EM_IA_64
case|:
case|case
name|EM_AVR
case|:
case|case
name|EM_AVR_OLD
case|:
case|case
name|EM_CRIS
case|:
case|case
name|EM_860
case|:
case|case
name|EM_X86_64
case|:
case|case
name|EM_S390
case|:
case|case
name|EM_S390_OLD
case|:
case|case
name|EM_MMIX
case|:
case|case
name|EM_MSP430
case|:
case|case
name|EM_MSP430_OLD
case|:
case|case
name|EM_XSTORMY16
case|:
case|case
name|EM_VAX
case|:
case|case
name|EM_IP2K
case|:
case|case
name|EM_IP2K_OLD
case|:
case|case
name|EM_IQ2000
case|:
case|case
name|EM_XTENSA
case|:
case|case
name|EM_XTENSA_OLD
case|:
case|case
name|EM_M32R
case|:
return|return
name|TRUE
return|;
case|case
name|EM_MMA
case|:
case|case
name|EM_PCP
case|:
case|case
name|EM_NCPU
case|:
case|case
name|EM_NDR1
case|:
case|case
name|EM_STARCORE
case|:
case|case
name|EM_ME16
case|:
case|case
name|EM_ST100
case|:
case|case
name|EM_TINYJ
case|:
case|case
name|EM_FX66
case|:
case|case
name|EM_ST9PLUS
case|:
case|case
name|EM_ST7
case|:
case|case
name|EM_68HC16
case|:
case|case
name|EM_68HC11
case|:
case|case
name|EM_68HC08
case|:
case|case
name|EM_68HC05
case|:
case|case
name|EM_SVX
case|:
case|case
name|EM_ST19
case|:
default|default:
name|warn
argument_list|(
name|_
argument_list|(
literal|"Don't know about relocations on this machine architecture\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|slurp_rela_relocs
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
name|unsigned
name|long
name|rel_offset
parameter_list|,
name|unsigned
name|long
name|rel_size
parameter_list|,
name|Elf_Internal_Rela
modifier|*
modifier|*
name|relasp
parameter_list|,
name|unsigned
name|long
modifier|*
name|nrelasp
parameter_list|)
block|{
name|Elf_Internal_Rela
modifier|*
name|relas
decl_stmt|;
name|unsigned
name|long
name|nrelas
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
if|if
condition|(
name|is_32bit_elf
condition|)
block|{
name|Elf32_External_Rela
modifier|*
name|erelas
decl_stmt|;
name|erelas
operator|=
name|get_data
argument_list|(
name|NULL
argument_list|,
name|file
argument_list|,
name|rel_offset
argument_list|,
name|rel_size
argument_list|,
name|_
argument_list|(
literal|"relocs"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|erelas
condition|)
return|return
literal|0
return|;
name|nrelas
operator|=
name|rel_size
operator|/
sizeof|sizeof
argument_list|(
name|Elf32_External_Rela
argument_list|)
expr_stmt|;
name|relas
operator|=
name|malloc
argument_list|(
name|nrelas
operator|*
sizeof|sizeof
argument_list|(
name|Elf_Internal_Rela
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|relas
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"out of memory parsing relocs"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nrelas
condition|;
name|i
operator|++
control|)
block|{
name|relas
index|[
name|i
index|]
operator|.
name|r_offset
operator|=
name|BYTE_GET
argument_list|(
name|erelas
index|[
name|i
index|]
operator|.
name|r_offset
argument_list|)
expr_stmt|;
name|relas
index|[
name|i
index|]
operator|.
name|r_info
operator|=
name|BYTE_GET
argument_list|(
name|erelas
index|[
name|i
index|]
operator|.
name|r_info
argument_list|)
expr_stmt|;
name|relas
index|[
name|i
index|]
operator|.
name|r_addend
operator|=
name|BYTE_GET
argument_list|(
name|erelas
index|[
name|i
index|]
operator|.
name|r_addend
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|erelas
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Elf64_External_Rela
modifier|*
name|erelas
decl_stmt|;
name|erelas
operator|=
name|get_data
argument_list|(
name|NULL
argument_list|,
name|file
argument_list|,
name|rel_offset
argument_list|,
name|rel_size
argument_list|,
name|_
argument_list|(
literal|"relocs"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|erelas
condition|)
return|return
literal|0
return|;
name|nrelas
operator|=
name|rel_size
operator|/
sizeof|sizeof
argument_list|(
name|Elf64_External_Rela
argument_list|)
expr_stmt|;
name|relas
operator|=
name|malloc
argument_list|(
name|nrelas
operator|*
sizeof|sizeof
argument_list|(
name|Elf_Internal_Rela
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|relas
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"out of memory parsing relocs"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nrelas
condition|;
name|i
operator|++
control|)
block|{
name|relas
index|[
name|i
index|]
operator|.
name|r_offset
operator|=
name|BYTE_GET8
argument_list|(
name|erelas
index|[
name|i
index|]
operator|.
name|r_offset
argument_list|)
expr_stmt|;
name|relas
index|[
name|i
index|]
operator|.
name|r_info
operator|=
name|BYTE_GET8
argument_list|(
name|erelas
index|[
name|i
index|]
operator|.
name|r_info
argument_list|)
expr_stmt|;
name|relas
index|[
name|i
index|]
operator|.
name|r_addend
operator|=
name|BYTE_GET8
argument_list|(
name|erelas
index|[
name|i
index|]
operator|.
name|r_addend
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|erelas
argument_list|)
expr_stmt|;
block|}
operator|*
name|relasp
operator|=
name|relas
expr_stmt|;
operator|*
name|nrelasp
operator|=
name|nrelas
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|slurp_rel_relocs
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
name|unsigned
name|long
name|rel_offset
parameter_list|,
name|unsigned
name|long
name|rel_size
parameter_list|,
name|Elf_Internal_Rela
modifier|*
modifier|*
name|relsp
parameter_list|,
name|unsigned
name|long
modifier|*
name|nrelsp
parameter_list|)
block|{
name|Elf_Internal_Rela
modifier|*
name|rels
decl_stmt|;
name|unsigned
name|long
name|nrels
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
if|if
condition|(
name|is_32bit_elf
condition|)
block|{
name|Elf32_External_Rel
modifier|*
name|erels
decl_stmt|;
name|erels
operator|=
name|get_data
argument_list|(
name|NULL
argument_list|,
name|file
argument_list|,
name|rel_offset
argument_list|,
name|rel_size
argument_list|,
name|_
argument_list|(
literal|"relocs"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|erels
condition|)
return|return
literal|0
return|;
name|nrels
operator|=
name|rel_size
operator|/
sizeof|sizeof
argument_list|(
name|Elf32_External_Rel
argument_list|)
expr_stmt|;
name|rels
operator|=
name|malloc
argument_list|(
name|nrels
operator|*
sizeof|sizeof
argument_list|(
name|Elf_Internal_Rela
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rels
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"out of memory parsing relocs"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nrels
condition|;
name|i
operator|++
control|)
block|{
name|rels
index|[
name|i
index|]
operator|.
name|r_offset
operator|=
name|BYTE_GET
argument_list|(
name|erels
index|[
name|i
index|]
operator|.
name|r_offset
argument_list|)
expr_stmt|;
name|rels
index|[
name|i
index|]
operator|.
name|r_info
operator|=
name|BYTE_GET
argument_list|(
name|erels
index|[
name|i
index|]
operator|.
name|r_info
argument_list|)
expr_stmt|;
name|rels
index|[
name|i
index|]
operator|.
name|r_addend
operator|=
literal|0
expr_stmt|;
block|}
name|free
argument_list|(
name|erels
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Elf64_External_Rel
modifier|*
name|erels
decl_stmt|;
name|erels
operator|=
name|get_data
argument_list|(
name|NULL
argument_list|,
name|file
argument_list|,
name|rel_offset
argument_list|,
name|rel_size
argument_list|,
name|_
argument_list|(
literal|"relocs"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|erels
condition|)
return|return
literal|0
return|;
name|nrels
operator|=
name|rel_size
operator|/
sizeof|sizeof
argument_list|(
name|Elf64_External_Rel
argument_list|)
expr_stmt|;
name|rels
operator|=
name|malloc
argument_list|(
name|nrels
operator|*
sizeof|sizeof
argument_list|(
name|Elf_Internal_Rela
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rels
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"out of memory parsing relocs"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nrels
condition|;
name|i
operator|++
control|)
block|{
name|rels
index|[
name|i
index|]
operator|.
name|r_offset
operator|=
name|BYTE_GET8
argument_list|(
name|erels
index|[
name|i
index|]
operator|.
name|r_offset
argument_list|)
expr_stmt|;
name|rels
index|[
name|i
index|]
operator|.
name|r_info
operator|=
name|BYTE_GET8
argument_list|(
name|erels
index|[
name|i
index|]
operator|.
name|r_info
argument_list|)
expr_stmt|;
name|rels
index|[
name|i
index|]
operator|.
name|r_addend
operator|=
literal|0
expr_stmt|;
block|}
name|free
argument_list|(
name|erels
argument_list|)
expr_stmt|;
block|}
operator|*
name|relsp
operator|=
name|rels
expr_stmt|;
operator|*
name|nrelsp
operator|=
name|nrels
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Display the contents of the relocation data found at the specified    offset.  */
end_comment

begin_function
specifier|static
name|int
name|dump_relocations
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
name|unsigned
name|long
name|rel_offset
parameter_list|,
name|unsigned
name|long
name|rel_size
parameter_list|,
name|Elf_Internal_Sym
modifier|*
name|symtab
parameter_list|,
name|unsigned
name|long
name|nsyms
parameter_list|,
name|char
modifier|*
name|strtab
parameter_list|,
name|int
name|is_rela
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|rels
decl_stmt|;
if|if
condition|(
name|is_rela
operator|==
name|UNKNOWN
condition|)
name|is_rela
operator|=
name|guess_is_rela
argument_list|(
name|elf_header
operator|.
name|e_machine
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_rela
condition|)
block|{
if|if
condition|(
operator|!
name|slurp_rela_relocs
argument_list|(
name|file
argument_list|,
name|rel_offset
argument_list|,
name|rel_size
argument_list|,
operator|&
name|rels
argument_list|,
operator|&
name|rel_size
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|slurp_rel_relocs
argument_list|(
name|file
argument_list|,
name|rel_offset
argument_list|,
name|rel_size
argument_list|,
operator|&
name|rels
argument_list|,
operator|&
name|rel_size
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
if|if
condition|(
name|is_32bit_elf
condition|)
block|{
if|if
condition|(
name|is_rela
condition|)
block|{
if|if
condition|(
name|do_wide
condition|)
name|printf
argument_list|(
name|_
argument_list|(
literal|" Offset     Info    Type                Sym. Value  Symbol's Name + Addend\n"
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
name|_
argument_list|(
literal|" Offset     Info    Type            Sym.Value  Sym. Name + Addend\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|do_wide
condition|)
name|printf
argument_list|(
name|_
argument_list|(
literal|" Offset     Info    Type                Sym. Value  Symbol's Name\n"
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
name|_
argument_list|(
literal|" Offset     Info    Type            Sym.Value  Sym. Name\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|is_rela
condition|)
block|{
if|if
condition|(
name|do_wide
condition|)
name|printf
argument_list|(
name|_
argument_list|(
literal|"    Offset             Info             Type               Symbol's Value  Symbol's Name + Addend\n"
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
name|_
argument_list|(
literal|"  Offset          Info           Type           Sym. Value    Sym. Name + Addend\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|do_wide
condition|)
name|printf
argument_list|(
name|_
argument_list|(
literal|"    Offset             Info             Type               Symbol's Value  Symbol's Name\n"
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
name|_
argument_list|(
literal|"  Offset          Info           Type           Sym. Value    Sym. Name\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rel_size
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|rtype
decl_stmt|;
specifier|const
name|char
modifier|*
name|rtype2
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|rtype3
init|=
name|NULL
decl_stmt|;
name|bfd_vma
name|offset
decl_stmt|;
name|bfd_vma
name|info
decl_stmt|;
name|bfd_vma
name|symtab_index
decl_stmt|;
name|bfd_vma
name|type
decl_stmt|;
name|bfd_vma
name|type2
init|=
literal|0
decl_stmt|;
name|bfd_vma
name|type3
init|=
literal|0
decl_stmt|;
name|offset
operator|=
name|rels
index|[
name|i
index|]
operator|.
name|r_offset
expr_stmt|;
name|info
operator|=
name|rels
index|[
name|i
index|]
operator|.
name|r_info
expr_stmt|;
if|if
condition|(
name|is_32bit_elf
condition|)
block|{
name|type
operator|=
name|ELF32_R_TYPE
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|symtab_index
operator|=
name|ELF32_R_SYM
argument_list|(
name|info
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* The #ifdef BFD64 below is to prevent a compile time warning. 	     We know that if we do not have a 64 bit data type that we 	     will never execute this code anyway.  */
ifdef|#
directive|ifdef
name|BFD64
if|if
condition|(
name|elf_header
operator|.
name|e_machine
operator|==
name|EM_MIPS
condition|)
block|{
comment|/* In little-endian objects, r_info isn't really a 64-bit 		 little-endian value: it has a 32-bit little-endian 		 symbol index followed by four individual byte fields. 		 Reorder INFO accordingly.  */
if|if
condition|(
name|elf_header
operator|.
name|e_ident
index|[
name|EI_DATA
index|]
operator|!=
name|ELFDATA2MSB
condition|)
name|info
operator|=
operator|(
operator|(
operator|(
name|info
operator|&
literal|0xffffffff
operator|)
operator|<<
literal|32
operator|)
operator||
operator|(
operator|(
name|info
operator|>>
literal|56
operator|)
operator|&
literal|0xff
operator|)
operator||
operator|(
operator|(
name|info
operator|>>
literal|40
operator|)
operator|&
literal|0xff00
operator|)
operator||
operator|(
operator|(
name|info
operator|>>
literal|24
operator|)
operator|&
literal|0xff0000
operator|)
operator||
operator|(
operator|(
name|info
operator|>>
literal|8
operator|)
operator|&
literal|0xff000000
operator|)
operator|)
expr_stmt|;
name|type
operator|=
name|ELF64_MIPS_R_TYPE
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|type2
operator|=
name|ELF64_MIPS_R_TYPE2
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|type3
operator|=
name|ELF64_MIPS_R_TYPE3
argument_list|(
name|info
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|elf_header
operator|.
name|e_machine
operator|==
name|EM_SPARCV9
condition|)
name|type
operator|=
name|ELF64_R_TYPE_ID
argument_list|(
name|info
argument_list|)
expr_stmt|;
else|else
name|type
operator|=
name|ELF64_R_TYPE
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|symtab_index
operator|=
name|ELF64_R_SYM
argument_list|(
name|info
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|is_32bit_elf
condition|)
block|{
ifdef|#
directive|ifdef
name|_bfd_int64_low
name|printf
argument_list|(
literal|"%8.8lx  %8.8lx "
argument_list|,
name|_bfd_int64_low
argument_list|(
name|offset
argument_list|)
argument_list|,
name|_bfd_int64_low
argument_list|(
name|info
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|printf
argument_list|(
literal|"%8.8lx  %8.8lx "
argument_list|,
name|offset
argument_list|,
name|info
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|_bfd_int64_low
name|printf
argument_list|(
name|do_wide
condition|?
literal|"%8.8lx%8.8lx  %8.8lx%8.8lx "
else|:
literal|"%4.4lx%8.8lx  %4.4lx%8.8lx "
argument_list|,
name|_bfd_int64_high
argument_list|(
name|offset
argument_list|)
argument_list|,
name|_bfd_int64_low
argument_list|(
name|offset
argument_list|)
argument_list|,
name|_bfd_int64_high
argument_list|(
name|info
argument_list|)
argument_list|,
name|_bfd_int64_low
argument_list|(
name|info
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|printf
argument_list|(
name|do_wide
condition|?
literal|"%16.16lx  %16.16lx "
else|:
literal|"%12.12lx  %12.12lx "
argument_list|,
name|offset
argument_list|,
name|info
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
switch|switch
condition|(
name|elf_header
operator|.
name|e_machine
condition|)
block|{
default|default:
name|rtype
operator|=
name|NULL
expr_stmt|;
break|break;
case|case
name|EM_M32R
case|:
case|case
name|EM_CYGNUS_M32R
case|:
name|rtype
operator|=
name|elf_m32r_reloc_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|EM_386
case|:
case|case
name|EM_486
case|:
name|rtype
operator|=
name|elf_i386_reloc_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|EM_68HC11
case|:
case|case
name|EM_68HC12
case|:
name|rtype
operator|=
name|elf_m68hc11_reloc_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|EM_68K
case|:
name|rtype
operator|=
name|elf_m68k_reloc_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|EM_960
case|:
name|rtype
operator|=
name|elf_i960_reloc_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|EM_AVR
case|:
case|case
name|EM_AVR_OLD
case|:
name|rtype
operator|=
name|elf_avr_reloc_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|EM_OLD_SPARCV9
case|:
case|case
name|EM_SPARC32PLUS
case|:
case|case
name|EM_SPARCV9
case|:
case|case
name|EM_SPARC
case|:
name|rtype
operator|=
name|elf_sparc_reloc_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|EM_V850
case|:
case|case
name|EM_CYGNUS_V850
case|:
name|rtype
operator|=
name|v850_reloc_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|EM_D10V
case|:
case|case
name|EM_CYGNUS_D10V
case|:
name|rtype
operator|=
name|elf_d10v_reloc_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|EM_D30V
case|:
case|case
name|EM_CYGNUS_D30V
case|:
name|rtype
operator|=
name|elf_d30v_reloc_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|EM_DLX
case|:
name|rtype
operator|=
name|elf_dlx_reloc_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|EM_SH
case|:
name|rtype
operator|=
name|elf_sh_reloc_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|EM_MN10300
case|:
case|case
name|EM_CYGNUS_MN10300
case|:
name|rtype
operator|=
name|elf_mn10300_reloc_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|EM_MN10200
case|:
case|case
name|EM_CYGNUS_MN10200
case|:
name|rtype
operator|=
name|elf_mn10200_reloc_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|EM_FR30
case|:
case|case
name|EM_CYGNUS_FR30
case|:
name|rtype
operator|=
name|elf_fr30_reloc_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|EM_CYGNUS_FRV
case|:
name|rtype
operator|=
name|elf_frv_reloc_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|EM_MCORE
case|:
name|rtype
operator|=
name|elf_mcore_reloc_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|EM_MMIX
case|:
name|rtype
operator|=
name|elf_mmix_reloc_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|EM_MSP430
case|:
case|case
name|EM_MSP430_OLD
case|:
name|rtype
operator|=
name|elf_msp430_reloc_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|EM_PPC
case|:
name|rtype
operator|=
name|elf_ppc_reloc_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|EM_PPC64
case|:
name|rtype
operator|=
name|elf_ppc64_reloc_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|EM_MIPS
case|:
case|case
name|EM_MIPS_RS3_LE
case|:
name|rtype
operator|=
name|elf_mips_reloc_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|is_32bit_elf
condition|)
block|{
name|rtype2
operator|=
name|elf_mips_reloc_type
argument_list|(
name|type2
argument_list|)
expr_stmt|;
name|rtype3
operator|=
name|elf_mips_reloc_type
argument_list|(
name|type3
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|EM_ALPHA
case|:
name|rtype
operator|=
name|elf_alpha_reloc_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|EM_ARM
case|:
name|rtype
operator|=
name|elf_arm_reloc_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|EM_ARC
case|:
name|rtype
operator|=
name|elf_arc_reloc_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|EM_PARISC
case|:
name|rtype
operator|=
name|elf_hppa_reloc_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|EM_H8_300
case|:
case|case
name|EM_H8_300H
case|:
case|case
name|EM_H8S
case|:
name|rtype
operator|=
name|elf_h8_reloc_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|EM_OPENRISC
case|:
case|case
name|EM_OR32
case|:
name|rtype
operator|=
name|elf_or32_reloc_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|EM_PJ
case|:
case|case
name|EM_PJ_OLD
case|:
name|rtype
operator|=
name|elf_pj_reloc_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|EM_IA_64
case|:
name|rtype
operator|=
name|elf_ia64_reloc_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|EM_CRIS
case|:
name|rtype
operator|=
name|elf_cris_reloc_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|EM_860
case|:
name|rtype
operator|=
name|elf_i860_reloc_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|EM_X86_64
case|:
name|rtype
operator|=
name|elf_x86_64_reloc_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|EM_S370
case|:
name|rtype
operator|=
name|i370_reloc_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|EM_S390_OLD
case|:
case|case
name|EM_S390
case|:
name|rtype
operator|=
name|elf_s390_reloc_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|EM_XSTORMY16
case|:
name|rtype
operator|=
name|elf_xstormy16_reloc_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|EM_VAX
case|:
name|rtype
operator|=
name|elf_vax_reloc_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|EM_IP2K
case|:
case|case
name|EM_IP2K_OLD
case|:
name|rtype
operator|=
name|elf_ip2k_reloc_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|EM_IQ2000
case|:
name|rtype
operator|=
name|elf_iq2000_reloc_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|EM_XTENSA_OLD
case|:
case|case
name|EM_XTENSA
case|:
name|rtype
operator|=
name|elf_xtensa_reloc_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|rtype
operator|==
name|NULL
condition|)
ifdef|#
directive|ifdef
name|_bfd_int64_low
name|printf
argument_list|(
name|_
argument_list|(
literal|"unrecognized: %-7lx"
argument_list|)
argument_list|,
name|_bfd_int64_low
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|printf
argument_list|(
name|_
argument_list|(
literal|"unrecognized: %-7lx"
argument_list|)
argument_list|,
name|type
argument_list|)
expr_stmt|;
endif|#
directive|endif
else|else
name|printf
argument_list|(
name|do_wide
condition|?
literal|"%-22.22s"
else|:
literal|"%-17.17s"
argument_list|,
name|rtype
argument_list|)
expr_stmt|;
if|if
condition|(
name|symtab_index
condition|)
block|{
if|if
condition|(
name|symtab
operator|==
name|NULL
operator|||
name|symtab_index
operator|>=
name|nsyms
condition|)
name|printf
argument_list|(
literal|" bad symbol index: %08lx"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|symtab_index
argument_list|)
expr_stmt|;
else|else
block|{
name|Elf_Internal_Sym
modifier|*
name|psym
decl_stmt|;
name|psym
operator|=
name|symtab
operator|+
name|symtab_index
expr_stmt|;
name|printf
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
name|print_vma
argument_list|(
name|psym
operator|->
name|st_value
argument_list|,
name|LONG_HEX
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|is_32bit_elf
condition|?
literal|"   "
else|:
literal|" "
argument_list|)
expr_stmt|;
if|if
condition|(
name|psym
operator|->
name|st_name
operator|==
literal|0
condition|)
block|{
specifier|const
name|char
modifier|*
name|sec_name
init|=
literal|"<null>"
decl_stmt|;
name|char
name|name_buf
index|[
literal|40
index|]
decl_stmt|;
if|if
condition|(
name|ELF_ST_TYPE
argument_list|(
name|psym
operator|->
name|st_info
argument_list|)
operator|==
name|STT_SECTION
condition|)
block|{
name|bfd_vma
name|sec_index
init|=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|psym
operator|->
name|st_shndx
operator|<
name|SHN_LORESERVE
condition|)
name|sec_index
operator|=
name|psym
operator|->
name|st_shndx
expr_stmt|;
elseif|else
if|if
condition|(
name|psym
operator|->
name|st_shndx
operator|>
name|SHN_LORESERVE
condition|)
name|sec_index
operator|=
name|psym
operator|->
name|st_shndx
operator|-
operator|(
name|SHN_HIRESERVE
operator|+
literal|1
operator|-
name|SHN_LORESERVE
operator|)
expr_stmt|;
if|if
condition|(
name|sec_index
operator|!=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
condition|)
name|sec_name
operator|=
name|SECTION_NAME
argument_list|(
name|section_headers
operator|+
name|sec_index
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|psym
operator|->
name|st_shndx
operator|==
name|SHN_ABS
condition|)
name|sec_name
operator|=
literal|"ABS"
expr_stmt|;
elseif|else
if|if
condition|(
name|psym
operator|->
name|st_shndx
operator|==
name|SHN_COMMON
condition|)
name|sec_name
operator|=
literal|"COMMON"
expr_stmt|;
elseif|else
if|if
condition|(
name|elf_header
operator|.
name|e_machine
operator|==
name|EM_IA_64
operator|&&
name|elf_header
operator|.
name|e_ident
index|[
name|EI_OSABI
index|]
operator|==
name|ELFOSABI_HPUX
operator|&&
name|psym
operator|->
name|st_shndx
operator|==
name|SHN_IA_64_ANSI_COMMON
condition|)
name|sec_name
operator|=
literal|"ANSI_COM"
expr_stmt|;
else|else
block|{
name|sprintf
argument_list|(
name|name_buf
argument_list|,
literal|"<section 0x%x>"
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|psym
operator|->
name|st_shndx
argument_list|)
expr_stmt|;
name|sec_name
operator|=
name|name_buf
expr_stmt|;
block|}
block|}
name|print_symbol
argument_list|(
literal|22
argument_list|,
name|sec_name
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strtab
operator|==
name|NULL
condition|)
name|printf
argument_list|(
name|_
argument_list|(
literal|"<string table index %3ld>"
argument_list|)
argument_list|,
name|psym
operator|->
name|st_name
argument_list|)
expr_stmt|;
else|else
name|print_symbol
argument_list|(
literal|22
argument_list|,
name|strtab
operator|+
name|psym
operator|->
name|st_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_rela
condition|)
name|printf
argument_list|(
literal|" + %lx"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|rels
index|[
name|i
index|]
operator|.
name|r_addend
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|is_rela
condition|)
block|{
name|printf
argument_list|(
literal|"%*c"
argument_list|,
name|is_32bit_elf
condition|?
operator|(
name|do_wide
condition|?
literal|34
else|:
literal|28
operator|)
else|:
operator|(
name|do_wide
condition|?
literal|26
else|:
literal|20
operator|)
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
name|print_vma
argument_list|(
name|rels
index|[
name|i
index|]
operator|.
name|r_addend
argument_list|,
name|LONG_HEX
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|elf_header
operator|.
name|e_machine
operator|==
name|EM_SPARCV9
operator|&&
operator|!
name|strcmp
argument_list|(
name|rtype
argument_list|,
literal|"R_SPARC_OLO10"
argument_list|)
condition|)
name|printf
argument_list|(
literal|" + %lx"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|ELF64_R_TYPE_DATA
argument_list|(
name|info
argument_list|)
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|is_32bit_elf
operator|&&
name|elf_header
operator|.
name|e_machine
operator|==
name|EM_MIPS
condition|)
block|{
name|printf
argument_list|(
literal|"                    Type2: "
argument_list|)
expr_stmt|;
if|if
condition|(
name|rtype2
operator|==
name|NULL
condition|)
ifdef|#
directive|ifdef
name|_bfd_int64_low
name|printf
argument_list|(
name|_
argument_list|(
literal|"unrecognized: %-7lx"
argument_list|)
argument_list|,
name|_bfd_int64_low
argument_list|(
name|type2
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|printf
argument_list|(
name|_
argument_list|(
literal|"unrecognized: %-7lx"
argument_list|)
argument_list|,
name|type2
argument_list|)
expr_stmt|;
endif|#
directive|endif
else|else
name|printf
argument_list|(
literal|"%-17.17s"
argument_list|,
name|rtype2
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n                    Type3: "
argument_list|)
expr_stmt|;
if|if
condition|(
name|rtype3
operator|==
name|NULL
condition|)
ifdef|#
directive|ifdef
name|_bfd_int64_low
name|printf
argument_list|(
name|_
argument_list|(
literal|"unrecognized: %-7lx"
argument_list|)
argument_list|,
name|_bfd_int64_low
argument_list|(
name|type3
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|printf
argument_list|(
name|_
argument_list|(
literal|"unrecognized: %-7lx"
argument_list|)
argument_list|,
name|type3
argument_list|)
expr_stmt|;
endif|#
directive|endif
else|else
name|printf
argument_list|(
literal|"%-17.17s"
argument_list|,
name|rtype3
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|rels
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|get_mips_dynamic_type
parameter_list|(
name|unsigned
name|long
name|type
parameter_list|)
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|DT_MIPS_RLD_VERSION
case|:
return|return
literal|"MIPS_RLD_VERSION"
return|;
case|case
name|DT_MIPS_TIME_STAMP
case|:
return|return
literal|"MIPS_TIME_STAMP"
return|;
case|case
name|DT_MIPS_ICHECKSUM
case|:
return|return
literal|"MIPS_ICHECKSUM"
return|;
case|case
name|DT_MIPS_IVERSION
case|:
return|return
literal|"MIPS_IVERSION"
return|;
case|case
name|DT_MIPS_FLAGS
case|:
return|return
literal|"MIPS_FLAGS"
return|;
case|case
name|DT_MIPS_BASE_ADDRESS
case|:
return|return
literal|"MIPS_BASE_ADDRESS"
return|;
case|case
name|DT_MIPS_MSYM
case|:
return|return
literal|"MIPS_MSYM"
return|;
case|case
name|DT_MIPS_CONFLICT
case|:
return|return
literal|"MIPS_CONFLICT"
return|;
case|case
name|DT_MIPS_LIBLIST
case|:
return|return
literal|"MIPS_LIBLIST"
return|;
case|case
name|DT_MIPS_LOCAL_GOTNO
case|:
return|return
literal|"MIPS_LOCAL_GOTNO"
return|;
case|case
name|DT_MIPS_CONFLICTNO
case|:
return|return
literal|"MIPS_CONFLICTNO"
return|;
case|case
name|DT_MIPS_LIBLISTNO
case|:
return|return
literal|"MIPS_LIBLISTNO"
return|;
case|case
name|DT_MIPS_SYMTABNO
case|:
return|return
literal|"MIPS_SYMTABNO"
return|;
case|case
name|DT_MIPS_UNREFEXTNO
case|:
return|return
literal|"MIPS_UNREFEXTNO"
return|;
case|case
name|DT_MIPS_GOTSYM
case|:
return|return
literal|"MIPS_GOTSYM"
return|;
case|case
name|DT_MIPS_HIPAGENO
case|:
return|return
literal|"MIPS_HIPAGENO"
return|;
case|case
name|DT_MIPS_RLD_MAP
case|:
return|return
literal|"MIPS_RLD_MAP"
return|;
case|case
name|DT_MIPS_DELTA_CLASS
case|:
return|return
literal|"MIPS_DELTA_CLASS"
return|;
case|case
name|DT_MIPS_DELTA_CLASS_NO
case|:
return|return
literal|"MIPS_DELTA_CLASS_NO"
return|;
case|case
name|DT_MIPS_DELTA_INSTANCE
case|:
return|return
literal|"MIPS_DELTA_INSTANCE"
return|;
case|case
name|DT_MIPS_DELTA_INSTANCE_NO
case|:
return|return
literal|"MIPS_DELTA_INSTANCE_NO"
return|;
case|case
name|DT_MIPS_DELTA_RELOC
case|:
return|return
literal|"MIPS_DELTA_RELOC"
return|;
case|case
name|DT_MIPS_DELTA_RELOC_NO
case|:
return|return
literal|"MIPS_DELTA_RELOC_NO"
return|;
case|case
name|DT_MIPS_DELTA_SYM
case|:
return|return
literal|"MIPS_DELTA_SYM"
return|;
case|case
name|DT_MIPS_DELTA_SYM_NO
case|:
return|return
literal|"MIPS_DELTA_SYM_NO"
return|;
case|case
name|DT_MIPS_DELTA_CLASSSYM
case|:
return|return
literal|"MIPS_DELTA_CLASSSYM"
return|;
case|case
name|DT_MIPS_DELTA_CLASSSYM_NO
case|:
return|return
literal|"MIPS_DELTA_CLASSSYM_NO"
return|;
case|case
name|DT_MIPS_CXX_FLAGS
case|:
return|return
literal|"MIPS_CXX_FLAGS"
return|;
case|case
name|DT_MIPS_PIXIE_INIT
case|:
return|return
literal|"MIPS_PIXIE_INIT"
return|;
case|case
name|DT_MIPS_SYMBOL_LIB
case|:
return|return
literal|"MIPS_SYMBOL_LIB"
return|;
case|case
name|DT_MIPS_LOCALPAGE_GOTIDX
case|:
return|return
literal|"MIPS_LOCALPAGE_GOTIDX"
return|;
case|case
name|DT_MIPS_LOCAL_GOTIDX
case|:
return|return
literal|"MIPS_LOCAL_GOTIDX"
return|;
case|case
name|DT_MIPS_HIDDEN_GOTIDX
case|:
return|return
literal|"MIPS_HIDDEN_GOTIDX"
return|;
case|case
name|DT_MIPS_PROTECTED_GOTIDX
case|:
return|return
literal|"MIPS_PROTECTED_GOTIDX"
return|;
case|case
name|DT_MIPS_OPTIONS
case|:
return|return
literal|"MIPS_OPTIONS"
return|;
case|case
name|DT_MIPS_INTERFACE
case|:
return|return
literal|"MIPS_INTERFACE"
return|;
case|case
name|DT_MIPS_DYNSTR_ALIGN
case|:
return|return
literal|"MIPS_DYNSTR_ALIGN"
return|;
case|case
name|DT_MIPS_INTERFACE_SIZE
case|:
return|return
literal|"MIPS_INTERFACE_SIZE"
return|;
case|case
name|DT_MIPS_RLD_TEXT_RESOLVE_ADDR
case|:
return|return
literal|"MIPS_RLD_TEXT_RESOLVE_ADDR"
return|;
case|case
name|DT_MIPS_PERF_SUFFIX
case|:
return|return
literal|"MIPS_PERF_SUFFIX"
return|;
case|case
name|DT_MIPS_COMPACT_SIZE
case|:
return|return
literal|"MIPS_COMPACT_SIZE"
return|;
case|case
name|DT_MIPS_GP_VALUE
case|:
return|return
literal|"MIPS_GP_VALUE"
return|;
case|case
name|DT_MIPS_AUX_DYNAMIC
case|:
return|return
literal|"MIPS_AUX_DYNAMIC"
return|;
default|default:
return|return
name|NULL
return|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|get_sparc64_dynamic_type
parameter_list|(
name|unsigned
name|long
name|type
parameter_list|)
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|DT_SPARC_REGISTER
case|:
return|return
literal|"SPARC_REGISTER"
return|;
default|default:
return|return
name|NULL
return|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|get_ppc64_dynamic_type
parameter_list|(
name|unsigned
name|long
name|type
parameter_list|)
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|DT_PPC64_GLINK
case|:
return|return
literal|"PPC64_GLINK"
return|;
case|case
name|DT_PPC64_OPD
case|:
return|return
literal|"PPC64_OPD"
return|;
case|case
name|DT_PPC64_OPDSZ
case|:
return|return
literal|"PPC64_OPDSZ"
return|;
default|default:
return|return
name|NULL
return|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|get_parisc_dynamic_type
parameter_list|(
name|unsigned
name|long
name|type
parameter_list|)
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|DT_HP_LOAD_MAP
case|:
return|return
literal|"HP_LOAD_MAP"
return|;
case|case
name|DT_HP_DLD_FLAGS
case|:
return|return
literal|"HP_DLD_FLAGS"
return|;
case|case
name|DT_HP_DLD_HOOK
case|:
return|return
literal|"HP_DLD_HOOK"
return|;
case|case
name|DT_HP_UX10_INIT
case|:
return|return
literal|"HP_UX10_INIT"
return|;
case|case
name|DT_HP_UX10_INITSZ
case|:
return|return
literal|"HP_UX10_INITSZ"
return|;
case|case
name|DT_HP_PREINIT
case|:
return|return
literal|"HP_PREINIT"
return|;
case|case
name|DT_HP_PREINITSZ
case|:
return|return
literal|"HP_PREINITSZ"
return|;
case|case
name|DT_HP_NEEDED
case|:
return|return
literal|"HP_NEEDED"
return|;
case|case
name|DT_HP_TIME_STAMP
case|:
return|return
literal|"HP_TIME_STAMP"
return|;
case|case
name|DT_HP_CHECKSUM
case|:
return|return
literal|"HP_CHECKSUM"
return|;
case|case
name|DT_HP_GST_SIZE
case|:
return|return
literal|"HP_GST_SIZE"
return|;
case|case
name|DT_HP_GST_VERSION
case|:
return|return
literal|"HP_GST_VERSION"
return|;
case|case
name|DT_HP_GST_HASHVAL
case|:
return|return
literal|"HP_GST_HASHVAL"
return|;
default|default:
return|return
name|NULL
return|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|get_ia64_dynamic_type
parameter_list|(
name|unsigned
name|long
name|type
parameter_list|)
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|DT_IA_64_PLT_RESERVE
case|:
return|return
literal|"IA_64_PLT_RESERVE"
return|;
default|default:
return|return
name|NULL
return|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|get_dynamic_type
parameter_list|(
name|unsigned
name|long
name|type
parameter_list|)
block|{
specifier|static
name|char
name|buff
index|[
literal|32
index|]
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|DT_NULL
case|:
return|return
literal|"NULL"
return|;
case|case
name|DT_NEEDED
case|:
return|return
literal|"NEEDED"
return|;
case|case
name|DT_PLTRELSZ
case|:
return|return
literal|"PLTRELSZ"
return|;
case|case
name|DT_PLTGOT
case|:
return|return
literal|"PLTGOT"
return|;
case|case
name|DT_HASH
case|:
return|return
literal|"HASH"
return|;
case|case
name|DT_STRTAB
case|:
return|return
literal|"STRTAB"
return|;
case|case
name|DT_SYMTAB
case|:
return|return
literal|"SYMTAB"
return|;
case|case
name|DT_RELA
case|:
return|return
literal|"RELA"
return|;
case|case
name|DT_RELASZ
case|:
return|return
literal|"RELASZ"
return|;
case|case
name|DT_RELAENT
case|:
return|return
literal|"RELAENT"
return|;
case|case
name|DT_STRSZ
case|:
return|return
literal|"STRSZ"
return|;
case|case
name|DT_SYMENT
case|:
return|return
literal|"SYMENT"
return|;
case|case
name|DT_INIT
case|:
return|return
literal|"INIT"
return|;
case|case
name|DT_FINI
case|:
return|return
literal|"FINI"
return|;
case|case
name|DT_SONAME
case|:
return|return
literal|"SONAME"
return|;
case|case
name|DT_RPATH
case|:
return|return
literal|"RPATH"
return|;
case|case
name|DT_SYMBOLIC
case|:
return|return
literal|"SYMBOLIC"
return|;
case|case
name|DT_REL
case|:
return|return
literal|"REL"
return|;
case|case
name|DT_RELSZ
case|:
return|return
literal|"RELSZ"
return|;
case|case
name|DT_RELENT
case|:
return|return
literal|"RELENT"
return|;
case|case
name|DT_PLTREL
case|:
return|return
literal|"PLTREL"
return|;
case|case
name|DT_DEBUG
case|:
return|return
literal|"DEBUG"
return|;
case|case
name|DT_TEXTREL
case|:
return|return
literal|"TEXTREL"
return|;
case|case
name|DT_JMPREL
case|:
return|return
literal|"JMPREL"
return|;
case|case
name|DT_BIND_NOW
case|:
return|return
literal|"BIND_NOW"
return|;
case|case
name|DT_INIT_ARRAY
case|:
return|return
literal|"INIT_ARRAY"
return|;
case|case
name|DT_FINI_ARRAY
case|:
return|return
literal|"FINI_ARRAY"
return|;
case|case
name|DT_INIT_ARRAYSZ
case|:
return|return
literal|"INIT_ARRAYSZ"
return|;
case|case
name|DT_FINI_ARRAYSZ
case|:
return|return
literal|"FINI_ARRAYSZ"
return|;
case|case
name|DT_RUNPATH
case|:
return|return
literal|"RUNPATH"
return|;
case|case
name|DT_FLAGS
case|:
return|return
literal|"FLAGS"
return|;
case|case
name|DT_PREINIT_ARRAY
case|:
return|return
literal|"PREINIT_ARRAY"
return|;
case|case
name|DT_PREINIT_ARRAYSZ
case|:
return|return
literal|"PREINIT_ARRAYSZ"
return|;
case|case
name|DT_CHECKSUM
case|:
return|return
literal|"CHECKSUM"
return|;
case|case
name|DT_PLTPADSZ
case|:
return|return
literal|"PLTPADSZ"
return|;
case|case
name|DT_MOVEENT
case|:
return|return
literal|"MOVEENT"
return|;
case|case
name|DT_MOVESZ
case|:
return|return
literal|"MOVESZ"
return|;
case|case
name|DT_FEATURE
case|:
return|return
literal|"FEATURE"
return|;
case|case
name|DT_POSFLAG_1
case|:
return|return
literal|"POSFLAG_1"
return|;
case|case
name|DT_SYMINSZ
case|:
return|return
literal|"SYMINSZ"
return|;
case|case
name|DT_SYMINENT
case|:
return|return
literal|"SYMINENT"
return|;
comment|/* aka VALRNGHI */
case|case
name|DT_ADDRRNGLO
case|:
return|return
literal|"ADDRRNGLO"
return|;
case|case
name|DT_CONFIG
case|:
return|return
literal|"CONFIG"
return|;
case|case
name|DT_DEPAUDIT
case|:
return|return
literal|"DEPAUDIT"
return|;
case|case
name|DT_AUDIT
case|:
return|return
literal|"AUDIT"
return|;
case|case
name|DT_PLTPAD
case|:
return|return
literal|"PLTPAD"
return|;
case|case
name|DT_MOVETAB
case|:
return|return
literal|"MOVETAB"
return|;
case|case
name|DT_SYMINFO
case|:
return|return
literal|"SYMINFO"
return|;
comment|/* aka ADDRRNGHI */
case|case
name|DT_VERSYM
case|:
return|return
literal|"VERSYM"
return|;
case|case
name|DT_RELACOUNT
case|:
return|return
literal|"RELACOUNT"
return|;
case|case
name|DT_RELCOUNT
case|:
return|return
literal|"RELCOUNT"
return|;
case|case
name|DT_FLAGS_1
case|:
return|return
literal|"FLAGS_1"
return|;
case|case
name|DT_VERDEF
case|:
return|return
literal|"VERDEF"
return|;
case|case
name|DT_VERDEFNUM
case|:
return|return
literal|"VERDEFNUM"
return|;
case|case
name|DT_VERNEED
case|:
return|return
literal|"VERNEED"
return|;
case|case
name|DT_VERNEEDNUM
case|:
return|return
literal|"VERNEEDNUM"
return|;
case|case
name|DT_AUXILIARY
case|:
return|return
literal|"AUXILIARY"
return|;
case|case
name|DT_USED
case|:
return|return
literal|"USED"
return|;
case|case
name|DT_FILTER
case|:
return|return
literal|"FILTER"
return|;
case|case
name|DT_GNU_PRELINKED
case|:
return|return
literal|"GNU_PRELINKED"
return|;
case|case
name|DT_GNU_CONFLICT
case|:
return|return
literal|"GNU_CONFLICT"
return|;
case|case
name|DT_GNU_CONFLICTSZ
case|:
return|return
literal|"GNU_CONFLICTSZ"
return|;
case|case
name|DT_GNU_LIBLIST
case|:
return|return
literal|"GNU_LIBLIST"
return|;
case|case
name|DT_GNU_LIBLISTSZ
case|:
return|return
literal|"GNU_LIBLISTSZ"
return|;
default|default:
if|if
condition|(
operator|(
name|type
operator|>=
name|DT_LOPROC
operator|)
operator|&&
operator|(
name|type
operator|<=
name|DT_HIPROC
operator|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|result
decl_stmt|;
switch|switch
condition|(
name|elf_header
operator|.
name|e_machine
condition|)
block|{
case|case
name|EM_MIPS
case|:
case|case
name|EM_MIPS_RS3_LE
case|:
name|result
operator|=
name|get_mips_dynamic_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|EM_SPARCV9
case|:
name|result
operator|=
name|get_sparc64_dynamic_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|EM_PPC64
case|:
name|result
operator|=
name|get_ppc64_dynamic_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|EM_IA_64
case|:
name|result
operator|=
name|get_ia64_dynamic_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
break|break;
default|default:
name|result
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|result
operator|!=
name|NULL
condition|)
return|return
name|result
return|;
name|sprintf
argument_list|(
name|buff
argument_list|,
name|_
argument_list|(
literal|"Processor Specific: %lx"
argument_list|)
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|type
operator|>=
name|DT_LOOS
operator|)
operator|&&
operator|(
name|type
operator|<=
name|DT_HIOS
operator|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|result
decl_stmt|;
switch|switch
condition|(
name|elf_header
operator|.
name|e_machine
condition|)
block|{
case|case
name|EM_PARISC
case|:
name|result
operator|=
name|get_parisc_dynamic_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
break|break;
default|default:
name|result
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|result
operator|!=
name|NULL
condition|)
return|return
name|result
return|;
name|sprintf
argument_list|(
name|buff
argument_list|,
name|_
argument_list|(
literal|"Operating System specific: %lx"
argument_list|)
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
else|else
name|sprintf
argument_list|(
name|buff
argument_list|,
name|_
argument_list|(
literal|"<unknown>: %lx"
argument_list|)
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
name|buff
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|get_file_type
parameter_list|(
name|unsigned
name|e_type
parameter_list|)
block|{
specifier|static
name|char
name|buff
index|[
literal|32
index|]
decl_stmt|;
switch|switch
condition|(
name|e_type
condition|)
block|{
case|case
name|ET_NONE
case|:
return|return
name|_
argument_list|(
literal|"NONE (None)"
argument_list|)
return|;
case|case
name|ET_REL
case|:
return|return
name|_
argument_list|(
literal|"REL (Relocatable file)"
argument_list|)
return|;
case|case
name|ET_EXEC
case|:
return|return
name|_
argument_list|(
literal|"EXEC (Executable file)"
argument_list|)
return|;
case|case
name|ET_DYN
case|:
return|return
name|_
argument_list|(
literal|"DYN (Shared object file)"
argument_list|)
return|;
case|case
name|ET_CORE
case|:
return|return
name|_
argument_list|(
literal|"CORE (Core file)"
argument_list|)
return|;
default|default:
if|if
condition|(
operator|(
name|e_type
operator|>=
name|ET_LOPROC
operator|)
operator|&&
operator|(
name|e_type
operator|<=
name|ET_HIPROC
operator|)
condition|)
name|sprintf
argument_list|(
name|buff
argument_list|,
name|_
argument_list|(
literal|"Processor Specific: (%x)"
argument_list|)
argument_list|,
name|e_type
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|e_type
operator|>=
name|ET_LOOS
operator|)
operator|&&
operator|(
name|e_type
operator|<=
name|ET_HIOS
operator|)
condition|)
name|sprintf
argument_list|(
name|buff
argument_list|,
name|_
argument_list|(
literal|"OS Specific: (%x)"
argument_list|)
argument_list|,
name|e_type
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|buff
argument_list|,
name|_
argument_list|(
literal|"<unknown>: %x"
argument_list|)
argument_list|,
name|e_type
argument_list|)
expr_stmt|;
return|return
name|buff
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|get_machine_name
parameter_list|(
name|unsigned
name|e_machine
parameter_list|)
block|{
specifier|static
name|char
name|buff
index|[
literal|64
index|]
decl_stmt|;
comment|/* XXX */
switch|switch
condition|(
name|e_machine
condition|)
block|{
case|case
name|EM_NONE
case|:
return|return
name|_
argument_list|(
literal|"None"
argument_list|)
return|;
case|case
name|EM_M32
case|:
return|return
literal|"WE32100"
return|;
case|case
name|EM_SPARC
case|:
return|return
literal|"Sparc"
return|;
case|case
name|EM_386
case|:
return|return
literal|"Intel 80386"
return|;
case|case
name|EM_68K
case|:
return|return
literal|"MC68000"
return|;
case|case
name|EM_88K
case|:
return|return
literal|"MC88000"
return|;
case|case
name|EM_486
case|:
return|return
literal|"Intel 80486"
return|;
case|case
name|EM_860
case|:
return|return
literal|"Intel 80860"
return|;
case|case
name|EM_MIPS
case|:
return|return
literal|"MIPS R3000"
return|;
case|case
name|EM_S370
case|:
return|return
literal|"IBM System/370"
return|;
case|case
name|EM_MIPS_RS3_LE
case|:
return|return
literal|"MIPS R4000 big-endian"
return|;
case|case
name|EM_OLD_SPARCV9
case|:
return|return
literal|"Sparc v9 (old)"
return|;
case|case
name|EM_PARISC
case|:
return|return
literal|"HPPA"
return|;
case|case
name|EM_PPC_OLD
case|:
return|return
literal|"Power PC (old)"
return|;
case|case
name|EM_SPARC32PLUS
case|:
return|return
literal|"Sparc v8+"
return|;
case|case
name|EM_960
case|:
return|return
literal|"Intel 90860"
return|;
case|case
name|EM_PPC
case|:
return|return
literal|"PowerPC"
return|;
case|case
name|EM_PPC64
case|:
return|return
literal|"PowerPC64"
return|;
case|case
name|EM_V800
case|:
return|return
literal|"NEC V800"
return|;
case|case
name|EM_FR20
case|:
return|return
literal|"Fujitsu FR20"
return|;
case|case
name|EM_RH32
case|:
return|return
literal|"TRW RH32"
return|;
case|case
name|EM_MCORE
case|:
return|return
literal|"MCORE"
return|;
case|case
name|EM_ARM
case|:
return|return
literal|"ARM"
return|;
case|case
name|EM_OLD_ALPHA
case|:
return|return
literal|"Digital Alpha (old)"
return|;
case|case
name|EM_SH
case|:
return|return
literal|"Renesas / SuperH SH"
return|;
case|case
name|EM_SPARCV9
case|:
return|return
literal|"Sparc v9"
return|;
case|case
name|EM_TRICORE
case|:
return|return
literal|"Siemens Tricore"
return|;
case|case
name|EM_ARC
case|:
return|return
literal|"ARC"
return|;
case|case
name|EM_H8_300
case|:
return|return
literal|"Renesas H8/300"
return|;
case|case
name|EM_H8_300H
case|:
return|return
literal|"Renesas H8/300H"
return|;
case|case
name|EM_H8S
case|:
return|return
literal|"Renesas H8S"
return|;
case|case
name|EM_H8_500
case|:
return|return
literal|"Renesas H8/500"
return|;
case|case
name|EM_IA_64
case|:
return|return
literal|"Intel IA-64"
return|;
case|case
name|EM_MIPS_X
case|:
return|return
literal|"Stanford MIPS-X"
return|;
case|case
name|EM_COLDFIRE
case|:
return|return
literal|"Motorola Coldfire"
return|;
case|case
name|EM_68HC12
case|:
return|return
literal|"Motorola M68HC12"
return|;
case|case
name|EM_ALPHA
case|:
return|return
literal|"Alpha"
return|;
case|case
name|EM_CYGNUS_D10V
case|:
case|case
name|EM_D10V
case|:
return|return
literal|"d10v"
return|;
case|case
name|EM_CYGNUS_D30V
case|:
case|case
name|EM_D30V
case|:
return|return
literal|"d30v"
return|;
case|case
name|EM_CYGNUS_M32R
case|:
case|case
name|EM_M32R
case|:
return|return
literal|"Renesas M32R (formerly Mitsubishi M32r)"
return|;
case|case
name|EM_CYGNUS_V850
case|:
case|case
name|EM_V850
case|:
return|return
literal|"NEC v850"
return|;
case|case
name|EM_CYGNUS_MN10300
case|:
case|case
name|EM_MN10300
case|:
return|return
literal|"mn10300"
return|;
case|case
name|EM_CYGNUS_MN10200
case|:
case|case
name|EM_MN10200
case|:
return|return
literal|"mn10200"
return|;
case|case
name|EM_CYGNUS_FR30
case|:
case|case
name|EM_FR30
case|:
return|return
literal|"Fujitsu FR30"
return|;
case|case
name|EM_CYGNUS_FRV
case|:
return|return
literal|"Fujitsu FR-V"
return|;
case|case
name|EM_PJ_OLD
case|:
case|case
name|EM_PJ
case|:
return|return
literal|"picoJava"
return|;
case|case
name|EM_MMA
case|:
return|return
literal|"Fujitsu Multimedia Accelerator"
return|;
case|case
name|EM_PCP
case|:
return|return
literal|"Siemens PCP"
return|;
case|case
name|EM_NCPU
case|:
return|return
literal|"Sony nCPU embedded RISC processor"
return|;
case|case
name|EM_NDR1
case|:
return|return
literal|"Denso NDR1 microprocesspr"
return|;
case|case
name|EM_STARCORE
case|:
return|return
literal|"Motorola Star*Core processor"
return|;
case|case
name|EM_ME16
case|:
return|return
literal|"Toyota ME16 processor"
return|;
case|case
name|EM_ST100
case|:
return|return
literal|"STMicroelectronics ST100 processor"
return|;
case|case
name|EM_TINYJ
case|:
return|return
literal|"Advanced Logic Corp. TinyJ embedded processor"
return|;
case|case
name|EM_FX66
case|:
return|return
literal|"Siemens FX66 microcontroller"
return|;
case|case
name|EM_ST9PLUS
case|:
return|return
literal|"STMicroelectronics ST9+ 8/16 bit microcontroller"
return|;
case|case
name|EM_ST7
case|:
return|return
literal|"STMicroelectronics ST7 8-bit microcontroller"
return|;
case|case
name|EM_68HC16
case|:
return|return
literal|"Motorola MC68HC16 Microcontroller"
return|;
case|case
name|EM_68HC11
case|:
return|return
literal|"Motorola MC68HC11 Microcontroller"
return|;
case|case
name|EM_68HC08
case|:
return|return
literal|"Motorola MC68HC08 Microcontroller"
return|;
case|case
name|EM_68HC05
case|:
return|return
literal|"Motorola MC68HC05 Microcontroller"
return|;
case|case
name|EM_SVX
case|:
return|return
literal|"Silicon Graphics SVx"
return|;
case|case
name|EM_ST19
case|:
return|return
literal|"STMicroelectronics ST19 8-bit microcontroller"
return|;
case|case
name|EM_VAX
case|:
return|return
literal|"Digital VAX"
return|;
case|case
name|EM_AVR_OLD
case|:
case|case
name|EM_AVR
case|:
return|return
literal|"Atmel AVR 8-bit microcontroller"
return|;
case|case
name|EM_CRIS
case|:
return|return
literal|"Axis Communications 32-bit embedded processor"
return|;
case|case
name|EM_JAVELIN
case|:
return|return
literal|"Infineon Technologies 32-bit embedded cpu"
return|;
case|case
name|EM_FIREPATH
case|:
return|return
literal|"Element 14 64-bit DSP processor"
return|;
case|case
name|EM_ZSP
case|:
return|return
literal|"LSI Logic's 16-bit DSP processor"
return|;
case|case
name|EM_MMIX
case|:
return|return
literal|"Donald Knuth's educational 64-bit processor"
return|;
case|case
name|EM_HUANY
case|:
return|return
literal|"Harvard Universitys's machine-independent object format"
return|;
case|case
name|EM_PRISM
case|:
return|return
literal|"Vitesse Prism"
return|;
case|case
name|EM_X86_64
case|:
return|return
literal|"Advanced Micro Devices X86-64"
return|;
case|case
name|EM_S390_OLD
case|:
case|case
name|EM_S390
case|:
return|return
literal|"IBM S/390"
return|;
case|case
name|EM_XSTORMY16
case|:
return|return
literal|"Sanyo Xstormy16 CPU core"
return|;
case|case
name|EM_OPENRISC
case|:
case|case
name|EM_OR32
case|:
return|return
literal|"OpenRISC"
return|;
case|case
name|EM_DLX
case|:
return|return
literal|"OpenDLX"
return|;
case|case
name|EM_IP2K_OLD
case|:
case|case
name|EM_IP2K
case|:
return|return
literal|"Ubicom IP2xxx 8-bit microcontrollers"
return|;
case|case
name|EM_IQ2000
case|:
return|return
literal|"Vitesse IQ2000"
return|;
case|case
name|EM_XTENSA_OLD
case|:
case|case
name|EM_XTENSA
case|:
return|return
literal|"Tensilica Xtensa Processor"
return|;
default|default:
name|sprintf
argument_list|(
name|buff
argument_list|,
name|_
argument_list|(
literal|"<unknown>: %x"
argument_list|)
argument_list|,
name|e_machine
argument_list|)
expr_stmt|;
return|return
name|buff
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|decode_ARM_machine_flags
parameter_list|(
name|unsigned
name|e_flags
parameter_list|,
name|char
name|buf
index|[]
parameter_list|)
block|{
name|unsigned
name|eabi
decl_stmt|;
name|int
name|unknown
init|=
literal|0
decl_stmt|;
name|eabi
operator|=
name|EF_ARM_EABI_VERSION
argument_list|(
name|e_flags
argument_list|)
expr_stmt|;
name|e_flags
operator|&=
operator|~
name|EF_ARM_EABIMASK
expr_stmt|;
comment|/* Handle "generic" ARM flags.  */
if|if
condition|(
name|e_flags
operator|&
name|EF_ARM_RELEXEC
condition|)
block|{
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", relocatable executable"
argument_list|)
expr_stmt|;
name|e_flags
operator|&=
operator|~
name|EF_ARM_RELEXEC
expr_stmt|;
block|}
if|if
condition|(
name|e_flags
operator|&
name|EF_ARM_HASENTRY
condition|)
block|{
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", has entry point"
argument_list|)
expr_stmt|;
name|e_flags
operator|&=
operator|~
name|EF_ARM_HASENTRY
expr_stmt|;
block|}
comment|/* Now handle EABI specific flags.  */
switch|switch
condition|(
name|eabi
condition|)
block|{
default|default:
name|strcat
argument_list|(
name|buf
argument_list|,
literal|",<unrecognized EABI>"
argument_list|)
expr_stmt|;
if|if
condition|(
name|e_flags
condition|)
name|unknown
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|EF_ARM_EABI_VER1
case|:
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", Version1 EABI"
argument_list|)
expr_stmt|;
while|while
condition|(
name|e_flags
condition|)
block|{
name|unsigned
name|flag
decl_stmt|;
comment|/* Process flags one bit at a time.  */
name|flag
operator|=
name|e_flags
operator|&
operator|-
name|e_flags
expr_stmt|;
name|e_flags
operator|&=
operator|~
name|flag
expr_stmt|;
switch|switch
condition|(
name|flag
condition|)
block|{
case|case
name|EF_ARM_SYMSARESORTED
case|:
comment|/* Conflicts with EF_ARM_INTERWORK.  */
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", sorted symbol tables"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|unknown
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
break|break;
case|case
name|EF_ARM_EABI_VER2
case|:
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", Version2 EABI"
argument_list|)
expr_stmt|;
while|while
condition|(
name|e_flags
condition|)
block|{
name|unsigned
name|flag
decl_stmt|;
comment|/* Process flags one bit at a time.  */
name|flag
operator|=
name|e_flags
operator|&
operator|-
name|e_flags
expr_stmt|;
name|e_flags
operator|&=
operator|~
name|flag
expr_stmt|;
switch|switch
condition|(
name|flag
condition|)
block|{
case|case
name|EF_ARM_SYMSARESORTED
case|:
comment|/* Conflicts with EF_ARM_INTERWORK.  */
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", sorted symbol tables"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EF_ARM_DYNSYMSUSESEGIDX
case|:
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", dynamic symbols use segment index"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EF_ARM_MAPSYMSFIRST
case|:
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", mapping symbols precede others"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|unknown
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
break|break;
case|case
name|EF_ARM_EABI_UNKNOWN
case|:
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", GNU EABI"
argument_list|)
expr_stmt|;
while|while
condition|(
name|e_flags
condition|)
block|{
name|unsigned
name|flag
decl_stmt|;
comment|/* Process flags one bit at a time.  */
name|flag
operator|=
name|e_flags
operator|&
operator|-
name|e_flags
expr_stmt|;
name|e_flags
operator|&=
operator|~
name|flag
expr_stmt|;
switch|switch
condition|(
name|flag
condition|)
block|{
case|case
name|EF_ARM_INTERWORK
case|:
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", interworking enabled"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EF_ARM_APCS_26
case|:
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", uses APCS/26"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EF_ARM_APCS_FLOAT
case|:
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", uses APCS/float"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EF_ARM_PIC
case|:
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", position independent"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EF_ARM_ALIGN8
case|:
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", 8 bit structure alignment"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EF_ARM_NEW_ABI
case|:
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", uses new ABI"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EF_ARM_OLD_ABI
case|:
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", uses old ABI"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EF_ARM_SOFT_FLOAT
case|:
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", software FP"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EF_ARM_MAVERICK_FLOAT
case|:
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", Maverick FP"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|unknown
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|unknown
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|",<unknown>"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|get_machine_flags
parameter_list|(
name|unsigned
name|e_flags
parameter_list|,
name|unsigned
name|e_machine
parameter_list|)
block|{
specifier|static
name|char
name|buf
index|[
literal|1024
index|]
decl_stmt|;
name|buf
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|e_flags
condition|)
block|{
switch|switch
condition|(
name|e_machine
condition|)
block|{
default|default:
break|break;
case|case
name|EM_ARM
case|:
name|decode_ARM_machine_flags
argument_list|(
name|e_flags
argument_list|,
name|buf
argument_list|)
expr_stmt|;
break|break;
case|case
name|EM_68K
case|:
if|if
condition|(
name|e_flags
operator|&
name|EF_CPU32
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", cpu32"
argument_list|)
expr_stmt|;
if|if
condition|(
name|e_flags
operator|&
name|EF_M68000
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", m68000"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EM_PPC
case|:
if|if
condition|(
name|e_flags
operator|&
name|EF_PPC_EMB
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", emb"
argument_list|)
expr_stmt|;
if|if
condition|(
name|e_flags
operator|&
name|EF_PPC_RELOCATABLE
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", relocatable"
argument_list|)
expr_stmt|;
if|if
condition|(
name|e_flags
operator|&
name|EF_PPC_RELOCATABLE_LIB
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", relocatable-lib"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EM_V850
case|:
case|case
name|EM_CYGNUS_V850
case|:
switch|switch
condition|(
name|e_flags
operator|&
name|EF_V850_ARCH
condition|)
block|{
case|case
name|E_V850E1_ARCH
case|:
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", v850e1"
argument_list|)
expr_stmt|;
break|break;
case|case
name|E_V850E_ARCH
case|:
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", v850e"
argument_list|)
expr_stmt|;
break|break;
case|case
name|E_V850_ARCH
case|:
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", v850"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", unknown v850 architecture variant"
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|EM_M32R
case|:
case|case
name|EM_CYGNUS_M32R
case|:
if|if
condition|(
operator|(
name|e_flags
operator|&
name|EF_M32R_ARCH
operator|)
operator|==
name|E_M32R_ARCH
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", m32r"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EM_MIPS
case|:
case|case
name|EM_MIPS_RS3_LE
case|:
if|if
condition|(
name|e_flags
operator|&
name|EF_MIPS_NOREORDER
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", noreorder"
argument_list|)
expr_stmt|;
if|if
condition|(
name|e_flags
operator|&
name|EF_MIPS_PIC
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", pic"
argument_list|)
expr_stmt|;
if|if
condition|(
name|e_flags
operator|&
name|EF_MIPS_CPIC
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", cpic"
argument_list|)
expr_stmt|;
if|if
condition|(
name|e_flags
operator|&
name|EF_MIPS_UCODE
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", ugen_reserved"
argument_list|)
expr_stmt|;
if|if
condition|(
name|e_flags
operator|&
name|EF_MIPS_ABI2
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", abi2"
argument_list|)
expr_stmt|;
if|if
condition|(
name|e_flags
operator|&
name|EF_MIPS_OPTIONS_FIRST
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", odk first"
argument_list|)
expr_stmt|;
if|if
condition|(
name|e_flags
operator|&
name|EF_MIPS_32BITMODE
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", 32bitmode"
argument_list|)
expr_stmt|;
switch|switch
condition|(
operator|(
name|e_flags
operator|&
name|EF_MIPS_MACH
operator|)
condition|)
block|{
case|case
name|E_MIPS_MACH_3900
case|:
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", 3900"
argument_list|)
expr_stmt|;
break|break;
case|case
name|E_MIPS_MACH_4010
case|:
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", 4010"
argument_list|)
expr_stmt|;
break|break;
case|case
name|E_MIPS_MACH_4100
case|:
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", 4100"
argument_list|)
expr_stmt|;
break|break;
case|case
name|E_MIPS_MACH_4111
case|:
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", 4111"
argument_list|)
expr_stmt|;
break|break;
case|case
name|E_MIPS_MACH_4120
case|:
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", 4120"
argument_list|)
expr_stmt|;
break|break;
case|case
name|E_MIPS_MACH_4650
case|:
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", 4650"
argument_list|)
expr_stmt|;
break|break;
case|case
name|E_MIPS_MACH_5400
case|:
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", 5400"
argument_list|)
expr_stmt|;
break|break;
case|case
name|E_MIPS_MACH_5500
case|:
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", 5500"
argument_list|)
expr_stmt|;
break|break;
case|case
name|E_MIPS_MACH_SB1
case|:
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", sb1"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0
case|:
comment|/* We simply ignore the field in this case to avoid confusion: 	       MIPS ELF does not specify EF_MIPS_MACH, it is a GNU 	       extension.  */
break|break;
default|default:
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", unknown CPU"
argument_list|)
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
operator|(
name|e_flags
operator|&
name|EF_MIPS_ABI
operator|)
condition|)
block|{
case|case
name|E_MIPS_ABI_O32
case|:
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", o32"
argument_list|)
expr_stmt|;
break|break;
case|case
name|E_MIPS_ABI_O64
case|:
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", o64"
argument_list|)
expr_stmt|;
break|break;
case|case
name|E_MIPS_ABI_EABI32
case|:
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", eabi32"
argument_list|)
expr_stmt|;
break|break;
case|case
name|E_MIPS_ABI_EABI64
case|:
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", eabi64"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0
case|:
comment|/* We simply ignore the field in this case to avoid confusion: 	       MIPS ELF does not specify EF_MIPS_ABI, it is a GNU extension. 	       This means it is likely to be an o32 file, but not for 	       sure.  */
break|break;
default|default:
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", unknown ABI"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|e_flags
operator|&
name|EF_MIPS_ARCH_ASE_MDMX
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", mdmx"
argument_list|)
expr_stmt|;
if|if
condition|(
name|e_flags
operator|&
name|EF_MIPS_ARCH_ASE_M16
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", mips16"
argument_list|)
expr_stmt|;
switch|switch
condition|(
operator|(
name|e_flags
operator|&
name|EF_MIPS_ARCH
operator|)
condition|)
block|{
case|case
name|E_MIPS_ARCH_1
case|:
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", mips1"
argument_list|)
expr_stmt|;
break|break;
case|case
name|E_MIPS_ARCH_2
case|:
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", mips2"
argument_list|)
expr_stmt|;
break|break;
case|case
name|E_MIPS_ARCH_3
case|:
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", mips3"
argument_list|)
expr_stmt|;
break|break;
case|case
name|E_MIPS_ARCH_4
case|:
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", mips4"
argument_list|)
expr_stmt|;
break|break;
case|case
name|E_MIPS_ARCH_5
case|:
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", mips5"
argument_list|)
expr_stmt|;
break|break;
case|case
name|E_MIPS_ARCH_32
case|:
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", mips32"
argument_list|)
expr_stmt|;
break|break;
case|case
name|E_MIPS_ARCH_32R2
case|:
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", mips32r2"
argument_list|)
expr_stmt|;
break|break;
case|case
name|E_MIPS_ARCH_64
case|:
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", mips64"
argument_list|)
expr_stmt|;
break|break;
case|case
name|E_MIPS_ARCH_64R2
case|:
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", mips64r2"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", unknown ISA"
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|EM_SPARCV9
case|:
if|if
condition|(
name|e_flags
operator|&
name|EF_SPARC_32PLUS
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", v8+"
argument_list|)
expr_stmt|;
if|if
condition|(
name|e_flags
operator|&
name|EF_SPARC_SUN_US1
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", ultrasparcI"
argument_list|)
expr_stmt|;
if|if
condition|(
name|e_flags
operator|&
name|EF_SPARC_SUN_US3
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", ultrasparcIII"
argument_list|)
expr_stmt|;
if|if
condition|(
name|e_flags
operator|&
name|EF_SPARC_HAL_R1
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", halr1"
argument_list|)
expr_stmt|;
if|if
condition|(
name|e_flags
operator|&
name|EF_SPARC_LEDATA
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", ledata"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|e_flags
operator|&
name|EF_SPARCV9_MM
operator|)
operator|==
name|EF_SPARCV9_TSO
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", tso"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|e_flags
operator|&
name|EF_SPARCV9_MM
operator|)
operator|==
name|EF_SPARCV9_PSO
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", pso"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|e_flags
operator|&
name|EF_SPARCV9_MM
operator|)
operator|==
name|EF_SPARCV9_RMO
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", rmo"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EM_PARISC
case|:
switch|switch
condition|(
name|e_flags
operator|&
name|EF_PARISC_ARCH
condition|)
block|{
case|case
name|EFA_PARISC_1_0
case|:
name|strcpy
argument_list|(
name|buf
argument_list|,
literal|", PA-RISC 1.0"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EFA_PARISC_1_1
case|:
name|strcpy
argument_list|(
name|buf
argument_list|,
literal|", PA-RISC 1.1"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EFA_PARISC_2_0
case|:
name|strcpy
argument_list|(
name|buf
argument_list|,
literal|", PA-RISC 2.0"
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
if|if
condition|(
name|e_flags
operator|&
name|EF_PARISC_TRAPNIL
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", trapnil"
argument_list|)
expr_stmt|;
if|if
condition|(
name|e_flags
operator|&
name|EF_PARISC_EXT
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", ext"
argument_list|)
expr_stmt|;
if|if
condition|(
name|e_flags
operator|&
name|EF_PARISC_LSB
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", lsb"
argument_list|)
expr_stmt|;
if|if
condition|(
name|e_flags
operator|&
name|EF_PARISC_WIDE
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", wide"
argument_list|)
expr_stmt|;
if|if
condition|(
name|e_flags
operator|&
name|EF_PARISC_NO_KABP
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", no kabp"
argument_list|)
expr_stmt|;
if|if
condition|(
name|e_flags
operator|&
name|EF_PARISC_LAZYSWAP
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", lazyswap"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EM_PJ
case|:
case|case
name|EM_PJ_OLD
case|:
if|if
condition|(
operator|(
name|e_flags
operator|&
name|EF_PICOJAVA_NEWCALLS
operator|)
operator|==
name|EF_PICOJAVA_NEWCALLS
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", new calling convention"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|e_flags
operator|&
name|EF_PICOJAVA_GNUCALLS
operator|)
operator|==
name|EF_PICOJAVA_GNUCALLS
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", gnu calling convention"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EM_IA_64
case|:
if|if
condition|(
operator|(
name|e_flags
operator|&
name|EF_IA_64_ABI64
operator|)
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", 64-bit"
argument_list|)
expr_stmt|;
else|else
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", 32-bit"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|e_flags
operator|&
name|EF_IA_64_REDUCEDFP
operator|)
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", reduced fp model"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|e_flags
operator|&
name|EF_IA_64_NOFUNCDESC_CONS_GP
operator|)
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", no function descriptors, constant gp"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|e_flags
operator|&
name|EF_IA_64_CONS_GP
operator|)
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", constant gp"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|e_flags
operator|&
name|EF_IA_64_ABSOLUTE
operator|)
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", absolute"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EM_VAX
case|:
if|if
condition|(
operator|(
name|e_flags
operator|&
name|EF_VAX_NONPIC
operator|)
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", non-PIC"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|e_flags
operator|&
name|EF_VAX_DFLOAT
operator|)
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", D-Float"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|e_flags
operator|&
name|EF_VAX_GFLOAT
operator|)
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", G-Float"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
return|return
name|buf
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|get_osabi_name
parameter_list|(
name|unsigned
name|int
name|osabi
parameter_list|)
block|{
specifier|static
name|char
name|buff
index|[
literal|32
index|]
decl_stmt|;
switch|switch
condition|(
name|osabi
condition|)
block|{
case|case
name|ELFOSABI_NONE
case|:
return|return
literal|"UNIX - System V"
return|;
case|case
name|ELFOSABI_HPUX
case|:
return|return
literal|"UNIX - HP-UX"
return|;
case|case
name|ELFOSABI_NETBSD
case|:
return|return
literal|"UNIX - NetBSD"
return|;
case|case
name|ELFOSABI_LINUX
case|:
return|return
literal|"UNIX - Linux"
return|;
case|case
name|ELFOSABI_HURD
case|:
return|return
literal|"GNU/Hurd"
return|;
case|case
name|ELFOSABI_SOLARIS
case|:
return|return
literal|"UNIX - Solaris"
return|;
case|case
name|ELFOSABI_AIX
case|:
return|return
literal|"UNIX - AIX"
return|;
case|case
name|ELFOSABI_IRIX
case|:
return|return
literal|"UNIX - IRIX"
return|;
case|case
name|ELFOSABI_FREEBSD
case|:
return|return
literal|"UNIX - FreeBSD"
return|;
case|case
name|ELFOSABI_TRU64
case|:
return|return
literal|"UNIX - TRU64"
return|;
case|case
name|ELFOSABI_MODESTO
case|:
return|return
literal|"Novell - Modesto"
return|;
case|case
name|ELFOSABI_OPENBSD
case|:
return|return
literal|"UNIX - OpenBSD"
return|;
case|case
name|ELFOSABI_OPENVMS
case|:
return|return
literal|"VMS - OpenVMS"
return|;
case|case
name|ELFOSABI_NSK
case|:
return|return
literal|"HP - Non-Stop Kernel"
return|;
case|case
name|ELFOSABI_AROS
case|:
return|return
literal|"Amiga Research OS"
return|;
case|case
name|ELFOSABI_STANDALONE
case|:
return|return
name|_
argument_list|(
literal|"Standalone App"
argument_list|)
return|;
case|case
name|ELFOSABI_ARM
case|:
return|return
literal|"ARM"
return|;
default|default:
name|sprintf
argument_list|(
name|buff
argument_list|,
name|_
argument_list|(
literal|"<unknown: %x>"
argument_list|)
argument_list|,
name|osabi
argument_list|)
expr_stmt|;
return|return
name|buff
return|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|get_mips_segment_type
parameter_list|(
name|unsigned
name|long
name|type
parameter_list|)
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|PT_MIPS_REGINFO
case|:
return|return
literal|"REGINFO"
return|;
case|case
name|PT_MIPS_RTPROC
case|:
return|return
literal|"RTPROC"
return|;
case|case
name|PT_MIPS_OPTIONS
case|:
return|return
literal|"OPTIONS"
return|;
default|default:
break|break;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|get_parisc_segment_type
parameter_list|(
name|unsigned
name|long
name|type
parameter_list|)
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|PT_HP_TLS
case|:
return|return
literal|"HP_TLS"
return|;
case|case
name|PT_HP_CORE_NONE
case|:
return|return
literal|"HP_CORE_NONE"
return|;
case|case
name|PT_HP_CORE_VERSION
case|:
return|return
literal|"HP_CORE_VERSION"
return|;
case|case
name|PT_HP_CORE_KERNEL
case|:
return|return
literal|"HP_CORE_KERNEL"
return|;
case|case
name|PT_HP_CORE_COMM
case|:
return|return
literal|"HP_CORE_COMM"
return|;
case|case
name|PT_HP_CORE_PROC
case|:
return|return
literal|"HP_CORE_PROC"
return|;
case|case
name|PT_HP_CORE_LOADABLE
case|:
return|return
literal|"HP_CORE_LOADABLE"
return|;
case|case
name|PT_HP_CORE_STACK
case|:
return|return
literal|"HP_CORE_STACK"
return|;
case|case
name|PT_HP_CORE_SHM
case|:
return|return
literal|"HP_CORE_SHM"
return|;
case|case
name|PT_HP_CORE_MMF
case|:
return|return
literal|"HP_CORE_MMF"
return|;
case|case
name|PT_HP_PARALLEL
case|:
return|return
literal|"HP_PARALLEL"
return|;
case|case
name|PT_HP_FASTBIND
case|:
return|return
literal|"HP_FASTBIND"
return|;
case|case
name|PT_PARISC_ARCHEXT
case|:
return|return
literal|"PARISC_ARCHEXT"
return|;
case|case
name|PT_PARISC_UNWIND
case|:
return|return
literal|"PARISC_UNWIND"
return|;
default|default:
break|break;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|get_ia64_segment_type
parameter_list|(
name|unsigned
name|long
name|type
parameter_list|)
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|PT_IA_64_ARCHEXT
case|:
return|return
literal|"IA_64_ARCHEXT"
return|;
case|case
name|PT_IA_64_UNWIND
case|:
return|return
literal|"IA_64_UNWIND"
return|;
case|case
name|PT_HP_TLS
case|:
return|return
literal|"HP_TLS"
return|;
case|case
name|PT_IA_64_HP_OPT_ANOT
case|:
return|return
literal|"HP_OPT_ANNOT"
return|;
case|case
name|PT_IA_64_HP_HSL_ANOT
case|:
return|return
literal|"HP_HSL_ANNOT"
return|;
case|case
name|PT_IA_64_HP_STACK
case|:
return|return
literal|"HP_STACK"
return|;
default|default:
break|break;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|get_segment_type
parameter_list|(
name|unsigned
name|long
name|p_type
parameter_list|)
block|{
specifier|static
name|char
name|buff
index|[
literal|32
index|]
decl_stmt|;
switch|switch
condition|(
name|p_type
condition|)
block|{
case|case
name|PT_NULL
case|:
return|return
literal|"NULL"
return|;
case|case
name|PT_LOAD
case|:
return|return
literal|"LOAD"
return|;
case|case
name|PT_DYNAMIC
case|:
return|return
literal|"DYNAMIC"
return|;
case|case
name|PT_INTERP
case|:
return|return
literal|"INTERP"
return|;
case|case
name|PT_NOTE
case|:
return|return
literal|"NOTE"
return|;
case|case
name|PT_SHLIB
case|:
return|return
literal|"SHLIB"
return|;
case|case
name|PT_PHDR
case|:
return|return
literal|"PHDR"
return|;
case|case
name|PT_TLS
case|:
return|return
literal|"TLS"
return|;
case|case
name|PT_GNU_EH_FRAME
case|:
return|return
literal|"GNU_EH_FRAME"
return|;
case|case
name|PT_GNU_STACK
case|:
return|return
literal|"STACK"
return|;
default|default:
if|if
condition|(
operator|(
name|p_type
operator|>=
name|PT_LOPROC
operator|)
operator|&&
operator|(
name|p_type
operator|<=
name|PT_HIPROC
operator|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|result
decl_stmt|;
switch|switch
condition|(
name|elf_header
operator|.
name|e_machine
condition|)
block|{
case|case
name|EM_MIPS
case|:
case|case
name|EM_MIPS_RS3_LE
case|:
name|result
operator|=
name|get_mips_segment_type
argument_list|(
name|p_type
argument_list|)
expr_stmt|;
break|break;
case|case
name|EM_PARISC
case|:
name|result
operator|=
name|get_parisc_segment_type
argument_list|(
name|p_type
argument_list|)
expr_stmt|;
break|break;
case|case
name|EM_IA_64
case|:
name|result
operator|=
name|get_ia64_segment_type
argument_list|(
name|p_type
argument_list|)
expr_stmt|;
break|break;
default|default:
name|result
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|result
operator|!=
name|NULL
condition|)
return|return
name|result
return|;
name|sprintf
argument_list|(
name|buff
argument_list|,
literal|"LOPROC+%lx"
argument_list|,
name|p_type
operator|-
name|PT_LOPROC
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|p_type
operator|>=
name|PT_LOOS
operator|)
operator|&&
operator|(
name|p_type
operator|<=
name|PT_HIOS
operator|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|result
decl_stmt|;
switch|switch
condition|(
name|elf_header
operator|.
name|e_machine
condition|)
block|{
case|case
name|EM_PARISC
case|:
name|result
operator|=
name|get_parisc_segment_type
argument_list|(
name|p_type
argument_list|)
expr_stmt|;
break|break;
case|case
name|EM_IA_64
case|:
name|result
operator|=
name|get_ia64_segment_type
argument_list|(
name|p_type
argument_list|)
expr_stmt|;
break|break;
default|default:
name|result
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|result
operator|!=
name|NULL
condition|)
return|return
name|result
return|;
name|sprintf
argument_list|(
name|buff
argument_list|,
literal|"LOOS+%lx"
argument_list|,
name|p_type
operator|-
name|PT_LOOS
argument_list|)
expr_stmt|;
block|}
else|else
name|sprintf
argument_list|(
name|buff
argument_list|,
name|_
argument_list|(
literal|"<unknown>: %lx"
argument_list|)
argument_list|,
name|p_type
argument_list|)
expr_stmt|;
return|return
name|buff
return|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|get_mips_section_type_name
parameter_list|(
name|unsigned
name|int
name|sh_type
parameter_list|)
block|{
switch|switch
condition|(
name|sh_type
condition|)
block|{
case|case
name|SHT_MIPS_LIBLIST
case|:
return|return
literal|"MIPS_LIBLIST"
return|;
case|case
name|SHT_MIPS_MSYM
case|:
return|return
literal|"MIPS_MSYM"
return|;
case|case
name|SHT_MIPS_CONFLICT
case|:
return|return
literal|"MIPS_CONFLICT"
return|;
case|case
name|SHT_MIPS_GPTAB
case|:
return|return
literal|"MIPS_GPTAB"
return|;
case|case
name|SHT_MIPS_UCODE
case|:
return|return
literal|"MIPS_UCODE"
return|;
case|case
name|SHT_MIPS_DEBUG
case|:
return|return
literal|"MIPS_DEBUG"
return|;
case|case
name|SHT_MIPS_REGINFO
case|:
return|return
literal|"MIPS_REGINFO"
return|;
case|case
name|SHT_MIPS_PACKAGE
case|:
return|return
literal|"MIPS_PACKAGE"
return|;
case|case
name|SHT_MIPS_PACKSYM
case|:
return|return
literal|"MIPS_PACKSYM"
return|;
case|case
name|SHT_MIPS_RELD
case|:
return|return
literal|"MIPS_RELD"
return|;
case|case
name|SHT_MIPS_IFACE
case|:
return|return
literal|"MIPS_IFACE"
return|;
case|case
name|SHT_MIPS_CONTENT
case|:
return|return
literal|"MIPS_CONTENT"
return|;
case|case
name|SHT_MIPS_OPTIONS
case|:
return|return
literal|"MIPS_OPTIONS"
return|;
case|case
name|SHT_MIPS_SHDR
case|:
return|return
literal|"MIPS_SHDR"
return|;
case|case
name|SHT_MIPS_FDESC
case|:
return|return
literal|"MIPS_FDESC"
return|;
case|case
name|SHT_MIPS_EXTSYM
case|:
return|return
literal|"MIPS_EXTSYM"
return|;
case|case
name|SHT_MIPS_DENSE
case|:
return|return
literal|"MIPS_DENSE"
return|;
case|case
name|SHT_MIPS_PDESC
case|:
return|return
literal|"MIPS_PDESC"
return|;
case|case
name|SHT_MIPS_LOCSYM
case|:
return|return
literal|"MIPS_LOCSYM"
return|;
case|case
name|SHT_MIPS_AUXSYM
case|:
return|return
literal|"MIPS_AUXSYM"
return|;
case|case
name|SHT_MIPS_OPTSYM
case|:
return|return
literal|"MIPS_OPTSYM"
return|;
case|case
name|SHT_MIPS_LOCSTR
case|:
return|return
literal|"MIPS_LOCSTR"
return|;
case|case
name|SHT_MIPS_LINE
case|:
return|return
literal|"MIPS_LINE"
return|;
case|case
name|SHT_MIPS_RFDESC
case|:
return|return
literal|"MIPS_RFDESC"
return|;
case|case
name|SHT_MIPS_DELTASYM
case|:
return|return
literal|"MIPS_DELTASYM"
return|;
case|case
name|SHT_MIPS_DELTAINST
case|:
return|return
literal|"MIPS_DELTAINST"
return|;
case|case
name|SHT_MIPS_DELTACLASS
case|:
return|return
literal|"MIPS_DELTACLASS"
return|;
case|case
name|SHT_MIPS_DWARF
case|:
return|return
literal|"MIPS_DWARF"
return|;
case|case
name|SHT_MIPS_DELTADECL
case|:
return|return
literal|"MIPS_DELTADECL"
return|;
case|case
name|SHT_MIPS_SYMBOL_LIB
case|:
return|return
literal|"MIPS_SYMBOL_LIB"
return|;
case|case
name|SHT_MIPS_EVENTS
case|:
return|return
literal|"MIPS_EVENTS"
return|;
case|case
name|SHT_MIPS_TRANSLATE
case|:
return|return
literal|"MIPS_TRANSLATE"
return|;
case|case
name|SHT_MIPS_PIXIE
case|:
return|return
literal|"MIPS_PIXIE"
return|;
case|case
name|SHT_MIPS_XLATE
case|:
return|return
literal|"MIPS_XLATE"
return|;
case|case
name|SHT_MIPS_XLATE_DEBUG
case|:
return|return
literal|"MIPS_XLATE_DEBUG"
return|;
case|case
name|SHT_MIPS_WHIRL
case|:
return|return
literal|"MIPS_WHIRL"
return|;
case|case
name|SHT_MIPS_EH_REGION
case|:
return|return
literal|"MIPS_EH_REGION"
return|;
case|case
name|SHT_MIPS_XLATE_OLD
case|:
return|return
literal|"MIPS_XLATE_OLD"
return|;
case|case
name|SHT_MIPS_PDR_EXCEPTION
case|:
return|return
literal|"MIPS_PDR_EXCEPTION"
return|;
default|default:
break|break;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|get_parisc_section_type_name
parameter_list|(
name|unsigned
name|int
name|sh_type
parameter_list|)
block|{
switch|switch
condition|(
name|sh_type
condition|)
block|{
case|case
name|SHT_PARISC_EXT
case|:
return|return
literal|"PARISC_EXT"
return|;
case|case
name|SHT_PARISC_UNWIND
case|:
return|return
literal|"PARISC_UNWIND"
return|;
case|case
name|SHT_PARISC_DOC
case|:
return|return
literal|"PARISC_DOC"
return|;
default|default:
break|break;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|get_ia64_section_type_name
parameter_list|(
name|unsigned
name|int
name|sh_type
parameter_list|)
block|{
comment|/* If the top 8 bits are 0x78 the next 8 are the os/abi ID. */
if|if
condition|(
operator|(
name|sh_type
operator|&
literal|0xFF000000
operator|)
operator|==
name|SHT_IA_64_LOPSREG
condition|)
return|return
name|get_osabi_name
argument_list|(
operator|(
name|sh_type
operator|&
literal|0x00FF0000
operator|)
operator|>>
literal|16
argument_list|)
return|;
switch|switch
condition|(
name|sh_type
condition|)
block|{
case|case
name|SHT_IA_64_EXT
case|:
return|return
literal|"IA_64_EXT"
return|;
case|case
name|SHT_IA_64_UNWIND
case|:
return|return
literal|"IA_64_UNWIND"
return|;
case|case
name|SHT_IA_64_PRIORITY_INIT
case|:
return|return
literal|"IA_64_PRIORITY_INIT"
return|;
default|default:
break|break;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|get_section_type_name
parameter_list|(
name|unsigned
name|int
name|sh_type
parameter_list|)
block|{
specifier|static
name|char
name|buff
index|[
literal|32
index|]
decl_stmt|;
switch|switch
condition|(
name|sh_type
condition|)
block|{
case|case
name|SHT_NULL
case|:
return|return
literal|"NULL"
return|;
case|case
name|SHT_PROGBITS
case|:
return|return
literal|"PROGBITS"
return|;
case|case
name|SHT_SYMTAB
case|:
return|return
literal|"SYMTAB"
return|;
case|case
name|SHT_STRTAB
case|:
return|return
literal|"STRTAB"
return|;
case|case
name|SHT_RELA
case|:
return|return
literal|"RELA"
return|;
case|case
name|SHT_HASH
case|:
return|return
literal|"HASH"
return|;
case|case
name|SHT_DYNAMIC
case|:
return|return
literal|"DYNAMIC"
return|;
case|case
name|SHT_NOTE
case|:
return|return
literal|"NOTE"
return|;
case|case
name|SHT_NOBITS
case|:
return|return
literal|"NOBITS"
return|;
case|case
name|SHT_REL
case|:
return|return
literal|"REL"
return|;
case|case
name|SHT_SHLIB
case|:
return|return
literal|"SHLIB"
return|;
case|case
name|SHT_DYNSYM
case|:
return|return
literal|"DYNSYM"
return|;
case|case
name|SHT_INIT_ARRAY
case|:
return|return
literal|"INIT_ARRAY"
return|;
case|case
name|SHT_FINI_ARRAY
case|:
return|return
literal|"FINI_ARRAY"
return|;
case|case
name|SHT_PREINIT_ARRAY
case|:
return|return
literal|"PREINIT_ARRAY"
return|;
case|case
name|SHT_GROUP
case|:
return|return
literal|"GROUP"
return|;
case|case
name|SHT_SYMTAB_SHNDX
case|:
return|return
literal|"SYMTAB SECTION INDICIES"
return|;
case|case
name|SHT_GNU_verdef
case|:
return|return
literal|"VERDEF"
return|;
case|case
name|SHT_GNU_verneed
case|:
return|return
literal|"VERNEED"
return|;
case|case
name|SHT_GNU_versym
case|:
return|return
literal|"VERSYM"
return|;
case|case
literal|0x6ffffff0
case|:
return|return
literal|"VERSYM"
return|;
case|case
literal|0x6ffffffc
case|:
return|return
literal|"VERDEF"
return|;
case|case
literal|0x7ffffffd
case|:
return|return
literal|"AUXILIARY"
return|;
case|case
literal|0x7fffffff
case|:
return|return
literal|"FILTER"
return|;
case|case
name|SHT_GNU_LIBLIST
case|:
return|return
literal|"GNU_LIBLIST"
return|;
default|default:
if|if
condition|(
operator|(
name|sh_type
operator|>=
name|SHT_LOPROC
operator|)
operator|&&
operator|(
name|sh_type
operator|<=
name|SHT_HIPROC
operator|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|result
decl_stmt|;
switch|switch
condition|(
name|elf_header
operator|.
name|e_machine
condition|)
block|{
case|case
name|EM_MIPS
case|:
case|case
name|EM_MIPS_RS3_LE
case|:
name|result
operator|=
name|get_mips_section_type_name
argument_list|(
name|sh_type
argument_list|)
expr_stmt|;
break|break;
case|case
name|EM_PARISC
case|:
name|result
operator|=
name|get_parisc_section_type_name
argument_list|(
name|sh_type
argument_list|)
expr_stmt|;
break|break;
case|case
name|EM_IA_64
case|:
name|result
operator|=
name|get_ia64_section_type_name
argument_list|(
name|sh_type
argument_list|)
expr_stmt|;
break|break;
default|default:
name|result
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|result
operator|!=
name|NULL
condition|)
return|return
name|result
return|;
name|sprintf
argument_list|(
name|buff
argument_list|,
literal|"LOPROC+%x"
argument_list|,
name|sh_type
operator|-
name|SHT_LOPROC
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|sh_type
operator|>=
name|SHT_LOOS
operator|)
operator|&&
operator|(
name|sh_type
operator|<=
name|SHT_HIOS
operator|)
condition|)
name|sprintf
argument_list|(
name|buff
argument_list|,
literal|"LOOS+%x"
argument_list|,
name|sh_type
operator|-
name|SHT_LOOS
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|sh_type
operator|>=
name|SHT_LOUSER
operator|)
operator|&&
operator|(
name|sh_type
operator|<=
name|SHT_HIUSER
operator|)
condition|)
name|sprintf
argument_list|(
name|buff
argument_list|,
literal|"LOUSER+%x"
argument_list|,
name|sh_type
operator|-
name|SHT_LOUSER
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|buff
argument_list|,
name|_
argument_list|(
literal|"<unknown>: %x"
argument_list|)
argument_list|,
name|sh_type
argument_list|)
expr_stmt|;
return|return
name|buff
return|;
block|}
block|}
end_function

begin_define
define|#
directive|define
name|OPTION_DEBUG_DUMP
value|512
end_define

begin_decl_stmt
name|struct
name|option
name|options
index|[]
init|=
block|{
block|{
literal|"all"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'a'
block|}
block|,
block|{
literal|"file-header"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'h'
block|}
block|,
block|{
literal|"program-headers"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'l'
block|}
block|,
block|{
literal|"headers"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'e'
block|}
block|,
block|{
literal|"histogram"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'I'
block|}
block|,
block|{
literal|"segments"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'l'
block|}
block|,
block|{
literal|"sections"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'S'
block|}
block|,
block|{
literal|"section-headers"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'S'
block|}
block|,
block|{
literal|"symbols"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'s'
block|}
block|,
block|{
literal|"syms"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'s'
block|}
block|,
block|{
literal|"relocs"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'r'
block|}
block|,
block|{
literal|"notes"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'n'
block|}
block|,
block|{
literal|"dynamic"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'d'
block|}
block|,
block|{
literal|"arch-specific"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'A'
block|}
block|,
block|{
literal|"version-info"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'V'
block|}
block|,
block|{
literal|"use-dynamic"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'D'
block|}
block|,
block|{
literal|"hex-dump"
block|,
name|required_argument
block|,
literal|0
block|,
literal|'x'
block|}
block|,
block|{
literal|"debug-dump"
block|,
name|optional_argument
block|,
literal|0
block|,
name|OPTION_DEBUG_DUMP
block|}
block|,
block|{
literal|"unwind"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'u'
block|}
block|,
ifdef|#
directive|ifdef
name|SUPPORT_DISASSEMBLY
block|{
literal|"instruction-dump"
block|,
name|required_argument
block|,
literal|0
block|,
literal|'i'
block|}
block|,
endif|#
directive|endif
block|{
literal|"version"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'v'
block|}
block|,
block|{
literal|"wide"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'W'
block|}
block|,
block|{
literal|"help"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'H'
block|}
block|,
block|{
literal|0
block|,
name|no_argument
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|usage
parameter_list|(
name|void
parameter_list|)
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
name|_
argument_list|(
literal|"Usage: readelf<option(s)> elf-file(s)\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
name|_
argument_list|(
literal|" Display information about the contents of ELF format files\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
name|_
argument_list|(
literal|" Options are:\n\   -a --all               Equivalent to: -h -l -S -s -r -d -V -A -I\n\   -h --file-header       Display the ELF file header\n\   -l --program-headers   Display the program headers\n\      --segments          An alias for --program-headers\n\   -S --section-headers   Display the sections' header\n\      --sections          An alias for --section-headers\n\   -e --headers           Equivalent to: -h -l -S\n\   -s --syms              Display the symbol table\n\       --symbols          An alias for --syms\n\   -n --notes             Display the core notes (if present)\n\   -r --relocs            Display the relocations (if present)\n\   -u --unwind            Display the unwind info (if present)\n\   -d --dynamic           Display the dynamic segment (if present)\n\   -V --version-info      Display the version sections (if present)\n\   -A --arch-specific     Display architecture specific information (if any).\n\   -D --use-dynamic       Use the dynamic section info when displaying symbols\n\   -x --hex-dump=<number> Dump the contents of section<number>\n\   -w[liaprmfFso] or\n\   --debug-dump[=line,=info,=abbrev,=pubnames,=ranges,=macro,=frames,=str,=loc]\n\                          Display the contents of DWARF2 debug sections\n"
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SUPPORT_DISASSEMBLY
name|fprintf
argument_list|(
name|stdout
argument_list|,
name|_
argument_list|(
literal|"\   -i --instruction-dump=<number>\n\                          Disassemble the contents of section<number>\n"
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|fprintf
argument_list|(
name|stdout
argument_list|,
name|_
argument_list|(
literal|"\   -I --histogram         Display histogram of bucket list lengths\n\   -W --wide              Allow output width to exceed 80 characters\n\   -H --help              Display this information\n\   -v --version           Display the version number of readelf\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
name|_
argument_list|(
literal|"Report bugs to %s\n"
argument_list|)
argument_list|,
name|REPORT_BUGS_TO
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|request_dump
parameter_list|(
name|unsigned
name|int
name|section
parameter_list|,
name|int
name|type
parameter_list|)
block|{
if|if
condition|(
name|section
operator|>=
name|num_dump_sects
condition|)
block|{
name|char
modifier|*
name|new_dump_sects
decl_stmt|;
name|new_dump_sects
operator|=
name|calloc
argument_list|(
name|section
operator|+
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_dump_sects
operator|==
name|NULL
condition|)
name|error
argument_list|(
name|_
argument_list|(
literal|"Out of memory allocating dump request table."
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Copy current flag settings.  */
name|memcpy
argument_list|(
name|new_dump_sects
argument_list|,
name|dump_sects
argument_list|,
name|num_dump_sects
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dump_sects
argument_list|)
expr_stmt|;
name|dump_sects
operator|=
name|new_dump_sects
expr_stmt|;
name|num_dump_sects
operator|=
name|section
operator|+
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|dump_sects
condition|)
name|dump_sects
index|[
name|section
index|]
operator||=
name|type
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|parse_args
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
name|usage
argument_list|()
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getopt_long
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"ersuahnldSDAIw::x:i:vVWH"
argument_list|,
name|options
argument_list|,
name|NULL
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
name|char
modifier|*
name|cp
decl_stmt|;
name|int
name|section
decl_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|0
case|:
comment|/* Long options.  */
break|break;
case|case
literal|'H'
case|:
name|usage
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
name|do_syms
operator|++
expr_stmt|;
name|do_reloc
operator|++
expr_stmt|;
name|do_unwind
operator|++
expr_stmt|;
name|do_dynamic
operator|++
expr_stmt|;
name|do_header
operator|++
expr_stmt|;
name|do_sections
operator|++
expr_stmt|;
name|do_segments
operator|++
expr_stmt|;
name|do_version
operator|++
expr_stmt|;
name|do_histogram
operator|++
expr_stmt|;
name|do_arch
operator|++
expr_stmt|;
name|do_notes
operator|++
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
name|do_header
operator|++
expr_stmt|;
name|do_sections
operator|++
expr_stmt|;
name|do_segments
operator|++
expr_stmt|;
break|break;
case|case
literal|'A'
case|:
name|do_arch
operator|++
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
name|do_using_dynamic
operator|++
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|do_reloc
operator|++
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
name|do_unwind
operator|++
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
name|do_header
operator|++
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|do_segments
operator|++
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|do_syms
operator|++
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
name|do_sections
operator|++
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|do_dynamic
operator|++
expr_stmt|;
break|break;
case|case
literal|'I'
case|:
name|do_histogram
operator|++
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
name|do_notes
operator|++
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
name|do_dump
operator|++
expr_stmt|;
name|section
operator|=
name|strtoul
argument_list|(
name|optarg
argument_list|,
operator|&
name|cp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|cp
operator|&&
name|section
operator|>=
literal|0
condition|)
block|{
name|request_dump
argument_list|(
name|section
argument_list|,
name|HEX_DUMP
argument_list|)
expr_stmt|;
break|break;
block|}
goto|goto
name|oops
goto|;
case|case
literal|'w'
case|:
name|do_dump
operator|++
expr_stmt|;
if|if
condition|(
name|optarg
operator|==
literal|0
condition|)
name|do_debugging
operator|=
literal|1
expr_stmt|;
else|else
block|{
name|unsigned
name|int
name|index
init|=
literal|0
decl_stmt|;
name|do_debugging
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|optarg
index|[
name|index
index|]
condition|)
switch|switch
condition|(
name|optarg
index|[
name|index
operator|++
index|]
condition|)
block|{
case|case
literal|'i'
case|:
case|case
literal|'I'
case|:
name|do_debug_info
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
case|case
literal|'A'
case|:
name|do_debug_abbrevs
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
case|case
literal|'L'
case|:
name|do_debug_lines
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
case|case
literal|'P'
case|:
name|do_debug_pubnames
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
case|case
literal|'R'
case|:
name|do_debug_aranges
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'F'
case|:
name|do_debug_frames_interp
operator|=
literal|1
expr_stmt|;
case|case
literal|'f'
case|:
name|do_debug_frames
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
case|case
literal|'M'
case|:
name|do_debug_macinfo
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
case|case
literal|'S'
case|:
name|do_debug_str
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
case|case
literal|'O'
case|:
name|do_debug_loc
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
name|warn
argument_list|(
name|_
argument_list|(
literal|"Unrecognized debug option '%s'\n"
argument_list|)
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
break|break;
case|case
name|OPTION_DEBUG_DUMP
case|:
name|do_dump
operator|++
expr_stmt|;
if|if
condition|(
name|optarg
operator|==
literal|0
condition|)
name|do_debugging
operator|=
literal|1
expr_stmt|;
else|else
block|{
specifier|static
specifier|const
name|char
modifier|*
name|debug_dump_opt
index|[]
init|=
block|{
literal|"line"
block|,
literal|"info"
block|,
literal|"abbrev"
block|,
literal|"pubnames"
block|,
literal|"ranges"
block|,
literal|"macro"
block|,
literal|"frames"
block|,
literal|"frames-interp"
block|,
literal|"str"
block|,
literal|"loc"
block|,
name|NULL
block|}
decl_stmt|;
name|unsigned
name|int
name|index
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|do_debugging
operator|=
literal|0
expr_stmt|;
name|p
operator|=
name|optarg
expr_stmt|;
while|while
condition|(
operator|*
name|p
condition|)
block|{
for|for
control|(
name|index
operator|=
literal|0
init|;
name|debug_dump_opt
index|[
name|index
index|]
condition|;
name|index
operator|++
control|)
block|{
name|size_t
name|len
init|=
name|strlen
argument_list|(
name|debug_dump_opt
index|[
name|index
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|p
argument_list|,
name|debug_dump_opt
index|[
name|index
index|]
argument_list|,
name|len
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|p
index|[
name|len
index|]
operator|==
literal|','
operator|||
name|p
index|[
name|len
index|]
operator|==
literal|'\0'
operator|)
condition|)
block|{
switch|switch
condition|(
name|p
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|'i'
case|:
name|do_debug_info
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
name|do_debug_abbrevs
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|==
literal|'i'
condition|)
name|do_debug_lines
operator|=
literal|1
expr_stmt|;
else|else
name|do_debug_loc
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|do_debug_pubnames
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|do_debug_aranges
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
if|if
condition|(
name|len
operator|>
literal|6
condition|)
name|do_debug_frames_interp
operator|=
literal|1
expr_stmt|;
name|do_debug_frames
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
name|do_debug_macinfo
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|do_debug_str
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|p
operator|+=
name|len
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|debug_dump_opt
index|[
name|index
index|]
operator|==
name|NULL
condition|)
block|{
name|warn
argument_list|(
name|_
argument_list|(
literal|"Unrecognized debug option '%s'\n"
argument_list|)
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|p
operator|=
name|strchr
argument_list|(
name|p
argument_list|,
literal|','
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
break|break;
block|}
if|if
condition|(
operator|*
name|p
operator|==
literal|','
condition|)
name|p
operator|++
expr_stmt|;
block|}
block|}
break|break;
ifdef|#
directive|ifdef
name|SUPPORT_DISASSEMBLY
case|case
literal|'i'
case|:
name|do_dump
operator|++
expr_stmt|;
name|section
operator|=
name|strtoul
argument_list|(
name|optarg
argument_list|,
operator|&
name|cp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|cp
operator|&&
name|section
operator|>=
literal|0
condition|)
block|{
name|request_dump
argument_list|(
name|section
argument_list|,
name|DISASS_DUMP
argument_list|)
expr_stmt|;
break|break;
block|}
goto|goto
name|oops
goto|;
endif|#
directive|endif
case|case
literal|'v'
case|:
name|print_version
argument_list|(
name|program_name
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'V'
case|:
name|do_version
operator|++
expr_stmt|;
break|break;
case|case
literal|'W'
case|:
name|do_wide
operator|++
expr_stmt|;
break|break;
default|default:
name|oops
label|:
comment|/* xgettext:c-format */
name|error
argument_list|(
name|_
argument_list|(
literal|"Invalid option '-%c'\n"
argument_list|)
argument_list|,
name|c
argument_list|)
expr_stmt|;
comment|/* Drop through.  */
case|case
literal|'?'
case|:
name|usage
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|do_dynamic
operator|&&
operator|!
name|do_syms
operator|&&
operator|!
name|do_reloc
operator|&&
operator|!
name|do_unwind
operator|&&
operator|!
name|do_sections
operator|&&
operator|!
name|do_segments
operator|&&
operator|!
name|do_header
operator|&&
operator|!
name|do_dump
operator|&&
operator|!
name|do_version
operator|&&
operator|!
name|do_histogram
operator|&&
operator|!
name|do_debugging
operator|&&
operator|!
name|do_arch
operator|&&
operator|!
name|do_notes
condition|)
name|usage
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|argc
operator|<
literal|3
condition|)
block|{
name|warn
argument_list|(
name|_
argument_list|(
literal|"Nothing to do.\n"
argument_list|)
argument_list|)
expr_stmt|;
name|usage
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|get_elf_class
parameter_list|(
name|unsigned
name|int
name|elf_class
parameter_list|)
block|{
specifier|static
name|char
name|buff
index|[
literal|32
index|]
decl_stmt|;
switch|switch
condition|(
name|elf_class
condition|)
block|{
case|case
name|ELFCLASSNONE
case|:
return|return
name|_
argument_list|(
literal|"none"
argument_list|)
return|;
case|case
name|ELFCLASS32
case|:
return|return
literal|"ELF32"
return|;
case|case
name|ELFCLASS64
case|:
return|return
literal|"ELF64"
return|;
default|default:
name|sprintf
argument_list|(
name|buff
argument_list|,
name|_
argument_list|(
literal|"<unknown: %x>"
argument_list|)
argument_list|,
name|elf_class
argument_list|)
expr_stmt|;
return|return
name|buff
return|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|get_data_encoding
parameter_list|(
name|unsigned
name|int
name|encoding
parameter_list|)
block|{
specifier|static
name|char
name|buff
index|[
literal|32
index|]
decl_stmt|;
switch|switch
condition|(
name|encoding
condition|)
block|{
case|case
name|ELFDATANONE
case|:
return|return
name|_
argument_list|(
literal|"none"
argument_list|)
return|;
case|case
name|ELFDATA2LSB
case|:
return|return
name|_
argument_list|(
literal|"2's complement, little endian"
argument_list|)
return|;
case|case
name|ELFDATA2MSB
case|:
return|return
name|_
argument_list|(
literal|"2's complement, big endian"
argument_list|)
return|;
default|default:
name|sprintf
argument_list|(
name|buff
argument_list|,
name|_
argument_list|(
literal|"<unknown: %x>"
argument_list|)
argument_list|,
name|encoding
argument_list|)
expr_stmt|;
return|return
name|buff
return|;
block|}
block|}
end_function

begin_comment
comment|/* Decode the data held in 'elf_header'.  */
end_comment

begin_function
specifier|static
name|int
name|process_file_header
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|elf_header
operator|.
name|e_ident
index|[
name|EI_MAG0
index|]
operator|!=
name|ELFMAG0
operator|||
name|elf_header
operator|.
name|e_ident
index|[
name|EI_MAG1
index|]
operator|!=
name|ELFMAG1
operator|||
name|elf_header
operator|.
name|e_ident
index|[
name|EI_MAG2
index|]
operator|!=
name|ELFMAG2
operator|||
name|elf_header
operator|.
name|e_ident
index|[
name|EI_MAG3
index|]
operator|!=
name|ELFMAG3
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"Not an ELF file - it has the wrong magic bytes at the start\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|do_header
condition|)
block|{
name|int
name|i
decl_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"ELF Header:\n"
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"  Magic:   "
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|EI_NIDENT
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|"%2.2x "
argument_list|,
name|elf_header
operator|.
name|e_ident
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"  Class:                             %s\n"
argument_list|)
argument_list|,
name|get_elf_class
argument_list|(
name|elf_header
operator|.
name|e_ident
index|[
name|EI_CLASS
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"  Data:                              %s\n"
argument_list|)
argument_list|,
name|get_data_encoding
argument_list|(
name|elf_header
operator|.
name|e_ident
index|[
name|EI_DATA
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"  Version:                           %d %s\n"
argument_list|)
argument_list|,
name|elf_header
operator|.
name|e_ident
index|[
name|EI_VERSION
index|]
argument_list|,
operator|(
name|elf_header
operator|.
name|e_ident
index|[
name|EI_VERSION
index|]
operator|==
name|EV_CURRENT
condition|?
literal|"(current)"
else|:
operator|(
name|elf_header
operator|.
name|e_ident
index|[
name|EI_VERSION
index|]
operator|!=
name|EV_NONE
condition|?
literal|"<unknown: %lx>"
else|:
literal|""
operator|)
operator|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"  OS/ABI:                            %s\n"
argument_list|)
argument_list|,
name|get_osabi_name
argument_list|(
name|elf_header
operator|.
name|e_ident
index|[
name|EI_OSABI
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"  ABI Version:                       %d\n"
argument_list|)
argument_list|,
name|elf_header
operator|.
name|e_ident
index|[
name|EI_ABIVERSION
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"  Type:                              %s\n"
argument_list|)
argument_list|,
name|get_file_type
argument_list|(
name|elf_header
operator|.
name|e_type
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"  Machine:                           %s\n"
argument_list|)
argument_list|,
name|get_machine_name
argument_list|(
name|elf_header
operator|.
name|e_machine
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"  Version:                           0x%lx\n"
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|elf_header
operator|.
name|e_version
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"  Entry point address:               "
argument_list|)
argument_list|)
expr_stmt|;
name|print_vma
argument_list|(
operator|(
name|bfd_vma
operator|)
name|elf_header
operator|.
name|e_entry
argument_list|,
name|PREFIX_HEX
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"\n  Start of program headers:          "
argument_list|)
argument_list|)
expr_stmt|;
name|print_vma
argument_list|(
operator|(
name|bfd_vma
operator|)
name|elf_header
operator|.
name|e_phoff
argument_list|,
name|DEC
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|" (bytes into file)\n  Start of section headers:          "
argument_list|)
argument_list|)
expr_stmt|;
name|print_vma
argument_list|(
operator|(
name|bfd_vma
operator|)
name|elf_header
operator|.
name|e_shoff
argument_list|,
name|DEC
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|" (bytes into file)\n"
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"  Flags:                             0x%lx%s\n"
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|elf_header
operator|.
name|e_flags
argument_list|,
name|get_machine_flags
argument_list|(
name|elf_header
operator|.
name|e_flags
argument_list|,
name|elf_header
operator|.
name|e_machine
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"  Size of this header:               %ld (bytes)\n"
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|elf_header
operator|.
name|e_ehsize
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"  Size of program headers:           %ld (bytes)\n"
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|elf_header
operator|.
name|e_phentsize
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"  Number of program headers:         %ld\n"
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|elf_header
operator|.
name|e_phnum
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"  Size of section headers:           %ld (bytes)\n"
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|elf_header
operator|.
name|e_shentsize
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"  Number of section headers:         %ld"
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|elf_header
operator|.
name|e_shnum
argument_list|)
expr_stmt|;
if|if
condition|(
name|section_headers
operator|!=
name|NULL
operator|&&
name|elf_header
operator|.
name|e_shnum
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|" (%ld)"
argument_list|,
operator|(
name|long
operator|)
name|section_headers
index|[
literal|0
index|]
operator|.
name|sh_size
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"  Section header string table index: %ld"
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|elf_header
operator|.
name|e_shstrndx
argument_list|)
expr_stmt|;
if|if
condition|(
name|section_headers
operator|!=
name|NULL
operator|&&
name|elf_header
operator|.
name|e_shstrndx
operator|==
name|SHN_XINDEX
condition|)
name|printf
argument_list|(
literal|" (%ld)"
argument_list|,
operator|(
name|long
operator|)
name|section_headers
index|[
literal|0
index|]
operator|.
name|sh_link
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|section_headers
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|elf_header
operator|.
name|e_shnum
operator|==
literal|0
condition|)
name|elf_header
operator|.
name|e_shnum
operator|=
name|section_headers
index|[
literal|0
index|]
operator|.
name|sh_size
expr_stmt|;
if|if
condition|(
name|elf_header
operator|.
name|e_shstrndx
operator|==
name|SHN_XINDEX
condition|)
name|elf_header
operator|.
name|e_shstrndx
operator|=
name|section_headers
index|[
literal|0
index|]
operator|.
name|sh_link
expr_stmt|;
name|free
argument_list|(
name|section_headers
argument_list|)
expr_stmt|;
name|section_headers
operator|=
name|NULL
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|get_32bit_program_headers
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
name|Elf_Internal_Phdr
modifier|*
name|program_headers
parameter_list|)
block|{
name|Elf32_External_Phdr
modifier|*
name|phdrs
decl_stmt|;
name|Elf32_External_Phdr
modifier|*
name|external
decl_stmt|;
name|Elf_Internal_Phdr
modifier|*
name|internal
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|phdrs
operator|=
name|get_data
argument_list|(
name|NULL
argument_list|,
name|file
argument_list|,
name|elf_header
operator|.
name|e_phoff
argument_list|,
name|elf_header
operator|.
name|e_phentsize
operator|*
name|elf_header
operator|.
name|e_phnum
argument_list|,
name|_
argument_list|(
literal|"program headers"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|phdrs
condition|)
return|return
literal|0
return|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|internal
operator|=
name|program_headers
operator|,
name|external
operator|=
name|phdrs
init|;
name|i
operator|<
name|elf_header
operator|.
name|e_phnum
condition|;
name|i
operator|++
operator|,
name|internal
operator|++
operator|,
name|external
operator|++
control|)
block|{
name|internal
operator|->
name|p_type
operator|=
name|BYTE_GET
argument_list|(
name|external
operator|->
name|p_type
argument_list|)
expr_stmt|;
name|internal
operator|->
name|p_offset
operator|=
name|BYTE_GET
argument_list|(
name|external
operator|->
name|p_offset
argument_list|)
expr_stmt|;
name|internal
operator|->
name|p_vaddr
operator|=
name|BYTE_GET
argument_list|(
name|external
operator|->
name|p_vaddr
argument_list|)
expr_stmt|;
name|internal
operator|->
name|p_paddr
operator|=
name|BYTE_GET
argument_list|(
name|external
operator|->
name|p_paddr
argument_list|)
expr_stmt|;
name|internal
operator|->
name|p_filesz
operator|=
name|BYTE_GET
argument_list|(
name|external
operator|->
name|p_filesz
argument_list|)
expr_stmt|;
name|internal
operator|->
name|p_memsz
operator|=
name|BYTE_GET
argument_list|(
name|external
operator|->
name|p_memsz
argument_list|)
expr_stmt|;
name|internal
operator|->
name|p_flags
operator|=
name|BYTE_GET
argument_list|(
name|external
operator|->
name|p_flags
argument_list|)
expr_stmt|;
name|internal
operator|->
name|p_align
operator|=
name|BYTE_GET
argument_list|(
name|external
operator|->
name|p_align
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|phdrs
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|get_64bit_program_headers
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
name|Elf_Internal_Phdr
modifier|*
name|program_headers
parameter_list|)
block|{
name|Elf64_External_Phdr
modifier|*
name|phdrs
decl_stmt|;
name|Elf64_External_Phdr
modifier|*
name|external
decl_stmt|;
name|Elf_Internal_Phdr
modifier|*
name|internal
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|phdrs
operator|=
name|get_data
argument_list|(
name|NULL
argument_list|,
name|file
argument_list|,
name|elf_header
operator|.
name|e_phoff
argument_list|,
name|elf_header
operator|.
name|e_phentsize
operator|*
name|elf_header
operator|.
name|e_phnum
argument_list|,
name|_
argument_list|(
literal|"program headers"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|phdrs
condition|)
return|return
literal|0
return|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|internal
operator|=
name|program_headers
operator|,
name|external
operator|=
name|phdrs
init|;
name|i
operator|<
name|elf_header
operator|.
name|e_phnum
condition|;
name|i
operator|++
operator|,
name|internal
operator|++
operator|,
name|external
operator|++
control|)
block|{
name|internal
operator|->
name|p_type
operator|=
name|BYTE_GET
argument_list|(
name|external
operator|->
name|p_type
argument_list|)
expr_stmt|;
name|internal
operator|->
name|p_flags
operator|=
name|BYTE_GET
argument_list|(
name|external
operator|->
name|p_flags
argument_list|)
expr_stmt|;
name|internal
operator|->
name|p_offset
operator|=
name|BYTE_GET8
argument_list|(
name|external
operator|->
name|p_offset
argument_list|)
expr_stmt|;
name|internal
operator|->
name|p_vaddr
operator|=
name|BYTE_GET8
argument_list|(
name|external
operator|->
name|p_vaddr
argument_list|)
expr_stmt|;
name|internal
operator|->
name|p_paddr
operator|=
name|BYTE_GET8
argument_list|(
name|external
operator|->
name|p_paddr
argument_list|)
expr_stmt|;
name|internal
operator|->
name|p_filesz
operator|=
name|BYTE_GET8
argument_list|(
name|external
operator|->
name|p_filesz
argument_list|)
expr_stmt|;
name|internal
operator|->
name|p_memsz
operator|=
name|BYTE_GET8
argument_list|(
name|external
operator|->
name|p_memsz
argument_list|)
expr_stmt|;
name|internal
operator|->
name|p_align
operator|=
name|BYTE_GET8
argument_list|(
name|external
operator|->
name|p_align
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|phdrs
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Returns 1 if the program headers were read into `program_headers'.  */
end_comment

begin_function
specifier|static
name|int
name|get_program_headers
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|)
block|{
name|Elf_Internal_Phdr
modifier|*
name|phdrs
decl_stmt|;
comment|/* Check cache of prior read.  */
if|if
condition|(
name|program_headers
operator|!=
name|NULL
condition|)
return|return
literal|1
return|;
name|phdrs
operator|=
name|malloc
argument_list|(
name|elf_header
operator|.
name|e_phnum
operator|*
sizeof|sizeof
argument_list|(
name|Elf_Internal_Phdr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|phdrs
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"Out of memory\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|is_32bit_elf
condition|?
name|get_32bit_program_headers
argument_list|(
name|file
argument_list|,
name|phdrs
argument_list|)
else|:
name|get_64bit_program_headers
argument_list|(
name|file
argument_list|,
name|phdrs
argument_list|)
condition|)
block|{
name|program_headers
operator|=
name|phdrs
expr_stmt|;
return|return
literal|1
return|;
block|}
name|free
argument_list|(
name|phdrs
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Returns 1 if the program headers were loaded.  */
end_comment

begin_function
specifier|static
name|int
name|process_program_headers
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|)
block|{
name|Elf_Internal_Phdr
modifier|*
name|segment
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
if|if
condition|(
name|elf_header
operator|.
name|e_phnum
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|do_segments
condition|)
name|printf
argument_list|(
name|_
argument_list|(
literal|"\nThere are no program headers in this file.\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|do_segments
operator|&&
operator|!
name|do_header
condition|)
block|{
name|printf
argument_list|(
name|_
argument_list|(
literal|"\nElf file type is %s\n"
argument_list|)
argument_list|,
name|get_file_type
argument_list|(
name|elf_header
operator|.
name|e_type
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"Entry point "
argument_list|)
argument_list|)
expr_stmt|;
name|print_vma
argument_list|(
operator|(
name|bfd_vma
operator|)
name|elf_header
operator|.
name|e_entry
argument_list|,
name|PREFIX_HEX
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"\nThere are %d program headers, starting at offset "
argument_list|)
argument_list|,
name|elf_header
operator|.
name|e_phnum
argument_list|)
expr_stmt|;
name|print_vma
argument_list|(
operator|(
name|bfd_vma
operator|)
name|elf_header
operator|.
name|e_phoff
argument_list|,
name|DEC
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|get_program_headers
argument_list|(
name|file
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|do_segments
condition|)
block|{
if|if
condition|(
name|elf_header
operator|.
name|e_phnum
operator|>
literal|1
condition|)
name|printf
argument_list|(
name|_
argument_list|(
literal|"\nProgram Headers:\n"
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
name|_
argument_list|(
literal|"\nProgram Headers:\n"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_32bit_elf
condition|)
name|printf
argument_list|(
name|_
argument_list|(
literal|"  Type           Offset   VirtAddr   PhysAddr   FileSiz MemSiz  Flg Align\n"
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|do_wide
condition|)
name|printf
argument_list|(
name|_
argument_list|(
literal|"  Type           Offset   VirtAddr           PhysAddr           FileSiz  MemSiz   Flg Align\n"
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|printf
argument_list|(
name|_
argument_list|(
literal|"  Type           Offset             VirtAddr           PhysAddr\n"
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"                 FileSiz            MemSiz              Flags  Align\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|dynamic_addr
operator|=
literal|0
expr_stmt|;
name|dynamic_size
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|segment
operator|=
name|program_headers
init|;
name|i
operator|<
name|elf_header
operator|.
name|e_phnum
condition|;
name|i
operator|++
operator|,
name|segment
operator|++
control|)
block|{
if|if
condition|(
name|do_segments
condition|)
block|{
name|printf
argument_list|(
literal|"  %-14.14s "
argument_list|,
name|get_segment_type
argument_list|(
name|segment
operator|->
name|p_type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_32bit_elf
condition|)
block|{
name|printf
argument_list|(
literal|"0x%6.6lx "
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|segment
operator|->
name|p_offset
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"0x%8.8lx "
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|segment
operator|->
name|p_vaddr
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"0x%8.8lx "
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|segment
operator|->
name|p_paddr
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"0x%5.5lx "
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|segment
operator|->
name|p_filesz
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"0x%5.5lx "
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|segment
operator|->
name|p_memsz
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%c%c%c "
argument_list|,
operator|(
name|segment
operator|->
name|p_flags
operator|&
name|PF_R
condition|?
literal|'R'
else|:
literal|' '
operator|)
argument_list|,
operator|(
name|segment
operator|->
name|p_flags
operator|&
name|PF_W
condition|?
literal|'W'
else|:
literal|' '
operator|)
argument_list|,
operator|(
name|segment
operator|->
name|p_flags
operator|&
name|PF_X
condition|?
literal|'E'
else|:
literal|' '
operator|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%#lx"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|segment
operator|->
name|p_align
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|do_wide
condition|)
block|{
if|if
condition|(
operator|(
name|unsigned
name|long
operator|)
name|segment
operator|->
name|p_offset
operator|==
name|segment
operator|->
name|p_offset
condition|)
name|printf
argument_list|(
literal|"0x%6.6lx "
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|segment
operator|->
name|p_offset
argument_list|)
expr_stmt|;
else|else
block|{
name|print_vma
argument_list|(
name|segment
operator|->
name|p_offset
argument_list|,
name|FULL_HEX
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
name|print_vma
argument_list|(
name|segment
operator|->
name|p_vaddr
argument_list|,
name|FULL_HEX
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|print_vma
argument_list|(
name|segment
operator|->
name|p_paddr
argument_list|,
name|FULL_HEX
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|unsigned
name|long
operator|)
name|segment
operator|->
name|p_filesz
operator|==
name|segment
operator|->
name|p_filesz
condition|)
name|printf
argument_list|(
literal|"0x%6.6lx "
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|segment
operator|->
name|p_filesz
argument_list|)
expr_stmt|;
else|else
block|{
name|print_vma
argument_list|(
name|segment
operator|->
name|p_filesz
argument_list|,
name|FULL_HEX
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|unsigned
name|long
operator|)
name|segment
operator|->
name|p_memsz
operator|==
name|segment
operator|->
name|p_memsz
condition|)
name|printf
argument_list|(
literal|"0x%6.6lx"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|segment
operator|->
name|p_memsz
argument_list|)
expr_stmt|;
else|else
block|{
name|print_vma
argument_list|(
name|segment
operator|->
name|p_offset
argument_list|,
name|FULL_HEX
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|" %c%c%c "
argument_list|,
operator|(
name|segment
operator|->
name|p_flags
operator|&
name|PF_R
condition|?
literal|'R'
else|:
literal|' '
operator|)
argument_list|,
operator|(
name|segment
operator|->
name|p_flags
operator|&
name|PF_W
condition|?
literal|'W'
else|:
literal|' '
operator|)
argument_list|,
operator|(
name|segment
operator|->
name|p_flags
operator|&
name|PF_X
condition|?
literal|'E'
else|:
literal|' '
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|unsigned
name|long
operator|)
name|segment
operator|->
name|p_align
operator|==
name|segment
operator|->
name|p_align
condition|)
name|printf
argument_list|(
literal|"%#lx"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|segment
operator|->
name|p_align
argument_list|)
expr_stmt|;
else|else
block|{
name|print_vma
argument_list|(
name|segment
operator|->
name|p_align
argument_list|,
name|PREFIX_HEX
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|print_vma
argument_list|(
name|segment
operator|->
name|p_offset
argument_list|,
name|FULL_HEX
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|print_vma
argument_list|(
name|segment
operator|->
name|p_vaddr
argument_list|,
name|FULL_HEX
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|print_vma
argument_list|(
name|segment
operator|->
name|p_paddr
argument_list|,
name|FULL_HEX
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n                 "
argument_list|)
expr_stmt|;
name|print_vma
argument_list|(
name|segment
operator|->
name|p_filesz
argument_list|,
name|FULL_HEX
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|print_vma
argument_list|(
name|segment
operator|->
name|p_memsz
argument_list|,
name|FULL_HEX
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  %c%c%c    "
argument_list|,
operator|(
name|segment
operator|->
name|p_flags
operator|&
name|PF_R
condition|?
literal|'R'
else|:
literal|' '
operator|)
argument_list|,
operator|(
name|segment
operator|->
name|p_flags
operator|&
name|PF_W
condition|?
literal|'W'
else|:
literal|' '
operator|)
argument_list|,
operator|(
name|segment
operator|->
name|p_flags
operator|&
name|PF_X
condition|?
literal|'E'
else|:
literal|' '
operator|)
argument_list|)
expr_stmt|;
name|print_vma
argument_list|(
name|segment
operator|->
name|p_align
argument_list|,
name|HEX
argument_list|)
expr_stmt|;
block|}
block|}
switch|switch
condition|(
name|segment
operator|->
name|p_type
condition|)
block|{
case|case
name|PT_DYNAMIC
case|:
if|if
condition|(
name|dynamic_addr
condition|)
name|error
argument_list|(
name|_
argument_list|(
literal|"more than one dynamic segment\n"
argument_list|)
argument_list|)
expr_stmt|;
name|dynamic_addr
operator|=
name|segment
operator|->
name|p_offset
expr_stmt|;
name|dynamic_size
operator|=
name|segment
operator|->
name|p_filesz
expr_stmt|;
break|break;
case|case
name|PT_INTERP
case|:
if|if
condition|(
name|fseek
argument_list|(
name|file
argument_list|,
name|archive_file_offset
operator|+
operator|(
name|long
operator|)
name|segment
operator|->
name|p_offset
argument_list|,
name|SEEK_SET
argument_list|)
condition|)
name|error
argument_list|(
name|_
argument_list|(
literal|"Unable to find program interpreter name\n"
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|program_interpreter
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|fscanf
argument_list|(
name|file
argument_list|,
literal|"%63s"
argument_list|,
name|program_interpreter
argument_list|)
expr_stmt|;
if|if
condition|(
name|do_segments
condition|)
name|printf
argument_list|(
name|_
argument_list|(
literal|"\n      [Requesting program interpreter: %s]"
argument_list|)
argument_list|,
name|program_interpreter
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
name|do_segments
condition|)
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|do_segments
operator|&&
name|section_headers
operator|!=
name|NULL
condition|)
block|{
name|printf
argument_list|(
name|_
argument_list|(
literal|"\n Section to Segment mapping:\n"
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"  Segment Sections...\n"
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|string_table
operator|!=
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|elf_header
operator|.
name|e_phnum
condition|;
name|i
operator|++
control|)
block|{
name|unsigned
name|int
name|j
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|section
decl_stmt|;
name|segment
operator|=
name|program_headers
operator|+
name|i
expr_stmt|;
name|section
operator|=
name|section_headers
expr_stmt|;
name|printf
argument_list|(
literal|"   %2.2d     "
argument_list|,
name|i
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<
name|elf_header
operator|.
name|e_shnum
condition|;
name|j
operator|++
operator|,
name|section
operator|++
control|)
block|{
if|if
condition|(
name|section
operator|->
name|sh_size
operator|>
literal|0
comment|/* Compare allocated sections by VMA, unallocated 		     sections by file offset.  */
operator|&&
operator|(
name|section
operator|->
name|sh_flags
operator|&
name|SHF_ALLOC
condition|?
operator|(
name|section
operator|->
name|sh_addr
operator|>=
name|segment
operator|->
name|p_vaddr
operator|&&
name|section
operator|->
name|sh_addr
operator|+
name|section
operator|->
name|sh_size
operator|<=
name|segment
operator|->
name|p_vaddr
operator|+
name|segment
operator|->
name|p_memsz
operator|)
else|:
operator|(
operator|(
name|bfd_vma
operator|)
name|section
operator|->
name|sh_offset
operator|>=
name|segment
operator|->
name|p_offset
operator|&&
operator|(
name|section
operator|->
name|sh_offset
operator|+
name|section
operator|->
name|sh_size
operator|<=
name|segment
operator|->
name|p_offset
operator|+
name|segment
operator|->
name|p_filesz
operator|)
operator|)
operator|)
condition|)
name|printf
argument_list|(
literal|"%s "
argument_list|,
name|SECTION_NAME
argument_list|(
name|section
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Find the file offset corresponding to VMA by using the program headers.  */
end_comment

begin_function
specifier|static
name|long
name|offset_from_vma
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
name|bfd_vma
name|vma
parameter_list|,
name|bfd_size_type
name|size
parameter_list|)
block|{
name|Elf_Internal_Phdr
modifier|*
name|seg
decl_stmt|;
if|if
condition|(
operator|!
name|get_program_headers
argument_list|(
name|file
argument_list|)
condition|)
block|{
name|warn
argument_list|(
name|_
argument_list|(
literal|"Cannot interpret virtual addresses without program headers.\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|long
operator|)
name|vma
return|;
block|}
for|for
control|(
name|seg
operator|=
name|program_headers
init|;
name|seg
operator|<
name|program_headers
operator|+
name|elf_header
operator|.
name|e_phnum
condition|;
operator|++
name|seg
control|)
block|{
if|if
condition|(
name|seg
operator|->
name|p_type
operator|!=
name|PT_LOAD
condition|)
continue|continue;
if|if
condition|(
name|vma
operator|>=
operator|(
name|seg
operator|->
name|p_vaddr
operator|&
operator|-
name|seg
operator|->
name|p_align
operator|)
operator|&&
name|vma
operator|+
name|size
operator|<=
name|seg
operator|->
name|p_vaddr
operator|+
name|seg
operator|->
name|p_filesz
condition|)
return|return
name|vma
operator|-
name|seg
operator|->
name|p_vaddr
operator|+
name|seg
operator|->
name|p_offset
return|;
block|}
name|warn
argument_list|(
name|_
argument_list|(
literal|"Virtual address 0x%lx not located in any PT_LOAD segment.\n"
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|vma
argument_list|)
expr_stmt|;
return|return
operator|(
name|long
operator|)
name|vma
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|get_32bit_section_headers
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
name|unsigned
name|int
name|num
parameter_list|)
block|{
name|Elf32_External_Shdr
modifier|*
name|shdrs
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|internal
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|shdrs
operator|=
name|get_data
argument_list|(
name|NULL
argument_list|,
name|file
argument_list|,
name|elf_header
operator|.
name|e_shoff
argument_list|,
name|elf_header
operator|.
name|e_shentsize
operator|*
name|num
argument_list|,
name|_
argument_list|(
literal|"section headers"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|shdrs
condition|)
return|return
literal|0
return|;
name|section_headers
operator|=
name|malloc
argument_list|(
name|num
operator|*
sizeof|sizeof
argument_list|(
name|Elf_Internal_Shdr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|section_headers
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"Out of memory\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|internal
operator|=
name|section_headers
init|;
name|i
operator|<
name|num
condition|;
name|i
operator|++
operator|,
name|internal
operator|++
control|)
block|{
name|internal
operator|->
name|sh_name
operator|=
name|BYTE_GET
argument_list|(
name|shdrs
index|[
name|i
index|]
operator|.
name|sh_name
argument_list|)
expr_stmt|;
name|internal
operator|->
name|sh_type
operator|=
name|BYTE_GET
argument_list|(
name|shdrs
index|[
name|i
index|]
operator|.
name|sh_type
argument_list|)
expr_stmt|;
name|internal
operator|->
name|sh_flags
operator|=
name|BYTE_GET
argument_list|(
name|shdrs
index|[
name|i
index|]
operator|.
name|sh_flags
argument_list|)
expr_stmt|;
name|internal
operator|->
name|sh_addr
operator|=
name|BYTE_GET
argument_list|(
name|shdrs
index|[
name|i
index|]
operator|.
name|sh_addr
argument_list|)
expr_stmt|;
name|internal
operator|->
name|sh_offset
operator|=
name|BYTE_GET
argument_list|(
name|shdrs
index|[
name|i
index|]
operator|.
name|sh_offset
argument_list|)
expr_stmt|;
name|internal
operator|->
name|sh_size
operator|=
name|BYTE_GET
argument_list|(
name|shdrs
index|[
name|i
index|]
operator|.
name|sh_size
argument_list|)
expr_stmt|;
name|internal
operator|->
name|sh_link
operator|=
name|BYTE_GET
argument_list|(
name|shdrs
index|[
name|i
index|]
operator|.
name|sh_link
argument_list|)
expr_stmt|;
name|internal
operator|->
name|sh_info
operator|=
name|BYTE_GET
argument_list|(
name|shdrs
index|[
name|i
index|]
operator|.
name|sh_info
argument_list|)
expr_stmt|;
name|internal
operator|->
name|sh_addralign
operator|=
name|BYTE_GET
argument_list|(
name|shdrs
index|[
name|i
index|]
operator|.
name|sh_addralign
argument_list|)
expr_stmt|;
name|internal
operator|->
name|sh_entsize
operator|=
name|BYTE_GET
argument_list|(
name|shdrs
index|[
name|i
index|]
operator|.
name|sh_entsize
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|shdrs
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|get_64bit_section_headers
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
name|unsigned
name|int
name|num
parameter_list|)
block|{
name|Elf64_External_Shdr
modifier|*
name|shdrs
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|internal
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|shdrs
operator|=
name|get_data
argument_list|(
name|NULL
argument_list|,
name|file
argument_list|,
name|elf_header
operator|.
name|e_shoff
argument_list|,
name|elf_header
operator|.
name|e_shentsize
operator|*
name|num
argument_list|,
name|_
argument_list|(
literal|"section headers"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|shdrs
condition|)
return|return
literal|0
return|;
name|section_headers
operator|=
name|malloc
argument_list|(
name|num
operator|*
sizeof|sizeof
argument_list|(
name|Elf_Internal_Shdr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|section_headers
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"Out of memory\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|internal
operator|=
name|section_headers
init|;
name|i
operator|<
name|num
condition|;
name|i
operator|++
operator|,
name|internal
operator|++
control|)
block|{
name|internal
operator|->
name|sh_name
operator|=
name|BYTE_GET
argument_list|(
name|shdrs
index|[
name|i
index|]
operator|.
name|sh_name
argument_list|)
expr_stmt|;
name|internal
operator|->
name|sh_type
operator|=
name|BYTE_GET
argument_list|(
name|shdrs
index|[
name|i
index|]
operator|.
name|sh_type
argument_list|)
expr_stmt|;
name|internal
operator|->
name|sh_flags
operator|=
name|BYTE_GET8
argument_list|(
name|shdrs
index|[
name|i
index|]
operator|.
name|sh_flags
argument_list|)
expr_stmt|;
name|internal
operator|->
name|sh_addr
operator|=
name|BYTE_GET8
argument_list|(
name|shdrs
index|[
name|i
index|]
operator|.
name|sh_addr
argument_list|)
expr_stmt|;
name|internal
operator|->
name|sh_size
operator|=
name|BYTE_GET8
argument_list|(
name|shdrs
index|[
name|i
index|]
operator|.
name|sh_size
argument_list|)
expr_stmt|;
name|internal
operator|->
name|sh_entsize
operator|=
name|BYTE_GET8
argument_list|(
name|shdrs
index|[
name|i
index|]
operator|.
name|sh_entsize
argument_list|)
expr_stmt|;
name|internal
operator|->
name|sh_link
operator|=
name|BYTE_GET
argument_list|(
name|shdrs
index|[
name|i
index|]
operator|.
name|sh_link
argument_list|)
expr_stmt|;
name|internal
operator|->
name|sh_info
operator|=
name|BYTE_GET
argument_list|(
name|shdrs
index|[
name|i
index|]
operator|.
name|sh_info
argument_list|)
expr_stmt|;
name|internal
operator|->
name|sh_offset
operator|=
name|BYTE_GET
argument_list|(
name|shdrs
index|[
name|i
index|]
operator|.
name|sh_offset
argument_list|)
expr_stmt|;
name|internal
operator|->
name|sh_addralign
operator|=
name|BYTE_GET
argument_list|(
name|shdrs
index|[
name|i
index|]
operator|.
name|sh_addralign
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|shdrs
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|Elf_Internal_Sym
modifier|*
name|get_32bit_elf_symbols
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
name|Elf_Internal_Shdr
modifier|*
name|section
parameter_list|)
block|{
name|unsigned
name|long
name|number
decl_stmt|;
name|Elf32_External_Sym
modifier|*
name|esyms
decl_stmt|;
name|Elf_External_Sym_Shndx
modifier|*
name|shndx
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|isyms
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|psym
decl_stmt|;
name|unsigned
name|int
name|j
decl_stmt|;
name|esyms
operator|=
name|get_data
argument_list|(
name|NULL
argument_list|,
name|file
argument_list|,
name|section
operator|->
name|sh_offset
argument_list|,
name|section
operator|->
name|sh_size
argument_list|,
name|_
argument_list|(
literal|"symbols"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|esyms
condition|)
return|return
name|NULL
return|;
name|shndx
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|symtab_shndx_hdr
operator|!=
name|NULL
operator|&&
operator|(
name|symtab_shndx_hdr
operator|->
name|sh_link
operator|==
operator|(
name|unsigned
name|long
operator|)
name|SECTION_HEADER_NUM
argument_list|(
name|section
operator|-
name|section_headers
argument_list|)
operator|)
condition|)
block|{
name|shndx
operator|=
name|get_data
argument_list|(
name|NULL
argument_list|,
name|file
argument_list|,
name|symtab_shndx_hdr
operator|->
name|sh_offset
argument_list|,
name|symtab_shndx_hdr
operator|->
name|sh_size
argument_list|,
name|_
argument_list|(
literal|"symtab shndx"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|shndx
condition|)
block|{
name|free
argument_list|(
name|esyms
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
name|number
operator|=
name|section
operator|->
name|sh_size
operator|/
name|section
operator|->
name|sh_entsize
expr_stmt|;
name|isyms
operator|=
name|malloc
argument_list|(
name|number
operator|*
sizeof|sizeof
argument_list|(
name|Elf_Internal_Sym
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|isyms
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"Out of memory\n"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|shndx
condition|)
name|free
argument_list|(
name|shndx
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|esyms
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
for|for
control|(
name|j
operator|=
literal|0
operator|,
name|psym
operator|=
name|isyms
init|;
name|j
operator|<
name|number
condition|;
name|j
operator|++
operator|,
name|psym
operator|++
control|)
block|{
name|psym
operator|->
name|st_name
operator|=
name|BYTE_GET
argument_list|(
name|esyms
index|[
name|j
index|]
operator|.
name|st_name
argument_list|)
expr_stmt|;
name|psym
operator|->
name|st_value
operator|=
name|BYTE_GET
argument_list|(
name|esyms
index|[
name|j
index|]
operator|.
name|st_value
argument_list|)
expr_stmt|;
name|psym
operator|->
name|st_size
operator|=
name|BYTE_GET
argument_list|(
name|esyms
index|[
name|j
index|]
operator|.
name|st_size
argument_list|)
expr_stmt|;
name|psym
operator|->
name|st_shndx
operator|=
name|BYTE_GET
argument_list|(
name|esyms
index|[
name|j
index|]
operator|.
name|st_shndx
argument_list|)
expr_stmt|;
if|if
condition|(
name|psym
operator|->
name|st_shndx
operator|==
name|SHN_XINDEX
operator|&&
name|shndx
operator|!=
name|NULL
condition|)
name|psym
operator|->
name|st_shndx
operator|=
name|byte_get
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
name|shndx
index|[
name|j
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|shndx
index|[
name|j
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|psym
operator|->
name|st_info
operator|=
name|BYTE_GET
argument_list|(
name|esyms
index|[
name|j
index|]
operator|.
name|st_info
argument_list|)
expr_stmt|;
name|psym
operator|->
name|st_other
operator|=
name|BYTE_GET
argument_list|(
name|esyms
index|[
name|j
index|]
operator|.
name|st_other
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|shndx
condition|)
name|free
argument_list|(
name|shndx
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|esyms
argument_list|)
expr_stmt|;
return|return
name|isyms
return|;
block|}
end_function

begin_function
specifier|static
name|Elf_Internal_Sym
modifier|*
name|get_64bit_elf_symbols
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
name|Elf_Internal_Shdr
modifier|*
name|section
parameter_list|)
block|{
name|unsigned
name|long
name|number
decl_stmt|;
name|Elf64_External_Sym
modifier|*
name|esyms
decl_stmt|;
name|Elf_External_Sym_Shndx
modifier|*
name|shndx
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|isyms
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|psym
decl_stmt|;
name|unsigned
name|int
name|j
decl_stmt|;
name|esyms
operator|=
name|get_data
argument_list|(
name|NULL
argument_list|,
name|file
argument_list|,
name|section
operator|->
name|sh_offset
argument_list|,
name|section
operator|->
name|sh_size
argument_list|,
name|_
argument_list|(
literal|"symbols"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|esyms
condition|)
return|return
name|NULL
return|;
name|shndx
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|symtab_shndx_hdr
operator|!=
name|NULL
operator|&&
operator|(
name|symtab_shndx_hdr
operator|->
name|sh_link
operator|==
operator|(
name|unsigned
name|long
operator|)
name|SECTION_HEADER_NUM
argument_list|(
name|section
operator|-
name|section_headers
argument_list|)
operator|)
condition|)
block|{
name|shndx
operator|=
name|get_data
argument_list|(
name|NULL
argument_list|,
name|file
argument_list|,
name|symtab_shndx_hdr
operator|->
name|sh_offset
argument_list|,
name|symtab_shndx_hdr
operator|->
name|sh_size
argument_list|,
name|_
argument_list|(
literal|"symtab shndx"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|shndx
condition|)
block|{
name|free
argument_list|(
name|esyms
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
name|number
operator|=
name|section
operator|->
name|sh_size
operator|/
name|section
operator|->
name|sh_entsize
expr_stmt|;
name|isyms
operator|=
name|malloc
argument_list|(
name|number
operator|*
sizeof|sizeof
argument_list|(
name|Elf_Internal_Sym
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|isyms
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"Out of memory\n"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|shndx
condition|)
name|free
argument_list|(
name|shndx
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|esyms
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
for|for
control|(
name|j
operator|=
literal|0
operator|,
name|psym
operator|=
name|isyms
init|;
name|j
operator|<
name|number
condition|;
name|j
operator|++
operator|,
name|psym
operator|++
control|)
block|{
name|psym
operator|->
name|st_name
operator|=
name|BYTE_GET
argument_list|(
name|esyms
index|[
name|j
index|]
operator|.
name|st_name
argument_list|)
expr_stmt|;
name|psym
operator|->
name|st_info
operator|=
name|BYTE_GET
argument_list|(
name|esyms
index|[
name|j
index|]
operator|.
name|st_info
argument_list|)
expr_stmt|;
name|psym
operator|->
name|st_other
operator|=
name|BYTE_GET
argument_list|(
name|esyms
index|[
name|j
index|]
operator|.
name|st_other
argument_list|)
expr_stmt|;
name|psym
operator|->
name|st_shndx
operator|=
name|BYTE_GET
argument_list|(
name|esyms
index|[
name|j
index|]
operator|.
name|st_shndx
argument_list|)
expr_stmt|;
if|if
condition|(
name|psym
operator|->
name|st_shndx
operator|==
name|SHN_XINDEX
operator|&&
name|shndx
operator|!=
name|NULL
condition|)
name|psym
operator|->
name|st_shndx
operator|=
name|byte_get
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
name|shndx
index|[
name|j
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|shndx
index|[
name|j
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|psym
operator|->
name|st_value
operator|=
name|BYTE_GET8
argument_list|(
name|esyms
index|[
name|j
index|]
operator|.
name|st_value
argument_list|)
expr_stmt|;
name|psym
operator|->
name|st_size
operator|=
name|BYTE_GET8
argument_list|(
name|esyms
index|[
name|j
index|]
operator|.
name|st_size
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|shndx
condition|)
name|free
argument_list|(
name|shndx
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|esyms
argument_list|)
expr_stmt|;
return|return
name|isyms
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|get_elf_section_flags
parameter_list|(
name|bfd_vma
name|sh_flags
parameter_list|)
block|{
specifier|static
name|char
name|buff
index|[
literal|32
index|]
decl_stmt|;
operator|*
name|buff
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|sh_flags
condition|)
block|{
name|bfd_vma
name|flag
decl_stmt|;
name|flag
operator|=
name|sh_flags
operator|&
operator|-
name|sh_flags
expr_stmt|;
name|sh_flags
operator|&=
operator|~
name|flag
expr_stmt|;
switch|switch
condition|(
name|flag
condition|)
block|{
case|case
name|SHF_WRITE
case|:
name|strcat
argument_list|(
name|buff
argument_list|,
literal|"W"
argument_list|)
expr_stmt|;
break|break;
case|case
name|SHF_ALLOC
case|:
name|strcat
argument_list|(
name|buff
argument_list|,
literal|"A"
argument_list|)
expr_stmt|;
break|break;
case|case
name|SHF_EXECINSTR
case|:
name|strcat
argument_list|(
name|buff
argument_list|,
literal|"X"
argument_list|)
expr_stmt|;
break|break;
case|case
name|SHF_MERGE
case|:
name|strcat
argument_list|(
name|buff
argument_list|,
literal|"M"
argument_list|)
expr_stmt|;
break|break;
case|case
name|SHF_STRINGS
case|:
name|strcat
argument_list|(
name|buff
argument_list|,
literal|"S"
argument_list|)
expr_stmt|;
break|break;
case|case
name|SHF_INFO_LINK
case|:
name|strcat
argument_list|(
name|buff
argument_list|,
literal|"I"
argument_list|)
expr_stmt|;
break|break;
case|case
name|SHF_LINK_ORDER
case|:
name|strcat
argument_list|(
name|buff
argument_list|,
literal|"L"
argument_list|)
expr_stmt|;
break|break;
case|case
name|SHF_OS_NONCONFORMING
case|:
name|strcat
argument_list|(
name|buff
argument_list|,
literal|"O"
argument_list|)
expr_stmt|;
break|break;
case|case
name|SHF_GROUP
case|:
name|strcat
argument_list|(
name|buff
argument_list|,
literal|"G"
argument_list|)
expr_stmt|;
break|break;
case|case
name|SHF_TLS
case|:
name|strcat
argument_list|(
name|buff
argument_list|,
literal|"T"
argument_list|)
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|flag
operator|&
name|SHF_MASKOS
condition|)
block|{
name|strcat
argument_list|(
name|buff
argument_list|,
literal|"o"
argument_list|)
expr_stmt|;
name|sh_flags
operator|&=
operator|~
name|SHF_MASKOS
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|flag
operator|&
name|SHF_MASKPROC
condition|)
block|{
name|strcat
argument_list|(
name|buff
argument_list|,
literal|"p"
argument_list|)
expr_stmt|;
name|sh_flags
operator|&=
operator|~
name|SHF_MASKPROC
expr_stmt|;
block|}
else|else
name|strcat
argument_list|(
name|buff
argument_list|,
literal|"x"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
return|return
name|buff
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|process_section_headers
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|)
block|{
name|Elf_Internal_Shdr
modifier|*
name|section
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|section_headers
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|elf_header
operator|.
name|e_shnum
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|do_sections
condition|)
name|printf
argument_list|(
name|_
argument_list|(
literal|"\nThere are no sections in this file.\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|do_sections
operator|&&
operator|!
name|do_header
condition|)
name|printf
argument_list|(
name|_
argument_list|(
literal|"There are %d section headers, starting at offset 0x%lx:\n"
argument_list|)
argument_list|,
name|elf_header
operator|.
name|e_shnum
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|elf_header
operator|.
name|e_shoff
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_32bit_elf
condition|)
block|{
if|if
condition|(
operator|!
name|get_32bit_section_headers
argument_list|(
name|file
argument_list|,
name|elf_header
operator|.
name|e_shnum
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|get_64bit_section_headers
argument_list|(
name|file
argument_list|,
name|elf_header
operator|.
name|e_shnum
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Read in the string table, so that we have names to display.  */
name|section
operator|=
name|SECTION_HEADER
argument_list|(
name|elf_header
operator|.
name|e_shstrndx
argument_list|)
expr_stmt|;
if|if
condition|(
name|section
operator|->
name|sh_size
operator|!=
literal|0
condition|)
block|{
name|string_table
operator|=
name|get_data
argument_list|(
name|NULL
argument_list|,
name|file
argument_list|,
name|section
operator|->
name|sh_offset
argument_list|,
name|section
operator|->
name|sh_size
argument_list|,
name|_
argument_list|(
literal|"string table"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|string_table
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|string_table_length
operator|=
name|section
operator|->
name|sh_size
expr_stmt|;
block|}
comment|/* Scan the sections for the dynamic symbol table      and dynamic string table and debug sections.  */
name|dynamic_symbols
operator|=
name|NULL
expr_stmt|;
name|dynamic_strings
operator|=
name|NULL
expr_stmt|;
name|dynamic_syminfo
operator|=
name|NULL
expr_stmt|;
name|symtab_shndx_hdr
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|section
operator|=
name|section_headers
init|;
name|i
operator|<
name|elf_header
operator|.
name|e_shnum
condition|;
name|i
operator|++
operator|,
name|section
operator|++
control|)
block|{
name|char
modifier|*
name|name
init|=
name|SECTION_NAME
argument_list|(
name|section
argument_list|)
decl_stmt|;
if|if
condition|(
name|section
operator|->
name|sh_type
operator|==
name|SHT_DYNSYM
condition|)
block|{
if|if
condition|(
name|dynamic_symbols
operator|!=
name|NULL
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"File contains multiple dynamic symbol tables\n"
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|num_dynamic_syms
operator|=
name|section
operator|->
name|sh_size
operator|/
name|section
operator|->
name|sh_entsize
expr_stmt|;
name|dynamic_symbols
operator|=
name|GET_ELF_SYMBOLS
argument_list|(
name|file
argument_list|,
name|section
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|section
operator|->
name|sh_type
operator|==
name|SHT_STRTAB
operator|&&
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".dynstr"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|dynamic_strings
operator|!=
name|NULL
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"File contains multiple dynamic string tables\n"
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|dynamic_strings
operator|=
name|get_data
argument_list|(
name|NULL
argument_list|,
name|file
argument_list|,
name|section
operator|->
name|sh_offset
argument_list|,
name|section
operator|->
name|sh_size
argument_list|,
name|_
argument_list|(
literal|"dynamic strings"
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|section
operator|->
name|sh_type
operator|==
name|SHT_SYMTAB_SHNDX
condition|)
block|{
if|if
condition|(
name|symtab_shndx_hdr
operator|!=
name|NULL
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"File contains multiple symtab shndx tables\n"
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|symtab_shndx_hdr
operator|=
name|section
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|do_debugging
operator|||
name|do_debug_info
operator|||
name|do_debug_abbrevs
operator|||
name|do_debug_lines
operator|||
name|do_debug_pubnames
operator|||
name|do_debug_aranges
operator|||
name|do_debug_frames
operator|||
name|do_debug_macinfo
operator|||
name|do_debug_str
operator|||
name|do_debug_loc
operator|)
operator|&&
name|strncmp
argument_list|(
name|name
argument_list|,
literal|".debug_"
argument_list|,
literal|7
argument_list|)
operator|==
literal|0
condition|)
block|{
name|name
operator|+=
literal|7
expr_stmt|;
if|if
condition|(
name|do_debugging
operator|||
operator|(
name|do_debug_info
operator|&&
operator|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"info"
argument_list|)
operator|==
literal|0
operator|)
operator|)
operator|||
operator|(
name|do_debug_abbrevs
operator|&&
operator|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"abbrev"
argument_list|)
operator|==
literal|0
operator|)
operator|)
operator|||
operator|(
name|do_debug_lines
operator|&&
operator|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"line"
argument_list|)
operator|==
literal|0
operator|)
operator|)
operator|||
operator|(
name|do_debug_pubnames
operator|&&
operator|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"pubnames"
argument_list|)
operator|==
literal|0
operator|)
operator|)
operator|||
operator|(
name|do_debug_aranges
operator|&&
operator|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"aranges"
argument_list|)
operator|==
literal|0
operator|)
operator|)
operator|||
operator|(
name|do_debug_frames
operator|&&
operator|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"frame"
argument_list|)
operator|==
literal|0
operator|)
operator|)
operator|||
operator|(
name|do_debug_macinfo
operator|&&
operator|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"macinfo"
argument_list|)
operator|==
literal|0
operator|)
operator|)
operator|||
operator|(
name|do_debug_str
operator|&&
operator|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"str"
argument_list|)
operator|==
literal|0
operator|)
operator|)
operator|||
operator|(
name|do_debug_loc
operator|&&
operator|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"loc"
argument_list|)
operator|==
literal|0
operator|)
operator|)
condition|)
name|request_dump
argument_list|(
name|i
argument_list|,
name|DEBUG_DUMP
argument_list|)
expr_stmt|;
block|}
comment|/* linkonce section to be combined with .debug_info at link time.  */
elseif|else
if|if
condition|(
operator|(
name|do_debugging
operator|||
name|do_debug_info
operator|)
operator|&&
name|strncmp
argument_list|(
name|name
argument_list|,
literal|".gnu.linkonce.wi."
argument_list|,
literal|17
argument_list|)
operator|==
literal|0
condition|)
name|request_dump
argument_list|(
name|i
argument_list|,
name|DEBUG_DUMP
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|do_debug_frames
operator|&&
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".eh_frame"
argument_list|)
operator|==
literal|0
condition|)
name|request_dump
argument_list|(
name|i
argument_list|,
name|DEBUG_DUMP
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|do_sections
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|elf_header
operator|.
name|e_shnum
operator|>
literal|1
condition|)
name|printf
argument_list|(
name|_
argument_list|(
literal|"\nSection Headers:\n"
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
name|_
argument_list|(
literal|"\nSection Header:\n"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_32bit_elf
condition|)
name|printf
argument_list|(
name|_
argument_list|(
literal|"  [Nr] Name              Type            Addr     Off    Size   ES Flg Lk Inf Al\n"
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|do_wide
condition|)
name|printf
argument_list|(
name|_
argument_list|(
literal|"  [Nr] Name              Type            Address          Off    Size   ES Flg Lk Inf Al\n"
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|printf
argument_list|(
name|_
argument_list|(
literal|"  [Nr] Name              Type             Address           Offset\n"
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"       Size              EntSize          Flags  Link  Info  Align\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|section
operator|=
name|section_headers
init|;
name|i
operator|<
name|elf_header
operator|.
name|e_shnum
condition|;
name|i
operator|++
operator|,
name|section
operator|++
control|)
block|{
name|printf
argument_list|(
literal|"  [%2u] %-17.17s %-15.15s "
argument_list|,
name|SECTION_HEADER_NUM
argument_list|(
name|i
argument_list|)
argument_list|,
name|SECTION_NAME
argument_list|(
name|section
argument_list|)
argument_list|,
name|get_section_type_name
argument_list|(
name|section
operator|->
name|sh_type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_32bit_elf
condition|)
block|{
name|print_vma
argument_list|(
name|section
operator|->
name|sh_addr
argument_list|,
name|LONG_HEX
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %6.6lx %6.6lx %2.2lx"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|section
operator|->
name|sh_offset
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|section
operator|->
name|sh_size
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|section
operator|->
name|sh_entsize
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %3s "
argument_list|,
name|get_elf_section_flags
argument_list|(
name|section
operator|->
name|sh_flags
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%2ld %3lx %2ld\n"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|section
operator|->
name|sh_link
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|section
operator|->
name|sh_info
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|section
operator|->
name|sh_addralign
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|do_wide
condition|)
block|{
name|print_vma
argument_list|(
name|section
operator|->
name|sh_addr
argument_list|,
name|LONG_HEX
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|long
operator|)
name|section
operator|->
name|sh_offset
operator|==
name|section
operator|->
name|sh_offset
condition|)
name|printf
argument_list|(
literal|" %6.6lx"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|section
operator|->
name|sh_offset
argument_list|)
expr_stmt|;
else|else
block|{
name|putchar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|print_vma
argument_list|(
name|section
operator|->
name|sh_offset
argument_list|,
name|LONG_HEX
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|unsigned
name|long
operator|)
name|section
operator|->
name|sh_size
operator|==
name|section
operator|->
name|sh_size
condition|)
name|printf
argument_list|(
literal|" %6.6lx"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|section
operator|->
name|sh_size
argument_list|)
expr_stmt|;
else|else
block|{
name|putchar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|print_vma
argument_list|(
name|section
operator|->
name|sh_size
argument_list|,
name|LONG_HEX
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|unsigned
name|long
operator|)
name|section
operator|->
name|sh_entsize
operator|==
name|section
operator|->
name|sh_entsize
condition|)
name|printf
argument_list|(
literal|" %2.2lx"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|section
operator|->
name|sh_entsize
argument_list|)
expr_stmt|;
else|else
block|{
name|putchar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|print_vma
argument_list|(
name|section
operator|->
name|sh_entsize
argument_list|,
name|LONG_HEX
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|" %3s "
argument_list|,
name|get_elf_section_flags
argument_list|(
name|section
operator|->
name|sh_flags
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%2ld %3lx "
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|section
operator|->
name|sh_link
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|section
operator|->
name|sh_info
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|unsigned
name|long
operator|)
name|section
operator|->
name|sh_addralign
operator|==
name|section
operator|->
name|sh_addralign
condition|)
name|printf
argument_list|(
literal|"%2ld\n"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|section
operator|->
name|sh_addralign
argument_list|)
expr_stmt|;
else|else
block|{
name|print_vma
argument_list|(
name|section
operator|->
name|sh_addralign
argument_list|,
name|DEC
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|putchar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|print_vma
argument_list|(
name|section
operator|->
name|sh_addr
argument_list|,
name|LONG_HEX
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|long
operator|)
name|section
operator|->
name|sh_offset
operator|==
name|section
operator|->
name|sh_offset
condition|)
name|printf
argument_list|(
literal|"  %8.8lx"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|section
operator|->
name|sh_offset
argument_list|)
expr_stmt|;
else|else
block|{
name|printf
argument_list|(
literal|"  "
argument_list|)
expr_stmt|;
name|print_vma
argument_list|(
name|section
operator|->
name|sh_offset
argument_list|,
name|LONG_HEX
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n       "
argument_list|)
expr_stmt|;
name|print_vma
argument_list|(
name|section
operator|->
name|sh_size
argument_list|,
name|LONG_HEX
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  "
argument_list|)
expr_stmt|;
name|print_vma
argument_list|(
name|section
operator|->
name|sh_entsize
argument_list|,
name|LONG_HEX
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %3s "
argument_list|,
name|get_elf_section_flags
argument_list|(
name|section
operator|->
name|sh_flags
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"     %2ld   %3lx     %ld\n"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|section
operator|->
name|sh_link
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|section
operator|->
name|sh_info
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|section
operator|->
name|sh_addralign
argument_list|)
expr_stmt|;
block|}
block|}
name|printf
argument_list|(
name|_
argument_list|(
literal|"Key to Flags:\n\   W (write), A (alloc), X (execute), M (merge), S (strings)\n\   I (info), L (link order), G (group), x (unknown)\n\   O (extra OS processing required) o (OS specific), p (processor specific)\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_struct
struct|struct
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|reloc
decl_stmt|;
name|int
name|size
decl_stmt|;
name|int
name|rela
decl_stmt|;
block|}
name|dynamic_relocations
index|[]
init|=
block|{
block|{
literal|"REL"
block|,
name|DT_REL
block|,
name|DT_RELSZ
block|,
name|FALSE
block|}
block|,
block|{
literal|"RELA"
block|,
name|DT_RELA
block|,
name|DT_RELASZ
block|,
name|TRUE
block|}
block|,
block|{
literal|"PLT"
block|,
name|DT_JMPREL
block|,
name|DT_PLTRELSZ
block|,
name|UNKNOWN
block|}
block|}
struct|;
end_struct

begin_comment
comment|/* Process the reloc section.  */
end_comment

begin_function
specifier|static
name|int
name|process_relocs
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|)
block|{
name|unsigned
name|long
name|rel_size
decl_stmt|;
name|unsigned
name|long
name|rel_offset
decl_stmt|;
if|if
condition|(
operator|!
name|do_reloc
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|do_using_dynamic
condition|)
block|{
name|int
name|is_rela
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|has_dynamic_reloc
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|has_dynamic_reloc
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|dynamic_relocations
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|is_rela
operator|=
name|dynamic_relocations
index|[
name|i
index|]
operator|.
name|rela
expr_stmt|;
name|name
operator|=
name|dynamic_relocations
index|[
name|i
index|]
operator|.
name|name
expr_stmt|;
name|rel_size
operator|=
name|dynamic_info
index|[
name|dynamic_relocations
index|[
name|i
index|]
operator|.
name|size
index|]
expr_stmt|;
name|rel_offset
operator|=
name|dynamic_info
index|[
name|dynamic_relocations
index|[
name|i
index|]
operator|.
name|reloc
index|]
expr_stmt|;
name|has_dynamic_reloc
operator||=
name|rel_size
expr_stmt|;
if|if
condition|(
name|is_rela
operator|==
name|UNKNOWN
condition|)
block|{
if|if
condition|(
name|dynamic_relocations
index|[
name|i
index|]
operator|.
name|reloc
operator|==
name|DT_JMPREL
condition|)
switch|switch
condition|(
name|dynamic_info
index|[
name|DT_PLTREL
index|]
condition|)
block|{
case|case
name|DT_REL
case|:
name|is_rela
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
name|DT_RELA
case|:
name|is_rela
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|rel_size
condition|)
block|{
name|printf
argument_list|(
name|_
argument_list|(
literal|"\n'%s' relocation section at offset 0x%lx contains %ld bytes:\n"
argument_list|)
argument_list|,
name|name
argument_list|,
name|rel_offset
argument_list|,
name|rel_size
argument_list|)
expr_stmt|;
name|dump_relocations
argument_list|(
name|file
argument_list|,
name|offset_from_vma
argument_list|(
name|file
argument_list|,
name|rel_offset
argument_list|,
name|rel_size
argument_list|)
argument_list|,
name|rel_size
argument_list|,
name|dynamic_symbols
argument_list|,
name|num_dynamic_syms
argument_list|,
name|dynamic_strings
argument_list|,
name|is_rela
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|has_dynamic_reloc
condition|)
name|printf
argument_list|(
name|_
argument_list|(
literal|"\nThere are no dynamic relocations in this file.\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Elf_Internal_Shdr
modifier|*
name|section
decl_stmt|;
name|unsigned
name|long
name|i
decl_stmt|;
name|int
name|found
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|section
operator|=
name|section_headers
init|;
name|i
operator|<
name|elf_header
operator|.
name|e_shnum
condition|;
name|i
operator|++
operator|,
name|section
operator|++
control|)
block|{
if|if
condition|(
name|section
operator|->
name|sh_type
operator|!=
name|SHT_RELA
operator|&&
name|section
operator|->
name|sh_type
operator|!=
name|SHT_REL
condition|)
continue|continue;
name|rel_offset
operator|=
name|section
operator|->
name|sh_offset
expr_stmt|;
name|rel_size
operator|=
name|section
operator|->
name|sh_size
expr_stmt|;
if|if
condition|(
name|rel_size
condition|)
block|{
name|Elf_Internal_Shdr
modifier|*
name|strsec
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|symtab
decl_stmt|;
name|char
modifier|*
name|strtab
decl_stmt|;
name|int
name|is_rela
decl_stmt|;
name|unsigned
name|long
name|nsyms
decl_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"\nRelocation section "
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|string_table
operator|==
name|NULL
condition|)
name|printf
argument_list|(
literal|"%d"
argument_list|,
name|section
operator|->
name|sh_name
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
name|_
argument_list|(
literal|"'%s'"
argument_list|)
argument_list|,
name|SECTION_NAME
argument_list|(
name|section
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|" at offset 0x%lx contains %lu entries:\n"
argument_list|)
argument_list|,
name|rel_offset
argument_list|,
call|(
name|unsigned
name|long
call|)
argument_list|(
name|rel_size
operator|/
name|section
operator|->
name|sh_entsize
argument_list|)
argument_list|)
expr_stmt|;
name|symtab
operator|=
name|NULL
expr_stmt|;
name|strtab
operator|=
name|NULL
expr_stmt|;
name|nsyms
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|section
operator|->
name|sh_link
condition|)
block|{
name|Elf_Internal_Shdr
modifier|*
name|symsec
decl_stmt|;
name|symsec
operator|=
name|SECTION_HEADER
argument_list|(
name|section
operator|->
name|sh_link
argument_list|)
expr_stmt|;
name|nsyms
operator|=
name|symsec
operator|->
name|sh_size
operator|/
name|symsec
operator|->
name|sh_entsize
expr_stmt|;
name|symtab
operator|=
name|GET_ELF_SYMBOLS
argument_list|(
name|file
argument_list|,
name|symsec
argument_list|)
expr_stmt|;
if|if
condition|(
name|symtab
operator|==
name|NULL
condition|)
continue|continue;
name|strsec
operator|=
name|SECTION_HEADER
argument_list|(
name|symsec
operator|->
name|sh_link
argument_list|)
expr_stmt|;
name|strtab
operator|=
name|get_data
argument_list|(
name|NULL
argument_list|,
name|file
argument_list|,
name|strsec
operator|->
name|sh_offset
argument_list|,
name|strsec
operator|->
name|sh_size
argument_list|,
name|_
argument_list|(
literal|"string table"
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|is_rela
operator|=
name|section
operator|->
name|sh_type
operator|==
name|SHT_RELA
expr_stmt|;
name|dump_relocations
argument_list|(
name|file
argument_list|,
name|rel_offset
argument_list|,
name|rel_size
argument_list|,
name|symtab
argument_list|,
name|nsyms
argument_list|,
name|strtab
argument_list|,
name|is_rela
argument_list|)
expr_stmt|;
if|if
condition|(
name|strtab
condition|)
name|free
argument_list|(
name|strtab
argument_list|)
expr_stmt|;
if|if
condition|(
name|symtab
condition|)
name|free
argument_list|(
name|symtab
argument_list|)
expr_stmt|;
name|found
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|found
condition|)
name|printf
argument_list|(
name|_
argument_list|(
literal|"\nThere are no relocations in this file.\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_include
include|#
directive|include
file|"unwind-ia64.h"
end_include

begin_comment
comment|/* An absolute address consists of a section and an offset.  If the    section is NULL, the offset itself is the address, otherwise, the    address equals to LOAD_ADDRESS(section) + offset.  */
end_comment

begin_struct
struct|struct
name|absaddr
block|{
name|unsigned
name|short
name|section
decl_stmt|;
name|bfd_vma
name|offset
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|unw_aux_info
block|{
struct|struct
name|unw_table_entry
block|{
name|struct
name|absaddr
name|start
decl_stmt|;
name|struct
name|absaddr
name|end
decl_stmt|;
name|struct
name|absaddr
name|info
decl_stmt|;
block|}
modifier|*
name|table
struct|;
comment|/* Unwind table.  */
name|unsigned
name|long
name|table_len
decl_stmt|;
comment|/* Length of unwind table.  */
name|unsigned
name|char
modifier|*
name|info
decl_stmt|;
comment|/* Unwind info.  */
name|unsigned
name|long
name|info_size
decl_stmt|;
comment|/* Size of unwind info.  */
name|bfd_vma
name|info_addr
decl_stmt|;
comment|/* starting address of unwind info.  */
name|bfd_vma
name|seg_base
decl_stmt|;
comment|/* Starting address of segment.  */
name|Elf_Internal_Sym
modifier|*
name|symtab
decl_stmt|;
comment|/* The symbol table.  */
name|unsigned
name|long
name|nsyms
decl_stmt|;
comment|/* Number of symbols.  */
name|char
modifier|*
name|strtab
decl_stmt|;
comment|/* The string table.  */
name|unsigned
name|long
name|strtab_size
decl_stmt|;
comment|/* Size of string table.  */
block|}
struct|;
end_struct

begin_function
specifier|static
name|void
name|find_symbol_for_address
parameter_list|(
name|struct
name|unw_aux_info
modifier|*
name|aux
parameter_list|,
name|struct
name|absaddr
name|addr
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|symname
parameter_list|,
name|bfd_vma
modifier|*
name|offset
parameter_list|)
block|{
name|bfd_vma
name|dist
init|=
literal|0x100000
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|sym
decl_stmt|,
modifier|*
name|best
init|=
name|NULL
decl_stmt|;
name|unsigned
name|long
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|sym
operator|=
name|aux
operator|->
name|symtab
init|;
name|i
operator|<
name|aux
operator|->
name|nsyms
condition|;
operator|++
name|i
operator|,
operator|++
name|sym
control|)
block|{
if|if
condition|(
name|ELF_ST_TYPE
argument_list|(
name|sym
operator|->
name|st_info
argument_list|)
operator|==
name|STT_FUNC
operator|&&
name|sym
operator|->
name|st_name
operator|!=
literal|0
operator|&&
operator|(
name|addr
operator|.
name|section
operator|==
name|SHN_UNDEF
operator|||
name|addr
operator|.
name|section
operator|==
name|sym
operator|->
name|st_shndx
operator|)
operator|&&
name|addr
operator|.
name|offset
operator|>=
name|sym
operator|->
name|st_value
operator|&&
name|addr
operator|.
name|offset
operator|-
name|sym
operator|->
name|st_value
operator|<
name|dist
condition|)
block|{
name|best
operator|=
name|sym
expr_stmt|;
name|dist
operator|=
name|addr
operator|.
name|offset
operator|-
name|sym
operator|->
name|st_value
expr_stmt|;
if|if
condition|(
operator|!
name|dist
condition|)
break|break;
block|}
block|}
if|if
condition|(
name|best
condition|)
block|{
operator|*
name|symname
operator|=
operator|(
name|best
operator|->
name|st_name
operator|>=
name|aux
operator|->
name|strtab_size
condition|?
literal|"<corrupt>"
else|:
name|aux
operator|->
name|strtab
operator|+
name|best
operator|->
name|st_name
operator|)
expr_stmt|;
operator|*
name|offset
operator|=
name|dist
expr_stmt|;
return|return;
block|}
operator|*
name|symname
operator|=
name|NULL
expr_stmt|;
operator|*
name|offset
operator|=
name|addr
operator|.
name|offset
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dump_ia64_unwind
parameter_list|(
name|struct
name|unw_aux_info
modifier|*
name|aux
parameter_list|)
block|{
name|bfd_vma
name|addr_size
decl_stmt|;
name|struct
name|unw_table_entry
modifier|*
name|tp
decl_stmt|;
name|int
name|in_body
decl_stmt|;
name|addr_size
operator|=
name|is_32bit_elf
condition|?
literal|4
else|:
literal|8
expr_stmt|;
for|for
control|(
name|tp
operator|=
name|aux
operator|->
name|table
init|;
name|tp
operator|<
name|aux
operator|->
name|table
operator|+
name|aux
operator|->
name|table_len
condition|;
operator|++
name|tp
control|)
block|{
name|bfd_vma
name|stamp
decl_stmt|;
name|bfd_vma
name|offset
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|dp
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|head
decl_stmt|;
specifier|const
name|char
modifier|*
name|procname
decl_stmt|;
name|find_symbol_for_address
argument_list|(
name|aux
argument_list|,
name|tp
operator|->
name|start
argument_list|,
operator|&
name|procname
argument_list|,
operator|&
name|offset
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"\n<"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|procname
condition|)
block|{
name|fputs
argument_list|(
name|procname
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
condition|)
name|printf
argument_list|(
literal|"+%lx"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|offset
argument_list|)
expr_stmt|;
block|}
name|fputs
argument_list|(
literal|">: ["
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|print_vma
argument_list|(
name|tp
operator|->
name|start
operator|.
name|offset
argument_list|,
name|PREFIX_HEX
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'-'
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|print_vma
argument_list|(
name|tp
operator|->
name|end
operator|.
name|offset
argument_list|,
name|PREFIX_HEX
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"], info at +0x%lx\n"
argument_list|,
call|(
name|unsigned
name|long
call|)
argument_list|(
name|tp
operator|->
name|info
operator|.
name|offset
operator|-
name|aux
operator|->
name|seg_base
argument_list|)
argument_list|)
expr_stmt|;
name|head
operator|=
name|aux
operator|->
name|info
operator|+
operator|(
name|tp
operator|->
name|info
operator|.
name|offset
operator|-
name|aux
operator|->
name|info_addr
operator|)
expr_stmt|;
name|stamp
operator|=
name|BYTE_GET8
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|head
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  v%u, flags=0x%lx (%s%s), len=%lu bytes\n"
argument_list|,
operator|(
name|unsigned
operator|)
name|UNW_VER
argument_list|(
name|stamp
argument_list|)
argument_list|,
call|(
name|unsigned
name|long
call|)
argument_list|(
operator|(
name|stamp
operator|&
name|UNW_FLAG_MASK
operator|)
operator|>>
literal|32
argument_list|)
argument_list|,
name|UNW_FLAG_EHANDLER
argument_list|(
name|stamp
argument_list|)
condition|?
literal|" ehandler"
else|:
literal|""
argument_list|,
name|UNW_FLAG_UHANDLER
argument_list|(
name|stamp
argument_list|)
condition|?
literal|" uhandler"
else|:
literal|""
argument_list|,
call|(
name|unsigned
name|long
call|)
argument_list|(
name|addr_size
operator|*
name|UNW_LENGTH
argument_list|(
name|stamp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|UNW_VER
argument_list|(
name|stamp
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"\tUnknown version.\n"
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|in_body
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|dp
operator|=
name|head
operator|+
literal|8
init|;
name|dp
operator|<
name|head
operator|+
literal|8
operator|+
name|addr_size
operator|*
name|UNW_LENGTH
argument_list|(
name|stamp
argument_list|)
condition|;
control|)
name|dp
operator|=
name|unw_decode
argument_list|(
name|dp
argument_list|,
name|in_body
argument_list|,
operator|&
name|in_body
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|slurp_ia64_unwind_table
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
name|struct
name|unw_aux_info
modifier|*
name|aux
parameter_list|,
name|Elf_Internal_Shdr
modifier|*
name|sec
parameter_list|)
block|{
name|unsigned
name|long
name|size
decl_stmt|,
name|addr_size
decl_stmt|,
name|nrelas
decl_stmt|,
name|i
decl_stmt|;
name|Elf_Internal_Phdr
modifier|*
name|seg
decl_stmt|;
name|struct
name|unw_table_entry
modifier|*
name|tep
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|relsec
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|rela
decl_stmt|,
modifier|*
name|rp
decl_stmt|;
name|unsigned
name|char
modifier|*
name|table
decl_stmt|,
modifier|*
name|tp
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|sym
decl_stmt|;
specifier|const
name|char
modifier|*
name|relname
decl_stmt|;
name|addr_size
operator|=
name|is_32bit_elf
condition|?
literal|4
else|:
literal|8
expr_stmt|;
comment|/* First, find the starting address of the segment that includes      this section: */
if|if
condition|(
name|elf_header
operator|.
name|e_phnum
condition|)
block|{
if|if
condition|(
operator|!
name|get_program_headers
argument_list|(
name|file
argument_list|)
condition|)
return|return
literal|0
return|;
for|for
control|(
name|seg
operator|=
name|program_headers
init|;
name|seg
operator|<
name|program_headers
operator|+
name|elf_header
operator|.
name|e_phnum
condition|;
operator|++
name|seg
control|)
block|{
if|if
condition|(
name|seg
operator|->
name|p_type
operator|!=
name|PT_LOAD
condition|)
continue|continue;
if|if
condition|(
name|sec
operator|->
name|sh_addr
operator|>=
name|seg
operator|->
name|p_vaddr
operator|&&
operator|(
name|sec
operator|->
name|sh_addr
operator|+
name|sec
operator|->
name|sh_size
operator|<=
name|seg
operator|->
name|p_vaddr
operator|+
name|seg
operator|->
name|p_memsz
operator|)
condition|)
block|{
name|aux
operator|->
name|seg_base
operator|=
name|seg
operator|->
name|p_vaddr
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|/* Second, build the unwind table from the contents of the unwind section:  */
name|size
operator|=
name|sec
operator|->
name|sh_size
expr_stmt|;
name|table
operator|=
name|get_data
argument_list|(
name|NULL
argument_list|,
name|file
argument_list|,
name|sec
operator|->
name|sh_offset
argument_list|,
name|size
argument_list|,
name|_
argument_list|(
literal|"unwind table"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|table
condition|)
return|return
literal|0
return|;
name|tep
operator|=
name|aux
operator|->
name|table
operator|=
name|xmalloc
argument_list|(
name|size
operator|/
operator|(
literal|3
operator|*
name|addr_size
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|aux
operator|->
name|table
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|tp
operator|=
name|table
init|;
name|tp
operator|<
name|table
operator|+
name|size
condition|;
name|tp
operator|+=
literal|3
operator|*
name|addr_size
operator|,
operator|++
name|tep
control|)
block|{
name|tep
operator|->
name|start
operator|.
name|section
operator|=
name|SHN_UNDEF
expr_stmt|;
name|tep
operator|->
name|end
operator|.
name|section
operator|=
name|SHN_UNDEF
expr_stmt|;
name|tep
operator|->
name|info
operator|.
name|section
operator|=
name|SHN_UNDEF
expr_stmt|;
if|if
condition|(
name|is_32bit_elf
condition|)
block|{
name|tep
operator|->
name|start
operator|.
name|offset
operator|=
name|byte_get
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|tp
operator|+
literal|0
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|tep
operator|->
name|end
operator|.
name|offset
operator|=
name|byte_get
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|tp
operator|+
literal|4
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|tep
operator|->
name|info
operator|.
name|offset
operator|=
name|byte_get
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|tp
operator|+
literal|8
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tep
operator|->
name|start
operator|.
name|offset
operator|=
name|BYTE_GET8
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|tp
operator|+
literal|0
argument_list|)
expr_stmt|;
name|tep
operator|->
name|end
operator|.
name|offset
operator|=
name|BYTE_GET8
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|tp
operator|+
literal|8
argument_list|)
expr_stmt|;
name|tep
operator|->
name|info
operator|.
name|offset
operator|=
name|BYTE_GET8
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|tp
operator|+
literal|16
argument_list|)
expr_stmt|;
block|}
name|tep
operator|->
name|start
operator|.
name|offset
operator|+=
name|aux
operator|->
name|seg_base
expr_stmt|;
name|tep
operator|->
name|end
operator|.
name|offset
operator|+=
name|aux
operator|->
name|seg_base
expr_stmt|;
name|tep
operator|->
name|info
operator|.
name|offset
operator|+=
name|aux
operator|->
name|seg_base
expr_stmt|;
block|}
name|free
argument_list|(
name|table
argument_list|)
expr_stmt|;
comment|/* Third, apply any relocations to the unwind table: */
for|for
control|(
name|relsec
operator|=
name|section_headers
init|;
name|relsec
operator|<
name|section_headers
operator|+
name|elf_header
operator|.
name|e_shnum
condition|;
operator|++
name|relsec
control|)
block|{
if|if
condition|(
name|relsec
operator|->
name|sh_type
operator|!=
name|SHT_RELA
operator|||
name|SECTION_HEADER
argument_list|(
name|relsec
operator|->
name|sh_info
argument_list|)
operator|!=
name|sec
condition|)
continue|continue;
if|if
condition|(
operator|!
name|slurp_rela_relocs
argument_list|(
name|file
argument_list|,
name|relsec
operator|->
name|sh_offset
argument_list|,
name|relsec
operator|->
name|sh_size
argument_list|,
operator|&
name|rela
argument_list|,
operator|&
name|nrelas
argument_list|)
condition|)
return|return
literal|0
return|;
for|for
control|(
name|rp
operator|=
name|rela
init|;
name|rp
operator|<
name|rela
operator|+
name|nrelas
condition|;
operator|++
name|rp
control|)
block|{
if|if
condition|(
name|is_32bit_elf
condition|)
block|{
name|relname
operator|=
name|elf_ia64_reloc_type
argument_list|(
name|ELF32_R_TYPE
argument_list|(
name|rp
operator|->
name|r_info
argument_list|)
argument_list|)
expr_stmt|;
name|sym
operator|=
name|aux
operator|->
name|symtab
operator|+
name|ELF32_R_SYM
argument_list|(
name|rp
operator|->
name|r_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|ELF32_ST_TYPE
argument_list|(
name|sym
operator|->
name|st_info
argument_list|)
operator|!=
name|STT_SECTION
condition|)
block|{
name|warn
argument_list|(
name|_
argument_list|(
literal|"Skipping unexpected symbol type %u\n"
argument_list|)
argument_list|,
name|ELF32_ST_TYPE
argument_list|(
name|sym
operator|->
name|st_info
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
else|else
block|{
name|relname
operator|=
name|elf_ia64_reloc_type
argument_list|(
name|ELF64_R_TYPE
argument_list|(
name|rp
operator|->
name|r_info
argument_list|)
argument_list|)
expr_stmt|;
name|sym
operator|=
name|aux
operator|->
name|symtab
operator|+
name|ELF64_R_SYM
argument_list|(
name|rp
operator|->
name|r_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|ELF64_ST_TYPE
argument_list|(
name|sym
operator|->
name|st_info
argument_list|)
operator|!=
name|STT_SECTION
condition|)
block|{
name|warn
argument_list|(
name|_
argument_list|(
literal|"Skipping unexpected symbol type %u\n"
argument_list|)
argument_list|,
name|ELF64_ST_TYPE
argument_list|(
name|sym
operator|->
name|st_info
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
if|if
condition|(
name|strncmp
argument_list|(
name|relname
argument_list|,
literal|"R_IA64_SEGREL"
argument_list|,
literal|13
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|warn
argument_list|(
name|_
argument_list|(
literal|"Skipping unexpected relocation type %s\n"
argument_list|)
argument_list|,
name|relname
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|i
operator|=
name|rp
operator|->
name|r_offset
operator|/
operator|(
literal|3
operator|*
name|addr_size
operator|)
expr_stmt|;
switch|switch
condition|(
name|rp
operator|->
name|r_offset
operator|/
name|addr_size
operator|%
literal|3
condition|)
block|{
case|case
literal|0
case|:
name|aux
operator|->
name|table
index|[
name|i
index|]
operator|.
name|start
operator|.
name|section
operator|=
name|sym
operator|->
name|st_shndx
expr_stmt|;
name|aux
operator|->
name|table
index|[
name|i
index|]
operator|.
name|start
operator|.
name|offset
operator|+=
name|rp
operator|->
name|r_addend
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|aux
operator|->
name|table
index|[
name|i
index|]
operator|.
name|end
operator|.
name|section
operator|=
name|sym
operator|->
name|st_shndx
expr_stmt|;
name|aux
operator|->
name|table
index|[
name|i
index|]
operator|.
name|end
operator|.
name|offset
operator|+=
name|rp
operator|->
name|r_addend
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|aux
operator|->
name|table
index|[
name|i
index|]
operator|.
name|info
operator|.
name|section
operator|=
name|sym
operator|->
name|st_shndx
expr_stmt|;
name|aux
operator|->
name|table
index|[
name|i
index|]
operator|.
name|info
operator|.
name|offset
operator|+=
name|rp
operator|->
name|r_addend
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
name|free
argument_list|(
name|rela
argument_list|)
expr_stmt|;
block|}
name|aux
operator|->
name|table_len
operator|=
name|size
operator|/
operator|(
literal|3
operator|*
name|addr_size
operator|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|process_unwind
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|)
block|{
name|Elf_Internal_Shdr
modifier|*
name|sec
decl_stmt|,
modifier|*
name|unwsec
init|=
name|NULL
decl_stmt|,
modifier|*
name|strsec
decl_stmt|;
name|unsigned
name|long
name|i
decl_stmt|,
name|addr_size
decl_stmt|,
name|unwcount
init|=
literal|0
decl_stmt|,
name|unwstart
init|=
literal|0
decl_stmt|;
name|struct
name|unw_aux_info
name|aux
decl_stmt|;
if|if
condition|(
operator|!
name|do_unwind
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|elf_header
operator|.
name|e_machine
operator|!=
name|EM_IA_64
condition|)
block|{
name|printf
argument_list|(
name|_
argument_list|(
literal|"\nThere are no unwind sections in this file.\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|memset
argument_list|(
operator|&
name|aux
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|aux
argument_list|)
argument_list|)
expr_stmt|;
name|addr_size
operator|=
name|is_32bit_elf
condition|?
literal|4
else|:
literal|8
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|sec
operator|=
name|section_headers
init|;
name|i
operator|<
name|elf_header
operator|.
name|e_shnum
condition|;
operator|++
name|i
operator|,
operator|++
name|sec
control|)
block|{
if|if
condition|(
name|sec
operator|->
name|sh_type
operator|==
name|SHT_SYMTAB
condition|)
block|{
name|aux
operator|.
name|nsyms
operator|=
name|sec
operator|->
name|sh_size
operator|/
name|sec
operator|->
name|sh_entsize
expr_stmt|;
name|aux
operator|.
name|symtab
operator|=
name|GET_ELF_SYMBOLS
argument_list|(
name|file
argument_list|,
name|sec
argument_list|)
expr_stmt|;
name|strsec
operator|=
name|SECTION_HEADER
argument_list|(
name|sec
operator|->
name|sh_link
argument_list|)
expr_stmt|;
name|aux
operator|.
name|strtab_size
operator|=
name|strsec
operator|->
name|sh_size
expr_stmt|;
name|aux
operator|.
name|strtab
operator|=
name|get_data
argument_list|(
name|NULL
argument_list|,
name|file
argument_list|,
name|strsec
operator|->
name|sh_offset
argument_list|,
name|aux
operator|.
name|strtab_size
argument_list|,
name|_
argument_list|(
literal|"string table"
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sec
operator|->
name|sh_type
operator|==
name|SHT_IA_64_UNWIND
condition|)
name|unwcount
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|unwcount
condition|)
name|printf
argument_list|(
name|_
argument_list|(
literal|"\nThere are no unwind sections in this file.\n"
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|unwcount
operator|--
operator|>
literal|0
condition|)
block|{
name|char
modifier|*
name|suffix
decl_stmt|;
name|size_t
name|len
decl_stmt|,
name|len2
decl_stmt|;
for|for
control|(
name|i
operator|=
name|unwstart
operator|,
name|sec
operator|=
name|section_headers
operator|+
name|unwstart
init|;
name|i
operator|<
name|elf_header
operator|.
name|e_shnum
condition|;
operator|++
name|i
operator|,
operator|++
name|sec
control|)
if|if
condition|(
name|sec
operator|->
name|sh_type
operator|==
name|SHT_IA_64_UNWIND
condition|)
block|{
name|unwsec
operator|=
name|sec
expr_stmt|;
break|break;
block|}
name|unwstart
operator|=
name|i
operator|+
literal|1
expr_stmt|;
name|len
operator|=
sizeof|sizeof
argument_list|(
name|ELF_STRING_ia64_unwind_once
argument_list|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|SECTION_NAME
argument_list|(
name|unwsec
argument_list|)
argument_list|,
name|ELF_STRING_ia64_unwind_once
argument_list|,
name|len
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* .gnu.linkonce.ia64unw.FOO -> .gnu.linkonce.ia64unwi.FOO */
name|len2
operator|=
sizeof|sizeof
argument_list|(
name|ELF_STRING_ia64_unwind_info_once
argument_list|)
operator|-
literal|1
expr_stmt|;
name|suffix
operator|=
name|SECTION_NAME
argument_list|(
name|unwsec
argument_list|)
operator|+
name|len
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|sec
operator|=
name|section_headers
init|;
name|i
operator|<
name|elf_header
operator|.
name|e_shnum
condition|;
operator|++
name|i
operator|,
operator|++
name|sec
control|)
if|if
condition|(
name|strncmp
argument_list|(
name|SECTION_NAME
argument_list|(
name|sec
argument_list|)
argument_list|,
name|ELF_STRING_ia64_unwind_info_once
argument_list|,
name|len2
argument_list|)
operator|==
literal|0
operator|&&
name|strcmp
argument_list|(
name|SECTION_NAME
argument_list|(
name|sec
argument_list|)
operator|+
name|len2
argument_list|,
name|suffix
argument_list|)
operator|==
literal|0
condition|)
break|break;
block|}
else|else
block|{
comment|/* .IA_64.unwindFOO -> .IA_64.unwind_infoFOO 	     .IA_64.unwind or BAR -> .IA_64.unwind_info */
name|len
operator|=
sizeof|sizeof
argument_list|(
name|ELF_STRING_ia64_unwind
argument_list|)
operator|-
literal|1
expr_stmt|;
name|len2
operator|=
sizeof|sizeof
argument_list|(
name|ELF_STRING_ia64_unwind_info
argument_list|)
operator|-
literal|1
expr_stmt|;
name|suffix
operator|=
literal|""
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|SECTION_NAME
argument_list|(
name|unwsec
argument_list|)
argument_list|,
name|ELF_STRING_ia64_unwind
argument_list|,
name|len
argument_list|)
operator|==
literal|0
condition|)
name|suffix
operator|=
name|SECTION_NAME
argument_list|(
name|unwsec
argument_list|)
operator|+
name|len
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|sec
operator|=
name|section_headers
init|;
name|i
operator|<
name|elf_header
operator|.
name|e_shnum
condition|;
operator|++
name|i
operator|,
operator|++
name|sec
control|)
if|if
condition|(
name|strncmp
argument_list|(
name|SECTION_NAME
argument_list|(
name|sec
argument_list|)
argument_list|,
name|ELF_STRING_ia64_unwind_info
argument_list|,
name|len2
argument_list|)
operator|==
literal|0
operator|&&
name|strcmp
argument_list|(
name|SECTION_NAME
argument_list|(
name|sec
argument_list|)
operator|+
name|len2
argument_list|,
name|suffix
argument_list|)
operator|==
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|==
name|elf_header
operator|.
name|e_shnum
condition|)
block|{
name|printf
argument_list|(
name|_
argument_list|(
literal|"\nCould not find unwind info section for "
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|string_table
operator|==
name|NULL
condition|)
name|printf
argument_list|(
literal|"%d"
argument_list|,
name|unwsec
operator|->
name|sh_name
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
name|_
argument_list|(
literal|"'%s'"
argument_list|)
argument_list|,
name|SECTION_NAME
argument_list|(
name|unwsec
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|aux
operator|.
name|info_size
operator|=
name|sec
operator|->
name|sh_size
expr_stmt|;
name|aux
operator|.
name|info_addr
operator|=
name|sec
operator|->
name|sh_addr
expr_stmt|;
name|aux
operator|.
name|info
operator|=
name|get_data
argument_list|(
name|NULL
argument_list|,
name|file
argument_list|,
name|sec
operator|->
name|sh_offset
argument_list|,
name|aux
operator|.
name|info_size
argument_list|,
name|_
argument_list|(
literal|"unwind info"
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"\nUnwind section "
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|string_table
operator|==
name|NULL
condition|)
name|printf
argument_list|(
literal|"%d"
argument_list|,
name|unwsec
operator|->
name|sh_name
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
name|_
argument_list|(
literal|"'%s'"
argument_list|)
argument_list|,
name|SECTION_NAME
argument_list|(
name|unwsec
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|" at offset 0x%lx contains %lu entries:\n"
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|unwsec
operator|->
name|sh_offset
argument_list|,
call|(
name|unsigned
name|long
call|)
argument_list|(
name|unwsec
operator|->
name|sh_size
operator|/
operator|(
literal|3
operator|*
name|addr_size
operator|)
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|slurp_ia64_unwind_table
argument_list|(
name|file
argument_list|,
operator|&
name|aux
argument_list|,
name|unwsec
argument_list|)
expr_stmt|;
if|if
condition|(
name|aux
operator|.
name|table_len
operator|>
literal|0
condition|)
name|dump_ia64_unwind
argument_list|(
operator|&
name|aux
argument_list|)
expr_stmt|;
if|if
condition|(
name|aux
operator|.
name|table
condition|)
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|aux
operator|.
name|table
argument_list|)
expr_stmt|;
if|if
condition|(
name|aux
operator|.
name|info
condition|)
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|aux
operator|.
name|info
argument_list|)
expr_stmt|;
name|aux
operator|.
name|table
operator|=
name|NULL
expr_stmt|;
name|aux
operator|.
name|info
operator|=
name|NULL
expr_stmt|;
block|}
block|}
if|if
condition|(
name|aux
operator|.
name|symtab
condition|)
name|free
argument_list|(
name|aux
operator|.
name|symtab
argument_list|)
expr_stmt|;
if|if
condition|(
name|aux
operator|.
name|strtab
condition|)
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|aux
operator|.
name|strtab
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|dynamic_segment_mips_val
parameter_list|(
name|Elf_Internal_Dyn
modifier|*
name|entry
parameter_list|)
block|{
switch|switch
condition|(
name|entry
operator|->
name|d_tag
condition|)
block|{
case|case
name|DT_MIPS_FLAGS
case|:
if|if
condition|(
name|entry
operator|->
name|d_un
operator|.
name|d_val
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"NONE\n"
argument_list|)
expr_stmt|;
else|else
block|{
specifier|static
specifier|const
name|char
modifier|*
name|opts
index|[]
init|=
block|{
literal|"QUICKSTART"
block|,
literal|"NOTPOT"
block|,
literal|"NO_LIBRARY_REPLACEMENT"
block|,
literal|"NO_MOVE"
block|,
literal|"SGI_ONLY"
block|,
literal|"GUARANTEE_INIT"
block|,
literal|"DELTA_C_PLUS_PLUS"
block|,
literal|"GUARANTEE_START_INIT"
block|,
literal|"PIXIE"
block|,
literal|"DEFAULT_DELAY_LOAD"
block|,
literal|"REQUICKSTART"
block|,
literal|"REQUICKSTARTED"
block|,
literal|"CORD"
block|,
literal|"NO_UNRES_UNDEF"
block|,
literal|"RLD_ORDER_SAFE"
block|}
decl_stmt|;
name|unsigned
name|int
name|cnt
decl_stmt|;
name|int
name|first
init|=
literal|1
decl_stmt|;
for|for
control|(
name|cnt
operator|=
literal|0
init|;
name|cnt
operator|<
name|NUM_ELEM
argument_list|(
name|opts
argument_list|)
condition|;
operator|++
name|cnt
control|)
if|if
condition|(
name|entry
operator|->
name|d_un
operator|.
name|d_val
operator|&
operator|(
literal|1
operator|<<
name|cnt
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"%s%s"
argument_list|,
name|first
condition|?
literal|""
else|:
literal|" "
argument_list|,
name|opts
index|[
name|cnt
index|]
argument_list|)
expr_stmt|;
name|first
operator|=
literal|0
expr_stmt|;
block|}
name|puts
argument_list|(
literal|""
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|DT_MIPS_IVERSION
case|:
if|if
condition|(
name|dynamic_strings
operator|!=
name|NULL
condition|)
name|printf
argument_list|(
literal|"Interface Version: %s\n"
argument_list|,
name|dynamic_strings
operator|+
name|entry
operator|->
name|d_un
operator|.
name|d_val
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%ld\n"
argument_list|,
operator|(
name|long
operator|)
name|entry
operator|->
name|d_un
operator|.
name|d_ptr
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_MIPS_TIME_STAMP
case|:
block|{
name|char
name|timebuf
index|[
literal|20
index|]
decl_stmt|;
name|struct
name|tm
modifier|*
name|tmp
decl_stmt|;
name|time_t
name|time
init|=
name|entry
operator|->
name|d_un
operator|.
name|d_val
decl_stmt|;
name|tmp
operator|=
name|gmtime
argument_list|(
operator|&
name|time
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|timebuf
argument_list|,
literal|"%04u-%02u-%02uT%02u:%02u:%02u"
argument_list|,
name|tmp
operator|->
name|tm_year
operator|+
literal|1900
argument_list|,
name|tmp
operator|->
name|tm_mon
operator|+
literal|1
argument_list|,
name|tmp
operator|->
name|tm_mday
argument_list|,
name|tmp
operator|->
name|tm_hour
argument_list|,
name|tmp
operator|->
name|tm_min
argument_list|,
name|tmp
operator|->
name|tm_sec
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Time Stamp: %s\n"
argument_list|,
name|timebuf
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|DT_MIPS_RLD_VERSION
case|:
case|case
name|DT_MIPS_LOCAL_GOTNO
case|:
case|case
name|DT_MIPS_CONFLICTNO
case|:
case|case
name|DT_MIPS_LIBLISTNO
case|:
case|case
name|DT_MIPS_SYMTABNO
case|:
case|case
name|DT_MIPS_UNREFEXTNO
case|:
case|case
name|DT_MIPS_HIPAGENO
case|:
case|case
name|DT_MIPS_DELTA_CLASS_NO
case|:
case|case
name|DT_MIPS_DELTA_INSTANCE_NO
case|:
case|case
name|DT_MIPS_DELTA_RELOC_NO
case|:
case|case
name|DT_MIPS_DELTA_SYM_NO
case|:
case|case
name|DT_MIPS_DELTA_CLASSSYM_NO
case|:
case|case
name|DT_MIPS_COMPACT_SIZE
case|:
name|printf
argument_list|(
literal|"%ld\n"
argument_list|,
operator|(
name|long
operator|)
name|entry
operator|->
name|d_un
operator|.
name|d_ptr
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"%#lx\n"
argument_list|,
operator|(
name|long
operator|)
name|entry
operator|->
name|d_un
operator|.
name|d_ptr
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|dynamic_segment_parisc_val
parameter_list|(
name|Elf_Internal_Dyn
modifier|*
name|entry
parameter_list|)
block|{
switch|switch
condition|(
name|entry
operator|->
name|d_tag
condition|)
block|{
case|case
name|DT_HP_DLD_FLAGS
case|:
block|{
specifier|static
struct|struct
block|{
name|long
name|int
name|bit
decl_stmt|;
specifier|const
name|char
modifier|*
name|str
decl_stmt|;
block|}
name|flags
index|[]
init|=
block|{
block|{
name|DT_HP_DEBUG_PRIVATE
block|,
literal|"HP_DEBUG_PRIVATE"
block|}
block|,
block|{
name|DT_HP_DEBUG_CALLBACK
block|,
literal|"HP_DEBUG_CALLBACK"
block|}
block|,
block|{
name|DT_HP_DEBUG_CALLBACK_BOR
block|,
literal|"HP_DEBUG_CALLBACK_BOR"
block|}
block|,
block|{
name|DT_HP_NO_ENVVAR
block|,
literal|"HP_NO_ENVVAR"
block|}
block|,
block|{
name|DT_HP_BIND_NOW
block|,
literal|"HP_BIND_NOW"
block|}
block|,
block|{
name|DT_HP_BIND_NONFATAL
block|,
literal|"HP_BIND_NONFATAL"
block|}
block|,
block|{
name|DT_HP_BIND_VERBOSE
block|,
literal|"HP_BIND_VERBOSE"
block|}
block|,
block|{
name|DT_HP_BIND_RESTRICTED
block|,
literal|"HP_BIND_RESTRICTED"
block|}
block|,
block|{
name|DT_HP_BIND_SYMBOLIC
block|,
literal|"HP_BIND_SYMBOLIC"
block|}
block|,
block|{
name|DT_HP_RPATH_FIRST
block|,
literal|"HP_RPATH_FIRST"
block|}
block|,
block|{
name|DT_HP_BIND_DEPTH_FIRST
block|,
literal|"HP_BIND_DEPTH_FIRST"
block|}
block|}
struct|;
name|int
name|first
init|=
literal|1
decl_stmt|;
name|size_t
name|cnt
decl_stmt|;
name|bfd_vma
name|val
init|=
name|entry
operator|->
name|d_un
operator|.
name|d_val
decl_stmt|;
for|for
control|(
name|cnt
operator|=
literal|0
init|;
name|cnt
operator|<
sizeof|sizeof
argument_list|(
name|flags
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|flags
index|[
literal|0
index|]
argument_list|)
condition|;
operator|++
name|cnt
control|)
if|if
condition|(
name|val
operator|&
name|flags
index|[
name|cnt
index|]
operator|.
name|bit
condition|)
block|{
if|if
condition|(
operator|!
name|first
condition|)
name|putchar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|flags
index|[
name|cnt
index|]
operator|.
name|str
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|first
operator|=
literal|0
expr_stmt|;
name|val
operator|^=
name|flags
index|[
name|cnt
index|]
operator|.
name|bit
expr_stmt|;
block|}
if|if
condition|(
name|val
operator|!=
literal|0
operator|||
name|first
condition|)
block|{
if|if
condition|(
operator|!
name|first
condition|)
name|putchar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|print_vma
argument_list|(
name|val
argument_list|,
name|HEX
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
default|default:
name|print_vma
argument_list|(
name|entry
operator|->
name|d_un
operator|.
name|d_ptr
argument_list|,
name|PREFIX_HEX
argument_list|)
expr_stmt|;
break|break;
block|}
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dynamic_segment_ia64_val
parameter_list|(
name|Elf_Internal_Dyn
modifier|*
name|entry
parameter_list|)
block|{
switch|switch
condition|(
name|entry
operator|->
name|d_tag
condition|)
block|{
case|case
name|DT_IA_64_PLT_RESERVE
case|:
comment|/* First 3 slots reserved.  */
name|print_vma
argument_list|(
name|entry
operator|->
name|d_un
operator|.
name|d_ptr
argument_list|,
name|PREFIX_HEX
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" -- "
argument_list|)
expr_stmt|;
name|print_vma
argument_list|(
name|entry
operator|->
name|d_un
operator|.
name|d_ptr
operator|+
operator|(
literal|3
operator|*
literal|8
operator|)
argument_list|,
name|PREFIX_HEX
argument_list|)
expr_stmt|;
break|break;
default|default:
name|print_vma
argument_list|(
name|entry
operator|->
name|d_un
operator|.
name|d_ptr
argument_list|,
name|PREFIX_HEX
argument_list|)
expr_stmt|;
break|break;
block|}
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|get_32bit_dynamic_segment
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|)
block|{
name|Elf32_External_Dyn
modifier|*
name|edyn
decl_stmt|;
name|Elf_Internal_Dyn
modifier|*
name|entry
decl_stmt|;
name|bfd_size_type
name|i
decl_stmt|;
name|edyn
operator|=
name|get_data
argument_list|(
name|NULL
argument_list|,
name|file
argument_list|,
name|dynamic_addr
argument_list|,
name|dynamic_size
argument_list|,
name|_
argument_list|(
literal|"dynamic segment"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|edyn
condition|)
return|return
literal|0
return|;
comment|/* SGI's ELF has more than one section in the DYNAMIC segment.  Determine      how large this .dynamic is now.  We can do this even before the byte      swapping since the DT_NULL tag is recognizable.  */
name|dynamic_size
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
operator|(
name|Elf32_Word
operator|*
operator|)
name|edyn
index|[
name|dynamic_size
operator|++
index|]
operator|.
name|d_tag
operator|!=
name|DT_NULL
condition|)
empty_stmt|;
name|dynamic_segment
operator|=
name|malloc
argument_list|(
name|dynamic_size
operator|*
sizeof|sizeof
argument_list|(
name|Elf_Internal_Dyn
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dynamic_segment
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"Out of memory\n"
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|edyn
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|entry
operator|=
name|dynamic_segment
init|;
name|i
operator|<
name|dynamic_size
condition|;
name|i
operator|++
operator|,
name|entry
operator|++
control|)
block|{
name|entry
operator|->
name|d_tag
operator|=
name|BYTE_GET
argument_list|(
name|edyn
index|[
name|i
index|]
operator|.
name|d_tag
argument_list|)
expr_stmt|;
name|entry
operator|->
name|d_un
operator|.
name|d_val
operator|=
name|BYTE_GET
argument_list|(
name|edyn
index|[
name|i
index|]
operator|.
name|d_un
operator|.
name|d_val
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|edyn
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|get_64bit_dynamic_segment
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|)
block|{
name|Elf64_External_Dyn
modifier|*
name|edyn
decl_stmt|;
name|Elf_Internal_Dyn
modifier|*
name|entry
decl_stmt|;
name|bfd_size_type
name|i
decl_stmt|;
name|edyn
operator|=
name|get_data
argument_list|(
name|NULL
argument_list|,
name|file
argument_list|,
name|dynamic_addr
argument_list|,
name|dynamic_size
argument_list|,
name|_
argument_list|(
literal|"dynamic segment"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|edyn
condition|)
return|return
literal|0
return|;
comment|/* SGI's ELF has more than one section in the DYNAMIC segment.  Determine      how large this .dynamic is now.  We can do this even before the byte      swapping since the DT_NULL tag is recognizable.  */
name|dynamic_size
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
operator|(
name|bfd_vma
operator|*
operator|)
name|edyn
index|[
name|dynamic_size
operator|++
index|]
operator|.
name|d_tag
operator|!=
name|DT_NULL
condition|)
empty_stmt|;
name|dynamic_segment
operator|=
name|malloc
argument_list|(
name|dynamic_size
operator|*
sizeof|sizeof
argument_list|(
name|Elf_Internal_Dyn
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dynamic_segment
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"Out of memory\n"
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|edyn
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|entry
operator|=
name|dynamic_segment
init|;
name|i
operator|<
name|dynamic_size
condition|;
name|i
operator|++
operator|,
name|entry
operator|++
control|)
block|{
name|entry
operator|->
name|d_tag
operator|=
name|BYTE_GET8
argument_list|(
name|edyn
index|[
name|i
index|]
operator|.
name|d_tag
argument_list|)
expr_stmt|;
name|entry
operator|->
name|d_un
operator|.
name|d_val
operator|=
name|BYTE_GET8
argument_list|(
name|edyn
index|[
name|i
index|]
operator|.
name|d_un
operator|.
name|d_val
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|edyn
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|get_dynamic_flags
parameter_list|(
name|bfd_vma
name|flags
parameter_list|)
block|{
specifier|static
name|char
name|buff
index|[
literal|128
index|]
decl_stmt|;
name|char
modifier|*
name|p
init|=
name|buff
decl_stmt|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
while|while
condition|(
name|flags
condition|)
block|{
name|bfd_vma
name|flag
decl_stmt|;
name|flag
operator|=
name|flags
operator|&
operator|-
name|flags
expr_stmt|;
name|flags
operator|&=
operator|~
name|flag
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|buff
condition|)
operator|*
name|p
operator|++
operator|=
literal|' '
expr_stmt|;
switch|switch
condition|(
name|flag
condition|)
block|{
case|case
name|DF_ORIGIN
case|:
name|strcpy
argument_list|(
name|p
argument_list|,
literal|"ORIGIN"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DF_SYMBOLIC
case|:
name|strcpy
argument_list|(
name|p
argument_list|,
literal|"SYMBOLIC"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DF_TEXTREL
case|:
name|strcpy
argument_list|(
name|p
argument_list|,
literal|"TEXTREL"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DF_BIND_NOW
case|:
name|strcpy
argument_list|(
name|p
argument_list|,
literal|"BIND_NOW"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DF_STATIC_TLS
case|:
name|strcpy
argument_list|(
name|p
argument_list|,
literal|"STATIC_TLS"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|strcpy
argument_list|(
name|p
argument_list|,
literal|"unknown"
argument_list|)
expr_stmt|;
break|break;
block|}
name|p
operator|=
name|strchr
argument_list|(
name|p
argument_list|,
literal|'\0'
argument_list|)
expr_stmt|;
block|}
return|return
name|buff
return|;
block|}
end_function

begin_comment
comment|/* Parse and display the contents of the dynamic segment.  */
end_comment

begin_function
specifier|static
name|int
name|process_dynamic_segment
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|)
block|{
name|Elf_Internal_Dyn
modifier|*
name|entry
decl_stmt|;
name|bfd_size_type
name|i
decl_stmt|;
if|if
condition|(
name|dynamic_size
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|do_dynamic
condition|)
name|printf
argument_list|(
name|_
argument_list|(
literal|"\nThere is no dynamic segment in this file.\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|is_32bit_elf
condition|)
block|{
if|if
condition|(
operator|!
name|get_32bit_dynamic_segment
argument_list|(
name|file
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|get_64bit_dynamic_segment
argument_list|(
name|file
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Find the appropriate symbol table.  */
if|if
condition|(
name|dynamic_symbols
operator|==
name|NULL
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|entry
operator|=
name|dynamic_segment
init|;
name|i
operator|<
name|dynamic_size
condition|;
operator|++
name|i
operator|,
operator|++
name|entry
control|)
block|{
name|Elf_Internal_Shdr
name|section
decl_stmt|;
if|if
condition|(
name|entry
operator|->
name|d_tag
operator|!=
name|DT_SYMTAB
condition|)
continue|continue;
name|dynamic_info
index|[
name|DT_SYMTAB
index|]
operator|=
name|entry
operator|->
name|d_un
operator|.
name|d_val
expr_stmt|;
comment|/* Since we do not know how big the symbol table is, 	     we default to reading in the entire file (!) and 	     processing that.  This is overkill, I know, but it 	     should work.  */
name|section
operator|.
name|sh_offset
operator|=
name|offset_from_vma
argument_list|(
name|file
argument_list|,
name|entry
operator|->
name|d_un
operator|.
name|d_val
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|archive_file_offset
operator|!=
literal|0
condition|)
name|section
operator|.
name|sh_size
operator|=
name|archive_file_size
operator|-
name|section
operator|.
name|sh_offset
expr_stmt|;
else|else
block|{
if|if
condition|(
name|fseek
argument_list|(
name|file
argument_list|,
literal|0
argument_list|,
name|SEEK_END
argument_list|)
condition|)
name|error
argument_list|(
name|_
argument_list|(
literal|"Unable to seek to end of file!"
argument_list|)
argument_list|)
expr_stmt|;
name|section
operator|.
name|sh_size
operator|=
name|ftell
argument_list|(
name|file
argument_list|)
operator|-
name|section
operator|.
name|sh_offset
expr_stmt|;
block|}
if|if
condition|(
name|is_32bit_elf
condition|)
name|section
operator|.
name|sh_entsize
operator|=
sizeof|sizeof
argument_list|(
name|Elf32_External_Sym
argument_list|)
expr_stmt|;
else|else
name|section
operator|.
name|sh_entsize
operator|=
sizeof|sizeof
argument_list|(
name|Elf64_External_Sym
argument_list|)
expr_stmt|;
name|num_dynamic_syms
operator|=
name|section
operator|.
name|sh_size
operator|/
name|section
operator|.
name|sh_entsize
expr_stmt|;
if|if
condition|(
name|num_dynamic_syms
operator|<
literal|1
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"Unable to determine the number of symbols to load\n"
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|dynamic_symbols
operator|=
name|GET_ELF_SYMBOLS
argument_list|(
name|file
argument_list|,
operator|&
name|section
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Similarly find a string table.  */
if|if
condition|(
name|dynamic_strings
operator|==
name|NULL
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|entry
operator|=
name|dynamic_segment
init|;
name|i
operator|<
name|dynamic_size
condition|;
operator|++
name|i
operator|,
operator|++
name|entry
control|)
block|{
name|unsigned
name|long
name|offset
decl_stmt|;
name|long
name|str_tab_len
decl_stmt|;
if|if
condition|(
name|entry
operator|->
name|d_tag
operator|!=
name|DT_STRTAB
condition|)
continue|continue;
name|dynamic_info
index|[
name|DT_STRTAB
index|]
operator|=
name|entry
operator|->
name|d_un
operator|.
name|d_val
expr_stmt|;
comment|/* Since we do not know how big the string table is, 	     we default to reading in the entire file (!) and 	     processing that.  This is overkill, I know, but it 	     should work.  */
name|offset
operator|=
name|offset_from_vma
argument_list|(
name|file
argument_list|,
name|entry
operator|->
name|d_un
operator|.
name|d_val
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|archive_file_offset
operator|!=
literal|0
condition|)
name|str_tab_len
operator|=
name|archive_file_size
operator|-
name|offset
expr_stmt|;
else|else
block|{
if|if
condition|(
name|fseek
argument_list|(
name|file
argument_list|,
literal|0
argument_list|,
name|SEEK_END
argument_list|)
condition|)
name|error
argument_list|(
name|_
argument_list|(
literal|"Unable to seek to end of file\n"
argument_list|)
argument_list|)
expr_stmt|;
name|str_tab_len
operator|=
name|ftell
argument_list|(
name|file
argument_list|)
operator|-
name|offset
expr_stmt|;
block|}
if|if
condition|(
name|str_tab_len
operator|<
literal|1
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"Unable to determine the length of the dynamic string table\n"
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|dynamic_strings
operator|=
name|get_data
argument_list|(
name|NULL
argument_list|,
name|file
argument_list|,
name|offset
argument_list|,
name|str_tab_len
argument_list|,
name|_
argument_list|(
literal|"dynamic string table"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|/* And find the syminfo section if available.  */
if|if
condition|(
name|dynamic_syminfo
operator|==
name|NULL
condition|)
block|{
name|unsigned
name|long
name|syminsz
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|entry
operator|=
name|dynamic_segment
init|;
name|i
operator|<
name|dynamic_size
condition|;
operator|++
name|i
operator|,
operator|++
name|entry
control|)
block|{
if|if
condition|(
name|entry
operator|->
name|d_tag
operator|==
name|DT_SYMINENT
condition|)
block|{
comment|/* Note: these braces are necessary to avoid a syntax 		 error from the SunOS4 C compiler.  */
name|assert
argument_list|(
sizeof|sizeof
argument_list|(
name|Elf_External_Syminfo
argument_list|)
operator|==
name|entry
operator|->
name|d_un
operator|.
name|d_val
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|entry
operator|->
name|d_tag
operator|==
name|DT_SYMINSZ
condition|)
name|syminsz
operator|=
name|entry
operator|->
name|d_un
operator|.
name|d_val
expr_stmt|;
elseif|else
if|if
condition|(
name|entry
operator|->
name|d_tag
operator|==
name|DT_SYMINFO
condition|)
name|dynamic_syminfo_offset
operator|=
name|offset_from_vma
argument_list|(
name|file
argument_list|,
name|entry
operator|->
name|d_un
operator|.
name|d_val
argument_list|,
name|syminsz
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dynamic_syminfo_offset
operator|!=
literal|0
operator|&&
name|syminsz
operator|!=
literal|0
condition|)
block|{
name|Elf_External_Syminfo
modifier|*
name|extsyminfo
decl_stmt|;
name|Elf_Internal_Syminfo
modifier|*
name|syminfo
decl_stmt|;
comment|/* There is a syminfo section.  Read the data.  */
name|extsyminfo
operator|=
name|get_data
argument_list|(
name|NULL
argument_list|,
name|file
argument_list|,
name|dynamic_syminfo_offset
argument_list|,
name|syminsz
argument_list|,
name|_
argument_list|(
literal|"symbol information"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|extsyminfo
condition|)
return|return
literal|0
return|;
name|dynamic_syminfo
operator|=
name|malloc
argument_list|(
name|syminsz
argument_list|)
expr_stmt|;
if|if
condition|(
name|dynamic_syminfo
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"Out of memory\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|dynamic_syminfo_nent
operator|=
name|syminsz
operator|/
sizeof|sizeof
argument_list|(
name|Elf_External_Syminfo
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|syminfo
operator|=
name|dynamic_syminfo
init|;
name|i
operator|<
name|dynamic_syminfo_nent
condition|;
operator|++
name|i
operator|,
operator|++
name|syminfo
control|)
block|{
name|syminfo
operator|->
name|si_boundto
operator|=
name|BYTE_GET
argument_list|(
name|extsyminfo
index|[
name|i
index|]
operator|.
name|si_boundto
argument_list|)
expr_stmt|;
name|syminfo
operator|->
name|si_flags
operator|=
name|BYTE_GET
argument_list|(
name|extsyminfo
index|[
name|i
index|]
operator|.
name|si_flags
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|extsyminfo
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|do_dynamic
operator|&&
name|dynamic_addr
condition|)
name|printf
argument_list|(
name|_
argument_list|(
literal|"\nDynamic segment at offset 0x%lx contains %ld entries:\n"
argument_list|)
argument_list|,
name|dynamic_addr
argument_list|,
operator|(
name|long
operator|)
name|dynamic_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|do_dynamic
condition|)
name|printf
argument_list|(
name|_
argument_list|(
literal|"  Tag        Type                         Name/Value\n"
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|entry
operator|=
name|dynamic_segment
init|;
name|i
operator|<
name|dynamic_size
condition|;
name|i
operator|++
operator|,
name|entry
operator|++
control|)
block|{
if|if
condition|(
name|do_dynamic
condition|)
block|{
specifier|const
name|char
modifier|*
name|dtype
decl_stmt|;
name|putchar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|print_vma
argument_list|(
name|entry
operator|->
name|d_tag
argument_list|,
name|FULL_HEX
argument_list|)
expr_stmt|;
name|dtype
operator|=
name|get_dynamic_type
argument_list|(
name|entry
operator|->
name|d_tag
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" (%s)%*s"
argument_list|,
name|dtype
argument_list|,
operator|(
operator|(
name|is_32bit_elf
condition|?
literal|27
else|:
literal|19
operator|)
operator|-
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|dtype
argument_list|)
operator|)
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|entry
operator|->
name|d_tag
condition|)
block|{
case|case
name|DT_FLAGS
case|:
if|if
condition|(
name|do_dynamic
condition|)
name|puts
argument_list|(
name|get_dynamic_flags
argument_list|(
name|entry
operator|->
name|d_un
operator|.
name|d_val
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_AUXILIARY
case|:
case|case
name|DT_FILTER
case|:
case|case
name|DT_CONFIG
case|:
case|case
name|DT_DEPAUDIT
case|:
case|case
name|DT_AUDIT
case|:
if|if
condition|(
name|do_dynamic
condition|)
block|{
switch|switch
condition|(
name|entry
operator|->
name|d_tag
condition|)
block|{
case|case
name|DT_AUXILIARY
case|:
name|printf
argument_list|(
name|_
argument_list|(
literal|"Auxiliary library"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_FILTER
case|:
name|printf
argument_list|(
name|_
argument_list|(
literal|"Filter library"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_CONFIG
case|:
name|printf
argument_list|(
name|_
argument_list|(
literal|"Configuration file"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_DEPAUDIT
case|:
name|printf
argument_list|(
name|_
argument_list|(
literal|"Dependency audit library"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_AUDIT
case|:
name|printf
argument_list|(
name|_
argument_list|(
literal|"Audit library"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|dynamic_strings
condition|)
name|printf
argument_list|(
literal|": [%s]\n"
argument_list|,
name|dynamic_strings
operator|+
name|entry
operator|->
name|d_un
operator|.
name|d_val
argument_list|)
expr_stmt|;
else|else
block|{
name|printf
argument_list|(
literal|": "
argument_list|)
expr_stmt|;
name|print_vma
argument_list|(
name|entry
operator|->
name|d_un
operator|.
name|d_val
argument_list|,
name|PREFIX_HEX
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|DT_FEATURE
case|:
if|if
condition|(
name|do_dynamic
condition|)
block|{
name|printf
argument_list|(
name|_
argument_list|(
literal|"Flags:"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|d_un
operator|.
name|d_val
operator|==
literal|0
condition|)
name|printf
argument_list|(
name|_
argument_list|(
literal|" None\n"
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|unsigned
name|long
name|int
name|val
init|=
name|entry
operator|->
name|d_un
operator|.
name|d_val
decl_stmt|;
if|if
condition|(
name|val
operator|&
name|DTF_1_PARINIT
condition|)
block|{
name|printf
argument_list|(
literal|" PARINIT"
argument_list|)
expr_stmt|;
name|val
operator|^=
name|DTF_1_PARINIT
expr_stmt|;
block|}
if|if
condition|(
name|val
operator|&
name|DTF_1_CONFEXP
condition|)
block|{
name|printf
argument_list|(
literal|" CONFEXP"
argument_list|)
expr_stmt|;
name|val
operator|^=
name|DTF_1_CONFEXP
expr_stmt|;
block|}
if|if
condition|(
name|val
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|" %lx"
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|""
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|DT_POSFLAG_1
case|:
if|if
condition|(
name|do_dynamic
condition|)
block|{
name|printf
argument_list|(
name|_
argument_list|(
literal|"Flags:"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|d_un
operator|.
name|d_val
operator|==
literal|0
condition|)
name|printf
argument_list|(
name|_
argument_list|(
literal|" None\n"
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|unsigned
name|long
name|int
name|val
init|=
name|entry
operator|->
name|d_un
operator|.
name|d_val
decl_stmt|;
if|if
condition|(
name|val
operator|&
name|DF_P1_LAZYLOAD
condition|)
block|{
name|printf
argument_list|(
literal|" LAZYLOAD"
argument_list|)
expr_stmt|;
name|val
operator|^=
name|DF_P1_LAZYLOAD
expr_stmt|;
block|}
if|if
condition|(
name|val
operator|&
name|DF_P1_GROUPPERM
condition|)
block|{
name|printf
argument_list|(
literal|" GROUPPERM"
argument_list|)
expr_stmt|;
name|val
operator|^=
name|DF_P1_GROUPPERM
expr_stmt|;
block|}
if|if
condition|(
name|val
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|" %lx"
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|""
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|DT_FLAGS_1
case|:
if|if
condition|(
name|do_dynamic
condition|)
block|{
name|printf
argument_list|(
name|_
argument_list|(
literal|"Flags:"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|d_un
operator|.
name|d_val
operator|==
literal|0
condition|)
name|printf
argument_list|(
name|_
argument_list|(
literal|" None\n"
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|unsigned
name|long
name|int
name|val
init|=
name|entry
operator|->
name|d_un
operator|.
name|d_val
decl_stmt|;
if|if
condition|(
name|val
operator|&
name|DF_1_NOW
condition|)
block|{
name|printf
argument_list|(
literal|" NOW"
argument_list|)
expr_stmt|;
name|val
operator|^=
name|DF_1_NOW
expr_stmt|;
block|}
if|if
condition|(
name|val
operator|&
name|DF_1_GLOBAL
condition|)
block|{
name|printf
argument_list|(
literal|" GLOBAL"
argument_list|)
expr_stmt|;
name|val
operator|^=
name|DF_1_GLOBAL
expr_stmt|;
block|}
if|if
condition|(
name|val
operator|&
name|DF_1_GROUP
condition|)
block|{
name|printf
argument_list|(
literal|" GROUP"
argument_list|)
expr_stmt|;
name|val
operator|^=
name|DF_1_GROUP
expr_stmt|;
block|}
if|if
condition|(
name|val
operator|&
name|DF_1_NODELETE
condition|)
block|{
name|printf
argument_list|(
literal|" NODELETE"
argument_list|)
expr_stmt|;
name|val
operator|^=
name|DF_1_NODELETE
expr_stmt|;
block|}
if|if
condition|(
name|val
operator|&
name|DF_1_LOADFLTR
condition|)
block|{
name|printf
argument_list|(
literal|" LOADFLTR"
argument_list|)
expr_stmt|;
name|val
operator|^=
name|DF_1_LOADFLTR
expr_stmt|;
block|}
if|if
condition|(
name|val
operator|&
name|DF_1_INITFIRST
condition|)
block|{
name|printf
argument_list|(
literal|" INITFIRST"
argument_list|)
expr_stmt|;
name|val
operator|^=
name|DF_1_INITFIRST
expr_stmt|;
block|}
if|if
condition|(
name|val
operator|&
name|DF_1_NOOPEN
condition|)
block|{
name|printf
argument_list|(
literal|" NOOPEN"
argument_list|)
expr_stmt|;
name|val
operator|^=
name|DF_1_NOOPEN
expr_stmt|;
block|}
if|if
condition|(
name|val
operator|&
name|DF_1_ORIGIN
condition|)
block|{
name|printf
argument_list|(
literal|" ORIGIN"
argument_list|)
expr_stmt|;
name|val
operator|^=
name|DF_1_ORIGIN
expr_stmt|;
block|}
if|if
condition|(
name|val
operator|&
name|DF_1_DIRECT
condition|)
block|{
name|printf
argument_list|(
literal|" DIRECT"
argument_list|)
expr_stmt|;
name|val
operator|^=
name|DF_1_DIRECT
expr_stmt|;
block|}
if|if
condition|(
name|val
operator|&
name|DF_1_TRANS
condition|)
block|{
name|printf
argument_list|(
literal|" TRANS"
argument_list|)
expr_stmt|;
name|val
operator|^=
name|DF_1_TRANS
expr_stmt|;
block|}
if|if
condition|(
name|val
operator|&
name|DF_1_INTERPOSE
condition|)
block|{
name|printf
argument_list|(
literal|" INTERPOSE"
argument_list|)
expr_stmt|;
name|val
operator|^=
name|DF_1_INTERPOSE
expr_stmt|;
block|}
if|if
condition|(
name|val
operator|&
name|DF_1_NODEFLIB
condition|)
block|{
name|printf
argument_list|(
literal|" NODEFLIB"
argument_list|)
expr_stmt|;
name|val
operator|^=
name|DF_1_NODEFLIB
expr_stmt|;
block|}
if|if
condition|(
name|val
operator|&
name|DF_1_NODUMP
condition|)
block|{
name|printf
argument_list|(
literal|" NODUMP"
argument_list|)
expr_stmt|;
name|val
operator|^=
name|DF_1_NODUMP
expr_stmt|;
block|}
if|if
condition|(
name|val
operator|&
name|DF_1_CONLFAT
condition|)
block|{
name|printf
argument_list|(
literal|" CONLFAT"
argument_list|)
expr_stmt|;
name|val
operator|^=
name|DF_1_CONLFAT
expr_stmt|;
block|}
if|if
condition|(
name|val
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|" %lx"
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|""
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|DT_PLTREL
case|:
name|dynamic_info
index|[
name|entry
operator|->
name|d_tag
index|]
operator|=
name|entry
operator|->
name|d_un
operator|.
name|d_val
expr_stmt|;
if|if
condition|(
name|do_dynamic
condition|)
name|puts
argument_list|(
name|get_dynamic_type
argument_list|(
name|entry
operator|->
name|d_un
operator|.
name|d_val
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_NULL
case|:
case|case
name|DT_NEEDED
case|:
case|case
name|DT_PLTGOT
case|:
case|case
name|DT_HASH
case|:
case|case
name|DT_STRTAB
case|:
case|case
name|DT_SYMTAB
case|:
case|case
name|DT_RELA
case|:
case|case
name|DT_INIT
case|:
case|case
name|DT_FINI
case|:
case|case
name|DT_SONAME
case|:
case|case
name|DT_RPATH
case|:
case|case
name|DT_SYMBOLIC
case|:
case|case
name|DT_REL
case|:
case|case
name|DT_DEBUG
case|:
case|case
name|DT_TEXTREL
case|:
case|case
name|DT_JMPREL
case|:
case|case
name|DT_RUNPATH
case|:
name|dynamic_info
index|[
name|entry
operator|->
name|d_tag
index|]
operator|=
name|entry
operator|->
name|d_un
operator|.
name|d_val
expr_stmt|;
if|if
condition|(
name|do_dynamic
condition|)
block|{
name|char
modifier|*
name|name
decl_stmt|;
if|if
condition|(
name|dynamic_strings
operator|==
name|NULL
condition|)
name|name
operator|=
name|NULL
expr_stmt|;
else|else
name|name
operator|=
name|dynamic_strings
operator|+
name|entry
operator|->
name|d_un
operator|.
name|d_val
expr_stmt|;
if|if
condition|(
name|name
condition|)
block|{
switch|switch
condition|(
name|entry
operator|->
name|d_tag
condition|)
block|{
case|case
name|DT_NEEDED
case|:
name|printf
argument_list|(
name|_
argument_list|(
literal|"Shared library: [%s]"
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|program_interpreter
argument_list|)
operator|==
literal|0
condition|)
name|printf
argument_list|(
name|_
argument_list|(
literal|" program interpreter"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_SONAME
case|:
name|printf
argument_list|(
name|_
argument_list|(
literal|"Library soname: [%s]"
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_RPATH
case|:
name|printf
argument_list|(
name|_
argument_list|(
literal|"Library rpath: [%s]"
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_RUNPATH
case|:
name|printf
argument_list|(
name|_
argument_list|(
literal|"Library runpath: [%s]"
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
break|break;
default|default:
name|print_vma
argument_list|(
name|entry
operator|->
name|d_un
operator|.
name|d_val
argument_list|,
name|PREFIX_HEX
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
else|else
name|print_vma
argument_list|(
name|entry
operator|->
name|d_un
operator|.
name|d_val
argument_list|,
name|PREFIX_HEX
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|DT_PLTRELSZ
case|:
case|case
name|DT_RELASZ
case|:
case|case
name|DT_STRSZ
case|:
case|case
name|DT_RELSZ
case|:
case|case
name|DT_RELAENT
case|:
case|case
name|DT_SYMENT
case|:
case|case
name|DT_RELENT
case|:
name|dynamic_info
index|[
name|entry
operator|->
name|d_tag
index|]
operator|=
name|entry
operator|->
name|d_un
operator|.
name|d_val
expr_stmt|;
case|case
name|DT_PLTPADSZ
case|:
case|case
name|DT_MOVEENT
case|:
case|case
name|DT_MOVESZ
case|:
case|case
name|DT_INIT_ARRAYSZ
case|:
case|case
name|DT_FINI_ARRAYSZ
case|:
case|case
name|DT_GNU_CONFLICTSZ
case|:
case|case
name|DT_GNU_LIBLISTSZ
case|:
if|if
condition|(
name|do_dynamic
condition|)
block|{
name|print_vma
argument_list|(
name|entry
operator|->
name|d_un
operator|.
name|d_val
argument_list|,
name|UNSIGNED
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" (bytes)\n"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|DT_VERDEFNUM
case|:
case|case
name|DT_VERNEEDNUM
case|:
case|case
name|DT_RELACOUNT
case|:
case|case
name|DT_RELCOUNT
case|:
if|if
condition|(
name|do_dynamic
condition|)
block|{
name|print_vma
argument_list|(
name|entry
operator|->
name|d_un
operator|.
name|d_val
argument_list|,
name|UNSIGNED
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|DT_SYMINSZ
case|:
case|case
name|DT_SYMINENT
case|:
case|case
name|DT_SYMINFO
case|:
case|case
name|DT_USED
case|:
case|case
name|DT_INIT_ARRAY
case|:
case|case
name|DT_FINI_ARRAY
case|:
if|if
condition|(
name|do_dynamic
condition|)
block|{
if|if
condition|(
name|dynamic_strings
operator|!=
name|NULL
operator|&&
name|entry
operator|->
name|d_tag
operator|==
name|DT_USED
condition|)
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|name
operator|=
name|dynamic_strings
operator|+
name|entry
operator|->
name|d_un
operator|.
name|d_val
expr_stmt|;
if|if
condition|(
operator|*
name|name
condition|)
block|{
name|printf
argument_list|(
name|_
argument_list|(
literal|"Not needed object: [%s]\n"
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|print_vma
argument_list|(
name|entry
operator|->
name|d_un
operator|.
name|d_val
argument_list|,
name|PREFIX_HEX
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|DT_BIND_NOW
case|:
comment|/* The value of this entry is ignored.  */
if|if
condition|(
name|do_dynamic
condition|)
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_GNU_PRELINKED
case|:
if|if
condition|(
name|do_dynamic
condition|)
block|{
name|struct
name|tm
modifier|*
name|tmp
decl_stmt|;
name|time_t
name|time
init|=
name|entry
operator|->
name|d_un
operator|.
name|d_val
decl_stmt|;
name|tmp
operator|=
name|gmtime
argument_list|(
operator|&
name|time
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%04u-%02u-%02uT%02u:%02u:%02u\n"
argument_list|,
name|tmp
operator|->
name|tm_year
operator|+
literal|1900
argument_list|,
name|tmp
operator|->
name|tm_mon
operator|+
literal|1
argument_list|,
name|tmp
operator|->
name|tm_mday
argument_list|,
name|tmp
operator|->
name|tm_hour
argument_list|,
name|tmp
operator|->
name|tm_min
argument_list|,
name|tmp
operator|->
name|tm_sec
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
if|if
condition|(
operator|(
name|entry
operator|->
name|d_tag
operator|>=
name|DT_VERSYM
operator|)
operator|&&
operator|(
name|entry
operator|->
name|d_tag
operator|<=
name|DT_VERNEEDNUM
operator|)
condition|)
name|version_info
index|[
name|DT_VERSIONTAGIDX
argument_list|(
name|entry
operator|->
name|d_tag
argument_list|)
index|]
operator|=
name|entry
operator|->
name|d_un
operator|.
name|d_val
expr_stmt|;
if|if
condition|(
name|do_dynamic
condition|)
block|{
switch|switch
condition|(
name|elf_header
operator|.
name|e_machine
condition|)
block|{
case|case
name|EM_MIPS
case|:
case|case
name|EM_MIPS_RS3_LE
case|:
name|dynamic_segment_mips_val
argument_list|(
name|entry
argument_list|)
expr_stmt|;
break|break;
case|case
name|EM_PARISC
case|:
name|dynamic_segment_parisc_val
argument_list|(
name|entry
argument_list|)
expr_stmt|;
break|break;
case|case
name|EM_IA_64
case|:
name|dynamic_segment_ia64_val
argument_list|(
name|entry
argument_list|)
expr_stmt|;
break|break;
default|default:
name|print_vma
argument_list|(
name|entry
operator|->
name|d_un
operator|.
name|d_val
argument_list|,
name|PREFIX_HEX
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
block|}
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|get_ver_flags
parameter_list|(
name|unsigned
name|int
name|flags
parameter_list|)
block|{
specifier|static
name|char
name|buff
index|[
literal|32
index|]
decl_stmt|;
name|buff
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|flags
operator|==
literal|0
condition|)
return|return
name|_
argument_list|(
literal|"none"
argument_list|)
return|;
if|if
condition|(
name|flags
operator|&
name|VER_FLG_BASE
condition|)
name|strcat
argument_list|(
name|buff
argument_list|,
literal|"BASE "
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|VER_FLG_WEAK
condition|)
block|{
if|if
condition|(
name|flags
operator|&
name|VER_FLG_BASE
condition|)
name|strcat
argument_list|(
name|buff
argument_list|,
literal|"| "
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|buff
argument_list|,
literal|"WEAK "
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|&
operator|~
operator|(
name|VER_FLG_BASE
operator||
name|VER_FLG_WEAK
operator|)
condition|)
name|strcat
argument_list|(
name|buff
argument_list|,
literal|"|<unknown>"
argument_list|)
expr_stmt|;
return|return
name|buff
return|;
block|}
end_function

begin_comment
comment|/* Display the contents of the version sections.  */
end_comment

begin_function
specifier|static
name|int
name|process_version_sections
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|)
block|{
name|Elf_Internal_Shdr
modifier|*
name|section
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
name|int
name|found
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|do_version
condition|)
return|return
literal|1
return|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|section
operator|=
name|section_headers
init|;
name|i
operator|<
name|elf_header
operator|.
name|e_shnum
condition|;
name|i
operator|++
operator|,
name|section
operator|++
control|)
block|{
switch|switch
condition|(
name|section
operator|->
name|sh_type
condition|)
block|{
case|case
name|SHT_GNU_verdef
case|:
block|{
name|Elf_External_Verdef
modifier|*
name|edefs
decl_stmt|;
name|unsigned
name|int
name|idx
decl_stmt|;
name|unsigned
name|int
name|cnt
decl_stmt|;
name|found
operator|=
literal|1
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"\nVersion definition section '%s' contains %ld entries:\n"
argument_list|)
argument_list|,
name|SECTION_NAME
argument_list|(
name|section
argument_list|)
argument_list|,
name|section
operator|->
name|sh_info
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"  Addr: 0x"
argument_list|)
argument_list|)
expr_stmt|;
name|printf_vma
argument_list|(
name|section
operator|->
name|sh_addr
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"  Offset: %#08lx  Link: %lx (%s)\n"
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|section
operator|->
name|sh_offset
argument_list|,
name|section
operator|->
name|sh_link
argument_list|,
name|SECTION_NAME
argument_list|(
name|SECTION_HEADER
argument_list|(
name|section
operator|->
name|sh_link
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|edefs
operator|=
name|get_data
argument_list|(
name|NULL
argument_list|,
name|file
argument_list|,
name|section
operator|->
name|sh_offset
argument_list|,
name|section
operator|->
name|sh_size
argument_list|,
name|_
argument_list|(
literal|"version definition section"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|edefs
condition|)
break|break;
for|for
control|(
name|idx
operator|=
name|cnt
operator|=
literal|0
init|;
name|cnt
operator|<
name|section
operator|->
name|sh_info
condition|;
operator|++
name|cnt
control|)
block|{
name|char
modifier|*
name|vstart
decl_stmt|;
name|Elf_External_Verdef
modifier|*
name|edef
decl_stmt|;
name|Elf_Internal_Verdef
name|ent
decl_stmt|;
name|Elf_External_Verdaux
modifier|*
name|eaux
decl_stmt|;
name|Elf_Internal_Verdaux
name|aux
decl_stmt|;
name|int
name|j
decl_stmt|;
name|int
name|isum
decl_stmt|;
name|vstart
operator|=
operator|(
operator|(
name|char
operator|*
operator|)
name|edefs
operator|)
operator|+
name|idx
expr_stmt|;
name|edef
operator|=
operator|(
name|Elf_External_Verdef
operator|*
operator|)
name|vstart
expr_stmt|;
name|ent
operator|.
name|vd_version
operator|=
name|BYTE_GET
argument_list|(
name|edef
operator|->
name|vd_version
argument_list|)
expr_stmt|;
name|ent
operator|.
name|vd_flags
operator|=
name|BYTE_GET
argument_list|(
name|edef
operator|->
name|vd_flags
argument_list|)
expr_stmt|;
name|ent
operator|.
name|vd_ndx
operator|=
name|BYTE_GET
argument_list|(
name|edef
operator|->
name|vd_ndx
argument_list|)
expr_stmt|;
name|ent
operator|.
name|vd_cnt
operator|=
name|BYTE_GET
argument_list|(
name|edef
operator|->
name|vd_cnt
argument_list|)
expr_stmt|;
name|ent
operator|.
name|vd_hash
operator|=
name|BYTE_GET
argument_list|(
name|edef
operator|->
name|vd_hash
argument_list|)
expr_stmt|;
name|ent
operator|.
name|vd_aux
operator|=
name|BYTE_GET
argument_list|(
name|edef
operator|->
name|vd_aux
argument_list|)
expr_stmt|;
name|ent
operator|.
name|vd_next
operator|=
name|BYTE_GET
argument_list|(
name|edef
operator|->
name|vd_next
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"  %#06x: Rev: %d  Flags: %s"
argument_list|)
argument_list|,
name|idx
argument_list|,
name|ent
operator|.
name|vd_version
argument_list|,
name|get_ver_flags
argument_list|(
name|ent
operator|.
name|vd_flags
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"  Index: %d  Cnt: %d  "
argument_list|)
argument_list|,
name|ent
operator|.
name|vd_ndx
argument_list|,
name|ent
operator|.
name|vd_cnt
argument_list|)
expr_stmt|;
name|vstart
operator|+=
name|ent
operator|.
name|vd_aux
expr_stmt|;
name|eaux
operator|=
operator|(
name|Elf_External_Verdaux
operator|*
operator|)
name|vstart
expr_stmt|;
name|aux
operator|.
name|vda_name
operator|=
name|BYTE_GET
argument_list|(
name|eaux
operator|->
name|vda_name
argument_list|)
expr_stmt|;
name|aux
operator|.
name|vda_next
operator|=
name|BYTE_GET
argument_list|(
name|eaux
operator|->
name|vda_next
argument_list|)
expr_stmt|;
if|if
condition|(
name|dynamic_strings
condition|)
name|printf
argument_list|(
name|_
argument_list|(
literal|"Name: %s\n"
argument_list|)
argument_list|,
name|dynamic_strings
operator|+
name|aux
operator|.
name|vda_name
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
name|_
argument_list|(
literal|"Name index: %ld\n"
argument_list|)
argument_list|,
name|aux
operator|.
name|vda_name
argument_list|)
expr_stmt|;
name|isum
operator|=
name|idx
operator|+
name|ent
operator|.
name|vd_aux
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<
name|ent
operator|.
name|vd_cnt
condition|;
name|j
operator|++
control|)
block|{
name|isum
operator|+=
name|aux
operator|.
name|vda_next
expr_stmt|;
name|vstart
operator|+=
name|aux
operator|.
name|vda_next
expr_stmt|;
name|eaux
operator|=
operator|(
name|Elf_External_Verdaux
operator|*
operator|)
name|vstart
expr_stmt|;
name|aux
operator|.
name|vda_name
operator|=
name|BYTE_GET
argument_list|(
name|eaux
operator|->
name|vda_name
argument_list|)
expr_stmt|;
name|aux
operator|.
name|vda_next
operator|=
name|BYTE_GET
argument_list|(
name|eaux
operator|->
name|vda_next
argument_list|)
expr_stmt|;
if|if
condition|(
name|dynamic_strings
condition|)
name|printf
argument_list|(
name|_
argument_list|(
literal|"  %#06x: Parent %d: %s\n"
argument_list|)
argument_list|,
name|isum
argument_list|,
name|j
argument_list|,
name|dynamic_strings
operator|+
name|aux
operator|.
name|vda_name
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
name|_
argument_list|(
literal|"  %#06x: Parent %d, name index: %ld\n"
argument_list|)
argument_list|,
name|isum
argument_list|,
name|j
argument_list|,
name|aux
operator|.
name|vda_name
argument_list|)
expr_stmt|;
block|}
name|idx
operator|+=
name|ent
operator|.
name|vd_next
expr_stmt|;
block|}
name|free
argument_list|(
name|edefs
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SHT_GNU_verneed
case|:
block|{
name|Elf_External_Verneed
modifier|*
name|eneed
decl_stmt|;
name|unsigned
name|int
name|idx
decl_stmt|;
name|unsigned
name|int
name|cnt
decl_stmt|;
name|found
operator|=
literal|1
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"\nVersion needs section '%s' contains %ld entries:\n"
argument_list|)
argument_list|,
name|SECTION_NAME
argument_list|(
name|section
argument_list|)
argument_list|,
name|section
operator|->
name|sh_info
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|" Addr: 0x"
argument_list|)
argument_list|)
expr_stmt|;
name|printf_vma
argument_list|(
name|section
operator|->
name|sh_addr
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"  Offset: %#08lx  Link to section: %ld (%s)\n"
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|section
operator|->
name|sh_offset
argument_list|,
name|section
operator|->
name|sh_link
argument_list|,
name|SECTION_NAME
argument_list|(
name|SECTION_HEADER
argument_list|(
name|section
operator|->
name|sh_link
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|eneed
operator|=
name|get_data
argument_list|(
name|NULL
argument_list|,
name|file
argument_list|,
name|section
operator|->
name|sh_offset
argument_list|,
name|section
operator|->
name|sh_size
argument_list|,
name|_
argument_list|(
literal|"version need section"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|eneed
condition|)
break|break;
for|for
control|(
name|idx
operator|=
name|cnt
operator|=
literal|0
init|;
name|cnt
operator|<
name|section
operator|->
name|sh_info
condition|;
operator|++
name|cnt
control|)
block|{
name|Elf_External_Verneed
modifier|*
name|entry
decl_stmt|;
name|Elf_Internal_Verneed
name|ent
decl_stmt|;
name|int
name|j
decl_stmt|;
name|int
name|isum
decl_stmt|;
name|char
modifier|*
name|vstart
decl_stmt|;
name|vstart
operator|=
operator|(
operator|(
name|char
operator|*
operator|)
name|eneed
operator|)
operator|+
name|idx
expr_stmt|;
name|entry
operator|=
operator|(
name|Elf_External_Verneed
operator|*
operator|)
name|vstart
expr_stmt|;
name|ent
operator|.
name|vn_version
operator|=
name|BYTE_GET
argument_list|(
name|entry
operator|->
name|vn_version
argument_list|)
expr_stmt|;
name|ent
operator|.
name|vn_cnt
operator|=
name|BYTE_GET
argument_list|(
name|entry
operator|->
name|vn_cnt
argument_list|)
expr_stmt|;
name|ent
operator|.
name|vn_file
operator|=
name|BYTE_GET
argument_list|(
name|entry
operator|->
name|vn_file
argument_list|)
expr_stmt|;
name|ent
operator|.
name|vn_aux
operator|=
name|BYTE_GET
argument_list|(
name|entry
operator|->
name|vn_aux
argument_list|)
expr_stmt|;
name|ent
operator|.
name|vn_next
operator|=
name|BYTE_GET
argument_list|(
name|entry
operator|->
name|vn_next
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"  %#06x: Version: %d"
argument_list|)
argument_list|,
name|idx
argument_list|,
name|ent
operator|.
name|vn_version
argument_list|)
expr_stmt|;
if|if
condition|(
name|dynamic_strings
condition|)
name|printf
argument_list|(
name|_
argument_list|(
literal|"  File: %s"
argument_list|)
argument_list|,
name|dynamic_strings
operator|+
name|ent
operator|.
name|vn_file
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
name|_
argument_list|(
literal|"  File: %lx"
argument_list|)
argument_list|,
name|ent
operator|.
name|vn_file
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"  Cnt: %d\n"
argument_list|)
argument_list|,
name|ent
operator|.
name|vn_cnt
argument_list|)
expr_stmt|;
name|vstart
operator|+=
name|ent
operator|.
name|vn_aux
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
operator|,
name|isum
operator|=
name|idx
operator|+
name|ent
operator|.
name|vn_aux
init|;
name|j
operator|<
name|ent
operator|.
name|vn_cnt
condition|;
operator|++
name|j
control|)
block|{
name|Elf_External_Vernaux
modifier|*
name|eaux
decl_stmt|;
name|Elf_Internal_Vernaux
name|aux
decl_stmt|;
name|eaux
operator|=
operator|(
name|Elf_External_Vernaux
operator|*
operator|)
name|vstart
expr_stmt|;
name|aux
operator|.
name|vna_hash
operator|=
name|BYTE_GET
argument_list|(
name|eaux
operator|->
name|vna_hash
argument_list|)
expr_stmt|;
name|aux
operator|.
name|vna_flags
operator|=
name|BYTE_GET
argument_list|(
name|eaux
operator|->
name|vna_flags
argument_list|)
expr_stmt|;
name|aux
operator|.
name|vna_other
operator|=
name|BYTE_GET
argument_list|(
name|eaux
operator|->
name|vna_other
argument_list|)
expr_stmt|;
name|aux
operator|.
name|vna_name
operator|=
name|BYTE_GET
argument_list|(
name|eaux
operator|->
name|vna_name
argument_list|)
expr_stmt|;
name|aux
operator|.
name|vna_next
operator|=
name|BYTE_GET
argument_list|(
name|eaux
operator|->
name|vna_next
argument_list|)
expr_stmt|;
if|if
condition|(
name|dynamic_strings
condition|)
name|printf
argument_list|(
name|_
argument_list|(
literal|"  %#06x:   Name: %s"
argument_list|)
argument_list|,
name|isum
argument_list|,
name|dynamic_strings
operator|+
name|aux
operator|.
name|vna_name
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
name|_
argument_list|(
literal|"  %#06x:   Name index: %lx"
argument_list|)
argument_list|,
name|isum
argument_list|,
name|aux
operator|.
name|vna_name
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"  Flags: %s  Version: %d\n"
argument_list|)
argument_list|,
name|get_ver_flags
argument_list|(
name|aux
operator|.
name|vna_flags
argument_list|)
argument_list|,
name|aux
operator|.
name|vna_other
argument_list|)
expr_stmt|;
name|isum
operator|+=
name|aux
operator|.
name|vna_next
expr_stmt|;
name|vstart
operator|+=
name|aux
operator|.
name|vna_next
expr_stmt|;
block|}
name|idx
operator|+=
name|ent
operator|.
name|vn_next
expr_stmt|;
block|}
name|free
argument_list|(
name|eneed
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SHT_GNU_versym
case|:
block|{
name|Elf_Internal_Shdr
modifier|*
name|link_section
decl_stmt|;
name|int
name|total
decl_stmt|;
name|int
name|cnt
decl_stmt|;
name|unsigned
name|char
modifier|*
name|edata
decl_stmt|;
name|unsigned
name|short
modifier|*
name|data
decl_stmt|;
name|char
modifier|*
name|strtab
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|symbols
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|string_sec
decl_stmt|;
name|long
name|off
decl_stmt|;
name|link_section
operator|=
name|SECTION_HEADER
argument_list|(
name|section
operator|->
name|sh_link
argument_list|)
expr_stmt|;
name|total
operator|=
name|section
operator|->
name|sh_size
operator|/
name|section
operator|->
name|sh_entsize
expr_stmt|;
name|found
operator|=
literal|1
expr_stmt|;
name|symbols
operator|=
name|GET_ELF_SYMBOLS
argument_list|(
name|file
argument_list|,
name|link_section
argument_list|)
expr_stmt|;
name|string_sec
operator|=
name|SECTION_HEADER
argument_list|(
name|link_section
operator|->
name|sh_link
argument_list|)
expr_stmt|;
name|strtab
operator|=
name|get_data
argument_list|(
name|NULL
argument_list|,
name|file
argument_list|,
name|string_sec
operator|->
name|sh_offset
argument_list|,
name|string_sec
operator|->
name|sh_size
argument_list|,
name|_
argument_list|(
literal|"version string table"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|strtab
condition|)
break|break;
name|printf
argument_list|(
name|_
argument_list|(
literal|"\nVersion symbols section '%s' contains %d entries:\n"
argument_list|)
argument_list|,
name|SECTION_NAME
argument_list|(
name|section
argument_list|)
argument_list|,
name|total
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|" Addr: "
argument_list|)
argument_list|)
expr_stmt|;
name|printf_vma
argument_list|(
name|section
operator|->
name|sh_addr
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"  Offset: %#08lx  Link: %lx (%s)\n"
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|section
operator|->
name|sh_offset
argument_list|,
name|section
operator|->
name|sh_link
argument_list|,
name|SECTION_NAME
argument_list|(
name|link_section
argument_list|)
argument_list|)
expr_stmt|;
name|off
operator|=
name|offset_from_vma
argument_list|(
name|file
argument_list|,
name|version_info
index|[
name|DT_VERSIONTAGIDX
argument_list|(
name|DT_VERSYM
argument_list|)
index|]
argument_list|,
name|total
operator|*
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|)
expr_stmt|;
name|edata
operator|=
name|get_data
argument_list|(
name|NULL
argument_list|,
name|file
argument_list|,
name|off
argument_list|,
name|total
operator|*
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|,
name|_
argument_list|(
literal|"version symbol data"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|edata
condition|)
block|{
name|free
argument_list|(
name|strtab
argument_list|)
expr_stmt|;
break|break;
block|}
name|data
operator|=
name|malloc
argument_list|(
name|total
operator|*
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|cnt
operator|=
name|total
init|;
name|cnt
operator|--
condition|;
control|)
name|data
index|[
name|cnt
index|]
operator|=
name|byte_get
argument_list|(
name|edata
operator|+
name|cnt
operator|*
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|edata
argument_list|)
expr_stmt|;
for|for
control|(
name|cnt
operator|=
literal|0
init|;
name|cnt
operator|<
name|total
condition|;
name|cnt
operator|+=
literal|4
control|)
block|{
name|int
name|j
decl_stmt|,
name|nn
decl_stmt|;
name|int
name|check_def
decl_stmt|,
name|check_need
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|printf
argument_list|(
literal|"  %03x:"
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
operator|(
name|j
operator|<
literal|4
operator|)
operator|&&
operator|(
name|cnt
operator|+
name|j
operator|)
operator|<
name|total
condition|;
operator|++
name|j
control|)
switch|switch
condition|(
name|data
index|[
name|cnt
operator|+
name|j
index|]
condition|)
block|{
case|case
literal|0
case|:
name|fputs
argument_list|(
name|_
argument_list|(
literal|"   0 (*local*)    "
argument_list|)
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|fputs
argument_list|(
name|_
argument_list|(
literal|"   1 (*global*)   "
argument_list|)
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
break|break;
default|default:
name|nn
operator|=
name|printf
argument_list|(
literal|"%4x%c"
argument_list|,
name|data
index|[
name|cnt
operator|+
name|j
index|]
operator|&
literal|0x7fff
argument_list|,
name|data
index|[
name|cnt
operator|+
name|j
index|]
operator|&
literal|0x8000
condition|?
literal|'h'
else|:
literal|' '
argument_list|)
expr_stmt|;
name|check_def
operator|=
literal|1
expr_stmt|;
name|check_need
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|SECTION_HEADER
argument_list|(
name|symbols
index|[
name|cnt
operator|+
name|j
index|]
operator|.
name|st_shndx
argument_list|)
operator|->
name|sh_type
operator|!=
name|SHT_NOBITS
condition|)
block|{
if|if
condition|(
name|symbols
index|[
name|cnt
operator|+
name|j
index|]
operator|.
name|st_shndx
operator|==
name|SHN_UNDEF
condition|)
name|check_def
operator|=
literal|0
expr_stmt|;
else|else
name|check_need
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|check_need
operator|&&
name|version_info
index|[
name|DT_VERSIONTAGIDX
argument_list|(
name|DT_VERNEED
argument_list|)
index|]
condition|)
block|{
name|Elf_Internal_Verneed
name|ivn
decl_stmt|;
name|unsigned
name|long
name|offset
decl_stmt|;
name|offset
operator|=
name|offset_from_vma
argument_list|(
name|file
argument_list|,
name|version_info
index|[
name|DT_VERSIONTAGIDX
argument_list|(
name|DT_VERNEED
argument_list|)
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|Elf_External_Verneed
argument_list|)
argument_list|)
expr_stmt|;
do|do
block|{
name|Elf_Internal_Vernaux
name|ivna
decl_stmt|;
name|Elf_External_Verneed
name|evn
decl_stmt|;
name|Elf_External_Vernaux
name|evna
decl_stmt|;
name|unsigned
name|long
name|a_off
decl_stmt|;
name|get_data
argument_list|(
operator|&
name|evn
argument_list|,
name|file
argument_list|,
name|offset
argument_list|,
sizeof|sizeof
argument_list|(
name|evn
argument_list|)
argument_list|,
name|_
argument_list|(
literal|"version need"
argument_list|)
argument_list|)
expr_stmt|;
name|ivn
operator|.
name|vn_aux
operator|=
name|BYTE_GET
argument_list|(
name|evn
operator|.
name|vn_aux
argument_list|)
expr_stmt|;
name|ivn
operator|.
name|vn_next
operator|=
name|BYTE_GET
argument_list|(
name|evn
operator|.
name|vn_next
argument_list|)
expr_stmt|;
name|a_off
operator|=
name|offset
operator|+
name|ivn
operator|.
name|vn_aux
expr_stmt|;
do|do
block|{
name|get_data
argument_list|(
operator|&
name|evna
argument_list|,
name|file
argument_list|,
name|a_off
argument_list|,
sizeof|sizeof
argument_list|(
name|evna
argument_list|)
argument_list|,
name|_
argument_list|(
literal|"version need aux (2)"
argument_list|)
argument_list|)
expr_stmt|;
name|ivna
operator|.
name|vna_next
operator|=
name|BYTE_GET
argument_list|(
name|evna
operator|.
name|vna_next
argument_list|)
expr_stmt|;
name|ivna
operator|.
name|vna_other
operator|=
name|BYTE_GET
argument_list|(
name|evna
operator|.
name|vna_other
argument_list|)
expr_stmt|;
name|a_off
operator|+=
name|ivna
operator|.
name|vna_next
expr_stmt|;
block|}
do|while
condition|(
name|ivna
operator|.
name|vna_other
operator|!=
name|data
index|[
name|cnt
operator|+
name|j
index|]
operator|&&
name|ivna
operator|.
name|vna_next
operator|!=
literal|0
condition|)
do|;
if|if
condition|(
name|ivna
operator|.
name|vna_other
operator|==
name|data
index|[
name|cnt
operator|+
name|j
index|]
condition|)
block|{
name|ivna
operator|.
name|vna_name
operator|=
name|BYTE_GET
argument_list|(
name|evna
operator|.
name|vna_name
argument_list|)
expr_stmt|;
name|name
operator|=
name|strtab
operator|+
name|ivna
operator|.
name|vna_name
expr_stmt|;
name|nn
operator|+=
name|printf
argument_list|(
literal|"(%s%-*s"
argument_list|,
name|name
argument_list|,
literal|12
operator|-
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
name|check_def
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|offset
operator|+=
name|ivn
operator|.
name|vn_next
expr_stmt|;
block|}
do|while
condition|(
name|ivn
operator|.
name|vn_next
condition|)
do|;
block|}
if|if
condition|(
name|check_def
operator|&&
name|data
index|[
name|cnt
operator|+
name|j
index|]
operator|!=
literal|0x8001
operator|&&
name|version_info
index|[
name|DT_VERSIONTAGIDX
argument_list|(
name|DT_VERDEF
argument_list|)
index|]
condition|)
block|{
name|Elf_Internal_Verdef
name|ivd
decl_stmt|;
name|Elf_External_Verdef
name|evd
decl_stmt|;
name|unsigned
name|long
name|offset
decl_stmt|;
name|offset
operator|=
name|offset_from_vma
argument_list|(
name|file
argument_list|,
name|version_info
index|[
name|DT_VERSIONTAGIDX
argument_list|(
name|DT_VERDEF
argument_list|)
index|]
argument_list|,
sizeof|sizeof
name|evd
argument_list|)
expr_stmt|;
do|do
block|{
name|get_data
argument_list|(
operator|&
name|evd
argument_list|,
name|file
argument_list|,
name|offset
argument_list|,
sizeof|sizeof
argument_list|(
name|evd
argument_list|)
argument_list|,
name|_
argument_list|(
literal|"version def"
argument_list|)
argument_list|)
expr_stmt|;
name|ivd
operator|.
name|vd_next
operator|=
name|BYTE_GET
argument_list|(
name|evd
operator|.
name|vd_next
argument_list|)
expr_stmt|;
name|ivd
operator|.
name|vd_ndx
operator|=
name|BYTE_GET
argument_list|(
name|evd
operator|.
name|vd_ndx
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|ivd
operator|.
name|vd_next
expr_stmt|;
block|}
do|while
condition|(
name|ivd
operator|.
name|vd_ndx
operator|!=
operator|(
name|data
index|[
name|cnt
operator|+
name|j
index|]
operator|&
literal|0x7fff
operator|)
operator|&&
name|ivd
operator|.
name|vd_next
operator|!=
literal|0
condition|)
do|;
if|if
condition|(
name|ivd
operator|.
name|vd_ndx
operator|==
operator|(
name|data
index|[
name|cnt
operator|+
name|j
index|]
operator|&
literal|0x7fff
operator|)
condition|)
block|{
name|Elf_External_Verdaux
name|evda
decl_stmt|;
name|Elf_Internal_Verdaux
name|ivda
decl_stmt|;
name|ivd
operator|.
name|vd_aux
operator|=
name|BYTE_GET
argument_list|(
name|evd
operator|.
name|vd_aux
argument_list|)
expr_stmt|;
name|get_data
argument_list|(
operator|&
name|evda
argument_list|,
name|file
argument_list|,
name|offset
operator|-
name|ivd
operator|.
name|vd_next
operator|+
name|ivd
operator|.
name|vd_aux
argument_list|,
sizeof|sizeof
argument_list|(
name|evda
argument_list|)
argument_list|,
name|_
argument_list|(
literal|"version def aux"
argument_list|)
argument_list|)
expr_stmt|;
name|ivda
operator|.
name|vda_name
operator|=
name|BYTE_GET
argument_list|(
name|evda
operator|.
name|vda_name
argument_list|)
expr_stmt|;
name|name
operator|=
name|strtab
operator|+
name|ivda
operator|.
name|vda_name
expr_stmt|;
name|nn
operator|+=
name|printf
argument_list|(
literal|"(%s%-*s"
argument_list|,
name|name
argument_list|,
literal|12
operator|-
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|nn
operator|<
literal|18
condition|)
name|printf
argument_list|(
literal|"%*c"
argument_list|,
literal|18
operator|-
name|nn
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
block|}
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|strtab
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|symbols
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|found
condition|)
name|printf
argument_list|(
name|_
argument_list|(
literal|"\nNo version information found in this file.\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|get_symbol_binding
parameter_list|(
name|unsigned
name|int
name|binding
parameter_list|)
block|{
specifier|static
name|char
name|buff
index|[
literal|32
index|]
decl_stmt|;
switch|switch
condition|(
name|binding
condition|)
block|{
case|case
name|STB_LOCAL
case|:
return|return
literal|"LOCAL"
return|;
case|case
name|STB_GLOBAL
case|:
return|return
literal|"GLOBAL"
return|;
case|case
name|STB_WEAK
case|:
return|return
literal|"WEAK"
return|;
default|default:
if|if
condition|(
name|binding
operator|>=
name|STB_LOPROC
operator|&&
name|binding
operator|<=
name|STB_HIPROC
condition|)
name|sprintf
argument_list|(
name|buff
argument_list|,
name|_
argument_list|(
literal|"<processor specific>: %d"
argument_list|)
argument_list|,
name|binding
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|binding
operator|>=
name|STB_LOOS
operator|&&
name|binding
operator|<=
name|STB_HIOS
condition|)
name|sprintf
argument_list|(
name|buff
argument_list|,
name|_
argument_list|(
literal|"<OS specific>: %d"
argument_list|)
argument_list|,
name|binding
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|buff
argument_list|,
name|_
argument_list|(
literal|"<unknown>: %d"
argument_list|)
argument_list|,
name|binding
argument_list|)
expr_stmt|;
return|return
name|buff
return|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|get_symbol_type
parameter_list|(
name|unsigned
name|int
name|type
parameter_list|)
block|{
specifier|static
name|char
name|buff
index|[
literal|32
index|]
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|STT_NOTYPE
case|:
return|return
literal|"NOTYPE"
return|;
case|case
name|STT_OBJECT
case|:
return|return
literal|"OBJECT"
return|;
case|case
name|STT_FUNC
case|:
return|return
literal|"FUNC"
return|;
case|case
name|STT_SECTION
case|:
return|return
literal|"SECTION"
return|;
case|case
name|STT_FILE
case|:
return|return
literal|"FILE"
return|;
case|case
name|STT_COMMON
case|:
return|return
literal|"COMMON"
return|;
case|case
name|STT_TLS
case|:
return|return
literal|"TLS"
return|;
default|default:
if|if
condition|(
name|type
operator|>=
name|STT_LOPROC
operator|&&
name|type
operator|<=
name|STT_HIPROC
condition|)
block|{
if|if
condition|(
name|elf_header
operator|.
name|e_machine
operator|==
name|EM_ARM
operator|&&
name|type
operator|==
name|STT_ARM_TFUNC
condition|)
return|return
literal|"THUMB_FUNC"
return|;
if|if
condition|(
name|elf_header
operator|.
name|e_machine
operator|==
name|EM_SPARCV9
operator|&&
name|type
operator|==
name|STT_REGISTER
condition|)
return|return
literal|"REGISTER"
return|;
if|if
condition|(
name|elf_header
operator|.
name|e_machine
operator|==
name|EM_PARISC
operator|&&
name|type
operator|==
name|STT_PARISC_MILLI
condition|)
return|return
literal|"PARISC_MILLI"
return|;
name|sprintf
argument_list|(
name|buff
argument_list|,
name|_
argument_list|(
literal|"<processor specific>: %d"
argument_list|)
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|>=
name|STT_LOOS
operator|&&
name|type
operator|<=
name|STT_HIOS
condition|)
block|{
if|if
condition|(
name|elf_header
operator|.
name|e_machine
operator|==
name|EM_PARISC
condition|)
block|{
if|if
condition|(
name|type
operator|==
name|STT_HP_OPAQUE
condition|)
return|return
literal|"HP_OPAQUE"
return|;
if|if
condition|(
name|type
operator|==
name|STT_HP_STUB
condition|)
return|return
literal|"HP_STUB"
return|;
block|}
name|sprintf
argument_list|(
name|buff
argument_list|,
name|_
argument_list|(
literal|"<OS specific>: %d"
argument_list|)
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
else|else
name|sprintf
argument_list|(
name|buff
argument_list|,
name|_
argument_list|(
literal|"<unknown>: %d"
argument_list|)
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
name|buff
return|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|get_symbol_visibility
parameter_list|(
name|unsigned
name|int
name|visibility
parameter_list|)
block|{
switch|switch
condition|(
name|visibility
condition|)
block|{
case|case
name|STV_DEFAULT
case|:
return|return
literal|"DEFAULT"
return|;
case|case
name|STV_INTERNAL
case|:
return|return
literal|"INTERNAL"
return|;
case|case
name|STV_HIDDEN
case|:
return|return
literal|"HIDDEN"
return|;
case|case
name|STV_PROTECTED
case|:
return|return
literal|"PROTECTED"
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|get_symbol_index_type
parameter_list|(
name|unsigned
name|int
name|type
parameter_list|)
block|{
specifier|static
name|char
name|buff
index|[
literal|32
index|]
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|SHN_UNDEF
case|:
return|return
literal|"UND"
return|;
case|case
name|SHN_ABS
case|:
return|return
literal|"ABS"
return|;
case|case
name|SHN_COMMON
case|:
return|return
literal|"COM"
return|;
default|default:
if|if
condition|(
name|type
operator|==
name|SHN_IA_64_ANSI_COMMON
operator|&&
name|elf_header
operator|.
name|e_machine
operator|==
name|EM_IA_64
operator|&&
name|elf_header
operator|.
name|e_ident
index|[
name|EI_OSABI
index|]
operator|==
name|ELFOSABI_HPUX
condition|)
return|return
literal|"ANSI_COM"
return|;
elseif|else
if|if
condition|(
name|type
operator|>=
name|SHN_LOPROC
operator|&&
name|type
operator|<=
name|SHN_HIPROC
condition|)
name|sprintf
argument_list|(
name|buff
argument_list|,
literal|"PRC[0x%04x]"
argument_list|,
name|type
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|type
operator|>=
name|SHN_LOOS
operator|&&
name|type
operator|<=
name|SHN_HIOS
condition|)
name|sprintf
argument_list|(
name|buff
argument_list|,
literal|"OS [0x%04x]"
argument_list|,
name|type
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|type
operator|>=
name|SHN_LORESERVE
operator|&&
name|type
operator|<=
name|SHN_HIRESERVE
condition|)
name|sprintf
argument_list|(
name|buff
argument_list|,
literal|"RSV[0x%04x]"
argument_list|,
name|type
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|buff
argument_list|,
literal|"%3d"
argument_list|,
name|type
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|buff
return|;
block|}
end_function

begin_function
specifier|static
name|int
modifier|*
name|get_dynamic_data
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
name|unsigned
name|int
name|number
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|e_data
decl_stmt|;
name|int
modifier|*
name|i_data
decl_stmt|;
name|e_data
operator|=
name|malloc
argument_list|(
name|number
operator|*
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|e_data
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"Out of memory\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|fread
argument_list|(
name|e_data
argument_list|,
literal|4
argument_list|,
name|number
argument_list|,
name|file
argument_list|)
operator|!=
name|number
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"Unable to read in dynamic data\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|i_data
operator|=
name|malloc
argument_list|(
name|number
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|i_data
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|i_data
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"Out of memory\n"
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|e_data
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
while|while
condition|(
name|number
operator|--
condition|)
name|i_data
index|[
name|number
index|]
operator|=
name|byte_get
argument_list|(
name|e_data
operator|+
name|number
operator|*
literal|4
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|e_data
argument_list|)
expr_stmt|;
return|return
name|i_data
return|;
block|}
end_function

begin_comment
comment|/* Dump the symbol table.  */
end_comment

begin_function
specifier|static
name|int
name|process_symbol_table
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|)
block|{
name|Elf_Internal_Shdr
modifier|*
name|section
decl_stmt|;
name|unsigned
name|char
name|nb
index|[
literal|4
index|]
decl_stmt|;
name|unsigned
name|char
name|nc
index|[
literal|4
index|]
decl_stmt|;
name|int
name|nbuckets
init|=
literal|0
decl_stmt|;
name|int
name|nchains
init|=
literal|0
decl_stmt|;
name|int
modifier|*
name|buckets
init|=
name|NULL
decl_stmt|;
name|int
modifier|*
name|chains
init|=
name|NULL
decl_stmt|;
if|if
condition|(
operator|!
name|do_syms
operator|&&
operator|!
name|do_histogram
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|dynamic_info
index|[
name|DT_HASH
index|]
operator|&&
operator|(
operator|(
name|do_using_dynamic
operator|&&
name|dynamic_strings
operator|!=
name|NULL
operator|)
operator|||
name|do_histogram
operator|)
condition|)
block|{
if|if
condition|(
name|fseek
argument_list|(
name|file
argument_list|,
operator|(
name|archive_file_offset
operator|+
name|offset_from_vma
argument_list|(
name|file
argument_list|,
name|dynamic_info
index|[
name|DT_HASH
index|]
argument_list|,
sizeof|sizeof
name|nb
operator|+
sizeof|sizeof
name|nc
argument_list|)
operator|)
argument_list|,
name|SEEK_SET
argument_list|)
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"Unable to seek to start of dynamic information"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|fread
argument_list|(
name|nb
argument_list|,
sizeof|sizeof
argument_list|(
name|nb
argument_list|)
argument_list|,
literal|1
argument_list|,
name|file
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"Failed to read in number of buckets\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|fread
argument_list|(
name|nc
argument_list|,
sizeof|sizeof
argument_list|(
name|nc
argument_list|)
argument_list|,
literal|1
argument_list|,
name|file
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"Failed to read in number of chains\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|nbuckets
operator|=
name|byte_get
argument_list|(
name|nb
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|nchains
operator|=
name|byte_get
argument_list|(
name|nc
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|buckets
operator|=
name|get_dynamic_data
argument_list|(
name|file
argument_list|,
name|nbuckets
argument_list|)
expr_stmt|;
name|chains
operator|=
name|get_dynamic_data
argument_list|(
name|file
argument_list|,
name|nchains
argument_list|)
expr_stmt|;
if|if
condition|(
name|buckets
operator|==
name|NULL
operator|||
name|chains
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
block|}
if|if
condition|(
name|do_syms
operator|&&
name|dynamic_info
index|[
name|DT_HASH
index|]
operator|&&
name|do_using_dynamic
operator|&&
name|dynamic_strings
operator|!=
name|NULL
condition|)
block|{
name|int
name|hn
decl_stmt|;
name|int
name|si
decl_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"\nSymbol table for image:\n"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_32bit_elf
condition|)
name|printf
argument_list|(
name|_
argument_list|(
literal|"  Num Buc:    Value  Size   Type   Bind Vis      Ndx Name\n"
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
name|_
argument_list|(
literal|"  Num Buc:    Value          Size   Type   Bind Vis      Ndx Name\n"
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|hn
operator|=
literal|0
init|;
name|hn
operator|<
name|nbuckets
condition|;
name|hn
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|buckets
index|[
name|hn
index|]
condition|)
continue|continue;
for|for
control|(
name|si
operator|=
name|buckets
index|[
name|hn
index|]
init|;
name|si
operator|<
name|nchains
operator|&&
name|si
operator|>
literal|0
condition|;
name|si
operator|=
name|chains
index|[
name|si
index|]
control|)
block|{
name|Elf_Internal_Sym
modifier|*
name|psym
decl_stmt|;
name|psym
operator|=
name|dynamic_symbols
operator|+
name|si
expr_stmt|;
name|printf
argument_list|(
literal|"  %3d %3d: "
argument_list|,
name|si
argument_list|,
name|hn
argument_list|)
expr_stmt|;
name|print_vma
argument_list|(
name|psym
operator|->
name|st_value
argument_list|,
name|LONG_HEX
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|print_vma
argument_list|(
name|psym
operator|->
name|st_size
argument_list|,
name|DEC_5
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  %6s"
argument_list|,
name|get_symbol_type
argument_list|(
name|ELF_ST_TYPE
argument_list|(
name|psym
operator|->
name|st_info
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %6s"
argument_list|,
name|get_symbol_binding
argument_list|(
name|ELF_ST_BIND
argument_list|(
name|psym
operator|->
name|st_info
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %3s"
argument_list|,
name|get_symbol_visibility
argument_list|(
name|ELF_ST_VISIBILITY
argument_list|(
name|psym
operator|->
name|st_other
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %3.3s "
argument_list|,
name|get_symbol_index_type
argument_list|(
name|psym
operator|->
name|st_shndx
argument_list|)
argument_list|)
expr_stmt|;
name|print_symbol
argument_list|(
literal|25
argument_list|,
name|dynamic_strings
operator|+
name|psym
operator|->
name|st_name
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|do_syms
operator|&&
operator|!
name|do_using_dynamic
condition|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|section
operator|=
name|section_headers
init|;
name|i
operator|<
name|elf_header
operator|.
name|e_shnum
condition|;
name|i
operator|++
operator|,
name|section
operator|++
control|)
block|{
name|unsigned
name|int
name|si
decl_stmt|;
name|char
modifier|*
name|strtab
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|symtab
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|psym
decl_stmt|;
if|if
condition|(
name|section
operator|->
name|sh_type
operator|!=
name|SHT_SYMTAB
operator|&&
name|section
operator|->
name|sh_type
operator|!=
name|SHT_DYNSYM
condition|)
continue|continue;
name|printf
argument_list|(
name|_
argument_list|(
literal|"\nSymbol table '%s' contains %lu entries:\n"
argument_list|)
argument_list|,
name|SECTION_NAME
argument_list|(
name|section
argument_list|)
argument_list|,
call|(
name|unsigned
name|long
call|)
argument_list|(
name|section
operator|->
name|sh_size
operator|/
name|section
operator|->
name|sh_entsize
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_32bit_elf
condition|)
name|printf
argument_list|(
name|_
argument_list|(
literal|"   Num:    Value  Size Type    Bind   Vis      Ndx Name\n"
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
name|_
argument_list|(
literal|"   Num:    Value          Size Type    Bind   Vis      Ndx Name\n"
argument_list|)
argument_list|)
expr_stmt|;
name|symtab
operator|=
name|GET_ELF_SYMBOLS
argument_list|(
name|file
argument_list|,
name|section
argument_list|)
expr_stmt|;
if|if
condition|(
name|symtab
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|section
operator|->
name|sh_link
operator|==
name|elf_header
operator|.
name|e_shstrndx
condition|)
name|strtab
operator|=
name|string_table
expr_stmt|;
else|else
block|{
name|Elf_Internal_Shdr
modifier|*
name|string_sec
decl_stmt|;
name|string_sec
operator|=
name|SECTION_HEADER
argument_list|(
name|section
operator|->
name|sh_link
argument_list|)
expr_stmt|;
name|strtab
operator|=
name|get_data
argument_list|(
name|NULL
argument_list|,
name|file
argument_list|,
name|string_sec
operator|->
name|sh_offset
argument_list|,
name|string_sec
operator|->
name|sh_size
argument_list|,
name|_
argument_list|(
literal|"string table"
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|si
operator|=
literal|0
operator|,
name|psym
operator|=
name|symtab
init|;
name|si
operator|<
name|section
operator|->
name|sh_size
operator|/
name|section
operator|->
name|sh_entsize
condition|;
name|si
operator|++
operator|,
name|psym
operator|++
control|)
block|{
name|printf
argument_list|(
literal|"%6d: "
argument_list|,
name|si
argument_list|)
expr_stmt|;
name|print_vma
argument_list|(
name|psym
operator|->
name|st_value
argument_list|,
name|LONG_HEX
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|print_vma
argument_list|(
name|psym
operator|->
name|st_size
argument_list|,
name|DEC_5
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %-7s"
argument_list|,
name|get_symbol_type
argument_list|(
name|ELF_ST_TYPE
argument_list|(
name|psym
operator|->
name|st_info
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %-6s"
argument_list|,
name|get_symbol_binding
argument_list|(
name|ELF_ST_BIND
argument_list|(
name|psym
operator|->
name|st_info
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %-3s"
argument_list|,
name|get_symbol_visibility
argument_list|(
name|ELF_ST_VISIBILITY
argument_list|(
name|psym
operator|->
name|st_other
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %4s "
argument_list|,
name|get_symbol_index_type
argument_list|(
name|psym
operator|->
name|st_shndx
argument_list|)
argument_list|)
expr_stmt|;
name|print_symbol
argument_list|(
literal|25
argument_list|,
name|strtab
operator|+
name|psym
operator|->
name|st_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|section
operator|->
name|sh_type
operator|==
name|SHT_DYNSYM
operator|&&
name|version_info
index|[
name|DT_VERSIONTAGIDX
argument_list|(
name|DT_VERSYM
argument_list|)
index|]
operator|!=
literal|0
condition|)
block|{
name|unsigned
name|char
name|data
index|[
literal|2
index|]
decl_stmt|;
name|unsigned
name|short
name|vers_data
decl_stmt|;
name|unsigned
name|long
name|offset
decl_stmt|;
name|int
name|is_nobits
decl_stmt|;
name|int
name|check_def
decl_stmt|;
name|offset
operator|=
name|offset_from_vma
argument_list|(
name|file
argument_list|,
name|version_info
index|[
name|DT_VERSIONTAGIDX
argument_list|(
name|DT_VERSYM
argument_list|)
index|]
argument_list|,
sizeof|sizeof
name|data
operator|+
name|si
operator|*
sizeof|sizeof
argument_list|(
name|vers_data
argument_list|)
argument_list|)
expr_stmt|;
name|get_data
argument_list|(
operator|&
name|data
argument_list|,
name|file
argument_list|,
name|offset
operator|+
name|si
operator|*
sizeof|sizeof
argument_list|(
name|vers_data
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|data
argument_list|)
argument_list|,
name|_
argument_list|(
literal|"version data"
argument_list|)
argument_list|)
expr_stmt|;
name|vers_data
operator|=
name|byte_get
argument_list|(
name|data
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|is_nobits
operator|=
operator|(
name|SECTION_HEADER
argument_list|(
name|psym
operator|->
name|st_shndx
argument_list|)
operator|->
name|sh_type
operator|==
name|SHT_NOBITS
operator|)
expr_stmt|;
name|check_def
operator|=
operator|(
name|psym
operator|->
name|st_shndx
operator|!=
name|SHN_UNDEF
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|vers_data
operator|&
literal|0x8000
operator|)
operator|||
name|vers_data
operator|>
literal|1
condition|)
block|{
if|if
condition|(
name|version_info
index|[
name|DT_VERSIONTAGIDX
argument_list|(
name|DT_VERNEED
argument_list|)
index|]
operator|&&
operator|(
name|is_nobits
operator|||
operator|!
name|check_def
operator|)
condition|)
block|{
name|Elf_External_Verneed
name|evn
decl_stmt|;
name|Elf_Internal_Verneed
name|ivn
decl_stmt|;
name|Elf_Internal_Vernaux
name|ivna
decl_stmt|;
comment|/* We must test both.  */
name|offset
operator|=
name|offset_from_vma
argument_list|(
name|file
argument_list|,
name|version_info
index|[
name|DT_VERSIONTAGIDX
argument_list|(
name|DT_VERNEED
argument_list|)
index|]
argument_list|,
sizeof|sizeof
name|evn
argument_list|)
expr_stmt|;
do|do
block|{
name|unsigned
name|long
name|vna_off
decl_stmt|;
name|get_data
argument_list|(
operator|&
name|evn
argument_list|,
name|file
argument_list|,
name|offset
argument_list|,
sizeof|sizeof
argument_list|(
name|evn
argument_list|)
argument_list|,
name|_
argument_list|(
literal|"version need"
argument_list|)
argument_list|)
expr_stmt|;
name|ivn
operator|.
name|vn_aux
operator|=
name|BYTE_GET
argument_list|(
name|evn
operator|.
name|vn_aux
argument_list|)
expr_stmt|;
name|ivn
operator|.
name|vn_next
operator|=
name|BYTE_GET
argument_list|(
name|evn
operator|.
name|vn_next
argument_list|)
expr_stmt|;
name|vna_off
operator|=
name|offset
operator|+
name|ivn
operator|.
name|vn_aux
expr_stmt|;
do|do
block|{
name|Elf_External_Vernaux
name|evna
decl_stmt|;
name|get_data
argument_list|(
operator|&
name|evna
argument_list|,
name|file
argument_list|,
name|vna_off
argument_list|,
sizeof|sizeof
argument_list|(
name|evna
argument_list|)
argument_list|,
name|_
argument_list|(
literal|"version need aux (3)"
argument_list|)
argument_list|)
expr_stmt|;
name|ivna
operator|.
name|vna_other
operator|=
name|BYTE_GET
argument_list|(
name|evna
operator|.
name|vna_other
argument_list|)
expr_stmt|;
name|ivna
operator|.
name|vna_next
operator|=
name|BYTE_GET
argument_list|(
name|evna
operator|.
name|vna_next
argument_list|)
expr_stmt|;
name|ivna
operator|.
name|vna_name
operator|=
name|BYTE_GET
argument_list|(
name|evna
operator|.
name|vna_name
argument_list|)
expr_stmt|;
name|vna_off
operator|+=
name|ivna
operator|.
name|vna_next
expr_stmt|;
block|}
do|while
condition|(
name|ivna
operator|.
name|vna_other
operator|!=
name|vers_data
operator|&&
name|ivna
operator|.
name|vna_next
operator|!=
literal|0
condition|)
do|;
if|if
condition|(
name|ivna
operator|.
name|vna_other
operator|==
name|vers_data
condition|)
break|break;
name|offset
operator|+=
name|ivn
operator|.
name|vn_next
expr_stmt|;
block|}
do|while
condition|(
name|ivn
operator|.
name|vn_next
operator|!=
literal|0
condition|)
do|;
if|if
condition|(
name|ivna
operator|.
name|vna_other
operator|==
name|vers_data
condition|)
block|{
name|printf
argument_list|(
literal|"@%s (%d)"
argument_list|,
name|strtab
operator|+
name|ivna
operator|.
name|vna_name
argument_list|,
name|ivna
operator|.
name|vna_other
argument_list|)
expr_stmt|;
name|check_def
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|is_nobits
condition|)
name|error
argument_list|(
name|_
argument_list|(
literal|"bad dynamic symbol"
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|check_def
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|check_def
condition|)
block|{
if|if
condition|(
name|vers_data
operator|!=
literal|0x8001
operator|&&
name|version_info
index|[
name|DT_VERSIONTAGIDX
argument_list|(
name|DT_VERDEF
argument_list|)
index|]
condition|)
block|{
name|Elf_Internal_Verdef
name|ivd
decl_stmt|;
name|Elf_Internal_Verdaux
name|ivda
decl_stmt|;
name|Elf_External_Verdaux
name|evda
decl_stmt|;
name|unsigned
name|long
name|offset
decl_stmt|;
name|offset
operator|=
name|offset_from_vma
argument_list|(
name|file
argument_list|,
name|version_info
index|[
name|DT_VERSIONTAGIDX
argument_list|(
name|DT_VERDEF
argument_list|)
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|Elf_External_Verdef
argument_list|)
argument_list|)
expr_stmt|;
do|do
block|{
name|Elf_External_Verdef
name|evd
decl_stmt|;
name|get_data
argument_list|(
operator|&
name|evd
argument_list|,
name|file
argument_list|,
name|offset
argument_list|,
sizeof|sizeof
argument_list|(
name|evd
argument_list|)
argument_list|,
name|_
argument_list|(
literal|"version def"
argument_list|)
argument_list|)
expr_stmt|;
name|ivd
operator|.
name|vd_ndx
operator|=
name|BYTE_GET
argument_list|(
name|evd
operator|.
name|vd_ndx
argument_list|)
expr_stmt|;
name|ivd
operator|.
name|vd_aux
operator|=
name|BYTE_GET
argument_list|(
name|evd
operator|.
name|vd_aux
argument_list|)
expr_stmt|;
name|ivd
operator|.
name|vd_next
operator|=
name|BYTE_GET
argument_list|(
name|evd
operator|.
name|vd_next
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|ivd
operator|.
name|vd_next
expr_stmt|;
block|}
do|while
condition|(
name|ivd
operator|.
name|vd_ndx
operator|!=
operator|(
name|vers_data
operator|&
literal|0x7fff
operator|)
operator|&&
name|ivd
operator|.
name|vd_next
operator|!=
literal|0
condition|)
do|;
name|offset
operator|-=
name|ivd
operator|.
name|vd_next
expr_stmt|;
name|offset
operator|+=
name|ivd
operator|.
name|vd_aux
expr_stmt|;
name|get_data
argument_list|(
operator|&
name|evda
argument_list|,
name|file
argument_list|,
name|offset
argument_list|,
sizeof|sizeof
argument_list|(
name|evda
argument_list|)
argument_list|,
name|_
argument_list|(
literal|"version def aux"
argument_list|)
argument_list|)
expr_stmt|;
name|ivda
operator|.
name|vda_name
operator|=
name|BYTE_GET
argument_list|(
name|evda
operator|.
name|vda_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|psym
operator|->
name|st_name
operator|!=
name|ivda
operator|.
name|vda_name
condition|)
name|printf
argument_list|(
operator|(
name|vers_data
operator|&
literal|0x8000
operator|)
condition|?
literal|"@%s"
else|:
literal|"@@%s"
argument_list|,
name|strtab
operator|+
name|ivda
operator|.
name|vda_name
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|symtab
argument_list|)
expr_stmt|;
if|if
condition|(
name|strtab
operator|!=
name|string_table
condition|)
name|free
argument_list|(
name|strtab
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|do_syms
condition|)
name|printf
argument_list|(
name|_
argument_list|(
literal|"\nDynamic symbol information is not available for displaying symbols.\n"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|do_histogram
operator|&&
name|buckets
operator|!=
name|NULL
condition|)
block|{
name|int
modifier|*
name|lengths
decl_stmt|;
name|int
modifier|*
name|counts
decl_stmt|;
name|int
name|hn
decl_stmt|;
name|int
name|si
decl_stmt|;
name|int
name|maxlength
init|=
literal|0
decl_stmt|;
name|int
name|nzero_counts
init|=
literal|0
decl_stmt|;
name|int
name|nsyms
init|=
literal|0
decl_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"\nHistogram for bucket list length (total of %d buckets):\n"
argument_list|)
argument_list|,
name|nbuckets
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|" Length  Number     %% of total  Coverage\n"
argument_list|)
argument_list|)
expr_stmt|;
name|lengths
operator|=
name|calloc
argument_list|(
name|nbuckets
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|lengths
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"Out of memory"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
for|for
control|(
name|hn
operator|=
literal|0
init|;
name|hn
operator|<
name|nbuckets
condition|;
operator|++
name|hn
control|)
block|{
if|if
condition|(
operator|!
name|buckets
index|[
name|hn
index|]
condition|)
continue|continue;
for|for
control|(
name|si
operator|=
name|buckets
index|[
name|hn
index|]
init|;
name|si
operator|>
literal|0
operator|&&
name|si
operator|<
name|nchains
condition|;
name|si
operator|=
name|chains
index|[
name|si
index|]
control|)
block|{
operator|++
name|nsyms
expr_stmt|;
if|if
condition|(
name|maxlength
operator|<
operator|++
name|lengths
index|[
name|hn
index|]
condition|)
operator|++
name|maxlength
expr_stmt|;
block|}
block|}
name|counts
operator|=
name|calloc
argument_list|(
name|maxlength
operator|+
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|counts
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"Out of memory"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
for|for
control|(
name|hn
operator|=
literal|0
init|;
name|hn
operator|<
name|nbuckets
condition|;
operator|++
name|hn
control|)
operator|++
name|counts
index|[
name|lengths
index|[
name|hn
index|]
index|]
expr_stmt|;
if|if
condition|(
name|nbuckets
operator|>
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"      0  %-10d (%5.1f%%)\n"
argument_list|,
name|counts
index|[
literal|0
index|]
argument_list|,
operator|(
name|counts
index|[
literal|0
index|]
operator|*
literal|100.0
operator|)
operator|/
name|nbuckets
argument_list|)
expr_stmt|;
for|for
control|(
name|si
operator|=
literal|1
init|;
name|si
operator|<=
name|maxlength
condition|;
operator|++
name|si
control|)
block|{
name|nzero_counts
operator|+=
name|counts
index|[
name|si
index|]
operator|*
name|si
expr_stmt|;
name|printf
argument_list|(
literal|"%7d  %-10d (%5.1f%%)    %5.1f%%\n"
argument_list|,
name|si
argument_list|,
name|counts
index|[
name|si
index|]
argument_list|,
operator|(
name|counts
index|[
name|si
index|]
operator|*
literal|100.0
operator|)
operator|/
name|nbuckets
argument_list|,
operator|(
name|nzero_counts
operator|*
literal|100.0
operator|)
operator|/
name|nsyms
argument_list|)
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|counts
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|lengths
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|buckets
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|buckets
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|chains
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|process_syminfo
parameter_list|(
name|FILE
modifier|*
name|file
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
if|if
condition|(
name|dynamic_syminfo
operator|==
name|NULL
operator|||
operator|!
name|do_dynamic
condition|)
comment|/* No syminfo, this is ok.  */
return|return
literal|1
return|;
comment|/* There better should be a dynamic symbol section.  */
if|if
condition|(
name|dynamic_symbols
operator|==
name|NULL
operator|||
name|dynamic_strings
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|dynamic_addr
condition|)
name|printf
argument_list|(
name|_
argument_list|(
literal|"\nDynamic info segment at offset 0x%lx contains %d entries:\n"
argument_list|)
argument_list|,
name|dynamic_syminfo_offset
argument_list|,
name|dynamic_syminfo_nent
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|" Num: Name                           BoundTo     Flags\n"
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dynamic_syminfo_nent
condition|;
operator|++
name|i
control|)
block|{
name|unsigned
name|short
name|int
name|flags
init|=
name|dynamic_syminfo
index|[
name|i
index|]
operator|.
name|si_flags
decl_stmt|;
name|printf
argument_list|(
literal|"%4d: "
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|print_symbol
argument_list|(
literal|30
argument_list|,
name|dynamic_strings
operator|+
name|dynamic_symbols
index|[
name|i
index|]
operator|.
name|st_name
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|dynamic_syminfo
index|[
name|i
index|]
operator|.
name|si_boundto
condition|)
block|{
case|case
name|SYMINFO_BT_SELF
case|:
name|fputs
argument_list|(
literal|"SELF       "
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
break|break;
case|case
name|SYMINFO_BT_PARENT
case|:
name|fputs
argument_list|(
literal|"PARENT     "
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|dynamic_syminfo
index|[
name|i
index|]
operator|.
name|si_boundto
operator|>
literal|0
operator|&&
name|dynamic_syminfo
index|[
name|i
index|]
operator|.
name|si_boundto
operator|<
name|dynamic_size
condition|)
block|{
name|print_symbol
argument_list|(
literal|10
argument_list|,
name|dynamic_strings
operator|+
operator|(
name|dynamic_segment
index|[
name|dynamic_syminfo
index|[
name|i
index|]
operator|.
name|si_boundto
index|]
operator|.
name|d_un
operator|.
name|d_val
operator|)
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
else|else
name|printf
argument_list|(
literal|"%-10d "
argument_list|,
name|dynamic_syminfo
index|[
name|i
index|]
operator|.
name|si_boundto
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|flags
operator|&
name|SYMINFO_FLG_DIRECT
condition|)
name|printf
argument_list|(
literal|" DIRECT"
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|SYMINFO_FLG_PASSTHRU
condition|)
name|printf
argument_list|(
literal|" PASSTHRU"
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|SYMINFO_FLG_COPY
condition|)
name|printf
argument_list|(
literal|" COPY"
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|SYMINFO_FLG_LAZYLOAD
condition|)
name|printf
argument_list|(
literal|" LAZYLOAD"
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|""
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|SUPPORT_DISASSEMBLY
end_ifdef

begin_function
specifier|static
name|void
name|disassemble_section
parameter_list|(
name|Elf_Internal_Shdr
modifier|*
name|section
parameter_list|,
name|FILE
modifier|*
name|file
parameter_list|)
block|{
name|printf
argument_list|(
name|_
argument_list|(
literal|"\nAssembly dump of section %s\n"
argument_list|)
argument_list|,
name|SECTION_NAME
argument_list|(
name|section
argument_list|)
argument_list|)
expr_stmt|;
comment|/* XXX -- to be done --- XXX */
return|return
literal|1
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|dump_section
parameter_list|(
name|Elf_Internal_Shdr
modifier|*
name|section
parameter_list|,
name|FILE
modifier|*
name|file
parameter_list|)
block|{
name|bfd_size_type
name|bytes
decl_stmt|;
name|bfd_vma
name|addr
decl_stmt|;
name|unsigned
name|char
modifier|*
name|data
decl_stmt|;
name|unsigned
name|char
modifier|*
name|start
decl_stmt|;
name|bytes
operator|=
name|section
operator|->
name|sh_size
expr_stmt|;
if|if
condition|(
name|bytes
operator|==
literal|0
operator|||
name|section
operator|->
name|sh_type
operator|==
name|SHT_NOBITS
condition|)
block|{
name|printf
argument_list|(
name|_
argument_list|(
literal|"\nSection '%s' has no data to dump.\n"
argument_list|)
argument_list|,
name|SECTION_NAME
argument_list|(
name|section
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
name|printf
argument_list|(
name|_
argument_list|(
literal|"\nHex dump of section '%s':\n"
argument_list|)
argument_list|,
name|SECTION_NAME
argument_list|(
name|section
argument_list|)
argument_list|)
expr_stmt|;
name|addr
operator|=
name|section
operator|->
name|sh_addr
expr_stmt|;
name|start
operator|=
name|get_data
argument_list|(
name|NULL
argument_list|,
name|file
argument_list|,
name|section
operator|->
name|sh_offset
argument_list|,
name|bytes
argument_list|,
name|_
argument_list|(
literal|"section data"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|start
condition|)
return|return
literal|0
return|;
name|data
operator|=
name|start
expr_stmt|;
while|while
condition|(
name|bytes
condition|)
block|{
name|int
name|j
decl_stmt|;
name|int
name|k
decl_stmt|;
name|int
name|lbytes
decl_stmt|;
name|lbytes
operator|=
operator|(
name|bytes
operator|>
literal|16
condition|?
literal|16
else|:
name|bytes
operator|)
expr_stmt|;
name|printf
argument_list|(
literal|"  0x%8.8lx "
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|addr
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|elf_header
operator|.
name|e_ident
index|[
name|EI_DATA
index|]
condition|)
block|{
default|default:
case|case
name|ELFDATA2LSB
case|:
for|for
control|(
name|j
operator|=
literal|15
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
block|{
if|if
condition|(
name|j
operator|<
name|lbytes
condition|)
name|printf
argument_list|(
literal|"%2.2x"
argument_list|,
name|data
index|[
name|j
index|]
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"  "
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|j
operator|&
literal|0x3
operator|)
condition|)
name|printf
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ELFDATA2MSB
case|:
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|16
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|j
operator|<
name|lbytes
condition|)
name|printf
argument_list|(
literal|"%2.2x"
argument_list|,
name|data
index|[
name|j
index|]
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"  "
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|j
operator|&
literal|3
operator|)
operator|==
literal|3
condition|)
name|printf
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|lbytes
condition|;
name|j
operator|++
control|)
block|{
name|k
operator|=
name|data
index|[
name|j
index|]
expr_stmt|;
if|if
condition|(
name|k
operator|>=
literal|' '
operator|&&
name|k
operator|<
literal|0x7f
condition|)
name|printf
argument_list|(
literal|"%c"
argument_list|,
name|k
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"."
argument_list|)
expr_stmt|;
block|}
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|data
operator|+=
name|lbytes
expr_stmt|;
name|addr
operator|+=
name|lbytes
expr_stmt|;
name|bytes
operator|-=
name|lbytes
expr_stmt|;
block|}
name|free
argument_list|(
name|start
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|unsigned
name|long
name|int
name|read_leb128
parameter_list|(
name|unsigned
name|char
modifier|*
name|data
parameter_list|,
name|int
modifier|*
name|length_return
parameter_list|,
name|int
name|sign
parameter_list|)
block|{
name|unsigned
name|long
name|int
name|result
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|num_read
init|=
literal|0
decl_stmt|;
name|int
name|shift
init|=
literal|0
decl_stmt|;
name|unsigned
name|char
name|byte
decl_stmt|;
do|do
block|{
name|byte
operator|=
operator|*
name|data
operator|++
expr_stmt|;
name|num_read
operator|++
expr_stmt|;
name|result
operator||=
operator|(
name|byte
operator|&
literal|0x7f
operator|)
operator|<<
name|shift
expr_stmt|;
name|shift
operator|+=
literal|7
expr_stmt|;
block|}
do|while
condition|(
name|byte
operator|&
literal|0x80
condition|)
do|;
if|if
condition|(
name|length_return
operator|!=
name|NULL
condition|)
operator|*
name|length_return
operator|=
name|num_read
expr_stmt|;
if|if
condition|(
name|sign
operator|&&
operator|(
name|shift
operator|<
literal|32
operator|)
operator|&&
operator|(
name|byte
operator|&
literal|0x40
operator|)
condition|)
name|result
operator||=
operator|-
literal|1
operator|<<
name|shift
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_typedef
typedef|typedef
struct|struct
name|State_Machine_Registers
block|{
name|unsigned
name|long
name|address
decl_stmt|;
name|unsigned
name|int
name|file
decl_stmt|;
name|unsigned
name|int
name|line
decl_stmt|;
name|unsigned
name|int
name|column
decl_stmt|;
name|int
name|is_stmt
decl_stmt|;
name|int
name|basic_block
decl_stmt|;
name|int
name|end_sequence
decl_stmt|;
comment|/* This variable hold the number of the last entry seen    in the File Table.  */
name|unsigned
name|int
name|last_file_entry
decl_stmt|;
block|}
name|SMR
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|SMR
name|state_machine_regs
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|reset_state_machine
parameter_list|(
name|int
name|is_stmt
parameter_list|)
block|{
name|state_machine_regs
operator|.
name|address
operator|=
literal|0
expr_stmt|;
name|state_machine_regs
operator|.
name|file
operator|=
literal|1
expr_stmt|;
name|state_machine_regs
operator|.
name|line
operator|=
literal|1
expr_stmt|;
name|state_machine_regs
operator|.
name|column
operator|=
literal|0
expr_stmt|;
name|state_machine_regs
operator|.
name|is_stmt
operator|=
name|is_stmt
expr_stmt|;
name|state_machine_regs
operator|.
name|basic_block
operator|=
literal|0
expr_stmt|;
name|state_machine_regs
operator|.
name|end_sequence
operator|=
literal|0
expr_stmt|;
name|state_machine_regs
operator|.
name|last_file_entry
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handled an extend line op.  Returns true if this is the end    of sequence.  */
end_comment

begin_function
specifier|static
name|int
name|process_extended_line_op
parameter_list|(
name|unsigned
name|char
modifier|*
name|data
parameter_list|,
name|int
name|is_stmt
parameter_list|,
name|int
name|pointer_size
parameter_list|)
block|{
name|unsigned
name|char
name|op_code
decl_stmt|;
name|int
name|bytes_read
decl_stmt|;
name|unsigned
name|int
name|len
decl_stmt|;
name|unsigned
name|char
modifier|*
name|name
decl_stmt|;
name|unsigned
name|long
name|adr
decl_stmt|;
name|len
operator|=
name|read_leb128
argument_list|(
name|data
argument_list|,
operator|&
name|bytes_read
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|data
operator|+=
name|bytes_read
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
block|{
name|warn
argument_list|(
name|_
argument_list|(
literal|"badly formed extended line op encountered!\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|bytes_read
return|;
block|}
name|len
operator|+=
name|bytes_read
expr_stmt|;
name|op_code
operator|=
operator|*
name|data
operator|++
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"  Extended opcode %d: "
argument_list|)
argument_list|,
name|op_code
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|op_code
condition|)
block|{
case|case
name|DW_LNE_end_sequence
case|:
name|printf
argument_list|(
name|_
argument_list|(
literal|"End of Sequence\n\n"
argument_list|)
argument_list|)
expr_stmt|;
name|reset_state_machine
argument_list|(
name|is_stmt
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_LNE_set_address
case|:
name|adr
operator|=
name|byte_get
argument_list|(
name|data
argument_list|,
name|pointer_size
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"set Address to 0x%lx\n"
argument_list|)
argument_list|,
name|adr
argument_list|)
expr_stmt|;
name|state_machine_regs
operator|.
name|address
operator|=
name|adr
expr_stmt|;
break|break;
case|case
name|DW_LNE_define_file
case|:
name|printf
argument_list|(
name|_
argument_list|(
literal|"  define new File Table entry\n"
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"  Entry\tDir\tTime\tSize\tName\n"
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"   %d\t"
argument_list|)
argument_list|,
operator|++
name|state_machine_regs
operator|.
name|last_file_entry
argument_list|)
expr_stmt|;
name|name
operator|=
name|data
expr_stmt|;
name|data
operator|+=
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|data
argument_list|)
operator|+
literal|1
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"%lu\t"
argument_list|)
argument_list|,
name|read_leb128
argument_list|(
name|data
argument_list|,
operator|&
name|bytes_read
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|data
operator|+=
name|bytes_read
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"%lu\t"
argument_list|)
argument_list|,
name|read_leb128
argument_list|(
name|data
argument_list|,
operator|&
name|bytes_read
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|data
operator|+=
name|bytes_read
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"%lu\t"
argument_list|)
argument_list|,
name|read_leb128
argument_list|(
name|data
argument_list|,
operator|&
name|bytes_read
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"%s\n\n"
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
name|_
argument_list|(
literal|"UNKNOWN: length %d\n"
argument_list|)
argument_list|,
name|len
operator|-
name|bytes_read
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|len
return|;
block|}
end_function

begin_comment
comment|/* Finds section NAME inside FILE and returns a    pointer to it, or NULL upon failure.  */
end_comment

begin_function
specifier|static
name|Elf_Internal_Shdr
modifier|*
name|find_section
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|Elf_Internal_Shdr
modifier|*
name|sec
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|elf_header
operator|.
name|e_shnum
operator|,
name|sec
operator|=
name|section_headers
operator|+
name|i
operator|-
literal|1
init|;
name|i
condition|;
operator|--
name|i
operator|,
operator|--
name|sec
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|SECTION_NAME
argument_list|(
name|sec
argument_list|)
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|i
operator|&&
name|sec
operator|&&
name|sec
operator|->
name|sh_size
operator|!=
literal|0
condition|)
return|return
name|sec
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Size of pointers in the .debug_line section.  This information is not    really present in that section.  It's obtained before dumping the debug    sections by doing some pre-scan of the .debug_info section.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|int
modifier|*
name|debug_line_pointer_sizes
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|num_debug_line_pointer_sizes
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Locate and scan the .debug_info section in the file and record the pointer    sizes for the compilation units in it.  Usually an executable will have    just one pointer size, but this is not guaranteed, and so we try not to    make any assumptions.  Returns zero upon failure, or the number of    compilation units upon success.  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|get_debug_line_pointer_sizes
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|)
block|{
name|Elf_Internal_Shdr
modifier|*
name|section
decl_stmt|;
name|unsigned
name|char
modifier|*
name|start
decl_stmt|;
name|unsigned
name|char
modifier|*
name|end
decl_stmt|;
name|unsigned
name|char
modifier|*
name|begin
decl_stmt|;
name|unsigned
name|long
name|length
decl_stmt|;
name|unsigned
name|int
name|num_units
decl_stmt|;
name|unsigned
name|int
name|unit
decl_stmt|;
name|section
operator|=
name|find_section
argument_list|(
literal|".debug_info"
argument_list|)
expr_stmt|;
if|if
condition|(
name|section
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|length
operator|=
name|section
operator|->
name|sh_size
expr_stmt|;
name|start
operator|=
name|get_data
argument_list|(
name|NULL
argument_list|,
name|file
argument_list|,
name|section
operator|->
name|sh_offset
argument_list|,
name|section
operator|->
name|sh_size
argument_list|,
name|_
argument_list|(
literal|"extracting pointer sizes from .debug_info section"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|start
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|end
operator|=
name|start
operator|+
name|section
operator|->
name|sh_size
expr_stmt|;
comment|/* First scan the section to get the number of comp units.  */
for|for
control|(
name|begin
operator|=
name|start
operator|,
name|num_units
operator|=
literal|0
init|;
name|begin
operator|<
name|end
condition|;
name|num_units
operator|++
control|)
block|{
comment|/* Read the first 4 bytes.  For a 32-bit DWARF section, this will 	 be the length.  For a 64-bit DWARF section, it'll be the escape 	 code 0xffffffff followed by an 8 byte length.  */
name|length
operator|=
name|byte_get
argument_list|(
name|begin
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|length
operator|==
literal|0xffffffff
condition|)
block|{
name|length
operator|=
name|byte_get
argument_list|(
name|begin
operator|+
literal|4
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|begin
operator|+=
name|length
operator|+
literal|12
expr_stmt|;
block|}
else|else
name|begin
operator|+=
name|length
operator|+
literal|4
expr_stmt|;
block|}
if|if
condition|(
name|num_units
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"No comp units in .debug_info section ?"
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|start
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Then allocate an array to hold the pointer sizes.  */
name|debug_line_pointer_sizes
operator|=
name|malloc
argument_list|(
name|num_units
operator|*
sizeof|sizeof
expr|*
name|debug_line_pointer_sizes
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug_line_pointer_sizes
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"Not enough memory for a pointer size array of %u entries"
argument_list|)
argument_list|,
name|num_units
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|start
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Populate the array.  */
for|for
control|(
name|begin
operator|=
name|start
operator|,
name|unit
operator|=
literal|0
init|;
name|begin
operator|<
name|end
condition|;
name|unit
operator|++
control|)
block|{
name|length
operator|=
name|byte_get
argument_list|(
name|begin
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|length
operator|==
literal|0xffffffff
condition|)
block|{
comment|/* For 64-bit DWARF, the 1-byte address_size field is 22 bytes 	     from the start of the section.  This is computed as follows:  	     unit_length:         12 bytes 	     version:              2 bytes 	     debug_abbrev_offset:  8 bytes 	     ----------------------------- 	     Total:               22 bytes  */
name|debug_line_pointer_sizes
index|[
name|unit
index|]
operator|=
name|byte_get
argument_list|(
name|begin
operator|+
literal|22
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|length
operator|=
name|byte_get
argument_list|(
name|begin
operator|+
literal|4
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|begin
operator|+=
name|length
operator|+
literal|12
expr_stmt|;
block|}
else|else
block|{
comment|/* For 32-bit DWARF, the 1-byte address_size field is 10 bytes from 	     the start of the section:  	     unit_length:          4 bytes 	     version:              2 bytes 	     debug_abbrev_offset:  4 bytes 	     ----------------------------- 	     Total:               10 bytes  */
name|debug_line_pointer_sizes
index|[
name|unit
index|]
operator|=
name|byte_get
argument_list|(
name|begin
operator|+
literal|10
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|begin
operator|+=
name|length
operator|+
literal|4
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|start
argument_list|)
expr_stmt|;
name|num_debug_line_pointer_sizes
operator|=
name|num_units
expr_stmt|;
return|return
name|num_units
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|display_debug_lines
parameter_list|(
name|Elf_Internal_Shdr
modifier|*
name|section
parameter_list|,
name|unsigned
name|char
modifier|*
name|start
parameter_list|,
name|FILE
modifier|*
name|file
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|hdrptr
decl_stmt|;
name|DWARF2_Internal_LineInfo
name|info
decl_stmt|;
name|unsigned
name|char
modifier|*
name|standard_opcodes
decl_stmt|;
name|unsigned
name|char
modifier|*
name|data
init|=
name|start
decl_stmt|;
name|unsigned
name|char
modifier|*
name|end
init|=
name|start
operator|+
name|section
operator|->
name|sh_size
decl_stmt|;
name|unsigned
name|char
modifier|*
name|end_of_sequence
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|offset_size
decl_stmt|;
name|int
name|initial_length_size
decl_stmt|;
name|unsigned
name|int
name|comp_unit
init|=
literal|0
decl_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"\nDump of debug contents of section %s:\n\n"
argument_list|)
argument_list|,
name|SECTION_NAME
argument_list|(
name|section
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|num_debug_line_pointer_sizes
operator|==
literal|0
condition|)
name|get_debug_line_pointer_sizes
argument_list|(
name|file
argument_list|)
expr_stmt|;
while|while
condition|(
name|data
operator|<
name|end
condition|)
block|{
name|unsigned
name|int
name|pointer_size
decl_stmt|;
name|hdrptr
operator|=
name|data
expr_stmt|;
comment|/* Check the length of the block.  */
name|info
operator|.
name|li_length
operator|=
name|byte_get
argument_list|(
name|hdrptr
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|hdrptr
operator|+=
literal|4
expr_stmt|;
if|if
condition|(
name|info
operator|.
name|li_length
operator|==
literal|0xffffffff
condition|)
block|{
comment|/* This section is 64-bit DWARF 3.  */
name|info
operator|.
name|li_length
operator|=
name|byte_get
argument_list|(
name|hdrptr
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|hdrptr
operator|+=
literal|8
expr_stmt|;
name|offset_size
operator|=
literal|8
expr_stmt|;
name|initial_length_size
operator|=
literal|12
expr_stmt|;
block|}
else|else
block|{
name|offset_size
operator|=
literal|4
expr_stmt|;
name|initial_length_size
operator|=
literal|4
expr_stmt|;
block|}
if|if
condition|(
name|info
operator|.
name|li_length
operator|+
name|initial_length_size
operator|>
name|section
operator|->
name|sh_size
condition|)
block|{
name|warn
argument_list|(
name|_
argument_list|(
literal|"The line info appears to be corrupt - the section is too small\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Check its version number.  */
name|info
operator|.
name|li_version
operator|=
name|byte_get
argument_list|(
name|hdrptr
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|hdrptr
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|info
operator|.
name|li_version
operator|!=
literal|2
operator|&&
name|info
operator|.
name|li_version
operator|!=
literal|3
condition|)
block|{
name|warn
argument_list|(
name|_
argument_list|(
literal|"Only DWARF version 2 and 3 line info is currently supported.\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|info
operator|.
name|li_prologue_length
operator|=
name|byte_get
argument_list|(
name|hdrptr
argument_list|,
name|offset_size
argument_list|)
expr_stmt|;
name|hdrptr
operator|+=
name|offset_size
expr_stmt|;
name|info
operator|.
name|li_min_insn_length
operator|=
name|byte_get
argument_list|(
name|hdrptr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|hdrptr
operator|++
expr_stmt|;
name|info
operator|.
name|li_default_is_stmt
operator|=
name|byte_get
argument_list|(
name|hdrptr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|hdrptr
operator|++
expr_stmt|;
name|info
operator|.
name|li_line_base
operator|=
name|byte_get
argument_list|(
name|hdrptr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|hdrptr
operator|++
expr_stmt|;
name|info
operator|.
name|li_line_range
operator|=
name|byte_get
argument_list|(
name|hdrptr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|hdrptr
operator|++
expr_stmt|;
name|info
operator|.
name|li_opcode_base
operator|=
name|byte_get
argument_list|(
name|hdrptr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|hdrptr
operator|++
expr_stmt|;
comment|/* Sign extend the line base field.  */
name|info
operator|.
name|li_line_base
operator|<<=
literal|24
expr_stmt|;
name|info
operator|.
name|li_line_base
operator|>>=
literal|24
expr_stmt|;
comment|/* Get the pointer size from the comp unit associated 	 with this block of line number information.  */
if|if
condition|(
name|comp_unit
operator|>=
name|num_debug_line_pointer_sizes
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"Not enough comp units for .debug_lines section\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
block|{
name|pointer_size
operator|=
name|debug_line_pointer_sizes
index|[
name|comp_unit
index|]
expr_stmt|;
name|comp_unit
operator|++
expr_stmt|;
block|}
name|printf
argument_list|(
name|_
argument_list|(
literal|"  Length:                      %ld\n"
argument_list|)
argument_list|,
name|info
operator|.
name|li_length
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"  DWARF Version:               %d\n"
argument_list|)
argument_list|,
name|info
operator|.
name|li_version
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"  Prologue Length:             %d\n"
argument_list|)
argument_list|,
name|info
operator|.
name|li_prologue_length
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"  Minimum Instruction Length:  %d\n"
argument_list|)
argument_list|,
name|info
operator|.
name|li_min_insn_length
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"  Initial value of 'is_stmt':  %d\n"
argument_list|)
argument_list|,
name|info
operator|.
name|li_default_is_stmt
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"  Line Base:                   %d\n"
argument_list|)
argument_list|,
name|info
operator|.
name|li_line_base
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"  Line Range:                  %d\n"
argument_list|)
argument_list|,
name|info
operator|.
name|li_line_range
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"  Opcode Base:                 %d\n"
argument_list|)
argument_list|,
name|info
operator|.
name|li_opcode_base
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"  (Pointer size:               %u)\n"
argument_list|)
argument_list|,
name|pointer_size
argument_list|)
expr_stmt|;
name|end_of_sequence
operator|=
name|data
operator|+
name|info
operator|.
name|li_length
operator|+
name|initial_length_size
expr_stmt|;
name|reset_state_machine
argument_list|(
name|info
operator|.
name|li_default_is_stmt
argument_list|)
expr_stmt|;
comment|/* Display the contents of the Opcodes table.  */
name|standard_opcodes
operator|=
name|hdrptr
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"\n Opcodes:\n"
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|info
operator|.
name|li_opcode_base
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
name|_
argument_list|(
literal|"  Opcode %d has %d args\n"
argument_list|)
argument_list|,
name|i
argument_list|,
name|standard_opcodes
index|[
name|i
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
comment|/* Display the contents of the Directory table.  */
name|data
operator|=
name|standard_opcodes
operator|+
name|info
operator|.
name|li_opcode_base
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|*
name|data
operator|==
literal|0
condition|)
name|printf
argument_list|(
name|_
argument_list|(
literal|"\n The Directory Table is empty.\n"
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|printf
argument_list|(
name|_
argument_list|(
literal|"\n The Directory Table:\n"
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|data
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
name|_
argument_list|(
literal|"  %s\n"
argument_list|)
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|data
operator|+=
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|data
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
block|}
comment|/* Skip the NUL at the end of the table.  */
name|data
operator|++
expr_stmt|;
comment|/* Display the contents of the File Name table.  */
if|if
condition|(
operator|*
name|data
operator|==
literal|0
condition|)
name|printf
argument_list|(
name|_
argument_list|(
literal|"\n The File Name Table is empty.\n"
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|printf
argument_list|(
name|_
argument_list|(
literal|"\n The File Name Table:\n"
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"  Entry\tDir\tTime\tSize\tName\n"
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|data
operator|!=
literal|0
condition|)
block|{
name|unsigned
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|bytes_read
decl_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"  %d\t"
argument_list|)
argument_list|,
operator|++
name|state_machine_regs
operator|.
name|last_file_entry
argument_list|)
expr_stmt|;
name|name
operator|=
name|data
expr_stmt|;
name|data
operator|+=
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|data
argument_list|)
operator|+
literal|1
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"%lu\t"
argument_list|)
argument_list|,
name|read_leb128
argument_list|(
name|data
argument_list|,
operator|&
name|bytes_read
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|data
operator|+=
name|bytes_read
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"%lu\t"
argument_list|)
argument_list|,
name|read_leb128
argument_list|(
name|data
argument_list|,
operator|&
name|bytes_read
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|data
operator|+=
name|bytes_read
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"%lu\t"
argument_list|)
argument_list|,
name|read_leb128
argument_list|(
name|data
argument_list|,
operator|&
name|bytes_read
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|data
operator|+=
name|bytes_read
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"%s\n"
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Skip the NUL at the end of the table.  */
name|data
operator|++
expr_stmt|;
comment|/* Now display the statements.  */
name|printf
argument_list|(
name|_
argument_list|(
literal|"\n Line Number Statements:\n"
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|data
operator|<
name|end_of_sequence
condition|)
block|{
name|unsigned
name|char
name|op_code
decl_stmt|;
name|int
name|adv
decl_stmt|;
name|int
name|bytes_read
decl_stmt|;
name|op_code
operator|=
operator|*
name|data
operator|++
expr_stmt|;
if|if
condition|(
name|op_code
operator|>=
name|info
operator|.
name|li_opcode_base
condition|)
block|{
name|op_code
operator|-=
name|info
operator|.
name|li_opcode_base
expr_stmt|;
name|adv
operator|=
operator|(
name|op_code
operator|/
name|info
operator|.
name|li_line_range
operator|)
operator|*
name|info
operator|.
name|li_min_insn_length
expr_stmt|;
name|state_machine_regs
operator|.
name|address
operator|+=
name|adv
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"  Special opcode %d: advance Address by %d to 0x%lx"
argument_list|)
argument_list|,
name|op_code
argument_list|,
name|adv
argument_list|,
name|state_machine_regs
operator|.
name|address
argument_list|)
expr_stmt|;
name|adv
operator|=
operator|(
name|op_code
operator|%
name|info
operator|.
name|li_line_range
operator|)
operator|+
name|info
operator|.
name|li_line_base
expr_stmt|;
name|state_machine_regs
operator|.
name|line
operator|+=
name|adv
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|" and Line by %d to %d\n"
argument_list|)
argument_list|,
name|adv
argument_list|,
name|state_machine_regs
operator|.
name|line
argument_list|)
expr_stmt|;
block|}
else|else
switch|switch
condition|(
name|op_code
condition|)
block|{
case|case
name|DW_LNS_extended_op
case|:
name|data
operator|+=
name|process_extended_line_op
argument_list|(
name|data
argument_list|,
name|info
operator|.
name|li_default_is_stmt
argument_list|,
name|pointer_size
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_LNS_copy
case|:
name|printf
argument_list|(
name|_
argument_list|(
literal|"  Copy\n"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_LNS_advance_pc
case|:
name|adv
operator|=
name|info
operator|.
name|li_min_insn_length
operator|*
name|read_leb128
argument_list|(
name|data
argument_list|,
operator|&
name|bytes_read
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|data
operator|+=
name|bytes_read
expr_stmt|;
name|state_machine_regs
operator|.
name|address
operator|+=
name|adv
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"  Advance PC by %d to %lx\n"
argument_list|)
argument_list|,
name|adv
argument_list|,
name|state_machine_regs
operator|.
name|address
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_LNS_advance_line
case|:
name|adv
operator|=
name|read_leb128
argument_list|(
name|data
argument_list|,
operator|&
name|bytes_read
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|data
operator|+=
name|bytes_read
expr_stmt|;
name|state_machine_regs
operator|.
name|line
operator|+=
name|adv
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"  Advance Line by %d to %d\n"
argument_list|)
argument_list|,
name|adv
argument_list|,
name|state_machine_regs
operator|.
name|line
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_LNS_set_file
case|:
name|adv
operator|=
name|read_leb128
argument_list|(
name|data
argument_list|,
operator|&
name|bytes_read
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|data
operator|+=
name|bytes_read
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"  Set File Name to entry %d in the File Name Table\n"
argument_list|)
argument_list|,
name|adv
argument_list|)
expr_stmt|;
name|state_machine_regs
operator|.
name|file
operator|=
name|adv
expr_stmt|;
break|break;
case|case
name|DW_LNS_set_column
case|:
name|adv
operator|=
name|read_leb128
argument_list|(
name|data
argument_list|,
operator|&
name|bytes_read
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|data
operator|+=
name|bytes_read
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"  Set column to %d\n"
argument_list|)
argument_list|,
name|adv
argument_list|)
expr_stmt|;
name|state_machine_regs
operator|.
name|column
operator|=
name|adv
expr_stmt|;
break|break;
case|case
name|DW_LNS_negate_stmt
case|:
name|adv
operator|=
name|state_machine_regs
operator|.
name|is_stmt
expr_stmt|;
name|adv
operator|=
operator|!
name|adv
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"  Set is_stmt to %d\n"
argument_list|)
argument_list|,
name|adv
argument_list|)
expr_stmt|;
name|state_machine_regs
operator|.
name|is_stmt
operator|=
name|adv
expr_stmt|;
break|break;
case|case
name|DW_LNS_set_basic_block
case|:
name|printf
argument_list|(
name|_
argument_list|(
literal|"  Set basic block\n"
argument_list|)
argument_list|)
expr_stmt|;
name|state_machine_regs
operator|.
name|basic_block
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|DW_LNS_const_add_pc
case|:
name|adv
operator|=
operator|(
operator|(
operator|(
literal|255
operator|-
name|info
operator|.
name|li_opcode_base
operator|)
operator|/
name|info
operator|.
name|li_line_range
operator|)
operator|*
name|info
operator|.
name|li_min_insn_length
operator|)
expr_stmt|;
name|state_machine_regs
operator|.
name|address
operator|+=
name|adv
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"  Advance PC by constant %d to 0x%lx\n"
argument_list|)
argument_list|,
name|adv
argument_list|,
name|state_machine_regs
operator|.
name|address
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_LNS_fixed_advance_pc
case|:
name|adv
operator|=
name|byte_get
argument_list|(
name|data
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|data
operator|+=
literal|2
expr_stmt|;
name|state_machine_regs
operator|.
name|address
operator|+=
name|adv
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"  Advance PC by fixed size amount %d to 0x%lx\n"
argument_list|)
argument_list|,
name|adv
argument_list|,
name|state_machine_regs
operator|.
name|address
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_LNS_set_prologue_end
case|:
name|printf
argument_list|(
name|_
argument_list|(
literal|"  Set prologue_end to true\n"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_LNS_set_epilogue_begin
case|:
name|printf
argument_list|(
name|_
argument_list|(
literal|"  Set epilogue_begin to true\n"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_LNS_set_isa
case|:
name|adv
operator|=
name|read_leb128
argument_list|(
name|data
argument_list|,
operator|&
name|bytes_read
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|data
operator|+=
name|bytes_read
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"  Set ISA to %d\n"
argument_list|)
argument_list|,
name|adv
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
name|_
argument_list|(
literal|"  Unknown opcode %d with operands: "
argument_list|)
argument_list|,
name|op_code
argument_list|)
expr_stmt|;
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|standard_opcodes
index|[
name|op_code
operator|-
literal|1
index|]
init|;
name|i
operator|>
literal|0
condition|;
operator|--
name|i
control|)
block|{
name|printf
argument_list|(
literal|"0x%lx%s"
argument_list|,
name|read_leb128
argument_list|(
name|data
argument_list|,
operator|&
name|bytes_read
argument_list|,
literal|0
argument_list|)
argument_list|,
name|i
operator|==
literal|1
condition|?
literal|""
else|:
literal|", "
argument_list|)
expr_stmt|;
name|data
operator|+=
name|bytes_read
expr_stmt|;
block|}
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|display_debug_pubnames
parameter_list|(
name|Elf_Internal_Shdr
modifier|*
name|section
parameter_list|,
name|unsigned
name|char
modifier|*
name|start
parameter_list|,
name|FILE
modifier|*
name|file
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|DWARF2_Internal_PubNames
name|pubnames
decl_stmt|;
name|unsigned
name|char
modifier|*
name|end
decl_stmt|;
name|end
operator|=
name|start
operator|+
name|section
operator|->
name|sh_size
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"Contents of the %s section:\n\n"
argument_list|)
argument_list|,
name|SECTION_NAME
argument_list|(
name|section
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|start
operator|<
name|end
condition|)
block|{
name|unsigned
name|char
modifier|*
name|data
decl_stmt|;
name|unsigned
name|long
name|offset
decl_stmt|;
name|int
name|offset_size
decl_stmt|,
name|initial_length_size
decl_stmt|;
name|data
operator|=
name|start
expr_stmt|;
name|pubnames
operator|.
name|pn_length
operator|=
name|byte_get
argument_list|(
name|data
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|data
operator|+=
literal|4
expr_stmt|;
if|if
condition|(
name|pubnames
operator|.
name|pn_length
operator|==
literal|0xffffffff
condition|)
block|{
name|pubnames
operator|.
name|pn_length
operator|=
name|byte_get
argument_list|(
name|data
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|data
operator|+=
literal|8
expr_stmt|;
name|offset_size
operator|=
literal|8
expr_stmt|;
name|initial_length_size
operator|=
literal|12
expr_stmt|;
block|}
else|else
block|{
name|offset_size
operator|=
literal|4
expr_stmt|;
name|initial_length_size
operator|=
literal|4
expr_stmt|;
block|}
name|pubnames
operator|.
name|pn_version
operator|=
name|byte_get
argument_list|(
name|data
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|data
operator|+=
literal|2
expr_stmt|;
name|pubnames
operator|.
name|pn_offset
operator|=
name|byte_get
argument_list|(
name|data
argument_list|,
name|offset_size
argument_list|)
expr_stmt|;
name|data
operator|+=
name|offset_size
expr_stmt|;
name|pubnames
operator|.
name|pn_size
operator|=
name|byte_get
argument_list|(
name|data
argument_list|,
name|offset_size
argument_list|)
expr_stmt|;
name|data
operator|+=
name|offset_size
expr_stmt|;
name|start
operator|+=
name|pubnames
operator|.
name|pn_length
operator|+
name|initial_length_size
expr_stmt|;
if|if
condition|(
name|pubnames
operator|.
name|pn_version
operator|!=
literal|2
operator|&&
name|pubnames
operator|.
name|pn_version
operator|!=
literal|3
condition|)
block|{
specifier|static
name|int
name|warned
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|warned
condition|)
block|{
name|warn
argument_list|(
name|_
argument_list|(
literal|"Only DWARF 2 and 3 pubnames are currently supported\n"
argument_list|)
argument_list|)
expr_stmt|;
name|warned
operator|=
literal|1
expr_stmt|;
block|}
continue|continue;
block|}
name|printf
argument_list|(
name|_
argument_list|(
literal|"  Length:                              %ld\n"
argument_list|)
argument_list|,
name|pubnames
operator|.
name|pn_length
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"  Version:                             %d\n"
argument_list|)
argument_list|,
name|pubnames
operator|.
name|pn_version
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"  Offset into .debug_info section:     %ld\n"
argument_list|)
argument_list|,
name|pubnames
operator|.
name|pn_offset
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"  Size of area in .debug_info section: %ld\n"
argument_list|)
argument_list|,
name|pubnames
operator|.
name|pn_size
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"\n    Offset\tName\n"
argument_list|)
argument_list|)
expr_stmt|;
do|do
block|{
name|offset
operator|=
name|byte_get
argument_list|(
name|data
argument_list|,
name|offset_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|!=
literal|0
condition|)
block|{
name|data
operator|+=
name|offset_size
expr_stmt|;
name|printf
argument_list|(
literal|"    %-6ld\t\t%s\n"
argument_list|,
name|offset
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|data
operator|+=
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|data
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
block|}
do|while
condition|(
name|offset
operator|!=
literal|0
condition|)
do|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|get_TAG_name
parameter_list|(
name|unsigned
name|long
name|tag
parameter_list|)
block|{
switch|switch
condition|(
name|tag
condition|)
block|{
case|case
name|DW_TAG_padding
case|:
return|return
literal|"DW_TAG_padding"
return|;
case|case
name|DW_TAG_array_type
case|:
return|return
literal|"DW_TAG_array_type"
return|;
case|case
name|DW_TAG_class_type
case|:
return|return
literal|"DW_TAG_class_type"
return|;
case|case
name|DW_TAG_entry_point
case|:
return|return
literal|"DW_TAG_entry_point"
return|;
case|case
name|DW_TAG_enumeration_type
case|:
return|return
literal|"DW_TAG_enumeration_type"
return|;
case|case
name|DW_TAG_formal_parameter
case|:
return|return
literal|"DW_TAG_formal_parameter"
return|;
case|case
name|DW_TAG_imported_declaration
case|:
return|return
literal|"DW_TAG_imported_declaration"
return|;
case|case
name|DW_TAG_label
case|:
return|return
literal|"DW_TAG_label"
return|;
case|case
name|DW_TAG_lexical_block
case|:
return|return
literal|"DW_TAG_lexical_block"
return|;
case|case
name|DW_TAG_member
case|:
return|return
literal|"DW_TAG_member"
return|;
case|case
name|DW_TAG_pointer_type
case|:
return|return
literal|"DW_TAG_pointer_type"
return|;
case|case
name|DW_TAG_reference_type
case|:
return|return
literal|"DW_TAG_reference_type"
return|;
case|case
name|DW_TAG_compile_unit
case|:
return|return
literal|"DW_TAG_compile_unit"
return|;
case|case
name|DW_TAG_string_type
case|:
return|return
literal|"DW_TAG_string_type"
return|;
case|case
name|DW_TAG_structure_type
case|:
return|return
literal|"DW_TAG_structure_type"
return|;
case|case
name|DW_TAG_subroutine_type
case|:
return|return
literal|"DW_TAG_subroutine_type"
return|;
case|case
name|DW_TAG_typedef
case|:
return|return
literal|"DW_TAG_typedef"
return|;
case|case
name|DW_TAG_union_type
case|:
return|return
literal|"DW_TAG_union_type"
return|;
case|case
name|DW_TAG_unspecified_parameters
case|:
return|return
literal|"DW_TAG_unspecified_parameters"
return|;
case|case
name|DW_TAG_variant
case|:
return|return
literal|"DW_TAG_variant"
return|;
case|case
name|DW_TAG_common_block
case|:
return|return
literal|"DW_TAG_common_block"
return|;
case|case
name|DW_TAG_common_inclusion
case|:
return|return
literal|"DW_TAG_common_inclusion"
return|;
case|case
name|DW_TAG_inheritance
case|:
return|return
literal|"DW_TAG_inheritance"
return|;
case|case
name|DW_TAG_inlined_subroutine
case|:
return|return
literal|"DW_TAG_inlined_subroutine"
return|;
case|case
name|DW_TAG_module
case|:
return|return
literal|"DW_TAG_module"
return|;
case|case
name|DW_TAG_ptr_to_member_type
case|:
return|return
literal|"DW_TAG_ptr_to_member_type"
return|;
case|case
name|DW_TAG_set_type
case|:
return|return
literal|"DW_TAG_set_type"
return|;
case|case
name|DW_TAG_subrange_type
case|:
return|return
literal|"DW_TAG_subrange_type"
return|;
case|case
name|DW_TAG_with_stmt
case|:
return|return
literal|"DW_TAG_with_stmt"
return|;
case|case
name|DW_TAG_access_declaration
case|:
return|return
literal|"DW_TAG_access_declaration"
return|;
case|case
name|DW_TAG_base_type
case|:
return|return
literal|"DW_TAG_base_type"
return|;
case|case
name|DW_TAG_catch_block
case|:
return|return
literal|"DW_TAG_catch_block"
return|;
case|case
name|DW_TAG_const_type
case|:
return|return
literal|"DW_TAG_const_type"
return|;
case|case
name|DW_TAG_constant
case|:
return|return
literal|"DW_TAG_constant"
return|;
case|case
name|DW_TAG_enumerator
case|:
return|return
literal|"DW_TAG_enumerator"
return|;
case|case
name|DW_TAG_file_type
case|:
return|return
literal|"DW_TAG_file_type"
return|;
case|case
name|DW_TAG_friend
case|:
return|return
literal|"DW_TAG_friend"
return|;
case|case
name|DW_TAG_namelist
case|:
return|return
literal|"DW_TAG_namelist"
return|;
case|case
name|DW_TAG_namelist_item
case|:
return|return
literal|"DW_TAG_namelist_item"
return|;
case|case
name|DW_TAG_packed_type
case|:
return|return
literal|"DW_TAG_packed_type"
return|;
case|case
name|DW_TAG_subprogram
case|:
return|return
literal|"DW_TAG_subprogram"
return|;
case|case
name|DW_TAG_template_type_param
case|:
return|return
literal|"DW_TAG_template_type_param"
return|;
case|case
name|DW_TAG_template_value_param
case|:
return|return
literal|"DW_TAG_template_value_param"
return|;
case|case
name|DW_TAG_thrown_type
case|:
return|return
literal|"DW_TAG_thrown_type"
return|;
case|case
name|DW_TAG_try_block
case|:
return|return
literal|"DW_TAG_try_block"
return|;
case|case
name|DW_TAG_variant_part
case|:
return|return
literal|"DW_TAG_variant_part"
return|;
case|case
name|DW_TAG_variable
case|:
return|return
literal|"DW_TAG_variable"
return|;
case|case
name|DW_TAG_volatile_type
case|:
return|return
literal|"DW_TAG_volatile_type"
return|;
case|case
name|DW_TAG_MIPS_loop
case|:
return|return
literal|"DW_TAG_MIPS_loop"
return|;
case|case
name|DW_TAG_format_label
case|:
return|return
literal|"DW_TAG_format_label"
return|;
case|case
name|DW_TAG_function_template
case|:
return|return
literal|"DW_TAG_function_template"
return|;
case|case
name|DW_TAG_class_template
case|:
return|return
literal|"DW_TAG_class_template"
return|;
comment|/* DWARF 2.1 values.  */
case|case
name|DW_TAG_dwarf_procedure
case|:
return|return
literal|"DW_TAG_dwarf_procedure"
return|;
case|case
name|DW_TAG_restrict_type
case|:
return|return
literal|"DW_TAG_restrict_type"
return|;
case|case
name|DW_TAG_interface_type
case|:
return|return
literal|"DW_TAG_interface_type"
return|;
case|case
name|DW_TAG_namespace
case|:
return|return
literal|"DW_TAG_namespace"
return|;
case|case
name|DW_TAG_imported_module
case|:
return|return
literal|"DW_TAG_imported_module"
return|;
case|case
name|DW_TAG_unspecified_type
case|:
return|return
literal|"DW_TAG_unspecified_type"
return|;
case|case
name|DW_TAG_partial_unit
case|:
return|return
literal|"DW_TAG_partial_unit"
return|;
case|case
name|DW_TAG_imported_unit
case|:
return|return
literal|"DW_TAG_imported_unit"
return|;
comment|/* UPC values.  */
case|case
name|DW_TAG_upc_shared_type
case|:
return|return
literal|"DW_TAG_upc_shared_type"
return|;
case|case
name|DW_TAG_upc_strict_type
case|:
return|return
literal|"DW_TAG_upc_strict_type"
return|;
case|case
name|DW_TAG_upc_relaxed_type
case|:
return|return
literal|"DW_TAG_upc_relaxed_type"
return|;
default|default:
block|{
specifier|static
name|char
name|buffer
index|[
literal|100
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|buffer
argument_list|,
name|_
argument_list|(
literal|"Unknown TAG value: %lx"
argument_list|)
argument_list|,
name|tag
argument_list|)
expr_stmt|;
return|return
name|buffer
return|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|get_AT_name
parameter_list|(
name|unsigned
name|long
name|attribute
parameter_list|)
block|{
switch|switch
condition|(
name|attribute
condition|)
block|{
case|case
name|DW_AT_sibling
case|:
return|return
literal|"DW_AT_sibling"
return|;
case|case
name|DW_AT_location
case|:
return|return
literal|"DW_AT_location"
return|;
case|case
name|DW_AT_name
case|:
return|return
literal|"DW_AT_name"
return|;
case|case
name|DW_AT_ordering
case|:
return|return
literal|"DW_AT_ordering"
return|;
case|case
name|DW_AT_subscr_data
case|:
return|return
literal|"DW_AT_subscr_data"
return|;
case|case
name|DW_AT_byte_size
case|:
return|return
literal|"DW_AT_byte_size"
return|;
case|case
name|DW_AT_bit_offset
case|:
return|return
literal|"DW_AT_bit_offset"
return|;
case|case
name|DW_AT_bit_size
case|:
return|return
literal|"DW_AT_bit_size"
return|;
case|case
name|DW_AT_element_list
case|:
return|return
literal|"DW_AT_element_list"
return|;
case|case
name|DW_AT_stmt_list
case|:
return|return
literal|"DW_AT_stmt_list"
return|;
case|case
name|DW_AT_low_pc
case|:
return|return
literal|"DW_AT_low_pc"
return|;
case|case
name|DW_AT_high_pc
case|:
return|return
literal|"DW_AT_high_pc"
return|;
case|case
name|DW_AT_language
case|:
return|return
literal|"DW_AT_language"
return|;
case|case
name|DW_AT_member
case|:
return|return
literal|"DW_AT_member"
return|;
case|case
name|DW_AT_discr
case|:
return|return
literal|"DW_AT_discr"
return|;
case|case
name|DW_AT_discr_value
case|:
return|return
literal|"DW_AT_discr_value"
return|;
case|case
name|DW_AT_visibility
case|:
return|return
literal|"DW_AT_visibility"
return|;
case|case
name|DW_AT_import
case|:
return|return
literal|"DW_AT_import"
return|;
case|case
name|DW_AT_string_length
case|:
return|return
literal|"DW_AT_string_length"
return|;
case|case
name|DW_AT_common_reference
case|:
return|return
literal|"DW_AT_common_reference"
return|;
case|case
name|DW_AT_comp_dir
case|:
return|return
literal|"DW_AT_comp_dir"
return|;
case|case
name|DW_AT_const_value
case|:
return|return
literal|"DW_AT_const_value"
return|;
case|case
name|DW_AT_containing_type
case|:
return|return
literal|"DW_AT_containing_type"
return|;
case|case
name|DW_AT_default_value
case|:
return|return
literal|"DW_AT_default_value"
return|;
case|case
name|DW_AT_inline
case|:
return|return
literal|"DW_AT_inline"
return|;
case|case
name|DW_AT_is_optional
case|:
return|return
literal|"DW_AT_is_optional"
return|;
case|case
name|DW_AT_lower_bound
case|:
return|return
literal|"DW_AT_lower_bound"
return|;
case|case
name|DW_AT_producer
case|:
return|return
literal|"DW_AT_producer"
return|;
case|case
name|DW_AT_prototyped
case|:
return|return
literal|"DW_AT_prototyped"
return|;
case|case
name|DW_AT_return_addr
case|:
return|return
literal|"DW_AT_return_addr"
return|;
case|case
name|DW_AT_start_scope
case|:
return|return
literal|"DW_AT_start_scope"
return|;
case|case
name|DW_AT_stride_size
case|:
return|return
literal|"DW_AT_stride_size"
return|;
case|case
name|DW_AT_upper_bound
case|:
return|return
literal|"DW_AT_upper_bound"
return|;
case|case
name|DW_AT_abstract_origin
case|:
return|return
literal|"DW_AT_abstract_origin"
return|;
case|case
name|DW_AT_accessibility
case|:
return|return
literal|"DW_AT_accessibility"
return|;
case|case
name|DW_AT_address_class
case|:
return|return
literal|"DW_AT_address_class"
return|;
case|case
name|DW_AT_artificial
case|:
return|return
literal|"DW_AT_artificial"
return|;
case|case
name|DW_AT_base_types
case|:
return|return
literal|"DW_AT_base_types"
return|;
case|case
name|DW_AT_calling_convention
case|:
return|return
literal|"DW_AT_calling_convention"
return|;
case|case
name|DW_AT_count
case|:
return|return
literal|"DW_AT_count"
return|;
case|case
name|DW_AT_data_member_location
case|:
return|return
literal|"DW_AT_data_member_location"
return|;
case|case
name|DW_AT_decl_column
case|:
return|return
literal|"DW_AT_decl_column"
return|;
case|case
name|DW_AT_decl_file
case|:
return|return
literal|"DW_AT_decl_file"
return|;
case|case
name|DW_AT_decl_line
case|:
return|return
literal|"DW_AT_decl_line"
return|;
case|case
name|DW_AT_declaration
case|:
return|return
literal|"DW_AT_declaration"
return|;
case|case
name|DW_AT_discr_list
case|:
return|return
literal|"DW_AT_discr_list"
return|;
case|case
name|DW_AT_encoding
case|:
return|return
literal|"DW_AT_encoding"
return|;
case|case
name|DW_AT_external
case|:
return|return
literal|"DW_AT_external"
return|;
case|case
name|DW_AT_frame_base
case|:
return|return
literal|"DW_AT_frame_base"
return|;
case|case
name|DW_AT_friend
case|:
return|return
literal|"DW_AT_friend"
return|;
case|case
name|DW_AT_identifier_case
case|:
return|return
literal|"DW_AT_identifier_case"
return|;
case|case
name|DW_AT_macro_info
case|:
return|return
literal|"DW_AT_macro_info"
return|;
case|case
name|DW_AT_namelist_items
case|:
return|return
literal|"DW_AT_namelist_items"
return|;
case|case
name|DW_AT_priority
case|:
return|return
literal|"DW_AT_priority"
return|;
case|case
name|DW_AT_segment
case|:
return|return
literal|"DW_AT_segment"
return|;
case|case
name|DW_AT_specification
case|:
return|return
literal|"DW_AT_specification"
return|;
case|case
name|DW_AT_static_link
case|:
return|return
literal|"DW_AT_static_link"
return|;
case|case
name|DW_AT_type
case|:
return|return
literal|"DW_AT_type"
return|;
case|case
name|DW_AT_use_location
case|:
return|return
literal|"DW_AT_use_location"
return|;
case|case
name|DW_AT_variable_parameter
case|:
return|return
literal|"DW_AT_variable_parameter"
return|;
case|case
name|DW_AT_virtuality
case|:
return|return
literal|"DW_AT_virtuality"
return|;
case|case
name|DW_AT_vtable_elem_location
case|:
return|return
literal|"DW_AT_vtable_elem_location"
return|;
comment|/* DWARF 2.1 values.  */
case|case
name|DW_AT_allocated
case|:
return|return
literal|"DW_AT_allocated"
return|;
case|case
name|DW_AT_associated
case|:
return|return
literal|"DW_AT_associated"
return|;
case|case
name|DW_AT_data_location
case|:
return|return
literal|"DW_AT_data_location"
return|;
case|case
name|DW_AT_stride
case|:
return|return
literal|"DW_AT_stride"
return|;
case|case
name|DW_AT_entry_pc
case|:
return|return
literal|"DW_AT_entry_pc"
return|;
case|case
name|DW_AT_use_UTF8
case|:
return|return
literal|"DW_AT_use_UTF8"
return|;
case|case
name|DW_AT_extension
case|:
return|return
literal|"DW_AT_extension"
return|;
case|case
name|DW_AT_ranges
case|:
return|return
literal|"DW_AT_ranges"
return|;
case|case
name|DW_AT_trampoline
case|:
return|return
literal|"DW_AT_trampoline"
return|;
case|case
name|DW_AT_call_column
case|:
return|return
literal|"DW_AT_call_column"
return|;
case|case
name|DW_AT_call_file
case|:
return|return
literal|"DW_AT_call_file"
return|;
case|case
name|DW_AT_call_line
case|:
return|return
literal|"DW_AT_call_line"
return|;
comment|/* SGI/MIPS extensions.  */
case|case
name|DW_AT_MIPS_fde
case|:
return|return
literal|"DW_AT_MIPS_fde"
return|;
case|case
name|DW_AT_MIPS_loop_begin
case|:
return|return
literal|"DW_AT_MIPS_loop_begin"
return|;
case|case
name|DW_AT_MIPS_tail_loop_begin
case|:
return|return
literal|"DW_AT_MIPS_tail_loop_begin"
return|;
case|case
name|DW_AT_MIPS_epilog_begin
case|:
return|return
literal|"DW_AT_MIPS_epilog_begin"
return|;
case|case
name|DW_AT_MIPS_loop_unroll_factor
case|:
return|return
literal|"DW_AT_MIPS_loop_unroll_factor"
return|;
case|case
name|DW_AT_MIPS_software_pipeline_depth
case|:
return|return
literal|"DW_AT_MIPS_software_pipeline_depth"
return|;
case|case
name|DW_AT_MIPS_linkage_name
case|:
return|return
literal|"DW_AT_MIPS_linkage_name"
return|;
case|case
name|DW_AT_MIPS_stride
case|:
return|return
literal|"DW_AT_MIPS_stride"
return|;
case|case
name|DW_AT_MIPS_abstract_name
case|:
return|return
literal|"DW_AT_MIPS_abstract_name"
return|;
case|case
name|DW_AT_MIPS_clone_origin
case|:
return|return
literal|"DW_AT_MIPS_clone_origin"
return|;
case|case
name|DW_AT_MIPS_has_inlines
case|:
return|return
literal|"DW_AT_MIPS_has_inlines"
return|;
comment|/* GNU extensions.  */
case|case
name|DW_AT_sf_names
case|:
return|return
literal|"DW_AT_sf_names"
return|;
case|case
name|DW_AT_src_info
case|:
return|return
literal|"DW_AT_src_info"
return|;
case|case
name|DW_AT_mac_info
case|:
return|return
literal|"DW_AT_mac_info"
return|;
case|case
name|DW_AT_src_coords
case|:
return|return
literal|"DW_AT_src_coords"
return|;
case|case
name|DW_AT_body_begin
case|:
return|return
literal|"DW_AT_body_begin"
return|;
case|case
name|DW_AT_body_end
case|:
return|return
literal|"DW_AT_body_end"
return|;
case|case
name|DW_AT_GNU_vector
case|:
return|return
literal|"DW_AT_GNU_vector"
return|;
comment|/* UPC extension.  */
case|case
name|DW_AT_upc_threads_scaled
case|:
return|return
literal|"DW_AT_upc_threads_scaled"
return|;
default|default:
block|{
specifier|static
name|char
name|buffer
index|[
literal|100
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|buffer
argument_list|,
name|_
argument_list|(
literal|"Unknown AT value: %lx"
argument_list|)
argument_list|,
name|attribute
argument_list|)
expr_stmt|;
return|return
name|buffer
return|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|get_FORM_name
parameter_list|(
name|unsigned
name|long
name|form
parameter_list|)
block|{
switch|switch
condition|(
name|form
condition|)
block|{
case|case
name|DW_FORM_addr
case|:
return|return
literal|"DW_FORM_addr"
return|;
case|case
name|DW_FORM_block2
case|:
return|return
literal|"DW_FORM_block2"
return|;
case|case
name|DW_FORM_block4
case|:
return|return
literal|"DW_FORM_block4"
return|;
case|case
name|DW_FORM_data2
case|:
return|return
literal|"DW_FORM_data2"
return|;
case|case
name|DW_FORM_data4
case|:
return|return
literal|"DW_FORM_data4"
return|;
case|case
name|DW_FORM_data8
case|:
return|return
literal|"DW_FORM_data8"
return|;
case|case
name|DW_FORM_string
case|:
return|return
literal|"DW_FORM_string"
return|;
case|case
name|DW_FORM_block
case|:
return|return
literal|"DW_FORM_block"
return|;
case|case
name|DW_FORM_block1
case|:
return|return
literal|"DW_FORM_block1"
return|;
case|case
name|DW_FORM_data1
case|:
return|return
literal|"DW_FORM_data1"
return|;
case|case
name|DW_FORM_flag
case|:
return|return
literal|"DW_FORM_flag"
return|;
case|case
name|DW_FORM_sdata
case|:
return|return
literal|"DW_FORM_sdata"
return|;
case|case
name|DW_FORM_strp
case|:
return|return
literal|"DW_FORM_strp"
return|;
case|case
name|DW_FORM_udata
case|:
return|return
literal|"DW_FORM_udata"
return|;
case|case
name|DW_FORM_ref_addr
case|:
return|return
literal|"DW_FORM_ref_addr"
return|;
case|case
name|DW_FORM_ref1
case|:
return|return
literal|"DW_FORM_ref1"
return|;
case|case
name|DW_FORM_ref2
case|:
return|return
literal|"DW_FORM_ref2"
return|;
case|case
name|DW_FORM_ref4
case|:
return|return
literal|"DW_FORM_ref4"
return|;
case|case
name|DW_FORM_ref8
case|:
return|return
literal|"DW_FORM_ref8"
return|;
case|case
name|DW_FORM_ref_udata
case|:
return|return
literal|"DW_FORM_ref_udata"
return|;
case|case
name|DW_FORM_indirect
case|:
return|return
literal|"DW_FORM_indirect"
return|;
default|default:
block|{
specifier|static
name|char
name|buffer
index|[
literal|100
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|buffer
argument_list|,
name|_
argument_list|(
literal|"Unknown FORM value: %lx"
argument_list|)
argument_list|,
name|form
argument_list|)
expr_stmt|;
return|return
name|buffer
return|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* FIXME:  There are better and more efficient ways to handle    these structures.  For now though, I just want something that    is simple to implement.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|abbrev_attr
block|{
name|unsigned
name|long
name|attribute
decl_stmt|;
name|unsigned
name|long
name|form
decl_stmt|;
name|struct
name|abbrev_attr
modifier|*
name|next
decl_stmt|;
block|}
name|abbrev_attr
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|abbrev_entry
block|{
name|unsigned
name|long
name|entry
decl_stmt|;
name|unsigned
name|long
name|tag
decl_stmt|;
name|int
name|children
decl_stmt|;
name|struct
name|abbrev_attr
modifier|*
name|first_attr
decl_stmt|;
name|struct
name|abbrev_attr
modifier|*
name|last_attr
decl_stmt|;
name|struct
name|abbrev_entry
modifier|*
name|next
decl_stmt|;
block|}
name|abbrev_entry
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|abbrev_entry
modifier|*
name|first_abbrev
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|abbrev_entry
modifier|*
name|last_abbrev
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|free_abbrevs
parameter_list|(
name|void
parameter_list|)
block|{
name|abbrev_entry
modifier|*
name|abbrev
decl_stmt|;
for|for
control|(
name|abbrev
operator|=
name|first_abbrev
init|;
name|abbrev
condition|;
control|)
block|{
name|abbrev_entry
modifier|*
name|next
init|=
name|abbrev
operator|->
name|next
decl_stmt|;
name|abbrev_attr
modifier|*
name|attr
decl_stmt|;
for|for
control|(
name|attr
operator|=
name|abbrev
operator|->
name|first_attr
init|;
name|attr
condition|;
control|)
block|{
name|abbrev_attr
modifier|*
name|next
init|=
name|attr
operator|->
name|next
decl_stmt|;
name|free
argument_list|(
name|attr
argument_list|)
expr_stmt|;
name|attr
operator|=
name|next
expr_stmt|;
block|}
name|free
argument_list|(
name|abbrev
argument_list|)
expr_stmt|;
name|abbrev
operator|=
name|next
expr_stmt|;
block|}
name|last_abbrev
operator|=
name|first_abbrev
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|add_abbrev
parameter_list|(
name|unsigned
name|long
name|number
parameter_list|,
name|unsigned
name|long
name|tag
parameter_list|,
name|int
name|children
parameter_list|)
block|{
name|abbrev_entry
modifier|*
name|entry
decl_stmt|;
name|entry
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|entry
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|==
name|NULL
condition|)
comment|/* ugg */
return|return;
name|entry
operator|->
name|entry
operator|=
name|number
expr_stmt|;
name|entry
operator|->
name|tag
operator|=
name|tag
expr_stmt|;
name|entry
operator|->
name|children
operator|=
name|children
expr_stmt|;
name|entry
operator|->
name|first_attr
operator|=
name|NULL
expr_stmt|;
name|entry
operator|->
name|last_attr
operator|=
name|NULL
expr_stmt|;
name|entry
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|first_abbrev
operator|==
name|NULL
condition|)
name|first_abbrev
operator|=
name|entry
expr_stmt|;
else|else
name|last_abbrev
operator|->
name|next
operator|=
name|entry
expr_stmt|;
name|last_abbrev
operator|=
name|entry
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|add_abbrev_attr
parameter_list|(
name|unsigned
name|long
name|attribute
parameter_list|,
name|unsigned
name|long
name|form
parameter_list|)
block|{
name|abbrev_attr
modifier|*
name|attr
decl_stmt|;
name|attr
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|attr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|attr
operator|==
name|NULL
condition|)
comment|/* ugg */
return|return;
name|attr
operator|->
name|attribute
operator|=
name|attribute
expr_stmt|;
name|attr
operator|->
name|form
operator|=
name|form
expr_stmt|;
name|attr
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|last_abbrev
operator|->
name|first_attr
operator|==
name|NULL
condition|)
name|last_abbrev
operator|->
name|first_attr
operator|=
name|attr
expr_stmt|;
else|else
name|last_abbrev
operator|->
name|last_attr
operator|->
name|next
operator|=
name|attr
expr_stmt|;
name|last_abbrev
operator|->
name|last_attr
operator|=
name|attr
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Processes the (partial) contents of a .debug_abbrev section.    Returns NULL if the end of the section was encountered.    Returns the address after the last byte read if the end of    an abbreviation set was found.  */
end_comment

begin_function
specifier|static
name|unsigned
name|char
modifier|*
name|process_abbrev_section
parameter_list|(
name|unsigned
name|char
modifier|*
name|start
parameter_list|,
name|unsigned
name|char
modifier|*
name|end
parameter_list|)
block|{
if|if
condition|(
name|first_abbrev
operator|!=
name|NULL
condition|)
return|return
name|NULL
return|;
while|while
condition|(
name|start
operator|<
name|end
condition|)
block|{
name|int
name|bytes_read
decl_stmt|;
name|unsigned
name|long
name|entry
decl_stmt|;
name|unsigned
name|long
name|tag
decl_stmt|;
name|unsigned
name|long
name|attribute
decl_stmt|;
name|int
name|children
decl_stmt|;
name|entry
operator|=
name|read_leb128
argument_list|(
name|start
argument_list|,
operator|&
name|bytes_read
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|start
operator|+=
name|bytes_read
expr_stmt|;
comment|/* A single zero is supposed to end the section according 	 to the standard.  If there's more, then signal that to 	 the caller.  */
if|if
condition|(
name|entry
operator|==
literal|0
condition|)
return|return
name|start
operator|==
name|end
condition|?
name|NULL
else|:
name|start
return|;
name|tag
operator|=
name|read_leb128
argument_list|(
name|start
argument_list|,
operator|&
name|bytes_read
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|start
operator|+=
name|bytes_read
expr_stmt|;
name|children
operator|=
operator|*
name|start
operator|++
expr_stmt|;
name|add_abbrev
argument_list|(
name|entry
argument_list|,
name|tag
argument_list|,
name|children
argument_list|)
expr_stmt|;
do|do
block|{
name|unsigned
name|long
name|form
decl_stmt|;
name|attribute
operator|=
name|read_leb128
argument_list|(
name|start
argument_list|,
operator|&
name|bytes_read
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|start
operator|+=
name|bytes_read
expr_stmt|;
name|form
operator|=
name|read_leb128
argument_list|(
name|start
argument_list|,
operator|&
name|bytes_read
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|start
operator|+=
name|bytes_read
expr_stmt|;
if|if
condition|(
name|attribute
operator|!=
literal|0
condition|)
name|add_abbrev_attr
argument_list|(
name|attribute
argument_list|,
name|form
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|attribute
operator|!=
literal|0
condition|)
do|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|display_debug_macinfo
parameter_list|(
name|Elf_Internal_Shdr
modifier|*
name|section
parameter_list|,
name|unsigned
name|char
modifier|*
name|start
parameter_list|,
name|FILE
modifier|*
name|file
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|end
init|=
name|start
operator|+
name|section
operator|->
name|sh_size
decl_stmt|;
name|unsigned
name|char
modifier|*
name|curr
init|=
name|start
decl_stmt|;
name|unsigned
name|int
name|bytes_read
decl_stmt|;
name|enum
name|dwarf_macinfo_record_type
name|op
decl_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"Contents of the %s section:\n\n"
argument_list|)
argument_list|,
name|SECTION_NAME
argument_list|(
name|section
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|curr
operator|<
name|end
condition|)
block|{
name|unsigned
name|int
name|lineno
decl_stmt|;
specifier|const
name|char
modifier|*
name|string
decl_stmt|;
name|op
operator|=
operator|*
name|curr
expr_stmt|;
name|curr
operator|++
expr_stmt|;
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|DW_MACINFO_start_file
case|:
block|{
name|unsigned
name|int
name|filenum
decl_stmt|;
name|lineno
operator|=
name|read_leb128
argument_list|(
name|curr
argument_list|,
operator|&
name|bytes_read
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|curr
operator|+=
name|bytes_read
expr_stmt|;
name|filenum
operator|=
name|read_leb128
argument_list|(
name|curr
argument_list|,
operator|&
name|bytes_read
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|curr
operator|+=
name|bytes_read
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|" DW_MACINFO_start_file - lineno: %d filenum: %d\n"
argument_list|)
argument_list|,
name|lineno
argument_list|,
name|filenum
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|DW_MACINFO_end_file
case|:
name|printf
argument_list|(
name|_
argument_list|(
literal|" DW_MACINFO_end_file\n"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_MACINFO_define
case|:
name|lineno
operator|=
name|read_leb128
argument_list|(
name|curr
argument_list|,
operator|&
name|bytes_read
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|curr
operator|+=
name|bytes_read
expr_stmt|;
name|string
operator|=
name|curr
expr_stmt|;
name|curr
operator|+=
name|strlen
argument_list|(
name|string
argument_list|)
operator|+
literal|1
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|" DW_MACINFO_define - lineno : %d macro : %s\n"
argument_list|)
argument_list|,
name|lineno
argument_list|,
name|string
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_MACINFO_undef
case|:
name|lineno
operator|=
name|read_leb128
argument_list|(
name|curr
argument_list|,
operator|&
name|bytes_read
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|curr
operator|+=
name|bytes_read
expr_stmt|;
name|string
operator|=
name|curr
expr_stmt|;
name|curr
operator|+=
name|strlen
argument_list|(
name|string
argument_list|)
operator|+
literal|1
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|" DW_MACINFO_undef - lineno : %d macro : %s\n"
argument_list|)
argument_list|,
name|lineno
argument_list|,
name|string
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_MACINFO_vendor_ext
case|:
block|{
name|unsigned
name|int
name|constant
decl_stmt|;
name|constant
operator|=
name|read_leb128
argument_list|(
name|curr
argument_list|,
operator|&
name|bytes_read
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|curr
operator|+=
name|bytes_read
expr_stmt|;
name|string
operator|=
name|curr
expr_stmt|;
name|curr
operator|+=
name|strlen
argument_list|(
name|string
argument_list|)
operator|+
literal|1
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|" DW_MACINFO_vendor_ext - constant : %d string : %s\n"
argument_list|)
argument_list|,
name|constant
argument_list|,
name|string
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|display_debug_abbrev
parameter_list|(
name|Elf_Internal_Shdr
modifier|*
name|section
parameter_list|,
name|unsigned
name|char
modifier|*
name|start
parameter_list|,
name|FILE
modifier|*
name|file
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|abbrev_entry
modifier|*
name|entry
decl_stmt|;
name|unsigned
name|char
modifier|*
name|end
init|=
name|start
operator|+
name|section
operator|->
name|sh_size
decl_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"Contents of the %s section:\n\n"
argument_list|)
argument_list|,
name|SECTION_NAME
argument_list|(
name|section
argument_list|)
argument_list|)
expr_stmt|;
do|do
block|{
name|start
operator|=
name|process_abbrev_section
argument_list|(
name|start
argument_list|,
name|end
argument_list|)
expr_stmt|;
if|if
condition|(
name|first_abbrev
operator|==
name|NULL
condition|)
continue|continue;
name|printf
argument_list|(
name|_
argument_list|(
literal|"  Number TAG\n"
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|entry
operator|=
name|first_abbrev
init|;
name|entry
condition|;
name|entry
operator|=
name|entry
operator|->
name|next
control|)
block|{
name|abbrev_attr
modifier|*
name|attr
decl_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"   %ld      %s    [%s]\n"
argument_list|)
argument_list|,
name|entry
operator|->
name|entry
argument_list|,
name|get_TAG_name
argument_list|(
name|entry
operator|->
name|tag
argument_list|)
argument_list|,
name|entry
operator|->
name|children
condition|?
name|_
argument_list|(
literal|"has children"
argument_list|)
else|:
name|_
argument_list|(
literal|"no children"
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|attr
operator|=
name|entry
operator|->
name|first_attr
init|;
name|attr
condition|;
name|attr
operator|=
name|attr
operator|->
name|next
control|)
block|{
name|printf
argument_list|(
name|_
argument_list|(
literal|"    %-18s %s\n"
argument_list|)
argument_list|,
name|get_AT_name
argument_list|(
name|attr
operator|->
name|attribute
argument_list|)
argument_list|,
name|get_FORM_name
argument_list|(
name|attr
operator|->
name|form
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|free_abbrevs
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
name|start
condition|)
do|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|unsigned
name|char
modifier|*
name|display_block
parameter_list|(
name|unsigned
name|char
modifier|*
name|data
parameter_list|,
name|unsigned
name|long
name|length
parameter_list|)
block|{
name|printf
argument_list|(
name|_
argument_list|(
literal|" %lu byte block: "
argument_list|)
argument_list|,
name|length
argument_list|)
expr_stmt|;
while|while
condition|(
name|length
operator|--
condition|)
name|printf
argument_list|(
literal|"%lx "
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|byte_get
argument_list|(
name|data
operator|++
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|data
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|decode_location_expression
parameter_list|(
name|unsigned
name|char
modifier|*
name|data
parameter_list|,
name|unsigned
name|int
name|pointer_size
parameter_list|,
name|unsigned
name|long
name|length
parameter_list|)
block|{
name|unsigned
name|op
decl_stmt|;
name|int
name|bytes_read
decl_stmt|;
name|unsigned
name|long
name|uvalue
decl_stmt|;
name|unsigned
name|char
modifier|*
name|end
init|=
name|data
operator|+
name|length
decl_stmt|;
while|while
condition|(
name|data
operator|<
name|end
condition|)
block|{
name|op
operator|=
operator|*
name|data
operator|++
expr_stmt|;
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|DW_OP_addr
case|:
name|printf
argument_list|(
literal|"DW_OP_addr: %lx"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|byte_get
argument_list|(
name|data
argument_list|,
name|pointer_size
argument_list|)
argument_list|)
expr_stmt|;
name|data
operator|+=
name|pointer_size
expr_stmt|;
break|break;
case|case
name|DW_OP_deref
case|:
name|printf
argument_list|(
literal|"DW_OP_deref"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_OP_const1u
case|:
name|printf
argument_list|(
literal|"DW_OP_const1u: %lu"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|byte_get
argument_list|(
name|data
operator|++
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_OP_const1s
case|:
name|printf
argument_list|(
literal|"DW_OP_const1s: %ld"
argument_list|,
operator|(
name|long
operator|)
name|byte_get
argument_list|(
name|data
operator|++
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_OP_const2u
case|:
name|printf
argument_list|(
literal|"DW_OP_const2u: %lu"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|byte_get
argument_list|(
name|data
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|data
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
name|DW_OP_const2s
case|:
name|printf
argument_list|(
literal|"DW_OP_const2s: %ld"
argument_list|,
operator|(
name|long
operator|)
name|byte_get
argument_list|(
name|data
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|data
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
name|DW_OP_const4u
case|:
name|printf
argument_list|(
literal|"DW_OP_const4u: %lu"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|byte_get
argument_list|(
name|data
argument_list|,
literal|4
argument_list|)
argument_list|)
expr_stmt|;
name|data
operator|+=
literal|4
expr_stmt|;
break|break;
case|case
name|DW_OP_const4s
case|:
name|printf
argument_list|(
literal|"DW_OP_const4s: %ld"
argument_list|,
operator|(
name|long
operator|)
name|byte_get
argument_list|(
name|data
argument_list|,
literal|4
argument_list|)
argument_list|)
expr_stmt|;
name|data
operator|+=
literal|4
expr_stmt|;
break|break;
case|case
name|DW_OP_const8u
case|:
name|printf
argument_list|(
literal|"DW_OP_const8u: %lu %lu"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|byte_get
argument_list|(
name|data
argument_list|,
literal|4
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|byte_get
argument_list|(
name|data
operator|+
literal|4
argument_list|,
literal|4
argument_list|)
argument_list|)
expr_stmt|;
name|data
operator|+=
literal|8
expr_stmt|;
break|break;
case|case
name|DW_OP_const8s
case|:
name|printf
argument_list|(
literal|"DW_OP_const8s: %ld %ld"
argument_list|,
operator|(
name|long
operator|)
name|byte_get
argument_list|(
name|data
argument_list|,
literal|4
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|byte_get
argument_list|(
name|data
operator|+
literal|4
argument_list|,
literal|4
argument_list|)
argument_list|)
expr_stmt|;
name|data
operator|+=
literal|8
expr_stmt|;
break|break;
case|case
name|DW_OP_constu
case|:
name|printf
argument_list|(
literal|"DW_OP_constu: %lu"
argument_list|,
name|read_leb128
argument_list|(
name|data
argument_list|,
operator|&
name|bytes_read
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|data
operator|+=
name|bytes_read
expr_stmt|;
break|break;
case|case
name|DW_OP_consts
case|:
name|printf
argument_list|(
literal|"DW_OP_consts: %ld"
argument_list|,
name|read_leb128
argument_list|(
name|data
argument_list|,
operator|&
name|bytes_read
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|data
operator|+=
name|bytes_read
expr_stmt|;
break|break;
case|case
name|DW_OP_dup
case|:
name|printf
argument_list|(
literal|"DW_OP_dup"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_OP_drop
case|:
name|printf
argument_list|(
literal|"DW_OP_drop"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_OP_over
case|:
name|printf
argument_list|(
literal|"DW_OP_over"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_OP_pick
case|:
name|printf
argument_list|(
literal|"DW_OP_pick: %ld"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|byte_get
argument_list|(
name|data
operator|++
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_OP_swap
case|:
name|printf
argument_list|(
literal|"DW_OP_swap"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_OP_rot
case|:
name|printf
argument_list|(
literal|"DW_OP_rot"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_OP_xderef
case|:
name|printf
argument_list|(
literal|"DW_OP_xderef"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_OP_abs
case|:
name|printf
argument_list|(
literal|"DW_OP_abs"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_OP_and
case|:
name|printf
argument_list|(
literal|"DW_OP_and"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_OP_div
case|:
name|printf
argument_list|(
literal|"DW_OP_div"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_OP_minus
case|:
name|printf
argument_list|(
literal|"DW_OP_minus"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_OP_mod
case|:
name|printf
argument_list|(
literal|"DW_OP_mod"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_OP_mul
case|:
name|printf
argument_list|(
literal|"DW_OP_mul"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_OP_neg
case|:
name|printf
argument_list|(
literal|"DW_OP_neg"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_OP_not
case|:
name|printf
argument_list|(
literal|"DW_OP_not"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_OP_or
case|:
name|printf
argument_list|(
literal|"DW_OP_or"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_OP_plus
case|:
name|printf
argument_list|(
literal|"DW_OP_plus"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_OP_plus_uconst
case|:
name|printf
argument_list|(
literal|"DW_OP_plus_uconst: %lu"
argument_list|,
name|read_leb128
argument_list|(
name|data
argument_list|,
operator|&
name|bytes_read
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|data
operator|+=
name|bytes_read
expr_stmt|;
break|break;
case|case
name|DW_OP_shl
case|:
name|printf
argument_list|(
literal|"DW_OP_shl"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_OP_shr
case|:
name|printf
argument_list|(
literal|"DW_OP_shr"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_OP_shra
case|:
name|printf
argument_list|(
literal|"DW_OP_shra"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_OP_xor
case|:
name|printf
argument_list|(
literal|"DW_OP_xor"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_OP_bra
case|:
name|printf
argument_list|(
literal|"DW_OP_bra: %ld"
argument_list|,
operator|(
name|long
operator|)
name|byte_get
argument_list|(
name|data
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|data
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
name|DW_OP_eq
case|:
name|printf
argument_list|(
literal|"DW_OP_eq"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_OP_ge
case|:
name|printf
argument_list|(
literal|"DW_OP_ge"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_OP_gt
case|:
name|printf
argument_list|(
literal|"DW_OP_gt"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_OP_le
case|:
name|printf
argument_list|(
literal|"DW_OP_le"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_OP_lt
case|:
name|printf
argument_list|(
literal|"DW_OP_lt"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_OP_ne
case|:
name|printf
argument_list|(
literal|"DW_OP_ne"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_OP_skip
case|:
name|printf
argument_list|(
literal|"DW_OP_skip: %ld"
argument_list|,
operator|(
name|long
operator|)
name|byte_get
argument_list|(
name|data
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|data
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
name|DW_OP_lit0
case|:
case|case
name|DW_OP_lit1
case|:
case|case
name|DW_OP_lit2
case|:
case|case
name|DW_OP_lit3
case|:
case|case
name|DW_OP_lit4
case|:
case|case
name|DW_OP_lit5
case|:
case|case
name|DW_OP_lit6
case|:
case|case
name|DW_OP_lit7
case|:
case|case
name|DW_OP_lit8
case|:
case|case
name|DW_OP_lit9
case|:
case|case
name|DW_OP_lit10
case|:
case|case
name|DW_OP_lit11
case|:
case|case
name|DW_OP_lit12
case|:
case|case
name|DW_OP_lit13
case|:
case|case
name|DW_OP_lit14
case|:
case|case
name|DW_OP_lit15
case|:
case|case
name|DW_OP_lit16
case|:
case|case
name|DW_OP_lit17
case|:
case|case
name|DW_OP_lit18
case|:
case|case
name|DW_OP_lit19
case|:
case|case
name|DW_OP_lit20
case|:
case|case
name|DW_OP_lit21
case|:
case|case
name|DW_OP_lit22
case|:
case|case
name|DW_OP_lit23
case|:
case|case
name|DW_OP_lit24
case|:
case|case
name|DW_OP_lit25
case|:
case|case
name|DW_OP_lit26
case|:
case|case
name|DW_OP_lit27
case|:
case|case
name|DW_OP_lit28
case|:
case|case
name|DW_OP_lit29
case|:
case|case
name|DW_OP_lit30
case|:
case|case
name|DW_OP_lit31
case|:
name|printf
argument_list|(
literal|"DW_OP_lit%d"
argument_list|,
name|op
operator|-
name|DW_OP_lit0
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_OP_reg0
case|:
case|case
name|DW_OP_reg1
case|:
case|case
name|DW_OP_reg2
case|:
case|case
name|DW_OP_reg3
case|:
case|case
name|DW_OP_reg4
case|:
case|case
name|DW_OP_reg5
case|:
case|case
name|DW_OP_reg6
case|:
case|case
name|DW_OP_reg7
case|:
case|case
name|DW_OP_reg8
case|:
case|case
name|DW_OP_reg9
case|:
case|case
name|DW_OP_reg10
case|:
case|case
name|DW_OP_reg11
case|:
case|case
name|DW_OP_reg12
case|:
case|case
name|DW_OP_reg13
case|:
case|case
name|DW_OP_reg14
case|:
case|case
name|DW_OP_reg15
case|:
case|case
name|DW_OP_reg16
case|:
case|case
name|DW_OP_reg17
case|:
case|case
name|DW_OP_reg18
case|:
case|case
name|DW_OP_reg19
case|:
case|case
name|DW_OP_reg20
case|:
case|case
name|DW_OP_reg21
case|:
case|case
name|DW_OP_reg22
case|:
case|case
name|DW_OP_reg23
case|:
case|case
name|DW_OP_reg24
case|:
case|case
name|DW_OP_reg25
case|:
case|case
name|DW_OP_reg26
case|:
case|case
name|DW_OP_reg27
case|:
case|case
name|DW_OP_reg28
case|:
case|case
name|DW_OP_reg29
case|:
case|case
name|DW_OP_reg30
case|:
case|case
name|DW_OP_reg31
case|:
name|printf
argument_list|(
literal|"DW_OP_reg%d"
argument_list|,
name|op
operator|-
name|DW_OP_reg0
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_OP_breg0
case|:
case|case
name|DW_OP_breg1
case|:
case|case
name|DW_OP_breg2
case|:
case|case
name|DW_OP_breg3
case|:
case|case
name|DW_OP_breg4
case|:
case|case
name|DW_OP_breg5
case|:
case|case
name|DW_OP_breg6
case|:
case|case
name|DW_OP_breg7
case|:
case|case
name|DW_OP_breg8
case|:
case|case
name|DW_OP_breg9
case|:
case|case
name|DW_OP_breg10
case|:
case|case
name|DW_OP_breg11
case|:
case|case
name|DW_OP_breg12
case|:
case|case
name|DW_OP_breg13
case|:
case|case
name|DW_OP_breg14
case|:
case|case
name|DW_OP_breg15
case|:
case|case
name|DW_OP_breg16
case|:
case|case
name|DW_OP_breg17
case|:
case|case
name|DW_OP_breg18
case|:
case|case
name|DW_OP_breg19
case|:
case|case
name|DW_OP_breg20
case|:
case|case
name|DW_OP_breg21
case|:
case|case
name|DW_OP_breg22
case|:
case|case
name|DW_OP_breg23
case|:
case|case
name|DW_OP_breg24
case|:
case|case
name|DW_OP_breg25
case|:
case|case
name|DW_OP_breg26
case|:
case|case
name|DW_OP_breg27
case|:
case|case
name|DW_OP_breg28
case|:
case|case
name|DW_OP_breg29
case|:
case|case
name|DW_OP_breg30
case|:
case|case
name|DW_OP_breg31
case|:
name|printf
argument_list|(
literal|"DW_OP_breg%d: %ld"
argument_list|,
name|op
operator|-
name|DW_OP_breg0
argument_list|,
name|read_leb128
argument_list|(
name|data
argument_list|,
operator|&
name|bytes_read
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|data
operator|+=
name|bytes_read
expr_stmt|;
break|break;
case|case
name|DW_OP_regx
case|:
name|printf
argument_list|(
literal|"DW_OP_regx: %lu"
argument_list|,
name|read_leb128
argument_list|(
name|data
argument_list|,
operator|&
name|bytes_read
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|data
operator|+=
name|bytes_read
expr_stmt|;
break|break;
case|case
name|DW_OP_fbreg
case|:
name|printf
argument_list|(
literal|"DW_OP_fbreg: %ld"
argument_list|,
name|read_leb128
argument_list|(
name|data
argument_list|,
operator|&
name|bytes_read
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|data
operator|+=
name|bytes_read
expr_stmt|;
break|break;
case|case
name|DW_OP_bregx
case|:
name|uvalue
operator|=
name|read_leb128
argument_list|(
name|data
argument_list|,
operator|&
name|bytes_read
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|data
operator|+=
name|bytes_read
expr_stmt|;
name|printf
argument_list|(
literal|"DW_OP_bregx: %lu %ld"
argument_list|,
name|uvalue
argument_list|,
name|read_leb128
argument_list|(
name|data
argument_list|,
operator|&
name|bytes_read
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|data
operator|+=
name|bytes_read
expr_stmt|;
break|break;
case|case
name|DW_OP_piece
case|:
name|printf
argument_list|(
literal|"DW_OP_piece: %lu"
argument_list|,
name|read_leb128
argument_list|(
name|data
argument_list|,
operator|&
name|bytes_read
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|data
operator|+=
name|bytes_read
expr_stmt|;
break|break;
case|case
name|DW_OP_deref_size
case|:
name|printf
argument_list|(
literal|"DW_OP_deref_size: %ld"
argument_list|,
operator|(
name|long
operator|)
name|byte_get
argument_list|(
name|data
operator|++
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_OP_xderef_size
case|:
name|printf
argument_list|(
literal|"DW_OP_xderef_size: %ld"
argument_list|,
operator|(
name|long
operator|)
name|byte_get
argument_list|(
name|data
operator|++
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_OP_nop
case|:
name|printf
argument_list|(
literal|"DW_OP_nop"
argument_list|)
expr_stmt|;
break|break;
comment|/* DWARF 3 extensions.  */
case|case
name|DW_OP_push_object_address
case|:
name|printf
argument_list|(
literal|"DW_OP_push_object_address"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_OP_call2
case|:
name|printf
argument_list|(
literal|"DW_OP_call2:<%lx>"
argument_list|,
operator|(
name|long
operator|)
name|byte_get
argument_list|(
name|data
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|data
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
name|DW_OP_call4
case|:
name|printf
argument_list|(
literal|"DW_OP_call4:<%lx>"
argument_list|,
operator|(
name|long
operator|)
name|byte_get
argument_list|(
name|data
argument_list|,
literal|4
argument_list|)
argument_list|)
expr_stmt|;
name|data
operator|+=
literal|4
expr_stmt|;
break|break;
case|case
name|DW_OP_call_ref
case|:
name|printf
argument_list|(
literal|"DW_OP_call_ref"
argument_list|)
expr_stmt|;
break|break;
comment|/* GNU extensions.  */
case|case
name|DW_OP_GNU_push_tls_address
case|:
name|printf
argument_list|(
literal|"DW_OP_GNU_push_tls_address"
argument_list|)
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|op
operator|>=
name|DW_OP_lo_user
operator|&&
name|op
operator|<=
name|DW_OP_hi_user
condition|)
name|printf
argument_list|(
name|_
argument_list|(
literal|"(User defined location op)"
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
name|_
argument_list|(
literal|"(Unknown location op)"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* No way to tell where the next op is, so just bail.  */
return|return;
block|}
comment|/* Separate the ops.  */
if|if
condition|(
name|data
operator|<
name|end
condition|)
name|printf
argument_list|(
literal|"; "
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|debug_loc_contents
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_vma
name|debug_loc_size
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|load_debug_loc
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|)
block|{
name|Elf_Internal_Shdr
modifier|*
name|sec
decl_stmt|;
comment|/* If it is already loaded, do nothing.  */
if|if
condition|(
name|debug_loc_contents
operator|!=
name|NULL
condition|)
return|return;
comment|/* Locate the .debug_loc section.  */
name|sec
operator|=
name|find_section
argument_list|(
literal|".debug_loc"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sec
operator|==
name|NULL
condition|)
return|return;
name|debug_loc_size
operator|=
name|sec
operator|->
name|sh_size
expr_stmt|;
name|debug_loc_contents
operator|=
name|get_data
argument_list|(
name|NULL
argument_list|,
name|file
argument_list|,
name|sec
operator|->
name|sh_offset
argument_list|,
name|sec
operator|->
name|sh_size
argument_list|,
name|_
argument_list|(
literal|"debug_loc section data"
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|free_debug_loc
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|debug_loc_contents
operator|==
name|NULL
condition|)
return|return;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|debug_loc_contents
argument_list|)
expr_stmt|;
name|debug_loc_contents
operator|=
name|NULL
expr_stmt|;
name|debug_loc_size
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|display_debug_loc
parameter_list|(
name|Elf_Internal_Shdr
modifier|*
name|section
parameter_list|,
name|unsigned
name|char
modifier|*
name|start
parameter_list|,
name|FILE
modifier|*
name|file
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|section_end
decl_stmt|;
name|unsigned
name|long
name|bytes
decl_stmt|;
name|unsigned
name|char
modifier|*
name|section_begin
init|=
name|start
decl_stmt|;
name|bfd_vma
name|addr
decl_stmt|;
name|unsigned
name|int
name|comp_unit
init|=
literal|0
decl_stmt|;
name|addr
operator|=
name|section
operator|->
name|sh_addr
expr_stmt|;
name|bytes
operator|=
name|section
operator|->
name|sh_size
expr_stmt|;
name|section_end
operator|=
name|start
operator|+
name|bytes
expr_stmt|;
if|if
condition|(
name|bytes
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
name|_
argument_list|(
literal|"\nThe .debug_loc section is empty.\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|num_debug_line_pointer_sizes
operator|==
literal|0
condition|)
name|get_debug_line_pointer_sizes
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"Contents of the .debug_loc section:\n\n"
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"\n    Offset   Begin    End      Expression\n"
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|start
operator|<
name|section_end
condition|)
block|{
name|unsigned
name|long
name|begin
decl_stmt|;
name|unsigned
name|long
name|end
decl_stmt|;
name|unsigned
name|short
name|length
decl_stmt|;
name|unsigned
name|long
name|offset
decl_stmt|;
name|unsigned
name|int
name|pointer_size
decl_stmt|;
name|offset
operator|=
name|start
operator|-
name|section_begin
expr_stmt|;
comment|/* Get the pointer size from the comp unit associated 	 with this block of location information.  */
if|if
condition|(
name|comp_unit
operator|>=
name|num_debug_line_pointer_sizes
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"Not enough comp units for .debug_loc section\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
block|{
name|pointer_size
operator|=
name|debug_line_pointer_sizes
index|[
name|comp_unit
index|]
expr_stmt|;
name|comp_unit
operator|++
expr_stmt|;
block|}
while|while
condition|(
literal|1
condition|)
block|{
name|begin
operator|=
name|byte_get
argument_list|(
name|start
argument_list|,
name|pointer_size
argument_list|)
expr_stmt|;
name|start
operator|+=
name|pointer_size
expr_stmt|;
name|end
operator|=
name|byte_get
argument_list|(
name|start
argument_list|,
name|pointer_size
argument_list|)
expr_stmt|;
name|start
operator|+=
name|pointer_size
expr_stmt|;
if|if
condition|(
name|begin
operator|==
literal|0
operator|&&
name|end
operator|==
literal|0
condition|)
break|break;
comment|/* For now, skip any base address specifiers.  */
if|if
condition|(
name|begin
operator|==
literal|0xffffffff
condition|)
continue|continue;
name|begin
operator|+=
name|addr
expr_stmt|;
name|end
operator|+=
name|addr
expr_stmt|;
name|length
operator|=
name|byte_get
argument_list|(
name|start
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|start
operator|+=
literal|2
expr_stmt|;
name|printf
argument_list|(
literal|"    %8.8lx %8.8lx %8.8lx ("
argument_list|,
name|offset
argument_list|,
name|begin
argument_list|,
name|end
argument_list|)
expr_stmt|;
name|decode_location_expression
argument_list|(
name|start
argument_list|,
name|pointer_size
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|")\n"
argument_list|)
expr_stmt|;
name|start
operator|+=
name|length
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|debug_str_contents
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_vma
name|debug_str_size
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|load_debug_str
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|)
block|{
name|Elf_Internal_Shdr
modifier|*
name|sec
decl_stmt|;
comment|/* If it is already loaded, do nothing.  */
if|if
condition|(
name|debug_str_contents
operator|!=
name|NULL
condition|)
return|return;
comment|/* Locate the .debug_str section.  */
name|sec
operator|=
name|find_section
argument_list|(
literal|".debug_str"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sec
operator|==
name|NULL
condition|)
return|return;
name|debug_str_size
operator|=
name|sec
operator|->
name|sh_size
expr_stmt|;
name|debug_str_contents
operator|=
name|get_data
argument_list|(
name|NULL
argument_list|,
name|file
argument_list|,
name|sec
operator|->
name|sh_offset
argument_list|,
name|sec
operator|->
name|sh_size
argument_list|,
name|_
argument_list|(
literal|"debug_str section data"
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|free_debug_str
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|debug_str_contents
operator|==
name|NULL
condition|)
return|return;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|debug_str_contents
argument_list|)
expr_stmt|;
name|debug_str_contents
operator|=
name|NULL
expr_stmt|;
name|debug_str_size
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|fetch_indirect_string
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
name|debug_str_contents
operator|==
name|NULL
condition|)
return|return
name|_
argument_list|(
literal|"<no .debug_str section>"
argument_list|)
return|;
if|if
condition|(
name|offset
operator|>
name|debug_str_size
condition|)
return|return
name|_
argument_list|(
literal|"<offset is too big>"
argument_list|)
return|;
return|return
name|debug_str_contents
operator|+
name|offset
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|display_debug_str
parameter_list|(
name|Elf_Internal_Shdr
modifier|*
name|section
parameter_list|,
name|unsigned
name|char
modifier|*
name|start
parameter_list|,
name|FILE
modifier|*
name|file
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|unsigned
name|long
name|bytes
decl_stmt|;
name|bfd_vma
name|addr
decl_stmt|;
name|addr
operator|=
name|section
operator|->
name|sh_addr
expr_stmt|;
name|bytes
operator|=
name|section
operator|->
name|sh_size
expr_stmt|;
if|if
condition|(
name|bytes
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
name|_
argument_list|(
literal|"\nThe .debug_str section is empty.\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|printf
argument_list|(
name|_
argument_list|(
literal|"Contents of the .debug_str section:\n\n"
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|bytes
condition|)
block|{
name|int
name|j
decl_stmt|;
name|int
name|k
decl_stmt|;
name|int
name|lbytes
decl_stmt|;
name|lbytes
operator|=
operator|(
name|bytes
operator|>
literal|16
condition|?
literal|16
else|:
name|bytes
operator|)
expr_stmt|;
name|printf
argument_list|(
literal|"  0x%8.8lx "
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|addr
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|16
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|j
operator|<
name|lbytes
condition|)
name|printf
argument_list|(
literal|"%2.2x"
argument_list|,
name|start
index|[
name|j
index|]
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"  "
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|j
operator|&
literal|3
operator|)
operator|==
literal|3
condition|)
name|printf
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|lbytes
condition|;
name|j
operator|++
control|)
block|{
name|k
operator|=
name|start
index|[
name|j
index|]
expr_stmt|;
if|if
condition|(
name|k
operator|>=
literal|' '
operator|&&
name|k
operator|<
literal|0x80
condition|)
name|printf
argument_list|(
literal|"%c"
argument_list|,
name|k
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"."
argument_list|)
expr_stmt|;
block|}
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|start
operator|+=
name|lbytes
expr_stmt|;
name|addr
operator|+=
name|lbytes
expr_stmt|;
name|bytes
operator|-=
name|lbytes
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|unsigned
name|char
modifier|*
name|read_and_display_attr_value
parameter_list|(
name|unsigned
name|long
name|attribute
parameter_list|,
name|unsigned
name|long
name|form
parameter_list|,
name|unsigned
name|char
modifier|*
name|data
parameter_list|,
name|unsigned
name|long
name|cu_offset
parameter_list|,
name|unsigned
name|long
name|pointer_size
parameter_list|,
name|unsigned
name|long
name|offset_size
parameter_list|,
name|int
name|dwarf_version
parameter_list|)
block|{
name|unsigned
name|long
name|uvalue
init|=
literal|0
decl_stmt|;
name|unsigned
name|char
modifier|*
name|block_start
init|=
name|NULL
decl_stmt|;
name|int
name|bytes_read
decl_stmt|;
switch|switch
condition|(
name|form
condition|)
block|{
default|default:
break|break;
case|case
name|DW_FORM_ref_addr
case|:
if|if
condition|(
name|dwarf_version
operator|==
literal|2
condition|)
block|{
name|uvalue
operator|=
name|byte_get
argument_list|(
name|data
argument_list|,
name|pointer_size
argument_list|)
expr_stmt|;
name|data
operator|+=
name|pointer_size
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dwarf_version
operator|==
literal|3
condition|)
block|{
name|uvalue
operator|=
name|byte_get
argument_list|(
name|data
argument_list|,
name|offset_size
argument_list|)
expr_stmt|;
name|data
operator|+=
name|offset_size
expr_stmt|;
block|}
else|else
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"Internal error: DWARF version is not 2 or 3.\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|DW_FORM_addr
case|:
name|uvalue
operator|=
name|byte_get
argument_list|(
name|data
argument_list|,
name|pointer_size
argument_list|)
expr_stmt|;
name|data
operator|+=
name|pointer_size
expr_stmt|;
break|break;
case|case
name|DW_FORM_strp
case|:
name|uvalue
operator|=
name|byte_get
argument_list|(
name|data
argument_list|,
name|offset_size
argument_list|)
expr_stmt|;
name|data
operator|+=
name|offset_size
expr_stmt|;
break|break;
case|case
name|DW_FORM_ref1
case|:
case|case
name|DW_FORM_flag
case|:
case|case
name|DW_FORM_data1
case|:
name|uvalue
operator|=
name|byte_get
argument_list|(
name|data
operator|++
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_FORM_ref2
case|:
case|case
name|DW_FORM_data2
case|:
name|uvalue
operator|=
name|byte_get
argument_list|(
name|data
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|data
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
name|DW_FORM_ref4
case|:
case|case
name|DW_FORM_data4
case|:
name|uvalue
operator|=
name|byte_get
argument_list|(
name|data
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|data
operator|+=
literal|4
expr_stmt|;
break|break;
case|case
name|DW_FORM_sdata
case|:
name|uvalue
operator|=
name|read_leb128
argument_list|(
name|data
argument_list|,
operator|&
name|bytes_read
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|data
operator|+=
name|bytes_read
expr_stmt|;
break|break;
case|case
name|DW_FORM_ref_udata
case|:
case|case
name|DW_FORM_udata
case|:
name|uvalue
operator|=
name|read_leb128
argument_list|(
name|data
argument_list|,
operator|&
name|bytes_read
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|data
operator|+=
name|bytes_read
expr_stmt|;
break|break;
case|case
name|DW_FORM_indirect
case|:
name|form
operator|=
name|read_leb128
argument_list|(
name|data
argument_list|,
operator|&
name|bytes_read
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|data
operator|+=
name|bytes_read
expr_stmt|;
name|printf
argument_list|(
literal|" %s"
argument_list|,
name|get_FORM_name
argument_list|(
name|form
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|read_and_display_attr_value
argument_list|(
name|attribute
argument_list|,
name|form
argument_list|,
name|data
argument_list|,
name|cu_offset
argument_list|,
name|pointer_size
argument_list|,
name|offset_size
argument_list|,
name|dwarf_version
argument_list|)
return|;
block|}
switch|switch
condition|(
name|form
condition|)
block|{
case|case
name|DW_FORM_ref_addr
case|:
name|printf
argument_list|(
literal|"<#%lx>"
argument_list|,
name|uvalue
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_FORM_ref1
case|:
case|case
name|DW_FORM_ref2
case|:
case|case
name|DW_FORM_ref4
case|:
case|case
name|DW_FORM_ref_udata
case|:
name|printf
argument_list|(
literal|"<%lx>"
argument_list|,
name|uvalue
operator|+
name|cu_offset
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_FORM_addr
case|:
name|printf
argument_list|(
literal|" %#lx"
argument_list|,
name|uvalue
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_FORM_flag
case|:
case|case
name|DW_FORM_data1
case|:
case|case
name|DW_FORM_data2
case|:
case|case
name|DW_FORM_data4
case|:
case|case
name|DW_FORM_sdata
case|:
case|case
name|DW_FORM_udata
case|:
name|printf
argument_list|(
literal|" %ld"
argument_list|,
name|uvalue
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_FORM_ref8
case|:
case|case
name|DW_FORM_data8
case|:
name|uvalue
operator|=
name|byte_get
argument_list|(
name|data
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %lx"
argument_list|,
name|uvalue
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %lx"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|byte_get
argument_list|(
name|data
operator|+
literal|4
argument_list|,
literal|4
argument_list|)
argument_list|)
expr_stmt|;
name|data
operator|+=
literal|8
expr_stmt|;
break|break;
case|case
name|DW_FORM_string
case|:
name|printf
argument_list|(
literal|" %s"
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|data
operator|+=
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|data
argument_list|)
operator|+
literal|1
expr_stmt|;
break|break;
case|case
name|DW_FORM_block
case|:
name|uvalue
operator|=
name|read_leb128
argument_list|(
name|data
argument_list|,
operator|&
name|bytes_read
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|block_start
operator|=
name|data
operator|+
name|bytes_read
expr_stmt|;
name|data
operator|=
name|display_block
argument_list|(
name|block_start
argument_list|,
name|uvalue
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_FORM_block1
case|:
name|uvalue
operator|=
name|byte_get
argument_list|(
name|data
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|block_start
operator|=
name|data
operator|+
literal|1
expr_stmt|;
name|data
operator|=
name|display_block
argument_list|(
name|block_start
argument_list|,
name|uvalue
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_FORM_block2
case|:
name|uvalue
operator|=
name|byte_get
argument_list|(
name|data
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|block_start
operator|=
name|data
operator|+
literal|2
expr_stmt|;
name|data
operator|=
name|display_block
argument_list|(
name|block_start
argument_list|,
name|uvalue
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_FORM_block4
case|:
name|uvalue
operator|=
name|byte_get
argument_list|(
name|data
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|block_start
operator|=
name|data
operator|+
literal|4
expr_stmt|;
name|data
operator|=
name|display_block
argument_list|(
name|block_start
argument_list|,
name|uvalue
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_FORM_strp
case|:
name|printf
argument_list|(
name|_
argument_list|(
literal|" (indirect string, offset: 0x%lx): %s"
argument_list|)
argument_list|,
name|uvalue
argument_list|,
name|fetch_indirect_string
argument_list|(
name|uvalue
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_FORM_indirect
case|:
comment|/* Handled above.  */
break|break;
default|default:
name|warn
argument_list|(
name|_
argument_list|(
literal|"Unrecognized form: %d\n"
argument_list|)
argument_list|,
name|form
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* For some attributes we can display further information.  */
name|printf
argument_list|(
literal|"\t"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|attribute
condition|)
block|{
case|case
name|DW_AT_inline
case|:
switch|switch
condition|(
name|uvalue
condition|)
block|{
case|case
name|DW_INL_not_inlined
case|:
name|printf
argument_list|(
name|_
argument_list|(
literal|"(not inlined)"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_INL_inlined
case|:
name|printf
argument_list|(
name|_
argument_list|(
literal|"(inlined)"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_INL_declared_not_inlined
case|:
name|printf
argument_list|(
name|_
argument_list|(
literal|"(declared as inline but ignored)"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_INL_declared_inlined
case|:
name|printf
argument_list|(
name|_
argument_list|(
literal|"(declared as inline and inlined)"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
name|_
argument_list|(
literal|"  (Unknown inline attribute value: %lx)"
argument_list|)
argument_list|,
name|uvalue
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|DW_AT_language
case|:
switch|switch
condition|(
name|uvalue
condition|)
block|{
case|case
name|DW_LANG_C
case|:
name|printf
argument_list|(
literal|"(non-ANSI C)"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_LANG_C89
case|:
name|printf
argument_list|(
literal|"(ANSI C)"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_LANG_C_plus_plus
case|:
name|printf
argument_list|(
literal|"(C++)"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_LANG_Fortran77
case|:
name|printf
argument_list|(
literal|"(FORTRAN 77)"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_LANG_Fortran90
case|:
name|printf
argument_list|(
literal|"(Fortran 90)"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_LANG_Modula2
case|:
name|printf
argument_list|(
literal|"(Modula 2)"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_LANG_Pascal83
case|:
name|printf
argument_list|(
literal|"(ANSI Pascal)"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_LANG_Ada83
case|:
name|printf
argument_list|(
literal|"(Ada)"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_LANG_Cobol74
case|:
name|printf
argument_list|(
literal|"(Cobol 74)"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_LANG_Cobol85
case|:
name|printf
argument_list|(
literal|"(Cobol 85)"
argument_list|)
expr_stmt|;
break|break;
comment|/* DWARF 2.1 values.	*/
case|case
name|DW_LANG_C99
case|:
name|printf
argument_list|(
literal|"(ANSI C99)"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_LANG_Ada95
case|:
name|printf
argument_list|(
literal|"(ADA 95)"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_LANG_Fortran95
case|:
name|printf
argument_list|(
literal|"(Fortran 95)"
argument_list|)
expr_stmt|;
break|break;
comment|/* MIPS extension.  */
case|case
name|DW_LANG_Mips_Assembler
case|:
name|printf
argument_list|(
literal|"(MIPS assembler)"
argument_list|)
expr_stmt|;
break|break;
comment|/* UPC extension.  */
case|case
name|DW_LANG_Upc
case|:
name|printf
argument_list|(
literal|"(Unified Parallel C)"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"(Unknown: %lx)"
argument_list|,
name|uvalue
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|DW_AT_encoding
case|:
switch|switch
condition|(
name|uvalue
condition|)
block|{
case|case
name|DW_ATE_void
case|:
name|printf
argument_list|(
literal|"(void)"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_ATE_address
case|:
name|printf
argument_list|(
literal|"(machine address)"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_ATE_boolean
case|:
name|printf
argument_list|(
literal|"(boolean)"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_ATE_complex_float
case|:
name|printf
argument_list|(
literal|"(complex float)"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_ATE_float
case|:
name|printf
argument_list|(
literal|"(float)"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_ATE_signed
case|:
name|printf
argument_list|(
literal|"(signed)"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_ATE_signed_char
case|:
name|printf
argument_list|(
literal|"(signed char)"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_ATE_unsigned
case|:
name|printf
argument_list|(
literal|"(unsigned)"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_ATE_unsigned_char
case|:
name|printf
argument_list|(
literal|"(unsigned char)"
argument_list|)
expr_stmt|;
break|break;
comment|/* DWARF 2.1 value.  */
case|case
name|DW_ATE_imaginary_float
case|:
name|printf
argument_list|(
literal|"(imaginary float)"
argument_list|)
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|uvalue
operator|>=
name|DW_ATE_lo_user
operator|&&
name|uvalue
operator|<=
name|DW_ATE_hi_user
condition|)
name|printf
argument_list|(
literal|"(user defined type)"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"(unknown type)"
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|DW_AT_accessibility
case|:
switch|switch
condition|(
name|uvalue
condition|)
block|{
case|case
name|DW_ACCESS_public
case|:
name|printf
argument_list|(
literal|"(public)"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_ACCESS_protected
case|:
name|printf
argument_list|(
literal|"(protected)"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_ACCESS_private
case|:
name|printf
argument_list|(
literal|"(private)"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"(unknown accessibility)"
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|DW_AT_visibility
case|:
switch|switch
condition|(
name|uvalue
condition|)
block|{
case|case
name|DW_VIS_local
case|:
name|printf
argument_list|(
literal|"(local)"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_VIS_exported
case|:
name|printf
argument_list|(
literal|"(exported)"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_VIS_qualified
case|:
name|printf
argument_list|(
literal|"(qualified)"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"(unknown visibility)"
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|DW_AT_virtuality
case|:
switch|switch
condition|(
name|uvalue
condition|)
block|{
case|case
name|DW_VIRTUALITY_none
case|:
name|printf
argument_list|(
literal|"(none)"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_VIRTUALITY_virtual
case|:
name|printf
argument_list|(
literal|"(virtual)"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_VIRTUALITY_pure_virtual
case|:
name|printf
argument_list|(
literal|"(pure_virtual)"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"(unknown virtuality)"
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|DW_AT_identifier_case
case|:
switch|switch
condition|(
name|uvalue
condition|)
block|{
case|case
name|DW_ID_case_sensitive
case|:
name|printf
argument_list|(
literal|"(case_sensitive)"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_ID_up_case
case|:
name|printf
argument_list|(
literal|"(up_case)"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_ID_down_case
case|:
name|printf
argument_list|(
literal|"(down_case)"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_ID_case_insensitive
case|:
name|printf
argument_list|(
literal|"(case_insensitive)"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"(unknown case)"
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|DW_AT_calling_convention
case|:
switch|switch
condition|(
name|uvalue
condition|)
block|{
case|case
name|DW_CC_normal
case|:
name|printf
argument_list|(
literal|"(normal)"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_CC_program
case|:
name|printf
argument_list|(
literal|"(program)"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_CC_nocall
case|:
name|printf
argument_list|(
literal|"(nocall)"
argument_list|)
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|uvalue
operator|>=
name|DW_CC_lo_user
operator|&&
name|uvalue
operator|<=
name|DW_CC_hi_user
condition|)
name|printf
argument_list|(
literal|"(user defined)"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"(unknown convention)"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|DW_AT_ordering
case|:
switch|switch
condition|(
name|uvalue
condition|)
block|{
case|case
operator|-
literal|1
case|:
name|printf
argument_list|(
literal|"(undefined)"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0
case|:
name|printf
argument_list|(
literal|"(row major)"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|printf
argument_list|(
literal|"(column major)"
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|DW_AT_frame_base
case|:
case|case
name|DW_AT_location
case|:
case|case
name|DW_AT_data_member_location
case|:
case|case
name|DW_AT_vtable_elem_location
case|:
case|case
name|DW_AT_allocated
case|:
case|case
name|DW_AT_associated
case|:
case|case
name|DW_AT_data_location
case|:
case|case
name|DW_AT_stride
case|:
case|case
name|DW_AT_upper_bound
case|:
case|case
name|DW_AT_lower_bound
case|:
if|if
condition|(
name|block_start
condition|)
block|{
name|printf
argument_list|(
literal|"("
argument_list|)
expr_stmt|;
name|decode_location_expression
argument_list|(
name|block_start
argument_list|,
name|pointer_size
argument_list|,
name|uvalue
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|")"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|form
operator|==
name|DW_FORM_data4
operator|||
name|form
operator|==
name|DW_FORM_data8
condition|)
block|{
name|printf
argument_list|(
literal|"("
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"location list"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|")"
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
return|return
name|data
return|;
block|}
end_function

begin_function
specifier|static
name|unsigned
name|char
modifier|*
name|read_and_display_attr
parameter_list|(
name|unsigned
name|long
name|attribute
parameter_list|,
name|unsigned
name|long
name|form
parameter_list|,
name|unsigned
name|char
modifier|*
name|data
parameter_list|,
name|unsigned
name|long
name|cu_offset
parameter_list|,
name|unsigned
name|long
name|pointer_size
parameter_list|,
name|unsigned
name|long
name|offset_size
parameter_list|,
name|int
name|dwarf_version
parameter_list|)
block|{
name|printf
argument_list|(
literal|"     %-18s:"
argument_list|,
name|get_AT_name
argument_list|(
name|attribute
argument_list|)
argument_list|)
expr_stmt|;
name|data
operator|=
name|read_and_display_attr_value
argument_list|(
name|attribute
argument_list|,
name|form
argument_list|,
name|data
argument_list|,
name|cu_offset
argument_list|,
name|pointer_size
argument_list|,
name|offset_size
argument_list|,
name|dwarf_version
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
return|return
name|data
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|display_debug_info
parameter_list|(
name|Elf_Internal_Shdr
modifier|*
name|section
parameter_list|,
name|unsigned
name|char
modifier|*
name|start
parameter_list|,
name|FILE
modifier|*
name|file
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|end
init|=
name|start
operator|+
name|section
operator|->
name|sh_size
decl_stmt|;
name|unsigned
name|char
modifier|*
name|section_begin
init|=
name|start
decl_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"The section %s contains:\n\n"
argument_list|)
argument_list|,
name|SECTION_NAME
argument_list|(
name|section
argument_list|)
argument_list|)
expr_stmt|;
name|load_debug_str
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|load_debug_loc
argument_list|(
name|file
argument_list|)
expr_stmt|;
while|while
condition|(
name|start
operator|<
name|end
condition|)
block|{
name|DWARF2_Internal_CompUnit
name|compunit
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|relsec
decl_stmt|;
name|unsigned
name|char
modifier|*
name|hdrptr
decl_stmt|;
name|unsigned
name|char
modifier|*
name|cu_abbrev_offset_ptr
decl_stmt|;
name|unsigned
name|char
modifier|*
name|tags
decl_stmt|;
name|int
name|level
decl_stmt|;
name|unsigned
name|long
name|cu_offset
decl_stmt|;
name|int
name|offset_size
decl_stmt|;
name|int
name|initial_length_size
decl_stmt|;
name|hdrptr
operator|=
name|start
expr_stmt|;
name|compunit
operator|.
name|cu_length
operator|=
name|byte_get
argument_list|(
name|hdrptr
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|hdrptr
operator|+=
literal|4
expr_stmt|;
if|if
condition|(
name|compunit
operator|.
name|cu_length
operator|==
literal|0xffffffff
condition|)
block|{
name|compunit
operator|.
name|cu_length
operator|=
name|byte_get
argument_list|(
name|hdrptr
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|hdrptr
operator|+=
literal|8
expr_stmt|;
name|offset_size
operator|=
literal|8
expr_stmt|;
name|initial_length_size
operator|=
literal|12
expr_stmt|;
block|}
else|else
block|{
name|offset_size
operator|=
literal|4
expr_stmt|;
name|initial_length_size
operator|=
literal|4
expr_stmt|;
block|}
name|compunit
operator|.
name|cu_version
operator|=
name|byte_get
argument_list|(
name|hdrptr
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|hdrptr
operator|+=
literal|2
expr_stmt|;
comment|/* Apply addends of RELA relocations.  */
for|for
control|(
name|relsec
operator|=
name|section_headers
init|;
name|relsec
operator|<
name|section_headers
operator|+
name|elf_header
operator|.
name|e_shnum
condition|;
operator|++
name|relsec
control|)
block|{
name|unsigned
name|long
name|nrelas
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|rela
decl_stmt|,
modifier|*
name|rp
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|symsec
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|symtab
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|sym
decl_stmt|;
if|if
condition|(
name|relsec
operator|->
name|sh_type
operator|!=
name|SHT_RELA
operator|||
name|SECTION_HEADER
argument_list|(
name|relsec
operator|->
name|sh_info
argument_list|)
operator|!=
name|section
operator|||
name|relsec
operator|->
name|sh_size
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
operator|!
name|slurp_rela_relocs
argument_list|(
name|file
argument_list|,
name|relsec
operator|->
name|sh_offset
argument_list|,
name|relsec
operator|->
name|sh_size
argument_list|,
operator|&
name|rela
argument_list|,
operator|&
name|nrelas
argument_list|)
condition|)
return|return
literal|0
return|;
name|symsec
operator|=
name|SECTION_HEADER
argument_list|(
name|relsec
operator|->
name|sh_link
argument_list|)
expr_stmt|;
name|symtab
operator|=
name|GET_ELF_SYMBOLS
argument_list|(
name|file
argument_list|,
name|symsec
argument_list|)
expr_stmt|;
for|for
control|(
name|rp
operator|=
name|rela
init|;
name|rp
operator|<
name|rela
operator|+
name|nrelas
condition|;
operator|++
name|rp
control|)
block|{
name|unsigned
name|char
modifier|*
name|loc
decl_stmt|;
if|if
condition|(
name|rp
operator|->
name|r_offset
operator|>=
call|(
name|bfd_vma
call|)
argument_list|(
name|hdrptr
operator|-
name|section_begin
argument_list|)
operator|&&
name|section
operator|->
name|sh_size
operator|>
operator|(
name|bfd_vma
operator|)
name|offset_size
operator|&&
name|rp
operator|->
name|r_offset
operator|<=
name|section
operator|->
name|sh_size
operator|-
name|offset_size
condition|)
name|loc
operator|=
name|section_begin
operator|+
name|rp
operator|->
name|r_offset
expr_stmt|;
else|else
continue|continue;
if|if
condition|(
name|is_32bit_elf
condition|)
block|{
name|sym
operator|=
name|symtab
operator|+
name|ELF32_R_SYM
argument_list|(
name|rp
operator|->
name|r_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|ELF32_R_SYM
argument_list|(
name|rp
operator|->
name|r_info
argument_list|)
operator|!=
literal|0
operator|&&
name|ELF32_ST_TYPE
argument_list|(
name|sym
operator|->
name|st_info
argument_list|)
operator|!=
name|STT_SECTION
condition|)
block|{
name|warn
argument_list|(
name|_
argument_list|(
literal|"Skipping unexpected symbol type %u\n"
argument_list|)
argument_list|,
name|ELF32_ST_TYPE
argument_list|(
name|sym
operator|->
name|st_info
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
else|else
block|{
name|sym
operator|=
name|symtab
operator|+
name|ELF64_R_SYM
argument_list|(
name|rp
operator|->
name|r_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|ELF64_R_SYM
argument_list|(
name|rp
operator|->
name|r_info
argument_list|)
operator|!=
literal|0
operator|&&
name|ELF64_ST_TYPE
argument_list|(
name|sym
operator|->
name|st_info
argument_list|)
operator|!=
name|STT_SECTION
condition|)
block|{
name|warn
argument_list|(
name|_
argument_list|(
literal|"Skipping unexpected symbol type %u\n"
argument_list|)
argument_list|,
name|ELF64_ST_TYPE
argument_list|(
name|sym
operator|->
name|st_info
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
name|byte_put
argument_list|(
name|loc
argument_list|,
name|rp
operator|->
name|r_addend
argument_list|,
name|offset_size
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|rela
argument_list|)
expr_stmt|;
break|break;
block|}
name|cu_abbrev_offset_ptr
operator|=
name|hdrptr
expr_stmt|;
name|compunit
operator|.
name|cu_abbrev_offset
operator|=
name|byte_get
argument_list|(
name|hdrptr
argument_list|,
name|offset_size
argument_list|)
expr_stmt|;
name|hdrptr
operator|+=
name|offset_size
expr_stmt|;
name|compunit
operator|.
name|cu_pointer_size
operator|=
name|byte_get
argument_list|(
name|hdrptr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|hdrptr
operator|+=
literal|1
expr_stmt|;
name|tags
operator|=
name|hdrptr
expr_stmt|;
name|cu_offset
operator|=
name|start
operator|-
name|section_begin
expr_stmt|;
name|start
operator|+=
name|compunit
operator|.
name|cu_length
operator|+
name|initial_length_size
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"  Compilation Unit @ %lx:\n"
argument_list|)
argument_list|,
name|cu_offset
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"   Length:        %ld\n"
argument_list|)
argument_list|,
name|compunit
operator|.
name|cu_length
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"   Version:       %d\n"
argument_list|)
argument_list|,
name|compunit
operator|.
name|cu_version
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"   Abbrev Offset: %ld\n"
argument_list|)
argument_list|,
name|compunit
operator|.
name|cu_abbrev_offset
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"   Pointer Size:  %d\n"
argument_list|)
argument_list|,
name|compunit
operator|.
name|cu_pointer_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|compunit
operator|.
name|cu_version
operator|!=
literal|2
operator|&&
name|compunit
operator|.
name|cu_version
operator|!=
literal|3
condition|)
block|{
name|warn
argument_list|(
name|_
argument_list|(
literal|"Only version 2 and 3 DWARF debug information is currently supported.\n"
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|free_abbrevs
argument_list|()
expr_stmt|;
comment|/* Read in the abbrevs used by this compilation unit.  */
block|{
name|Elf_Internal_Shdr
modifier|*
name|sec
decl_stmt|;
name|unsigned
name|char
modifier|*
name|begin
decl_stmt|;
comment|/* Locate the .debug_abbrev section and process it.  */
name|sec
operator|=
name|find_section
argument_list|(
literal|".debug_abbrev"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sec
operator|==
name|NULL
condition|)
block|{
name|warn
argument_list|(
name|_
argument_list|(
literal|"Unable to locate .debug_abbrev section!\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|begin
operator|=
name|get_data
argument_list|(
name|NULL
argument_list|,
name|file
argument_list|,
name|sec
operator|->
name|sh_offset
argument_list|,
name|sec
operator|->
name|sh_size
argument_list|,
name|_
argument_list|(
literal|"debug_abbrev section data"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|begin
condition|)
return|return
literal|0
return|;
name|process_abbrev_section
argument_list|(
name|begin
operator|+
name|compunit
operator|.
name|cu_abbrev_offset
argument_list|,
name|begin
operator|+
name|sec
operator|->
name|sh_size
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|begin
argument_list|)
expr_stmt|;
block|}
name|level
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|tags
operator|<
name|start
condition|)
block|{
name|int
name|bytes_read
decl_stmt|;
name|unsigned
name|long
name|abbrev_number
decl_stmt|;
name|abbrev_entry
modifier|*
name|entry
decl_stmt|;
name|abbrev_attr
modifier|*
name|attr
decl_stmt|;
name|abbrev_number
operator|=
name|read_leb128
argument_list|(
name|tags
argument_list|,
operator|&
name|bytes_read
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tags
operator|+=
name|bytes_read
expr_stmt|;
comment|/* A null DIE marks the end of a list of children.  */
if|if
condition|(
name|abbrev_number
operator|==
literal|0
condition|)
block|{
operator|--
name|level
expr_stmt|;
continue|continue;
block|}
comment|/* Scan through the abbreviation list until we reach the 	     correct entry.  */
for|for
control|(
name|entry
operator|=
name|first_abbrev
init|;
name|entry
operator|&&
name|entry
operator|->
name|entry
operator|!=
name|abbrev_number
condition|;
name|entry
operator|=
name|entry
operator|->
name|next
control|)
continue|continue;
if|if
condition|(
name|entry
operator|==
name|NULL
condition|)
block|{
name|warn
argument_list|(
name|_
argument_list|(
literal|"Unable to locate entry %lu in the abbreviation table\n"
argument_list|)
argument_list|,
name|abbrev_number
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|printf
argument_list|(
name|_
argument_list|(
literal|"<%d><%lx>: Abbrev Number: %lu (%s)\n"
argument_list|)
argument_list|,
name|level
argument_list|,
call|(
name|unsigned
name|long
call|)
argument_list|(
name|tags
operator|-
name|section_begin
operator|-
name|bytes_read
argument_list|)
argument_list|,
name|abbrev_number
argument_list|,
name|get_TAG_name
argument_list|(
name|entry
operator|->
name|tag
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|attr
operator|=
name|entry
operator|->
name|first_attr
init|;
name|attr
condition|;
name|attr
operator|=
name|attr
operator|->
name|next
control|)
name|tags
operator|=
name|read_and_display_attr
argument_list|(
name|attr
operator|->
name|attribute
argument_list|,
name|attr
operator|->
name|form
argument_list|,
name|tags
argument_list|,
name|cu_offset
argument_list|,
name|compunit
operator|.
name|cu_pointer_size
argument_list|,
name|offset_size
argument_list|,
name|compunit
operator|.
name|cu_version
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|children
condition|)
operator|++
name|level
expr_stmt|;
block|}
block|}
name|free_debug_str
argument_list|()
expr_stmt|;
name|free_debug_loc
argument_list|()
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|display_debug_aranges
parameter_list|(
name|Elf_Internal_Shdr
modifier|*
name|section
parameter_list|,
name|unsigned
name|char
modifier|*
name|start
parameter_list|,
name|FILE
modifier|*
name|file
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|end
init|=
name|start
operator|+
name|section
operator|->
name|sh_size
decl_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"The section %s contains:\n\n"
argument_list|)
argument_list|,
name|SECTION_NAME
argument_list|(
name|section
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|start
operator|<
name|end
condition|)
block|{
name|unsigned
name|char
modifier|*
name|hdrptr
decl_stmt|;
name|DWARF2_Internal_ARange
name|arange
decl_stmt|;
name|unsigned
name|char
modifier|*
name|ranges
decl_stmt|;
name|unsigned
name|long
name|length
decl_stmt|;
name|unsigned
name|long
name|address
decl_stmt|;
name|int
name|excess
decl_stmt|;
name|int
name|offset_size
decl_stmt|;
name|int
name|initial_length_size
decl_stmt|;
name|hdrptr
operator|=
name|start
expr_stmt|;
name|arange
operator|.
name|ar_length
operator|=
name|byte_get
argument_list|(
name|hdrptr
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|hdrptr
operator|+=
literal|4
expr_stmt|;
if|if
condition|(
name|arange
operator|.
name|ar_length
operator|==
literal|0xffffffff
condition|)
block|{
name|arange
operator|.
name|ar_length
operator|=
name|byte_get
argument_list|(
name|hdrptr
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|hdrptr
operator|+=
literal|8
expr_stmt|;
name|offset_size
operator|=
literal|8
expr_stmt|;
name|initial_length_size
operator|=
literal|12
expr_stmt|;
block|}
else|else
block|{
name|offset_size
operator|=
literal|4
expr_stmt|;
name|initial_length_size
operator|=
literal|4
expr_stmt|;
block|}
name|arange
operator|.
name|ar_version
operator|=
name|byte_get
argument_list|(
name|hdrptr
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|hdrptr
operator|+=
literal|2
expr_stmt|;
name|arange
operator|.
name|ar_info_offset
operator|=
name|byte_get
argument_list|(
name|hdrptr
argument_list|,
name|offset_size
argument_list|)
expr_stmt|;
name|hdrptr
operator|+=
name|offset_size
expr_stmt|;
name|arange
operator|.
name|ar_pointer_size
operator|=
name|byte_get
argument_list|(
name|hdrptr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|hdrptr
operator|+=
literal|1
expr_stmt|;
name|arange
operator|.
name|ar_segment_size
operator|=
name|byte_get
argument_list|(
name|hdrptr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|hdrptr
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
name|arange
operator|.
name|ar_version
operator|!=
literal|2
operator|&&
name|arange
operator|.
name|ar_version
operator|!=
literal|3
condition|)
block|{
name|warn
argument_list|(
name|_
argument_list|(
literal|"Only DWARF 2 and 3 aranges are currently supported.\n"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|printf
argument_list|(
name|_
argument_list|(
literal|"  Length:                   %ld\n"
argument_list|)
argument_list|,
name|arange
operator|.
name|ar_length
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"  Version:                  %d\n"
argument_list|)
argument_list|,
name|arange
operator|.
name|ar_version
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"  Offset into .debug_info:  %lx\n"
argument_list|)
argument_list|,
name|arange
operator|.
name|ar_info_offset
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"  Pointer Size:             %d\n"
argument_list|)
argument_list|,
name|arange
operator|.
name|ar_pointer_size
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"  Segment Size:             %d\n"
argument_list|)
argument_list|,
name|arange
operator|.
name|ar_segment_size
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"\n    Address  Length\n"
argument_list|)
argument_list|)
expr_stmt|;
name|ranges
operator|=
name|hdrptr
expr_stmt|;
comment|/* Must pad to an alignment boundary that is twice the pointer size.  */
name|excess
operator|=
operator|(
name|hdrptr
operator|-
name|start
operator|)
operator|%
operator|(
literal|2
operator|*
name|arange
operator|.
name|ar_pointer_size
operator|)
expr_stmt|;
if|if
condition|(
name|excess
condition|)
name|ranges
operator|+=
operator|(
literal|2
operator|*
name|arange
operator|.
name|ar_pointer_size
operator|)
operator|-
name|excess
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|address
operator|=
name|byte_get
argument_list|(
name|ranges
argument_list|,
name|arange
operator|.
name|ar_pointer_size
argument_list|)
expr_stmt|;
name|ranges
operator|+=
name|arange
operator|.
name|ar_pointer_size
expr_stmt|;
name|length
operator|=
name|byte_get
argument_list|(
name|ranges
argument_list|,
name|arange
operator|.
name|ar_pointer_size
argument_list|)
expr_stmt|;
name|ranges
operator|+=
name|arange
operator|.
name|ar_pointer_size
expr_stmt|;
comment|/* A pair of zeros marks the end of the list.  */
if|if
condition|(
name|address
operator|==
literal|0
operator|&&
name|length
operator|==
literal|0
condition|)
break|break;
name|printf
argument_list|(
literal|"    %8.8lx %lu\n"
argument_list|,
name|address
argument_list|,
name|length
argument_list|)
expr_stmt|;
block|}
name|start
operator|+=
name|arange
operator|.
name|ar_length
operator|+
name|initial_length_size
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_typedef
typedef|typedef
struct|struct
name|Frame_Chunk
block|{
name|struct
name|Frame_Chunk
modifier|*
name|next
decl_stmt|;
name|unsigned
name|char
modifier|*
name|chunk_start
decl_stmt|;
name|int
name|ncols
decl_stmt|;
comment|/* DW_CFA_{undefined,same_value,offset,register,unreferenced}  */
name|short
name|int
modifier|*
name|col_type
decl_stmt|;
name|int
modifier|*
name|col_offset
decl_stmt|;
name|char
modifier|*
name|augmentation
decl_stmt|;
name|unsigned
name|int
name|code_factor
decl_stmt|;
name|int
name|data_factor
decl_stmt|;
name|unsigned
name|long
name|pc_begin
decl_stmt|;
name|unsigned
name|long
name|pc_range
decl_stmt|;
name|int
name|cfa_reg
decl_stmt|;
name|int
name|cfa_offset
decl_stmt|;
name|int
name|ra
decl_stmt|;
name|unsigned
name|char
name|fde_encoding
decl_stmt|;
name|unsigned
name|char
name|cfa_exp
decl_stmt|;
block|}
name|Frame_Chunk
typedef|;
end_typedef

begin_comment
comment|/* A marker for a col_type that means this column was never referenced    in the frame info.  */
end_comment

begin_define
define|#
directive|define
name|DW_CFA_unreferenced
value|(-1)
end_define

begin_function
specifier|static
name|void
name|frame_need_space
parameter_list|(
name|Frame_Chunk
modifier|*
name|fc
parameter_list|,
name|int
name|reg
parameter_list|)
block|{
name|int
name|prev
init|=
name|fc
operator|->
name|ncols
decl_stmt|;
if|if
condition|(
name|reg
operator|<
name|fc
operator|->
name|ncols
condition|)
return|return;
name|fc
operator|->
name|ncols
operator|=
name|reg
operator|+
literal|1
expr_stmt|;
name|fc
operator|->
name|col_type
operator|=
name|xrealloc
argument_list|(
name|fc
operator|->
name|col_type
argument_list|,
name|fc
operator|->
name|ncols
operator|*
expr|sizeof
operator|(
name|short
name|int
operator|)
argument_list|)
expr_stmt|;
name|fc
operator|->
name|col_offset
operator|=
name|xrealloc
argument_list|(
name|fc
operator|->
name|col_offset
argument_list|,
name|fc
operator|->
name|ncols
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|prev
operator|<
name|fc
operator|->
name|ncols
condition|)
block|{
name|fc
operator|->
name|col_type
index|[
name|prev
index|]
operator|=
name|DW_CFA_unreferenced
expr_stmt|;
name|fc
operator|->
name|col_offset
index|[
name|prev
index|]
operator|=
literal|0
expr_stmt|;
name|prev
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|frame_display_row
parameter_list|(
name|Frame_Chunk
modifier|*
name|fc
parameter_list|,
name|int
modifier|*
name|need_col_headers
parameter_list|,
name|int
modifier|*
name|max_regs
parameter_list|)
block|{
name|int
name|r
decl_stmt|;
name|char
name|tmp
index|[
literal|100
index|]
decl_stmt|;
if|if
condition|(
operator|*
name|max_regs
operator|<
name|fc
operator|->
name|ncols
condition|)
operator|*
name|max_regs
operator|=
name|fc
operator|->
name|ncols
expr_stmt|;
if|if
condition|(
operator|*
name|need_col_headers
condition|)
block|{
operator|*
name|need_col_headers
operator|=
literal|0
expr_stmt|;
name|printf
argument_list|(
literal|"   LOC   CFA      "
argument_list|)
expr_stmt|;
for|for
control|(
name|r
operator|=
literal|0
init|;
name|r
operator|<
operator|*
name|max_regs
condition|;
name|r
operator|++
control|)
if|if
condition|(
name|fc
operator|->
name|col_type
index|[
name|r
index|]
operator|!=
name|DW_CFA_unreferenced
condition|)
block|{
if|if
condition|(
name|r
operator|==
name|fc
operator|->
name|ra
condition|)
name|printf
argument_list|(
literal|"ra   "
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"r%-4d"
argument_list|,
name|r
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"%08lx "
argument_list|,
name|fc
operator|->
name|pc_begin
argument_list|)
expr_stmt|;
if|if
condition|(
name|fc
operator|->
name|cfa_exp
condition|)
name|strcpy
argument_list|(
name|tmp
argument_list|,
literal|"exp"
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|tmp
argument_list|,
literal|"r%d%+d"
argument_list|,
name|fc
operator|->
name|cfa_reg
argument_list|,
name|fc
operator|->
name|cfa_offset
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%-8s "
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
for|for
control|(
name|r
operator|=
literal|0
init|;
name|r
operator|<
name|fc
operator|->
name|ncols
condition|;
name|r
operator|++
control|)
block|{
if|if
condition|(
name|fc
operator|->
name|col_type
index|[
name|r
index|]
operator|!=
name|DW_CFA_unreferenced
condition|)
block|{
switch|switch
condition|(
name|fc
operator|->
name|col_type
index|[
name|r
index|]
condition|)
block|{
case|case
name|DW_CFA_undefined
case|:
name|strcpy
argument_list|(
name|tmp
argument_list|,
literal|"u"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_CFA_same_value
case|:
name|strcpy
argument_list|(
name|tmp
argument_list|,
literal|"s"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_CFA_offset
case|:
name|sprintf
argument_list|(
name|tmp
argument_list|,
literal|"c%+d"
argument_list|,
name|fc
operator|->
name|col_offset
index|[
name|r
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_CFA_register
case|:
name|sprintf
argument_list|(
name|tmp
argument_list|,
literal|"r%d"
argument_list|,
name|fc
operator|->
name|col_offset
index|[
name|r
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_CFA_expression
case|:
name|strcpy
argument_list|(
name|tmp
argument_list|,
literal|"exp"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|strcpy
argument_list|(
name|tmp
argument_list|,
literal|"n/a"
argument_list|)
expr_stmt|;
break|break;
block|}
name|printf
argument_list|(
literal|"%-5s"
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
block|}
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|size_of_encoded_value
parameter_list|(
name|int
name|encoding
parameter_list|)
block|{
switch|switch
condition|(
name|encoding
operator|&
literal|0x7
condition|)
block|{
default|default:
comment|/* ??? */
case|case
literal|0
case|:
return|return
name|is_32bit_elf
condition|?
literal|4
else|:
literal|8
return|;
case|case
literal|2
case|:
return|return
literal|2
return|;
case|case
literal|3
case|:
return|return
literal|4
return|;
case|case
literal|4
case|:
return|return
literal|8
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|bfd_vma
name|get_encoded_value
parameter_list|(
name|unsigned
name|char
modifier|*
name|data
parameter_list|,
name|int
name|encoding
parameter_list|)
block|{
name|int
name|size
init|=
name|size_of_encoded_value
argument_list|(
name|encoding
argument_list|)
decl_stmt|;
if|if
condition|(
name|encoding
operator|&
name|DW_EH_PE_signed
condition|)
return|return
name|byte_get_signed
argument_list|(
name|data
argument_list|,
name|size
argument_list|)
return|;
else|else
return|return
name|byte_get
argument_list|(
name|data
argument_list|,
name|size
argument_list|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|GET
parameter_list|(
name|N
parameter_list|)
value|byte_get (start, N); start += N
end_define

begin_define
define|#
directive|define
name|LEB
parameter_list|()
value|read_leb128 (start,& length_return, 0); start += length_return
end_define

begin_define
define|#
directive|define
name|SLEB
parameter_list|()
value|read_leb128 (start,& length_return, 1); start += length_return
end_define

begin_function
specifier|static
name|int
name|display_debug_frames
parameter_list|(
name|Elf_Internal_Shdr
modifier|*
name|section
parameter_list|,
name|unsigned
name|char
modifier|*
name|start
parameter_list|,
name|FILE
modifier|*
name|file
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|end
init|=
name|start
operator|+
name|section
operator|->
name|sh_size
decl_stmt|;
name|unsigned
name|char
modifier|*
name|section_start
init|=
name|start
decl_stmt|;
name|Frame_Chunk
modifier|*
name|chunks
init|=
literal|0
decl_stmt|;
name|Frame_Chunk
modifier|*
name|remembered_state
init|=
literal|0
decl_stmt|;
name|Frame_Chunk
modifier|*
name|rs
decl_stmt|;
name|int
name|is_eh
init|=
operator|(
name|strcmp
argument_list|(
name|SECTION_NAME
argument_list|(
name|section
argument_list|)
argument_list|,
literal|".eh_frame"
argument_list|)
operator|==
literal|0
operator|)
decl_stmt|;
name|int
name|length_return
decl_stmt|;
name|int
name|max_regs
init|=
literal|0
decl_stmt|;
name|int
name|addr_size
init|=
name|is_32bit_elf
condition|?
literal|4
else|:
literal|8
decl_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"The section %s contains:\n"
argument_list|)
argument_list|,
name|SECTION_NAME
argument_list|(
name|section
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|start
operator|<
name|end
condition|)
block|{
name|unsigned
name|char
modifier|*
name|saved_start
decl_stmt|;
name|unsigned
name|char
modifier|*
name|block_end
decl_stmt|;
name|unsigned
name|long
name|length
decl_stmt|;
name|unsigned
name|long
name|cie_id
decl_stmt|;
name|Frame_Chunk
modifier|*
name|fc
decl_stmt|;
name|Frame_Chunk
modifier|*
name|cie
decl_stmt|;
name|int
name|need_col_headers
init|=
literal|1
decl_stmt|;
name|unsigned
name|char
modifier|*
name|augmentation_data
init|=
name|NULL
decl_stmt|;
name|unsigned
name|long
name|augmentation_data_len
init|=
literal|0
decl_stmt|;
name|int
name|encoded_ptr_size
init|=
name|addr_size
decl_stmt|;
name|int
name|offset_size
decl_stmt|;
name|int
name|initial_length_size
decl_stmt|;
name|saved_start
operator|=
name|start
expr_stmt|;
name|length
operator|=
name|byte_get
argument_list|(
name|start
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|start
operator|+=
literal|4
expr_stmt|;
if|if
condition|(
name|length
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"\n%08lx ZERO terminator\n\n"
argument_list|,
call|(
name|unsigned
name|long
call|)
argument_list|(
name|saved_start
operator|-
name|section_start
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|length
operator|==
literal|0xffffffff
condition|)
block|{
name|length
operator|=
name|byte_get
argument_list|(
name|start
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|start
operator|+=
literal|8
expr_stmt|;
name|offset_size
operator|=
literal|8
expr_stmt|;
name|initial_length_size
operator|=
literal|12
expr_stmt|;
block|}
else|else
block|{
name|offset_size
operator|=
literal|4
expr_stmt|;
name|initial_length_size
operator|=
literal|4
expr_stmt|;
block|}
name|block_end
operator|=
name|saved_start
operator|+
name|length
operator|+
name|initial_length_size
expr_stmt|;
name|cie_id
operator|=
name|byte_get
argument_list|(
name|start
argument_list|,
name|offset_size
argument_list|)
expr_stmt|;
name|start
operator|+=
name|offset_size
expr_stmt|;
if|if
condition|(
name|is_eh
condition|?
operator|(
name|cie_id
operator|==
literal|0
operator|)
else|:
operator|(
name|cie_id
operator|==
name|DW_CIE_ID
operator|)
condition|)
block|{
name|int
name|version
decl_stmt|;
name|fc
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|Frame_Chunk
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|fc
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|Frame_Chunk
argument_list|)
argument_list|)
expr_stmt|;
name|fc
operator|->
name|next
operator|=
name|chunks
expr_stmt|;
name|chunks
operator|=
name|fc
expr_stmt|;
name|fc
operator|->
name|chunk_start
operator|=
name|saved_start
expr_stmt|;
name|fc
operator|->
name|ncols
operator|=
literal|0
expr_stmt|;
name|fc
operator|->
name|col_type
operator|=
name|xmalloc
argument_list|(
expr|sizeof
operator|(
name|short
name|int
operator|)
argument_list|)
expr_stmt|;
name|fc
operator|->
name|col_offset
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|frame_need_space
argument_list|(
name|fc
argument_list|,
name|max_regs
operator|-
literal|1
argument_list|)
expr_stmt|;
name|version
operator|=
operator|*
name|start
operator|++
expr_stmt|;
name|fc
operator|->
name|augmentation
operator|=
name|start
expr_stmt|;
name|start
operator|=
name|strchr
argument_list|(
name|start
argument_list|,
literal|'\0'
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|fc
operator|->
name|augmentation
index|[
literal|0
index|]
operator|==
literal|'z'
condition|)
block|{
name|fc
operator|->
name|code_factor
operator|=
name|LEB
argument_list|()
expr_stmt|;
name|fc
operator|->
name|data_factor
operator|=
name|SLEB
argument_list|()
expr_stmt|;
name|fc
operator|->
name|ra
operator|=
name|byte_get
argument_list|(
name|start
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|start
operator|+=
literal|1
expr_stmt|;
name|augmentation_data_len
operator|=
name|LEB
argument_list|()
expr_stmt|;
name|augmentation_data
operator|=
name|start
expr_stmt|;
name|start
operator|+=
name|augmentation_data_len
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|fc
operator|->
name|augmentation
argument_list|,
literal|"eh"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|start
operator|+=
name|addr_size
expr_stmt|;
name|fc
operator|->
name|code_factor
operator|=
name|LEB
argument_list|()
expr_stmt|;
name|fc
operator|->
name|data_factor
operator|=
name|SLEB
argument_list|()
expr_stmt|;
name|fc
operator|->
name|ra
operator|=
name|byte_get
argument_list|(
name|start
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|start
operator|+=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|fc
operator|->
name|code_factor
operator|=
name|LEB
argument_list|()
expr_stmt|;
name|fc
operator|->
name|data_factor
operator|=
name|SLEB
argument_list|()
expr_stmt|;
name|fc
operator|->
name|ra
operator|=
name|byte_get
argument_list|(
name|start
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|start
operator|+=
literal|1
expr_stmt|;
block|}
name|cie
operator|=
name|fc
expr_stmt|;
if|if
condition|(
name|do_debug_frames_interp
condition|)
name|printf
argument_list|(
literal|"\n%08lx %08lx %08lx CIE \"%s\" cf=%d df=%d ra=%d\n"
argument_list|,
call|(
name|unsigned
name|long
call|)
argument_list|(
name|saved_start
operator|-
name|section_start
argument_list|)
argument_list|,
name|length
argument_list|,
name|cie_id
argument_list|,
name|fc
operator|->
name|augmentation
argument_list|,
name|fc
operator|->
name|code_factor
argument_list|,
name|fc
operator|->
name|data_factor
argument_list|,
name|fc
operator|->
name|ra
argument_list|)
expr_stmt|;
else|else
block|{
name|printf
argument_list|(
literal|"\n%08lx %08lx %08lx CIE\n"
argument_list|,
call|(
name|unsigned
name|long
call|)
argument_list|(
name|saved_start
operator|-
name|section_start
argument_list|)
argument_list|,
name|length
argument_list|,
name|cie_id
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  Version:               %d\n"
argument_list|,
name|version
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  Augmentation:          \"%s\"\n"
argument_list|,
name|fc
operator|->
name|augmentation
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  Code alignment factor: %u\n"
argument_list|,
name|fc
operator|->
name|code_factor
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  Data alignment factor: %d\n"
argument_list|,
name|fc
operator|->
name|data_factor
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  Return address column: %d\n"
argument_list|,
name|fc
operator|->
name|ra
argument_list|)
expr_stmt|;
if|if
condition|(
name|augmentation_data_len
condition|)
block|{
name|unsigned
name|long
name|i
decl_stmt|;
name|printf
argument_list|(
literal|"  Augmentation data:    "
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|augmentation_data_len
condition|;
operator|++
name|i
control|)
name|printf
argument_list|(
literal|" %02x"
argument_list|,
name|augmentation_data
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|augmentation_data_len
condition|)
block|{
name|unsigned
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|p
operator|=
name|fc
operator|->
name|augmentation
operator|+
literal|1
expr_stmt|;
name|q
operator|=
name|augmentation_data
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'L'
condition|)
name|q
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'P'
condition|)
name|q
operator|+=
literal|1
operator|+
name|size_of_encoded_value
argument_list|(
operator|*
name|q
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'R'
condition|)
name|fc
operator|->
name|fde_encoding
operator|=
operator|*
name|q
operator|++
expr_stmt|;
else|else
break|break;
name|p
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|fc
operator|->
name|fde_encoding
condition|)
name|encoded_ptr_size
operator|=
name|size_of_encoded_value
argument_list|(
name|fc
operator|->
name|fde_encoding
argument_list|)
expr_stmt|;
block|}
name|frame_need_space
argument_list|(
name|fc
argument_list|,
name|fc
operator|->
name|ra
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|unsigned
name|char
modifier|*
name|look_for
decl_stmt|;
specifier|static
name|Frame_Chunk
name|fde_fc
decl_stmt|;
name|fc
operator|=
operator|&
name|fde_fc
expr_stmt|;
name|memset
argument_list|(
name|fc
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|Frame_Chunk
argument_list|)
argument_list|)
expr_stmt|;
name|look_for
operator|=
name|is_eh
condition|?
name|start
operator|-
literal|4
operator|-
name|cie_id
else|:
name|section_start
operator|+
name|cie_id
expr_stmt|;
for|for
control|(
name|cie
operator|=
name|chunks
init|;
name|cie
condition|;
name|cie
operator|=
name|cie
operator|->
name|next
control|)
if|if
condition|(
name|cie
operator|->
name|chunk_start
operator|==
name|look_for
condition|)
break|break;
if|if
condition|(
operator|!
name|cie
condition|)
block|{
name|warn
argument_list|(
literal|"Invalid CIE pointer %08lx in FDE at %08lx\n"
argument_list|,
name|cie_id
argument_list|,
name|saved_start
argument_list|)
expr_stmt|;
name|start
operator|=
name|block_end
expr_stmt|;
name|fc
operator|->
name|ncols
operator|=
literal|0
expr_stmt|;
name|fc
operator|->
name|col_type
operator|=
name|xmalloc
argument_list|(
expr|sizeof
operator|(
name|short
name|int
operator|)
argument_list|)
expr_stmt|;
name|fc
operator|->
name|col_offset
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|frame_need_space
argument_list|(
name|fc
argument_list|,
name|max_regs
operator|-
literal|1
argument_list|)
expr_stmt|;
name|cie
operator|=
name|fc
expr_stmt|;
name|fc
operator|->
name|augmentation
operator|=
literal|""
expr_stmt|;
name|fc
operator|->
name|fde_encoding
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|fc
operator|->
name|ncols
operator|=
name|cie
operator|->
name|ncols
expr_stmt|;
name|fc
operator|->
name|col_type
operator|=
name|xmalloc
argument_list|(
name|fc
operator|->
name|ncols
operator|*
expr|sizeof
operator|(
name|short
name|int
operator|)
argument_list|)
expr_stmt|;
name|fc
operator|->
name|col_offset
operator|=
name|xmalloc
argument_list|(
name|fc
operator|->
name|ncols
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|fc
operator|->
name|col_type
argument_list|,
name|cie
operator|->
name|col_type
argument_list|,
name|fc
operator|->
name|ncols
operator|*
expr|sizeof
operator|(
name|short
name|int
operator|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|fc
operator|->
name|col_offset
argument_list|,
name|cie
operator|->
name|col_offset
argument_list|,
name|fc
operator|->
name|ncols
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|fc
operator|->
name|augmentation
operator|=
name|cie
operator|->
name|augmentation
expr_stmt|;
name|fc
operator|->
name|code_factor
operator|=
name|cie
operator|->
name|code_factor
expr_stmt|;
name|fc
operator|->
name|data_factor
operator|=
name|cie
operator|->
name|data_factor
expr_stmt|;
name|fc
operator|->
name|cfa_reg
operator|=
name|cie
operator|->
name|cfa_reg
expr_stmt|;
name|fc
operator|->
name|cfa_offset
operator|=
name|cie
operator|->
name|cfa_offset
expr_stmt|;
name|fc
operator|->
name|ra
operator|=
name|cie
operator|->
name|ra
expr_stmt|;
name|frame_need_space
argument_list|(
name|fc
argument_list|,
name|max_regs
operator|-
literal|1
argument_list|)
expr_stmt|;
name|fc
operator|->
name|fde_encoding
operator|=
name|cie
operator|->
name|fde_encoding
expr_stmt|;
block|}
if|if
condition|(
name|fc
operator|->
name|fde_encoding
condition|)
name|encoded_ptr_size
operator|=
name|size_of_encoded_value
argument_list|(
name|fc
operator|->
name|fde_encoding
argument_list|)
expr_stmt|;
name|fc
operator|->
name|pc_begin
operator|=
name|get_encoded_value
argument_list|(
name|start
argument_list|,
name|fc
operator|->
name|fde_encoding
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fc
operator|->
name|fde_encoding
operator|&
literal|0x70
operator|)
operator|==
name|DW_EH_PE_pcrel
condition|)
name|fc
operator|->
name|pc_begin
operator|+=
name|section
operator|->
name|sh_addr
operator|+
operator|(
name|start
operator|-
name|section_start
operator|)
expr_stmt|;
name|start
operator|+=
name|encoded_ptr_size
expr_stmt|;
name|fc
operator|->
name|pc_range
operator|=
name|byte_get
argument_list|(
name|start
argument_list|,
name|encoded_ptr_size
argument_list|)
expr_stmt|;
name|start
operator|+=
name|encoded_ptr_size
expr_stmt|;
if|if
condition|(
name|cie
operator|->
name|augmentation
index|[
literal|0
index|]
operator|==
literal|'z'
condition|)
block|{
name|augmentation_data_len
operator|=
name|LEB
argument_list|()
expr_stmt|;
name|augmentation_data
operator|=
name|start
expr_stmt|;
name|start
operator|+=
name|augmentation_data_len
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n%08lx %08lx %08lx FDE cie=%08lx pc=%08lx..%08lx\n"
argument_list|,
call|(
name|unsigned
name|long
call|)
argument_list|(
name|saved_start
operator|-
name|section_start
argument_list|)
argument_list|,
name|length
argument_list|,
name|cie_id
argument_list|,
call|(
name|unsigned
name|long
call|)
argument_list|(
name|cie
operator|->
name|chunk_start
operator|-
name|section_start
argument_list|)
argument_list|,
name|fc
operator|->
name|pc_begin
argument_list|,
name|fc
operator|->
name|pc_begin
operator|+
name|fc
operator|->
name|pc_range
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|do_debug_frames_interp
operator|&&
name|augmentation_data_len
condition|)
block|{
name|unsigned
name|long
name|i
decl_stmt|;
name|printf
argument_list|(
literal|"  Augmentation data:    "
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|augmentation_data_len
condition|;
operator|++
name|i
control|)
name|printf
argument_list|(
literal|" %02x"
argument_list|,
name|augmentation_data
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* At this point, fc is the current chunk, cie (if any) is set, and we're 	 about to interpret instructions for the chunk.  */
comment|/* ??? At present we need to do this always, since this sizes the 	 fc->col_type and fc->col_offset arrays, which we write into always. 	 We should probably split the interpreted and non-interpreted bits 	 into two different routines, since there's so much that doesn't 	 really overlap between them.  */
if|if
condition|(
literal|1
operator|||
name|do_debug_frames_interp
condition|)
block|{
comment|/* Start by making a pass over the chunk, allocating storage 	     and taking note of what registers are used.  */
name|unsigned
name|char
modifier|*
name|tmp
init|=
name|start
decl_stmt|;
while|while
condition|(
name|start
operator|<
name|block_end
condition|)
block|{
name|unsigned
name|op
decl_stmt|,
name|opa
decl_stmt|;
name|unsigned
name|long
name|reg
decl_stmt|,
name|tmp
decl_stmt|;
name|op
operator|=
operator|*
name|start
operator|++
expr_stmt|;
name|opa
operator|=
name|op
operator|&
literal|0x3f
expr_stmt|;
if|if
condition|(
name|op
operator|&
literal|0xc0
condition|)
name|op
operator|&=
literal|0xc0
expr_stmt|;
comment|/* Warning: if you add any more cases to this switch, be 	         sure to add them to the corresponding switch below.  */
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|DW_CFA_advance_loc
case|:
break|break;
case|case
name|DW_CFA_offset
case|:
name|LEB
argument_list|()
expr_stmt|;
name|frame_need_space
argument_list|(
name|fc
argument_list|,
name|opa
argument_list|)
expr_stmt|;
name|fc
operator|->
name|col_type
index|[
name|opa
index|]
operator|=
name|DW_CFA_undefined
expr_stmt|;
break|break;
case|case
name|DW_CFA_restore
case|:
name|frame_need_space
argument_list|(
name|fc
argument_list|,
name|opa
argument_list|)
expr_stmt|;
name|fc
operator|->
name|col_type
index|[
name|opa
index|]
operator|=
name|DW_CFA_undefined
expr_stmt|;
break|break;
case|case
name|DW_CFA_set_loc
case|:
name|start
operator|+=
name|encoded_ptr_size
expr_stmt|;
break|break;
case|case
name|DW_CFA_advance_loc1
case|:
name|start
operator|+=
literal|1
expr_stmt|;
break|break;
case|case
name|DW_CFA_advance_loc2
case|:
name|start
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
name|DW_CFA_advance_loc4
case|:
name|start
operator|+=
literal|4
expr_stmt|;
break|break;
case|case
name|DW_CFA_offset_extended
case|:
name|reg
operator|=
name|LEB
argument_list|()
expr_stmt|;
name|LEB
argument_list|()
expr_stmt|;
name|frame_need_space
argument_list|(
name|fc
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|fc
operator|->
name|col_type
index|[
name|reg
index|]
operator|=
name|DW_CFA_undefined
expr_stmt|;
break|break;
case|case
name|DW_CFA_restore_extended
case|:
name|reg
operator|=
name|LEB
argument_list|()
expr_stmt|;
name|frame_need_space
argument_list|(
name|fc
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|fc
operator|->
name|col_type
index|[
name|reg
index|]
operator|=
name|DW_CFA_undefined
expr_stmt|;
break|break;
case|case
name|DW_CFA_undefined
case|:
name|reg
operator|=
name|LEB
argument_list|()
expr_stmt|;
name|frame_need_space
argument_list|(
name|fc
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|fc
operator|->
name|col_type
index|[
name|reg
index|]
operator|=
name|DW_CFA_undefined
expr_stmt|;
break|break;
case|case
name|DW_CFA_same_value
case|:
name|reg
operator|=
name|LEB
argument_list|()
expr_stmt|;
name|frame_need_space
argument_list|(
name|fc
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|fc
operator|->
name|col_type
index|[
name|reg
index|]
operator|=
name|DW_CFA_undefined
expr_stmt|;
break|break;
case|case
name|DW_CFA_register
case|:
name|reg
operator|=
name|LEB
argument_list|()
expr_stmt|;
name|LEB
argument_list|()
expr_stmt|;
name|frame_need_space
argument_list|(
name|fc
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|fc
operator|->
name|col_type
index|[
name|reg
index|]
operator|=
name|DW_CFA_undefined
expr_stmt|;
break|break;
case|case
name|DW_CFA_def_cfa
case|:
name|LEB
argument_list|()
expr_stmt|;
name|LEB
argument_list|()
expr_stmt|;
break|break;
case|case
name|DW_CFA_def_cfa_register
case|:
name|LEB
argument_list|()
expr_stmt|;
break|break;
case|case
name|DW_CFA_def_cfa_offset
case|:
name|LEB
argument_list|()
expr_stmt|;
break|break;
case|case
name|DW_CFA_def_cfa_expression
case|:
name|tmp
operator|=
name|LEB
argument_list|()
expr_stmt|;
name|start
operator|+=
name|tmp
expr_stmt|;
break|break;
case|case
name|DW_CFA_expression
case|:
name|reg
operator|=
name|LEB
argument_list|()
expr_stmt|;
name|tmp
operator|=
name|LEB
argument_list|()
expr_stmt|;
name|start
operator|+=
name|tmp
expr_stmt|;
name|frame_need_space
argument_list|(
name|fc
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|fc
operator|->
name|col_type
index|[
name|reg
index|]
operator|=
name|DW_CFA_undefined
expr_stmt|;
break|break;
case|case
name|DW_CFA_offset_extended_sf
case|:
name|reg
operator|=
name|LEB
argument_list|()
expr_stmt|;
name|SLEB
argument_list|()
expr_stmt|;
name|frame_need_space
argument_list|(
name|fc
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|fc
operator|->
name|col_type
index|[
name|reg
index|]
operator|=
name|DW_CFA_undefined
expr_stmt|;
break|break;
case|case
name|DW_CFA_def_cfa_sf
case|:
name|LEB
argument_list|()
expr_stmt|;
name|SLEB
argument_list|()
expr_stmt|;
break|break;
case|case
name|DW_CFA_def_cfa_offset_sf
case|:
name|SLEB
argument_list|()
expr_stmt|;
break|break;
case|case
name|DW_CFA_MIPS_advance_loc8
case|:
name|start
operator|+=
literal|8
expr_stmt|;
break|break;
case|case
name|DW_CFA_GNU_args_size
case|:
name|LEB
argument_list|()
expr_stmt|;
break|break;
case|case
name|DW_CFA_GNU_negative_offset_extended
case|:
name|reg
operator|=
name|LEB
argument_list|()
expr_stmt|;
name|LEB
argument_list|()
expr_stmt|;
name|frame_need_space
argument_list|(
name|fc
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|fc
operator|->
name|col_type
index|[
name|reg
index|]
operator|=
name|DW_CFA_undefined
expr_stmt|;
default|default:
break|break;
block|}
block|}
name|start
operator|=
name|tmp
expr_stmt|;
block|}
comment|/* Now we know what registers are used, make a second pass over          the chunk, this time actually printing out the info.  */
while|while
condition|(
name|start
operator|<
name|block_end
condition|)
block|{
name|unsigned
name|op
decl_stmt|,
name|opa
decl_stmt|;
name|unsigned
name|long
name|ul
decl_stmt|,
name|reg
decl_stmt|,
name|roffs
decl_stmt|;
name|long
name|l
decl_stmt|,
name|ofs
decl_stmt|;
name|bfd_vma
name|vma
decl_stmt|;
name|op
operator|=
operator|*
name|start
operator|++
expr_stmt|;
name|opa
operator|=
name|op
operator|&
literal|0x3f
expr_stmt|;
if|if
condition|(
name|op
operator|&
literal|0xc0
condition|)
name|op
operator|&=
literal|0xc0
expr_stmt|;
comment|/* Warning: if you add any more cases to this switch, be 	     sure to add them to the corresponding switch above.  */
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|DW_CFA_advance_loc
case|:
if|if
condition|(
name|do_debug_frames_interp
condition|)
name|frame_display_row
argument_list|(
name|fc
argument_list|,
operator|&
name|need_col_headers
argument_list|,
operator|&
name|max_regs
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"  DW_CFA_advance_loc: %d to %08lx\n"
argument_list|,
name|opa
operator|*
name|fc
operator|->
name|code_factor
argument_list|,
name|fc
operator|->
name|pc_begin
operator|+
name|opa
operator|*
name|fc
operator|->
name|code_factor
argument_list|)
expr_stmt|;
name|fc
operator|->
name|pc_begin
operator|+=
name|opa
operator|*
name|fc
operator|->
name|code_factor
expr_stmt|;
break|break;
case|case
name|DW_CFA_offset
case|:
name|roffs
operator|=
name|LEB
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|do_debug_frames_interp
condition|)
name|printf
argument_list|(
literal|"  DW_CFA_offset: r%d at cfa%+ld\n"
argument_list|,
name|opa
argument_list|,
name|roffs
operator|*
name|fc
operator|->
name|data_factor
argument_list|)
expr_stmt|;
name|fc
operator|->
name|col_type
index|[
name|opa
index|]
operator|=
name|DW_CFA_offset
expr_stmt|;
name|fc
operator|->
name|col_offset
index|[
name|opa
index|]
operator|=
name|roffs
operator|*
name|fc
operator|->
name|data_factor
expr_stmt|;
break|break;
case|case
name|DW_CFA_restore
case|:
if|if
condition|(
operator|!
name|do_debug_frames_interp
condition|)
name|printf
argument_list|(
literal|"  DW_CFA_restore: r%d\n"
argument_list|,
name|opa
argument_list|)
expr_stmt|;
name|fc
operator|->
name|col_type
index|[
name|opa
index|]
operator|=
name|cie
operator|->
name|col_type
index|[
name|opa
index|]
expr_stmt|;
name|fc
operator|->
name|col_offset
index|[
name|opa
index|]
operator|=
name|cie
operator|->
name|col_offset
index|[
name|opa
index|]
expr_stmt|;
break|break;
case|case
name|DW_CFA_set_loc
case|:
name|vma
operator|=
name|get_encoded_value
argument_list|(
name|start
argument_list|,
name|fc
operator|->
name|fde_encoding
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fc
operator|->
name|fde_encoding
operator|&
literal|0x70
operator|)
operator|==
name|DW_EH_PE_pcrel
condition|)
name|vma
operator|+=
name|section
operator|->
name|sh_addr
operator|+
operator|(
name|start
operator|-
name|section_start
operator|)
expr_stmt|;
name|start
operator|+=
name|encoded_ptr_size
expr_stmt|;
if|if
condition|(
name|do_debug_frames_interp
condition|)
name|frame_display_row
argument_list|(
name|fc
argument_list|,
operator|&
name|need_col_headers
argument_list|,
operator|&
name|max_regs
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"  DW_CFA_set_loc: %08lx\n"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|vma
argument_list|)
expr_stmt|;
name|fc
operator|->
name|pc_begin
operator|=
name|vma
expr_stmt|;
break|break;
case|case
name|DW_CFA_advance_loc1
case|:
name|ofs
operator|=
name|byte_get
argument_list|(
name|start
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|start
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
name|do_debug_frames_interp
condition|)
name|frame_display_row
argument_list|(
name|fc
argument_list|,
operator|&
name|need_col_headers
argument_list|,
operator|&
name|max_regs
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"  DW_CFA_advance_loc1: %ld to %08lx\n"
argument_list|,
name|ofs
operator|*
name|fc
operator|->
name|code_factor
argument_list|,
name|fc
operator|->
name|pc_begin
operator|+
name|ofs
operator|*
name|fc
operator|->
name|code_factor
argument_list|)
expr_stmt|;
name|fc
operator|->
name|pc_begin
operator|+=
name|ofs
operator|*
name|fc
operator|->
name|code_factor
expr_stmt|;
break|break;
case|case
name|DW_CFA_advance_loc2
case|:
name|ofs
operator|=
name|byte_get
argument_list|(
name|start
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|start
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|do_debug_frames_interp
condition|)
name|frame_display_row
argument_list|(
name|fc
argument_list|,
operator|&
name|need_col_headers
argument_list|,
operator|&
name|max_regs
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"  DW_CFA_advance_loc2: %ld to %08lx\n"
argument_list|,
name|ofs
operator|*
name|fc
operator|->
name|code_factor
argument_list|,
name|fc
operator|->
name|pc_begin
operator|+
name|ofs
operator|*
name|fc
operator|->
name|code_factor
argument_list|)
expr_stmt|;
name|fc
operator|->
name|pc_begin
operator|+=
name|ofs
operator|*
name|fc
operator|->
name|code_factor
expr_stmt|;
break|break;
case|case
name|DW_CFA_advance_loc4
case|:
name|ofs
operator|=
name|byte_get
argument_list|(
name|start
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|start
operator|+=
literal|4
expr_stmt|;
if|if
condition|(
name|do_debug_frames_interp
condition|)
name|frame_display_row
argument_list|(
name|fc
argument_list|,
operator|&
name|need_col_headers
argument_list|,
operator|&
name|max_regs
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"  DW_CFA_advance_loc4: %ld to %08lx\n"
argument_list|,
name|ofs
operator|*
name|fc
operator|->
name|code_factor
argument_list|,
name|fc
operator|->
name|pc_begin
operator|+
name|ofs
operator|*
name|fc
operator|->
name|code_factor
argument_list|)
expr_stmt|;
name|fc
operator|->
name|pc_begin
operator|+=
name|ofs
operator|*
name|fc
operator|->
name|code_factor
expr_stmt|;
break|break;
case|case
name|DW_CFA_offset_extended
case|:
name|reg
operator|=
name|LEB
argument_list|()
expr_stmt|;
name|roffs
operator|=
name|LEB
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|do_debug_frames_interp
condition|)
name|printf
argument_list|(
literal|"  DW_CFA_offset_extended: r%ld at cfa%+ld\n"
argument_list|,
name|reg
argument_list|,
name|roffs
operator|*
name|fc
operator|->
name|data_factor
argument_list|)
expr_stmt|;
name|fc
operator|->
name|col_type
index|[
name|reg
index|]
operator|=
name|DW_CFA_offset
expr_stmt|;
name|fc
operator|->
name|col_offset
index|[
name|reg
index|]
operator|=
name|roffs
operator|*
name|fc
operator|->
name|data_factor
expr_stmt|;
break|break;
case|case
name|DW_CFA_restore_extended
case|:
name|reg
operator|=
name|LEB
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|do_debug_frames_interp
condition|)
name|printf
argument_list|(
literal|"  DW_CFA_restore_extended: r%ld\n"
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|fc
operator|->
name|col_type
index|[
name|reg
index|]
operator|=
name|cie
operator|->
name|col_type
index|[
name|reg
index|]
expr_stmt|;
name|fc
operator|->
name|col_offset
index|[
name|reg
index|]
operator|=
name|cie
operator|->
name|col_offset
index|[
name|reg
index|]
expr_stmt|;
break|break;
case|case
name|DW_CFA_undefined
case|:
name|reg
operator|=
name|LEB
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|do_debug_frames_interp
condition|)
name|printf
argument_list|(
literal|"  DW_CFA_undefined: r%ld\n"
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|fc
operator|->
name|col_type
index|[
name|reg
index|]
operator|=
name|DW_CFA_undefined
expr_stmt|;
name|fc
operator|->
name|col_offset
index|[
name|reg
index|]
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|DW_CFA_same_value
case|:
name|reg
operator|=
name|LEB
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|do_debug_frames_interp
condition|)
name|printf
argument_list|(
literal|"  DW_CFA_same_value: r%ld\n"
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|fc
operator|->
name|col_type
index|[
name|reg
index|]
operator|=
name|DW_CFA_same_value
expr_stmt|;
name|fc
operator|->
name|col_offset
index|[
name|reg
index|]
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|DW_CFA_register
case|:
name|reg
operator|=
name|LEB
argument_list|()
expr_stmt|;
name|roffs
operator|=
name|LEB
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|do_debug_frames_interp
condition|)
name|printf
argument_list|(
literal|"  DW_CFA_register: r%ld in r%ld\n"
argument_list|,
name|reg
argument_list|,
name|roffs
argument_list|)
expr_stmt|;
name|fc
operator|->
name|col_type
index|[
name|reg
index|]
operator|=
name|DW_CFA_register
expr_stmt|;
name|fc
operator|->
name|col_offset
index|[
name|reg
index|]
operator|=
name|roffs
expr_stmt|;
break|break;
case|case
name|DW_CFA_remember_state
case|:
if|if
condition|(
operator|!
name|do_debug_frames_interp
condition|)
name|printf
argument_list|(
literal|"  DW_CFA_remember_state\n"
argument_list|)
expr_stmt|;
name|rs
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|Frame_Chunk
argument_list|)
argument_list|)
expr_stmt|;
name|rs
operator|->
name|ncols
operator|=
name|fc
operator|->
name|ncols
expr_stmt|;
name|rs
operator|->
name|col_type
operator|=
name|xmalloc
argument_list|(
name|rs
operator|->
name|ncols
operator|*
expr|sizeof
operator|(
name|short
name|int
operator|)
argument_list|)
expr_stmt|;
name|rs
operator|->
name|col_offset
operator|=
name|xmalloc
argument_list|(
name|rs
operator|->
name|ncols
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|rs
operator|->
name|col_type
argument_list|,
name|fc
operator|->
name|col_type
argument_list|,
name|rs
operator|->
name|ncols
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|rs
operator|->
name|col_offset
argument_list|,
name|fc
operator|->
name|col_offset
argument_list|,
name|rs
operator|->
name|ncols
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|rs
operator|->
name|next
operator|=
name|remembered_state
expr_stmt|;
name|remembered_state
operator|=
name|rs
expr_stmt|;
break|break;
case|case
name|DW_CFA_restore_state
case|:
if|if
condition|(
operator|!
name|do_debug_frames_interp
condition|)
name|printf
argument_list|(
literal|"  DW_CFA_restore_state\n"
argument_list|)
expr_stmt|;
name|rs
operator|=
name|remembered_state
expr_stmt|;
if|if
condition|(
name|rs
condition|)
block|{
name|remembered_state
operator|=
name|rs
operator|->
name|next
expr_stmt|;
name|frame_need_space
argument_list|(
name|fc
argument_list|,
name|rs
operator|->
name|ncols
operator|-
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|fc
operator|->
name|col_type
argument_list|,
name|rs
operator|->
name|col_type
argument_list|,
name|rs
operator|->
name|ncols
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|fc
operator|->
name|col_offset
argument_list|,
name|rs
operator|->
name|col_offset
argument_list|,
name|rs
operator|->
name|ncols
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|rs
operator|->
name|col_type
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|rs
operator|->
name|col_offset
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|rs
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|do_debug_frames_interp
condition|)
name|printf
argument_list|(
literal|"Mismatched DW_CFA_restore_state\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_CFA_def_cfa
case|:
name|fc
operator|->
name|cfa_reg
operator|=
name|LEB
argument_list|()
expr_stmt|;
name|fc
operator|->
name|cfa_offset
operator|=
name|LEB
argument_list|()
expr_stmt|;
name|fc
operator|->
name|cfa_exp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|do_debug_frames_interp
condition|)
name|printf
argument_list|(
literal|"  DW_CFA_def_cfa: r%d ofs %d\n"
argument_list|,
name|fc
operator|->
name|cfa_reg
argument_list|,
name|fc
operator|->
name|cfa_offset
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_CFA_def_cfa_register
case|:
name|fc
operator|->
name|cfa_reg
operator|=
name|LEB
argument_list|()
expr_stmt|;
name|fc
operator|->
name|cfa_exp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|do_debug_frames_interp
condition|)
name|printf
argument_list|(
literal|"  DW_CFA_def_cfa_reg: r%d\n"
argument_list|,
name|fc
operator|->
name|cfa_reg
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_CFA_def_cfa_offset
case|:
name|fc
operator|->
name|cfa_offset
operator|=
name|LEB
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|do_debug_frames_interp
condition|)
name|printf
argument_list|(
literal|"  DW_CFA_def_cfa_offset: %d\n"
argument_list|,
name|fc
operator|->
name|cfa_offset
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_CFA_nop
case|:
if|if
condition|(
operator|!
name|do_debug_frames_interp
condition|)
name|printf
argument_list|(
literal|"  DW_CFA_nop\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_CFA_def_cfa_expression
case|:
name|ul
operator|=
name|LEB
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|do_debug_frames_interp
condition|)
block|{
name|printf
argument_list|(
literal|"  DW_CFA_def_cfa_expression ("
argument_list|)
expr_stmt|;
name|decode_location_expression
argument_list|(
name|start
argument_list|,
name|addr_size
argument_list|,
name|ul
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|")\n"
argument_list|)
expr_stmt|;
block|}
name|fc
operator|->
name|cfa_exp
operator|=
literal|1
expr_stmt|;
name|start
operator|+=
name|ul
expr_stmt|;
break|break;
case|case
name|DW_CFA_expression
case|:
name|reg
operator|=
name|LEB
argument_list|()
expr_stmt|;
name|ul
operator|=
name|LEB
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|do_debug_frames_interp
condition|)
block|{
name|printf
argument_list|(
literal|"  DW_CFA_expression: r%ld ("
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|decode_location_expression
argument_list|(
name|start
argument_list|,
name|addr_size
argument_list|,
name|ul
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|")\n"
argument_list|)
expr_stmt|;
block|}
name|fc
operator|->
name|col_type
index|[
name|reg
index|]
operator|=
name|DW_CFA_expression
expr_stmt|;
name|start
operator|+=
name|ul
expr_stmt|;
break|break;
case|case
name|DW_CFA_offset_extended_sf
case|:
name|reg
operator|=
name|LEB
argument_list|()
expr_stmt|;
name|l
operator|=
name|SLEB
argument_list|()
expr_stmt|;
name|frame_need_space
argument_list|(
name|fc
argument_list|,
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|do_debug_frames_interp
condition|)
name|printf
argument_list|(
literal|"  DW_CFA_offset_extended_sf: r%ld at cfa%+ld\n"
argument_list|,
name|reg
argument_list|,
name|l
operator|*
name|fc
operator|->
name|data_factor
argument_list|)
expr_stmt|;
name|fc
operator|->
name|col_type
index|[
name|reg
index|]
operator|=
name|DW_CFA_offset
expr_stmt|;
name|fc
operator|->
name|col_offset
index|[
name|reg
index|]
operator|=
name|l
operator|*
name|fc
operator|->
name|data_factor
expr_stmt|;
break|break;
case|case
name|DW_CFA_def_cfa_sf
case|:
name|fc
operator|->
name|cfa_reg
operator|=
name|LEB
argument_list|()
expr_stmt|;
name|fc
operator|->
name|cfa_offset
operator|=
name|SLEB
argument_list|()
expr_stmt|;
name|fc
operator|->
name|cfa_exp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|do_debug_frames_interp
condition|)
name|printf
argument_list|(
literal|"  DW_CFA_def_cfa_sf: r%d ofs %d\n"
argument_list|,
name|fc
operator|->
name|cfa_reg
argument_list|,
name|fc
operator|->
name|cfa_offset
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_CFA_def_cfa_offset_sf
case|:
name|fc
operator|->
name|cfa_offset
operator|=
name|SLEB
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|do_debug_frames_interp
condition|)
name|printf
argument_list|(
literal|"  DW_CFA_def_cfa_offset_sf: %d\n"
argument_list|,
name|fc
operator|->
name|cfa_offset
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_CFA_MIPS_advance_loc8
case|:
name|ofs
operator|=
name|byte_get
argument_list|(
name|start
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|start
operator|+=
literal|8
expr_stmt|;
if|if
condition|(
name|do_debug_frames_interp
condition|)
name|frame_display_row
argument_list|(
name|fc
argument_list|,
operator|&
name|need_col_headers
argument_list|,
operator|&
name|max_regs
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"  DW_CFA_MIPS_advance_loc8: %ld to %08lx\n"
argument_list|,
name|ofs
operator|*
name|fc
operator|->
name|code_factor
argument_list|,
name|fc
operator|->
name|pc_begin
operator|+
name|ofs
operator|*
name|fc
operator|->
name|code_factor
argument_list|)
expr_stmt|;
name|fc
operator|->
name|pc_begin
operator|+=
name|ofs
operator|*
name|fc
operator|->
name|code_factor
expr_stmt|;
break|break;
case|case
name|DW_CFA_GNU_window_save
case|:
if|if
condition|(
operator|!
name|do_debug_frames_interp
condition|)
name|printf
argument_list|(
literal|"  DW_CFA_GNU_window_save\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_CFA_GNU_args_size
case|:
name|ul
operator|=
name|LEB
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|do_debug_frames_interp
condition|)
name|printf
argument_list|(
literal|"  DW_CFA_GNU_args_size: %ld\n"
argument_list|,
name|ul
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_CFA_GNU_negative_offset_extended
case|:
name|reg
operator|=
name|LEB
argument_list|()
expr_stmt|;
name|l
operator|=
operator|-
name|LEB
argument_list|()
expr_stmt|;
name|frame_need_space
argument_list|(
name|fc
argument_list|,
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|do_debug_frames_interp
condition|)
name|printf
argument_list|(
literal|"  DW_CFA_GNU_negative_offset_extended: r%ld at cfa%+ld\n"
argument_list|,
name|reg
argument_list|,
name|l
operator|*
name|fc
operator|->
name|data_factor
argument_list|)
expr_stmt|;
name|fc
operator|->
name|col_type
index|[
name|reg
index|]
operator|=
name|DW_CFA_offset
expr_stmt|;
name|fc
operator|->
name|col_offset
index|[
name|reg
index|]
operator|=
name|l
operator|*
name|fc
operator|->
name|data_factor
expr_stmt|;
break|break;
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"unsupported or unknown DW_CFA_%d\n"
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|start
operator|=
name|block_end
expr_stmt|;
block|}
block|}
if|if
condition|(
name|do_debug_frames_interp
condition|)
name|frame_display_row
argument_list|(
name|fc
argument_list|,
operator|&
name|need_col_headers
argument_list|,
operator|&
name|max_regs
argument_list|)
expr_stmt|;
name|start
operator|=
name|block_end
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_undef
undef|#
directive|undef
name|GET
end_undef

begin_undef
undef|#
directive|undef
name|LEB
end_undef

begin_undef
undef|#
directive|undef
name|SLEB
end_undef

begin_function
specifier|static
name|int
name|display_debug_not_supported
parameter_list|(
name|Elf_Internal_Shdr
modifier|*
name|section
parameter_list|,
name|unsigned
name|char
modifier|*
name|start
name|ATTRIBUTE_UNUSED
parameter_list|,
name|FILE
modifier|*
name|file
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|printf
argument_list|(
name|_
argument_list|(
literal|"Displaying the debug contents of section %s is not yet supported.\n"
argument_list|)
argument_list|,
name|SECTION_NAME
argument_list|(
name|section
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* A structure containing the name of a debug section    and a pointer to a function that can decode it.  */
end_comment

begin_struct
struct|struct
block|{
specifier|const
name|char
modifier|*
specifier|const
name|name
decl_stmt|;
name|int
function_decl|(
modifier|*
name|display
function_decl|)
parameter_list|(
name|Elf_Internal_Shdr
modifier|*
parameter_list|,
name|unsigned
name|char
modifier|*
parameter_list|,
name|FILE
modifier|*
parameter_list|)
function_decl|;
block|}
name|debug_displays
index|[]
init|=
block|{
block|{
literal|".debug_abbrev"
block|,
name|display_debug_abbrev
block|}
block|,
block|{
literal|".debug_aranges"
block|,
name|display_debug_aranges
block|}
block|,
block|{
literal|".debug_frame"
block|,
name|display_debug_frames
block|}
block|,
block|{
literal|".debug_info"
block|,
name|display_debug_info
block|}
block|,
block|{
literal|".debug_line"
block|,
name|display_debug_lines
block|}
block|,
block|{
literal|".debug_pubnames"
block|,
name|display_debug_pubnames
block|}
block|,
block|{
literal|".eh_frame"
block|,
name|display_debug_frames
block|}
block|,
block|{
literal|".debug_macinfo"
block|,
name|display_debug_macinfo
block|}
block|,
block|{
literal|".debug_str"
block|,
name|display_debug_str
block|}
block|,
block|{
literal|".debug_loc"
block|,
name|display_debug_loc
block|}
block|,
block|{
literal|".debug_pubtypes"
block|,
name|display_debug_pubnames
block|}
block|,
block|{
literal|".debug_ranges"
block|,
name|display_debug_not_supported
block|}
block|,
block|{
literal|".debug_static_func"
block|,
name|display_debug_not_supported
block|}
block|,
block|{
literal|".debug_static_vars"
block|,
name|display_debug_not_supported
block|}
block|,
block|{
literal|".debug_types"
block|,
name|display_debug_not_supported
block|}
block|,
block|{
literal|".debug_weaknames"
block|,
name|display_debug_not_supported
block|}
block|}
struct|;
end_struct

begin_function
specifier|static
name|int
name|display_debug_section
parameter_list|(
name|Elf_Internal_Shdr
modifier|*
name|section
parameter_list|,
name|FILE
modifier|*
name|file
parameter_list|)
block|{
name|char
modifier|*
name|name
init|=
name|SECTION_NAME
argument_list|(
name|section
argument_list|)
decl_stmt|;
name|bfd_size_type
name|length
decl_stmt|;
name|unsigned
name|char
modifier|*
name|start
decl_stmt|;
name|int
name|i
decl_stmt|;
name|length
operator|=
name|section
operator|->
name|sh_size
expr_stmt|;
if|if
condition|(
name|length
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
name|_
argument_list|(
literal|"\nSection '%s' has no debugging data.\n"
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|start
operator|=
name|get_data
argument_list|(
name|NULL
argument_list|,
name|file
argument_list|,
name|section
operator|->
name|sh_offset
argument_list|,
name|length
argument_list|,
name|_
argument_list|(
literal|"debug section data"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|start
condition|)
return|return
literal|0
return|;
comment|/* See if we know how to display the contents of this section.  */
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
literal|".gnu.linkonce.wi."
argument_list|,
literal|17
argument_list|)
operator|==
literal|0
condition|)
name|name
operator|=
literal|".debug_info"
expr_stmt|;
for|for
control|(
name|i
operator|=
name|NUM_ELEM
argument_list|(
name|debug_displays
argument_list|)
init|;
name|i
operator|--
condition|;
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|debug_displays
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
name|debug_displays
index|[
name|i
index|]
operator|.
name|display
argument_list|(
name|section
argument_list|,
name|start
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|i
operator|==
operator|-
literal|1
condition|)
name|printf
argument_list|(
name|_
argument_list|(
literal|"Unrecognized debug section: %s\n"
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|start
argument_list|)
expr_stmt|;
comment|/* If we loaded in the abbrev section at some point,      we must release it here.  */
name|free_abbrevs
argument_list|()
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|process_section_contents
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|)
block|{
name|Elf_Internal_Shdr
modifier|*
name|section
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|do_dump
condition|)
return|return
literal|1
return|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|section
operator|=
name|section_headers
init|;
name|i
operator|<
name|elf_header
operator|.
name|e_shnum
operator|&&
name|i
operator|<
name|num_dump_sects
condition|;
name|i
operator|++
operator|,
name|section
operator|++
control|)
block|{
ifdef|#
directive|ifdef
name|SUPPORT_DISASSEMBLY
if|if
condition|(
name|dump_sects
index|[
name|i
index|]
operator|&
name|DISASS_DUMP
condition|)
name|disassemble_section
argument_list|(
name|section
argument_list|,
name|file
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|dump_sects
index|[
name|i
index|]
operator|&
name|HEX_DUMP
condition|)
name|dump_section
argument_list|(
name|section
argument_list|,
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|dump_sects
index|[
name|i
index|]
operator|&
name|DEBUG_DUMP
condition|)
name|display_debug_section
argument_list|(
name|section
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|<
name|num_dump_sects
condition|)
name|warn
argument_list|(
name|_
argument_list|(
literal|"Some sections were not dumped because they do not exist!\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|process_mips_fpe_exception
parameter_list|(
name|int
name|mask
parameter_list|)
block|{
if|if
condition|(
name|mask
condition|)
block|{
name|int
name|first
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|mask
operator|&
name|OEX_FPU_INEX
condition|)
name|fputs
argument_list|(
literal|"INEX"
argument_list|,
name|stdout
argument_list|)
operator|,
name|first
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|mask
operator|&
name|OEX_FPU_UFLO
condition|)
name|printf
argument_list|(
literal|"%sUFLO"
argument_list|,
name|first
condition|?
literal|""
else|:
literal|"|"
argument_list|)
operator|,
name|first
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|mask
operator|&
name|OEX_FPU_OFLO
condition|)
name|printf
argument_list|(
literal|"%sOFLO"
argument_list|,
name|first
condition|?
literal|""
else|:
literal|"|"
argument_list|)
operator|,
name|first
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|mask
operator|&
name|OEX_FPU_DIV0
condition|)
name|printf
argument_list|(
literal|"%sDIV0"
argument_list|,
name|first
condition|?
literal|""
else|:
literal|"|"
argument_list|)
operator|,
name|first
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|mask
operator|&
name|OEX_FPU_INVAL
condition|)
name|printf
argument_list|(
literal|"%sINVAL"
argument_list|,
name|first
condition|?
literal|""
else|:
literal|"|"
argument_list|)
expr_stmt|;
block|}
else|else
name|fputs
argument_list|(
literal|"0"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|process_mips_specific
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|)
block|{
name|Elf_Internal_Dyn
modifier|*
name|entry
decl_stmt|;
name|size_t
name|liblist_offset
init|=
literal|0
decl_stmt|;
name|size_t
name|liblistno
init|=
literal|0
decl_stmt|;
name|size_t
name|conflictsno
init|=
literal|0
decl_stmt|;
name|size_t
name|options_offset
init|=
literal|0
decl_stmt|;
name|size_t
name|conflicts_offset
init|=
literal|0
decl_stmt|;
comment|/* We have a lot of special sections.  Thanks SGI!  */
if|if
condition|(
name|dynamic_segment
operator|==
name|NULL
condition|)
comment|/* No information available.  */
return|return
literal|0
return|;
for|for
control|(
name|entry
operator|=
name|dynamic_segment
init|;
name|entry
operator|->
name|d_tag
operator|!=
name|DT_NULL
condition|;
operator|++
name|entry
control|)
switch|switch
condition|(
name|entry
operator|->
name|d_tag
condition|)
block|{
case|case
name|DT_MIPS_LIBLIST
case|:
name|liblist_offset
operator|=
name|offset_from_vma
argument_list|(
name|file
argument_list|,
name|entry
operator|->
name|d_un
operator|.
name|d_val
argument_list|,
name|liblistno
operator|*
sizeof|sizeof
argument_list|(
name|Elf32_External_Lib
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_MIPS_LIBLISTNO
case|:
name|liblistno
operator|=
name|entry
operator|->
name|d_un
operator|.
name|d_val
expr_stmt|;
break|break;
case|case
name|DT_MIPS_OPTIONS
case|:
name|options_offset
operator|=
name|offset_from_vma
argument_list|(
name|file
argument_list|,
name|entry
operator|->
name|d_un
operator|.
name|d_val
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_MIPS_CONFLICT
case|:
name|conflicts_offset
operator|=
name|offset_from_vma
argument_list|(
name|file
argument_list|,
name|entry
operator|->
name|d_un
operator|.
name|d_val
argument_list|,
name|conflictsno
operator|*
sizeof|sizeof
argument_list|(
name|Elf32_External_Conflict
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_MIPS_CONFLICTNO
case|:
name|conflictsno
operator|=
name|entry
operator|->
name|d_un
operator|.
name|d_val
expr_stmt|;
break|break;
default|default:
break|break;
block|}
if|if
condition|(
name|liblist_offset
operator|!=
literal|0
operator|&&
name|liblistno
operator|!=
literal|0
operator|&&
name|do_dynamic
condition|)
block|{
name|Elf32_External_Lib
modifier|*
name|elib
decl_stmt|;
name|size_t
name|cnt
decl_stmt|;
name|elib
operator|=
name|get_data
argument_list|(
name|NULL
argument_list|,
name|file
argument_list|,
name|liblist_offset
argument_list|,
name|liblistno
operator|*
sizeof|sizeof
argument_list|(
name|Elf32_External_Lib
argument_list|)
argument_list|,
name|_
argument_list|(
literal|"liblist"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|elib
condition|)
block|{
name|printf
argument_list|(
literal|"\nSection '.liblist' contains %lu entries:\n"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|liblistno
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"     Library              Time Stamp          Checksum   Version Flags\n"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
for|for
control|(
name|cnt
operator|=
literal|0
init|;
name|cnt
operator|<
name|liblistno
condition|;
operator|++
name|cnt
control|)
block|{
name|Elf32_Lib
name|liblist
decl_stmt|;
name|time_t
name|time
decl_stmt|;
name|char
name|timebuf
index|[
literal|20
index|]
decl_stmt|;
name|struct
name|tm
modifier|*
name|tmp
decl_stmt|;
name|liblist
operator|.
name|l_name
operator|=
name|BYTE_GET
argument_list|(
name|elib
index|[
name|cnt
index|]
operator|.
name|l_name
argument_list|)
expr_stmt|;
name|time
operator|=
name|BYTE_GET
argument_list|(
name|elib
index|[
name|cnt
index|]
operator|.
name|l_time_stamp
argument_list|)
expr_stmt|;
name|liblist
operator|.
name|l_checksum
operator|=
name|BYTE_GET
argument_list|(
name|elib
index|[
name|cnt
index|]
operator|.
name|l_checksum
argument_list|)
expr_stmt|;
name|liblist
operator|.
name|l_version
operator|=
name|BYTE_GET
argument_list|(
name|elib
index|[
name|cnt
index|]
operator|.
name|l_version
argument_list|)
expr_stmt|;
name|liblist
operator|.
name|l_flags
operator|=
name|BYTE_GET
argument_list|(
name|elib
index|[
name|cnt
index|]
operator|.
name|l_flags
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|gmtime
argument_list|(
operator|&
name|time
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|timebuf
argument_list|,
literal|"%04u-%02u-%02uT%02u:%02u:%02u"
argument_list|,
name|tmp
operator|->
name|tm_year
operator|+
literal|1900
argument_list|,
name|tmp
operator|->
name|tm_mon
operator|+
literal|1
argument_list|,
name|tmp
operator|->
name|tm_mday
argument_list|,
name|tmp
operator|->
name|tm_hour
argument_list|,
name|tmp
operator|->
name|tm_min
argument_list|,
name|tmp
operator|->
name|tm_sec
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%3lu: "
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|cnt
argument_list|)
expr_stmt|;
name|print_symbol
argument_list|(
literal|20
argument_list|,
name|dynamic_strings
operator|+
name|liblist
operator|.
name|l_name
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %s %#10lx %-7ld"
argument_list|,
name|timebuf
argument_list|,
name|liblist
operator|.
name|l_checksum
argument_list|,
name|liblist
operator|.
name|l_version
argument_list|)
expr_stmt|;
if|if
condition|(
name|liblist
operator|.
name|l_flags
operator|==
literal|0
condition|)
name|puts
argument_list|(
literal|" NONE"
argument_list|)
expr_stmt|;
else|else
block|{
specifier|static
specifier|const
struct|struct
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|bit
decl_stmt|;
block|}
name|l_flags_vals
index|[]
init|=
block|{
block|{
literal|" EXACT_MATCH"
block|,
name|LL_EXACT_MATCH
block|}
block|,
block|{
literal|" IGNORE_INT_VER"
block|,
name|LL_IGNORE_INT_VER
block|}
block|,
block|{
literal|" REQUIRE_MINOR"
block|,
name|LL_REQUIRE_MINOR
block|}
block|,
block|{
literal|" EXPORTS"
block|,
name|LL_EXPORTS
block|}
block|,
block|{
literal|" DELAY_LOAD"
block|,
name|LL_DELAY_LOAD
block|}
block|,
block|{
literal|" DELTA"
block|,
name|LL_DELTA
block|}
block|}
struct|;
name|int
name|flags
init|=
name|liblist
operator|.
name|l_flags
decl_stmt|;
name|size_t
name|fcnt
decl_stmt|;
for|for
control|(
name|fcnt
operator|=
literal|0
init|;
name|fcnt
operator|<
sizeof|sizeof
argument_list|(
name|l_flags_vals
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|l_flags_vals
index|[
literal|0
index|]
argument_list|)
condition|;
operator|++
name|fcnt
control|)
if|if
condition|(
operator|(
name|flags
operator|&
name|l_flags_vals
index|[
name|fcnt
index|]
operator|.
name|bit
operator|)
operator|!=
literal|0
condition|)
block|{
name|fputs
argument_list|(
name|l_flags_vals
index|[
name|fcnt
index|]
operator|.
name|name
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|flags
operator|^=
name|l_flags_vals
index|[
name|fcnt
index|]
operator|.
name|bit
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|" %#x"
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|flags
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|""
argument_list|)
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|elib
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|options_offset
operator|!=
literal|0
condition|)
block|{
name|Elf_External_Options
modifier|*
name|eopt
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|sect
init|=
name|section_headers
decl_stmt|;
name|Elf_Internal_Options
modifier|*
name|iopt
decl_stmt|;
name|Elf_Internal_Options
modifier|*
name|option
decl_stmt|;
name|size_t
name|offset
decl_stmt|;
name|int
name|cnt
decl_stmt|;
comment|/* Find the section header so that we get the size.  */
while|while
condition|(
name|sect
operator|->
name|sh_type
operator|!=
name|SHT_MIPS_OPTIONS
condition|)
operator|++
name|sect
expr_stmt|;
name|eopt
operator|=
name|get_data
argument_list|(
name|NULL
argument_list|,
name|file
argument_list|,
name|options_offset
argument_list|,
name|sect
operator|->
name|sh_size
argument_list|,
name|_
argument_list|(
literal|"options"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|eopt
condition|)
block|{
name|iopt
operator|=
name|malloc
argument_list|(
operator|(
name|sect
operator|->
name|sh_size
operator|/
sizeof|sizeof
argument_list|(
name|eopt
argument_list|)
operator|)
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|iopt
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|iopt
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"Out of memory"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|offset
operator|=
name|cnt
operator|=
literal|0
expr_stmt|;
name|option
operator|=
name|iopt
expr_stmt|;
while|while
condition|(
name|offset
operator|<
name|sect
operator|->
name|sh_size
condition|)
block|{
name|Elf_External_Options
modifier|*
name|eoption
decl_stmt|;
name|eoption
operator|=
operator|(
name|Elf_External_Options
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|eopt
operator|+
name|offset
operator|)
expr_stmt|;
name|option
operator|->
name|kind
operator|=
name|BYTE_GET
argument_list|(
name|eoption
operator|->
name|kind
argument_list|)
expr_stmt|;
name|option
operator|->
name|size
operator|=
name|BYTE_GET
argument_list|(
name|eoption
operator|->
name|size
argument_list|)
expr_stmt|;
name|option
operator|->
name|section
operator|=
name|BYTE_GET
argument_list|(
name|eoption
operator|->
name|section
argument_list|)
expr_stmt|;
name|option
operator|->
name|info
operator|=
name|BYTE_GET
argument_list|(
name|eoption
operator|->
name|info
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|option
operator|->
name|size
expr_stmt|;
operator|++
name|option
expr_stmt|;
operator|++
name|cnt
expr_stmt|;
block|}
name|printf
argument_list|(
name|_
argument_list|(
literal|"\nSection '%s' contains %d entries:\n"
argument_list|)
argument_list|,
name|SECTION_NAME
argument_list|(
name|sect
argument_list|)
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
name|option
operator|=
name|iopt
expr_stmt|;
while|while
condition|(
name|cnt
operator|--
operator|>
literal|0
condition|)
block|{
name|size_t
name|len
decl_stmt|;
switch|switch
condition|(
name|option
operator|->
name|kind
condition|)
block|{
case|case
name|ODK_NULL
case|:
comment|/* This shouldn't happen.  */
name|printf
argument_list|(
literal|" NULL       %d %lx"
argument_list|,
name|option
operator|->
name|section
argument_list|,
name|option
operator|->
name|info
argument_list|)
expr_stmt|;
break|break;
case|case
name|ODK_REGINFO
case|:
name|printf
argument_list|(
literal|" REGINFO    "
argument_list|)
expr_stmt|;
if|if
condition|(
name|elf_header
operator|.
name|e_machine
operator|==
name|EM_MIPS
condition|)
block|{
comment|/* 32bit form.  */
name|Elf32_External_RegInfo
modifier|*
name|ereg
decl_stmt|;
name|Elf32_RegInfo
name|reginfo
decl_stmt|;
name|ereg
operator|=
operator|(
name|Elf32_External_RegInfo
operator|*
operator|)
operator|(
name|option
operator|+
literal|1
operator|)
expr_stmt|;
name|reginfo
operator|.
name|ri_gprmask
operator|=
name|BYTE_GET
argument_list|(
name|ereg
operator|->
name|ri_gprmask
argument_list|)
expr_stmt|;
name|reginfo
operator|.
name|ri_cprmask
index|[
literal|0
index|]
operator|=
name|BYTE_GET
argument_list|(
name|ereg
operator|->
name|ri_cprmask
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|reginfo
operator|.
name|ri_cprmask
index|[
literal|1
index|]
operator|=
name|BYTE_GET
argument_list|(
name|ereg
operator|->
name|ri_cprmask
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|reginfo
operator|.
name|ri_cprmask
index|[
literal|2
index|]
operator|=
name|BYTE_GET
argument_list|(
name|ereg
operator|->
name|ri_cprmask
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|reginfo
operator|.
name|ri_cprmask
index|[
literal|3
index|]
operator|=
name|BYTE_GET
argument_list|(
name|ereg
operator|->
name|ri_cprmask
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|reginfo
operator|.
name|ri_gp_value
operator|=
name|BYTE_GET
argument_list|(
name|ereg
operator|->
name|ri_gp_value
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"GPR %08lx  GP 0x%lx\n"
argument_list|,
name|reginfo
operator|.
name|ri_gprmask
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|reginfo
operator|.
name|ri_gp_value
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"            CPR0 %08lx  CPR1 %08lx  CPR2 %08lx  CPR3 %08lx\n"
argument_list|,
name|reginfo
operator|.
name|ri_cprmask
index|[
literal|0
index|]
argument_list|,
name|reginfo
operator|.
name|ri_cprmask
index|[
literal|1
index|]
argument_list|,
name|reginfo
operator|.
name|ri_cprmask
index|[
literal|2
index|]
argument_list|,
name|reginfo
operator|.
name|ri_cprmask
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 64 bit form.  */
name|Elf64_External_RegInfo
modifier|*
name|ereg
decl_stmt|;
name|Elf64_Internal_RegInfo
name|reginfo
decl_stmt|;
name|ereg
operator|=
operator|(
name|Elf64_External_RegInfo
operator|*
operator|)
operator|(
name|option
operator|+
literal|1
operator|)
expr_stmt|;
name|reginfo
operator|.
name|ri_gprmask
operator|=
name|BYTE_GET
argument_list|(
name|ereg
operator|->
name|ri_gprmask
argument_list|)
expr_stmt|;
name|reginfo
operator|.
name|ri_cprmask
index|[
literal|0
index|]
operator|=
name|BYTE_GET
argument_list|(
name|ereg
operator|->
name|ri_cprmask
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|reginfo
operator|.
name|ri_cprmask
index|[
literal|1
index|]
operator|=
name|BYTE_GET
argument_list|(
name|ereg
operator|->
name|ri_cprmask
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|reginfo
operator|.
name|ri_cprmask
index|[
literal|2
index|]
operator|=
name|BYTE_GET
argument_list|(
name|ereg
operator|->
name|ri_cprmask
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|reginfo
operator|.
name|ri_cprmask
index|[
literal|3
index|]
operator|=
name|BYTE_GET
argument_list|(
name|ereg
operator|->
name|ri_cprmask
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|reginfo
operator|.
name|ri_gp_value
operator|=
name|BYTE_GET8
argument_list|(
name|ereg
operator|->
name|ri_gp_value
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"GPR %08lx  GP 0x"
argument_list|,
name|reginfo
operator|.
name|ri_gprmask
argument_list|)
expr_stmt|;
name|printf_vma
argument_list|(
name|reginfo
operator|.
name|ri_gp_value
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"            CPR0 %08lx  CPR1 %08lx  CPR2 %08lx  CPR3 %08lx\n"
argument_list|,
name|reginfo
operator|.
name|ri_cprmask
index|[
literal|0
index|]
argument_list|,
name|reginfo
operator|.
name|ri_cprmask
index|[
literal|1
index|]
argument_list|,
name|reginfo
operator|.
name|ri_cprmask
index|[
literal|2
index|]
argument_list|,
name|reginfo
operator|.
name|ri_cprmask
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
block|}
operator|++
name|option
expr_stmt|;
continue|continue;
case|case
name|ODK_EXCEPTIONS
case|:
name|fputs
argument_list|(
literal|" EXCEPTIONS fpe_min("
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|process_mips_fpe_exception
argument_list|(
name|option
operator|->
name|info
operator|&
name|OEX_FPU_MIN
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|") fpe_max("
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|process_mips_fpe_exception
argument_list|(
operator|(
name|option
operator|->
name|info
operator|&
name|OEX_FPU_MAX
operator|)
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|")"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|option
operator|->
name|info
operator|&
name|OEX_PAGE0
condition|)
name|fputs
argument_list|(
literal|" PAGE0"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|option
operator|->
name|info
operator|&
name|OEX_SMM
condition|)
name|fputs
argument_list|(
literal|" SMM"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|option
operator|->
name|info
operator|&
name|OEX_FPDBUG
condition|)
name|fputs
argument_list|(
literal|" FPDBUG"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|option
operator|->
name|info
operator|&
name|OEX_DISMISS
condition|)
name|fputs
argument_list|(
literal|" DISMISS"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
break|break;
case|case
name|ODK_PAD
case|:
name|fputs
argument_list|(
literal|" PAD       "
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|option
operator|->
name|info
operator|&
name|OPAD_PREFIX
condition|)
name|fputs
argument_list|(
literal|" PREFIX"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|option
operator|->
name|info
operator|&
name|OPAD_POSTFIX
condition|)
name|fputs
argument_list|(
literal|" POSTFIX"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|option
operator|->
name|info
operator|&
name|OPAD_SYMBOL
condition|)
name|fputs
argument_list|(
literal|" SYMBOL"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
break|break;
case|case
name|ODK_HWPATCH
case|:
name|fputs
argument_list|(
literal|" HWPATCH   "
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|option
operator|->
name|info
operator|&
name|OHW_R4KEOP
condition|)
name|fputs
argument_list|(
literal|" R4KEOP"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|option
operator|->
name|info
operator|&
name|OHW_R8KPFETCH
condition|)
name|fputs
argument_list|(
literal|" R8KPFETCH"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|option
operator|->
name|info
operator|&
name|OHW_R5KEOP
condition|)
name|fputs
argument_list|(
literal|" R5KEOP"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|option
operator|->
name|info
operator|&
name|OHW_R5KCVTL
condition|)
name|fputs
argument_list|(
literal|" R5KCVTL"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
break|break;
case|case
name|ODK_FILL
case|:
name|fputs
argument_list|(
literal|" FILL       "
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
comment|/* XXX Print content of info word?  */
break|break;
case|case
name|ODK_TAGS
case|:
name|fputs
argument_list|(
literal|" TAGS       "
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
comment|/* XXX Print content of info word?  */
break|break;
case|case
name|ODK_HWAND
case|:
name|fputs
argument_list|(
literal|" HWAND     "
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|option
operator|->
name|info
operator|&
name|OHWA0_R4KEOP_CHECKED
condition|)
name|fputs
argument_list|(
literal|" R4KEOP_CHECKED"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|option
operator|->
name|info
operator|&
name|OHWA0_R4KEOP_CLEAN
condition|)
name|fputs
argument_list|(
literal|" R4KEOP_CLEAN"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
break|break;
case|case
name|ODK_HWOR
case|:
name|fputs
argument_list|(
literal|" HWOR      "
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|option
operator|->
name|info
operator|&
name|OHWA0_R4KEOP_CHECKED
condition|)
name|fputs
argument_list|(
literal|" R4KEOP_CHECKED"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|option
operator|->
name|info
operator|&
name|OHWA0_R4KEOP_CLEAN
condition|)
name|fputs
argument_list|(
literal|" R4KEOP_CLEAN"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
break|break;
case|case
name|ODK_GP_GROUP
case|:
name|printf
argument_list|(
literal|" GP_GROUP  %#06lx  self-contained %#06lx"
argument_list|,
name|option
operator|->
name|info
operator|&
name|OGP_GROUP
argument_list|,
operator|(
name|option
operator|->
name|info
operator|&
name|OGP_SELF
operator|)
operator|>>
literal|16
argument_list|)
expr_stmt|;
break|break;
case|case
name|ODK_IDENT
case|:
name|printf
argument_list|(
literal|" IDENT     %#06lx  self-contained %#06lx"
argument_list|,
name|option
operator|->
name|info
operator|&
name|OGP_GROUP
argument_list|,
operator|(
name|option
operator|->
name|info
operator|&
name|OGP_SELF
operator|)
operator|>>
literal|16
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* This shouldn't happen.  */
name|printf
argument_list|(
literal|" %3d ???     %d %lx"
argument_list|,
name|option
operator|->
name|kind
argument_list|,
name|option
operator|->
name|section
argument_list|,
name|option
operator|->
name|info
argument_list|)
expr_stmt|;
break|break;
block|}
name|len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|eopt
argument_list|)
expr_stmt|;
while|while
condition|(
name|len
operator|<
name|option
operator|->
name|size
condition|)
if|if
condition|(
operator|(
operator|(
name|char
operator|*
operator|)
name|option
operator|)
index|[
name|len
index|]
operator|>=
literal|' '
operator|&&
operator|(
operator|(
name|char
operator|*
operator|)
name|option
operator|)
index|[
name|len
index|]
operator|<
literal|0x7f
condition|)
name|printf
argument_list|(
literal|"%c"
argument_list|,
operator|(
operator|(
name|char
operator|*
operator|)
name|option
operator|)
index|[
name|len
operator|++
index|]
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"\\%03o"
argument_list|,
operator|(
operator|(
name|char
operator|*
operator|)
name|option
operator|)
index|[
name|len
operator|++
index|]
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"\n"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
operator|++
name|option
expr_stmt|;
block|}
name|free
argument_list|(
name|eopt
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|conflicts_offset
operator|!=
literal|0
operator|&&
name|conflictsno
operator|!=
literal|0
condition|)
block|{
name|Elf32_Conflict
modifier|*
name|iconf
decl_stmt|;
name|size_t
name|cnt
decl_stmt|;
if|if
condition|(
name|dynamic_symbols
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"conflict list found without a dynamic symbol table"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|iconf
operator|=
name|malloc
argument_list|(
name|conflictsno
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|iconf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|iconf
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"Out of memory"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|is_32bit_elf
condition|)
block|{
name|Elf32_External_Conflict
modifier|*
name|econf32
decl_stmt|;
name|econf32
operator|=
name|get_data
argument_list|(
name|NULL
argument_list|,
name|file
argument_list|,
name|conflicts_offset
argument_list|,
name|conflictsno
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|econf32
argument_list|)
argument_list|,
name|_
argument_list|(
literal|"conflict"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|econf32
condition|)
return|return
literal|0
return|;
for|for
control|(
name|cnt
operator|=
literal|0
init|;
name|cnt
operator|<
name|conflictsno
condition|;
operator|++
name|cnt
control|)
name|iconf
index|[
name|cnt
index|]
operator|=
name|BYTE_GET
argument_list|(
name|econf32
index|[
name|cnt
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|econf32
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Elf64_External_Conflict
modifier|*
name|econf64
decl_stmt|;
name|econf64
operator|=
name|get_data
argument_list|(
name|NULL
argument_list|,
name|file
argument_list|,
name|conflicts_offset
argument_list|,
name|conflictsno
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|econf64
argument_list|)
argument_list|,
name|_
argument_list|(
literal|"conflict"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|econf64
condition|)
return|return
literal|0
return|;
for|for
control|(
name|cnt
operator|=
literal|0
init|;
name|cnt
operator|<
name|conflictsno
condition|;
operator|++
name|cnt
control|)
name|iconf
index|[
name|cnt
index|]
operator|=
name|BYTE_GET
argument_list|(
name|econf64
index|[
name|cnt
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|econf64
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
name|_
argument_list|(
literal|"\nSection '.conflict' contains %lu entries:\n"
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|conflictsno
argument_list|)
expr_stmt|;
name|puts
argument_list|(
name|_
argument_list|(
literal|"  Num:    Index       Value  Name"
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|cnt
operator|=
literal|0
init|;
name|cnt
operator|<
name|conflictsno
condition|;
operator|++
name|cnt
control|)
block|{
name|Elf_Internal_Sym
modifier|*
name|psym
init|=
operator|&
name|dynamic_symbols
index|[
name|iconf
index|[
name|cnt
index|]
index|]
decl_stmt|;
name|printf
argument_list|(
literal|"%5lu: %8lu  "
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|cnt
argument_list|,
name|iconf
index|[
name|cnt
index|]
argument_list|)
expr_stmt|;
name|print_vma
argument_list|(
name|psym
operator|->
name|st_value
argument_list|,
name|FULL_HEX
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|print_symbol
argument_list|(
literal|25
argument_list|,
name|dynamic_strings
operator|+
name|psym
operator|->
name|st_name
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|iconf
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|process_gnu_liblist
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|)
block|{
name|Elf_Internal_Shdr
modifier|*
name|section
decl_stmt|,
modifier|*
name|string_sec
decl_stmt|;
name|Elf32_External_Lib
modifier|*
name|elib
decl_stmt|;
name|char
modifier|*
name|strtab
decl_stmt|;
name|size_t
name|cnt
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|do_arch
condition|)
return|return
literal|0
return|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|section
operator|=
name|section_headers
init|;
name|i
operator|<
name|elf_header
operator|.
name|e_shnum
condition|;
name|i
operator|++
operator|,
name|section
operator|++
control|)
block|{
switch|switch
condition|(
name|section
operator|->
name|sh_type
condition|)
block|{
case|case
name|SHT_GNU_LIBLIST
case|:
name|elib
operator|=
name|get_data
argument_list|(
name|NULL
argument_list|,
name|file
argument_list|,
name|section
operator|->
name|sh_offset
argument_list|,
name|section
operator|->
name|sh_size
argument_list|,
name|_
argument_list|(
literal|"liblist"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|elib
operator|==
name|NULL
condition|)
break|break;
name|string_sec
operator|=
name|SECTION_HEADER
argument_list|(
name|section
operator|->
name|sh_link
argument_list|)
expr_stmt|;
name|strtab
operator|=
name|get_data
argument_list|(
name|NULL
argument_list|,
name|file
argument_list|,
name|string_sec
operator|->
name|sh_offset
argument_list|,
name|string_sec
operator|->
name|sh_size
argument_list|,
name|_
argument_list|(
literal|"liblist string table"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|strtab
operator|==
name|NULL
operator|||
name|section
operator|->
name|sh_entsize
operator|!=
sizeof|sizeof
argument_list|(
name|Elf32_External_Lib
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|elib
argument_list|)
expr_stmt|;
break|break;
block|}
name|printf
argument_list|(
name|_
argument_list|(
literal|"\nLibrary list section '%s' contains %lu entries:\n"
argument_list|)
argument_list|,
name|SECTION_NAME
argument_list|(
name|section
argument_list|)
argument_list|,
call|(
name|long
call|)
argument_list|(
name|section
operator|->
name|sh_size
operator|/
sizeof|sizeof
argument_list|(
name|Elf32_External_Lib
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|"     Library              Time Stamp          Checksum   Version Flags"
argument_list|)
expr_stmt|;
for|for
control|(
name|cnt
operator|=
literal|0
init|;
name|cnt
operator|<
name|section
operator|->
name|sh_size
operator|/
sizeof|sizeof
argument_list|(
name|Elf32_External_Lib
argument_list|)
condition|;
operator|++
name|cnt
control|)
block|{
name|Elf32_Lib
name|liblist
decl_stmt|;
name|time_t
name|time
decl_stmt|;
name|char
name|timebuf
index|[
literal|20
index|]
decl_stmt|;
name|struct
name|tm
modifier|*
name|tmp
decl_stmt|;
name|liblist
operator|.
name|l_name
operator|=
name|BYTE_GET
argument_list|(
name|elib
index|[
name|cnt
index|]
operator|.
name|l_name
argument_list|)
expr_stmt|;
name|time
operator|=
name|BYTE_GET
argument_list|(
name|elib
index|[
name|cnt
index|]
operator|.
name|l_time_stamp
argument_list|)
expr_stmt|;
name|liblist
operator|.
name|l_checksum
operator|=
name|BYTE_GET
argument_list|(
name|elib
index|[
name|cnt
index|]
operator|.
name|l_checksum
argument_list|)
expr_stmt|;
name|liblist
operator|.
name|l_version
operator|=
name|BYTE_GET
argument_list|(
name|elib
index|[
name|cnt
index|]
operator|.
name|l_version
argument_list|)
expr_stmt|;
name|liblist
operator|.
name|l_flags
operator|=
name|BYTE_GET
argument_list|(
name|elib
index|[
name|cnt
index|]
operator|.
name|l_flags
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|gmtime
argument_list|(
operator|&
name|time
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|timebuf
argument_list|,
literal|"%04u-%02u-%02uT%02u:%02u:%02u"
argument_list|,
name|tmp
operator|->
name|tm_year
operator|+
literal|1900
argument_list|,
name|tmp
operator|->
name|tm_mon
operator|+
literal|1
argument_list|,
name|tmp
operator|->
name|tm_mday
argument_list|,
name|tmp
operator|->
name|tm_hour
argument_list|,
name|tmp
operator|->
name|tm_min
argument_list|,
name|tmp
operator|->
name|tm_sec
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%3lu: "
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|cnt
argument_list|)
expr_stmt|;
if|if
condition|(
name|do_wide
condition|)
name|printf
argument_list|(
literal|"%-20s"
argument_list|,
name|strtab
operator|+
name|liblist
operator|.
name|l_name
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%-20.20s"
argument_list|,
name|strtab
operator|+
name|liblist
operator|.
name|l_name
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %s %#010lx %-7ld %-7ld\n"
argument_list|,
name|timebuf
argument_list|,
name|liblist
operator|.
name|l_checksum
argument_list|,
name|liblist
operator|.
name|l_version
argument_list|,
name|liblist
operator|.
name|l_flags
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|elib
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|get_note_type
parameter_list|(
name|unsigned
name|e_type
parameter_list|)
block|{
specifier|static
name|char
name|buff
index|[
literal|64
index|]
decl_stmt|;
switch|switch
condition|(
name|e_type
condition|)
block|{
case|case
name|NT_AUXV
case|:
return|return
name|_
argument_list|(
literal|"NT_AUXV (auxiliary vector)"
argument_list|)
return|;
case|case
name|NT_PRSTATUS
case|:
return|return
name|_
argument_list|(
literal|"NT_PRSTATUS (prstatus structure)"
argument_list|)
return|;
case|case
name|NT_FPREGSET
case|:
return|return
name|_
argument_list|(
literal|"NT_FPREGSET (floating point registers)"
argument_list|)
return|;
case|case
name|NT_PRPSINFO
case|:
return|return
name|_
argument_list|(
literal|"NT_PRPSINFO (prpsinfo structure)"
argument_list|)
return|;
case|case
name|NT_TASKSTRUCT
case|:
return|return
name|_
argument_list|(
literal|"NT_TASKSTRUCT (task structure)"
argument_list|)
return|;
case|case
name|NT_PRXFPREG
case|:
return|return
name|_
argument_list|(
literal|"NT_PRXFPREG (user_xfpregs structure)"
argument_list|)
return|;
case|case
name|NT_PSTATUS
case|:
return|return
name|_
argument_list|(
literal|"NT_PSTATUS (pstatus structure)"
argument_list|)
return|;
case|case
name|NT_FPREGS
case|:
return|return
name|_
argument_list|(
literal|"NT_FPREGS (floating point registers)"
argument_list|)
return|;
case|case
name|NT_PSINFO
case|:
return|return
name|_
argument_list|(
literal|"NT_PSINFO (psinfo structure)"
argument_list|)
return|;
case|case
name|NT_LWPSTATUS
case|:
return|return
name|_
argument_list|(
literal|"NT_LWPSTATUS (lwpstatus_t structure)"
argument_list|)
return|;
case|case
name|NT_LWPSINFO
case|:
return|return
name|_
argument_list|(
literal|"NT_LWPSINFO (lwpsinfo_t structure)"
argument_list|)
return|;
case|case
name|NT_WIN32PSTATUS
case|:
return|return
name|_
argument_list|(
literal|"NT_WIN32PSTATUS (win32_pstatus structure)"
argument_list|)
return|;
default|default:
name|sprintf
argument_list|(
name|buff
argument_list|,
name|_
argument_list|(
literal|"Unknown note type: (0x%08x)"
argument_list|)
argument_list|,
name|e_type
argument_list|)
expr_stmt|;
return|return
name|buff
return|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|get_netbsd_elfcore_note_type
parameter_list|(
name|unsigned
name|e_type
parameter_list|)
block|{
specifier|static
name|char
name|buff
index|[
literal|64
index|]
decl_stmt|;
if|if
condition|(
name|e_type
operator|==
name|NT_NETBSDCORE_PROCINFO
condition|)
block|{
comment|/* NetBSD core "procinfo" structure.  */
return|return
name|_
argument_list|(
literal|"NetBSD procinfo structure"
argument_list|)
return|;
block|}
comment|/* As of Jan 2002 there are no other machine-independent notes      defined for NetBSD core files.  If the note type is less      than the start of the machine-dependent note types, we don't      understand it.  */
if|if
condition|(
name|e_type
operator|<
name|NT_NETBSDCORE_FIRSTMACH
condition|)
block|{
name|sprintf
argument_list|(
name|buff
argument_list|,
name|_
argument_list|(
literal|"Unknown note type: (0x%08x)"
argument_list|)
argument_list|,
name|e_type
argument_list|)
expr_stmt|;
return|return
name|buff
return|;
block|}
switch|switch
condition|(
name|elf_header
operator|.
name|e_machine
condition|)
block|{
comment|/* On the Alpha, SPARC (32-bit and 64-bit), PT_GETREGS == mach+0        and PT_GETFPREGS == mach+2.  */
case|case
name|EM_OLD_ALPHA
case|:
case|case
name|EM_ALPHA
case|:
case|case
name|EM_SPARC
case|:
case|case
name|EM_SPARC32PLUS
case|:
case|case
name|EM_SPARCV9
case|:
switch|switch
condition|(
name|e_type
condition|)
block|{
case|case
name|NT_NETBSDCORE_FIRSTMACH
operator|+
literal|0
case|:
return|return
name|_
argument_list|(
literal|"PT_GETREGS (reg structure)"
argument_list|)
return|;
case|case
name|NT_NETBSDCORE_FIRSTMACH
operator|+
literal|2
case|:
return|return
name|_
argument_list|(
literal|"PT_GETFPREGS (fpreg structure)"
argument_list|)
return|;
default|default:
break|break;
block|}
break|break;
comment|/* On all other arch's, PT_GETREGS == mach+1 and        PT_GETFPREGS == mach+3.  */
default|default:
switch|switch
condition|(
name|e_type
condition|)
block|{
case|case
name|NT_NETBSDCORE_FIRSTMACH
operator|+
literal|1
case|:
return|return
name|_
argument_list|(
literal|"PT_GETREGS (reg structure)"
argument_list|)
return|;
case|case
name|NT_NETBSDCORE_FIRSTMACH
operator|+
literal|3
case|:
return|return
name|_
argument_list|(
literal|"PT_GETFPREGS (fpreg structure)"
argument_list|)
return|;
default|default:
break|break;
block|}
block|}
name|sprintf
argument_list|(
name|buff
argument_list|,
name|_
argument_list|(
literal|"PT_FIRSTMACH+%d"
argument_list|)
argument_list|,
name|e_type
operator|-
name|NT_NETBSDCORE_FIRSTMACH
argument_list|)
expr_stmt|;
return|return
name|buff
return|;
block|}
end_function

begin_comment
comment|/* Note that by the ELF standard, the name field is already null byte    terminated, and namesz includes the terminating null byte.    I.E. the value of namesz for the name "FSF" is 4.     If the value of namesz is zero, there is no name present.  */
end_comment

begin_function
specifier|static
name|int
name|process_note
parameter_list|(
name|Elf_Internal_Note
modifier|*
name|pnote
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|nt
decl_stmt|;
if|if
condition|(
name|pnote
operator|->
name|namesz
operator|==
literal|0
condition|)
block|{
comment|/* If there is no note name, then use the default set of 	 note type strings.  */
name|nt
operator|=
name|get_note_type
argument_list|(
name|pnote
operator|->
name|type
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|pnote
operator|->
name|namedata
argument_list|,
literal|"NetBSD-CORE"
argument_list|,
literal|11
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* NetBSD-specific core file notes.  */
name|nt
operator|=
name|get_netbsd_elfcore_note_type
argument_list|(
name|pnote
operator|->
name|type
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Don't recognize this note name; just use the default set of 	 note type strings.  */
name|nt
operator|=
name|get_note_type
argument_list|(
name|pnote
operator|->
name|type
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"  %s\t\t0x%08lx\t%s\n"
argument_list|,
name|pnote
operator|->
name|namesz
condition|?
name|pnote
operator|->
name|namedata
else|:
literal|"(NONE)"
argument_list|,
name|pnote
operator|->
name|descsz
argument_list|,
name|nt
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|process_corefile_note_segment
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
name|bfd_vma
name|offset
parameter_list|,
name|bfd_vma
name|length
parameter_list|)
block|{
name|Elf_External_Note
modifier|*
name|pnotes
decl_stmt|;
name|Elf_External_Note
modifier|*
name|external
decl_stmt|;
name|int
name|res
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|length
operator|<=
literal|0
condition|)
return|return
literal|0
return|;
name|pnotes
operator|=
name|get_data
argument_list|(
name|NULL
argument_list|,
name|file
argument_list|,
name|offset
argument_list|,
name|length
argument_list|,
name|_
argument_list|(
literal|"notes"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pnotes
condition|)
return|return
literal|0
return|;
name|external
operator|=
name|pnotes
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"\nNotes at offset 0x%08lx with length 0x%08lx:\n"
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|offset
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|length
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"  Owner\t\tData size\tDescription\n"
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|external
operator|<
operator|(
name|Elf_External_Note
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|pnotes
operator|+
name|length
operator|)
condition|)
block|{
name|Elf_External_Note
modifier|*
name|next
decl_stmt|;
name|Elf_Internal_Note
name|inote
decl_stmt|;
name|char
modifier|*
name|temp
init|=
name|NULL
decl_stmt|;
name|inote
operator|.
name|type
operator|=
name|BYTE_GET
argument_list|(
name|external
operator|->
name|type
argument_list|)
expr_stmt|;
name|inote
operator|.
name|namesz
operator|=
name|BYTE_GET
argument_list|(
name|external
operator|->
name|namesz
argument_list|)
expr_stmt|;
name|inote
operator|.
name|namedata
operator|=
name|external
operator|->
name|name
expr_stmt|;
name|inote
operator|.
name|descsz
operator|=
name|BYTE_GET
argument_list|(
name|external
operator|->
name|descsz
argument_list|)
expr_stmt|;
name|inote
operator|.
name|descdata
operator|=
name|inote
operator|.
name|namedata
operator|+
name|align_power
argument_list|(
name|inote
operator|.
name|namesz
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|inote
operator|.
name|descpos
operator|=
name|offset
operator|+
operator|(
name|inote
operator|.
name|descdata
operator|-
operator|(
name|char
operator|*
operator|)
name|pnotes
operator|)
expr_stmt|;
name|next
operator|=
operator|(
name|Elf_External_Note
operator|*
operator|)
operator|(
name|inote
operator|.
name|descdata
operator|+
name|align_power
argument_list|(
name|inote
operator|.
name|descsz
argument_list|,
literal|2
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|char
operator|*
operator|)
name|next
operator|)
operator|>
operator|(
operator|(
operator|(
name|char
operator|*
operator|)
name|pnotes
operator|)
operator|+
name|length
operator|)
condition|)
block|{
name|warn
argument_list|(
name|_
argument_list|(
literal|"corrupt note found at offset %x into core notes\n"
argument_list|)
argument_list|,
operator|(
operator|(
name|char
operator|*
operator|)
name|external
operator|)
operator|-
operator|(
operator|(
name|char
operator|*
operator|)
name|pnotes
operator|)
argument_list|)
expr_stmt|;
name|warn
argument_list|(
name|_
argument_list|(
literal|" type: %x, namesize: %08lx, descsize: %08lx\n"
argument_list|)
argument_list|,
name|inote
operator|.
name|type
argument_list|,
name|inote
operator|.
name|namesz
argument_list|,
name|inote
operator|.
name|descsz
argument_list|)
expr_stmt|;
break|break;
block|}
name|external
operator|=
name|next
expr_stmt|;
comment|/* Verify that name is null terminated.  It appears that at least 	 one version of Linux (RedHat 6.0) generates corefiles that don't 	 comply with the ELF spec by failing to include the null byte in 	 namesz.  */
if|if
condition|(
name|inote
operator|.
name|namedata
index|[
name|inote
operator|.
name|namesz
index|]
operator|!=
literal|'\0'
condition|)
block|{
name|temp
operator|=
name|malloc
argument_list|(
name|inote
operator|.
name|namesz
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"Out of memory\n"
argument_list|)
argument_list|)
expr_stmt|;
name|res
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|strncpy
argument_list|(
name|temp
argument_list|,
name|inote
operator|.
name|namedata
argument_list|,
name|inote
operator|.
name|namesz
argument_list|)
expr_stmt|;
name|temp
index|[
name|inote
operator|.
name|namesz
index|]
operator|=
literal|0
expr_stmt|;
comment|/* warn (_("'%s' NOTE name not properly null terminated\n"), temp);  */
name|inote
operator|.
name|namedata
operator|=
name|temp
expr_stmt|;
block|}
name|res
operator|&=
name|process_note
argument_list|(
operator|&
name|inote
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|temp
operator|=
name|NULL
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|pnotes
argument_list|)
expr_stmt|;
return|return
name|res
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|process_corefile_note_segments
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|)
block|{
name|Elf_Internal_Phdr
modifier|*
name|segment
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|int
name|res
init|=
literal|1
decl_stmt|;
if|if
condition|(
operator|!
name|get_program_headers
argument_list|(
name|file
argument_list|)
condition|)
return|return
literal|0
return|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|segment
operator|=
name|program_headers
init|;
name|i
operator|<
name|elf_header
operator|.
name|e_phnum
condition|;
name|i
operator|++
operator|,
name|segment
operator|++
control|)
block|{
if|if
condition|(
name|segment
operator|->
name|p_type
operator|==
name|PT_NOTE
condition|)
name|res
operator|&=
name|process_corefile_note_segment
argument_list|(
name|file
argument_list|,
operator|(
name|bfd_vma
operator|)
name|segment
operator|->
name|p_offset
argument_list|,
operator|(
name|bfd_vma
operator|)
name|segment
operator|->
name|p_filesz
argument_list|)
expr_stmt|;
block|}
return|return
name|res
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|process_corefile_contents
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|)
block|{
comment|/* If we have not been asked to display the notes then do nothing.  */
if|if
condition|(
operator|!
name|do_notes
condition|)
return|return
literal|1
return|;
comment|/* If file is not a core file then exit.  */
if|if
condition|(
name|elf_header
operator|.
name|e_type
operator|!=
name|ET_CORE
condition|)
return|return
literal|1
return|;
comment|/* No program headers means no NOTE segment.  */
if|if
condition|(
name|elf_header
operator|.
name|e_phnum
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
name|_
argument_list|(
literal|"No note segments present in the core file.\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
name|process_corefile_note_segments
argument_list|(
name|file
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|process_arch_specific
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|)
block|{
if|if
condition|(
operator|!
name|do_arch
condition|)
return|return
literal|1
return|;
switch|switch
condition|(
name|elf_header
operator|.
name|e_machine
condition|)
block|{
case|case
name|EM_MIPS
case|:
case|case
name|EM_MIPS_RS3_LE
case|:
return|return
name|process_mips_specific
argument_list|(
name|file
argument_list|)
return|;
break|break;
default|default:
break|break;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|get_file_header
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|)
block|{
comment|/* Read in the identity array.  */
if|if
condition|(
name|fread
argument_list|(
name|elf_header
operator|.
name|e_ident
argument_list|,
name|EI_NIDENT
argument_list|,
literal|1
argument_list|,
name|file
argument_list|)
operator|!=
literal|1
condition|)
return|return
literal|0
return|;
comment|/* Determine how to read the rest of the header.  */
switch|switch
condition|(
name|elf_header
operator|.
name|e_ident
index|[
name|EI_DATA
index|]
condition|)
block|{
default|default:
comment|/* fall through */
case|case
name|ELFDATANONE
case|:
comment|/* fall through */
case|case
name|ELFDATA2LSB
case|:
name|byte_get
operator|=
name|byte_get_little_endian
expr_stmt|;
name|byte_put
operator|=
name|byte_put_little_endian
expr_stmt|;
break|break;
case|case
name|ELFDATA2MSB
case|:
name|byte_get
operator|=
name|byte_get_big_endian
expr_stmt|;
name|byte_put
operator|=
name|byte_put_big_endian
expr_stmt|;
break|break;
block|}
comment|/* For now we only support 32 bit and 64 bit ELF files.  */
name|is_32bit_elf
operator|=
operator|(
name|elf_header
operator|.
name|e_ident
index|[
name|EI_CLASS
index|]
operator|!=
name|ELFCLASS64
operator|)
expr_stmt|;
comment|/* Read in the rest of the header.  */
if|if
condition|(
name|is_32bit_elf
condition|)
block|{
name|Elf32_External_Ehdr
name|ehdr32
decl_stmt|;
if|if
condition|(
name|fread
argument_list|(
name|ehdr32
operator|.
name|e_type
argument_list|,
sizeof|sizeof
argument_list|(
name|ehdr32
argument_list|)
operator|-
name|EI_NIDENT
argument_list|,
literal|1
argument_list|,
name|file
argument_list|)
operator|!=
literal|1
condition|)
return|return
literal|0
return|;
name|elf_header
operator|.
name|e_type
operator|=
name|BYTE_GET
argument_list|(
name|ehdr32
operator|.
name|e_type
argument_list|)
expr_stmt|;
name|elf_header
operator|.
name|e_machine
operator|=
name|BYTE_GET
argument_list|(
name|ehdr32
operator|.
name|e_machine
argument_list|)
expr_stmt|;
name|elf_header
operator|.
name|e_version
operator|=
name|BYTE_GET
argument_list|(
name|ehdr32
operator|.
name|e_version
argument_list|)
expr_stmt|;
name|elf_header
operator|.
name|e_entry
operator|=
name|BYTE_GET
argument_list|(
name|ehdr32
operator|.
name|e_entry
argument_list|)
expr_stmt|;
name|elf_header
operator|.
name|e_phoff
operator|=
name|BYTE_GET
argument_list|(
name|ehdr32
operator|.
name|e_phoff
argument_list|)
expr_stmt|;
name|elf_header
operator|.
name|e_shoff
operator|=
name|BYTE_GET
argument_list|(
name|ehdr32
operator|.
name|e_shoff
argument_list|)
expr_stmt|;
name|elf_header
operator|.
name|e_flags
operator|=
name|BYTE_GET
argument_list|(
name|ehdr32
operator|.
name|e_flags
argument_list|)
expr_stmt|;
name|elf_header
operator|.
name|e_ehsize
operator|=
name|BYTE_GET
argument_list|(
name|ehdr32
operator|.
name|e_ehsize
argument_list|)
expr_stmt|;
name|elf_header
operator|.
name|e_phentsize
operator|=
name|BYTE_GET
argument_list|(
name|ehdr32
operator|.
name|e_phentsize
argument_list|)
expr_stmt|;
name|elf_header
operator|.
name|e_phnum
operator|=
name|BYTE_GET
argument_list|(
name|ehdr32
operator|.
name|e_phnum
argument_list|)
expr_stmt|;
name|elf_header
operator|.
name|e_shentsize
operator|=
name|BYTE_GET
argument_list|(
name|ehdr32
operator|.
name|e_shentsize
argument_list|)
expr_stmt|;
name|elf_header
operator|.
name|e_shnum
operator|=
name|BYTE_GET
argument_list|(
name|ehdr32
operator|.
name|e_shnum
argument_list|)
expr_stmt|;
name|elf_header
operator|.
name|e_shstrndx
operator|=
name|BYTE_GET
argument_list|(
name|ehdr32
operator|.
name|e_shstrndx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Elf64_External_Ehdr
name|ehdr64
decl_stmt|;
comment|/* If we have been compiled with sizeof (bfd_vma) == 4, then 	 we will not be able to cope with the 64bit data found in 	 64 ELF files.  Detect this now and abort before we start 	 overwriting things.  */
if|if
condition|(
sizeof|sizeof
argument_list|(
name|bfd_vma
argument_list|)
operator|<
literal|8
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"This instance of readelf has been built without support for a\n\ 64 bit data type and so it cannot read 64 bit ELF files.\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|fread
argument_list|(
name|ehdr64
operator|.
name|e_type
argument_list|,
sizeof|sizeof
argument_list|(
name|ehdr64
argument_list|)
operator|-
name|EI_NIDENT
argument_list|,
literal|1
argument_list|,
name|file
argument_list|)
operator|!=
literal|1
condition|)
return|return
literal|0
return|;
name|elf_header
operator|.
name|e_type
operator|=
name|BYTE_GET
argument_list|(
name|ehdr64
operator|.
name|e_type
argument_list|)
expr_stmt|;
name|elf_header
operator|.
name|e_machine
operator|=
name|BYTE_GET
argument_list|(
name|ehdr64
operator|.
name|e_machine
argument_list|)
expr_stmt|;
name|elf_header
operator|.
name|e_version
operator|=
name|BYTE_GET
argument_list|(
name|ehdr64
operator|.
name|e_version
argument_list|)
expr_stmt|;
name|elf_header
operator|.
name|e_entry
operator|=
name|BYTE_GET8
argument_list|(
name|ehdr64
operator|.
name|e_entry
argument_list|)
expr_stmt|;
name|elf_header
operator|.
name|e_phoff
operator|=
name|BYTE_GET8
argument_list|(
name|ehdr64
operator|.
name|e_phoff
argument_list|)
expr_stmt|;
name|elf_header
operator|.
name|e_shoff
operator|=
name|BYTE_GET8
argument_list|(
name|ehdr64
operator|.
name|e_shoff
argument_list|)
expr_stmt|;
name|elf_header
operator|.
name|e_flags
operator|=
name|BYTE_GET
argument_list|(
name|ehdr64
operator|.
name|e_flags
argument_list|)
expr_stmt|;
name|elf_header
operator|.
name|e_ehsize
operator|=
name|BYTE_GET
argument_list|(
name|ehdr64
operator|.
name|e_ehsize
argument_list|)
expr_stmt|;
name|elf_header
operator|.
name|e_phentsize
operator|=
name|BYTE_GET
argument_list|(
name|ehdr64
operator|.
name|e_phentsize
argument_list|)
expr_stmt|;
name|elf_header
operator|.
name|e_phnum
operator|=
name|BYTE_GET
argument_list|(
name|ehdr64
operator|.
name|e_phnum
argument_list|)
expr_stmt|;
name|elf_header
operator|.
name|e_shentsize
operator|=
name|BYTE_GET
argument_list|(
name|ehdr64
operator|.
name|e_shentsize
argument_list|)
expr_stmt|;
name|elf_header
operator|.
name|e_shnum
operator|=
name|BYTE_GET
argument_list|(
name|ehdr64
operator|.
name|e_shnum
argument_list|)
expr_stmt|;
name|elf_header
operator|.
name|e_shstrndx
operator|=
name|BYTE_GET
argument_list|(
name|ehdr64
operator|.
name|e_shstrndx
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|elf_header
operator|.
name|e_shoff
condition|)
block|{
comment|/* There may be some extensions in the first section header.  Don't 	 bomb if we can't read it.  */
if|if
condition|(
name|is_32bit_elf
condition|)
name|get_32bit_section_headers
argument_list|(
name|file
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|get_64bit_section_headers
argument_list|(
name|file
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Process one ELF object file according to the command line options.    This file may actually be stored in an archive.  The file is    positioned at the start of the ELF object.  */
end_comment

begin_function
specifier|static
name|int
name|process_object
parameter_list|(
name|char
modifier|*
name|file_name
parameter_list|,
name|FILE
modifier|*
name|file
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|get_file_header
argument_list|(
name|file
argument_list|)
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"%s: Failed to read file header\n"
argument_list|)
argument_list|,
name|file_name
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* Initialise per file variables.  */
for|for
control|(
name|i
operator|=
name|NUM_ELEM
argument_list|(
name|version_info
argument_list|)
init|;
name|i
operator|--
condition|;
control|)
name|version_info
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|NUM_ELEM
argument_list|(
name|dynamic_info
argument_list|)
init|;
name|i
operator|--
condition|;
control|)
name|dynamic_info
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
comment|/* Process the file.  */
if|if
condition|(
name|show_name
condition|)
name|printf
argument_list|(
name|_
argument_list|(
literal|"\nFile: %s\n"
argument_list|)
argument_list|,
name|file_name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|process_file_header
argument_list|()
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|!
name|process_section_headers
argument_list|(
name|file
argument_list|)
condition|)
block|{
comment|/* Without loaded section headers we 	 cannot process lots of things.  */
name|do_unwind
operator|=
name|do_version
operator|=
name|do_dump
operator|=
name|do_arch
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|do_using_dynamic
condition|)
name|do_syms
operator|=
name|do_reloc
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|process_program_headers
argument_list|(
name|file
argument_list|)
condition|)
name|process_dynamic_segment
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|process_relocs
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|process_unwind
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|process_symbol_table
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|process_syminfo
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|process_version_sections
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|process_section_contents
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|process_corefile_contents
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|process_gnu_liblist
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|process_arch_specific
argument_list|(
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|program_headers
condition|)
block|{
name|free
argument_list|(
name|program_headers
argument_list|)
expr_stmt|;
name|program_headers
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|section_headers
condition|)
block|{
name|free
argument_list|(
name|section_headers
argument_list|)
expr_stmt|;
name|section_headers
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|string_table
condition|)
block|{
name|free
argument_list|(
name|string_table
argument_list|)
expr_stmt|;
name|string_table
operator|=
name|NULL
expr_stmt|;
name|string_table_length
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|dynamic_strings
condition|)
block|{
name|free
argument_list|(
name|dynamic_strings
argument_list|)
expr_stmt|;
name|dynamic_strings
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|dynamic_symbols
condition|)
block|{
name|free
argument_list|(
name|dynamic_symbols
argument_list|)
expr_stmt|;
name|dynamic_symbols
operator|=
name|NULL
expr_stmt|;
name|num_dynamic_syms
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|dynamic_syminfo
condition|)
block|{
name|free
argument_list|(
name|dynamic_syminfo
argument_list|)
expr_stmt|;
name|dynamic_syminfo
operator|=
name|NULL
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Process an ELF archive.  The file is positioned just after the    ARMAG string.  */
end_comment

begin_function
specifier|static
name|int
name|process_archive
parameter_list|(
name|char
modifier|*
name|file_name
parameter_list|,
name|FILE
modifier|*
name|file
parameter_list|)
block|{
name|struct
name|ar_hdr
name|arhdr
decl_stmt|;
name|size_t
name|got
decl_stmt|;
name|unsigned
name|long
name|size
decl_stmt|;
name|char
modifier|*
name|longnames
init|=
name|NULL
decl_stmt|;
name|unsigned
name|long
name|longnames_size
init|=
literal|0
decl_stmt|;
name|size_t
name|file_name_size
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|show_name
operator|=
literal|1
expr_stmt|;
name|got
operator|=
name|fread
argument_list|(
operator|&
name|arhdr
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
name|arhdr
argument_list|,
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|got
operator|!=
sizeof|sizeof
name|arhdr
condition|)
block|{
if|if
condition|(
name|got
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|error
argument_list|(
name|_
argument_list|(
literal|"%s: failed to read archive header\n"
argument_list|)
argument_list|,
name|file_name
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|memcmp
argument_list|(
name|arhdr
operator|.
name|ar_name
argument_list|,
literal|"/               "
argument_list|,
literal|16
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* This is the archive symbol table.  Skip it. 	 FIXME: We should have an option to dump it.  */
name|size
operator|=
name|strtoul
argument_list|(
name|arhdr
operator|.
name|ar_size
argument_list|,
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|fseek
argument_list|(
name|file
argument_list|,
name|size
operator|+
operator|(
name|size
operator|&
literal|1
operator|)
argument_list|,
name|SEEK_CUR
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"%s: failed to skip archive symbol table\n"
argument_list|)
argument_list|,
name|file_name
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|got
operator|=
name|fread
argument_list|(
operator|&
name|arhdr
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
name|arhdr
argument_list|,
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|got
operator|!=
sizeof|sizeof
name|arhdr
condition|)
block|{
if|if
condition|(
name|got
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|error
argument_list|(
name|_
argument_list|(
literal|"%s: failed to read archive header\n"
argument_list|)
argument_list|,
name|file_name
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
if|if
condition|(
name|memcmp
argument_list|(
name|arhdr
operator|.
name|ar_name
argument_list|,
literal|"//              "
argument_list|,
literal|16
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* This is the archive string table holding long member 	 names.  */
name|longnames_size
operator|=
name|strtoul
argument_list|(
name|arhdr
operator|.
name|ar_size
argument_list|,
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|longnames
operator|=
name|malloc
argument_list|(
name|longnames_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|longnames
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"Out of memory\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|fread
argument_list|(
name|longnames
argument_list|,
name|longnames_size
argument_list|,
literal|1
argument_list|,
name|file
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|free
argument_list|(
name|longnames
argument_list|)
expr_stmt|;
name|error
argument_list|(
name|_
argument_list|(
literal|"%s: failed to read string table\n"
argument_list|)
argument_list|,
name|file_name
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
operator|(
name|longnames_size
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
name|getc
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|got
operator|=
name|fread
argument_list|(
operator|&
name|arhdr
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
name|arhdr
argument_list|,
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|got
operator|!=
sizeof|sizeof
name|arhdr
condition|)
block|{
name|free
argument_list|(
name|longnames
argument_list|)
expr_stmt|;
if|if
condition|(
name|got
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|error
argument_list|(
name|_
argument_list|(
literal|"%s: failed to read archive header\n"
argument_list|)
argument_list|,
name|file_name
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
name|file_name_size
operator|=
name|strlen
argument_list|(
name|file_name
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|nameend
decl_stmt|;
name|char
modifier|*
name|namealc
decl_stmt|;
if|if
condition|(
name|arhdr
operator|.
name|ar_name
index|[
literal|0
index|]
operator|==
literal|'/'
condition|)
block|{
name|unsigned
name|long
name|off
decl_stmt|;
name|off
operator|=
name|strtoul
argument_list|(
name|arhdr
operator|.
name|ar_name
operator|+
literal|1
argument_list|,
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|off
operator|>=
name|longnames_size
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"%s: invalid archive string table offset %lu\n"
argument_list|)
argument_list|,
name|off
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|name
operator|=
name|longnames
operator|+
name|off
expr_stmt|;
name|nameend
operator|=
name|memchr
argument_list|(
name|name
argument_list|,
literal|'/'
argument_list|,
name|longnames_size
operator|-
name|off
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|name
operator|=
name|arhdr
operator|.
name|ar_name
expr_stmt|;
name|nameend
operator|=
name|memchr
argument_list|(
name|name
argument_list|,
literal|'/'
argument_list|,
literal|16
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nameend
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"%s: bad archive file name\n"
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|namealc
operator|=
name|malloc
argument_list|(
name|file_name_size
operator|+
operator|(
name|nameend
operator|-
name|name
operator|)
operator|+
literal|3
argument_list|)
expr_stmt|;
if|if
condition|(
name|namealc
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"Out of memory\n"
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|memcpy
argument_list|(
name|namealc
argument_list|,
name|file_name
argument_list|,
name|file_name_size
argument_list|)
expr_stmt|;
name|namealc
index|[
name|file_name_size
index|]
operator|=
literal|'('
expr_stmt|;
name|memcpy
argument_list|(
name|namealc
operator|+
name|file_name_size
operator|+
literal|1
argument_list|,
name|name
argument_list|,
name|nameend
operator|-
name|name
argument_list|)
expr_stmt|;
name|namealc
index|[
name|file_name_size
operator|+
literal|1
operator|+
operator|(
name|nameend
operator|-
name|name
operator|)
index|]
operator|=
literal|')'
expr_stmt|;
name|namealc
index|[
name|file_name_size
operator|+
literal|2
operator|+
operator|(
name|nameend
operator|-
name|name
operator|)
index|]
operator|=
literal|'\0'
expr_stmt|;
name|archive_file_offset
operator|=
name|ftell
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|archive_file_size
operator|=
name|strtoul
argument_list|(
name|arhdr
operator|.
name|ar_size
argument_list|,
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|ret
operator||=
name|process_object
argument_list|(
name|namealc
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|namealc
argument_list|)
expr_stmt|;
if|if
condition|(
name|fseek
argument_list|(
name|file
argument_list|,
operator|(
name|archive_file_offset
operator|+
name|archive_file_size
operator|+
operator|(
name|archive_file_size
operator|&
literal|1
operator|)
operator|)
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"%s: failed to seek to next archive header\n"
argument_list|)
argument_list|,
name|file_name
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|got
operator|=
name|fread
argument_list|(
operator|&
name|arhdr
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
name|arhdr
argument_list|,
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|got
operator|!=
sizeof|sizeof
name|arhdr
condition|)
block|{
if|if
condition|(
name|got
operator|==
literal|0
condition|)
break|break;
name|error
argument_list|(
name|_
argument_list|(
literal|"%s: failed to read archive header\n"
argument_list|)
argument_list|,
name|file_name
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|longnames
operator|!=
literal|0
condition|)
name|free
argument_list|(
name|longnames
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|process_file
parameter_list|(
name|char
modifier|*
name|file_name
parameter_list|)
block|{
name|FILE
modifier|*
name|file
decl_stmt|;
name|struct
name|stat
name|statbuf
decl_stmt|;
name|char
name|armag
index|[
name|SARMAG
index|]
decl_stmt|;
name|int
name|ret
decl_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|file_name
argument_list|,
operator|&
name|statbuf
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|ENOENT
condition|)
name|error
argument_list|(
name|_
argument_list|(
literal|"'%s': No such file\n"
argument_list|)
argument_list|,
name|file_name
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
name|_
argument_list|(
literal|"Could not locate '%s'.  System error message: %s\n"
argument_list|)
argument_list|,
name|file_name
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
operator|!
name|S_ISREG
argument_list|(
name|statbuf
operator|.
name|st_mode
argument_list|)
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"'%s' is not an ordinary file\n"
argument_list|)
argument_list|,
name|file_name
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|file
operator|=
name|fopen
argument_list|(
name|file_name
argument_list|,
literal|"rb"
argument_list|)
expr_stmt|;
if|if
condition|(
name|file
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"Input file '%s' is not readable.\n"
argument_list|)
argument_list|,
name|file_name
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|fread
argument_list|(
name|armag
argument_list|,
name|SARMAG
argument_list|,
literal|1
argument_list|,
name|file
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"%s: Failed to read file header\n"
argument_list|)
argument_list|,
name|file_name
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|file
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|memcmp
argument_list|(
name|armag
argument_list|,
name|ARMAG
argument_list|,
name|SARMAG
argument_list|)
operator|==
literal|0
condition|)
name|ret
operator|=
name|process_archive
argument_list|(
name|file_name
argument_list|,
name|file
argument_list|)
expr_stmt|;
else|else
block|{
name|rewind
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|archive_file_size
operator|=
name|archive_file_offset
operator|=
literal|0
expr_stmt|;
name|ret
operator|=
name|process_object
argument_list|(
name|file_name
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
name|fclose
argument_list|(
name|file
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|SUPPORT_DISASSEMBLY
end_ifdef

begin_comment
comment|/* Needed by the i386 disassembler.  For extra credit, someone could    fix this so that we insert symbolic addresses here, esp for GOT/PLT    symbols.  */
end_comment

begin_function
name|void
name|print_address
parameter_list|(
name|unsigned
name|int
name|addr
parameter_list|,
name|FILE
modifier|*
name|outfile
parameter_list|)
block|{
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"0x%8.8x"
argument_list|,
name|addr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Needed by the i386 disassembler.  */
end_comment

begin_function
name|void
name|db_task_printsym
parameter_list|(
name|unsigned
name|int
name|addr
parameter_list|)
block|{
name|print_address
argument_list|(
name|addr
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|char
modifier|*
name|cmdline_dump_sects
init|=
name|NULL
decl_stmt|;
name|unsigned
name|num_cmdline_dump_sects
init|=
literal|0
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HAVE_SETLOCALE
argument_list|)
operator|&&
name|defined
argument_list|(
name|HAVE_LC_MESSAGES
argument_list|)
name|setlocale
argument_list|(
name|LC_MESSAGES
argument_list|,
literal|""
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|HAVE_SETLOCALE
argument_list|)
name|setlocale
argument_list|(
name|LC_CTYPE
argument_list|,
literal|""
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|bindtextdomain
argument_list|(
name|PACKAGE
argument_list|,
name|LOCALEDIR
argument_list|)
expr_stmt|;
name|textdomain
argument_list|(
name|PACKAGE
argument_list|)
expr_stmt|;
name|parse_args
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
if|if
condition|(
name|optind
operator|<
operator|(
name|argc
operator|-
literal|1
operator|)
condition|)
name|show_name
operator|=
literal|1
expr_stmt|;
comment|/* When processing more than one file remember the dump requests      issued on command line to reset them after each file.  */
if|if
condition|(
name|optind
operator|+
literal|1
operator|<
name|argc
operator|&&
name|dump_sects
operator|!=
name|NULL
condition|)
block|{
name|cmdline_dump_sects
operator|=
name|malloc
argument_list|(
name|num_dump_sects
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmdline_dump_sects
operator|==
name|NULL
condition|)
name|error
argument_list|(
name|_
argument_list|(
literal|"Out of memory allocating dump request table."
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|memcpy
argument_list|(
name|cmdline_dump_sects
argument_list|,
name|dump_sects
argument_list|,
name|num_dump_sects
argument_list|)
expr_stmt|;
name|num_cmdline_dump_sects
operator|=
name|num_dump_sects
expr_stmt|;
block|}
block|}
name|err
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|optind
operator|<
name|argc
condition|)
block|{
name|err
operator||=
name|process_file
argument_list|(
name|argv
index|[
name|optind
operator|++
index|]
argument_list|)
expr_stmt|;
comment|/* Reset dump requests.  */
if|if
condition|(
name|optind
operator|<
name|argc
operator|&&
name|dump_sects
operator|!=
name|NULL
condition|)
block|{
name|num_dump_sects
operator|=
name|num_cmdline_dump_sects
expr_stmt|;
if|if
condition|(
name|num_cmdline_dump_sects
operator|>
literal|0
condition|)
name|memcpy
argument_list|(
name|dump_sects
argument_list|,
name|cmdline_dump_sects
argument_list|,
name|num_cmdline_dump_sects
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|dump_sects
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|dump_sects
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmdline_dump_sects
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|cmdline_dump_sects
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

end_unit

